<!DOCTYPE html><html><head><title>Help for package prevR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prevR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.prevR'><p>Convert an object of class prevR into a data.frame.</p></a></li>
<li><a href='#as.prevR'><p>Create an object of class prevR.</p></a></li>
<li><a href='#changeproj,prevR-method'><p>Convert map projection of a object of class prevR.</p></a></li>
<li><a href='#create.boundary'><p>Provide national boundaries of a country.</p></a></li>
<li><a href='#direct.label_prevR'><p>Direct label on a ggplot object</p></a></li>
<li><a href='#export,prevR-method'><p>Export an object of class prevR.</p></a></li>
<li><a href='#fdhs'><p>Fictitious data generated by a DHS simulation.</p></a></li>
<li><a href='#import.dhs'><p>Import DHS data.</p></a></li>
<li><a href='#is.prevR'><p>Test if an object is of class prevR.</p>
This function test if the class of an object is prevR.
It could be used to test the slot <code>rings</code> or the slot <code>boundary</code>.</a></li>
<li><a href='#kde,prevR-method'><p>Kernel density estimation for prevR object.</p></a></li>
<li><a href='#krige,ANY,prevR-method'><p>Spatial interpolation (kriging and inverse distance weighting) for objects</p>
of class prevR.</a></li>
<li><a href='#make.grid.prevR'><p>Create a spatial grid from an object of class prevR.</p></a></li>
<li><a href='#Noptim'><p>Suggested optimal value for N</p></a></li>
<li><a href='#plot,prevR,missing-method'><p>Plot object of class prevR.</p></a></li>
<li><a href='#prevR-class'><p>Objects of class prevR.</p></a></li>
<li><a href='#prevR-package'><p>Estimating regional trends of a prevalence from a DHS.</p></a></li>
<li><a href='#prevR.colors'><p>Continuous color palettes.</p></a></li>
<li><a href='#print,prevR-method'><p>Summary of a prevR object.</p></a></li>
<li><a href='#quick.prevR'><p>Quick prevR analysis and plot</p></a></li>
<li><a href='#rings,prevR-method'><p>Calculation of rings of equal number of observation and/or equal radius.</p></a></li>
<li><a href='#show,prevR-method'><p>Summary of a prevR object.</p></a></li>
<li><a href='#st_filter_prevR'><p>Spatial filter</p></a></li>
<li><a href='#summary,prevR-method'><p>Detailed summary of the variables of a prevR object</p></a></li>
<li><a href='#theme_prevR'><p>prevR themes for ggplot2</p></a></li>
<li><a href='#TMWorldBorders'><p>Dataset &quot;TM World Borders Dataset 0.3&quot;.</p></a></li>
<li><a href='#update_prevR'><p>Update a prevR object</p></a></li>
<li><a href='#xyz2dataframe'><p>Convert a surface in xyz to a data frame.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Regional Trends of a Prevalence from a DHS and
Similar Surveys</td>
</tr>
<tr>
<td>Version:</td>
<td>5.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Larmarange &lt;joseph.larmarange@ird.fr&gt;</td>
</tr>
<tr>
<td>Acknowledgments:</td>
<td>funding from ANRS and IRD, and technical support from
LYSIS (info@lysis-consultants.fr)</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial estimation of a prevalence surface
    or a relative risks surface, using data from a Demographic and Health
    Survey (DHS) or an analog survey, see Larmarange et al. (2011)
    &lt;<a href="https://doi.org/10.4000%2Fcybergeo.24606">doi:10.4000/cybergeo.24606</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL version 2</a> | <a href="https://www.cecill.info/licences/Licence_CeCILL_V2.1-en.txt">CECILL-2.1</a> [expanded from: CeCILL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/larmarange/prevR/">https://github.com/larmarange/prevR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/larmarange/prevR/issues">https://github.com/larmarange/prevR/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>directlabels, ggplot2, gstat, KernSmooth, fields, foreign,
methods, sf, stars</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grDevices, knitr, rmarkdown, spelling, terra</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-15 14:11:50 UTC; josep</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Larmarange <a href="https://orcid.org/0000-0001-7097-700X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-15 18:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.prevR'>Convert an object of class prevR into a data.frame.</h2><span id='topic+as.data.frame.prevR'></span><span id='topic+as.data.frame'></span>

<h3>Description</h3>

<p>This function merges the slots <code>clusters</code> et <code>rings</code> of
a object of class <code><a href="#topic+prevR-class">prevR</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prevR'
as.data.frame(x, ..., N = NULL, R = NULL, clusters.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.prevR_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+prevR-class">prevR</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.prevR_+3A_...">...</code></td>
<td>
<p>not used, for compatibility with the generic method
<code><a href="base.html#topic+as.data.frame">base::as.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.prevR_+3A_n">N</code></td>
<td>
<p>integer or list of integers setting elements of
<code>rings</code> to extract.</p>
</td></tr>
<tr><td><code id="as.data.frame.prevR_+3A_r">R</code></td>
<td>
<p>integer or list of integers setting elements of
<code>rings</code> to extract.</p>
</td></tr>
<tr><td><code id="as.data.frame.prevR_+3A_clusters.only">clusters.only</code></td>
<td>
<p>return only the slot <code>clusters</code> of <code>x</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>clusters.only = TRUE</code>, the function will return only the
slot <code>clusters</code> of <code>x</code>.
</p>
<p>Otherwise, slots <code>clusters</code> and <code>rings</code> of <code>x</code> will be
merged in a unique data frame. The columns of <code>rings</code> will be renamed
adding a suffix like <em>.N300.RInf</em>.
</p>
<p><code>N</code> and <code>R</code> define the elements of <code>rings</code> to extract.
If not specified (<code>NULL</code>), all the elements of <code>rings</code> will
be included.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">base::as.data.frame()</a></code>, <code><a href="#topic+prevR-class">prevR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(fdhs)
str(as.data.frame(fdhs))
## Not run: 
r.fdhs &lt;- rings(fdhs, N = c(100, 200, 300))
str(r.fdhs)
str(as.data.frame(r.fdhs, clusters.only = TRUE))
str(as.data.frame(r.fdhs))
str(as.data.frame(r.fdhs, N = 300))

## End(Not run)

</code></pre>

<hr>
<h2 id='as.prevR'>Create an object of class prevR.</h2><span id='topic+as.prevR'></span>

<h3>Description</h3>

<p>This function creates an object of class <code><a href="#topic+prevR-class">prevR</a></code> from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.prevR(data, col, boundary = NULL, proj = "+proj=longlat +datum=WGS84")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.prevR_+3A_data">data</code></td>
<td>
<p>data frame, each line corresponding to an observed cluster.</p>
</td></tr>
<tr><td><code id="as.prevR_+3A_col">col</code></td>
<td>
<p>vector identifying the columns of <code>data</code> to use.<br />
<code>clusters</code> columns names are fixed:</p>

<ul>
<li><p> &quot;id&quot; (optional) cluster's identifier.
</p>
</li>
<li><p> &quot;x&quot; cluster's longitude.
</p>
</li>
<li><p> &quot;y&quot; cluster's latitude.
</p>
</li>
<li><p> &quot;n&quot; number of valid observations in the cluster.
</p>
</li>
<li><p> &quot;pos&quot; number of positive cases in the cluster.
</p>
</li>
<li><p> &quot;wn&quot; (optional) sum of observations weight.
</p>
</li>
<li><p> &quot;wpos&quot; (optional) sum of positive cases weight.
</p>
</li>
<li><p> &quot;c.type&quot; (optional) type of cluster (used only by <code><a href="#topic+plot">plot()</a></code>).
</p>
</li></ul>

<p>See examples.</p>
</td></tr>
<tr><td><code id="as.prevR_+3A_boundary">boundary</code></td>
<td>
<p>object of class <a href="sf.html#topic+sf">sf::sf</a> defining the studied area.</p>
</td></tr>
<tr><td><code id="as.prevR_+3A_proj">proj</code></td>
<td>
<p>projection of clusters coordinates used in <code>data</code>
(longitude and latitude in decimal degrees by default). One of
(i) character: a string accepted by GDAL, (ii) integer, a valid EPSG value
(numeric), or (iii) an object of class <code>crs</code>, see <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only &quot;x&quot;, &quot;y&quot; &quot;n&quot; and &quot;pos&quot; are required in <code>col</code>.
If &quot;id&quot; is not specified, a numerical identifier will be automatically
created.
</p>
<p>If <code>boundary</code> is not defined (<code>NULL</code>), a rectangle corresponding to minimal
and maximal coordinates of <code>data</code> will be used.
</p>
<p><code>boundary</code> could be the result of the function <code><a href="#topic+create.boundary">create.boundary()</a></code>.
</p>
<p>It's not possible to change projection of <code>data</code> with <code>as.prevR()</code>.
Use <code><a href="#topic+changeproj">changeproj()</a></code> instead.
</p>


<h3>Value</h3>

<p>Object of class <code><a href="#topic+prevR-class">prevR</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prevR-class">prevR</a></code> class, <code><a href="#topic+create.boundary">create.boundary()</a></code>,
<code><a href="#topic+changeproj">changeproj()</a></code>, <code><a href="#topic+import.dhs">import.dhs()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col &lt;- c(
  id = "cluster",
  x = "x",
  y = "y",
  n = "n",
  pos = "pos",
  c.type = "residence",
  wn = "weighted.n",
  wpos = "weighted.pos"
)
dhs &lt;- as.prevR(fdhs.clusters, col, fdhs.boundary)

str(dhs)
print(dhs)
</code></pre>

<hr>
<h2 id='changeproj+2CprevR-method'>Convert map projection of a object of class prevR.</h2><span id='topic+changeproj+2CprevR-method'></span><span id='topic+changeproj'></span><span id='topic+changeproj-methods'></span>

<h3>Description</h3>

<p>This function converts map projection (and/or datum) used by an object of
class <a href="#topic+prevR-class">prevR</a> into another one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prevR'
changeproj(object, proj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="changeproj+2B2CprevR-method_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="changeproj+2B2CprevR-method_+3A_proj">proj</code></td>
<td>
<p>new map projection. One of
(i) character: a string accepted by GDAL, (ii) integer, a valid EPSG value
(numeric), or (iii) an object of class <code>crs</code>, see <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>changeproj()</code> transform the columns  &quot;x&quot; and &quot;y&quot; of the slot
<code>clusters</code> of <code>object</code> and convert <code>boundary</code> using the new
map projection defined by <code>proj</code>.
</p>
<p>If applicable, the slot <code>rings</code> will be recalculated.
</p>


<h3>Value</h3>

<p>Return <code>object</code> expressed in the projection <code>proj</code>.
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_transform">sf::st_transform()</a></code>, <a href="#topic+prevR-class">prevR</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(fdhs)
plot(fdhs, axes = TRUE, main = "Projection: longitude/latitude")

fdhs2 &lt;- changeproj(
  fdhs,
  "+proj=utm +zone=30 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
)
print(fdhs2)
plot(fdhs2, axes = TRUE, main = "Projection: UTM Zone 30")

</code></pre>

<hr>
<h2 id='create.boundary'>Provide national boundaries of a country.</h2><span id='topic+create.boundary'></span>

<h3>Description</h3>

<p>This function uses the data set <a href="#topic+TMWorldBorders">TMWorldBorders</a>. One or several countries
can be selected and will be returned as an object of class
<a href="sp.html#topic+SpatialPolygons-class">sp::SpatialPolygons</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.boundary(
  countries = NULL,
  multiple = FALSE,
  proj = "+proj=longlat +datum=WGS84"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.boundary_+3A_countries">countries</code></td>
<td>
<p>a vector of character string corresponding to the name of
the countries you want to extract from the dataset. If <code>NULL</code>,
a dialogue box will be appear in order to select the desired country.</p>
</td></tr>
<tr><td><code id="create.boundary_+3A_multiple">multiple</code></td>
<td>
<p>should the dialog box allow multiple selection
(unused if <code>countries</code> is specified)?</p>
</td></tr>
<tr><td><code id="create.boundary_+3A_proj">proj</code></td>
<td>
<p>projection of clusters coordinates used in <code>data</code>
(longitude and latitude in decimal degrees by default). One of
(i) character: a string accepted by GDAL, (ii) integer, a valid EPSG value
(numeric), or (iii) an object of class <code>crs</code>, see <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <a href="sp.html#topic+SpatialPolygons-class">sp::SpatialPolygons</a>.
</p>


<h3>Note</h3>

<p>The result will be automatically plotted.
</p>


<h3>See Also</h3>

<p><a href="#topic+TMWorldBorders">TMWorldBorders</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
boundary &lt;- create.boundary()

## End(Not run)

boundary &lt;- create.boundary("Burkina Faso")
boundary &lt;- create.boundary("Burkina Faso",
  proj = "+proj=utm +zone=30 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
)
boundary &lt;- create.boundary(countries = c("Burkina Faso", "Ghana", "Benin"))


</code></pre>

<hr>
<h2 id='direct.label_prevR'>Direct label on a ggplot object</h2><span id='topic+direct.label_prevR'></span>

<h3>Description</h3>

<p>Direct label a ggplot2 grouped plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct.label_prevR(p, method = NULL, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct.label_prevR_+3A_p">p</code></td>
<td>
<p>The ggplot object.</p>
</td></tr>
<tr><td><code id="direct.label_prevR_+3A_method">method</code></td>
<td>
<p>Method for direct labeling
(see <code><a href="directlabels.html#topic+direct.label">directlabels::direct.label()</a></code>).</p>
</td></tr>
<tr><td><code id="direct.label_prevR_+3A_debug">debug</code></td>
<td>
<p>Show debug output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ggplot object with direct labels added.
</p>


<h3>Note</h3>

<p>This function is based on and similar to
<code><a href="directlabels.html#topic+direct.label">directlabels::direct.label()</a></code>
except that legend is not hidden.
</p>


<h3>See Also</h3>

<p><code><a href="directlabels.html#topic+direct.label">directlabels::direct.label()</a></code>
</p>

<hr>
<h2 id='export+2CprevR-method'>Export an object of class prevR.</h2><span id='topic+export+2CprevR-method'></span><span id='topic+export-methods'></span><span id='topic+export'></span>

<h3>Description</h3>

<p>This method could be used to export an object of class <a href="#topic+prevR-class">prevR</a>
in different formats (text, shapefile, dbase...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prevR'
export(
  object,
  element,
  format,
  file,
  N = NULL,
  R = NULL,
  clusters.only = FALSE,
  ext = NULL,
  sep = NULL,
  dec = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export+2B2CprevR-method_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_element">element</code></td>
<td>
<p>element to export: &quot;clusters&quot; or &quot;boundary&quot;.</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_format">format</code></td>
<td>
<p>format: &quot;dbf&quot;, &quot;txt&quot;, csv&quot;, &quot;csv2&quot; or &quot;shp&quot;
(unused if <code>element = "boundary"</code>).</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_file">file</code></td>
<td>
<p>file name <strong>without</strong> extension.</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_n">N</code></td>
<td>
<p>integer or list of integers setting elements of <code>rings</code>
to export (unused if <code>element="boundary"</code>).</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_r">R</code></td>
<td>
<p>integer or list of integers setting elements of <code>rings</code>
to export (unused if <code>element="boundary"</code>).</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_clusters.only">clusters.only</code></td>
<td>
<p>export only the slot <code>clusters</code> of <code>object</code>
(unused if <code>element="boundary"</code>)?</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_ext">ext</code></td>
<td>
<p>coerce the extension of the export file
(unused if <code>element="boundary"</code> or if <code>format="shp"</code>).</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_sep">sep</code></td>
<td>
<p>coerce the field separator string
(unused if <code>element="boundary"</code>
or if <code>format="shp"</code> or if <code>format="dbf"</code>).</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_dec">dec</code></td>
<td>
<p>coerce the string to use for decimal point
(unused if <code>element="boundary"</code> or if <code>format="shp"</code>
or if <code>format="dbf"</code>).</p>
</td></tr>
<tr><td><code id="export+2B2CprevR-method_+3A_...">...</code></td>
<td>
<p>additional arguments transmitted to
<a href="sf.html#topic+st_write">sf::st_write</a>, <code><a href="foreign.html#topic+write.dbf">foreign::write.dbf()</a></code> or
<code><a href="utils.html#topic+write.table">utils::write.table()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>element="boundary"</code>, the slot <code>boundary</code> of
<code>object</code> will be exported as a <em>shapefile</em>.
</p>
<p>Otherwise, the slot <code>clusters</code>, merged with the slot <code>rings</code>,
will be exported.
</p>
<p>See <code><a href="#topic+as.data.frame">as.data.frame()</a></code> for details on the use of the parameters of <code>N</code>,
<code>R</code> et <code>clusters.only</code>.
</p>
<p><code>format</code> specifies the export format of the data frame returned by
<code><a href="#topic+as.data.frame">as.data.frame()</a></code>: </p>

<table>
<tr>
 <td style="text-align: left;">
"shp" </td><td style="text-align: left;"> Shape File</td>
</tr>
<tr>
 <td style="text-align: left;">
"dbf" </td><td style="text-align: left;"> DBASE format</td>
</tr>
<tr>
 <td style="text-align: left;">
"txt" </td><td style="text-align: left;"> tabulated text</td>
</tr>
<tr>
 <td style="text-align: left;">
"csv" </td><td style="text-align: left;"> 'comma separated values'</td>
</tr>
<tr>
 <td style="text-align: left;">
"csv2" </td><td style="text-align: left;"> CSV variant using a semicolon as field separator
</td>
</tr>

</table>

<p><code>ext</code> could be used to coerce the extension of the output file,
except for <em>shapefile</em> export, which will write four different files
(.shp, .shx, .dbf and .prj).
</p>
<p>The &quot;txt&quot; format uses by default a tabulation as field separator and
a point &quot;.&quot; for decimal point.
</p>
<p>The &quot;csv&quot; format uses a comma &quot;,&quot; as field separator and
a point &quot;.&quot; as decimal point.
</p>
<p>The &quot;csv2&quot; format is a variant using a semicolon &quot;;&quot; as field separator and
a colon &quot;,&quot; for decimal point,
the Excel convention for CSV files in some Western European locales.
</p>
<p><code>sep</code> and <code>dec</code> could be used to coerce the field separator and
the decimal point (together with the &quot;txt&quot; format).
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_write">sf::st_write()</a></code>,
<code><a href="foreign.html#topic+write.dbf">foreign::write.dbf()</a></code>, <code><a href="utils.html#topic+write.table">utils::write.table()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
export(fdhs, element = "boundary", file = "area")
export(fdhs, element = "clusters", format = "shp", file = "points")

dhs &lt;- rings(fdhs, N = c(100, 300, 500))
export(dhs, element = "clusters", format = "csv", N = 300, file = "points")

## End(Not run)

</code></pre>

<hr>
<h2 id='fdhs'>Fictitious data generated by a DHS simulation.</h2><span id='topic+fdhs'></span><span id='topic+fdhs.boundary'></span><span id='topic+fdhs.clusters'></span>

<h3>Description</h3>

<p>Data set generated by a Demographic and Health Survey (DHS) simulation on a
fictitious country with a national prevalence of 10\
surveyed, distributed in 401 clusters.
This dataset is composed of 3 objects:</p>

<ul>
<li> <p><code>fdhs.clusters</code>: data frame (one line per cluster).
</p>
</li>
<li> <p><code>fdhs.boundary</code>: object of class
<a href="sp.html#topic+SpatialPolygons-class">sp::SpatialPolygons</a> corresponding to the borders of the
fictitious country.
</p>
</li>
<li> <p><code>fdhs</code>: object of class <a href="#topic+prevR-class">prevR</a>
returned by <code><a href="#topic+as.prevR">as.prevR()</a></code> using the two previous objects.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
str(fdhs)
str(fdhs.clusters)
str(fdhs.boundary)
demo(prevR)

## End(Not run)
</code></pre>

<hr>
<h2 id='import.dhs'>Import DHS data.</h2><span id='topic+import.dhs'></span>

<h3>Description</h3>

<p>This step by step function guides users to import data from a Demographic
and Health Survey (DHS)
and create an object of class <a href="#topic+prevR-class">prevR</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.dhs(file.sav, file.dbf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.dhs_+3A_file.sav">file.sav</code></td>
<td>
<p>DHS data (one individual per line) in SPSS format (.sav),
downloaded from <a href="https://www.dhsprogram.com/">https://www.dhsprogram.com/</a>. Could also be directly a
data.frame.</p>
</td></tr>
<tr><td><code id="import.dhs_+3A_file.dbf">file.dbf</code></td>
<td>
<p>GPS position of clusters in DATABASE format (.dbf),
downloaded from <a href="https://www.dhsprogram.com/">https://www.dhsprogram.com/</a>.
Could also be directly a data.frame.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If you don't provide the precise path of files, <span class="rlang"><b>R</b></span> will check the
working directory (see <code><a href="base.html#topic+getwd">base::setwd()</a></code>).
To specify the file path, see <code><a href="base.html#topic+file.path">base::file.path()</a></code>.
</p>
<p>This function was developed specifically for importing DHS.
For a generic function for creating an object of class <a href="#topic+prevR-class">prevR</a>,
see <code><a href="#topic+as.prevR">as.prevR()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.prevR">as.prevR()</a></code>, <a href="#topic+prevR-class">prevR</a> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
imported_data &lt;- import.dhs("data.sav", "gps.dbf")

## End(Not run)

</code></pre>

<hr>
<h2 id='is.prevR'>Test if an object is of class prevR.
This function test if the class of an object is <a href="#topic+prevR-class">prevR</a>.
It could be used to test the slot <code>rings</code> or the slot <code>boundary</code>.</h2><span id='topic+is.prevR'></span>

<h3>Description</h3>

<p>Test if an object is of class prevR.
This function test if the class of an object is <a href="#topic+prevR-class">prevR</a>.
It could be used to test the slot <code>rings</code> or the slot <code>boundary</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.prevR(object, slot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.prevR_+3A_object">object</code></td>
<td>
<p>object to test.</p>
</td></tr>
<tr><td><code id="is.prevR_+3A_slot">slot</code></td>
<td>
<p>&quot;clusters&quot;, &quot;rings&quot;,&quot;boundary&quot; or &quot;proj&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Slots <code>rings</code> and <code>boundary</code> are always present in an object of
class <a href="#topic+prevR-class">prevR</a>, but <code>rings</code> could be <code>NULL</code> and
<code>boundary</code> a <a href="sf.html#topic+sf">sf::sf</a> object with an attribute named <code>valid</code>
with the value <code>FALSE</code> (when boundaries of the studied
area have not been specified explicitly).
</p>

<ul>
<li><p> If <code>rings</code> is <code>NULL</code>, <code>is.prevR(object,"rings")</code> will return <code>FALSE</code>.
</p>
</li>
<li><p> If <code>boundary</code> has an attribute <code>valid</code> equal to <code>FALSE</code>,
<code>is.prevR(object,"boundary")</code> will return <code>FALSE</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+prevR-class">prevR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col &lt;- c(
  id = "cluster",
  x = "x",
  y = "y",
  n = "n",
  pos = "pos",
  c.type = "residence",
  wn = "weighted.n",
  wpos = "weighted.pos"
)
dhs &lt;- as.prevR(fdhs.clusters, col, fdhs.boundary)

is.prevR(dhs)
is.prevR(dhs, "rings")
is.prevR(dhs, "boundary")

dhs &lt;- rings(dhs, N = 300)
is.prevR(dhs, "rings")

</code></pre>

<hr>
<h2 id='kde+2CprevR-method'>Kernel density estimation for prevR object.</h2><span id='topic+kde+2CprevR-method'></span><span id='topic+kde-methods'></span><span id='topic+kde'></span>

<h3>Description</h3>

<p>This function allows to calculate a prevalence surface (ratio of two
intensity surfaces) and/or a relative risks surface (ratio of two density
surfaces) using gaussian kernel estimators with adaptative bandwidths of
equal number of observations or equal radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prevR'
kde(
  object,
  N = NULL,
  R = NULL,
  weighted = TRUE,
  risk.ratio = FALSE,
  keep.details = FALSE,
  nb.cells = 100,
  cell.size = NULL,
  progression = TRUE,
  short.names = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kde+2B2CprevR-method_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_n">N</code></td>
<td>
<p>integer or list of integers corresponding to the rings to use.</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_r">R</code></td>
<td>
<p>integer or list of integers corresponding to the rings to use.</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_weighted">weighted</code></td>
<td>
<p>use weighted data (<code>TRUE</code>, <code>FALSE</code> or <code>2</code>)?</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_risk.ratio">risk.ratio</code></td>
<td>
<p>calculate a relative risks surface instead of a
prevalence surface (<code>TRUE</code>, <code>FALSE</code> or <code>2</code>)?</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_keep.details">keep.details</code></td>
<td>
<p>return surface of positive cases and surface of
observed cases?</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_nb.cells">nb.cells</code></td>
<td>
<p>number of cells on the longest side of the studied area
(unused if <code>cell.size</code> is defined).</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_cell.size">cell.size</code></td>
<td>
<p>size of each cell (in the unit of the projection).</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_progression">progression</code></td>
<td>
<p>show a progress bar?</p>
</td></tr>
<tr><td><code id="kde+2B2CprevR-method_+3A_short.names">short.names</code></td>
<td>
<p>should names of the output be short?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates a prevalence surface as the ratio of the
intensity surface (expressed in cases per surface unit) of positive cases
on the intensity surface of observed cases and could also calculate a
relative risks surface corresponding to the ratio of the density surface
(whose integral has been normalized to one) of positive cases on density
surface of observed cases.
</p>
<p>This method is a variant of the nearest neighbor technique. Surfaces are
estimated using gaussian kernel estimators with adaptative bandwidths,
bandwidth size being determined by a minimum number of
observations in the neighborhood (see <code><a href="#topic+rings">rings()</a></code> for more details).
Fixed bandwidths could also be used. More precisely, the bandwidth used is
half the radius of rings of equal number of observations or equal radius
(parameters <code>N</code> and <code>R</code>) calculated by the' function <code><a href="#topic+rings">rings()</a></code>.
</p>
<p>See references for a detailed explanation of the implemented methodology.
</p>
<p><code>N</code> and <code>R</code> determine the rings to use for the estimation. If they are not
defined, surfaces will be estimated for each available couples (N,R)
available in <code>object</code>. Several estimations could be
simultaneously calculated if several values of N and R are defined.
</p>
<p>A suggested value of N could be computed with <code><a href="#topic+Noptim">Noptim()</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <a href="sf.html#topic+sf">sf::sf</a>.
Surfaces are named according to the name of the corresponding N and R
(for example: <em>k.prev.N300.RInf</em>). If <code>short.names</code> is <code>TRUE</code> and
if there is only one combination of couples (N, R), variable names will not
be suffixed by the value of N and R.
</p>
<p>Estimated variables are (depending on the function parameters) :</p>

<ul>
<li><p> &quot;k.pos&quot; unweighted intensity surface of positive cases.
</p>
</li>
<li><p> &quot;k.obs&quot; unweighted intensity surface of observed cases.
</p>
</li>
<li><p> &quot;k.prev&quot; unweighted surface of prevalence (k.pos/k.obs).
</p>
</li>
<li><p> &quot;k.case&quot; unweighted density surface of positive cases.
</p>
</li>
<li><p> &quot;k.control&quot; unweighted density surface of observed cases.
</p>
</li>
<li><p> &quot;k.rr&quot; unweighted surface of relative risks (k.case/k.control).
</p>
</li>
<li><p> &quot;k.wpos&quot; weighted intensity surface of positive cases.
</p>
</li>
<li><p> &quot;k.wobs&quot; weighted intensity surface of observed cases.
</p>
</li>
<li><p> &quot;k.wprev&quot; weighted surface of prevalence (k.wpos/k.wobs).
</p>
</li>
<li><p> &quot;k.wcase&quot; weighted density surface of positive cases.
</p>
</li>
<li><p> &quot;k.wcontrol&quot; weighted density surface of observed cases.
</p>
</li>
<li><p> &quot;k.wrr&quot; weighted surface of relative risks (k.wcase/k.wcontrol).
</p>
</li></ul>



<h3>Note</h3>

<p>Results could be plotted with <code><a href="sf.html#topic+plot">sf::plot()</a></code> or with <span class="pkg">ggplot2</span>
using <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>. See examples.
</p>
<p><span class="pkg">prevR</span> provides several continuous color palettes
(see <a href="#topic+prevR.colors">prevR.colors</a>).
</p>
<p>Results could be turned into a <span class="pkg">stars</span> raster using
<code><a href="stars.html#topic+st_rasterize">stars::st_rasterize()</a></code>.
</p>
<p>To export to ASCII grid, rasterize the results with <code><a href="stars.html#topic+st_rasterize">stars::st_rasterize()</a></code>,
convert to <code>SpatRast</code> with <code><a href="terra.html#topic+rast">terra::rast()</a></code>, extract the desired layer with
<code style="white-space: pre;">&#8288;[[]]&#8288;</code> and then use <code>terra::writeRaster()</code>. See examples.
</p>
<p>See the package <span class="pkg">sparr</span> for another methodology to estimate relative
risks surfaces, adapted for other kind of data than Demographic and
Health Surveys (DHS).
</p>


<h3>References</h3>

<p>Larmarange Joseph, Vallo Roselyne, Yaro Seydou, Msellati Philippe
and Meda Nicolas (2011) &quot;Methods for mapping regional trends of HIV
prevalence from Demographic and Health Surveys (DHS)&quot;,
<em>Cybergeo: European Journal of Geography</em>, no 558,
<a href="https://journals.openedition.org/cybergeo/24606">https://journals.openedition.org/cybergeo/24606</a>,
DOI: 10.4000/cybergeo.24606.
</p>


<h3>See Also</h3>

<p><code><a href="KernSmooth.html#topic+bkde2D">KernSmooth::bkde2D()</a></code>, <code><a href="#topic+rings">rings()</a></code>, <code><a href="#topic+Noptim">Noptim()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dhs &lt;- rings(fdhs, N = c(100, 200, 300, 400, 500))

prev.N300 &lt;- kde(dhs, N = 300, nb.cells = 200)

plot(prev.N300, lty = 0)

library(ggplot2)
ggplot(prev.N300) +
  aes(fill = k.wprev.N300.RInf) +
  geom_sf(colour = "transparent") +
  scale_fill_gradientn(colors = prevR.colors.red()) +
  theme_prevR_light()

# Export k.wprev.N300.RInf surface in ASCII Grid
r &lt;- terra::rast(stars::st_rasterize(prev.N300))
# writeRaster(r[[2]], "kprev.N300.asc")

## End(Not run)

</code></pre>

<hr>
<h2 id='krige+2CANY+2CprevR-method'>Spatial interpolation (kriging and inverse distance weighting) for objects
of class prevR.</h2><span id='topic+krige+2CANY+2CprevR-method'></span><span id='topic+krige+2CprevR-method'></span><span id='topic+krige-methods'></span><span id='topic+krige'></span><span id='topic+idw+2CANY+2CprevR-method'></span><span id='topic+idw-methods'></span><span id='topic+idw+2CprevR-method'></span><span id='topic+idw'></span>

<h3>Description</h3>

<p>These functions execute a spatial interpolation of a variable of the slot
<code>rings</code> of an object of class <a href="#topic+prevR-class">prevR</a>. The method <code>krige()</code>
implements the ordinary kriging technique. The method <code>idw()</code> executes
an inverse distance weighting interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,prevR'
krige(
  formula,
  locations,
  N = NULL,
  R = Inf,
  model = NULL,
  nb.cells = 100,
  cell.size = NULL,
  fit = "auto",
  keep.variance = FALSE,
  show.variogram = FALSE,
  ...
)

## S4 method for signature 'ANY,prevR'
idw(
  formula,
  locations,
  N = NULL,
  R = Inf,
  nb.cells = 100,
  cell.size = NULL,
  idp = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_formula">formula</code></td>
<td>
<p>variable(s) to interpolate (see details).</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_locations">locations</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_n">N</code></td>
<td>
<p>integer or list of integers corresponding to the rings to use.</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_r">R</code></td>
<td>
<p>integer or list of integers corresponding to the rings to use.</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_model">model</code></td>
<td>
<p>a variogram model returned by the function <code><a href="gstat.html#topic+vgm">gstat::vgm()</a></code>.</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_nb.cells">nb.cells</code></td>
<td>
<p>number of cells on the longest side of the studied area
(unused if <code>cell.size</code> is defined).</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_cell.size">cell.size</code></td>
<td>
<p>size of each cell (in the unit of the projection).</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_fit">fit</code></td>
<td>
<p><code>"auto"</code> for using a variogram automatically fitted from the data,
only if <code>model</code> is not defined (<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_keep.variance">keep.variance</code></td>
<td>
<p>return variance of estimates?</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_show.variogram">show.variogram</code></td>
<td>
<p>plot the variogram?</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_...">...</code></td>
<td>
<p>additional arguments transmitted to <code><a href="gstat.html#topic+krige">gstat::krige()</a></code>
or <code><a href="gstat.html#topic+krige">gstat::idw()</a></code>.</p>
</td></tr>
<tr><td><code id="krige+2B2CANY+2B2CprevR-method_+3A_idp">idp</code></td>
<td>
<p>inverse distance weighting power (see <code><a href="gstat.html#topic+krige">gstat::idw()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>formula</code> specifies the variable(s) to interpolate. Only variables
available in the slot <code>rings</code> of <code>locations</code> could be used. Possible values
are <code>"r.pos"</code>, <code>"r.n"</code>, <code>"r.prev"</code>, <code>"r.radius"</code>, <code>"r.clusters"</code>, <code>"r.wpos"</code>,
<code>"r.wn"</code> or <code>"r.wprev"</code>. Variables could be specified with a character
string or a formula (example: <code style="white-space: pre;">&#8288;list(r.pos ~ 1, r.prev ~ 1}&#8288;</code>. Only formula
like <code>variable.name ~ 1</code> are accepted. For more complex interpolations,
use directly functions <code><a href="gstat.html#topic+krige">gstat::krige()</a></code> and <code><a href="gstat.html#topic+krige">gstat::idw()</a></code> from <span class="pkg">gstat</span>.
</p>
<p><code>N</code> and <code>R</code> determine the rings to use for the interpolation. If they are
not defined, surfaces will be estimated for each available couples (N,R).
Several interpolations could be simultaneously calculated if several
variables and/or several values of N and R are defined.
</p>
<p>A suggested value of N could be computed with <code><a href="#topic+Noptim">Noptim()</a></code>.
</p>
<p>In the case of an ordinary kriging, the method <code><a href="#topic+krige">krige()</a></code> from <span class="pkg">prevR</span>
will try to fit automatically a exponential variogram to the sample variogram
(<code>fit = "auto"</code>). You can also specify directly the variogram to use with
the parameter <code>model</code>.
</p>
<p>Interpolations are calculated on a spatial grid obtained with
<code><a href="#topic+make.grid.prevR">make.grid.prevR()</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <a href="sf.html#topic+sf">sf::sf</a>.
The name of estimated surfaces depends on the name of the interpolated
variable, N and R (for example: <em>r.radius.N300.RInf</em>).
If you ask the function to return variance (<code>keep.variance=TRUE</code>),
corresponding surfaces names will have the suffix <em>.var</em>.
</p>


<h3>Note</h3>

<p>Results could be plotted with <code><a href="sf.html#topic+plot">sf::plot()</a></code> or with <span class="pkg">ggplot2</span>
using <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>. See examples.
</p>
<p><span class="pkg">prevR</span> provides several continuous color palettes
(see <a href="#topic+prevR.colors">prevR.colors</a>).
</p>
<p>Results could be turned into a <span class="pkg">stars</span> raster using
<code><a href="stars.html#topic+st_rasterize">stars::st_rasterize()</a></code>.
</p>
<p>To export to ASCII grid, rasterize the results with <code><a href="stars.html#topic+st_rasterize">stars::st_rasterize()</a></code>,
convert to <code>SpatRast</code> with <code><a href="terra.html#topic+rast">terra::rast()</a></code>, extract the desired layer with
<code style="white-space: pre;">&#8288;[[]]&#8288;</code> and then use <code>terra::writeRaster()</code>. See examples.
</p>


<h3>References</h3>

<p>Larmarange Joseph, Vallo Roselyne, Yaro Seydou, Msellati Philippe and Meda
Nicolas (2011) &quot;Methods for mapping regional trends of HIV prevalence from
Demographic and Health Surveys (DHS)&quot;,
<em>Cybergeo: European Journal of Geography</em>, no 558,
<a href="https://journals.openedition.org/cybergeo/24606">https://journals.openedition.org/cybergeo/24606</a>,
DOI: 10.4000/cybergeo.24606.
</p>


<h3>See Also</h3>

<p><code><a href="gstat.html#topic+krige">gstat::krige()</a></code>, <code><a href="gstat.html#topic+krige">gstat::idw()</a></code>, <code><a href="#topic+rings">rings()</a></code>, <code><a href="#topic+Noptim">Noptim()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    dhs &lt;- rings(fdhs, N = c(100,200,300,400,500))
    radius.N300 &lt;- krige('r.radius', dhs, N = 300, nb.cells = 50)
    prev.krige &lt;- krige(r.wprev ~ 1, dhs, N = c(100, 300, 500))

    plot(prev.krige, lty = 0)

    library(ggplot2)
    ggplot(prev.krige) +
      aes(fill = r.wprev.N300.RInf) +
      geom_sf(colour = "transparent") +
      scale_fill_gradientn(colors = prevR.colors.red()) +
      theme_prevR_light()

    # Export r.wprev.N300.RInf surface in ASCII Grid
    r &lt;- terra::rast(stars::st_rasterize(prev.krige))
    # writeRaster(r[[2]], "wprev.N300.asc")
  
## End(Not run)

</code></pre>

<hr>
<h2 id='make.grid.prevR'>Create a spatial grid from an object of class prevR.</h2><span id='topic+make.grid.prevR'></span>

<h3>Description</h3>

<p>This function generates a spatial rectangular grid from the slot
<code>boundary</code> of an object of class <code><a href="#topic+prevR-class">prevR</a></code>; function used in
particular by the methods <code><a href="#topic+kde">kde()</a></code>, <code><a href="#topic+krige">krige()</a></code> and <code><a href="#topic+idw">idw()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.grid.prevR(object, nb.cells = 100, cell.size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.grid.prevR_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="make.grid.prevR_+3A_nb.cells">nb.cells</code></td>
<td>
<p>number of cells on the longest side of the studied area
(unused if <code>cell.size</code> is defined).</p>
</td></tr>
<tr><td><code id="make.grid.prevR_+3A_cell.size">cell.size</code></td>
<td>
<p>size of each cell (in the unit of the projection).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a spatial rectangular grid, each cell
corresponding to the center of a square of side <code>cell.size</code>.
If <code>cell.size</code> is not defined, side of cells will be
calculated as the longest side of the slot <code>boundary</code> of <code>object</code>
divided by <code>nb.cells</code>.
</p>


<h3>Value</h3>

<p>Object of class <a href="sf.html#topic+sfc">sf::sfc</a> (simple feature geometry list column).
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_make_grid">sf::st_make_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.grid.prevR(fdhs)
make.grid.prevR(fdhs, nb.cells = 200)
</code></pre>

<hr>
<h2 id='Noptim'>Suggested optimal value for N</h2><span id='topic+Noptim'></span>

<h3>Description</h3>

<p>Based on previous simulation work, the function suggests an optimal
value for the N parameter based on national prevalence, the total number
of observations and the number of clusters. See Larmarange et al. 2011
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Noptim(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Noptim_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer.
</p>


<h3>References</h3>

<p>Larmarange Joseph, Vallo Roselyne, Yaro Seydou, Msellati Philippe and Meda
Nicolas (2011) &quot;Methods for mapping regional trends of HIV prevalence from
Demographic and Health Surveys (DHS)&quot;,
<em>Cybergeo: European Journal of Geography</em>, no 558,
<a href="https://journals.openedition.org/cybergeo/24606">https://journals.openedition.org/cybergeo/24606</a>,
DOI: 10.4000/cybergeo.24606.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Noptim(fdhs)

</code></pre>

<hr>
<h2 id='plot+2CprevR+2Cmissing-method'>Plot object of class prevR.</h2><span id='topic+plot+2CprevR+2Cmissing-method'></span><span id='topic+plot'></span><span id='topic+plot-methods'></span><span id='topic+plot+2CprevR-method'></span>

<h3>Description</h3>

<p>Method <code>plot</code> for object of class <a href="#topic+prevR-class">prevR</a>.
Plot clusters, number of observations per cluster or number of positive cases
per cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prevR,missing'
plot(
  x,
  type = "position",
  add.legend = TRUE,
  legend.location = "bottomright",
  factor.size = 0.2,
  new.window = FALSE,
  axes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CprevR+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="plot+2B2CprevR+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>graph to plot:</p>

<ul>
<li><p> &quot;position&quot; clusters position.
</p>
</li>
<li><p> &quot;c.type&quot; clusters per <code>c.type</code>.
</p>
</li>
<li><p> &quot;count&quot; number of observations per cluster.
</p>
</li>
<li><p> &quot;flower&quot; number of positive cases per cluster.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot+2B2CprevR+2B2Cmissing-method_+3A_add.legend">add.legend</code></td>
<td>
<p>add a legend?</p>
</td></tr>
<tr><td><code id="plot+2B2CprevR+2B2Cmissing-method_+3A_legend.location">legend.location</code></td>
<td>
<p>legend location.</p>
</td></tr>
<tr><td><code id="plot+2B2CprevR+2B2Cmissing-method_+3A_factor.size">factor.size</code></td>
<td>
<p>scale factor of rings (for <code>type="count"</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2CprevR+2B2Cmissing-method_+3A_new.window">new.window</code></td>
<td>
<p>plot in a new window?</p>
</td></tr>
<tr><td><code id="plot+2B2CprevR+2B2Cmissing-method_+3A_axes">axes</code></td>
<td>
<p>show axes?</p>
</td></tr>
<tr><td><code id="plot+2B2CprevR+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>additional arguments transmitted to <code><a href="graphics.html#topic+title">graphics::title()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available values for <code>legend.location</code> are: <em>&quot;bottomright&quot;</em>,
<em>&quot;bottom&quot;</em>, <em>&quot;bottomleft&quot;</em>, <em>&quot;left&quot;</em>, <em>&quot;topleft&quot;</em>,
<em>&quot;top&quot;</em>, <em>&quot;topright&quot;</em>, <em>&quot;right&quot;</em> use <em>&quot;center&quot;</em>.
</p>
<p>Use <code>main</code> to define a title and <code>sub</code> for a subtitle
(see <code><a href="graphics.html#topic+title">graphics::title()</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+title">graphics::title()</a></code>, <code><a href="graphics.html#topic+legend">graphics::legend()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(fdhs, type = "position", main = "position", axes = TRUE)
plot(fdhs, type = "c.type", main = "c.type")
plot(fdhs, type = "count", main = "count", factor.size = 0.1)
plot(fdhs, type = "flower", main = "flower")


</code></pre>

<hr>
<h2 id='prevR-class'>Objects of class prevR.</h2><span id='topic+prevR-class'></span>

<h3>Description</h3>

<p>Class used by the package <span class="pkg">prevR</span>
</p>


<h3>Slots</h3>


<dl>
<dt><code>clusters</code></dt><dd><p><code>data.frame</code> with observed data (one line per cluster).
Columns names are:</p>

<ul>
<li><p> &quot;id&quot; cluster ID.
</p>
</li>
<li><p> &quot;x&quot; longitude.
</p>
</li>
<li><p> &quot;y&quot; latitude.
</p>
</li>
<li><p> &quot;n&quot; number of valid observations per cluster.
</p>
</li>
<li><p> &quot;pos&quot; number of positive cases per cluster.
</p>
</li>
<li><p> &quot;prev&quot; observed prevalence (in %) in the cluster (pos/n).
</p>
</li>
<li><p> &quot;wn&quot; (optional) sum of weights of observations per cluster.
</p>
</li>
<li><p> &quot;wpos&quot; (optional) sum of weights of positive cases per cluster.
</p>
</li>
<li><p> &quot;wprev&quot; (optional) weighted observed prevalence (in %)
in the cluster (wpos/wn).
</p>
</li>
<li><p> &quot;c.type&quot; (optional) cluster type.
</p>
</li></ul>
</dd>
<dt><code>boundary</code></dt><dd><p>object of class <a href="sf.html#topic+sf">sf::sf</a>,
borders of the studied area.</p>
</dd>
<dt><code>proj</code></dt><dd><p>object of class <a href="sf.html#topic+st_crs">sf::crs</a>, map projection used.</p>
</dd>
<dt><code>rings</code></dt><dd><p>list of results returned by <code><a href="#topic+rings">rings()</a></code>.
Each entry is composed of 3 elements: <code>N</code>, minimum number of
observations per ring; <code>R</code>, maximum radius of rings and
<code>estimates</code>, a data frame with the following
variables:</p>

<ul>
<li><p> &quot;id&quot; cluster ID.
</p>
</li>
<li><p> &quot;r.pos&quot; number of positive cases inside the ring.
</p>
</li>
<li><p> &quot;r.n&quot; number of valid observations inside the ring.
</p>
</li>
<li><p> &quot;r.prev&quot; observed prevalence (in \
</p>
</li>
<li><p> &quot;r.radius&quot; ring radius (in kilometers if coordinates in
decimal degrees, in the unit of the projection otherwise).
</p>
</li>
<li><p> &quot;r.clusters&quot; number of clusters located inside the ring.
</p>
</li>
<li><p> &quot;r.wpos&quot; (optional) sum of weights of positive cases inside the ring.
</p>
</li>
<li><p> &quot;r.wn&quot; (optional) sum of weights of valid observations inside the
ring.
</p>
</li>
<li><p> &quot;r.wprev&quot; (optional) weighted observed prevalence (in %) inside
the ring (r.wpos/r.wn).
</p>
</li></ul>

<p>Note: the list <code>rings</code> is named, the name of each element is
N<em>N_value</em>.R<em>R_value</em>, for example <em>N300.RInf</em>.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects of this class could be created by the function <code><a href="#topic+as.prevR">as.prevR()</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.frame</dt><dd><p><code>signature(x = "prevR")</code> converts an object of
class prevR into a data frame.</p>
</dd>
<dt>as.SpatialGrid</dt><dd><p><code>signature(object = "prevR")</code> generates a
spatial grid.</p>
</dd>
<dt>export</dt><dd><p><code>signature(object = "prevR")</code> exports a prevR object as
a shapefile, a dbase file or a text file.</p>
</dd>
<dt>idw</dt><dd><p><code>signature(formula = "ANY", locations = "prevR")</code>
calculates a spatial interpolation using an inverse distance weighting.</p>
</dd>
<dt>kde</dt><dd><p><code>signature(object = "prevR")</code> estimates a prevalence
surface using kernel density estimators.</p>
</dd>
<dt>krige</dt><dd><p><code>signature(formula = "ANY", locations = "prevR")</code>
calculates a spatial interpolation by kriging.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "prevR", y = "ANY")</code> plots data of a
prevR object.</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "prevR")</code> shows a summary of a prevR
object.</p>
</dd>
<dt>rings</dt><dd><p><code>signature(object = "prevR")</code> calculates rings of equal
number of observations and/or equal radius.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "prevR")</code> shows a summary of a prevR
object.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "prevR")</code> shows a summary of the
variables of a prevR object.</p>
</dd>
<dt>changeproj</dt><dd><p><code>signature(object = "prevR")</code> changes the map
projection used.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+as.prevR">as.prevR()</a></code>, <code><a href="#topic+is.prevR">is.prevR()</a></code>, <code><a href="#topic+changeproj">changeproj()</a></code>, <code><a href="#topic+rings">rings()</a></code>, <code><a href="#topic+print">print()</a></code>, <code><a href="#topic+plot">plot()</a></code>,
<code><a href="#topic+summary">summary()</a></code>, <code><a href="#topic+kde">kde()</a></code>, <code><a href="#topic+krige">krige()</a></code>, <code><a href="#topic+idw">idw()</a></code>, <code><a href="#topic+export">export()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("prevR")

col &lt;- c(
  id = "cluster",
  x = "x",
  y = "y",
  n = "n",
  pos = "pos",
  c.type = "residence",
  wn = "weighted.n",
  wpos = "weighted.pos"
)
dhs &lt;- as.prevR(fdhs.clusters, col, fdhs.boundary)
str(dhs)
print(dhs)

## Not run: 
dhs &lt;- rings(fdhs, N = c(100, 300, 500))
str(dhs)
print(dhs)

## End(Not run)
</code></pre>

<hr>
<h2 id='prevR-package'>Estimating regional trends of a prevalence from a DHS.</h2><span id='topic+prevR-package'></span>

<h3>Description</h3>

<p><span class="pkg">prevR</span> allows spatial estimation of a prevalence surface or a relative
risks surface, using data from a Demographic and Health Survey (DHS) or an
analog survey.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> prevR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Licence: </td><td style="text-align: left;"> CeCILL-C -
<a href="https://cecill.info/licences/Licence_CeCILL-C_V1-en.html">https://cecill.info/licences/Licence_CeCILL-C_V1-en.html</a></td>
</tr>
<tr>
 <td style="text-align: left;">
Website: </td><td style="text-align: left;"> <a href="https://larmarange.github.io/prevR/">https://larmarange.github.io/prevR/</a></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package performs a methodological approach for spatial estimation of
regional trends of a prevalence using data from surveys using a stratified
two-stage sample design (as Demographic and Health Surveys). In these kind
of surveys, positive and control cases are spatially positioned at the
centre of their corresponding surveyed cluster.
</p>
<p>This package provides functions to estimate a prevalence surface using a
kernel estimator with adaptative bandwidths of equal number of persons
surveyed (a variant of the nearest neighbor technique) or with fixed
bandwidths. The prevalence surface could also be calculated using a spatial
interpolation (kriging or inverse distance weighting) after a moving average
smoothing based on circles of equal number of observed persons or circles
of equal radius.
</p>
<p>With the kernel estimator approach, it's also possible to estimate a surface
of relative risks.
</p>
<p>For a quick demo, enter <code>quick.prevR(fdhs)</code>.
</p>
<p>For a full demo, enter <code>demo(prevR)</code>.
</p>
<p>The content of <span class="pkg">prevR</span> can be broken up as follows:
</p>
<p><em>Datasets</em><br />
<a href="#topic+fdhs">fdhs</a> is a fictive dataset used for testing the package.<br />
<a href="#topic+TMWorldBorders">TMWorldBorders</a> provides national borders of every countries in the World
and could be used to define the limits of the studied area.
</p>
<p><em>Creating objects</em><br />
<span class="pkg">prevR</span> functions takes as input objects of class <a href="#topic+prevR-class">prevR</a>.<br />
<code><a href="#topic+import.dhs">import.dhs()</a></code> allows to import easily, through a step by step procedure,
data from a DHS (Demographic and Health Surveys) downloaded from
<a href="http://www.measuredhs.com">http://www.measuredhs.com</a>.<br />
<code><a href="#topic+as.prevR">as.prevR()</a></code> is a generic function to create an object of class
<a href="#topic+prevR-class">prevR</a>.<br />
<code><a href="#topic+create.boundary">create.boundary()</a></code> could be used to select borders of a country and
transfer them to <code><a href="#topic+as.prevR">as.prevR()</a></code> in order to define the studied area.
</p>
<p><em>Data visualization</em><br />
Methods <code><a href="#topic+show">show()</a></code>, <code><a href="#topic+print">print()</a></code>
and <code><a href="#topic+summary">summary()</a></code> display a summary of a object of class
<a href="#topic+prevR-class">prevR</a>.<br />
The method <code><a href="#topic+plot">plot()</a></code> could be used on a object of class
<a href="#topic+prevR-class">prevR</a> for visualizing the studied area, spatial position
of clusters, number of observations or number of positive cases by cluster.
</p>
<p><em>Data manipulation</em><br />
The method <code><a href="#topic+changeproj">changeproj()</a></code> changes the projection
of the spatial coordinates.<br />
The method <code><a href="#topic+as.data.frame">as.data.frame()</a></code> converts an object of
class <a href="#topic+prevR-class">prevR</a> into a data frame.<br />
The method <code><a href="#topic+export">export()</a></code> export data and/or the studied
area in a text file, a dbf file or a shapefile.
</p>
<p><em>Data analysis</em><br />
<code><a href="#topic+rings">rings()</a></code> calculates rings of equal number of
observations and/or equal radius.<br />
<code><a href="#topic+kde">kde()</a></code> calculates a prevalence surface or a relative
risks surface using gaussian kernel density estimators (kde)
with adaptative bandwidths.<br />
<code><a href="#topic+krige">krige()</a></code> executes a spatial interpolation using an
ordinary kriging.<br />
<code><a href="#topic+idw">idw()</a></code> executes a spatial interpolation using an inverse
distance weighting (idw) technique.
</p>


<h3>Acknowledgment</h3>

<p><span class="pkg">prevR</span> has been developed with funding from
the French National Agency for Research on AIDS and Viral Hepatitis
(ANRS - <a href="http://www.anrs.fr">http://www.anrs.fr</a>) and the French Research Institute for
Sustainable Development (IRD - <a href="https://www.ird.fr">https://www.ird.fr</a>), and technical
support from LYSIS (info@lysis-consultants.fr).
</p>


<h3>Citation</h3>

<p>To cite <span class="pkg">prevR</span>:<br />
Larmarange Joseph, Vallo Roselyne, Yaro Seydou, Msellati Philippe and
Meda Nicolas (2011) &quot;Methods for mapping regional trends of HIV prevalence
from Demographic and Health Surveys (DHS)&quot;,
<em>Cybergeo: European Journal of Geography</em>, no 558,
<a href="https://journals.openedition.org/cybergeo/24606">https://journals.openedition.org/cybergeo/24606</a>,
DOI: 10.4000/cybergeo.24606.
</p>


<h3>Author(s)</h3>

<p>Joseph Larmarange <a href="mailto:joseph.larmarange@ird.fr">joseph.larmarange@ird.fr</a><br />
IRD - CEPED (UMR 196 Université Paris Descartes Ined IRD)
</p>


<h3>References</h3>

<p>Larmarange Joseph and Bendaud Victoria (2014) &quot;HIV estimates at second
subnational level from national population-based survey&quot;,
<em>AIDS</em>, n° 28, p. S469-S476, DOI: 10.1097/QAD.0000000000000480
</p>
<p>Larmarange Joseph, Vallo Roselyne, Yaro Seydou, Msellati Philippe and Meda
Nicolas (2011) &quot;Methods for mapping regional trends of HIV prevalence from
Demographic and Health Surveys (DHS)&quot;,
<em>Cybergeo: European Journal of Geography</em>, n° 558,
<a href="https://journals.openedition.org/cybergeo/24606">https://journals.openedition.org/cybergeo/24606</a>,
DOI: 10.4000/cybergeo.24606
</p>
<p>Larmarange Joseph (2007) <em>Prévalences du VIH en Afrique : validité
d'une mesure</em>, PhD thesis in demography, directed by Benoît Ferry,
université Paris Descartes,
<a href="https://theses.hal.science/tel-00320283">https://theses.hal.science/tel-00320283</a>.
</p>
<p>Larmarange Joseph, Vallo Roselyne, Yaro Seydou, Msellati Philippe Meda
Nicolas and Ferry Benoît (2006), &quot;Cartographier les données des enquêtes
démographiques et de santé à partir des coordonnées des zones d'enquête&quot;,
<em>Chaire Quételet, 29 novembre au 1er décembre 2006</em>, Université
Catholique de Louvain, Louvain-la-Neuve, Belgique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
par(ask = TRUE)
# Creating an object of class prevR
col &lt;- c(
  id = "cluster",
  x = "x",
  y = "y",
  n = "n",
  pos = "pos",
  c.type = "residence",
  wn = "weighted.n",
  wpos = "weighted.pos"
)
dhs &lt;- as.prevR(fdhs.clusters, col, fdhs.boundary)

str(dhs)
print(dhs)

plot(dhs, main = "Clusters position")
plot(dhs, type = "c.type", main = "Clusters by residence")
plot(dhs, type = "count", main = "Observations by cluster")
plot(dhs, type = "flower", main = "Positive cases by cluster")

# Changing coordinates projection
plot(dhs, axes = TRUE)
dhs &lt;- changeproj(
  dhs,
  "+proj=utm +zone=30 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
)
print(dhs)
plot(dhs, axes = TRUE)

# Calculating rings of equal number of observations for different values of N
dhs &lt;- rings(dhs, N = c(100, 200, 300, 400, 500))
print(dhs)
summary(dhs)

# Prevalence surface for N=300
prev.N300 &lt;- kde(dhs, N = 300, nb.cells = 200)
plot(
  prev.N300["k.wprev.N300.RInf"],
  pal = prevR.colors.red,
  lty = 0,
  main = "Regional trends of prevalence (N=300)"
)

# Smoothing ring radii surface (spatial interpolation by kriging)
radius.N300 &lt;- krige("r.radius", dhs, N = 300, nb.cells = 200)
plot(
  radius.N300,
  pal = prevR.colors.blue,
  lty = 0,
  main = "Radius of circle (N=300)"
)
par(ask = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='prevR.colors'>Continuous color palettes.</h2><span id='topic+prevR.colors'></span><span id='topic+prevR.colors.blue'></span><span id='topic+prevR.colors.blue.inverse'></span><span id='topic+prevR.colors.gray'></span><span id='topic+prevR.colors.gray.inverse'></span><span id='topic+prevR.colors.green'></span><span id='topic+prevR.colors.green.inverse'></span><span id='topic+prevR.colors.red'></span><span id='topic+prevR.colors.red.inverse'></span><span id='topic+prevR.demo.pal'></span><span id='topic+prevR.colors.qgis.pal'></span>

<h3>Description</h3>

<p>Functions generating color palettes usable with <span class="rlang"><b>R</b></span> graphical functions.
These palettes are continuous, contrast being accentuated by darkening
and lightening extreme values. <code>prevR.demo.pal</code> plot the available
palettes. <code>prevR.colors.qgis.pal</code> export a palette in a text file
readable by Quantum GIS, an open-source mapping software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prevR.colors.blue(n = 10)

prevR.colors.blue.inverse(n = 10)

prevR.colors.gray(n = 10)

prevR.colors.gray.inverse(n = 10)

prevR.colors.green(n = 10)

prevR.colors.green.inverse(n = 10)

prevR.colors.red(n = 10)

prevR.colors.red.inverse(n = 10)

prevR.demo.pal(n, border = if (n &lt; 32) "light gray" else NA, main = NULL)

prevR.colors.qgis.pal(file, at, pal = "red", inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prevR.colors_+3A_n">n</code></td>
<td>
<p>number of different colors in the palette.</p>
</td></tr>
<tr><td><code id="prevR.colors_+3A_border">border</code></td>
<td>
<p>border color.</p>
</td></tr>
<tr><td><code id="prevR.colors_+3A_main">main</code></td>
<td>
<p>title.</p>
</td></tr>
<tr><td><code id="prevR.colors_+3A_file">file</code></td>
<td>
<p>file name with extension.</p>
</td></tr>
<tr><td><code id="prevR.colors_+3A_at">at</code></td>
<td>
<p>list of values of the palette.</p>
</td></tr>
<tr><td><code id="prevR.colors_+3A_pal">pal</code></td>
<td>
<p>color palette to use (&quot;red&quot;, &quot;green&quot;, &quot;blue&quot; or &quot;gray&quot;).</p>
</td></tr>
<tr><td><code id="prevR.colors_+3A_inverse">inverse</code></td>
<td>
<p>use the inverse palette?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+prevR.colors.red">prevR.colors.red()</a></code> produces a color gradation from white/yellow
to red/dark red.
</p>
<p><code><a href="#topic+prevR.colors.blue">prevR.colors.blue()</a></code> produces a color gradation from light blue
to dark blue.
</p>
<p><code><a href="#topic+prevR.colors.green">prevR.colors.green()</a></code> produces a color gradation from light green
to dark green.
</p>
<p><code><a href="#topic+prevR.colors.gray">prevR.colors.gray()</a></code> produces a color gradation from white/light gray to
dark gray/black.
</p>
<p>Functions with a suffix <em>.inverse</em> produce the same color gradation,
but from dark colors to light ones.
</p>


<h3>Value</h3>

<p><code><a href="#topic+prevR.demo.pal">prevR.demo.pal()</a></code> plot the color palettes.
</p>
<p><code><a href="#topic+prevR.colors.qgis.pal">prevR.colors.qgis.pal()</a></code> export a color palette in a text file readable
by Quantum GIS.
</p>
<p>The other functions return a list of colors coded in hexadecimal.
</p>


<h3>Note</h3>

<p>To obtain the list of colors in RGB (Red/Green/Blue), use the function
<code><a href="grDevices.html#topic+col2rgb">grDevices::col2rgb()</a></code>.
The code of <code><a href="#topic+prevR.demo.pal">prevR.demo.pal()</a></code> was adapted from the function <code>demo.pal</code>
presented in the examples of <code><a href="grDevices.html#topic+palettes">grDevices::rainbow()</a></code>.
</p>


<h3>See Also</h3>

<p>Other color palettes are available in <span class="rlang"><b>R</b></span>. See for example
<code><a href="grDevices.html#topic+palettes">grDevices::rainbow()</a></code> or the package <span class="pkg">RColorBrewer</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prevR.demo.pal(25)
prevR.colors.red(5)
col2rgb(prevR.colors.red(5))

## Not run: 
prevR.colors.qgis.pal("palette.txt", seq(0, 25, length.out = 100), "red")

## End(Not run)

</code></pre>

<hr>
<h2 id='print+2CprevR-method'>Summary of a prevR object.</h2><span id='topic+print+2CprevR-method'></span><span id='topic+print'></span><span id='topic+print-methods'></span>

<h3>Description</h3>

<p>Method <code>print</code> for objects of class <a href="#topic+prevR-class">prevR</a>:
shows a summary of the object's characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prevR'
print(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CprevR-method_+3A_x">x</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Exactly the same as <code><a href="#topic+show">show()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary">summary()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(fdhs)
## Not run: 
dhs &lt;- rings(fdhs, N = c(100, 300, 500))
print(dhs)

## End(Not run)

</code></pre>

<hr>
<h2 id='quick.prevR'>Quick prevR analysis and plot</h2><span id='topic+quick.prevR'></span>

<h3>Description</h3>

<p>This function performs several analysis in one go:
(i) apply <code><a href="#topic+rings">rings()</a></code>;
(ii) compute prevalence surface with <code><a href="#topic+kde">kde()</a></code>;
(iii) compute the surface of rings radii with <code><a href="#topic+krige">krige()</a></code>;
(iv) plot prevalence surface using <code><a href="#topic+prevR.colors.red">prevR.colors.red()</a></code> and add rings radii
as a contour plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quick.prevR(
  object,
  N = Noptim(object),
  nb.cells = 100,
  cell.size = NULL,
  weighted = NULL,
  plot.results = TRUE,
  return.results = FALSE,
  return.plot = FALSE,
  legend.title = "%",
  cex = 0.7,
  progression = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quick.prevR_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_n">N</code></td>
<td>
<p>integer or list of integers corresponding to the rings to use.</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_nb.cells">nb.cells</code></td>
<td>
<p>number of cells on the longest side of the studied area
(unused if <code>cell.size</code> is defined).</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_cell.size">cell.size</code></td>
<td>
<p>size of each cell (in the unit of the projection).</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_weighted">weighted</code></td>
<td>
<p>use weighted data (TRUE, FALSE or &quot;2&quot;)?</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_plot.results">plot.results</code></td>
<td>
<p>plot the results?</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_return.results">return.results</code></td>
<td>
<p>return the results?</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_return.plot">return.plot</code></td>
<td>
<p>return the plot within the results?</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_legend.title">legend.title</code></td>
<td>
<p>title of the legend</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_cex">cex</code></td>
<td>
<p>to control the text size on the graph</p>
</td></tr>
<tr><td><code id="quick.prevR_+3A_progression">progression</code></td>
<td>
<p>show a progress bar?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>N</code> determine the rings to use for the estimation.
By default, a suggested value of N will be computed with <code><a href="#topic+Noptim">Noptim()</a></code>.
</p>


<h3>Value</h3>

<p>A list of one or several elements, depending on the arguments:
(i) <code>prev</code> is a <code>SpatialPixelsDataFrame</code> containing the prevalence
surface; (ii) <code>radius</code> a <code>SpatialPixelsDataFrame</code> containing the
kriged surface of the rings radii; (iii) <code>plot</code> a <code>ggplot</code> graph.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Noptim">Noptim()</a></code>, <code><a href="#topic+rings">rings()</a></code>, <code><a href="#topic+kde">kde()</a></code> and <code><a href="#topic+krige">krige()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
quick.prevR(fdhs)

## End(Not run)

</code></pre>

<hr>
<h2 id='rings+2CprevR-method'>Calculation of rings of equal number of observation and/or equal radius.</h2><span id='topic+rings+2CprevR-method'></span><span id='topic+rings'></span><span id='topic+rings-methods'></span>

<h3>Description</h3>

<p>For each cluster, this function determines a ring of equal number of
observations and/or equal radius and calculates several indicators from
observations located inside that ring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prevR'
rings(object, N = seq(100, 500, 50), R = Inf, progression = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rings+2B2CprevR-method_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="rings+2B2CprevR-method_+3A_n">N</code></td>
<td>
<p>minimum number of observations.</p>
</td></tr>
<tr><td><code id="rings+2B2CprevR-method_+3A_r">R</code></td>
<td>
<p>maximum rings radius (in kilometers if coordinates in decimal
degrees, in the unit of the projection otherwise).</p>
</td></tr>
<tr><td><code id="rings+2B2CprevR-method_+3A_progression">progression</code></td>
<td>
<p>show a progress bar?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each row of the data frame <code>clusters</code> of <code>object</code>, <code>rings()</code>
determines a ring, centered on the cluster. It could be:
</p>

<ul>
<li><p> rings of equal number of observations if <code>N</code> is finite and <code>R = Inf</code>;
</p>
</li>
<li><p> rings of equal radius if <code>N = Inf</code> and <code>R</code> is finite;
</p>
</li>
<li><p> a combination of both (see below) if <code>N</code> and <code>R</code> are both finite.
</p>
</li></ul>

<p>For *rings of equal number of observations, <code>rings()</code> selects the smallest
ring containing at least <code>N</code> valid observations.
</p>
<p>For <em>rings of equal radius</em>, <code>rings()</code> selects all clusters located at a
lower distance than <code>R</code> from the central cluster.
</p>
<p>For <em>combination of both</em>, <code>rings()</code> calculates first the ring with the
minimum number of observations and test if its radius is lower than <code>R</code> or
not. If so, the ring is kept, otherwise the ring of maximum radius is
calculated.
</p>
<p>Different series of rings could be simultaneously calculated by providing
different values for <code>N</code> and <code>R</code>. <code>rings()</code> will calculate rings
corresponding to each couple (<code>N</code>,<code>R</code>).
</p>


<h3>Value</h3>

<p>Return <code>object</code> with the slot <code>rings</code> completed for each couple
(N,R).
</p>
<p>Each entry is composed of 3 elements: <code>N</code>, minimum number of observations per
ring; <code>R</code>, maximum radius of rings and <code>estimates</code>, a data frame with the
following variables:
</p>

<ul>
<li><p> &quot;id&quot; cluster ID.
</p>
</li>
<li><p> &quot;r.pos&quot; number of positive cases inside the ring.
</p>
</li>
<li><p> &quot;r.n&quot; number of valid observations inside the ring.
</p>
</li>
<li><p> &quot;r.prev&quot; observed prevalence (in %) inside the ring (r.pos/r.n).
</p>
</li>
<li><p> &quot;r.radius&quot; ring radius (in kilometers if coordinates in decimal degrees,
in the unit of the projection otherwise).
</p>
</li>
<li><p> &quot;r.clusters&quot; number of clusters located inside the ring.
</p>
</li>
<li><p> &quot;r.wpos&quot; (optional) sum of weights of positive cases inside the ring.
</p>
</li>
<li><p> &quot;r.wn&quot; (optional) sum of weights of valid observations inside the ring.
</p>
</li>
<li><p> &quot;r.wprev&quot; (optional) weighted observed prevalence (in %) inside the ring
(r.wpos/r.wn).
</p>
</li></ul>

<p>Note: the list <code>rings</code> is named, the name of each element is
N<em>N_value</em>.R<em>R_value</em>, for example <em>N300.RInf</em>.
</p>
<p>Note 2: <em>r.wpos</em>, <em>r.wn</em> and <em>r.wprev</em> are calculated only if
the slot <code>clusters</code> of <code>object</code> contains weighted data.
</p>


<h3>References</h3>

<p>Larmarange Joseph, Vallo Roselyne, Yaro Seydou, Msellati Philippe and Meda
Nicolas (2011) &quot;Methods for mapping regional trends of HIV prevalence from
Demographic and Health Surveys (DHS)&quot;,
<em>Cybergeo : European Journal of Geography</em>, no 558,
<a href="https://journals.openedition.org/cybergeo/24606">https://journals.openedition.org/cybergeo/24606</a>,
DOI: 10.4000/cybergeo.24606.
</p>
<p>Larmarange Joseph (2007)
<em>Prévalences du VIH en Afrique : validité d'une mesure</em>,
PhD thesis in demography, directed by Benoît Ferry, université Paris
Descartes, <a href="https://theses.hal.science/tel-00320283">https://theses.hal.science/tel-00320283</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+prevR-class">prevR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
print(fdhs)
dhs &lt;- rings(fdhs, N = c(100, 200, 300, 400, 500))
print(dhs)

## End(Not run)
</code></pre>

<hr>
<h2 id='show+2CprevR-method'>Summary of a prevR object.</h2><span id='topic+show+2CprevR-method'></span><span id='topic+show'></span><span id='topic+show-methods'></span>

<h3>Description</h3>

<p>Method <code>show</code> for objects of class <a href="#topic+prevR-class">prevR</a>:
shows a summary of the object's characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prevR'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CprevR-method_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Exactly the same as <code><a href="#topic+print">print()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary">summary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdhs
## Not run: 
dhs &lt;- rings(fdhs, N = c(100, 300, 500))
dhs

## End(Not run)

</code></pre>

<hr>
<h2 id='st_filter_prevR'>Spatial filter</h2><span id='topic+st_filter_prevR'></span>

<h3>Description</h3>

<p>This function forces points of an object of class
<code>[</code>sf] located outside
the limits defined by an object of class <a href="sp.html#topic+SpatialPolygons-class">sp::SpatialPolygons</a>
to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_filter_prevR(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_filter_prevR_+3A_x">x</code></td>
<td>
<p>object of class <a href="sf.html#topic+sf">sf::sf</a></p>
</td></tr>
<tr><td><code id="st_filter_prevR_+3A_y">y</code></td>
<td>
<p>object of class <a href="sf.html#topic+sf">sf::sf</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function try to apply <code>sf::st_filter()</code>. In case it fails,
it will try to rebuild <code>y</code> according to spherical geometry
(see <code><a href="sf.html#topic+s2">sf::st_as_s2()</a></code>) before filtering. If it still fail, it will return
<code>x</code> unfiltered.
</p>


<h3>Value</h3>

<p>Return <code>x</code> filtered by <code>y</code>
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_join">sf::st_filter()</a></code>.
</p>

<hr>
<h2 id='summary+2CprevR-method'>Detailed summary of the variables of a prevR object</h2><span id='topic+summary+2CprevR-method'></span><span id='topic+summary-methods'></span><span id='topic+summary'></span><span id='topic+prevRsummary'></span>

<h3>Description</h3>

<p>Method <code>summary</code> for objects of class <a href="#topic+prevR-class">prevR</a>:
shows a summary of the variables of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prevR'
summary(object, probs = c(0, 0.1, 0.25, 0.5, 0.75, 0.8, 0.9, 0.95, 0.99, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CprevR-method_+3A_object">object</code></td>
<td>
<p>object of class <a href="#topic+prevR-class">prevR</a>.</p>
</td></tr>
<tr><td><code id="summary+2B2CprevR-method_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> for computing
quantiles of the rings radii (see examples).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+print">print()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(fdhs)
## Not run: 
dhs &lt;- rings(fdhs, N = c(100, 300, 500))
summary(dhs)
summary(dhs, c(0, 0.25, 0.5, 0.75, 1))

## End(Not run)

</code></pre>

<hr>
<h2 id='theme_prevR'>prevR themes for ggplot2</h2><span id='topic+theme_prevR'></span><span id='topic+theme_prevR_light'></span>

<h3>Description</h3>

<p>Two custom themes for ggplot2 graphs, hiding axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_prevR(base_size = 12)

theme_prevR_light(base_size = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_prevR_+3A_base_size">base_size</code></td>
<td>
<p>base font size</p>
</td></tr>
</table>

<hr>
<h2 id='TMWorldBorders'>Dataset &quot;TM World Borders Dataset 0.3&quot;.</h2><span id='topic+TMWorldBorders'></span>

<h3>Description</h3>

<p>This dataset provides boundaries of all countries in the world,
in decimal degrees.
Available variables are:</p>

<ul>
<li><p> &quot;FIPS&quot; FIPS 10-4 Country Code.
</p>
</li>
<li><p> &quot;ISO2&quot; ISO 3166-1 Alpha-2 Country Code.
</p>
</li>
<li><p> &quot;ISO3&quot; ISO 3166-1 Alpha-3 Country Code.
</p>
</li>
<li><p> &quot;UN&quot; ISO 3166-1 Numeric-3 Country Code.
</p>
</li>
<li><p> &quot;NAME&quot; Name of country/area.
</p>
</li>
<li><p> &quot;AREA&quot; Land area, FAO Statistics (2002).
</p>
</li>
<li><p> &quot;POP2005&quot; Population, World Population Prospects (2005).
</p>
</li>
<li><p> &quot;REGION&quot; Macro geographical (continental region), UN Statistics.
</p>
</li>
<li><p> &quot;SUBREGION&quot; Geographical sub-region, UN Statistics.
</p>
</li>
<li><p> &quot;LON&quot; Longitude.
</p>
</li>
<li><p> &quot;LAT&quot; Latitude.
</p>
</li></ul>



<h3>Format</h3>

<p>Object of class <a href="sp.html#topic+SpatialPolygonsDataFrame-class">sp::SpatialPolygonsDataFrame</a>.
</p>


<h3>Note</h3>

<p>The boundaries, names designations used do not imply official
endorsement or acceptance by the authors. Use this dataset with care,
as several of the borders are disputed.
</p>


<h3>Source</h3>

<p>Provided by Bjorn Sandvik on
The dataset was derived by Schuyler Erle from public domain sources.
Sean Gilles did some clean up and made some enhancements. The dataset is
available under a <em>Creative Commons Attribution-Share Alike License</em>
(<a href="https://creativecommons.org/licenses/by-sa/3.0/">https://creativecommons.org/licenses/by-sa/3.0/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(TMWorldBorders["NAME"])
</code></pre>

<hr>
<h2 id='update_prevR'>Update a prevR object</h2><span id='topic+update_prevR'></span>

<h3>Description</h3>

<p>Update an object of class <code>prevR</code> created with a previous version of the
package to the last version. In particular, it will convert any boundary
slot defined with the <code>sp</code> package to <code>sf</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_prevR(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_prevR_+3A_object">object</code></td>
<td>
<p>a <code>prevR</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>prevR</code> object
</p>

<hr>
<h2 id='xyz2dataframe'>Convert a surface in xyz to a data frame.</h2><span id='topic+xyz2dataframe'></span>

<h3>Description</h3>

<p>Several functions (for example <code><a href="KernSmooth.html#topic+bkde2D">KernSmooth::bkde2D()</a></code>)
return a surface as a list &quot;xyz&quot; composed of three elements:
vector of ordinates in the x dimension,
vector of ordinates in the y dimension and
a matrix with the values of the surface in x and y.
This function transforms a list &quot;xyz&quot; into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz2dataframe(xyz, xcol = 1, ycol = 2, zcol = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz2dataframe_+3A_xyz">xyz</code></td>
<td>
<p>a list with 3 elements: a vector with x-coordinates,
a vector with y-coordinates and
and matrix with value for each point of coordinates <code style="white-space: pre;">&#8288;x[i], y[j]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="xyz2dataframe_+3A_xcol">xcol</code></td>
<td>
<p>x index.</p>
</td></tr>
<tr><td><code id="xyz2dataframe_+3A_ycol">ycol</code></td>
<td>
<p>y index.</p>
</td></tr>
<tr><td><code id="xyz2dataframe_+3A_zcol">zcol</code></td>
<td>
<p>z index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Note</h3>

<p><code>xyz</code> could be a list like <code>x,y,z1,z2,z3</code>.
If so, <code>zcol</code> should be equal
to <code>c("z1","z2","z3")</code> or <code>c(3,4,5)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(2, 4, 6, 8, 10, 2, 4, 6, 8, 10), ncol = 2)
op &lt;- KernSmooth::bkde2D(x, bandwidth = 1)
str(op)

op.df &lt;- xyz2dataframe(op)
str(op.df)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
