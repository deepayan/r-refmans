<!DOCTYPE html><html lang="en"><head><title>Help for package cfa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cfa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcfa'><p>Bootstrap-CFA</p></a></li>
<li><a href='#cfa'><p> Analysis of configuration frequencies</p></a></li>
<li><a href='#fCFA'><p>Stepwise CFA approaches</p></a></li>
<li><a href='#hcfa'><p>Hierachical analysis of configuration frequencies</p></a></li>
<li><a href='#mcfa'><p> Two or more-sample CFA</p></a></li>
<li><a href='#plot.bcfa'><p>Plotting method for a bcfa object</p></a></li>
<li><a href='#plot.hcfa'><p>Plotting method for a hcfa object</p></a></li>
<li><a href='#plot.mcfa'><p> Plotting method for a mcfa object</p></a></li>
<li><a href='#plot.scfa'><p> Plotting method for a scfa object</p></a></li>
<li><a href='#print.bcfa'><p>Print an object of the class hcfa</p></a></li>
<li><a href='#print.hcfa'><p>Print an object of the class hcfa</p></a></li>
<li><a href='#print.mcfa'><p>Print an object of the class mcfa</p></a></li>
<li><a href='#print.scfa'><p>Print an object of the class scfa</p></a></li>
<li><a href='#PXisM'><p> Test according to Lindner</p></a></li>
<li><a href='#PXisMclassic'><p> Test according to Lindner</p></a></li>
<li><a href='#scfa'><p> One sample CFA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Description:</td>
<td>Analysis of configuration frequencies for simple and repeated measures, multiple-samples CFA, hierarchical CFA, bootstrap CFA, functional CFA, Kieser-Victor CFA, and Lindner's test using a conventional and an accelerated algorithm.</td>
</tr>
<tr>
<td>Title:</td>
<td>Configural Frequency Analysis (CFA)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-14</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-14 15:26:31 UTC; patrick</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Mair [aut, cre],
  Stefan Funke [aut],
  Joachim Harloff [ctb],
  Alexander von Eye [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Mair &lt;mair@fas.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 08:36:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcfa'>Bootstrap-CFA</h2><span id='topic+bcfa'></span>

<h3>Description</h3>

<p> The bootstrap-CFA tries to replicate the pattern of significant configurations by
re-sampling. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcfa(configs, cnts, runs=100, sig.item="sig.z",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bcfa_+3A_configs">configs</code></td>
<td>
<p> Contains the configurations. This can be a dataframe or a matrix. The dataframe can contain numbers,
characters, factors, or booleans. The matrix can consist of numbers, characters or booleans 
(factors are implicitely re-converted to numerical levels). There must be &gt;=3 columns.
</p>
</td></tr>
<tr><td><code id="bcfa_+3A_cnts">cnts</code></td>
<td>
<p> Contains the counts for the configuration. If it is set to NA, a count of one is assumed for every
row. This allows untabulated data to be processed. <code>cnts</code> must be a vector.
</p>
</td></tr>
<tr><td><code id="bcfa_+3A_runs">runs</code></td>
<td>
<p>Number of samples to be drawn.</p>
</td></tr>
<tr><td><code id="bcfa_+3A_sig.item">sig.item</code></td>
<td>
<p>Indicator of significance in the result table (sig.z,sig.chisq,sig.perli,sig.zl,
sig.zl.corr). Do not forget to set the proper parameters for the CFA if sig.perli,sig.zl or
sig.zl.corr are to be used!</p>
</td></tr>
<tr><td><code id="bcfa_+3A_...">...</code></td>
<td>
<p>Parameters to be to relayed to the CFA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes 'runs' samples and does as many CFAs while counting how many times this configuration 
was  considered to be significant. 
</p>
<p>Repeated-measures CFAs (mcfa) are not provided.
</p>
<p>This is a heuristic method rather than a strict test of significance since there 
is no adjustment for multiple testing whatsoever. The advantage  is a more reliable picture
compared to splitting the original data, doing a CFA, and checking if the configurations re-appear 
in a CFA with the other half of the data. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cnt.antitype</code></td>
<td>
<p>Number of antiypes</p>
</td></tr>
<tr><td><code>cnt.type</code></td>
<td>
<p>Number of types</p>
</td></tr>
<tr><td><code>pct.types</code></td>
<td>
<p>Number of types in percent</p>
</td></tr>
<tr><td><code>cnt.sig</code></td>
<td>
<p>Number of significant results</p>
</td></tr>
<tr><td><code>pct.cnt.sig</code></td>
<td>
<p>Number of significant results in percent</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>bcfa()</code> performs many CFAs which are by themselves slow, so the execution can
be <b>very</b> time-consuming, especially if a sufficiently high value for <code>runs</code> was selected</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

 
<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse 
Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+scfa">scfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts&lt;-trunc(runif(250)*10)
bcfa(configs,counts,runs=25) 
</code></pre>

<hr>
<h2 id='cfa'> Analysis of configuration frequencies</h2><span id='topic+cfa'></span>

<h3>Description</h3>

<p>This is the main function which will call scfa() und mcfa() as required to handle the simple and the multiple cfa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfa(cfg, cnts=NA, sorton="chisq", sort.descending=TRUE, format.labels=TRUE, 
    casewise.delete.empty=TRUE, 
    binom.test=FALSE, exact.binom.test=FALSE, exact.binom.limit=10, 
    perli.correct=FALSE, lehmacher=FALSE, lehmacher.corr=TRUE, 
    alpha=0.05, bonferroni=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cfa_+3A_cfg">cfg</code></td>
<td>
<p> Contains the configurations. This can be a dataframe or a matrix. The dataframe can contain numbers,
characters, factors, or booleans. The matrix can consist of numbers, characters, or booleans 
(factors are implicitely re-converted to numerical levels). There must be &gt;=3 columns.
</p>
</td></tr>
<tr><td><code id="cfa_+3A_cnts">cnts</code></td>
<td>
<p> Contains the counts for the configuration. If it is set to NA, a count of one is assumed for every
row. This allows untabulated data to be processed. <code>cnts</code> can be a vector or a matrix/dataframe with &gt;=2 columns.
</p>
</td></tr>
<tr><td><code id="cfa_+3A_sorton">sorton</code></td>
<td>
<p> Determines the sorting order of the output table. Can be set to <code>chisq</code>, <code>n</code>, or <code>label</code>.</p>
</td></tr>
<tr><td><code id="cfa_+3A_sort.descending">sort.descending</code></td>
<td>
<p> Sort in descending order</p>
</td></tr>
<tr><td><code id="cfa_+3A_format.labels">format.labels</code></td>
<td>
<p> Format the labels of the configuration. This makes to output wider but it will increase the
readability.</p>
</td></tr>
<tr><td><code id="cfa_+3A_casewise.delete.empty">casewise.delete.empty</code></td>
<td>
<p> If set to TRUE all configurations containing a NA in any column will be deleted. Otherwise
NA is handled as the string &quot;NA&quot; and will appear as a valid configuration.</p>
</td></tr>
<tr><td><code id="cfa_+3A_binom.test">binom.test</code></td>
<td>
<p> Use z approximation for binomial test.</p>
</td></tr>
<tr><td><code id="cfa_+3A_exact.binom.test">exact.binom.test</code></td>
<td>
<p> Do an exact binomial test.</p>
</td></tr>
<tr><td><code id="cfa_+3A_exact.binom.limit">exact.binom.limit</code></td>
<td>
<p> Maximum n for which an exact binomial test is performed (n &gt;10 causes p to become inexact).</p>
</td></tr>
<tr><td><code id="cfa_+3A_perli.correct">perli.correct</code></td>
<td>
<p> Use Perli's correction for multiple test.</p>
</td></tr>
<tr><td><code id="cfa_+3A_lehmacher">lehmacher</code></td>
<td>
<p> Use Lehmacher's correction for multiple test.</p>
</td></tr>
<tr><td><code id="cfa_+3A_lehmacher.corr">lehmacher.corr</code></td>
<td>
<p> Use a continuity correction for Lehmacher's correction.</p>
</td></tr>
<tr><td><code id="cfa_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level</p>
</td></tr>
<tr><td><code id="cfa_+3A_bonferroni">bonferroni</code></td>
<td>
<p>Do Bonferroni adjustment for multiple test (irrelevant for Perli's and Lehmacher's test).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cfa is used to sift large tables of nominal data. Usually it is used for dichotomous 
variables but can be extended to three or more possible values. There should be at least three configuration variables
in <code>cfg</code> - otherwise a simple contigency table would do.
All tests of significance are two-sided: They test for both types or antitypes, i.e. if n is significantly larger or
smaller than the expected value.
The usual caveats for testing contigency tables apply. If a configuration has a n &lt;5 an exact test
should be used. As an alternative the least interesting configuration variable can be left out (if
it is not essential) which will automatically increase the n for the remaining configurations.
</p>


<h3>Value</h3>

<p> Some of these elements will only be returned when the corresponding argument
in the function call has been set. The relation is obvious due to corresponding names.
</p>
<table role = "presentation">
<tr><td><code>table</code></td>
<td>
<p>The cfa output table</p>
</td></tr>
<tr><td><code>table["label"]</code></td>
<td>
<p>Label for the given configuration</p>
</td></tr>
<tr><td><code>table["n"]</code></td>
<td>
<p>Observed n for this configuration</p>
</td></tr> 
<tr><td><code>table["expected"]</code></td>
<td>
<p>Expected n for this configuration</p>
</td></tr> 
<tr><td><code>table["Q"]</code></td>
<td>
<p>Coefficient of pronouncedness (varies between 0 and 1)</p>
</td></tr> 
<tr><td><code>table["chisq"]</code></td>
<td>
<p>Chi squared for the given configuration</p>
</td></tr> 
<tr><td><code>table["p.chisq"]</code></td>
<td>
<p>p for the chi squared test</p>
</td></tr> 
<tr><td><code>table["sig.chisq"]</code></td>
<td>
<p>Is it significant (will Bonferroni-adjust if argument <code>bonferroni</code> 
is set)</p>
</td></tr> 
<tr><td><code>table["z"]</code></td>
<td>
<p>z-approximation for chi squared</p>
</td></tr>
<tr><td><code>table["p.z"]</code></td>
<td>
<p>p of z-test</p>
</td></tr>
<tr><td><code>table["sig.z"]</code></td>
<td>
<p>Is it significant (will Bonferroni-adjust if argument <code>bonferroni</code> 
is set)?</p>
</td></tr>
<tr><td><code>table["x.perli"]</code></td>
<td>
<p>Statistic for Perli's test</p>
</td></tr>
<tr><td><code>table["sig.perli"]</code></td>
<td>
<p>Is it significant (this is designed as a multiple test)?</p>
</td></tr>
<tr><td><code>table["zl"]</code></td>
<td>
<p>z for Lehmacher's test</p>
</td></tr>
<tr><td><code>table["sig.zl"]</code></td>
<td>
<p>Is it significant (this is designed as a multiple test)?</p>
</td></tr>  
<tr><td><code>table["zl.corr"]</code></td>
<td>
<p>z for Lehmacher's test (with continuity correction)</p>
</td></tr>
<tr><td><code>table["sig.zl.corr"]</code></td>
<td>
<p>Is it significant (this is designed as a multiple test)?</p>
</td></tr>
<tr><td><code>table["p.exact.bin"]</code></td>
<td>
<p>p for exact binomial test</p>
</td></tr> 
<tr><td><code>summary.stats</code></td>
<td>
<p>Summary stats for entire table</p>
</td></tr>
<tr><td><code>summary.stats["totalchisq"]</code></td>
<td>
<p>Total chi squared</p>
</td></tr> 
<tr><td><code>summary.stats["df"]</code></td>
<td>
<p>Degrees of freedom</p>
</td></tr>
<tr><td><code>summary.stats["p"]</code></td>
<td>
<p>p for the chi squared test</p>
</td></tr>
<tr><td><code>summary.stats["sum of counts"]</code></td>
<td>
<p>Sum of all counts</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>Levels for each configuration. Should all be 2 for the bivariate case</p>
</td></tr> 
</table>


<h3>WARNING </h3>

<p>Note than spurious &quot;significant&quot; configurations are likely to appear in very large tables.
The results should therefore be replicated before they are accepted as real. <code>boot.cfa</code> can be helpful to check
the results.</p>


<h3>Note</h3>

<p>There are no hard-coded limits in the program so even large tables can be processed. 
The output table can be very wide if the levels of factors variables are long  strings so &lsquo;options(width=..)&rsquo;
may need to be adjusted. 
</p>
<p>The object returned has the class scfa if a one-sample CFA was performed or 
the class mcfa if a repeated-measures CFA was performed. <code>cfa()</code> decides which
one is appropriate by looking at <code>cnts</code>: If it is a vector, it will do a
simple CFA. If it is a dataframe or matrix with 2 or more columns, a repeated-measures
CFA ist done.
</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p> Krauth J., Lienert G. A. (1973, Reprint 1995) Die
Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in
Psychologie und Medizin. Beltz Psychologie Verlagsunion
</p>
<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse in
Psychologie und Medizin. Beltz Psychologie Verlagsunion
</p>
<p>Eye, A. von (1990) Introduction to configural frequency analysis.
The search for types and anti-types in cross-classification. 
Cambride 1990
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scfa">scfa</a></code>, <code><a href="#topic+mcfa">mcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts&lt;-trunc(runif(250)*10)
cfa(configs,counts) 
</code></pre>

<hr>
<h2 id='fCFA'>Stepwise CFA approaches</h2><span id='topic+fCFA'></span><span id='topic+kvCFA'></span><span id='topic+print.fCFA'></span><span id='topic+print.kvCFA'></span><span id='topic+summary.fCFA'></span><span id='topic+summary.kvCFA'></span>

<h3>Description</h3>

<p>These CFA methods detect and eliminate stepwise types/antitypes
cells by specifying an appropriate contrast in the design matrix.
The procedures stop when model fit is achieved. Functional CFA (fCFA) uses a residual
criterion, Kieser-Victor CFA (kvCFA) a LR-criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fCFA(m.i,  X, tabdim, alpha = 0.05)
kvCFA(m.i, X, tabdim, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fCFA_+3A_m.i">m.i</code></td>
<td>
<p>Vector of observed frequencies.</p>
</td></tr>
<tr><td><code id="fCFA_+3A_x">X</code></td>
<td>
<p>Design Matrix of the base model.</p>
</td></tr>
<tr><td><code id="fCFA_+3A_tabdim">tabdim</code></td>
<td>
<p>Vector of table dimensions.</p>
</td></tr>
<tr><td><code id="fCFA_+3A_alpha">alpha</code></td>
<td>
<p>Significance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>restable</code></td>
<td>
<p>Fit results for each step</p>
</td></tr>
<tr><td><code>design.mat</code></td>
<td>
<p>Final design matrix</p>
</td></tr>
<tr><td><code>struc.mat</code></td>
<td>
<p>Structural part of the design matrix for each step</p>
</td></tr>
<tr><td><code>typevec</code></td>
<td>
<p>Type or antitype for each step</p>
</td></tr>
<tr><td><code>resstep</code></td>
<td>
<p>Design matrix, expected frequency vector, and fit results for each step</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Patrick Mair, Alexander von Eye</p>


<h3>References</h3>

<p>von Eye, A., and Mair, P. (2008). A functional approach to configural frequency analysis. 
Austrian Journal of Statistics, 37, 161-173.
</p>
<p>Kieser, M., and Victor, N. (1999). Configural frequency analysis (CFA) revisited: A new look at an old approach. 
Biometrical Journal, 41, 967-983. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Functional CFA for a internet terminal usage data set by Wurzer 
#(An application of configural frequency analysis: Evaluation of the
#usage of internet terminals, 2005, p.82)
dd &lt;- data.frame(a1=gl(3,4),b1=gl(2,2,12),c1=gl(2,1,12))
X &lt;- model.matrix(~a1+b1+c1,dd,contrasts=list(a1="contr.sum",b1="contr.sum",
    c1="contr.sum"))
ofreq &lt;- c(121,13,44,37,158,69,100,79,24,0,26,3)
tabdim &lt;- c(3,2,2)

res1 &lt;- fCFA(ofreq, X, tabdim=tabdim)
res1
summary(res1)


# Kieser-Vector CFA for Children's temperament data from 
# von Eye  (Configural Frequency Analysis, 2002, p. 192) 
dd &lt;- data.frame(a1=gl(3,9),b1=gl(3,3,27),c1=gl(3,1,27))
X &lt;- model.matrix(~a1+b1+c1,dd,contrasts=list(a1="contr.sum",
    b1="contr.sum",c1="contr.sum"))
ofreq &lt;- c(3,2,4,23,23,6,39,33,9,11,29,13,19,36,19,21,26,18,13,30,
         41,12,14,23,8,6,7)
tabdim &lt;- c(3,3,3)

res2 &lt;- kvCFA(ofreq, X, tabdim=tabdim)
res2
summary(res2)
</code></pre>

<hr>
<h2 id='hcfa'>Hierachical analysis of configuration frequencies</h2><span id='topic+hcfa'></span>

<h3>Description</h3>

<p>Recursively eliminates one variable in the configuration to generate all possible
sub-tables and performs a global chi-squared-test on them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcfa(configs, cnts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hcfa_+3A_configs">configs</code></td>
<td>
<p> Contains the configurations. This can be a dataframe or a matrix. The dataframe can contain numbers,
characters, factors or booleans. The matrix can consist of numbers, characters or booleans 
(factors are implicitely re-converted to numerical levels). There must be &gt;=3 columns.
</p>
</td></tr>
<tr><td><code id="hcfa_+3A_cnts">cnts</code></td>
<td>
<p> Contains the counts for the configuration. If it is set to NA, a count of one is assumed for every
row. This allows untabulated data to be processed. <code>cnts</code> can be a vector or a matrix/dataframe with &gt;=2 columns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hierarchical CFA assists in the selection of configuration variables by showing
which variables contribute the most to the variability. If eliminating a variable does not
markedly decrease the global chi squared the variable is likely to be redundant, provided there are
no extraneous reasons for retaining it. 
</p>
<p>The output is in decreasing order of chi squared so the most useful combinations of 
variables come first.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>chisq</code></td>
<td>
<p>Global chi squared</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for this subtable</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>Order (number of configuration variables)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The p for the test of significance ist provided by the print method</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse 
in Psychologie und Medizin, Beltz Psychologie Verlagsunion</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+scfa">scfa</a></code>, <code><a href="#topic+mcfa">mcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],
c("C","D")[rbinom(250,1,0.1)+1],
c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts&lt;-trunc(runif(250)*10)
hcfa(configs,counts) 
</code></pre>

<hr>
<h2 id='mcfa'> Two or more-sample CFA</h2><span id='topic+mcfa'></span>

<h3>Description</h3>

<p>Performs an analysis of configuration frequencies for two or more sets of counts. 
<em>This function is not designed to be called directly by the user but will only be used internally by <code>cfa()</code>.</em>
Both the simple an the multiple cfa are handled by <code>cfa()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcfa(cfg, cnts, sorton="chisq", sort.descending=TRUE, format.labels=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcfa_+3A_cfg">cfg</code></td>
<td>
<p>Contains the configurations. This can be a dataframe or a matrix. The dataframe can contain numbers,
characters, factors or booleans. The matrix can consist of numbers, characters or booleans 
(factors are implicitely re-converted to numerical levels). There must be &gt;=3 columns.</p>
</td></tr>
<tr><td><code id="mcfa_+3A_cnts">cnts</code></td>
<td>
<p> Contains the counts for the configuration. <code>cnts</code> is a matrix or dataframe with 2 or more columns.</p>
</td></tr>
<tr><td><code id="mcfa_+3A_sorton">sorton</code></td>
<td>
<p> Determines the sorting order of the output. Can be set to <code>chisq</code>, <code>n</code>, or <code>label</code>.</p>
</td></tr>
<tr><td><code id="mcfa_+3A_sort.descending">sort.descending</code></td>
<td>
<p>Sort in descending order </p>
</td></tr>
<tr><td><code id="mcfa_+3A_format.labels">format.labels</code></td>
<td>
<p>Format the labels of the configuration. This makes to output wider but it will increase the
readability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function is the &quot;engine&quot; <code>cfa()</code> will use. It does
the aggregation, summing up, and will calculate chi squared. All tests of significance are left to  <code>cfa()</code> 
</p>


<h3>Value</h3>

<p> The function returns the following list:
</p>
<table role = "presentation">
<tr><td><code>labels</code></td>
<td>
<p>Configuration label</p>
</td></tr> 
<tr><td><code>sums</code></td>
<td>
<p>Sums for each configuration and each variable in the configuration</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Matrix of observed n of the given configuration</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>Matrix of expected n for the given configuration</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>Chi squared for each configuration</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>There are no hard-coded limits in the program so even large tables can be processed. 
</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>Krauth J., Lienert G. A. (1973, Reprint 1995) Die
Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in
Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse 
in Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Eye, A. von (1990) Introduction to configural frequency analysis.
The search for types and anti-types in cross-classification. 
Cambride 1990 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+scfa">scfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts1&lt;-trunc(runif(250)*10) 
counts2&lt;-trunc(runif(250)*10)
cfa(configs,cbind(counts1,counts2))
# cfa rather than mcfa!
</code></pre>

<hr>
<h2 id='plot.bcfa'>Plotting method for a bcfa object</h2><span id='topic+plot.bcfa'></span>

<h3>Description</h3>

<p>Plots an object of the class <code>bcfa</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bcfa'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bcfa_+3A_x">x</code></td>
<td>
<p>An object of the class <code>bcfa</code> which is returned by the function 
<code>boot.cfa()</code></p>
</td></tr>
<tr><td><code id="plot.bcfa_+3A_...">...</code></td>
<td>
<p>Any arguments to be given to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the number of cases considered significant vs. the number of cases considered
to be a type (n &gt; expected). 
</p>
<p>This is in some way like other plots of quality versus quantity.
</p>
<p>Configurations can be identified by left-clicking on them until the
right mouse button is pressed. The labels of the configurations selected will be displayed
in the text window.
</p>


<h3>Value</h3>

<p>Returns a vector of the configurations selected with their name set to the labels
</p>


<h3>Note</h3>

<p>This function is usually invoked plotting an object returned by 
<code>bcfa</code></p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>None - plots have been rarely used with the CFA</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bcfa">bcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts&lt;-trunc(runif(250)*10)
plot(bcfa(configs,counts,runs=25))
</code></pre>

<hr>
<h2 id='plot.hcfa'>Plotting method for a hcfa object</h2><span id='topic+plot.hcfa'></span>

<h3>Description</h3>

<p>Plots an object of the class <code>hcfa</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hcfa'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hcfa_+3A_x">x</code></td>
<td>
<p>An object of the class hcfa</p>
</td></tr>
<tr><td><code id="plot.hcfa_+3A_...">...</code></td>
<td>
<p>Any arguments to be used by <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p> A dotchart is generated which plots chi squared vs. the order of the configuration 
(i.e. the number of configuration variables it contains).
</p>


<h3>Value</h3>

<p>Returns NULL.
</p>


<h3>Note</h3>

<p>This function is usually invoked plotting an object returned by 
<code>hcfa</code></p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>None - plots have been rarely used with the CFA</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+hcfa">hcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
#          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
#counts&lt;-trunc(runif(250)*10)
#plot(hcfa(configs,counts))
</code></pre>

<hr>
<h2 id='plot.mcfa'> Plotting method for a mcfa object</h2><span id='topic+plot.mcfa'></span>

<h3>Description</h3>

<p>Plots an object of the class <code>mcfa</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcfa'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mcfa_+3A_x">x</code></td>
<td>
<p>An object of the class <code>mcfa</code> which is returned by the function 
<code>cfa()</code> (rather than <code>mcfa()</code>) which performs a repeated measures CFA (two or more columns of counts)</p>
</td></tr>
<tr><td><code id="plot.mcfa_+3A_...">...</code></td>
<td>
<p>Any arguments to be used by <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots chi squared vs. the sum of all counts for this configuration which indicates 
pronouncedness of the configuration vs. practical importance. 
Configurations can be identified by left-clicking on them until the
right mouse button is pressed. The labels of the configurations selected will be displayed
in the text window.
</p>


<h3>Value</h3>

<p>Returns a list of the labels of the configurations selected.
</p>


<h3>Note</h3>

<p>This function is usually invoked plotting an object returned by 
<code>cfa</code></p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>None - plots have been rarely used with the CFA</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+mcfa">mcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts1&lt;-trunc(runif(250)*10)
counts2&lt;-trunc(runif(250)*10)

plot(cfa(configs,cbind(counts1,counts2)))

</code></pre>

<hr>
<h2 id='plot.scfa'> Plotting method for a scfa object</h2><span id='topic+plot.scfa'></span>

<h3>Description</h3>

<p>Plots an object of the class <code>scfa</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scfa'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scfa_+3A_x">x</code></td>
<td>
<p>An object of the class <code>scfa</code> which is returned by the function 
<code>cfa()</code> (rather than <code>scfa()</code>) which performs a simple CFA (one column of counts)</p>
</td></tr>
<tr><td><code id="plot.scfa_+3A_...">...</code></td>
<td>
<p>Any arguments to be used by <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots chi squared vs. n which indicates pronouncedness of the configuration vs. 
practical importance. Configurations can be identified by left-clicking on them until the
right mouse button is pressed. The labels of the configurations selected will be displayed
in the text window.
</p>


<h3>Value</h3>

<p>Returns a list of the labels of the configurations selected.
</p>


<h3>Note</h3>

<p>This function is usually invoked plotting an object returned by 
<code>cfa</code></p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>None - plots have been rarely used with the CFA</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+scfa">scfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts&lt;-trunc(runif(250)*10)
plot(cfa(configs,counts))
</code></pre>

<hr>
<h2 id='print.bcfa'>Print an object of the class hcfa</h2><span id='topic+print.bcfa'></span>

<h3>Description</h3>

<p>Printing method for an object returned by  <code>boot.cfa()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bcfa'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bcfa_+3A_x">x</code></td>
<td>
<p>An object of the class bcfa</p>
</td></tr>
<tr><td><code id="print.bcfa_+3A_...">...</code></td>
<td>
<p>Additional arguments given to <code>print</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called implicitely.
</p>


<h3>Value</h3>

<p>Returns NULL
</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>Krauth J., Lienert G. A. (1973, Reprint 1995) Die
Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in
Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse 
in Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Eye, A. von (1990) Introduction to configural frequency analysis.
The search for types and anti-types in cross-classification. 
Cambride 1990 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+bcfa">bcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts&lt;-trunc(runif(250)*10)
result&lt;-bcfa(configs,counts,runs=25) 
print(result)
</code></pre>

<hr>
<h2 id='print.hcfa'>Print an object of the class hcfa</h2><span id='topic+print.hcfa'></span>

<h3>Description</h3>

<p>Printing method for an object returned by  <code>hier.cfa()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hcfa'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.hcfa_+3A_x">x</code></td>
<td>
<p>An object of the class hcfa</p>
</td></tr>
<tr><td><code id="print.hcfa_+3A_...">...</code></td>
<td>
<p>Additional arguments given to <code>print</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called implicitely.
</p>


<h3>Value</h3>

<p> Returns NULL.
</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>Krauth J., Lienert G. A. (1973, Reprint 1995) Die
Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in
Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse 
in Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Eye, A. von (1990) Introduction to configural frequency analysis.
The search for types and anti-types in cross-classification. 
Cambride 1990 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+hcfa">hcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
#          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
#counts&lt;-trunc(runif(250)*10)
#result&lt;-hcfa(configs,counts) 
#print(result)
</code></pre>

<hr>
<h2 id='print.mcfa'>Print an object of the class mcfa</h2><span id='topic+print.mcfa'></span>

<h3>Description</h3>

<p>Printing method for one of two possible objects returned by  <code>cfa()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcfa'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mcfa_+3A_x">x</code></td>
<td>
<p>An object of the class mcfa</p>
</td></tr>
<tr><td><code id="print.mcfa_+3A_...">...</code></td>
<td>
<p>Additional arguments given to <code>print</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called implicitely.
</p>


<h3>Value</h3>

<p>Returns NULL
</p>


<h3>Note</h3>

<p>Note that <code>cfa()</code> will return an object with the class scfa if there is only one
row of counts. If there are two or more of them, an object with the class mcfa is returned.
In contrast <code>scfa()</code> and <code>mcfa()</code> return a list which has no class of it's own.</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>Krauth J., Lienert G. A. (1973, Reprint 1995) Die
Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in
Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse 
in Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Eye, A. von (1990) Introduction to configural frequency analysis.
The search for types and anti-types in cross-classification. 
Cambride 1990 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+mcfa">mcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts1&lt;-trunc(runif(250)*10) 
counts2&lt;-trunc(runif(250)*10)
result&lt;-cfa(configs,cbind(counts1,counts2))
print(result)
</code></pre>

<hr>
<h2 id='print.scfa'>Print an object of the class scfa</h2><span id='topic+print.scfa'></span>

<h3>Description</h3>

<p>Printing method for one of two possible objects returned by  <code>cfa()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scfa'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.scfa_+3A_x">x</code></td>
<td>
<p>An object of the class scfa</p>
</td></tr>
<tr><td><code id="print.scfa_+3A_...">...</code></td>
<td>
<p>Additional arguments given to <code>print</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called implicitely.
</p>


<h3>Value</h3>

<p>Returns NULL</p>


<h3>Note</h3>

<p>Note that <code>cfa()</code> will return an object with the class scfa if there is only one
row of counts. If there are two or more of them, an object with the class mcfa is returned.
In contrast <code>scfa()</code> and <code>mcfa()</code> return a list which has no class of it's own.</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>Krauth J., Lienert G. A. (1973, Reprint 1995) Die
Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in
in Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse 
in Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Eye, A. von (1990) Introduction to configural frequency analysis.
The search for types and anti-types in cross-classification. 
Cambride 1990 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+scfa">scfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts&lt;-trunc(runif(250)*10)
result&lt;-cfa(configs,counts) 
print(result)
</code></pre>

<hr>
<h2 id='PXisM'> Test according to Lindner</h2><span id='topic+PXisM'></span>

<h3>Description</h3>

<p>Performs a test of significance according to Lindner
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PXisM(m,n,Nt,k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PXisM_+3A_m">m</code></td>
<td>
<p>Observed frequency of the observation tested</p>
</td></tr>
<tr><td><code id="PXisM_+3A_n">n</code></td>
<td>
<p>Marginal sums of the parameters realized in the configuration to be tested (vector) </p>
</td></tr>
<tr><td><code id="PXisM_+3A_nt">Nt</code></td>
<td>
<p>Sample size of configurations </p>
</td></tr>
<tr><td><code id="PXisM_+3A_k">k</code></td>
<td>
<p>Number of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns p for the test according to Linder
</p>


<h3>Note</h3>

<p> The test according to Lindner requires the packages parallel. All other parts of cfa do not.
</p>


<h3>Author(s)</h3>

<p>J. Harloff &lt;oachimharloff@joachimharloff.de&gt; </p>


<h3>References</h3>

<p>Lindner, K.: Eine exakte Auswertungsmethode zur Konfigurationsfrequenzanalyse [An exact procedure for
the configural frequency analysis]. Psycholog Beitraege 26, 393?415 (1984)
</p>
<p>Harloff, Joachim, An efficient algorithm for Lindners test
(configural frequency analysis), Qual Quant DOI 10.1007/s11135-011-9499-9
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Does not work with windows since there is no parallel for it
if (require(parallel)) {
lk&lt;-4 # number of parameters
ln&lt;-c(59,57,59,58) # marginal sums of the parameters realized in the configuration to be tested
lNt&lt;-116 # sample size of configurations
lm0&lt;-16 # observed frequency of the configuration tested


# New algorithm
starttime=proc.time()
pHXsmallerequalM0&lt;-sum(unlist(mclapply(0:lm0,PXisM,ln,lNt,lk)))
pHXequalM0&lt;-PXisM(lm0,ln,lNt,lk)
pHlargerequalM0&lt;-sum(unlist(mclapply(lm0: min(ln),PXisM,ln,lNt,lk)))
stoptime&lt;-proc.time()
list(pHXsmallerequalM0=pHXsmallerequalM0,pHXequalM0=pHXequalM0,pHlargerequalM0=pHlargerequalM0,
timed.required=stoptime-starttime)

# End of the new algorithm
}

</code></pre>

<hr>
<h2 id='PXisMclassic'> Test according to Lindner</h2><span id='topic+PXisMclassic'></span>

<h3>Description</h3>

<p>Performs a test of significance according to Lindner - old algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PXisMclassic(m,n,Nt,k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PXisMclassic_+3A_m">m</code></td>
<td>
<p>Observed frequency of the observation tested</p>
</td></tr>
<tr><td><code id="PXisMclassic_+3A_n">n</code></td>
<td>
<p>Marginal sums of the parameters realized in the configuration to be tested (vector) </p>
</td></tr>
<tr><td><code id="PXisMclassic_+3A_nt">Nt</code></td>
<td>
<p>Sample size of configurations </p>
</td></tr>
<tr><td><code id="PXisMclassic_+3A_k">k</code></td>
<td>
<p>Number of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns p for the test according to Linder
</p>


<h3>Note</h3>

<p> The test according to Lindner requires the packages parallel. All other parts of cfa do not.
</p>


<h3>Author(s)</h3>

<p>J. Harloff &lt;oachimharloff@joachimharloff.de&gt; </p>


<h3>References</h3>

<p>Lindner, K.: Eine exakte Auswertungsmethode zur Konfigurationsfrequenzanalyse [An exact procedure for
the configural frequency analysis]. Psycholog Beitraege 26, 393?415 (1984)
</p>
<p>Harloff, Joachim, An efficient algorithm for Lindners test
(configural frequency analysis), Qual Quant DOI 10.1007/s11135-011-9499-9
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Does not work with windows since there is no parallel for it
if (require (parallel)) {

lk&lt;-4 # number of parameters
ln&lt;-c(59,57,59,58) # marginal sums of the parameters realized in the configuration to be tested
lNt&lt;-116 # sample size of configurations
lm0&lt;-16 # observed frequency of the configuration tested


# Old algorithm
starttime=proc.time()
pHXsmallerequalM0&lt;-sum(unlist(mclapply(0:lm0,PXisMclassic,ln,lNt,lk)))
pHXequalM0&lt;-PXisMclassic(lm0,ln,lNt,lk)
pHlargerequalM0&lt;-sum(unlist(mclapply(lm0: min(ln),PXisMclassic,ln,lNt,lk)))
stoptime&lt;-proc.time()
list(pHXsmallerequalM0=pHXsmallerequalM0,pHXequalM0=pHXequalM0,pHlargerequalM0=pHlargerequalM0,
timed.required=stoptime-starttime)
# End of the old algorithm
}

</code></pre>

<hr>
<h2 id='scfa'> One sample CFA</h2><span id='topic+scfa'></span>

<h3>Description</h3>

<p>Performs a configuration frequency analysis if only one set of counts exists. 
<em>This function is not designed to be called directly by the user but will only be used internally by by <code>cfa()</code>.</em> Both the simple an the multiple cfa are handled by <code>cfa()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scfa(cfg, cnt=NA, sorton="chisq", sort.descending=TRUE, format.labels=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scfa_+3A_cfg">cfg</code></td>
<td>
<p>Contains the configurations. This can be a dataframe or a matrix. The dataframe can contain numbers,
characters, factors or booleans. The matrix can consist of numbers, characters or booleans 
(factors are implicitely re-converted to numerical levels). There must be &gt;=3 columns.</p>
</td></tr>
<tr><td><code id="scfa_+3A_cnt">cnt</code></td>
<td>
<p> Contains the counts for the configuration. If it is set to NA, a count of one is assumed for every
row. This allows untabulated data to be processed. <code>cnts</code> is a vector.</p>
</td></tr>
<tr><td><code id="scfa_+3A_sorton">sorton</code></td>
<td>
<p> Determines the sorting order of the output. Can be set to <code>chisq</code>, <code>n</code>, or <code>label</code>.</p>
</td></tr>
<tr><td><code id="scfa_+3A_sort.descending">sort.descending</code></td>
<td>
<p>Sort in descending order </p>
</td></tr>
<tr><td><code id="scfa_+3A_format.labels">format.labels</code></td>
<td>
<p>Format the labels of the configuration. This makes to output wider but it will increase the
readability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function is the &quot;engine&quot; <code>cfa()</code> will use. It does the aggregation, summing up,
and will calculate chi squared. All tests of significance are left to  <code>cfa()</code> 
</p>


<h3>Value</h3>

<p> The function returns the following list:
</p>
<table role = "presentation">
<tr><td><code>labels</code></td>
<td>
<p>Configuration label</p>
</td></tr> 
<tr><td><code>n.levels</code></td>
<td>
<p>Number of levels for each configuration</p>
</td></tr>
<tr><td><code>sums</code></td>
<td>
<p>Sums for each configuration and each variable in the configuration</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Observed n of the given configuration</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>Expected n for the given configuration</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>Chi squared for each configuration</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>There are no hard-coded limits in the program so even large tables can be processed. 
</p>


<h3>Author(s)</h3>

<p>Stefan Funke &lt;s.funke@t-online.de&gt;</p>


<h3>References</h3>

<p>Krauth J., Lienert G. A. (1973, Reprint 1995) Die
Konfigurationsfrequenzanalyse (KFA) und ihre Anwendung in
Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Lautsch, E., von Weber S. (1995) Methoden und Anwendungen der Konfigurationsfrequenzanalyse 
Psychologie und Medizin, Beltz Psychologie Verlagsunion
</p>
<p>Eye, A. von (1990) Introduction to configural frequency analysis.
The search for types and anti-types in cross-classification. 
Cambride 1990 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+mcfa">mcfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# library(cfa) if not yet loaded
# Some random configurations:
configs&lt;-cbind(c("A","B")[rbinom(250,1,0.3)+1],c("C","D")[rbinom(250,1,0.1)+1],
          c("E","F")[rbinom(250,1,0.3)+1],c("G","H")[rbinom(250,1,0.1)+1])
counts&lt;-trunc(runif(250)*10)
cfa(configs,counts) 
# cfa rather than scfa!
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
