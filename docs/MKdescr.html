<!DOCTYPE html><html><head><title>Help for package MKdescr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MKdescr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MKdescr-package'>
<p>Descriptive Statistics.</p></a></li>
<li><a href='#CV'><p> Compute CV</p></a></li>
<li><a href='#fiveNS'><p> Five-Number Summaries</p></a></li>
<li><a href='#glog'><p> Compute Generalized Logarithm</p></a></li>
<li><a href='#illustrate.boxplot'><p> Illustrate Box-and-Whisker Plots</p></a></li>
<li><a href='#illustrate.quantile'><p> Illustrate Quantiles</p></a></li>
<li><a href='#IQrange'><p>The Interquartile Range</p></a></li>
<li><a href='#meanAD'><p>The Mean Absolute Deviation</p></a></li>
<li><a href='#melt.long'><p> Transform data.frame to Long Form</p></a></li>
<li><a href='#qboxplot'><p> Box Plots</p></a></li>
<li><a href='#qbxp.stats'><p> Box Plot Statistics</p></a></li>
<li><a href='#sevenNS'><p> Seven-Number Summaries</p></a></li>
<li><a href='#simCorVars'><p> Simulate correlated variables.</p></a></li>
<li><a href='#skippedMean'><p>Hyber-type Skipped Mean and SD</p></a></li>
<li><a href='#SMD'><p> Compute Standardized Mean Difference (SMD)</p></a></li>
<li><a href='#SNR'><p> Compute SNR</p></a></li>
<li><a href='#thyroid'><p> Plot TSH, fT3 and fT4 with respect to reference range.</p></a></li>
<li><a href='#transformations'><p> New Transformations for Use with ggplot2 Package</p></a></li>
<li><a href='#zscore'><p> Compute z-Scores</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Descriptive Statistics</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl <a href="https://orcid.org/0000-0001-9514-8910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, ggplot2, scales</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of standardized interquartile range (IQR), Huber-type skipped mean (Hampel (1985), &lt;<a href="https://doi.org/10.2307%2F1268758">doi:10.2307/1268758</a>&gt;), robust coefficient of variation (CV) (Arachchige et al. (2019), &lt;<a href="https://doi.org/10.48550/arXiv.1907.01110">doi:10.48550/arXiv.1907.01110</a>&gt;), robust signal to noise ratio (SNR), z-score, standardized mean difference (SMD), as well as functions that support graphical visualization such as boxplots based on quartiles (not hinges), negative logarithms and generalized logarithms for 'ggplot2' (Wickham (2016), ISBN:978-3-319-24277-4).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stamats/MKdescr">https://github.com/stamats/MKdescr</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-05 10:00:09 UTC; kohlm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-05 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MKdescr-package'>
Descriptive Statistics.
</h2><span id='topic+MKdescr-package'></span><span id='topic+MKdescr'></span>

<h3>Description</h3>

<p>Computation of standardized interquartile range (IQR), Huber-type skipped mean 
(Hampel (1985), &lt;doi:10.2307/1268758&gt;), robust coefficient of variation (CV) 
(Arachchige et al. (2019), &lt;arXiv:1907.01110&gt;), robust signal to noise ratio (SNR), 
z-score, standardized mean difference (SMD), as well as functions that support 
graphical visualization such as boxplots based on quartiles (not hinges), negative 
logarithms and generalized logarithms for 'ggplot2' (Wickham (2016), ISBN:978-3-319-24277-4).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MKdescr</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-11-08</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, graphics, ggplot2, scales</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/stamats/MKdescr</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>library(MKdescr)
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="https://www.stamats.de">https://www.stamats.de</a>
</p>
<p>Maintainer: Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>

<hr>
<h2 id='CV'> Compute CV </h2><span id='topic+CV'></span><span id='topic+medCV'></span><span id='topic+iqrCV'></span>

<h3>Description</h3>

<p>The functions compute coefficient of variation (CV) as well as two robust 
versions of the CV.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CV(x, na.rm = FALSE)
medCV(x, na.rm = FALSE, constant = 1/qnorm(0.75))
iqrCV(x, na.rm = FALSE, type = 7, constant = 2*qnorm(0.75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CV_+3A_x">x</code></td>
<td>
<p> numeric vector with positive numbers. </p>
</td></tr>
<tr><td><code id="CV_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="CV_+3A_type">type</code></td>
<td>
<p> an integer between 1 and 9 selecting one of nine quantile
algorithms; for more details see <code><a href="stats.html#topic+quantile">quantile</a></code>. </p>
</td></tr>
<tr><td><code id="CV_+3A_constant">constant</code></td>
<td>
<p> standardizing contant; see <code><a href="stats.html#topic+mad">mad</a></code>
and <code><a href="#topic+sIQR">sIQR</a></code>, respectively. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions compute the (classical) CV as well as two robust variants.
</p>
<p><code>medCV</code> uses the (standardized) MAD instead of SD and median instead of mean.
</p>
<p><code>iqrCV</code> uses the (standardized) IQR instead of SD and median instead of mean.
</p>


<h3>Value</h3>

<p>CV value.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>C.N.P.G. Arachchige, L.A. Prendergast and R.G. Staudte. Robust analogues
to the Coefficient of Variation. https://arxiv.org/abs/1907.01110.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 5% outliers
out &lt;- rbinom(100, prob = 0.05, size = 1)
sum(out)
x &lt;- (1-out)*rnorm(100, mean = 10, sd = 2) + out*25
CV(x)
medCV(x)
iqrCV(x)
</code></pre>

<hr>
<h2 id='fiveNS'> Five-Number Summaries </h2><span id='topic+fiveNS'></span>

<h3>Description</h3>

<p>Function to compute five-number summaries (minimum, 1st quartile,
median, 3rd quartile, maximum)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fiveNS(x, na.rm = TRUE, type = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fiveNS_+3A_x">x</code></td>
<td>
<p> numeric vector </p>
</td></tr>
<tr><td><code id="fiveNS_+3A_na.rm">na.rm</code></td>
<td>
<p> logical; remove <code>NA</code> before the computations. </p>
</td></tr>
<tr><td><code id="fiveNS_+3A_type">type</code></td>
<td>
<p> an integer between 1 and 9 selecting one of nine quantile
algorithms; for more details see <code><a href="stats.html#topic+quantile">quantile</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to <code><a href="stats.html#topic+fivenum">fivenum</a></code> the functions computes the
first and third quartile using function <code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length 5 containing the summary information.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+fivenum">fivenum</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
fiveNS(x)
fiveNS(x, type = 2)
fivenum(x)
</code></pre>

<hr>
<h2 id='glog'> Compute Generalized Logarithm</h2><span id='topic+glog'></span><span id='topic+glog10'></span><span id='topic+glog2'></span><span id='topic+inv.glog'></span><span id='topic+inv.glog10'></span><span id='topic+inv.glog2'></span>

<h3>Description</h3>

<p>The functions compute the generalized logarithm, which is more or less
identical to the area hyperbolic sine, and their inverse; see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glog(x, base = exp(1))
glog10(x)
glog2(x)
inv.glog(x, base = exp(1))
inv.glog10(x)
inv.glog2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glog_+3A_x">x</code></td>
<td>
<p> a numeric or complex vector.</p>
</td></tr>
<tr><td><code id="glog_+3A_base">base</code></td>
<td>
<p> a positive or a positive or complex number: the base with
respect to which logarithms are computed. Defaults to e=exp(1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes
</p>
<p style="text-align: center;"><code class="reqn">\log(x + \sqrt{x^2 + 1}) - \log(2)</code>
</p>

<p>where the first part corresponds to the area hyperbolic sine. Subtracting
log(2) makes the function asymptotically identical to the logarithm.
</p>


<h3>Value</h3>

<p>A vector of the same length as x containing the transformed values.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(log, from = -3, to = 5)
curve(glog, from = -3, to = 5, add = TRUE, col = "orange")
legend("topleft", fill = c("black", "orange"), legend = c("log", "glog"))

curve(log10(x), from = -3, to = 5)
curve(glog10(x), from = -3, to = 5, add = TRUE, col = "orange")
legend("topleft", fill = c("black", "orange"), legend = c("log10", "glog10"))

inv.glog(glog(10))
inv.glog(glog(10, base = 3), base = 3)
inv.glog10(glog10(10))
inv.glog2(glog2(10))
</code></pre>

<hr>
<h2 id='illustrate.boxplot'> Illustrate Box-and-Whisker Plots </h2><span id='topic+illustrate.boxplot'></span>

<h3>Description</h3>

<p>Function to illustrate the computation of box-and-whisker plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illustrate.boxplot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="illustrate.boxplot_+3A_x">x</code></td>
<td>
<p> numeric vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function visualizes the computation of box-and-whisker plots.
</p>


<h3>Value</h3>

<p>An invisible object of class <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>, <code><a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
illustrate.boxplot(rt(50, df = 5))
illustrate.boxplot(rnorm(50, mean = 3, sd = 2))
</code></pre>

<hr>
<h2 id='illustrate.quantile'> Illustrate Quantiles </h2><span id='topic+illustrate.quantile'></span>

<h3>Description</h3>

<p>Function to illustrate the computation of quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illustrate.quantile(x, alpha, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="illustrate.quantile_+3A_x">x</code></td>
<td>
<p> numeric vector </p>
</td></tr>
<tr><td><code id="illustrate.quantile_+3A_alpha">alpha</code></td>
<td>
<p> numeric value in the interval (0,1). </p>
</td></tr>
<tr><td><code id="illustrate.quantile_+3A_type">type</code></td>
<td>
<p> integer values between 1 and 9 selecting one or several of 
nine quantile algorithms; for more details see 
<code><a href="stats.html#topic+quantile">quantile</a></code>. If missing, all nine are 
computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function visualizes the computation of alpha-quantiles.
</p>


<h3>Value</h3>

<p>An invisible object of class <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+quantile">quantile</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
illustrate.quantile(x, alpha = 0.15)
illustrate.quantile(x, alpha = 0.5)
illustrate.quantile(x, alpha = 0.8, type = 2)
illustrate.quantile(x, alpha = 0.8, type = c(2, 7))

illustrate.quantile(x = rnorm(20), alpha = 0.95)
illustrate.quantile(x = rnorm(21), alpha = 0.95)
</code></pre>

<hr>
<h2 id='IQrange'>The Interquartile Range</h2><span id='topic+IQrange'></span><span id='topic+sIQR'></span>

<h3>Description</h3>

<p>Computes (standardized) interquartile range of the <code>x</code> values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>IQrange(x, na.rm = FALSE, type = 7)
sIQR(x, na.rm = FALSE, type = 7, constant = 2*qnorm(0.75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IQrange_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="IQrange_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="IQrange_+3A_type">type</code></td>
<td>
<p> an integer between 1 and 9 selecting one of nine quantile
algorithms; for more details see <code><a href="stats.html#topic+quantile">quantile</a></code>. </p>
</td></tr>
<tr><td><code id="IQrange_+3A_constant">constant</code></td>
<td>
<p> standardizing contant; see details below. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>IQrange</code> computes quartiles as
<code>IQR(x) = quantile(x,3/4) - quantile(x,1/4)</code>.
The function is identical to function <code><a href="stats.html#topic+IQR">IQR</a></code>. It was added
before the <code>type</code> argument was introduced to function <code><a href="stats.html#topic+IQR">IQR</a></code>
in 2010 (r53643, r53644).
</p>
<p>For normally <code class="reqn">N(m,1)</code> distributed <code class="reqn">X</code>, the expected value of
<code>IQR(X)</code> is <code>2*qnorm(3/4) = 1.3490</code>, i.e., for a normal-consistent
estimate of the standard deviation, use <code>IQR(x) / 1.349</code>. This is implemented
in function <code>sIQR</code> (standardized IQR).
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Tukey, J. W. (1977). <em>Exploratory Data Analysis.</em> Reading: Addison-Wesley.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="stats.html#topic+IQR">IQR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IQrange(rivers)

## identical to
IQR(rivers)

## other quantile algorithms
IQrange(rivers, type = 4)
IQrange(rivers, type = 5)

## standardized IQR
sIQR(rivers)

## right-skewed data distribution
sd(rivers)
mad(rivers)

## for normal data
x &lt;- rnorm(100)
sd(x)
sIQR(x)
mad(x)
</code></pre>

<hr>
<h2 id='meanAD'>The Mean Absolute Deviation</h2><span id='topic+meanAD'></span>

<h3>Description</h3>

<p>Computes (standardized) mean absolute deviation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanAD(x, na.rm = FALSE, constant = sqrt(pi/2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanAD_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="meanAD_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="meanAD_+3A_constant">constant</code></td>
<td>
<p> standardizing contant; see details below. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean absolute deviation is a consistent estimator of 
<code class="reqn">\sqrt{2/\pi}\sigma</code> for the standard deviation of
a normal distribution. Under minor deviations of the normal distributions
its asymptotic variance is smaller than that of the sample standard 
deviation (Tukey (1960)).
</p>
<p>It works well under the assumption of symmetric, where mean and median
coincide. Under the normal distribution it's about 18% more efficient
(asymptotic relative efficiency) than the median absolute deviation 
(<code>(1/qnorm(0.75))/sqrt(pi/2)</code>) and about 12% less efficient than the 
sample standard deviation (Tukey (1960)).
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Tukey, J. W. (1960). A survey of sampling from contaminated distribution.
In Olkin, I., editor, <em>Contributions to Probability and Statistics. 
Essays in Honor of H. Hotelling.</em>, pages 448-485. Stanford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+mad">mad</a></code>, <code>sIQR</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## right skewed data
## mean absolute deviation
meanAD(rivers)
## standardized IQR
sIQR(rivers)
## median absolute deviation
mad(rivers)
## sample standard deviation
sd(rivers)

## for normal data
x &lt;- rnorm(100)
sd(x)
sIQR(x)
mad(x)
meanAD(x)

## Asymptotic relative efficiency for Tukey's symmetric gross-error model
## (1-eps)*Norm(mean, sd = sigma) + eps*Norm(mean, sd = 3*sigma)
eps &lt;- seq(from = 0, to = 1, by = 0.001)
ARE &lt;- function(eps){
  0.25*((3*(1+80*eps))/((1+8*eps)^2)-1)/(pi*(1+8*eps)/(2*(1+2*eps)^2)-1)
}
plot(eps, ARE(eps), type = "l", xlab = "Proportion of gross-errors",
     ylab = "Asymptotic relative efficiency", 
     main = "ARE of mean absolute deviation w.r.t. sample standard deviation")
abline(h = 1.0, col = "red")
text(x = 0.5, y = 1.5, "Mean absolute deviation is better", col = "red", 
    cex = 1, font = 1)
## lower bound of interval
uniroot(function(x){ ARE(x)-1 }, interval = c(0, 0.002))
## upper bound of interval
uniroot(function(x){ ARE(x)-1 }, interval = c(0.5, 0.55))
## worst case
optimize(ARE, interval = c(0,1), maximum = TRUE)
</code></pre>

<hr>
<h2 id='melt.long'> Transform data.frame to Long Form </h2><span id='topic+melt.long'></span>

<h3>Description</h3>

<p>The function transforms a given data.frame form wide to long form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt.long(data, select, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt.long_+3A_data">data</code></td>
<td>
<p> data.frame that shall be transformed.</p>
</td></tr>
<tr><td><code id="melt.long_+3A_select">select</code></td>
<td>
<p> optional integer vector to select a subset of the columns of <code>data</code>.</p>
</td></tr>
<tr><td><code id="melt.long_+3A_group">group</code></td>
<td>
<p> optional vector to include an additional grouping in the output;
for more details see examples below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function transforms a given data.frame form wide to long form. This is
for example useful for plotting with ggplot2.
</p>


<h3>Value</h3>

<p>data.frame in long form.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
## some random data
test &lt;- data.frame(x = rnorm(10), y = rnorm(10), z = rnorm(10))
test.long &lt;- melt.long(test)
test.long
ggplot(test.long, aes(x = variable, y = value)) +
  geom_boxplot(aes(fill = variable))
## introducing an additional grouping variable
group &lt;- factor(rep(c("a","b"), each = 5))
test.long.gr &lt;- melt.long(test, select = 1:2, group = group)
test.long.gr
ggplot(test.long.gr, aes(x = variable, y = value, fill = group)) +
  geom_boxplot()
</code></pre>

<hr>
<h2 id='qboxplot'> Box Plots </h2><span id='topic+qboxplot'></span><span id='topic+qboxplot.default'></span><span id='topic+qboxplot.formula'></span>

<h3>Description</h3>

<p>Produce box-and-whisker plot(s) of the given (grouped) values. In contrast
to <code><a href="graphics.html#topic+boxplot">boxplot</a></code> quartiles are used instead of hinges
(which are not necessarily quartiles) the rest of the implementation is
identical to <code>boxplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qboxplot(x, ...)

## S3 method for class 'formula'
qboxplot(formula, data = NULL, ..., subset, na.action = NULL, type = 7)

## Default S3 method:
qboxplot(x, ..., range = 1.5, width = NULL, varwidth = FALSE, 
        notch = FALSE, outline = TRUE, names, plot = TRUE, 
        border = par("fg"), col = NULL, log = "", 
        pars = list(boxwex = 0.8, staplewex = 0.5, outwex = 0.5), 
        horizontal = FALSE, add = FALSE, at = NULL, type = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qboxplot_+3A_formula">formula</code></td>
<td>
<p>a formula, such as <code>y ~ grp</code>, where <code>y</code> is a
numeric vector of data values to be split into groups according to
the grouping variable <code>grp</code> (usually a factor).</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_data">data</code></td>
<td>
<p>a data.frame (or list) from which the variables in
<code>formula</code> should be taken.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used for plotting.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is to ignore missing
values in either the response or the group.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_x">x</code></td>
<td>
<p>for specifying data from which the boxplots are to be
produced. Either a numeric vector, or a single list containing such
vectors. Additional unnamed arguments specify further data
as separate vectors (each corresponding to a component boxplot).
<code><a href="base.html#topic+NA">NA</a></code>s are allowed in the data.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_...">...</code></td>
<td>
<p>For the <code>formula</code> method, named arguments to be passed to
the default method.
</p>
<p>For the default method, unnamed arguments are additional data
vectors (unless <code>x</code> is a list when they are ignored),
and named arguments are arguments and graphical parameters to be
passed to <code><a href="graphics.html#topic+bxp">bxp</a></code> in addition to the ones
given by argument <code>pars</code> (and override those in <code>pars</code>).
</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_range">range</code></td>
<td>
<p>this determines how far the plot whiskers extend out
from the box.  If <code>range</code> is positive, the whiskers extend
to the most extreme data point which is no more than
<code>range</code> times the interquartile range from the box. A value
of zero causes the whiskers to extend to the data extremes.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_width">width</code></td>
<td>
<p>a vector giving the relative widths of the boxes making
up the plot.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_varwidth">varwidth</code></td>
<td>
<p>if <code>varwidth</code> is <code>TRUE</code>, the boxes are
drawn with widths proportional to the square-roots of the number
of observations in the groups.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_notch">notch</code></td>
<td>
<p>if <code>notch</code> is <code>TRUE</code>, a notch is drawn in
each side of the boxes.  If the notches of two plots do not
overlap this is &lsquo;strong evidence&rsquo; that the two medians differ
(Chambers <em>et al.</em>, 1983, p. 62).  See <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code>
for the calculations used.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_outline">outline</code></td>
<td>
<p>if <code>outline</code> is not true, the outliers are
not drawn (as points whereas S+ uses lines).</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_names">names</code></td>
<td>
<p>group labels which will be printed under each boxplot.
Can be a character vector or an <a href="base.html#topic+expression">expression</a> (see
<a href="grDevices.html#topic+plotmath">plotmath</a>).</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_boxwex">boxwex</code></td>
<td>
<p>a scale factor to be applied to all boxes.  When there
are only a few groups, the appearance of the plot can be improved
by making the boxes narrower.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_staplewex">staplewex</code></td>
<td>
<p>staple line width expansion, proportional to box
width.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_outwex">outwex</code></td>
<td>
<p>outlier line width expansion, proportional to box
width.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> (the default) then a boxplot is
produced.  If not, the summaries which the boxplots are based on
are returned.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_border">border</code></td>
<td>
<p>an optional vector of colors for the outlines of the
boxplots.  The values in <code>border</code> are recycled if the
length of <code>border</code> is less than the number of plots.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_col">col</code></td>
<td>
<p>if <code>col</code> is non-null it is assumed to contain colors
to be used to colour the bodies of the box plots. By default they
are in the background colour.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_log">log</code></td>
<td>
<p>character indicating if x or y or both coordinates should
be plotted in log scale.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_pars">pars</code></td>
<td>
<p>a list of (potentially many) more graphical parameters,
e.g., <code>boxwex</code> or <code>outpch</code>; these are passed to
<code><a href="graphics.html#topic+bxp">bxp</a></code> (if <code>plot</code> is true); for details, see there.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_horizontal">horizontal</code></td>
<td>
<p>logical indicating if the boxplots should be
horizontal; default <code>FALSE</code> means vertical boxes.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_add">add</code></td>
<td>
<p>logical, if true <em>add</em> boxplot to current plot.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_at">at</code></td>
<td>
<p>numeric vector giving the locations where the boxplots should
be drawn, particularly when <code>add = TRUE</code>;
defaults to <code>1:n</code> where <code>n</code> is the number of boxes.</p>
</td></tr>
<tr><td><code id="qboxplot_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 9 selecting one of nine quantile
algorithms; for more details see <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code>qboxplot</code> currently has a default method
(<code>qboxplot.default</code>) and a formula interface (<code>qboxplot.formula</code>).
</p>
<p>If multiple groups are supplied either as multiple arguments or via a
formula, parallel boxplots will be plotted, in the order of the
arguments or the order of the levels of the factor (see
<code><a href="base.html#topic+factor">factor</a></code>).
</p>
<p>Missing values are ignored when forming boxplots.
</p>


<h3>Value</h3>

<p>List with the following components:
</p>
<table>
<tr><td><code>stats</code></td>
<td>
<p>a matrix, each column contains the extreme of the lower
whisker, the lower hinge, the median, the upper hinge and the
extreme of the upper whisker for one group/plot.  If all the inputs
have the same class attribute, so will this component.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a vector with the number of observations in each group.</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>a matrix where each column contains the lower and upper
extremes of the notch.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>the values of any data points which lie beyond the
extremes of the whiskers.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>a vector of the same length as <code>out</code> whose elements
indicate to which group the outlier belongs.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>a vector of names for the groups.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>
<p>Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A. (1983)
<em>Graphical Methods for Data Analysis.</em>  Wadsworth &amp; Brooks/Cole.
</p>
<p>Murrell, P. (2005) <em>R Graphics</em>. Chapman &amp; Hall/CRC Press.
</p>
<p>See also <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qbxp.stats">qbxp.stats</a></code> which does the computation,
<code><a href="graphics.html#topic+bxp">bxp</a></code> for the plotting and more examples;
and <code><a href="graphics.html#topic+stripchart">stripchart</a></code> for an alternative (with small data
sets).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## adapted examples from boxplot
op &lt;- par()

## qboxplot on a formula:
qboxplot(count ~ spray, data = InsectSprays, col = "lightgray")
# *add* notches (somewhat funny here):
qboxplot(count ~ spray, data = InsectSprays,
        notch = TRUE, add = TRUE, col = "blue")

qboxplot(decrease ~ treatment, data = OrchardSprays,
        log = "y", col = "bisque")

rb &lt;- qboxplot(decrease ~ treatment, data = OrchardSprays, col="bisque")
title("Comparing boxplot()s and non-robust mean +/- SD")

mn.t &lt;- tapply(OrchardSprays$decrease, OrchardSprays$treatment, mean)
sd.t &lt;- tapply(OrchardSprays$decrease, OrchardSprays$treatment, sd)
xi &lt;- 0.3 + seq(rb$n)
points(xi, mn.t, col = "orange", pch = 18)
arrows(xi, mn.t - sd.t, xi, mn.t + sd.t,
       code = 3, col = "pink", angle = 75, length = .1)

## boxplot on a matrix:
mat &lt;- cbind(Uni05 = (1:100)/21, Norm = rnorm(100),
             `5T` = rt(100, df = 5), Gam2 = rgamma(100, shape = 2))
qboxplot(as.data.frame(mat),
        main = "qboxplot(as.data.frame(mat), main = ...)")
par(las = 1)# all axis labels horizontal
qboxplot(as.data.frame(mat), main = "boxplot(*, horizontal = TRUE)",
        horizontal = TRUE)

## Using 'at = ' and adding boxplots -- example idea by Roger Bivand :

qboxplot(len ~ dose, data = ToothGrowth,
        boxwex = 0.25, at = 1:3 - 0.2,
        subset = supp == "VC", col = "yellow",
        main = "Guinea Pigs' Tooth Growth",
        xlab = "Vitamin C dose mg",
        ylab = "tooth length",
        xlim = c(0.5, 3.5), ylim = c(0, 35), yaxs = "i")
qboxplot(len ~ dose, data = ToothGrowth, add = TRUE,
        boxwex = 0.25, at = 1:3 + 0.2,
        subset = supp == "OJ", col = "orange")
legend(2, 9, c("Ascorbic acid", "Orange juice"),
       fill = c("yellow", "orange"))
par(op)
</code></pre>

<hr>
<h2 id='qbxp.stats'> Box Plot Statistics </h2><span id='topic+qbxp.stats'></span>

<h3>Description</h3>

<p>This functions works identical to <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code>.
It is typically called by another function to gather the statistics 
necessary for producing box plots, but may be invoked separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qbxp.stats(x, coef = 1.5, do.conf = TRUE, do.out = TRUE, type = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qbxp.stats_+3A_x">x</code></td>
<td>
<p> a numeric vector for which the boxplot will be constructed 
(<code><a href="base.html#topic+NA">NA</a></code>s and <code><a href="base.html#topic+NaN">NaN</a></code>s are allowed and omitted). </p>
</td></tr>
<tr><td><code id="qbxp.stats_+3A_coef">coef</code></td>
<td>
<p> it determines how far the plot &lsquo;whiskers&rsquo; extend out
from the box. If <code>coef</code> is positive, the whiskers extend to the
most extreme data point which is no more than <code>coef</code> times
the length of the box away from the box. A value of zero causes
the whiskers to extend to the data extremes (and no outliers be returned). </p>
</td></tr>
<tr><td><code id="qbxp.stats_+3A_do.conf">do.conf</code></td>
<td>
<p> logical; if <code>FALSE</code>, the <code>conf</code> component 
will be empty in the result. </p>
</td></tr>
<tr><td><code id="qbxp.stats_+3A_do.out">do.out</code></td>
<td>
<p> logical; if <code>FALSE</code>, <code>out</code> component will 
be empty in the result. </p>
</td></tr>
<tr><td><code id="qbxp.stats_+3A_type">type</code></td>
<td>
<p> an integer between 1 and 9 selecting one of nine quantile
algorithms; for more details see <code><a href="stats.html#topic+quantile">quantile</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The notches (if requested) extend to <code>+/-1.58 IQR/sqrt(n)</code>.
This seems to be based on the same calculations as the formula with 1.57 in
Chambers <em>et al.</em> (1983, p. 62), given in McGill <em>et al.</em>
(1978, p. 16).  They are based on asymptotic normality of the median
and roughly equal sample sizes for the two medians being compared, and
are said to be rather insensitive to the underlying distributions of
the samples.  The idea appears to be to give roughly a 95% confidence
interval for the difference in two medians.
</p>


<h3>Value</h3>

<p>List with named components as follows:
</p>
<table>
<tr><td><code>stats</code></td>
<td>
<p>a vector of length 5, containing the extreme of the
lower whisker, the first quartile, the median, the third quartile
and the extreme of the upper whisker.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of non-<code>NA</code> observations in the sample.</p>
</td></tr>
<tr><td><code>conf</code></td>
<td>
<p>the lower and upper extremes of the &lsquo;notch&rsquo;
(<code>if(do.conf)</code>). See the details.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>the values of any data points which lie beyond the
extremes of the whiskers (<code>if(do.out)</code>).</p>
</td></tr>
</table>
<p>Note that <code>$stats</code> and <code>$conf</code> are sorted in <em>in</em>creasing
order, unlike S, and that <code>$n</code> and <code>$out</code> include any
<code>+- Inf</code> values.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Tukey, J. W. (1977) <em>Exploratory Data Analysis.</em> Section 2C.
</p>
<p>McGill, R., Tukey, J. W. and Larsen, W. A. (1978) Variations of box
plots. <em>The American Statistician</em> <b>32</b>, 12&ndash;16.
</p>
<p>Velleman, P. F. and Hoaglin, D. C. (1981) <em>Applications, Basics
and Computing of Exploratory Data Analysis.</em>  Duxbury Press.
</p>
<p>Emerson, J. D and Strenio, J. (1983). Boxplots and batch comparison.
Chapter 3 of <em>Understanding Robust and Exploratory Data
Analysis</em>, eds. D. C. Hoaglin, F. Mosteller and J. W. Tukey.  Wiley.
</p>
<p>Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A. (1983)
<em>Graphical Methods for Data Analysis.</em>  Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## adapted example from boxplot.stats
x &lt;- c(1:100, 1000)
(b1 &lt;- qbxp.stats(x))
(b2 &lt;- qbxp.stats(x, do.conf=FALSE, do.out=FALSE))
stopifnot(b1$stats == b2$stats) # do.out=F is still robust
qbxp.stats(x, coef = 3, do.conf=FALSE)
## no outlier treatment:
qbxp.stats(x, coef = 0)

qbxp.stats(c(x, NA)) # slight change : n is 101
(r &lt;- qbxp.stats(c(x, -1:1/0)))
stopifnot(r$out == c(1000, -Inf, Inf))
</code></pre>

<hr>
<h2 id='sevenNS'> Seven-Number Summaries </h2><span id='topic+sevenNS'></span>

<h3>Description</h3>

<p>Function to compute seven-number summaries (minimum, 1st octile, 
1st quartile, median, 3rd quartile, 7th octile, maximum)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sevenNS(x, na.rm = TRUE, type = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sevenNS_+3A_x">x</code></td>
<td>
<p> numeric vector </p>
</td></tr>
<tr><td><code id="sevenNS_+3A_na.rm">na.rm</code></td>
<td>
<p> logical; remove <code>NA</code> before the computations. </p>
</td></tr>
<tr><td><code id="sevenNS_+3A_type">type</code></td>
<td>
<p> an integer between 1 and 9 selecting one of nine quantile
algorithms; for more details see <code><a href="stats.html#topic+quantile">quantile</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to Tukey (1977) who proposes hinges and eighths, 
we use function <code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length 7 containing the summary information.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p> Tukey, J.W. (1977). Exploratory Data Analysis. Section 2G. </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+fivenum">fivenum</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
sevenNS(x)
sevenNS(x, type = 2)
</code></pre>

<hr>
<h2 id='simCorVars'> Simulate correlated variables. </h2><span id='topic+simCorVars'></span>

<h3>Description</h3>

<p>The function simulates a pair of correlated variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simCorVars(n, r, mu1 = 0, mu2 = 0, sd1 = 1, sd2 = 1, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simCorVars_+3A_n">n</code></td>
<td>
<p> integer: sample size. </p>
</td></tr>
<tr><td><code id="simCorVars_+3A_r">r</code></td>
<td>
<p> numeric: correlation.</p>
</td></tr>
<tr><td><code id="simCorVars_+3A_mu1">mu1</code></td>
<td>
<p> numeric: mean of first variable.</p>
</td></tr>
<tr><td><code id="simCorVars_+3A_mu2">mu2</code></td>
<td>
<p> numeric: mean of second variable.</p>
</td></tr>
<tr><td><code id="simCorVars_+3A_sd1">sd1</code></td>
<td>
<p> numeric: SD of first variable.</p>
</td></tr>
<tr><td><code id="simCorVars_+3A_sd2">sd2</code></td>
<td>
<p> numeric: SD of second variable.</p>
</td></tr>
<tr><td><code id="simCorVars_+3A_plot">plot</code></td>
<td>
<p>logical: generate scatter plot of the variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is mainly for teaching purposes and simulates <code>n</code> observations
from a pair of normal distributed variables with correlation <code>r</code>.
</p>
<p>By specifying <code>plot = TRUE</code> a scatter plot of the data is generated.
</p>


<h3>Value</h3>

<p>data.frame with entries <code>Var1</code> and <code>Var2</code>
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
res &lt;- simCorVars(n = 100, r = 0.8)
cor(res$Var1, res$Var2)
colMeans(res)
apply(res, 2, sd)
set.seed(123)
res &lt;- simCorVars(n = 100, r = 0.8, mu1 = -1, mu2 = 1, sd1 = 2, sd2 = 0.5)
cor(res$Var1, res$Var2)
colMeans(res)
apply(res, 2, sd)
</code></pre>

<hr>
<h2 id='skippedMean'>Hyber-type Skipped Mean and SD</h2><span id='topic+skippedMean'></span><span id='topic+skippedSD'></span>

<h3>Description</h3>

<p>Computes Huper-type Skipped Mean and SD.</p>


<h3>Usage</h3>

<pre><code class='language-R'>skippedMean(x, na.rm = FALSE, constant = 3.0)
skippedSD(x, na.rm = FALSE, constant = 3.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skippedMean_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="skippedMean_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="skippedMean_+3A_constant">constant</code></td>
<td>
<p> multiplier for outlier identification; see details below. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Huber-type skipped mean and is very close to estimator X42 of Hampel 
(1985), which uses 3.03 x MAD. Quoting Hampel et al. (1986), p. 69, the X42 
estimator is &quot;frequently quite reasonable, according to present preliminary 
knowledge&quot;.
</p>
<p>For computing the Huber-type skipped mean, one first computes median and
MAD. In the next step, all observations outside the interval 
[median - constant x MAD, median + constant x MAD] are removed and 
arithmetic mean and sample standard deviation are computed on the remaining data.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Hampel, F.R. (1985). The breakdown points of the mean combined with some 
rejection rules. <em>Technometrics</em>, <b>27</b>: 95-107.
</p>
<p>Hampel, F.R., Ronchetti, E.M., Rousseeuw, P.J., Stahel, W.A (1986). 
<em>Robust statistics. The approach based on influence functions.</em> 
New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+median">median</a></code>, 
<code><a href="stats.html#topic+mad">mad</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normal data
x &lt;- rnorm(100)
mean(x)
median(x)
skippedMean(x)

sd(x)
mad(x)
skippedSD(x)

## Tukey's gross error model
## (1-eps)*Norm(mean, sd = sigma) + eps*Norm(mean, sd = 3*sigma)
ind &lt;- rbinom(100, size = 1, prob = 0.1)
x.err &lt;- (1-ind)*x + ind*rnorm(100, sd = 3)
mean(x.err)
median(x.err)
skippedMean(x.err)

sd(x.err)
mad(x.err)
skippedSD(x.err)
</code></pre>

<hr>
<h2 id='SMD'> Compute Standardized Mean Difference (SMD)</h2><span id='topic+SMD'></span>

<h3>Description</h3>

<p>The function computes the standardized mean difference, where a bias correction
can be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMD(x, y, bias.cor = TRUE, var.equal = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SMD_+3A_x">x</code></td>
<td>
<p> numeric vector, data of group 1. </p>
</td></tr>
<tr><td><code id="SMD_+3A_y">y</code></td>
<td>
<p> numeric vector, data of group 2. </p>
</td></tr>
<tr><td><code id="SMD_+3A_bias.cor">bias.cor</code></td>
<td>
<p>a logical variable indicating whether a bias correction should
be performed.</p>
</td></tr>
<tr><td><code id="SMD_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the two variances 
as being equal. If <code>TRUE</code> then the pooled variance is used to estimate 
the variance otherwise the Welch-Satterthwaite approximation is used.</p>
</td></tr>
<tr><td><code id="SMD_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function compute the (bias-corrected) standardized mean difference. 
</p>
<p>If <code>bias.cor = FALSE</code> and <code>var.equal = TRUE</code>, the result corresponds 
to Cohen's d (Cohen (1988)).
</p>
<p>If <code>bias.cor = TRUE</code> and <code>var.equal = TRUE</code>, the result corresponds to 
Hedges' g (Hedges (1981)).
</p>
<p>If <code>bias.cor = FALSE</code> and <code>var.equal = FALSE</code>, the result is closely
related to the test statistic of Welch's t test (Aoki (2020)).
</p>
<p>If <code>bias.cor = TRUE</code> and <code>var.equal = FALSE</code>, the result corresponds to 
Aoki's e (Aoki (2020)) which incorporates a Welch-Satterthwaite approximation 
in combination with a bias correction.
</p>


<h3>Value</h3>

<p>SMD value.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Aoki, S. (2020). Effect sizes of the differences between means without assuming 
variance equality and between a mean and a constant. <em>Heliyon</em>, <b>6</b>(1), e03306.
</p>
<p>Cohen, J. (1988). Statistical Power Analysis for the Behavioral Sciences. 
Routledge. ISBN 978-1-134-74270-7.
</p>
<p>Hedges, L. V. (1981). Distribution theory for Glass's estimator of effectsize 
and related estimators. <em>Journal of Educational Statistics</em> <b>6</b>, 107-128.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 200
x &lt;- rnorm(n1)
n2 &lt;- 300
y &lt;- rnorm(n2, mean = 3, sd = 2)
## true value
(0-3)/sqrt((1 + n1/n2*2^2)/(n1/n2+1))
## estimates
## Aoki's e
SMD(x, y)
## Hedges' g
SMD(x, y, var.equal = TRUE)
## standardized test statistic of Welch's t-test
SMD(x, y, bias.cor = FALSE)
## Cohen's d
SMD(x, y, bias.cor = FALSE, var.equal = TRUE)

## Example from Aoki (2020)
SMD(0:4, c(0, 0, 1, 2, 2))
SMD(0:4, c(0, 0, 1, 2, 2), var.equal = TRUE)
SMD(0:4, c(0, 0, 1, 2, 2), bias.cor = FALSE)
SMD(0:4, c(0, 0, 1, 2, 2), bias.cor = FALSE, var.equal = TRUE)
</code></pre>

<hr>
<h2 id='SNR'> Compute SNR </h2><span id='topic+SNR'></span><span id='topic+medSNR'></span><span id='topic+iqrSNR'></span>

<h3>Description</h3>

<p>The functions compute the signal to noise ration (SNR) as well as two robust 
versions of the SNR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SNR(x, na.rm = FALSE)
medSNR(x, na.rm = FALSE, constant = 1/qnorm(0.75))
iqrSNR(x, na.rm = FALSE, type = 7, constant = 2*qnorm(0.75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNR_+3A_x">x</code></td>
<td>
<p> numeric vector. </p>
</td></tr>
<tr><td><code id="SNR_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="SNR_+3A_type">type</code></td>
<td>
<p> an integer between 1 and 9 selecting one of nine quantile
algorithms; for more details see <code><a href="stats.html#topic+quantile">quantile</a></code>. </p>
</td></tr>
<tr><td><code id="SNR_+3A_constant">constant</code></td>
<td>
<p> standardizing contant; see <code><a href="stats.html#topic+mad">mad</a></code>
and <code><a href="#topic+sIQR">sIQR</a></code>, respectively. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions compute the (classical) SNRas well as two robust variants.
</p>
<p><code>medSNR</code> uses the (standardized) MAD instead of SD and median instead of mean.
</p>
<p><code>iqrSNR</code> uses the (standardized) IQR instead of SD and median instead of mean.
</p>


<h3>Value</h3>

<p>SNR value.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>C.N.P.G. Arachchige, L.A. Prendergast and R.G. Staudte. Robust analogues
to the Coefficient of Variation. https://arxiv.org/abs/1907.01110.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 5% outliers
out &lt;- rbinom(100, prob = 0.05, size = 1)
sum(out)
x &lt;- (1-out)*rnorm(100, mean = 10, sd = 2) + out*25
SNR(x)
medSNR(x)
iqrSNR(x)
</code></pre>

<hr>
<h2 id='thyroid'> Plot TSH, fT3 and fT4 with respect to reference range. </h2><span id='topic+thyroid'></span>

<h3>Description</h3>

<p>The function computes and plots TSH, fT3 and fT4 values with respect to
the provided reference range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thyroid(TSH, fT3, fT4, TSHref, fT3ref, fT4ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thyroid_+3A_tsh">TSH</code></td>
<td>
<p> numeric vector of length 1: measured TSH concentration.</p>
</td></tr>
<tr><td><code id="thyroid_+3A_ft3">fT3</code></td>
<td>
<p> numeric vector of length 1: measured fT3 concentration.</p>
</td></tr>
<tr><td><code id="thyroid_+3A_ft4">fT4</code></td>
<td>
<p> numeric vector of length 1: measured fT4 concentration.</p>
</td></tr>
<tr><td><code id="thyroid_+3A_tshref">TSHref</code></td>
<td>
<p> numeric vector of length 2: reference range TSH.</p>
</td></tr>
<tr><td><code id="thyroid_+3A_ft3ref">fT3ref</code></td>
<td>
<p> numeric vector of length 2: reference range fT3.</p>
</td></tr>
<tr><td><code id="thyroid_+3A_ft4ref">fT4ref</code></td>
<td>
<p> numeric vector of length 2: reference range fT4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple function that computes the relative values of the measured values
with respect to the provided reference range and visualizes the values
using a barplot. Relative values between 40% and 60% are marked as O.K..
</p>


<h3>Value</h3>

<p>Invisible <code>data.frame</code> with the relative values.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>thyroid(TSH = 1.5, fT3 = 2.5, fT4 = 14, TSHref = c(0.2, 3.0),
        fT3ref = c(1.7, 4.2), fT4ref = c(7.6, 15.0))
</code></pre>

<hr>
<h2 id='transformations'> New Transformations for Use with ggplot2 Package</h2><span id='topic+glog_trans'></span><span id='topic+glog10_trans'></span><span id='topic+glog2_trans'></span><span id='topic+scale_y_glog'></span><span id='topic+scale_x_glog'></span><span id='topic+scale_y_glog10'></span><span id='topic+scale_x_glog10'></span><span id='topic+scale_y_glog2'></span><span id='topic+scale_x_glog2'></span><span id='topic+scale_y_log'></span><span id='topic+scale_x_log'></span><span id='topic+scale_y_log2'></span><span id='topic+scale_x_log2'></span><span id='topic+neglog_breaks'></span><span id='topic+neglog_trans'></span><span id='topic+neglog10_trans'></span><span id='topic+neglog2_trans'></span><span id='topic+scale_y_neglog'></span><span id='topic+scale_x_neglog'></span><span id='topic+scale_y_neglog10'></span><span id='topic+scale_x_neglog10'></span><span id='topic+scale_y_neglog2'></span><span id='topic+scale_x_neglog2'></span>

<h3>Description</h3>

<p>The functions generate new transformations for the generalized logarithm and
the negative logarithm that can be used for transforming the axes in ggplot2
plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glog_trans(base = exp(1))
glog10_trans()
glog2_trans()
scale_y_glog(...)
scale_x_glog(...)
scale_y_glog10(...)
scale_x_glog10(...)
scale_y_glog2(...)
scale_x_glog2(...)
scale_y_log(...)
scale_x_log(...)
scale_y_log2(...)
scale_x_log2(...)
neglog_breaks(n = 5, base = 10)
neglog_trans(base = exp(1))
neglog10_trans()
neglog2_trans()
scale_y_neglog(...)
scale_x_neglog(...)
scale_y_neglog10(...)
scale_x_neglog10(...)
scale_y_neglog2(...)
scale_x_neglog2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformations_+3A_base">base</code></td>
<td>
<p> a positive or a positive or complex number: the base with
respect to which generalized and negative logarithms are computed.
Defaults to e=exp(1).</p>
</td></tr>
<tr><td><code id="transformations_+3A_...">...</code></td>
<td>
<p> Arguments passed on to scale_(x|y)_continuous.</p>
</td></tr>
<tr><td><code id="transformations_+3A_n">n</code></td>
<td>
<p> desired number of breaks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions can be used to transform axes in ggplot2 plots. The implementation
is analogous to e.g. <code>scale_y_log10</code>.
</p>
<p>The negative logarithm is for instance of use in case of p values (e.g.
volcano plots),
</p>
<p>The functions were adapted from packages scales and ggplot2.
</p>


<h3>Value</h3>

<p>A transformation.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>H. Wickham. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York, 2016.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+scale_continuous">scale_continuous</a></code>, <code><a href="scales.html#topic+log_trans">log_trans</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
data(mpg)
p1 &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()
p1
p1 + scale_x_log10()
p1 + scale_x_glog10()
p1 + scale_y_log10()
p1 + scale_y_glog10()

## A volcano plot
x &lt;- matrix(rnorm(1000, mean = 10), nrow = 10)
g1 &lt;- rep("control", 10)
y1 &lt;- matrix(rnorm(500, mean = 11.25), nrow = 10)
y2 &lt;- matrix(rnorm(500, mean = 9.75), nrow = 10)
g2 &lt;- rep("treatment", 10)
group &lt;- factor(c(g1, g2))
Data &lt;- rbind(x, cbind(y1, y2))
pvals &lt;- apply(Data, 2, function(x, group) t.test(x ~ group)$p.value,
               group = group)
## compute log-fold change
logfc &lt;- function(x, group){
  res &lt;- tapply(x, group, mean)
  log2(res[1]/res[2])
}
lfcs &lt;- apply(Data, 2, logfc, group = group)
ps &lt;- data.frame(pvals = pvals, logfc = lfcs)
ggplot(ps, aes(x = logfc, y = pvals)) + geom_point() +
    geom_hline(yintercept = 0.05) + scale_y_neglog10() +
    geom_vline(xintercept = c(-0.1, 0.1)) + xlab("log-fold change") +
    ylab("-log10(p value)") + ggtitle("A Volcano Plot")
</code></pre>

<hr>
<h2 id='zscore'> Compute z-Scores </h2><span id='topic+zscore'></span><span id='topic+medZscore'></span><span id='topic+iqrZscore'></span>

<h3>Description</h3>

<p>The functions compute the classical z-score as well as two robust versions of 
z-scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zscore(x, na.rm = FALSE)
medZscore(x, na.rm = FALSE, constant = 1/qnorm(0.75))
iqrZscore(x, na.rm = FALSE, type = 7, constant = 2*qnorm(0.75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zscore_+3A_x">x</code></td>
<td>
<p> numeric vector with positive numbers. </p>
</td></tr>
<tr><td><code id="zscore_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="zscore_+3A_type">type</code></td>
<td>
<p> an integer between 1 and 9 selecting one of nine quantile
algorithms; for more details see <code><a href="stats.html#topic+quantile">quantile</a></code>. </p>
</td></tr>
<tr><td><code id="zscore_+3A_constant">constant</code></td>
<td>
<p> standardizing contant; see <code><a href="stats.html#topic+mad">mad</a></code>
and <code><a href="#topic+sIQR">sIQR</a></code>, respectively. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions compute the (classical) zscore as well as two robust variants.
</p>
<p><code>medZscore</code> uses the (standardized) MAD instead of SD and median instead of mean.
</p>
<p><code>iqrZscore</code> uses the (standardized) IQR instead of SD and median instead of mean.
</p>


<h3>Value</h3>

<p>z-score.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## 10% outliers
out &lt;- rbinom(100, prob = 0.1, size = 1)
sum(out)
x &lt;- (1-out)*rnorm(100, mean = 10, sd = 2) + out*25
z &lt;- zscore(x)
z.med &lt;- medZscore(x)
z.iqr &lt;- iqrZscore(x)
## mean without outliers (should by close to 0)
mean(z[!out])
mean(z.med[!out])
mean(z.iqr[!out])
## sd without outliers (should by close to 1)
sd(z[!out])
sd(z.med[!out])
sd(z.iqr[!out])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
