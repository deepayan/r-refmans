<!DOCTYPE html><html lang="en"><head><title>Help for package RCAL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RCAL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RCAL-package'><p>RCAL: Regularized calibrated estimation</p></a></li>
<li><a href='#ate.aipw'><p>Augmented inverse probability weighted estimation of population means</p></a></li>
<li><a href='#ate.ipw'><p>Inverse probability weighted estimation of average treatment effects</p></a></li>
<li><a href='#ate.nreg'><p>Model-assisted inference for average treatment effects without regularization</p></a></li>
<li><a href='#ate.regu.cv'><p>Model-assisted inference for average treatment effects based on cross validation</p></a></li>
<li><a href='#ate.regu.path'><p>Model-assisted inference for average treatment effects along regularization paths</p></a></li>
<li><a href='#glm.nreg'><p>Non-regularied M-estimation for fitting generalized linear models</p></a></li>
<li><a href='#glm.regu'><p>Regularied M-estimation for fitting generalized linear models with a fixed tuning parameter</p></a></li>
<li><a href='#glm.regu.cv'><p>Regularied M-estimation for fitting generalized linear models based on cross validation</p></a></li>
<li><a href='#glm.regu.path'><p>Regularied M-estimation for fitting generalized linear models along a regularization path</p></a></li>
<li><a href='#late.aipw'><p>Augmented inverse probability weighted estimation of local average treatment effects</p></a></li>
<li><a href='#late.nreg'><p>Model-assisted inference for local average treatment effects without regularization</p></a></li>
<li><a href='#late.regu.cv'><p>Model-assisted inference for local average treatment effects (LATEs) with instrumental variables based on cross validation</p></a></li>
<li><a href='#late.regu.path'><p>Model-assisted inference for local average treatment effects along regularization paths</p></a></li>
<li><a href='#mn.aipw'><p>Augmented inverse probability weighted estimation of population means</p></a></li>
<li><a href='#mn.ipw'><p>Inverse probability weighted estimation of population means</p></a></li>
<li><a href='#mn.nreg'><p>Model-assisted inference for population means without regularization</p></a></li>
<li><a href='#mn.regu.cv'><p>Model-assisted inference for population means based on cross validation</p></a></li>
<li><a href='#mn.regu.path'><p>Model-assisted inference for population means along a regularization path</p></a></li>
<li><a href='#simu.data'><p>Simulated data</p></a></li>
<li><a href='#simu.iv.data'><p>Simulated instrumental variable data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Regularized Calibrated Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhiqiang Tan, Baoluo Sun</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhiqiang Tan &lt;ztan@stat.rutgers.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.rutgers.edu/~ztan">http://www.stat.rutgers.edu/~ztan</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Regularized calibrated estimation for causal inference and missing-data problems with high-dimensional data, based on Tan (2020a) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasz059">doi:10.1093/biomet/asz059</a>&gt;, Tan (2020b) &lt;<a href="https://doi.org/10.1214%2F19-AOS1824">doi:10.1214/19-AOS1824</a>&gt; and Sun and Tan (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2009.09286">doi:10.48550/arXiv.2009.09286</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), trust</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-29 09:38:04 UTC; BaoLuo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-05 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RCAL-package'>RCAL: Regularized calibrated estimation</h2><span id='topic+RCAL-package'></span><span id='topic+RCAL'></span>

<h3>Description</h3>

<p>Regularized calibrated estimation for causal inference and missing-data problems with high-dimensional data.
</p>


<h3>Details</h3>

<p>The R package <code>RCAL</code> - version 2.0 can be used for two main tasks:
</p>

<ul>
<li><p> to estimate the mean of an outcome in the presence of missing data,
</p>
</li>
<li><p> to estimate the average treatment effects (ATE) and local average treatment effects (LATE) in causal inference.
</p>
</li></ul>

<p>There are 3 high-level functions provided for the first task:
</p>

<ul>
<li> <p><code>mn.nreg</code>: inference using non-regularized calibrated estimation,
</p>
</li>
<li> <p><code>mn.regu.cv</code>: inference using regularized calibrated estimation based on cross validation,
</p>
</li>
<li> <p><code>mn.regu.path</code>: inference using regularized calibrated estimation along a regularization path. 
</p>
</li></ul>

<p>The first function <code>mn.nreg</code> is appropriate only in relatively low-dimensional settings,
whereas the functions <code>mn.regu.cv</code> and <code>mn.regu.path</code> are designed to deal with high-dimensional data (namely, 
the number of covariates close to or greater than the sample size). 
In parallel, there are 3 functions for estimating the average treatment effect in the second task, <code>ate.nreg</code>, <code>ate.regu.cv</code>, and <code>ate.regu.path</code>.
These functions can also be used to perform inference for the average treatment effects on the treated or on the untreated.
Currently, the treatment is assumed to be binary (i.e., untreated or treated). There are also 3 functions for estimating the local average treatment effect using instrumental variables, 
<code>late.nreg</code>, <code>late.regu.cv</code>, and <code>late.regu.path</code>. Currently both the treatment and instrumental variable are assumed to be binary. Extensions to multi-valued treatments and instrumental variables will be incorporated in later versions. 
</p>
<p>The package also provides lower-level functions, including <code>glm.nreg</code> to implement non-regularized M-estimation and <code>glm.regu</code> to 
implement Lasso regularized M-estimation for fitting generalized linear models currently with continuous or binary outcomes. 
The latter function <code>glm.regu</code> uses an active-set descent algorithm, which enjoys a finite termination property 
for solving least-squares Lasso problems. 
</p>
<p>See the the vignettes for more details.
</p>

<hr>
<h2 id='ate.aipw'>Augmented inverse probability weighted estimation of population means</h2><span id='topic+ate.aipw'></span>

<h3>Description</h3>

<p>This function implements augmented inverse probability weighted (IPW) estimation of average treatment effects (ATEs),
provided both fitted propensity scores and fitted values from outcome regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ate.aipw(y, tr, mfp, mfo, off = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ate.aipw_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="ate.aipw_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="ate.aipw_+3A_mfp">mfp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted propensity scores for untreated (first column) and treated (second column).</p>
</td></tr>
<tr><td><code id="ate.aipw_+3A_mfo">mfo</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted values from outcome regression, for untreated (first column) and treated (second column).</p>
</td></tr>
<tr><td><code id="ate.aipw_+3A_off">off</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of offset values (e.g., the true values in simulations) used to calculate the z-statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>one</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of direct IPW estimates of 1.</p>
</td></tr>
<tr><td><code>ipw</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of ratio IPW estimates of means.</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of outcome regression estimates of means.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of augmented IPW estimates of means.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The estimated variances associated with the augmented IPW estimates of means.</p>
</td></tr>
<tr><td><code>ze</code></td>
<td>
<p>The z-statistics for the augmented IPW estimates of means, compared to <code>off</code>.</p>
</td></tr>
<tr><td><code>diff</code></td>
<td>
<p>The augmented IPW estimate of ATE.</p>
</td></tr>
<tr><td><code>diff.var</code></td>
<td>
<p>The estimated variance associated with the augmented IPW estimate of ATE.</p>
</td></tr>
<tr><td><code>diff.ze</code></td>
<td>
<p>The z-statistic for the augmented IPW estimate of ATE.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>

<hr>
<h2 id='ate.ipw'>Inverse probability weighted estimation of average treatment effects</h2><span id='topic+ate.ipw'></span>

<h3>Description</h3>

<p>This function implements inverse probability weighted (IPW) estimation of average treatment effects (ATEs),
provided fitted propensity scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ate.ipw(y, tr, mfp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ate.ipw_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="ate.ipw_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="ate.ipw_+3A_mfp">mfp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted propensity scores for untreated (first column) and treated (second column).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>one</code></td>
<td>
<p>The direct IPW estimates of 1.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>The ratio IPW estimates of means.</p>
</td></tr>
<tr><td><code>diff</code></td>
<td>
<p>The ratio IPW estimate of ATE.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>

<hr>
<h2 id='ate.nreg'>Model-assisted inference for average treatment effects without regularization</h2><span id='topic+ate.nreg'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for average treatment effects,
using non-regularized calibrated estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ate.nreg(y, tr, x, ploss = "cal", yloss = "gaus", off = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ate.nreg_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="ate.nreg_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="ate.nreg_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, used in both propensity score and outcome regression models.</p>
</td></tr>
<tr><td><code id="ate.nreg_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in propensity score estimation (either &quot;ml&quot; or &quot;cal&quot;).</p>
</td></tr>
<tr><td><code id="ate.nreg_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="ate.nreg_+3A_off">off</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of offset values (e.g., the true values in simulations) used to calculate the z-statistics from augmented IPW estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For calibrated estimation, two sets of propensity scores are separately estimated for the untreated and treated as discussed in Tan (2020a, 2020b).
See also <strong>Details</strong> for <code><a href="#topic+mn.nreg">mn.nreg</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ps</code></td>
<td>
<p>A list containing the results from fitting the propensity score model by <code><a href="#topic+glm.nreg">glm.nreg</a></code>.</p>
</td></tr>
<tr><td><code>mfp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted propensity scores for untreated (first column) and treated (second column).</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list containing the results from fitting the outcome regression model by <code><a href="#topic+glm.nreg">glm.nreg</a></code>.</p>
</td></tr>
<tr><td><code>mfo</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted values from outcome regression, for untreated (first column) and treated (second column).</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+ate.aipw">ate.aipw</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

# include only 10 covariates
x2 &lt;- x[,1:10]

ate.cal &lt;- ate.nreg(y, tr, x2, ploss="cal", yloss="gaus")
matrix(unlist(ate.cal$est), ncol=2, byrow=TRUE,
dimnames=list(c("one", "ipw", "or", "est", "var", "ze", 
"diff.est", "diff.var", "diff.ze"), c("untreated", "treated")))

</code></pre>

<hr>
<h2 id='ate.regu.cv'>Model-assisted inference for average treatment effects based on cross validation</h2><span id='topic+ate.regu.cv'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for average treatment effects,
using regularized calibrated estimation based on cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ate.regu.cv(fold, nrho = NULL, rho.seq = NULL, y, tr, x, ploss = "cal",
  yloss = "gaus", off = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ate.regu.cv_+3A_fold">fold</code></td>
<td>
<p>A vector of length 2 giving the fold numbers for cross validation in propensity score estimation and outcome regression respectively.</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_nrho">nrho</code></td>
<td>
<p>A vector of length 2 giving the numbers of tuning parameters searched in cross validation.</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_rho.seq">rho.seq</code></td>
<td>
<p>A list of two vectors giving the tuning parameters in propensity score estimation (first vector) and outcome regression (second vector).</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, used in both propensity score and outcome regression models.</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in propensity score estimation (either &quot;ml&quot; or &quot;cal&quot;).</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_off">off</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of offset values (e.g., the true values in simulations) used to calculate the z-statistics from augmented IPW estimation.</p>
</td></tr>
<tr><td><code id="ate.regu.cv_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For calibrated estimation, two sets of propensity scores are separately estimated for the untreated and treated as discussed in Tan (2020a, 2020b).
See also <strong>Details</strong> for <code><a href="#topic+mn.regu.cv">mn.regu.cv</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ps</code></td>
<td>
<p>A list containing the results from fitting the propensity score model by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
<tr><td><code>mfp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted propensity scores for untreated (first column) and treated (second column).</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list containing the results from fitting the outcome regression model by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
<tr><td><code>mfo</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted values from outcome regression, for untreated (first column) and treated (second column).</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+ate.aipw">ate.aipw</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

ate.cv.rcal &lt;- ate.regu.cv(fold=5*c(1,1), nrho=(1+10)*c(1,1), rho.seq=NULL, y, tr, x, 
                           ploss="cal", yloss="gaus")

matrix(unlist(ate.cv.rcal$est), ncol=2, byrow=TRUE, 
dimnames=list(c("one", "ipw", "or", "est", "var", "ze", 
"diff.est", "diff.var", "diff.ze"), c("untreated", "treated")))


</code></pre>

<hr>
<h2 id='ate.regu.path'>Model-assisted inference for average treatment effects along regularization paths</h2><span id='topic+ate.regu.path'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for average treatment effects,
using regularized calibrated estimation along regularization paths for propensity score (PS) estimation 
while based on cross validation for outcome regression (OR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ate.regu.path(fold, nrho = NULL, rho.seq = NULL, y, tr, x, ploss = "cal",
  yloss = "gaus", off = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ate.regu.path_+3A_fold">fold</code></td>
<td>
<p>A vector of length 2, with the second component giving the fold number for cross validation in outcome regression. The first component is not used.</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_nrho">nrho</code></td>
<td>
<p>A vector of length 2 giving the number of tuning parameters in a regularization path for PS estimation and that in cross validation for OR.</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_rho.seq">rho.seq</code></td>
<td>
<p>A list of two vectors giving the tuning parameters for propensity score estimation (first vector) and outcome regression (second vector).</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, used in both propensity score and outcome regression models.</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in propensity score estimation (either &quot;ml&quot; or &quot;cal&quot;).</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_off">off</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of offset values (e.g., the true values in simulations) used to calculate the z-statistics from augmented IPW estimation.</p>
</td></tr>
<tr><td><code id="ate.regu.path_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code> and <code><a href="#topic+glm.regu.path">glm.regu.path</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <strong>Details</strong> for <code><a href="#topic+ate.regu.cv">ate.regu.cv</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ps</code></td>
<td>
<p>A list of 2 objects, giving the results from fitting the propensity score model by <code><a href="#topic+glm.regu.path">glm.regu.path</a></code> for untreated (first) and treated (second).</p>
</td></tr>
<tr><td><code>mfp</code></td>
<td>
<p>A list of 2 matrices of fitted propensity scores, along the PS regularization path, for untreated (first matrix) and treated (second matrix).</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list of 2 lists of objects for untreated (first) and treated (second), where each object gives 
the results from fitting the outcome regression model by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code> for a PS tuning parameter.</p>
</td></tr>
<tr><td><code>mfo</code></td>
<td>
<p>A list of 2 matrices of fitted values from outcome regression based on cross validation, along the PS regularization path, 
for untreated (first matrix) and treated (second matrix).</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+ate.aipw">ate.aipw</a></code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>A vector of tuning parameters leading to converged results in propensity score estimation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

ate.path.rcal &lt;- ate.regu.path(fold=5*c(0,1), nrho=(1+10)*c(1,1), rho.seq=NULL, y, tr, x, 
                               ploss="cal", yloss="gaus")
ate.path.rcal$est


</code></pre>

<hr>
<h2 id='glm.nreg'>Non-regularied M-estimation for fitting generalized linear models</h2><span id='topic+glm.nreg'></span>

<h3>Description</h3>

<p>This function implements non-regularizd M-estimation for fitting generalized linear models with continuous or binary responses, including maximum likelihood, 
calibrated estimation, and covariate-balancing estimation in the latter case of fitting propensity score models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.nreg(y, x, iw = NULL, loss = "cal", init = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.nreg_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> response vector.</p>
</td></tr>
<tr><td><code id="glm.nreg_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, excluding a constant.</p>
</td></tr>
<tr><td><code id="glm.nreg_+3A_iw">iw</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> weight vector.</p>
</td></tr>
<tr><td><code id="glm.nreg_+3A_loss">loss</code></td>
<td>
<p>A loss function used, which can be specified as &quot;gaus&quot; for continuous responses, or &quot;ml&quot;, &quot;cal&quot;, or &quot;bal&quot; for binary responses.</p>
</td></tr>
<tr><td><code id="glm.nreg_+3A_init">init</code></td>
<td>
<p>A <code class="reqn">(p+1)</code> x <code class="reqn">1</code> vector of initial values (the intercept and coefficients).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Least squares estimation is implemented by calling <code>lm</code> for continuous responses (<code>loss</code>=&quot;gaus&quot;). For binary responses, 
maximum likelihood estimation (<code>loss</code>=&quot;ml&quot;) is implemented by calling <code>glm</code>. Calibrated estimation (<code>loss</code>=&quot;cal&quot;) is implemented by 
using a trust-region algorithm in the R package <span class="pkg">trust</span> to minimize the calibration loss, i.e., (6) in Tan (2020). 
Covariate-balancing estimation (<code>loss</code>=&quot;bal&quot;) in Imai and Ratkovic (2014) is implemented by using <span class="pkg">trust</span> to minimize (36) in Tan (2020a).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>The <code class="reqn">(p+1)</code> x <code class="reqn">1</code> vector of estimated intercept and coefficients.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The <code class="reqn">n</code> x <code class="reqn">1</code> vector of fitted values.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>Logical; 1 if loss=&quot;gaus&quot; for continuous responses or convergence is obtained within 1000 iterations by <code>glm</code> with loss=&quot;ml&quot; or <code>trust</code> with loss=&quot;cal&quot; or &quot;bal&quot; for binary responses.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Imai, K. and Ratkovic, M. (2014) Covariate balancing propensity score, <em>Journal of the Royal Statistical Society</em>, Ser. B, 76, 243-263.
</p>
<p>Tan, Z. (2020) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

# include only 10 covariates
x2 &lt;- x[,1:10]

ps.ml &lt;- glm.nreg(y=tr, x=x2, loss="ml")
check.ml &lt;- mn.ipw(x2, tr, ps.ml$fit)
check.ml

ps.cal &lt;- glm.nreg(y=tr, x=x2, loss="cal")
check.cal &lt;- mn.ipw(x2, tr, ps.cal$fit)
check.cal  # should be numerically 0

ps.bal &lt;- glm.nreg(y=tr, x=x2, loss="bal")
check.bal &lt;- mn.ipw(x2, tr, ps.bal$fit)
check.bal

</code></pre>

<hr>
<h2 id='glm.regu'>Regularied M-estimation for fitting generalized linear models with a fixed tuning parameter</h2><span id='topic+glm.regu'></span>

<h3>Description</h3>

<p>This function implements regularized M-estimation for fitting generalized linear models with continuous or binary responses 
for a fixed choice of tuning parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.regu(y, x, iw = NULL, loss = "cal", init = NULL, rhos, test = NULL,
  offs = NULL, id = NULL, Wmat = NULL, Rmat = NULL, zzs = NULL,
  xxs = NULL, n.iter = 100, eps = 1e-06, bt.lim = 3, nz.lab = NULL,
  pos = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.regu_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> response vector.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, excluding a constant.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_iw">iw</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> weight vector.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_loss">loss</code></td>
<td>
<p>A loss function, which can be specified as &quot;gaus&quot; for continuous responses, or &quot;ml&quot; or &quot;cal&quot; for binary respones.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_init">init</code></td>
<td>
<p>A <code class="reqn">(p+1)</code> x <code class="reqn">1</code> vector of initial values (the intercept and coefficients).</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_rhos">rhos</code></td>
<td>
<p>A <code class="reqn">p</code> x <code class="reqn">1</code> vector of Lasso tuning parameters, usually a constant vector, associated with the <code class="reqn">p</code> coefficients.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_test">test</code></td>
<td>
<p>A vector giving the indices of observations between 1 and <code class="reqn">n</code> which are included in the test set.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_offs">offs</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of offset values, similarly as in <code>glm</code>.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_id">id</code></td>
<td>
<p>An argument which can be used to speed up computation.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_wmat">Wmat</code></td>
<td>
<p>An argument which can be used to speed up computation.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_rmat">Rmat</code></td>
<td>
<p>An argument which can be used to speed up computation.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_zzs">zzs</code></td>
<td>
<p>An argument which can be used to speed up computation.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_xxs">xxs</code></td>
<td>
<p>An argument which can be used to speed up computation.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_n.iter">n.iter</code></td>
<td>
<p>The maximum number of iterations allowed. An iteration is defined by computing an quadratic approximation and solving a least-squares Lasso problem.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_eps">eps</code></td>
<td>
<p>The tolerance at which the difference in the objective (loss plus penalty) values is considered close enough to 0 to declare convergence.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_bt.lim">bt.lim</code></td>
<td>
<p>The maximum number of backtracking steps allowed.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_nz.lab">nz.lab</code></td>
<td>
<p>A <code class="reqn">p</code> x <code class="reqn">1</code> logical vector (useful for simulations), indicating which covariates are included when calculating the number of nonzero coefficients. 
If <code>nz.lab=NULL</code>, then <code>nz.lab</code> is reset to a vector of 0s.</p>
</td></tr>
<tr><td><code id="glm.regu_+3A_pos">pos</code></td>
<td>
<p>A value which can be used to facilitate recording the numbers of nonzero coefficients with or without the restriction by <code>nz.lab</code>. 
If <code>nz.lab=NULL</code>, then <code>pos</code> is reset to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For continuous responses, this function uses an active-set descent algorithm (Osborne et al. 2000; Yang and Tan 2018) to solve the least-squares Lasso problem. 
For binary responses, regularized calibrated estimation is implemented using the Fisher scoring descent algorithm in Tan (2020), whereas
regularized maximum likelihood estimation is implemented in a similar manner based on quadratic approximation as in the R package <span class="pkg">glmnet</span>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations performed up to <code>n.iter</code>.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>1 if convergence is obtained, 0 if exceeding the maximum number of iterations, or -1 if exceeding maximum number of backtracking steps.</p>
</td></tr>
<tr><td><code>nz</code></td>
<td>
<p>A value defined as (nz0 * <code>pos</code> + nz1) to record the numbers of nonzero coefficients without or with the restriction 
(denoted as nz0 and nz1) by <code>nz.lab</code>.
If <code>nz.lab=NULL</code>, then nz1 is 0, <code>pos</code> is 1, and hence <code>nz</code> is nz0.</p>
</td></tr>
<tr><td><code>inter</code></td>
<td>
<p>The estimated intercept.</p>
</td></tr>
<tr><td><code>bet</code></td>
<td>
<p>The <code class="reqn">p</code> x <code class="reqn">1</code> vector of estimated coefficients, excluding the intercept.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The vector of fitted values in the training set.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The vector of linear predictors in the training set.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>The <code class="reqn">p</code> x <code class="reqn">1</code> vector of generalized signs, which should be -1 or 1 for a negative or positive estimate and between -1 and 1 for a zero estimate.</p>
</td></tr>
<tr><td><code>obj.train</code></td>
<td>
<p>The average loss in the training set.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>The Lasso penalty of the estimates.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>The average loss plus the Lasso penalty.</p>
</td></tr>
<tr><td><code>fit.test</code></td>
<td>
<p>The vector of fitted values in the test set.</p>
</td></tr>
<tr><td><code>eta.test</code></td>
<td>
<p>The vector of linear predictors in the test set.</p>
</td></tr>
<tr><td><code>obj.test</code></td>
<td>
<p>The average loss in the test set.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>This can be re-used to speed up computation.</p>
</td></tr>
<tr><td><code>Wmat</code></td>
<td>
<p>This can be re-used to speed up computation.</p>
</td></tr>
<tr><td><code>Rmat</code></td>
<td>
<p>This can be re-used to speed up computation.</p>
</td></tr>
<tr><td><code>zzs</code></td>
<td>
<p>This can be re-used to speed up computation.</p>
</td></tr>
<tr><td><code>xxs</code></td>
<td>
<p>This can be re-used to speed up computation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Osborne, M., Presnell, B., and Turlach, B. (2000) A new approach to variable selection in least squares problems, <em>IMA Journal of Numerical Analysis</em>, 20, 389-404.
</p>
<p>Yang, T. and Tan, Z. (2018) Backfitting algorithms for total-variation and empirical-norm penalized additive modeling with high-dimensional data, <em>Stat</em>, 7, e198.
</p>
<p>Tibshirani, R. (1996) Regression shrinkage and selection via the Lasso, <em>Journal of the Royal Statistical Society</em>, Ser. B, 58, 267-288.
</p>
<p>Tan, Z. (2020) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

### Example 1: linear regression
# rhos should be a vector of length p, even though a constant vector
out.rgaus &lt;- glm.regu(y[tr==1], x[tr==1,], rhos=rep(.05,p), loss="gaus")

# the intercept
out.rgaus$inter

# the estimated coefficients and generalized signs; the first 10 are shown
cbind(out.rgaus$bet, out.rgaus$tau)[1:10,]

# the number of nonzero coefficients 
out.rgaus$nz

### Example 2: logistic regression using likelihood loss
out.rml &lt;- glm.regu(tr, x, rhos=rep(.01,p), loss="ml")
out.rml$inter
cbind(out.rml$bet, out.rml$tau)[1:10,]
out.rml$nz

### Example 3: logistic regression using calibration loss
out.rcal &lt;- glm.regu(tr, x, rhos=rep(.05,p), loss="cal")
out.rcal$inter
cbind(out.rcal$bet, out.rcal$tau)[1:10,]
out.rcal$nz

</code></pre>

<hr>
<h2 id='glm.regu.cv'>Regularied M-estimation for fitting generalized linear models based on cross validation</h2><span id='topic+glm.regu.cv'></span>

<h3>Description</h3>

<p>This function implements regularized M-estimation for fitting generalized linear models with binary or contiunous responses 
based on cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.regu.cv(fold, nrho = NULL, rho.seq = NULL, y, x, iw = NULL,
  loss = "cal", n.iter = 100, eps = 1e-06, tune.fac = 0.5,
  tune.cut = TRUE, ann.init = TRUE, nz.lab = NULL, permut = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.regu.cv_+3A_fold">fold</code></td>
<td>
<p>A fold number used for cross validation.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_nrho">nrho</code></td>
<td>
<p>The number of tuning parameters searched in cross validation.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_rho.seq">rho.seq</code></td>
<td>
<p>A vector of tuning parameters searched in cross validation. If both <code>nrho</code> and <code>rho.seq</code> are specified, then <code>rho.seq</code> overrides <code>nrho</code>.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> response vector.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, excluding a constant.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_iw">iw</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> weight vector.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_loss">loss</code></td>
<td>
<p>A loss function, which can be specified as &quot;gaus&quot; for continuous responses, or &quot;ml&quot; or &quot;cal&quot; for binary respones.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_n.iter">n.iter</code></td>
<td>
<p>The maximum number of iterations allowed as in <code><a href="#topic+glm.regu">glm.regu</a></code>.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_eps">eps</code></td>
<td>
<p>The tolerance used to declare convergence as in <code><a href="#topic+glm.regu">glm.regu</a></code>.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_tune.fac">tune.fac</code></td>
<td>
<p>The multiplier (factor) used to define <code>rho.seq</code> if only <code>nrho</code> is specified.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_tune.cut">tune.cut</code></td>
<td>
<p>Logical; if <code>TRUE</code>, all smaller tuning parameters are skipped once non-convergence is found with a tuning parameter.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_ann.init">ann.init</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the estimates from the previous tuning parameter are used as the inital values when fitting with the current tuning parameter.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_nz.lab">nz.lab</code></td>
<td>
<p>A <code class="reqn">p</code> x <code class="reqn">1</code> logical vector (useful for simulations), indicating which covariates are included when calculating the number of nonzero coefficients.</p>
</td></tr>
<tr><td><code id="glm.regu.cv_+3A_permut">permut</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector, giving a random permutation of the integers from 1 to <code class="reqn">n</code>, which is used in cross validation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cross validation is performed as described in Tan (2020a, 2020b). If not specified by users, the sequence of tuning parameters searched is defined as 
a geometric series of length <code>nrho</code>, starting from the value which yields a zero solution, and then decreasing by a factor <code>tune.fac</code> successively. 
</p>
<p>After cross validation, two tuning parameters are selected. The first and default choice is the value yielding the smallest average test loss.
The second choice is the largest value giving the average test loss within one standard error of the first choice (Hastie, Tibshirani, and Friedman 2016).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>permut</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector, giving the random permutation used in cross validation.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>The vector of tuning parameters, searched in cross validation.</p>
</td></tr>
<tr><td><code>non.conv</code></td>
<td>
<p>A vector indicating the non-convergene status found or imputed if <code>tune.cut=TRUE</code>, for the tuning parmaters in cross validation.
For each tuning parameter, 0 indicates convergence, 1 non-convergence if exceeding <code>n.iter</code>, 2 non-convergence if exceeding <code>bt.lim</code>.</p>
</td></tr>
<tr><td><code>err.ave</code></td>
<td>
<p>A vector giving the averages of the test losses in cross validation.</p>
</td></tr>
<tr><td><code>err.sd</code></td>
<td>
<p>A vector giving the standard deviations of the test losses in cross validation.</p>
</td></tr>
<tr><td><code>sel.rho</code></td>
<td>
<p>A vector of two selected tuning parameters by cross validation; see <strong>Details</strong>.</p>
</td></tr>
<tr><td><code>sel.nz</code></td>
<td>
<p>A vector of numbers of nonzero coefficients estimated for the selected tuning parameters.</p>
</td></tr>
<tr><td><code>sel.bet</code></td>
<td>
<p>The <code class="reqn">(p+1)</code> x <code class="reqn">2</code> vector of estimated intercept and coefficients.</p>
</td></tr>
<tr><td><code>sel.fit</code></td>
<td>
<p>The <code class="reqn">n</code> x <code class="reqn">2</code> vector of fitted values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hastie, T., Tibshirani, R., and Friedman. J. (2016) <em>The Elements of Statistical Learning</em> (second edition), Springer: New York.
</p>
<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

### Example 1: Regularized maximum likelihood estimation of propensity scores
ps.cv.rml &lt;- glm.regu.cv(fold=5, nrho=1+10, y=tr, x=x, loss="ml")
ps.cv.rml$rho
ps.cv.rml$err.ave
ps.cv.rml$err.sd
ps.cv.rml$sel.rho
ps.cv.rml$sel.nz

fp.cv.rml &lt;- ps.cv.rml $sel.fit[,1]
check.cv.rml &lt;- mn.ipw(x, tr, fp.cv.rml)
check.cv.rml$est

### Example 2: Regularized calibrated estimation of propensity scores
ps.cv.rcal &lt;- glm.regu.cv(fold=5, nrho=1+10, y=tr, x=x, loss="cal")
ps.cv.rcal$rho
ps.cv.rcal$err.ave
ps.cv.rcal$err.sd
ps.cv.rcal$sel.rho
ps.cv.rcal$sel.nz

fp.cv.rcal &lt;- ps.cv.rcal $sel.fit[,1]

check.cv.rcal &lt;- mn.ipw(x, tr, fp.cv.rcal)
check.cv.rcal$est


</code></pre>

<hr>
<h2 id='glm.regu.path'>Regularied M-estimation for fitting generalized linear models along a regularization path</h2><span id='topic+glm.regu.path'></span>

<h3>Description</h3>

<p>This function implements regularized M-estimation for fitting generalized linear models with binary or contiunous responses 
along a regularization path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.regu.path(nrho = NULL, rho.seq = NULL, y, x, iw = NULL,
  loss = "cal", n.iter = 100, eps = 1e-06, tune.fac = 0.5,
  tune.cut = TRUE, ann.init = TRUE, nz.lab = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.regu.path_+3A_nrho">nrho</code></td>
<td>
<p>The number of tuning parameters in a regularization path.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_rho.seq">rho.seq</code></td>
<td>
<p>A vector of tuning parameters in a regularization path. If both <code>nrho</code> and <code>rho.seq</code> are specified, then <code>rho.seq</code> overrides <code>nrho</code>.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> response vector.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, excluding a constant.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_iw">iw</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> weight vector.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_loss">loss</code></td>
<td>
<p>A loss function, which can be specified as &quot;gaus&quot; for continuous responses, or &quot;ml&quot; or &quot;cal&quot; for binary respones.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_n.iter">n.iter</code></td>
<td>
<p>The maximum number of iterations allowed as in <code><a href="#topic+glm.regu">glm.regu</a></code>.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_eps">eps</code></td>
<td>
<p>The tolerance used to declare convergence as in <code><a href="#topic+glm.regu">glm.regu</a></code>.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_tune.fac">tune.fac</code></td>
<td>
<p>The multiplier (factor) used to define rho.seq if only <code>nrho</code> is specified.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_tune.cut">tune.cut</code></td>
<td>
<p>Logical; if <code>TRUE</code>, all smaller tuning parameters are skipped once non-convergence is found with a tuning parameter.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_ann.init">ann.init</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the estimates from the previous tuning parameter are used as the inital value when fitting with the current tuning parameter.</p>
</td></tr>
<tr><td><code id="glm.regu.path_+3A_nz.lab">nz.lab</code></td>
<td>
<p>A <code class="reqn">p</code> x <code class="reqn">1</code> logical vector (useful for simulations), indicating which covariates are included when calculating the number of nonzero coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If not specified by users, the sequence of tuning parameters (i.e., the regularization path) is defined as a geometric series 
of length <code>nrho</code>, starting from the value which yields a zero solution, and then decreasing by a factor <code>tune.fac</code> successively.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rho</code></td>
<td>
<p>The vector of tuning parameters included in the regularization path.</p>
</td></tr>
<tr><td><code>non.conv</code></td>
<td>
<p>A vector indicating the non-convergene status found or imputed if <code>tune.cut=TRUE</code>, along the regularization path. 
For each tuning parameter, 0 indicates convergence, 1 non-convergence if exceeding <code>n.iter</code>, 2 non-convergence if exceeding <code>bt.lim</code>.</p>
</td></tr>
<tr><td><code>nz.all</code></td>
<td>
<p>A vector giving the numbers of nonzero coefficients estimated, along the regularization path.</p>
</td></tr>
<tr><td><code>bet.all</code></td>
<td>
<p>A matrix giving estimated intercept and coefficients, column by column, along the regularization path.</p>
</td></tr>
<tr><td><code>fit.all</code></td>
<td>
<p>A matrix giving fitted values, column by column, along the regularization path.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

### Example 1: linear regression
out.rgaus.path &lt;- glm.regu.path(rho.seq=c(.01, .02, .05, .1, .2, .5), y=y[tr==1], x=x[tr==1,], 
                                loss="gaus")

# the estimated intercept and coefficients; the first 10 are shown
out.rgaus.path$bet.all[1:10,]

### Example 2: logistic regression using likelihood loss
out.rml.path &lt;- glm.regu.path(rho.seq=c(.002, .005, .01, .02, .05, .1), y=tr, x=x, loss="ml")
out.rml.path$bet.all[1:10,]

### Example 3: logistic regression using calibration loss
out.rcal.path &lt;- glm.regu.path(rho.seq=c(.005, .01, .02, .05, .1, .2), y=tr, x=x, loss="cal")
out.rcal.path$bet.all[1:10,]


</code></pre>

<hr>
<h2 id='late.aipw'>Augmented inverse probability weighted estimation of local average treatment effects</h2><span id='topic+late.aipw'></span>

<h3>Description</h3>

<p>This function implements augmented inverse probability weighted (IPW) estimation of local average treatment effects (LATEs) as proposed in Tan (2006),
provided the fitted instrument propensity scores and fitted values from both treatment and outcome regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>late.aipw(y, tr, iv, mfp, mft, mfo, off = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="late.aipw_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="late.aipw_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="late.aipw_+3A_iv">iv</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of instruments (0 or 1).</p>
</td></tr>
<tr><td><code id="late.aipw_+3A_mfp">mfp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted instrument propensity scores for <code>iv</code>=0 (first column) and <code>iv</code>=1 (second column).</p>
</td></tr>
<tr><td><code id="late.aipw_+3A_mft">mft</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted values from treatment regression, for <code>iv</code>=0 (first column) and <code>iv</code>=1 (second column).</p>
</td></tr>
<tr><td><code id="late.aipw_+3A_mfo">mfo</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">4</code> matrix of fitted values from outcome regression, for <code>iv</code>=0, <code>tr</code>=0 (first column), <code>iv</code>=0, <code>tr</code>=1 (second column), <code>iv</code>=1, <code>tr</code>=0 (third column) and  <code>iv</code>=1, <code>tr</code>=1 (fourth column).</p>
</td></tr>
<tr><td><code id="late.aipw_+3A_off">off</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of offset values (e.g., the true values in simulations) used to calculate the z-statistics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The individual expectations <code class="reqn">\theta_d=E(Y(d)|D(1)&gt;D(0))</code> are estimated separately for <code class="reqn">d\in\{0,1\}</code> using inverse probability weighting (&quot;ipw&quot;), treatment and outcome regressions (&quot;or&quot;) and augmented IPW methods as proposed in Tan (2006). The population LATE is defined as <code class="reqn">\theta_1-\theta_0</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ipw</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of IPW estimates of <code class="reqn">\theta_1</code> and <code class="reqn">\theta_0</code>; see <strong>Details</strong>.</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of regression estimates of <code class="reqn">\theta_1</code> and <code class="reqn">\theta_0</code>; see <strong>Details</strong>.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of augmented IPW estimates of <code class="reqn">\theta_1</code> and <code class="reqn">\theta_0</code>; see <strong>Details</strong>.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The estimated variances associated with the augmented IPW estimates of <code class="reqn">\theta_1</code> and <code class="reqn">\theta_0</code>.</p>
</td></tr>
<tr><td><code>ze</code></td>
<td>
<p>The z-statistics for the augmented IPW estimates of <code class="reqn">\theta_1</code> and <code class="reqn">\theta_0</code>, compared to <code>off</code>.</p>
</td></tr>
<tr><td><code>late.est</code></td>
<td>
<p>The augmented IPW estimate of LATE.</p>
</td></tr>
<tr><td><code>late.var</code></td>
<td>
<p>The estimated variance associated with the augmented IPW estimate of LATE.</p>
</td></tr>
<tr><td><code>late.ze</code></td>
<td>
<p>The z-statistic for the augmented IPW estimate of LATE, compared to <code>off</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2006) Regression and weighting methods for causal inference using instrumental variables, Journal of the American Statistical Association, 101, 1607–1618.
</p>

<hr>
<h2 id='late.nreg'>Model-assisted inference for local average treatment effects without regularization</h2><span id='topic+late.nreg'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for local average treatment effects,
using non-regularized calibrated estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>late.nreg(y, tr, iv, fx, gx, hx, arm = 2, d1 = NULL, d2 = NULL,
  ploss = "cal", yloss = "gaus", off = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="late.nreg_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_iv">iv</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of instruments (0 or 1).</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_fx">fx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, used in the instrument propensity score model.</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_gx">gx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">q_1</code> matix of covariates, used in the treatment regression models.</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_hx">hx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">q_2</code> matix of covariates, used in the outcome regression models.</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_arm">arm</code></td>
<td>
<p>An integer 0, 1 or 2 indicating whether <code class="reqn">\theta_0</code>, <code class="reqn">\theta_1</code> or both are computed; see <strong>Details</strong> for <code><a href="#topic+late.aipw">late.aipw</a></code>.</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_d1">d1</code></td>
<td>
<p>Degree of truncated polynomials of fitted values from treatment regression to be included as regressors in the outcome regression (NULL: no adjustment, 0: piecewise constant, 1: piecewise linear etc..).</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_d2">d2</code></td>
<td>
<p>Number of knots of fitted values from treatment regression to be included as regressors in the outcome regression, with knots specified as the <code class="reqn">i</code>/(<code>d2</code>+1)-quantiles for <code class="reqn">i</code>=1,...,<code>d2</code>.</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in instrument propensity score estimation (either &quot;ml&quot; for likelihood estimation or &quot;cal&quot; for calibrated estimation).</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="late.nreg_+3A_off">off</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of offset values (e.g., the true values in simulations) used to calculate the z-statistics from augmented IPW estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For ploss=&quot;cal&quot;, calibrated estimation of the instrument propensity score (IPS) and weighted likelihood estimation of the treatment and outcome regression models are performed, similarly as in Sun and Tan (2020), but without regularization. 
See also <strong>Details</strong> for <code><a href="#topic+mn.nreg">mn.nreg</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ips</code></td>
<td>
<p>A list containing the results from fitting the instrument propensity score models by <code><a href="#topic+glm.nreg">glm.nreg</a></code>.</p>
</td></tr>
<tr><td><code>mfp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted instrument propensity scores for <code>iv</code>=0 (first column) and <code>iv</code>=1 (second column).</p>
</td></tr>
<tr><td><code>tps</code></td>
<td>
<p>A list containing the results from fitting the treatment regression models by <code><a href="#topic+glm.nreg">glm.nreg</a></code>.</p>
</td></tr>
<tr><td><code>mft</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted treatment regression models for <code>iv</code>=0 (first column) and <code>iv</code>=1 (second column).</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list containing the results from fitting the outcome regression models by <code><a href="#topic+glm.nreg">glm.nreg</a></code>.</p>
</td></tr>
<tr><td><code>mfo</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">4</code> matrix of fitted outcome regression models for for <code>iv</code>=0, <code>tr</code>=0 (first column), <code>iv</code>=0, <code>tr</code>=1 (second column), <code>iv</code>=1, <code>tr</code>=0 (third column) and  <code>iv</code>=1, <code>tr</code>=1 (fourth column). Two columns are set to <code>NA</code> if <code>arm</code>=0 or 1.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+late.aipw">late.aipw</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2006) Regression and weighting methods for causal inference using instrumental variables, Journal of the American Statistical Association, 101, 1607–1618.
</p>
<p>Sun, B. and Tan, Z. (2020) High-dimensional model-assisted inference for local average treatment effects with instrumental variables, arXiv:2009.09286.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simu.iv.data)
n &lt;- dim(simu.iv.data)[1]
p &lt;- dim(simu.iv.data)[2]-3

y &lt;- simu.iv.data[,1]
tr &lt;- simu.iv.data[,2]
iv &lt;- simu.iv.data[,3]
x &lt;- simu.iv.data[,3+1:p]
x &lt;- scale(x)

# include only 10 covariates
x2 &lt;- x[,1:10]

late.cal &lt;- late.nreg(y, tr, iv, fx=x2, gx=x2, hx=x2, arm=2, d1=1, d2=3,
                       ploss="cal", yloss="gaus")

matrix(unlist(late.cal$est), ncol=2, byrow=TRUE, 
dimnames=list(c("ipw", "or", "est", "var", "ze", 
 "late.est", "late.var", "late.ze"), c("theta1", "theta0")))

</code></pre>

<hr>
<h2 id='late.regu.cv'>Model-assisted inference for local average treatment effects (LATEs) with instrumental variables based on cross validation</h2><span id='topic+late.regu.cv'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for LATEs with instrumental variables, using regularized calibrated estimation based on cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>late.regu.cv(fold, nrho = NULL, rho.seq = NULL, y, tr, iv, fx, gx, hx,
  arm = 2, d1 = NULL, d2 = NULL, ploss = "cal", yloss = "gaus",
  off = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="late.regu.cv_+3A_fold">fold</code></td>
<td>
<p>A vector of length 3 giving the fold numbers for cross validation in instrument propensity score estimation, treatment and outcome regressions respectively.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_nrho">nrho</code></td>
<td>
<p>A vector of length 3 giving the numbers of tuning parameters searched in cross validation.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_rho.seq">rho.seq</code></td>
<td>
<p>A list of three vectors giving the tuning parameters in instrument propensity score estimation (first vector), treatment (second vector) and outcome (third vector) regressions.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_iv">iv</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of instruments (0 or 1).</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_fx">fx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, used in the instrument propensity score model.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_gx">gx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">q_1</code> matix of covariates, used in the treatment regression models. In theory, <code>gx</code> should be a subvector of <code>gx</code>, hence <code class="reqn">p\leq q_1</code>.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_hx">hx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">q_2</code> matix of covariates, used in the outcome regression models. In theory, <code>hx</code> should be a subvector of <code>hx</code>, hence <code class="reqn">p\leq q_2</code>.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_arm">arm</code></td>
<td>
<p>An integer 0, 1 or 2 indicating whether <code class="reqn">\theta_0</code>, <code class="reqn">\theta_1</code> or both are computed; see <strong>Details</strong> for <code><a href="#topic+late.aipw">late.aipw</a></code>.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_d1">d1</code></td>
<td>
<p>Degree of truncated polynomials of fitted values from treatment regression to be included as regressors in the outcome regression (NULL: no adjustment, 0: piecewise constant, 1: piecewise linear etc.).</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_d2">d2</code></td>
<td>
<p>Number of knots of fitted values from treatment regression to be included as regressors in the outcome regression, with knots specified as the <code class="reqn">i</code>/(<code>d2</code>+1)-quantiles for <code class="reqn">i</code>=1,...,<code>d2</code>.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in instrument propensity score estimation (either &quot;ml&quot; for likelihood estimation or &quot;cal&quot; for calibrated estimation).</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_off">off</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of offset values (e.g., the true values in simulations) used to calculate the z-statistics from augmented IPW estimation.</p>
</td></tr>
<tr><td><code id="late.regu.cv_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>ploss</code>=&quot;cal&quot;, regularized calibrated estimation of the instrument propensity score (IPS) and regularized weighted likelihood estimation of the treatment and outcome regression models are performed. The method leads to model-assisted inference for LATE, in which condidence intervals are valid
with high-dimensional data if the IPS model is correctly specified, but the treatment and outcome regression models may be misspecified (Sun and Tan 2020). For <code>ploss</code>=&quot;ml&quot;, regularized maximum likelihood estimation is used (Chernozhukov et al. 2018). In this case, standard errors are only shown to be valid if the IPS, treatment and outcome models are all correctly specified.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ips</code></td>
<td>
<p>A list containing the results from fitting the instrument propensity score models by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
<tr><td><code>mfp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted instrument propensity scores for <code>iv</code>=0 (first column) and <code>iv</code>=1 (second column).</p>
</td></tr>
<tr><td><code>tps</code></td>
<td>
<p>A list containing the results from fitting the treatment regression models by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
<tr><td><code>mft</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">2</code> matrix of fitted treatment regression models for <code>iv</code>=0 (first column) and <code>iv</code>=1 (second column).</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list containing the results from fitting the outcome regression models by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
<tr><td><code>mfo</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">4</code> matrix of fitted outcome regression models for for <code>iv</code>=0, <code>tr</code>=0 (first column), <code>iv</code>=0, <code>tr</code>=1 (second column), <code>iv</code>=1, <code>tr</code>=0 (third column) and  <code>iv</code>=1, <code>tr</code>=1 (fourth column). Two columns are set to <code>NA</code> if <code>arm</code>=0 or 1.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+late.aipw">late.aipw</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chernozhukov, V., Chetverikov, D., Demirer, M., Duflo, E., Hansen, C., Newey, W. and Robins, J.M. (2018) Double/debiased machine learning for treatment and structural parameters, <em>The Econometrics Journal</em>, 21, C1–C68.
</p>
<p>Sun, B. and Tan, Z. (2020) High-dimensional model-assisted inference for local average treatment effects with instrumental variables, arXiv:2009.09286.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simu.iv.data)
n &lt;- dim(simu.iv.data)[1]
p &lt;- dim(simu.iv.data)[2]-3

y &lt;- simu.iv.data[,1]
tr &lt;- simu.iv.data[,2]
iv &lt;- simu.iv.data[,3]
x &lt;- simu.iv.data[,3+1:p]
x &lt;- scale(x)

late.cv.rcal &lt;- late.regu.cv(fold=5*c(1,1,1), nrho=(1+10)*c(1,1,1), rho.seq=NULL, 
                 y, tr, iv, fx=x, gx=x, hx=x, arm=2, d1=1, d2=3, ploss="cal", yloss="gaus")

matrix(unlist(late.cv.rcal$est), ncol=2, byrow=TRUE, 
dimnames=list(c("ipw", "or", "est", "var", "ze", 
 "late.est", "late.var", "late.ze"), c("theta1", "theta0")))


</code></pre>

<hr>
<h2 id='late.regu.path'>Model-assisted inference for local average treatment effects along regularization paths</h2><span id='topic+late.regu.path'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for local average treatment effects (LATEs) using regularized calibrated estimation along regularization paths for instrument propensity score (IPS) estimation, 
while based on cross validation for the treatment and outcome regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>late.regu.path(fold, nrho = NULL, rho.seq = NULL, y, tr, iv, fx, gx, hx,
  arm = 2, d1 = NULL, d2 = NULL, ploss = "cal", yloss = "gaus",
  off = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="late.regu.path_+3A_fold">fold</code></td>
<td>
<p>A vector of length 3, with the second and third components giving the fold number for cross validation in the treatment and outcome regressions respectively. The first component is not used.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_nrho">nrho</code></td>
<td>
<p>A vector of length 3 giving the number of tuning parameters in a regularization path for IPS estimation and that in cross validation for the treatment and outcome regressions.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_rho.seq">rho.seq</code></td>
<td>
<p>A list of two vectors giving the tuning parameters for IPS estimation (first vector), treatment (second vector) and outcome (third vector) regressions.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of treatment indicators (=1 if treated or 0 if untreated).</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_iv">iv</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of instruments (0 or 1).</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_fx">fx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, used in the instrument propensity score model.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_gx">gx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">q_1</code> matix of covariates, used in the treatment regression models. In theory, <code>gx</code> should be a subvector of <code>gx</code>, hence <code class="reqn">p\leq q_1</code>.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_hx">hx</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">q_2</code> matix of covariates, used in the outcome regression models. In theory, <code>hx</code> should be a subvector of <code>gx</code>, hence <code class="reqn">p\leq q_2</code>.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_arm">arm</code></td>
<td>
<p>An integer 0, 1 or 2 indicating whether <code class="reqn">\theta_0</code>, <code class="reqn">\theta_1</code> or both are computed; see <strong>Details</strong> for <code><a href="#topic+late.aipw">late.aipw</a></code>.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_d1">d1</code></td>
<td>
<p>Degree of truncated polynomials of fitted values from treatment regression to be included as regressors in the outcome regression (NULL: no adjustment, 0: piecewise constant, 1: piecewise linear etc.).</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_d2">d2</code></td>
<td>
<p>Number of knots of fitted values from treatment regression to be included as regressors in the outcome regression, with knots specified as the <code class="reqn">i</code>/(<code>d2</code>+1)-quantiles for <code class="reqn">i</code>=1,...,<code>d2</code>.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in instrument propensity score estimation (either &quot;ml&quot; for likelihood estimation or &quot;cal&quot; for calibrated estimation).</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_off">off</code></td>
<td>
<p>A <code class="reqn">2</code> x <code class="reqn">1</code> vector of offset values (e.g., the true values in simulations) used to calculate the z-statistics from augmented IPW estimation.</p>
</td></tr>
<tr><td><code id="late.regu.path_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code> and <code><a href="#topic+glm.regu.path">glm.regu.path</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ips</code></td>
<td>
<p>A list of 2 objects, giving the results from fitting the IPS models by <code><a href="#topic+glm.regu.path">glm.regu.path</a></code> for <code>iv</code>=0 (first) and <code>iv</code>=1 (second).</p>
</td></tr>
<tr><td><code>mfp</code></td>
<td>
<p>A list of 2 matrices of fitted instrument propensity scores, along the IPS regularization path, for <code>iv</code>=0 (first matrix) and <code>iv</code>=1 (second matrix).</p>
</td></tr>
<tr><td><code>tps</code></td>
<td>
<p>A list of 2 lists of objects for <code>iv</code>=0 (first) and <code>iv</code>=1 (second), where each object gives the results from fitting the treatment regression models by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code> for an IPS tuning parameter.</p>
</td></tr>
<tr><td><code>mft</code></td>
<td>
<p>A list of 2 matrices of fitted treatment regression models based on cross validation, along the IPS regularization path, for <code>iv</code>=0 (first matrix) and <code>iv</code>=1 (second matrix).</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list of 4 lists of objects for <code>iv</code>=0, <code>tr</code>=0 (first), <code>iv</code>=0, <code>tr</code>=1 (second), <code>iv</code>=1, <code>tr</code>=0 (third) and  <code>iv</code>=1, <code>tr</code>=1 (fourth), containing the results from fitting the outcome regression models by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
<tr><td><code>mfo</code></td>
<td>
<p>A list of 4 matrices of fitted outcome regression models based on cross validation, along the IPS regularization path, for <code>iv</code>=0, <code>tr</code>=0 (first), <code>iv</code>=0, <code>tr</code>=1 (second), <code>iv</code>=1, <code>tr</code>=0 (third) and  <code>iv</code>=1, <code>tr</code>=1 (fourth). Two matrices are set to <code>NA</code> if <code>arm</code>=0 or 1.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+late.aipw">late.aipw</a></code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>A vector of tuning parameters leading to converged results in IPS estimation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sun, B. and Tan, Z. (2020) High-dimensional model-assisted inference for local average treatment effects with instrumental variables, arXiv:2009.09286.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simu.iv.data)
n &lt;- dim(simu.iv.data)[1]
p &lt;- dim(simu.iv.data)[2]-3

y &lt;- simu.iv.data[,1]
tr &lt;- simu.iv.data[,2]
iv &lt;- simu.iv.data[,3]
x &lt;- simu.iv.data[,3+1:p]
x &lt;- scale(x)


late.path.rcal &lt;- late.regu.path(fold=5*c(0,1,1), nrho=(1+10)*c(1,1,1), rho.seq=NULL,
                   y, tr, iv, fx=x, gx=x, hx=x, arm=2, d1=1, d2=3, ploss="cal", yloss="gaus")


late.path.rcal$est


</code></pre>

<hr>
<h2 id='mn.aipw'>Augmented inverse probability weighted estimation of population means</h2><span id='topic+mn.aipw'></span>

<h3>Description</h3>

<p>This function implements augmented inverse probability weighted (IPW) estimation of population means with missing data,
provided both fitted propensity scores and fitted values from outcome regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mn.aipw(y, tr, fp, fo, off = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mn.aipw_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of outcomes with missing data.</p>
</td></tr>
<tr><td><code id="mn.aipw_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of non-missing indicators (=1 if <code>y</code> is observed or 0 if <code>y</code> is missing).</p>
</td></tr>
<tr><td><code id="mn.aipw_+3A_fp">fp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of fitted propensity scores.</p>
</td></tr>
<tr><td><code id="mn.aipw_+3A_fo">fo</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of fitted values from outcome regression.</p>
</td></tr>
<tr><td><code id="mn.aipw_+3A_off">off</code></td>
<td>
<p>An offset value (e.g., the true value in simulations) used to calculate the z-statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>one</code></td>
<td>
<p>The direct IPW estimate of 1.</p>
</td></tr>
<tr><td><code>ipw</code></td>
<td>
<p>The ratio IPW estimate.</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>The outcome regression estimate.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>The augmented IPW estimate.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The estimated variance associated with the augmented IPW estimate.</p>
</td></tr>
<tr><td><code>ze</code></td>
<td>
<p>The z-statistic for the augmented IPW estimate, compared to <code>off</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>

<hr>
<h2 id='mn.ipw'>Inverse probability weighted estimation of population means</h2><span id='topic+mn.ipw'></span>

<h3>Description</h3>

<p>This function implements inverse probability weighted (IPW) estimation of population means with missing data,
provided fitted propensity scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mn.ipw(y, tr, fp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mn.ipw_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of outcomes with missing data.</p>
</td></tr>
<tr><td><code id="mn.ipw_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of non-missing indicators (=1 if <code>y</code> is observed or 0 if <code>y</code> is missing).</p>
</td></tr>
<tr><td><code id="mn.ipw_+3A_fp">fp</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of fitted propensity scores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ratio IPW estimate is the direct IPW estimate divided by that with <code>y</code> replaced by a vector of 1s. The latter is referred to as
the direct IPW estimate of 1.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>one</code></td>
<td>
<p>The direct IPW estimate of 1.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>The ratio IPW estimate.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>

<hr>
<h2 id='mn.nreg'>Model-assisted inference for population means without regularization</h2><span id='topic+mn.nreg'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for population means with missing data,
using non-regularized calibrated estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mn.nreg(y, tr, x, ploss = "cal", yloss = "gaus", off = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mn.nreg_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of outcomes with missing data.</p>
</td></tr>
<tr><td><code id="mn.nreg_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of non-missing indicators (=1 if <code>y</code> is observed or 0 if <code>y</code> is missing).</p>
</td></tr>
<tr><td><code id="mn.nreg_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates (excluding a constant), used in both propensity score and outcome regression models.</p>
</td></tr>
<tr><td><code id="mn.nreg_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in propensity score estimation (either &quot;ml&quot; or &quot;cal&quot;).</p>
</td></tr>
<tr><td><code id="mn.nreg_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="mn.nreg_+3A_off">off</code></td>
<td>
<p>An offset value (e.g., the true value in simulations) used to calculate the z-statistic from augmented IPW estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two steps are involved in this function: first fitting propensity score and outcome regression models and then applying the augmented IPW estimator 
for a population mean. For <code>ploss</code>=&quot;cal&quot;, calibrated estimation is performed similarly as in Tan (2020a, 2020b), but without regularization. 
The method then leads to model-assisted inference, in which confidence intervals are valid if the propensity score model is correctly specified but 
the outcome regression model may be misspecified.
With linear outcome models, the inference is also doubly robust (Kim and Haziza 2014; Vermeulen and Vansteelandt 2015).  
For <code>ploss</code>=&quot;ml&quot;, maximum likelihood estimation is used (Robins et al. 1994). In this case, standard errors are in general conservative 
if the propensity score model is correctly specified but the outcome regression model may be misspecified.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ps</code></td>
<td>
<p>A list containing the results from fitting the propensity score model by <code><a href="#topic+glm.nreg">glm.nreg</a></code>.</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>The <code class="reqn">n</code> x <code class="reqn">1</code> vector of fitted propensity scores.</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list containing the results from fitting the outcome regression model by <code><a href="#topic+glm.nreg">glm.nreg</a></code>.</p>
</td></tr>
<tr><td><code>fo</code></td>
<td>
<p>The <code class="reqn">n</code> x <code class="reqn">1</code> vector of fitted values from outcome regression.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+mn.aipw">mn.aipw</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim, J.K. and Haziza, D. (2014) Doubly robust inference with missing data in survey sampling, <em>Statistica Sinica</em>, 24, 375-394.
</p>
<p>Robins, J.M., Rotnitzky, A., and Zhao, L.P. (1994) Estimation of regression coefficients when some regressors are not always observed, 
<em>Journal of the American Statistical Association</em>, 89, 846-866.
</p>
<p>Vermeulen, K. and Vansteelandt, S. (2015) Bias-reduced doubly robust estimation, <em>Journal of the American Statistical Association</em>, 110, 1024-1036.
</p>
<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

# missing data
y[tr==0] &lt;- NA

# include only 10 covariates
x2 &lt;- x[,1:10]

mn.cal &lt;- mn.nreg(y, tr, x2, ploss="cal", yloss="gaus")
unlist(mn.cal$est)

</code></pre>

<hr>
<h2 id='mn.regu.cv'>Model-assisted inference for population means based on cross validation</h2><span id='topic+mn.regu.cv'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for population means with missing data,
using regularized calibrated estimation based on cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mn.regu.cv(fold, nrho = NULL, rho.seq = NULL, y, tr, x, ploss = "cal",
  yloss = "gaus", off = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mn.regu.cv_+3A_fold">fold</code></td>
<td>
<p>A vector of length 2 giving the fold numbers for cross validation in propensity score estimation and outcome regression respectively.</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_nrho">nrho</code></td>
<td>
<p>A vector of length 2 giving the numbers of tuning parameters searched in cross validation.</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_rho.seq">rho.seq</code></td>
<td>
<p>A list of two vectors giving the tuning parameters in propensity score estimation (first vector) and outcome regression (second vector).</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of outcomes with missing data.</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of non-missing indicators (=1 if <code>y</code> is observed or 0 if <code>y</code> is missing).</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, used in both propensity score and outcome regression models.</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in propensity score estimation (either &quot;ml&quot; or &quot;cal&quot;).</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_off">off</code></td>
<td>
<p>An offset value (e.g., the true value in simulations) used to calculate the z-statistic from augmented IPW estimation.</p>
</td></tr>
<tr><td><code id="mn.regu.cv_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two steps are involved in this function: first fitting propensity score and outcome regression models and then applying the augmented IPW estimator 
for a population mean. For <code>ploss</code>=&quot;cal&quot;, regularized calibrated estimation is performed with cross validation as described in Tan (2020a, 2020b). 
The method then leads to model-assisted inference, in which confidence intervals are valid with high-dimensinoal data 
if the propensity score model is correctly specified but the outcome regression model may be misspecified.
With linear outcome models, the inference is also doubly robust.
For <code>ploss</code>=&quot;ml&quot;, regularized maximum likelihood estimation is used (Belloni et al. 2014; Farrell 2015). In this case, standard errors 
are only shown to be valid if both the propensity score model and the outcome regression model are correctly specified.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ps</code></td>
<td>
<p>A list containing the results from fitting the propensity score model by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>The <code class="reqn">n</code> x <code class="reqn">1</code> vector of fitted propensity scores.</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list containing the results from fitting the outcome regression model by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code>.</p>
</td></tr>
<tr><td><code>fo</code></td>
<td>
<p>The <code class="reqn">n</code> x <code class="reqn">1</code> vector of fitted values from outcome regression.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+mn.aipw">mn.aipw</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., and Hansen, C. (2014) Inference on treatment effects after selection among high-dimensional controls,
<em>Review of Economic Studies</em>, 81, 608-650.
</p>
<p>Farrell, M.H. (2015) Robust inference on average treatment effects with possibly more covariates than observations, <em>Journal of Econometrics</em>, 189, 1-23.
</p>
<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

# missing data
y[tr==0] &lt;- NA

mn.cv.rcal &lt;- mn.regu.cv(fold=5*c(1,1), nrho=(1+10)*c(1,1), rho.seq=NULL, y, tr, x, 
                         ploss="cal", yloss="gaus")
unlist(mn.cv.rcal$est)


</code></pre>

<hr>
<h2 id='mn.regu.path'>Model-assisted inference for population means along a regularization path</h2><span id='topic+mn.regu.path'></span>

<h3>Description</h3>

<p>This function implements model-assisted inference for population means with missing data,
using regularized calibrated estimation along a regularization path for propensity score (PS) estimation 
while based on cross validation for outcome regression (OR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mn.regu.path(fold, nrho = NULL, rho.seq = NULL, y, tr, x, ploss = "cal",
  yloss = "gaus", off = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mn.regu.path_+3A_fold">fold</code></td>
<td>
<p>A vector of length 2, with the second component giving the fold number for cross validation in outcome regression. The first component is not used.</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_nrho">nrho</code></td>
<td>
<p>A vector of length 2 giving the number of tuning parameters in a regularization path for PS estimation and that in cross validation for OR.</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_rho.seq">rho.seq</code></td>
<td>
<p>A list of two vectors giving the tuning parameters for propensity score estimation (first vector) and outcome regression (second vector).</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_y">y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of outcomes with missing data.</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_tr">tr</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> vector of non-missing indicators (=1 if <code>y</code> is observed or 0 if <code>y</code> is missing).</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, used in both propensity score and outcome regression models.</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_ploss">ploss</code></td>
<td>
<p>A loss function used in propensity score estimation (either &quot;ml&quot; or &quot;cal&quot;).</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_yloss">yloss</code></td>
<td>
<p>A loss function used in outcome regression (either &quot;gaus&quot; for continuous outcomes or &quot;ml&quot; for binary outcomes).</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_off">off</code></td>
<td>
<p>An offset value (e.g., the true value in simulations) used to calculate the z-statistic from augmented IPW estimation.</p>
</td></tr>
<tr><td><code id="mn.regu.path_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code> and <code><a href="#topic+glm.regu.path">glm.regu.path</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <strong>Details</strong> for <code><a href="#topic+mn.regu.cv">mn.regu.cv</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ps</code></td>
<td>
<p>A list containing the results from fitting the propensity score model by <code><a href="#topic+glm.regu.path">glm.regu.path</a></code>.</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>The matrix of fitted propensity scores, column by column, along the PS regularization path.</p>
</td></tr>
<tr><td><code>or</code></td>
<td>
<p>A list of objects, each giving the results from fitting the outcome regression model by <code><a href="#topic+glm.regu.cv">glm.regu.cv</a></code> for a PS tuning parameter.</p>
</td></tr>
<tr><td><code>fo</code></td>
<td>
<p>The matrix of fitted values from outcome regression based on cross validation, column by column, along the PS regularization path.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>A list containing the results from augmented IPW estimation by <code><a href="#topic+mn.aipw">mn.aipw</a></code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>A vector of tuning parameters leading to converged results in propensity score estimation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

# missing data
y[tr==0] &lt;- NA

mn.path.rcal &lt;- mn.regu.path(fold=5*c(0,1), nrho=(1+10)*c(1,1), y=y, tr=tr, x=x, 
                             ploss="cal", yloss="gaus")
mn.path.rcal$est


</code></pre>

<hr>
<h2 id='simu.data'>Simulated data</h2><span id='topic+simu.data'></span>

<h3>Description</h3>

<p>A dataset simulated as in Tan (2020), Section 4.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simu.data)</code></pre>


<h3>Format</h3>

<p>A data matrix with 800 rows and 202 columns.</p>


<h3>Details</h3>

 
<p>The dataset is generated as follows, where <code>y</code>, <code>tr</code>, and <code>x</code> represent an outcome, a treatment, and covariates respectively. 
</p>
<pre>
library(MASS)

###
mt0 &lt;- 1-pnorm(-1)
mt1 &lt;- dnorm(-1)
mt2 &lt;- -(2*pnorm(-1)-1)/2 - dnorm(-1) +1/2
mt3 &lt;- 3*dnorm(-1)
mt4 &lt;- -3/2*(2*pnorm(-1)-1) - 4*dnorm(-1) +3/2

m.z1 &lt;- mt0 + 2*mt1 + mt2
v.z1 &lt;- mt0 + 4*mt1 + 6*mt2 + 4*mt3 + mt4
v.z1 &lt;- v.z1 + 1 + 2*(mt1 + 2*mt2 + mt3)

sd.z1 &lt;- sqrt(v.z1 -m.z1^2)
###

set.seed(123)

n &lt;- 800
p &lt;- 200

noise &lt;- rnorm(n)

covm &lt;- matrix(1,p,p)
for (i1 in 1:p)
  for (i2 in 1:p) {
    covm[i1,i2] &lt;- 2^(-abs(i1-i2))
  }
x &lt;- mvrnorm(n, mu=rep(0,p), Sigma=covm)

# transformation
z &lt;- x 
for (i in 1:4) {
  z[,i] &lt;- ifelse(x[,i]&gt;-1,x[,i]+(x[,i]+1)^2,x[,i])
  z[,i] &lt;- (z[,i]-m.z1) /sd.z1   # standardized
}

# treatment 
eta &lt;- 1+ c( z[,1:4] %*% c(1, .5, .25, .125) )
tr &lt;- rbinom(n, size=1, prob=expit(eta))

# outcome
eta.y &lt;- c( z[,1:4] %*% c(1, .5, .25, .125) )
y &lt;- eta.y + noise

# save; if using main effects of x, then both the propensity score
# and outcome regression models are misspecified
 
simu.data &lt;- cbind(y, tr, x)
save(simu.data, file="simu.data.rda")
</pre> 

<h3>References</h3>

<p>Tan, Z. (2020) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>

<hr>
<h2 id='simu.iv.data'>Simulated instrumental variable data</h2><span id='topic+simu.iv.data'></span>

<h3>Description</h3>

<p>A dataset simulated as in Sun and Tan (2020), Section 4.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simu.iv.data)</code></pre>


<h3>Format</h3>

<p>A data matrix with 800 rows and 203 columns.</p>


<h3>Details</h3>

 
<p>The dataset is generated as follows, where <code>y</code>, <code>iv</code>, <code>tr</code> and <code>x</code> represent an outcome, an instrumental variable, a treatment, and covariates respectively. 
</p>
<pre>
g&lt;-function(z) {
	1/(1+exp(z/b))^2*dnorm(z)
}

rnorm.trunct &lt;- function(n, mu, sig, lft, rgt) {
   x &lt;- rep(0,n)
   for (i in 1:n) {
      x[i] &lt;- rnorm(1,mu,sig)  
      while (x[i]&lt;=lft | x[i]&gt;rgt)
         x[i] &lt;- rnorm(1,mu,sig)                                  
   }
   return(x)
}

### covariate mean and variance computed as in preprint of Tan (2020)

a&lt;- 2.5;
c&lt;- 2*pnorm(a)-1;
b&lt;- sqrt(1-2*a*dnorm(a)/c)

m1&lt;- exp(1/(8*b^2))*(pnorm(a-1/(2*b))-pnorm(-a-1/(2*b)))/c
v1&lt;- exp(1/(2*b^2))*(pnorm(a-1/b)-pnorm(-a-1/b))/c-m1^2;

m2&lt;- 10;
v2&lt;- 1/c*integrate(g,-a,a)$value #by numerical integration

m3  &lt;- 3/(25^2)*0.6+(0.6)^3;
mu4 &lt;-(1/(b^4*c))*((3/2*(2*pnorm(a)-1)-a*(a^2+3)*dnorm(a))
	-(3/2*(2*pnorm(-a)-1)-(-a)*((-a)^2+3)*dnorm(-a)))
mu6 &lt;-(1/(b^6*c))*((15/2*(2*pnorm(a)-1)-a*(a^4+5*a^2+15)*dnorm(a))
	-(15/2*(2*pnorm(-a)-1)-(-a)*((-a)^4+5*(-a)^2+15)*dnorm(-a)))
v3  &lt;-mu6^2/25^6+15*mu4^2/25^4*0.6^2+15/25^2*0.6^4+0.6^6-m3^2

m4&lt;- 2+20^2;
v4&lt;- (2*mu4+6)+6*2*20^2+20^4-m4^2

###

set.seed(120)

n&lt;- 800
p&lt;- 200 

# covariates
 
x&lt;- matrix(rnorm.trunct(p*n, 0, 1, -a, a),n,p)/b

# transformation

z&lt;- x
z[,1] &lt;- (exp(0.5*x[,1])-m1)/sqrt(v1);	
z[,2] &lt;- (10+x[,2]/(1+exp(x[,1]))-m2)/sqrt(v2);	
z[,3] &lt;- ((0.04*x[,1]*x[,3]+0.6)^3-m3)/sqrt(v3);
z[,4] &lt;- ((x[,2]+x[,4]+20)^2-m4)/sqrt(v4);

# instrumental variable

eta&lt;- z[,1:4]
iv&lt;- rbinom(n,1,prob=expit(eta));

# unmeasured confounder in latent index model
u&lt;- rlogis(n, location = 0, scale = 1);

# treatment
eta.d&lt;- 1+cbind(iv,z[,1:4])
tr&lt;- as.numeric(eta.d &gt;=u);

# outcome
late  &lt;- 1
eta.y &lt;- late*tr +z[,1:4]
y &lt;- rnorm(n, mean=eta.y, sd=1)

# save; if using main effects of x, then both the instrument propensity score
# and outcome models are misspecified

simu.iv.data &lt;- cbind(y,tr,iv,x)

save(simu.iv.data, file="simu.iv.data.rda")
</pre> 

<h3>References</h3>

<p>Tan, Z. (2020) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>
<p>Sun, B. and Tan, Z. (2020) High-dimensional model-assisted inference for local average treatment effects with instrumental variables, arXiv:2009.09286.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
