<!DOCTYPE html><html><head><title>Help for package reqres</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reqres}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#default_formatters'><p>A list of default formatter mappings</p></a></li>
<li><a href='#default_parsers'><p>A list of default parser mappings</p></a></li>
<li><a href='#formatters'><p>Pre-supplied formatting generators</p></a></li>
<li><a href='#parsers'><p>Pre-supplied parsing generators</p></a></li>
<li><a href='#reqres-package'><p>reqres: Powerful Classes for HTTP Requests and Responses</p></a></li>
<li><a href='#Request'><p>HTTP Request Handling</p></a></li>
<li><a href='#Response'><p>HTTP Response handling</p></a></li>
<li><a href='#to_http_date'><p>Format timestamps to match the HTTP specs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Powerful Classes for HTTP Requests and Responses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In order to facilitate parsing of http requests and creating 
    appropriate responses this package provides two classes to handle a lot of
    the housekeeping involved in working with http exchanges. The infrastructure
    builds upon the 'rook' specification and is thus well suited to be combined
    with 'httpuv' based web servers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, assertthat, stringi, urltools, tools, brotli, jsonlite,
xml2, webutils, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fiery, testthat, covr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://reqres.data-imaginist.com">https://reqres.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/reqres#reqres">https://github.com/thomasp85/reqres#reqres</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/reqres/issues">https://github.com/thomasp85/reqres/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-19 12:25:20 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 12:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='default_formatters'>A list of default formatter mappings</h2><span id='topic+default_formatters'></span>

<h3>Description</h3>

<p>This list matches the most normal mime types with their respective formatters
using default arguments. For a no-frills request parsing this can be supplied
directly to <code>Response$format()</code>. To add or modify to this list simply supply
the additional parsers as second, third, etc, argument and they will
overwrite or add depending on whether it specifies a mime type already
present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_formatters
</code></pre>


<h3>See Also</h3>

<p><a href="#topic+formatters">formatters</a> for an overview of the build in formatters in <code>reqres</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res$format(default_formatters, 'text/plain' = format_plain(sep = ' '))

## End(Not run)

</code></pre>

<hr>
<h2 id='default_parsers'>A list of default parser mappings</h2><span id='topic+default_parsers'></span>

<h3>Description</h3>

<p>This list matches the most normal mime types with their respective parsers
using default arguments. For a no-frills request parsing this can be supplied
directly to <code>Request$parse()</code>. To add or modify to this list simply supply
the additional parsers as second, third, etc, argument and they will
overwrite or add depending on whether it specifies a mime type already
present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_parsers
</code></pre>


<h3>See Also</h3>

<p><a href="#topic+parsers">parsers</a> for an overview of the build in parsers in <code>reqres</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
req$parse(default_parsers, 'application/json' = parse_json(flatten = TRUE))

## End(Not run)

</code></pre>

<hr>
<h2 id='formatters'>Pre-supplied formatting generators</h2><span id='topic+formatters'></span><span id='topic+format_json'></span><span id='topic+format_plain'></span><span id='topic+format_xml'></span><span id='topic+format_html'></span><span id='topic+format_table'></span>

<h3>Description</h3>

<p>This set of functions can be used to construct formatting functions adhering
to the Response$format() requirements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_json(
  dataframe = "rows",
  matrix = "rowmajor",
  Date = "ISO8601",
  POSIXt = "string",
  factor = "string",
  complex = "string",
  raw = "base64",
  null = "list",
  na = "null",
  auto_unbox = FALSE,
  digits = 4,
  pretty = FALSE,
  force = FALSE
)

format_plain(sep = "\n")

format_xml(encoding = "UTF-8", options = "as_xml")

format_html(encoding = "UTF-8", options = "as_html")

format_table(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatters_+3A_dataframe">dataframe</code></td>
<td>
<p>how to encode data.frame objects: must be one of 'rows', 'columns' or 'values'</p>
</td></tr>
<tr><td><code id="formatters_+3A_matrix">matrix</code></td>
<td>
<p>how to encode matrices and higher dimensional arrays: must be one of 'rowmajor' or 'columnmajor'.</p>
</td></tr>
<tr><td><code id="formatters_+3A_date">Date</code></td>
<td>
<p>how to encode Date objects: must be one of 'ISO8601' or 'epoch'</p>
</td></tr>
<tr><td><code id="formatters_+3A_posixt">POSIXt</code></td>
<td>
<p>how to encode POSIXt (datetime) objects: must be one of 'string', 'ISO8601', 'epoch' or 'mongo'</p>
</td></tr>
<tr><td><code id="formatters_+3A_factor">factor</code></td>
<td>
<p>how to encode factor objects: must be one of 'string' or 'integer'</p>
</td></tr>
<tr><td><code id="formatters_+3A_complex">complex</code></td>
<td>
<p>how to encode complex numbers: must be one of 'string' or 'list'</p>
</td></tr>
<tr><td><code id="formatters_+3A_raw">raw</code></td>
<td>
<p>how to encode raw objects: must be one of 'base64', 'hex' or 'mongo'</p>
</td></tr>
<tr><td><code id="formatters_+3A_null">null</code></td>
<td>
<p>how to encode NULL values within a list: must be one of 'null' or 'list'</p>
</td></tr>
<tr><td><code id="formatters_+3A_na">na</code></td>
<td>
<p>how to print NA values: must be one of 'null' or 'string'. Defaults are class specific</p>
</td></tr>
<tr><td><code id="formatters_+3A_auto_unbox">auto_unbox</code></td>
<td>
<p>automatically <code><a href="jsonlite.html#topic+unbox">unbox()</a></code> all atomic vectors of length 1. It is usually safer to avoid this and instead use the <code><a href="jsonlite.html#topic+unbox">unbox()</a></code> function to unbox individual elements.
An exception is that objects of class <code>AsIs</code> (i.e. wrapped in <code><a href="base.html#topic+I">I()</a></code>) are not automatically unboxed. This is a way to mark single values as length-1 arrays.</p>
</td></tr>
<tr><td><code id="formatters_+3A_digits">digits</code></td>
<td>
<p>max number of decimal digits to print for numeric values. Use <code><a href="base.html#topic+I">I()</a></code> to specify significant digits. Use <code>NA</code> for max precision.</p>
</td></tr>
<tr><td><code id="formatters_+3A_pretty">pretty</code></td>
<td>
<p>adds indentation whitespace to JSON output. Can be TRUE/FALSE or a number specifying the number of spaces to indent. See <code><a href="jsonlite.html#topic+prettify">prettify()</a></code></p>
</td></tr>
<tr><td><code id="formatters_+3A_force">force</code></td>
<td>
<p>unclass/skip objects of classes with no defined JSON mapping</p>
</td></tr>
<tr><td><code id="formatters_+3A_sep">sep</code></td>
<td>
<p>The line separator. Plain text will be split into multiple strings
based on this.</p>
</td></tr>
<tr><td><code id="formatters_+3A_encoding">encoding</code></td>
<td>
<p>The character encoding to use in the document. The default
encoding is &lsquo;UTF-8&rsquo;. Available encodings are specified at
<a href="http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding">http://xmlsoft.org/html/libxml-encoding.html#xmlCharEncoding</a>.</p>
</td></tr>
<tr><td><code id="formatters_+3A_options">options</code></td>
<td>
<p>default: &lsquo;format&rsquo;. Zero or more of
</p>

<dl>
<dt>format</dt><dd><p>Format output</p>
</dd>
<dt>no_declaration</dt><dd><p>Drop the XML declaration</p>
</dd>
<dt>no_empty_tags</dt><dd><p>Remove empty tags</p>
</dd>
<dt>no_xhtml</dt><dd><p>Disable XHTML1 rules</p>
</dd>
<dt>require_xhtml</dt><dd><p>Force XHTML rules</p>
</dd>
<dt>as_xml</dt><dd><p>Force XML output</p>
</dd>
<dt>as_html</dt><dd><p>Force HTML output</p>
</dd>
<dt>format_whitespace</dt><dd><p>Format with non-significant whitespace</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="formatters_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="utils.html#topic+write.table">write.table()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function accepting an R object
</p>


<h3>See Also</h3>

<p><a href="#topic+parsers">parsers</a> for converting <code>Request</code> bodies into R objects
</p>
<p><a href="#topic+default_formatters">default_formatters</a> for a list that maps the most common mime types
to their respective formatters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fake_rook &lt;- fiery::fake_request(
  'http://example.com/test',
  content = '',
  headers = list(
    Content_Type = 'text/plain',
    Accept = 'application/json, text/csv'
  )
)

req &lt;- Request$new(fake_rook)
res &lt;- req$respond()
res$body &lt;- mtcars
res$format(json = format_json(), csv = format_table(sep=','))
res$body

# Cleaning up connections
rm(fake_rook, req, res)
gc()

</code></pre>

<hr>
<h2 id='parsers'>Pre-supplied parsing generators</h2><span id='topic+parsers'></span><span id='topic+parse_json'></span><span id='topic+parse_plain'></span><span id='topic+parse_xml'></span><span id='topic+parse_html'></span><span id='topic+parse_multiform'></span><span id='topic+parse_queryform'></span><span id='topic+parse_table'></span>

<h3>Description</h3>

<p>This set of functions can be used to construct parsing functions adhering to
the Request$parse() requirements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_json(
  simplifyVector = TRUE,
  simplifyDataFrame = simplifyVector,
  simplifyMatrix = simplifyVector,
  flatten = FALSE
)

parse_plain(sep = "\n")

parse_xml(encoding = "", options = "NOBLANKS", base_url = "")

parse_html(
  encoding = "",
  options = c("RECOVER", "NOERROR", "NOBLANKS"),
  base_url = ""
)

parse_multiform()

parse_queryform()

parse_table(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parsers_+3A_simplifyvector">simplifyVector</code></td>
<td>
<p>coerce JSON arrays containing only primitives into an atomic vector</p>
</td></tr>
<tr><td><code id="parsers_+3A_simplifydataframe">simplifyDataFrame</code></td>
<td>
<p>coerce JSON arrays containing only records (JSON objects) into a data frame</p>
</td></tr>
<tr><td><code id="parsers_+3A_simplifymatrix">simplifyMatrix</code></td>
<td>
<p>coerce JSON arrays containing vectors of equal mode and dimension into matrix or array</p>
</td></tr>
<tr><td><code id="parsers_+3A_flatten">flatten</code></td>
<td>
<p>automatically <code><a href="jsonlite.html#topic+flatten">flatten()</a></code> nested data frames into a single non-nested data frame</p>
</td></tr>
<tr><td><code id="parsers_+3A_sep">sep</code></td>
<td>
<p>The line separator. Plain text will be split into multiple strings
based on this.</p>
</td></tr>
<tr><td><code id="parsers_+3A_encoding">encoding</code></td>
<td>
<p>Specify a default encoding for the document. Unless
otherwise specified XML documents are assumed to be in UTF-8 or
UTF-16. If the document is not UTF-8/16, and lacks an explicit
encoding directive, this allows you to supply a default.</p>
</td></tr>
<tr><td><code id="parsers_+3A_options">options</code></td>
<td>
<p>Set parsing options for the libxml2 parser. Zero or more of
</p>

<dl>
<dt>RECOVER</dt><dd><p>recover on errors</p>
</dd>
<dt>NOENT</dt><dd><p>substitute entities</p>
</dd>
<dt>DTDLOAD</dt><dd><p>load the external subset</p>
</dd>
<dt>DTDATTR</dt><dd><p>default DTD attributes</p>
</dd>
<dt>DTDVALID</dt><dd><p>validate with the DTD</p>
</dd>
<dt>NOERROR</dt><dd><p>suppress error reports</p>
</dd>
<dt>NOWARNING</dt><dd><p>suppress warning reports</p>
</dd>
<dt>PEDANTIC</dt><dd><p>pedantic error reporting</p>
</dd>
<dt>NOBLANKS</dt><dd><p>remove blank nodes</p>
</dd>
<dt>SAX1</dt><dd><p>use the SAX1 interface internally</p>
</dd>
<dt>XINCLUDE</dt><dd><p>Implement XInclude substitition</p>
</dd>
<dt>NONET</dt><dd><p>Forbid network access</p>
</dd>
<dt>NODICT</dt><dd><p>Do not reuse the context dictionary</p>
</dd>
<dt>NSCLEAN</dt><dd><p>remove redundant namespaces declarations</p>
</dd>
<dt>NOCDATA</dt><dd><p>merge CDATA as text nodes</p>
</dd>
<dt>NOXINCNODE</dt><dd><p>do not generate XINCLUDE START/END nodes</p>
</dd>
<dt>COMPACT</dt><dd><p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p>
</dd>
<dt>OLD10</dt><dd><p>parse using XML-1.0 before update 5</p>
</dd>
<dt>NOBASEFIX</dt><dd><p>do not fixup XINCLUDE xml:base uris</p>
</dd>
<dt>HUGE</dt><dd><p>relax any hardcoded limit from the parser</p>
</dd>
<dt>OLDSAX</dt><dd><p>parse using SAX2 interface before 2.7.0</p>
</dd>
<dt>IGNORE_ENC</dt><dd><p>ignore internal document encoding hint</p>
</dd>
<dt>BIG_LINES</dt><dd><p>Store big lines numbers in text PSVI field</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="parsers_+3A_base_url">base_url</code></td>
<td>
<p>When loading from a connection, raw vector or literal
html/xml, this allows you to specify a base url for the document. Base
urls are used to turn relative urls into absolute urls.</p>
</td></tr>
<tr><td><code id="parsers_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="utils.html#topic+read.table">read.table()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function accepting a raw vector and a named list of directives
</p>


<h3>See Also</h3>

<p><a href="#topic+formatters">formatters</a> for converting <code>Response</code> bodies into compatible types
</p>
<p><a href="#topic+default_parsers">default_parsers</a> for a list that maps the most common mime types
to their respective parsers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fake_rook &lt;- fiery::fake_request(
  'http://example.com/test',
  content = '[1, 2, 3, 4]',
  headers = list(
    Content_Type = 'application/json'
  )
)

req &lt;- Request$new(fake_rook)
req$parse(json = parse_json())
req$body

# Cleaning up connections
rm(fake_rook, req)
gc()

</code></pre>

<hr>
<h2 id='reqres-package'>reqres: Powerful Classes for HTTP Requests and Responses</h2><span id='topic+reqres'></span><span id='topic+reqres-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>In order to facilitate parsing of http requests and creating appropriate responses this package provides two classes to handle a lot of the housekeeping involved in working with http exchanges. The infrastructure builds upon the 'rook' specification and is thus well suited to be combined with 'httpuv' based web servers.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://reqres.data-imaginist.com">https://reqres.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/reqres#reqres">https://github.com/thomasp85/reqres#reqres</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/reqres/issues">https://github.com/thomasp85/reqres/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Request'>HTTP Request Handling</h2><span id='topic+Request'></span><span id='topic+as.Request'></span><span id='topic+is.Request'></span>

<h3>Description</h3>

<p>This class wraps all functionality related to extracting information from a
http request. Much of the functionality is inspired by the Request class in
Express.js, so <a href="https://expressjs.com/en/4x/api.html#req">the documentation</a>
for this will complement this document. As <code>reqres</code> is build on top of the
<a href="https://github.com/jeffreyhorner/Rook/blob/a5e45f751/README.md">Rook specifications</a>
the <code>Request</code> object is initialized from a Rook-compliant object. This will
often be the request object provided by the <code>httpuv</code> framework. While it
shouldn't be needed, the original Rook object is always accessible and can be
modified, though any modifications will not propagate to derived values in
the <code>Request</code> object (e.g. changing the <code>HTTP_HOST</code> element of the Rook
object will not change the <code>host</code> field of the <code>Request</code> object). Because of
this, direct manipulation of the Rook object is generally discouraged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Request(x, ...)

is.Request(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Request_+3A_x">x</code></td>
<td>
<p>An object coercible to a <code>Request</code>.</p>
</td></tr>
<tr><td><code id="Request_+3A_...">...</code></td>
<td>
<p>Parameters passed on to <code>Request$new()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Request</code> object (for <code>as.Request()</code>) or a logical indicating whether
the object is a <code>Request</code> (for <code>is.Request()</code>)
</p>


<h3>Initialization</h3>

<p>A new 'Request'-object is initialized using the <code>new()</code> method on the
generator:
</p>
<p><strong>Usage</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>req &lt;- Request$new(rook, trust = FALSE)</code>
</td>
</tr>

</table>

<p><strong>Arguments</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>rook</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> The rook request that the new object should wrap</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>trust</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> Is this request trusted blindly. If <code>TRUE</code> <code style="white-space: pre;">&#8288;X-Forwarded-*&#8288;</code> headers will be returned when querying host, ip, and protocol
</td>
</tr>

</table>



<h3>Fields</h3>

<p>The following fields are accessible in a <code>Request</code> object:
</p>

<dl>
<dt><code>trust</code></dt><dd><p>A logical indicating whether the request is trusted. <em>Mutable</em></p>
</dd>
<dt><code>method</code></dt><dd><p>A string indicating the request method (in lower case, e.g.
'get', 'put', etc.). <em>Immutable</em></p>
</dd>
<dt><code>body</code></dt><dd><p>An object holding the body of the request. This is an empty
string by default and needs to be populated using the <code>set_body()</code> method
(this is often done using a body parser that accesses the Rook$input
stream). <em>Immutable</em></p>
</dd>
<dt><code>cookies</code></dt><dd><p>Access a named list of all cookies in the request. These
have been URI decoded. <em>Immutable</em></p>
</dd>
<dt><code>headers</code></dt><dd><p>Access a named list of all headers in the request. In order
to follow R variable naming standards <code>-</code> have been substituted with <code style="white-space: pre;">&#8288;_&#8288;</code>.
Use the <code>get_header()</code> method to lookup based on the correct header name.
<em>Immutable</em></p>
</dd>
<dt><code>host</code></dt><dd><p>Return the domain of the server given by the &quot;Host&quot; header if
<code>trust == FALSE</code>. If <code>trust == true</code> returns the <code>X-Forwarded-Host</code> instead.</p>
</dd>
<dt><code>ip</code></dt><dd><p>Returns the remote address of the request if <code>trust == FALSE</code>.
if <code>trust == TRUE</code> it will instead return the first value of the
<code>X-Forwarded-For</code> header. <em>Immutable</em></p>
</dd>
<dt><code>ips</code></dt><dd><p>If <code>trust == TRUE</code> it will return the full list of ips in the
<code>X-Forwarded-For</code> header. If <code>trust == FALSE</code> it will return an empty
vector. <em>Immutable</em></p>
</dd>
<dt><code>protocol</code></dt><dd><p>Returns the protocol (e.g. 'http') used for the request.
If <code>trust == TRUE</code> it will use the value of the <code>X-Forwarded-Proto</code> header.
<em>Immutable</em></p>
</dd>
<dt><code>root</code></dt><dd><p>The mount point of the application receiving this request. Can
be empty if the application is mounted on the server root. <em>Immutable</em></p>
</dd>
<dt><code>path</code></dt><dd><p>The part of the url following the root. Defines the local
target of the request (independent of where it is mounted). <em>Immutable</em></p>
</dd>
<dt><code>url</code></dt><dd><p>The full URL of the request. <em>Immutable</em></p>
</dd>
<dt><code>query</code></dt><dd><p>The query string of the request (anything following &quot;?&quot; in
the URL) parsed into a named list. The query has been url decoded and &quot;+&quot;
has been substituted with space. Multiple queries are expected to be
separated by either &quot;&amp;&quot; or &quot;|&quot;. <em>Immutable</em></p>
</dd>
<dt><code>querystring</code></dt><dd><p>The unparsed query string of the request, including
&quot;?&quot;. If no query string exists it will be <code>""</code> rather than <code>"?"</code></p>
</dd>
<dt><code>xhr</code></dt><dd><p>A logical indicating whether the <code>X-Requested-With</code> header
equals <code>XMLHttpRequest</code> thus indicating that the request was performed using
a JavaScript library such as jQuery. <em>Immutable</em></p>
</dd>
<dt><code>secure</code></dt><dd><p>A logical indicating whether the request was performed using
a secure connection, i.e. <code>protocol == 'https'</code>. <em>Immutable</em></p>
</dd>
<dt><code>origin</code></dt><dd><p>The original object used to create the <code>Request</code> object. As
<code>reqres</code> currently only works with rook this will always return the original
rook object. <em>Immutable</em>, though the content of the rook object itself might
be manipulated as it is an environment.</p>
</dd>
<dt><code>response</code></dt><dd><p>If a <code>Response</code> object has been created for this request
it is accessible through this field. <em>Immutable</em></p>
</dd>
</dl>



<h3>Methods</h3>

<p>The following methods are available in a <code>Request</code> object:
</p>

<dl>
<dt><code>set_body(content)</code></dt><dd><p>Sets the content of the request body. This method
should mainly be used in concert with a body parser that reads the
<code>rook$input</code> stream</p>
</dd>
<dt><code>set_cookies(cookies)</code></dt><dd><p>Sets the cookies of the request. The cookies
are automatically parsed and populated, so this method is mainly available
to facilitate cookie signing and encryption</p>
</dd>
<dt><code>get_header(name)</code></dt><dd><p>Get the header of the specified name.</p>
</dd>
<dt><code>accepts(types)</code></dt><dd><p>Given a vector of response content types it returns
the preferred one based on the <code>Accept</code> header.</p>
</dd>
<dt><code>accepts_charsets(charsets)</code></dt><dd><p>Given a vector of possible character
encodings it returns the preferred one based on the <code>Accept-Charset</code>
header.</p>
</dd>
<dt><code>accepts_encoding(encoding)</code></dt><dd><p>Given a vector of possible content
encodings (usually compression algorithms) it selects the preferred one
based on the <code>Accept-Encoding</code> header. If there is no match it will return
<code>"identity"</code> signaling no compression.</p>
</dd>
<dt><code>accepts_language(language)</code></dt><dd><p>Given a vector of possible content
languages it selects the best one based on the <code>Accept-Language</code> header.</p>
</dd>
<dt><code>is(type)</code></dt><dd><p>Queries whether the body of the request is in a given
format by looking at the <code>Content-Type</code> header. Used for selecting the best
parsing method.</p>
</dd>
<dt><code>respond()</code></dt><dd><p>Creates a new <code>Response</code> object from the request</p>
</dd>
<dt><code>parse(..., autofail = TRUE)</code></dt><dd><p>Based on provided parsers it selects
the appropriate one by looking at the <code>Content-Type</code> header and assigns the
result to the request body. A parser is a function accepting a raw vector,
and a named list of additional directives,
and returns an R object of any kind (if the parser knows the input to be
plain text, simply wrap it in <code><a href="base.html#topic+rawToChar">rawToChar()</a></code>). If the body is compressed, it
will be decompressed based on the <code>Content-Encoding</code> header prior to passing
it on to the parser. See <a href="#topic+parsers">parsers</a> for a list of pre-supplied parsers.
Parsers are either supplied in a named list or as named arguments to the
parse method. The names should correspond to mime types or known file
extensions. If <code>autofail = TRUE</code> the response will be set with the correct
error code if parsing fails. <code>parse()</code> returns <code>TRUE</code> if parsing was
successful and <code>FALSE</code> if not</p>
</dd>
<dt><code>parse_raw(autofail = TRUE)</code></dt><dd><p>This is a simpler version of the
<code>parse()</code> method. It will attempt to decompress the body and set the <code>body</code>
field to the resulting raw vector. It is then up to the server to decide how
to handle the payload. It returns <code>TRUE</code> if successful and <code>FALSE</code>
otherwise.</p>
</dd>
<dt><code>as_message()</code></dt><dd><p>Prints a HTTP representation of the request to the
output stream.</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Request-new"><code>Request$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-print"><code>Request$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-set_body"><code>Request$set_body()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-set_cookies"><code>Request$set_cookies()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-accepts"><code>Request$accepts()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-accepts_charsets"><code>Request$accepts_charsets()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-accepts_encoding"><code>Request$accepts_encoding()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-accepts_language"><code>Request$accepts_language()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-is"><code>Request$is()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-get_header"><code>Request$get_header()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-respond"><code>Request$respond()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-parse"><code>Request$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-parse_raw"><code>Request$parse_raw()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-as_message"><code>Request$as_message()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-clone"><code>Request$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Request-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$new(rook, trust = FALSE)</pre></div>


<hr>
<a id="method-Request-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$print(...)</pre></div>


<hr>
<a id="method-Request-set_body"></a>



<h4>Method <code>set_body()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$set_body(content)</pre></div>


<hr>
<a id="method-Request-set_cookies"></a>



<h4>Method <code>set_cookies()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$set_cookies(cookies)</pre></div>


<hr>
<a id="method-Request-accepts"></a>



<h4>Method <code>accepts()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$accepts(types)</pre></div>


<hr>
<a id="method-Request-accepts_charsets"></a>



<h4>Method <code>accepts_charsets()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$accepts_charsets(charsets)</pre></div>


<hr>
<a id="method-Request-accepts_encoding"></a>



<h4>Method <code>accepts_encoding()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$accepts_encoding(encoding)</pre></div>


<hr>
<a id="method-Request-accepts_language"></a>



<h4>Method <code>accepts_language()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$accepts_language(language)</pre></div>


<hr>
<a id="method-Request-is"></a>



<h4>Method <code>is()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$is(type)</pre></div>


<hr>
<a id="method-Request-get_header"></a>



<h4>Method <code>get_header()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$get_header(name)</pre></div>


<hr>
<a id="method-Request-respond"></a>



<h4>Method <code>respond()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$respond()</pre></div>


<hr>
<a id="method-Request-parse"></a>



<h4>Method <code>parse()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$parse(..., autofail = TRUE)</pre></div>


<hr>
<a id="method-Request-parse_raw"></a>



<h4>Method <code>parse_raw()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$parse_raw(autofail = TRUE)</pre></div>


<hr>
<a id="method-Request-as_message"></a>



<h4>Method <code>as_message()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$as_message()</pre></div>


<hr>
<a id="method-Request-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Response">Response</a></code> for handling http responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fake_rook &lt;- fiery::fake_request(
  'http://example.com/test?id=34632&amp;question=who+is+hadley',
  content = 'This is an elaborate ruse',
  headers = list(
    Accept = 'application/json; text/*',
    Content_Type = 'text/plain'
  )
)

req &lt;- Request$new(fake_rook)

# Get full URL
req$url

# Get list of query parameters
req$query

# Test if content is text
req$is('txt')

# Perform content negotiation for the response
req$accepts(c('html', 'json', 'txt'))

# Cleaning up connections
rm(fake_rook, req)
gc()

</code></pre>

<hr>
<h2 id='Response'>HTTP Response handling</h2><span id='topic+Response'></span><span id='topic+as.list.Response'></span><span id='topic+is.Response'></span>

<h3>Description</h3>

<p>This class handles all functionality involved in crafting a http response.
Much of the functionality is inspired by the Request class in Express.js, so
<a href="https://expressjs.com/en/4x/api.html#res">the documentation</a> for this will
complement this document. As <code>reqres</code> is build on top of the
<a href="https://github.com/jeffreyhorner/Rook/blob/a5e45f751/README.md">Rook specifications</a>
the <code>Response</code> object can be converted to a compliant list object to be
passed on to e.g. the <code>httpuv</code> handler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Response'
as.list(x, ...)

is.Response(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Response_+3A_x">x</code></td>
<td>
<p>A <code>Response</code> object</p>
</td></tr>
<tr><td><code id="Response_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>Response</code> object is always created
as a response to a <code>Request</code> object and contains a reference to the
originating <code>Request</code> object. A <code>Response</code> is always initialized with a
404 Not Found code, an empty string as body and the <code>Content-Type</code> header set
to <code>text/plain</code>. As the <code>Content-Type</code> header is required for <code>httpuv</code> to
function, it will be inferred if missing when converting to a list. If the
body is a raw vector it will be set to <code>application/octet-stream</code> and
otherwise it will be set to <code>text/plain</code>. It is always advised to consciously
set the <code>Content-Type</code> header though. The only exception is when attaching a
standard file where the type is inferred from the file extension
automatically. Unless the body is a raw vector it will automatically be
converted to a character vector and collapsed to a single string with <code>"\n"</code>
separating the individual elements before the <code>Response</code> object is converted
to a list (that is, the body can exist as any type of object up until the
moment where the <code>Response</code> object is converted to a list). To facilitate
communication between different middleware the <code>Response</code> object contains
a data store where information can be stored during the lifetime of the
response.
</p>


<h3>Value</h3>

<p>A rook-compliant list-response (in case of <code>as.list()</code>) or a logical
indicating whether the object is a <code>Response</code> (in case of <code>is.Response()</code>)
</p>


<h3>Initialization</h3>

<p>A new 'Response'-object is initialized using the <code>new()</code> method on the
generator:
</p>
<p><strong>Usage</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>res &lt;- Response$new(request)</code>
</td>
</tr>

</table>

<p>But often it will be provided by the request using the <code>respond()</code> method,
which will provide the response, creating one if it doesn't exist
</p>
<p><strong>Usage</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>res &lt;- request$respond()</code>
</td>
</tr>

</table>

<p><strong>Arguments</strong>
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>request</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> The <code>Request</code> object that the <code>Response</code> is responding to</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Fields</h3>

<p>The following fields are accessible in a <code>Response</code> object:
</p>

<dl>
<dt><code>status</code></dt><dd><p>Gets or sets the status code of the response. Is initialised
with <code>404L</code></p>
</dd>
<dt><code>body</code></dt><dd><p>Set or get he body of the response. If it is a character
vector with a single element named <code>'file'</code> it will be interpreted as the
location of a file. It is better to use the <code>file</code> field for creating a
response referencing a file as it will automatically set the correct
headers.</p>
</dd>
<dt><code>file</code></dt><dd><p>Set or get the location of a file that should be used as the
body of the response. If the body is not referencing a file (but contains
something else) it will return <code>NULL</code>. The <code>Content-Type</code> header will
automatically be inferred from the file extension, if known. If unknown it
will defaults to <code>application/octet-stream</code>. If the file has no extension it
will be <code>text/plain</code>. Existence of the file will be checked.</p>
</dd>
<dt><code>type</code></dt><dd><p>Get or sets the <code>Content-Type</code> header of the response based on
a file extension or mime-type.</p>
</dd>
<dt><code>request</code></dt><dd><p>Get the original <code>Request</code> object that the object is
responding to.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>The following methods are available in a <code>Response</code> object:
</p>

<dl>
<dt><code>set_header(name, value)</code></dt><dd><p>Sets the header given by <code>name</code>. <code>value</code>
will be converted to character. A header will be added for each element in
<code>value</code>. Use <code>append_header()</code> for setting headers without overwriting
existing ones.</p>
</dd>
<dt><code>get_header(name)</code></dt><dd><p>Returns the header(s) given by <code>name</code></p>
</dd>
<dt><code>remove_header(name)</code></dt><dd><p>Removes all headers given by <code>name</code></p>
</dd>
<dt><code>has_header(name)</code></dt><dd><p>Test for the existence of any header given by
<code>name</code></p>
</dd>
<dt><code>append_header(name, value)</code></dt><dd><p>Adds an additional header given by
<code>name</code> with the value given by <code>value</code>. If the header does not exist yet it
will be created.</p>
</dd>
<dt><code>set_data(key, value)</code></dt><dd><p>Adds <code>value</code> to the internal data store and
stores it with <code>key</code></p>
</dd>
<dt><code>get_data(key)</code></dt><dd><p>Retrieves the data stored under <code>key</code> in the internal
data store.</p>
</dd>
<dt><code>remove_data(key)</code></dt><dd><p>Removes the data stored under <code>key</code> in the
internal data store.</p>
</dd>
<dt><code>has_data(key)</code></dt><dd><p>Queries whether the data store has an entry given by
<code>key</code></p>
</dd>
<dt><code>attach(file, filename=basename(file), type=NULL)</code></dt><dd><p>Sets the body to
the file given by <code>file</code> and marks the response as a download by setting the
<code>Content-Disposition</code> to <code style="white-space: pre;">&#8288;attachment; filename=&lt;filename&gt;&#8288;</code>. Use the <code>type</code>
argument to overwrite the automatic type inference from the file extension.</p>
</dd>
<dt><code>status_with_text(code)</code></dt><dd><p>Sets the status to <code>code</code> and sets the body
to the associated status code description (e.g. <code style="white-space: pre;">&#8288;Bad Gateway&#8288;</code> for <code>502L</code>)</p>
</dd>
<dt><code>set_cookie(name, value, encode = TRUE, expires = NULL, http_only = NULL, max_age = NULL, path = NULL, secure = NULL, same_site = NULL)</code></dt><dd><p>Adds
the cookie given by <code>name</code> to the given <code>value</code>, optionally url encoding it,
along with any additional directives. See
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie</a> for a
description of the different directives. If the cookie already exists it
will be overwritten. The validity of the directives will automatically be
checked. <code>expires</code> expects a POSIXct object, <code>http_only</code> and <code>secure</code> expect
a logical, <code>max_age</code> expects an integer, <code>path</code> a string, and <code>same_site</code>
either <code>"Lax"</code> or <code>"Strict"</code></p>
</dd>
<dt><code>remove_cookie(name)</code></dt><dd><p>Removes the cookie named <code>name</code> from the
response.</p>
</dd>
<dt><code>has_cookie(name)</code></dt><dd><p>Queries whether the response contains a cookie
named <code>name</code></p>
</dd>
<dt><code>set_links(...)</code></dt><dd><p>Sets the <code>Link</code> header based on the named arguments
passed to <code>...</code>. The names will be used for the <code>rel</code> directive.</p>
</dd>
<dt><code>format(..., autofail = TRUE, compress = TRUE)</code></dt><dd><p>Based on the
formatters passed in through <code>...</code> content negotiation is performed with
request and the preferred formatter is chosen. The <code>Content-Type</code> header is
set automatically. If <code>compress = TRUE</code> the
<code>compress()</code> method will be called after formatting. If an error is
encountered and <code>autofail = TRUE</code> the response will be set to <code>500</code>. If a
formatter is not found and <code>autofail = TRUE</code> the response will be set to
<code>406</code>. If formatting is successful it will return <code>TRUE</code>, if not it will
return <code>FALSE</code></p>
</dd>
<dt><code>compress(priority = c('gzip', 'deflate', 'br', 'identity'))</code></dt><dd><p>Based
on the provided priority, an encoding is negotiated with the request and
applied. The <code>Content-Encoding</code> header is set to the chosen compression
algorithm.</p>
</dd>
<dt><code>content_length()</code></dt><dd><p>Calculates the length (in bytes) of the body.
This is the number that goes into the <code>Content-Length</code> header. Note that the
<code>Content-Length</code> header is set automatically by <code>httpuv</code> so this method
should only be called if the response size is needed for other reasons.</p>
</dd>
<dt><code>as_list()</code></dt><dd><p>Converts the object to a list for further processing by
a Rook compliant server such as <code>httpuv</code>. Will set <code>Content-Type</code> header if
missing and convert a non-raw body to a single character string.</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Response-new"><code>Response$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-print"><code>Response$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_header"><code>Response$set_header()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-get_header"><code>Response$get_header()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-remove_header"><code>Response$remove_header()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-has_header"><code>Response$has_header()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-append_header"><code>Response$append_header()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_data"><code>Response$set_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-get_data"><code>Response$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-remove_data"><code>Response$remove_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-has_data"><code>Response$has_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-timestamp"><code>Response$timestamp()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-attach"><code>Response$attach()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-status_with_text"><code>Response$status_with_text()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_cookie"><code>Response$set_cookie()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-remove_cookie"><code>Response$remove_cookie()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-has_cookie"><code>Response$has_cookie()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_links"><code>Response$set_links()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-format"><code>Response$format()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-compress"><code>Response$compress()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-content_length"><code>Response$content_length()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-as_list"><code>Response$as_list()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-as_message"><code>Response$as_message()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-clone"><code>Response$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Response-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$new(request)</pre></div>


<hr>
<a id="method-Response-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$print(...)</pre></div>


<hr>
<a id="method-Response-set_header"></a>



<h4>Method <code>set_header()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$set_header(name, value)</pre></div>


<hr>
<a id="method-Response-get_header"></a>



<h4>Method <code>get_header()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$get_header(name)</pre></div>


<hr>
<a id="method-Response-remove_header"></a>



<h4>Method <code>remove_header()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$remove_header(name)</pre></div>


<hr>
<a id="method-Response-has_header"></a>



<h4>Method <code>has_header()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$has_header(name)</pre></div>


<hr>
<a id="method-Response-append_header"></a>



<h4>Method <code>append_header()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$append_header(name, value)</pre></div>


<hr>
<a id="method-Response-set_data"></a>



<h4>Method <code>set_data()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$set_data(key, value)</pre></div>


<hr>
<a id="method-Response-get_data"></a>



<h4>Method <code>get_data()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$get_data(key)</pre></div>


<hr>
<a id="method-Response-remove_data"></a>



<h4>Method <code>remove_data()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$remove_data(key)</pre></div>


<hr>
<a id="method-Response-has_data"></a>



<h4>Method <code>has_data()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$has_data(key)</pre></div>


<hr>
<a id="method-Response-timestamp"></a>



<h4>Method <code>timestamp()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$timestamp()</pre></div>


<hr>
<a id="method-Response-attach"></a>



<h4>Method <code>attach()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$attach(file, filename = basename(file), type = NULL)</pre></div>


<hr>
<a id="method-Response-status_with_text"></a>



<h4>Method <code>status_with_text()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$status_with_text(code)</pre></div>


<hr>
<a id="method-Response-set_cookie"></a>



<h4>Method <code>set_cookie()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$set_cookie(
  name,
  value,
  encode = TRUE,
  expires = NULL,
  http_only = NULL,
  max_age = NULL,
  path = NULL,
  secure = NULL,
  same_site = NULL
)</pre></div>


<hr>
<a id="method-Response-remove_cookie"></a>



<h4>Method <code>remove_cookie()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$remove_cookie(name)</pre></div>


<hr>
<a id="method-Response-has_cookie"></a>



<h4>Method <code>has_cookie()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$has_cookie(name)</pre></div>


<hr>
<a id="method-Response-set_links"></a>



<h4>Method <code>set_links()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$set_links(...)</pre></div>


<hr>
<a id="method-Response-format"></a>



<h4>Method <code>format()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$format(..., autofail = TRUE, compress = TRUE)</pre></div>


<hr>
<a id="method-Response-compress"></a>



<h4>Method <code>compress()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$compress(priority = c("gzip", "deflate", "br", "identity"))</pre></div>


<hr>
<a id="method-Response-content_length"></a>



<h4>Method <code>content_length()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$content_length()</pre></div>


<hr>
<a id="method-Response-as_list"></a>



<h4>Method <code>as_list()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$as_list()</pre></div>


<hr>
<a id="method-Response-as_message"></a>



<h4>Method <code>as_message()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$as_message()</pre></div>


<hr>
<a id="method-Response-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Request">Request</a></code> for handling http requests
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fake_rook &lt;- fiery::fake_request(
  'http://example.com/test?id=34632&amp;question=who+is+hadley',
  content = 'This is elaborate ruse',
  headers = list(
    Accept = 'application/json; text/*',
    Content_Type = 'text/plain'
  )
)

req &lt;- Request$new(fake_rook)
res &lt;- Response$new(req)
res

# Set the body to the associated status text
res$status_with_text(200L)
res$body

# Infer Content-Type from file extension
res$type &lt;- 'json'
res$type

# Prepare a file for download
res$attach(system.file('DESCRIPTION', package = 'reqres'))
res$type
res$body
res$get_header('Content-Disposition')

# Cleaning up connections
rm(fake_rook, req, res)
gc()

</code></pre>

<hr>
<h2 id='to_http_date'>Format timestamps to match the HTTP specs</h2><span id='topic+to_http_date'></span><span id='topic+from_http_date'></span>

<h3>Description</h3>

<p>Dates/times in HTTP headers needs a specific format to be valid, and is
furthermore always given in GMT time. These two functions aids in converting
back and forth between the required format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_http_date(time, format = NULL)

from_http_date(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_http_date_+3A_time">time</code></td>
<td>
<p>A string or an object coercible to POSIXct</p>
</td></tr>
<tr><td><code id="to_http_date_+3A_format">format</code></td>
<td>
<p>In case <code>time</code> is not a POSIXct object a specification how the
string should be interpreted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>to_http_date()</code> returns a properly formatted string, while
<code>from_http_date()</code> returns a POSIXct object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time &lt;- to_http_date(Sys.time())
time
from_http_date(time)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
