<!DOCTYPE html><html><head><title>Help for package rotations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rotations}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Angular-distributions'><p>Angular distributions</p></a></li>
<li><a href='#Arithmetic'><p>Arithmetic operators on SO(3)</p></a></li>
<li><a href='#bayes.mean'><p>Parameter estimates based on non-informative Bayes</p></a></li>
<li><a href='#bayesCR'><p>Bayes credible regions</p></a></li>
<li><a href='#Cayley'><p>The symmetric Cayley distribution</p></a></li>
<li><a href='#cayley.kappa'><p>Circular variance and concentration parameter</p></a></li>
<li><a href='#center'><p>Center rotation data</p></a></li>
<li><a href='#chang'><p>M-estimator asymptotic confidence region</p></a></li>
<li><a href='#discord'><p>Measure of Discord</p></a></li>
<li><a href='#drill'><p>Drill data set</p></a></li>
<li><a href='#Fisher'><p>The matrix-Fisher distribution</p></a></li>
<li><a href='#fisher.kappa'><p>Circular variance and concentration parameter</p></a></li>
<li><a href='#fisheretal'><p>Transformation based pivotal bootstrap confidence region</p></a></li>
<li><a href='#genR'><p>Generate rotations</p></a></li>
<li><a href='#gradient.search'><p>Gradient optimization for rotation data</p></a></li>
<li><a href='#Haar'><p>Uniform distribution</p></a></li>
<li><a href='#head'><p>Return the First or Last Parts of an Object</p></a></li>
<li><a href='#log.SO3'><p>Rotation logarithm</p></a></li>
<li><a href='#Maxwell'><p>The modified Maxwell-Boltzmann distribution</p></a></li>
<li><a href='#maxwell.kappa'><p>Circular variance and concentration parameter</p></a></li>
<li><a href='#MCMCSO3'><p>MCMC for rotation data</p></a></li>
<li><a href='#mean'><p>Mean rotation</p></a></li>
<li><a href='#median'><p>Median rotation</p></a></li>
<li><a href='#mis.angle'><p>Misorientation angle</p></a></li>
<li><a href='#mis.axis'><p>Misorientation axis</p></a></li>
<li><a href='#Mises'><p>The circular-von Mises distribution</p></a></li>
<li><a href='#nickel'><p>Nickel electron backscatter diffraction data set</p></a></li>
<li><a href='#plot'><p>Visualizing random rotations</p></a></li>
<li><a href='#pointsXYZ'><p>Project rotation data onto sphere</p></a></li>
<li><a href='#prentice'><p>Transformation based asymptotic confidence region</p></a></li>
<li><a href='#project.SO3'><p>Projection into SO(3)</p></a></li>
<li><a href='#Q4'><p>'Q4' class for storing rotation data as quaternions</p></a></li>
<li><a href='#region'><p>Confidence and credible regions for the central orientation</p></a></li>
<li><a href='#rot.dist'><p>Rotational distance</p></a></li>
<li><a href='#rotations'><p>A package for working with rotation data.</p></a></li>
<li><a href='#rotdist.sum'><p>Sample distance</p></a></li>
<li><a href='#skew.exp'><p>Matrix exponential</p></a></li>
<li><a href='#SO3'><p>'SO3' class for storing rotation data as rotation matrices</p></a></li>
<li><a href='#tail'><p>Return the First or Last Parts of an Object</p></a></li>
<li><a href='#UARS'><p>Generic UARS Distribution</p></a></li>
<li><a href='#vmises.kappa'><p>Circular variance and concentration parameter</p></a></li>
<li><a href='#weighted.mean'><p>Weighted mean rotation</p></a></li>
<li><a href='#zhang'><p>M-estimator theory pivotal bootstrap confidence region</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Working with Rotation Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for working with rotational data, including
    simulation from the most commonly used distributions on SO(3),
    methods for different Bayes, mean and median type estimators for
    the central orientation of a sample, confidence/credible
    regions for the central orientation based on those estimators and
    a novel visualization technique for rotation data.  Most recently,
    functions to identify potentially discordant (outlying) values
    have been added.  References: Bingham, Melissa A. and Nordman, Dan J. and Vardeman, Steve B. (2009),
    Bingham, Melissa A and Vardeman, Stephen B and Nordman, Daniel J (2009),
    Bingham, Melissa A and Nordman, Daniel J and Vardeman, Stephen B (2010),
    Leon, C.A. and Masse, J.C. and Rivest, L.P. (2006),
    Hartley, R and Aftab, K and Trumpf, J. (2011),
    Stanfill, Bryan and Genschel, Ulrike and Hofmann, Heike (2013),
    Maonton, Jonathan (2004), 
    Mardia, KV and Jupp, PE (2000, ISBN:9780471953333), 
    Rancourt, D. and Rivest, L.P. and Asselin, J. (2000),
    Chang, Ted and Rivest, Louis-Paul (2001), 
    Fisher, Nicholas I. (1996, ISBN:0521568900).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, gridExtra, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, onion, orientlib, testthat, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stanfill/rotationsC">https://github.com/stanfill/rotationsC</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stanfill/rotationsC/issues">https://github.com/stanfill/rotationsC/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Q4-class.R' 'RcppExports.R' 'preliminary.R' 'SO3-class.R'
'bayes.R' 'data.R' 'distributions.R' 'estimators.R'
'grid-search.R' 'help.R' 'kappa.R' 'plot.R' 'primitives.R'
'regions.R' 'robust.R' 'rotations-package.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 13:37:48 UTC; stanfill</td>
</tr>
<tr>
<td>Author:</td>
<td>Bryan Stanfill [aut, cre],
  Heike Hofmann [aut],
  Ulrike Genschel [aut],
  Aymeric Stamm <a href="https://orcid.org/0000-0002-8725-3654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Luciano Selzer [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bryan Stanfill &lt;bstanfill2003@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Angular-distributions'>Angular distributions</h2><span id='topic+Angular-distributions'></span>

<h3>Description</h3>

<p>Density, distribution function and random variate generation for symmetric probability distributions in the rotations package.
</p>


<h3>Details</h3>

<p>The functions for the density function and random variate generation are named in the usual form dxxxx, pxxxx and rxxxx,
respectively.
</p>

<ul>
<li><p> See <code><a href="#topic+Cayley">Cayley</a></code> for the Cayley distribution.
</p>
</li>
<li><p> See <code><a href="#topic+Fisher">Fisher</a></code> for the matrix Fisher distribution.
</p>
</li>
<li><p> See <code><a href="#topic+Haar">Haar</a></code> for the uniform distribution on the circle.
</p>
</li>
<li><p> See <code><a href="#topic+Maxwell">Maxwell</a></code> for the Maxwell-Boltzmann distribution on the circle.
</p>
</li>
<li><p> See <code><a href="#topic+Mises">Mises</a></code> for the von Mises-Fisher distribution.
</p>
</li></ul>


<hr>
<h2 id='Arithmetic'>Arithmetic operators on SO(3)</h2><span id='topic+Arithmetic'></span><span id='topic++22+2B.SO3+22'></span><span id='topic++22-.SO3+22'></span><span id='topic++22+2B.Q4+22'></span><span id='topic++22-.Q4+22'></span><span id='topic++2B.SO3'></span><span id='topic+-.SO3'></span><span id='topic++2B.Q4'></span><span id='topic+-.Q4'></span>

<h3>Description</h3>

<p>These binary operators perform arithmetic on rotations in quaternion or rotation matrix form
(or objects which can be coerced into them).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SO3'
x + y

## S3 method for class 'SO3'
x - y = NULL

## S3 method for class 'Q4'
x + y

## S3 method for class 'Q4'
x - y = NULL
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arithmetic_+3A_x">x</code></td>
<td>
<p>first argument</p>
</td></tr>
<tr><td><code id="Arithmetic_+3A_y">y</code></td>
<td>
<p>second argument (optional for subtraction)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rotation group SO(3) is a multiplicative group so &ldquo;adding&quot; rotations <code class="reqn">R_1</code> and <code class="reqn">R_2</code>
results in <code class="reqn">R_1+R_2=R_2R_1</code>.  Similarly, the difference between rotations <code class="reqn">R_1</code> and <code class="reqn">R_2</code> is
<code class="reqn">R_1-R_2=R_2^\top R_1</code>.  With this definition it is clear that
<code class="reqn">R_1+R_2-R_2=R_2^\top R_2R_1=R_1</code>.
If only one rotation is provided to subtraction then the inverse (transpose) it returned,
e.g. <code class="reqn">-R_2=R_2^\top</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>+</code></td>
<td>
<p>the result of rotating the identity frame through x then y</p>
</td></tr>
<tr><td><code>-</code></td>
<td>
<p>the difference of the rotations, or the inverse rotation of only one argument is provided</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- c(1, 0, 0)          #Rotate about the x-axis
R1 &lt;- as.SO3(U, pi/8)    #Rotate pi/8 radians about the x-axis
R2 &lt;- R1 + R1            #Rotate pi/8 radians about the x-axis twice
mis.axis(R2)             #x-axis: (1,0,0)
mis.angle(R2)            #pi/8 + pi/8 = pi/4

R3 &lt;- R1 - R1            #Rotate pi/8 radians about x-axis then back again
R3                       #Identity matrix

R4 &lt;- -R1                #Rotate in the opposite direction through pi/8
R5 &lt;- as.SO3(U, -pi/8)   #Equivalent to R4

M1 &lt;- matrix(R1, 3, 3)   #If element-wise addition is requred,
M2 &lt;- matrix(R2, 3, 3)   #translate them to matrices then treat as usual
M3 &lt;- M1 + M2

M1 %*% M1                #Equivalent to R2
t(M1) %*% M1             #Equivalent to R3
t(M1)                    #Equivalent to R4 and R5

#The same can be done with quaternions: the identity rotation is (1, 0, 0, 0)
#and the inverse rotation of Q=(a, b, c, d) is -Q=(a, -b, -c, -d)

Q1 &lt;- as.Q4(R1)
Q2 &lt;- Q1 + Q1
mis.axis(Q2)
mis.angle(Q2)

Q1 - Q1                  #id.Q4 = (1, 0, 0, 0)
</code></pre>

<hr>
<h2 id='bayes.mean'>Parameter estimates based on non-informative Bayes</h2><span id='topic+bayes.mean'></span><span id='topic+bayes.mean.SO3'></span><span id='topic+bayes.mean.Q4'></span>

<h3>Description</h3>

<p>Use non-informative Bayes to estimate the central orientation and concentration parameter of a sample of rotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes.mean(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000)

## S3 method for class 'SO3'
bayes.mean(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000)

## S3 method for class 'Q4'
bayes.mean(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes.mean_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="bayes.mean_+3A_type">type</code></td>
<td>
<p>Angular distribution assumed on R.  Options are <code><a href="#topic+Cayley">Cayley</a></code>, <code><a href="#topic+Fisher">Fisher</a></code> or <code><a href="#topic+Mises">Mises</a></code></p>
</td></tr>
<tr><td><code id="bayes.mean_+3A_s0">S0</code></td>
<td>
<p>initial estimate of central orientation</p>
</td></tr>
<tr><td><code id="bayes.mean_+3A_kappa0">kappa0</code></td>
<td>
<p>initial estimate of concentration parameter</p>
</td></tr>
<tr><td><code id="bayes.mean_+3A_tunes">tuneS</code></td>
<td>
<p>central orientation tuning parameter, concentration of proposal distribution</p>
</td></tr>
<tr><td><code id="bayes.mean_+3A_tunek">tuneK</code></td>
<td>
<p>concentration tuning parameter, standard deviation of proposal distribution</p>
</td></tr>
<tr><td><code id="bayes.mean_+3A_burn_in">burn_in</code></td>
<td>
<p>number of draws to use as burn-in</p>
</td></tr>
<tr><td><code id="bayes.mean_+3A_m">m</code></td>
<td>
<p>number of draws to keep from posterior distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedures detailed in <cite>bingham2009b</cite> and <cite>bingham2010</cite> are implemented to obtain
draws from the posterior distribution for the central orientation and concentration parameters for
a sample of 3D rotations.  A uniform prior on SO(3) is used for the central orientation and the
Jeffreys prior determined by <code>type</code> is used for the concentration parameter.
</p>
<p>bingham2009b bingham2010
</p>


<h3>Value</h3>

<p>list of
</p>

<ul>
<li> <p><code>Shat</code> Mode of the posterior distribution for the central orientation S
</p>
</li>
<li> <p><code>kappa</code> Mean of the posterior distribution for the concentration kappa
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mean.SO3">mean.SO3</a></code>, <code><a href="#topic+median.SO3">median.SO3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rvmises, kappa = 10)

Shat &lt;- mean(Rs)               #Estimate the central orientation using the projected mean
rotdist.sum(Rs, Shat, p = 2)   #The projected mean minimizes the sum of squared Euclidean
rot.dist(Shat)                 #distances, compute the minimized sum and estimator bias

#Estimate the central orientation using the posterior mode (not run due to time constraints)
#Compare it to the projected mean in terms of the squared Euclidean distance and bias

ests &lt;- bayes.mean(Rs, type = "Mises", S0 = mean(Rs), kappa0 = 10, tuneS = 5000,
                   tuneK = 1, burn_in = 1000, m = 5000)

Shat2 &lt;- ests$Shat             #The posterior mode is the 'Shat' object
rotdist.sum(Rs, Shat2, p = 2)  #Compute sum of squared Euclidean distances
rot.dist(Shat2)                #Bayes estimator bias
</code></pre>

<hr>
<h2 id='bayesCR'>Bayes credible regions</h2><span id='topic+bayesCR'></span><span id='topic+bayesCR.SO3'></span><span id='topic+bayesCR.Q4'></span>

<h3>Description</h3>

<p>Find the radius of a <code class="reqn">100(1-\alpha)</code>% credible region for the central orientation and concentration parameter using
non-informative Bayesian methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesCR(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000, alp = 0.1)

## S3 method for class 'SO3'
bayesCR(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000, alp = 0.1)

## S3 method for class 'Q4'
bayesCR(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000, alp = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesCR_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="bayesCR_+3A_type">type</code></td>
<td>
<p>Angular distribution assumed on R.  Options are <code><a href="#topic+Cayley">Cayley</a></code>, <code><a href="#topic+Fisher">Fisher</a></code> or <code><a href="#topic+Mises">Mises</a></code></p>
</td></tr>
<tr><td><code id="bayesCR_+3A_s0">S0</code></td>
<td>
<p>initial estimate of central orientation</p>
</td></tr>
<tr><td><code id="bayesCR_+3A_kappa0">kappa0</code></td>
<td>
<p>initial estimate of concentration parameter</p>
</td></tr>
<tr><td><code id="bayesCR_+3A_tunes">tuneS</code></td>
<td>
<p>central orientation tuning parameter, concentration of proposal distribution</p>
</td></tr>
<tr><td><code id="bayesCR_+3A_tunek">tuneK</code></td>
<td>
<p>concentration tuning parameter, standard deviation of proposal distribution</p>
</td></tr>
<tr><td><code id="bayesCR_+3A_burn_in">burn_in</code></td>
<td>
<p>number of draws to use as burn-in</p>
</td></tr>
<tr><td><code id="bayesCR_+3A_m">m</code></td>
<td>
<p>number of draws to keep from posterior distribution</p>
</td></tr>
<tr><td><code id="bayesCR_+3A_alp">alp</code></td>
<td>
<p>alpha level desired, e.g. 0.05 or 0.10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the radius of a <code class="reqn">100(1-\alpha)</code>% credible region for the central orientation and concentration parameter
as described in <cite>bingham2009b</cite> and <cite>bingham2010</cite>.  The posterior mode is returned along with the radius
of the credible region centered at the posterior mode.
</p>
<p>bingham2009b bingham2010
</p>


<h3>Value</h3>

<p>list of
</p>

<ul>
<li> <p><code>Shat,Qhat</code> Mode of the posterior distribution for the central orientation S
</p>
</li>
<li> <p><code>Radius</code> Radius of the credible region centered at the posterior mode
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fisheretal">fisheretal</a></code>, <code><a href="#topic+prentice">prentice</a></code>, <code><a href="#topic+chang">chang</a></code>, <code><a href="#topic+zhang">zhang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Not run due to time constraints

Rs &lt;- ruars(20, rvmises, kappa = 10)

#Compare the region size of the moment based theory mean estimator to the
#Bayes region.

region(Rs, method = "direct", type = "theory", estimator = "mean", alp=0.1, m = 100)
bayesCR &lt;- region(Rs, type = "Mises", method = "Bayes", estimator = "mean", S0 = mean(Rs),
                   kappa0 = 10, tuneS = 5000, tuneK = 1, burn_in = 1000, alp = .01, m = 5000)

bayesCR$Radius       #Region size is give by "Radius"
bayesCR$Shat         #The Bayes region is centered around the posterior mode: "Shat"
</code></pre>

<hr>
<h2 id='Cayley'>The symmetric Cayley distribution</h2><span id='topic+Cayley'></span><span id='topic+rcayley'></span><span id='topic+dcayley'></span><span id='topic+pcayley'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the Cayley distribution with concentration <code>kappa</code> <code class="reqn">\kappa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcayley(r, kappa = 1, nu = NULL, Haar = TRUE)

pcayley(q, kappa = 1, nu = NULL, lower.tail = TRUE)

rcayley(n, kappa = 1, nu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cayley_+3A_r">r</code>, <code id="Cayley_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Cayley_+3A_kappa">kappa</code></td>
<td>
<p>concentration parameter.</p>
</td></tr>
<tr><td><code id="Cayley_+3A_nu">nu</code></td>
<td>
<p>circular variance, can be used in place of <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="Cayley_+3A_haar">Haar</code></td>
<td>
<p>logical; if TRUE density is evaluated with respect to the Haar measure.</p>
</td></tr>
<tr><td><code id="Cayley_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default) probabilities are <code class="reqn">P(X\leq x)</code> otherwise, <code class="reqn">P(X&gt;x)</code>.</p>
</td></tr>
<tr><td><code id="Cayley_+3A_n">n</code></td>
<td>
<p>number of observations.  If <code>length(n)&gt;1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symmetric Cayley distribution with concentration <code class="reqn">\kappa</code> has density
</p>
<p style="text-align: center;"><code class="reqn">C_C(r |\kappa)=\frac{1}{\sqrt{\pi}} \frac{\Gamma(\kappa+2)}{\Gamma(\kappa+1/2)}2^{-(\kappa+1)}(1+\cos r)^\kappa(1-\cos r).</code>
</p>

<p>The Cayley distribution is equivalent to the de la Vallee Poussin distribution of <cite>Schaeben1997</cite>.
</p>
<p>Schaeben1997 leon2006
</p>


<h3>Value</h3>

<table>
<tr><td><code>dcayley</code></td>
<td>
<p>gives the density</p>
</td></tr>
<tr><td><code>pcayley</code></td>
<td>
<p>gives the distribution function</p>
</td></tr>
<tr><td><code>rcayley</code></td>
<td>
<p>generates a vector of random deviates</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Angular-distributions">Angular-distributions</a> for other distributions in the rotations package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- seq(-pi, pi, length = 500)

#Visualize the Cayley density fucntion with respect to the Haar measure
plot(r, dcayley(r, kappa = 10), type = "l", ylab = "f(r)")

#Visualize the Cayley density fucntion with respect to the Lebesgue measure
plot(r, dcayley(r, kappa = 10, Haar = FALSE), type = "l", ylab = "f(r)")

#Plot the Cayley CDF
plot(r,pcayley(r,kappa = 10), type = "l", ylab = "F(r)")

#Generate random observations from Cayley distribution
rs &lt;- rcayley(20, kappa = 1)
hist(rs, breaks = 10)
</code></pre>

<hr>
<h2 id='cayley.kappa'>Circular variance and concentration parameter</h2><span id='topic+cayley.kappa'></span>

<h3>Description</h3>

<p>Return the concentration parameter that corresponds to a given circular
variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cayley.kappa(nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cayley.kappa_+3A_nu">nu</code></td>
<td>
<p>circular variance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concentration parameter <code class="reqn">\kappa</code> does not translate across circular
distributions.  A commonly used measure of spread in circular distributions
that does translate is the circular variance defined as
<code class="reqn">\nu=1-E[\cos(r)]</code> where <code class="reqn">E[\cos(r)]</code> is
the mean resultant length.  See <cite>mardia2000</cite> for more details. This
function translates the circular variance <code class="reqn">\nu</code> into the corresponding
concentration parameter <code class="reqn">\kappa</code> for the Cayley distribution.
</p>
<p>mardia2000
</p>


<h3>Value</h3>

<p>Concentration parameter corresponding to nu.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cayley">Cayley</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the concentration parameter for circular variances 0.25, 0.5, 0.75
cayley.kappa(0.25)
cayley.kappa(0.5)
cayley.kappa(0.75)
</code></pre>

<hr>
<h2 id='center'>Center rotation data</h2><span id='topic+center'></span><span id='topic+center.SO3'></span><span id='topic+center.Q4'></span>

<h3>Description</h3>

<p>This function will take the sample Rs and return the sample Rs centered at
S.  That is, the ith observation of Rs denoted <code class="reqn">R_i</code> is returned as <code class="reqn">S^\top R_i</code>.
If S is the true center then the projected mean should be close to the 3-by-3 identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(x, S)

## S3 method for class 'SO3'
center(x, S)

## S3 method for class 'Q4'
center(x, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="center_+3A_s">S</code></td>
<td>
<p>the rotation or a matrix of <code class="reqn">n\times p</code> rotations about which to center each row of x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sample centered about S
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(5, rcayley)
cRs &lt;- center(Rs, mean(Rs))
mean(cRs)                      #Close to identity matrix

all.equal(cRs, Rs - mean(Rs))  #TRUE, center and '-' have the same effect
                               #See ?"-.SO3" for more details

center(Rs,Rs)                  #n-Identity matrices: If the second argument is of the same dimension
                               #as Rs then each row is centered around the corresponding
                               #row in the first argument
</code></pre>

<hr>
<h2 id='chang'>M-estimator asymptotic confidence region</h2><span id='topic+chang'></span><span id='topic+chang.SO3'></span><span id='topic+chang.Q4'></span>

<h3>Description</h3>

<p>Compute the radius of a <code class="reqn">100(1-\alpha)</code>% confidence region for the
central orientation based on M-estimation theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chang(x, estimator, alp = NULL)

## S3 method for class 'SO3'
chang(x, estimator, alp = NULL)

## S3 method for class 'Q4'
chang(x, estimator, alp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chang_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="chang_+3A_estimator">estimator</code></td>
<td>
<p>character string either &quot;mean&quot; or &quot;median.&quot;</p>
</td></tr>
<tr><td><code id="chang_+3A_alp">alp</code></td>
<td>
<p>alpha level desired, e.g. 0.05 or 0.10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the radius of a <code class="reqn">100(1-\alpha)</code>% confidence region for the
central orientation centered at the projected mean or median based on a
result due to <cite>chang2001</cite> among others.  By construction each axis will
have the same radius so the radius reported is for all three axes.  This
method is called &quot;direct&quot; because it uses M-estimation theory for SO(3)
directly instead of relying on the transformation of a result from
directional statistics like <code><a href="#topic+prentice">prentice</a></code> and
<code><a href="#topic+fisheretal">fisheretal</a></code> do.
</p>
<p>chang2001
</p>


<h3>Value</h3>

<p>Radius of the confidence region centered at the specified estimator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesCR">bayesCR</a></code>, <code><a href="#topic+prentice">prentice</a></code>,
<code><a href="#topic+fisheretal">fisheretal</a></code>, <code><a href="#topic+zhang">zhang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rcayley, kappa = 100)

# The chang method can be accesed from the "region" function or the "chang" function
region(Rs, method = "direct", type = "asymptotic", alp = 0.1, estimator = "mean")
chang(Rs, estimator = "mean", alp = 0.1)
</code></pre>

<hr>
<h2 id='discord'>Measure of Discord</h2><span id='topic+discord'></span>

<h3>Description</h3>

<p>This function computes a measure of discord for a sample of random rotations.
The larger the statistic value the less likely it is the corresponding observation
was generated by the same mechanism the rest of the data as generated by.
It can be used to test for outliers in SO(3) by comparing it to an F distribution
with 3,3(n-2) df for the Cayley or matrix Fisher distributions or to an F
distribution with 1,n-2 df for the von Mises Fisher distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discord(x, type, t = 1L, obs = 1:nrow(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discord_+3A_x">x</code></td>
<td>
<p>The sample of random rotations</p>
</td></tr>
<tr><td><code id="discord_+3A_type">type</code></td>
<td>
<p>To specify if &quot;intrinsic&quot; or &quot;extrinsic&quot; approach should be used to compute the statistic</p>
</td></tr>
<tr><td><code id="discord_+3A_t">t</code></td>
<td>
<p>If test blocs then the bloc size, set to 1 by default</p>
</td></tr>
<tr><td><code id="discord_+3A_obs">obs</code></td>
<td>
<p>integer vector specifying which observation(s) to compute the measure of discord for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Hi statistic for each group of size t is returned.  If <code>t&gt;1</code> then which observations 
that define each group of size <code>t</code> is returned as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Compute the measures of discord for a sample from the Cayley distribution
# Intrinsic examples are commented out but are below if you're interested

Rss &lt;- ruars(20,rcayley,kappa=1)
Hi &lt;- discord(Rss, type='intrinsic')
He &lt;- discord(Rss, type='extrinsic')

#Compare to the theoretical F distribution
OrdHi &lt;- sort(Hi)
OrdHe &lt;- sort(He)

par(mfrow=c(1,2))
plot(ecdf(OrdHi),main='Intrinsic',xlim=range(c(OrdHi,OrdHe)))
lines(OrdHi,pf(OrdHi,3,3*(length(OrdHi)-2)))

plot(ecdf(OrdHe),main='Extrinsic',xlim=range(c(OrdHi,OrdHe)))
lines(OrdHi,pf(OrdHi,3,3*(length(OrdHe)-2)))
layout(1)
</code></pre>

<hr>
<h2 id='drill'>Drill data set</h2><span id='topic+drill'></span>

<h3>Description</h3>

<p>The <code>drill</code> data set was collected to assess variation in human movement
while performing a task (Rancourt, 1995). Eight subjects drilled into a metal
plate while being monitored by infared cameras. Quaternions are used to
represent the orientation of each subjects' wrist, elbow and shoulder in one
of six positions. For some subjects several replicates are available. See
Rancourt et al. (2000) for one approach to analyzing these data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drill
</code></pre>


<h3>Format</h3>

<p>A data frame with 720 observations on the following 8 variables:
</p>

<dl>
<dt><code>Subject</code></dt><dd><p>Subject number (1-8)</p>
</dd>
<dt><code>Joint</code></dt><dd><p>Joint name (Wrist, elbow, shoulder)</p>
</dd>
<dt><code>Position</code></dt><dd><p>Drilling position (1-6)</p>
</dd>
<dt><code>Replicate</code></dt><dd><p>Replicate number (1-5)</p>
</dd>
<dt><code>Q1</code></dt><dd><p>First element of orientation (quaternion)</p>
</dd>
<dt><code>Q2</code></dt><dd><p>Second element of orientation (quaternion)</p>
</dd>
<dt><code>Q3</code></dt><dd><p>Third element of orientation (quaternion)</p>
</dd>
<dt><code>Q4</code></dt><dd><p>Fourth element of orientation (quaternion)</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.fsg.ulaval.ca/departements/professeurs/louis-paul-rivest-98">https://www.fsg.ulaval.ca/departements/professeurs/louis-paul-rivest-98</a>
</p>


<h3>References</h3>


<ol>
<li><p> Rancourt, D. (1995). &quot;Arm posture and hand
mechanical impedance in the control of a hand-held power drill.&quot; Ph.D.
Thesis, MIT.
</p>
</li>
<li><p> Rancourt, D., Rivest, L. &amp; Asselin, J. (2000). &quot;Using
orientation statistics to investigate variations in human kinematics.&quot;
Journal of the Royal Statistical Society: Series C (Applied Statistics),
49(1), pp. 81-94.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Estimate central orientation of the first subject's wrist
Subject1Wrist &lt;- subset(drill, Subject == 1 &amp; Joint == "Wrist")
Qs &lt;- as.Q4(Subject1Wrist[, 5:8])
mean(Qs)


  # Plot Subject 1's wrist measurements using the connection to rotation matrices
  plot(Qs, col = c(1, 2, 3))


# Translate the quaternion measurements into rotations and
# estimate the central orientation in terms of rotations
Rs &lt;- as.SO3(Qs)
mean(Rs)
</code></pre>

<hr>
<h2 id='Fisher'>The matrix-Fisher distribution</h2><span id='topic+Fisher'></span><span id='topic+dfisher'></span><span id='topic+rfisher'></span><span id='topic+pfisher'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the matrix-Fisher distribution with concentration <code>kappa</code> <code class="reqn">\kappa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfisher(r, kappa = 1, nu = NULL, Haar = TRUE)

pfisher(q, kappa = 1, nu = NULL, lower.tail = TRUE)

rfisher(n, kappa = 1, nu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fisher_+3A_r">r</code>, <code id="Fisher_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Fisher_+3A_kappa">kappa</code></td>
<td>
<p>concentration parameter.</p>
</td></tr>
<tr><td><code id="Fisher_+3A_nu">nu</code></td>
<td>
<p>circular variance, can be used in place of <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="Fisher_+3A_haar">Haar</code></td>
<td>
<p>logical; if TRUE density is evaluated with respect to the Haar measure.</p>
</td></tr>
<tr><td><code id="Fisher_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X \le x)</code> otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Fisher_+3A_n">n</code></td>
<td>
<p>number of observations.  If <code>length(n)&gt;1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix-Fisher distribution with concentration <code class="reqn">\kappa</code> has density
</p>
<p style="text-align: center;"><code class="reqn">C_\mathrm{{F}}(r|\kappa)=\frac{1}{2\pi[\mathrm{I_0}(2\kappa)-\mathrm{I_1}(2\kappa)]}e^{2\kappa\cos(r)}[1-\cos(r)]</code>
</p>

<p>with respect to Lebesgue measure where <code class="reqn">\mathrm{I}_p(\cdot)</code> denotes the Bessel function of order <code class="reqn">p</code> defined as
<code class="reqn">\mathrm{I}_p(\kappa)=\frac{1}{2\pi}\int_{-\pi}^{\pi}\cos(pr)e^{\kappa\cos r}dr</code>.  If <code>kappa&gt;354</code> then random deviates
are generated from the <code><a href="#topic+Cayley">Cayley</a></code> distribution because they agree closely for large <code>kappa</code> and generation is
more stable from the Cayley distribution.
</p>
<p>For large <code class="reqn">\kappa</code>, the Bessel functon gives errors so a large <code class="reqn">\kappa</code> approximation to the matrix-Fisher
distribution is used instead, which is the Maxwell-Boltzmann density.
</p>


<h3>Value</h3>

<table>
<tr><td><code>dfisher</code></td>
<td>
<p>gives the density</p>
</td></tr>
<tr><td><code>pfisher</code></td>
<td>
<p>gives the distribution function</p>
</td></tr>
<tr><td><code>rfisher</code></td>
<td>
<p>generates random deviates</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Angular-distributions">Angular-distributions</a> for other distributions in the rotations package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- seq(-pi, pi, length = 500)

#Visualize the matrix Fisher density fucntion with respect to the Haar measure
plot(r, dfisher(r, kappa = 10), type = "l", ylab = "f(r)")

#Visualize the matrix Fisher density fucntion with respect to the Lebesgue measure
plot(r, dfisher(r, kappa = 10, Haar = FALSE), type = "l", ylab = "f(r)")

#Plot the matrix Fisher CDF
plot(r,pfisher(r,kappa = 10), type = "l", ylab = "F(r)")

#Generate random observations from matrix Fisher distribution
rs &lt;- rfisher(20, kappa = 1)
hist(rs, breaks = 10)
</code></pre>

<hr>
<h2 id='fisher.kappa'>Circular variance and concentration parameter</h2><span id='topic+fisher.kappa'></span>

<h3>Description</h3>

<p>Return the concentration parameter that corresponds to a given circular
variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.kappa(nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher.kappa_+3A_nu">nu</code></td>
<td>
<p>circular variance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concentration parameter <code class="reqn">\kappa</code> does not translate across circular
distributions. A commonly used measure of spread in circular distributions
that does translate is the circular variance defined as
<code class="reqn">\nu=1-E[\cos(r)]</code> where <code class="reqn">E[\cos(r)]</code> is
the mean resultant length.  See <cite>mardia2000</cite> for more details. This
function translates the circular variance <code class="reqn">\nu</code> into the corresponding
concentration parameter <code class="reqn">\kappa</code> for the matrix-Fisher distribution.
For numerical stability, a maximum <code class="reqn">\kappa</code> of 350 is returned.
</p>
<p>mardia2000
</p>


<h3>Value</h3>

<p>Concentration parameter corresponding to nu.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fisher">Fisher</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the concentration parameter for circular variances 0.25, 0.5, 0.75
fisher.kappa(0.25)
fisher.kappa(0.5)
fisher.kappa(0.75)
</code></pre>

<hr>
<h2 id='fisheretal'>Transformation based pivotal bootstrap confidence region</h2><span id='topic+fisheretal'></span><span id='topic+fisheretal.Q4'></span><span id='topic+fisheretal.SO3'></span>

<h3>Description</h3>

<p>Find the radius of a <code class="reqn">100(1-\alpha)</code>% confidence region for the central
orientation based on  transforming a result from directional statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisheretal(x, alp = NULL, boot = TRUE, m = 300, symm = TRUE)

## S3 method for class 'Q4'
fisheretal(x, alp = NULL, boot = TRUE, m = 300, symm = TRUE)

## S3 method for class 'SO3'
fisheretal(x, alp = NULL, boot = TRUE, m = 300, symm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisheretal_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="fisheretal_+3A_alp">alp</code></td>
<td>
<p>alpha level desired, e.g. 0.05 or 0.10.</p>
</td></tr>
<tr><td><code id="fisheretal_+3A_boot">boot</code></td>
<td>
<p>should the bootstrap or normal theory critical value be used.</p>
</td></tr>
<tr><td><code id="fisheretal_+3A_m">m</code></td>
<td>
<p>number of bootstrap replicates to use to estimate critical value.</p>
</td></tr>
<tr><td><code id="fisheretal_+3A_symm">symm</code></td>
<td>
<p>logical; if TRUE (default), a symmetric region is constructed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the radius of a <code class="reqn">100(1-\alpha)</code>% confidence region for the
central orientation based on the projected mean estimator using the method
for the mean polar axis as proposed in <cite>fisher1996</cite>.  To be able to
reduce their method to a radius requires the additional assumption of
rotational symmetry, equation (10) in <cite>fisher1996</cite>.
</p>
<p>fisher1996
</p>


<h3>Value</h3>

<p>Radius of the confidence region centered at the projected mean.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesCR">bayesCR</a></code>, <code><a href="#topic+prentice">prentice</a></code>, <code><a href="#topic+chang">chang</a></code>,
<code><a href="#topic+zhang">zhang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Qs&lt;-ruars(20, rcayley, kappa = 100, space = 'Q4')

# The Fisher et al. method can be accesed from the "region" function or the "fisheretal" function
region(Qs, method = "transformation", type = "bootstrap", alp = 0.1,
symm = TRUE, estimator = "mean")
fisheretal(Qs, alp = 0.1, boot = TRUE, symm = TRUE)
</code></pre>

<hr>
<h2 id='genR'>Generate rotations</h2><span id='topic+genR'></span>

<h3>Description</h3>

<p>Generate rotations in matrix format using Rodrigues' formula or quaternions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genR(r, S = NULL, space = "SO3")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genR_+3A_r">r</code></td>
<td>
<p>vector of angles.</p>
</td></tr>
<tr><td><code id="genR_+3A_s">S</code></td>
<td>
<p>central orientation.</p>
</td></tr>
<tr><td><code id="genR_+3A_space">space</code></td>
<td>
<p>indicates the desired representation: rotation matrix &quot;SO3&quot; or quaternions &quot;Q4.&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector <code class="reqn">U=(u_1,u_2,u_3)^\top\in R^3</code> of length one and angle of rotation <code class="reqn">r</code>, a <code class="reqn">3\times 3</code> rotation
matrix is formed using Rodrigues' formula
</p>
<p style="text-align: center;"><code class="reqn">\cos(r)I_{3\times 3}+\sin(r)\Phi(U)+(1-\cos(r))UU^\top</code>
</p>

<p>where <code class="reqn">I_{3\times 3}</code> is the <code class="reqn">3\times 3</code> identity matrix, <code class="reqn">\Phi(U)</code> is a <code class="reqn">3\times 3</code> skew-symmetric matrix
with upper triangular elements <code class="reqn">-u_3</code>, <code class="reqn">u_2</code> and <code class="reqn">-u_1</code> in that order.
</p>
<p>For the same vector and angle a quaternion is formed according to </p>
<p style="text-align: center;"><code class="reqn">q=[cos(\theta/2),sin(\theta/2)U]^\top.</code>
</p>



<h3>Value</h3>

<p>A <code class="reqn">n\times p</code> matrix where each row is a random rotation matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rvmises(20, kappa = 0.01)
Rs &lt;- genR(r, space = "SO3")
Qs &lt;- genR(r, space = "Q4")
</code></pre>

<hr>
<h2 id='gradient.search'>Gradient optimization for rotation data</h2><span id='topic+gradient.search'></span>

<h3>Description</h3>

<p>Gradient based optimization for user defined central orientation of a rotation sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient.search(
  sample,
  error,
  minerr = 1e-05,
  start = mean(sample),
  theta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient.search_+3A_sample">sample</code></td>
<td>
<p>sample of rotations.</p>
</td></tr>
<tr><td><code id="gradient.search_+3A_error">error</code></td>
<td>
<p>user defined function to observed distance between sample and estimate, has to have parameters for the sample and the estimate.</p>
</td></tr>
<tr><td><code id="gradient.search_+3A_minerr">minerr</code></td>
<td>
<p>minimal distance to consider for convergence.</p>
</td></tr>
<tr><td><code id="gradient.search_+3A_start">start</code></td>
<td>
<p>starting value for the estimation.</p>
</td></tr>
<tr><td><code id="gradient.search_+3A_theta">theta</code></td>
<td>
<p>size of the grid considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 
</p>

<ul>
<li> <p><code>Shat</code> estimate of the main direction
</p>
</li>
<li> <p><code>iter</code> number of iterations necessary for convergence
</p>
</li>
<li> <p><code>theta</code> final size of the grid
</p>
</li>
<li> <p><code>minerr</code> error used for convergence
</p>
</li>
<li> <p><code>error</code> numeric value of total sample's distance from main direction
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># minimize L1 norm:
L1.error &lt;- function(sample, Shat) {
  sum(rot.dist(sample, Shat, method = "intrinsic", p = 1))
}

cayley.sample &lt;- ruars(n = 10, rangle = rcayley, nu = 1, space = 'SO3')
SL1 &lt;- gradient.search(cayley.sample, L1.error, start = id.SO3)

# visually no perceptible difference between median estimates from in-built function and 
# gradient based search (for almost all starting values)


plot(cayley.sample, center=SL1$Shat, show_estimates="all")
</code></pre>

<hr>
<h2 id='Haar'>Uniform distribution</h2><span id='topic+Haar'></span><span id='topic+dhaar'></span><span id='topic+phaar'></span><span id='topic+rhaar'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhaar(r)

phaar(q, lower.tail = TRUE)

rhaar(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Haar_+3A_r">r</code>, <code id="Haar_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Haar_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X \le x)</code> otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Haar_+3A_n">n</code></td>
<td>
<p>number of observations.  If <code>length(n)&gt;1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The uniform distribution
has density </p>
<p style="text-align: center;"><code class="reqn">C_U(r)=\frac{[1-cos(r)]}{2\pi}</code>
</p>
<p> with respect to the Lebesgue
measure.  The Haar measure is the volume invariant measure for SO(3) that plays the role
of the uniform measure on SO(3) and <code class="reqn">C_U(r)</code> is the angular distribution that corresponds
to the uniform distribution on SO(3), see <code><a href="#topic+UARS">UARS</a></code>.  The uniform distribution with respect to the Haar measure is given
by </p>
<p style="text-align: center;"><code class="reqn">C_U(r)=\frac{1}{2\pi}.</code>
</p>
<p>  Because the uniform distribution
with respect to the Haar measure gives a horizontal line at 1
with respect to the Lebesgue measure, we called this distribution 'Haar.'
</p>


<h3>Value</h3>

<table>
<tr><td><code>dhaar</code></td>
<td>
<p>gives the density</p>
</td></tr>
<tr><td><code>phaar</code></td>
<td>
<p>gives the distribution function</p>
</td></tr>
<tr><td><code>rhaar</code></td>
<td>
<p>generates random deviates</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Angular-distributions">Angular-distributions</a> for other distributions in the rotations package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- seq(-pi, pi, length = 1000)

#Visualize the uniform distribution with respect to Lebesgue measure
plot(r, dhaar(r), type = "l", ylab = "f(r)")

#Visualize the uniform distribution with respect to Haar measure, which is
#a horizontal line at 1
plot(r, 2*pi*dhaar(r)/(1-cos(r)), type = "l", ylab = "f(r)")

#Plot the uniform CDF
plot(r,phaar(r), type = "l", ylab = "F(r)")

#Generate random observations from uniform distribution
rs &lt;- rhaar(50)

#Visualize on the real line
hist(rs, breaks = 10)

</code></pre>

<hr>
<h2 id='head'>Return the First or Last Parts of an Object</h2><span id='topic+head'></span><span id='topic+head.SO3'></span><span id='topic+head.Q4'></span>

<h3>Description</h3>

<p>Returns the first or last parts of a vector, matrix, table, data frame
or function.  Since <code>head()</code> and <code>tail()</code> are generic
functions, they may also have been extended to other classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SO3'
head(x, n = 6L, ...)

## S3 method for class 'Q4'
head(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="head_+3A_n">n</code></td>
<td>
<p>an integer vector of length up to <code>dim(x)</code> (or 1,
for non-dimensioned objects).  A <code>logical</code> is silently coerced to
integer.  Values specify the indices to be
selected in the corresponding dimension (or along the length) of the
object. A positive value of <code>n[i]</code> includes the first/last
<code>n[i]</code> indices in that dimension, while a negative value
excludes the last/first <code>abs(n[i])</code>, including all remaining
indices. <code>NA</code> or non-specified values (when <code>length(n) &lt;
      length(dim(x))</code>) select all indices in that dimension. Must
contain at least one non-missing value.</p>
</td></tr>
<tr><td><code id="head_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vector/array based objects, <code>head()</code> (<code>tail()</code>) returns
a subset of the same dimensionality as <code>x</code>, usually of
the same class. For historical reasons, by default they select the
first (last) 6 indices in the first dimension (&quot;rows&quot;) or along the
length of a non-dimensioned vector, and the full extent (all indices)
in any remaining dimensions. <code>head.matrix()</code> and
<code>tail.matrix()</code> are exported.
</p>
<p>The default and array(/matrix) methods for <code>head()</code> and
<code>tail()</code> are quite general. They will work as is for any class
which has a <code>dim()</code> method, a <code>length()</code> method (only
required if <code>dim()</code> returns <code>NULL</code>), and a <code>[</code> method
(that accepts the <code>drop</code> argument and can subset in all
dimensions in the dimensioned case).
</p>
<p>For functions, the lines of the deparsed function are returned as
character strings.
</p>
<p>When <code>x</code> is an array(/matrix) of dimensionality two and more,
<code>tail()</code> will add dimnames similar to how they would appear in a
full printing of <code>x</code> for all dimensions <code>k</code> where
<code>n[k]</code> is specified and non-missing and <code>dimnames(x)[[k]]</code>
(or <code>dimnames(x)</code> itself) is <code>NULL</code>.  Specifically, the
form of the added dimnames will vary for different dimensions as follows:
</p>

<dl>
<dt><code>k=1</code> (rows): </dt><dd><p><code>"[n,]"</code> (right justified with
whitespace padding)</p>
</dd>
<dt><code>k=2</code> (columns): </dt><dd><p><code>"[,n]"</code> (with <em>no</em> whitespace
padding)</p>
</dd>
<dt><code>k&gt;2</code> (higher dims): </dt><dd><p><code>"n"</code>, i.e., the indices as
<em>character</em> values</p>
</dd>
</dl>

<p>Setting <code>keepnums = FALSE</code> suppresses this behaviour.
</p>
<p>As <code><a href="base.html#topic+data.frame">data.frame</a></code> subsetting (&lsquo;indexing&rsquo;) keeps
<code><a href="base.html#topic+attributes">attributes</a></code>, so do the <code>head()</code> and <code>tail()</code>
methods for data frames.
</p>


<h3>Value</h3>

<p>An object (usually) like <code>x</code> but generally smaller.  Hence, for
<code><a href="base.html#topic+array">array</a></code>s, the result corresponds to <code>x[.., drop=FALSE]</code>.
For <code><a href="stats.html#topic+ftable">ftable</a></code> objects <code>x</code>, a transformed <code>format(x)</code>.
</p>


<h3>Note</h3>

<p>For array inputs the output of <code>tail</code> when <code>keepnums</code> is <code>TRUE</code>,
any dimnames vectors added for dimensions <code>&gt;2</code> are the original
numeric indices in that dimension <em>as character vectors</em>.  This
means that, e.g., for 3-dimensional array <code>arr</code>,
<code>tail(arr, c(2,2,-1))[ , , 2]</code> and
<code>tail(arr, c(2,2,-1))[ , , "2"]</code> may both be valid but have
completely different meanings.
</p>


<h3>Author(s)</h3>

<p>Patrick Burns, improved and corrected by R-Core. Negative argument
added by Vincent Goulet.  Multi-dimension support added by Gabriel Becker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(letters)
head(letters, n = -6L)

head(freeny.x, n = 10L)
head(freeny.y)

head(iris3)
head(iris3, c(6L, 2L))
head(iris3, c(6L, -1L, 2L))

tail(letters)
tail(letters, n = -6L)

tail(freeny.x)
## the bottom-right "corner" :
tail(freeny.x, n = c(4, 2))
tail(freeny.y)

tail(iris3)
tail(iris3, c(6L, 2L))
tail(iris3, c(6L, -1L, 2L))

## iris with dimnames stripped
a3d &lt;- iris3 ; dimnames(a3d) &lt;- NULL
tail(a3d, c(6, -1, 2)) # keepnums = TRUE is default here!
tail(a3d, c(6, -1, 2), keepnums = FALSE)

## data frame w/ a (non-standard) attribute:
treeS &lt;- structure(trees, foo = "bar")
(n &lt;- nrow(treeS))
stopifnot(exprs = { # attribute is kept
    identical(htS &lt;- head(treeS), treeS[1:6, ])
    identical(attr(htS, "foo") , "bar")
    identical(tlS &lt;- tail(treeS), treeS[(n-5):n, ])
    ## BUT if I use "useAttrib(.)", this is *not* ok, when n is of length 2:
    ## --- because [i,j]-indexing of data frames *also* drops "other" attributes ..
    identical(tail(treeS, 3:2), treeS[(n-2):n, 2:3] )
})

tail(library) # last lines of function

head(stats::ftable(Titanic))

## 1d-array (with named dim) :
a1 &lt;- array(1:7, 7); names(dim(a1)) &lt;- "O2"
stopifnot(exprs = {
  identical( tail(a1, 10), a1)
  identical( head(a1, 10), a1)
  identical( head(a1, 1), a1 [1 , drop=FALSE] ) # was a1[1] in R &lt;= 3.6.x
  identical( tail(a1, 2), a1[6:7])
  identical( tail(a1, 1), a1 [7 , drop=FALSE] ) # was a1[7] in R &lt;= 3.6.x
})
</code></pre>

<hr>
<h2 id='log.SO3'>Rotation logarithm</h2><span id='topic+log.SO3'></span>

<h3>Description</h3>

<p>Compute the logarithm of a rotation matrix, which results in a <code class="reqn">3\times 3</code> skew-symmetric matrix.  This function maps
the lie group <code class="reqn">SO(3)</code> into its tangent space, which is the space of all <code class="reqn">3\times 3</code> skew symmetric matrices,
the lie algebra <code class="reqn">so(3)</code>.  For details see e.g. <cite>moakher02</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SO3'
log(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log.SO3_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times 9</code> matrix where each row corresponds to a random rotation matrix.</p>
</td></tr>
<tr><td><code id="log.SO3_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>moakher02
</p>


<h3>Value</h3>

<p>Skew symmetric matrix <code class="reqn">\log(R)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rcayley)

#Here we demonstrate how the logarithm can be used to determine the angle and
#axis corresponding to the provided sample

lRs &lt;- log(Rs)               #Take the logarithm of the sample
Ws &lt;- lRs[,c(6, 7, 2)]       #The appropriate diagonal entries are the axis*angle
lens &lt;- sqrt(rowSums(Ws^2))
axes &lt;- mis.axis(Rs)
angs &lt;- mis.angle(Rs)
all.equal(axes, Ws/lens)
all.equal(angs, lens)
</code></pre>

<hr>
<h2 id='Maxwell'>The modified Maxwell-Boltzmann distribution</h2><span id='topic+Maxwell'></span><span id='topic+rmaxwell'></span><span id='topic+dmaxwell'></span><span id='topic+pmaxwell'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the Maxwell-Boltzmann distribution with
concentration <code>kappa</code> <code class="reqn">\kappa</code> restricted to the range <code class="reqn">[-\pi,\pi)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmaxwell(r, kappa = 1, nu = NULL, Haar = TRUE)

pmaxwell(q, kappa = 1, nu = NULL, lower.tail = TRUE)

rmaxwell(n, kappa = 1, nu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Maxwell_+3A_r">r</code>, <code id="Maxwell_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_kappa">kappa</code></td>
<td>
<p>concentration parameter.</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_nu">nu</code></td>
<td>
<p>circular variance, can be used in place of <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_haar">Haar</code></td>
<td>
<p>logical; if TRUE density is evaluated with respect to the Haar measure.</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default) probabilities are <code class="reqn">P(X\leq x)</code> otherwise, <code class="reqn">P(X&gt;x)</code>.</p>
</td></tr>
<tr><td><code id="Maxwell_+3A_n">n</code></td>
<td>
<p>number of observations.  If <code>length(n)&gt;1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Maxwell-Boltzmann distribution with concentration <code class="reqn">\kappa</code> has density
</p>
<p style="text-align: center;"><code class="reqn">C_\mathrm{{M}}(r|\kappa)=2\kappa\sqrt{\frac{\kappa}{\pi}}r^2e^{-\kappa r^2}</code>
</p>

<p>with respect to Lebesgue measure.  The usual expression for the Maxwell-Boltzmann distribution can be recovered by
setting <code class="reqn">a=(2\kappa)^0.5</code>.
</p>
<p>bingham2010
</p>


<h3>Value</h3>

<table>
<tr><td><code>dmaxwell</code></td>
<td>
<p>gives the density</p>
</td></tr>
<tr><td><code>pmaxwell</code></td>
<td>
<p>gives the distribution function</p>
</td></tr>
<tr><td><code>rmaxwell</code></td>
<td>
<p>generates a vector of random deviates</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Angular-distributions">Angular-distributions</a> for other distributions in the rotations package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- seq(-pi, pi, length = 500)

#Visualize the Maxwell-Boltzmann density fucntion with respect to the Haar measure
plot(r, dmaxwell(r, kappa = 10), type = "l", ylab = "f(r)")

#Visualize the Maxwell-Boltzmann density fucntion with respect to the Lebesgue measure
plot(r, dmaxwell(r, kappa = 10, Haar = FALSE), type = "l", ylab = "f(r)")

#Plot the Maxwell-Boltzmann CDF
plot(r,pmaxwell(r,kappa = 10), type = "l", ylab = "F(r)")

#Generate random observations from Maxwell-Boltzmann distribution
rs &lt;- rmaxwell(20, kappa = 1)
hist(rs, breaks = 10)
</code></pre>

<hr>
<h2 id='maxwell.kappa'>Circular variance and concentration parameter</h2><span id='topic+maxwell.kappa'></span>

<h3>Description</h3>

<p>Return the concentration parameter that corresponds to a given circular
variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxwell.kappa(nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxwell.kappa_+3A_nu">nu</code></td>
<td>
<p>circular variance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concentration parameter <code class="reqn">\kappa</code> does not translate across circular
distributions.  A commonly used measure of spread in circular distributions
that does translate is the circular variance defined as
<code class="reqn">\nu=1-E[\cos(r)]</code> where <code class="reqn">E[\cos(r)]</code> is
the mean resultant length.  See <cite>mardia2000</cite> for more details. This
function translates the circular variance <code class="reqn">\nu</code> into the corresponding
concentration parameter <code class="reqn">\kappa</code> for the modified Maxwell-Boltzmann
distribution.  For numerical stability, a maximum <code class="reqn">\kappa</code> of 1000 is
returned.
</p>


<h3>Value</h3>

<p>Concentration parameter corresponding to nu.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Maxwell">Maxwell</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the concentration parameter for circular variances 0.25, 0.5, 0.75
maxwell.kappa(0.25)
maxwell.kappa(0.5)
maxwell.kappa(0.75)
</code></pre>

<hr>
<h2 id='MCMCSO3'>MCMC for rotation data</h2><span id='topic+MCMCSO3'></span><span id='topic+MCMCSO3.SO3'></span><span id='topic+MCMCSO3.Q4'></span>

<h3>Description</h3>

<p>Use non-informative Bayesian methods to infer about the central orientation and concentration
parameter for a sample of rotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCSO3(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000)

## S3 method for class 'SO3'
MCMCSO3(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000)

## S3 method for class 'Q4'
MCMCSO3(x, type, S0, kappa0, tuneS, tuneK, burn_in, m = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCSO3_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="MCMCSO3_+3A_type">type</code></td>
<td>
<p>Angular distribution assumed on R.  Options are <code><a href="#topic+Cayley">Cayley</a></code>, <code><a href="#topic+Fisher">Fisher</a></code> or <code><a href="#topic+Mises">Mises</a></code></p>
</td></tr>
<tr><td><code id="MCMCSO3_+3A_s0">S0</code></td>
<td>
<p>initial estimate of central orientation</p>
</td></tr>
<tr><td><code id="MCMCSO3_+3A_kappa0">kappa0</code></td>
<td>
<p>initial estimate of concentration parameter</p>
</td></tr>
<tr><td><code id="MCMCSO3_+3A_tunes">tuneS</code></td>
<td>
<p>central orientation tuning parameter, concentration of proposal distribution</p>
</td></tr>
<tr><td><code id="MCMCSO3_+3A_tunek">tuneK</code></td>
<td>
<p>concentration tuning parameter, standard deviation of proposal distribution</p>
</td></tr>
<tr><td><code id="MCMCSO3_+3A_burn_in">burn_in</code></td>
<td>
<p>number of draws to use as burn-in</p>
</td></tr>
<tr><td><code id="MCMCSO3_+3A_m">m</code></td>
<td>
<p>number of draws to keep from posterior distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedures detailed in <cite>bingham2009b</cite> and <cite>bingham2010</cite> are implemented to obtain
draws from the posterior distribution for the central orientation and concentration parameters for
a sample of 3D rotations.  A uniform prior on SO(3) is used for the central orientation and the
Jeffreys prior determined by <code>type</code> is used for the concentration parameter.
</p>
<p>bingham2009b bingham2010
</p>


<h3>Value</h3>

<p>list of
</p>

<ul>
<li> <p><code>S</code> Draws from the posterior distribution for central orientation S
</p>
</li>
<li> <p><code>kappa</code> Draws from the posterior distribution for concentration parameter kappa
</p>
</li>
<li> <p><code>Saccept</code> Acceptance rate for central orientation draws
</p>
</li>
<li> <p><code>Kaccept</code> Acceptance rate for concentration draws
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#Not run due to time constraints

Rs &lt;- ruars(20, rfisher, kappa = 10)
draws &lt;- MCMCSO3(Rs, type = "Fisher", S0 = mean(Rs), kappa0 = 10, tuneS = 5000,
                 tuneK = 1,burn_in = 1000, m = 5000)
</code></pre>

<hr>
<h2 id='mean'>Mean rotation</h2><span id='topic+mean'></span><span id='topic+mean.SO3'></span><span id='topic+mean.Q4'></span>

<h3>Description</h3>

<p>Compute the sample geometric or projected mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SO3'
mean(x, type = "projected", epsilon = 1e-05, maxIter = 2000, ...)

## S3 method for class 'Q4'
mean(x, type = "projected", epsilon = 1e-05, maxIter = 2000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix form (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="mean_+3A_type">type</code></td>
<td>
<p>string indicating &quot;projected&quot; or &quot;geometric&quot; type mean estimator.</p>
</td></tr>
<tr><td><code id="mean_+3A_epsilon">epsilon</code></td>
<td>
<p>stopping rule for the geometric-mean.</p>
</td></tr>
<tr><td><code id="mean_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations allowed for geometric-mean.</p>
</td></tr>
<tr><td><code id="mean_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a sample of 3D rotations (in matrix or quaternion form)
and returns the projected arithmetic mean denoted <code class="reqn">\widehat{\bm
S}_P</code> or geometric mean <code class="reqn">\widehat{\bm S}_G</code> according to the
<code>type</code> option. For a sample of <code class="reqn">n</code> rotations in matrix form
<code class="reqn">\bm{R}_i\in SO(3), i=1,2,\dots,n</code>, the
mean-type estimator is defined as </p>
<p style="text-align: center;"><code class="reqn">\widehat{\bm{S}}=argmin_{\bm{S}\in
SO(3)}\sum_{i=1}^nd^2(\bm{R}_i,\bm{S})</code>
</p>
<p> where <code class="reqn">d</code>
is the Riemannian or Euclidean distance. For more on the projected mean see
<cite>moakher02</cite> and for the geometric mean see <cite>manton04</cite>. For the
projected mean from a quaternion point of view see <cite>tyler1981</cite>.
</p>
<p>tyler1981, moakher02, manton04
</p>


<h3>Value</h3>

<p>Estimate of the projected or geometric mean of the sample in the same
parametrization.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+median.SO3">median.SO3</a></code>, <code><a href="#topic+bayes.mean">bayes.mean</a></code>, <code><a href="#topic+weighted.mean.SO3">weighted.mean.SO3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rvmises, kappa = 0.01)

# Projected mean
mean(Rs)

# Same as mean(Rs)
project.SO3(colMeans(Rs))

# Geometric mean
mean(Rs, type = "geometric")

# Bias of the projected mean
rot.dist(mean(Rs))

# Bias of the geometric mean
rot.dist(mean(Rs, type = "geometric"))

# Same thing with quaternion form
Qs &lt;- as.Q4(Rs)
mean(Qs)
mean(Qs, type = "geometric")
rot.dist(mean(Qs))
rot.dist(mean(Qs, type = "geometric"))
</code></pre>

<hr>
<h2 id='median'>Median rotation</h2><span id='topic+median'></span><span id='topic+median.SO3'></span><span id='topic+median.Q4'></span>

<h3>Description</h3>

<p>Compute the sample projected or geometric median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SO3'
median(
  x,
  na.rm = FALSE,
  type = "projected",
  epsilon = 1e-05,
  maxIter = 2000,
  ...
)

## S3 method for class 'Q4'
median(
  x,
  na.rm = FALSE,
  type = "projected",
  epsilon = 1e-05,
  maxIter = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix form (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="median_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="median_+3A_type">type</code></td>
<td>
<p>string indicating &quot;projected&quot; or &quot;geometric&quot; type mean estimator.</p>
</td></tr>
<tr><td><code id="median_+3A_epsilon">epsilon</code></td>
<td>
<p>stopping rule.</p>
</td></tr>
<tr><td><code id="median_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations allowed before returning most
recent estimate.</p>
</td></tr>
<tr><td><code id="median_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The median-type estimators are defined as
</p>
<p style="text-align: center;"><code class="reqn">\widetilde{\bm{S}}=argmin_{\bm{S}\in
SO(3)}\sum_{i=1}^nd(\bm{R}_i,\bm{S}).</code>
</p>
<p> If the choice of
distance metric <code class="reqn">d</code> is Riemannian then the estimator is called the
geometric median, and if the distance metric in Euclidean then it is called
the projected median. The algorithm used in the geometric case is discussed
in <cite>hartley11</cite> and the projected case is in <cite>stanfill2013</cite>.
</p>
<p>hartley11 stanfill2013
</p>


<h3>Value</h3>

<p>Estimate of the projected or geometric median in the same
parametrization.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.SO3">mean.SO3</a></code>, <code><a href="#topic+bayes.mean">bayes.mean</a></code>,
<code><a href="#topic+weighted.mean.SO3">weighted.mean.SO3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rvmises, kappa = 0.01)

# Projected median
median(Rs)

# Geometric median
median(Rs, type = "geometric")

# Bias of the projected median
rot.dist(median(Rs))

# Bias of the geometric median
rot.dist(median(Rs, type = "geometric"))

Qs &lt;- as.Q4(Rs)

# Projected median
median(Qs)

# Geometric median
median(Qs, type = "geometric")

# Bias of the projected median
rot.dist(median(Qs))

# Bias of the geometric median
rot.dist(median(Qs, type = "geometric"))
</code></pre>

<hr>
<h2 id='mis.angle'>Misorientation angle</h2><span id='topic+mis.angle'></span><span id='topic+mis.angle.SO3'></span><span id='topic+mis.angle.Q4'></span>

<h3>Description</h3>

<p>Compute the misorientation angle of a rotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mis.angle(x)

## S3 method for class 'SO3'
mis.angle(x)

## S3 method for class 'Q4'
mis.angle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mis.angle_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every rotation can be thought of as some reference coordinate system rotated about an axis through an angle.  These quantities
are referred to as the misorientation axis and misorientation angle, respectively, in the material sciences literature.
This function returns the misorentation angle associated with a rotation assuming the reference coordinate system
is the identity.
</p>


<h3>Value</h3>

<p>Angle of rotation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mis.axis">mis.axis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs &lt;- rcayley(20, kappa = 20)
Rs &lt;- genR(rs, S = id.SO3)
mis.angle(Rs)

#If the central orientation is id.SO3 then mis.angle(Rs) and abs(rs) are equal
all.equal(mis.angle(Rs), abs(rs))  #TRUE

#For other reference frames, the data must be centered first
S &lt;- genR(pi/2)
RsS &lt;- genR(rs, S = S)
mis.axis(RsS-S)
all.equal(mis.angle(RsS-S),abs(rs)) #TRUE

#If the central orientation is NOT id.SO3 then mis.angle(Rs) and abs(rs) are usual unequal
Rs &lt;- genR(rs, S = genR(pi/8))
all.equal(mis.angle(Rs), abs(rs))  #Mean relative difference &gt; 0
</code></pre>

<hr>
<h2 id='mis.axis'>Misorientation axis</h2><span id='topic+mis.axis'></span><span id='topic+mis.axis.SO3'></span><span id='topic+mis.axis.Q4'></span>

<h3>Description</h3>

<p>Determine the misorientation axis of a rotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mis.axis(x, ...)

## S3 method for class 'SO3'
mis.axis(x, ...)

## S3 method for class 'Q4'
mis.axis(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mis.axis_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="mis.axis_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every rotation can be interpreted as some reference coordinate system rotated about an axis through an angle.  These quantities
are referred to as the misorientation axis and misorientation angle, respectively, in the material sciences literature.
This function returns the misorentation axis associated with a rotation assuming the reference coordinate system
is the identity.  The data must be centered before calling <code>mis.axis</code> if a different coordinate system is required.
</p>


<h3>Value</h3>

<p>Axis in form of three dimensional vector of length one.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mis.angle">mis.angle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs &lt;- rcayley(20, kappa = 20)

#If the reference frame is set to id.SO3 then no centering is required
Rs &lt;- genR(rs, S = id.SO3)
mis.axis(Rs)
all.equal(Rs, as.SO3(mis.axis(Rs), mis.angle(Rs)))

#For other reference frames, the data must be centered first
S &lt;- genR(pi/2)
RsS &lt;- genR(rs, S = S)
mis.axis(RsS-S)
all.equal(mis.angle(RsS-S),abs(rs)) #TRUE

Qs &lt;- genR(rs, S = id.Q4, space = "Q4")
mis.axis(Qs)
all.equal(Qs, as.Q4(mis.axis(Qs), mis.angle(Qs)))
</code></pre>

<hr>
<h2 id='Mises'>The circular-von Mises distribution</h2><span id='topic+Mises'></span><span id='topic+dvmises'></span><span id='topic+rvmises'></span><span id='topic+pvmises'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the circular-von Mises distribution with concentration <code>kappa</code> <code class="reqn">\kappa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvmises(r, kappa = 1, nu = NULL, Haar = TRUE)

pvmises(q, kappa = 1, nu = NULL, lower.tail = TRUE)

rvmises(n, kappa = 1, nu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mises_+3A_r">r</code>, <code id="Mises_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="Mises_+3A_kappa">kappa</code></td>
<td>
<p>concentration parameter.</p>
</td></tr>
<tr><td><code id="Mises_+3A_nu">nu</code></td>
<td>
<p>circular variance, can be used in place of <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="Mises_+3A_haar">Haar</code></td>
<td>
<p>logical; if TRUE density is evaluated with respect to the Haar measure.</p>
</td></tr>
<tr><td><code id="Mises_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P(X \le x)</code> otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Mises_+3A_n">n</code></td>
<td>
<p>number of observations.  If <code>length(n)&gt;1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The circular von Mises distribution with concentration <code class="reqn">\kappa</code> has density
</p>
<p style="text-align: center;"><code class="reqn">C_\mathrm{M}(r|\kappa)=\frac{1}{2\pi \mathrm{I_0}(\kappa)}e^{\kappa cos(r)}.</code>
</p>

<p>where <code class="reqn">\mathrm{I_0}(\kappa)</code> is the modified Bessel function of order 0.
</p>


<h3>Value</h3>

<table>
<tr><td><code>dvmises</code></td>
<td>
<p>gives the density</p>
</td></tr>
<tr><td><code>pvmises</code></td>
<td>
<p>gives the distribution function</p>
</td></tr>
<tr><td><code>rvmises</code></td>
<td>
<p>generates random deviates</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+Angular-distributions">Angular-distributions</a> for other distributions in the rotations package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- seq(-pi, pi, length = 500)

#Visualize the von Mises density fucntion with respect to the Haar measure
plot(r, dvmises(r, kappa = 10), type = "l", ylab = "f(r)", ylim = c(0, 100))

#Visualize the von Mises density fucntion with respect to the Lebesgue measure
plot(r, dvmises(r, kappa = 10, Haar = FALSE), type = "l", ylab = "f(r)")

#Plot the von Mises CDF
plot(r,pvmises(r,kappa = 10), type = "l", ylab = "F(r)")

#Generate random observations from von Mises distribution
rs &lt;- rvmises(20, kappa = 1)
hist(rs, breaks = 10)
</code></pre>

<hr>
<h2 id='nickel'>Nickel electron backscatter diffraction data set</h2><span id='topic+nickel'></span>

<h3>Description</h3>

<p>This data set consists of electron backscatter diffraction (EBSD) data
obtained by scanning a fixed 12.5 <code class="reqn">\mu</code>m-by-10 <code class="reqn">\mu</code>m nickel surface
at individual locations spaced 0.2 <code class="reqn">\mu</code>m apart. This scan was repeated
14 times for each of the 3,449 locations yielding a total of 48,286
observations. Every observation corresponds to the orientation, expressed as
a rotation matrix, of a cubic crystal on the metal surface at a particular
location. Be aware that there are missing values and erroneous scans at some
locations and scans. See Bingham et al. (2009) and Bingham et al. (2010) for
more details and analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nickel
</code></pre>


<h3>Format</h3>

<p>A data frame with 48,286 rows and the following 13 columns:
</p>

<dl>
<dt><code>xpos</code></dt><dd><p>location x position</p>
</dd>
<dt><code>ypos</code></dt><dd><p>location y position</p>
</dd>
<dt><code>location</code></dt><dd><p>Location number for easy reference</p>
</dd>
<dt><code>rep</code></dt><dd><p>Replicate scan identifier</p>
</dd>
<dt><code>V1</code></dt><dd><p>First element of x-axis describing crystal orientation at corresponding location</p>
</dd>
<dt><code>V2</code></dt><dd><p>Second element of x-axis describing crystal orientation at corresponding location</p>
</dd>
<dt><code>V3</code></dt><dd><p>Third element of x-axis describing crystal orientation at corresponding location</p>
</dd>
<dt><code>V4</code></dt><dd><p>First element of y-axis describing crystal orientation at corresponding location</p>
</dd>
<dt><code>V5</code></dt><dd><p>Second element of y-axis describing crystal orientation at corresponding location</p>
</dd>
<dt><code>V6</code></dt><dd><p>Third element of y-axis describing crystal orientation at corresponding location</p>
</dd>
<dt><code>V7</code></dt><dd><p>First element of z-axis describing crystal orientation at corresponding location</p>
</dd>
<dt><code>V8</code></dt><dd><p>Second element of z-axis describing crystal orientation at corresponding location</p>
</dd>
<dt><code>V9</code></dt><dd><p>Third element of z-axis describing crystal orientation at corresponding location</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data set was collected by the Ames Lab located in Ames, IA.
</p>


<h3>References</h3>


<ol>
<li><p> Bingham, M. A., Nordman, D., &amp; Vardeman, S. (2009). &quot;Modeling and
inference for measured crystal orientations and a tractable class of
symmetric distributions for rotations in three dimensions.&quot; Journal of the
American Statistical Association, 104(488), pp. 1385-1397.
</p>
</li>
<li><p> Bingham, M. A., Lograsso, B. K., &amp; Laabs, F. C. (2010). &quot;A
statistical analysis of the variation in measured crystal orientations
obtained through electron backscatter diffraction.&quot; Ultramicroscopy,
110(10), pp. 1312-1319.
</p>
</li>
<li><p> Stanfill, B., Genschel, U., &amp; Heike, H. (2013). &quot;Point estimation of
the central orientation of random rotations&quot;. Technometrics, 55(4), pp.
524-535.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Subset the data to include only the first scan
Rep1 &lt;- subset(nickel, rep == 1)

# Get a rough idea of how the grain map looks by plotting the first
# element of the rotation matrix at each location
ggplot2::qplot(xpos, ypos, data = Rep1, colour = V1, size = I(2))

# Focus in on a particular location, for example location 698
Rs &lt;- subset(nickel, location == 698)

# Translate the Rs data.frame into an object of class 'SO3'
Rs &lt;- as.SO3(Rs[,5:13])

# Some observations are not rotations, remove them
Rs &lt;- Rs[is.SO3(Rs),]

# Estimate the central orientation with the average
mean(Rs)

# Re-estimate central orientation robustly
median(Rs)


  # Visualize the location, there appears to be two groups
  plot(Rs, col = c(1, 2, 3))

</code></pre>

<hr>
<h2 id='plot'>Visualizing random rotations</h2><span id='topic+plot'></span><span id='topic+plot.SO3'></span><span id='topic+plot.Q4'></span>

<h3>Description</h3>

<p>This function produces a static three-dimensional globe onto
which  one of the  columns of the provided sample of rotations is projected.
The data are centered around a user-specified rotation matrix.  The static
plot uses <code>ggplot2</code>.  Interactive plots are no longer supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SO3'
plot(
  x,
  center = mean(x),
  col = 1,
  to_range = FALSE,
  show_estimates = NULL,
  label_points = NULL,
  mean_regions = NULL,
  median_regions = NULL,
  alp = NULL,
  m = 300,
  interactive = FALSE,
  ...
)

## S3 method for class 'Q4'
plot(
  x,
  center = mean(x),
  col = 1,
  to_range = FALSE,
  show_estimates = NULL,
  label_points = NULL,
  mean_regions = NULL,
  median_regions = NULL,
  alp = NULL,
  m = 300,
  interactive = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>n rotations in <code>SO3</code> or <code>Q4</code> format.</p>
</td></tr>
<tr><td><code id="plot_+3A_center">center</code></td>
<td>
<p>rotation about which to center the observations.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>integer or vector comprised of 1, 2, 3 indicating which column(s)
to display.  If <code>length(col)&gt;1</code> then each eyeball is labelled with the
corresponding axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_to_range">to_range</code></td>
<td>
<p>logical; if <code>TRUE</code> only part of the globe relevant to
the data is displayed</p>
</td></tr>
<tr><td><code id="plot_+3A_show_estimates">show_estimates</code></td>
<td>
<p>character vector to specify  which of the four
estimates of the principal direction to show. Possibilities are &quot;all&quot;,
&quot;proj.mean&quot;, &quot;proj.median&quot;, &quot;geom.mean&quot;, &quot;geom.median&quot;.</p>
</td></tr>
<tr><td><code id="plot_+3A_label_points">label_points</code></td>
<td>
<p>vector of labels.</p>
</td></tr>
<tr><td><code id="plot_+3A_mean_regions">mean_regions</code></td>
<td>
<p>character vector to specify which of the three confidence
regions to show for the projected mean.  Possibilities are &quot;all&quot;,
&quot;trans.theory&quot;,&quot;trans.bootstrap, &quot;direct.theory&quot;, &quot;direct.bootstrap&quot;.</p>
</td></tr>
<tr><td><code id="plot_+3A_median_regions">median_regions</code></td>
<td>
<p>character vector to specify which of the three
confidence regions to show for the projected median.  Possibilities are
&quot;all&quot;, &quot;theory&quot;, &quot;bootstrap.&quot;</p>
</td></tr>
<tr><td><code id="plot_+3A_alp">alp</code></td>
<td>
<p>alpha level to be used for confidence regions.  See
<code><a href="#topic+region">region</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plot_+3A_m">m</code></td>
<td>
<p>number of bootstrap replicates to use in bootstrap confidence
regions.</p>
</td></tr>
<tr><td><code id="plot_+3A_interactive">interactive</code></td>
<td>
<p>deprecated; <code>sphereplot</code> was set to be removed from CRAN
and was going to take this package down with it</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>parameters passed onto the points layer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A visualization of rotation data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rvmises(200, kappa = 1.0)
Rs &lt;- genR(r)
plot(Rs, center = mean(Rs), show_estimates = "proj.mean", shape = 4)


  # Z is computed internally and contains information on depth
  plot(
    Rs,
    center = mean(Rs),
    show_estimates = c("proj.mean", "geom.mean"),
    label_points = sample(LETTERS, 200, replace = TRUE)
 ) +
   ggplot2::aes(size = Z, alpha = Z) +
   ggplot2::scale_size(limits = c(-1, 1), range = c(0.5, 2.5))

</code></pre>

<hr>
<h2 id='pointsXYZ'>Project rotation data onto sphere</h2><span id='topic+pointsXYZ'></span>

<h3>Description</h3>

<p>Projection of rotation matrices onto sphere with given center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsXYZ(data, center = id.SO3, column = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsXYZ_+3A_data">data</code></td>
<td>
<p>data frame of rotation matrices in <code class="reqn">3\times 3</code> matrix representation.</p>
</td></tr>
<tr><td><code id="pointsXYZ_+3A_center">center</code></td>
<td>
<p>rotation matrix about which to center the observations.</p>
</td></tr>
<tr><td><code id="pointsXYZ_+3A_column">column</code></td>
<td>
<p>integer 1 to 3 indicating which column to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns X, Y, Z standing for the respective coordinates in 3D space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs&lt;-ruars(20, rcayley)

#Project the sample's 3 axes onto the 3-shere centered at the identity rotation

pointsXYZ(Rs, center = id.SO3, column = 1)  #x-axis
pointsXYZ(Rs, center = id.SO3, column = 2)  #y-axis
pointsXYZ(Rs, center = id.SO3, column = 3)  #z-axis
</code></pre>

<hr>
<h2 id='prentice'>Transformation based asymptotic confidence region</h2><span id='topic+prentice'></span><span id='topic+prentice.Q4'></span><span id='topic+prentice.SO3'></span>

<h3>Description</h3>

<p>Find the radius of a <code class="reqn">100(1-\alpha)</code>% confidence region for the
projected mean based on a result from directional statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prentice(x, alp)

## S3 method for class 'Q4'
prentice(x, alp = NULL)

## S3 method for class 'SO3'
prentice(x, alp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prentice_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="prentice_+3A_alp">alp</code></td>
<td>
<p>alpha level desired, e.g. 0.05 or 0.10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the radius of a <code class="reqn">100(1-\alpha)</code>% confidence region for the
central orientation based on the projected mean estimator using the method
due to <cite>prentice1986</cite>.  For a rotation specific version see
<cite>rancourt2000</cite>. The variability in each axis is different so each axis
will have its own radius.
</p>
<p>prentice1986, rancourt2000
</p>


<h3>Value</h3>

<p>Radius of the confidence region centered at the projected mean for
each of the x-, y- and z-axes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesCR">bayesCR</a></code>, <code><a href="#topic+fisheretal">fisheretal</a></code>,
<code><a href="#topic+chang">chang</a></code>, <code><a href="#topic+zhang">zhang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Qs&lt;-ruars(20, rcayley, kappa = 100, space = 'Q4')

# The prentice method can be accessed from the "region" function or the "prentice" function
region(Qs, method = "transformation", type = "asymptotic", alp = 0.1, estimator = "mean")
prentice(Qs, alp = 0.1)
</code></pre>

<hr>
<h2 id='project.SO3'>Projection into SO(3)</h2><span id='topic+project.SO3'></span>

<h3>Description</h3>

<p>Project an arbitrary <code class="reqn">3\times 3</code> matrix into <code class="reqn">SO(3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project.SO3(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project.SO3_+3A_m">M</code></td>
<td>
<p><code class="reqn">3\times 3</code> matrix to project into <code class="reqn">SO(3)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the process detailed in Section 3.1 of <cite>moakher02</cite> to project an arbitrary <code class="reqn">3\times 3</code> matrix into <code class="reqn">SO(3)</code>.
More specifically it finds the closest orthogonal 3-by-3 matrix with determinant one to the provided matrix.
</p>


<h3>Value</h3>

<p>Projection of <code class="reqn">\bm M</code> into <code class="reqn">SO(3)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.SO3">mean.SO3</a></code>, <code><a href="#topic+median.SO3">median.SO3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Project an arbitrary 3x3 matrix into SO(3)
M&lt;-matrix(rnorm(9), 3, 3)
project.SO3(M)

#Project a sample arithmetic mean into SO(3), same as 'mean'
Rs &lt;- ruars(20, rcayley)
Rbar &lt;- colSums(Rs)/nrow(Rs)
project.SO3(Rbar)              #The following is equivalent
mean(Rs)
</code></pre>

<hr>
<h2 id='Q4'>'Q4' class for storing rotation data as quaternions</h2><span id='topic+Q4'></span><span id='topic+as.Q4'></span><span id='topic+as.Q4.default'></span><span id='topic+as.Q4.SO3'></span><span id='topic+as.Q4.Q4'></span><span id='topic+as.Q4.data.frame'></span><span id='topic+is.Q4'></span><span id='topic+id.Q4'></span>

<h3>Description</h3>

<p>Creates or tests for objects of class &quot;Q4&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Q4(x, ...)

## Default S3 method:
as.Q4(x, theta = NULL, ...)

## S3 method for class 'SO3'
as.Q4(x, ...)

## S3 method for class 'Q4'
as.Q4(x, ...)

## S3 method for class 'data.frame'
as.Q4(x, ...)

is.Q4(x)

id.Q4
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q4_+3A_x">x</code></td>
<td>
<p>object to be coerced or tested</p>
</td></tr>
<tr><td><code id="Q4_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="Q4_+3A_theta">theta</code></td>
<td>
<p>vector or single rotation angle; if <code>length(theta)==1</code>, the
same theta is used for all axes</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code>id.Q4</code> is the identity rotation given by the matrix
<code class="reqn">[1,0,0,0]^\top</code>.
</p>
<p>An object of class <code>Q4</code> with 1 rows and 4 columns.
</p>


<h3>Details</h3>

<p>Construct a single or sample of rotations in 3-dimensions in quaternion form.
Several possible inputs for <code>x</code> are possible and they are differentiated
based on their class and dimension.
</p>
<p>For <code>x</code> an n-by-3 matrix or a vector of length 3, the angle-axis
representation of rotations is utilized.  More specifically, each quaternion
can be interpreted as a rotation of some reference frame about the axis
<code class="reqn">U</code> (of unit length) through the angle <code class="reqn">\theta</code>.  For each axis and
angle the quaternion is formed through
</p>
<p style="text-align: center;"><code class="reqn">q=[cos(\theta/2),sin(\theta/2)U]^\top.</code>
</p>

<p>The object <code>x</code> is treated as if it has rows <code class="reqn">U</code> and <code>theta</code> is
a vector or angles. If no angle is supplied then the length of each axis is
taken to be the angle of rotation theta.
</p>
<p>For <code>x</code> an n-by-9 matrix of rotation matrices or an object of class
<code>"SO3"</code>, this function will return the quaternion equivalent of
<code>x</code>.  See <code><a href="#topic+SO3">SO3</a></code> or the vignette &quot;rotations-intro&quot; for more
details on rotation matrices.
</p>
<p>For <code>x</code> an n-by-4 matrix, rows are treated as quaternions; rows that
aren't of unit length are made unit length while the rest are returned
untouched.  A message is printed if any of the rows are not quaternions.
</p>
<p>For <code>x</code> a <code>"data.frame"</code>, it is translated into a matrix of the
same dimension and the dimensionality of <code>x</code> is used to determine the
data type: angle-axis, quaternion or rotation (see above). As demonstrated
below, <code>is.Q4</code> may return <code>TRUE</code> for a data frame, but the
functions defined for objects of class <code>'Q4'</code> will not be called until
<code>as.Q4</code> has been used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>as.Q4</code></td>
<td>
<p>coerces its object into a Q4 type</p>
</td></tr>
<tr><td><code>is.Q4</code></td>
<td>
<p>returns <code>TRUE</code> or <code>FALSE</code> depending on whether its
argument satisfies the conditions to be an quaternion; namely it must be
four-dimensional and of unit length</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Pull off subject 1's wrist measurements
Subj1Wrist &lt;- subset(drill, Subject == '1' &amp; Joint == 'Wrist')

                               ## The measurements are in columns 5:8
all(is.Q4(Subj1Wrist[,5:8]))   #TRUE, even though Qs is a data.frame, the rows satisfy the
                               #conditions necessary to be quaternions BUT,
                               #S3 methods (e.g. 'mean' or 'plot') for objects of class
                               #'Q4' will not work until 'as.Q4' is used

Qs &lt;- as.Q4(Subj1Wrist[,5:8])  #Coerce measurements into 'Q4' type using as.Q4.data.frame
all(is.Q4(Qs))                 #TRUE
mean(Qs)                       #Estimate central orientation for subject 1's wrist, see ?mean.Q4
Rs &lt;- as.SO3(Qs)               #Coerce a 'Q4' object into rotation matrix format, see ?as.SO3

#Visualize the measurements, see ?plot.Q4 for more

  plot(Qs, col = c(1, 2, 3))

</code></pre>

<hr>
<h2 id='region'>Confidence and credible regions for the central orientation</h2><span id='topic+region'></span><span id='topic+region.Q4'></span><span id='topic+region.SO3'></span>

<h3>Description</h3>

<p>Find the radius of a <code class="reqn">100(1-\alpha)</code>% confidence or credible region for
the central orientation based on the projected mean or median. For more on
the currently available methods see <code><a href="#topic+prentice">prentice</a></code>,
<code><a href="#topic+fisheretal">fisheretal</a></code>, <code><a href="#topic+chang">chang</a></code>, <code><a href="#topic+zhang">zhang</a></code> and
<code><a href="#topic+bayesCR">bayesCR</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>region(x, method, type, estimator, alp = NULL, ...)

## S3 method for class 'Q4'
region(x, method, type, estimator, alp = NULL, ...)

## S3 method for class 'SO3'
region(x, method, type, estimator, alp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="region_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="region_+3A_method">method</code></td>
<td>
<p>character string specifying which type of interval to report,
&quot;bayes&quot;, &quot;transformation&quot; or &quot;direct&quot; based theory.</p>
</td></tr>
<tr><td><code id="region_+3A_type">type</code></td>
<td>
<p>character string, &quot;bootstrap&quot; or &quot;asymptotic&quot; are available.  For
Bayes regions, give the type of likelihood: &quot;Cayley&quot;,&quot;Mises&quot; or &quot;Fisher.&quot;</p>
</td></tr>
<tr><td><code id="region_+3A_estimator">estimator</code></td>
<td>
<p>character string either &quot;mean&quot; or &quot;median.&quot;  Note that not
all method/type combinations are available for both estimators.</p>
</td></tr>
<tr><td><code id="region_+3A_alp">alp</code></td>
<td>
<p>the alpha level desired, e.g. 0.05 or 0.10.</p>
</td></tr>
<tr><td><code id="region_+3A_...">...</code></td>
<td>
<p>additional arguments that are method specific.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For frequentist regions only the radius of the confidence region
centered at the specified estimator is returned. For Bayes regions the
posterior mode and radius of the credible region centered at that mode is
returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesCR">bayesCR</a></code>, <code><a href="#topic+prentice">prentice</a></code>,
<code><a href="#topic+fisheretal">fisheretal</a></code>, <code><a href="#topic+chang">chang</a></code>, <code><a href="#topic+zhang">zhang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rvmises, kappa = 10)

# Compare the region sizes that are currently available

region(Rs, method = "transformation", type = "asymptotic", estimator = "mean", alp = 0.1)
region(Rs, method = "transformation", type = "bootstrap", estimator = "mean",
alp = 0.1, symm = TRUE)
region(Rs, method = "direct", type = "bootstrap", estimator = "mean", alp = 0.1, m = 100)
region(Rs, method = "direct", type = "asymptotic", estimator = "mean", alp = 0.1)

region(Rs, method = "Bayes", type = "Mises", estimator = "mean",
       S0 = mean(Rs), kappa0 = 10, tuneS = 5000, tuneK = 1, burn_in = 1000, alp = .01, m = 5000)

</code></pre>

<hr>
<h2 id='rot.dist'>Rotational distance</h2><span id='topic+rot.dist'></span><span id='topic+rot.dist.SO3'></span><span id='topic+rot.dist.Q4'></span>

<h3>Description</h3>

<p>Calculate the extrinsic or intrinsic distance between two rotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rot.dist(x, ...)

## S3 method for class 'SO3'
rot.dist(x, R2 = id.SO3, method = "extrinsic", p = 1, ...)

## S3 method for class 'Q4'
rot.dist(x, Q2 = id.Q4, method = "extrinsic", p = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rot.dist_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="rot.dist_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="rot.dist_+3A_r2">R2</code>, <code id="rot.dist_+3A_q2">Q2</code></td>
<td>
<p>a single, second rotation in the same parametrization as x.</p>
</td></tr>
<tr><td><code id="rot.dist_+3A_method">method</code></td>
<td>
<p>string indicating &quot;extrinsic&quot; or &quot;intrinsic&quot; method of
distance.</p>
</td></tr>
<tr><td><code id="rot.dist_+3A_p">p</code></td>
<td>
<p>the order of the distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will calculate the intrinsic (Riemannian) or extrinsic
(Euclidean) distance between two rotations. <code>R2</code> and <code>Q2</code> are set
to the identity rotations by default.  For rotations <code class="reqn">R_1</code> and
<code class="reqn">R_2</code> both in <code class="reqn">SO(3)</code>, the Euclidean distance between them is
</p>
<p style="text-align: center;"><code class="reqn">||R_1-R_2||_F</code>
</p>
<p> where <code class="reqn">||\cdot||_F</code> is the
Frobenius norm. The Riemannian distance is defined as </p>
<p style="text-align: center;"><code class="reqn">||Log(R_1^\top
R_2)||_F</code>
</p>
<p> where <code class="reqn">Log</code> is the matrix logarithm, and it
corresponds to the misorientation angle of <code class="reqn">R_1^\top R_2</code>.  See
the vignette &lsquo;rotations-intro&rsquo; for a comparison of these two distance
measures.
</p>


<h3>Value</h3>

<p>The rotational distance between each rotation in x and R2 or Q2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs &lt;- rcayley(20, kappa = 10)
Rs &lt;- genR(rs, S = id.SO3)
dEs &lt;- rot.dist(Rs,id.SO3)
dRs &lt;- rot.dist(Rs, id.SO3 , method = "intrinsic")

#The intrinsic distance between the true central orientation and each observation
#is the same as the absolute value of observations' respective misorientation angles
all.equal(dRs, abs(rs))              #TRUE

#The extrinsic distance is related to the intrinsic distance
all.equal(dEs, 2*sqrt(2)*sin(dRs/2)) #TRUE
</code></pre>

<hr>
<h2 id='rotations'>A package for working with rotation data.</h2><span id='topic+rotations'></span>

<h3>Description</h3>

<p>This package implements tools for working with rotational data: it allows simulation from the 
most commonly used  distributions on <code class="reqn">SO(3)</code>, it includes methods for different mean and median type 
estimators for the central orientation of a sample, it provides confidence regions 
for those estimates and it includes a novel visualization technique for rotation data.
</p>

<hr>
<h2 id='rotdist.sum'>Sample distance</h2><span id='topic+rotdist.sum'></span><span id='topic+rotdist.sum.SO3'></span><span id='topic+rotdist.sum.Q4'></span>

<h3>Description</h3>

<p>Compute the sum of the <code class="reqn">p^{th}</code> order distances between each row of x and S.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotdist.sum(x, S = genR(0, space = class(x)), method = "extrinsic", p = 1)

## S3 method for class 'SO3'
rotdist.sum(x, S = id.SO3, method = "extrinsic", p = 1)

## S3 method for class 'Q4'
rotdist.sum(x, S = id.Q4, method = "extrinsic", p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotdist.sum_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="rotdist.sum_+3A_s">S</code></td>
<td>
<p>the individual matrix of interest, usually an estimate of the mean.</p>
</td></tr>
<tr><td><code id="rotdist.sum_+3A_method">method</code></td>
<td>
<p>type of distance used method in &quot;extrinsic&quot; or &quot;intrinsic&quot;</p>
</td></tr>
<tr><td><code id="rotdist.sum_+3A_p">p</code></td>
<td>
<p>the order of the distances to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sum of the pth order distance between each row of x and S.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rot.dist">rot.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rvmises, kappa = 10)

SE1 &lt;- median(Rs)                      #Projected median
SE2 &lt;- mean(Rs)                        #Projected mean
SR2 &lt;- mean(Rs, type = "geometric")    #Geometric mean

#I will use "rotdist.sum" to verify these three estimators minimize the
#loss function they are designed to minimize relative to the other esimators.
#All of the following statements should evaluate to "TRUE"

#The projected mean minimizes the sum of squared Euclidean distances
rotdist.sum(Rs, S = SE2, p = 2) &lt; rotdist.sum(Rs, S = SE1, p = 2)
rotdist.sum(Rs, S = SE2, p = 2) &lt; rotdist.sum(Rs, S = SR2, p = 2)

#The projected median minimizes the sum of first order Euclidean distances
rotdist.sum(Rs, S = SE1, p = 1) &lt; rotdist.sum(Rs, S = SE2, p = 1)
rotdist.sum(Rs, S = SE1, p = 1) &lt; rotdist.sum(Rs, S = SR2, p = 1)

#The geometric mean minimizes the sum of squared Riemannian distances
rotdist.sum(Rs, S = SR2, p = 2, method = "intrinsic") &lt;
                 rotdist.sum(Rs, S = SE1, p = 2, method = "intrinsic")
rotdist.sum(Rs, S = SR2, p = 2, method = "intrinsic") &lt;
                 rotdist.sum(Rs, S = SE2, p = 2, method = "intrinsic")
</code></pre>

<hr>
<h2 id='skew.exp'>Matrix exponential</h2><span id='topic+skew.exp'></span>

<h3>Description</h3>

<p>Compute the matrix exponential for skew-symmetric matrices according to the usual Taylor expansion.
The expansion is significantly simplified for skew-symmetric matrices, see <cite>moakher02</cite>.
Maps a matrix belonging to the lie algebra <code class="reqn">so(3)</code> into the lie group <code class="reqn">SO(3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skew.exp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skew.exp_+3A_x">x</code></td>
<td>
<p>single <code class="reqn">3\times 3</code> skew-symmetric matrix or <code class="reqn">n\times 9</code> sample of skew-symmetric matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>moakher02
</p>


<h3>Value</h3>

<p>Matrix <code class="reqn">e^{\bm H}</code> in <code class="reqn">SO(3)</code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rcayley)
lRs &lt;- log(Rs)           #Take the matrix logarithm for rotation matrices
Rs2 &lt;- skew.exp(lRs)     #Go back to rotation matrices
all.equal(Rs, Rs2)
</code></pre>

<hr>
<h2 id='SO3'>'SO3' class for storing rotation data as rotation matrices</h2><span id='topic+SO3'></span><span id='topic+as.SO3'></span><span id='topic+as.SO3.default'></span><span id='topic+as.SO3.Q4'></span><span id='topic+as.SO3.SO3'></span><span id='topic+as.SO3.data.frame'></span><span id='topic+is.SO3'></span><span id='topic+id.SO3'></span>

<h3>Description</h3>

<p>Creates or tests for objects of class &quot;SO3&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SO3(x, ...)

## Default S3 method:
as.SO3(x, theta = NULL, ...)

## S3 method for class 'Q4'
as.SO3(x, ...)

## S3 method for class 'SO3'
as.SO3(x, ...)

## S3 method for class 'data.frame'
as.SO3(x, ...)

is.SO3(x)

id.SO3
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SO3_+3A_x">x</code></td>
<td>
<p>object to be coerced or tested; see details for possible forms</p>
</td></tr>
<tr><td><code id="SO3_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="SO3_+3A_theta">theta</code></td>
<td>
<p>vector or single rotation angle; if <code>length(theta)==1</code> the
same theta is used for all axes</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code>id.SO3</code> is the identity rotation given by the the 3-by-3
identity matrix.
</p>
<p>An object of class <code>SO3</code> with 1 rows and 9 columns.
</p>


<h3>Details</h3>

<p>Construct a single or sample of rotations in 3-dimensions in 3-by-3 matrix
form.  Several possible inputs for <code>x</code> are possible and they are
differentiated based on their class and dimension.
</p>
<p>For <code>x</code> an n-by-3 matrix or a vector of length 3, the angle-axis
representation of rotations is utilized.  More specifically, each rotation
matrix can be interpreted as a rotation of some reference frame about the
axis <code class="reqn">U</code> (of unit length) through the angle <code class="reqn">\theta</code>.  If a single
axis (in matrix or vector format) or matrix of axes are provided for
<code>x</code>, then for each axis and angle the matrix is formed through
</p>
<p style="text-align: center;"><code class="reqn">R=\exp[\Phi(U\theta)]</code>
</p>
<p> where <code class="reqn">U</code> is replace
by <code>x</code>.  If axes are provided but <code>theta</code> is not provided then the
length of each axis is taken to be the angle of rotation, theta.
</p>
<p>For <code>x</code> an n-by-4 matrix of quaternions or an object of class
<code>"Q4"</code>, this function will return the rotation matrix equivalent of
<code>x</code>.  See <code><a href="#topic+Q4">Q4</a></code> or the vignette &quot;rotations-intro&quot; for more
details on quaternions.
</p>
<p>For <code>x</code> an n-by-9 matrix, rows are treated as 3-by-3 matrices; rows that
don't form matrices in SO(3) are projected into SO(3) and those that are
already in SO(3) are returned untouched.  See <code><a href="#topic+project.SO3">project.SO3</a></code> for
more on projecting arbitrary matrices into SO(3).  A message is printed if
any of the rows are not proper rotations.
</p>
<p>For <code>x</code> a <code>"data.frame"</code>, it is translated into a matrix of the
same dimension and the dimensionality of <code>x</code> is used to determine the
data type: angle-axis, quaternion or rotation. As demonstrated below,
<code>is.SO3</code> may return <code>TRUE</code> for a data frame, but the functions
defined for objects of class <code>"SO3"</code> will not be called until
<code>as.SO3</code> has been used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>as.SO3</code></td>
<td>
<p>coerces provided data into an SO3 type.</p>
</td></tr>
<tr><td><code>is.SO3</code></td>
<td>
<p>returns <code>TRUE</code> or <code>False</code> depending on whether its
argument satisfies the conditions to be an rotation matrix.  Namely, has
determinant one and its transpose is its inverse.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Select one location to focus on
Loc698 &lt;- subset(nickel, location == 698)

is.SO3(Loc698[,5:13])          #Some of the rows are not rotations due to rounding or entry errors
                               #as.SO3 will project matrices not in SO(3) to SO(3)

Rs &lt;- as.SO3(Loc698[,5:13])    #Translate the Rs data.frame into an object of class 'SO3'
                               #Rows 4, 6 and 13 are not in SO(3) so they are projected to SO(3)

mean(Rs)                       #Estimate the central orientation with the average
median(Rs)                     #Re-estimate central orientation robustly
Qs &lt;- as.Q4(Rs)                #Coerse into "SO3" format, see ?as.SO3 for more

#Visualize the location, there appears to be two groups

  plot(Rs, col = c(1, 2, 3))

</code></pre>

<hr>
<h2 id='tail'>Return the First or Last Parts of an Object</h2><span id='topic+tail'></span><span id='topic+tail.SO3'></span><span id='topic+tail.Q4'></span>

<h3>Description</h3>

<p>Returns the first or last parts of a vector, matrix, table, data frame
or function.  Since <code>head()</code> and <code>tail()</code> are generic
functions, they may also have been extended to other classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SO3'
tail(x, n = 6L, addrownums = TRUE, ...)

## S3 method for class 'Q4'
tail(x, n = 6L, addrownums = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tail_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="tail_+3A_n">n</code></td>
<td>
<p>an integer vector of length up to <code>dim(x)</code> (or 1,
for non-dimensioned objects).  A <code>logical</code> is silently coerced to
integer.  Values specify the indices to be
selected in the corresponding dimension (or along the length) of the
object. A positive value of <code>n[i]</code> includes the first/last
<code>n[i]</code> indices in that dimension, while a negative value
excludes the last/first <code>abs(n[i])</code>, including all remaining
indices. <code>NA</code> or non-specified values (when <code>length(n) &lt;
      length(dim(x))</code>) select all indices in that dimension. Must
contain at least one non-missing value.</p>
</td></tr>
<tr><td><code id="tail_+3A_addrownums">addrownums</code></td>
<td>
<p>deprecated - <code>keepnums</code> should be used
instead. Taken as the value of <code>keepnums</code> if it is explicitly
set when <code>keepnums</code> is not.</p>
</td></tr>
<tr><td><code id="tail_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vector/array based objects, <code>head()</code> (<code>tail()</code>) returns
a subset of the same dimensionality as <code>x</code>, usually of
the same class. For historical reasons, by default they select the
first (last) 6 indices in the first dimension (&quot;rows&quot;) or along the
length of a non-dimensioned vector, and the full extent (all indices)
in any remaining dimensions. <code>head.matrix()</code> and
<code>tail.matrix()</code> are exported.
</p>
<p>The default and array(/matrix) methods for <code>head()</code> and
<code>tail()</code> are quite general. They will work as is for any class
which has a <code>dim()</code> method, a <code>length()</code> method (only
required if <code>dim()</code> returns <code>NULL</code>), and a <code>[</code> method
(that accepts the <code>drop</code> argument and can subset in all
dimensions in the dimensioned case).
</p>
<p>For functions, the lines of the deparsed function are returned as
character strings.
</p>
<p>When <code>x</code> is an array(/matrix) of dimensionality two and more,
<code>tail()</code> will add dimnames similar to how they would appear in a
full printing of <code>x</code> for all dimensions <code>k</code> where
<code>n[k]</code> is specified and non-missing and <code>dimnames(x)[[k]]</code>
(or <code>dimnames(x)</code> itself) is <code>NULL</code>.  Specifically, the
form of the added dimnames will vary for different dimensions as follows:
</p>

<dl>
<dt><code>k=1</code> (rows): </dt><dd><p><code>"[n,]"</code> (right justified with
whitespace padding)</p>
</dd>
<dt><code>k=2</code> (columns): </dt><dd><p><code>"[,n]"</code> (with <em>no</em> whitespace
padding)</p>
</dd>
<dt><code>k&gt;2</code> (higher dims): </dt><dd><p><code>"n"</code>, i.e., the indices as
<em>character</em> values</p>
</dd>
</dl>

<p>Setting <code>keepnums = FALSE</code> suppresses this behaviour.
</p>
<p>As <code><a href="base.html#topic+data.frame">data.frame</a></code> subsetting (&lsquo;indexing&rsquo;) keeps
<code><a href="base.html#topic+attributes">attributes</a></code>, so do the <code>head()</code> and <code>tail()</code>
methods for data frames.
</p>


<h3>Value</h3>

<p>An object (usually) like <code>x</code> but generally smaller.  Hence, for
<code><a href="base.html#topic+array">array</a></code>s, the result corresponds to <code>x[.., drop=FALSE]</code>.
For <code><a href="stats.html#topic+ftable">ftable</a></code> objects <code>x</code>, a transformed <code>format(x)</code>.
</p>


<h3>Note</h3>

<p>For array inputs the output of <code>tail</code> when <code>keepnums</code> is <code>TRUE</code>,
any dimnames vectors added for dimensions <code>&gt;2</code> are the original
numeric indices in that dimension <em>as character vectors</em>.  This
means that, e.g., for 3-dimensional array <code>arr</code>,
<code>tail(arr, c(2,2,-1))[ , , 2]</code> and
<code>tail(arr, c(2,2,-1))[ , , "2"]</code> may both be valid but have
completely different meanings.
</p>


<h3>Author(s)</h3>

<p>Patrick Burns, improved and corrected by R-Core. Negative argument
added by Vincent Goulet.  Multi-dimension support added by Gabriel Becker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(letters)
head(letters, n = -6L)

head(freeny.x, n = 10L)
head(freeny.y)

head(iris3)
head(iris3, c(6L, 2L))
head(iris3, c(6L, -1L, 2L))

tail(letters)
tail(letters, n = -6L)

tail(freeny.x)
## the bottom-right "corner" :
tail(freeny.x, n = c(4, 2))
tail(freeny.y)

tail(iris3)
tail(iris3, c(6L, 2L))
tail(iris3, c(6L, -1L, 2L))

## iris with dimnames stripped
a3d &lt;- iris3 ; dimnames(a3d) &lt;- NULL
tail(a3d, c(6, -1, 2)) # keepnums = TRUE is default here!
tail(a3d, c(6, -1, 2), keepnums = FALSE)

## data frame w/ a (non-standard) attribute:
treeS &lt;- structure(trees, foo = "bar")
(n &lt;- nrow(treeS))
stopifnot(exprs = { # attribute is kept
    identical(htS &lt;- head(treeS), treeS[1:6, ])
    identical(attr(htS, "foo") , "bar")
    identical(tlS &lt;- tail(treeS), treeS[(n-5):n, ])
    ## BUT if I use "useAttrib(.)", this is *not* ok, when n is of length 2:
    ## --- because [i,j]-indexing of data frames *also* drops "other" attributes ..
    identical(tail(treeS, 3:2), treeS[(n-2):n, 2:3] )
})

tail(library) # last lines of function

head(stats::ftable(Titanic))

## 1d-array (with named dim) :
a1 &lt;- array(1:7, 7); names(dim(a1)) &lt;- "O2"
stopifnot(exprs = {
  identical( tail(a1, 10), a1)
  identical( head(a1, 10), a1)
  identical( head(a1, 1), a1 [1 , drop=FALSE] ) # was a1[1] in R &lt;= 3.6.x
  identical( tail(a1, 2), a1[6:7])
  identical( tail(a1, 1), a1 [7 , drop=FALSE] ) # was a1[7] in R &lt;= 3.6.x
})
</code></pre>

<hr>
<h2 id='UARS'>Generic UARS Distribution</h2><span id='topic+UARS'></span><span id='topic+puars'></span><span id='topic+duars'></span><span id='topic+ruars'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for the the generic uniform axis-random spin (UARS) class of distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duars(R, dangle, S = id.SO3, kappa = 1, ...)

puars(R, pangle = NULL, S = id.SO3, kappa = 1, ...)

ruars(n, rangle, S = NULL, kappa = 1, space = "SO3", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UARS_+3A_r">R</code></td>
<td>
<p>Value at which to evaluate the UARS density.</p>
</td></tr>
<tr><td><code id="UARS_+3A_dangle">dangle</code></td>
<td>
<p>The function to evaluate the angles from, e.g. dcayley, dvmises, dfisher, dhaar.</p>
</td></tr>
<tr><td><code id="UARS_+3A_s">S</code></td>
<td>
<p>central orientation of the distribution.</p>
</td></tr>
<tr><td><code id="UARS_+3A_kappa">kappa</code></td>
<td>
<p>concentration parameter.</p>
</td></tr>
<tr><td><code id="UARS_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="UARS_+3A_pangle">pangle</code></td>
<td>
<p>The form of the angular density, e.g. pcayley, pvmises, pfisher, phaar.</p>
</td></tr>
<tr><td><code id="UARS_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n)&gt;1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="UARS_+3A_rangle">rangle</code></td>
<td>
<p>The function from which to simulate angles, e.g. rcayley, rvmises, rhaar, rfisher.</p>
</td></tr>
<tr><td><code id="UARS_+3A_space">space</code></td>
<td>
<p>indicates the desired representation: matrix (&quot;SO3&quot;) or quaternion (&quot;Q4&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the rotation R with central orientation S and concentration <code class="reqn">\kappa</code> the UARS density is given by
</p>
<p style="text-align: center;"><code class="reqn">f(R|S,\kappa)=\frac{4\pi}{3-tr(S^\top R)}C(\cos^{-1}[tr(S^\top R)-1]/2|\kappa)</code>
</p>

<p>where <code class="reqn">C(r|\kappa)</code> is one of the <a href="#topic+Angular-distributions">Angular-distributions</a>.
</p>
<p>bingham09
</p>


<h3>Value</h3>

<table>
<tr><td><code>duars</code></td>
<td>
<p>gives the density</p>
</td></tr>
<tr><td><code>puars</code></td>
<td>
<p>gives the distribution function.  If pangle is left empty, the empirical CDF is returned.</p>
</td></tr>
<tr><td><code>ruars</code></td>
<td>
<p>generates random deviates</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For more on the angular distribution options see <a href="#topic+Angular-distributions">Angular-distributions</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate random rotations from the Cayley-UARS distribution with central orientation
#rotated about the y-axis through pi/2 radians
S &lt;- as.SO3(c(0, 1, 0), pi/2)
Rs &lt;- ruars(20, rangle = rcayley, kappa = 1, S = S)

rs &lt;- mis.angle(Rs-S)                          #Find the associated misorientation angles
frs &lt;- duars(Rs, dcayley, kappa = 10, S = S)   #Compute UARS density evaluated at each rotations
plot(rs, frs)

cdf &lt;- puars(Rs, pcayley, S = S)               #By supplying 'pcayley', it is used to compute the
plot(rs, cdf)                                  #the CDF

ecdf &lt;- puars(Rs, S = S)                       #No 'puars' arguement is supplied so the empirical
plot(rs, ecdf)                                 #cdf is returned
</code></pre>

<hr>
<h2 id='vmises.kappa'>Circular variance and concentration parameter</h2><span id='topic+vmises.kappa'></span>

<h3>Description</h3>

<p>Return the concentration parameter that corresponds to a given circular
variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmises.kappa(nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmises.kappa_+3A_nu">nu</code></td>
<td>
<p>circular variance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concentration parameter <code class="reqn">\kappa</code> does not translate across circular
distributions.  A commonly used measure of spread in circular distributions
that does translate is the circular variance defined as
<code class="reqn">\nu=1-E[\cos(r)]</code> where <code class="reqn">E[\cos(r)]</code> is
the mean resultant length.  See <cite>mardia2000</cite> for more details. This
function translates the circular variance <code class="reqn">\nu</code> into the corresponding
concentration parameter <code class="reqn">\kappa</code> for the circular-von Mises
distribution.  For numerical stability, a maximum <code class="reqn">\kappa</code> of 500 is
returned.
</p>
<p>mardia2000
</p>


<h3>Value</h3>

<p>Concentration parameter corresponding to nu.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mises">Mises</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the concentration parameter for circular variances 0.25, 0.5, 0.75
vmises.kappa(0.25)
vmises.kappa(0.5)
vmises.kappa(0.75)
</code></pre>

<hr>
<h2 id='weighted.mean'>Weighted mean rotation</h2><span id='topic+weighted.mean'></span><span id='topic+weighted.mean.SO3'></span><span id='topic+weighted.mean.Q4'></span>

<h3>Description</h3>

<p>Compute the weighted geometric or projected mean of a sample of rotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SO3'
weighted.mean(
  x,
  w = NULL,
  type = "projected",
  epsilon = 1e-05,
  maxIter = 2000,
  ...
)

## S3 method for class 'Q4'
weighted.mean(
  x,
  w = NULL,
  type = "projected",
  epsilon = 1e-05,
  maxIter = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.mean_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix form (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_w">w</code></td>
<td>
<p>vector of weights the same length as the number of rows in x giving
the weights to use for elements of x. Default is <code>NULL</code>, which falls
back to the usual <code>mean</code> function.</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_type">type</code></td>
<td>
<p>string indicating &quot;projected&quot; or &quot;geometric&quot; type mean estimator.</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_epsilon">epsilon</code></td>
<td>
<p>stopping rule for the geometric method.</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations allowed before returning most
recent estimate.</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_...">...</code></td>
<td>
<p>only used for consistency with mean.default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a sample of 3D rotations (in matrix or quaternion form)
and returns the weighted projected arithmetic mean <code class="reqn">\widehat{\bm
S}_P</code> or geometric mean <code class="reqn">\widehat{\bm S}_G</code> according to the
<code>type</code> option. For a sample of <code class="reqn">n</code> rotations in matrix form
<code class="reqn">\bm{R}_i\in SO(3), i=1,2,\dots,n</code>, the
weighted mean is defined as </p>
<p style="text-align: center;"><code class="reqn">\widehat{\bm{S}}=argmin_{\bm{S}\in
SO(3)}\sum_{i=1}^nw_id^2(\bm{R}_i,\bm{S})</code>
</p>
<p> where
<code class="reqn">d</code> is the Riemannian or Euclidean distance.  For more on the projected
mean see <cite>moakher02</cite> and for the geometric mean see <cite>manton04</cite>.
</p>
<p>moakher02
</p>


<h3>Value</h3>

<p>Weighted mean of the sample in the same parametrization.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+median.SO3">median.SO3</a></code>, <code><a href="#topic+mean.SO3">mean.SO3</a></code>, <code><a href="#topic+bayes.mean">bayes.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rvmises, kappa = 0.01)

# Find the equal-weight projected mean
mean(Rs)

# Use the rotation misorientation angle as weight
wt &lt;- abs(1 / mis.angle(Rs))
weighted.mean(Rs, wt)

rot.dist(mean(Rs))

# Usually much smaller than unweighted mean
rot.dist(weighted.mean(Rs, wt))

# Can do the same thing with quaternions
Qs &lt;- as.Q4(Rs)
mean(Qs)
wt &lt;- abs(1 / mis.angle(Qs))
weighted.mean(Qs, wt)
rot.dist(mean(Qs))
rot.dist(weighted.mean(Qs, wt))
</code></pre>

<hr>
<h2 id='zhang'>M-estimator theory pivotal bootstrap confidence region</h2><span id='topic+zhang'></span><span id='topic+zhang.SO3'></span><span id='topic+zhang.Q4'></span>

<h3>Description</h3>

<p>Compute the radius of a <code class="reqn">100(1-\alpha)</code>% confidence region for the
central orientation based on M-estimation theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zhang(x, estimator, alp = NULL, m = 300)

## S3 method for class 'SO3'
zhang(x, estimator, alp = NULL, m = 300)

## S3 method for class 'Q4'
zhang(x, estimator, alp = NULL, m = 300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zhang_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td></tr>
<tr><td><code id="zhang_+3A_estimator">estimator</code></td>
<td>
<p>character string either &quot;mean&quot; or &quot;median.&quot;</p>
</td></tr>
<tr><td><code id="zhang_+3A_alp">alp</code></td>
<td>
<p>alpha level desired, e.g. 0.05 or 0.10.</p>
</td></tr>
<tr><td><code id="zhang_+3A_m">m</code></td>
<td>
<p>number of replicates to use to estimate the critical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the radius of a <code class="reqn">100(1-\alpha)</code>% confidence region for the
central orientation based on the projected mean estimator using the method
due to Zhang &amp; Nordman (2009) (unpublished MS thesis).  By construction each
axis will have the same radius so the radius reported is for all three axis.
A normal theory version of this procedure uses the theoretical chi-square
limiting distribution and is given by the <code><a href="#topic+chang">chang</a></code> option.  This
method is called &quot;direct&quot; because it used M-estimation theory for SO(3)
directly instead of relying on transforming a result from directional
statistics as <code><a href="#topic+prentice">prentice</a></code> and <code><a href="#topic+fisheretal">fisheretal</a></code> do.
</p>


<h3>Value</h3>

<p>Radius of the confidence region centered at the specified estimator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesCR">bayesCR</a></code>, <code><a href="#topic+prentice">prentice</a></code>,
<code><a href="#topic+fisheretal">fisheretal</a></code>, <code><a href="#topic+chang">chang</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rs &lt;- ruars(20, rcayley, kappa = 100)

# The zhang method can be accesed from the "region" function or the "zhang" function
# They will be different because it is a bootstrap.
region(Rs, method = "direct", type = "bootstrap", alp = 0.1, estimator = "mean")
zhang(Rs, estimator = "mean", alp = 0.1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
