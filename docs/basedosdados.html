<!DOCTYPE html><html><head><title>Help for package basedosdados</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {basedosdados}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#BaseDosDadosConnection-class'><p>Base dos dados specific connection to BigQuery</p></a></li>
<li><a href='#bd_collect'><p>Collects the results of a remote table called via <code>bdplyr()</code></p></a></li>
<li><a href='#bd_write'><p>Writes the result of operations with <code>bdplyr()</code> to disk</p></a></li>
<li><a href='#bdplyr'><p>Compatibility with dplyr verbs without using SQL language</p></a></li>
<li><a href='#dataset_search'><p>Search for a dataset by keyword</p></a></li>
<li><a href='#download'><p>Write the results of a query locally to a comma-separated file.</p></a></li>
<li><a href='#get_billing_id'><p>Internal functions for project billing management</p></a></li>
<li><a href='#get_dataset_description'><p>Describe a dataset</p></a></li>
<li><a href='#get_table_columns'><p>Get columns in a table</p></a></li>
<li><a href='#get_table_description'><p>Describe a table within a dataset</p></a></li>
<li><a href='#list_dataset_tables'><p>List tables in a dataset</p></a></li>
<li><a href='#partition_table'><p>Slice a big data frame into smaller csv files by grouping variables</p>
Still in development</a></li>
<li><a href='#read_sql'><p>Query our datalake and get results in a tibble</p></a></li>
<li><a href='#set_billing_id'><p>Define your Project Id</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>'Base Dos Dados' R Client</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>An R interface to the 'Base dos Dados' API &lt;https:basedosdados.github.io/mais/py_reference_api/&gt;). Authenticate your project, query our tables, save data to disk and memory, all from R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr (&ge; 0.3.4), dplyr (&ge; 1.0.6), tibble (&ge; 3.1.1), httr
(&ge; 1.4.2), cli (&ge; 2.5.0), magrittr (&ge; 2.0.1), readr (&ge;
1.4.0), stringr (&ge; 1.4.0), dotenv (&ge; 1.0.2), bigrquery (&ge;
1.4.0), glue (&ge; 1.4.2), rlang (&ge; 0.4.0), writexl (&ge; 1.4.0),
fs (&ge; 1.5.0), dbplyr (&ge; 2.1.1), scales (&ge; 1.1.1), DBI (&ge;
1.1.1), typed (&ge; 0.0.1), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-07 01:02:31 UTC; pedro</td>
</tr>
<tr>
<td>Author:</td>
<td>Pedro Cavalcante [aut, cre],
  Daniel Herszenhut <a href="https://orcid.org/0000-0001-8066-1105"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rodrigo Dornelles <a href="https://orcid.org/0000-0003-3709-4760"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pedro Cavalcante &lt;pedrocolrj@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-07 03:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='BaseDosDadosConnection-class'>Base dos dados specific connection to BigQuery</h2><span id='topic+BaseDosDadosConnection-class'></span><span id='topic+dbplyr_edition.BaseDosDadosConnection'></span>

<h3>Description</h3>

<p>Implements a connection class to prevent a bug caused when trying to use
BigQueryConnection. The bug is described in Pull Request #1563. Once fixed,
this class and its method should probably be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BaseDosDadosConnection'
dbplyr_edition(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BaseDosDadosConnection-class_+3A_con">con</code></td>
<td>
<p>A BaseDosDadosConnection object.</p>
</td></tr>
</table>

<hr>
<h2 id='bd_collect'>Collects the results of a remote table called via <code>bdplyr()</code></h2><span id='topic+bd_collect'></span>

<h3>Description</h3>

<p>After <code><a href="#topic+bdplyr">bdplyr()</a></code> is used to create the remote connection, this function
allows you to collect the result of the manipulations carried out with
the dplyr's verbs and thus use it in local memory completely.
</p>
<p>Alternatively, you can also save to disk directly using <code><a href="#topic+bd_write">bd_write()</a></code>
function or its derivatives: <code><a href="#topic+bd_write_csv">bd_write_csv()</a></code> or <code><a href="#topic+bd_write_rds">bd_write_rds()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bd_collect(
  .lazy_tbl,
  billing_project_id = basedosdados::get_billing_id(),
  show_query = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bd_collect_+3A_.lazy_tbl">.lazy_tbl</code></td>
<td>
<p>A variable that contains a database that was previously
connected through the <code><a href="#topic+bdplyr">bdplyr()</a></code> function. Tipically, it will be called
after performing the desired operations with the <code>{dplyr}</code> verbs.</p>
</td></tr>
<tr><td><code id="bd_collect_+3A_billing_project_id">billing_project_id</code></td>
<td>
<p>a string containing your billing project id.
If you've run <code><a href="#topic+set_billing_id">set_billing_id()</a></code> then feel free to leave this empty.</p>
</td></tr>
<tr><td><code id="bd_collect_+3A_show_query">show_query</code></td>
<td>
<p>If TRUE will show the SQL query calling <code><a href="dplyr.html#topic+explain">dplyr::show_query()</a></code>.
Is useful for diagnosing performance problems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# setup billing
 basedosdados::set_billing_id("billing-project-id")

 # select a cool database at Base dos Dados
bd_table &lt;- basedosdados::bdplyr(
  "basedosdados.br_sp_gov_ssp.ocorrencias_registradas")

# quick look
bd_table %&gt;%
  dplyr::glimpse()

 # filter, select and group the remote data
bd_ssp &lt;-  bd_table %&gt;%
  dplyr::filter(ano &gt;= 2019) %&gt;%
  dplyr::select(ano, mes, homicidio_doloso) %&gt;%
  dplyr::group_by(ano, mes)

 # make some plots
library(ggplot2)

bd_ssp %&gt;%
 # collect the data to continue the analisis
 basedosdados::bd_collect() %&gt;%
  dplyr::summarise(homicidios_sum = sum(homicidio_doloso,
                                         na.rm = TRUE)) %&gt;%
  ggplot(aes(x = mes, y = homicidios_sum, fill = ano)) +
  geom_col(position = "dodge")



## End(Not run)
</code></pre>

<hr>
<h2 id='bd_write'>Writes the result of operations with <code><a href="#topic+bdplyr">bdplyr()</a></code> to disk</h2><span id='topic+bd_write'></span><span id='topic+bd_write_rds'></span><span id='topic+bd_write_csv'></span>

<h3>Description</h3>

<p>Writes a remote table to disk that was called via bdplyr.
It will collect the data and write to disk in the chosen format.
You will only need this function if you have not yet collected the data
using the <code><a href="#topic+bd_collect">bd_collect()</a></code>.
</p>
<p>The comprehensive function <code><a href="#topic+bd_write">bd_write()</a></code> takes as a parameter <code>.write_fn</code>,
which will be the name of some function (without parentheses) capable of
writing a tibble to disk.
</p>
<p>As helpers, the <code><a href="#topic+bd_write_rds">bd_write_rds()</a></code> and <code><a href="#topic+bd_write_csv">bd_write_csv()</a></code> functions make it
easier to write in these formats, more common in everyday life, calling
writing functions from <code>{readr}</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bd_write(
  .lazy_tbl,
  .write_fn = `?`(typed::Function()),
  path = `?`(typed::Character(length = 1)),
  overwrite = `?`(FALSE, typed::Logical(1)),
  ...
)

bd_write_rds(.lazy_tbl, path, overwrite = FALSE, compress = "none", ...)

bd_write_csv(
  .lazy_tbl,
  path = `?`(typed::Character(1)),
  overwrite = `?`(FALSE, typed::Logical(1)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bd_write_+3A_.lazy_tbl">.lazy_tbl</code></td>
<td>
<p>A lazy tibble, tipically the output of <code><a href="#topic+bdplyr">bdplyr()</a></code>.</p>
</td></tr>
<tr><td><code id="bd_write_+3A_.write_fn">.write_fn</code></td>
<td>
<p>A function for writing the result of a tibble to
disk. Do not use () afther the function's name, the function <em>object</em> should be passed. Some functions the user might consider are:
<a href="writexl.html#topic+write_xlsx">writexl::write_xlsx</a>, <a href="jsonlite.html#topic+read_json">jsonlite::write_json</a>, <a href="foreign.html#topic+write.dta">foreign::write.dta</a>,
<a href="arrow.html#topic+write_feather">arrow::write_feather</a>, etc.</p>
</td></tr>
<tr><td><code id="bd_write_+3A_path">path</code></td>
<td>
<p>String containing the path for the file to be created.
The desired folders must already exist and the file should normally end with
the corresponding extension.</p>
</td></tr>
<tr><td><code id="bd_write_+3A_overwrite">overwrite</code></td>
<td>
<p>FALSE by default. Indicates whether the local file should
be overwritten if it already exists. Use with care.</p>
</td></tr>
<tr><td><code id="bd_write_+3A_...">...</code></td>
<td>
<p>Parameters passed to the <code>.write_fn</code> function.</p>
</td></tr>
<tr><td><code id="bd_write_+3A_compress">compress</code></td>
<td>
<p>For <code><a href="#topic+bd_write_rds">bd_write_rds()</a></code> only. Compression method to use: &quot;none&quot;
(default), &quot;gz&quot; ,&quot;bz&quot;, or &quot;xz&quot;, in ascending order of compression.
Remember that the higher the compression, the smaller the file size on disk,
ut also the longer the time to load the data. See also: <code><a href="readr.html#topic+read_rds">readr::write_rds()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String containing the path to the created file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

 cool_db &lt;- basedosdados::

# setup billing
basedosdados::set_billing_id("MY-BILLING-ID")

# connect with a Base dos Dados db

cool_db_ssp &lt;- basedosdados::bdplyr(
 "basedosdados.br_sp_gov_ssp.ocorrencias_registradas")

# subset the data
my_subset &lt;- cool_db_ssp %&gt;%
 dplyr::filter(ano == 2021, mes == 04)

# write it in csv - generic function

basedosdados::bd_write(.lazy_tbl = my_subset,
                      .write_fn = write.csv,
                      "data-raw/ssp_subset.csv"
)

# write in .xlsx
basedosdados::bd_write(.lazy_tbl = my_subset,
                      .write_fn = writexl::write_xlsx,
                      "data-raw/ssp_subset.xlsx"
)

# using the derivatives functions
# to csv
basedosdados::bd_write_csv(.lazy_tbl = my_subset,
                          "data-raw/ssp_subset2.csv"
)

#' # to rds
basedosdados::bd_write_rds(.lazy_tbl = my_subset,
                           "data-raw/ssp_subset.rds"
)

# to rds - with compression
basedosdados::bd_write_rds(.lazy_tbl = my_subset,
                           "data-raw/ssp_subset2.rds",
                           compress = "gz"
)

# to rds - with HARD compression
basedosdados::bd_write_rds(.lazy_tbl = my_subset,
                           "data-raw/ssp_subset3.rds",
                           compress = "xz"
)

## using other write functions

# json
basedosdados::bd_write(.lazy_tbl = my_subset,
                       .write_fn = jsonlite::write_json,
                       "data-raw/ssp_subset.json"
)

# dta
basedosdados::bd_write(.lazy_tbl = my_subset,
                       .write_fn = foreign::write.dta,
                       "data-raw/ssp_subset.dta")
)

# feather
basedosdados::bd_write(.lazy_tbl = my_subset,
                       .write_fn = arrow::write_feather,
                       "data-raw/ssp_subset.feather"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdplyr'>Compatibility with dplyr verbs without using SQL language</h2><span id='topic+bdplyr'></span>

<h3>Description</h3>

<p>Allow you to explore and perform operation with Base dos Dados' datasets
without using SQL language. The <code><a href="#topic+bdplyr">bdplyr()</a></code> function creates <code>lazy</code> variables
that will be connected directly to the desired table from Base dos Dados at
Google BigQuery and can be handled with the <a href="dplyr.html#topic+dplyr-package">dplyr::dplyr-package</a>'s verbs
as traditionally done as local bases. See also: <a href="bigrquery.html#topic+src_bigquery">bigrquery::src_bigquery</a>.
</p>
<p>Therefore, it is possible (without using <code>SQL</code>) to perform, for example,
column selection with <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, filter rows with <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>,
operations with <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, joins with <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code> and
other vebs from <code>{dplyr}</code> package.
</p>
<p>The data will be automatically be downloaded from Google BigQuery in the
background as it if necessary, but wille not be loaded into your virtual
memory nor recorded on disk unless expressly requested.
</p>
<p>For this, the functions such as <code><a href="#topic+bd_collect">bd_collect()</a></code> or <code><a href="#topic+bd_write">bd_write()</a></code> should be
used. To load the data handled locally in your virtual memory, use
<code><a href="#topic+bd_collect">bd_collect()</a></code>. To save the result in disk use the broader function
<code><a href="#topic+bd_write">bd_write()</a></code> or its derivatives <code><a href="#topic+bd_write_csv">bd_write_csv()</a></code> or <code><a href="#topic+bd_write_rds">bd_write_rds()</a></code> to
save, respectively in <code>.csv</code> or <code>.rds</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdplyr(
  table,
  billing_project_id = basedosdados::get_billing_id(),
  query_project_id = "basedosdados"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdplyr_+3A_table">table</code></td>
<td>
<p>String in the format <code>(dataset_name)</code>.<code>(table_name)</code>. You can optionally input a project before the dataset name.</p>
</td></tr>
<tr><td><code id="bdplyr_+3A_billing_project_id">billing_project_id</code></td>
<td>
<p>a string containing your billing project id.
If you've run <code><a href="#topic+set_billing_id">set_billing_id()</a></code> then feel free to leave this empty.</p>
</td></tr>
<tr><td><code id="bdplyr_+3A_query_project_id">query_project_id</code></td>
<td>
<p>The project name at GoogleBigQuery. By default
<code>basedosdados</code>. You do not need to inform this if project is uset
on <code>table</code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;lazy tibble&#8288;</code>, which can be handled (almost) as if were a local
database. After satisfactorily handled, the result must be loaded into
memory using <code><a href="#topic+bd_collect">bd_collect()</a></code> or written to disk using <code><a href="#topic+bd_write">bd_write()</a></code> or its
derivatives.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bd_collect">bd_collect()</a></code>, <code><a href="#topic+bd_write">bd_write()</a></code>, <code><a href="#topic+bd_write_rds">bd_write_rds()</a></code>, <code><a href="#topic+bd_write_rds">bd_write_rds()</a></code>,
<a href="bigrquery.html#topic+src_bigquery">bigrquery::src_bigquery</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# set project billing id
basedosdados::set_billing_id("avalidprojectbillingid")

# connects to the remote table I want
base_sim &lt;- bdplyr("br_ms_sim.municipio_causa_idade")

# connects to another remote table
municipios &lt;- bdplyr("br_bd_diretorios_brasil.municipio")

# explore data
base_sim %&gt;%
  dplyr::glimpse()

# use normal `{dplyr}` operations
municipios %&gt;%
  head()

# filter
base_sim_acre &lt;- base_sim %&gt;%
 dplyr::mutate(ano = as.numeric(ano)) %&gt;%
  dplyr::filter(sigla_uf == "AC", ano &gt;= 2018)

municipios_acre &lt;- municipios %&gt;%
  dplyr::filter(sigla_uf == "AC") %&gt;%
  dplyr::select(id_municipio, municipio, regiao)


# join
base_junta &lt;- base_sim_acre %&gt;%
  dplyr::left_join(municipios_acre,
                   by = "id_municipio")

# tests whether the result is satisfactory
base_junta

# collect the result
base_final &lt;- base_junta %&gt;%
  basedosdados::bd_collect()

# alternatively, write in disk the result

base_final %&gt;%
  basedosdados::bd_write_rds(path = "data-raw/data.rds")


## End(Not run)
</code></pre>

<hr>
<h2 id='dataset_search'>Search for a dataset by keyword</h2><span id='topic+dataset_search'></span>

<h3>Description</h3>

<p>Search for a dataset by keyword
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_search(search_term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_search_+3A_search_term">search_term</code></td>
<td>
<p>keyword for search</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with search results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

dataset_search("agua")
dataset_search("educação")


## End(Not run)


</code></pre>

<hr>
<h2 id='download'>Write the results of a query locally to a comma-separated file.</h2><span id='topic+download'></span>

<h3>Description</h3>

<p>Write the results of a query locally to a comma-separated file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download(
  query = NULL,
  table = NULL,
  path,
  billing_project_id = get_billing_id(),
  .na = " "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_+3A_query">query</code></td>
<td>
<p>a string containing a valid SQL query.</p>
</td></tr>
<tr><td><code id="download_+3A_table">table</code></td>
<td>
<p>defaults to <code>NULL</code>. If a table name is provided then it'll be concatenated with &quot;basedosdados.&quot; and the whole table will be returned.</p>
</td></tr>
<tr><td><code id="download_+3A_path">path</code></td>
<td>
<p>String with the output file's name. If running an R Project relative location can be provided. Passed to <code>readr::write_csv</code>'s <code>file</code> argument.</p>
</td></tr>
<tr><td><code id="download_+3A_billing_project_id">billing_project_id</code></td>
<td>
<p>a string containing your billing project id. If you've run <code>set_billing_id</code> then feel free to leave this empty.</p>
</td></tr>
<tr><td><code id="download_+3A_.na">.na</code></td>
<td>
<p>how should missing values be written in the resulting file? Value passed to <code>na</code> argument of <code>readr::write_csv</code>. Defaults to a whitespace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently there's only support for UTF-8 encoding. Users requiring more control over writing should use <code>read_sql</code> to get the data in memory and custom code from there.
</p>


<h3>Value</h3>

<p>Invisibly returns the query's output in a tibble. Intended to be used for side-effects. If you simply want to load a query's result in memory, use <code>read_sql</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

path &lt;- file.path(tempdir(), "pib_per_capita.csv")

bare_query &lt;- "SELECT *
FROM basedosdados.br_tse_eleicoes.bens_candidato
WHERE ano = 2020
AND sigla_uf = \'TO\'"

download(query = bare_query, path = path)

# or download the entire table
download(table = "br_tse_eleicoes.bens_candidato", path = path)


## End(Not run)


</code></pre>

<hr>
<h2 id='get_billing_id'>Internal functions for project billing management</h2><span id='topic+get_billing_id'></span>

<h3>Description</h3>

<p>Retrieves the project's billing Id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_billing_id()
</code></pre>


<h3>Value</h3>

<p>a string with the project's billing id.
</p>

<hr>
<h2 id='get_dataset_description'>Describe a dataset</h2><span id='topic+get_dataset_description'></span>

<h3>Description</h3>

<p>Describe a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dataset_description(dataset_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dataset_description_+3A_dataset_id">dataset_id</code></td>
<td>
<p>a dataset name e.g. if addressing table &quot;br_sp_alesp.deputado&quot; then table_id is <code>br_sp_alesp</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble describing the specified dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

get_dataset_description("br_sp_alesp")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_table_columns'>Get columns in a table</h2><span id='topic+get_table_columns'></span>

<h3>Description</h3>

<p>Get columns in a table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_table_columns(dataset_id, table_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_table_columns_+3A_dataset_id">dataset_id</code></td>
<td>
<p>a dataset name e.g. if addressing table &quot;br_sp_alesp.deputado&quot; then table_id is <code>br_sp_alesp</code></p>
</td></tr>
<tr><td><code id="get_table_columns_+3A_table_id">table_id</code></td>
<td>
<p>a table name e.g. if addressing table &quot;br_sp_alesp.deputado&quot; then table_id is <code>deputado</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble describing all columns in a table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_table_columns("br_sp_alesp", "deputado")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_table_description'>Describe a table within a dataset</h2><span id='topic+get_table_description'></span>

<h3>Description</h3>

<p>Describe a table within a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_table_description(
  dataset_id = `?`(typed::Character(1)),
  table_id = `?`(typed::Character(1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_table_description_+3A_dataset_id">dataset_id</code></td>
<td>
<p>a dataset name e.g. if addressing table &quot;br_sp_alesp.deputado&quot; then table_id is <code>br_sp_alesp</code></p>
</td></tr>
<tr><td><code id="get_table_description_+3A_table_id">table_id</code></td>
<td>
<p>a table name e.g. if addressing table &quot;br_sp_alesp.deputado&quot; then table_id is <code>deputado</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble describing the specified table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_table_description("br_sp_alesp", "deputado")

## End(Not run)
</code></pre>

<hr>
<h2 id='list_dataset_tables'>List tables in a dataset</h2><span id='topic+list_dataset_tables'></span>

<h3>Description</h3>

<p>List tables in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_dataset_tables(dataset_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_dataset_tables_+3A_dataset_id">dataset_id</code></td>
<td>
<p>a dataset name e.g. if addressing table &quot;br_sp_alesp.deputado&quot; then table_id is <code>br_sp_alesp</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble listing all tables in a given dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
list_dataset_tables("br_sp_alesp")

## End(Not run)
</code></pre>

<hr>
<h2 id='partition_table'>Slice a big data frame into smaller csv files by grouping variables
Still in development</h2><span id='topic+partition_table'></span>

<h3>Description</h3>

<p><code>partition_table</code> populates a folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_table(.data, dir, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_table_+3A_.data">.data</code></td>
<td>
<p>a tibble.</p>
</td></tr>
<tr><td><code id="partition_table_+3A_dir">dir</code></td>
<td>
<p>directory where to write the csv files. Must exist before function call.</p>
</td></tr>
<tr><td><code id="partition_table_+3A_...">...</code></td>
<td>
<p>comma-separated variables used to define groupings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns all written files' addresses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

tibble(
  x = rnorm(1000),
  y = runif(1000) + x,
  group = sample(letters, 1000, replace = TRUE)) %&gt;%
  partition_table(tempdir())



## End(Not run)


</code></pre>

<hr>
<h2 id='read_sql'>Query our datalake and get results in a tibble</h2><span id='topic+read_sql'></span>

<h3>Description</h3>

<p><code>read_sql</code> is given either a fully-written SQL query through the <code>query</code> argument or a valid table name through the <code>table</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sql(query, billing_project_id = get_billing_id())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_sql_+3A_query">query</code></td>
<td>
<p>a string containing a valid SQL query.</p>
</td></tr>
<tr><td><code id="read_sql_+3A_billing_project_id">billing_project_id</code></td>
<td>
<p>a string containing your billing project id. If you've run <code>set_billing_id</code> then feel free to leave this empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the query's output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

set_billing_id("&lt;your id here&gt;")

query &lt;- "SELECT
pib.id_municipio,
pop.ano,
pib.PIB / pop.populacao * 1000 as pib_per_capita
FROM `basedosdados.br_ibge_pib.municipio` as pib
JOIN `basedosdados.br_ibge_populacao.municipio` as pop
ON pib.id_municipio = pop.id_municipio
LIMIT 5 "

data &lt;- read_sql(query)

# in case you want to write your data on disk as a .xlsx, .csv or .Rds file.

library(writexl)
library(readr)

dir &lt;- tempdir()

write_xlsx(data, file.path(dir, "data.xlsx"))
write_csv(data, file.path(dir, "data.csv"))
saveRDS(data, file.path(dir, "data.Rds"))


## End(Not run)

</code></pre>

<hr>
<h2 id='set_billing_id'>Define your Project Id</h2><span id='topic+set_billing_id'></span>

<h3>Description</h3>

<p>Define your project billing ids here so all your queries are authenticated and return data, not errors.
If using in production or leaving code available at public repositories, <code>dotenv</code> is highly recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_billing_id(billing_project_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_billing_id_+3A_billing_project_id">billing_project_id</code></td>
<td>
<p>a single character value containing the string. Vectors with longer lengths and non-vectors will trigger an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set_billing_id("my_billing_project_id")

# or load from an .env file

library(dotenv)

load_dot_env("keys.env")
print(Sys.getenv("billing_project_id"))

set_billing_id(Sys.getenv("billing_project_id"))


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
