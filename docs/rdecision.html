<!DOCTYPE html><html><head><title>Help for package rdecision</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rdecision}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rdecision-package'><p>rdecision: Decision Analytic Modelling in Health Economics.</p></a></li>
<li><a href='#Action'><p>An action in a decision tree</p></a></li>
<li><a href='#Arborescence'><p>A rooted directed tree</p></a></li>
<li><a href='#Arrow'><p>A directed edge in a digraph</p></a></li>
<li><a href='#BetaDistribution'><p>A parametrized Beta Distribution</p></a></li>
<li><a href='#BetaModVar'><p>A model variable whose uncertainty follows a Beta distribution</p></a></li>
<li><a href='#BriggsEx47'><p>Probabilistic results of HIV model</p></a></li>
<li><a href='#ChanceNode'><p>A chance node in a decision tree</p></a></li>
<li><a href='#ConstModVar'><p>A constant model variable</p></a></li>
<li><a href='#DecisionNode'><p>A decision node in a decision tree</p></a></li>
<li><a href='#DecisionTree'><p>A decision tree</p></a></li>
<li><a href='#Digraph'><p>A directed graph</p></a></li>
<li><a href='#DiracDistribution'><p>A Dirac delta function</p></a></li>
<li><a href='#DirichletDistribution'><p>A parametrized Dirichlet distribution</p></a></li>
<li><a href='#Distribution'><p>A probability distribution</p></a></li>
<li><a href='#Edge'><p>An edge in a graph</p></a></li>
<li><a href='#EmpiricalDistribution'><p>An empirical distribution</p></a></li>
<li><a href='#ExprModVar'><p>A model variable constructed from an expression of other variables</p></a></li>
<li><a href='#GammaDistribution'><p>A parametrized Gamma distribution</p></a></li>
<li><a href='#GammaModVar'><p>A model variable whose uncertainty follows a Gamma distribution</p></a></li>
<li><a href='#Graph'><p>An undirected graph</p></a></li>
<li><a href='#LeafNode'><p>A leaf node in a decision tree</p></a></li>
<li><a href='#LogNormDistribution'><p>A parametrized log Normal probability distribution</p></a></li>
<li><a href='#LogNormModVar'><p>A model variable whose uncertainty follows a log Normal distribution</p></a></li>
<li><a href='#MarkovState'><p>A state in a Markov model</p></a></li>
<li><a href='#ModVar'><p>A model variable incorporating uncertainty</p></a></li>
<li><a href='#Node'><p>A node in a graph</p></a></li>
<li><a href='#NormalDistribution'><p>A parametrized Normal distribution</p></a></li>
<li><a href='#NormModVar'><p>A model variable whose uncertainty follows a Normal distribution</p></a></li>
<li><a href='#Reaction'><p>A reaction (chance) edge in a decision tree</p></a></li>
<li><a href='#SemiMarkovModel'><p>A semi-Markov model for cohort simulation</p></a></li>
<li><a href='#Stack'><p>A stack</p></a></li>
<li><a href='#Transition'><p>A transition in a semi-Markov model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Decision Analytic Modelling in Health Economics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and functions for modelling health care interventions 
  using decision trees and semi-Markov models. Mechanisms are provided for 
  associating an uncertainty distribution with each source variable and for
  ensuring transparency of the mathematical relationships between variables.
  The package terminology follows Briggs "Decision Modelling for Health
  Economic Evaluation" (2006, ISBN:978-0-19-852662-9).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, R6, rlang (&ge; 0.4.2), stats, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, DiagrammeR, grDevices, knitr, pander, rmarkdown,
testthat (&ge; 3.0.0), utf8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 13:30:15 UTC; simsa</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Sims <a href="https://orcid.org/0000-0002-9553-7278"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Kim Fairbairn <a href="https://orcid.org/0000-0001-5108-6279"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Paola Cognigni <a href="https://orcid.org/0000-0001-5418-3103"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Sims &lt;andrew.sims@newcastle.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 10:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='rdecision-package'>rdecision: Decision Analytic Modelling in Health Economics.</h2><span id='topic+rdecision'></span><span id='topic+rdecision-package'></span>

<h3>Description</h3>

<p>The goal of 'rdecision' is to provide methods for assessing health care
interventions using cohort models (decision trees and semi-Markov models)
which can be constructed using only a few lines of R code. Mechanisms
are provided for associating an uncertainty distribution with each source
variable and for ensuring transparency of the mathematical relationships
between
variables. The package terminology follows Briggs <em>et al</em> &quot;Decision
Modelling for Health Economic Evaluation&quot; (2006, ISBN:978-0-19-852662-9).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a> (<a href="https://orcid.org/0000-0002-9553-7278">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Kim Fairbairn <a href="mailto:kim.fairbairn@nhs.net">kim.fairbairn@nhs.net</a> (<a href="https://orcid.org/0000-0001-5108-6279">ORCID</a>)
</p>
</li>
<li><p> Paola Cognigni <a href="mailto:paola.cognigni@nhs.net">paola.cognigni@nhs.net</a> (<a href="https://orcid.org/0000-0001-5418-3103">ORCID</a>)
</p>
</li></ul>


<hr>
<h2 id='Action'>An action in a decision tree</h2><span id='topic+Action'></span>

<h3>Description</h3>

<p>R6 class representing an action (choice) edge.
</p>


<h3>Details</h3>

<p>A specialism of class <code>Arrow</code> which is used in a decision tree
to represent an edge whose source node is a <code>DecisionNode</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Edge">rdecision::Edge</a></code> -&gt; <code><a href="#topic+Arrow">rdecision::Arrow</a></code> -&gt; <code>Action</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Action-new"><code>Action$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Action-modvars"><code>Action$modvars()</code></a>
</p>
</li>
<li> <p><a href="#method-Action-p"><code>Action$p()</code></a>
</p>
</li>
<li> <p><a href="#method-Action-set_cost"><code>Action$set_cost()</code></a>
</p>
</li>
<li> <p><a href="#method-Action-cost"><code>Action$cost()</code></a>
</p>
</li>
<li> <p><a href="#method-Action-set_benefit"><code>Action$set_benefit()</code></a>
</p>
</li>
<li> <p><a href="#method-Action-benefit"><code>Action$benefit()</code></a>
</p>
</li>
<li> <p><a href="#method-Action-clone"><code>Action$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="endpoints"><a href='../../rdecision/html/Edge.html#method-Edge-endpoints'><code>rdecision::Edge$endpoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="is_same_edge"><a href='../../rdecision/html/Edge.html#method-Edge-is_same_edge'><code>rdecision::Edge$is_same_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="label"><a href='../../rdecision/html/Edge.html#method-Edge-label'><code>rdecision::Edge$label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arrow" data-id="source"><a href='../../rdecision/html/Arrow.html#method-Arrow-source'><code>rdecision::Arrow$source()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arrow" data-id="target"><a href='../../rdecision/html/Arrow.html#method-Arrow-target'><code>rdecision::Arrow$target()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Action-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of type <code>Action</code>. Optionally, a cost
and a benefit may be associated with traversing the edge. A <dfn>pay-off</dfn>
(benefit minus cost)  is sometimes used in edges of decision trees; the
parametrization used here is more general.
</p>


<h5>Usage</h5>

<div class="r"><pre>Action$new(source_node, target_node, label, cost = 0, benefit = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>source_node</code></dt><dd><p>Decision node from which the arrow leaves.</p>
</dd>
<dt><code>target_node</code></dt><dd><p>Node to which the arrow points.</p>
</dd>
<dt><code>label</code></dt><dd><p>Character string containing the arrow label. This
must be defined for an action because the label is used in
tabulation of strategies. It is recommended to choose labels that are
brief and not punctuated with spaces, dots or underscores.</p>
</dd>
<dt><code>cost</code></dt><dd><p>Cost associated with traversal of this edge (numeric or
<code>ModVar</code>).</p>
</dd>
<dt><code>benefit</code></dt><dd><p>Benefit associated with traversal of the edge.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Action</code> object.
</p>


<hr>
<a id="method-Action-modvars"></a>



<h4>Method <code>modvars()</code></h4>

<p>Find all the model variables of type <code>ModVar</code> that have
been specified as values associated with this <code>Action</code>. Includes
operands of these <code>ModVar</code>s, if they are expressions.
</p>


<h5>Usage</h5>

<div class="r"><pre>Action$modvars()</pre></div>



<h5>Returns</h5>

<p>A list of <code>ModVar</code>s.
</p>


<hr>
<a id="method-Action-p"></a>



<h4>Method <code>p()</code></h4>

<p>Return the current value of the edge probability, i.e. the
conditional probability of traversing the edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Action$p()</pre></div>



<h5>Returns</h5>

<p>Numeric value equal to 1.
</p>


<hr>
<a id="method-Action-set_cost"></a>



<h4>Method <code>set_cost()</code></h4>

<p>Set the cost associated with the action edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Action$set_cost(c = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>c</code></dt><dd><p>Cost associated with traversing the action edge. Of type numeric
or <code>ModVar</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>Action</code> object.
</p>


<hr>
<a id="method-Action-cost"></a>



<h4>Method <code>cost()</code></h4>

<p>Return the cost associated with traversing the edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Action$cost()</pre></div>



<h5>Returns</h5>

<p>Cost.
</p>


<hr>
<a id="method-Action-set_benefit"></a>



<h4>Method <code>set_benefit()</code></h4>

<p>Set the benefit associated with the action edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Action$set_benefit(b = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>b</code></dt><dd><p>Benefit associated with traversing the action edge. Of type
numeric or <code>ModVar</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>Action</code> object.
</p>


<hr>
<a id="method-Action-benefit"></a>



<h4>Method <code>benefit()</code></h4>

<p>Return the benefit associated with traversing the edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Action$benefit()</pre></div>



<h5>Returns</h5>

<p>Benefit.
</p>


<hr>
<a id="method-Action-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Action$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='Arborescence'>A rooted directed tree</h2><span id='topic+Arborescence'></span>

<h3>Description</h3>

<p>An R6 class representing an <dfn>arborescence</dfn> (a rooted
directed tree).
</p>


<h3>Details</h3>

<p>Class to encapsulate a directed rooted tree specialization of a
digraph. An arborescence is a directed tree with exactly one root and
unique directed paths from the root. Inherits from class <code>Digraph</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Graph">rdecision::Graph</a></code> -&gt; <code><a href="#topic+Digraph">rdecision::Digraph</a></code> -&gt; <code>Arborescence</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Arborescence-new"><code>Arborescence$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-parent"><code>Arborescence$parent()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-is_parent"><code>Arborescence$is_parent()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-is_leaf"><code>Arborescence$is_leaf()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-root"><code>Arborescence$root()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-is_root"><code>Arborescence$is_root()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-siblings"><code>Arborescence$siblings()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-root_to_leaf_paths"><code>Arborescence$root_to_leaf_paths()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-postree"><code>Arborescence$postree()</code></a>
</p>
</li>
<li> <p><a href="#method-Arborescence-clone"><code>Arborescence$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="degree"><a href='../../rdecision/html/Graph.html#method-Graph-degree'><code>rdecision::Graph$degree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_along"><a href='../../rdecision/html/Graph.html#method-Graph-edge_along'><code>rdecision::Graph$edge_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_at"><a href='../../rdecision/html/Graph.html#method-Graph-edge_at'><code>rdecision::Graph$edge_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_index"><a href='../../rdecision/html/Graph.html#method-Graph-edge_index'><code>rdecision::Graph$edge_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_label"><a href='../../rdecision/html/Graph.html#method-Graph-edge_label'><code>rdecision::Graph$edge_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edges"><a href='../../rdecision/html/Graph.html#method-Graph-edges'><code>rdecision::Graph$edges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="graph_adjacency_matrix"><a href='../../rdecision/html/Graph.html#method-Graph-graph_adjacency_matrix'><code>rdecision::Graph$graph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_edge"><a href='../../rdecision/html/Graph.html#method-Graph-has_edge'><code>rdecision::Graph$has_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_vertex"><a href='../../rdecision/html/Graph.html#method-Graph-has_vertex'><code>rdecision::Graph$has_vertex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="is_simple"><a href='../../rdecision/html/Graph.html#method-Graph-is_simple'><code>rdecision::Graph$is_simple()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="neighbours"><a href='../../rdecision/html/Graph.html#method-Graph-neighbours'><code>rdecision::Graph$neighbours()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="order"><a href='../../rdecision/html/Graph.html#method-Graph-order'><code>rdecision::Graph$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="size"><a href='../../rdecision/html/Graph.html#method-Graph-size'><code>rdecision::Graph$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_along"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_along'><code>rdecision::Graph$vertex_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_at"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_at'><code>rdecision::Graph$vertex_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_index"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_index'><code>rdecision::Graph$vertex_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_label"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_label'><code>rdecision::Graph$vertex_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertexes"><a href='../../rdecision/html/Graph.html#method-Graph-vertexes'><code>rdecision::Graph$vertexes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="arrow_source"><a href='../../rdecision/html/Digraph.html#method-Digraph-arrow_source'><code>rdecision::Digraph$arrow_source()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="arrow_target"><a href='../../rdecision/html/Digraph.html#method-Digraph-arrow_target'><code>rdecision::Digraph$arrow_target()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="as_DOT"><a href='../../rdecision/html/Digraph.html#method-Digraph-as_DOT'><code>rdecision::Digraph$as_DOT()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_adjacency_matrix"><a href='../../rdecision/html/Digraph.html#method-Digraph-digraph_adjacency_matrix'><code>rdecision::Digraph$digraph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_incidence_matrix"><a href='../../rdecision/html/Digraph.html#method-Digraph-digraph_incidence_matrix'><code>rdecision::Digraph$digraph_incidence_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_predecessors"><a href='../../rdecision/html/Digraph.html#method-Digraph-direct_predecessors'><code>rdecision::Digraph$direct_predecessors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_successors"><a href='../../rdecision/html/Digraph.html#method-Digraph-direct_successors'><code>rdecision::Digraph$direct_successors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_acyclic"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_acyclic'><code>rdecision::Digraph$is_acyclic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_arborescence"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_arborescence'><code>rdecision::Digraph$is_arborescence()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_connected"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_connected'><code>rdecision::Digraph$is_connected()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_polytree"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_polytree'><code>rdecision::Digraph$is_polytree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_tree"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_tree'><code>rdecision::Digraph$is_tree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_weakly_connected"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_weakly_connected'><code>rdecision::Digraph$is_weakly_connected()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="paths"><a href='../../rdecision/html/Digraph.html#method-Digraph-paths'><code>rdecision::Digraph$paths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="topological_sort"><a href='../../rdecision/html/Digraph.html#method-Digraph-topological_sort'><code>rdecision::Digraph$topological_sort()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="walk"><a href='../../rdecision/html/Digraph.html#method-Digraph-walk'><code>rdecision::Digraph$walk()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Arborescence-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Arborescence</code> object from sets of nodes
and edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$new(V, A)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>V</code></dt><dd><p>A list of Nodes.</p>
</dd>
<dt><code>A</code></dt><dd><p>A list of Arrows.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>Arborescence</code> object.
</p>


<hr>
<a id="method-Arborescence-parent"></a>



<h4>Method <code>parent()</code></h4>

<p>Find the parent of a Node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$parent(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>Index node, or a list of index Nodes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of Nodes of the same length as v, if v is a list, or a
scalar Node if v is a single node. NA if v (or an element of v) is the
root node.
</p>


<hr>
<a id="method-Arborescence-is_parent"></a>



<h4>Method <code>is_parent()</code></h4>

<p>Test whether the given node(s) is (are) parent(s).
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$is_parent(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>Node to test, or a list of Nodes.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In an arborescence, <code>is_parent()</code> and <code>is_leaf()</code> are
mutually exclusive.
</p>



<h5>Returns</h5>

<p>A logical vector of the same length as v, if v is a list, or a
logical scalar if v is a single node.
</p>


<hr>
<a id="method-Arborescence-is_leaf"></a>



<h4>Method <code>is_leaf()</code></h4>

<p>Test whether the given node is a leaf.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$is_leaf(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>Node to test, or a list of Nodes.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In an arborescence, <code>is_parent()</code> and <code>is_leaf()</code> are
mutually exclusive.
</p>



<h5>Returns</h5>

<p>A logical vector of the same length as v, if v is a list, or a
logical scalar is v is a single node.
</p>


<hr>
<a id="method-Arborescence-root"></a>



<h4>Method <code>root()</code></h4>

<p>Find the root vertex of the arborescence.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$root()</pre></div>



<h5>Returns</h5>

<p>The root vertex.
</p>


<hr>
<a id="method-Arborescence-is_root"></a>



<h4>Method <code>is_root()</code></h4>

<p>Is the specified node the root?
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$is_root(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>Vertex to test, or list of vertexes</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A logical vector if v is a list, or a logical scalar if v is a
single node.
</p>


<hr>
<a id="method-Arborescence-siblings"></a>



<h4>Method <code>siblings()</code></h4>

<p>Find the siblings of a vertex in the arborescence.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$siblings(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>Vertex to test (only accepts a scalar Node).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A (possibly empty) list of siblings.
</p>


<hr>
<a id="method-Arborescence-root_to_leaf_paths"></a>



<h4>Method <code>root_to_leaf_paths()</code></h4>

<p>Find all directed paths from the root of the tree to the
leaves.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$root_to_leaf_paths()</pre></div>



<h5>Returns</h5>

<p>A list of ordered node lists.
</p>


<hr>
<a id="method-Arborescence-postree"></a>



<h4>Method <code>postree()</code></h4>

<p>Implements function <code style="white-space: pre;">&#8288;POSITIONTREE&#8288;</code> (Walker, 1989) to
determine the coordinates for each node in an arborescence.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$postree(
  SiblingSeparation = 4,
  SubtreeSeparation = 4,
  LevelSeparation = 1,
  RootOrientation = "SOUTH",
  MaxDepth = Inf
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>SiblingSeparation</code></dt><dd><p>Distance in arbitrary units for the
distance between siblings.</p>
</dd>
<dt><code>SubtreeSeparation</code></dt><dd><p>Distance in arbitrary units for the
distance between neighbouring subtrees.</p>
</dd>
<dt><code>LevelSeparation</code></dt><dd><p>Distance in arbitrary units for the
separation between adjacent levels.</p>
</dd>
<dt><code>RootOrientation</code></dt><dd><p>Must be one of &quot;NORTH&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;, &quot;WEST&quot;.
Defined as per Walker (1989), but noting that Walker assumed that
y increased down the page. Thus the meaning of NORTH and SOUTH are
opposite to his, with the default (SOUTH) having the child nodes at
positive y value and root at zero, as per his example (figure 12).</p>
</dd>
<dt><code>MaxDepth</code></dt><dd><p>The maximum depth (number of levels) to be drawn; if
the tree exceeds this, an error will be raised.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In the <code>rdecision</code> implementation, the
sibling order is taken to be the lexicographic order of the node
labels, if they are unique among siblings, or the node indexes otherwise.
</p>



<h5>Returns</h5>

<p>A data frame with one row per node and three columns (n, x
and y) where <code>n</code> gives the node index given by the
<code>Graph::vertex_index()</code> function.
</p>


<hr>
<a id="method-Arborescence-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arborescence$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Walker, John Q II. A A node-positioning algorithm for general trees.
University of North Carolina Technical Report <abbr><span class="acronym">TR</span></abbr> 89-034, 1989.

</p>

<hr>
<h2 id='Arrow'>A directed edge in a digraph</h2><span id='topic+Arrow'></span>

<h3>Description</h3>

<p>An R6 class representing an directed edge in a digraph.
</p>


<h3>Details</h3>

<p>An arrow is the formal term for an edge between pairs of nodes in a
directed graph. Inherits from class <code>Edge</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Edge">rdecision::Edge</a></code> -&gt; <code>Arrow</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Arrow-new"><code>Arrow$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Arrow-source"><code>Arrow$source()</code></a>
</p>
</li>
<li> <p><a href="#method-Arrow-target"><code>Arrow$target()</code></a>
</p>
</li>
<li> <p><a href="#method-Arrow-clone"><code>Arrow$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="endpoints"><a href='../../rdecision/html/Edge.html#method-Edge-endpoints'><code>rdecision::Edge$endpoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="is_same_edge"><a href='../../rdecision/html/Edge.html#method-Edge-is_same_edge'><code>rdecision::Edge$is_same_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="label"><a href='../../rdecision/html/Edge.html#method-Edge-label'><code>rdecision::Edge$label()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Arrow-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of type <code>Arrow</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arrow$new(source_node, target_node, label = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>source_node</code></dt><dd><p>Node from which the arrow leaves.</p>
</dd>
<dt><code>target_node</code></dt><dd><p>Node to which the arrow points.</p>
</dd>
<dt><code>label</code></dt><dd><p>Character string containing the arrow label.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Arrow</code> object.
</p>


<hr>
<a id="method-Arrow-source"></a>



<h4>Method <code>source()</code></h4>

<p>Access source node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arrow$source()</pre></div>



<h5>Returns</h5>

<p>Node from which the arrow leads.
</p>


<hr>
<a id="method-Arrow-target"></a>



<h4>Method <code>target()</code></h4>

<p>Access target node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arrow$target()</pre></div>



<h5>Returns</h5>

<p>Node to which the arrow points.
</p>


<hr>
<a id="method-Arrow-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Arrow$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='BetaDistribution'>A parametrized Beta Distribution</h2><span id='topic+BetaDistribution'></span>

<h3>Description</h3>

<p>An R6 class representing a Beta distribution with parameters.
</p>


<h3>Details</h3>

<p>A Beta distribution with hyperparameters for shape (<code>alpha</code>
and <code>beta</code>). Inherits from class <code>Distribution</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Distribution">rdecision::Distribution</a></code> -&gt; <code>BetaDistribution</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BetaDistribution-new"><code>BetaDistribution$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaDistribution-distribution"><code>BetaDistribution$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaDistribution-mean"><code>BetaDistribution$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaDistribution-mode"><code>BetaDistribution$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaDistribution-SD"><code>BetaDistribution$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaDistribution-sample"><code>BetaDistribution$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaDistribution-quantile"><code>BetaDistribution$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaDistribution-clone"><code>BetaDistribution$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="order"><a href='../../rdecision/html/Distribution.html#method-Distribution-order'><code>rdecision::Distribution$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="r"><a href='../../rdecision/html/Distribution.html#method-Distribution-r'><code>rdecision::Distribution$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="varcov"><a href='../../rdecision/html/Distribution.html#method-Distribution-varcov'><code>rdecision::Distribution$varcov()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-BetaDistribution-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of class <code>BetaDistribution</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaDistribution$new(alpha, beta)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>parameter of the Beta distribution.</p>
</dd>
<dt><code>beta</code></dt><dd><p>parameter of the Beta distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>BetaDistribution</code>.
</p>


<hr>
<a id="method-BetaDistribution-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Accessor function for the name of the uncertainty
distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaDistribution$distribution()</pre></div>



<h5>Returns</h5>

<p>Distribution name as character string.
</p>


<hr>
<a id="method-BetaDistribution-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>The expected value of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaDistribution$mean()</pre></div>



<h5>Returns</h5>

<p>Expected value as a numeric value.
</p>


<hr>
<a id="method-BetaDistribution-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>The mode of the distribution (if
<code>alpha</code>, <code>beta</code> &gt; 1)
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaDistribution$mode()</pre></div>



<h5>Returns</h5>

<p>mode as a numeric value.
</p>


<hr>
<a id="method-BetaDistribution-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>The standard deviation of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaDistribution$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-BetaDistribution-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Draw and hold a random sample from the model variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaDistribution$sample(expected = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expected</code></dt><dd><p>If TRUE, sets the next value retrieved by a call to
<code>r()</code> to be the mean of the distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated distribution.
</p>


<hr>
<a id="method-BetaDistribution-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>The quantiles of the Beta distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaDistribution$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Vector of probabilities, in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of quantiles.
</p>


<hr>
<a id="method-BetaDistribution-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaDistribution$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='BetaModVar'>A model variable whose uncertainty follows a Beta distribution</h2><span id='topic+BetaModVar'></span>

<h3>Description</h3>

<p>An R6 class representing a model variable whose uncertainty
is described by a Beta distribution.
</p>


<h3>Details</h3>

<p>A model variable for which the uncertainty in the point estimate can
be modelled with a Beta distribution. The hyperparameters of the
distribution are the shape parameters (<code>alpha</code> and <code>beta</code>) of
the uncertainty distribution. Inherits from class <code>ModVar</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ModVar">rdecision::ModVar</a></code> -&gt; <code>BetaModVar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BetaModVar-new"><code>BetaModVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaModVar-is_probabilistic"><code>BetaModVar$is_probabilistic()</code></a>
</p>
</li>
<li> <p><a href="#method-BetaModVar-clone"><code>BetaModVar$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="SD"><a href='../../rdecision/html/ModVar.html#method-ModVar-SD'><code>rdecision::ModVar$SD()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="description"><a href='../../rdecision/html/ModVar.html#method-ModVar-description'><code>rdecision::ModVar$description()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="distribution"><a href='../../rdecision/html/ModVar.html#method-ModVar-distribution'><code>rdecision::ModVar$distribution()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="get"><a href='../../rdecision/html/ModVar.html#method-ModVar-get'><code>rdecision::ModVar$get()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="is_expression"><a href='../../rdecision/html/ModVar.html#method-ModVar-is_expression'><code>rdecision::ModVar$is_expression()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mean"><a href='../../rdecision/html/ModVar.html#method-ModVar-mean'><code>rdecision::ModVar$mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mode"><a href='../../rdecision/html/ModVar.html#method-ModVar-mode'><code>rdecision::ModVar$mode()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="quantile"><a href='../../rdecision/html/ModVar.html#method-ModVar-quantile'><code>rdecision::ModVar$quantile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="r"><a href='../../rdecision/html/ModVar.html#method-ModVar-r'><code>rdecision::ModVar$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="set"><a href='../../rdecision/html/ModVar.html#method-ModVar-set'><code>rdecision::ModVar$set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="units"><a href='../../rdecision/html/ModVar.html#method-ModVar-units'><code>rdecision::ModVar$units()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-BetaModVar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of class <code>BetaModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaModVar$new(description, units, alpha, beta)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt><dd><p>A character string describing the variable.</p>
</dd>
<dt><code>units</code></dt><dd><p>Units of the variable, as character string.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>parameter of the Beta distribution.</p>
</dd>
<dt><code>beta</code></dt><dd><p>parameter of the Beta distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>BetaModVar</code>.
</p>


<hr>
<a id="method-BetaModVar-is_probabilistic"></a>



<h4>Method <code>is_probabilistic()</code></h4>

<p>Tests whether the model variable is probabilistic,
i.e. a random variable that follows a distribution, or an expression
involving random variables, some of which follow distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaModVar$is_probabilistic()</pre></div>



<h5>Returns</h5>

<p>TRUE if probabilistic
</p>


<hr>
<a id="method-BetaModVar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BetaModVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='BriggsEx47'>Probabilistic results of HIV model</h2><span id='topic+BriggsEx47'></span>

<h3>Description</h3>

<p>A dataset containing PSA results of Briggs example 2.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BriggsEx47)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 7 columns:
</p>

<dl>
<dt>Mono.LYs</dt><dd><p>Life years gained with monotherapy</p>
</dd>
<dt>Mono.Cost</dt><dd><p>Incremental cost with monotherapy, in GBP</p>
</dd>
<dt>Comb.LYs</dt><dd><p>Life years gained with combination therapy</p>
</dd>
<dt>Comb.Cost</dt><dd><p>Incremental cost with combination therapy, in GBP</p>
</dd>
<dt>Diff.LYG</dt><dd><p>Difference in life years gained</p>
</dd>
<dt>Diff.incCost</dt><dd><p>Difference in incremental cost, GBP</p>
</dd>
<dt>ICER</dt><dd><p>Incremental cost effectiveness ratio, GBP/QALY</p>
</dd>
</dl>



<h3>Details</h3>

<p>A dataset containing the results of probabilistic sensitivity
analysis of Briggs (2006) example 2.5 (HIV model), provided as Example 4.7 in
the book. These data were generated from the solution spreadsheet
provided as a companion to the book (Exercise 4.7 solution) via an Excel
macro written to record 1000 runs of the model.
</p>


<h3>Source</h3>

<p><a href="https://www.herc.ox.ac.uk/downloads/decision-modelling-for-health-economic-evaluation/">https://www.herc.ox.ac.uk/downloads/decision-modelling-for-health-economic-evaluation/</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K, Sculpher M. Decision modelling for health economic
evaluation. Oxford, UK: Oxford University Press; 2006.

</p>

<hr>
<h2 id='ChanceNode'>A chance node in a decision tree</h2><span id='topic+ChanceNode'></span>

<h3>Description</h3>

<p>An R6 class representing a chance node in a decision tree.
</p>


<h3>Details</h3>

<p>A chance node is associated with at least two branches to other
nodes, each of which has a conditional probability (the probability of
following that branch given that the node has been reached). Inherits from
class <code>Node</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Node">rdecision::Node</a></code> -&gt; <code>ChanceNode</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ChanceNode-new"><code>ChanceNode$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ChanceNode-clone"><code>ChanceNode$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Node" data-id="label"><a href='../../rdecision/html/Node.html#method-Node-label'><code>rdecision::Node$label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Node" data-id="type"><a href='../../rdecision/html/Node.html#method-Node-type'><code>rdecision::Node$type()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ChanceNode-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>ChanceNode</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>ChanceNode$new(label = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>label</code></dt><dd><p>An optional label for the chance node.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>ChanceNode</code> object
</p>


<hr>
<a id="method-ChanceNode-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ChanceNode$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='ConstModVar'>A constant model variable</h2><span id='topic+ConstModVar'></span>

<h3>Description</h3>

<p>An R6 class representing a constant in a model.
</p>


<h3>Details</h3>

<p>A <code>ModVar</code> with no uncertainty in its value. Its distribution
is treated as a Dirac delta function <code class="reqn">\delta(x-c)</code> where <code class="reqn">c</code> is the
hyperparameter (value of the constant). The benefit over
using a regular numeric variable in a model is that it will appear in
tabulations of the model variables associated with a model and therefore be
explicitly documented as a model input. Inherits from class <code>ModVar</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ModVar">rdecision::ModVar</a></code> -&gt; <code>ConstModVar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ConstModVar-new"><code>ConstModVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ConstModVar-is_probabilistic"><code>ConstModVar$is_probabilistic()</code></a>
</p>
</li>
<li> <p><a href="#method-ConstModVar-clone"><code>ConstModVar$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="SD"><a href='../../rdecision/html/ModVar.html#method-ModVar-SD'><code>rdecision::ModVar$SD()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="description"><a href='../../rdecision/html/ModVar.html#method-ModVar-description'><code>rdecision::ModVar$description()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="distribution"><a href='../../rdecision/html/ModVar.html#method-ModVar-distribution'><code>rdecision::ModVar$distribution()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="get"><a href='../../rdecision/html/ModVar.html#method-ModVar-get'><code>rdecision::ModVar$get()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="is_expression"><a href='../../rdecision/html/ModVar.html#method-ModVar-is_expression'><code>rdecision::ModVar$is_expression()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mean"><a href='../../rdecision/html/ModVar.html#method-ModVar-mean'><code>rdecision::ModVar$mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mode"><a href='../../rdecision/html/ModVar.html#method-ModVar-mode'><code>rdecision::ModVar$mode()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="quantile"><a href='../../rdecision/html/ModVar.html#method-ModVar-quantile'><code>rdecision::ModVar$quantile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="r"><a href='../../rdecision/html/ModVar.html#method-ModVar-r'><code>rdecision::ModVar$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="set"><a href='../../rdecision/html/ModVar.html#method-ModVar-set'><code>rdecision::ModVar$set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="units"><a href='../../rdecision/html/ModVar.html#method-ModVar-units'><code>rdecision::ModVar$units()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ConstModVar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new constant model variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConstModVar$new(description, units, const)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt><dd><p>A character string description of the variable
and its role in the model. This description will be used in a tabulation
of the variables linked to a model.</p>
</dd>
<dt><code>units</code></dt><dd><p>A character string description of the units, e.g. &quot;GBP&quot;,
&quot;per year&quot;.</p>
</dd>
<dt><code>const</code></dt><dd><p>The constant numerical value of the object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>ConstModVar</code> object.
</p>


<hr>
<a id="method-ConstModVar-is_probabilistic"></a>



<h4>Method <code>is_probabilistic()</code></h4>

<p>Tests whether the model variable is probabilistic.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConstModVar$is_probabilistic()</pre></div>



<h5>Details</h5>

<p>Does the random variable follow a distribution, or is it an
expression involving' random variables, some of which follow
distributions?
</p>



<h5>Returns</h5>

<p>TRUE if probabilistic
</p>


<hr>
<a id="method-ConstModVar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConstModVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='DecisionNode'>A decision node in a decision tree</h2><span id='topic+DecisionNode'></span>

<h3>Description</h3>

<p>An R6 class representing a decision node in a decision tree.
</p>


<h3>Details</h3>

<p>A class to represent a decision node in a decision tree. The node
is associated with one or more branches to child nodes. Inherits from class
<code>Node</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Node">rdecision::Node</a></code> -&gt; <code>DecisionNode</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DecisionNode-new"><code>DecisionNode$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionNode-clone"><code>DecisionNode$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Node" data-id="label"><a href='../../rdecision/html/Node.html#method-Node-label'><code>rdecision::Node$label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Node" data-id="type"><a href='../../rdecision/html/Node.html#method-Node-type'><code>rdecision::Node$type()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DecisionNode-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new decision node.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionNode$new(label)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>label</code></dt><dd><p>A label for the node. Must be defined because the label is
used in tabulation of strategies. The label is automatically converted
to a syntactically valid (in R) name to ensure it can be used as a column
name in a data frame.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>DecisionNode</code> object.
</p>


<hr>
<a id="method-DecisionNode-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionNode$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='DecisionTree'>A decision tree</h2><span id='topic+DecisionTree'></span>

<h3>Description</h3>

<p>An R6 class to represent a decision tree model.
</p>


<h3>Details</h3>

<p>A class to represent a decision tree. An object contains a tree of
decision nodes, chance nodes and leaf nodes, connected by edges
(either actions or reactions). It inherits from class <code>Arborescence</code> and
satisfies the following conditions:
</p>

<ol>
<li><p>Nodes and edges must form a tree with a single root and
there must be a unique path from the root to each node.
In graph theory terminology, the directed graph formed by the nodes
and edges must be an <dfn>arborescence</dfn>.
</p>
</li>
<li><p>Each node must inherit from one of <code>DecisionNode</code>,
<code>ChanceNode</code> or <code>LeafNode</code>. Formally the set of vertices
must be a disjoint union of sets of decision nodes, chance nodes
and leaf nodes.
</p>
</li>
<li><p>All and only leaf nodes must have no children.
</p>
</li>
<li><p>Each edge must inherit from either <code>Action</code> or
<code>Reaction</code>.
</p>
</li>
<li><p>All and only edges that have source endpoints joined to
decision nodes must inherit from <code>Action</code>.
</p>
</li>
<li><p>All and only edges that have source endpoints joined to
chance nodes must inherit from <code>Reaction</code>.
</p>
</li>
<li><p>The sum of probabilities of each set of reaction edges
with a common source endpoint must be 1.
</p>
</li>
<li><p>Each <code>DecisionNode</code> must have a label, and the labels of all
<code>DecisionNodes</code> must be unique within the model.
</p>
</li>
<li><p>Each <code>Action</code> must have a label, and the labels of
<code>Action</code>s that share a common source endpoint must be unique.
</p>
</li></ol>



<h3>Super classes</h3>

<p><code><a href="#topic+Graph">rdecision::Graph</a></code> -&gt; <code><a href="#topic+Digraph">rdecision::Digraph</a></code> -&gt; <code><a href="#topic+Arborescence">rdecision::Arborescence</a></code> -&gt; <code>DecisionTree</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DecisionTree-new"><code>DecisionTree$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-decision_nodes"><code>DecisionTree$decision_nodes()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-chance_nodes"><code>DecisionTree$chance_nodes()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-leaf_nodes"><code>DecisionTree$leaf_nodes()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-actions"><code>DecisionTree$actions()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-modvars"><code>DecisionTree$modvars()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-modvar_table"><code>DecisionTree$modvar_table()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-draw"><code>DecisionTree$draw()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-is_strategy"><code>DecisionTree$is_strategy()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-strategy_table"><code>DecisionTree$strategy_table()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-strategy_paths"><code>DecisionTree$strategy_paths()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-edge_properties"><code>DecisionTree$edge_properties()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-evaluate_walks"><code>DecisionTree$evaluate_walks()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-evaluate"><code>DecisionTree$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-tornado"><code>DecisionTree$tornado()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-threshold"><code>DecisionTree$threshold()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-clone"><code>DecisionTree$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="degree"><a href='../../rdecision/html/Graph.html#method-Graph-degree'><code>rdecision::Graph$degree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_along"><a href='../../rdecision/html/Graph.html#method-Graph-edge_along'><code>rdecision::Graph$edge_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_at"><a href='../../rdecision/html/Graph.html#method-Graph-edge_at'><code>rdecision::Graph$edge_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_index"><a href='../../rdecision/html/Graph.html#method-Graph-edge_index'><code>rdecision::Graph$edge_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_label"><a href='../../rdecision/html/Graph.html#method-Graph-edge_label'><code>rdecision::Graph$edge_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edges"><a href='../../rdecision/html/Graph.html#method-Graph-edges'><code>rdecision::Graph$edges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="graph_adjacency_matrix"><a href='../../rdecision/html/Graph.html#method-Graph-graph_adjacency_matrix'><code>rdecision::Graph$graph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_edge"><a href='../../rdecision/html/Graph.html#method-Graph-has_edge'><code>rdecision::Graph$has_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_vertex"><a href='../../rdecision/html/Graph.html#method-Graph-has_vertex'><code>rdecision::Graph$has_vertex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="is_simple"><a href='../../rdecision/html/Graph.html#method-Graph-is_simple'><code>rdecision::Graph$is_simple()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="neighbours"><a href='../../rdecision/html/Graph.html#method-Graph-neighbours'><code>rdecision::Graph$neighbours()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="order"><a href='../../rdecision/html/Graph.html#method-Graph-order'><code>rdecision::Graph$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="size"><a href='../../rdecision/html/Graph.html#method-Graph-size'><code>rdecision::Graph$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_along"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_along'><code>rdecision::Graph$vertex_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_at"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_at'><code>rdecision::Graph$vertex_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_index"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_index'><code>rdecision::Graph$vertex_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_label"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_label'><code>rdecision::Graph$vertex_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertexes"><a href='../../rdecision/html/Graph.html#method-Graph-vertexes'><code>rdecision::Graph$vertexes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="arrow_source"><a href='../../rdecision/html/Digraph.html#method-Digraph-arrow_source'><code>rdecision::Digraph$arrow_source()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="arrow_target"><a href='../../rdecision/html/Digraph.html#method-Digraph-arrow_target'><code>rdecision::Digraph$arrow_target()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="as_DOT"><a href='../../rdecision/html/Digraph.html#method-Digraph-as_DOT'><code>rdecision::Digraph$as_DOT()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_adjacency_matrix"><a href='../../rdecision/html/Digraph.html#method-Digraph-digraph_adjacency_matrix'><code>rdecision::Digraph$digraph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_incidence_matrix"><a href='../../rdecision/html/Digraph.html#method-Digraph-digraph_incidence_matrix'><code>rdecision::Digraph$digraph_incidence_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_predecessors"><a href='../../rdecision/html/Digraph.html#method-Digraph-direct_predecessors'><code>rdecision::Digraph$direct_predecessors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_successors"><a href='../../rdecision/html/Digraph.html#method-Digraph-direct_successors'><code>rdecision::Digraph$direct_successors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_acyclic"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_acyclic'><code>rdecision::Digraph$is_acyclic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_arborescence"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_arborescence'><code>rdecision::Digraph$is_arborescence()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_connected"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_connected'><code>rdecision::Digraph$is_connected()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_polytree"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_polytree'><code>rdecision::Digraph$is_polytree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_tree"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_tree'><code>rdecision::Digraph$is_tree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_weakly_connected"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_weakly_connected'><code>rdecision::Digraph$is_weakly_connected()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="paths"><a href='../../rdecision/html/Digraph.html#method-Digraph-paths'><code>rdecision::Digraph$paths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="topological_sort"><a href='../../rdecision/html/Digraph.html#method-Digraph-topological_sort'><code>rdecision::Digraph$topological_sort()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="walk"><a href='../../rdecision/html/Digraph.html#method-Digraph-walk'><code>rdecision::Digraph$walk()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="is_leaf"><a href='../../rdecision/html/Arborescence.html#method-Arborescence-is_leaf'><code>rdecision::Arborescence$is_leaf()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="is_parent"><a href='../../rdecision/html/Arborescence.html#method-Arborescence-is_parent'><code>rdecision::Arborescence$is_parent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="is_root"><a href='../../rdecision/html/Arborescence.html#method-Arborescence-is_root'><code>rdecision::Arborescence$is_root()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="parent"><a href='../../rdecision/html/Arborescence.html#method-Arborescence-parent'><code>rdecision::Arborescence$parent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="postree"><a href='../../rdecision/html/Arborescence.html#method-Arborescence-postree'><code>rdecision::Arborescence$postree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="root"><a href='../../rdecision/html/Arborescence.html#method-Arborescence-root'><code>rdecision::Arborescence$root()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="root_to_leaf_paths"><a href='../../rdecision/html/Arborescence.html#method-Arborescence-root_to_leaf_paths'><code>rdecision::Arborescence$root_to_leaf_paths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="siblings"><a href='../../rdecision/html/Arborescence.html#method-Arborescence-siblings'><code>rdecision::Arborescence$siblings()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DecisionTree-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new decision tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$new(V, E)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>V</code></dt><dd><p>A list of nodes.</p>
</dd>
<dt><code>E</code></dt><dd><p>A list of edges.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The tree must consist of a set of nodes and a set of edges
which satisfy the conditions given in the details section of this class.
</p>



<h5>Returns</h5>

<p>A <code>DecisionTree</code> object
</p>


<hr>
<a id="method-DecisionTree-decision_nodes"></a>



<h4>Method <code>decision_nodes()</code></h4>

<p>Find the decision nodes in the tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$decision_nodes(what = "node")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt><dd><p>A character string defining what to return. Must be one
of &quot;node&quot;, &quot;label&quot; or &quot;index&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of <code>DecisionNode</code> objects (for what = &quot;node&quot;); a list
of character strings (for what = &quot;label&quot;), or an integer vector with
indexes of the decision nodes (for what = &quot;index&quot;).
</p>


<hr>
<a id="method-DecisionTree-chance_nodes"></a>



<h4>Method <code>chance_nodes()</code></h4>

<p>Find the chance nodes in the tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$chance_nodes(what = "node")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt><dd><p>A character string defining what to return. Must be one
of &quot;node&quot;, &quot;label&quot; or &quot;index&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of <code>ChanceNode</code> objects (for what = &quot;node&quot;); a list
of character strings (for what = &quot;label&quot;), or an integer vector with
indexes of the decision nodes (for what = &quot;index&quot;).
</p>


<hr>
<a id="method-DecisionTree-leaf_nodes"></a>



<h4>Method <code>leaf_nodes()</code></h4>

<p>Find the leaf nodes in the tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$leaf_nodes(what = "node")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt><dd><p>One of &quot;node&quot; (returns Node objects), &quot;label&quot; (returns the
leaf node labels) or &quot;index&quot; (returns the vertex indexes of the leaf
nodes).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of <code>LeafNode</code> objects (for what = &quot;node&quot;); a list
of character strings (for what = &quot;label&quot;); or an integer vector of
leaf node indexes (for what = &quot;index&quot;).
</p>


<hr>
<a id="method-DecisionTree-actions"></a>



<h4>Method <code>actions()</code></h4>

<p>Find the edges that have the specified decision node as
their source.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$actions(d)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>d</code></dt><dd><p>A decision node.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of <code>Action</code> edges.
</p>


<hr>
<a id="method-DecisionTree-modvars"></a>



<h4>Method <code>modvars()</code></h4>

<p>Find all the model variables of type <code>ModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$modvars()</pre></div>



<h5>Details</h5>

<p>Find <code>ModVar</code>s that have been specified as values
associated with the nodes and edges of the tree.
</p>



<h5>Returns</h5>

<p>A list of <code>ModVar</code>s.
</p>


<hr>
<a id="method-DecisionTree-modvar_table"></a>



<h4>Method <code>modvar_table()</code></h4>

<p>Tabulate the model variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$modvar_table(expressions = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expressions</code></dt><dd><p>A logical that defines whether expression model
variables should be included in the tabulation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Data frame with one row per model variable, as follows:
</p>

<dl>
<dt><code>Description</code></dt><dd><p>As given at initialization.</p>
</dd>
<dt><code>Units</code></dt><dd><p>Units of the variable.</p>
</dd>
<dt><code>Distribution</code></dt><dd><p>Either the uncertainty distribution, if
it is a regular model variable, or the expression used to create it,
if it is an <code>ExprModVar</code>.</p>
</dd>
<dt><code>Mean</code></dt><dd><p>Mean; calculated from means of operands if
an expression.</p>
</dd>
<dt><code>E</code></dt><dd><p>Expectation; estimated from random sample if expression,
mean otherwise.</p>
</dd>
<dt><code>SD</code></dt><dd><p>Standard deviation; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Q2.5</code></dt><dd><p>p=0.025 quantile; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Q97.5</code></dt><dd><p>p=0.975 quantile; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Est</code></dt><dd><p>TRUE if the quantiles and SD have been estimated by
random sampling.</p>
</dd>
</dl>



<hr>
<a id="method-DecisionTree-draw"></a>



<h4>Method <code>draw()</code></h4>

<p>Draw the decision tree to the current graphics output.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$draw(border = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>border</code></dt><dd><p>If TRUE draw a light grey border around the plot area.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Uses the algorithm of Walker (1989) to distribute the nodes
compactly (see the <a href="#topic+Arborescence">Arborescence</a> class help for details).
</p>



<h5>Returns</h5>

<p>No return value.
</p>


<hr>
<a id="method-DecisionTree-is_strategy"></a>



<h4>Method <code>is_strategy()</code></h4>

<p>Tests whether an object is a valid strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$is_strategy(strategy)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy</code></dt><dd><p>A list of Action edges.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A strategy is a unanimous prescription of an action taken at
each decision node, coded as a list of action edges. This checks
whether the strategy is valid for this decision tree.
</p>



<h5>Returns</h5>

<p>TRUE if the strategy is valid for this tree. Returns
FALSE if the list of Action edges are not a valid strategy.
</p>


<hr>
<a id="method-DecisionTree-strategy_table"></a>



<h4>Method <code>strategy_table()</code></h4>

<p>Find all potential strategies for the decision tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$strategy_table(what = "index", select = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt><dd><p>A character string defining what to return. Must be one
of &quot;label&quot; or &quot;index&quot;.</p>
</dd>
<dt><code>select</code></dt><dd><p>A single strategy (given as a list of action edges, with
one action edge per decision node). If provided, only that strategy
is selected from the returned table. Intended for tabulating a
single strategy into a readable form.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A strategy is a unanimous prescription of the actions at each
decision node. If there are decision nodes that are descendants of other
nodes in the tree, the strategies returned will not necessarily
be unique.
</p>



<h5>Returns</h5>

<p>A data frame where each row is a potential strategy
and each column is a decision node, ordered lexicographically. Values
are either the index of each action edge, or their label. The row names
are the edge labels of each strategy, concatenated with underscores.
</p>


<hr>
<a id="method-DecisionTree-strategy_paths"></a>



<h4>Method <code>strategy_paths()</code></h4>

<p>Find all paths walked in each possible strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$strategy_paths()</pre></div>



<h5>Details</h5>

<p>A strategy is a unanimous prescription of an action in each
decision node. Some paths can be walked in more than one strategy, if
there exist paths that do not pass a decision node.
</p>



<h5>Returns</h5>

<p>A data frame, where each row is a path walked in a strategy. The
structure is similar to that returned by <code>strategy_table</code> but
includes an extra column, <code>Leaf</code> which gives the leaf node index of
each path, and there is one row for each path in each strategy.
</p>


<hr>
<a id="method-DecisionTree-edge_properties"></a>



<h4>Method <code>edge_properties()</code></h4>

<p>Properties of all actions and reactions as a matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$edge_properties()</pre></div>



<h5>Details</h5>

<p>Gets the properties (probability, cost, benefit) of each
action and reaction in the decision tree in matrix form.
</p>



<h5>Returns</h5>

<p>A numeric matrix with one row per edge, and with four columns:
the index of the edge, the conditional probability of traversing the
edge, the cost of traversing the edge and the benefit associated with
traversing the edge. The column names are <code>index</code>,
<code>probability</code>, <code>cost</code>, <code>benefit</code> and the row names are
the labels of the edges.
</p>


<hr>
<a id="method-DecisionTree-evaluate_walks"></a>



<h4>Method <code>evaluate_walks()</code></h4>

<p>Evaluate the components of pay-off associated with a set of
walks in the decision tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$evaluate_walks(W = NULL, Wi = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>W</code></dt><dd><p>A list of root-to-leaf walks. A walk is a sequence of edges
(actions and reactions), stored as a list. Each walk must start with an
edge whose source is the root node and end with an edge whose target is
a leaf node. The list of walks is normally the walks associated with all
the root to leaf paths in a tree.</p>
</dd>
<dt><code>Wi</code></dt><dd><p>As <var>W</var> but with edge indices instead of Edge objects. One
of <var>W</var> and <var>Wi</var> must be NULL. It is more efficient to provide
<var>Wi</var> during PSA, where the paths do not change between cycles, to
avoid repeated conversion of edges to indices.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For each walk, probability, cost, benefit and utility are
calculated. There is minimal checking of the argument because this
function is intended to be called repeatedly during tree evaluation,
including PSA.
</p>



<h5>Returns</h5>

<p>A pay-off table, represented as a matrix of numeric values
with response columns as follows:
</p>

<dl>
<dt><code>Probability</code></dt><dd><p>The probability of traversing the pathway. </p>
</dd>
<dt><code>Path.Cost</code></dt><dd><p>The cost of traversing the pathway.</p>
</dd>
<dt><code>Path.Benefit</code></dt><dd><p>The benefit derived from traversing the
pathway.</p>
</dd>
<dt><code>Path.Utility</code></dt><dd><p>The utility associated with the outcome (leaf
node).</p>
</dd>
<dt><code>Path.QALY</code></dt><dd><p>The QALYs associated with the outcome (leaf
node).</p>
</dd>
<dt><code>Cost</code></dt><dd><p><code>Path.Cost</code> <code class="reqn">*</code> probability of traversing the
pathway.</p>
</dd>
<dt><code>Benefit</code></dt><dd><p><code>Path.Benefit</code> <code class="reqn">*</code> probability of
traversing the pathway.</p>
</dd>
<dt><code>Utility</code></dt><dd><p><code>Path.Utility</code> <code class="reqn">*</code> probability of
traversing the pathway.</p>
</dd>
<dt><code>QALY</code></dt><dd><p><code>Path.QALY</code> <code class="reqn">*</code> probability of traversing the
pathway.</p>
</dd>
</dl>

<p>The matrix has one row per path, with the row label equal to the
character representation of the index of the leaf node at the end of
the path.
</p>


<hr>
<a id="method-DecisionTree-evaluate"></a>



<h4>Method <code>evaluate()</code></h4>

<p>Evaluate each strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$evaluate(setvars = "expected", N = 1L, by = "strategy")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>setvars</code></dt><dd><p>One of &quot;expected&quot; (evaluate with each model variable at
its mean value), &quot;random&quot; (sample each variable from its uncertainty
distribution and evaluate the model), &quot;q2.5&quot;, &quot;q50&quot;, &quot;q97.5&quot; (set each
model variable to its 2.5%, 50% or 97.5% quantile, respectively, and
evaluate the model) or &quot;current&quot; (leave each model variable at its
current value prior to calling the function and evaluate the model).</p>
</dd>
<dt><code>N</code></dt><dd><p>Number of replicates. Intended for use with PSA
(<code>modvars = "random"</code>); use with <code>modvars</code> = &quot;expected&quot;
will be repetitive and uninformative.</p>
</dd>
<dt><code>by</code></dt><dd><p>One of {&quot;path&quot;, &quot;strategy&quot;, &quot;run&quot;}. If &quot;path&quot;, the table has
one row per path walked per strategy, per run, and includes the label of
the terminating leaf node to identify each path. If &quot;strategy&quot; (the
default), the table is aggregated by strategy, i.e., there is one row per
strategy per run. If &quot;run&quot;, the table has one row per run and uses
concatenated strategy names (as above) and one (cost, benefit, utility,
QALY) as row names.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Starting with the root, the function works though all possible
paths to leaf nodes and computes the probability, cost, benefit and
utility of each, optionally aggregated by strategy or run.
The columns of the returned data frame are:
</p>

<dl>
<dt><code>by = "path"</code></dt><dd>

<dl>
<dt><code>Run</code></dt><dd><p>Run number</p>
</dd>
<dt><code>&lt;label of first decision node&gt;</code></dt><dd><p>label of action leaving
the node</p>
</dd>
<dt><code>&lt;label of second decision node (etc.)&gt;</code></dt><dd><p>label of action
leaving the node</p>
</dd>
<dt><code>Leaf</code></dt><dd><p>The label of terminating leaf node</p>
</dd>
<dt><code>Probability</code></dt><dd><p>Probability of traversing the path</p>
</dd>
<dt><code>Cost</code></dt><dd><p>Cost of traversing the path</p>
</dd>
<dt><code>Benefit</code></dt><dd><p>Benefit of traversing the path</p>
</dd>
<dt><code>Utility</code></dt><dd><p>Utility of traversing the path</p>
</dd>
<dt><code>QALY</code></dt><dd><p>QALY of traversing the path</p>
</dd>
</dl>

</dd>
<dt><code>by = "strategy"</code></dt><dd>

<dl>
<dt><code>Run</code></dt><dd><p>Run number</p>
</dd>
<dt><code>&lt;label of first decision node&gt;</code></dt><dd><p>label of action leaving
the node</p>
</dd>
<dt><code>&lt;label of second decision node (etc)</code></dt><dd><p>label of action</p>
</dd>
<dt><code>Probability</code></dt><dd><p><code class="reqn">\Sigma p_i</code> for the run (1)</p>
</dd>
<dt><code>Cost</code></dt><dd><p>Aggregate cost of the strategy</p>
</dd>
<dt><code>Benefit</code></dt><dd><p>Aggregate benefit of the strategy</p>
</dd>
<dt><code>Utility</code></dt><dd><p>Aggregate utility of the strategy</p>
</dd>
<dt><code>QALY</code></dt><dd><p>Aggregate QALY of the strategy</p>
</dd>
</dl>

</dd>
<dt><code>by = "run"</code></dt><dd>

<dl>
<dt><code>Run</code></dt><dd><p>Run number</p>
</dd>
<dt><code>Probability.&lt;S&gt;</code></dt><dd><p>Probability for strategy S</p>
</dd>
<dt><code>Cost.&lt;S&gt;</code></dt><dd><p>Cost for strategy S</p>
</dd>
<dt><code>Benefit.&lt;S&gt;</code></dt><dd><p>Benefit for strategy S</p>
</dd>
<dt><code>Utility.&lt;S&gt;</code></dt><dd><p>Benefit for strategy S</p>
</dd>
<dt><code>QALY.&lt;S&gt;</code></dt><dd><p>QALY for strategy S</p>
</dd>
</dl>

<p>where &lt;S&gt; is a label associated with strategy <code>S</code>. Each strategy
label is
a list of the labels of the action edges that are traversed in the
strategy, concatenated with underscores. The ordering of each label
part follows the lexicographical order of the decision node labels
concatenated with underscores. For example, if there are three
decision nodes labelled d1, d2 and d3, each strategy label will be of
the form a1i_a2i_a3i where a1i is the label of one action edge
emanating from decision node d1, etc. There will be one probability,
cost, benefit, utility and QALY column for each strategy.
</p>
</dd>
</dl>




<h5>Returns</h5>

<p>A data frame whose columns depend on <code>by</code>; see &quot;Details&quot;.
</p>


<hr>
<a id="method-DecisionTree-tornado"></a>



<h4>Method <code>tornado()</code></h4>

<p>Create a &quot;tornado&quot; diagram.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$tornado(
  index,
  ref,
  outcome = "saving",
  exclude = NULL,
  draw = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>The index strategy (option) to be evaluated.</p>
</dd>
<dt><code>ref</code></dt><dd><p>The reference strategy (option) with which the index strategy
will be compared.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>One of <code>"saving"</code> or <code>"ICER"</code>. For
<code>"saving"</code> (e.g. in cost consequence analysis), the x axis is cost
saved (cost of reference minus
cost of index), on the presumption that the new technology will be cost
saving at the point estimate. For <code>"ICER"</code> the x axis is
<code class="reqn">\Delta C/\Delta E</code> and is expected to be positive at the point
estimate (i.e. in the NE or SW quadrants of the cost-effectiveness
plane), where <code class="reqn">\Delta C</code> is cost of index minus cost of reference,
and <code class="reqn">\Delta E</code> is utility of index minus utility of reference.</p>
</dd>
<dt><code>exclude</code></dt><dd><p>A list of descriptions of model variables to be excluded
from the tornado.</p>
</dd>
<dt><code>draw</code></dt><dd><p>TRUE if the graph is to be drawn; otherwise return the
data frame silently.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Used to compare two strategies for traversing the decision tree.
A strategy is a unanimous prescription of the actions at each
decision node. The extreme values of each input variable are the upper
and lower 95% confidence limits of the uncertainty distributions of each
variable. This ensures that the range of each input is defensible
(Briggs 2012).
</p>



<h5>Returns</h5>

<p>A data frame with one row per input model variable and columns
for: minimum value of the variable, maximum value of the variable,
minimum value of the outcome and maximum value of the outcome. NULL
if there are no <code>ModVar</code>s.
</p>


<hr>
<a id="method-DecisionTree-threshold"></a>



<h4>Method <code>threshold()</code></h4>

<p>Find the threshold value of a model variable at which
the cost difference is zero or the ICER is equal to a threshold, for an
index strategy compared with a reference strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$threshold(
  index,
  ref,
  outcome,
  mvd,
  a,
  b,
  tol,
  lambda = NULL,
  nmax = 1000L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>The index strategy (option) to be evaluated.</p>
</dd>
<dt><code>ref</code></dt><dd><p>The reference strategy (option) with which the index strategy
will be compared.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>One of <code>"saving"</code> or <code>"ICER"</code>. For
<code>"saving"</code> (e.g., in cost consequence analysis), the value of
<code>mvd</code>
is found at which cost saved is zero (cost saved is cost of reference
minus cost of index, on the presumption that the new technology will be
cost saving at the point estimate). For <code>"ICER"</code> the value of
<code>mvd</code>
is found for which the incremental cost effectiveness ratio (ICER) is
equal to the threshold <code>lambda</code>. ICER is calculated as
<code class="reqn">\Delta C/\Delta E</code>, which will normally be positive
at the point estimate (i.e. in the NE or SW quadrants of the
cost-effectiveness plane), where <code class="reqn">\Delta C</code> is cost of index minus
cost of reference and <code class="reqn">\Delta E</code> is utility of index minus utility
of reference.</p>
</dd>
<dt><code>mvd</code></dt><dd><p>The description of the model variable for which the threshold
is to be found.</p>
</dd>
<dt><code>a</code></dt><dd><p>The lower bound of the range of values of <code>mvd</code> to search
for the root (numeric).</p>
</dd>
<dt><code>b</code></dt><dd><p>The upper bound of the range of values of <code>mvd</code> to search
for the root (numeric).</p>
</dd>
<dt><code>tol</code></dt><dd><p>The tolerance to which the threshold should be
calculated (numeric).</p>
</dd>
<dt><code>lambda</code></dt><dd><p>The ICER threshold (threshold ratio) for outcome=&quot;ICER&quot;.</p>
</dd>
<dt><code>nmax</code></dt><dd><p>Maximum number if iterations allowed to reach convergence.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Uses a rudimentary bisection method method to find the root.
In PSA terms, the algorithm finds the value of the specified model
variable for which 50% of runs are cost saving (or above the ICER
threshold) and 50% are cost incurring (below the ICER threshold).
</p>



<h5>Returns</h5>

<p>Value of the model variable of interest at the threshold.
</p>


<hr>
<a id="method-DecisionTree-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K, Sculpher M. Decision modelling for health economic
evaluation. Oxford, UK: Oxford University Press; 2006.
</p>
<p>Briggs AH, Weinstein MC, Fenwick EAL, Karnon J, Sculpher MJ, Paltiel AD.
Model Parameter Estimation and Uncertainty: A Report of the
<abbr><span class="acronym">ISPOR-SMDM</span></abbr> Modeling Good Research Practices Task Force-6.
<em>Value in Health</em> 2012;<b>15</b>:83542,
<a href="https://doi.org/10.1016/j.jval.2012.04.014">doi:10.1016/j.jval.2012.04.014</a>.
</p>
<p>Kaminski B, Jakubczyk M, Szufel P. A framework for sensitivity analysis of
decision trees. <em>Central European Journal of Operational Research</em>
2018;<b>26</b>:13559, <a href="https://doi.org/10.1007/s10100-017-0479-6">doi:10.1007/s10100-017-0479-6</a>.

</p>

<hr>
<h2 id='Digraph'>A directed graph</h2><span id='topic+Digraph'></span>

<h3>Description</h3>

<p>An R6 class representing a digraph (a directed graph).
</p>


<h3>Details</h3>

<p>Encapsulates and provides methods for computation and checking of
directed graphs (digraphs). Inherits from class <code>Graph</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Graph">rdecision::Graph</a></code> -&gt; <code>Digraph</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Digraph-new"><code>Digraph$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-digraph_adjacency_matrix"><code>Digraph$digraph_adjacency_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-digraph_incidence_matrix"><code>Digraph$digraph_incidence_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-topological_sort"><code>Digraph$topological_sort()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_connected"><code>Digraph$is_connected()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_weakly_connected"><code>Digraph$is_weakly_connected()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_acyclic"><code>Digraph$is_acyclic()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_tree"><code>Digraph$is_tree()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_polytree"><code>Digraph$is_polytree()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_arborescence"><code>Digraph$is_arborescence()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-direct_successors"><code>Digraph$direct_successors()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-direct_predecessors"><code>Digraph$direct_predecessors()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-arrow_source"><code>Digraph$arrow_source()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-arrow_target"><code>Digraph$arrow_target()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-paths"><code>Digraph$paths()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-walk"><code>Digraph$walk()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-as_DOT"><code>Digraph$as_DOT()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-clone"><code>Digraph$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="degree"><a href='../../rdecision/html/Graph.html#method-Graph-degree'><code>rdecision::Graph$degree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_along"><a href='../../rdecision/html/Graph.html#method-Graph-edge_along'><code>rdecision::Graph$edge_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_at"><a href='../../rdecision/html/Graph.html#method-Graph-edge_at'><code>rdecision::Graph$edge_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_index"><a href='../../rdecision/html/Graph.html#method-Graph-edge_index'><code>rdecision::Graph$edge_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_label"><a href='../../rdecision/html/Graph.html#method-Graph-edge_label'><code>rdecision::Graph$edge_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edges"><a href='../../rdecision/html/Graph.html#method-Graph-edges'><code>rdecision::Graph$edges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="graph_adjacency_matrix"><a href='../../rdecision/html/Graph.html#method-Graph-graph_adjacency_matrix'><code>rdecision::Graph$graph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_edge"><a href='../../rdecision/html/Graph.html#method-Graph-has_edge'><code>rdecision::Graph$has_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_vertex"><a href='../../rdecision/html/Graph.html#method-Graph-has_vertex'><code>rdecision::Graph$has_vertex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="is_simple"><a href='../../rdecision/html/Graph.html#method-Graph-is_simple'><code>rdecision::Graph$is_simple()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="neighbours"><a href='../../rdecision/html/Graph.html#method-Graph-neighbours'><code>rdecision::Graph$neighbours()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="order"><a href='../../rdecision/html/Graph.html#method-Graph-order'><code>rdecision::Graph$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="size"><a href='../../rdecision/html/Graph.html#method-Graph-size'><code>rdecision::Graph$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_along"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_along'><code>rdecision::Graph$vertex_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_at"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_at'><code>rdecision::Graph$vertex_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_index"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_index'><code>rdecision::Graph$vertex_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_label"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_label'><code>rdecision::Graph$vertex_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertexes"><a href='../../rdecision/html/Graph.html#method-Graph-vertexes'><code>rdecision::Graph$vertexes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Digraph-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Digraph</code> object from sets of nodes and
edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$new(V, A)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>V</code></dt><dd><p>A list of Nodes.</p>
</dd>
<dt><code>A</code></dt><dd><p>A list of Arrows.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A Digraph object.
</p>


<hr>
<a id="method-Digraph-digraph_adjacency_matrix"></a>



<h4>Method <code>digraph_adjacency_matrix()</code></h4>

<p>Compute the adjacency matrix for the digraph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$digraph_adjacency_matrix(boolean = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>boolean</code></dt><dd><p>If <code>TRUE</code>, the adjacency matrix is logical, each
cell is <code>{FALSE,TRUE}</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Each cell contains the number of edges from the row vertex to
the column vertex, with the convention of self loops being counted once,
unless <code>boolean</code> is <code>TRUE</code> when cells are either <code>FALSE</code>
(not adjacent) or <code>TRUE</code> (adjacent).
</p>



<h5>Returns</h5>

<p>A square integer matrix with the number of rows and columns
equal to the order of the graph. The rows and columns are in the
same order as <code>V</code>. If the nodes have defined and unique labels the
dimnames of the matrix are the labels of the nodes.
</p>


<hr>
<a id="method-Digraph-digraph_incidence_matrix"></a>



<h4>Method <code>digraph_incidence_matrix()</code></h4>

<p>Compute the incidence matrix for the digraph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$digraph_incidence_matrix()</pre></div>



<h5>Details</h5>

<p>Each row is a vertex and each column is an edge. Edges leaving
a vertex have value -1 and edges entering have value +1. By convention
self loops have value 0 (1-1). If all vertexes have defined and unique
labels and all edges have defined and unique labels, the dimnames of the
matrix are the labels of the vertexes and edges.
</p>



<h5>Returns</h5>

<p>The incidence matrix of integers.
</p>


<hr>
<a id="method-Digraph-topological_sort"></a>



<h4>Method <code>topological_sort()</code></h4>

<p>Topologically sort the vertexes in the digraph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$topological_sort()</pre></div>



<h5>Details</h5>

<p>Uses Kahn's algorithm (Kahn, 1962).
</p>



<h5>Returns</h5>

<p>A list of vertexes, topologically sorted. If the digraph has
cycles, the returned ordered list will not contain all the vertexes
in the graph, but no error will be raised.
</p>


<hr>
<a id="method-Digraph-is_connected"></a>



<h4>Method <code>is_connected()</code></h4>

<p>Test whether the graph is connected.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_connected()</pre></div>



<h5>Details</h5>

<p>For digraphs this will always return <code>FALSE</code> because
<dfn>connected</dfn> is not defined. Function <code>weakly_connected</code>
calculates whether the underlying graph is connected.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if connected, <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Digraph-is_weakly_connected"></a>



<h4>Method <code>is_weakly_connected()</code></h4>

<p>Test whether the digraph is weakly connected, i.e. if the
underlying graph is connected.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_weakly_connected()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if connected, <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Digraph-is_acyclic"></a>



<h4>Method <code>is_acyclic()</code></h4>

<p>Checks for the presence of a cycle in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_acyclic()</pre></div>



<h5>Details</h5>

<p>Attempts to do a topological sort. If the sort does not contain
all vertexes, the digraph contains at least one cycle. This method
overrides <code>is_acyclic</code> in <code>Graph</code>.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if no cycles detected.
</p>


<hr>
<a id="method-Digraph-is_tree"></a>



<h4>Method <code>is_tree()</code></h4>

<p>Is the digraph's underlying graph a tree?
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_tree()</pre></div>



<h5>Details</h5>

<p>It is a tree if it is connected and acyclic.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the underlying graph is a tree; <code>FALSE</code>
if not.
</p>


<hr>
<a id="method-Digraph-is_polytree"></a>



<h4>Method <code>is_polytree()</code></h4>

<p>Is the digraph's underlying graph a polytree?
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_polytree()</pre></div>



<h5>Details</h5>

<p>It is a polytree if it is directed, connected and acyclic.
Because the object is a digraph (directed), this is synonymous with
<code>tree</code>.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the underlying graph is a tree; <code>FALSE</code>
if not.
</p>


<hr>
<a id="method-Digraph-is_arborescence"></a>



<h4>Method <code>is_arborescence()</code></h4>

<p>Is the digraph an arborescence?
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_arborescence()</pre></div>



<h5>Details</h5>

<p>An <dfn>arborescence</dfn> is a tree with a single root and unique
paths from the root.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the digraph is an arborescence; <code>FALSE</code>
if not.
</p>


<hr>
<a id="method-Digraph-direct_successors"></a>



<h4>Method <code>direct_successors()</code></h4>

<p>Find the direct successors of a node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$direct_successors(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>The index vertex (a scalar; does not accept a vector of nodes).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of Nodes or an empty list if the specified
node has no successors.
</p>


<hr>
<a id="method-Digraph-direct_predecessors"></a>



<h4>Method <code>direct_predecessors()</code></h4>

<p>Find the direct predecessors of a node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$direct_predecessors(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>The index vertex (a scalar; does not accept an index of nodes).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of Nodes or an empty list if the specified
node has no predecessors.
</p>


<hr>
<a id="method-Digraph-arrow_source"></a>



<h4>Method <code>arrow_source()</code></h4>

<p>Find the node that is the source of the given arrow.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$arrow_source(a)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>An arrow (directed edge), which must be in the digraph.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The source node is a property of the arrow, not the digraph of
which it is part, hence the canonical method for establishing the source
node of an arrow is via method <code>$source</code> of an <code>Arrow</code> object.
This function is provided for convenience when iterating the arrows of a
digraph. It raises an error if the arrow is not in the graph. It
returns the index of the source node, which is a property of the graph;
the node object itself may be retrieved using the <code>$vertex_at</code>
method of the graph.
</p>



<h5>Returns</h5>

<p>Index of the source node of the specified edge.
</p>


<hr>
<a id="method-Digraph-arrow_target"></a>



<h4>Method <code>arrow_target()</code></h4>

<p>Find the node that is the target of the given arrow.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$arrow_target(a)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p>An arrow (directed edge), which must be in the digraph.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The target node is a property of the arrow, not the digraph of
which it is part, hence the canonical method for establishing the target
node of an arrow is via method <code>$target</code> of an <code>$Arrow</code> object.
This function is provided for convenience when iterating the arrows of a
digraph. It raises an error if the arrow is not in the graph. It
returns the index of the target node, which is a property of the graph;
the node itself may be retrieved using the <code>$vertex_at</code> method
of the graph.
</p>



<h5>Returns</h5>

<p>Index of the target node of the specified edge.
</p>


<hr>
<a id="method-Digraph-paths"></a>



<h4>Method <code>paths()</code></h4>

<p>Find all directed simple paths from source to target.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$paths(s, t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s</code></dt><dd><p>Source node.</p>
</dd>
<dt><code>t</code></dt><dd><p>Target node.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>In simple paths all vertexes are unique. Uses a recursive
depth-first search algorithm.
</p>



<h5>Returns</h5>

<p>A list of ordered node lists.
</p>


<hr>
<a id="method-Digraph-walk"></a>



<h4>Method <code>walk()</code></h4>

<p>Sequence of edges which join the specified path.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$walk(P, what = "edge")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt><dd><p>A list of Nodes</p>
</dd>
<dt><code>what</code></dt><dd><p>One of &quot;edge&quot; or &quot;index&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of Edges for <code>what = "edge"</code> or a list of Edge
indices for <code>what = "index"</code>.
</p>


<hr>
<a id="method-Digraph-as_DOT"></a>



<h4>Method <code>as_DOT()</code></h4>

<p>Exports the digraph in DOT notation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$as_DOT(rankdir = "LR", width = 7, height = 7)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rankdir</code></dt><dd><p>One of &quot;LR&quot; (default), &quot;TB&quot;, &quot;RL&quot; or &quot;BT&quot;.</p>
</dd>
<dt><code>width</code></dt><dd><p>of the drawing, in inches</p>
</dd>
<dt><code>height</code></dt><dd><p>of the drawing, in inches</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Writes a representation of the digraph in the
<code>graphviz</code> DOT language
(<a href="https://graphviz.org/doc/info/lang.html">https://graphviz.org/doc/info/lang.html</a>) for drawing with one
of the <code>graphviz</code> tools, including <code>dot</code> (Gansner, 1993). If
all nodes have labels, these are used in the graph, otherwise the labels
are the node indices.
</p>



<h5>Returns</h5>

<p>A character vector. Intended for passing to <code>writeLines</code>
for saving as a text file.
</p>


<hr>
<a id="method-Digraph-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Gansner ER, Koutsofios E, North SC, Vo K-P. A technique for drawing
directed graphs. <em>IEEE Transactions on Software Engineering</em>,
1993;<b>19</b>:21430, <a href="https://doi.org/10.1109/32.221135">doi:10.1109/32.221135</a>.
</p>
<p>Gross JL, Yellen J, Zhang P. Handbook of Graph Theory. Second edition,
Chapman and Hall/CRC.; 2013, <a href="https://doi.org/10.1201/b16132">doi:10.1201/b16132</a>.
</p>
<p>Kahn AB, Topological Sorting of Large Networks,
<em>Communications of the <abbr><span class="acronym">ACM</span></abbr></em>,
1962;<strong>5</strong>:558-562, <a href="https://doi.org/10.1145/368996.369025">doi:10.1145/368996.369025</a>.

</p>

<hr>
<h2 id='DiracDistribution'>A Dirac delta function</h2><span id='topic+DiracDistribution'></span>

<h3>Description</h3>

<p>An R6 class representing a Dirac Delta function.
</p>


<h3>Details</h3>

<p>A distribution modelled by a Dirac delta function <code class="reqn">\delta(x-c)</code>
where <code class="reqn">c</code> is the hyperparameter (value of the constant). It has
probability 1 that the value will be equal to <code class="reqn">c</code> and zero otherwise.
The mode, mean, quantiles and random samples are all equal to <code class="reqn">c</code>. It is
acknowledged that there is debate over whether Dirac delta functions are
true distributions, but the assumption makes little practical difference in
this case. Inherits from class <code>Distribution</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Distribution">rdecision::Distribution</a></code> -&gt; <code>DiracDistribution</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DiracDistribution-new"><code>DiracDistribution$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DiracDistribution-distribution"><code>DiracDistribution$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-DiracDistribution-mode"><code>DiracDistribution$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-DiracDistribution-mean"><code>DiracDistribution$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-DiracDistribution-SD"><code>DiracDistribution$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-DiracDistribution-quantile"><code>DiracDistribution$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-DiracDistribution-sample"><code>DiracDistribution$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-DiracDistribution-clone"><code>DiracDistribution$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="order"><a href='../../rdecision/html/Distribution.html#method-Distribution-order'><code>rdecision::Distribution$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="r"><a href='../../rdecision/html/Distribution.html#method-Distribution-r'><code>rdecision::Distribution$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="varcov"><a href='../../rdecision/html/Distribution.html#method-Distribution-varcov'><code>rdecision::Distribution$varcov()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DiracDistribution-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Dirac Delta function distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiracDistribution$new(const)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>const</code></dt><dd><p>The value at which the distribution is centred.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>DiracDistribution</code> object.
</p>


<hr>
<a id="method-DiracDistribution-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Accessor function for the name of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiracDistribution$distribution()</pre></div>



<h5>Returns</h5>

<p>Distribution name as character string.
</p>


<hr>
<a id="method-DiracDistribution-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>Return the mode of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiracDistribution$mode()</pre></div>



<h5>Returns</h5>

<p>Numeric Value where the distribution is centered.
</p>


<hr>
<a id="method-DiracDistribution-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Return the expected value of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiracDistribution$mean()</pre></div>



<h5>Returns</h5>

<p>Expected value as a numeric value.
</p>


<hr>
<a id="method-DiracDistribution-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>Return the standard deviation of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiracDistribution$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-DiracDistribution-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Quantiles of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiracDistribution$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Numeric vector of probabilities, each in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For a Dirac Delta Function all quantiles are returned as the
value at which the distribution is centred.
</p>



<h5>Returns</h5>

<p>Vector of numeric values of the same length as <code>probs</code>.
</p>


<hr>
<a id="method-DiracDistribution-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Draw and hold a random sample from the model variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiracDistribution$sample(expected = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expected</code></dt><dd><p>If TRUE, sets the next value retrieved by a call to
<code>r()</code> to be the mean of the distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated distribution.
</p>


<hr>
<a id="method-DiracDistribution-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DiracDistribution$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='DirichletDistribution'>A parametrized Dirichlet distribution</h2><span id='topic+DirichletDistribution'></span>

<h3>Description</h3>

<p>An R6 class representing a multivariate Dirichlet distribution.
</p>


<h3>Details</h3>

<p>A multivariate Dirichlet distribution. See
<a href="https://en.wikipedia.org/wiki/Dirichlet_distribution">https://en.wikipedia.org/wiki/Dirichlet_distribution</a> for details.
Inherits from class <code>Distribution</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Distribution">rdecision::Distribution</a></code> -&gt; <code>DirichletDistribution</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DirichletDistribution-new"><code>DirichletDistribution$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DirichletDistribution-distribution"><code>DirichletDistribution$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-DirichletDistribution-mean"><code>DirichletDistribution$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-DirichletDistribution-mode"><code>DirichletDistribution$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-DirichletDistribution-quantile"><code>DirichletDistribution$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-DirichletDistribution-varcov"><code>DirichletDistribution$varcov()</code></a>
</p>
</li>
<li> <p><a href="#method-DirichletDistribution-sample"><code>DirichletDistribution$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-DirichletDistribution-clone"><code>DirichletDistribution$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="SD"><a href='../../rdecision/html/Distribution.html#method-Distribution-SD'><code>rdecision::Distribution$SD()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="order"><a href='../../rdecision/html/Distribution.html#method-Distribution-order'><code>rdecision::Distribution$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="r"><a href='../../rdecision/html/Distribution.html#method-Distribution-r'><code>rdecision::Distribution$r()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DirichletDistribution-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of class <code>DirichletDistribution</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>DirichletDistribution$new(alpha)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>Parameters of the distribution; a vector of <code>K</code> numeric
values each &gt; 0, with <code class="reqn">K &gt; 1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>DirichletDistribution</code>.
</p>


<hr>
<a id="method-DirichletDistribution-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Accessor function for the name of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DirichletDistribution$distribution()</pre></div>



<h5>Returns</h5>

<p>Distribution name as character string.
</p>


<hr>
<a id="method-DirichletDistribution-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Mean value of each dimension of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DirichletDistribution$mean()</pre></div>



<h5>Returns</h5>

<p>A numerical vector of length K.
</p>


<hr>
<a id="method-DirichletDistribution-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>Return the mode of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DirichletDistribution$mode()</pre></div>



<h5>Details</h5>

<p>Undefined if any alpha is <code class="reqn">\le 1</code>.
</p>



<h5>Returns</h5>

<p>Mode as a vector of length <code>K</code>.
</p>


<hr>
<a id="method-DirichletDistribution-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Quantiles of the univariate marginal distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>DirichletDistribution$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Numeric vector of probabilities, each in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The univariate marginal distributions of a Dirichlet
distribution are Beta distributions. This function returns the
quantiles of each marginal. Note that these are not the true
quantiles of the multivariate Dirichlet.
</p>



<h5>Returns</h5>

<p>A matrix of numeric values with the number of rows equal to the
length of <code>probs</code>, the number of columns equal to the order; rows
are labelled with quantiles and columns with the dimension (1, 2, etc).
</p>


<hr>
<a id="method-DirichletDistribution-varcov"></a>



<h4>Method <code>varcov()</code></h4>

<p>Variance-covariance matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>DirichletDistribution$varcov()</pre></div>



<h5>Returns</h5>

<p>A positive definite symmetric matrix of size <code>K</code> by
<code>K</code>.
</p>


<hr>
<a id="method-DirichletDistribution-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Draw and hold a random sample from the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DirichletDistribution$sample(expected = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expected</code></dt><dd><p>If TRUE, sets the next value retrieved by a call to
<code>r()</code> to be the mean of the distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Void; sample is retrieved with call to <code>r()</code>.
</p>


<hr>
<a id="method-DirichletDistribution-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DirichletDistribution$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='Distribution'>A probability distribution</h2><span id='topic+Distribution'></span>

<h3>Description</h3>

<p>An R6 class representing a (possibly multivariate) distribution.
</p>


<h3>Details</h3>

<p>The base class for particular univariate or multivariate
distributions.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Distribution-new"><code>Distribution$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-order"><code>Distribution$order()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-distribution"><code>Distribution$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-mean"><code>Distribution$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-mode"><code>Distribution$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-SD"><code>Distribution$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-varcov"><code>Distribution$varcov()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-quantile"><code>Distribution$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-sample"><code>Distribution$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-r"><code>Distribution$r()</code></a>
</p>
</li>
<li> <p><a href="#method-Distribution-clone"><code>Distribution$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Distribution-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of class <code>Distribution</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$new(name, K = 1L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the distribution (&quot;Beta&quot; etc.)</p>
</dd>
<dt><code>K</code></dt><dd><p>Order of the distribution (1 = univariate, 2 = bivariate etc.).
Must be an integer; use 1L, 3L etc. to avoid an error.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>Distribution</code>.
</p>


<hr>
<a id="method-Distribution-order"></a>



<h4>Method <code>order()</code></h4>

<p>Order of the distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$order()</pre></div>



<h5>Returns</h5>

<p>Order (<code>K</code>).
</p>


<hr>
<a id="method-Distribution-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Description of the uncertainty distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$distribution()</pre></div>



<h5>Details</h5>

<p>Includes the distribution name and its parameters.
</p>



<h5>Returns</h5>

<p>Distribution name and parameters as character string.
</p>


<hr>
<a id="method-Distribution-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Mean value of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$mean()</pre></div>



<h5>Returns</h5>

<p>Mean value as a numeric scalar (<code>K = 1L</code>) or vector of
length <code>K</code>.
</p>


<hr>
<a id="method-Distribution-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>Return the mode of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$mode()</pre></div>



<h5>Details</h5>

<p>By default returns <code>NA</code>, which will be the case for most
because an arbitrary distribution is not guaranteed to be unimodal.
</p>



<h5>Returns</h5>

<p>Mode as a numeric scalar (<code>K = 1L</code>) or vector of
length <code>K</code>.
</p>


<hr>
<a id="method-Distribution-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>Return the standard deviation of a univariate distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$SD()</pre></div>



<h5>Details</h5>

<p>Only defined for univariate (<code>K = 1L</code>) distributions; for
multivariate distributions, function <code>varcov</code> returns the
variance-covariance matrix.
</p>



<h5>Returns</h5>

<p>Standard deviation as a numeric value.
</p>


<hr>
<a id="method-Distribution-varcov"></a>



<h4>Method <code>varcov()</code></h4>

<p>Variance-covariance matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$varcov()</pre></div>



<h5>Returns</h5>

<p>A positive definite symmetric matrix of size <code>K</code> by
<code>K</code>, or a scalar for <code>K = 1L</code>, equal to the variance.
</p>


<hr>
<a id="method-Distribution-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Marginal quantiles of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Numeric vector of probabilities, each in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If they are defined, this function returns the marginal
quantiles of the multivariate distribution; i.e. the quantiles of each
univariate marginal distribution of the multivariate distribution. For
example, the univariate marginal distributions of a multivariate
normal are univariate normals, and the univariate marginal distributions
of a Dirichlet distribution are Beta distributions. Note that these are
not the true quantiles of a multivariate distribution, which are contours
for <code>K = 2L</code>, surfaces for <code>K = 3L</code>, etc. For example, the
2.5% and 97.5% marginal quantiles of a bivariate normal distribution
define a rectangle in <code class="reqn">x_1, x_2</code> space that will include more than
95% of the distribution, whereas the contour containing 95% of the
distribution is an ellipse.
</p>



<h5>Returns</h5>

<p>For <code>K = 1L</code> a numeric vector of length equal to the length
of <code>probs</code>, with each entry labelled with the quantile. For
<code>K &gt; 1L</code> a matrix of numeric values with the number of rows equal
to the length of <code>probs</code>, the number of columns equal to the order;
rows are labelled with probabilities and columns with the dimension
(1, 2, etc).
</p>


<hr>
<a id="method-Distribution-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Draw and hold a random sample from the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$sample(expected = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expected</code></dt><dd><p>If TRUE, sets the next value retrieved by a call to
<code>r()</code> to be the mean of the distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Void
</p>


<hr>
<a id="method-Distribution-r"></a>



<h4>Method <code>r()</code></h4>

<p>Return a random sample drawn from the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$r()</pre></div>



<h5>Details</h5>

<p>Returns the sample generated at the last call to <code>sample</code>.
</p>



<h5>Returns</h5>

<p>A vector of length <code>K</code> representing one sample.
</p>


<hr>
<a id="method-Distribution-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Distribution$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='Edge'>An edge in a graph</h2><span id='topic+Edge'></span>

<h3>Description</h3>

<p>An R6 class representing an edge in a graph.
</p>


<h3>Details</h3>

<p>Edges are the formal term for links between pairs of nodes in a
graph. A base class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Edge-new"><code>Edge$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge-is_same_edge"><code>Edge$is_same_edge()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge-endpoints"><code>Edge$endpoints()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge-label"><code>Edge$label()</code></a>
</p>
</li>
<li> <p><a href="#method-Edge-clone"><code>Edge$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Edge-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of type <code>Edge</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge$new(v1, v2, label = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v1</code></dt><dd><p>Node at one endpoint of the edge.</p>
</dd>
<dt><code>v2</code></dt><dd><p>Node at the other endpoint of the edge.</p>
</dd>
<dt><code>label</code></dt><dd><p>Character string containing the edge label.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Edge</code> object.
</p>


<hr>
<a id="method-Edge-is_same_edge"></a>



<h4>Method <code>is_same_edge()</code></h4>

<p>Is this edge the same as the argument?
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge$is_same_edge(e)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>e</code></dt><dd><p>edge to compare with this one</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> if <code>e</code> is also this one.
</p>


<hr>
<a id="method-Edge-endpoints"></a>



<h4>Method <code>endpoints()</code></h4>

<p>Retrieve the endpoints of the edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge$endpoints()</pre></div>



<h5>Returns</h5>

<p>List of two nodes to which the edge is connected.
</p>


<hr>
<a id="method-Edge-label"></a>



<h4>Method <code>label()</code></h4>

<p>Access label.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge$label()</pre></div>



<h5>Returns</h5>

<p>Label of the edge; character string.
</p>


<hr>
<a id="method-Edge-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Edge$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='EmpiricalDistribution'>An empirical distribution</h2><span id='topic+EmpiricalDistribution'></span>

<h3>Description</h3>

<p>An R6 class representing an empirical (1D) distribution.
</p>


<h3>Details</h3>

<p>An object representing an empirical distribution. It inherits
from class <code>Distribution</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Distribution">rdecision::Distribution</a></code> -&gt; <code>EmpiricalDistribution</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EmpiricalDistribution-new"><code>EmpiricalDistribution$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EmpiricalDistribution-distribution"><code>EmpiricalDistribution$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-EmpiricalDistribution-mean"><code>EmpiricalDistribution$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-EmpiricalDistribution-mode"><code>EmpiricalDistribution$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-EmpiricalDistribution-SD"><code>EmpiricalDistribution$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-EmpiricalDistribution-sample"><code>EmpiricalDistribution$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-EmpiricalDistribution-quantile"><code>EmpiricalDistribution$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-EmpiricalDistribution-clone"><code>EmpiricalDistribution$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="order"><a href='../../rdecision/html/Distribution.html#method-Distribution-order'><code>rdecision::Distribution$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="r"><a href='../../rdecision/html/Distribution.html#method-Distribution-r'><code>rdecision::Distribution$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="varcov"><a href='../../rdecision/html/Distribution.html#method-Distribution-varcov'><code>rdecision::Distribution$varcov()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-EmpiricalDistribution-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of class <code>EmpiricalDistribution</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>EmpiricalDistribution$new(x, interpolate.sample = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>a sample of at least 1 numerical value from the population
of interest.</p>
</dd>
<dt><code>interpolate.sample</code></dt><dd><p>Logical; if true, each call to <code>sample()</code>
make a random draw from <code class="reqn">U_{0,1}</code> to find a <code class="reqn">p</code> value, then
finds that quantile of the sample, using the <code>quantile</code> function
in R, via interpolation from the eCDF. If false, the <code>sample()</code>
function makes a random draw from <code>x</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Empirical distributions based on very small sample sizes are
supported, but not recommended.
</p>



<h5>Returns</h5>

<p>An object of class <code>EmpiricalDistribution</code>.
</p>


<hr>
<a id="method-EmpiricalDistribution-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Accessor function for the name of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>EmpiricalDistribution$distribution()</pre></div>



<h5>Returns</h5>

<p>Distribution name as character string.
</p>


<hr>
<a id="method-EmpiricalDistribution-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Return the expected value of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>EmpiricalDistribution$mean()</pre></div>



<h5>Returns</h5>

<p>Expected value as a numeric value.
</p>


<hr>
<a id="method-EmpiricalDistribution-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>Return the mode of the distribution,
</p>


<h5>Usage</h5>

<div class="r"><pre>EmpiricalDistribution$mode()</pre></div>



<h5>Returns</h5>

<p>NA because an empirical distribution is not guaranteed to be
unimodal.
</p>


<hr>
<a id="method-EmpiricalDistribution-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>Return the standard deviation of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>EmpiricalDistribution$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-EmpiricalDistribution-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Draw and hold a random sample from the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>EmpiricalDistribution$sample(expected = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expected</code></dt><dd><p>If TRUE, sets the next value retrieved by a call to
<code>r()</code> to be the mean of the distribution.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Samples with interpolation or by random draw from the
supplied distribution (see parameter <code>interpolate.sample</code> in
<code>new()</code>).
</p>



<h5>Returns</h5>

<p>Updated distribution.
</p>


<hr>
<a id="method-EmpiricalDistribution-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Return the quantiles of the empirical uncertainty distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>EmpiricalDistribution$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Vector of probabilities, in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of quantiles.
</p>


<hr>
<a id="method-EmpiricalDistribution-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>EmpiricalDistribution$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='ExprModVar'>A model variable constructed from an expression of other variables</h2><span id='topic+ExprModVar'></span>

<h3>Description</h3>

<p>An R6 class representing a model variable constructed from an
expression involving other variables.
</p>


<h3>Details</h3>

<p>A class to support expressions involving objects of base class
<code>ModVar</code>, which itself behaves like a model variable. For example, if
<code>A</code> and <code>B</code> are variables with base class <code>ModVar</code> and
<code>c</code> is a variable of type <code>numeric</code>, then it is not possible to
write, for example, <code>x &lt;- 42*A/B + c</code>, because R cannot manipulate class
variables using the same operators as regular variables. But such forms of
expression may be desirable in constructing a model and this class provides
a mechanism for doing so. Inherits from class <code>ModVar</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ModVar">rdecision::ModVar</a></code> -&gt; <code>ExprModVar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ExprModVar-new"><code>ExprModVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-add_method"><code>ExprModVar$add_method()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-is_probabilistic"><code>ExprModVar$is_probabilistic()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-operands"><code>ExprModVar$operands()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-distribution"><code>ExprModVar$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-mean"><code>ExprModVar$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-mode"><code>ExprModVar$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-SD"><code>ExprModVar$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-quantile"><code>ExprModVar$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-mu_hat"><code>ExprModVar$mu_hat()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-sigma_hat"><code>ExprModVar$sigma_hat()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-q_hat"><code>ExprModVar$q_hat()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-set"><code>ExprModVar$set()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-get"><code>ExprModVar$get()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-clone"><code>ExprModVar$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="description"><a href='../../rdecision/html/ModVar.html#method-ModVar-description'><code>rdecision::ModVar$description()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="is_expression"><a href='../../rdecision/html/ModVar.html#method-ModVar-is_expression'><code>rdecision::ModVar$is_expression()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="r"><a href='../../rdecision/html/ModVar.html#method-ModVar-r'><code>rdecision::ModVar$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="units"><a href='../../rdecision/html/ModVar.html#method-ModVar-units'><code>rdecision::ModVar$units()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ExprModVar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a <code>ModVar</code> formed from an expression involving
other model variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$new(description, units, quo, nemp = 1000L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt><dd><p>Name for the model variable expression. In
a complex model it may help to tabulate how model variables are
combined into costs, probabilities and rates.</p>
</dd>
<dt><code>units</code></dt><dd><p>Units in which the variable is expressed.</p>
</dd>
<dt><code>quo</code></dt><dd><p>A <code style="white-space: pre;">&#8288;quosure&#8288;</code> (see package <span class="pkg">rlang</span>), which contains an
expression and its environment. The usage is <code>quo(x+y)</code> or
<code>rlang::quo(x+y)</code>.</p>
</dd>
<dt><code>nemp</code></dt><dd><p>sample size of the empirical distribution which will be
associated with the expression, and used to estimate values for
<code>mu_hat</code>, <code>sigma_hat</code> and <code>q_hat</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of type <code>ExprModVar</code>
</p>


<hr>
<a id="method-ExprModVar-add_method"></a>



<h4>Method <code>add_method()</code></h4>

<p>Create a new <code style="white-space: pre;">&#8288;quosure&#8288;</code> from that supplied in
<code>new()</code> but with each <code>ModVar</code>
operand appended with <code>$x</code> where <code>x</code> is the argument to this
function.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$add_method(method = "mean()")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>A character string with the method, e.g. <code>"mean()"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method is mostly intended for internal use within the
class and will not generally be needed for normal use of
<code>ExprModVar</code> objects. The returned expression is <em>not</em>
syntactically checked or evaluated before it is returned.
</p>



<h5>Returns</h5>

<p>A <dfn>quosure</dfn> whose expression is each <code>ModVar</code> <code>v</code>
in the
expression replaced with <code>v$method</code> and the same environment as
specified in the quosure supplied in new().
</p>


<hr>
<a id="method-ExprModVar-is_probabilistic"></a>



<h4>Method <code>is_probabilistic()</code></h4>

<p>Tests whether the model variable is probabilistic, i.e.
a random variable that follows a distribution, or an expression involving
random variables, at least one of which follows a distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$is_probabilistic()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if probabilistic
</p>


<hr>
<a id="method-ExprModVar-operands"></a>



<h4>Method <code>operands()</code></h4>

<p>Return a list of operands.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$operands(recursive = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recursive</code></dt><dd><p>Whether to include nested variables in the list.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Finds operands that are themselves <code>ModVar</code>s in the
expression. if <code>recursive=TRUE</code>, the list includes all
<code>ModVar</code>s that are operands of expression operands, recursively.
</p>



<h5>Returns</h5>

<p>A list of model variables.
</p>


<hr>
<a id="method-ExprModVar-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Accessor function for the name of the expression model
variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$distribution()</pre></div>



<h5>Returns</h5>

<p>Expression as a character string with all control characters
having been removed.
</p>


<hr>
<a id="method-ExprModVar-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Return the value of the expression when its operands take
their mean value (i.e. value returned by call to <code>mean</code> or their
value, if numeric). See notes on this class for further explanation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$mean()</pre></div>



<h5>Returns</h5>

<p>Mean value as a numeric value.
</p>


<hr>
<a id="method-ExprModVar-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>Return the mode of the variable. By default returns
<code>NA</code>, which will be the case for most <code>ExprModVar</code> variables,
because an arbitrary expression is not guaranteed to be unimodal.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$mode()</pre></div>



<h5>Returns</h5>

<p>Mode as a numeric value.
</p>


<hr>
<a id="method-ExprModVar-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>Return the standard deviation of the distribution as
<code>NA</code> because the variance is not available as a closed form for
all functions of distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-ExprModVar-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Find quantiles of the uncertainty distribution. Not
available as a closed form, and returned as <code>NA</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Numeric vector of probabilities, each in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of numeric values of the same length as <code>probs</code>.
</p>


<hr>
<a id="method-ExprModVar-mu_hat"></a>



<h4>Method <code>mu_hat()</code></h4>

<p>Return the estimated expected value of the variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$mu_hat()</pre></div>



<h5>Details</h5>

<p>This is computed by numerical simulation because there is, in
general, no closed form expressions for the mean of a function of
distributions. It is derived from the empirical distribution associated
with the object.
</p>



<h5>Returns</h5>

<p>Expected value as a numeric value.
</p>


<hr>
<a id="method-ExprModVar-sigma_hat"></a>



<h4>Method <code>sigma_hat()</code></h4>

<p>Return the estimated standard deviation of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$sigma_hat()</pre></div>



<h5>Details</h5>

<p>This is computed by numerical simulation because there is, in
general, no closed form expressions for the SD of a function of
distributions. It is derived from the empirical distribution associated
with the object.
</p>



<h5>Returns</h5>

<p>Standard deviation as a numeric value.
</p>


<hr>
<a id="method-ExprModVar-q_hat"></a>



<h4>Method <code>q_hat()</code></h4>

<p>Return the estimated quantiles by sampling the variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$q_hat(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Vector of probabilities, in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This is computed by numerical simulation because there is, in
general, no closed form expressions for the quantiles of a function of
distributions. The quantiles are derived from the empirical distribution
associated with the object.
</p>



<h5>Returns</h5>

<p>Vector of quantiles.
</p>


<hr>
<a id="method-ExprModVar-set"></a>



<h4>Method <code>set()</code></h4>

<p>Sets the value of the <code>ExprModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$set(what = "random", val = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt><dd><p>Until <code>set</code> is called again, subsequent calls to
<code>get</code> will return a value determined by the <code>what</code> parameter.
as follows:
</p>

<dl>
<dt><code>"random"</code></dt><dd><p>a random sample is derived by taking a random
sample from each of the operands and evaluating the expression. It
does not draw from the empirical distribution because of the possibility
of nested autocorrelation. For example, if <code class="reqn">z=xy</code>, where <code class="reqn">x</code> is a
model variable and <code class="reqn">y</code> is an expression which involves <code class="reqn">x</code>, then
<code class="reqn">y</code> and <code class="reqn">x</code> are correlated and will produce a different
distribution for <code class="reqn">z</code> than if <code class="reqn">x</code> and <code class="reqn">y</code> were independent.
However, if <code class="reqn">z</code> was sampled from the empirical distribution of
<code class="reqn">y</code> and the uncertainty distribution of <code class="reqn">x</code> independently, the
effect of correlation would be lost;</p>
</dd>
<dt><code>"expected"</code></dt><dd><p>the value of the expression when each of its
operands takes its expected value. This will not - in general - be the
mean of the uncertainty distribution for the expression which can be
estimated by calling <code>mu_hat</code>;</p>
</dd>
<dt><code>"q2.5"</code></dt><dd><p>the value of the expression when each of its
operands is equal to the 2.5th centile of their own uncertainty
distribution. In general, this will be a more extreme value than the
2.5th centile of the uncertainty distribution of the expression, which
can be found by using <code>q_hat(p=0.025)</code>;</p>
</dd>
<dt><code>"q50"</code></dt><dd><p>as per <code>"q2.5"</code> but for the 50th
centile (median);</p>
</dd>
<dt><code>"q97.5"</code></dt><dd><p>as per <code>"q2.5"</code> but for the 97.5th
centile;</p>
</dd>
<dt><code>"current"</code></dt><dd><p>leaves the <code>what</code> parameter of method
<code>set</code> unchanged <em>for each operand</em> and causes the expression
to be re-evaluated at subsequent calls to <code>get</code>. Thus, after calling
<code>set(what="current")</code> for the expression, subsequent calls to
<code>get</code> for the expression may not return the same value, if method
<code>set</code> has been called for one or more operands in the meantime;</p>
</dd>
<dt><code>"value"</code></dt><dd><p>sets the value of the expression to be equal to
parameter <code>val</code>. This is not recommended for normal usage because it
allows the model variable to be set to an implausible value, based on its
defined uncertainty. An example of where this may be needed is in
threshold finding.</p>
</dd>
</dl>
</dd>
<dt><code>val</code></dt><dd><p>A numeric value, only used with <code>what</code>=<code>"value"</code>,
ignored otherwise.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The available options for parameter <code>what</code> are identical to
those available for the <code>set</code> method of <code>ModVar</code>. However,
because an <code>ExprModVar</code> represents the left hand side of an
expression involving operands, the effect of some options is different
from its effect on a non-expression <code>ModVar</code>.
</p>



<h5>Returns</h5>

<p>Updated <code>ExprModVar</code>.
</p>


<hr>
<a id="method-ExprModVar-get"></a>



<h4>Method <code>get()</code></h4>

<p>Gets the value of the <code>ExprModVar</code> that was set by the most recent
call to <code>set()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$get()</pre></div>



<h5>Returns</h5>

<p>Value determined by last <code>set()</code>.
</p>


<hr>
<a id="method-ExprModVar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>For many expressions involving model variables there will
be no closed form expressions for the mean, standard deviation and
the quantiles. When an <code>ExprModVar</code> is created, an empirical
distribution is generated by repeatedly drawing a random sample from each
operand and evaluating the expression. The empirical distribution, which
becomes associated with the object, is used to provide estimates of the
mean, standard deviation and the quantiles via functions <code>mu_hat</code>,
<code>sigma_hat</code> and <code>q_hat</code>.
</p>
<p>For consistency with <code>ModVar</code>s which are not expressions, the
function <code>mean</code> returns the value of the expression when all
its operands take their mean values. This will, in general, not
be the mean of the expression distribution (which can be obtained
via <code>mu_hat</code>), but is the value normally used in the base
case of a model as the point estimate. As Briggs <em>et al</em> note
(section 4.1.1) &quot;in all but the most non-linear models, the
difference between the expectation over the output of a
probabilistic model and that model evaluated at the mean values
of the input parameters, is likely to be modest.&quot;
</p>
<p>Functions <code>SD</code>, <code>mode</code> and <code>quantile</code> return <code>NA</code>
because they do not necessarily have a closed form. The standard
deviation can be estimated by calling <code>sigma_hat</code> and the
quantiles by <code>q_hat</code>. Because a unimodal distribution is not
guaranteed, there is no estimator provided for the mode.
</p>
<p>Method <code>distribution</code> returns the string representation
of the expression used to create the model variable.
</p>


<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K, Sculpher M. Decision modelling for health
economic evaluation. Oxford, UK: Oxford University Press; 2006.

</p>

<hr>
<h2 id='GammaDistribution'>A parametrized Gamma distribution</h2><span id='topic+GammaDistribution'></span>

<h3>Description</h3>

<p>An R6 class representing a Gamma distribution.
</p>


<h3>Details</h3>

<p>An object representing a Gamma distribution with hyperparameters
shape (<code>k</code>) and scale (<code>theta</code>). In econometrics this
parametrization is more common but in Bayesian statistics the shape
(<code>alpha</code>) and rate (<code>beta</code>) parametrization is more usual. Note,
however, that although Briggs <em>et al</em> (2006) use the shape, scale
formulation, they use <code>alpha</code>, <code>beta</code> as parameter names. Inherits
from class <code>Distribution</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Distribution">rdecision::Distribution</a></code> -&gt; <code>GammaDistribution</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GammaDistribution-new"><code>GammaDistribution$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaDistribution-distribution"><code>GammaDistribution$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaDistribution-mean"><code>GammaDistribution$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaDistribution-mode"><code>GammaDistribution$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaDistribution-SD"><code>GammaDistribution$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaDistribution-sample"><code>GammaDistribution$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaDistribution-quantile"><code>GammaDistribution$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaDistribution-clone"><code>GammaDistribution$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="order"><a href='../../rdecision/html/Distribution.html#method-Distribution-order'><code>rdecision::Distribution$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="r"><a href='../../rdecision/html/Distribution.html#method-Distribution-r'><code>rdecision::Distribution$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="varcov"><a href='../../rdecision/html/Distribution.html#method-Distribution-varcov'><code>rdecision::Distribution$varcov()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GammaDistribution-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of class <code>GammaDistribution</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaDistribution$new(shape, scale)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>shape</code></dt><dd><p>shape parameter of the Gamma distribution.</p>
</dd>
<dt><code>scale</code></dt><dd><p>scale parameter of the Gamma distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>GammaDistribution</code>.
</p>


<hr>
<a id="method-GammaDistribution-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Accessor function for the name of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaDistribution$distribution()</pre></div>



<h5>Returns</h5>

<p>Distribution name as character string.
</p>


<hr>
<a id="method-GammaDistribution-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Return the expected value of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaDistribution$mean()</pre></div>



<h5>Returns</h5>

<p>Expected value as a numeric value.
</p>


<hr>
<a id="method-GammaDistribution-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>Return the mode of the distribution (if <code>shape</code> &gt;= 1)
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaDistribution$mode()</pre></div>



<h5>Returns</h5>

<p>mode as a numeric value.
</p>


<hr>
<a id="method-GammaDistribution-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>Return the standard deviation of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaDistribution$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-GammaDistribution-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Draw and hold a random sample from the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaDistribution$sample(expected = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expected</code></dt><dd><p>If TRUE, sets the next value retrieved by a call to
<code>r()</code> to be the mean of the distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated distribution.
</p>


<hr>
<a id="method-GammaDistribution-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Return the quantiles of the Gamma uncertainty distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaDistribution$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Vector of probabilities, in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of quantiles.
</p>


<hr>
<a id="method-GammaDistribution-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaDistribution$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K, Sculpher M. Decision modelling for health
economic evaluation. Oxford, UK: Oxford University Press; 2006.

</p>

<hr>
<h2 id='GammaModVar'>A model variable whose uncertainty follows a Gamma distribution</h2><span id='topic+GammaModVar'></span>

<h3>Description</h3>

<p>An R6 class for a model variable with Gamma uncertainty.
</p>


<h3>Details</h3>

<p>A model variable for which the uncertainty in the point estimate can
be modelled with a Gamma distribution. The hyperparameters of the
distribution are the shape (<code>k</code>) and the scale (<code>theta</code>). Note
that although Briggs <em>et al</em> (2006) use the shape, scale formulation,
they use <code>alpha</code>, <code>beta</code> as parameter names. Inherits from
class <code>ModVar</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ModVar">rdecision::ModVar</a></code> -&gt; <code>GammaModVar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GammaModVar-new"><code>GammaModVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaModVar-is_probabilistic"><code>GammaModVar$is_probabilistic()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaModVar-clone"><code>GammaModVar$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="SD"><a href='../../rdecision/html/ModVar.html#method-ModVar-SD'><code>rdecision::ModVar$SD()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="description"><a href='../../rdecision/html/ModVar.html#method-ModVar-description'><code>rdecision::ModVar$description()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="distribution"><a href='../../rdecision/html/ModVar.html#method-ModVar-distribution'><code>rdecision::ModVar$distribution()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="get"><a href='../../rdecision/html/ModVar.html#method-ModVar-get'><code>rdecision::ModVar$get()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="is_expression"><a href='../../rdecision/html/ModVar.html#method-ModVar-is_expression'><code>rdecision::ModVar$is_expression()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mean"><a href='../../rdecision/html/ModVar.html#method-ModVar-mean'><code>rdecision::ModVar$mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mode"><a href='../../rdecision/html/ModVar.html#method-ModVar-mode'><code>rdecision::ModVar$mode()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="quantile"><a href='../../rdecision/html/ModVar.html#method-ModVar-quantile'><code>rdecision::ModVar$quantile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="r"><a href='../../rdecision/html/ModVar.html#method-ModVar-r'><code>rdecision::ModVar$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="set"><a href='../../rdecision/html/ModVar.html#method-ModVar-set'><code>rdecision::ModVar$set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="units"><a href='../../rdecision/html/ModVar.html#method-ModVar-units'><code>rdecision::ModVar$units()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GammaModVar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of class <code>GammaModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaModVar$new(description, units, shape, scale)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt><dd><p>A character string describing the variable.</p>
</dd>
<dt><code>units</code></dt><dd><p>Units of the variable, as character string.</p>
</dd>
<dt><code>shape</code></dt><dd><p>shape parameter of the Gamma distribution.</p>
</dd>
<dt><code>scale</code></dt><dd><p>scale parameter of the Gamma distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>GammaModVar</code>.
</p>


<hr>
<a id="method-GammaModVar-is_probabilistic"></a>



<h4>Method <code>is_probabilistic()</code></h4>

<p>Tests whether the model variable is probabilistic, i.e.,
a random variable that follows a distribution, or an expression
involving random variables, some of which follow distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaModVar$is_probabilistic()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if probabilistic
</p>


<hr>
<a id="method-GammaModVar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaModVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>The Gamma model variable class can be used to model the uncertainty of
the mean of a count quantity which follows a Poisson distribution. The Gamma
distribution is the conjugate prior of a Poisson distribution, and the shape
and scale relate directly to the number of intervals from which the mean
count has been estimated. Specifically, the shape (<code class="reqn">k</code>) is equal to the
total count of events in <code class="reqn">1/\theta</code> intervals, where <code class="reqn">\theta</code> is the
scale. For example, if 200 counts were observed in a sample of 100 intervals,
setting <code>shape=200</code> and <code>scale=1/100</code> gives a Gamma distribution
with a mean of 2 and a 95% confidence interval from 1.73 to 2.29.
</p>


<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K, Sculpher M. Decision modelling for health
economic evaluation. Oxford, UK: Oxford University Press; 2006.

</p>

<hr>
<h2 id='Graph'>An undirected graph</h2><span id='topic+Graph'></span>

<h3>Description</h3>

<p>An R6 class to represent a graph (from discrete mathematics).
</p>


<h3>Details</h3>

<p>Encapsulates and provides methods for computation and checking of
undirected graphs. Graphs are systems of vertices connected in pairs by
edges. A base class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Graph-new"><code>Graph$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-order"><code>Graph$order()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-size"><code>Graph$size()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertexes"><code>Graph$vertexes()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertex_along"><code>Graph$vertex_along()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertex_index"><code>Graph$vertex_index()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertex_at"><code>Graph$vertex_at()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-has_vertex"><code>Graph$has_vertex()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertex_label"><code>Graph$vertex_label()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edges"><code>Graph$edges()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edge_along"><code>Graph$edge_along()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edge_index"><code>Graph$edge_index()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edge_at"><code>Graph$edge_at()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-has_edge"><code>Graph$has_edge()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edge_label"><code>Graph$edge_label()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-graph_adjacency_matrix"><code>Graph$graph_adjacency_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-is_simple"><code>Graph$is_simple()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-is_connected"><code>Graph$is_connected()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-is_acyclic"><code>Graph$is_acyclic()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-is_tree"><code>Graph$is_tree()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-degree"><code>Graph$degree()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-neighbours"><code>Graph$neighbours()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-as_DOT"><code>Graph$as_DOT()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-clone"><code>Graph$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Graph-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Graph</code> object from sets of nodes
and edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$new(V, E)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>V</code></dt><dd><p>An unordered set of Nodes, as a list.</p>
</dd>
<dt><code>E</code></dt><dd><p>An unordered set of Edges, as a list.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Graph</code> object.
</p>


<hr>
<a id="method-Graph-order"></a>



<h4>Method <code>order()</code></h4>

<p>Return the order of the graph (number of vertices).
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$order()</pre></div>



<h5>Returns</h5>

<p>Order of the graph (integer).
</p>


<hr>
<a id="method-Graph-size"></a>



<h4>Method <code>size()</code></h4>

<p>Return the size of the graph (number of edges).
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$size()</pre></div>



<h5>Returns</h5>

<p>Size of the graph (integer).
</p>


<hr>
<a id="method-Graph-vertexes"></a>



<h4>Method <code>vertexes()</code></h4>

<p>A list of all the Node objects in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertexes()</pre></div>



<h5>Details</h5>

<p>The list of Node objects is returned in the same order as their
indexes understood by <code>vertex_index</code>, <code>vertex_at</code> and
<code>vertex_along</code>, which is not necessarily the same order in which
they were supplied in the <code>V</code> argument to <code>new</code>.
</p>


<hr>
<a id="method-Graph-vertex_along"></a>



<h4>Method <code>vertex_along()</code></h4>

<p>Sequence of vertex indices.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertex_along()</pre></div>



<h5>Details</h5>

<p>Similar to <code>base::seq_along</code>, this function provides
the indices of the vertices in the graph. It is intended for use by
graph algorithms which iterate vertices.
</p>



<h5>Returns</h5>

<p>A numeric vector of indices from 1 to the order of the graph.
The vertex at index <code class="reqn">i</code> is not guaranteed to be the same vertex at
<code>V[[i]]</code> of the argument <code>V</code> to <code>new</code> (i.e., the order in
which the vertices are stored internally within the class may differ
from the order in which they were supplied).
</p>


<hr>
<a id="method-Graph-vertex_index"></a>



<h4>Method <code>vertex_index()</code></h4>

<p>Find the index of a vertex in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertex_index(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>A vertex, or list of vertexes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Index of <var>v</var>. The index of vertex <code>v</code> is the one
used internally to the class object, which is not necessarily the same as
the order of vertices in the <code>V</code> argument of <code>new</code>. <code>NA</code>
if <var>v</var> is not a vertex, or is a vertex that is not in the graph.
</p>


<hr>
<a id="method-Graph-vertex_at"></a>



<h4>Method <code>vertex_at()</code></h4>

<p>Find the vertex at a given index.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertex_at(index, as_list = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>Index of vertex in the graph, as an integer, or vector of
integers.</p>
</dd>
<dt><code>as_list</code></dt><dd><p>Boolean. If TRUE the method returns list of Nodes,
even if the length of <code>index</code> is 1.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The inverse of function <code>vertex_index</code>. The function will
raise an abort signal if all the supplied indexes are not vertexes. The
function is vectorized, but for historical compatibility the return
object is a single <code>Node</code> if <code>index</code> is a scalar. The
return object can be guaranteed to be a list if <code>as_list</code> is set.
</p>



<h5>Returns</h5>

<p>Node at <code>index</code> if <code>index</code> is a scalar, a list of Nodes
at the values of <code>index</code> if <code>index</code> is a vector, or an empty
list if index is an empty array.
</p>


<hr>
<a id="method-Graph-has_vertex"></a>



<h4>Method <code>has_vertex()</code></h4>

<p>Test whether a vertex is an element of the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$has_vertex(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>Subject vertex.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>TRUE if v is an element of V(G).
</p>


<hr>
<a id="method-Graph-vertex_label"></a>



<h4>Method <code>vertex_label()</code></h4>

<p>Find label of vertexes at index i.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertex_label(iv)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iv</code></dt><dd><p>Index of vertex, or vector of indexes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Label(s) of vertex at index i
</p>


<hr>
<a id="method-Graph-edges"></a>



<h4>Method <code>edges()</code></h4>

<p>A list of all the Edge objects in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edges()</pre></div>



<h5>Details</h5>

<p>The list of Edge objects is returned in the same order as their
indexes understood by <code>edge_index</code>, <code>edge_at</code> and
<code>edge_along</code>, which is not necessarily the same order in which they
were supplied in the <code>E</code> argument to <code>new</code>.
</p>


<hr>
<a id="method-Graph-edge_along"></a>



<h4>Method <code>edge_along()</code></h4>

<p>Sequence of edge indices.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edge_along()</pre></div>



<h5>Details</h5>

<p>Similar to <code>base::seq_along</code>, this function provides
the indices of the edges in the graph. It is intended for use by
graph algorithms which iterate edges. It is equivalent to
<code>seq_along(g$edges())</code>, where <code>g</code> is a graph.
</p>



<h5>Returns</h5>

<p>A numeric vector of indices from 1 to the size of the graph.
The edge at index <code class="reqn">i</code> is not guaranteed to be the same edge at
<code>E[[i]]</code> of the argument <code>E</code> to <code>new</code> (i.e., the order in
which the edges are stored internally within the class may differ
from the order in which they were supplied).
</p>


<hr>
<a id="method-Graph-edge_index"></a>



<h4>Method <code>edge_index()</code></h4>

<p>Find the index of an edge in a graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edge_index(e)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>e</code></dt><dd><p>An edge object, or list of edge objects.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The index of edge <code>e</code> is the one used internally to the
class object, which is not necessarily the same as the
order of edges in the <code>E</code> argument of <code>new</code>.
</p>



<h5>Returns</h5>

<p>Index of <code>e</code>. <code>NA</code> if <var>e</var> is not an edge, or is an
edge that is not in the graph.
</p>


<hr>
<a id="method-Graph-edge_at"></a>



<h4>Method <code>edge_at()</code></h4>

<p>Find the edge at a given index.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edge_at(index, as_list = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>Index of edge in the graph, as an integer, vector of
integers, or list of integers.</p>
</dd>
<dt><code>as_list</code></dt><dd><p>Boolean. If TRUE the method returns list of Edges,
even if the length of <code>index</code> is 1.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The inverse of function <code>edge_index</code>. The function will
raise an abort signal if the supplied index is not an edge. The
function is vectorized, but for historical compatibility the return
object is a single <code>Edge</code> if <code>index</code> is a scalar. The
return object can be guaranteed to be a list if <code>as_list</code> is set.
</p>



<h5>Returns</h5>

<p>The edge, or list of edges, with the specified index.
</p>


<hr>
<a id="method-Graph-has_edge"></a>



<h4>Method <code>has_edge()</code></h4>

<p>Test whether an edge is an element of the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$has_edge(e)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>e</code></dt><dd><p>Edge or list of edges.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with each element <code>TRUE</code> if the corresponding
element of <code>e</code> is an element of <code class="reqn">E(G)</code>.
</p>


<hr>
<a id="method-Graph-edge_label"></a>



<h4>Method <code>edge_label()</code></h4>

<p>Find label of edge at index i
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edge_label(ie)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ie</code></dt><dd><p>Index of edge, or vector of indexes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Label of edge at index i, or character vector with the labels at
indexes <code>ie</code>.
</p>


<hr>
<a id="method-Graph-graph_adjacency_matrix"></a>



<h4>Method <code>graph_adjacency_matrix()</code></h4>

<p>Compute the adjacency matrix for the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$graph_adjacency_matrix(boolean = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>boolean</code></dt><dd><p>If <code>TRUE</code>, the adjacency matrix is logical, each
cell is {<code>FALSE</code>, <code>TRUE</code>}.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Each cell contains the
number of edges joining the two vertexes, with the convention of
self loops being counted twice, unless <code>binary</code> is <code>TRUE</code> when
cells are either 0 (not adjacent) or 1 (adjacent).
</p>



<h5>Returns</h5>

<p>A square integer matrix with the number of rows and columns
equal to the order of the graph. The rows and columns are labelled
with the node labels, if all the nodes in the graph have unique labels,
or the node indices if not.
</p>


<hr>
<a id="method-Graph-is_simple"></a>



<h4>Method <code>is_simple()</code></h4>

<p>Is this a simple graph?
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$is_simple()</pre></div>



<h5>Details</h5>

<p>A simple graph has no self loops or multi-edges.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if simple, <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Graph-is_connected"></a>



<h4>Method <code>is_connected()</code></h4>

<p>Test whether the graph is connected.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$is_connected()</pre></div>



<h5>Details</h5>

<p>Graphs with no vertices are considered unconnected; graphs with
1 vertex are considered connected. Otherwise a graph is connected if all
nodes can be reached from an arbitrary starting point. Uses a depth first
search.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if connected, <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Graph-is_acyclic"></a>



<h4>Method <code>is_acyclic()</code></h4>

<p>Checks for the presence of a cycle in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$is_acyclic()</pre></div>



<h5>Details</h5>

<p>Uses a depth-first search from each node to detect the
presence of back edges. A back edge is an edge from the current node
joining a previously detected (visited) node, that is not the parent
node of the current one.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if no cycles detected.
</p>


<hr>
<a id="method-Graph-is_tree"></a>



<h4>Method <code>is_tree()</code></h4>

<p>Compute whether the graph is connected and acyclic.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$is_tree()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the graph is a tree; <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Graph-degree"></a>



<h4>Method <code>degree()</code></h4>

<p>The degree of a vertex in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$degree(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>The subject node.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The number of incident edges.
</p>



<h5>Returns</h5>

<p>Degree of the vertex, integer.
</p>


<hr>
<a id="method-Graph-neighbours"></a>



<h4>Method <code>neighbours()</code></h4>

<p>Find the neighbours of a node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$neighbours(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt><dd><p>The subject node (scalar, not a list).</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A property of the graph, not the node. Does not include self,
even in the case of a loop to self.
</p>



<h5>Returns</h5>

<p>A list of nodes which are joined to the subject.
</p>


<hr>
<a id="method-Graph-as_DOT"></a>



<h4>Method <code>as_DOT()</code></h4>

<p>Export a representation of the graph in DOT format.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$as_DOT()</pre></div>



<h5>Details</h5>

<p>Writes the representation in the <code>graphviz</code> DOT language
(<a href="https://graphviz.org/doc/info/lang.html">https://graphviz.org/doc/info/lang.html</a>) for drawing with one
of the <code>graphviz</code> tools including <code>dot</code> (Gansner, 1993).
</p>



<h5>Returns</h5>

<p>A character vector. Intended for passing to <code>writeLines</code>
for saving as a text file.
</p>


<hr>
<a id="method-Graph-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Gansner ER, Koutsofios E, North SC, Vo K-P. A technique for drawing
directed graphs. <em>IEEE Transactions on Software Engineering</em>,
1993;<b>19</b>:21430, <a href="https://doi.org/10.1109/32.221135">doi:10.1109/32.221135</a>.
</p>
<p>Gross JL, Yellen J, Zhang P. Handbook of Graph Theory. Second edition,
Chapman and Hall/CRC.; 2013, <a href="https://doi.org/10.1201/b16132">doi:10.1201/b16132</a>

</p>

<hr>
<h2 id='LeafNode'>A leaf node in a decision tree</h2><span id='topic+LeafNode'></span>

<h3>Description</h3>

<p>An R6 class representing a leaf (terminal) node in a decision
tree.
</p>


<h3>Details</h3>

<p>Represents a terminal state in a tree, and is associated with an
incremental utility. Inherits from class <code>Node</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Node">rdecision::Node</a></code> -&gt; <code>LeafNode</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LeafNode-new"><code>LeafNode$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LeafNode-modvars"><code>LeafNode$modvars()</code></a>
</p>
</li>
<li> <p><a href="#method-LeafNode-set_utility"><code>LeafNode$set_utility()</code></a>
</p>
</li>
<li> <p><a href="#method-LeafNode-utility"><code>LeafNode$utility()</code></a>
</p>
</li>
<li> <p><a href="#method-LeafNode-interval"><code>LeafNode$interval()</code></a>
</p>
</li>
<li> <p><a href="#method-LeafNode-QALY"><code>LeafNode$QALY()</code></a>
</p>
</li>
<li> <p><a href="#method-LeafNode-clone"><code>LeafNode$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Node" data-id="label"><a href='../../rdecision/html/Node.html#method-Node-label'><code>rdecision::Node$label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Node" data-id="type"><a href='../../rdecision/html/Node.html#method-Node-type'><code>rdecision::Node$type()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LeafNode-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>LeafNode</code> object; synonymous with a clinical outcome.
</p>


<h5>Usage</h5>

<div class="r"><pre>LeafNode$new(
  label,
  utility = 1,
  interval = as.difftime(365.25, units = "days")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>label</code></dt><dd><p>Character string; a label for the state; must be
defined because it is used in tabulations. The label is automatically
converted to a syntactically valid (in R) name to ensure it can be used
as a column name in a data frame.</p>
</dd>
<dt><code>utility</code></dt><dd><p>The incremental utility that a user associates with
being in the health state for the interval.
Intended for use with cost benefit analysis. Can be <code>numeric</code> or
a type of <code>ModVar</code>. If the type is <code>numeric</code>, the allowed
range is <code>-Inf</code> to 1; if it is of type <code>ModVar</code>, it is
unchecked.</p>
</dd>
<dt><code>interval</code></dt><dd><p>The time interval over which the <code>utility</code>
parameter applies, expressed as an R <code>difftime</code> object; default
1 year.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>LeafNode</code> object
</p>


<hr>
<a id="method-LeafNode-modvars"></a>



<h4>Method <code>modvars()</code></h4>

<p>Find all the model variables of type <code>ModVar</code> that have
been specified as values associated with this <code>LeafNode</code>. Includes
operands of these <code>ModVar</code>s, if they are expressions.
</p>


<h5>Usage</h5>

<div class="r"><pre>LeafNode$modvars()</pre></div>



<h5>Returns</h5>

<p>A list of <code>ModVar</code>s.
</p>


<hr>
<a id="method-LeafNode-set_utility"></a>



<h4>Method <code>set_utility()</code></h4>

<p>Set the incremental utility associated with the node.
</p>


<h5>Usage</h5>

<div class="r"><pre>LeafNode$set_utility(utility)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>utility</code></dt><dd><p>The incremental utility that a user associates with
being in the health state for the interval.
Intended for use with cost benefit analysis. Can be <code>numeric</code> or
a type of <code>ModVar</code>. If the type is <code>numeric</code>, the allowed
range is <code>-Inf</code> to 1; if it is of type <code>ModVar</code>, it is
unchecked.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>Leaf</code> object.
</p>


<hr>
<a id="method-LeafNode-utility"></a>



<h4>Method <code>utility()</code></h4>

<p>Return the incremental utility associated with being in the
state for the interval.
</p>


<h5>Usage</h5>

<div class="r"><pre>LeafNode$utility()</pre></div>



<h5>Returns</h5>

<p>Incremental utility (numeric value).
</p>


<hr>
<a id="method-LeafNode-interval"></a>



<h4>Method <code>interval()</code></h4>

<p>Return the interval associated with being in the state.
</p>


<h5>Usage</h5>

<div class="r"><pre>LeafNode$interval()</pre></div>



<h5>Returns</h5>

<p>Interval (as a <code>difftime</code>).
</p>


<hr>
<a id="method-LeafNode-QALY"></a>



<h4>Method <code>QALY()</code></h4>

<p>Return the quality adjusted life years associated with
being in the state.
</p>


<h5>Usage</h5>

<div class="r"><pre>LeafNode$QALY()</pre></div>



<h5>Returns</h5>

<p><abbr><span class="acronym">QALY</span></abbr>.
</p>


<hr>
<a id="method-LeafNode-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LeafNode$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='LogNormDistribution'>A parametrized log Normal probability distribution</h2><span id='topic+LogNormDistribution'></span>

<h3>Description</h3>

<p>An R6 class representing a log Normal distribution.
</p>


<h3>Details</h3>

<p>A parametrized Log Normal distribution inheriting from class
<code>Distribution</code>. Swat (2017) defined seven parametrizations of the log
normal distribution.
These are linked, allowing the parameters of any one to be derived from any
other. All 7 parametrizations require two parameters as follows:
</p>

<dl>
<dt>LN1</dt><dd><p><code class="reqn">p_1=\mu</code>, <code class="reqn">p_2=\sigma</code>, where <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>
are the mean and standard deviation, both on the log scale.</p>
</dd>
<dt>LN2</dt><dd><p><code class="reqn">p_1=\mu</code>, <code class="reqn">p_2=v</code>, where <code class="reqn">\mu</code> and <code class="reqn">v</code> are the
mean and variance, both on the log scale.</p>
</dd>
<dt>LN3</dt><dd><p><code class="reqn">p_1=m</code>, <code class="reqn">p_2=\sigma</code>, where <code class="reqn">m</code> is the median on the
natural scale and <code class="reqn">\sigma</code> is the standard deviation on the log scale.</p>
</dd>
<dt>LN4</dt><dd><p><code class="reqn">p_1=m</code>, <code class="reqn">p_2=c_v</code>, where <code class="reqn">m</code> is the median on the
natural scale and <code class="reqn">c_v</code> is the coefficient of variation on the natural
scale.</p>
</dd>
<dt>LN5</dt><dd><p><code class="reqn">p_1=\mu</code>, <code class="reqn">p_2=\tau</code>, where <code class="reqn">\mu</code> is the mean on the
log scale and <code class="reqn">\tau</code> is the precision on the log scale.</p>
</dd>
<dt>LN6</dt><dd><p><code class="reqn">p_1=m</code>, <code class="reqn">p_2=\sigma_g</code>, where <code class="reqn">m</code> is the median on
the natural scale and <code class="reqn">\sigma_g</code> is the geometric standard deviation on
the natural scale.</p>
</dd>
<dt>LN7</dt><dd><p><code class="reqn">p_1=\mu_N</code>, <code class="reqn">p_2=\sigma_N</code>, where <code class="reqn">\mu_N</code> is the mean
on the natural scale and <code class="reqn">\sigma_N</code> is the standard deviation on the
natural scale.</p>
</dd>
</dl>



<h3>Super class</h3>

<p><code><a href="#topic+Distribution">rdecision::Distribution</a></code> -&gt; <code>LogNormDistribution</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LogNormDistribution-new"><code>LogNormDistribution$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormDistribution-distribution"><code>LogNormDistribution$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormDistribution-sample"><code>LogNormDistribution$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormDistribution-mean"><code>LogNormDistribution$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormDistribution-mode"><code>LogNormDistribution$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormDistribution-SD"><code>LogNormDistribution$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormDistribution-quantile"><code>LogNormDistribution$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormDistribution-clone"><code>LogNormDistribution$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="order"><a href='../../rdecision/html/Distribution.html#method-Distribution-order'><code>rdecision::Distribution$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="r"><a href='../../rdecision/html/Distribution.html#method-Distribution-r'><code>rdecision::Distribution$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="varcov"><a href='../../rdecision/html/Distribution.html#method-Distribution-varcov'><code>rdecision::Distribution$varcov()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LogNormDistribution-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a log normal distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormDistribution$new(p1, p2, parametrization = "LN1")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p1</code></dt><dd><p>First hyperparameter, a measure of location. See
<em>Details</em>.</p>
</dd>
<dt><code>p2</code></dt><dd><p>Second hyperparameter, a measure of spread. See <em>Details</em>.</p>
</dd>
<dt><code>parametrization</code></dt><dd><p>A character string taking one of the values
<code style="white-space: pre;">&#8288;"LN1"&#8288;</code> (default) through <code style="white-space: pre;">&#8288;"LN7"&#8288;</code> (see <em>Details</em>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>LogNormDistribution</code> object.
</p>


<hr>
<a id="method-LogNormDistribution-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Accessor function for the name of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormDistribution$distribution()</pre></div>



<h5>Returns</h5>

<p>Distribution name as character string (<code style="white-space: pre;">&#8288;"LN1"&#8288;</code>, <code style="white-space: pre;">&#8288;"LN2"&#8288;</code>
etc.).
</p>


<hr>
<a id="method-LogNormDistribution-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Draw a random sample from the model variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormDistribution$sample(expected = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expected</code></dt><dd><p>If TRUE, sets the next value retrieved by a call to
<code>r()</code> to be the mean of the distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>LogNormDistribution</code> object.
</p>


<hr>
<a id="method-LogNormDistribution-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Return the expected value of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormDistribution$mean()</pre></div>



<h5>Returns</h5>

<p>Expected value as a numeric value.
</p>


<hr>
<a id="method-LogNormDistribution-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>Return the point estimate of the variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormDistribution$mode()</pre></div>



<h5>Returns</h5>

<p>Point estimate (mode) of the log normal distribution.
</p>


<hr>
<a id="method-LogNormDistribution-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>Return the standard deviation of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormDistribution$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-LogNormDistribution-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Return the quantiles of the log normal distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormDistribution$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Vector of probabilities, in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of quantiles.
</p>


<hr>
<a id="method-LogNormDistribution-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormDistribution$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>The log normal distribution may be used to model the uncertainty in
an estimate of relative risk (Briggs 2006, p90). If a relative risk
estimate is available with a 95% confidence interval, the <code style="white-space: pre;">&#8288;"LN7"&#8288;</code>
parametrization
allows the uncertainty distribution to be specified directly. For example,
if RR = 0.67 with 95% confidence interval 0.53 to 0.84 (Leaper, 2016), it
can be modelled with
<code>LogNormModVar$new("rr", "RR", p1=0.67,
p2=(0.84-0.53)/(2*1.96)), "LN7")</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K and Sculpher M. Decision Modelling for Health
Economic Evaluation. Oxford 2006, ISBN 978-0-19-852662-9.
</p>
<p>Leaper DJ, Edmiston CE and Holy CE. Meta-analysis of the potential
economic impact following introduction of absorbable antimicrobial
sutures. <em>British Journal of Surgery</em> 2017;<b>104</b>:e134-e144.
</p>
<p>Swat MJ, Grenon P and Wimalaratne S. Ontology and Knowledge Base of
Probability Distributions. <em>Bioinformatics</em> 2016;<b>32</b>:2719-2721,
<a href="https://doi.org/10.1093/bioinformatics/btw170">doi:10.1093/bioinformatics/btw170</a>.

</p>

<hr>
<h2 id='LogNormModVar'>A model variable whose uncertainty follows a log Normal distribution</h2><span id='topic+LogNormModVar'></span>

<h3>Description</h3>

<p>An R6 class representing a model variable with log Normal
uncertainty.
</p>


<h3>Details</h3>

<p>A model variable for which the uncertainty in the point estimate can
be modelled with a log Normal distribution. One of seven parametrizations
defined by Swat <em>et al</em> can be used. Inherits from <code>ModVar</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ModVar">rdecision::ModVar</a></code> -&gt; <code>LogNormModVar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LogNormModVar-new"><code>LogNormModVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormModVar-is_probabilistic"><code>LogNormModVar$is_probabilistic()</code></a>
</p>
</li>
<li> <p><a href="#method-LogNormModVar-clone"><code>LogNormModVar$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="SD"><a href='../../rdecision/html/ModVar.html#method-ModVar-SD'><code>rdecision::ModVar$SD()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="description"><a href='../../rdecision/html/ModVar.html#method-ModVar-description'><code>rdecision::ModVar$description()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="distribution"><a href='../../rdecision/html/ModVar.html#method-ModVar-distribution'><code>rdecision::ModVar$distribution()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="get"><a href='../../rdecision/html/ModVar.html#method-ModVar-get'><code>rdecision::ModVar$get()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="is_expression"><a href='../../rdecision/html/ModVar.html#method-ModVar-is_expression'><code>rdecision::ModVar$is_expression()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mean"><a href='../../rdecision/html/ModVar.html#method-ModVar-mean'><code>rdecision::ModVar$mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mode"><a href='../../rdecision/html/ModVar.html#method-ModVar-mode'><code>rdecision::ModVar$mode()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="quantile"><a href='../../rdecision/html/ModVar.html#method-ModVar-quantile'><code>rdecision::ModVar$quantile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="r"><a href='../../rdecision/html/ModVar.html#method-ModVar-r'><code>rdecision::ModVar$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="set"><a href='../../rdecision/html/ModVar.html#method-ModVar-set'><code>rdecision::ModVar$set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="units"><a href='../../rdecision/html/ModVar.html#method-ModVar-units'><code>rdecision::ModVar$units()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LogNormModVar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a model variable with log normal uncertainty.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormModVar$new(description, units, p1, p2, parametrization = "LN1")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt><dd><p>A character string describing the variable.</p>
</dd>
<dt><code>units</code></dt><dd><p>Units of the quantity; character string.</p>
</dd>
<dt><code>p1</code></dt><dd><p>First hyperparameter, a measure of location.
See <em>Details</em>.</p>
</dd>
<dt><code>p2</code></dt><dd><p>Second hyperparameter, a measure of spread.
See <em>Details</em>.</p>
</dd>
<dt><code>parametrization</code></dt><dd><p>A character string taking one of the values
<code style="white-space: pre;">&#8288;"LN1"&#8288;</code> (default) through <code style="white-space: pre;">&#8288;"LN7"&#8288;</code> (see <em>Details</em>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>LogNormModVar</code> object.
</p>


<hr>
<a id="method-LogNormModVar-is_probabilistic"></a>



<h4>Method <code>is_probabilistic()</code></h4>

<p>Tests whether the model variable is probabilistic, i.e., a
random variable that follows a distribution, or an expression involving
random variables, some of which follow distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormModVar$is_probabilistic()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if probabilistic
</p>


<hr>
<a id="method-LogNormModVar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LogNormModVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K and Sculpher M. Decision Modelling for Health
Economic Evaluation. Oxford 2006, ISBN 978-0-19-852662-9.
</p>
<p>Leaper DJ, Edmiston CE and Holy CE. Meta-analysis of the potential
economic impact following introduction of absorbable antimicrobial
sutures. <em>British Journal of Surgery</em> 2017;<b>104</b>:e134-e144.
</p>
<p>Swat MJ, Grenon P and Wimalaratne S. Ontology and Knowledge Base of
Probability Distributions. <em>Bioinformatics</em> 2016;<b>32</b>:2719-2721,
<a href="https://doi.org/10.1093/bioinformatics/btw170">doi:10.1093/bioinformatics/btw170</a>.

</p>


<h3>See Also</h3>

<p><code><a href="#topic+LogNormDistribution">LogNormDistribution</a></code>.
</p>

<hr>
<h2 id='MarkovState'>A state in a Markov model</h2><span id='topic+MarkovState'></span>

<h3>Description</h3>

<p>An R6 class representing a state in a Markov model.
</p>


<h3>Details</h3>

<p>Represents a single state in a Markov model. A Markov model is
a digraph in which states are nodes and transitions are arrows. Inherits
from class <code>Node</code>.
</p>


<h3>Value</h3>

<p>Updated <code>MarkovState</code> object
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Node">rdecision::Node</a></code> -&gt; <code>MarkovState</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MarkovState-new"><code>MarkovState$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovState-name"><code>MarkovState$name()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovState-set_cost"><code>MarkovState$set_cost()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovState-cost"><code>MarkovState$cost()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovState-utility"><code>MarkovState$utility()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovState-modvars"><code>MarkovState$modvars()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovState-clone"><code>MarkovState$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Node" data-id="label"><a href='../../rdecision/html/Node.html#method-Node-label'><code>rdecision::Node$label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Node" data-id="type"><a href='../../rdecision/html/Node.html#method-Node-type'><code>rdecision::Node$type()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MarkovState-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of type <code>MarkovState</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovState$new(name, cost = 0, utility = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the state (character string).</p>
</dd>
<dt><code>cost</code></dt><dd><p>The annual cost of state occupancy (numeric or
<code>ModVar</code>). Default 0.0.</p>
</dd>
<dt><code>utility</code></dt><dd><p>The utility associated with being in the state (numeric
or <code>ModVar</code>).</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Utility must be in the range <code>[-Inf,1]</code>. If it is of type
numeric, the range is checked on object creation.
</p>



<h5>Returns</h5>

<p>An object of type <code>MarkovState</code>.
</p>


<hr>
<a id="method-MarkovState-name"></a>



<h4>Method <code>name()</code></h4>

<p>Accessor function to retrieve the state name.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovState$name()</pre></div>



<h5>Returns</h5>

<p>State name.
</p>


<hr>
<a id="method-MarkovState-set_cost"></a>



<h4>Method <code>set_cost()</code></h4>

<p>Set the annual occupancy cost
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovState$set_cost(cost)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cost</code></dt><dd><p>The annual cost of state occupancy</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovState-cost"></a>



<h4>Method <code>cost()</code></h4>

<p>Gets the annual cost of state occupancy.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovState$cost()</pre></div>



<h5>Returns</h5>

<p>Annual cost; numeric.
</p>


<hr>
<a id="method-MarkovState-utility"></a>



<h4>Method <code>utility()</code></h4>

<p>Gets the utility associated with the state.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovState$utility()</pre></div>



<h5>Returns</h5>

<p>Utility; numeric.
</p>


<hr>
<a id="method-MarkovState-modvars"></a>



<h4>Method <code>modvars()</code></h4>

<p>Find all the model variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovState$modvars()</pre></div>



<h5>Details</h5>

<p>Find variables of type <code>ModVar</code> that have been
specified as values associated with this <code>MarkovState</code>.
Includes operands of these <code>ModVar</code>s, if they are expressions.
</p>



<h5>Returns</h5>

<p>A list of <code>ModVar</code>s.
</p>


<hr>
<a id="method-MarkovState-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovState$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='ModVar'>A model variable incorporating uncertainty</h2><span id='topic+ModVar'></span>

<h3>Description</h3>

<p>An R6 class for a variable in a health economic model.
</p>


<h3>Details</h3>

<p>Base class for a variable used in a health economic model. The base
class wraps a numerical value which is used in calculations.
It provides a framework for creating classes of model
variables whose uncertainties are described by statistical distributions
parametrized with hyperparameters.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ModVar-new"><code>ModVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-is_expression"><code>ModVar$is_expression()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-is_probabilistic"><code>ModVar$is_probabilistic()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-description"><code>ModVar$description()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-units"><code>ModVar$units()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-distribution"><code>ModVar$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-mean"><code>ModVar$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-mode"><code>ModVar$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-SD"><code>ModVar$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-quantile"><code>ModVar$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-r"><code>ModVar$r()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-set"><code>ModVar$set()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-get"><code>ModVar$get()</code></a>
</p>
</li>
<li> <p><a href="#method-ModVar-clone"><code>ModVar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ModVar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of type <code>ModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$new(description, units, D = NULL, k = 1L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt><dd><p>A character string description of the variable
and its role in the model. This description will be used in a
tabulation of the variables linked to a model.</p>
</dd>
<dt><code>units</code></dt><dd><p>A character string description of the units, e.g.
<code>"GBP"</code>, <code>"per year"</code>.</p>
</dd>
<dt><code>D</code></dt><dd><p>The distribution representing the uncertainty in the variable.
Should inherit from class <code>Distribution</code>, or NULL if none is
defined.</p>
</dd>
<dt><code>k</code></dt><dd><p>The index of the dimension of the multivariate distribution
that applies to this model variable.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A <code>ModVar</code> is associated with an uncertainty distribution
(a &quot;has-a&quot; relationship in object-oriented terminology). There can be a
1-1 mapping of <code>ModVar</code>s to <code>Distribution</code>s, or several
model variables can be linked to the same distribution in a
many-1 mapping, e.g. when each transition probability from a Markov state
is represented as a <code>ModVar</code> and each can be linked to the <code>k</code>
dimensions of a common multivariate Dirichlet distribution.
</p>



<h5>Returns</h5>

<p>A new <code style="white-space: pre;">&#8288;ModVar&#8288;</code> object.
</p>


<hr>
<a id="method-ModVar-is_expression"></a>



<h4>Method <code>is_expression()</code></h4>

<p>Is this <code>ModVar</code> an expression?
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$is_expression()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if it inherits from <code>ExprModVar</code>, <code>FALSE</code>
otherwise.
</p>


<hr>
<a id="method-ModVar-is_probabilistic"></a>



<h4>Method <code>is_probabilistic()</code></h4>

<p>Is the model variable probabilistic?
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$is_probabilistic()</pre></div>



<h5>Details</h5>

<p>Tests whether the model variable is probabilistic, i.e. a
random variable that follows a distribution, or an expression involving
random variables, some of which follow distributions.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if probabilistic
</p>


<hr>
<a id="method-ModVar-description"></a>



<h4>Method <code>description()</code></h4>

<p>Accessor function for the description.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$description()</pre></div>



<h5>Returns</h5>

<p>Description of model variable as character string.
</p>


<hr>
<a id="method-ModVar-units"></a>



<h4>Method <code>units()</code></h4>

<p>Accessor function for units.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$units()</pre></div>



<h5>Returns</h5>

<p>Description of units as character string.
</p>


<hr>
<a id="method-ModVar-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Name and parameters of the uncertainty distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$distribution()</pre></div>



<h5>Details</h5>

<p>If <code class="reqn">K &gt; 1</code> the dimension of the distribution associated
with this model variable is appended, e.g. <code>Dir(2,3)[1]</code>
means that the model variable is associated with the first dimension
of a 2D Dirichlet distribution with alpha parameters 2 and 3.
</p>



<h5>Returns</h5>

<p>Distribution name as character string.
</p>


<hr>
<a id="method-ModVar-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Mean value of the model variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$mean()</pre></div>



<h5>Returns</h5>

<p>Mean value as a numeric value.
</p>


<hr>
<a id="method-ModVar-mode"></a>



<h4>Method <code>mode()</code></h4>

<p>The mode of the variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$mode()</pre></div>



<h5>Details</h5>

<p>By default returns <code>NA</code>, which will be the case for
most <code>ModVar</code> variables, because arbitrary distributions are
not guaranteed to be unimodal.
</p>



<h5>Returns</h5>

<p>Mode as a numeric value.
</p>


<hr>
<a id="method-ModVar-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>Standard deviation of the model variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-ModVar-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Quantiles of the uncertainty distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Numeric vector of probabilities, each in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of numeric values of the same length as <code>probs</code>.
</p>


<hr>
<a id="method-ModVar-r"></a>



<h4>Method <code>r()</code></h4>

<p>Draw a random sample from the model variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$r()</pre></div>



<h5>Details</h5>

<p>The same random sample will be returned until <code>set</code> is
called to force a resample.
</p>



<h5>Returns</h5>

<p>A sample drawn at random.
</p>


<hr>
<a id="method-ModVar-set"></a>



<h4>Method <code>set()</code></h4>

<p>Sets the value of the <code>ModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$set(what = "random", val = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt><dd><p>Until <code>set</code> is called again, subsequent calls to
<code>get</code> will return a value determined by the <code>what</code> parameter
as follows:
</p>

<dl>
<dt><code>"random"</code></dt><dd><p>a random sample is drawn from the uncertainty
distribution;</p>
</dd>
<dt><code>"expected"</code></dt><dd><p>the mean of the uncertainty distribution;</p>
</dd>
<dt><code>"q2.5"</code></dt><dd><p>the lower 95% confidence limit of the uncertainty
distribution, i.e. the 2.5th percentile;</p>
</dd>
<dt><code>"q50"</code></dt><dd><p>the median of the uncertainty distribution;</p>
</dd>
<dt><code>"q97.5"</code></dt><dd><p>the upper 95% confidence limit of the uncertainty
distribution, i.e. the 97.5th percentile;</p>
</dd>
<dt><code>"current"</code></dt><dd><p>leaves the <code>what</code> parameter of method
<code>set</code> unchanged, i.e. the call to <code>set</code> has no effect on the
subsequent values returned by <code>get</code>. It is provided as an option to
help use cases in which the <code>what</code> parameter is a variable;</p>
</dd>
<dt><code>"value"</code></dt><dd><p>sets the value explicitly to be equal to parameter
<code>val</code>. This is not recommended for normal usage because it allows
the model variable to be set to an implausible value, based on its
defined uncertainty. An example of where this may be needed is in
threshold finding.</p>
</dd>
</dl>
</dd>
<dt><code>val</code></dt><dd><p>A numeric value, only used with <code>what</code>=<code>"value"</code>,
ignored otherwise.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>ModVar</code>.
</p>


<hr>
<a id="method-ModVar-get"></a>



<h4>Method <code>get()</code></h4>

<p>Get the value of the <code>ModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$get()</pre></div>



<h5>Details</h5>

<p>Returns the value defined by the most recent call
to <code>set()</code>.
</p>



<h5>Returns</h5>

<p>Value determined by last <code>set()</code>.
</p>


<hr>
<a id="method-ModVar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='Node'>A node in a graph</h2><span id='topic+Node'></span>

<h3>Description</h3>

<p>An R6 class representing a node in a graph.
</p>


<h3>Details</h3>

<p>A base class to represent a single node in a graph.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Node-new"><code>Node$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-label"><code>Node$label()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-type"><code>Node$type()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-clone"><code>Node$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Node-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new <code>Node</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$new(label = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>label</code></dt><dd><p>An optional label for the node.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Node</code> object.
</p>


<hr>
<a id="method-Node-label"></a>



<h4>Method <code>label()</code></h4>

<p>Return the label of the node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$label()</pre></div>



<h5>Returns</h5>

<p>Label as a character string.
</p>


<hr>
<a id="method-Node-type"></a>



<h4>Method <code>type()</code></h4>

<p>node type
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$type()</pre></div>



<h5>Returns</h5>

<p><code>Node</code> class, as character string.
</p>


<hr>
<a id="method-Node-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='NormalDistribution'>A parametrized Normal distribution</h2><span id='topic+NormalDistribution'></span>

<h3>Description</h3>

<p>An R6 class representing a parametrized Normal distribution.
</p>


<h3>Details</h3>

<p>A Normal distribution with hyperparameters mean (<code>mu</code>) and
standard deviation (<code>sd</code>). Inherits from class <code>Distribution</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Distribution">rdecision::Distribution</a></code> -&gt; <code>NormalDistribution</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NormalDistribution-new"><code>NormalDistribution$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalDistribution-distribution"><code>NormalDistribution$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalDistribution-sample"><code>NormalDistribution$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalDistribution-mean"><code>NormalDistribution$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalDistribution-SD"><code>NormalDistribution$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalDistribution-quantile"><code>NormalDistribution$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalDistribution-clone"><code>NormalDistribution$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="mode"><a href='../../rdecision/html/Distribution.html#method-Distribution-mode'><code>rdecision::Distribution$mode()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="order"><a href='../../rdecision/html/Distribution.html#method-Distribution-order'><code>rdecision::Distribution$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="r"><a href='../../rdecision/html/Distribution.html#method-Distribution-r'><code>rdecision::Distribution$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Distribution" data-id="varcov"><a href='../../rdecision/html/Distribution.html#method-Distribution-varcov'><code>rdecision::Distribution$varcov()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-NormalDistribution-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a parametrized normal distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalDistribution$new(mu, sigma)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mu</code></dt><dd><p>Mean of the Normal distribution.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Standard deviation of the Normal distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>NormalDistribution</code> object.
</p>


<hr>
<a id="method-NormalDistribution-distribution"></a>



<h4>Method <code>distribution()</code></h4>

<p>Accessor function for the name of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalDistribution$distribution()</pre></div>



<h5>Returns</h5>

<p>Distribution name as character string.
</p>


<hr>
<a id="method-NormalDistribution-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Draw a random sample from the model variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalDistribution$sample(expected = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expected</code></dt><dd><p>If TRUE, sets the next value retrieved by a call to
<code>r()</code> to be the mean of the distribution.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A sample drawn at random.
</p>


<hr>
<a id="method-NormalDistribution-mean"></a>



<h4>Method <code>mean()</code></h4>

<p>Return the mean value of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalDistribution$mean()</pre></div>



<h5>Returns</h5>

<p>Expected value as a numeric value.
</p>


<hr>
<a id="method-NormalDistribution-SD"></a>



<h4>Method <code>SD()</code></h4>

<p>Return the standard deviation of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalDistribution$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-NormalDistribution-quantile"></a>



<h4>Method <code>quantile()</code></h4>

<p>Return the quantiles of the Normal uncertainty distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalDistribution$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt><dd><p>Vector of probabilities, in range [0,1].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of quantiles.
</p>


<hr>
<a id="method-NormalDistribution-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalDistribution$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='NormModVar'>A model variable whose uncertainty follows a Normal distribution</h2><span id='topic+NormModVar'></span>

<h3>Description</h3>

<p>An R6 class representing a model variable with Normal
uncertainty.
</p>


<h3>Details</h3>

<p>A model variable for which the uncertainty in its point estimate can
be modelled with a Normal distribution. The hyperparameters of the
distribution are the mean (<code>mu</code>) and the standard deviation (<code>sd</code>)
of the uncertainty distribution. The value of <code>mu</code> is the expected value
of the variable. Inherits from class <code>ModVar</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ModVar">rdecision::ModVar</a></code> -&gt; <code>NormModVar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NormModVar-new"><code>NormModVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NormModVar-is_probabilistic"><code>NormModVar$is_probabilistic()</code></a>
</p>
</li>
<li> <p><a href="#method-NormModVar-clone"><code>NormModVar$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="SD"><a href='../../rdecision/html/ModVar.html#method-ModVar-SD'><code>rdecision::ModVar$SD()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="description"><a href='../../rdecision/html/ModVar.html#method-ModVar-description'><code>rdecision::ModVar$description()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="distribution"><a href='../../rdecision/html/ModVar.html#method-ModVar-distribution'><code>rdecision::ModVar$distribution()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="get"><a href='../../rdecision/html/ModVar.html#method-ModVar-get'><code>rdecision::ModVar$get()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="is_expression"><a href='../../rdecision/html/ModVar.html#method-ModVar-is_expression'><code>rdecision::ModVar$is_expression()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mean"><a href='../../rdecision/html/ModVar.html#method-ModVar-mean'><code>rdecision::ModVar$mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="mode"><a href='../../rdecision/html/ModVar.html#method-ModVar-mode'><code>rdecision::ModVar$mode()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="quantile"><a href='../../rdecision/html/ModVar.html#method-ModVar-quantile'><code>rdecision::ModVar$quantile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="r"><a href='../../rdecision/html/ModVar.html#method-ModVar-r'><code>rdecision::ModVar$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="set"><a href='../../rdecision/html/ModVar.html#method-ModVar-set'><code>rdecision::ModVar$set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="units"><a href='../../rdecision/html/ModVar.html#method-ModVar-units'><code>rdecision::ModVar$units()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-NormModVar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a model variable with normal uncertainty.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormModVar$new(description, units, mu, sigma)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt><dd><p>A character string describing the variable.</p>
</dd>
<dt><code>units</code></dt><dd><p>Units of the quantity; character string.</p>
</dd>
<dt><code>mu</code></dt><dd><p>Hyperparameter with mean of the Normal distribution for
the uncertainty of the variable.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Hyperparameter equal to the standard deviation of the
normal distribution for the uncertainty of the variable.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>NormModVar</code> object.
</p>


<hr>
<a id="method-NormModVar-is_probabilistic"></a>



<h4>Method <code>is_probabilistic()</code></h4>

<p>Tests whether the model variable is probabilistic.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormModVar$is_probabilistic()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if probabilistic.
</p>


<hr>
<a id="method-NormModVar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormModVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='Reaction'>A reaction (chance) edge in a decision tree</h2><span id='topic+Reaction'></span>

<h3>Description</h3>

<p>An R6 class representing a reaction (chance) edge in a decision
tree.
</p>


<h3>Details</h3>

<p>A specialism of class <code>Arrow</code> which is used in a decision tree
to represent edges whose source nodes are <code>ChanceNode</code>s.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Edge">rdecision::Edge</a></code> -&gt; <code><a href="#topic+Arrow">rdecision::Arrow</a></code> -&gt; <code>Reaction</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Reaction-new"><code>Reaction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Reaction-modvars"><code>Reaction$modvars()</code></a>
</p>
</li>
<li> <p><a href="#method-Reaction-set_probability"><code>Reaction$set_probability()</code></a>
</p>
</li>
<li> <p><a href="#method-Reaction-p"><code>Reaction$p()</code></a>
</p>
</li>
<li> <p><a href="#method-Reaction-set_cost"><code>Reaction$set_cost()</code></a>
</p>
</li>
<li> <p><a href="#method-Reaction-cost"><code>Reaction$cost()</code></a>
</p>
</li>
<li> <p><a href="#method-Reaction-set_benefit"><code>Reaction$set_benefit()</code></a>
</p>
</li>
<li> <p><a href="#method-Reaction-benefit"><code>Reaction$benefit()</code></a>
</p>
</li>
<li> <p><a href="#method-Reaction-clone"><code>Reaction$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="endpoints"><a href='../../rdecision/html/Edge.html#method-Edge-endpoints'><code>rdecision::Edge$endpoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="is_same_edge"><a href='../../rdecision/html/Edge.html#method-Edge-is_same_edge'><code>rdecision::Edge$is_same_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="label"><a href='../../rdecision/html/Edge.html#method-Edge-label'><code>rdecision::Edge$label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arrow" data-id="source"><a href='../../rdecision/html/Arrow.html#method-Arrow-source'><code>rdecision::Arrow$source()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arrow" data-id="target"><a href='../../rdecision/html/Arrow.html#method-Arrow-target'><code>rdecision::Arrow$target()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Reaction-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of type <code>Reaction</code>. A probability
must be assigned
to the edge. Optionally, a cost and a benefit may be associated
with traversing the edge. A <dfn>pay-off</dfn> (benefit-cost) is sometimes
used in edges of decision trees; the parametrization used here is more
general.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$new(source_node, target_node, p, cost = 0, benefit = 0, label = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>source_node</code></dt><dd><p>Chance node from which the reaction leaves.</p>
</dd>
<dt><code>target_node</code></dt><dd><p>Node which the reaction enters.</p>
</dd>
<dt><code>p</code></dt><dd><p>Conditional probability of traversing the reaction edge.</p>
</dd>
<dt><code>cost</code></dt><dd><p>Cost associated with traversal of this edge (numeric or
<code>ModVar</code>).</p>
</dd>
<dt><code>benefit</code></dt><dd><p>Benefit associated with traversal of the edge (numeric or
<code>ModVar</code>).</p>
</dd>
<dt><code>label</code></dt><dd><p>Character string containing the reaction label.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Reaction</code> object.
</p>


<hr>
<a id="method-Reaction-modvars"></a>



<h4>Method <code>modvars()</code></h4>

<p>Find all the model variables of type <code>ModVar</code> that
have been specified as values associated with this Action. Includes
operands of these <code>ModVar</code>s, if they are expressions.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$modvars()</pre></div>



<h5>Returns</h5>

<p>A list of <code>ModVar</code>s.
</p>


<hr>
<a id="method-Reaction-set_probability"></a>



<h4>Method <code>set_probability()</code></h4>

<p>Set the probability associated with the reaction edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$set_probability(p)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p</code></dt><dd><p>Conditional probability of traversing the reaction edge. Of type
numeric or <code>ModVar</code>. If numeric, <code>p</code> must be in the range
[0,1].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>Reaction</code> object.
</p>


<hr>
<a id="method-Reaction-p"></a>



<h4>Method <code>p()</code></h4>

<p>Return the current value of the edge probability, i.e. the
conditional' probability of traversing the edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$p()</pre></div>



<h5>Returns</h5>

<p>Numeric value in range [0,1].
</p>


<hr>
<a id="method-Reaction-set_cost"></a>



<h4>Method <code>set_cost()</code></h4>

<p>Set the cost associated with the reaction edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$set_cost(c = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>c</code></dt><dd><p>Cost associated with traversing the reaction edge. Of type
numeric or <code>ModVar</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>Reaction</code> object.
</p>


<hr>
<a id="method-Reaction-cost"></a>



<h4>Method <code>cost()</code></h4>

<p>Return the cost associated with traversing the edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$cost()</pre></div>



<h5>Returns</h5>

<p>Cost.
</p>


<hr>
<a id="method-Reaction-set_benefit"></a>



<h4>Method <code>set_benefit()</code></h4>

<p>Set the benefit associated with the reaction edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$set_benefit(b = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>b</code></dt><dd><p>Benefit associated with traversing the reaction edge. Of type
numeric or <code>ModVar</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>Action</code> object.
</p>


<hr>
<a id="method-Reaction-benefit"></a>



<h4>Method <code>benefit()</code></h4>

<p>Return the benefit associated with traversing the edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$benefit()</pre></div>



<h5>Returns</h5>

<p>Benefit.
</p>


<hr>
<a id="method-Reaction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Reaction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='SemiMarkovModel'>A semi-Markov model for cohort simulation</h2><span id='topic+SemiMarkovModel'></span>

<h3>Description</h3>

<p>An R6 class representing a semi-Markov model for
cohort simulation.
</p>


<h3>Details</h3>

<p>A class to represent a continuous time semi-Markov chain, modelled
using cohort simulation. As interpreted in <span class="pkg">rdecision</span>, semi-Markov
models
may include temporary states and transitions are defined by per-cycle
probabilities. Although used widely in health economic modelling, the
differences between semi-Markov models and Markov processes introduce
some caveats for modellers:
</p>

<ul>
<li><p>If there are temporary states, the result will depend on cycle length.
</p>
</li>
<li><p>Transitions are specified by their conditional probability, which
is a <em>per-cycle</em> probability of starting a cycle in one state and
ending it in another; if the cycle length changes, the probabilities should
change, too.
</p>
</li>
<li><p>Probabilities and rates cannot be linked by the Kolmogorov forward
equation, where the per-cycle probabilities are given by the matrix
exponential of the transition rate matrix, because this equation does not
apply if there are temporary states. In creating semi-Markov models, it is
the  modeller's task to estimate probabilities from published data on
event rates.
</p>
</li>
<li><p>The cycle time cannot be changed during the simulation.
</p>
</li></ul>



<h3>Graph theory</h3>

<p>A Markov model is a directed multidigraph permitting loops (a loop
multidigraph), optionally labelled, or a <dfn>quiver</dfn>. It is a
multidigraph because there are potentially two edges between each pair of
nodes {A,B} representing the transition probabilities from A to B and
<em>vice versa</em>. It is a directed graph because the transition
probabilities refer to transitions in one direction. Each edge can be
optionally labelled. It permits self-loops (edges whose source and target
are the same node) to represent patients that remain in the same state
between cycles.
</p>


<h3>Transition rates and probabilities</h3>



<h4>Why semi-Markov?</h4>

<p>Beck and Pauker (1983) and later Sonnenberg and Beck (1993) proposed the
use of Markov processes to model the health economics of medical
interventions. Further, they introduced the additional concept of temporary
states, to which patients who transition remain for exactly one cycle. This
breaks the principle that Markov processes are memoryless
and thus the underlying mathematical formalism, first
developed by Kolmogorov, is not applicable. For example, ensuring that all
patients leave a temporary state requires its transition rate to be infinite.
Hence, such models are usually labelled as semi-Markov processes.
</p>



<h4>Rates and probabilities</h4>

<p>Miller and Homan (1994) and Fleurence &amp; Hollenbeak (2007) provide advice
on estimating probabilities from rates. Jones (2017) and Welton (2005)
describe methods for estimating probabilities in multi-state,
multi-transition models, although those methods may not apply to
semi-Markov models with temporary states. In particular, note that the
&quot;simple&quot; equation, <code class="reqn">p = 1-e^{-rt}</code> (Briggs 2006) applies only in a
two-state, one transition model.
</p>



<h4>Uncertainty in rates</h4>

<p>In semi-Markov models, the conditional probabilities of the transitions
from each state are usually modelled by a Dirichlet distribution. In
<span class="pkg">rdecision</span>, create a Dirichlet distribution for each state and
optionally create model variables for each conditional probability
(<code class="reqn">\rho_{ij}</code>) linked to an applicable Dirichlet distribution.
</p>



<h3>Super classes</h3>

<p><code><a href="#topic+Graph">rdecision::Graph</a></code> -&gt; <code><a href="#topic+Digraph">rdecision::Digraph</a></code> -&gt; <code>SemiMarkovModel</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SemiMarkovModel-new"><code>SemiMarkovModel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-set_probabilities"><code>SemiMarkovModel$set_probabilities()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-transition_probabilities"><code>SemiMarkovModel$transition_probabilities()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-transition_cost"><code>SemiMarkovModel$transition_cost()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-get_statenames"><code>SemiMarkovModel$get_statenames()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-reset"><code>SemiMarkovModel$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-get_populations"><code>SemiMarkovModel$get_populations()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-get_elapsed"><code>SemiMarkovModel$get_elapsed()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-tabulate_states"><code>SemiMarkovModel$tabulate_states()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-cycle"><code>SemiMarkovModel$cycle()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-cycles"><code>SemiMarkovModel$cycles()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-modvars"><code>SemiMarkovModel$modvars()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-modvar_table"><code>SemiMarkovModel$modvar_table()</code></a>
</p>
</li>
<li> <p><a href="#method-SemiMarkovModel-clone"><code>SemiMarkovModel$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="degree"><a href='../../rdecision/html/Graph.html#method-Graph-degree'><code>rdecision::Graph$degree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_along"><a href='../../rdecision/html/Graph.html#method-Graph-edge_along'><code>rdecision::Graph$edge_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_at"><a href='../../rdecision/html/Graph.html#method-Graph-edge_at'><code>rdecision::Graph$edge_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_index"><a href='../../rdecision/html/Graph.html#method-Graph-edge_index'><code>rdecision::Graph$edge_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_label"><a href='../../rdecision/html/Graph.html#method-Graph-edge_label'><code>rdecision::Graph$edge_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edges"><a href='../../rdecision/html/Graph.html#method-Graph-edges'><code>rdecision::Graph$edges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="graph_adjacency_matrix"><a href='../../rdecision/html/Graph.html#method-Graph-graph_adjacency_matrix'><code>rdecision::Graph$graph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_edge"><a href='../../rdecision/html/Graph.html#method-Graph-has_edge'><code>rdecision::Graph$has_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_vertex"><a href='../../rdecision/html/Graph.html#method-Graph-has_vertex'><code>rdecision::Graph$has_vertex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="is_simple"><a href='../../rdecision/html/Graph.html#method-Graph-is_simple'><code>rdecision::Graph$is_simple()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="neighbours"><a href='../../rdecision/html/Graph.html#method-Graph-neighbours'><code>rdecision::Graph$neighbours()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="order"><a href='../../rdecision/html/Graph.html#method-Graph-order'><code>rdecision::Graph$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="size"><a href='../../rdecision/html/Graph.html#method-Graph-size'><code>rdecision::Graph$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_along"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_along'><code>rdecision::Graph$vertex_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_at"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_at'><code>rdecision::Graph$vertex_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_index"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_index'><code>rdecision::Graph$vertex_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_label"><a href='../../rdecision/html/Graph.html#method-Graph-vertex_label'><code>rdecision::Graph$vertex_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertexes"><a href='../../rdecision/html/Graph.html#method-Graph-vertexes'><code>rdecision::Graph$vertexes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="arrow_source"><a href='../../rdecision/html/Digraph.html#method-Digraph-arrow_source'><code>rdecision::Digraph$arrow_source()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="arrow_target"><a href='../../rdecision/html/Digraph.html#method-Digraph-arrow_target'><code>rdecision::Digraph$arrow_target()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="as_DOT"><a href='../../rdecision/html/Digraph.html#method-Digraph-as_DOT'><code>rdecision::Digraph$as_DOT()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_adjacency_matrix"><a href='../../rdecision/html/Digraph.html#method-Digraph-digraph_adjacency_matrix'><code>rdecision::Digraph$digraph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_incidence_matrix"><a href='../../rdecision/html/Digraph.html#method-Digraph-digraph_incidence_matrix'><code>rdecision::Digraph$digraph_incidence_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_predecessors"><a href='../../rdecision/html/Digraph.html#method-Digraph-direct_predecessors'><code>rdecision::Digraph$direct_predecessors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_successors"><a href='../../rdecision/html/Digraph.html#method-Digraph-direct_successors'><code>rdecision::Digraph$direct_successors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_acyclic"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_acyclic'><code>rdecision::Digraph$is_acyclic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_arborescence"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_arborescence'><code>rdecision::Digraph$is_arborescence()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_connected"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_connected'><code>rdecision::Digraph$is_connected()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_polytree"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_polytree'><code>rdecision::Digraph$is_polytree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_tree"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_tree'><code>rdecision::Digraph$is_tree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_weakly_connected"><a href='../../rdecision/html/Digraph.html#method-Digraph-is_weakly_connected'><code>rdecision::Digraph$is_weakly_connected()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="paths"><a href='../../rdecision/html/Digraph.html#method-Digraph-paths'><code>rdecision::Digraph$paths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="topological_sort"><a href='../../rdecision/html/Digraph.html#method-Digraph-topological_sort'><code>rdecision::Digraph$topological_sort()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="walk"><a href='../../rdecision/html/Digraph.html#method-Digraph-walk'><code>rdecision::Digraph$walk()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SemiMarkovModel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a semi-Markov model for cohort simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$new(
  V,
  E,
  tcycle = as.difftime(365.25, units = "days"),
  discount.cost = 0,
  discount.utility = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>V</code></dt><dd><p>A list of nodes (<code>MarkovState</code>s).</p>
</dd>
<dt><code>E</code></dt><dd><p>A list of edges (<code>Transition</code>s).</p>
</dd>
<dt><code>tcycle</code></dt><dd><p>Cycle length, expressed as an R <code>difftime</code> object.</p>
</dd>
<dt><code>discount.cost</code></dt><dd><p>Annual discount rate for future costs. Note this
is a rate, not a probability (i.e. use 0.035 for 3.5%).</p>
</dd>
<dt><code>discount.utility</code></dt><dd><p>Annual discount rate for future incremental
utility. Note this is a rate, not a probability (i.e. use 0.035
for 3.5%).</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A semi-Markov model must meet the following conditions:
</p>

<ol>
<li><p> It must have at least one node and at least one edge.
</p>
</li>
<li><p> All nodes must be of class <code>MarkovState</code>;
</p>
</li>
<li><p> All edges must be of class <code>Transition</code>;
</p>
</li>
<li><p> The nodes and edges must form a digraph whose underlying
graph is connected;
</p>
</li>
<li><p> Each state must have at least one outgoing transition (for
absorbing states this is a self-loop);
</p>
</li>
<li><p> For each state the sum of outgoing conditional transition
probabilities must be one. For convenience, one outgoing transition
probability from each state may be set to NA when the
probabilities are defined. Typically, probabilities for self
loops would be set to NA. Transition probabilities in <code class="reqn">Pt</code>
associated with transitions that are not defined as edges in the
graph are zero. Probabilities can be changed between cycles.
</p>
</li>
<li><p> No two edges may share the same source and target nodes (i.e.
the digraph may not have multiple edges). This is to ensure that there
are no more transitions than cells in the transition matrix.
</p>
</li>
<li><p> The node labels must be unique to the graph.
</p>
</li></ol>




<h5>Returns</h5>

<p>A <code>SemiMarkovModel</code> object. The population of the first
state is set to 1000 and from each state there is an equal
conditional probability of each allowed transition.
</p>


<hr>
<a id="method-SemiMarkovModel-set_probabilities"></a>



<h4>Method <code>set_probabilities()</code></h4>

<p>Sets transition probabilities.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$set_probabilities(Pt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Pt</code></dt><dd><p>Per-cycle transition probability matrix. The row and
column labels must be the state names and each row must sum to one.
Non-zero probabilities for undefined transitions are not allowed. At
most one <code>NA</code> may appear in each row. If an NA is present in a row,
it is replaced by 1 minus the sum of the defined probabilities.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>SemiMarkovModel</code> object
</p>


<hr>
<a id="method-SemiMarkovModel-transition_probabilities"></a>



<h4>Method <code>transition_probabilities()</code></h4>

<p>Per-cycle transition probability matrix for the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$transition_probabilities()</pre></div>



<h5>Returns</h5>

<p>A square matrix of size equal to the number of states. If all
states are labelled, the dimnames take the names of the states.
</p>


<hr>
<a id="method-SemiMarkovModel-transition_cost"></a>



<h4>Method <code>transition_cost()</code></h4>

<p>Return the per-cycle transition costs for the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$transition_cost()</pre></div>



<h5>Returns</h5>

<p>A square matrix of size equal to the number of states. If all
states are labelled, the dimnames take the names of the states.
</p>


<hr>
<a id="method-SemiMarkovModel-get_statenames"></a>



<h4>Method <code>get_statenames()</code></h4>

<p>Returns a character list of state names.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$get_statenames()</pre></div>



<h5>Returns</h5>

<p>List of the names of each state.
</p>


<hr>
<a id="method-SemiMarkovModel-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Resets the model counters.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$reset(
  populations = NULL,
  icycle = 0L,
  elapsed = as.difftime(0, units = "days")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>populations</code></dt><dd><p>A named vector of populations for
the start of the state. The names should be the state names.
Due to the R implementation of matrix algebra, <code>populations</code>
must be a numeric type and is not restricted to being an integer. If
NULL, the population of all states is set to zero.</p>
</dd>
<dt><code>icycle</code></dt><dd><p>Cycle number at which to start/restart.</p>
</dd>
<dt><code>elapsed</code></dt><dd><p>Elapsed time since the index (reference) time used for
discounting as an R <code>difftime</code> object.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Resets the state populations, next cycle number and elapsed time
of the model. By default the model is returned to its ground state (zero
people in the all states; next cycle is labelled
zero; elapsed time (years) is zero). Any or all of these can be set via
this function. <code>icycle</code> is simply an integer counter label for each
cycle, <code>elapsed</code> sets the elapsed time in years from the index time
from which discounting is assumed to apply.
</p>



<h5>Returns</h5>

<p>Updated <code>SemiMarkovModel</code> object.
</p>


<hr>
<a id="method-SemiMarkovModel-get_populations"></a>



<h4>Method <code>get_populations()</code></h4>

<p>Gets the occupancy of each state
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$get_populations()</pre></div>



<h5>Returns</h5>

<p>A numeric vector of populations, named with state names.
</p>


<hr>
<a id="method-SemiMarkovModel-get_elapsed"></a>



<h4>Method <code>get_elapsed()</code></h4>

<p>Gets the current elapsed time.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$get_elapsed()</pre></div>



<h5>Details</h5>

<p>The elapsed time is defined as the difference between the
current time in the model and an index time used as the reference
time for applying discounting. By default the elapsed time starts at
zero. It can be set directly by calling <code>reset</code>. It is incremented
after each call to <code>cycle</code> by the cycle duration to the time at the
end of the cycle (even if half cycle correction is used). Thus, via the
<code>reset</code> and <code>cycle</code> methods, the time of each cycle relative
to the discounting index and its duration can be controlled arbitrarily.
</p>



<h5>Returns</h5>

<p>Elapsed time as an R <code>difftime</code> object.
</p>


<hr>
<a id="method-SemiMarkovModel-tabulate_states"></a>



<h4>Method <code>tabulate_states()</code></h4>

<p>Tabulation of states
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$tabulate_states()</pre></div>



<h5>Details</h5>

<p>Creates a data frame summary of each state in the model.
</p>



<h5>Returns</h5>

<p>A data frame with the following columns:
</p>

<dl>
<dt>Name</dt><dd><p>State name</p>
</dd>
<dt>Cost</dt><dd><p>Annual cost of occupying the state</p>
</dd>
<dt>Utility</dt><dd><p>Incremental utility associated with being in the state.</p>
</dd>
</dl>



<hr>
<a id="method-SemiMarkovModel-cycle"></a>



<h4>Method <code>cycle()</code></h4>

<p>Applies one cycle of the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$cycle(hcc.pop = TRUE, hcc.cost = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hcc.pop</code></dt><dd><p>Determines the state populations returned by this
function and for calculating incremental utility, and the time at which
the utility discount is applied. If FALSE, the end of cycle populations
and time apply; if TRUE the mid-cycle populations and time apply. The
mid-cycle populations are taken as the mean of the start and end
populations and the discount time as the mid-point. The value of this
parameter does not affect the state populations or elapsed time passed
to the next cycle or available via
<code>get_populations</code>; those are always the end cycle values.</p>
</dd>
<dt><code>hcc.cost</code></dt><dd><p>Determines the state occupancy costs returned by this
function and the time at which the cost discount is applied to the
occupancy costs and the entry costs. If FALSE, the end of cycle
populations and time apply; if TRUE the mid-cycle populations and time
apply, as per <code>hcc.pop</code>. The value of this parameter does not affect
the state populations or elapsed time passed to the next cycle or
available via <code>get_populations</code>; those are always the end cycle
values.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Calculated values, one row per state, as a data frame with the
following columns:
</p>

<dl>
<dt><code>State</code></dt><dd><p>Name of the state.</p>
</dd>
<dt><code>Cycle</code></dt><dd><p>The cycle number.</p>
</dd>
<dt><code>Time</code></dt><dd><p>Clock time in years of the end of the cycle.</p>
</dd>
<dt><code>Population</code></dt><dd><p>Populations of the states; see <code>hcc.pop</code>.</p>
</dd>
<dt><code>OccCost</code></dt><dd><p>Cost of the population occupying the state for
the cycle. Discounting and half cycle correction is applied, if those
options are set. The costs are normalized by the model population. The
cycle costs are derived from the annual occupancy costs of the
<code>MarkovState</code>s.</p>
</dd>
<dt><code>EntryCost</code></dt><dd><p>Cost of the transitions <em>into</em> the state
during the cycle. Discounting is applied, if the option is set.
The result is normalized by the model population. The cycle costs
are derived from <code>Transition</code> costs.</p>
</dd>
<dt><code>Cost</code></dt><dd><p>Total cost, normalized by model population.</p>
</dd>
<dt><code>QALY</code></dt><dd><p>Quality adjusted life years gained by occupancy of
the states during the cycle. Half cycle correction and discounting are
applied, if these options are set. Normalized by the model population.</p>
</dd>
</dl>



<hr>
<a id="method-SemiMarkovModel-cycles"></a>



<h4>Method <code>cycles()</code></h4>

<p>Applies multiple cycles of the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$cycles(ncycles = 2L, hcc.pop = TRUE, hcc.cost = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ncycles</code></dt><dd><p>Number of cycles to run; default is 2.</p>
</dd>
<dt><code>hcc.pop</code></dt><dd><p>Determines the state populations returned by this
function and for calculating incremental utility, and the time at which
the utility discount is applied. If FALSE, the end of cycle populations
and time apply; if TRUE the mid-cycle populations and time apply. The
mid-cycle populations are taken as the mean of the start and end
populations and the discount time as the mid-point. The value of this
parameter does not affect the state populations or elapsed time passed
to the next cycle or available via
<code>get_populations</code>; those are always the end cycle values.</p>
</dd>
<dt><code>hcc.cost</code></dt><dd><p>Determines the state occupancy costs returned by this
function and the time at which the cost discount is applied to the
occupancy costs and the entry costs. If FALSE, the end of cycle
populations and time apply; if TRUE the mid-cycle populations and time
apply, as per <code>hcc.pop</code>. The value of this parameter does not affect
the state populations or elapsed time passed to the next cycle or
available via <code>get_populations</code>; those are always the end cycle
values.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The starting populations are redistributed through the
transition probabilities and the state occupancy costs are
calculated, using function <code>cycle</code>. The end populations are
then fed back into the model for a further cycle and the
process is repeated. For each cycle, the state populations and
the aggregated occupancy costs are saved in one row of the
returned data frame, with the cycle number. If the cycle count
for the model is zero when called, the first cycle reported
will be cycle zero, i.e. the distribution of patients to starting
states.
</p>



<h5>Returns</h5>

<p>Data frame with cycle results, with the following columns:
</p>

<dl>
<dt><code>Cycle</code></dt><dd><p>The cycle number.</p>
</dd>
<dt><code>Years</code></dt><dd><p>Elapsed time at end of cycle, years</p>
</dd>
<dt><code>Cost</code></dt><dd><p>Cost associated with occupancy and transitions between
states during the cycle.</p>
</dd>
<dt><code>QALY</code></dt><dd><p>Quality adjusted life years associated with occupancy
of the states in the cycle.</p>
</dd>
<dt><code>&lt;name&gt;</code></dt><dd><p>Population of state <code>&lt;name&gt;</code> at the end of
the cycle.</p>
</dd>
</dl>



<hr>
<a id="method-SemiMarkovModel-modvars"></a>



<h4>Method <code>modvars()</code></h4>

<p>Find all the model variables in the Markov model.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$modvars()</pre></div>



<h5>Details</h5>

<p>Returns variables of type <code>ModVar</code> that have been
specified as values associated with transition rates and costs and
the state occupancy costs and utilities.
</p>



<h5>Returns</h5>

<p>A list of <code>ModVar</code>s.
</p>


<hr>
<a id="method-SemiMarkovModel-modvar_table"></a>



<h4>Method <code>modvar_table()</code></h4>

<p>Tabulate the model variables in the Markov model.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$modvar_table(expressions = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expressions</code></dt><dd><p>A logical that defines whether expression model
variables should be included in the tabulation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Data frame with one row per model variable, as follows:
</p>

<dl>
<dt><code>Description</code></dt><dd><p>As given at initialization.</p>
</dd>
<dt><code>Units</code></dt><dd><p>Units of the variable.</p>
</dd>
<dt><code>Distribution</code></dt><dd><p>Either the uncertainty distribution, if
it is a regular model variable, or the expression used to create it,
if it is an <code>ExprModVar</code>.</p>
</dd>
<dt><code>Mean</code></dt><dd><p>Mean; calculated from means of operands if
an expression.</p>
</dd>
<dt><code>E</code></dt><dd><p>Expectation; estimated from random sample if expression,
mean otherwise.</p>
</dd>
<dt><code>SD</code></dt><dd><p>Standard deviation; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Q2.5</code></dt><dd><p>p=0.025 quantile; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Q97.5</code></dt><dd><p>p=0.975 quantile; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Est</code></dt><dd><p>TRUE if the quantiles and SD have been estimated by
random sampling.</p>
</dd>
</dl>



<hr>
<a id="method-SemiMarkovModel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SemiMarkovModel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Beck JR and Pauker SG. The Markov Process in Medical Prognosis.
<em>Med Decision Making</em>, 1983;<strong>3</strong>:419458.
</p>
<p>Briggs A, Claxton K, Sculpher M. Decision modelling for health economic
evaluation. Oxford, UK: Oxford University Press; 2006.
</p>
<p>Fleurence RL and Hollenbeak CS. Rates and probabilities in economic
modelling. <em>PharmacoEconomics</em>, 2007;<strong>25</strong>:3&ndash;6.
</p>
<p>Jones E, Epstein D and Garca-Mochn L. A procedure for deriving
formulas to convert transition rates to probabilities for multistate
Markov models. <em>Medical Decision Making</em> 2017;<strong>37</strong>:779789.
</p>
<p>Miller DK and Homan SM. Determining transition probabilities: confusion
and suggestions. <em>Medical Decision Making</em> 1994;<strong>14</strong>:52-58.
</p>
<p>Sonnenberg FA, Beck JR. Markov models in medical decision making: a
practical guide. <em>Medical Decision Making</em>, 1993:<strong>13</strong>:322.
</p>
<p>Welton NJ and Ades A. Estimation of Markov chain transition probabilities
and rates from fully and partially observed data: uncertainty
propagation, evidence synthesis, and model calibration.
<em>Medical Decision Making</em>, 2005;<strong>25</strong>:633-645.

</p>

<hr>
<h2 id='Stack'>A stack</h2><span id='topic+Stack'></span>

<h3>Description</h3>

<p>An R6 class representing a stack of objects of any type.
</p>


<h3>Details</h3>

<p>Conventional implementation of a stack. Used extensively in graph
algorithms and offered as a separate class for ease of programming and to
ensure that implementations of stacks are optimized. By intention, there is
only minimal checking of method arguments. This is to maximize performance
and because the class is mainly intended for use internally to
<span class="pkg">rdecision</span>.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Stack-new"><code>Stack$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Stack-push"><code>Stack$push()</code></a>
</p>
</li>
<li> <p><a href="#method-Stack-pop"><code>Stack$pop()</code></a>
</p>
</li>
<li> <p><a href="#method-Stack-size"><code>Stack$size()</code></a>
</p>
</li>
<li> <p><a href="#method-Stack-as_list"><code>Stack$as_list()</code></a>
</p>
</li>
<li> <p><a href="#method-Stack-clone"><code>Stack$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Stack-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a stack.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stack$new()</pre></div>



<h5>Returns</h5>

<p>A new <code>Stack</code> object.
</p>


<hr>
<a id="method-Stack-push"></a>



<h4>Method <code>push()</code></h4>

<p>Push an item onto the stack.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stack$push(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>The item to push onto the top of the stack. It should be
of the same class as items previously pushed on to the stack. It is not
checked.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>Stack</code> object
</p>


<hr>
<a id="method-Stack-pop"></a>



<h4>Method <code>pop()</code></h4>

<p>Pop an item from the stack. Stack underflow and
raises an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stack$pop()</pre></div>



<h5>Returns</h5>

<p>The item previously at the top of the stack.
</p>


<hr>
<a id="method-Stack-size"></a>



<h4>Method <code>size()</code></h4>

<p>Gets the number of items on the stack.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stack$size()</pre></div>



<h5>Returns</h5>

<p>Number of items.
</p>


<hr>
<a id="method-Stack-as_list"></a>



<h4>Method <code>as_list()</code></h4>

<p>Inspect items in the stack.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stack$as_list()</pre></div>



<h5>Returns</h5>

<p>A list of items.
</p>


<hr>
<a id="method-Stack-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stack$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

<hr>
<h2 id='Transition'>A transition in a semi-Markov model</h2><span id='topic+Transition'></span>

<h3>Description</h3>

<p>An R6 class representing a transition in a semi-Markov model.
</p>


<h3>Details</h3>

<p>A specialism of class <code>Arrow</code> which is used in a semi-Markov
model to represent a transition between two <code>MarkovState</code>s. The
transition is optionally associated with a cost. The transition probability
is associated with the model (<code>SemiMarkovModel</code>) rather than the
transition.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Edge">rdecision::Edge</a></code> -&gt; <code><a href="#topic+Arrow">rdecision::Arrow</a></code> -&gt; <code>Transition</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Transition-new"><code>Transition$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Transition-modvars"><code>Transition$modvars()</code></a>
</p>
</li>
<li> <p><a href="#method-Transition-set_cost"><code>Transition$set_cost()</code></a>
</p>
</li>
<li> <p><a href="#method-Transition-cost"><code>Transition$cost()</code></a>
</p>
</li>
<li> <p><a href="#method-Transition-clone"><code>Transition$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="endpoints"><a href='../../rdecision/html/Edge.html#method-Edge-endpoints'><code>rdecision::Edge$endpoints()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="is_same_edge"><a href='../../rdecision/html/Edge.html#method-Edge-is_same_edge'><code>rdecision::Edge$is_same_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Edge" data-id="label"><a href='../../rdecision/html/Edge.html#method-Edge-label'><code>rdecision::Edge$label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arrow" data-id="source"><a href='../../rdecision/html/Arrow.html#method-Arrow-source'><code>rdecision::Arrow$source()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arrow" data-id="target"><a href='../../rdecision/html/Arrow.html#method-Arrow-target'><code>rdecision::Arrow$target()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Transition-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an object of type <code>MarkovTransition</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transition$new(source_state, target_state, cost = 0, label = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>source_state</code></dt><dd><p><code>MarkovState</code> from which the transition starts.</p>
</dd>
<dt><code>target_state</code></dt><dd><p><code>MarkovState</code> to which the transition ends.</p>
</dd>
<dt><code>cost</code></dt><dd><p>Cost associated with the transition.</p>
</dd>
<dt><code>label</code></dt><dd><p>Character string containing a label for the transition (the
name of the event).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Transition</code> object.
</p>


<hr>
<a id="method-Transition-modvars"></a>



<h4>Method <code>modvars()</code></h4>

<p>Find all the model variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transition$modvars()</pre></div>



<h5>Details</h5>

<p>Find variables of type <code>ModVar</code> that have been
specified as values associated with this <code>MarkovTransition</code>.
Includes operands of these <code>ModVar</code>s, if they are expressions.
</p>



<h5>Returns</h5>

<p>A list of <code>ModVar</code>s.
</p>


<hr>
<a id="method-Transition-set_cost"></a>



<h4>Method <code>set_cost()</code></h4>

<p>Set the cost associated with the transition.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transition$set_cost(c = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>c</code></dt><dd><p>Cost associated with the transition.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Updated <code>Transition</code> object.
</p>


<hr>
<a id="method-Transition-cost"></a>



<h4>Method <code>cost()</code></h4>

<p>Return the cost associated with traversing the edge.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transition$cost()</pre></div>



<h5>Returns</h5>

<p>Cost.
</p>


<hr>
<a id="method-Transition-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transition$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
