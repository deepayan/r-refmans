<!DOCTYPE html><html><head><title>Help for package piar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {piar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.piar_index'><p>Extract and replace index values</p></a></li>
<li><a href='#aggregate.piar_index'><p>Aggregate elemental price indexes</p></a></li>
<li><a href='#aggregation_structure'><p>Make a price index aggregation structure</p></a></li>
<li><a href='#as_aggregation_structure'><p>Coerce to an aggregation structure</p></a></li>
<li><a href='#as_index'><p>Coerce to a price index</p></a></li>
<li><a href='#as.data.frame.piar_index'><p>Coerce an index into a tabular form</p></a></li>
<li><a href='#as.matrix.piar_aggregation_structure'><p>Coerce an aggregation structure into a tabular form</p></a></li>
<li><a href='#chain'><p>Chain and rebase a price index</p></a></li>
<li><a href='#contrib'><p>Extract percent-change contributions</p></a></li>
<li><a href='#elemental_index'><p>Make elemental price indexes</p></a></li>
<li><a href='#expand_classification'><p>Expand a hierarchical classification</p></a></li>
<li><a href='#head.piar_index'><p>Return the first/last parts of an index</p></a></li>
<li><a href='#impute_prices'><p>Impute missing prices</p></a></li>
<li><a href='#is_aggregation_structure'><p>Test if an object is an aggregation structure</p></a></li>
<li><a href='#is_index'><p>Test if an object is a price index</p></a></li>
<li><a href='#is.na.piar_index'><p>Missing values in a price index</p></a></li>
<li><a href='#levels.piar_aggregation_structure'><p>Get the levels for an aggregation structure</p></a></li>
<li><a href='#levels.piar_index'><p>Get the levels for a price index</p></a></li>
<li><a href='#mean.piar_index'><p>Aggregate a price index over subperiods</p></a></li>
<li><a href='#merge.piar_index'><p>Merge price indexes</p></a></li>
<li><a href='#piar_index'><p>Price index objects</p></a></li>
<li><a href='#piar-package'><p>piar: Price Index Aggregation</p></a></li>
<li><a href='#price_data'><p>Price data</p></a></li>
<li><a href='#price_relative'><p>Calculate period-over-period price relatives</p></a></li>
<li><a href='#split.piar_index'><p>Split an index into groups</p></a></li>
<li><a href='#stack.piar_index'><p>Stack price indexes</p></a></li>
<li><a href='#summary.piar_index'><p>Summarize a price index</p></a></li>
<li><a href='#time.piar_index'><p>Get the time periods for a price index</p></a></li>
<li><a href='#update.piar_aggregation_structure'><p>Update an aggregation structure</p></a></li>
<li><a href='#vcov.aggregate_piar_index'><p>Bootstrap variance for a price index with replicate weights</p></a></li>
<li><a href='#weights.piar_aggregation_structure'><p>Get the weights for an aggregation structure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Price Index Aggregation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Most price indexes are made with a two-step procedure, where
    period-over-period elemental indexes are first calculated for a collection
    of elemental aggregates at each point in time, and then aggregated according
    to a price index aggregation structure. These indexes can then be chained
    together to form a time series that gives the evolution of prices with
    respect to a fixed base period. This package contains a collections of
    functions that revolve around this work flow, making it easy to build
    standard price indexes, and implement the methods described by
    Balk (2008, ISBN:978-1-107-40496-0), von der Lippe (2001,
    ISBN:3-8246-0638-0), and the CPI manual (2020, ISBN:978-1-51354-298-0)
    for bilateral price indexes.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, gpindex (&ge; 0.5.0), Matrix (&ge; 1.5-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, sps, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://marberts.github.io/piar/">https://marberts.github.io/piar/</a>, <a href="https://github.com/marberts/piar">https://github.com/marberts/piar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/marberts/piar/issues">https://github.com/marberts/piar/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 15:41:36 UTC; steve</td>
</tr>
<tr>
<td>Author:</td>
<td>Steve Martin <a href="https://orcid.org/0000-0003-2544-9480"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steve Martin &lt;marberts@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-08 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.piar_index'>Extract and replace index values</h2><span id='topic++5B.piar_index'></span><span id='topic++5B+3C-.piar_index'></span>

<h3>Description</h3>

<p>Methods to extract and replace index values like a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
x[i, j, ...]

## S3 replacement method for class 'piar_index'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="+2B5B.piar_index_+3A_i">i</code>, <code id="+2B5B.piar_index_+3A_j">j</code></td>
<td>
<p>Indices for the levels and time periods of a price index. See
details.</p>
</td></tr>
<tr><td><code id="+2B5B.piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="+2B5B.piar_index_+3A_value">value</code></td>
<td>
<p>A numeric vector or price index. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extraction method treats <code>x</code> like a matrix of index values with
(named) rows for each level and columns for each time period in
<code>x</code>. Unlike a matrix, dimensions are never dropped as subscripting
<code>x</code> always returns an index object. This means that subscripting with a
matrix is not possible, and only a &quot;submatrix&quot; can be extracted. As <code>x</code>
is not an atomic vector, subscripting with a single index like <code>x[1]</code>
extracts all time periods for that level.
</p>
<p>The replacement method similarly treat <code>x</code> like a matrix. If <code>value</code> is
an index object with the same number of time periods as <code>x[i, j]</code> and
it inherits from the same class as <code>x</code>, then the index values and
percent-change contributions of <code>x[i, j]</code> are replaced with those for the
corresponding levels of <code>value</code>. If <code>value</code> is not an index, then it is
coerced to a numeric vector and behaves the same as replacing values in a
matrix. Note that replacing the values of an index will remove the
corresponding percent-change contributions (if any). Unlike extraction, it
is possible to replace value in <code>x</code> using a logical matrix or a two-column
matrix of indices.
</p>
<p>Subscripting an aggregate index cannot generally preserve the aggregation
structure if any levels are removed or rearranged, and in this case the
resulting index is <em>not</em> an aggregate index. Similarly, replacing the
values for an aggregate index generally breaks consistency in aggregation,
and therefore the result is <em>not</em> an aggregate index.
</p>


<h3>Value</h3>

<p>A price index that inherits from <code><a href="#topic+chainable_piar_index">chainable_piar_index</a></code> if <code>x</code> is a
period-over-period index, or <code><a href="#topic+direct_piar_index">direct_piar_index</a></code> if <code>x</code> is a
fixed-base index. If <code>x</code> inherits from <code><a href="#topic+aggregate_piar_index">aggregate_piar_index</a></code> then
<code>[</code> returns an aggregate index if the levels are unchanged.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- as_index(matrix(1:6, 2))

index["1", ]

index[, 2]

index[1, ] &lt;- 1 # can be useful for doing specific imputations

index

</code></pre>

<hr>
<h2 id='aggregate.piar_index'>Aggregate elemental price indexes</h2><span id='topic+aggregate.piar_index'></span><span id='topic+aggregate.chainable_piar_index'></span><span id='topic+aggregate.direct_piar_index'></span>

<h3>Description</h3>

<p>Aggregate elemental price indexes with a price index aggregation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'chainable_piar_index'
aggregate(x, pias, ..., na.rm = FALSE, contrib = TRUE, r = 1)

## S3 method for class 'direct_piar_index'
aggregate(x, pias, ..., na.rm = FALSE, contrib = TRUE, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, usually made by <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="aggregate.piar_index_+3A_pias">pias</code></td>
<td>
<p>A price index aggregation structure or something that can be
coerced into one. This can be made with <code><a href="#topic+aggregation_structure">aggregation_structure()</a></code>.</p>
</td></tr>
<tr><td><code id="aggregate.piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="aggregate.piar_index_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed? By default, missing values
are not removed. Setting <code>na.rm = TRUE</code> is equivalent to overall mean
imputation.</p>
</td></tr>
<tr><td><code id="aggregate.piar_index_+3A_contrib">contrib</code></td>
<td>
<p>Aggregate percent-change contributions in <code>x</code> (if any)?</p>
</td></tr>
<tr><td><code id="aggregate.piar_index_+3A_r">r</code></td>
<td>
<p>Order of the generalized mean to aggregate index values. 0 for a
geometric index (the default for making elemental indexes), 1 for an
arithmetic index (the default for aggregating elemental indexes and
averaging indexes over subperiods), or -1 for a harmonic index (usually for
a Paasche index). Other values are possible; see
<code><a href="gpindex.html#topic+generalized_mean">gpindex::generalized_mean()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>aggregate()</code> method loops over each time period in <code>x</code> and
</p>

<ol>
<li><p> aggregates the elemental indexes with
<code><a href="gpindex.html#topic+generalized_mean">gpindex::generalized_mean(r)()</a></code> for each level
of <code>pias</code>;
</p>
</li>
<li><p> aggregates percent-change contributions for each level of
<code>pias</code> (if there are any and <code>contrib = TRUE</code>);
</p>
</li>
<li><p> price updates the weights in <code>pias</code> with
<code><a href="gpindex.html#topic+factor_weights">gpindex::factor_weights(r)()</a></code> (only for
period-over-period elemental indexes).
</p>
</li></ol>

<p>The result is a collection of aggregated period-over-period indexes that
can be chained together to get a fixed-base index when <code>x</code> are
period-over-period elemental indexes. Otherwise, when <code>x</code> are fixed-base
elemental indexes, the result is a collection of aggregated fixed-base
(direct) indexes.
</p>
<p>By default, missing elemental indexes will propagate when aggregating the
index. Missing elemental indexes can be due to both missingness of these
values in <code>x</code>, and the presence of elemental aggregates in <code>pias</code>
that are not part of <code>x</code>. Setting <code>na.rm = TRUE</code> ignores missing
values, and is equivalent to parental (or overall mean) imputation. As an
aggregated price index generally cannot have missing values (for otherwise
it can't be chained over time and weights can't be price updated), any
missing values for a level of <code>pias</code> are removed and recursively replaced
by the value of its immediate parent.
</p>
<p>In most cases aggregation is done with an arithmetic mean (the default), and
this is detailed in chapter 8 (pp. 190&ndash;198) of the CPI manual (2020).
Aggregating with a non-arithmetic mean follows the same steps, except that
the elemental indexes are aggregated with a mean of a different order (e.g.,
harmonic for a Paasche index), and the method for price updating the weights
is slightly different. Note that, because aggregation is done with a
generalized mean, the resulting index is consistent-in-aggregation at each
point in time.
</p>
<p>Aggregating percent-change contributions uses the method in chapter 9 of the
CPI manual (equations 9.26 and 9.28) when aggregating with an arithmetic
mean. With a non-arithmetic mean, arithmetic weights are constructed using
<code><a href="gpindex.html#topic+transmute_weights">gpindex::transmute_weights(r, 1)()</a></code> in order
to apply this method.
</p>
<p>There may not be contributions for all prices relatives in an elemental
aggregate if the elemental indexes are built from several sources (as with
<code><a href="#topic+merge.piar_index">merge()</a></code>). In this case the contribution for
a price relative in the aggregated index will be correct, but the sum of all
contributions will not equal the change in the value of the index. This can
also happen when aggregating an already aggregated index in which missing
index values have been imputed (i.e., when <code>na.rm = TRUE</code>).
</p>


<h3>Value</h3>

<p>An aggregate price index that inherits from <code><a href="#topic+aggregate_piar_index">aggregate_piar_index</a></code> and
the class of <code>x</code>.
</p>


<h3>Note</h3>

<p>For large indexes it can be much faster to turn the aggregation structure
into an aggregation matrix with
<code><a href="#topic+as.matrix.piar_aggregation_structure">as.matrix()</a></code>, then aggregate
elemental indexes as a matrix operation when there are no missing
values. See the examples for details.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2020).
<em>Consumer Price Index Manual: Theory and Practice</em>.
International Monetary Fund.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- data.frame(
  rel = 1:8,
  period = rep(1:2, each = 4),
  ea = rep(letters[1:2], 4)
)

# A two-level aggregation structure

pias &lt;- aggregation_structure(
  list(c("top", "top", "top"), c("a", "b", "c")), 1:3
)

# Calculate Jevons elemental indexes

(elemental &lt;- with(prices, elemental_index(rel, period, ea)))

# Aggregate (note the imputation for elemental index 'c')

(index &lt;- aggregate(elemental, pias, na.rm = TRUE))

# Aggregation can equivalently be done as matrix multiplication

as.matrix(pias) %*% as.matrix(chain(index[letters[1:3]]))

</code></pre>

<hr>
<h2 id='aggregation_structure'>Make a price index aggregation structure</h2><span id='topic+aggregation_structure'></span><span id='topic+piar_aggregation_structure'></span>

<h3>Description</h3>

<p>Create a price index aggregation structure from a hierarchical
classification and aggregation weights that can be used to aggregate
elemental indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregation_structure(x, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregation_structure_+3A_x">x</code></td>
<td>
<p>A list of character vectors that give the codes/labels for each
level of the classification, ordered so that moving down the list goes down
the hierarchy. The last vector gives the elemental aggregates, which should
have no duplicates. All vectors should be the same length, without
<code>NA</code>s, and there should be no duplicates across different levels of
<code>x</code>.</p>
</td></tr>
<tr><td><code id="aggregation_structure_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of aggregation weights for the elemental
aggregates (i.e., the last vector in <code>x</code>), or something that can be coerced
into one. The default is to give each elemental aggregate the same weight.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A price index aggregation structure of class <code>piar_aggregation_structure</code>.
This is a list-S3 class with the following components.
</p>
<table>
<tr><td><code>child</code></td>
<td>
<p>A nested list that gives the positions of the immediate
children for each node in each level of the aggregation structure above the
terminal nodes.</p>
</td></tr>
<tr><td><code>parent</code></td>
<td>
<p>A list that gives the position of the
immediate parent for each node of the aggregation structure below the
initial nodes.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>A list of character vectors that give the levels of <code>x</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>A named vector giving the weight for each elemental
aggregate.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The <code>aggregation_structure()</code> function does its best
to check its arguments, but there should be no expectation that the result
of <code>aggregation_structure()</code> will make any sense if <code>x</code> does not
represent a nested hierarchy.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate.piar_index">aggregate()</a></code> to aggregate price indexes made
with <code><a href="#topic+elemental_index">elemental_index()</a></code>.
</p>
<p><code><a href="#topic+expand_classification">expand_classification()</a></code> to make <code>x</code> from a character
representation of a hierarchical aggregation structure.
</p>
<p><code><a href="#topic+as_aggregation_structure">as_aggregation_structure()</a></code> to coerce tabular data into an
aggregation structure.
</p>
<p><code><a href="#topic+as.data.frame.piar_aggregation_structure">as.data.frame()</a></code> and
<code><a href="#topic+as.matrix.piar_aggregation_structure">as.matrix()</a></code> to coerce an
aggregation structure into a tabular form.
</p>
<p><code><a href="#topic+weights.piar_aggregation_structure">weights()</a></code> to get the
weights for an aggregation structure.
</p>
<p><code><a href="#topic+update.piar_aggregation_structure">update()</a></code> for updating a
price index aggregation structure with an aggregated index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple aggregation structure
#            1
#      |-----+-----|
#      11          12
#  |---+---|       |
#  111     112     121
#  (1)     (3)     (4)

aggregation_weights &lt;- data.frame(
  level1 = c("1", "1", "1"),
  level2 = c("11", "11", "12"),
  ea     = c("111", "112", "121"),
  weight = c(1, 3, 4)
)

aggregation_structure(
  aggregation_weights[1:3],
  weights = aggregation_weights[[4]]
)

# The aggregation structure can also be made by expanding the
# elemental aggregates

with(
  aggregation_weights,
  aggregation_structure(expand_classification(ea), weight)
)

</code></pre>

<hr>
<h2 id='as_aggregation_structure'>Coerce to an aggregation structure</h2><span id='topic+as_aggregation_structure'></span><span id='topic+as_aggregation_structure.default'></span><span id='topic+as_aggregation_structure.data.frame'></span><span id='topic+as_aggregation_structure.matrix'></span><span id='topic+as_aggregation_structure.aggregate_piar_index'></span>

<h3>Description</h3>

<p>Coerce an object into an aggregation structure object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_aggregation_structure(x, ...)

## Default S3 method:
as_aggregation_structure(x, weights = NULL, ...)

## S3 method for class 'data.frame'
as_aggregation_structure(x, ...)

## S3 method for class 'matrix'
as_aggregation_structure(x, ...)

## S3 method for class 'aggregate_piar_index'
as_aggregation_structure(x, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_aggregation_structure_+3A_x">x</code></td>
<td>
<p>An object to coerce into an aggregation structure.</p>
</td></tr>
<tr><td><code id="as_aggregation_structure_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="as_aggregation_structure_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of aggregation weights for the elemental
aggregates. The default is to give each elemental aggregate the same weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method attempts to coerce <code>x</code> into a list prior to calling
<code><a href="#topic+aggregation_structure">aggregation_structure()</a></code>.
</p>
<p>The data frame and matrix methods treat <code>x</code> as a table with a row for
each elemental aggregate, a column of labels for each level in the
aggregation structure, and a column of weights for the elemental aggregates.
</p>
<p>The method for aggregate indexes reconstructs the aggregation structure used
to generate the index (with optional weights).
</p>


<h3>Value</h3>

<p>A price index aggregation structure that inherits from
<code><a href="#topic+piar_aggregation_structure">piar_aggregation_structure</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.piar_aggregation_structure">as.matrix()</a></code> and
<code><a href="#topic+as.data.frame.piar_aggregation_structure">as.data.frame()</a></code> for
coercing an aggregation structure into a tabular form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple aggregation structure
#            1
#      |-----+-----|
#      11          12
#  |---+---|       |
#  111     112     121
#  (1)     (3)     (4)

aggregation_weights &lt;- data.frame(
  level1 = c("1", "1", "1"),
  level2 = c("11", "11", "12"),
  ea     = c("111", "112", "121"),
  weight = c(1, 3, 4)
)

pias &lt;- aggregation_structure(
  aggregation_weights[1:3],
  weights = aggregation_weights[[4]]
)

all.equal(
  pias,
  as_aggregation_structure(aggregation_weights)
)

all.equal(
  pias,
  as_aggregation_structure(as.matrix(aggregation_weights))
)

</code></pre>

<hr>
<h2 id='as_index'>Coerce to a price index</h2><span id='topic+as_index'></span><span id='topic+as_index.default'></span><span id='topic+as_index.matrix'></span><span id='topic+as_index.data.frame'></span><span id='topic+as_index.chainable_piar_index'></span><span id='topic+as_index.direct_piar_index'></span>

<h3>Description</h3>

<p>Coerce pre-computed index values into an index object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_index(x, ...)

## Default S3 method:
as_index(x, ..., chainable = TRUE)

## S3 method for class 'matrix'
as_index(x, ..., chainable = TRUE)

## S3 method for class 'data.frame'
as_index(x, cols = NULL, ..., chainable = TRUE)

## S3 method for class 'chainable_piar_index'
as_index(x, ..., chainable = TRUE)

## S3 method for class 'direct_piar_index'
as_index(x, ..., chainable = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_index_+3A_x">x</code></td>
<td>
<p>An object to coerce into a price index.</p>
</td></tr>
<tr><td><code id="as_index_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="as_index_+3A_chainable">chainable</code></td>
<td>
<p>Are the index values in <code>x</code> period-over-period
indexes, suitable for a chained calculation (the default)? This should be
<code>FALSE</code> when <code>x</code> is a fixed-base (direct) index.</p>
</td></tr>
<tr><td><code id="as_index_+3A_cols">cols</code></td>
<td>
<p>Deprecated. A vector giving the positions/names of the period,
level, and value columns in <code>x</code>. The default assumes that the first column
contains time periods, the second contains levels, and the third contains
index values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numeric matrices are coerced into an index object by treating each column as
a separate time period, and each row as a separate level of the index (e.g.,
an elemental aggregate). Column names
are used to denote time periods, and row names are used to denote levels
(so they must be unique). This essentially reverses calling
<code><a href="#topic+as.matrix.piar_index">as.matrix()</a></code> on an index object. If a
dimension is unnamed, then it is given a sequential label from 1 to the size
of that dimension. The default method coerces <code>x</code> to a matrix prior to
using the matrix method.
</p>
<p>The data frame method for <code>as_index()</code> is best understood as reversing
the effect of <code><a href="#topic+as.data.frame.piar_index">as.data.frame()</a></code> on an
index object. It constructs a matrix by taking the levels of
<code>x[[1]]</code> as columns and the levels of <code>x[[2]]</code> as rows
(coercing to a factor if necessary). It then populates this matrix with the
corresponding values in <code>x[[3]]</code>, and uses the matrix method for
<code>as_index()</code>.
</p>
<p>If <code>x</code> is a period-over-period index then it is returned unchanged when
<code>chainable = TRUE</code> and chained otherwise. Similarly, if <code>x</code> is a
fixed-base index then it is returned unchanged when
<code>chainable = FALSE</code> and unchain otherwise.
</p>


<h3>Value</h3>

<p><code>as_index()</code> returns a price index that inherits from
<code><a href="#topic+piar_index">piar_index</a></code>. If <code>chainable = TRUE</code> then this is a
period-over-period price index that also inherits from
<code><a href="#topic+chainable_piar_index">chainable_piar_index</a></code>; otherwise, it is a fixed-base index that
inherits from <code><a href="#topic+direct_piar_index">direct_piar_index</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.piar_index">as.matrix()</a></code> and
<code><a href="#topic+as.data.frame.piar_index">as.data.frame()</a></code> for coercing an index
into a tabular form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- data.frame(
  rel = 1:8,
  period = rep(1:2, each = 4),
  ea = rep(letters[1:2], 4)
)

index &lt;- with(prices, elemental_index(rel, period, ea))

all.equal(as_index(as.data.frame(index)), index)
all.equal(as_index(as.matrix(index)), index)

</code></pre>

<hr>
<h2 id='as.data.frame.piar_index'>Coerce an index into a tabular form</h2><span id='topic+as.data.frame.piar_index'></span><span id='topic+as.matrix.piar_index'></span>

<h3>Description</h3>

<p>Turn an index into a data frame or a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
as.data.frame(x, ..., stringsAsFactors = FALSE)

## S3 method for class 'piar_index'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="as.data.frame.piar_index_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.data.frame()</code> returns a data frame with three columns: <code>period</code>, <code>level</code>,
and <code>value</code>.
</p>
<p><code>as.matrix()</code> returns a matrix with a row for each level and a column
for each time period.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_index">as_index()</a></code> to coerce a matrix/data frame of index values into an index
object.
</p>
<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- as_index(matrix(1:6, 2))

as.data.frame(index)
as.matrix(index)

</code></pre>

<hr>
<h2 id='as.matrix.piar_aggregation_structure'>Coerce an aggregation structure into a tabular form</h2><span id='topic+as.matrix.piar_aggregation_structure'></span><span id='topic+as.data.frame.piar_aggregation_structure'></span>

<h3>Description</h3>

<p>Coerce a price index aggregation structure into an aggregation matrix, or a
data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_aggregation_structure'
as.matrix(x, ..., sparse = FALSE)

## S3 method for class 'piar_aggregation_structure'
as.data.frame(x, ..., stringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.piar_aggregation_structure_+3A_x">x</code></td>
<td>
<p>A price index aggregation structure, as made by
<code><a href="#topic+aggregation_structure">aggregation_structure()</a></code>.</p>
</td></tr>
<tr><td><code id="as.matrix.piar_aggregation_structure_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="as.matrix.piar_aggregation_structure_+3A_sparse">sparse</code></td>
<td>
<p>Should the result be a sparse matrix from <span class="pkg">Matrix</span>? This
is faster for large aggregation structures. The default returns an ordinary
dense matrix.</p>
</td></tr>
<tr><td><code id="as.matrix.piar_aggregation_structure_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.matrix()</code> represents an aggregation structure as a matrix,
such that multiplying with a (column) vector of elemental indexes gives the
aggregated index.
</p>
<p><code>as.data.frame()</code> takes an aggregation structure and returns a data
frame that could have generated it, with columns <code>level1</code>,
<code>level2</code>, ..., <code>ea</code>, and <code>weight</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_aggregation_structure">as_aggregation_structure()</a></code> for coercing into an aggregation structure.
</p>
<p>Other aggregation structure methods: 
<code><a href="#topic+levels.piar_aggregation_structure">levels.piar_aggregation_structure</a>()</code>,
<code><a href="#topic+update.piar_aggregation_structure">update.piar_aggregation_structure</a>()</code>,
<code><a href="#topic+weights.piar_aggregation_structure">weights.piar_aggregation_structure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple aggregation structure
#            1
#      |-----+-----|
#      11          12
#  |---+---|       |
#  111     112     121
#  (1)     (3)     (4)

aggregation_weights &lt;- data.frame(
  level1 = c("1", "1", "1"),
  level2 = c("11", "11", "12"),
  ea     = c("111", "112", "121"),
  weight = c(1, 3, 4)
)

pias &lt;- as_aggregation_structure(aggregation_weights)

as.matrix(pias)

all.equal(as.data.frame(pias), aggregation_weights)

</code></pre>

<hr>
<h2 id='chain'>Chain and rebase a price index</h2><span id='topic+chain'></span><span id='topic+chain.default'></span><span id='topic+chain.chainable_piar_index'></span><span id='topic+unchain'></span><span id='topic+unchain.default'></span><span id='topic+unchain.direct_piar_index'></span><span id='topic+rebase'></span><span id='topic+rebase.default'></span><span id='topic+rebase.direct_piar_index'></span>

<h3>Description</h3>

<p>Chain a period-over-period index by taking the cumulative product of its
values to turn it into a fixed-base (direct) index.
</p>
<p>Unchain a fixed-base index by dividing its values for successive periods to
get a period-over-period index.
</p>
<p>Rebase a fixed-base index by dividing its values with the value of the index
in the new base period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain(x, ...)

## Default S3 method:
chain(x, ...)

## S3 method for class 'chainable_piar_index'
chain(x, link = rep(1, nlevels(x)), ...)

unchain(x, ...)

## Default S3 method:
unchain(x, ...)

## S3 method for class 'direct_piar_index'
unchain(x, ...)

rebase(x, ...)

## Default S3 method:
rebase(x, ...)

## S3 method for class 'direct_piar_index'
rebase(x, base = rep(1, nlevels(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="chain_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="chain_+3A_link">link</code></td>
<td>
<p>A numeric vector, or something that can coerced into one, of
link values for each level in <code>x</code>. The default is a vector of 1s so
that no linking is done.</p>
</td></tr>
<tr><td><code id="chain_+3A_base">base</code></td>
<td>
<p>A numeric vector, or something that can coerced into one, of
base-period index values for each level in <code>x</code>. The default is a vector
of 1s so that the base period remains the same.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default methods attempt to coerce <code>x</code> into an index with
<code><a href="#topic+as_index">as_index()</a></code> prior to chaining/unchaining/rebasing.
</p>
<p>Chaining an index takes the cumulative product of the index values for each
level; this is roughly the same as
<code>t(apply(as.matrix(x), 1, cumprod)) * link</code>. Unchaining does the opposite,
so these are inverse operations. Note that unchaining a period-over-period
index does nothing, as does chaining a fixed-base index.
</p>
<p>Rebasing a fixed-base index divides the values for each level of this index
by the corresponding values for each level in the new base period. It's
roughly the same as <code>as.matrix(x) / base</code>. Like unchaining, rebasing a
period-over-period index does nothing.
</p>
<p>Percent-change contributions are removed when chaining/unchaining/rebasing
an index, as it's not usually possible to update them correctly.
</p>


<h3>Value</h3>

<p><code>chain()</code> and <code>rebase()</code> return a fixed-base index that inherits
from <code><a href="#topic+direct_piar_index">direct_piar_index</a></code>.
</p>
<p><code>unchain()</code> returns a period-over-period index that inherits from
<code><a href="#topic+chainable_piar_index">chainable_piar_index</a></code>.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- as_index(matrix(1:9, 3))

# Make period 0 the fixed base period

chain(index)

# Chaining and unchaining reverse each other

all.equal(index, unchain(chain(index)))

# Change the base period to period 2 (note the
# loss of information for period 0)

index &lt;- chain(index)
rebase(index, index[, 2])

</code></pre>

<hr>
<h2 id='contrib'>Extract percent-change contributions</h2><span id='topic+contrib'></span><span id='topic+contrib.piar_index'></span>

<h3>Description</h3>

<p>Extract a matrix of percent-change contributions from a price index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contrib(x, ...)

## S3 method for class 'piar_index'
contrib(x, level = levels(x)[1L], period = time(x), ..., pad = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contrib_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="contrib_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="contrib_+3A_level">level</code></td>
<td>
<p>The level of an index for which percent-change contributions
are desired, defaulting to the first level (usually the top-level for an
aggregate index).</p>
</td></tr>
<tr><td><code id="contrib_+3A_period">period</code></td>
<td>
<p>The time periods for which percent-change contributions are
desired, defaulting to all time periods.</p>
</td></tr>
<tr><td><code id="contrib_+3A_pad">pad</code></td>
<td>
<p>A numeric value to pad contributions so that they fit into a
rectangular array when products differ over time. The default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of percent-change contributions with a column for each
<code>period</code> and a row for each product (sorted) for which there are
contributions in <code>level</code>. Contributions are padded with <code>pad</code> to fit into a
rectangular array when products differ over time.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- data.frame(
  rel = 1:8,
  period = rep(1:2, each = 4),
  ea = rep(letters[1:2], 4)
)

index &lt;- with(
  prices,
  elemental_index(rel, period, ea, contrib = TRUE)
)

pias &lt;- aggregation_structure(
  list(c("top", "top", "top"), c("a", "b", "c")), 1:3
)

index &lt;- aggregate(index, pias, na.rm = TRUE)

# Percent-change contributions for the top-level index

contrib(index)

# Calculate EA contributions for the chained index

library(gpindex)

arithmetic_contributions(
  as.matrix(chain(index))[c("a", "b", "c"), 2],
  weights(pias)
)

</code></pre>

<hr>
<h2 id='elemental_index'>Make elemental price indexes</h2><span id='topic+elemental_index'></span><span id='topic+elemental_index.default'></span><span id='topic+elemental_index.numeric'></span>

<h3>Description</h3>

<p>Compute period-over-period (chainable) or fixed-base (direct) elemental
price indexes, with optional percent-change contributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elemental_index(x, ...)

## Default S3 method:
elemental_index(x, ...)

## S3 method for class 'numeric'
elemental_index(
  x,
  period = gl(1, length(x)),
  ea = gl(1, length(x)),
  weights = NULL,
  ...,
  chainable = TRUE,
  na.rm = FALSE,
  contrib = FALSE,
  r = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elemental_index_+3A_x">x</code></td>
<td>
<p>Period-over-period or fixed-base price relatives. Currently there
is only a method for numeric vectors; these can be made with
<code><a href="#topic+price_relative">price_relative()</a></code>.</p>
</td></tr>
<tr><td><code id="elemental_index_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="elemental_index_+3A_period">period</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the time period associated with each price relative in <code>x</code>. The
ordering of time periods follows of the levels of <code>period</code>, to agree
with <code><a href="base.html#topic+cut.Date">cut()</a></code>. The default assumes that all price
relatives belong to one time period.</p>
</td></tr>
<tr><td><code id="elemental_index_+3A_ea">ea</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving the
elemental aggregate associated with each price relative in <code>x</code>. The
default assumes that all price relatives belong to one elemental aggregate.</p>
</td></tr>
<tr><td><code id="elemental_index_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights for the price relatives in <code>x</code>,
or something that can be coerced into one. The default is equal weights.</p>
</td></tr>
<tr><td><code id="elemental_index_+3A_chainable">chainable</code></td>
<td>
<p>Are the price relatives in <code>x</code> period-over-period
relatives that are suitable for a chained calculation (the default)? This
should be <code>FALSE</code> when <code>x</code> contains fixed-base relatives.</p>
</td></tr>
<tr><td><code id="elemental_index_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed? By default, missing values
are not removed. Setting <code>na.rm = TRUE</code> is equivalent to overall mean
imputation.</p>
</td></tr>
<tr><td><code id="elemental_index_+3A_contrib">contrib</code></td>
<td>
<p>Should percent-change contributions be calculated? The
default does not calculate contributions.</p>
</td></tr>
<tr><td><code id="elemental_index_+3A_r">r</code></td>
<td>
<p>Order of the generalized mean to aggregate price relatives. 0 for a
geometric index (the default for making elemental indexes), 1 for an
arithmetic index (the default for aggregating elemental indexes and
averaging indexes over subperiods), or -1 for a harmonic index (usually for
a Paasche index). Other values are possible; see
<code><a href="gpindex.html#topic+generalized_mean">gpindex::generalized_mean()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When supplied with a numeric vector, <code>elemental_index()</code> is a simple
wrapper that applies
<code><a href="gpindex.html#topic+generalized_mean">gpindex::generalized_mean(r)()</a></code> and
<code><a href="gpindex.html#topic+contributions">gpindex::contributions(r)()</a></code> (if <code>contrib = TRUE</code>)
to <code>x</code> and <code>weights</code> grouped by <code>ea</code> and <code>period</code>. That
is, for every combination of elemental aggregate and time period,
<code>elemental_index()</code> calculates an index based on a generalized mean of
order <code>r</code> and, optionally, percent-change contributions. The default
(<code>r = 0</code> and no weights) makes Jevons elemental indexes. See chapter 8
(pp. 175&ndash;190) of the CPI manual (2020) for more detail about making
elemental indexes, and chapter 5 of Balk (2008).
</p>
<p>The default method simply coerces <code>x</code> to a numeric vector prior to
calling the method above.
</p>
<p>Names for <code>x</code> are used as product names when calculating percent-change
contributions. Product names should be unique within each time period, and,
if not, are passed to <code><a href="base.html#topic+make.unique">make.unique()</a></code> with a
warning. If <code>x</code> has no names then elements of <code>x</code> are given
sequential names within each elemental aggregate.
</p>
<p>The interpretation of the index depends on how the price relatives in
<code>x</code> are made. If these are period-over-period relatives, then the
result is a collection of period-over-period (chainable) elemental indexes;
if these are fixed-base relatives, then the result is a collection of
fixed-base (direct) elemental indexes. For the latter, <code>chainable</code>
should be set to <code>FALSE</code> so that no subsequent methods assume that a
chained calculation should be used.
</p>
<p>By default, missing price relatives in <code>x</code> will propagate throughout
the index calculation. Ignoring missing values with <code>na.rm = TRUE</code> is
the same as overall mean (parental) imputation, and needs to be explicitly
set in the call to <code>elemental_index()</code>. Explicit imputation of missing
relatives, and especially imputation of missing prices, should be done prior
to calling <code>elemental_index()</code>.
</p>
<p>Indexes based on nested generalized means, like the Fisher index (and
superlative quadratic mean indexes more generally), can be calculated by
supplying the appropriate weights with <code><a href="gpindex.html#topic+transmute_weights">gpindex::nested_transmute()</a></code>; see the
example below. It is important to note that there are several ways to
make these weights, and this affects how percent-change contributions
are calculated.
</p>


<h3>Value</h3>

<p>A price index that inherits from <code><a href="#topic+piar_index">piar_index</a></code>. If
<code>chainable = TRUE</code> then this is a period-over-period index that also
inherits from <code><a href="#topic+chainable_piar_index">chainable_piar_index</a></code>; otherwise, it is a
fixed-based index that inherits from <code><a href="#topic+direct_piar_index">direct_piar_index</a></code>.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2020).
<em>Consumer Price Index Manual: Theory and Practice</em>.
International Monetary Fund.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+price_relative">price_relative()</a></code> for making price relatives for the same products over
time, and <code><a href="#topic+carry_forward">carry_forward()</a></code> and <code><a href="#topic+shadow_price">shadow_price()</a></code> for
imputation of missing prices.
</p>
<p><code><a href="#topic+as_index">as_index()</a></code> to turn pre-computed (elemental) index values into an
index object.
</p>
<p><code><a href="#topic+chain">chain()</a></code> for chaining period-over-period indexes, and
<code><a href="#topic+rebase">rebase()</a></code> for rebasing an index.
</p>
<p><code><a href="#topic+aggregate.piar_index">aggregate()</a></code> to aggregate elemental indexes
according to an aggregation structure.
</p>
<p><code><a href="#topic+as.matrix.piar_index">as.matrix()</a></code> and
<code><a href="#topic+as.data.frame.piar_index">as.data.frame()</a></code> for coercing an index
into a tabular form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gpindex)

prices &lt;- data.frame(
  rel = 1:8,
  period = rep(1:2, each = 4),
  ea = rep(letters[1:2], 4)
)

# Calculate Jevons elemental indexes

with(prices, elemental_index(rel, period, ea))

# Same as using lm() or tapply()

exp(coef(lm(log(rel) ~ ea:factor(period) - 1, prices)))

with(
  prices,
  t(tapply(rel, list(period, ea), geometric_mean, na.rm = TRUE))
)

# A general function to calculate weights to turn the geometric
# mean of the arithmetic and harmonic mean (i.e., Fisher mean)
# into an arithmetic mean

fw &lt;- grouped(nested_transmute(0, c(1, -1), 1))

# Calculate a CSWD index (same as the Jevons in this example)
# as an arithmetic index by using the appropriate weights

with(
  prices,
  elemental_index(
    rel, period, ea,
    fw(rel, group = interaction(period, ea)),
    r = 1
  )
)

</code></pre>

<hr>
<h2 id='expand_classification'>Expand a hierarchical classification</h2><span id='topic+expand_classification'></span>

<h3>Description</h3>

<p>Expand a character representation of a hierarchical classification to make a
price index aggregation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_classification(x, width = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_classification_+3A_x">x</code></td>
<td>
<p>A character vector, or something that can be coerced into one, of
codes/labels for a specific level in a classification (e.g., 5-digit COICOP,
5-digit NAICS, 4-digit SIC).</p>
</td></tr>
<tr><td><code id="expand_classification_+3A_width">width</code></td>
<td>
<p>An integer vector that gives the width of each digit in
<code>x</code>. A single value is recycled to span the longest element in
<code>x</code>. This cannot contain NAs. The default assumes each digit has a
width of 1, as in the NAICS, NAPCS, and SIC classifications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a entry for each level in <code>x</code> giving the &quot;digits&quot;
that represent each level in the hierarchy.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregation_structure">aggregation_structure()</a></code> to make a price-index aggregation structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple classification structure
#            1
#      |-----+-----|
#      11          12
#  |---+---|       |
#  111     112     121

expand_classification(c("111", "112", "121"))

# Expanding more complex classifications
# ... if last 'digit' is either TA or TS

expand_classification(
  c("111TA", "112TA", "121TS"),
  width = c(1, 1, 1, 2)
)

# ... if first 'digit' is either 11 or 12

expand_classification(c("111", "112", "121"), width = c(2, 1))

# ...if there are delimiters in the classification (like COICOP)

expand_classification(c("01.1.1", "01.1.2", "01.2.1"), width = 2)

</code></pre>

<hr>
<h2 id='head.piar_index'>Return the first/last parts of an index</h2><span id='topic+head.piar_index'></span><span id='topic+tail.piar_index'></span>

<h3>Description</h3>

<p>Extract the first/last parts of an index as if it were a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
head(x, n = 6L, ...)

## S3 method for class 'piar_index'
tail(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="head.piar_index_+3A_n">n</code></td>
<td>
<p>See <code><a href="utils.html#topic+head">head()</a></code>/<code><a href="utils.html#topic+tail">tail()</a></code>. The default takes the
first/last 6 levels of <code>x</code>.</p>
</td></tr>
<tr><td><code id="head.piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A price index that inherits from <code><a href="#topic+chainable_piar_index">chainable_piar_index</a></code> if <code>x</code> is a
period-over-period index, or <code>direct_piar_index()</code> if <code>x</code> is a
fixed-base index.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- as_index(matrix(1:9, 3))

head(index, 1)

tail(index, 1)

</code></pre>

<hr>
<h2 id='impute_prices'>Impute missing prices</h2><span id='topic+impute_prices'></span><span id='topic+shadow_price'></span><span id='topic+carry_forward'></span><span id='topic+carry_backwards'></span>

<h3>Description</h3>

<p>Impute missing prices using the carry forward or shadow price method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shadow_price(
  x,
  period,
  product,
  ea,
  pias = NULL,
  weights = NULL,
  r1 = 0,
  r2 = 1
)

carry_forward(x, period, product)

carry_backwards(x, period, product)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_prices_+3A_x">x</code></td>
<td>
<p>A numeric vector of prices, or something that can be coerced
into one.</p>
</td></tr>
<tr><td><code id="impute_prices_+3A_period">period</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the time period associated with each price in <code>x</code>. The ordering of time
periods follows of the levels of <code>period</code>, to agree with
<code><a href="base.html#topic+cut.Date">cut()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_prices_+3A_product">product</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the product associated with each price in <code>x</code>.</p>
</td></tr>
<tr><td><code id="impute_prices_+3A_ea">ea</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving the
elemental aggregate associated with each price in <code>x</code>.</p>
</td></tr>
<tr><td><code id="impute_prices_+3A_pias">pias</code></td>
<td>
<p>A price index aggregation structure, or something that can be
coerced into one, as made with <code><a href="#topic+aggregation_structure">aggregation_structure()</a></code>. The default
imputes from elemental indexes only (i.e., not recursively).</p>
</td></tr>
<tr><td><code id="impute_prices_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights for the prices in <code>x</code> (i.e.,
product weights), or something that can be coerced into one. The default is
to give each price equal weight.</p>
</td></tr>
<tr><td><code id="impute_prices_+3A_r1">r1</code></td>
<td>
<p>Order of the generalized-mean price index used to calculate the
elemental price indexes: 0 for a geometric index (the default), 1 for an
arithmetic index, or -1 for a harmonic index. Other values are possible; see
<code><a href="gpindex.html#topic+generalized_mean">gpindex::generalized_mean()</a></code> for details.</p>
</td></tr>
<tr><td><code id="impute_prices_+3A_r2">r2</code></td>
<td>
<p>Order of the generalized-mean price index used to aggregate the
elemental price indexes: 0 for a geometric index, 1 for an arithmetic index
(the default), or -1 for a harmonic index. Other values are possible; see
<code><a href="gpindex.html#topic+generalized_mean">gpindex::generalized_mean()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The carry forward method replaces a missing price for a product by the price
for the same product in the previous period. It tends to push an index value
towards 1, and is usually avoided; see paragraph 6.61 in the CPI manual
(2020). The carry backwards method does the opposite, but this is rarely
used in practice.
</p>
<p>The shadow price method recursively imputes a missing price by the value of
the price for the same product in the previous period multiplied by the
value of the period-over-period elemental index for the elemental aggregate
to which that product belongs. This requires computing and aggregating an
index (according to <code>pias</code>, unless <code>pias</code> is not supplied) for
each <code>period</code>, and so these imputations can take a while. The index
values used to do the imputations are not returned because the index needs
to be recalculated to get correct percent-change contributions.
</p>
<p>Shadow price imputation is referred to as self-correcting overall mean
imputation in chapter 6 of the CPI manual (2020). It is identical to simply
excluding missing price relatives in the index calculation, except in the
period that a missing product returns. For this reason care is needed when
using this method. It is sensitive to the assumption that a product does not
change over time, and in some cases it is safer to simply omit the missing
price relatives instead of imputing the missing prices.
</p>


<h3>Value</h3>

<p>A copy of <code>x</code> with missing values replaced (where possible).
</p>


<h3>References</h3>

<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2020).
<em>Consumer Price Index Manual: Theory and Practice</em>. International
Monetary Fund.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+price_relative">price_relative()</a></code> for making price relatives for the
same products over time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- data.frame(
  price = c(1:7, NA),
  period = rep(1:2, each = 4),
  product = 1:4,
  ea = rep(letters[1:2], 4)
)

with(prices, carry_forward(price, period, product))

with(prices, shadow_price(price, period, product, ea))

</code></pre>

<hr>
<h2 id='is_aggregation_structure'>Test if an object is an aggregation structure</h2><span id='topic+is_aggregation_structure'></span>

<h3>Description</h3>

<p>Test if an object is a price index aggregation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_aggregation_structure(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_aggregation_structure_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> inherits from <code><a href="#topic+piar_aggregation_structure">piar_aggregation_structure</a></code>.
</p>

<hr>
<h2 id='is_index'>Test if an object is a price index</h2><span id='topic+is_index'></span><span id='topic+is_aggregate_index'></span><span id='topic+is_chainable_index'></span><span id='topic+is_direct_index'></span>

<h3>Description</h3>

<p>Test if an object is a index object, or a subclass of an index object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_index(x)

is_aggregate_index(x)

is_chainable_index(x)

is_direct_index(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_index_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_index()</code> returns <code>TRUE</code> if <code>x</code> inherits from <code><a href="#topic+piar_index">piar_index</a></code>.
</p>
<p><code>is_chainable_index()</code> returns <code>TRUE</code> if <code>x</code> inherits from
<code><a href="#topic+chainable_piar_index">chainable_piar_index</a></code>.
</p>
<p><code>is_direct_index()</code> returns <code>TRUE</code> if <code>x</code> inherits from
<code><a href="#topic+direct_piar_index">direct_piar_index</a></code>.
</p>
<p><code>is_aggregate_index()</code> returns <code>TRUE</code> if <code>x</code> inherits from
<code><a href="#topic+aggregate_piar_index">aggregate_piar_index</a></code>.
</p>

<hr>
<h2 id='is.na.piar_index'>Missing values in a price index</h2><span id='topic+is.na.piar_index'></span><span id='topic+anyNA.piar_index'></span>

<h3>Description</h3>

<p>Identify missing values in a price index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
is.na(x)

## S3 method for class 'piar_index'
anyNA(x, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.na.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="is.na.piar_index_+3A_recursive">recursive</code></td>
<td>
<p>Check if <code>x</code> also has missing percent-change
contributions. By default only index values are checked for missingness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.na()</code> returns a logical matrix, with a row for each level of <code>x</code> and a
columns for each time period, that indicates which index values are missing.
</p>
<p><code>anyNA()</code> returns <code>TRUE</code> if any index values are missing, or percent-change
contributions (if <code>recursive = TRUE</code>).
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- as_index(matrix(c(1, 2, 3, NA, 5, NA), 2))

anyNA(index)
is.na(index)

# Carry forward imputation

index[is.na(index)] &lt;- 1
index

</code></pre>

<hr>
<h2 id='levels.piar_aggregation_structure'>Get the levels for an aggregation structure</h2><span id='topic+levels.piar_aggregation_structure'></span>

<h3>Description</h3>

<p>Get the hierarchical list of levels for an aggregation structure. It is
an error to try and replace these values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_aggregation_structure'
levels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levels.piar_aggregation_structure_+3A_x">x</code></td>
<td>
<p>A price index aggregation structure, as made by
<code><a href="#topic+aggregation_structure">aggregation_structure()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors giving the levels for each position in the
aggregation structure.
</p>


<h3>See Also</h3>

<p>Other aggregation structure methods: 
<code><a href="#topic+as.matrix.piar_aggregation_structure">as.matrix.piar_aggregation_structure</a>()</code>,
<code><a href="#topic+update.piar_aggregation_structure">update.piar_aggregation_structure</a>()</code>,
<code><a href="#topic+weights.piar_aggregation_structure">weights.piar_aggregation_structure</a>()</code>
</p>

<hr>
<h2 id='levels.piar_index'>Get the levels for a price index</h2><span id='topic+levels.piar_index'></span><span id='topic+levels+3C-.piar_index'></span>

<h3>Description</h3>

<p>Methods to get and set the levels for a price index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
levels(x)

## S3 replacement method for class 'piar_index'
levels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levels.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="levels.piar_index_+3A_value">value</code></td>
<td>
<p>A character vector, or something that can be coerced into one,
giving the replacement levels for <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>levels()</code> returns a character vector with the levels for a price index.
</p>
<p>The replacement method returns a copy of <code>x</code> with the levels in <code>value</code>.
</p>
<p>It's not generally possible to change the levels of an aggregate price
index, and in this case replacing the levels does not return an aggregate
index.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>

<hr>
<h2 id='mean.piar_index'>Aggregate a price index over subperiods</h2><span id='topic+mean.piar_index'></span>

<h3>Description</h3>

<p>Aggregate an index over subperiods by taking the (usually arithmetic) mean
of index values over consecutive windows of subperiods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
mean(x, weights = NULL, ..., window = 3L, na.rm = FALSE, contrib = TRUE, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="mean.piar_index_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights for the index values in <code>x</code>, or
something that can be coerced into one. The
default is equal weights. It is usually easiest to specify these weights as
a matrix with a row for each index value in <code>x</code> and a column for each
time period.</p>
</td></tr>
<tr><td><code id="mean.piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="mean.piar_index_+3A_window">window</code></td>
<td>
<p>A positive integer giving the size of the window used to
average index values across subperiods. The default (3) turns a monthly
index into into a quarterly one. Non-integers are truncated towards 0.</p>
</td></tr>
<tr><td><code id="mean.piar_index_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed? By default, missing values
are not removed. Setting <code>na.rm = TRUE</code> is equivalent to overall mean
imputation.</p>
</td></tr>
<tr><td><code id="mean.piar_index_+3A_contrib">contrib</code></td>
<td>
<p>Aggregate percent-change contributions in <code>x</code> (if any)?</p>
</td></tr>
<tr><td><code id="mean.piar_index_+3A_r">r</code></td>
<td>
<p>Order of the generalized mean to aggregate index values. 0 for a
geometric index (the default for making elemental indexes), 1 for an
arithmetic index (the default for aggregating elemental indexes and
averaging indexes over subperiods), or -1 for a harmonic index (usually for
a Paasche index). Other values are possible; see
<code><a href="gpindex.html#topic+generalized_mean">gpindex::generalized_mean()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mean()</code> method constructs a set of non-overlapping windows of
length <code>window</code>, starting in the first period of the index, and takes
the mean of each index value in these windows for each level of the index.
The last window is discarded if it is incomplete (with a warning), so that
index values are
always averaged over <code>window</code> periods. The names for the first time
period in each window form the new names for the aggregated time periods.
</p>
<p>Percent-change contributions are aggregated if <code>contrib = TRUE</code> by treating
each product-subperiod pair as a unique product, then following the same
approach as <code><a href="#topic+aggregate.piar_index">aggregate()</a></code>. The number of the
subperiod is appended to product names to make them unique across subperiods.
</p>
<p>An optional vector of weights can be specified when aggregating index values
over subperiods, which is often useful when aggregating a Paasche index; see
section 4.3 of Balk (2008) for details.
</p>


<h3>Value</h3>

<p>A price index with the same class as <code>x</code>. If <code>x</code> is an aggregate index
and <code>r</code> is different than that used to aggregate <code>x</code>, then the result is
not an aggregate index (as it is no longer consistent in aggregation).
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- as_index(matrix(c(1:12, 12:1), 2, byrow = TRUE))

mean(index)

</code></pre>

<hr>
<h2 id='merge.piar_index'>Merge price indexes</h2><span id='topic+merge.piar_index'></span>

<h3>Description</h3>

<p>Combine two price indexes with common time periods, merging together the
index values and percent-change contributions for each time period.
</p>
<p>This is useful for building up an index when different elemental aggregates
come from different sources of data, or use different index-number formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="merge.piar_index_+3A_y">y</code></td>
<td>
<p>A price index, or something that can coerced into one. If <code>x</code>
is a period-over-period index then <code>y</code> is coerced into a chainable
index; otherwise, <code>y</code> is coerced into a direct index.</p>
</td></tr>
<tr><td><code id="merge.piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A price index that inherits from <code><a href="#topic+chainable_piar_index">chainable_piar_index</a></code> if <code>x</code> is a
period-over-period index, or <code><a href="#topic+direct_piar_index">direct_piar_index</a></code> if <code>x</code> is a fixed-base
index. It is not generally possible to merge aggregated indexes, as this
would change the aggregation structure, so merging does not return an
aggregated index.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index1 &lt;- as_index(matrix(1:6, 2))

index2 &lt;- index1
levels(index2) &lt;- 3:4

merge(index1, index2)

</code></pre>

<hr>
<h2 id='piar_index'>Price index objects</h2><span id='topic+piar_index'></span><span id='topic+chainable_piar_index'></span><span id='topic+direct_piar_index'></span><span id='topic+aggregate_piar_index'></span>

<h3>Description</h3>

<p>There are several classes to represent price indexes.
</p>

<ul>
<li><p> All indexes inherit from the <code>piar_index</code> virtual class.
</p>
</li>
<li><p> Period-over-period indexes that can be chained over time inherit from
<code>chainable_piar_index</code>.
</p>
</li>
<li><p> Fixed-base indexes inherit from <code>direct_piar_index</code>.
</p>
</li>
<li><p> Aggregate price indexes that are the result of aggregating elemental
indexes with an aggregation structure further inherit from
<code>aggregate_piar_index</code>.
</p>
</li></ul>



<h3>Details</h3>

<p>The <code>piar_index</code> object is a list-S3 class with the following
components:
</p>

<dl>
<dt>index</dt><dd><p>A list with an entry for each period in <code>time</code> that gives
a vector of index values for each level in <code>levels</code>.</p>
</dd>
<dt>contrib</dt><dd><p>A list with an entry for each period in <code>time</code>, which
itself contains a list with an entry for each level in <code>levels</code> with
a named vector that gives the additive contribution for each price relative.</p>
</dd>
<dt>levels</dt><dd><p>A character vector giving the levels of the index.</p>
</dd>
<dt>time</dt><dd><p>A character vector giving the time periods for the index.</p>
</dd>
</dl>

<p>The <code>chainable_piar_index</code> and <code>direct_piar_index</code> subclasses have
the same structure as the <code>piar_index</code> class, but differ in the methods
used to manipulate the indexes.
</p>
<p>The <code>aggregate_piar_index</code> class further subclasses either
<code>chainable_piar_index</code> or <code>direct_piar_index</code>, and adds the
following components:
</p>

<dl>
<dt>r</dt><dd><p>The order of the generalized mean used to aggregated the
index (usually 1).</p>
</dd>
<dt>pias</dt><dd><p>A list containing the <code>child</code>, <code>parent</code>, and <code>levels</code>
components of the aggregation structured used to aggregate the index.</p>
</dd>
</dl>


<hr>
<h2 id='piar-package'>piar: Price Index Aggregation</h2><span id='topic+piar'></span><span id='topic+piar-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Most price indexes are made with a two-step procedure, where period-over-period elemental indexes are first calculated for a collection of elemental aggregates at each point in time, and then aggregated according to a price index aggregation structure. These indexes can then be chained together to form a time series that gives the evolution of prices with respect to a fixed base period. This package contains a collections of functions that revolve around this work flow, making it easy to build standard price indexes, and implement the methods described by Balk (2008, ISBN:978-1-107-40496-0), von der Lippe (2001, ISBN:3-8246-0638-0), and the CPI manual (2020, ISBN:978-1-51354-298-0) for bilateral price indexes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Steve Martin <a href="mailto:marberts@protonmail.com">marberts@protonmail.com</a> (<a href="https://orcid.org/0000-0003-2544-9480">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://marberts.github.io/piar/">https://marberts.github.io/piar/</a>
</p>
</li>
<li> <p><a href="https://github.com/marberts/piar">https://github.com/marberts/piar</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/marberts/piar/issues">https://github.com/marberts/piar/issues</a>
</p>
</li></ul>


<hr>
<h2 id='price_data'>Price data</h2><span id='topic+price_data'></span><span id='topic+ms_prices'></span><span id='topic+ms_weights'></span><span id='topic+fs_prices'></span><span id='topic+fs_weights'></span>

<h3>Description</h3>

<p>Sample price and weight data for both a match sample and fixed sample type
index.
</p>

<hr>
<h2 id='price_relative'>Calculate period-over-period price relatives</h2><span id='topic+price_relative'></span>

<h3>Description</h3>

<p>Construct period-over-period price relatives from information on prices and
products over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price_relative(x, period, product)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price_relative_+3A_x">x</code></td>
<td>
<p>A numeric vector of prices.</p>
</td></tr>
<tr><td><code id="price_relative_+3A_period">period</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the corresponding time period for each element in <code>x</code>. The
ordering of time periods follows the levels of <code>period</code> to agree with
<code><a href="base.html#topic+cut.Date">cut()</a></code>.</p>
</td></tr>
<tr><td><code id="price_relative_+3A_product">product</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the corresponding product identifier for each element in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of price relatives, with <code>product</code> as names.
</p>


<h3>See Also</h3>

<p><code><a href="gpindex.html#topic+back_period">gpindex::back_period()</a></code> to get only the back price.
</p>
<p><code><a href="gpindex.html#topic+back_period">gpindex::base_period()</a></code> for making fixed-base price relatives.
</p>
<p><code><a href="#topic+carry_forward">carry_forward()</a></code> and <code><a href="#topic+shadow_price">shadow_price()</a></code> to impute missing prices.
</p>
<p><code><a href="gpindex.html#topic+outliers">gpindex::outliers</a></code> for methods to identify outliers with price relatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>price_relative(1:6, rep(1:2, each = 3), rep(letters[1:3], 2))

</code></pre>

<hr>
<h2 id='split.piar_index'>Split an index into groups</h2><span id='topic+split.piar_index'></span><span id='topic+split+3C-.piar_index'></span>

<h3>Description</h3>

<p>Split an index into groups of indexes according to a factor, along either
the levels or time periods of the index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
split(x, f, drop = FALSE, ..., margin = c("levels", "time"))

## S3 replacement method for class 'piar_index'
split(x, f, drop = FALSE, ..., margin = c("levels", "time")) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="split.piar_index_+3A_f">f</code></td>
<td>
<p>A factor or list of factors to group elements of <code>x</code>.</p>
</td></tr>
<tr><td><code id="split.piar_index_+3A_drop">drop</code></td>
<td>
<p>Should levels that do not occur in <code>f</code> be dropped? By default
all levels are kept.</p>
</td></tr>
<tr><td><code id="split.piar_index_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+split.default">split.default()</a></code>.</p>
</td></tr>
<tr><td><code id="split.piar_index_+3A_margin">margin</code></td>
<td>
<p>Either 'levels' to split over the levels of <code>x</code> (the default),
or 'time' to split over the time periods of <code>x</code>.</p>
</td></tr>
<tr><td><code id="split.piar_index_+3A_value">value</code></td>
<td>
<p>A list of values compatible with the splitting of <code>x</code>, recycled
if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>split()</code> returns a list of index objects for each level in <code>f</code>. The
replacement method replaces these values with the corresponding element of
<code>value</code>.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- as_index(matrix(1:6, 2))

split(index, 1:2)

split(index, c(1, 1, 2), margin = "time")

</code></pre>

<hr>
<h2 id='stack.piar_index'>Stack price indexes</h2><span id='topic+stack.piar_index'></span><span id='topic+unstack.piar_index'></span>

<h3>Description</h3>

<p><code>stack()</code> combines two price indexes with common levels, stacking index
values and percent-change contributions for one index after the other.
</p>
<p><code>unstack()</code> breaks up a price index into a list of indexes for each
time period.
</p>
<p>These methods can be used in a map-reduce to make an index with multiple
aggregation structures (like a Paasche index).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
stack(x, y, ...)

## S3 method for class 'piar_index'
unstack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="stack.piar_index_+3A_y">y</code></td>
<td>
<p>A price index, or something that can coerced into one. If <code>x</code>
is a period-over-period index then <code>y</code> is coerced into a chainable
index; otherwise, <code>y</code> is coerced into a direct index.</p>
</td></tr>
<tr><td><code id="stack.piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A price index that inherits from <code><a href="#topic+chainable_piar_index">chainable_piar_index</a></code> if <code>x</code> is a
period-over-period index, or <code><a href="#topic+direct_piar_index">direct_piar_index</a></code> if <code>x</code> is a fixed-base
index. If both <code>x</code> and <code>y</code> are aggregate indexes then the result will also
inherit from <code><a href="#topic+aggregate_piar_index">aggregate_piar_index</a></code>.
</p>
<p><code>unstack()</code> returns a list of price indexes with the same class as <code>x</code>.
</p>


<h3>Note</h3>

<p>It may be necessary to use <code>rebase()</code> prior to stacking fixed-based price
indexes to ensure they have the same base period.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index1 &lt;- as_index(matrix(1:6, 2))

index2 &lt;- index1
time(index2) &lt;- 4:6

stack(index1, index2)

# Unstack does the reverse

all.equal(
  c(unstack(index1), unstack(index2)),
  unstack(stack(index1, index2))
)

</code></pre>

<hr>
<h2 id='summary.piar_index'>Summarize a price index</h2><span id='topic+summary.piar_index'></span>

<h3>Description</h3>

<p>Summarize an index as a matrix of index values (i.e., the five-number
summary for each period). If there are percent-change contributions, then
these are also summarized as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.piar_index_+3A_object">object</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.piar_index_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+summary.matrix">summary.matrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of five-number summaries.
</p>


<h3>Note</h3>

<p>This function is still experimental and may change in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- data.frame(
  rel = 1:8,
  period = rep(1:2, each = 4),
  ea = rep(letters[1:2], 4),
  contrib = TRUE
)

elemental &lt;- with(prices, elemental_index(rel, period, ea))

summary(elemental)

</code></pre>

<hr>
<h2 id='time.piar_index'>Get the time periods for a price index</h2><span id='topic+time.piar_index'></span><span id='topic+time+3C-'></span><span id='topic+time+3C-.piar_index'></span><span id='topic+start.piar_index'></span><span id='topic+end.piar_index'></span>

<h3>Description</h3>

<p>Methods to get and set the time periods for a price index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_index'
time(x, ...)

time(x) &lt;- value

## S3 replacement method for class 'piar_index'
time(x) &lt;- value

## S3 method for class 'piar_index'
start(x, ...)

## S3 method for class 'piar_index'
end(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time.piar_index_+3A_x">x</code></td>
<td>
<p>A price index, as made by, e.g., <code><a href="#topic+elemental_index">elemental_index()</a></code>.</p>
</td></tr>
<tr><td><code id="time.piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="time.piar_index_+3A_value">value</code></td>
<td>
<p>A character vector, or something that can be coerced into one,
giving the replacement time periods for <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>time()</code> return a character vector with the time periods for a price index.
<code>start()</code> and <code>end()</code> return the first and last time period.
</p>
<p>The replacement method returns a copy of <code>x</code> with the time periods in
<code>value</code>.
</p>


<h3>See Also</h3>

<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+vcov.aggregate_piar_index">vcov.aggregate_piar_index</a>()</code>
</p>

<hr>
<h2 id='update.piar_aggregation_structure'>Update an aggregation structure</h2><span id='topic+update.piar_aggregation_structure'></span>

<h3>Description</h3>

<p>Price update the weights in a price index aggregation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_aggregation_structure'
update(object, index, period = end(index), ..., r = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.piar_aggregation_structure_+3A_object">object</code></td>
<td>
<p>A price index aggregation structure, as made by
<code><a href="#topic+aggregation_structure">aggregation_structure()</a></code>.</p>
</td></tr>
<tr><td><code id="update.piar_aggregation_structure_+3A_index">index</code></td>
<td>
<p>A price index, or something that can be coerced into one.
Usually an aggregate price index as made by
<code><a href="#topic+aggregate.piar_index">aggregate()</a></code>.</p>
</td></tr>
<tr><td><code id="update.piar_aggregation_structure_+3A_period">period</code></td>
<td>
<p>The time period used to price update the weights. The default
uses the last period in <code>index</code>.</p>
</td></tr>
<tr><td><code id="update.piar_aggregation_structure_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="update.piar_aggregation_structure_+3A_r">r</code></td>
<td>
<p>Order of the generalized mean to update the weights. The default
uses the order used to aggregate <code>index</code> if it's an aggregate index;
otherwise, the default is 1 for an arithmetic index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>object</code> with price-updated weights using the index
values in <code>index</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate.piar_index">aggregate()</a></code> to make an aggregated price index.
</p>
<p>Other aggregation structure methods: 
<code><a href="#topic+as.matrix.piar_aggregation_structure">as.matrix.piar_aggregation_structure</a>()</code>,
<code><a href="#topic+levels.piar_aggregation_structure">levels.piar_aggregation_structure</a>()</code>,
<code><a href="#topic+weights.piar_aggregation_structure">weights.piar_aggregation_structure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple aggregation structure
#            1
#      |-----+-----|
#      11          12
#  |---+---|       |
#  111     112     121
#  (1)     (3)     (4)

aggregation_weights &lt;- data.frame(
  level1 = c("1", "1", "1"),
  level2 = c("11", "11", "12"),
  ea     = c("111", "112", "121"),
  weight = c(1, 3, 4)
)

pias &lt;- as_aggregation_structure(aggregation_weights)

index &lt;- as_index(
  matrix(1:9, 3, dimnames = list(c("111", "112", "121"), NULL))
)

weights(pias, ea_only = FALSE)

weights(update(pias, index), ea_only = FALSE)

</code></pre>

<hr>
<h2 id='vcov.aggregate_piar_index'>Bootstrap variance for a price index with replicate weights</h2><span id='topic+vcov.aggregate_piar_index'></span>

<h3>Description</h3>

<p>Estimate the sampling variance for an aggregate price index when using a
sample of elemental aggregates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aggregate_piar_index'
vcov(object, repweights, ..., mse = TRUE, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.aggregate_piar_index_+3A_object">object</code></td>
<td>
<p>An aggregate price index, as made by
<code><a href="#topic+aggregate.piar_index">aggregate()</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.aggregate_piar_index_+3A_repweights">repweights</code></td>
<td>
<p>A matrix, or something that can be coerced into one, of
bootstrap replicate weights with a row for each elemental aggregate and a
column for each replicate.</p>
</td></tr>
<tr><td><code id="vcov.aggregate_piar_index_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="vcov.aggregate_piar_index_+3A_mse">mse</code></td>
<td>
<p>Should variance be centered off the value of the index in
<code>object</code> (the default), or the mean of the replicates?</p>
</td></tr>
<tr><td><code id="vcov.aggregate_piar_index_+3A_sparse">sparse</code></td>
<td>
<p>Use sparse matrices from <span class="pkg">Matrix</span> when aggregating the
index. Faster for indexes with large aggregation structures. The default
uses regular dense matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper that reaggregates the elemental indexes in
<code>object</code> using the bootstrap replicate weights in <code>repweights</code> to
get a collection of aggregate indexes from which the variance is calculated.
</p>
<p>This approach is usually applicable when elemental aggregates are sampled
with a stratified design that follows the aggregation structure, so that
there is no correlation between the index values for different levels of the
index. It ignores any variation from the elemental indexes (which often use
judgmental sampling), and ultimately depends on the method of generating
replicate weights. (Chapters 3 and 4 of Selvanathan and Rao (1994),
especially section 4.7, provide analytic variance estimators for some common
price indexes that are applicable with simple random sampling.)
</p>
<p>Note that any missing elemental indexes need to be explicitly imputed prior
to using this method, otherwise they will propagate throughout the variance
calculation.
</p>


<h3>Value</h3>

<p>A matrix of variances with a row for each upper-level index and a
column for each time period.
</p>


<h3>Source</h3>

<p>The <code>vcov()</code> method was influenced by a SAS routine by Justin
Francis that was first ported to R by Ambuj Dewan, and subsequently
rewritten by Steve Martin.
</p>


<h3>References</h3>

<p>Selvanathan, E. A., and Rao, D. S. P. (1994).
<em>Index Numbers: A Stochastic Approach</em>. MacMillan.
</p>


<h3>See Also</h3>

<p>The <code>sps_repweights()</code> function in the <span class="pkg">sps</span> package to
generate replicates weights when elemental aggregates are sampled using
sequential Poisson sampling.
</p>
<p>Other index methods: 
<code><a href="#topic++5B.piar_index">[.piar_index</a>()</code>,
<code><a href="#topic+aggregate.piar_index">aggregate.piar_index</a>()</code>,
<code><a href="#topic+as.data.frame.piar_index">as.data.frame.piar_index</a>()</code>,
<code><a href="#topic+chain">chain</a>()</code>,
<code><a href="#topic+contrib">contrib</a>()</code>,
<code><a href="#topic+head.piar_index">head.piar_index</a>()</code>,
<code><a href="#topic+is.na.piar_index">is.na.piar_index</a>()</code>,
<code><a href="#topic+levels.piar_index">levels.piar_index</a>()</code>,
<code><a href="#topic+mean.piar_index">mean.piar_index</a>()</code>,
<code><a href="#topic+merge.piar_index">merge.piar_index</a>()</code>,
<code><a href="#topic+split.piar_index">split.piar_index</a>()</code>,
<code><a href="#topic+stack.piar_index">stack.piar_index</a>()</code>,
<code><a href="#topic+time.piar_index">time.piar_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- data.frame(
  rel = 1:8,
  period = rep(1:2, each = 4),
  ea = rep(letters[1:2], 4)
)

# A two-level aggregation structure

pias &lt;- aggregation_structure(
  list(c("top", "top", "top"), c("a", "b", "c")), 1:3
)

repweights &lt;- matrix(c(0, 2, 3, 1, 2, 4, 2, 3, 3), 3)

# Calculate Jevons elemental indexes

elemental &lt;- with(prices, elemental_index(rel, period, ea))

# Aggregate

index &lt;- aggregate(elemental, pias, na.rm = TRUE)

# Calculate variance

vcov(index, repweights)

</code></pre>

<hr>
<h2 id='weights.piar_aggregation_structure'>Get the weights for an aggregation structure</h2><span id='topic+weights.piar_aggregation_structure'></span><span id='topic+weights+3C-'></span><span id='topic+weights+3C-.piar_aggregation_structure'></span>

<h3>Description</h3>

<p>Get and set the weights for a price index aggregation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piar_aggregation_structure'
weights(object, ..., ea_only = TRUE, na.rm = FALSE)

weights(object) &lt;- value

## S3 replacement method for class 'piar_aggregation_structure'
weights(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights.piar_aggregation_structure_+3A_object">object</code></td>
<td>
<p>A price index aggregation structure, as made by
<code><a href="#topic+aggregation_structure">aggregation_structure()</a></code>.</p>
</td></tr>
<tr><td><code id="weights.piar_aggregation_structure_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="weights.piar_aggregation_structure_+3A_ea_only">ea_only</code></td>
<td>
<p>Should weights be returned for only the elemental aggregates
(the default)? Setting to <code>FALSE</code> gives the weights for the entire
aggregation structure.</p>
</td></tr>
<tr><td><code id="weights.piar_aggregation_structure_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed when aggregating the
weights (i.e., when <code>ea_only = FALSE</code>)? By default, missing values are
not removed.</p>
</td></tr>
<tr><td><code id="weights.piar_aggregation_structure_+3A_value">value</code></td>
<td>
<p>A numeric vector of weights for the elemental aggregates of
<code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>weights()</code> returns a named vector of weights for the elemental aggregates.
The replacement method replaces these values without changing the
aggregation structure. If <code>ea_only = FALSE</code> then the return value is a list
with a named vector of weights for each level in the aggregation structure.
</p>


<h3>See Also</h3>

<p>Other aggregation structure methods: 
<code><a href="#topic+as.matrix.piar_aggregation_structure">as.matrix.piar_aggregation_structure</a>()</code>,
<code><a href="#topic+levels.piar_aggregation_structure">levels.piar_aggregation_structure</a>()</code>,
<code><a href="#topic+update.piar_aggregation_structure">update.piar_aggregation_structure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple aggregation structure
#            1
#      |-----+-----|
#      11          12
#  |---+---|       |
#  111     112     121
#  (1)     (3)     (4)

aggregation_weights &lt;- data.frame(
  level1 = c("1", "1", "1"),
  level2 = c("11", "11", "12"),
  ea     = c("111", "112", "121"),
  weight = c(1, 3, 4)
)

pias &lt;- as_aggregation_structure(aggregation_weights)

# Extract the weights

weights(pias)

# ... or update them

weights(pias) &lt;- 1:3
weights(pias)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
