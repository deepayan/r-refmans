<!DOCTYPE html><html><head><title>Help for package textshape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {textshape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bind_list'><p>Row Bind a List of Named Dataframes or Vectors</p></a></li>
<li><a href='#bind_table'><p>Column Bind a Table's Values with Its Names</p></a></li>
<li><a href='#bind_vector'><p>Column Bind an Atomic Vector's Values with Its Names</p></a></li>
<li><a href='#change_index'><p>Indexing of Changes in Runs</p></a></li>
<li><a href='#cluster_matrix'><p>Reorder a Matrix Based on Hierarchical Clustering</p></a></li>
<li><a href='#column_to_rownames'><p>Add a Column as Rownames</p></a></li>
<li><a href='#combine'><p>Combine Elements</p></a></li>
<li><a href='#DATA'><p>Fictitious Classroom Dialogue</p></a></li>
<li><a href='#duration'><p>Duration of Turns of Talk</p></a></li>
<li><a href='#flatten'><p>Flatten a Nested List of Vectors Into a Single Tier List of Vectors</p></a></li>
<li><a href='#from_to'><p>Prepare Discourse Data for Network Plotting</p></a></li>
<li><a href='#golden_rules'><p>Sentence Boundary Disambiguation Edge Cases</p></a></li>
<li><a href='#grab_index'><p>Get Elements Matching Between 2 Points</p></a></li>
<li><a href='#grab_match'><p>Get Elements Matching Between 2 Points</p></a></li>
<li><a href='#hamlet'><p>Hamlet (Complete &amp; Split by Sentence)</p></a></li>
<li><a href='#mtabulate'><p>Tabulate Frequency Counts for Multiple Vectors</p></a></li>
<li><a href='#simple_dtm'><p>Simple <code>DocumentTermMatrix</code></p></a></li>
<li><a href='#split_index'><p>Split Data Forms at Specified Indices</p></a></li>
<li><a href='#split_match'><p>Split a Vector By Split Points</p></a></li>
<li><a href='#split_match_regex_to_transcript'><p>Split Text by Regex Into a Transcript</p></a></li>
<li><a href='#split_portion'><p>Break Text Into Ordered Word Chunks</p></a></li>
<li><a href='#split_run'><p>Split Runs</p></a></li>
<li><a href='#split_sentence'><p>Split Sentences</p></a></li>
<li><a href='#split_sentence_token'><p>Split Sentences &amp; Tokens</p></a></li>
<li><a href='#split_speaker'><p>Break and Stretch if Multiple Persons per Cell</p></a></li>
<li><a href='#split_token'><p>Split Tokens</p></a></li>
<li><a href='#split_transcript'><p>Split a Transcript Style Vector on Delimiter &amp; Coerce to Dataframe</p></a></li>
<li><a href='#split_word'><p>Split Words</p></a></li>
<li><a href='#textshape'><p>Tools for Reshaping Text</p></a></li>
<li><a href='#tidy_colo_tdm'><p>Convert a</p>
<code>DocumentTermMatrix</code>/<code>TermDocumentMatrix</code>
into Collocating Words in Tidy Form</a></li>
<li><a href='#tidy_dtm'><p>Convert a</p>
<code>DocumentTermMatrix</code>/<code>TermDocumentMatrix</code>
into Tidy Form</a></li>
<li><a href='#tidy_list'><p>Tidy a List of Named Dataframes or Named Vectors or Vectors</p></a></li>
<li><a href='#tidy_matrix'><p>Convert a Matrix into Tidy Form</p></a></li>
<li><a href='#tidy_table'><p>Tidy a Table: Bind Its Values with Its Names</p></a></li>
<li><a href='#tidy_vector'><p>Tidy a Named Atomic Vector: Bind Its Values with Its Names</p></a></li>
<li><a href='#unique_pairs'><p>Extract Only Unique Pairs of Collocating Words in</p>
<code>tidy_colo_dtm</code></a></li>
<li><a href='#unnest_text'><p>Un-nest Nested Text Columns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Reshaping Text</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Rinker &lt;tyler.rinker@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools that can be used to reshape and restructure text data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, slam, stats, stringi, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/trinker/textshape">https://github.com/trinker/textshape</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trinker/textshape/issues">https://github.com/trinker/textshape/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'bind_list.R' 'bind_table.R' 'bind_vector.R' 'change_index.R'
'cluster_matrix.R' 'column_to_rownames.R' 'combine.R'
'duration.R' 'flatten.R' 'from_to.R' 'grab_index.R'
'grab_match.R' 'mtabulate.R' 'split_index.R' 'split_match.R'
'split_match_regex_to_transcript.R' 'split_portion.R'
'split_run.R' 'split_sentence.R' 'split_sentence_token.R'
'split_speaker.R' 'split_token.R' 'split_transcript.R'
'split_word.R' 'textshape-package.R' 'tidy_colo_dtm.R'
'utils.R' 'tidy_dtm.R' 'tidy_list.R' 'tidy_matrix.R'
'tidy_table.R' 'tidy_vector.R' 'unique_pairs.R' 'unnest_text.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-25 15:25:11 UTC; TylerRinker</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Rinker [aut, cre],
  Joran Elias [ctb],
  Matthew Flickinger [ctb],
  Paul Foster [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-28 17:50:03 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.3.0; ; 2022-06-13 14:59:34 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='bind_list'>Row Bind a List of Named Dataframes or Vectors</h2><span id='topic+bind_list'></span>

<h3>Description</h3>

<p>Deprecated, use <code><a href="#topic+tidy_list">tidy_list</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_list(x, id.name = "id", content.name = "content", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_list_+3A_x">x</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list</a></code> of
<code><a href="base.html#topic+data.frame">data.frame</a></code>s or <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="bind_list_+3A_id.name">id.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+list">list</a></code>.</p>
</td></tr>
<tr><td><code id="bind_list_+3A_content.name">content.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+list">list</a></code>
of <code><a href="base.html#topic+vector">vector</a></code>s (only used if <code>x</code> is  <code><a href="base.html#topic+vector">vector</a></code>).</p>
</td></tr>
<tr><td><code id="bind_list_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the <code><a href="base.html#topic+names">names</a></code>
from the <code><a href="base.html#topic+list">list</a></code> as an <code>id</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bind_list(list(p=1:500, r=letters))
bind_list(list(p=mtcars, r=mtcars, z=mtcars, d=mtcars))

## 2015 Vice-Presidential Debates Example
if (!require("pacman")) install.packages("pacman")
pacman::p_load(rvest, magrittr, xml2)

debates &lt;- c(
    wisconsin = "110908",
    boulder = "110906",
    california = "110756",
    ohio = "110489"
)

lapply(debates, function(x){
    xml2::read_html(paste0("http://www.presidency.ucsb.edu/ws/index.php?pid=", x)) %&gt;%
        rvest::html_nodes("p") %&gt;%
        rvest::html_text() %&gt;%
        textshape::split_index(grep("^[A-Z]+:", .)) %&gt;%
        textshape::combine() %&gt;%
        textshape::split_transcript() %&gt;%
        textshape::split_sentence()
}) %&gt;%
    textshape::bind_list("location")

## End(Not run)
</code></pre>

<hr>
<h2 id='bind_table'>Column Bind a Table's Values with Its Names</h2><span id='topic+bind_table'></span>

<h3>Description</h3>

<p>Deprecated, use <code><a href="#topic+tidy_table">tidy_table</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_table(x, id.name = "id", content.name = "content", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_table_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+table">table</a></code>.</p>
</td></tr>
<tr><td><code id="bind_table_+3A_id.name">id.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+table">table</a></code>
<code><a href="base.html#topic+names">names</a></code>.</p>
</td></tr>
<tr><td><code id="bind_table_+3A_content.name">content.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+table">table</a></code>
values.</p>
</td></tr>
<tr><td><code id="bind_table_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the <code><a href="base.html#topic+names">names</a></code>
from the <code><a href="base.html#topic+table">table</a></code> as an <code>id</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- table(sample(LETTERS[1:6], 1000, TRUE))
bind_table(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='bind_vector'>Column Bind an Atomic Vector's Values with Its Names</h2><span id='topic+bind_vector'></span>

<h3>Description</h3>

<p>Deprecated, use <code><a href="#topic+tidy_vector">tidy_vector</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_vector(x, id.name = "id", content.name = "content", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_vector_+3A_x">x</code></td>
<td>
<p>A named atomic <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="bind_vector_+3A_id.name">id.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+vector">vector</a></code>
<code><a href="base.html#topic+names">names</a></code>.</p>
</td></tr>
<tr><td><code id="bind_vector_+3A_content.name">content.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+vector">vector</a></code>
values.</p>
</td></tr>
<tr><td><code id="bind_vector_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the <code><a href="base.html#topic+names">names</a></code>
from the <code><a href="base.html#topic+vector">vector</a></code> as an <code>id</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- setNames(sample(LETTERS[1:6], 1000, TRUE), sample(state.name[1:5], 1000, TRUE))
bind_vector(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='change_index'>Indexing of Changes in Runs</h2><span id='topic+change_index'></span>

<h3>Description</h3>

<p>Find the indices of changes in runs in a vector.  This function pairs well 
with <code>split_index</code> and is the default for the <code>indices</code> in all 
<code>split_index</code> functions that act on atomic vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_index(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_index_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="change_index_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of integer indices of where a vector initially 
changes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split_index">split_index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
(x &lt;- sample(0:1, 20, TRUE))
change_index(x)
split_index(x, change_index(x))


(p_chng &lt;- change_index(CO2[["Plant"]]))
split_index(CO2[["Plant"]], p_chng)
</code></pre>

<hr>
<h2 id='cluster_matrix'>Reorder a Matrix Based on Hierarchical Clustering</h2><span id='topic+cluster_matrix'></span>

<h3>Description</h3>

<p>Reorder matrix rows, columns, or both via hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_matrix(x, dim = "both", method = "ward.D2", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_matrix_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="cluster_matrix_+3A_dim">dim</code></td>
<td>
<p>The dimension to reorder (cluster); must be set to &quot;row&quot;, &quot;col&quot;, 
or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="cluster_matrix_+3A_method">method</code></td>
<td>
<p>The agglomeration method to be used (see 
<code><a href="stats.html#topic+hclust">hclust</a></code>).</p>
</td></tr>
<tr><td><code id="cluster_matrix_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a reordered matrix.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluster_matrix(mtcars)
cluster_matrix(mtcars, dim = 'row')
cluster_matrix(mtcars, dim = 'col')

## Not run: 
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, viridis, gridExtra)

## plot heatmap w/o clustering
wo &lt;- mtcars %&gt;%
    cor() %&gt;%
    tidy_matrix('car', 'var') %&gt;%
    ggplot(aes(var, car, fill = value)) +
         geom_tile() +
         scale_fill_viridis(name = expression(r[xy])) +
         theme(
             axis.text.y = element_text(size = 8)   ,
             axis.text.x = element_text(
                 size = 8, 
                 hjust = 1, 
                 vjust = 1, 
                 angle = 45
             ),   
             legend.position = 'bottom',
             legend.key.height = grid::unit(.1, 'cm'),
             legend.key.width = grid::unit(.5, 'cm')
         ) +
         labs(subtitle = "With Out Clustering")

## plot heatmap w clustering
w &lt;- mtcars %&gt;%
    cor() %&gt;%
    cluster_matrix() %&gt;%
    tidy_matrix('car', 'var') %&gt;%
    mutate(
        var = factor(var, levels = unique(var)),
        car = factor(car, levels = unique(car))        
    ) %&gt;%
    group_by(var) %&gt;%
    ggplot(aes(var, car, fill = value)) +
         geom_tile() +
         scale_fill_viridis(name = expression(r[xy])) +
         theme(
             axis.text.y = element_text(size = 8)   ,
             axis.text.x = element_text(
                 size = 8, 
                 hjust = 1, 
                 vjust = 1, 
                 angle = 45
             ),   
             legend.position = 'bottom',
             legend.key.height = grid::unit(.1, 'cm'),
             legend.key.width = grid::unit(.5, 'cm')               
         ) +
         labs(subtitle = "With Clustering")

gridExtra::grid.arrange(wo, w, ncol = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='column_to_rownames'>Add a Column as Rownames</h2><span id='topic+column_to_rownames'></span>

<h3>Description</h3>

<p>Takes an existing column and uses it as rownames instead.  This is useful
when turning a <code><a href="base.html#topic+data.frame">data.frame</a></code> into a <code><a href="base.html#topic+matrix">matrix</a></code>.
Inspired by the <span class="pkg">tibble</span> package's <code>column_to_row</code> which is now
deprecated if done on a <span class="pkg">tibble</span> object.  By coercing to a
<code><a href="base.html#topic+data.frame">data.frame</a></code> this problem is avoided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>column_to_rownames(x, loc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="column_to_rownames_+3A_x">x</code></td>
<td>
<p>An object that can be coerced to a <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="column_to_rownames_+3A_loc">loc</code></td>
<td>
<p>The column location as either an integer or string index location.
Must be unique row names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> with the specified column
moved to rownames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>state_dat &lt;- data.frame(state.name, state.area, state.center, state.division)
column_to_rownames(state_dat)
column_to_rownames(state_dat, 'state.name')
</code></pre>

<hr>
<h2 id='combine'>Combine Elements</h2><span id='topic+combine'></span><span id='topic+combine.default'></span><span id='topic+combine.data.frame'></span>

<h3>Description</h3>

<p>Combine (<code><a href="base.html#topic+paste">paste</a></code>) elements (<code><a href="base.html#topic+vector">vector</a></code>s,
<code><a href="base.html#topic+list">list</a></code>s, or <code><a href="base.html#topic+data.frame">data.frame</a></code>s) together
with <code>collapse = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(x, ...)

## Default S3 method:
combine(x, fix.punctuation = TRUE, ...)

## S3 method for class 'data.frame'
combine(x, text.var = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or character vector with runs.</p>
</td></tr>
<tr><td><code id="combine_+3A_fix.punctuation">fix.punctuation</code></td>
<td>
<p>logical If <code>TRUE</code> spaces before/after punctuation
that should not be are a removed (regex used:
<code>"(\s+(?=[,.?!;:%-]))|((?&lt;=[$-])\s+)"</code>).</p>
</td></tr>
<tr><td><code id="combine_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable.</p>
</td></tr>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (if given a list/vector) or an expanded
<code><a href="data.table.html#topic+data.table">data.table</a></code> with elements pasted together.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- split_token(DATA[["state"]][1], FALSE))
combine(x)

(x2 &lt;- split_token(DATA[["state"]], FALSE))
combine(x2)

(x3 &lt;- split_sentence(DATA))

## without dropping the non-group variable column
combine(x3)

## Dropping the non-group variable column
combine(x3[, 1:5, with=FALSE])
</code></pre>

<hr>
<h2 id='DATA'>Fictitious Classroom Dialogue</h2><span id='topic+DATA'></span>

<h3>Description</h3>

<p>A fictitious dataset useful for small demonstrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DATA)
</code></pre>


<h3>Format</h3>

<p>A data frame with 11 rows and 5 variables
</p>


<h3>Details</h3>


<ul>
<li><p> person. Speaker
</p>
</li>
<li><p> sex. Gender
</p>
</li>
<li><p> adult. Dummy coded adult (0-no; 1-yes)
</p>
</li>
<li><p> state. Statement (dialogue)
</p>
</li>
<li><p> code. Dialogue coding scheme
</p>
</li></ul>


<hr>
<h2 id='duration'>Duration of Turns of Talk</h2><span id='topic+duration'></span><span id='topic+duration.default'></span><span id='topic+duration.data.frame'></span><span id='topic+duration.numeric'></span><span id='topic+starts'></span><span id='topic+ends'></span>

<h3>Description</h3>

<p><code>duration</code> - Calculate duration (start and end times) for duration of 
turns of talk measured in words.
</p>
<p><code>startss</code> - Calculate start times from a numeric vector.
</p>
<p><code>ends</code> - Calculate end times from a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duration(x, ...)

## Default S3 method:
duration(x, grouping.var = NULL, ...)

## S3 method for class 'data.frame'
duration(x, text.var = TRUE, ...)

## S3 method for class 'numeric'
duration(x, ...)

starts(x, ...)

ends(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or character vector with a text
variable or a numeric vector.</p>
</td></tr>
<tr><td><code id="duration_+3A_grouping.var">grouping.var</code></td>
<td>
<p>The grouping variables.  Default <code>NULL</code> generates
one word list for all text.  Also takes a single grouping variable or a list
of 1 or more grouping variables.</p>
</td></tr>
<tr><td><code id="duration_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable.  If <code>TRUE</code>
<code>duration</code> tries to detect the text column.</p>
</td></tr>
<tr><td><code id="duration_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or data frame of starts and/or ends.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- c(
    "Mr. Brown comes! He says hello. i give him coffee.",
    "I'll go at 5 p. m. eastern time.  Or somewhere in between!",
    "go there"
))
duration(x)
group &lt;- c("A", "B", "A")
duration(x, group)

groups &lt;- list(group1 = c("A", "B", "A"), group2 = c("red", "red", "green"))
duration(x, groups)

data(DATA)
duration(DATA)

## Larger data set
duration(hamlet)

## Integer values
x &lt;- sample(1:10, 10)
duration(x)
starts(x)
ends(x)
</code></pre>

<hr>
<h2 id='flatten'>Flatten a Nested List of Vectors Into a Single Tier List of Vectors</h2><span id='topic+flatten'></span>

<h3>Description</h3>

<p>Flatten a named, nested list of atomic vectors to a single level using the
concatenated list/atomic vector names as the names of the single tiered
list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten(x, sep = "_", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_+3A_x">x</code></td>
<td>
<p>A nested, named list of vectors.</p>
</td></tr>
<tr><td><code id="flatten_+3A_sep">sep</code></td>
<td>
<p>A separator to use for the concatenation of the names from the
nested list.</p>
</td></tr>
<tr><td><code id="flatten_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a flattened list.
</p>


<h3>Note</h3>

<p>The order of the list is sorted alphabetically.  Pull requests for the
option to return the original order would be appreciated.
</p>


<h3>Author(s)</h3>

<p>StackOverflow user @Michael and Paul Foster and Tyler 
Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/41882883/1000343">https://stackoverflow.com/a/41882883/1000343</a> <br />
<a href="https://stackoverflow.com/a/48357114/1000343">https://stackoverflow.com/a/48357114/1000343</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(
    urban = list(
        cars = c('volvo', 'ford'),
        food.dining = list(
            local.business = c('carls'),
            chain.business = c('dennys', 'panera')
        )
    ),
    rural = list(
        land.use = list(
            farming =list(
                dairy = c('cows'),
                vegie.plan = c('carrots')
            )
        ),
        social.rec = list(
            community.center = c('town.square')
        ),
        people.type = c('good', 'bad', 'in.between')
    ),
    other.locales = c('suburban'),
    missing = list(
        unknown = c(),
        known = c()
    ),
    end = c('wow')
)

x

flatten(x)
flatten(x, ' -&gt; ')

## Not run: 
## dictionary from quanteda
require(quanteda); library(textreadr); library(dplyr)
mydict &lt;- https://provalisresearch.com/Download/LaverGarry.zip" %&gt;%
    textreadr::download(") %&gt;%
    unzip(exdir = tempdir()) %&gt;%
    `[`(1) %&gt;%
    quanteda::dictionary(file = .)

mydict
flatten(as.list(mydict))

## End(Not run)
</code></pre>

<hr>
<h2 id='from_to'>Prepare Discourse Data for Network Plotting</h2><span id='topic+from_to'></span><span id='topic+from_to.default'></span><span id='topic+from_to.character'></span><span id='topic+from_to.numeric'></span><span id='topic+from_to.data.frame'></span><span id='topic+from_to_summarize'></span>

<h3>Description</h3>

<p><code>from_to</code> - Add the next speaker as the from variable in a to/from
network data structure.  Assumes that the flow of discourse is coming from
person A to person B, or at the very least the talk is taken up by person B.
Works by taking the vector of speakers and shifting everything down one and
then adding a closing element.
</p>
<p><code>from_to_summarize</code> - A wrapper for <code>from_to.data.frame</code> that
adds a <code>word.count</code> column and then combines duplicate rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_to(x, ...)

## Default S3 method:
from_to(x, final = "End", ...)

## S3 method for class 'character'
from_to(x, final = "End", ...)

## S3 method for class 'numeric'
from_to(x, final = "End", ...)

## S3 method for class 'data.frame'
from_to(x, from.var, final = "End", ...)

from_to_summarize(x, from.var, id.vars = NULL, text.var = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_to_+3A_x">x</code></td>
<td>
<p>A data form <code>vector</code> or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="from_to_+3A_final">final</code></td>
<td>
<p>The name of the closing element or node.</p>
</td></tr>
<tr><td><code id="from_to_+3A_from.var">from.var</code></td>
<td>
<p>A character string naming the column to be considered the
origin of the talk.</p>
</td></tr>
<tr><td><code id="from_to_+3A_id.vars">id.vars</code></td>
<td>
<p>The variables that correspond to the speaker or are attributes
of the speaker (from variable).</p>
</td></tr>
<tr><td><code id="from_to_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable.  If <code>TRUE</code>
<code>duration</code> tries to detect the text column.</p>
</td></tr>
<tr><td><code id="from_to_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (if given a vector) or an augmented
<code><a href="data.table.html#topic+data.table">data.table</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>from_to(DATA, 'person')
from_to_summarize(DATA, 'person')
from_to_summarize(DATA, 'person', c('sex', 'adult'))
## Not run: 
if (!require("pacman")) install.packages("pacman"); library(pacman)
p_load(dplyr, geomnet, qdap, stringi, scales)
p_load_current_gh('trinker/textsahpe')

dat &lt;- from_to_summarize(DATA, 'person', c('sex', 'adult')) %&gt;%
    mutate(words = rescale(word.count, c(.5, 1.5)))

dat %&gt;%
    ggplot(aes(from_id = from, to_id = to)) +
        geom_net(
            aes(linewidth = words),
            layout.alg = "fruchtermanreingold",
            directed = TRUE,
            labelon = TRUE,
            size = 1,
            labelcolour = 'black',
            ecolour = "grey70",
            arrowsize = 1,
            curvature = .1
        ) +
        theme_net() +
        xlim(c(-0.05, 1.05))

## End(Not run)
</code></pre>

<hr>
<h2 id='golden_rules'>Sentence Boundary Disambiguation Edge Cases</h2><span id='topic+golden_rules'></span>

<h3>Description</h3>

<p>A slightly filtered dataset containing Dias's sentence boundary
disambiguation edge cases.  This is a nested data set with the outcome
column as a nested list of desired splits.  The non-ASCII cases and spaced
ellipsis examples have been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(golden_rules)
</code></pre>


<h3>Format</h3>

<p>A data frame with 45 rows and 3 variables
</p>


<h3>Details</h3>


<ul>
<li><p> Rule. The name of the rule to test
</p>
</li>
<li><p> Text. The testing text
</p>
</li>
<li><p> Outcome. The desired outcome of the sentence disambiguation
</p>
</li></ul>



<h3>References</h3>

<p>Dias, Kevin S. 2015. Golden Rules (English).
Retrieved: https://s3.amazonaws.com/tm-town-nlp-resources/golden_rules.txt
</p>

<hr>
<h2 id='grab_index'>Get Elements Matching Between 2 Points</h2><span id='topic+grab_index'></span><span id='topic+grab_index.character'></span><span id='topic+grab_index.default'></span><span id='topic+grab_index.list'></span><span id='topic+grab_index.data.frame'></span>

<h3>Description</h3>

<p>Use regexes to get all the elements between two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_index(x, from = NULL, to = NULL, ...)

## S3 method for class 'character'
grab_index(x, from = NULL, to = NULL, ...)

## Default S3 method:
grab_index(x, from = NULL, to = NULL, ...)

## S3 method for class 'list'
grab_index(x, from = NULL, to = NULL, ...)

## S3 method for class 'data.frame'
grab_index(x, from = NULL, to = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_index_+3A_x">x</code></td>
<td>
<p>A character vector, <code><a href="base.html#topic+data.frame">data.frame</a></code>, or list.</p>
</td></tr>
<tr><td><code id="grab_index_+3A_from">from</code></td>
<td>
<p>An integer to start from (if <code>NULL</code> defaults to the first 
element/row).</p>
</td></tr>
<tr><td><code id="grab_index_+3A_to">to</code></td>
<td>
<p>A integer to get up to (if <code>NULL</code> defaults to the last 
element/row).</p>
</td></tr>
<tr><td><code id="grab_index_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a subset of the original data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grab_index(DATA, from = 2, to = 4)
grab_index(DATA$state, from = 2, to = 4)
grab_index(DATA$state, from = 2)
grab_index(DATA$state, to = 4)
grab_index(matrix(1:100, nrow = 10), 2, 4)
</code></pre>

<hr>
<h2 id='grab_match'>Get Elements Matching Between 2 Points</h2><span id='topic+grab_match'></span><span id='topic+grab_match.character'></span><span id='topic+grab_match.list'></span><span id='topic+grab_match.data.frame'></span>

<h3>Description</h3>

<p>Use regexes to get all the elements between two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_match(x, from = NULL, to = NULL, from.n = 1, to.n = 1, ...)

## S3 method for class 'character'
grab_match(x, from = NULL, to = NULL, from.n = 1, to.n = 1, ...)

## S3 method for class 'list'
grab_match(x, from = NULL, to = NULL, from.n = 1, to.n = 1, ...)

## S3 method for class 'data.frame'
grab_match(
  x,
  from = NULL,
  to = NULL,
  from.n = 1,
  to.n = 1,
  text.var = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_match_+3A_x">x</code></td>
<td>
<p>A character vector, <code><a href="base.html#topic+data.frame">data.frame</a></code>, or list.</p>
</td></tr>
<tr><td><code id="grab_match_+3A_from">from</code></td>
<td>
<p>A regex to start getting from (if <code>NULL</code> defaults to the 
first element/row).</p>
</td></tr>
<tr><td><code id="grab_match_+3A_to">to</code></td>
<td>
<p>A regex to get up to (if <code>NULL</code> defaults to the last element/row).</p>
</td></tr>
<tr><td><code id="grab_match_+3A_from.n">from.n</code></td>
<td>
<p>If more than one element matches <code>from</code> this dictates 
which one should be used.  Must be an integer up to the number of possible
matches, <code>'first'</code> (equal to <code>1</code>), <code>'last'</code> (the last match
possible), or <code>'n'</code> (the same as <code>'last'</code>).</p>
</td></tr>
<tr><td><code id="grab_match_+3A_to.n">to.n</code></td>
<td>
<p>If more than one element matches <code>to</code> this dictates 
which one should be used.  Must be an integer up to the number of possible
matches, <code>'first'</code> (equal to <code>1</code>), <code>'last'</code> (the last match
possible), or <code>'n'</code> (the same as <code>'last'</code>).</p>
</td></tr>
<tr><td><code id="grab_match_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable with matches. If <code>TRUE</code>
<code>grab_match</code> tries to detect the text column.</p>
</td></tr>
<tr><td><code id="grab_match_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="base.html#topic+grep">grep</a></code>, most notable
is <code>ignore.case</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a subset of the original data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grab_match(DATA$state, from = 'dumb', to = 'liar')
grab_match(DATA$state, from = 'dumb')
grab_match(DATA$state, to = 'liar')
grab_match(DATA$state, from = 'no', to = 'the', ignore.case = TRUE)
grab_match(DATA$state, from = 'no', to = 'the', ignore.case = TRUE, 
    from.n = 'first', to.n = 'last')
grab_match(as.list(DATA$state), from = 'dumb', to = 'liar')

## Data.frame: attempts to find text.var
grab_match(DATA, from = 'dumb', to = 'liar')
</code></pre>

<hr>
<h2 id='hamlet'>Hamlet (Complete &amp; Split by Sentence)</h2><span id='topic+hamlet'></span>

<h3>Description</h3>

<p>A dataset containing the complete dialogue of Hamlet with turns of talk split
into sentences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hamlet)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2007 rows and 7 variables
</p>


<h3>Details</h3>


<ul>
<li><p> act. The act (akin to repeated measures)
</p>
</li>
<li><p> tot. The turn of talk
</p>
</li>
<li><p> scene. The scene (nested within an act)
</p>
</li>
<li><p> location. Location of the scene
</p>
</li>
<li><p> person. Character in the play
</p>
</li>
<li><p> died. Logical coded death variable if yes the character dies in the
play
</p>
</li>
<li><p> dialogue. The spoken dialogue
</p>
</li></ul>



<h3>References</h3>

<p>http://www.gutenberg.org
</p>

<hr>
<h2 id='mtabulate'>Tabulate Frequency Counts for Multiple Vectors</h2><span id='topic+mtabulate'></span><span id='topic+as_list'></span>

<h3>Description</h3>

<p><code>mtabulate</code> - Similar to <code><a href="base.html#topic+tabulate">tabulate</a></code> that works on 
multiple vectors.
</p>
<p><code>as_list</code> - Convert a count matrix to a named list of elements.  The
semantic inverse of <code>mtabulate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtabulate(vects)

as_list(mat, nm = rownames(mat))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtabulate_+3A_vects">vects</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code>, <code><a href="base.html#topic+list">list</a></code>, or
<code><a href="base.html#topic+data.frame">data.frame</a></code> of named/unnamed vectors.</p>
</td></tr>
<tr><td><code id="mtabulate_+3A_mat">mat</code></td>
<td>
<p>A matrix of counts.</p>
</td></tr>
<tr><td><code id="mtabulate_+3A_nm">nm</code></td>
<td>
<p>A character vector of names to assign to the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mtabulate</code> - Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 
columns equal to number of unique elements and the number of rows equal to 
the the original length of the <code><a href="base.html#topic+vector">vector</a></code>, 
<code><a href="base.html#topic+list">list</a></code>, or <code><a href="base.html#topic+data.frame">data.frame</a></code> (length equals 
number of columns in <code><a href="base.html#topic+data.frame">data.frame</a></code>).  If list of vectors is 
named these will be the rownames of the dataframe.
</p>
<p><code>as_list</code> - Returns a list of elements.
</p>


<h3>Author(s)</h3>

<p>Joran Elias and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/9961324/1000343">https://stackoverflow.com/a/9961324/1000343</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tabulate">tabulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtabulate(list(w=letters[1:10], x=letters[1:5], z=letters))
mtabulate(list(mtcars$cyl[1:10]))

## Dummy coding
mtabulate(mtcars$cyl[1:10])
mtabulate(CO2[, "Plant"])

dat &lt;- data.frame(matrix(sample(c("A", "B"), 30, TRUE), ncol=3))
mtabulate(dat)
as_list(mtabulate(dat))
t(mtabulate(dat))
as_list(t(mtabulate(dat)))
</code></pre>

<hr>
<h2 id='simple_dtm'>Simple <code><a href="tm.html#topic+DocumentTermMatrix">DocumentTermMatrix</a></code></h2><span id='topic+simple_dtm'></span>

<h3>Description</h3>

<p>A dataset containing a simple <code><a href="tm.html#topic+DocumentTermMatrix">DocumentTermMatrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simple_dtm)
</code></pre>


<h3>Format</h3>

<p>A list with 6 elements
</p>


<h3>Details</h3>


<dl>
<dt>i</dt><dd><p>The document locations</p>
</dd>
<dt>j</dt><dd><p>The term locations</p>
</dd>
<dt>v</dt><dd><p>The count of terms for that particular element position</p>
</dd>
<dt>nrow</dt><dd><p>The number of rows</p>
</dd>
<dt>ncol</dt><dd><p>The number of columns</p>
</dd>
<dt>dimnames</dt><dd><p>document and terms</p>
</dd>
</dl>


<hr>
<h2 id='split_index'>Split Data Forms at Specified Indices</h2><span id='topic+split_index'></span><span id='topic+split_index.list'></span><span id='topic+split_index.data.frame'></span><span id='topic+split_index.matrix'></span><span id='topic+split_index.numeric'></span><span id='topic+split_index.factor'></span><span id='topic+split_index.character'></span><span id='topic+split_index.default'></span>

<h3>Description</h3>

<p>Split data forms at specified integer indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_index(
  x,
  indices = if (is.atomic(x)) {     NULL } else {     change_index(x) },
  names = NULL,
  ...
)

## S3 method for class 'list'
split_index(x, indices, names = NULL, ...)

## S3 method for class 'data.frame'
split_index(x, indices, names = NULL, ...)

## S3 method for class 'matrix'
split_index(x, indices, names = NULL, ...)

## S3 method for class 'numeric'
split_index(x, indices = change_index(x), names = NULL, ...)

## S3 method for class 'factor'
split_index(x, indices = change_index(x), names = NULL, ...)

## S3 method for class 'character'
split_index(x, indices = change_index(x), names = NULL, ...)

## Default S3 method:
split_index(x, indices = change_index(x), names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_index_+3A_x">x</code></td>
<td>
<p>A data form (<code>list</code>, <code>vector</code>, <code>data.frame</code>,
<code>matrix</code>).</p>
</td></tr>
<tr><td><code id="split_index_+3A_indices">indices</code></td>
<td>
<p>A vector of integer indices to split at.  If <code>indices</code>
contains the index 1, it will be silently dropped.  The default value when
<code>x</code> evaluates to <code>TRUE</code> for <code><a href="base.html#topic+is.atomic">is.atomic</a></code> is to use
<code><a href="#topic+change_index">change_index</a>(x)</code>.</p>
</td></tr>
<tr><td><code id="split_index_+3A_names">names</code></td>
<td>
<p>Optional vector of names to give to the list elements.</p>
</td></tr>
<tr><td><code id="split_index_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns of list of data forms broken at the <code>indices</code>.
</p>


<h3>Note</h3>

<p>Two dimensional object will retain dimension (i.e., <code>drop = FALSE</code>
is used).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+change_index">change_index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## character
split_index(LETTERS, c(4, 10, 16))
split_index(LETTERS, c(4, 10, 16), c("dog", "cat", "chicken", "rabbit"))

## numeric
split_index(1:100, c(33, 66))

## factor
(p_chng &lt;- change_index(CO2[["Plant"]]))
split_index(CO2[["Plant"]], p_chng)
#`change_index` was unnecessary as it is the default of atomic vectors
split_index(CO2[["Plant"]])

## list
split_index(as.list(LETTERS), c(4, 10, 16))

## data.frame
(vs_change &lt;- change_index(mtcars[["vs"]]))
split_index(mtcars, vs_change)

## matrix
(mat &lt;- matrix(1:50, nrow=10))
split_index(mat, c(3, 6, 10))
</code></pre>

<hr>
<h2 id='split_match'>Split a Vector By Split Points</h2><span id='topic+split_match'></span><span id='topic+split_match_regex'></span>

<h3>Description</h3>

<p><code>split_match</code> - Splits a <code>vector</code> into a list of vectors based on
split points.
</p>
<p><code>split_match_regex</code> - <code>split_match</code> with <code>regex = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_match(x, split = "", include = FALSE, regex = FALSE, ...)

split_match_regex(x, split = "", include = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_match_+3A_x">x</code></td>
<td>
<p>A vector with split points.</p>
</td></tr>
<tr><td><code id="split_match_+3A_split">split</code></td>
<td>
<p>A vector of places (elements) to split on or a regular
expression if <code>regex</code> argument is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="split_match_+3A_include">include</code></td>
<td>
<p>An integer of <code>1</code> (<code>split</code> character(s) are not
included in the output), <code>2</code> (<code>split</code> character(s) are included at
the beginning of the output), or <code>3</code> (<code>split</code> character(s) are
included at the end of the output).</p>
</td></tr>
<tr><td><code id="split_match_+3A_regex">regex</code></td>
<td>
<p>logical.  If <code>TRUE</code> regular expressions will be enabled for
<code>split</code> argument.</p>
</td></tr>
<tr><td><code id="split_match_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="base.html#topic+grep">grep</a></code> and
<code><a href="base.html#topic+grepl">grepl</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors.
</p>


<h3>Author(s)</h3>

<p>Matthew Flickinger and Tyler Rinker &lt;tyler.rinker@gmail.com&gt;.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/24319217/1000343">https://stackoverflow.com/a/24319217/1000343</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(15)
x &lt;- sample(c("", LETTERS[1:10]), 25, TRUE, prob=c(.2, rep(.08, 10)))

split_match(x)
split_match(x, "C")
split_match(x, c("", "C"))

split_match(x, include = 0)
split_match(x, include = 1)
split_match(x, include = 2)

set.seed(15)
x &lt;- sample(1:11, 25, TRUE, prob=c(.2, rep(.08, 10)))
split_match(x, 1)
</code></pre>

<hr>
<h2 id='split_match_regex_to_transcript'>Split Text by Regex Into a Transcript</h2><span id='topic+split_match_regex_to_transcript'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="#topic+split_match_regex">split_match_regex</a></code> and 
<span class="pkg">textreadr</span>'s <code>as_transript</code> to detect person variable, split the 
text into turns of talk, and convert to a data.frame with <code>person</code> and 
<code>dialogue</code> variables.  There is a bit of cleansing that is closer to 
<code>as_transript</code> than <code><a href="#topic+split_transcript">split_transcript</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_match_regex_to_transcript(
  x,
  person.regex = "^[A-Z]{3,}",
  col.names = c("Person", "Dialogue"),
  dash = "",
  ellipsis = "...",
  quote2bracket = FALSE,
  rm.empty.rows = TRUE,
  skip = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_match_regex_to_transcript_+3A_x">x</code></td>
<td>
<p>A vector with split points.</p>
</td></tr>
<tr><td><code id="split_match_regex_to_transcript_+3A_person.regex">person.regex</code></td>
<td>
<p>A vector of places (elements) to split on or a regular
expression if <code>regex</code> argument is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="split_match_regex_to_transcript_+3A_col.names">col.names</code></td>
<td>
<p>A character vector specifying the column names of the
transcript columns.</p>
</td></tr>
<tr><td><code id="split_match_regex_to_transcript_+3A_dash">dash</code></td>
<td>
<p>A character string to replace the en and em dashes special
characters (default is to remove).</p>
</td></tr>
<tr><td><code id="split_match_regex_to_transcript_+3A_ellipsis">ellipsis</code></td>
<td>
<p>A character string to replace the ellipsis special 
characters.</p>
</td></tr>
<tr><td><code id="split_match_regex_to_transcript_+3A_quote2bracket">quote2bracket</code></td>
<td>
<p>logical. If <code>TRUE</code> replaces curly quotes with 
curly braces (default is <code>FALSE</code>).  If <code>FALSE</code> curly quotes are 
removed.</p>
</td></tr>
<tr><td><code id="split_match_regex_to_transcript_+3A_rm.empty.rows">rm.empty.rows</code></td>
<td>
<p>logical.  If <code>TRUE</code>
<code><a href="textreadr.html#topic+read_transcript">read_transcript</a></code>  attempts to remove empty rows.</p>
</td></tr>
<tr><td><code id="split_match_regex_to_transcript_+3A_skip">skip</code></td>
<td>
<p>Integer; the number of lines of the data file to skip before
beginning to read data.</p>
</td></tr>
<tr><td><code id="split_match_regex_to_transcript_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame of dialogue and people.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
system.file(
    "docs/Simpsons_Roasting_on_an_Open_Fire_Script.pdf", 
    package = "textshape"
) %&gt;%
    textreadr::read_document() %&gt;%
    split_match_regex_to_transcript("^[A-Z]{3,}", skip = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='split_portion'>Break Text Into Ordered Word Chunks</h2><span id='topic+split_portion'></span>

<h3>Description</h3>

<p>Some visualizations and algorithms require text to be broken into chunks of
ordered words.  <code>split_portion</code> breaks text, optionally by grouping
variables, into equal chunks.  The chunk size can be specified by giving
number of words to be in each chunk or the number of chunks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_portion(
  text.var,
  grouping.var = NULL,
  n.words,
  n.chunks,
  as.string = TRUE,
  rm.unequal = FALSE,
  as.table = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_portion_+3A_text.var">text.var</code></td>
<td>
<p>The text variable</p>
</td></tr>
<tr><td><code id="split_portion_+3A_grouping.var">grouping.var</code></td>
<td>
<p>The grouping variables.  Default <code>NULL</code> generates
one word list for all text.  Also takes a single grouping variable or a list
of 1 or more grouping variables.</p>
</td></tr>
<tr><td><code id="split_portion_+3A_n.words">n.words</code></td>
<td>
<p>An integer specifying the number of words in each chunk (must
specify n.chunks or n.words).</p>
</td></tr>
<tr><td><code id="split_portion_+3A_n.chunks">n.chunks</code></td>
<td>
<p>An integer specifying the number of chunks (must specify
n.chunks or n.words).</p>
</td></tr>
<tr><td><code id="split_portion_+3A_as.string">as.string</code></td>
<td>
<p>logical.  If <code>TRUE</code> the chunks are returned as a single
string.  If <code>FALSE</code> the chunks are returned as a vector of single words.</p>
</td></tr>
<tr><td><code id="split_portion_+3A_rm.unequal">rm.unequal</code></td>
<td>
<p>logical. If <code>TRUE</code> final chunks that are unequal in
length to the other chunks are removed.</p>
</td></tr>
<tr><td><code id="split_portion_+3A_as.table">as.table</code></td>
<td>
<p>logical.  If <code>TRUE</code> the list output is coerced to
<code><a href="data.table.html#topic+data.table">data.table</a></code> or <span class="pkg">tibble</span>.</p>
</td></tr>
<tr><td><code id="split_portion_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list or <code><a href="data.table.html#topic+data.table">data.table</a></code> of text chunks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(DATA, split_portion(state, n.chunks = 10))
with(DATA, split_portion(state, n.words = 10))
with(DATA, split_portion(state, n.chunks = 10, as.string=FALSE))
with(DATA, split_portion(state, n.chunks = 10, rm.unequal=TRUE))
with(DATA, split_portion(state, person, n.chunks = 10))
with(DATA, split_portion(state, list(sex, adult), n.words = 10))
with(DATA, split_portion(state, person, n.words = 10, rm.unequal=TRUE))

## Bigger data
with(hamlet, split_portion(dialogue, person, n.chunks = 10))
with(hamlet, split_portion(dialogue, list(act, scene, person), n.chunks = 10))
with(hamlet, split_portion(dialogue, person, n.words = 300))
with(hamlet, split_portion(dialogue, list(act, scene, person), n.words = 300))
</code></pre>

<hr>
<h2 id='split_run'>Split Runs</h2><span id='topic+split_run'></span><span id='topic+split_run.default'></span><span id='topic+split_run.data.frame'></span>

<h3>Description</h3>

<p>Split runs of consecutive characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_run(x, ...)

## Default S3 method:
split_run(x, ...)

## S3 method for class 'data.frame'
split_run(x, text.var = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_run_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or character vector with runs.</p>
</td></tr>
<tr><td><code id="split_run_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable with runs. If <code>TRUE</code>
<code>split_word</code> tries to detect the text column with runs.</p>
</td></tr>
<tr><td><code id="split_run_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors of runs or an expanded
<code><a href="data.table.html#topic+data.table">data.table</a></code> with runs split apart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(
     "122333444455555666666",
     NA,
     "abbcccddddeeeeeffffff",
     "sddfg",
     "11112222333"
)

x &lt;- c(rep(x1, 2), "&gt;&gt;???,,,,....::::;[[")

split_run(x)


DATA[["run.col"]] &lt;- x
split_run(DATA, "run.col")
</code></pre>

<hr>
<h2 id='split_sentence'>Split Sentences</h2><span id='topic+split_sentence'></span><span id='topic+split_sentence.default'></span><span id='topic+split_sentence.data.frame'></span>

<h3>Description</h3>

<p>Split sentences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_sentence(x, ...)

## Default S3 method:
split_sentence(x, ...)

## S3 method for class 'data.frame'
split_sentence(x, text.var = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_sentence_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or character vector with sentences.</p>
</td></tr>
<tr><td><code id="split_sentence_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable.  If <code>TRUE</code>
<code>split_sentence</code> tries to detect the column with sentences.</p>
</td></tr>
<tr><td><code id="split_sentence_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors of sentences or a expanded
<code><a href="base.html#topic+data.frame">data.frame</a></code> with sentences split apart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- c(paste0(
    "Mr. Brown comes! He says hello. i give him coffee.  i will ",
    "go at 5 p. m. eastern time.  Or somewhere in between!go there"
),
paste0(
    "Marvin K. Mooney Will You Please Go Now!", "The time has come.",
    "The time has come. The time is now. Just go. Go. GO!",
    "I don't care how."
)))
split_sentence(x)

data(DATA)
split_sentence(DATA)

## Not run: 
## Kevin S. Dias' sentence boundary disambiguation test set
data(golden_rules)
library(magrittr)

golden_rules %$%
    split_sentence(Text)

## End(Not run)
</code></pre>

<hr>
<h2 id='split_sentence_token'>Split Sentences &amp; Tokens</h2><span id='topic+split_sentence_token'></span><span id='topic+split_sentence_token.default'></span><span id='topic+split_sentence_token.data.frame'></span>

<h3>Description</h3>

<p>Split sentences and tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_sentence_token(x, ...)

## Default S3 method:
split_sentence_token(x, lower = TRUE, ...)

## S3 method for class 'data.frame'
split_sentence_token(x, text.var = TRUE, lower = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_sentence_token_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or character vector with sentences.</p>
</td></tr>
<tr><td><code id="split_sentence_token_+3A_lower">lower</code></td>
<td>
<p>logical.  If <code>TRUE</code> the words are converted to lower case.</p>
</td></tr>
<tr><td><code id="split_sentence_token_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable.  If <code>TRUE</code>
<code>split_sentence_token</code> tries to detect the column with sentences.</p>
</td></tr>
<tr><td><code id="split_sentence_token_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors of sentences or a expanded
<code><a href="base.html#topic+data.frame">data.frame</a></code> with sentences split apart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- c(paste0(
    "Mr. Brown comes! He says hello. i give him coffee.  i will ",
    "go at 5 p. m. eastern time.  Or somewhere in between!go there"
),
paste0(
    "Marvin K. Mooney Will You Please Go Now!", "The time has come.",
    "The time has come. The time is now. Just go. Go. GO!",
    "I don't care how."
)))
split_sentence_token(x)

data(DATA)
split_sentence_token(DATA)

## Not run: 
## Kevin S. Dias' sentence boundary disambiguation test set
data(golden_rules)
library(magrittr)

golden_rules %$%
    split_sentence_token(Text)

## End(Not run)
</code></pre>

<hr>
<h2 id='split_speaker'>Break and Stretch if Multiple Persons per Cell</h2><span id='topic+split_speaker'></span>

<h3>Description</h3>

<p>Look for cells with multiple people and create separate rows for each person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_speaker(dataframe, speaker.var = 1, sep = c("and", "&amp;", ","), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_speaker_+3A_dataframe">dataframe</code></td>
<td>
<p>A dataframe that contains the person variable.</p>
</td></tr>
<tr><td><code id="split_speaker_+3A_speaker.var">speaker.var</code></td>
<td>
<p>The person variable to be stretched.</p>
</td></tr>
<tr><td><code id="split_speaker_+3A_sep">sep</code></td>
<td>
<p>The separator(s) to search for and break on.  Default is:
c(&quot;and&quot;, &quot;&amp;&quot;, &quot;,&quot;)</p>
</td></tr>
<tr><td><code id="split_speaker_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an expanded dataframe with person variable stretched and
accompanying rows repeated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DATA$person &lt;- as.character(DATA$person)
DATA$person[c(1, 4, 6)] &lt;- c("greg, sally, &amp; sam",
    "greg, sally", "sam and sally")

split_speaker(DATA)

DATA$person[c(1, 4, 6)] &lt;- c("greg_sally_sam",
    "greg.sally", "sam; sally")

split_speaker(DATA, sep = c(".", "_", ";"))

DATA &lt;- textshape::DATA  #reset DATA

## End(Not run)
</code></pre>

<hr>
<h2 id='split_token'>Split Tokens</h2><span id='topic+split_token'></span><span id='topic+split_token.default'></span><span id='topic+split_token.data.frame'></span>

<h3>Description</h3>

<p>Split tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_token(x, ...)

## Default S3 method:
split_token(x, lower = TRUE, ...)

## S3 method for class 'data.frame'
split_token(x, text.var = TRUE, lower = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_token_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or character vector with tokens.</p>
</td></tr>
<tr><td><code id="split_token_+3A_lower">lower</code></td>
<td>
<p>logical.  If <code>TRUE</code> the words are converted to lower case.</p>
</td></tr>
<tr><td><code id="split_token_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable.  If <code>TRUE</code>
<code>split_token</code> tries to detect the text column with tokens.</p>
</td></tr>
<tr><td><code id="split_token_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors of tokens or an expanded
<code><a href="data.table.html#topic+data.table">data.table</a></code> with tokens split apart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- c(
    "Mr. Brown comes! He says hello. i give him coffee.",
    "I'll go at 5 p. m. eastern time.  Or somewhere in between!",
    "go there"
))
split_token(x)
split_token(x, lower=FALSE)

data(DATA)
split_token(DATA)
split_token(DATA, lower=FALSE)

## Larger data set
split_token(hamlet)
</code></pre>

<hr>
<h2 id='split_transcript'>Split a Transcript Style Vector on Delimiter &amp; Coerce to Dataframe</h2><span id='topic+split_transcript'></span>

<h3>Description</h3>

<p>Split a transcript style vector (e.g., <code>c("greg: Who me", "sarah: yes you!")</code>
into a name and dialogue vector that is coerced to a <code><a href="data.table.html#topic+data.table">data.table</a></code>.
Leading/trailing white space in the columns is stripped out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_transcript(
  x,
  delim = ":",
  colnames = c("person", "dialogue"),
  max.delim = 15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_transcript_+3A_x">x</code></td>
<td>
<p>A transcript style vector (e.g., <code>c("greg: Who me", "sarah: yes you!")</code>.</p>
</td></tr>
<tr><td><code id="split_transcript_+3A_delim">delim</code></td>
<td>
<p>The delimiter to split on.</p>
</td></tr>
<tr><td><code id="split_transcript_+3A_colnames">colnames</code></td>
<td>
<p>The column names to use for the <code><a href="data.table.html#topic+data.table">data.table</a></code>
output.</p>
</td></tr>
<tr><td><code id="split_transcript_+3A_max.delim">max.delim</code></td>
<td>
<p>An integer stating how many characters may come before a
delimiter is found.  This is useful for the case when a colon is the delimiter
but time stamps are also found in the text.</p>
</td></tr>
<tr><td><code id="split_transcript_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 2 column <code><a href="data.table.html#topic+data.table">data.table</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>split_transcript(c("greg: Who me", "sarah: yes you!"))

## Not run: 
## 2015 Vice-Presidential Debates Example
if (!require("pacman")) install.packages("pacman")
pacman::p_load(rvest, magrittr, xml2)

debates &lt;- c(
    wisconsin = "110908",
    boulder = "110906",
    california = "110756",
    ohio = "110489"
)

lapply(debates, function(x){
    xml2::read_html(paste0("http://www.presidency.ucsb.edu/ws/index.php?pid=", x)) %&gt;%
        rvest::html_nodes("p") %&gt;%
        rvest::html_text() %&gt;%
        textshape::split_index(grep("^[A-Z]+:", .)) %&gt;%
        textshape::combine() %&gt;%
        textshape::split_transcript() %&gt;%
        textshape::split_sentence()
})

## End(Not run)
</code></pre>

<hr>
<h2 id='split_word'>Split Words</h2><span id='topic+split_word'></span><span id='topic+split_word.default'></span><span id='topic+split_word.data.frame'></span>

<h3>Description</h3>

<p>Split words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_word(x, ...)

## Default S3 method:
split_word(x, lower = TRUE, ...)

## S3 method for class 'data.frame'
split_word(x, text.var = TRUE, lower = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_word_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or character vector with words.</p>
</td></tr>
<tr><td><code id="split_word_+3A_lower">lower</code></td>
<td>
<p>logical.  If <code>TRUE</code> the words are converted to lower case.</p>
</td></tr>
<tr><td><code id="split_word_+3A_text.var">text.var</code></td>
<td>
<p>The name of the text variable.  If <code>TRUE</code>
<code>split_word</code> tries to detect the text column with words.</p>
</td></tr>
<tr><td><code id="split_word_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of vectors of words or an expanded
<code><a href="data.table.html#topic+data.table">data.table</a></code> with words split apart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- c(
    "Mr. Brown comes! He says hello. i give him coffee.",
    "I'll go at 5 p. m. eastern time.  Or somewhere in between!",
    "go there"
))
split_word(x)
split_word(x, lower=FALSE)

data(DATA)
split_word(DATA)
split_word(DATA, lower=FALSE)

## Larger data set
split_word(hamlet)
</code></pre>

<hr>
<h2 id='textshape'>Tools for Reshaping Text</h2><span id='topic+textshape'></span><span id='topic+package-textshape'></span>

<h3>Description</h3>

<p>Tools that can be used to reshape and restructure text data.
</p>

<hr>
<h2 id='tidy_colo_tdm'>Convert a 
<code><a href="tm.html#topic+DocumentTermMatrix">DocumentTermMatrix</a></code>/<code><a href="tm.html#topic+TermDocumentMatrix">TermDocumentMatrix</a></code> 
into Collocating Words in Tidy Form</h2><span id='topic+tidy_colo_tdm'></span><span id='topic+tidy_colo_dtm'></span>

<h3>Description</h3>

<p>Converts non-zero elements of a
<code><a href="tm.html#topic+DocumentTermMatrix">DocumentTermMatrix</a></code>/<code><a href="tm.html#topic+TermDocumentMatrix">TermDocumentMatrix</a></code> 
into a tidy data set made of collocating words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_colo_tdm(x, ...)

tidy_colo_dtm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_colo_tdm_+3A_x">x</code></td>
<td>
<p>A 
<code><a href="tm.html#topic+DocumentTermMatrix">DocumentTermMatrix</a></code>/<code><a href="tm.html#topic+TermDocumentMatrix">TermDocumentMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_colo_tdm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tidied data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unique_pairs">unique_pairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simple_dtm)

tidied &lt;- tidy_colo_dtm(simple_dtm)
tidied
unique_pairs(tidied)

## Not run: 
if (!require("pacman")) install.packages("pacman")
pacman::p_load_current_gh('trinker/gofastr', 'trinker/lexicon')
pacman::p_load(tidyverse, magrittr, ggstance)

my_dtm &lt;- with(
    presidential_debates_2012, 
    q_dtm(dialogue, paste(time, tot, sep = "_"))
)

tidy_colo_dtm(my_dtm) %&gt;%
    tbl_df() %&gt;%
    filter(!term_1 %in% c('i', lexicon::sw_onix) &amp; 
        !term_2 %in% lexicon::sw_onix
    ) %&gt;%
    filter(term_1 != term_2) %&gt;%
    unique_pairs() %&gt;%
    filter(n &gt; 15) %&gt;%
    complete(term_1, term_2, fill = list(n = 0)) %&gt;%
    ggplot(aes(x = term_1, y = term_2, fill = n)) +
        geom_tile() +
        scale_fill_gradient(low= 'white', high = 'red') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='tidy_dtm'>Convert a 
<code><a href="tm.html#topic+DocumentTermMatrix">DocumentTermMatrix</a></code>/<code><a href="tm.html#topic+TermDocumentMatrix">TermDocumentMatrix</a></code>
into Tidy Form</h2><span id='topic+tidy_dtm'></span><span id='topic+tidy_tdm'></span>

<h3>Description</h3>

<p>Converts non-zero elements of a
<code><a href="tm.html#topic+DocumentTermMatrix">DocumentTermMatrix</a></code>/<code><a href="tm.html#topic+TermDocumentMatrix">TermDocumentMatrix</a></code> 
into a tidy data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_dtm(x, ...)

tidy_tdm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_dtm_+3A_x">x</code></td>
<td>
<p>A 
<code><a href="tm.html#topic+DocumentTermMatrix">DocumentTermMatrix</a></code>/<code><a href="tm.html#topic+TermDocumentMatrix">TermDocumentMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_dtm_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tidied data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simple_dtm)

tidy_dtm(simple_dtm)

## Not run: 
if (!require("pacman")) install.packages("pacman")
pacman::p_load_current_gh('trinker/gofastr')
pacman::p_load(tidyverse, magrittr, ggstance)

my_dtm &lt;- with(
    presidential_debates_2012, 
    q_dtm(dialogue, paste(time, tot, sep = "_"))
)

tidy_dtm(my_dtm) %&gt;%
    tidyr::extract(
        col = doc, 
        into = c("time", "turn", "sentence"), 
        regex = "(\\d)_(\\d+)\\.(\\d+)"
    ) %&gt;%
    mutate(
        time = as.numeric(time),
        turn = as.numeric(turn),
        sentence = as.numeric(sentence)
    ) %&gt;%
    tbl_df() %T&gt;%
    print() %&gt;%
    group_by(time, term) %&gt;%
    summarize(n = sum(n)) %&gt;%
    group_by(time) %&gt;%
    arrange(desc(n)) %&gt;%
    slice(1:10) %&gt;%
    ungroup() %&gt;%
    mutate(
        term = factor(paste(term, time, sep = "__"),
            levels = rev(paste(term, time, sep = "__")))
    ) %&gt;%
    ggplot(aes(x = n, y = term)) +
        geom_barh(stat='identity') +
        facet_wrap(~time, ncol=2, scales = 'free_y') +
        scale_y_discrete(labels = function(x) gsub("__.+$", "", x))

## End(Not run)
</code></pre>

<hr>
<h2 id='tidy_list'>Tidy a List of Named Dataframes or Named Vectors or Vectors</h2><span id='topic+tidy_list'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+rbind">rbind</a></code> a named <code><a href="base.html#topic+list">list</a></code> of
<code><a href="base.html#topic+data.frame">data.frame</a></code>s or <code><a href="base.html#topic+vector">vector</a></code>s to
output a single <code><a href="base.html#topic+data.frame">data.frame</a></code> with the 
<code><a href="base.html#topic+names">names</a></code> from the <code><a href="base.html#topic+list">list</a></code> as an <code>id</code> 
column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_list(
  x,
  id.name = "id",
  content.name = "content",
  content.attribute.name = "attribute",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_list_+3A_x">x</code></td>
<td>
<p>A named <code><a href="base.html#topic+list">list</a></code> of
<code><a href="base.html#topic+data.frame">data.frame</a></code>s or <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_list_+3A_id.name">id.name</code></td>
<td>
<p>The name to use for the column created from the 
<code><a href="base.html#topic+list">list</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_list_+3A_content.name">content.name</code></td>
<td>
<p>The name to use for the column created from the 
<code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+vector">vector</a></code>s (only used if 
<code>x</code> is <code><a href="base.html#topic+vector">vector</a></code>).</p>
</td></tr>
<tr><td><code id="tidy_list_+3A_content.attribute.name">content.attribute.name</code></td>
<td>
<p>The name to use for the column created from the
<code><a href="base.html#topic+list">list</a></code> of names given to the <code><a href="base.html#topic+vector">vector</a></code>s
(only used if <code>x</code> is named <code><a href="base.html#topic+vector">vector</a></code>).</p>
</td></tr>
<tr><td><code id="tidy_list_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the 
<code><a href="base.html#topic+names">names</a></code> from the <code><a href="base.html#topic+list">list</a></code> as an <code>id</code> 
column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tidy_list(list(p=1:500, r=letters))
tidy_list(list(p=mtcars, r=mtcars, z=mtcars, d=mtcars))

x &lt;- list(
    a = setNames(c(1:4), LETTERS[1:4]),
    b = setNames(c(7:9), LETTERS[7:9]),
    c = setNames(c(10:15), LETTERS[10:15]),
    d = c(x=4, y=6, 4),
    e = setNames(1:10, sample(state.abb, 10, TRUE)),
    f = setNames(1:10, sample(month.abb, 10, TRUE))
)

tidy_list(x)

## Not run: 
## 2015 Vice-Presidential Debates Example
if (!require("pacman")) install.packages("pacman")
pacman::p_load(rvest, magrittr, xml2)

debates &lt;- c(
    wisconsin = "110908",
    boulder = "110906",
    california = "110756",
    ohio = "110489"
)

lapply(debates, function(x){
    paste0("http://www.presidency.ucsb.edu/ws/index.php?pid=", x) %&gt;%
        xml2::read_html() %&gt;%
        rvest::html_nodes("p") %&gt;%
        rvest::html_text() %&gt;%
        textshape::split_index(grep("^[A-Z]+:", .)) %&gt;%
        textshape::combine() %&gt;%
        textshape::split_transcript() %&gt;%
        textshape::split_sentence()
}) %&gt;%
    textshape::tidy_list("location")

## End(Not run)
</code></pre>

<hr>
<h2 id='tidy_matrix'>Convert a Matrix into Tidy Form</h2><span id='topic+tidy_matrix'></span><span id='topic+tidy_adjacency_matrix'></span>

<h3>Description</h3>

<p><code>tidy_matrix</code> - Converts matrices into a tidy data set.  Essentially, a
stacking of the matrix columns and repeating row/column names as necessary.
</p>
<p><code>tidy_adjacency_matrix</code> - A wrapper for <code>tidy_matrix</code> with the 
<code>row.name</code>, <code>col.name</code>, &amp; <code>value.name</code> all set to 
<code>"from"</code>,<code>"to"</code>, &amp; <code>"n"</code>, assuming preparation for network 
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_matrix(x, row.name = "row", col.name = "col", value.name = "value", ...)

tidy_adjacency_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_matrix_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="tidy_matrix_+3A_row.name">row.name</code></td>
<td>
<p>A string to use for the row names that are now a column.</p>
</td></tr>
<tr><td><code id="tidy_matrix_+3A_col.name">col.name</code></td>
<td>
<p>A string to use for the column names that are now a column.</p>
</td></tr>
<tr><td><code id="tidy_matrix_+3A_value.name">value.name</code></td>
<td>
<p>A string to use for the values that are now a column.</p>
</td></tr>
<tr><td><code id="tidy_matrix_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tidied <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:16, nrow = 4,
    dimnames = list(LETTERS[1:4], LETTERS[23:26])
)

mat
tidy_matrix(mat)


data(simple_dtm)
tidy_matrix(as.matrix(simple_dtm), 'doc', 'term', 'n')

X &lt;- as.matrix(simple_dtm[1:10, 1:10])
tidy_adjacency_matrix(crossprod(X))
tidy_adjacency_matrix(crossprod(t(X)))
</code></pre>

<hr>
<h2 id='tidy_table'>Tidy a Table: Bind Its Values with Its Names</h2><span id='topic+tidy_table'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+cbind">cbind</a></code> a <code><a href="base.html#topic+table">table</a></code>'s values with its
<code><a href="base.html#topic+names">names</a></code> to form <code>id</code> (from the names) and
<code>content</code> columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_table(x, id.name = "id", content.name = "content", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_table_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+table">table</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_table_+3A_id.name">id.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+table">table</a></code>
<code><a href="base.html#topic+names">names</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_table_+3A_content.name">content.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+table">table</a></code>
values.</p>
</td></tr>
<tr><td><code id="tidy_table_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the <code><a href="base.html#topic+names">names</a></code>
from the <code><a href="base.html#topic+table">table</a></code> as an <code>id</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- table(sample(LETTERS[1:6], 1000, TRUE))
tidy_table(x)
</code></pre>

<hr>
<h2 id='tidy_vector'>Tidy a Named Atomic Vector: Bind Its Values with Its Names</h2><span id='topic+tidy_vector'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+cbind">cbind</a></code> a named atomic <code><a href="base.html#topic+vector">vector</a></code>'s values
with its <code><a href="base.html#topic+names">names</a></code> to form <code>id</code> (from the names) and
<code>content</code> columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_vector(x, id.name = "id", content.name = "content", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_vector_+3A_x">x</code></td>
<td>
<p>A named atomic <code><a href="base.html#topic+vector">vector</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_vector_+3A_id.name">id.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+vector">vector</a></code>
<code><a href="base.html#topic+names">names</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_vector_+3A_content.name">content.name</code></td>
<td>
<p>The name to use for the column created from the <code><a href="base.html#topic+vector">vector</a></code>
values.</p>
</td></tr>
<tr><td><code id="tidy_vector_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the <code><a href="base.html#topic+names">names</a></code>
from the <code><a href="base.html#topic+vector">vector</a></code> as an <code>id</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- setNames(sample(LETTERS[1:6], 1000, TRUE), sample(state.name[1:5], 1000, TRUE))
tidy_vector(x)
</code></pre>

<hr>
<h2 id='unique_pairs'>Extract Only Unique Pairs of Collocating Words in 
<code><a href="#topic+tidy_colo_dtm">tidy_colo_dtm</a></code></h2><span id='topic+unique_pairs'></span><span id='topic+unique_pairs.default'></span><span id='topic+unique_pairs.data.table'></span>

<h3>Description</h3>

<p><code><a href="#topic+tidy_colo_dtm">tidy_colo_dtm</a></code> utilizes the entire matrix to generate
the tidied data.frame.  This means that the upper and lower triangles are
used redundantly.  This function eliminates this redundancy by dropping one
set of the pairs from a tidied data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_pairs(x, col1 = "term_1", col2 = "term_2", ...)

## Default S3 method:
unique_pairs(x, col1 = "term_1", col2 = "term_2", ...)

## S3 method for class 'data.table'
unique_pairs(x, col1 = "term_1", col2 = "term_2", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_pairs_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with two columns that contain
redundant pairs.</p>
</td></tr>
<tr><td><code id="unique_pairs_+3A_col1">col1</code></td>
<td>
<p>A string naming column 1.</p>
</td></tr>
<tr><td><code id="unique_pairs_+3A_col2">col2</code></td>
<td>
<p>A string naming column 2.</p>
</td></tr>
<tr><td><code id="unique_pairs_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a filtered <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy_colo_dtm">tidy_colo_dtm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(
    term_1 = LETTERS[1:10],
    term_2 = LETTERS[10:1],
    stringsAsFactors = FALSE
)

unique_pairs(dat)
</code></pre>

<hr>
<h2 id='unnest_text'>Un-nest Nested Text Columns</h2><span id='topic+unnest_text'></span>

<h3>Description</h3>

<p>Un-nest nested text columns in a data.frame.   Attempts to locate the nested 
text column without specifying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_text(dataframe, column, integer.rownames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_text_+3A_dataframe">dataframe</code></td>
<td>
<p>A dataframe object.</p>
</td></tr>
<tr><td><code id="unnest_text_+3A_column">column</code></td>
<td>
<p>Column name to search for markers/terms.</p>
</td></tr>
<tr><td><code id="unnest_text_+3A_integer.rownames">integer.rownames</code></td>
<td>
<p>logical.  If <code>TRUE</code> then the rownames are 
numbered 1 through number of rows, otherwise the original row number is 
retained followed by a period and the element number from the list.</p>
</td></tr>
<tr><td><code id="unnest_text_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an un-nested data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- DATA

## Add a nested/list text column
dat$split &lt;- lapply(dat$state, function(x) {
    unlist(strsplit(x, '(?&lt;=[?!.])\\s+', perl = TRUE))
})

unnest_text(dat)
unnest_text(dat, integer.rownames = FALSE)

## Add a second nested integer column
dat$d &lt;- lapply(dat$split, nchar)
## Not run: 
unnest_text(dat) # causes error, must supply column explicitly

## End(Not run)
unnest_text(dat, 'split')

## As a data.table
library(data.table)
dt_dat &lt;- data.table::as.data.table(data.table::copy(dat))
unnest_text(dt_dat, 'split')
## Not run: 
unnest_text(dt_dat, 'd')

## End(Not run)

## Not run: 
## As a tibble
library(tibble)
t_dat &lt;- tibble:::as_tibble(dat)
unnest_text(t_dat, 'split')

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
