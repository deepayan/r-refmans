<!DOCTYPE html><html><head><title>Help for package ems</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ems}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#breastCancer'><p>German Breast Cancer Dataset</p></a></li>
<li><a href='#calcurve'><p>Calibration Curve</p></a></li>
<li><a href='#dataquality'><p>Collection of functions to check data quality in a dataset and remove not valid or extreme values.</p></a></li>
<li><a href='#funnel'><p>Funnel plot for benchmarking health units</p></a></li>
<li><a href='#icu'><p>Data from ICU admissions.</p></a></li>
<li><a href='#miscellaneous'><p>Miscellaneous functions for data editing</p></a></li>
<li><a href='#mortality_rate'><p>Mortality Rate</p></a></li>
<li><a href='#reclass'><p>Comparisson of the Standardized Resource Use (SRU)</p></a></li>
<li><a href='#SMR'><p>Standardized Mortality Ratio (SMR)</p></a></li>
<li><a href='#SRU'><p>Standardized Resource Use (SRU)</p></a></li>
<li><a href='#survPerformance'><p>Survival models performance analysis</p></a></li>
<li><a href='#tableStack'><p>Tabulation of variables in a stack form</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Epimed Solutions Collection for Data Editing, Analysis, and
Benchmark of Health Units</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of functions related to benchmark with prediction models
	 for data analysis and editing of clinical and epidemiological data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, survival, rms</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-09 19:46:18 UTC; thamires.marques</td>
</tr>
<tr>
<td>Author:</td>
<td>Lunna Borges [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lunna Borges &lt;lunna.borges@epimedsolutions.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-09 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='breastCancer'>German Breast Cancer Dataset</h2><span id='topic+breastCancer'></span>

<h3>Description</h3>

<p>A dataset containing variables related with breast cancer from german population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breastCancer
</code></pre>


<h3>Format</h3>

<p>A data frame with 686 rows and 14 variables
</p>


<h3>Details</h3>


<ul>
<li> <p><code>age</code> Patient age (years).
</p>
</li>
<li> <p><code>meno</code> Menopausal status (0 = premeno, 1 = postmeno).
</p>
</li>
<li> <p><code>size</code> Tumour size (mm).
</p>
</li>
<li> <p><code>gradd1</code> 1 = tumour grade 2 or 3; 0 = grade 1.
</p>
</li>
<li> <p><code>gradd2</code> 1 = tumour grade 3; 0 = grade 1 or 2.
</p>
</li>
<li> <p><code>nodes</code> Number of positive lymph nodes.
</p>
</li>
<li> <p><code>enodes</code> emp(-0.12 x <code>nodes</code>).
</p>
</li>
<li> <p><code>pgr</code> Progesterone receptor status (fmol 1^-1).
</p>
</li>
<li> <p><code>er</code> Oestrogen reeceotor status (fmol 1^-1).
</p>
</li>
<li> <p><code>hormon</code> Tamoxifen treatment (0 = no; 1 = yes).
</p>
</li>
<li> <p><code>rectime</code> Time (days) to death or cancer recurrence.
</p>
</li>
<li> <p><code>censrec</code> Censoring (0 = censored; 1 = event).
</p>
</li></ul>



<h3>Source</h3>

<p>https://biostat.app.vumc.org/wiki/Main/DataSets
</p>

<hr>
<h2 id='calcurve'>Calibration Curve</h2><span id='topic+calcurve'></span><span id='topic+print.calcurve'></span><span id='topic+plot.calcurve'></span>

<h3>Description</h3>

<p><code>calcurve</code> function returns a data.frame containing the number of patients, the observed mortality rate and the predicted mortality rate for each category of the predicted mortality rate. If any other acute physiology score is given, the function will also return the mortality rate predicted by this score for each category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcurve(
  deaths,
  pred,
  score = NULL,
  name_score = "Saps3",
  other_score = NULL,
  name_other_score = NULL,
  categories_option = c("predicted", "score", "patients"),
  table = FALSE,
  plot = TRUE,
  title_label = "Calibration Curve",
  y1axis_label = "Patients (n)",
  y2axis_label = "Mortality Rate (%)",
  score_color = c("#cac7cc", "#ffc341", "#33cca3"),
  bar_color = "#1f77b4",
  points = c(19, 18, 17),
  cultureCode = "en-US",
  legend_inset = -0.7
)

## S3 method for class 'calcurve'
print(x, ...)

## S3 method for class 'calcurve'
plot(
  x,
  ...,
  xlab = NULL,
  ylab2 = NULL,
  main = x$title_label,
  text = x$y2axis_label,
  ylab = x$y1axis_label,
  col = c(x$bar_color, x$score_color),
  pch = x$points,
  cultureCode = x$cultureCode,
  legend_inset = x$legend_inset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcurve_+3A_deaths">deaths</code></td>
<td>
<p>a numerical vector that only contains 0 and 1, indicating whether the patient was alive or dead, respectively.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_pred">pred</code></td>
<td>
<p>a numerical vector that contains the mortality rate predicted by the main score, in percentage, for each patient.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_score">score</code></td>
<td>
<p>a numerical vector that contains the main score punctuation for each patient, or NULL.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_name_score">name_score</code></td>
<td>
<p>a character string which determines the name of the main score.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_other_score">other_score</code></td>
<td>
<p>a list of numerical vectors, where each vector contains the mortality rate predicted by other score, in percentage, for each patient, or NULL (the default).</p>
</td></tr>
<tr><td><code id="calcurve_+3A_name_other_score">name_other_score</code></td>
<td>
<p>if other_score variable is different from NULL, this argument must be a vector with the name(s) of the score(s) given.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_categories_option">categories_option</code></td>
<td>
<p>a character string which determines if the categories will refer to the main score or to the predicted mortality rate. Accepted values are 'predicted' (the default), 'score' or 'patients'.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_table">table</code></td>
<td>
<p>logical; if <code>TRUE</code> prints the <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>TRUE</code> (the default) plots the categories chosen versus the mortality rates in the secondary vertical axis. The main vertical axis refers to the number of patients in each category, represented by the bars.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_title_label">title_label</code></td>
<td>
<p>main title for <code>calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_y1axis_label">y1axis_label</code>, <code id="calcurve_+3A_y2axis_label">y2axis_label</code></td>
<td>
<p>labels of the main vertical axis and the secondary axis, respectively, for <code>calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_score_color">score_color</code></td>
<td>
<p>a vector with the colors to be used in the score traces for <code>calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_bar_color">bar_color</code></td>
<td>
<p>color of the bars for <code>calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_points">points</code></td>
<td>
<p>a vector with markers types of the scores for <code>calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_culturecode">cultureCode</code></td>
<td>
<p>a character specifying which language should be used for plot x axis title and legends. Possible values are 'pt-BR' and 'en-US'. The default is 'en-US'.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_legend_inset">legend_inset</code></td>
<td>
<p>inset distance(s) from the margins as a fraction of the plot region when legend is placed by keyword. See <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_x">x</code></td>
<td>
<p>an object of class 'calcurve'.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_xlab">xlab</code></td>
<td>
<p>label of the horizontal axis for <code>plot.calcurve</code>, defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_ylab2">ylab2</code></td>
<td>
<p>label of the secondary vertical axis for <code>plot.calcurve</code>, defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_main">main</code></td>
<td>
<p>main title for <code>plot.calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_text">text</code></td>
<td>
<p>label of the secondary vertical axis for <code>plot.calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_ylab">ylab</code></td>
<td>
<p>label of the main vertical axis for <code>plot.calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_col">col</code></td>
<td>
<p>character vector with the colors of the bars and score traces, in this order, for <code>plot.calcurve</code>.</p>
</td></tr>
<tr><td><code id="calcurve_+3A_pch">pch</code></td>
<td>
<p>a vector with markers types of the scores for <code>plot.curve</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>categories_option = 'score'</code>, the categories will refer to the deciles of the main score punctuation. If <code>categories_option = 'predicted'</code>, the categories will refer to fixed intervals of the predicted mortality rate. If <code>categories_option = 'patients'</code> the categories will refer to the deciles of patients.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Camila Cardoso
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Loading the dataset
data(icu)

# Calibration Curve Plot
a &lt;- calcurve(deaths = icu$UnitDischargeName,
pred = icu$Saps3DeathProbabilityStandardEquation,
score = icu$Saps3Points, name_score = 'Saps3',
categories_option = 'predicted', table = FALSE, plot = TRUE)


</code></pre>

<hr>
<h2 id='dataquality'>Collection of functions to check data quality in a dataset and remove not valid or extreme values.</h2><span id='topic+dataquality'></span><span id='topic+t_factor'></span><span id='topic+factor.table'></span><span id='topic+t_num'></span><span id='topic+num.table'></span><span id='topic+t_date'></span><span id='topic+date.table'></span><span id='topic+rm.unwanted'></span>

<h3>Description</h3>

<p>These functions return the counts and fractions of expected values, unexpected values, missing values and not valid values. They are able to do it with factor variables, numeric variables and date variables. <code>t_factor</code>, <code>t_num</code>, and <code>t_date</code> do the job for a single variable and have simpler arguments, while <code>factor.table</code>, <code>num.table</code>, and <code>date.table</code> do the job for several variables at once. <code>rm.unwanted</code> cheks the factor and numeric variables and remove the not valid or extreme values. This approach is attractive before data imputation. They all return a <code>data.frame</code>.
</p>
<p><code>t_factor</code> and <code>factor.table</code> will try to get factor or character variables and check how much of its content match with the expectd. They will try to treat the levels or cells containing &quot; &quot; as <code>NAs</code>.
</p>
<p><code>t_num</code> will try to get a numeric variable (even if it is currently formated as character or factor) and check how much of its content is expected (match a desired range), unexpected, non-numeric values and missing vlaues. <code>num.table</code> does the same, but for two or more variables at once.
</p>
<p><code>t_date</code> will try to get a date variable (even if it is currently formated as character or factor) and check how much of its content is expected (match a desired range), unexpected, non-date values and missing vlaues. <code>date.table</code> does the same, but for two or more variables at once.
</p>
<p><code>rm.unwanted</code> will chek in data the variables specified in the limits object according to the limits specified for each variable. If there are levels considered not valid in a factor variable, these levels are deleted. For example, if Sex is expected to be &quot;M&quot; and &quot;F&quot;, and there is also an &quot;I&quot; level in data, every &quot;I&quot; is replaced by <code>NA</code>. Similarly, misspelled levels will be understood as non-valid levels and coercerd to <code>NA</code>, with the exception of leading or trailing empty spaces and lower and upper cases diferences if <code>try.keep = TRUE</code>. If there is a continuous numeric variable and it is expected to have values ranging from 30 to 700, the values outside this range, i.e. higher then 700 or lower then 30, are replaced by <code>NA</code>. Non-numeric elements, i.e. non-valid elements that should be numeric, will also be coerced to <code>NA</code>. If a varible is specified in <code>num.limits</code>, then it will be returned as a numeric variable, even if it was formated as factor or character. If a variable is specified in limits, the returnig format will depend on the <code>stringAsFactors</code> argument, unless it is formated as logical. In this case it is skipped. The arguments <code>limits</code> and <code>num.limits</code> may be <code>NULL</code>, meaning that the factor-character variables or the numeric variables , respectively, will not be edited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_factor(
  data,
  variable,
  legal,
  var.labels = attr(data, "var.labels")[match(variable, names(data))],
  digits = 3
)

factor.table(
  data,
  limits,
  var.labels = attr(data, "var.labels")[match(unlist(sapply(seq_along(limits),
    function(i) limits[[i]][1])), names(data))],
  digits = 3
)

t_num(
  data,
  num.var,
  num.max = 100,
  num.min = 0,
  var.labels = attr(data, "var.labels")[match(num.var, names(data))],
  digits = 3
)

num.table(
  data,
  num.limits,
  var.labels = attr(data, "var.labels")[match(num.limits$num.var, names(data))],
  digits = 3
)

t_date(
  data,
  date.var,
  date.max = as.Date("2010-11-30"),
  date.min = as.Date("2010-01-31"),
  format.date = "auto",
  digits = 3,
  var.labels = attr(data, "var.labels")[match(date.var, names(data))]
)

date.table(
  data,
  date.limits,
  format.date = "auto",
  digits = 3,
  var.labels = attr(data, "var.labels")[match(date.limits$date.var, names(data))]
)

rm.unwanted(
  data,
  limits = NULL,
  num.limits = TRUE,
  try.keep = TRUE,
  stringAsFactors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataquality_+3A_data">data</code></td>
<td>
<p>A data.frame where variables will be tested.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_variable">variable</code></td>
<td>
<p>A character vector of length one, indicating the name of the variable in the dataset to be tested.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_legal">legal</code></td>
<td>
<p>A character vector representeing the expected levels of the tested variable.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_var.labels">var.labels</code></td>
<td>
<p>Variables labels for a nice output. Must be informed in the same order as variable argument. By default, it captures the labels stored in attr(data, &quot;var.labels&quot;), if any. If not informed, the function returns the variables names.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places for rounding.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_limits">limits</code></td>
<td>
<p>a list of two or more lists, each containing the arguments variable name and legal levels (in this order), to check on the factor variables. In the case of <code>rm.unwanted</code>, if left NULL, it means no numeric variable will be checked. See examples.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_num.var">num.var</code></td>
<td>
<p>A character vector indicating the name of a variable that should be numeric (although it can yet be formated as character or factor).</p>
</td></tr>
<tr><td><code id="dataquality_+3A_num.max">num.max</code>, <code id="dataquality_+3A_num.min">num.min</code></td>
<td>
<p>The maximal and minimal limits of acceptable range of a numeric variable.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_num.limits">num.limits</code></td>
<td>
<p>A data.frame with the following variables: num.var, num.max and num.min, representing the numeric variables names, maximal and minimal expected valid values. In the case of <code>rm.unwanted</code>, if left NULL, it means no numeric variable will be checked. See example.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_date.var">date.var</code></td>
<td>
<p>A character vector indicating the name of a variable in data that should be a date (althoug it can yet be formated as character or factor).</p>
</td></tr>
<tr><td><code id="dataquality_+3A_date.max">date.max</code>, <code id="dataquality_+3A_date.min">date.min</code></td>
<td>
<p>The maximal and minimal limits of acceptable range of a date variable.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_format.date">format.date</code></td>
<td>
<p>Default is &quot;auto&quot;. If so, <code>t_date</code> will use <code><a href="#topic+f.date">f.date</a></code> to detect the date format and format it as date. If not set to &quot;auto&quot;, it should be a date format to be passed to <code><a href="base.html#topic+as.Date">as.Date</a></code> format argument. If <code>format.date</code> is misspecified, then <code>t_date</code> and <code>date.table</code> will identify all dates as non-dates. For <code>date.table</code>, if it is set to 'auto' , it will use <code><a href="#topic+f.date">f.date</a></code> to detect the date format and format it as date. If different from 'auto', one should specify the desired date formats in the date.limits data.frame. See example.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_date.limits">date.limits</code></td>
<td>
<p>A <code>data.frame</code> with the following variables: date.var, date.max, date.min, and (optionaly) format.date. These represent values of the arguments above. See example.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_try.keep">try.keep</code></td>
<td>
<p>Default is <code>TRUE</code>. If <code>TRUE</code>, <code>remove.unwanted</code> will first trim all empty spaces and transform all levels to lower case characters before comparing the found levels and expected levels of a character/factor variable. Therefore, found levels such as &quot;yes  &quot; will be considered identical to the expected level &quot;Yes&quot;, and will not be coerced to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="dataquality_+3A_stringasfactors">stringAsFactors</code></td>
<td>
<p>In <code>rm.unwanted</code>, if set to <code>TRUE</code>, the default value, variables in the limits argument that are character and numeric variables in data will be returned as factors. Logical variables are skipped. However, a variable will be returned as logical if it is originally a factor but its final levels are <code>TRUE</code> and <code>FALSE</code> and <code>stringAsFactors = FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lunna Borges &amp; Pedro Brasil
</p>


<h3>See Also</h3>

<p><code><a href="#topic+miscellaneous">miscellaneous</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulating a dataset with 5 factor variables and assigning labels
y &lt;- data.frame(Var1 = sample(c("Yes","No", "Ignored", "", "yes ", NA), 200, replace = TRUE),
                Var2 = sample(c("Death","Discharge", "", NA), 200, replace = TRUE),
                Var3 = sample(c(16:35, NA), 200, replace = TRUE),
                Var4 = sample(c(12:300, "Female", "", NA), 200, replace = TRUE),
                Var5 = sample(c(60:800), 200, replace = TRUE))
attr(y, "var.labels") &lt;- c("Intervention use","Unit destination","BMI","Age","Cholesterol")
summary(y)

# Cheking the quality only the first variable
t_factor(y, "Var1", c("Yes","No","Ignored"))

# Checking two or more variables at once
factor.limits  = list(list("Var1",c("Yes","No")),
                      list("Var2",c("Death","Discharge")))
factor.table(y, limits = factor.limits)

# Checking only one variable that shohuld be numeric
t_num(y,"Var3", num.min = 17, num.max = 32)

# Making the limits data.frame
num.limits &lt;- data.frame(num.var = c("Var3","Var4","Var5"),
              num.min = c(17,18,70), num.max = c(32,110,300))
num.limits

# Checking two or more numeric variables (or the ones that
#          should be as numeric) at once
num.table(y, num.limits)

# Removing the unwanted values (extremes or not valid).
y &lt;- rm.unwanted(data = y, limits = factor.limits,
                           num.limits = num.limits)
summary(y)

rm(y, num.limits, factor.limits)
#'
# Loading a dataset and assigning labels
data(icu)
attr(icu, "var.labels")[match(c("UnitAdmissionDateTime","UnitDischargeDateTime",
   "HospitalAdmissionDate", "HospitalDischargeDate"), names(icu))] &lt;-
   c("Unit admission","Unit discharge","Hospital admission","Hospital discharge")

# Checking only one variable that should be a date.
t_date(icu, "HospitalDischargeDate", date.max = as.Date("2013-10-30"),
                                     date.min = as.Date("2013-02-20"))

# Checking a date variable misspecifying the date format
# will cause the variable dates to be identified as non-date values.
t_date(data = icu, date.var = "HospitalDischargeDate",
                   date.max = as.Date("2013-10-30"),
                   date.min = as.Date("2013-02-20"),
                   format.date = "%d/%m/%Y")

# Making a limit data.frame assuming an 'auto' format.date
d.lim &lt;- data.frame(date.var = c("UnitAdmissionDateTime","UnitDischargeDateTime",
                   "HospitalAdmissionDate","HospitalDischargeDate"),
                   date.min = rep(as.Date("2013-02-28"), 4),
                   date.max = rep(as.Date("2013-11-30"), 4))
d.lim

# Checking two or more date variables (or the ones that should be as date) at once
date.table(data = icu, date.limits = d.lim)

# Making a limit data.frame specifying format.date argument
# Here the the last 'format.date' is missspecified on purpose
# So, the last date will be identified as non-date values.
d.lim &lt;- data.frame(date.var = c("UnitAdmissionDateTime","UnitDischargeDateTime",
         "HospitalAdmissionDate","HospitalDischargeDate"),
          date.min = rep(as.Date("2013-02-28"), 4),
          date.max = rep(as.Date("2013-11-30"), 4),
          format.date = c(rep("%Y/%m/%d",3), "%Y-%m-%d"))
d.lim

# Checking the quality of date variable with new limits.
# The 'format.date = ""' is required to force the function to look the format
# into the date.limits data.frame
date.table(data = icu, date.limits = d.lim, format.date = "")

rm(icu, d.lim)

</code></pre>

<hr>
<h2 id='funnel'>Funnel plot for benchmarking health units</h2><span id='topic+funnel'></span><span id='topic+print.funnel'></span><span id='topic+plot.funnel'></span><span id='topic+rateFunnel'></span><span id='topic+changeRateFunnel'></span><span id='topic+propFunnel'></span><span id='topic+changePropFunnel'></span>

<h3>Description</h3>

<p>Produces a variety of funnel plots comparing health units or ICUs (intensive care units) making easy to identify those units which deviate from the group. There is a function that calculates all the values required and returns the values for all units and the funnel, and there is a function that calls graphical parameters from the former values. The options of funnels available are the funnel for rate, for ratio of rates, for proportions, for difference of proportions and for ratio of proportions.
</p>
<p>The funnel for rates are usually plots of either SMR or SRU at vertical axis. If the direct method is chosen, the horizontal axis will display the number of admissions. If the indirect method is chosen instead, the expected number of deaths will be displayed for SMR or the expected length of stay for SRU. As consequence of this differentiation, the interpretation regarding the clssification of the points displayed will be the same in every case.
</p>
<p>The funnel for ratio of rates are usually plots of ratios of SMRs (or SRUs) within the same units. These two SMRs are, for example, from the same units in different time periods. Therefore, it expresses how the SMR changed over time. If the number of expected deaths is different in both periods, the plot will return at the horizontal axis a parametrization of the geometric mean of the expected number of deaths in both periods for each unit. If the number of expected deaths is identical in both periods, the plot will return at the horizontal axis the arithmetic mean of the observed number of deaths in both periods for each unit.
</p>
<p>The funnel for proportions plots on the vertical axis the percentage of observed deaths of the units and on the horizontal axis the number (volume) of admissions. The funnel for ratio of proportions and for difference of proportions are usually used to express the fraction of deaths of the same units in different time period. Therefore, they express how the fraction of deaths changed over time in each unit. If one picks the difference of proportions, the horizontal axis will display a parametrization of the arithmetic mean of the number of admissions in both periods. If one picks the ratio of proportions, the horizontal axis will display a parametrization of the geometric mean of the number of admissions in both periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funnel(
  unit,
  y,
  n,
  n1,
  n2,
  o,
  o1,
  o2,
  e,
  e1,
  e2,
  lambda1 = sum(o1)/sum(n1),
  lambda2 = sum(o2)/sum(n2),
  pi1 = sum(o1)/sum(n1),
  pi2 = sum(o2)/sum(n2),
  y.type = c("SMR", "SRU"),
  p = c(0.95, 0.998),
  theta,
  method = c("normal", "exact"),
  direct = FALSE,
  myunits = rep(0, length(unit)),
  option = c("rate", "ratioRates", "prop", "diffProp", "ratioProp"),
  printUnits = TRUE,
  plot = TRUE,
  digits = 5,
  overdispersion = FALSE,
  ...
)

## S3 method for class 'funnel'
print(x, ...)

## S3 method for class 'funnel'
plot(
  x,
  ...,
  col = c("darkblue", "paleturquoise3", "gray26"),
  lwd = 2,
  lty = c(2, 6, 1),
  bty = "n",
  pch = 21,
  pt.col = "white",
  bg = "orange",
  pt.cex = 1.5,
  auto.legend = TRUE,
  text.cex = 0.7,
  text.pos = NULL,
  mypts.col = "darkblue",
  printUnits = x$printUnits,
  xlab = x$xlab,
  ylab = x$ylab,
  xlim = x$xlim,
  ylim = x$ylim
)

rateFunnel(
  unit,
  y,
  n,
  o,
  e,
  y.type,
  p,
  theta = 1,
  method = c("exact", "normal"),
  direct,
  ...,
  printUnits,
  auto.xlab = TRUE,
  xlab = c("Volume of cases", "Expected values"),
  ylab = y.type[1],
  xlim = c(0, max(rho)),
  ylim = c(min(lowerCI[[which(p == max(p))]]), max(upperCI[[which(p == max(p))]])),
  myunits,
  digits,
  overdispersion
)

changeRateFunnel(
  unit,
  n1,
  n2,
  o1,
  e1,
  o2,
  e2,
  lambda1,
  lambda2,
  y.type,
  p,
  ...,
  printUnits,
  auto.xlab = TRUE,
  xlab = c("Average observed count", "Expectation per period"),
  auto.ylab = TRUE,
  ylab = c(paste0(y.type[1], "'s Ratio"), paste0("Log(", y.type[1], "'s Ratio)")),
  ylim = c(max(lowerCI[[which(p == max(p))]]) - 1.5 * theta, min(upperCI[[which(p ==
    max(p))]]) + 1.5 * theta),
  xlim = c(0, max(rho)),
  myunits,
  digits,
  overdispersion
)

propFunnel(
  unit,
  o,
  n,
  theta,
  p,
  method = c("exact", "normal"),
  ...,
  printUnits,
  ylab = "%",
  xlab = "Volume",
  ylim = c(0, min(upperCI[[which(p == max(p))]]) + 2.5 * theta),
  xlim = c(0, max(n)),
  myunits,
  digits,
  overdispersion
)

changePropFunnel(
  unit,
  o1,
  o2,
  n1,
  n2,
  p,
  pi1,
  pi2,
  method = c("diff", "ratio"),
  ...,
  printUnits,
  xlab = "Sample size per period",
  auto.ylab = TRUE,
  ylab = c("Proportions difference", "Proportions ratio log"),
  ylim = c(max(lowerCI[[which(p == max(p))]]) - 6 * theta, min(upperCI[[which(p ==
    max(p))]]) + 6 * theta),
  xlim = c(0, max(rho)),
  myunits,
  digits,
  overdispersion
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funnel_+3A_unit">unit</code></td>
<td>
<p>A factor vector representing the unit names.</p>
</td></tr>
<tr><td><code id="funnel_+3A_y">y</code></td>
<td>
<p>A numeric vector representing the &quot;Standardized rate&quot; for each unit, usually the SMR (Standardized Mortality Ratio), or possibly the SRU (Standardized Resource Use), accordind to <code>y.type</code> . It's also called &quot;indicator&quot;.</p>
</td></tr>
<tr><td><code id="funnel_+3A_n">n</code></td>
<td>
<p>A numeric vector representing the case volume, or number of admissions, for each unit.</p>
</td></tr>
<tr><td><code id="funnel_+3A_n1">n1</code>, <code id="funnel_+3A_n2">n2</code></td>
<td>
<p>If one picks <code>option = "ratioRates"</code> or <code>option = "diffProp"</code> or <code>option = "ratioProp"</code>, then <code>n1</code> and <code>n2</code> are numeric vectors representing the total of admissions at 1st and 2nd periods, respectively.</p>
</td></tr>
<tr><td><code id="funnel_+3A_o">o</code></td>
<td>
<p>A numeric vector representing the observed death. Acceptable values are 0 (absence) or 1 (presence).</p>
</td></tr>
<tr><td><code id="funnel_+3A_o1">o1</code>, <code id="funnel_+3A_o2">o2</code></td>
<td>
<p>If one picks <code>option = "ratioRates"</code> or <code>option = "diffProp"</code> or <code>option = "ratioProp"</code>, then <code>o1</code> and <code>o2</code> are numeric vectors representing the observed deaths at 1st and 2nd periods, respectively.</p>
</td></tr>
<tr><td><code id="funnel_+3A_e">e</code></td>
<td>
<p>Used only when <code>option = "rate"</code> and <code>direct = FALSE</code>. This is a numeric vector representing the expected number of deaths.</p>
</td></tr>
<tr><td><code id="funnel_+3A_e1">e1</code>, <code id="funnel_+3A_e2">e2</code></td>
<td>
<p>If one picks <code>option = "ratioRates"</code>, <code>e1</code> and <code>e2</code> are numeric vectors representing the expected number of deaths at 1st and 2nd periods, respectively.</p>
</td></tr>
<tr><td><code id="funnel_+3A_lambda1">lambda1</code>, <code id="funnel_+3A_lambda2">lambda2</code></td>
<td>
<p>Values correponding to the rate at which a death occurs in the institutions at the 1st and 2nd periods, respectively. It is assumed that the parameters <code>o1</code> and <code>o2</code> are distributed as <code>oi</code> ~ Poisson(<code>lambdai</code>) when <code>option = "ratioRates"</code>. The default value for <code>lambdai</code> is <code>lambdai = sum(oi)/sum(ni)</code>, where ni is the value of the parameter <code>n1</code> or <code>n2</code> when i equals 1 or 2. <code>lambdai</code> is the estimate for the mean of the poisson distribution.</p>
</td></tr>
<tr><td><code id="funnel_+3A_pi1">pi1</code>, <code id="funnel_+3A_pi2">pi2</code></td>
<td>
<p>Values correponding to the probability for the occurrence of a death in the institutions at the 1st and 2nd periods, respectively. Its assumed that the paramenters <code>o1</code> and <code>o2</code> are distributed as <code>oi</code> ~ Bin(<code>pii,ni</code>) when <code>option = "diffProp"</code> or <code>option = "ratioProp"</code>. <code>ni</code> is the value of the parameter n1 or n2 when i equals 1 or 2. The default value for <code>pii</code> is <code>sum(oi)/sum(ni)</code>, the estimate for the mean of the poisson distribution.</p>
</td></tr>
<tr><td><code id="funnel_+3A_y.type">y.type</code></td>
<td>
<p>A character vector representing the indicator type. It is used to name the vertical axis if <code>option = "rate"</code> or <code>option = "ratioRate"</code> and ignored otherwise. It usually is 'SMR' or 'SRU'.</p>
</td></tr>
<tr><td><code id="funnel_+3A_p">p</code></td>
<td>
<p>A confidence level numeric vector. The function will return a confidence interval for each value in p. The default is 2 and 3 standard deviations (<code>p = c(.95, 998)</code>).</p>
</td></tr>
<tr><td><code id="funnel_+3A_theta">theta</code></td>
<td>
<p>The target value which specifies the desired expectation for institutions considered &quot;in control&quot;. Used when <code>option = "prop"</code> or <code>option = "rate"</code>. Usually, this function internally estimates a theta to represent a central tendency of the group. However, one may want to set a pre-specified value for theta to indicate a &quot;baseline&quot; parameter for comparison (e.g 1 for <code>option = "rate"</code> or .20 for <code>option = "prop"</code>). If this is the case, the horizontal line representing theta may not be centralized in the funnel or may be even outside the funnel, making the plot look unusual.</p>
</td></tr>
<tr><td><code id="funnel_+3A_method">method</code></td>
<td>
<p>There are two kinds of approximations for the CI, as mentioned in <code>direct</code> parameter. The one from the exact distribuition (binomial or poisson) and the one from the normal distribution. So, <code>method</code> is a character vector representing the kind of approximation desired, being <code>"exact"</code> (default) or <code>"normal"</code> the two options. It is used when <code>option = "rate"</code> or <code>option = "prop"</code>. The original report makes no formal comparison of which method is best, however it is mentioned that the funnels from different methods should look identical or very similar if all units have 100 or more observations. If any unit has less, the funnel from the normal approximation may mislead the interpretation. See details.</p>
</td></tr>
<tr><td><code id="funnel_+3A_direct">direct</code></td>
<td>
<p>Logical (default = <code>FALSE</code>); Used when <code>option = "rate"</code>. If <code>TRUE</code>, we assume the vector of rates &quot;y&quot; is being reported as a rate per (say) 1000 individuals, and that it has been transformed to a proportion between 0 and 1. The associated error (horizontal axis) will be measured accordingly to the size of the populations <code>n</code>. The CI - confidence interval - is calculated by a binomial distribution. If <code>FALSE</code>, the associated error will be measured accordingly to the expected number of deaths <code>e</code>. The CI is calculated by a poisson distribution instead. See details.</p>
</td></tr>
<tr><td><code id="funnel_+3A_myunits">myunits</code></td>
<td>
<p>A numeric vector coded with 0 and 1 indicating which units one would like to benchmark among all units. These will be highlighted with dots of different collors in the plot.</p>
</td></tr>
<tr><td><code id="funnel_+3A_option">option</code></td>
<td>
<p>A character specifying the type of funnel plot one wants to produce. It can assume <code>"rate"</code>, <code>"ratioRates"</code>, <code>"prop"</code>, <code>"diffProp"</code> or <code>"ratioProp"</code>. If <code>option = "rate"</code>, <code>funnel</code> plots a standardized rate y versus the expected number of deaths or case volume (number of unit admissions) for all units. If <code>option = "ratioRate"</code>, <code>funnel</code> can be used to compare units at two diferent periods. It plots a ratio of rates y versus a precision parameter rho. If <code>option = "prop"</code>, <code>funnel</code> plots a proportion y versus its case volume (number of admissions). If <code>option = "ratioProp"</code> or <code>option = "diffProp"</code>, <code>funnel</code> can be used to compare units at two diferent periods. It plots a ratio (or difference) of proportions y versus a precision parameter rho. See details.</p>
</td></tr>
<tr><td><code id="funnel_+3A_printunits">printUnits</code></td>
<td>
<p>Logical (default = <code>TRUE</code>); If <code>TRUE</code>, the units are identified in the plot and printed in de console. The numbers plotted correspond to the row numbers printed in the console.</p>
</td></tr>
<tr><td><code id="funnel_+3A_plot">plot</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), the correspondent graphic is plotted with the standard options.</p>
</td></tr>
<tr><td><code id="funnel_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimals to be used in the output.</p>
</td></tr>
<tr><td><code id="funnel_+3A_overdispersion">overdispersion</code></td>
<td>
<p>Logical (default = FALSE); If TRUE, introduces an multiplicative over-dispersion factor phi that will inflate the CI null variance. See details.</p>
</td></tr>
<tr><td><code id="funnel_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_x">x</code></td>
<td>
<p>An object of class 'funnel'.</p>
</td></tr>
<tr><td><code id="funnel_+3A_col">col</code></td>
<td>
<p>A character vector representing the colors for the CI funnel lines. Must have same length of <code>p</code> + 1 with the target line color in the last position.</p>
</td></tr>
<tr><td><code id="funnel_+3A_lwd">lwd</code></td>
<td>
<p>A positive number specifying the lines width. It's the same for all lines in the plot. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_lty">lty</code></td>
<td>
<p>A numeric vector representing the CI lines types. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_bty">bty</code></td>
<td>
<p>A character string which represents the type of <code><a href="graphics.html#topic+box">box</a></code> which is drawn around plots. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_pch">pch</code></td>
<td>
<p>Either an integer or a single character specifying a symbol to be used as the default in plotting points. See <code><a href="graphics.html#topic+points">points</a></code> for possible values and their interpretation. Note that only integers and single-character strings can be set as a graphics parameter (and not NA nor NULL).</p>
</td></tr>
<tr><td><code id="funnel_+3A_pt.col">pt.col</code></td>
<td>
<p>A character specifying the points colors.</p>
</td></tr>
<tr><td><code id="funnel_+3A_bg">bg</code></td>
<td>
<p>A character specifying the color to be used for the points background when <code>pch = 21</code> (default). See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_pt.cex">pt.cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting points should be magnified relative to the default.  See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_auto.legend">auto.legend</code></td>
<td>
<p>Logical; If <code>TRUE</code> (default), prints a legend with default arguments.</p>
</td></tr>
<tr><td><code id="funnel_+3A_text.cex">text.cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text should be magnified relative to the default.  See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_text.pos">text.pos</code></td>
<td>
<p>A position specifier for numbers that correspond to the units in the plot. Values of 1, 2, 3 and 4, respectively indicate positions below, to the left of, above and to the right of the points.</p>
</td></tr>
<tr><td><code id="funnel_+3A_mypts.col">mypts.col</code></td>
<td>
<p>A character representing the color used to benchmark the units specified in <code>myunits</code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_xlab">xlab</code>, <code id="funnel_+3A_ylab">ylab</code></td>
<td>
<p>A title for the x and y axis. See <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="funnel_+3A_xlim">xlim</code>, <code id="funnel_+3A_ylim">ylim</code></td>
<td>
<p>Limits of horizontal and vertical axis. These limits are defined in the funnel plot and passed to <code>plot.funnel</code>. The user may redefine the limits in <code>plot.funnel</code>. Ultimately, these arguments are passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="funnel_+3A_auto.xlab">auto.xlab</code>, <code id="funnel_+3A_auto.ylab">auto.ylab</code></td>
<td>
<p>Logical. If <code>TRUE</code>, one is not able to change x and y axis labels, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> For every possible value of <code>option</code>, if <code>overdispersion = TRUE</code>, the CI can be inflated by a overdispersion parameter phi. There is a test for overdispersion which inflates the funnel if it's necessary. An &quot;Winsorized&quot; over-dispersion parameter is estimated and is used to inflate the funnel limits if it is significantly greater than 1. The parameter phi is returned as an funnel object.
</p>
</li>
<li><p> If <code>option = "rate"</code>, <code>funnel</code> plots a standardized rate y versus the expected number of deaths or volume value for several units.
</p>
<p>To choose the <code>direct</code> argument, one should pay attention if one wants to use a Direct or Indirect Standardized Rate. If direct, we assume the rate is reported as a rate per (say) 1000 individuals, then it is treated as a proportion. If indirect, we assume it is a cross-sectional data that leads to a standardized event ratio.
</p>
<p>In many circumstances we can assume an exact or approximate normal distribution for the data. Using the <code>method</code> argument, one could choose between <code>"exact"</code> or  <code>"normal"</code>. For direct standardized rates, the exact distribuition is binomial and for indirect standardized rates, the exact distribuition is poisson. Assume rho is the precision parameter (volume, for direct rates; expected value, for indirect rates). The original report claims that, for rho &gt; 100, the normal and exact curves almost coincide. So, one could perfectly use  normal approximation if ones data parameter precision is greater than 100, in general.
</p>
<p>The console warns if there are units with volume/expected value less than 100.
</p>
<p>phi = (1/total) * sum((y - theta) ^ 2 * rho)/g(theta)
</p>
<p>var(y|theta,rho) = (phi * g(theta))/rho
</p>
</li>
<li><p> If <code>option = "ratioRate"</code>, <code>funnel</code> can be used to compare units at two diferent periods. It plots a ratio of rates y versus a precision parameter rho.
</p>
<p>Suppose we have two measures for each institution: O1; E1 in a baseline period and O2; E2 in a subsequent period, and we wish to assess the change in the underlying rate (SMR or SRU). We shall only consider the ratio of rates option. The exact method will automatically be applied if E1 = E2, and the indirect method, of normal approximations, otherwise. On this second method, for low (especially zero) counts the <code>funnel</code> function adds 0.5 to all parameters O and E in order to stabilize the estimates.
</p>
<p>Y = (O1/E1)/(O2/E2) and the target theta =	lambda2/lambda1.
</p>
<p>When E1 = E2, y is plotted versus the average observed count (rho).
</p>
<p>When E1 is different of E2, i.e., it is used normal approximation. It is convenient to work on a logarithmic scale so that log(theta) is a target for log(Y). Y is plotted versus a different rho depending on the chosen rate.
</p>
</li>
<li><p> If <code>option = "prop"</code>, <code>funnel</code> plots a proportion y versus its volume.
It is used for cross-sectional data. Suppose in each institution that O events are observed out of a sample size of N:
</p>
<p>The indicator is the observed proportion y = O/N
</p>
<p>Assume <code>N</code> is the precision parameter (volume). Similarly to when <code>option = "rate"</code>, for <code>N</code> &gt; 100 the normal and exact curves almost coincide. So, one could perfectly use normal approximation on the parameter <code>method</code> if ones data parameter precision is greater than 100, in general.
</p>
<p>phi = (1/total) * sum((y - theta) ^ 2 * N)/g(theta)
</p>
<p>var(y|theta,N) = (phi * g(theta))/N
</p>
</li>
<li><p> If <code>option = "ratioProp"</code> or <code>option = "diffProp"</code>, <code>funnel</code> can be used to compare units at two diferent periods. It plots a ratio (or difference) of proportions y versus a precision parameter rho to assess the change in the underlying proportion from pi1 to pi2. Normal approximations are used throughout, and for low (especially zero) counts, the function adds 0.5 to all arguments r and 1 to all arguments n in order to stabilize the estimates.
</p>
<p>In the case <code>option = "diffProp"</code>, the indicator is Y = (O2/N2 - O1/N1) and theta = pi2 - pi1. If <code>option = "ratioProp"</code>, the indicator is Y = (O2/N2)/(O1/N1) and theta = pi2/pi1. It is convenient to work on a logarithmic scale, so that log(theta) is a target for log(Y) in this case as well.
</p>
<p>For these two parameter options, the precision parameter (plotted at horizontal axis) can be interpreted as approximately the sample size per period.
</p>
</li></ul>



<h3>Value</h3>

<p>A table with unit names, y, observed (Obs), expected (Exp) and admissions (N) for each unit, a binary column showing which units one would like to highlight in the plot (myunits) and final columns show which units are out of control.
</p>


<h3>References</h3>

<p>Spiegelhalter, David J. &quot;Funnel plots for comparing institutional performance.&quot; Statistics in medicine 24.8 (2005): 1185-1202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SMR">SMR</a></code>, <code><a href="#topic+SRU">SRU</a></code>, <code><a href="#topic+reclass">reclass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading data
data(icu)

# Some edition
icu$Saps3DeathProbabilityStandardEquation &lt;- icu$Saps3DeathProbabilityStandardEquation / 100
icu &lt;- icu[-which(icu$Unit == "F"),]
icu$myunits &lt;- ifelse(icu$Unit == "A",1,0) #my units
icu &lt;- droplevels(icu)

# Getting the cross-sectional arguments to use in funnel
x &lt;- SMR.table(data = icu, group.var = "Unit",
              obs.var = "UnitDischargeName", pred.var = "Saps3DeathProbabilityStandardEquation")
myunit_names &lt;- unique(icu$Unit[which(icu$myunits == 1)])
x$myunits &lt;- ifelse(x$Levels %in% myunit_names, 1,0)

# Analysis of proportions
f1 &lt;- funnel(unit = x$Levels[-1], o = x[-1,]$Observed, theta = x$Observed[1] / x$N[1],
            n = x[-1,]$N, method = "exact", myunits = x$myunits[-1], option = "prop", plot = FALSE)
f1
plot(f1, main = "Cross-sectional proportions")

# To analyze rates (SMR)
f2 &lt;- funnel(unit = x$Levels[-1], y = x[-1,]$SMR, method = "exact", direct = TRUE,
            theta = x$SMR[1], e = x[-1,]$Expected, n = x[-1,]$N, o = x[-1,]$Observed,
            option = "rate", plot = FALSE)
f2
plot(f2, main = "Cross-sectional rate (SMR)")

# Creating a variable containing month information about each admission
icu$month &lt;- as.numeric(format(as.Date(icu$UnitAdmissionDateTime),"%m"))

# First quarter
dt1 &lt;- icu[which(icu$month %in% c(1,2,3)),]

# Second quarter
dt2 &lt;- icu[which(icu$month %in% c(4,5,6)),]

# Getting the two period arguments to use in funnel
z &lt;- SMR.table(data = dt1, group.var = "Unit", obs.var = "UnitDischargeName",
              pred.var = "Saps3DeathProbabilityStandardEquation")
w &lt;- SMR.table(data = dt2, group.var = "Unit", obs.var = "UnitDischargeName",
              pred.var = "Saps3DeathProbabilityStandardEquation")

z$myunits &lt;- ifelse(z$Levels %in% myunit_names, 1,0)
w$myunits &lt;- ifelse(w$Levels %in% myunit_names, 1,0)
# To analyze periods using ratio rates with e1 = e1
f3 &lt;- funnel(unit = z$Levels[-1], n1 = z$N[-1], o1 = z$Observed[-1],
            e1 = z$Expected[-1],
            n2 = w$N[-1], o2 = w$Observed[-1], e2 = z$Expected[-1],
            myunits = z$myunits[-1], option = "ratioRates", plot = FALSE)
f3
plot(f3, main = "Ratio of SMRs of periods with same expectation of death")


# To analyze periods using ratio rates with e1 =! e1
f4 &lt;- funnel(unit &lt;- z$Levels[-1], n1 = z$N[-1], o1 = z$Observed[-1],
            e1 = z$Expected[-1], n2 = w$N[-1], o2 = w$Observed[-1], e2 = w$Expected[-1],
            option = "ratioRates", plot = FALSE)
f4
plot(f4, main = "Ratio of SMRs of periods with different expectation of death",
    ylim = c(-1.5,1.5), xlim = c(0,200))

# To analyze periods by difference in proportions
f5 &lt;- funnel(unit &lt;- z$Levels[-1], n1 = z$N[-1], o1 = z$Observed[-1],
            n2 = w$N[-1], o2 = w$Observed[-1], option = "diffProp", plot = FALSE)
f5
plot(f5, main = "Difference in proportions of death for two periods")

# To analyze periods by ratio of proportions
f6 &lt;- funnel(unit &lt;- z$Levels[-1], n1 = z$N[-1], o1 = z$Observed[-1],
            n2 = w$N[-1], o2 = w$Observed[-1], option = "ratioProp", plot = FALSE)
f6
plot(f6, main = "Ratio of proportions of death for two periods")

rm(icu, x, z, w, dt1, dt2, unit, f1, f2, f3, f4, f5, f6)

</code></pre>

<hr>
<h2 id='icu'>Data from ICU admissions.</h2><span id='topic+icu'></span>

<h3>Description</h3>

<p>A dataset containing selected data from some ICU (intensive care units) admissions and its outcomes at the year 2013 used in the ORCHESTRA study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icu
</code></pre>


<h3>Format</h3>

<p>A data frame with 13709 rows and 24 variables
</p>


<h3>Details</h3>


<ul>
<li> <p><code>Unit</code> The name of the ICU unit.
</p>
</li>
<li> <p><code>Age</code> Patient age.
</p>
</li>
<li> <p><code>UnitAdmissionDateTime</code> ICU unit admission date and time.
</p>
</li>
<li> <p><code>UnitDischargeDateTime</code> ICU unit discharge date and time.
</p>
</li>
<li> <p><code>UnitDischargeName</code> Unit admission outcome. Death = 1, or Discharge = 0.
</p>
</li>
<li> <p><code>UnitDestinationName</code> ICU unit destination after discharge.
</p>
</li>
<li> <p><code>HospitalAdmissionDate</code> Hospital admission date.
</p>
</li>
<li> <p><code>HospitalDischargeDate</code> Hospital discharge date.
</p>
</li>
<li> <p><code>HospitalDischargeName</code> Hospital admission outcome. Death = 1, Discharge = 0.
</p>
</li>
<li> <p><code>LengthHospitalStayPriorUnitAdmission</code> Hospital length of stay before unit admission.
</p>
</li>
<li> <p><code>AdmissionSourceName</code> The origin of the patient before ICU admission.
</p>
</li>
<li> <p><code>AdmissionTypeName_pri</code> Admission as Clinical treatment (1) Elective surgery (2), or Urgent surgery (3).
</p>
</li>
<li> <p><code>AdmissionReasonName_pri</code> Main diagnosis groups.
</p>
</li>
<li> <p><code>Vasopressors_D1</code> Vasopressors use at ICU first day admission? No = No, Yes = 1
</p>
</li>
<li> <p><code>IsMechanicalVentilation1h</code> Required mechanichal ventilation at 1st hour of admission. No = 0, Yes = 1.
</p>
</li>
<li> <p><code>CharlsonComorbidityIndex</code> Charlson comorbidity index.
</p>
</li>
<li> <p><code>Saps3Points</code> SAPS 3 score
</p>
</li>
<li> <p><code>Saps3DeathProbabilityStandardEquation</code> SAPS 3 estimated probability
</p>
</li>
<li> <p><code>SofaScore</code> SOFA score.
</p>
</li>
<li> <p><code>los</code> Unit length of stay, that is, the time difference between <code>UnitAdmissionDateTime</code> and <code>UnitDischargeDateTime</code>, in days.
</p>
</li></ul>



<h3>Source</h3>

<p>Organizational characteristics, outcomes, and resource use in 78 Brazilian intensive care units: the ORCHESTRA study. Intensive Care Med. 2015 Dec;41(12):2149-60.
</p>

<hr>
<h2 id='miscellaneous'>Miscellaneous functions for data editing</h2><span id='topic+miscellaneous'></span><span id='topic+f.num'></span><span id='topic+f.date'></span><span id='topic+remove.na'></span><span id='topic+tab2tex'></span><span id='topic+trunc_num'></span><span id='topic+dummy.columns'></span><span id='topic+rm.dummy.columns'></span><span id='topic+funnelEstimate'></span><span id='topic+winsorising'></span>

<h3>Description</h3>

<p>Collection of functions for data editing, usually used as lower levels for other functions.
</p>
<p><code>f.num</code> is a wrapper to format numeric variables that are stored as character or factor, simultaneously it will try to detect comma spearated and replace it by dots before formating the variable as numeric. Any non-numeric encoding will be coerced to NA.
</p>
<p><code>f.date</code> is a wrapper either to <code><a href="base.html#topic+as.Date">as.Date</a></code> or <code><a href="base.html#topic+strptime">strptime</a></code> to format character or factor variables into dates. In Epimed Solutions database there are a few pre-specified formats that <code>f.date</code> will try to detect and return a formated date. <code>f.date</code> will try to dected if more than half of the elements in a vector have a pre-specified format. If so, the remaining will be coerced to NA if they have different format from the detected. See example.
</p>
<p><code>remove.na</code> identifies all the empty spaces, i.e. the &quot; &quot; cells, of character or factor variables in a data.frame and returns the same data.frame with these empty cells replaced, by default, by NAs. It does not matter the length of the empty spaces. Also, <code>remove.na</code> trims the leading and trailing empty spaces from all character and factor variables. It does not format the numeric variables. It may also return at the console a few information about the &quot; &quot; fields.
</p>
<p><code>tab2tex</code> removes the empty rows, and also tunrs the rownames of a table epiDisplay::tableStack into the first column, to make it easier to paste the table into a rtf or latex document without empty rows or rownames conflicts.
</p>
<p><code>trunc_num</code> truncates a numeric vector by replacing the values below the min value or above the max values by the min and max values respectively or optionall to NA. See example.
</p>
<p><code>dummy.columns</code> takes a <code>data.frame</code> with one column with concatatenated levels of a factor (or character) variable and return a <code>data.frame</code> with additional columns with zeros and ones (dummy values), which names are the factor levels of the original column. See example below. <code>rm.dummy.columns</code> is an internal function of <code>dummy.columns</code> that deletes the new dummy columns which have less then a specified minimum events.
</p>
<p><code>funnelEstimate</code>  estimates funnel confidence intervals (CI) for binomial, poisson or normal distribution. Used inside <code><a href="#topic+funnel">funnel</a></code>.
</p>
<p><code>winsorising</code> is an internal function that estimates a phi parameter after shirinking extreme z-scores. This parameter is used to inflate funnel CIs due overdispersion presence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.num(num.var)

f.date(date)

remove.na(data, replace = NA, console.output = TRUE)

tab2tex(x, nc = ncol(x))

trunc_num(x, min, max, toNA = FALSE)

dummy.columns(
  data,
  original.column,
  factors,
  scan.oc = FALSE,
  sep = ",",
  colnames.add = "Dummy.",
  min.events = NULL,
  rm.oc = FALSE,
  warn = FALSE,
  return.factor = TRUE
)

rm.dummy.columns(data, colnames, event = "1", min.events = 50, warn = FALSE)

funnelEstimate(
  y,
  range,
  u,
  totalAdmissions,
  totalObserved,
  p = 0.95,
  theta = 1,
  overdispersion = TRUE,
  dist = c("binomial", "normal", "poisson"),
  rho,
  gdetheta
)

winsorising(z_score, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miscellaneous_+3A_num.var">num.var</code></td>
<td>
<p>A character, or factor variable to be formated as numeric.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_date">date</code></td>
<td>
<p>A character or factor variable to be formated as date.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_replace">replace</code></td>
<td>
<p>By default, NA. But could be any vector of length 1.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_console.output">console.output</code></td>
<td>
<p>Logical. Print at the console a few informations about the &quot; &quot; fields?</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_x">x</code>, <code id="miscellaneous_+3A_nc">nc</code></td>
<td>
<p>For <code>tab2tex</code> x is a object from epiDisplay::tableStack. nc is the number of the last column to keep in the table. If the table has 5 columns and nc = 3, then columns 4 and 5 are removed. For <code>trunc_num</code>, x is a numeric vector.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_min">min</code>, <code id="miscellaneous_+3A_max">max</code></td>
<td>
<p>For <code>trunc_num</code>, min and max are the minimal and maximal numeric values where the numeric vector will be truncated.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_tona">toNA</code></td>
<td>
<p>For <code>trunc_num</code>, if FALSE any min and max are the minimal and maximal numeric values where the numeric vector will be truncated.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_original.column">original.column</code></td>
<td>
<p>A character vector representing the name of the column the be transformed in dummy variables.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_factors">factors</code></td>
<td>
<p>A character vector to make new dummy columns and to match values in <code>original.column</code>. This is interesting if the user desires to make dummy only from a few factors in the originlal column. Ignored if scan.oc = TRUE</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_scan.oc">scan.oc</code></td>
<td>
<p>Default = FALSE, if TRUE, <code>dummy.columns</code> scans the specified <code>original.column</code> and uses all factors to generate dummy variables. It overrides the <code>factor</code> argument.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_sep">sep</code></td>
<td>
<p>A character of legth one that systematically split the factors in the original columns. It wil be passed to the <code>sep</code> argument in the <code><a href="base.html#topic+scan">scan</a></code> function.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_colnames.add">colnames.add</code></td>
<td>
<p>The default is '= &quot;Dummy_&quot;'. This is a character vector of length one to stick in the <code>colnames</code> of the dummy variables. For example, if the orginal column has A;B;C factor levels, the new dummy variables <code>colnames</code> would be &quot;Dummy_A&quot;, &quot;Dummy_B&quot;, and &quot;Dummy_C&quot;</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_min.events">min.events</code></td>
<td>
<p>Either <code>NULL</code> (default), or a numeric scalar. If any of the new variables have less events then specified in <code>min.events</code>, they will be deleted before returning the output data.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_rm.oc">rm.oc</code></td>
<td>
<p>Default is <code>FALSE</code>. If <code>TRUE</code>, <code>dummy.columns</code> will delete the original column before returnig the final <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_warn">warn</code></td>
<td>
<p>Default is <code>FALSE</code>. If <code>TRUE</code>, <code>dummy.columns</code> will print at the console the deleted columns names.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_return.factor">return.factor</code></td>
<td>
<p>Default is <code>TRUE</code>. If <code>TRUE</code>, <code>dummy.columns</code> return factor columns with &quot;0&quot; and &quot;1&quot; levels, or numeric otherwise.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_colnames">colnames</code></td>
<td>
<p>For <code>rm.dummy.columns</code> this is the names of the columns to be tested and deleted inside <code>dummy.columns</code>.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_event">event</code></td>
<td>
<p>A character string to be detected as a event. In <code>rm.dummy.columns</code>, if the columns are coded as '0' and '1', the event is '1', if it is coded as logical, the events is 'TRUE'.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_y">y</code></td>
<td>
<p>A numeric vector representing the &quot;Standardized rate&quot; for each unit, usually the SMR or possibly the SRU , accordind to <code>y.type</code>.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_range">range</code></td>
<td>
<p>A numeric range representing for which values the funnel will be estimated. Usually the same variable in x axis (the precision parameter).</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_u">u</code></td>
<td>
<p>A number indicating the total amount of ICUs in the data.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_totaladmissions">totalAdmissions</code></td>
<td>
<p>The quantity of admissions in all units.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_totalobserved">totalObserved</code></td>
<td>
<p>The quantity of observed death in all units.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_p">p</code></td>
<td>
<p>A number between 0 and 1 indicating the confidence interval level for the funnel.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_theta">theta</code></td>
<td>
<p>Target value which specifies the desired expectation for institutions considered &quot;in control&quot;.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_overdispersion">overdispersion</code></td>
<td>
<p>Logical (default = FALSE); If TRUE, introduces an multiplicative over-dispersion factor phi that will inflate the CI null variance. See <code>funnel</code> details.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_dist">dist</code></td>
<td>
<p>A character specifying the distribution about the funnel control limits will be estimated. It can be &quot;binomial&quot; (default), &quot;normal&quot; or &quot;poisson&quot;.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_rho">rho</code></td>
<td>
<p>A numeric vector representing the funnel precision parameter. It is calculated inside <code>funnel</code> and used to calculer <code>z_score</code>.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_gdetheta">gdetheta</code></td>
<td>
<p>A numeric auxiliary numeric vector used to calculate <code>z_score</code> to be used to calculate estimate funnel control limits.</p>
</td></tr>
<tr><td><code id="miscellaneous_+3A_z_score">z_score</code></td>
<td>
<p>A numeric vector indicating the standardized Pearson residual or the &quot;naive&quot; Z-Score for each unit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lunna Borges &amp; Pedro Brasil
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataquality">dataquality</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Formating character or factor variable that should be numeric variables
f.num(c("2,4000","10,0000","5.0400"))

# Simulating a dataset
y &lt;- data.frame(v1 = sample(c(" F","M  ","   "), 10, replace = TRUE),
                v2 = sample(c(1:3,"     "), 10, replace = TRUE),
                v3 = sample(c("Alive","Dead",""), 10, replace = TRUE))
y

# Replacing the "" cells by NA
y &lt;- remove.na(y)
y

rm(y)

# Formating dates
x &lt;- f.date(c("28/02/2013","16/07/1998","31/03/2010"))
x
class(x)

# The first element (i.e., the different one) is coerced to NA
x &lt;- f.date(c("2013-02-28 12:40","16/07/1998","31/03/2010"))
x
class(x)

# The last element (i.e. the different one) is coerced to NA
x &lt;- f.date(c("2013-02-28 12:40","1998-07-16 18:50","31/03/2010"))
x
class(x)

# Truncating numeric vectors
trunc_num(1:12, min = 3, max = 10)

# Truncating numeric vectors but returning NAs instead
trunc_num(1:12, min = 3, max = 10, toNA = TRUE)

# Simulating a dataset for dummy.columns example

y &lt;- data.frame(v1 = 1:20,
               v2 = sapply(1:20, function(i) toString(sample(c("Code1","Code2","Code3","Code4"),
                     size = sample(2:4, 1), replace = FALSE))))
y


# For a few of the codes in the original column
y &lt;- dummy.columns(y, original.column = "v2", factor = c("Code2","Code3"))
y

# For all codes in the original column
y &lt;- dummy.columns(y[, 1:2], original.column = "v2", scan.oc = TRUE)
y

# Funnel Estimate
data(icu)
icu

funnelEstimate(y = icu$Saps3DeathProbabilityStandardEquation,
               range = 1, u = length(unique(icu$Unit)),
               totalAdmissions = nrow(icu),
               totalObserved = sum(icu$UnitDischargeName),
               theta = mean(icu$Saps3DeathProbabilityStandardEquation),
               dist = 'normal', rho = 1, gdetheta = 1)

rm(y, icu)

</code></pre>

<hr>
<h2 id='mortality_rate'>Mortality Rate</h2><span id='topic+mortality_rate'></span>

<h3>Description</h3>

<p><code>mortality_rate</code> function returns a list with the mortality rate and the number of patients for each month or quarter of the year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mortality_rate(
  deaths,
  period = NULL,
  isQuarter = FALSE,
  isYear = FALSE,
  option = c("both", "monthly", "quarterly", "annual"),
  periodName = NULL,
  default_tapply = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mortality_rate_+3A_deaths">deaths</code></td>
<td>
<p>a numerical vector that only contains 0 and 1, indicating whether the patient was alive or dead, respectively.</p>
</td></tr>
<tr><td><code id="mortality_rate_+3A_period">period</code></td>
<td>
<p>a numerical vector that contains the order of months when the patients were admitted to the hospital unit. If period variable is NULL (the default), the function will return a single mortality rate.</p>
</td></tr>
<tr><td><code id="mortality_rate_+3A_isquarter">isQuarter</code></td>
<td>
<p>logical indicating whether the <code>period</code> refers to quarter or not. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mortality_rate_+3A_isyear">isYear</code></td>
<td>
<p>logical indicating whether the <code>period</code> refers to years or not. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mortality_rate_+3A_option">option</code></td>
<td>
<p>a character string which determines what the function mortality_rate returns. If the option is chosen to be 'both' (the default), the function will return a list containing monthly mortality rate, quarterly mortality rate, annual mortality rate and the number of patients in each month, quarter and year. If the option is 'monthly', only the monthly mortality rate and the number of patients in each month are returned. If the option is 'quarterly', only the quarterly mortality rate and the number of patients in each quarter are returned. If the option is 'annual', only the annual mortality rate and the number of patients in each year are returned.</p>
</td></tr>
<tr><td><code id="mortality_rate_+3A_periodname">periodName</code></td>
<td>
<p>a character vector that contains the name of months when the patients were admitted to de hospital unit. Used only if period is not NULL.</p>
</td></tr>
<tr><td><code id="mortality_rate_+3A_default_tapply">default_tapply</code></td>
<td>
<p>argument to set the <code>default</code> in <code>tapply</code> function when evaluating the mortality rate for each period. Can be equal to <code>0</code> or <code>NA</code> (the default).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Camila Cardoso &lt;camila.cardoso@epimedsolutions.com&gt;
Lunna Borges &lt;lunna.borges@epimedsolutions.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Loading the dataset
data(icu)

# Creating a vector of months
date &lt;- as.Date(icu$UnitDischargeDateTime, tryFormats = '%d/%m/%Y')
months &lt;- as.numeric(format(date, '%m'))

# Vector of deaths
deaths &lt;- icu$UnitDischargeName

# Calculating monthly and quarterly mortality rate
mortality_rate(deaths = deaths, period = months, option = 'both')


</code></pre>

<hr>
<h2 id='reclass'>Comparisson of the Standardized Resource Use (SRU)</h2><span id='topic+reclass'></span><span id='topic+print.reclass'></span><span id='topic+plot.reclass'></span>

<h3>Description</h3>

<p>Compares ICU's (intensive care units) SRU with diferent severity classes or compares ICU's SRU at two diferents times. This comparison checks if the ICUs remains in the same quadrant after a time period, and highlights their rank changes over time.
</p>
<p><code>plot.reclass</code> Plots a SMR vs. SRU scatter plot with the ICUs which had their quadrant/rank classification changed.
</p>
<p><code>print.reclass</code> Prints a table with information about which ICUs changed from a classification to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclass(
  x,
  y,
  same = TRUE,
  plot = FALSE,
  digits = 2,
  compare = c("SRU", "SMR", "BOTH"),
  decreasing = FALSE,
  complete.rank = TRUE
)

## S3 method for class 'reclass'
print(x, ...)

## S3 method for class 'reclass'
plot(
  x,
  ...,
  xlim_x = range(x$smr_x),
  ylim_x = range(x$sru_x),
  xlim_y = range(x$smr_y),
  ylim_y = range(x$sru_y),
  xlab = "SMR",
  ylab = "SRU",
  points.arg_x = list(pch = 21, col = "white", bg = "yellow", cex = 2),
  points.arg_y = list(pch = 21, col = "white", bg = "yellow", cex = 2),
  med.arg_x = list(col = "dodgerblue4", lwd = 2, lty = 1),
  med.arg_y = list(col = "dodgerblue4", lwd = 2, lty = 1),
  tert.arg_x = list(col = "darkorange2", lty = 2, lwd = 1),
  tert.arg_y = list(col = "darkorange2", lty = 2, lwd = 1),
  text.arg_x = list(labels = seq(1, nrow(x$tab)), cex = 0.6),
  text.arg_y = list(labels = seq(1, nrow(x$tab)), cex = 0.6),
  worse.arg_x = list(x = x$worse_x, pch = 21, col = "white", bg = "tomato", cex = 2),
  worse.arg_y = list(x = x$worse_y, pch = 21, col = "white", bg = "tomato", cex = 2),
  better.arg_x = list(x = x$better_x, pch = 21, col = "white", bg = "mediumseagreen",
    cex = 2),
  better.arg_y = list(x = x$better_y, pch = 21, col = "white", bg = "mediumseagreen",
    cex = 2),
  auto.legend = TRUE,
  leg.arg = list(x = "topleft", bty = "n", xpd = NA, inset = c(-1.8, -0.2), ncol = 1,
    horiz = F, pch = 19, cex = 0.8, pt.cex = 1.5),
  main.arg_x = list(main = "1st Stage"),
  main.arg_y = list(main = "2nd Stage")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reclass_+3A_x">x</code>, <code id="reclass_+3A_y">y</code></td>
<td>
<p>Objects of class 'SRU'. x is the SRU analsys from the 1st period (e.g. first trimester) and y from the 2nd period (e.g. second trimester). For <code>print.reclass</code> or <code>plot.reclass</code>, x is an object of class 'reclass'.</p>
</td></tr>
<tr><td><code id="reclass_+3A_same">same</code></td>
<td>
<p>Logical; If <code>TRUE</code>, compare the same units, with the same severity classes at two consecutive time periods (default). If <code>same = TRUE</code> and the ICUs do not match exactly in 'x' and 'y', there is a warning and non matching units are discarded from the analysis. If <code>FALSE</code>, it compares the same units, with different severity classes within the same period. In this case, if the ICUs do not match exactly in 'x' and'y', the function will return an error.</p>
</td></tr>
<tr><td><code id="reclass_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), plots a SMR vs. SRU scatter plot highlighting the ICUs which had their classification changed.</p>
</td></tr>
<tr><td><code id="reclass_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be used in the output.</p>
</td></tr>
<tr><td><code id="reclass_+3A_compare">compare</code></td>
<td>
<p>The way one prefers to benchmark the ICUs: by &quot;SRU&quot; (default), &quot;SMR&quot; or &quot;BOTH&quot;. If &quot;BOTH&quot;, the ICUs will be ranked by their SRU.</p>
</td></tr>
<tr><td><code id="reclass_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. Should the sort order of ICU's rank be increasing or decreasing?</p>
</td></tr>
<tr><td><code id="reclass_+3A_complete.rank">complete.rank</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), returns all ICUs ranked. If <code>FALSE</code>, returns only ICUs whose efficiency classification ranked changed.</p>
</td></tr>
<tr><td><code id="reclass_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="reclass_+3A_xlim_x">xlim_x</code>, <code id="reclass_+3A_ylim_x">ylim_x</code></td>
<td>
<p>Limits for x and y axis for 1st stage plot for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_xlim_y">xlim_y</code>, <code id="reclass_+3A_ylim_y">ylim_y</code></td>
<td>
<p>Limits for x and y axis for 2nd stage plot for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_xlab">xlab</code>, <code id="reclass_+3A_ylab">ylab</code></td>
<td>
<p>Labels of x and y axis for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_points.arg_x">points.arg_x</code>, <code id="reclass_+3A_points.arg_y">points.arg_y</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+points">points</a></code> for plotting points correponding to units' SMR and SRU in 1st and 2nd stage plots for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_med.arg_x">med.arg_x</code>, <code id="reclass_+3A_med.arg_y">med.arg_y</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+abline">abline</a></code> for plotting lines corresponding to SRU and SMR medians in 1st and 2nd stage plots for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_tert.arg_x">tert.arg_x</code>, <code id="reclass_+3A_tert.arg_y">tert.arg_y</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+abline">abline</a></code> for plotting lines corresponding to SRU and SMR tertiles in 1st and 2nd stage plots for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_text.arg_x">text.arg_x</code>, <code id="reclass_+3A_text.arg_y">text.arg_y</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting units labels in 1st and 2nd stage plots for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_worse.arg_x">worse.arg_x</code>, <code id="reclass_+3A_worse.arg_y">worse.arg_y</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+points">points</a></code> for plotting points correponding to units which got their rank worse in 1st and 2nd stage plots for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_better.arg_x">better.arg_x</code>, <code id="reclass_+3A_better.arg_y">better.arg_y</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+points">points</a></code> for plotting points correponding to units which got their rank better in 1st and 2nd stage plots for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_auto.legend">auto.legend</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it prints a legend with <code>leg.arg</code> arguments for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_leg.arg">leg.arg</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code> for plotting legends corresponding to SRU and SMR medians and tertiles in 1st and 2nd stage plots for <code>plot.reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_main.arg_x">main.arg_x</code>, <code id="reclass_+3A_main.arg_y">main.arg_y</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code> for the titles for the 1st and 2nd stage plots for <code>plot.reclass</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>reclass</code> retunrs  a data.frame with the following columns:
</p>

<ul>
<li> <p><code>Unit</code> Names of the ICU.
</p>
</li>
<li><p><code>Admission</code> Number of admissions in each ICU.
</p>
</li>
<li> <p><code>From</code> ICU's initial efficiency quadrant.
</p>
</li>
<li> <p><code>To</code> ICU's final efficiency quadrant.
</p>
</li>
<li> <p><code>SRU.1st</code> ICU's initial SRU estimate.
</p>
</li>
<li> <p><code>SRU.2nd</code> ICU's final SRU estimate.
</p>
</li>
<li> <p><code>SMR.1st</code> ICU's initial SMR estimate.
</p>
</li>
<li> <p><code>SMR.2nd</code> ICU's final SMR estimate.
</p>
</li>
<li> <p><code>Rank1</code> ICU's initial SRU (or SMR) rank.
</p>
</li>
<li> <p><code>Rank2</code> ICU's final SRU (or SMR) rank.
</p>
</li></ul>

<p><code>plot.reclass</code> returns a scatter plot with grpahical comparison of the two periods/stages with their respective medians and tertiles.
</p>


<h3>Author(s)</h3>

<p>Lunna Borges and Pedro Brasil
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SRU">SRU</a></code>, <code><a href="#topic+SMR">SMR</a></code>, <code><a href="#topic+funnel">funnel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icu)
# A little editing
icu$Saps3DeathProbabilityStandardEquation &lt;- icu$Saps3DeathProbabilityStandardEquation / 100
icu &lt;- icu[-which(icu$los &lt; 0 ),]

# Subseting the data for the 1st quarter
x &lt;- droplevels(icu[which(format(as.Date(icu$UnitAdmissionDate),"%m") %in% c("01","02","03")),])

# Subseting the data for the 2nd quarter
y &lt;- droplevels(icu[which(format(as.Date(icu$UnitAdmissionDate),"%m") %in% c("04","05","06")),])

# Running the SRU analysis for both quarters
FirstQ &lt;- SRU(prob = x$Saps3DeathProbabilityStandardEquation, death = x$UnitDischargeName,
unit = x$Unit, los = x$los, score = x$Saps3Points, originals = TRUE, type = 1, plot = FALSE)
FirstQ

SecondQ &lt;- SRU(prob = y$Saps3DeathProbabilityStandardEquation, death = y$UnitDischargeName,
unit = y$Unit, los = y$los, score = y$Saps3Points, originals = TRUE, type = 1, plot = FALSE)
SecondQ

z &lt;- reclass(x = FirstQ, y = SecondQ, same = TRUE)
z
plot(z)

rm(icu, x, y, FirstQ, SecondQ, z)

</code></pre>

<hr>
<h2 id='SMR'>Standardized Mortality Ratio (SMR)</h2><span id='topic+SMR'></span><span id='topic+SMR.table'></span><span id='topic+forest.SMR'></span>

<h3>Description</h3>

<p>Calculates the standardized mortality ratio and its confidence interval. SMR, for a group, is defined as the ratio of the observed deaths in this group and the sum of the predicted individual probabilities of death by any model (expected deaths).
</p>
<p><code>SMR.table</code> estimates at once the overall SMR and the SMR across several groups, e.g. ICU units or clinical characteristics. The <code>SMR.table</code> can be ordered by the SMR estimate or its confidence intervals, facilitating the comparison of the units ranks.
</p>
<p><code>forest.SMR</code> shows the <code>SMR.table</code> output as a forest plot. The plot opens two windows and plot at the left side the values from the <code>SMR.table</code> and at the right side the points and lines graphically representing each SMR and its confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMR(
  obs.var,
  pred.var,
  digits = 5,
  ci.method = c("Hosmer", "Byar"),
  ci.level = 0.95
)

SMR.table(
  data,
  group.var,
  obs.var,
  pred.var,
  digits = 5,
  use.label = FALSE,
  var.labels = attr(data, "var.labels")[match(group.var, names(data))],
  ci.method = c("Hosmer", "Byar"),
  ci.level = 0.95,
  reorder = c("no", "SMR", "lower.Cl", "upper.Cl"),
  decreasing = FALSE
)

forest.SMR(
  x,
  mar1 = c(5.1, 1, 4.1, 1),
  mar.SMR = c(5.1, 7, 4.1, 1),
  overall.arg = list(x = 0.01, font = 2, las = 1, labels = var.labels[1], xpd = NA, adj
    = 0),
  NOE.overall.args = list(x = c(N.values.arg$x, O.values.arg$x, E.values.arg$x), font =
    2, las = 1, xpd = NA),
  var.labels.arg = list(x = 0.01, font = 2, las = 1, cex = 1, xpd = NA, adj = 0),
  cat.labels.arg = list(x = 0.1, font = 3, las = 1, cex = 0.95, col = gray(0.4), xpd =
    NA, adj = 0),
  N.values.arg = list(x = 0.5, col = gray(0.4), xpd = NA),
  O.values.arg = list(x = 0.675, col = gray(0.4), xpd = NA),
  E.values.arg = list(x = 0.85, col = gray(0.4), xpd = NA),
  NOE.head.arg = list(font = 2, labels = c("N", "O", "E"), xpd = NA),
  Overall.seg.arg = list(col = "navyblue", xpd = NA, lwd = 2),
  Overall.p.arg = list(pch = 23, cex = 2, col = "black", bg = gray(0.4), xpd = NA),
  Overall.est.arg = list(x = smr.xlim[1] - 0.06, las = 1, font = 2, xpd = NA, adj = 1),
  cat.seg.arg = list(col = "navyblue", xpd = NA, lwd = 2),
  cat.p.arg = list(pch = 22, cex = 1, col = "black", bg = gray(0.4), xpd = NA),
  cat.est.arg = list(x = smr.xlim[1] - 0.06, las = 1, col = gray(0.4), xpd = NA, adj =
    1),
  SMR.head.arg = list(smr.xlim[1] - 0.06, font = 2, labels = "SMR [95% CIs]", xpd =
    NA, adj = 1),
  smr.xlab = "Standardized Mortality Ratio",
  smr.xlim = "auto",
  grid = TRUE,
  digits = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SMR_+3A_obs.var">obs.var</code></td>
<td>
<p>Observed death. Accepted values are 0 (absence) or 1 (presence) in a vector. For <code>SMR.table</code> it must be a character indicating the name of the variable in the data.</p>
</td></tr>
<tr><td><code id="SMR_+3A_pred.var">pred.var</code></td>
<td>
<p>Death individual predictions (ranging from 0 to 1) in a vector. For <code>SMR.table</code> it must be a character indicating the name of the variable in the data.</p>
</td></tr>
<tr><td><code id="SMR_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding the output.</p>
</td></tr>
<tr><td><code id="SMR_+3A_ci.method">ci.method</code></td>
<td>
<p>Method to estimate the confidence interval. &quot;Hosmer&quot; (default) or &quot;Byar&quot; are acceptable values.</p>
</td></tr>
<tr><td><code id="SMR_+3A_ci.level">ci.level</code></td>
<td>
<p>Level of the confidence interval. Default is 0.95.</p>
</td></tr>
<tr><td><code id="SMR_+3A_data">data</code></td>
<td>
<p>For <code>SMR.table</code>, a dataset where pred.var, obs.var and group.var are in.</p>
</td></tr>
<tr><td><code id="SMR_+3A_group.var">group.var</code></td>
<td>
<p>For <code>SMR.table</code>, this is a character vector indicating the name(s) of the variable(s) in the data that will form the groups where SMR will be calculated. The variables must be factors.</p>
</td></tr>
<tr><td><code id="SMR_+3A_use.label">use.label</code></td>
<td>
<p>Logical. Default is FALSE. For <code>SMR.table</code> this option will replace the variables names by its labels in var.labels argument.</p>
</td></tr>
<tr><td><code id="SMR_+3A_var.labels">var.labels</code></td>
<td>
<p>A character vector with variables labels. The default is to replace the variable name by the label stored at attr(data, &quot;var.labels&quot;). But one may specify labels directly.</p>
</td></tr>
<tr><td><code id="SMR_+3A_reorder">reorder</code></td>
<td>
<p>Default is &quot;no&quot;. Possible values are: &quot;no&quot;, &quot;SMR&quot;,&quot;lower.Cl&quot;, and &quot;upper.Cl&quot;. It will make the <code>SMR.table</code> to be ordered within each varibale by its original order, or by SMR order, or by lower.Cl order, or by upper.Cl.</p>
</td></tr>
<tr><td><code id="SMR_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical. When 'reorderd' is TRUE, should the order be decreasing or incresing? See <code><a href="base.html#topic+order">order</a></code></p>
</td></tr>
<tr><td><code id="SMR_+3A_x">x</code></td>
<td>
<p>For the <code>forest.SMR</code> this is the output of <code>SMR.table</code>.</p>
</td></tr>
<tr><td><code id="SMR_+3A_mar1">mar1</code>, <code id="SMR_+3A_mar.smr">mar.SMR</code></td>
<td>
<p>Values to set the margins (mar parameter) of left and right windows. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="SMR_+3A_overall.arg">overall.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the overall label. Internally, 'y' coordinate is replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_noe.overall.args">NOE.overall.args</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the overall N (number of observations), O (observed deaths) and E (expected deaths). Internally, 'labels' and 'y' arguments are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_var.labels.arg">var.labels.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the variables labels. Internally, 'y' coordinate is replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_cat.labels.arg">cat.labels.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the categories labels. Internally, 'y' coordinate is replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_n.values.arg">N.values.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the values of N (number of observations) of each subgroup. Internally, the arguments 'label' and 'y' coordinate are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_o.values.arg">O.values.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the values of Observed deaths of each subgroup. Internally, the arguments 'label'  and 'y' coordinate are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_e.values.arg">E.values.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the values of Expected deaths of each subgroup. Internally, the arguments 'label' and 'y' coordinate are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_noe.head.arg">NOE.head.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the labels of the columns N, E and O on the top of the graph. Internally, the 'x' and 'y' coordinates are replaced. The x coordinates are taken from the x in <code>N.values.arg</code>, <code>O.values.arg</code> and <code>E.values.arg</code>.</p>
</td></tr>
<tr><td><code id="SMR_+3A_overall.seg.arg">Overall.seg.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+segments">segments</a></code> for plotting the lines corresponding to overall SMR confidence intervals. Internally, 'x' and 'y' coordinates are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_overall.p.arg">Overall.p.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+points">points</a></code> for plotting the points corresponding to overall SMR. Internally, 'x' and 'y' coordinates are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_overall.est.arg">Overall.est.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the overall SMR beside the graph. Internally, 'y' coordinate and 'label' argument are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_cat.seg.arg">cat.seg.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+segments">segments</a></code> for plotting the lines corresponding to SMR confidence intervals for all groups. Internally, 'x' and 'y' coordinates are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_cat.p.arg">cat.p.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+points">points</a></code> for plotting the points corresponding to all categoreis SMR. Internally, 'x' and 'y' coordinates are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_cat.est.arg">cat.est.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the categories SMR beside the graph. Internally, 'y' coordinate and 'label' arguments are replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_smr.head.arg">SMR.head.arg</code></td>
<td>
<p>A list of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for plotting the label of the SMR column on the top of the graph. Internally, the 'y' coordinate is replaced.</p>
</td></tr>
<tr><td><code id="SMR_+3A_smr.xlab">smr.xlab</code></td>
<td>
<p>Label of the x axis. Default is &quot;Standardized Mortality Ratio&quot;.</p>
</td></tr>
<tr><td><code id="SMR_+3A_smr.xlim">smr.xlim</code></td>
<td>
<p>Limits of x axis of the <code>forest.SMR</code> plot. Default is &quot;auto&quot;, which internally will pick the highest values of all upper.Cl and the lowest lower.Cl. Besides &quot;auto&quot;, only a vector of 2 numbers is valid, and will be passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="SMR_+3A_grid">grid</code></td>
<td>
<p>Logical. If TRUE (default), it will draw a grid with the <code><a href="graphics.html#topic+grid">grid</a></code> default arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If SMR, then:
</p>

<ul>
<li> <p><code>N</code> Number of subjects analyzed.
</p>
</li>
<li><p><code>O</code> Observed number of deaths.
</p>
</li>
<li> <p><code>E</code> Expected number of deaths.
</p>
</li>
<li> <p><code>SMR</code> Standardized mortality ratio.
</p>
</li>
<li> <p><code>lower.Cl</code> lower confidence limit.
</p>
</li>
<li> <p><code>upper.Cl</code> upper confidence limit.
</p>
</li></ul>

<p>If SMR.table, then a data.frame with the same information as above, and the
additional information is returned: &quot;Variables&quot; (variables names), &quot;Levels&quot; (variables levels).
</p>
<p>If forest.SMR, then a plot is returned.
</p>


<h3>Author(s)</h3>

<p>Lunna Borges and Pedro Brasil
</p>


<h3>References</h3>

<p>David W. Hosmer and Stanley Lemeshow. Confidence intervals estimates of an index of quality performance basend on logistic regression models. Statistics in Medicine , vol. 14, 2161-2172 (1995)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SRU">SRU</a></code>, <code><a href="#topic+reclass">reclass</a></code>, <code><a href="#topic+funnel">funnel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a example data
data(icu)

# Setting variable labels to data
attr(icu, "var.labels")[match(c("Unit", "IsMechanicalVentilation1h",
          "AdmissionTypeName_pri","Vasopressors_D1"), names(icu))] &lt;-
  c("ICU unit","Mechanichal ventilation","Admission type","Vasopressors at admission")

# Some editing
icu$Saps3DeathProbabilityStandardEquation &lt;- icu$Saps3DeathProbabilityStandardEquation /100
icu$IsMechanicalVentilation1h &lt;- as.factor(ifelse(icu$IsMechanicalVentilation1h == 1, "Yes", "No"))
icu$AdmissionTypeName_pri &lt;- as.factor(icu$AdmissionTypeName_pri)
levels(icu$AdmissionTypeName_pri) &lt;- c("Clinical","Elective surgery", "Urgent surgery")
icu$Vasopressors_D1 &lt;- as.factor(ifelse(icu$Vasopressors_D1 == 1, "Yes", "No"))

# The overall SMR for the whole sample
SMR(icu$UnitDischargeName, icu$Saps3DeathProbabilityStandardEquation)

# The overall SMR and for some subgroups
x &lt;- SMR.table(data = icu, obs.var = "UnitDischargeName",
               pred.var = "Saps3DeathProbabilityStandardEquation",
               group.var = c( "IsMechanicalVentilation1h",
               "AdmissionTypeName_pri","Vasopressors_D1"),
               reorder = "no",
               decreasing = TRUE,
               use.label = TRUE)
x

# A forest plot for all groups SMR (resize the window may be required)
forest.SMR(x, digits = 2)

# The same thing but reordering the categories
x &lt;- SMR.table(data = icu, obs.var = "UnitDischargeName",
               pred.var = "Saps3DeathProbabilityStandardEquation",
               group.var = c( "IsMechanicalVentilation1h",
               "AdmissionTypeName_pri", "Vasopressors_D1"),
               reorder = "SMR",
               decreasing = TRUE,
               use.label = TRUE)
forest.SMR(x, digits = 2)

# The overall SMR and for all Units
x &lt;- SMR.table(data = icu, obs.var = "UnitDischargeName",
               pred.var = "Saps3DeathProbabilityStandardEquation",
               group.var = "Unit",
               reorder = "no",
               decreasing = TRUE,
               use.label = TRUE)
x

# A forest plot for all Units
forest.SMR(x, digits = 2)

# The same thing but reordering the categories
x &lt;- SMR.table(data = icu, obs.var = "UnitDischargeName",
               pred.var = "Saps3DeathProbabilityStandardEquation",
               group.var = "Unit",
               reorder = "SMR",
               decreasing = TRUE,
               use.label = TRUE)
forest.SMR(x, digits = 2)

rm(x, icu)
</code></pre>

<hr>
<h2 id='SRU'>Standardized Resource Use (SRU)</h2><span id='topic+SRU'></span><span id='topic+print.SRU'></span><span id='topic+plot.SRU'></span><span id='topic+cut_in'></span><span id='topic+SRUcalc'></span>

<h3>Description</h3>

<p><code>SRU</code> calculates the standardized resource use for ICUs (Intensive Care Units) from information regarding admissions of individual patients. Resource use is represented by the patient's length of stay (LOS). Therefore the SRU for each unit is defined as the observed LOS divided by it's expected LOS. To estimate the expected LOS for each ICU one must define a severity score, here defined by the SAPS 3 score. In theory, the 'score' could be any score/probability that estimates death for each ICU admission.
</p>
<p>The <code>plot.SRU</code> function will return a <code><a href="#topic+SMR">SMR</a></code> versus SRU scatter plot with its medians and tertiles. Thus, it classifies each unit in the quadrants formed by these two medians as: most efficient (ME) which is the lower left quadrant (both SRU and SMR below their medians);  least efficient (LE) is the upper right quadrant (both SRU and SMR above their medians); and least achieving (LA) - the lower right quadrant (SRU below and SMR above their medians); and over achieving (OA) - the upper left quadrant (SRU above and SMR below their medians).
</p>
<p><code>print.SRU</code> Prints a object of class 'SRU'.
</p>
<p><code>cut_in</code> is used to find limits to define severity classes which are used in <code>SRU</code> function. The severity classes are necessary to calculate the average of days to produce one survivor and consequently to estimate the expected LOS in each ICU. Its rationale is to find the limits for the severity classes that yeld a desired average of days to produce one survivor. At some point in time, we made a study to test if different arrangements of the severity classes would yeld different classifications in the efficiency quadrants. Despite the fact that this study did not show any difference from each approach, we left the function in the package. Therefore, any arbitrary severity classes should yeild the same results.
</p>
<p><code>SRUcalc</code> is a simpler function to estimte SRU and returns, for each unit, the SRU value, the observed and expected number of deaths, and the observed and expected LOS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SRU(
  prob,
  death,
  unit,
  los,
  los.exp,
  class,
  score,
  plot = FALSE,
  type = 1,
  digits = 2,
  digits2 = 5,
  originals = FALSE,
  myunits = NULL
)

## S3 method for class 'SRU'
print(x, ...)

## S3 method for class 'SRU'
plot(
  x,
  ...,
  xlim = range(x$rates[, 2]),
  ylim = range(x$rates[, 1]),
  xlab = "SMR",
  ylab = "SRU",
  points.arg = list(pch = 21, col = "white", bg = "cadetblue3", cex = 1.5),
  med.arg = list(col = "dodgerblue4", lwd = 2, lty = 1),
  tert.arg = list(col = "darkorange2", lty = 2, lwd = 1),
  auto.legend = TRUE,
  leg.arg = list(x = "top", bty = "n", xpd = NA, inset = -0.2, ncol = 2),
  bty = "n",
  myunits = x$myunits,
  myunitspts.arg = list(pch = 21, col = "white", bg = "red", cex = 1.5),
  myunitstext.arg = list(pos = 1, font = 2, cex = 0.8)
)

cut_in(
  score,
  los,
  death,
  unit,
  days,
  min = 200,
  exc.ICU = TRUE,
  complete = FALSE,
  digits = 5
)

SRUcalc(prob, death, unit, los, score, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SRU_+3A_prob">prob</code></td>
<td>
<p>Individual predicted probability of death (ranging from 0 to 1) in a vector.</p>
</td></tr>
<tr><td><code id="SRU_+3A_death">death</code></td>
<td>
<p>Observed death. Accepted values are 0 (absence) or 1 (presence) in a vector.</p>
</td></tr>
<tr><td><code id="SRU_+3A_unit">unit</code></td>
<td>
<p>A character or factor variable indicating the ICU where the patient is admitted.</p>
</td></tr>
<tr><td><code id="SRU_+3A_los">los</code></td>
<td>
<p>A numeric variable indicating the observed length of stay for each patient.</p>
</td></tr>
<tr><td><code id="SRU_+3A_los.exp">los.exp</code></td>
<td>
<p>Estimated length of stay (LOS). This argument is optional and will be required only if <code>type = 2</code>. If the user has an alternative model to estimate the individual LOS, the predicted individual LOS should be passed to this argument. If this is the case, the predicted ICU LOS is estimated as the mean of the individual predictions of the LOS of these groups.</p>
</td></tr>
<tr><td><code id="SRU_+3A_class">class</code></td>
<td>
<p>A factor variable indicating the class of severity score (e.g. SAPS 3). In the case of SAPS 3, this is a cut in the SAPS 3 score, grouping patients into severity classes. This will be required if the argument <code>original = FALSE</code> and NAs are not allowed; if <code>original = TRUE</code>, class is ignored.</p>
</td></tr>
<tr><td><code id="SRU_+3A_score">score</code></td>
<td>
<p>A numeric vector with the Acute Physiology Score (SAPS) 3 score for each admission. The function will use this argument to know to which severity class each patient will be assigned to. It is used only when <code>originals = TRUE</code> and ignored otherwise. NAs are not allowed.</p>
</td></tr>
<tr><td><code id="SRU_+3A_plot">plot</code></td>
<td>
<p>Logical; If <code>TRUE</code>, plots a SMR versus SRU scatter plot.</p>
</td></tr>
<tr><td><code id="SRU_+3A_type">type</code></td>
<td>
<p>A Way to calculate SRU. If <code>type = 1</code>, it does as the original article to estimate the ICU's expected LOS (default). First, it multiplies the overall average of days of each severity class by the number of survivors in the same severity class in that ICU. Than, it sums the expected LOS for each severity class in that ICU. If <code>type = 2</code>, the user must provide the <code>los.exp</code> (expected LOS) for each subject (i.e. from a prediction model), and the function will estimate the ICU's expected LOS as the mean of all individual LOS for patients in that ICU.</p>
</td></tr>
<tr><td><code id="SRU_+3A_digits">digits</code>, <code id="SRU_+3A_digits2">digits2</code></td>
<td>
<p>Integer indicating the number of decimals to be used in the output.</p>
</td></tr>
<tr><td><code id="SRU_+3A_originals">originals</code></td>
<td>
<p>Logical; If <code>TRUE</code>, it uses the severity classes and average days as the original article and will override the <code>class</code> argument, if any. It requires the <code>score</code> argument and it must be the SAPS 3 score. We recommend not to set it <code>TRUE</code> unless you really know what you are doing. Even if one wishes to have severity classes identical to the original paper, it is better to set the severity classes before running the analysis. This way, the function will estimate the average days from the data instead of using the fixed average days from the original paper.</p>
</td></tr>
<tr><td><code id="SRU_+3A_myunits">myunits</code></td>
<td>
<p>A character vector with the unit names which one would like to benchmark among all units. These units will be highlighted with dots of different collors in the plot. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SRU_+3A_x">x</code></td>
<td>
<p>For <code>print.SRU</code> or <code>plot.SRU</code>, an object of class 'SRU'.</p>
</td></tr>
<tr><td><code id="SRU_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> or to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="SRU_+3A_xlim">xlim</code>, <code id="SRU_+3A_ylim">ylim</code></td>
<td>
<p>Limits of x and y axis for <code>plot.SRU</code>.</p>
</td></tr>
<tr><td><code id="SRU_+3A_xlab">xlab</code>, <code id="SRU_+3A_ylab">ylab</code></td>
<td>
<p>Labels of x and y axis for <code>plot.SRU</code>.</p>
</td></tr>
<tr><td><code id="SRU_+3A_points.arg">points.arg</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+points">points</a></code> for plotting points correponding to ICU's SMR and SRU.</p>
</td></tr>
<tr><td><code id="SRU_+3A_med.arg">med.arg</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+abline">abline</a></code> for plotting lines corresponding to SRU's and SMR's medians.</p>
</td></tr>
<tr><td><code id="SRU_+3A_tert.arg">tert.arg</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+abline">abline</a></code> for plotting lines corresponding to SRU's and SMR's tertiles.</p>
</td></tr>
<tr><td><code id="SRU_+3A_auto.legend">auto.legend</code></td>
<td>
<p>Logical; If <code>TRUE</code>, prints a legend with parameters in <code>leg.arg</code> arguments.</p>
</td></tr>
<tr><td><code id="SRU_+3A_leg.arg">leg.arg</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code> for plotting legends in <code>plot.SRU</code>.</p>
</td></tr>
<tr><td><code id="SRU_+3A_bty">bty</code></td>
<td>
<p>A character string which determines the type of box that is drawn about plots. See  <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="SRU_+3A_myunitspts.arg">myunitspts.arg</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+points">points</a></code> for plotting points correponding to <code>myunits</code>'s SMR and SRU.</p>
</td></tr>
<tr><td><code id="SRU_+3A_myunitstext.arg">myunitstext.arg</code></td>
<td>
<p>List of arguments passed to <code><a href="graphics.html#topic+text">text</a></code> for labelling points correponding to <code>myunits</code>'s position.</p>
</td></tr>
<tr><td><code id="SRU_+3A_days">days</code></td>
<td>
<p>For <code>cut_in</code>, this is a vector of days to get an avarage. See example.</p>
</td></tr>
<tr><td><code id="SRU_+3A_min">min</code></td>
<td>
<p>For <code>cut_in</code>, this is the minimum desired quantity of patients in each severity class (default = 200) to estimate the average days.</p>
</td></tr>
<tr><td><code id="SRU_+3A_exc.icu">exc.ICU</code></td>
<td>
<p>Logical; For <code>cut_in</code>, if <code>TRUE</code>, ICUs without surviving patients are ignored.</p>
</td></tr>
<tr><td><code id="SRU_+3A_complete">complete</code></td>
<td>
<p>Logical; For <code>cut_in</code>, if <code>TRUE</code>, shows additional information about severity classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two tables: one with information about severity classes and the respective quantities required to estimate the expected LOS, and another with information about ICUs classified as Most Efficient (ME) or Least Efficient (LE).
</p>

<ul>
<li> <p><code>Sev</code> Severity class.
</p>
</li>
<li><p><code>Total</code> Total of patients.
</p>
</li>
<li> <p><code>Surv</code> Total of survivors.
</p>
</li>
<li> <p><code>Total.LOS</code> Total length of stay (days).
</p>
</li>
<li> <p><code>AvDays</code> Average days to produce a survivor.
</p>
</li>
<li> <p><code>N.Unit</code> Quantity of ICUs.
</p>
</li>
<li> <p><code>N.Pat</code> Quantity of patients.
</p>
</li>
<li><p><code>SMR</code> Standardized Mortality Ratio Mean (standard deviation).
</p>
</li>
<li> <p><code>SRU</code> Standardized Resource Use Mean (standard deviation).
</p>
</li></ul>

<p>Most Efficient ICUs have SRU, SMR &lt; median. Least Efficient ICUs have SRU, SMR &gt; median.
</p>
<p><code>cut_in</code> returns a vector with the limits to cut the severity score.
</p>
<p><code>SRUcalc</code> returns a table with:
</p>

<ul>
<li> <p><code>Unit</code> ICUs names.
</p>
</li>
<li><p><code>SMR or SRU</code> Standardized Rate.
</p>
</li>
<li> <p><code>N</code> Number of subjects analyzed.
</p>
</li>
<li> <p><code>Observed</code> Observed number of deaths.
</p>
</li>
<li> <p><code>Expected</code> Expected number of deaths.
</p>
</li>
<li> <p><code>LOS_esp</code> Expected length of stay.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Lunna Borges and Pedro Brasil
</p>


<h3>References</h3>

<p>Rothen HU, Stricker K, Einfalt J, Bauer P, Metnitz PGH, Moreno RP, Takala J (2007) Variability in outcome and resource use in intensive care units. Intensive Care Med 33:1329-1336
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SMR">SMR</a></code>, <code><a href="#topic+reclass">reclass</a></code>, <code><a href="#topic+funnel">funnel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Loading the dataset
data(icu)

# Removing data with inapropriate values and some editing
icu &lt;- icu[-which(icu$los &lt; 0 ),]
icu$Saps3DeathProbabilityStandardEquation &lt;- icu$Saps3DeathProbabilityStandardEquation / 100

# Setting classes acording to limits of SAPS 3 score
days &lt;- seq(1,100)
cut_lims &lt;- cut_in(icu$Saps3Points, icu$los, icu$UnitDischargeName,
                   icu$Unit, days, exc.ICU = TRUE)
icu$class &lt;- cut(icu$Saps3Points, breaks = cut_lims, include.lowest = TRUE)

# Estimating the SRU benchmarking myunit A and B
x &lt;- SRU(prob = icu$Saps3DeathProbabilityStandardEquation,
death = icu$UnitDischargeName, unit = icu$Unit,
los = icu$los, score = icu$Saps3Points,
originals = TRUE, type = 1, plot = FALSE, myunits = c("A","B"))
x
plot(x)

# To see the units rankings and individual SMR and SRU, ordering by its SRU
x$rates[order(x$rates$sru),]

# SRU with diferent severity classes created by cut_in function
y &lt;- SRU(prob = icu$Saps3DeathProbabilityStandardEquation,
death = icu$UnitDischargeName, unit = icu$Unit,
los = icu$los, score = icu$Saps3Points,
originals = FALSE, type = 1, plot = FALSE, class = icu$class)
y

# Using SRUcalc
SRUcalc(prob = icu$Saps3DeathProbabilityStandardEquation,
        death = icu$UnitDischargeName, unit = icu$Unit, los = icu$los,
        score = icu$Saps3Points)

rm(x, y, days, icu, cut_lims)

</code></pre>

<hr>
<h2 id='survPerformance'>Survival models performance analysis</h2><span id='topic+survPerformance'></span><span id='topic+R2sh'></span><span id='topic+R2pm'></span><span id='topic+cal.Slope'></span>

<h3>Description</h3>

<p>Colection of functions for survival models performance analysis.
</p>
<p><code>R2sh</code> estimates a distance-based estimator of survival predictive accuracy proposed by Schemper and Henderson. It was inspirated in survAUC::schemper function, but receives the predicted values directly. Besides that, <code>R2sh</code> does bootstrap resampling and returns its confidence interval estimate.
</p>
<p><code>R2pm</code> calculates a estimator of survival predictive accuracy proposed by Kent &amp; O'Quigley and its bootstrap confidence interval.
</p>
<p><code>cal.Slope</code> returns the calibration slope of a survival model and its bootstrap confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2sh(time, status, lin.pred, data, R)

R2pm(lin.pred, R)

cal.Slope(time, status, lin.pred, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survPerformance_+3A_time">time</code></td>
<td>
<p>A vector of event times.</p>
</td></tr>
<tr><td><code id="survPerformance_+3A_status">status</code></td>
<td>
<p>A indicator vector of event occurrence.</p>
</td></tr>
<tr><td><code id="survPerformance_+3A_lin.pred">lin.pred</code></td>
<td>
<p>A vector of linear predictors of a survival model for each observation. (prognostic index)</p>
</td></tr>
<tr><td><code id="survPerformance_+3A_data">data</code></td>
<td>
<p>A data.frame where to find column vectors.</p>
</td></tr>
<tr><td><code id="survPerformance_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates. Usually this will be a single positive integer. For importance resampling, some resamples may use one set of weights and others use a different set of weights. In this case R would be a vector of integers where each component gives the number of resamples from each of the rows of weights. To be passed to <code><a href="boot.html#topic+boot">boot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>R2sh</code> returns a list with the following components:
</p>

<ul>
<li> <p><code>D</code>: The estimator of predictive accuracy obtained from the covariate-free null model.
</p>
</li>
<li> <p><code>Dx</code>: The estimator of predictive accuracy obtained from the Cox model.
</p>
</li>
<li> <p><code>V</code>: The estimator of relative gains in predictive accuracy.
</p>
</li>
<li> <p><code>Mhat</code>: The absolute distance estimator obtained from the   Cox model (evaluated at the event times of the test data).
</p>
</li>
<li> <p><code>Mhat.0</code>: The absolute distance estimator obtained from the covariate-free null model (evaluated at the event times of the test data).
</p>
</li>
<li> <p><code>timep</code>: The event times of the test data.
</p>
</li>
<li> <p><code>lower</code>: V lower confidence limit.
</p>
</li>
<li> <p><code>upper</code>: V upper confidence limit.
</p>
</li>
<li> <p><code>boot</code>: An object of class &quot;<code><a href="boot.html#topic+boot">boot</a></code>&quot;.
</p>
</li>
<li> <p><code>bootCI</code>: Boot confidence intervals resampling.
</p>
</li></ul>

<p><code>R2pm</code> returns a list with the following components:
</p>

<ul>
<li> <p><code>r2</code>: The estimator of predictive accuracy obtained from the Cox model.
</p>
</li>
<li> <p><code>lower</code>: r2 lower confidence limit.
</p>
</li>
<li> <p><code>upper</code>: r2 upper confidence limit.
</p>
</li>
<li> <p><code>boot</code>: An object of class &quot;<code><a href="boot.html#topic+boot">boot</a></code>&quot;.
</p>
</li>
<li> <p><code>bootCI</code>: Boot confidence intervals resampling.
</p>
</li></ul>

<p><code>cal.Slope</code> returns a list with the following components:
</p>

<ul>
<li> <p><code>slope</code>: The calibration slope measure of a survival model.
</p>
</li>
<li> <p><code>lower</code>: slope lower confidence limit.
</p>
</li>
<li> <p><code>upper</code>: slope upper confidence limit.
</p>
</li>
<li> <p><code>boot</code>: An object of class &quot;<code><a href="boot.html#topic+boot">boot</a></code>&quot;.
</p>
</li>
<li> <p><code>bootCI</code>: Boot confidence intervals resampling.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Lunna Borges &lt;lunna.borges@epimedsolutions.com&gt;
</p>


<h3>References</h3>

<p>Schemper, M. and R. Henderson (2000).
Predictive accuracy and explained variation in Cox regression.
Biometrics 56, 249-255.
</p>
<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application, Chapter 5. Cambridge University Press.
</p>
<p>DiCiccio, T.J. and Efron B. (1996) Bootstrap confidence intervals (with Discussion). Statistical Science, 11, 189-228.
</p>
<p>Efron, B. (1987) Better bootstrap confidence intervals (with Discussion). Journal of the American Statistical Association, 82, 171-200.
</p>
<p>Kent, John T., and J. O. H. N. O'QUIGLEY. &quot;Measures of dependence for censored survival data.&quot; Biometrika 75.3 (1988): 525-534.
</p>
<p>van Houwelingen, Hans C. &quot;Validation, calibration, revision and combination of prognostic survival models.&quot; Statistics in medicine 19.24 (2000): 3401-3415.
</p>
<p>Rahman, M. Shafiqur, et al. &quot;Review and evaluation of performance measures for survival prediction models in external validation settings.&quot; BMC medical research methodology 17.1 (2017): 60.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Survival model ####

data(breastCancer)
class(breastCancer$gradd1) &lt;- "character"
class(breastCancer$gradd2) &lt;- "character"

traindata &lt;- breastCancer[sample(nrow(breastCancer), nrow(breastCancer)*2/3),]
newdata &lt;- breastCancer[-sample(nrow(breastCancer), nrow(breastCancer)*2/3),]
model &lt;- rms::cph(survival::Surv(rectime, censrec) ~ rms::rcs(age,6) +
 rms::rcs(nodes,3) + rms::rcs(pgr,3) + gradd1 + gradd2 +
 hormon, data = traindata)

lp &lt;- predict(model, newdata = newdata)

#### R2sh  example ####

R2sh(newdata$rectime, newdata$censrec, lp, data = newdata, R = 50)

#### R2pm example ####

R2pm(lp, R = 50)

#### cal.slope example ####

cal.Slope(newdata$rectime, newdata$censrec, lp, R = 50)

</code></pre>

<hr>
<h2 id='tableStack'>Tabulation of variables in a stack form</h2><span id='topic+tableStack'></span>

<h3>Description</h3>

<p>There are two functionalities: Tabulation of variables with the same possible range of distribution and stack into a new table with or without other descriptive statistics or to breakdown distribution of more than one row variables against a column variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableStack(
  vars,
  dataFrame,
  minlevel = "auto",
  maxlevel = "auto",
  count = TRUE,
  na.rm = FALSE,
  means = TRUE,
  medians = FALSE,
  sds = TRUE,
  decimal = 2,
  total = TRUE,
  var.labels = TRUE,
  var.labels.trunc = 150,
  reverse = FALSE,
  vars.to.reverse = NULL,
  by = NULL,
  vars.to.factor = NULL,
  iqr = "auto",
  prevalence = FALSE,
  percent = c("column", "row", "none"),
  frequency = TRUE,
  test = TRUE,
  name.test = TRUE,
  total.column = FALSE,
  simulate.p.value = FALSE,
  sample.size = TRUE,
  assumption.p.value = 0.01,
  NAcol = FALSE,
  NArow = FALSE,
  drplvls = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tableStack_+3A_vars">vars</code></td>
<td>
<p>a vector of variables in the data frame. The imput may be given with or without quotes.</p>
</td></tr>
<tr><td><code id="tableStack_+3A_dataframe">dataFrame</code></td>
<td>
<p>source data frame of the variables</p>
</td></tr>
<tr><td><code id="tableStack_+3A_minlevel">minlevel</code></td>
<td>
<p>possible minimum value of items specified by user</p>
</td></tr>
<tr><td><code id="tableStack_+3A_maxlevel">maxlevel</code></td>
<td>
<p>possible maximum value of items specified by user</p>
</td></tr>
<tr><td><code id="tableStack_+3A_count">count</code></td>
<td>
<p>whether number of valid records for each item will be displayed</p>
</td></tr>
<tr><td><code id="tableStack_+3A_na.rm">na.rm</code></td>
<td>
<p>whether missing value would be removed during calculation mean score of each person</p>
</td></tr>
<tr><td><code id="tableStack_+3A_means">means</code></td>
<td>
<p>whether means of all selected items will be displayed</p>
</td></tr>
<tr><td><code id="tableStack_+3A_medians">medians</code></td>
<td>
<p>whether medians of all selected items will be displayed</p>
</td></tr>
<tr><td><code id="tableStack_+3A_sds">sds</code></td>
<td>
<p>whether standard deviations of all selected items will be displayed</p>
</td></tr>
<tr><td><code id="tableStack_+3A_decimal">decimal</code></td>
<td>
<p>number of decimals displayed</p>
</td></tr>
<tr><td><code id="tableStack_+3A_total">total</code></td>
<td>
<p>display of means and standard deviations of total and average scores</p>
</td></tr>
<tr><td><code id="tableStack_+3A_var.labels">var.labels</code></td>
<td>
<p>presence of descriptions of variables on the last column of output</p>
</td></tr>
<tr><td><code id="tableStack_+3A_var.labels.trunc">var.labels.trunc</code></td>
<td>
<p>number of characters used for variable description</p>
</td></tr>
<tr><td><code id="tableStack_+3A_reverse">reverse</code></td>
<td>
<p>whether item(s) negatively correlated with other majority will be reversed</p>
</td></tr>
<tr><td><code id="tableStack_+3A_vars.to.reverse">vars.to.reverse</code></td>
<td>
<p>variable(s) to reverse</p>
</td></tr>
<tr><td><code id="tableStack_+3A_by">by</code></td>
<td>
<p>a variable for column breakdown. If NONE is given, only the 'total column' will be displayed. More on Details.</p>
</td></tr>
<tr><td><code id="tableStack_+3A_vars.to.factor">vars.to.factor</code></td>
<td>
<p>variable(s) to be converted to factor for tabulaton</p>
</td></tr>
<tr><td><code id="tableStack_+3A_iqr">iqr</code></td>
<td>
<p>variable(s) to display median and inter-quartile range</p>
</td></tr>
<tr><td><code id="tableStack_+3A_prevalence">prevalence</code></td>
<td>
<p>for logical or dichotomous variables, whether prevalence of the dichotomous row variable in each column subgroup will be displayed</p>
</td></tr>
<tr><td><code id="tableStack_+3A_percent">percent</code></td>
<td>
<p>type of percentage displayed when the variable is categorical and for NArow when activated. Default is column</p>
</td></tr>
<tr><td><code id="tableStack_+3A_frequency">frequency</code></td>
<td>
<p>whether to display frequency in the cells when the variable is categorical and for NArow when activated</p>
</td></tr>
<tr><td><code id="tableStack_+3A_test">test</code></td>
<td>
<p>whether statistical test(s) will be computed</p>
</td></tr>
<tr><td><code id="tableStack_+3A_name.test">name.test</code></td>
<td>
<p>display name of the test and relevant degrees of freedom</p>
</td></tr>
<tr><td><code id="tableStack_+3A_total.column">total.column</code></td>
<td>
<p>whether to add 'total column' to the output or not</p>
</td></tr>
<tr><td><code id="tableStack_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>simulate P value for Fisher's exact test</p>
</td></tr>
<tr><td><code id="tableStack_+3A_sample.size">sample.size</code></td>
<td>
<p>whether to display non-missing sample size of each column</p>
</td></tr>
<tr><td><code id="tableStack_+3A_assumption.p.value">assumption.p.value</code></td>
<td>
<p>level of Bartlett's test P value to judge whether the comparison and the test should be parametric</p>
</td></tr>
<tr><td><code id="tableStack_+3A_nacol">NAcol</code></td>
<td>
<p>whether to add 'NA column' to the output or not</p>
</td></tr>
<tr><td><code id="tableStack_+3A_narow">NArow</code></td>
<td>
<p>whether to add 'NA rows' for each variable to the output or not</p>
</td></tr>
<tr><td><code id="tableStack_+3A_drplvls">drplvls</code></td>
<td>
<p>whether to hide non used levels on factor and character variables or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a clone of <code>tableStack</code> from the <code>epiDisplay</code> package. Comparing to the original, tt adds options to show the NA in the variables as categories, similar to the option <code>useNA</code> in the <code>table</code> function, and it also fix few bugs, such as showing the <code>total.column</code> without the need to <code>test = TRUE</code>, and to show or hide levels with zero counts without returning error.
</p>
<p>This function simultaneously explores several variables with a fixed integer rating scale. For non-factor variables, the default values for tabulation are the minimum and the maximum of all variables but can be specified by the user.
</p>
<p>When 'by' is omitted, all variables must be of the same class, and must be 'integer', 'factor' or 'logical. Some parameters are only used if by is omitted, others are only used if by is available. The by-omitted dependent variable are minlevel, maxlevel, count, na.rm, means, medians, sds, total, reverse, vars.to.reverse. The by-available dependent variables are iqr, prevalence, percent, frequency, test, name.test, total.column, simulate.p.value, sample.size, assumption.p.value, NArow, NAcol, drplvls.
Unlike function 'alpha', the argument 'reverse' has a default value of FALSE. This argument is ignored if 'vars.to.reverse' is specified.
</p>
<p>Options for 'reverse', 'vars.to.reverse' and statistics of 'means', 'medians', 'sds' and 'total' are available only if the items are not factor. To obtain statistics of factor items, users need to use 'unclassDataframe' to convert them into integer.
</p>
<p>When the 'by' argument is given, 'reverse' and 'vars.to.reverse' do not apply, as mentioned before. Instead, columns of the 'by' variable will be formed. A table will be created against each selected variable. If the variable is a factor or coerced to factor with 'vars.to.factor', cross-tabulation will result with percents as specified, ie. &quot;column&quot;, &quot;row&quot;, or &quot;none&quot; (FALSE). For a dichotomous row variable, if set to 'TRUE', the prevalence of row variable in the form of a fraction is displayed in each subgroup column. For objects of class 'numeric' or 'integer', means with standard deviations will be displayed. For variables with residuals that are not normally distributed or where the variance of subgroups are significantly not normally distributed (using a significance level of 0.01), medians and inter-quartile ranges will be presented if the argument 'iqr' is set to &quot;auto&quot; (by default). Users may specify a subset of the selected variables (from the 'vars' argument) to be presented in such a form. Otherwise, the argument could be set as any other character string, except the variables names, to insist to present means and standard deviations.
</p>
<p>When 'test = TRUE' (default), Pearson's chi-squared test (or a two-sided Fisher's exact test, if the sample size is small) will be carried out for a categorical variable or a factor. Parametric or non-parametric comparison and test will be carried out for a object of class 'numeric' or 'integer' (See 'iqr' and 'assumption.p.value' below). If the sample size of the numeric variable is too small in any group, the test is omitted and the problem reported.
</p>
<p>For Fisher's exact test, the default method employs 'simulate.p.value = FALSE'. See further explanation in 'fisher.test' procedure. If the dataset is extraordinarily large, the option may be manually set to TRUE.
</p>
<p>When 'by' is specified as a single character object (such as 'by=&quot;none&quot;') or when 'by = NONE' there will be no column breakdown and all tests will be omitted. Only the total column is displayed. Only the 'total' column is shown.
</p>
<p>If this 'total column' is to accompany the 'by' breakdown, the argument 'total.column=TRUE' should be specified. The 'sample.size' is TRUE by default. The total number of records for each group is displayed in the first row of the output. However, the variable in each row may have some missing records, the information on which is reported by NArow for each variable on 'vars' and by NAcol for the variable on 'by'.
</p>
<p>By default, Epicalc sets 'var.labels=TRUE' in order to give nice output. However, 'var.labels=FALSE' can sometimes be more useful during data exploration. Variable numbers as well as variable names are displayed instead of variable labels. Names and numbers of abnormally distributed variables, especially factors with too many levels, can be easily identified for further relevelling or recoding.
</p>
<p>The argument 'iqr' has a default value being &quot;auto&quot;. Non-parametric comparison and test will be automatically chosen if Bartlett's test P value is below the 'assumption.p.value'.
</p>
<p>The test can be forced to parametric by setting 'iqr=NULL' and to non-parametric by if iqr is set to the variable number of cont.var (See examples.).
</p>


<h3>Value</h3>

<p>an object of class 'tableStack' and 'list' when by=NULL
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>results</code> </td><td style="text-align: left;"> an object of class 'noquote' which is used for print out</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>items.reversed</code>  </td><td style="text-align: left;"> name(s) of variable(s) reversed</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>total.score</code> </td><td style="text-align: left;"> a vector from 'rowSums' of the columns of variables specified in 'vars'</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mean.score</code>  </td><td style="text-align: left;"> a vector from 'rowMeans' of the columns of variables specified in 'vars'</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mean.of.total.scores</code>  </td><td style="text-align: left;"> mean of total scores</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sd.of.total.scores</code>  </td><td style="text-align: left;"> standard deviation of total scores</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mean.of.average.scores</code>  </td><td style="text-align: left;"> mean of mean scores</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sd.of.average.scores</code>  </td><td style="text-align: left;"> standard deviation of mean scores
</td>
</tr>

</table>

<p>When 'by' is specified, an object of class 'tableStack' and 'table is returned.
</p>


<h3>Author(s)</h3>

<p>Virasakdi Chongsuvivatwong &lt;cvirasak@medicine.psu.ac.th&gt;
</p>
<p>Caio Ferreira &lt;caio.ferreira@epimedsolutions.com&gt;
</p>
<p>Lunna Borges &lt;caio.ferreira@epimedsolutions.com&gt;
</p>
<p>Pedro Brasil &lt;pedro.brasil@epimedsolutions.com&gt;
</p>


<h3>References</h3>

<p>'table', 'tab1', 'summ', 'alpha', 'unclassDataframe'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data &lt;- data.frame(sex = sample(c("M","F"), 50, rep = TRUE),
age = sample(c(NA,20:70), 50, rep = TRUE),
admissionType = sample(c(NA,"urgency", "clinical", "scheduled"), 50, rep = TRUE),
hospitalizationTime = sample(c(0:10), 50, rep = TRUE),
numberOfChildren = sample(c(NA,0:3), 50, rep = TRUE),
cancerInFamily = sample(c(NA,TRUE,FALSE), 50, rep = TRUE),
diabetesInFamily = sample(c(TRUE,FALSE), 50, rep = TRUE),
thrombosisInFamily = sample(c(TRUE,FALSE), 50, rep = TRUE),
mentaldiseasesInFamily = sample(c(TRUE,FALSE), 50, rep = TRUE),
cardiadicdiseaseInFamily = sample(c(NA,TRUE,FALSE), 50, rep = TRUE),
readmission = sample(c(NA,TRUE,FALSE), 50, rep = TRUE))

attach(data)
tableStack(cancerInFamily:cardiadicdiseaseInFamily, dataFrame = data)
detach(data)
tableStack(cancerInFamily:cardiadicdiseaseInFamily, data) # Default data frame is data
# "by" compares variables
tableStack(cancerInFamily:cardiadicdiseaseInFamily, data, by= readmission)
# "prevalence" returns the prevalence instead of the absolute values
tableStack(cancerInFamily:cardiadicdiseaseInFamily, data,
by= readmission, prevalence=TRUE)
# "percent" as FALSE hides the percentage in parenthesis
tableStack(cancerInFamily:cardiadicdiseaseInFamily, data,
by= readmission, percent=FALSE)
# "name.test" as FALSE hides the column that shows the tests names
tableStack(cancerInFamily:cardiadicdiseaseInFamily, data,
by= readmission, percent=FALSE, name.test=FALSE)
# "NAcol" displays a column of NA values on the variable on "by"
tableStack(cancerInFamily:cardiadicdiseaseInFamily, data,
by= readmission, NAcol = TRUE)
# "NArow" displays rows of NA values on the variables on "vars"
tableStack(cancerInFamily:cardiadicdiseaseInFamily, data,
by= readmission, NAcol = TRUE, NArow = TRUE)

# the specification of the vars may be done as the range
tableStack(vars=2:7, data, by=sex)
# "by" var may be specified as "none" and the selected vars will be crossed only against the total
tableStack(vars=2:7, data, by="none")
# by = NONE works just as by = "none"
tableStack(vars=2:7, data, by = NONE)
# total.column displays a column of totals in adition to the variable on by
tableStack(vars=2:7, data, by=sex, total.column=TRUE)

var.labels &lt;- c("sex", "Type of admission for each patient",
"age", "Duration time in days of the patient's hospitalization",
"Number of children that the patient have",
"whether or not the patient has cancer in family",
"whether or not the patient has diabetes in family",
"whether or not the patient has thrombosis in family",
"whether or not the patient has mental diseases in family",
"whether or not the patient has cardiac diseases in family",
"whether or not the patient is on a relapse admission")
#setting the attribute var.labels
attr(data, "var.labels") &lt;- var.labels
rm(var.labels)

# May need full screen of Rconsole
tableStack(vars=c(numberOfChildren,hospitalizationTime), data)
# Fits in with default R console screen
tableStack(vars=c(numberOfChildren,hospitalizationTime), data,
var.labels.trunc=35)
tableStack(vars=c(age,numberOfChildren,hospitalizationTime),
data, reverse=TRUE) -&gt; a
a
## Components of 'a' have appropriate items reversed
a$mean.score -&gt; mean.score
a$total.score -&gt; total.score
data$mean.score &lt;- mean.score
data$total.score &lt;- total.score

# hiding the test column
tableStack(c(age, numberOfChildren,hospitalizationTime,
mean.score,total.score), data, by=sex, test=FALSE)
# variables specified on iqr will not display SD but IQR instead
tableStack(3:5, data, by=sex, iqr=hospitalizationTime)
## 'vars' can be mixture of variables of different classes
tableStack(3:5, data, by=admissionType,
iqr=c(hospitalizationTime, total.score))

data$highscore &lt;- mean.score &gt; 4
# a variable with some comparison may be created easily
tableStack(mean.score:highscore, data,
by=sex, iqr=total.score)

# the percentage information may be hidden
tableStack(vars=c(readmission,admissionType),
data, by=sex, percent="none")
# it may be shown the prevalende of the
# variable instead of the values themselves
tableStack(vars=c(readmission,admissionType), data,
by=sex, prevalence = TRUE)
# the name of the tests may be hidden
# while the test itself still shows
tableStack(vars=c(readmission,admissionType), data,
by=sex, name.test = FALSE)

## Variable in numeric or factor
# as continuous varaibles
tableStack(vars=3:5, data, by=sex)
# as factors
tableStack(vars=3:5, data, by=sex, vars.to.factor = 3:5)

## Using drplvls
# a dataframe will be created containing a factor with an unused level
bloodbank &lt;- data.frame(AgeInDays =
    sample(0:15,200, replace = TRUE), Type =
    factor(sample(c("A","B","0"), 200, replace = TRUE),
      levels = c("A","B","AB","0")), Origin =
    sample(c("US","CA"), 200, replace = TRUE))

# by using drplvls the row of the unused fator is hidden
tableStack(vars = c(AgeInDays, Type),
bloodbank, by = Origin) #usual
tableStack(vars = c(AgeInDays, Type),
bloodbank, by = Origin,
drplvls = TRUE) # with drplvls

rm(total.score, mean.score, a, data, bloodbank)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
