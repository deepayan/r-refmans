<!DOCTYPE html><html><head><title>Help for package segregation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {segregation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compress'><p>Compresses a data matrix based on mutual information (segregation)</p></a></li>
<li><a href='#dissimilarity'><p>Calculates Index of Dissimilarity</p></a></li>
<li><a href='#dissimilarity_expected'><p>Calculates expected values when true segregation is zero</p></a></li>
<li><a href='#entropy'><p>Calculates the entropy of a distribution</p></a></li>
<li><a href='#exposure'><p>Calculates pairwise exposure indices</p></a></li>
<li><a href='#get_crosswalk'><p>Create crosswalk after compression</p></a></li>
<li><a href='#ipf'><p>Adjustment of marginal distributions using iterative proportional fitting</p></a></li>
<li><a href='#isolation'><p>Calculates isolation indices</p></a></li>
<li><a href='#matrix_to_long'><p>Turns a contingency table into long format</p></a></li>
<li><a href='#merge_units'><p>Creates a compressed dataset</p></a></li>
<li><a href='#mutual_difference'><p>Decomposes the difference between two M indices</p></a></li>
<li><a href='#mutual_expected'><p>Calculates expected values when true segregation is zero</p></a></li>
<li><a href='#mutual_local'><p>Calculates local segregation scores based on M</p></a></li>
<li><a href='#mutual_total'><p>Calculates the Mutual Information Index M and Theil's Entropy Index H</p></a></li>
<li><a href='#mutual_total_nested'><p>Calculates a nested decomposition of segregation for M and H</p></a></li>
<li><a href='#mutual_within'><p>Calculates detailed within-category segregation scores for M and H</p></a></li>
<li><a href='#school_ses'><p>Student-level data including SES status</p></a></li>
<li><a href='#schools00'><p>Ethnic/racial composition of schools for 2000/2001</p></a></li>
<li><a href='#schools05'><p>Ethnic/racial composition of schools for 2005/2006</p></a></li>
<li><a href='#scree_plot'><p>Scree plot for segregation compression</p></a></li>
<li><a href='#segcurve'><p>A visual representation of two-group segregation</p></a></li>
<li><a href='#segplot'><p>A visual representation of segregation</p></a></li>
<li><a href='#segregation'><p>segregation: Entropy-based segregation indices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Entropy-Based Segregation Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes segregation indices, including the Index of Dissimilarity,
    as well as the information-theoretic indices developed by
    Theil (1971) &lt;isbn:978-0471858454&gt;, namely
    the Mutual Information Index (M) and Theil's Information Index (H).
    The M, further described by Mora and Ruiz-Castillo (2011) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9531.2011.01237.x">doi:10.1111/j.1467-9531.2011.01237.x</a>&gt;
    and Frankel and Volij (2011) &lt;<a href="https://doi.org/10.1016%2Fj.jet.2010.10.008">doi:10.1016/j.jet.2010.10.008</a>&gt;,
    is a measure of segregation that is highly decomposable. The package provides
    tools to decompose the index by units and groups (local segregation),
    and by within and between terms. The package also provides a method to decompose
    differences in segregation as described by Elbers (2021) &lt;<a href="https://doi.org/10.1177%2F0049124121986204">doi:10.1177/0049124121986204</a>&gt;.
    The package includes standard error estimation by bootstrapping, which also corrects for
    small sample bias. The package also contains functions for visualizing segregation patterns.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, checkmate, Rcpp, RcppProgress,</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown, dplyr, ggplot2, scales,
tidycensus, tigris, rrapply, dendextend, patchwork</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://elbersb.github.io/segregation/">https://elbersb.github.io/segregation/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/elbersb/segregation/issues">https://github.com/elbersb/segregation/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-02 11:54:48 UTC; benjamin</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Elbers <a href="https://orcid.org/0000-0001-5392-3448"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Elbers &lt;be2239@columbia.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-02 12:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='compress'>Compresses a data matrix based on mutual information (segregation)</h2><span id='topic+compress'></span>

<h3>Description</h3>

<p>Given a data set that identifies suitable neighbors for merging,
this function will merge units iteratively, where in each iteration
the neighbors with the smallest reduction in terms of total M will be merged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress(
  data,
  group,
  unit,
  weight = NULL,
  neighbors = "local",
  n_neighbors = 50,
  max_iter = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="compress_+3A_group">group</code></td>
<td>
<p>A categorical variable
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="compress_+3A_unit">unit</code></td>
<td>
<p>A categorical variable
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="compress_+3A_weight">weight</code></td>
<td>
<p>Numeric. Only frequency weights are allowed.
(Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="compress_+3A_neighbors">neighbors</code></td>
<td>
<p>Either a data frame or a character. If data frame, then
it needs exactly two columns, where each row identifies
a set of &quot;neighbors&quot; that may be merged.
If &quot;local&quot;, considers the <code>n_neighbors</code> closest neighbors
in terms of local segregation.
If &quot;all&quot;, all units are considered as possible neighbors. This
may be very time-consuming.</p>
</td></tr>
<tr><td><code id="compress_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>Only relevant if <code>neighbors</code> is <code>"local"</code>.</p>
</td></tr>
<tr><td><code id="compress_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations (Default <code>Inf</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table.
</p>

<hr>
<h2 id='dissimilarity'>Calculates Index of Dissimilarity</h2><span id='topic+dissimilarity'></span>

<h3>Description</h3>

<p>Returns the total segregation between <code>group</code> and <code>unit</code> using
the Index of Dissimilarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity(
  data,
  group,
  unit,
  weight = NULL,
  se = FALSE,
  CI = 0.95,
  n_bootstrap = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissimilarity_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the first dimension
over which segregation is computed. The D index only
allows two distinct groups.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_se">se</code></td>
<td>
<p>If <code>TRUE</code>, the segregation estimates are bootstrapped to provide
standard errors and to apply bias correction. The bias that is reported
has already been applied to the estimates (i.e. the reported estimates are &quot;debiased&quot;)
(Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_ci">CI</code></td>
<td>
<p>If <code>se = TRUE</code>, compute the confidence (CI*100)
in addition to the bootstrap standard error.
This is based on percentiles of the bootstrap distribution, and a valid interpretation
relies on a larger number of bootstrap iterations. (Default <code>0.95</code>)</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>Number of bootstrap iterations. (Default <code>100</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table with one row. The column <code>est</code> contains
the Index of Dissimilarity.
If <code>se</code> is set to <code>TRUE</code>, an additional column <code>se</code> contains
the associated bootstrapped standard errors, an additional column <code>CI</code> contains
the estimate confidence interval as a list column, an additional column <code>bias</code> contains
the estimated bias, and the column <code>est</code> contains the bias-corrected estimates.
</p>


<h3>References</h3>

<p>Otis Dudley Duncan and Beverly Duncan. 1955. &quot;A Methodological Analysis of Segregation Indexes,&quot;
American Sociological Review 20(2): 210-217.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example where D and H deviate
m1 &lt;- matrix_to_long(matrix(c(100, 60, 40, 0, 0, 40, 60, 100), ncol = 2))
m2 &lt;- matrix_to_long(matrix(c(80, 80, 20, 20, 20, 20, 80, 80), ncol = 2))
dissimilarity(m1, "group", "unit", weight = "n")
dissimilarity(m2, "group", "unit", weight = "n")
</code></pre>

<hr>
<h2 id='dissimilarity_expected'>Calculates expected values when true segregation is zero</h2><span id='topic+dissimilarity_expected'></span>

<h3>Description</h3>

<p>When sample sizes are small, one group has a small proportion, or
when there are many units, segregation indices are typically upwardly
biased, even when true segregation is zero. This function simulates
tables with zero segregation, given the marginals of the dataset,
and calculates segregation. If the expected values are large,
the interpretation of index scores might have to be adjusted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity_expected(
  data,
  group,
  unit,
  weight = NULL,
  fixed_margins = TRUE,
  n_bootstrap = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissimilarity_expected_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="dissimilarity_expected_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="dissimilarity_expected_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="dissimilarity_expected_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="dissimilarity_expected_+3A_fixed_margins">fixed_margins</code></td>
<td>
<p>Should the margins be fixed or simulated? (Default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="dissimilarity_expected_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>Number of bootstrap iterations. (Default <code>100</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with one row, corresponding to the expected value of
the D index when true segregation is zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build a smaller table, with 100 students distributed across
# 10 schools, where one racial group has 10% of the students
small &lt;- data.frame(
    school = c(1:10, 1:10),
    race = c(rep("r1", 10), rep("r2", 10)),
    n = c(rep(1, 10), rep(9, 10))
)
dissimilarity_expected(small, "race", "school", weight = "n")
# with an increase in sample size (n=1000), the values improve
small$n &lt;- small$n * 10
dissimilarity_expected(small, "race", "school", weight = "n")
</code></pre>

<hr>
<h2 id='entropy'>Calculates the entropy of a distribution</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>Returns the entropy of the distribution defined by
<code>group</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(data, group, weight = NULL, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="entropy_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="entropy_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="entropy_+3A_base">base</code></td>
<td>
<p>Base of the logarithm that is used in the entropy
calculation. Defaults to the natural logarithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number, the entropy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(cat = c("A", "B"), n = c(25, 75))
entropy(d, "cat", weight = "n") # =&gt; .56
# this is equivalent to -.25*log(.25)-.75*log(.75)

d &lt;- data.frame(cat = c("A", "B"), n = c(50, 50))
# use base 2 for the logarithm, then entropy is maximized at 1
entropy(d, "cat", weight = "n", base = 2) # =&gt; 1
</code></pre>

<hr>
<h2 id='exposure'>Calculates pairwise exposure indices</h2><span id='topic+exposure'></span>

<h3>Description</h3>

<p>Returns the pairwise exposure indices between groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exposure(data, group, unit, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exposure_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="exposure_+3A_group">group</code></td>
<td>
<p>A categorical variable
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="exposure_+3A_unit">unit</code></td>
<td>
<p>A vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="exposure_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table with columns &quot;of&quot;, &quot;to&quot;, and
&quot;exposure&quot;. Read results as &quot;exposure of group x to group y&quot;.
</p>

<hr>
<h2 id='get_crosswalk'>Create crosswalk after compression</h2><span id='topic+get_crosswalk'></span>

<h3>Description</h3>

<p>After running <a href="#topic+compress">compress</a>, this function creates a crosswalk table.
Usually it is preferred to call <a href="#topic+merge_units">merge_units</a> directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_crosswalk(compression, n_units = NULL, percent = NULL, parts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_crosswalk_+3A_compression">compression</code></td>
<td>
<p>A &quot;segcompression&quot; object returned by <a href="#topic+compress">compress</a>.</p>
</td></tr>
<tr><td><code id="get_crosswalk_+3A_n_units">n_units</code></td>
<td>
<p>Determines the number of merges by specifying the number of
units to remain in the compressed dataset.
Only <code>n_units</code> or <code>percent</code> must be given. (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="get_crosswalk_+3A_percent">percent</code></td>
<td>
<p>Determines the number of merges by specifying the percentage
of total segregation information retained in the compressed dataset.
Only <code>n_units</code> or <code>percent</code> must be given. (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="get_crosswalk_+3A_parts">parts</code></td>
<td>
<p>(default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 plot.
</p>
<p>Returns a data.table.
</p>

<hr>
<h2 id='ipf'>Adjustment of marginal distributions using iterative proportional fitting</h2><span id='topic+ipf'></span>

<h3>Description</h3>

<p>Adjusts the marginal distributions for <code>group</code> and <code>unit</code>
in <code>source</code> to the respective marginal distributions in <code>target</code>, using the iterative
proportional fitting algorithm (IPF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipf(
  source,
  target,
  group,
  unit,
  weight = NULL,
  max_iterations = 100,
  precision = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipf_+3A_source">source</code></td>
<td>
<p>A &quot;source&quot; data frame. The marginals of this
dataset are adjusted to the marginals of <code>target</code>.</p>
</td></tr>
<tr><td><code id="ipf_+3A_target">target</code></td>
<td>
<p>A &quot;target&quot; data frame. The function returns a dataset
where the marginal distributions of <code>group</code> and <code>unit</code> categories
are approximated by those of <code>target</code>.</p>
</td></tr>
<tr><td><code id="ipf_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>source</code> and <code>target</code>. Defines the first distribution
for adjustment.</p>
</td></tr>
<tr><td><code id="ipf_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>source</code> and <code>target</code>. Defines the second distribution
for adjustment.</p>
</td></tr>
<tr><td><code id="ipf_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="ipf_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations used for the IPF algorithm.</p>
</td></tr>
<tr><td><code id="ipf_+3A_precision">precision</code></td>
<td>
<p>Convergence criterion for the IPF algorithm. In every iteration,
the ratio of the source and target marginals are calculated for every category of
<code>group</code> and <code>unit</code>. The algorithm converges when all ratios are smaller
than <code>1 + precision</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works by scaling
the marginal distribution of <code>group</code> in the <code>source</code> data frame towards the
marginal distribution of <code>target</code>; then repeating this process for <code>unit</code>. The
algorithm then keeps alternating between <code>group</code> and <code>unit</code> until the marginals
of the adjusted data frame are within the allowed precision. This results in a dataset that
retains the association structure of <code>source</code> while approximating
the marginal distribution of <code>target</code>. If the number of <code>unit</code> and
<code>group</code> categories is different in <code>source</code> and <code>target</code>, the data frame returns
the combination of <code>unit</code> and <code>group</code> categories that occur in both datasets.
Zero values are replaced by a small, non-zero number (1e-4).
Note that the values returned sum to the observations of the source data frame, not the
target data frame. This is different from other IPF implementations, but ensures that the IPF
does not change the number of observations.
</p>


<h3>Value</h3>

<p>Returns a data frame that retains
the association structure of <code>source</code> while approximating
the marginal distributions for <code>group</code> and <code>unit</code> of <code>target</code>.
The dataset identifies each combination of <code>group</code> and <code>unit</code>,
and categories that only occur in either <code>source</code> or <code>target</code> are dropped.
The adjusted frequency of each combination is given by the column <code>n</code>,
while <code>n_target</code> and <code>n_source</code> contain the zero-adjusted frequencies
in the target and source dataset, respectively.
</p>


<h3>References</h3>

<p>W. E. Deming and F. F. Stephan. 1940.
&quot;On a Least Squares Adjustment of a Sampled Frequency Table
When the Expected Marginal Totals are Known&quot;.
Annals of Mathematical Statistics. 11 (4): 427–444.
</p>
<p>T. Karmel and M. Maclachlan. 1988.
&quot;Occupational Sex Segregation — Increasing or Decreasing?&quot; Economic Record 64: 187-195.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# adjusts the marginals of group and unit categories so that
# schools00 has similar marginals as schools05
adj &lt;- ipf(schools00, schools05, "race", "school", weight = "n")

# check that the new "race" marginals are similar to the target marginals
# (the same could be done for schools)
aggregate(adj$n, list(adj$race), sum)
aggregate(adj$n_target, list(adj$race), sum)

# note that the adjusted dataset contains fewer
# schools than either the source or the target dataset,
# because the marginals are only defined for the overlap
# of schools
length(unique(schools00$school))
length(unique(schools05$school))
length(unique(adj$school))

## End(Not run)
</code></pre>

<hr>
<h2 id='isolation'>Calculates isolation indices</h2><span id='topic+isolation'></span>

<h3>Description</h3>

<p>Returns isolation index of each group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolation(data, group, unit, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isolation_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="isolation_+3A_group">group</code></td>
<td>
<p>A categorical variable
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="isolation_+3A_unit">unit</code></td>
<td>
<p>A vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="isolation_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table with group column and isolation index.
</p>

<hr>
<h2 id='matrix_to_long'>Turns a contingency table into long format</h2><span id='topic+matrix_to_long'></span>

<h3>Description</h3>

<p>Returns a data.table in long form, such that it is suitable
for use in <a href="#topic+mutual_total">mutual_total</a>, etc. Colnames and rownames of
the matrix will be respected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_long(
  matrix,
  group = "group",
  unit = "unit",
  weight = "n",
  drop_zero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_long_+3A_matrix">matrix</code></td>
<td>
<p>A matrix, where the rows represent the units, and the
column represent the groups.</p>
</td></tr>
<tr><td><code id="matrix_to_long_+3A_group">group</code></td>
<td>
<p>Variable name for group. (Default <code>group</code>)</p>
</td></tr>
<tr><td><code id="matrix_to_long_+3A_unit">unit</code></td>
<td>
<p>Variable name for unit. (Default <code>unit</code>)</p>
</td></tr>
<tr><td><code id="matrix_to_long_+3A_weight">weight</code></td>
<td>
<p>Variable name for frequency weight. (Default <code>weight</code>)</p>
</td></tr>
<tr><td><code id="matrix_to_long_+3A_drop_zero">drop_zero</code></td>
<td>
<p>Drop unit-group combinations with zero weight. (Default <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(10, 20, 30, 30, 20, 10), nrow = 3)
colnames(m) &lt;- c("Black", "White")
long &lt;- matrix_to_long(m, group = "race", unit = "school")
mutual_total(long, "race", "school", weight = "n")
</code></pre>

<hr>
<h2 id='merge_units'>Creates a compressed dataset</h2><span id='topic+merge_units'></span>

<h3>Description</h3>

<p>After running <a href="#topic+compress">compress</a>, this function creates a dataset where
units are merged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_units(compression, n_units = NULL, percent = NULL, parts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_units_+3A_compression">compression</code></td>
<td>
<p>A &quot;segcompression&quot; object returned by <a href="#topic+compress">compress</a>.</p>
</td></tr>
<tr><td><code id="merge_units_+3A_n_units">n_units</code></td>
<td>
<p>Determines the number of merges by specifying the number of
units to remain in the compressed dataset.
Only <code>n_units</code> or <code>percent</code> must be given. (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="merge_units_+3A_percent">percent</code></td>
<td>
<p>Determines the number of merges by specifying the percentage
of total segregation information retained in the compressed dataset.
Only <code>n_units</code> or <code>percent</code> must be given. (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="merge_units_+3A_parts">parts</code></td>
<td>
<p>(default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table.
</p>

<hr>
<h2 id='mutual_difference'>Decomposes the difference between two M indices</h2><span id='topic+mutual_difference'></span>

<h3>Description</h3>

<p>Uses one of three methods to decompose the difference between two M indices:
(1) &quot;shapley&quot; / &quot;shapley_detailed&quot;: a method based on the Shapley decomposition
with a few advantages over the Karmel-Maclachlan method
(recommended and the default, Deutsch et al. 2006),
(2) &quot;km&quot;: the method based on Karmel-Maclachlan (1988),
(3) &quot;mrc&quot;: the method developed by Mora and Ruiz-Castillo (2009).
All methods have been extended to account for missing units/groups in either data input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual_difference(
  data1,
  data2,
  group,
  unit,
  weight = NULL,
  method = "shapley",
  se = FALSE,
  CI = 0.95,
  n_bootstrap = 100,
  base = exp(1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual_difference_+3A_data1">data1</code></td>
<td>
<p>A data frame with same structure as <code>data2</code>.</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_data2">data2</code></td>
<td>
<p>A data frame with same structure as <code>data1</code>.</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_method">method</code></td>
<td>
<p>Either &quot;shapley&quot; (the default), &quot;km&quot; (Karmel and Maclachlan method), or
&quot;mrc&quot; (Mora and Ruiz-Castillo method).</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_se">se</code></td>
<td>
<p>If <code>TRUE</code>, the segregation estimates are bootstrapped to provide
standard errors and to apply bias correction. The bias that is reported
has already been applied to the estimates (i.e. the reported estimates are &quot;debiased&quot;)
(Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_ci">CI</code></td>
<td>
<p>If <code>se = TRUE</code>, compute the confidence (CI*100)
in addition to the bootstrap standard error.
This is based on percentiles of the bootstrap distribution, and a valid interpretation
relies on a larger number of bootstrap iterations. (Default <code>0.95</code>)</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>Number of bootstrap iterations. (Default <code>100</code>)</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_base">base</code></td>
<td>
<p>Base of the logarithm that is used in the calculation.
Defaults to the natural logarithm.</p>
</td></tr>
<tr><td><code id="mutual_difference_+3A_...">...</code></td>
<td>
<p>Only used for additional arguments when
when <code>method</code> is set to <code>shapley</code> or <code>km</code>. See <a href="#topic+ipf">ipf</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Shapley method is an improvement over the Karmel-Maclachlan method (Deutsch et al. 2006).
It is based on several margins-adjusted data inputs
and yields symmetrical results (i.e. <code>data1</code> and <code>data2</code> can be switched).
When &quot;shapley_detailed&quot; is used, the structural component is further decomposed into
the contributions of individuals units.
</p>
<p>The Karmel-Maclachlan method (Karmel and Maclachlan 1988) adjusts
the margins of <code>data1</code> to be similar to the margins of <code>data2</code>. This process
is not symmetrical.
</p>
<p>The Shapley and Karmel-Maclachlan methods are based on iterative proportional fitting (IPF),
first introduced by Deming and Stephan (1940).
Depending on the size of the dataset, this may take a few seconds (see <a href="#topic+ipf">ipf</a> for details).
</p>
<p>The method developed by Mora and Ruiz-Castillo (2009) uses an algebraic approach to estimate the
size of the components. This will often yield substantively different results from the Shapley
and Karmel-Maclachlan methods. Note that this method is not symmetric in terms of what is
defined as <code>group</code> and <code>unit</code> categories, which may yield contradictory results.
</p>
<p>A problem arises when there are <code>group</code> and/or <code>unit</code> categories in <code>data1</code>
that are not present in <code>data2</code> (or vice versa).
All methods estimate the difference only
for categories that are present in both datasets, and report additionally
the change in M that is induced by these cases as
<code>additions</code> (present in <code>data2</code>, but not in <code>data1</code>) and
<code>removals</code> (present in <code>data1</code>, but not in <code>data2</code>).
</p>


<h3>Value</h3>

<p>Returns a data.table with columns <code>stat</code> and <code>est</code>. The data frame contains
the following rows defined by <code>stat</code>:
<code>M1</code> contains the M for <code>data1</code>.
<code>M2</code> contains the M for <code>data2</code>.
<code>diff</code> is the difference between <code>M2</code> and <code>M1</code>.
The sum of the five rows following <code>diff</code> equal <code>diff</code>.
</p>
<p><code>additions</code> contains the change in M induces by <code>unit</code> and <code>group</code> categories
present in <code>data2</code> but not <code>data1</code>, and <code>removals</code> the reverse.
</p>
<p>All methods return the following three terms:
<code>unit_marginal</code> is the contribution of unit composition differences.
<code>group_marginal</code> is the contribution of group composition differences.
<code>structural</code> is the contribution unexplained by the marginal changes, i.e. the structural
difference. Note that the interpretation of these terms depend on the exact method used.
</p>
<p>When using &quot;km&quot;, one additional row is returned:
<code>interaction</code> is the contribution of differences in the joint marginal distribution
of <code>unit</code> and <code>group</code>.
</p>
<p>When &quot;shapley_detailed&quot; is used, an additional column &quot;unit&quot; is returned, along with
six additional rows for each unit that is present in both <code>data1</code> and <code>data2</code>.
The five rows have the following meaning:
<code>p1</code> (<code>p2</code>) is the proportion of the unit in <code>data1</code> (<code>data2</code>)
once non-intersecting units/groups have been removed. The changes in local linkage are
given by <code>ls_diff1</code> and <code>ls_diff2</code>, and their average is given by
<code>ls_diff_mean</code>. The row named <code>total</code>
summarizes the contribution of
the unit towards structural change
using the formula <code>.5 * p1 * ls_diff1 + .5 * p2 * ls_diff2</code>.
The sum of all &quot;total&quot; components equals structural change.
</p>
<p>If <code>se</code> is set to <code>TRUE</code>, an additional column <code>se</code> contains
the associated bootstrapped standard errors, an additional column <code>CI</code> contains
the estimate confidence interval as a list column, an additional column <code>bias</code> contains
the estimated bias, and the column <code>est</code> contains the bias-corrected estimates.
</p>


<h3>References</h3>

<p>W. E. Deming, F. F. Stephan. 1940. &quot;On a Least Squares Adjustment of a Sampled Frequency Table
When the Expected Marginal Totals are Known.&quot;
The Annals of Mathematical Statistics 11(4): 427-444.
</p>
<p>T. Karmel and M. Maclachlan. 1988.
&quot;Occupational Sex Segregation — Increasing or Decreasing?&quot; Economic Record 64: 187-195.
</p>
<p>R. Mora and J. Ruiz-Castillo. 2009. &quot;The Invariance Properties of the
Mutual Information Index of Multigroup Segregation.&quot; Research on Economic Inequality 17: 33-53.
</p>
<p>J. Deutsch, Y. Flückiger, and J. Silber. 2009.
&quot;Analyzing Changes in Occupational Segregation: The Case of Switzerland (1970–2000).&quot;
Research on Economic Inequality 17: 171–202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# decompose the difference in school segregation between 2000 and 2005,
# using the Shapley method
mutual_difference(schools00, schools05,
    group = "race", unit = "school",
    weight = "n", method = "shapley", precision = .1
)
# =&gt; the structural component is close to zero, thus most change is in the marginals.
# This method gives identical results when we switch the unit and group definitions,
# and when we switch the data inputs.

# the Karmel-Maclachlan method is similar, but only adjust the data in the forward direction...
mutual_difference(schools00, schools05,
    group = "school", unit = "race",
    weight = "n", method = "km", precision = .1
)

# ...this means that the results won't be identical when we switch the data inputs
mutual_difference(schools05, schools00,
    group = "school", unit = "race",
    weight = "n", method = "km", precision = .1
)

# the MRC method indicates a much higher structural change...
mutual_difference(schools00, schools05,
    group = "race", unit = "school",
    weight = "n", method = "mrc"
)

# ...and is not symmetric
mutual_difference(schools00, schools05,
    group = "school", unit = "race",
    weight = "n", method = "mrc"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='mutual_expected'>Calculates expected values when true segregation is zero</h2><span id='topic+mutual_expected'></span>

<h3>Description</h3>

<p>When sample sizes are small, one group has a small proportion, or
when there are many units, segregation indices are typically upwardly
biased, even when true segregation is zero. This function simulates
tables with zero segregation, given the marginals of the dataset,
and calculates segregation. If the expected values are large,
the interpretation of index scores might have to be adjusted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual_expected(
  data,
  group,
  unit,
  weight = NULL,
  within = NULL,
  fixed_margins = TRUE,
  n_bootstrap = 100,
  base = exp(1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual_expected_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="mutual_expected_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_expected_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_expected_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mutual_expected_+3A_within">within</code></td>
<td>
<p>Apply algorithm within each group defined by this variable,
and report the weighted average. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mutual_expected_+3A_fixed_margins">fixed_margins</code></td>
<td>
<p>Should the margins be fixed or simulated? (Default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="mutual_expected_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>Number of bootstrap iterations. (Default <code>100</code>)</p>
</td></tr>
<tr><td><code id="mutual_expected_+3A_base">base</code></td>
<td>
<p>Base of the logarithm that is used in the calculation.
Defaults to the natural logarithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with two rows, corresponding to the expected values of
segregation when true segregation is zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# the schools00 dataset has a large sample size, so expected segregation is close to zero
mutual_expected(schools00, "race", "school", weight = "n")

# but we can build a smaller table, with 100 students distributed across
# 10 schools, where one racial group has 10% of the students
small &lt;- data.frame(
    school = c(1:10, 1:10),
    race = c(rep("r1", 10), rep("r2", 10)),
    n = c(rep(1, 10), rep(9, 10))
)
mutual_expected(small, "race", "school", weight = "n")
# with an increase in sample size (n=1000), the values improve
small$n &lt;- small$n * 10
mutual_expected(small, "race", "school", weight = "n")

## End(Not run)
</code></pre>

<hr>
<h2 id='mutual_local'>Calculates local segregation scores based on M</h2><span id='topic+mutual_local'></span>

<h3>Description</h3>

<p>Returns local segregation indices for each category defined
by <code>unit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual_local(
  data,
  group,
  unit,
  weight = NULL,
  se = FALSE,
  CI = 0.95,
  n_bootstrap = 100,
  base = exp(1),
  wide = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual_local_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="mutual_local_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_local_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the group for which local
segregation indices are calculated.</p>
</td></tr>
<tr><td><code id="mutual_local_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mutual_local_+3A_se">se</code></td>
<td>
<p>If <code>TRUE</code>, the segregation estimates are bootstrapped to provide
standard errors and to apply bias correction. The bias that is reported
has already been applied to the estimates (i.e. the reported estimates are &quot;debiased&quot;)
(Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mutual_local_+3A_ci">CI</code></td>
<td>
<p>If <code>se = TRUE</code>, compute the confidence (CI*100)
in addition to the bootstrap standard error.
This is based on percentiles of the bootstrap distribution, and a valid interpretation
relies on a larger number of bootstrap iterations. (Default <code>0.95</code>)</p>
</td></tr>
<tr><td><code id="mutual_local_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>Number of bootstrap iterations. (Default <code>100</code>)</p>
</td></tr>
<tr><td><code id="mutual_local_+3A_base">base</code></td>
<td>
<p>Base of the logarithm that is used in the calculation.
Defaults to the natural logarithm.</p>
</td></tr>
<tr><td><code id="mutual_local_+3A_wide">wide</code></td>
<td>
<p>Returns a wide dataframe instead of a long dataframe.
(Default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table with two rows for each category defined by <code>unit</code>,
for a total of <code>2*(number of units)</code> rows.
The column <code>est</code> contains two statistics that
are provided for each unit: <code>ls</code>, the local segregation score, and
<code>p</code>, the proportion of the unit from the total number of cases.
If <code>se</code> is set to <code>TRUE</code>, an additional column <code>se</code> contains
the associated bootstrapped standard errors, an additional column <code>CI</code> contains
the estimate confidence interval as a list column, an additional column <code>bias</code> contains
the estimated bias, and the column <code>est</code> contains the bias-corrected estimates.
If <code>wide</code> is set to <code>TRUE</code>, returns instead a wide dataframe, with one
row for each <code>unit</code>, and the associated statistics in separate columns.
</p>


<h3>References</h3>

<p>Henri Theil. 1971. Principles of Econometrics. New York: Wiley.
</p>
<p>Ricardo Mora and Javier Ruiz-Castillo. 2011.
&quot;Entropy-based Segregation Indices&quot;. Sociological Methodology 41(1): 159–194.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># which schools are most segregated?
(localseg &lt;- mutual_local(schools00, "race", "school",
    weight = "n", wide = TRUE
))

sum(localseg$p) # =&gt; 1

# the sum of the weighted local segregation scores equals
# total segregation
sum(localseg$ls * localseg$p) # =&gt; .425
mutual_total(schools00, "school", "race", weight = "n") # M =&gt; .425
</code></pre>

<hr>
<h2 id='mutual_total'>Calculates the Mutual Information Index M and Theil's Entropy Index H</h2><span id='topic+mutual_total'></span>

<h3>Description</h3>

<p>Returns the total segregation between <code>group</code> and <code>unit</code>.
If <code>within</code> is given, calculates segregation within each
<code>within</code> category separately, and takes the weighted average.
Also see <code><a href="#topic+mutual_within">mutual_within</a></code> for detailed within calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual_total(
  data,
  group,
  unit,
  within = NULL,
  weight = NULL,
  se = FALSE,
  CI = 0.95,
  n_bootstrap = 100,
  base = exp(1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual_total_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="mutual_total_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_total_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_total_+3A_within">within</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. The variable(s) should be a superset of either
the <code>unit</code> or the <code>group</code> for the calculation to be meaningful.
If provided, segregation is
computed within the groups defined by the variable, and then averaged.
(Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mutual_total_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mutual_total_+3A_se">se</code></td>
<td>
<p>If <code>TRUE</code>, the segregation estimates are bootstrapped to provide
standard errors and to apply bias correction. The bias that is reported
has already been applied to the estimates (i.e. the reported estimates are &quot;debiased&quot;)
(Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mutual_total_+3A_ci">CI</code></td>
<td>
<p>If <code>se = TRUE</code>, compute the confidence (CI*100)
in addition to the bootstrap standard error.
This is based on percentiles of the bootstrap distribution, and a valid interpretation
relies on a larger number of bootstrap iterations. (Default <code>0.95</code>)</p>
</td></tr>
<tr><td><code id="mutual_total_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>Number of bootstrap iterations. (Default <code>100</code>)</p>
</td></tr>
<tr><td><code id="mutual_total_+3A_base">base</code></td>
<td>
<p>Base of the logarithm that is used in the calculation.
Defaults to the natural logarithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table with two rows. The column <code>est</code> contains
the Mutual Information Index, M, and Theil's Entropy Index, H. The H is the
the M divided by the <code>group</code> entropy. If <code>within</code> was given,
M and H are weighted averages of the within-category segregation scores.
If <code>se</code> is set to <code>TRUE</code>, an additional column <code>se</code> contains
the associated bootstrapped standard errors, an additional column <code>CI</code> contains
the estimate confidence interval as a list column, an additional column <code>bias</code> contains
the estimated bias, and the column <code>est</code> contains the bias-corrected estimates.
</p>


<h3>References</h3>

<p>Henri Theil. 1971. Principles of Econometrics. New York: Wiley.
</p>
<p>Ricardo Mora and Javier Ruiz-Castillo. 2011.
&quot;Entropy-based Segregation Indices&quot;. Sociological Methodology 41(1): 159–194.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate school racial segregation
mutual_total(schools00, "school", "race", weight = "n") # M =&gt; .425

# note that the definition of groups and units is arbitrary
mutual_total(schools00, "race", "school", weight = "n") # M =&gt; .425

# if groups or units are defined by a combination of variables,
# vectors of variable names can be provided -
# here there is no difference, because schools
# are nested within districts
mutual_total(schools00, "race", c("district", "school"),
    weight = "n"
) # M =&gt; .424

# estimate standard errors and 95% CI for M and H
## Not run: 
mutual_total(schools00, "race", "school",
    weight = "n",
    se = TRUE, n_bootstrap = 1000
)

# estimate segregation within school districts
mutual_total(schools00, "race", "school",
    within = "district", weight = "n"
) # M =&gt; .087

# estimate between-district racial segregation
mutual_total(schools00, "race", "district", weight = "n") # M =&gt; .338
# note that the sum of within-district and between-district
# segregation equals total school-race segregation;
# here, most segregation is between school districts

## End(Not run)
</code></pre>

<hr>
<h2 id='mutual_total_nested'>Calculates a nested decomposition of segregation for M and H</h2><span id='topic+mutual_total_nested'></span>

<h3>Description</h3>

<p>Returns the between-within decomposition defined by
the sequence of variables in <code>unit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual_total_nested(data, group, unit, weight = NULL, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual_total_nested_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="mutual_total_nested_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_total_nested_+3A_unit">unit</code></td>
<td>
<p>A vector of variables
contained in <code>data</code>. Defines the levels at which
the decomposition should be computed.</p>
</td></tr>
<tr><td><code id="mutual_total_nested_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mutual_total_nested_+3A_base">base</code></td>
<td>
<p>Base of the logarithm that is used in the calculation.
Defaults to the natural logarithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table similar to <code><a href="#topic+mutual_total">mutual_total</a></code>,
but with column <code>between</code> and <code>within</code> that define
the levels of nesting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mutual_total_nested(schools00, "race", c("state", "district", "school"),
    weight = "n"
)
# This is a simpler way to run the following manually:
# mutual_total(schools00, "race", "state", weight = "n")
# mutual_total(schools00, "race", "district", within = "state", weight = "n")
# mutual_total(schools00, "race", "school", within = c("state", "district"), weight = "n")
</code></pre>

<hr>
<h2 id='mutual_within'>Calculates detailed within-category segregation scores for M and H</h2><span id='topic+mutual_within'></span>

<h3>Description</h3>

<p>Calculates the segregation between <code>group</code> and <code>unit</code>
within each category defined by <code>within</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual_within(
  data,
  group,
  unit,
  within,
  weight = NULL,
  se = FALSE,
  CI = 0.95,
  n_bootstrap = 100,
  base = exp(1),
  wide = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual_within_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_within">within</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code> that defines the within-segregation categories.</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_se">se</code></td>
<td>
<p>If <code>TRUE</code>, the segregation estimates are bootstrapped to provide
standard errors and to apply bias correction. The bias that is reported
has already been applied to the estimates (i.e. the reported estimates are &quot;debiased&quot;)
(Default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_ci">CI</code></td>
<td>
<p>If <code>se = TRUE</code>, compute the confidence (CI*100)
in addition to the bootstrap standard error.
This is based on percentiles of the bootstrap distribution, and a valid interpretation
relies on a larger number of bootstrap iterations. (Default <code>0.95</code>)</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>Number of bootstrap iterations. (Default <code>100</code>)</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_base">base</code></td>
<td>
<p>Base of the logarithm that is used in the calculation.
Defaults to the natural logarithm.</p>
</td></tr>
<tr><td><code id="mutual_within_+3A_wide">wide</code></td>
<td>
<p>Returns a wide dataframe instead of a long dataframe.
(Default <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table with four rows for each category defined by <code>within</code>.
The column <code>est</code> contains four statistics that
are provided for each unit:
<code>M</code> is the within-category M, and <code>p</code> is the proportion of the category.
Multiplying <code>M</code> and <code>p</code> gives the contribution of each within-category
towards the total M.
<code>H</code> is the within-category H, and <code>ent_ratio</code> provides the entropy ratio,
defined as <code>EW/E</code>, where <code>EW</code> is the within-category entropy,
and <code>E</code> is the overall entropy.
Multiplying <code>H</code>, <code>p</code>, and <code>ent_ratio</code> gives the contribution of each within-category
towards the total H.
If <code>se</code> is set to <code>TRUE</code>, an additional column <code>se</code> contains
the associated bootstrapped standard errors, an additional column <code>CI</code> contains
the estimate confidence interval as a list column, an additional column <code>bias</code> contains
the estimated bias, and the column <code>est</code> contains the bias-corrected estimates.
If <code>wide</code> is set to <code>TRUE</code>, returns instead a wide dataframe, with one
row for each <code>within</code> category, and the associated statistics in separate columns.
</p>


<h3>References</h3>

<p>Henri Theil. 1971. Principles of Econometrics. New York: Wiley.
</p>
<p>Ricardo Mora and Javier Ruiz-Castillo. 2011.
&quot;Entropy-based Segregation Indices&quot;. Sociological Methodology 41(1): 159–194.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(within &lt;- mutual_within(schools00, "race", "school",
    within = "state",
    weight = "n", wide = TRUE
))
# the M for state "A" is .409
# manual calculation
schools_A &lt;- schools00[schools00$state == "A", ]
mutual_total(schools_A, "race", "school", weight = "n") # M =&gt; .409

# to recover the within M and H from the output, multiply
# p * M and p * ent_ratio * H, respectively
sum(within$p * within$M) # =&gt; .326
sum(within$p * within$ent_ratio * within$H) # =&gt; .321
# compare with:
mutual_total(schools00, "race", "school", within = "state", weight = "n")

## End(Not run)
</code></pre>

<hr>
<h2 id='school_ses'>Student-level data including SES status</h2><span id='topic+school_ses'></span>

<h3>Description</h3>

<p>Fake dataset used for examples. This is an individual-level
dataset of students in schools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>school_ses
</code></pre>


<h3>Format</h3>

<p>A data frame with 5,153 rows and 3 variables:
</p>

<dl>
<dt>school_id</dt><dd><p>school ID</p>
</dd>
<dt>ethnic_group</dt><dd><p>one of A, B, or C</p>
</dd>
<dt>ses_quintile</dt><dd><p>SES of the student (1 = lowest, 5 = highest)</p>
</dd>
</dl>


<hr>
<h2 id='schools00'>Ethnic/racial composition of schools for 2000/2001</h2><span id='topic+schools00'></span>

<h3>Description</h3>

<p>Fake dataset used for examples. Loosely based on data provided by
the National Center for Education Statistics, Common Core of Data,
with information on U.S. primary schools in three U.S. states.
The original data can be downloaded at <a href="https://nces.ed.gov/ccd/">https://nces.ed.gov/ccd/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schools00
</code></pre>


<h3>Format</h3>

<p>A data frame with 8,142 rows and 5 variables:
</p>

<dl>
<dt>state</dt><dd><p>either A, B, or C</p>
</dd>
<dt>district</dt><dd><p>school agency/district ID</p>
</dd>
<dt>school</dt><dd><p>school ID</p>
</dd>
<dt>race</dt><dd><p>either native, asian, hispanic, black, or white</p>
</dd>
<dt>n</dt><dd><p>n of students by school and race</p>
</dd>
</dl>


<hr>
<h2 id='schools05'>Ethnic/racial composition of schools for 2005/2006</h2><span id='topic+schools05'></span>

<h3>Description</h3>

<p>Fake dataset used for examples. Loosely based on data provided by
the National Center for Education Statistics, Common Core of Data,
with information on U.S. primary schools in three U.S. states.
The original data can be downloaded at <a href="https://nces.ed.gov/ccd/">https://nces.ed.gov/ccd/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schools05
</code></pre>


<h3>Format</h3>

<p>A data frame with 8,013 rows and 5 variables:
</p>

<dl>
<dt>state</dt><dd><p>either A, B, or C</p>
</dd>
<dt>district</dt><dd><p>school agency/district ID</p>
</dd>
<dt>school</dt><dd><p>school ID</p>
</dd>
<dt>race</dt><dd><p>either native, asian, hispanic, black, or white</p>
</dd>
<dt>n</dt><dd><p>n of students by school and race</p>
</dd>
</dl>


<hr>
<h2 id='scree_plot'>Scree plot for segregation compression</h2><span id='topic+scree_plot'></span>

<h3>Description</h3>

<p>A plot that allows to visually see the effect of compression
on mutual information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scree_plot(compression, tail = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scree_plot_+3A_compression">compression</code></td>
<td>
<p>A &quot;segcompression&quot; object returned by <a href="#topic+compress">compress</a>.</p>
</td></tr>
<tr><td><code id="scree_plot_+3A_tail">tail</code></td>
<td>
<p>Return only the last <code>tail</code> units (default: <code>Inf</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 plot.
</p>

<hr>
<h2 id='segcurve'>A visual representation of two-group segregation</h2><span id='topic+segcurve'></span>

<h3>Description</h3>

<p>Produces one or several segregation curves, as defined in Duncan and Duncan (1955)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segcurve(data, group, unit, weight = NULL, segment = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segcurve_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="segcurve_+3A_group">group</code></td>
<td>
<p>A categorical variable contained in <code>data</code>.
Defines the first dimension over which segregation is computed.</p>
</td></tr>
<tr><td><code id="segcurve_+3A_unit">unit</code></td>
<td>
<p>A categorical variable contained in <code>data</code>.
Defines the second dimension over which segregation is computed.</p>
</td></tr>
<tr><td><code id="segcurve_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="segcurve_+3A_segment">segment</code></td>
<td>
<p>A categorical variable contained in <code>data</code>. (Default <code>NULL</code>)
If given, several segregation curves will be shown, one for each segment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object.
</p>

<hr>
<h2 id='segplot'>A visual representation of segregation</h2><span id='topic+segplot'></span>

<h3>Description</h3>

<p>Produces a segregation plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segplot(
  data,
  group,
  unit,
  weight,
  order = "segregation",
  secondary_plot = NULL,
  reference_distribution = NULL,
  bar_space = 0,
  hline = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segplot_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="segplot_+3A_group">group</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the first dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="segplot_+3A_unit">unit</code></td>
<td>
<p>A categorical variable or a vector of variables
contained in <code>data</code>. Defines the second dimension
over which segregation is computed.</p>
</td></tr>
<tr><td><code id="segplot_+3A_weight">weight</code></td>
<td>
<p>Numeric. (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="segplot_+3A_order">order</code></td>
<td>
<p>A character, either
&quot;segregation&quot;, &quot;entropy&quot;, &quot;majority&quot;, or &quot;majority_fixed&quot;.
Affects the ordering of the units.
The horizontal ordering of the groups can be changed
by using a factor variable for <code>group</code>.
The difference between &quot;majority&quot; and &quot;majority_fixed&quot; is that the former
will reorder the groups in such a way that the majority group actually comes first.
If you want to control the ordering yourself, use &quot;majority_fixed&quot; and specify
the <code>group</code> variable as a factor variable.</p>
</td></tr>
<tr><td><code id="segplot_+3A_secondary_plot">secondary_plot</code></td>
<td>
<p>If <code>NULL</code> (default), no secondary plot is drawn.
If &quot;segregation&quot;, a secondary plot is drawn that shows adjusted local segregation
scores for each unit. If &quot;cumulative&quot;, a secondary plot is drawn that shows
the cumulative contribution of each unit toward the total H (calculated as the
proportion of each unit times the adjusted local segregation of each unit)0.</p>
</td></tr>
<tr><td><code id="segplot_+3A_reference_distribution">reference_distribution</code></td>
<td>
<p>Specifies the reference distribution, given as
a two-column data frame, to be plotted on the right.
If order is <code>segregation</code>, then this reference distribution is
also used to compute the local segregation scores.</p>
</td></tr>
<tr><td><code id="segplot_+3A_bar_space">bar_space</code></td>
<td>
<p>Specifies space between single units.</p>
</td></tr>
<tr><td><code id="segplot_+3A_hline">hline</code></td>
<td>
<p>Default <code>NULL</code>. If a color is specified,
horizontal lines will be drawn where groups are separated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 or patchwork object.
</p>

<hr>
<h2 id='segregation'>segregation: Entropy-based segregation indices</h2><span id='topic+segregation'></span><span id='topic+segregation-package'></span>

<h3>Description</h3>

<p>Calculate and decompose entropy-based, multigroup segregation indices, with a focus
on the Mutual Information Index (M) and Theil's Information Index (H).
Provides tools to decompose the measures by groups and units, and by within
and between terms. Includes standard error estimation by bootstrapping.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Benjamin Elbers <a href="mailto:be2239@columbia.edu">be2239@columbia.edu</a> (<a href="https://orcid.org/0000-0001-5392-3448">ORCID</a>)
</p>


<h3>See Also</h3>

<p><a href="https://elbersb.com/segregation">https://elbersb.com/segregation</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
