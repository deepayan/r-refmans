<!DOCTYPE html><html><head><title>Help for package molaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {molaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARC'><p>Calculate several measures of Area Relative Curvature</p></a></li>
<li><a href='#ARC3d'><p>Plot Area Relative Curvature on Tooth Mesh</p></a></li>
<li><a href='#Check2D'><p>Plot 2D footprint and footprint triangle points to check for erros in 2D calculation</p></a></li>
<li><a href='#DNE'><p>Calculate Dirichlet normal energy of a surface</p></a></li>
<li><a href='#DNE3d'><p>Plot results of a DNE analysis of a surface</p></a></li>
<li><a href='#DNE3dDiscard'><p>Plot advanced results of a DNE surface analysis</p></a></li>
<li><a href='#DNEbar'><p>Plot advanced results of a DNE surface analysis</p></a></li>
<li><a href='#DNEDensities'><p>Plot advanced results of a DNE surface analysis</p></a></li>
<li><a href='#DNEpie'><p>Plot advanced results of a DNE surface analysis</p></a></li>
<li><a href='#Hills'><p>Hills surface mesh</p></a></li>
<li><a href='#molaR_Batch'><p>Run molaR analyses on a batch of specimens</p></a></li>
<li><a href='#molaR_Clean'><p>Clean up problem ply files</p></a></li>
<li><a href='#OPC'><p>Calculate orientation patch count of a surface</p></a></li>
<li><a href='#OPC3d'><p>Plot results of OPC analysis of a surface</p></a></li>
<li><a href='#OPCbinareas'><p>Visualize surface area distribution into separate OPC orientation bins.</p></a></li>
<li><a href='#OPCr'><p>Calculate average orientation patch count after several rotations</p></a></li>
<li><a href='#OPCr_Example1'><p>OPCr_Example1 - object created by OPCr function used as an example.</p></a></li>
<li><a href='#OPCr_Example2'><p>OPCr_Example2 - object created by OPCr function used as an example.</p></a></li>
<li><a href='#plyPlaneCut'><p>Cut a PLY Mesh Along a Specified Plane</p></a></li>
<li><a href='#RFI'><p>Calculate relief index for a surface</p></a></li>
<li><a href='#RFI3d'><p>Plot 3D and 2D areas of a mesh used to calculate relief index</p></a></li>
<li><a href='#Slope'><p>Function to calculate the average slope of a surface</p></a></li>
<li><a href='#Slope3d'><p>Plot results of a Slope analysis of a surface</p></a></li>
<li><a href='#Tooth'><p>Tooth a surface mesh of a tooth.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Dental Surface Complexity Measurement Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>5.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Surface topography calculations of Dirichlet's normal energy,
    relief index, surface slope, and orientation patch count for teeth using scans of
    enamel caps.
    Importantly, for the relief index and orientation patch count calculations to
    work, the scanned tooth files must be oriented with the occlusal plane parallel
    to the x and y axes, and perpendicular to the z axis. The files should also be
    simplified, and smoothed in some other software prior to uploading into R.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), alphahull, rgl, Rvcg, pracma</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, rglwidget</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-27 00:04:32 UTC; jamespampush</td>
</tr>
<tr>
<td>Author:</td>
<td>James D. Pampush [aut, cre, cph],
  Paul E. Morse [aut, cph],
  Alexander Q. Vining [aut, cph],
  Edward Fuselier [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James D. Pampush &lt;jdpampush@gmail.com&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-27 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARC'>Calculate several measures of Area Relative Curvature</h2><span id='topic+ARC'></span>

<h3>Description</h3>

<p>A function that calculates the average slope over a tooth
or some other 3D surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARC(plyFile, BoundaryDiscard = "Vertex", Range = c(0.01, 0.99))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARC_+3A_plyfile">plyFile</code></td>
<td>
<p>An object of classes 'mesh3d' and 'shape3d' with calculated normals</p>
</td></tr>
<tr><td><code id="ARC_+3A_boundarydiscard">BoundaryDiscard</code></td>
<td>
<p>String indicating how to handle the exclusion of
boundary faces. Default of Vertex excludes faces which have at least 1 vertex
on the boundary</p>
</td></tr>
<tr><td><code id="ARC_+3A_range">Range</code></td>
<td>
<p>A pair of values which set lower and upper outlier exclusions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires an object created by reading in a ply file.
</p>
<p>This function calculates Area Relative Curvature, as described by Guy et al. (2013)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arc_output &lt;- ARC(Tooth)
summary(arc_output)
</code></pre>

<hr>
<h2 id='ARC3d'>Plot Area Relative Curvature on Tooth Mesh</h2><span id='topic+ARC3d'></span>

<h3>Description</h3>

<p>a molaR surface plotting function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARC3d(
  ARC_object,
  main = "",
  cex.main = 2,
  cex = 1,
  colors = c("darkblue", "blue", "powderblue", "gray", "gray", "tan", "orange",
    "darkorange1"),
  fieldofview = 0,
  legend = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARC3d_+3A_arc_object">ARC_object</code></td>
<td>
<p>An object that stores the output of the <code>ARC()</code>
function</p>
</td></tr>
<tr><td><code id="ARC3d_+3A_main">main</code></td>
<td>
<p>string indicating plot title. Defaults to empty</p>
</td></tr>
<tr><td><code id="ARC3d_+3A_cex.main">cex.main</code></td>
<td>
<p>numeric value setting the relative size of the plot title,</p>
</td></tr>
<tr><td><code id="ARC3d_+3A_cex">cex</code></td>
<td>
<p>numeric value setting the relative size of the legend, default=1</p>
</td></tr>
<tr><td><code id="ARC3d_+3A_colors">colors</code></td>
<td>
<p>a concatenated string of colors for plotting different values of
positive and negative curvature.</p>
</td></tr>
<tr><td><code id="ARC3d_+3A_fieldofview">fieldofview</code></td>
<td>
<p>Passes an argument to <code>par3d()</code> changing the field of
view (in degrees) of the resulting 3D plot</p>
</td></tr>
<tr><td><code id="ARC3d_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether or not a legend
shold be displayed. Default=T</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a surface map of the discarded DNE faces.
DNE calculations typically discard the top 1 tenth of one percent of faces,
associated with extreme pockets and broken parts of surfaces. DNE
calculations also typically discard the boundary faces from the calculation,
either on the basis of 2 vertices on the boundary, or at least one vertext on
the boundary. concaveCol defaults to gray and therefore is turned off. When
an alternative color is provided, the function will identify the the areas of the
tooth that are concave vs convex.
</p>
<p>Details of the other function arguments can be found in the DNE3d() description
and identical terms are organized to function the same way.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ARC_output &lt;- ARC(Tooth)
ARC3d(ARC_output)
</code></pre>

<hr>
<h2 id='Check2D'>Plot 2D footprint and footprint triangle points to check for erros in 2D calculation</h2><span id='topic+Check2D'></span>

<h3>Description</h3>

<p>This function will plot the points used for the 2D footprint area
calculation. This is meant to be a visual checking mechanism to
ensure that there are no 'extra' triangles within the footprint erroneously
adding to the total 2D area of the footprint. If a user finds extra points
within the boundaries of the footprint, they should assume that the alpha
value used for the RFI calculation was too small, and they are getting
a 2D footprint calculation which was too large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Check2D(RFI_Output, FootColor = "red", TriPointsColor = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Check2D_+3A_rfi_output">RFI_Output</code></td>
<td>
<p>An object that stores the output of the RFI
function</p>
</td></tr>
<tr><td><code id="Check2D_+3A_footcolor">FootColor</code></td>
<td>
<p>changes color of the 2D surface footprint</p>
</td></tr>
<tr><td><code id="Check2D_+3A_tripointscolor">TriPointsColor</code></td>
<td>
<p>color for the points of the footprint triangles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will plot the points used for the 2D footprint area
calculation. This is meant to be a visual checking mechanism to
ensure that there are no 'extra' triangles within the footprint erroneously
adding to the total 2D area of the footprint. If a user finds extra points
within the boundaries of the footprint, they should assume that the alpha
value used for the RFI calculation was too small, and they are getting
a 2D footprint calculation which was too large.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RFI_output &lt;- RFI(Tooth, alpha=0.5)
Check2D(RFI_output)
</code></pre>

<hr>
<h2 id='DNE'>Calculate Dirichlet normal energy of a surface</h2><span id='topic+DNE'></span>

<h3>Description</h3>

<p>A function that calculates Dirichlet normal energy following the method of Bunn et
al. (2011) Comparing Dirichlet normal surface energy of tooth crowns, a new
technique of molar shape quantification for dietary inference, with previous methods
in isolation and in combination. Am J Phys Anthropol 145:247-261 doi: 10.1002
ajpa.21489
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNE(plyFile, outliers = 0.1, kappa = 0, BoundaryDiscard = "Vertex", oex = "c")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNE_+3A_plyfile">plyFile</code></td>
<td>
<p>An object of classes 'mesh3d' and 'shape3d' with calculated normals</p>
</td></tr>
<tr><td><code id="DNE_+3A_outliers">outliers</code></td>
<td>
<p>The percentile of Dirichlet energy density values to be excluded
defaults to top 0.1 percent</p>
</td></tr>
<tr><td><code id="DNE_+3A_kappa">kappa</code></td>
<td>
<p>An integer value of mean curvature to define concave vs convex faces</p>
</td></tr>
<tr><td><code id="DNE_+3A_boundarydiscard">BoundaryDiscard</code></td>
<td>
<p>String indicating how to handle the exclusion of
boundary faces. Default of Vertex excludes faces which have at least 1 vertex
on the boundary</p>
</td></tr>
<tr><td><code id="DNE_+3A_oex">oex</code></td>
<td>
<p>String indicating outlier exclusion principle. Defaults to 'c', which
combines all convex and concave faces and removes the percentage of outliers
defined by <code>outliers</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires an object created by reading in a ply file.
</p>
<p>Dirichlet normal energy is calculated on meshes that represent specimen surfaces and
have already been simplified and pre-smoothed in a 3D data editing program.
</p>
<p>In the default settings, the function seeks to discard boundary faces. This can be
changed by adjusting the <code>BoundaryDiscard</code> argument to 'None' which will not discard
any faces on the boundary. Further, there are two ways of excluding boundary faces.
Either if they have a leg on the boundary by setting <code>BoundaryDiscard='Leg'</code> or by
excluding any face which has a vertex on the boundary with <code>BoundaryDiscard='Vertex'</code>.
The function defaults to remove the top 0.1 percent of calculated energy densities as
outliers. Mesh orientation does not affect this calculation.
</p>
<p>Faces are labeled as concave or convex on the basis of the <code>kappa</code> value, which
defaults to 0. Each face is assigned a <code>kappa</code> value, which describes the the localized
degree of convergence or divergence among the three vertex normals on each face.
Faces with positive <code>kappa</code> values have vertex normals that are divergent. Faces with
negative <code>kappa</code> values possess vertex normals that are convergent. Users can adjust
the <code>kappa</code> value to redefine areas of the tooth assigned to the convex or concave bin.
</p>
<p>The mode of Outlier exclusion can be modified with the <code>oex</code> argument. The default,
<code>oex='c'</code> considers the Dirichlet energy density values of all faces on the surface and
removes those in the top percentile defined by <code>outliers</code>, regardless of the convexity
or concavity bins. The alternative, <code>oex='s'</code>, divides the surface into concave and
convex portions, then removes the percentile defined by <code>outliers</code> from each of
these subsets before calculating total surface DNE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DNE_output &lt;- DNE(Tooth)
summary(DNE_output)
</code></pre>

<hr>
<h2 id='DNE3d'>Plot results of a DNE analysis of a surface</h2><span id='topic+DNE3d'></span>

<h3>Description</h3>

<p>a molaR surface plotting function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNE3d(
  DNE_File,
  setMax = 0,
  logColors = TRUE,
  signColor = TRUE,
  main = "",
  cex = 1,
  cex.main = 2,
  legend = TRUE,
  leftOffset = 1,
  fieldofview = 0,
  fileName = NA,
  binary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNE3d_+3A_dne_file">DNE_File</code></td>
<td>
<p>An object that stores the output of the <code>DNE()</code>
function</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_setmax">setMax</code></td>
<td>
<p>User-defined upper range for plotting color scheme, see
Details</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_logcolors">logColors</code></td>
<td>
<p>Logical that log transforms the color scheme</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_signcolor">signColor</code></td>
<td>
<p>Logical indicating whether or not to plot by
concavity vs convexity. Plotting by curve orientation is the default.</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_main">main</code></td>
<td>
<p>String indicating plot title</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_cex">cex</code></td>
<td>
<p>Numeric setting the relative size of the legend</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_cex.main">cex.main</code></td>
<td>
<p>Numeric setting the size of the title</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether or not a legend should be displayed</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_leftoffset">leftOffset</code></td>
<td>
<p>Numeric between -1 and 1 setting the amount of offset for
the plotted surface to the left. Larger values push surface farther to right.</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_fieldofview">fieldofview</code></td>
<td>
<p>Passes an argument to <code>par3d()</code> changing the field of
view (in degrees) of the resulting 3D plot</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_filename">fileName</code></td>
<td>
<p>String indicating a name to save the plotted surface to as a
*.ply file; default of 'NA' will not save a file</p>
</td></tr>
<tr><td><code id="DNE3d_+3A_binary">binary</code></td>
<td>
<p>Logical indicating whether or not the saved surface plot should
be binary, passed to <code>vcgPlyWrite()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a heat map on the mesh surface
corresponding to the Dirichlet energy density of each face calculated by
the <code>DNE()</code> function. Hottest colors represent highest normal energy
values.
</p>
<p>Dirichlet energy densities for the faces of a mesh surface tend to be
positively skewed, with a small proportion of the faces contributing
most of the total energy for the surface. When <code>logColors</code> is enabled, the
function colorizes based on the log-transformed Dirichlet energy
densities, allowing for finer resolution between faces near the mode of
the energy per face distribution. Disabling <code>logColors</code> will display the
un-transformed Dirichlet energy densities.
</p>
<p>The legend will update to reflect the other arguments chosen by the
user. By default, the function sets the lowest Dirichlet energy density
calculated among all faces to a cool color and the absolute highest normal
energy calculated among all faces to a hot color, and then colors the remaining
faces on a continuous color spectrum between these two end points using
either absolute or log transformed Dirichlet energy density values
(depending on the status of <code>logColors</code>). Since the scale is relative to the
energies of the input surface, visual comparisons cannot directly be
made between multiple plots of different surfaces.
</p>
<p>The <code>setMax</code> argument allows users to define the maximum of the
plotting color scheme for use across multiple plots. This enables the
direct comparison of different surfaces to one another with red equal to
the user-defined maximum and a cool color equal to the minimum. The user
should choose a reasonable upper bound for the maximum. <code>setMax</code> will not
accept negative values. If there are faces with Dirichlet normal energy
values higher than the <code>setMax</code> value, these faces are marked with the
highest possible color.
</p>
<p>The logical <code>signColor</code> colors the surface with two separate gradients,
one for the convex and one for the concave faces (curvature sign). By
default, the plot now makes this distinction.
</p>
<p>A title can be added to the plot by supplying a character string to the <code>main</code>
argument. Title and legend size are controlled with the <code>cex</code> argument,
analogous to that in the default R graphics device.
</p>
<p>The <code>leftOffset</code> value sets how far to the left the surface will plot, intended
to help avoid overlap with the legend. Value of 0 will center the surface and
should be invoked if the <code>legend</code> argument is disabled. Higher values will push
the surface farther left and negative values will push it to the right. It is
recommended that these values be restricted between -1 and 1 to avoid plotting
the surface outside of the rgl window.
</p>
<p><code>fieldofview</code> is set to a default of 0, which is an isometric projection.
Increasing it alters the degree of parallax in the perspective view, up to
a maximum of 179 degrees (see <code><a href="rgl.html#topic+par3d">rgl::par3d()</a></code>).
</p>
<p>The plotted, colorized surface can be saved as a *.ply to the working directory
by changing the <code>fileName</code> argument from <code>NA</code> to a string (e.g., &quot;DNEPlot&quot;). The
resultant ply file can be opened and manipulated in other 3D visualizing programs,
such as <a href="https://www.meshlab.net/">MeshLab</a>, but will <strong>NOT</strong> retain its legend
(a background of the plotting window). To retain the legend, the user is
encouraged to utilize the function 'snapshot3d()' in the rgl package. (see <code><a href="rgl.html#topic+rgl.snapshot">rgl::rgl.snapshot()</a></code>)
The <code>binary</code> argument saves a file in ascii format by default, which is supported by
more 3D visualization software than is binary. However, binary files will be
considerably smaller.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DNE_output &lt;- DNE(Tooth)
DNE3d(DNE_output)
</code></pre>

<hr>
<h2 id='DNE3dDiscard'>Plot advanced results of a DNE surface analysis</h2><span id='topic+DNE3dDiscard'></span>

<h3>Description</h3>

<p>a molaR surface plotting function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNE3dDiscard(
  DNE_File,
  baseCol = "gray",
  boundCol = "red",
  outlierCol = "lawngreen",
  concaveCol = baseCol,
  main = "",
  cex = 1,
  cex.main = 2.5,
  legend = T,
  leftOffset = 1,
  fieldofview = 0,
  fileName = NA,
  binary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNE3dDiscard_+3A_dne_file">DNE_File</code></td>
<td>
<p>An object that stores the output of the <code>DNE()</code>
function</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_basecol">baseCol</code></td>
<td>
<p>Base color for typical face on surface. Default is gray</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_boundcol">boundCol</code></td>
<td>
<p>Color for the boundary faces discarded from
the DNE calculation. Default is red.</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_outliercol">outlierCol</code></td>
<td>
<p>Color for the faces discarded as outliers from
the DNE calculation. Default is lawngreen</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_concavecol">concaveCol</code></td>
<td>
<p>Color of the Concave faces on the surface.
When left in default concave faces remain undistinguished on
the plotted surface and are colored the same as baseCol.</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_main">main</code></td>
<td>
<p>string indicating plot title. Defaults to empty</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_cex">cex</code></td>
<td>
<p>numeric value setting the relative size of the legend, default=1</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_cex.main">cex.main</code></td>
<td>
<p>numeric value setting the relative size of the plot title,</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether or not a legend
shold be displayed. Default=T</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_leftoffset">leftOffset</code></td>
<td>
<p>numeric value between -1 and 1 setting the degree of
offset for the plotted surface to the left. Larger values set further to right.
Default=1</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_fieldofview">fieldofview</code></td>
<td>
<p>Passes an argument to <code>par3d()</code> changing the field of
view (in degrees) of the resulting 3D plot</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_filename">fileName</code></td>
<td>
<p>String indicating a name to save the plotted surface to as a
*.ply file; default of 'NA' will not save a file</p>
</td></tr>
<tr><td><code id="DNE3dDiscard_+3A_binary">binary</code></td>
<td>
<p>Logical indicating whether or not the saved surface plot should
be binary, passed to <code>vcgPlyWrite()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a surface map of the discarded DNE faces.
DNE calculations typically discard the top 1 tenth of one percent of faces,
associated with extreme pockets and broken parts of surfaces. DNE
calculations also typically discard the boundary faces from the calculation,
either on the basis of 2 vertices on the boundary, or at least one vertext on
the boundary. concaveCol defaults to gray and therefore is turned off. When
an alternative color is provided, the function will identify the the areas of the
tooth that are concave vs convex.
</p>
<p>Details of the other function arguments can be found in the DNE3d() description
and identical terms are organized to function the same way.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DNE_output &lt;- DNE(Tooth)
DNE3dDiscard(DNE_output)
</code></pre>

<hr>
<h2 id='DNEbar'>Plot advanced results of a DNE surface analysis</h2><span id='topic+DNEbar'></span>

<h3>Description</h3>

<p>a molaR plotting function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNEbar(
  DNE_File,
  main = "",
  convexCol = "hotpink",
  concaveCol = "deepskyblue",
  type = "both",
  legendPos = "topright",
  legendInset = 0,
  las = 1,
  names.arg = "",
  cex.names = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNEbar_+3A_dne_file">DNE_File</code></td>
<td>
<p>An object that stores the output of the DNE()
function</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_main">main</code></td>
<td>
<p>User's title for plot.</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_convexcol">convexCol</code></td>
<td>
<p>Color for the convex DNE total. Default='hotpink'</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_concavecol">concaveCol</code></td>
<td>
<p>Color for the concave DNE total. Default='deepskyblue'</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_type">type</code></td>
<td>
<p>string to determine what parameters to plot. Default=both and
both concave and convex DNE totals will be plotted in stacked bar plot. See details</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_legendpos">legendPos</code></td>
<td>
<p>string to determine location of the legend. Default='topright'
see details.</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_legendinset">legendInset</code></td>
<td>
<p>numeric value determining how far to inset the legend from plot
boarder. Default=0</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_las">las</code></td>
<td>
<p>logical indicating orientation of the x-axis labels for each bar plot. Enter either 1 or 2.</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_names.arg">names.arg</code></td>
<td>
<p>concatenated string of surface names for labels. If none supplied function will
pull names from the object itself.</p>
</td></tr>
<tr><td><code id="DNEbar_+3A_cex.names">cex.names</code></td>
<td>
<p>Font size for the bar labels. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a stacked barplot of DNE values. It colors them according
to curve orientation, which is defined by the <code>kappa</code> parameter in <code>DNE()</code> function. If multiple
DNE objects are grouped together the barplot will return a set. When employed on a single
DNE object this will return a single stacked bar.
</p>
<p>The argument <code>type</code> accepts either 'Concave' or 'Convex' to plot only concave or convex
DNE totals respectively. Default=NA and results in both totals being plotted in stacked barplot.
</p>
<p>The argument <code>legendPos</code> is a string that determines the position of the legend. Default='topright'
but will accept any of the following keywords: 'bottomright', 'bottom', 'bottomleft', 'left', 'topleft', 'top',
'topright', 'right', or 'center'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DNEs &lt;- list()
DNEs$Tooth &lt;- DNE(Tooth)
DNEs$Hills &lt;- DNE(Hills)
DNEbar(DNEs)
</code></pre>

<hr>
<h2 id='DNEDensities'>Plot advanced results of a DNE surface analysis</h2><span id='topic+DNEDensities'></span>

<h3>Description</h3>

<p>Plot advanced results of a DNE surface analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNEDensities(
  DNE_File,
  main = "",
  type = "DNE",
  legendPos = "topright",
  convexCol = "hotpink",
  concaveCol = "deepskyblue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNEDensities_+3A_dne_file">DNE_File</code></td>
<td>
<p>An object that stores the output of the DNE
function</p>
</td></tr>
<tr><td><code id="DNEDensities_+3A_main">main</code></td>
<td>
<p>User's title for plot. Default is blank</p>
</td></tr>
<tr><td><code id="DNEDensities_+3A_type">type</code></td>
<td>
<p>string determining which density plots to make. Default</p>
</td></tr>
<tr><td><code id="DNEDensities_+3A_legendpos">legendPos</code></td>
<td>
<p>string to determine location of the legend. Default='topright'
see details.
is to plot DNE face densities. Alternatively can plot face areas with 'area'</p>
</td></tr>
<tr><td><code id="DNEDensities_+3A_convexcol">convexCol</code></td>
<td>
<p>Color for the convex density polygon, Default='hotpink'</p>
</td></tr>
<tr><td><code id="DNEDensities_+3A_concavecol">concaveCol</code></td>
<td>
<p>Color for the concave density polygon, Default='deepskyblue'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a set of overlapping density plots of two potential types.
The user can plot overlapping density plots that sort the surface into concave and convex
portions for plotting. The function will default to plotting DNE density values, however
density of face surface areas sorted into concave and convex portions of the surface
can be plotted by calling <code>type='area'</code>. Colors can be customized by altering the
<code>convexCol</code> and <code>concaveCol</code> arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DNE_output &lt;- DNE(Tooth)
DNEDensities(DNE_output)
</code></pre>

<hr>
<h2 id='DNEpie'>Plot advanced results of a DNE surface analysis</h2><span id='topic+DNEpie'></span>

<h3>Description</h3>

<p>Plot advanced results of a DNE surface analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNEpie(
  DNE_File,
  main = "",
  type = "area",
  convexCol = "hotpink",
  concaveCol = "deepskyblue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNEpie_+3A_dne_file">DNE_File</code></td>
<td>
<p>An object that stores the output of the <code>DNE()</code>
function</p>
</td></tr>
<tr><td><code id="DNEpie_+3A_main">main</code></td>
<td>
<p>User's title for the plot</p>
</td></tr>
<tr><td><code id="DNEpie_+3A_type">type</code></td>
<td>
<p>string determine which parameters to plot. Default='DNE'
also accepts 'area' to plot pie charts of the area.</p>
</td></tr>
<tr><td><code id="DNEpie_+3A_convexcol">convexCol</code></td>
<td>
<p>Color for the portion of the pie chart representing convex
contribution. Default='hotpink'. Accepts any color keyword.</p>
</td></tr>
<tr><td><code id="DNEpie_+3A_concavecol">concaveCol</code></td>
<td>
<p>Color for the portion of the pie chart representing concave
contribution. Default='deepskyblue'. Accepts any color keyword.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a pie chart of the total area or DNE of the surface
originating from the concave or convex portions of the surface. The function
defaults to plotting surface area, however, relative proportion of total DNE from the
concave and convex portions of the surface can be plotted by calling <code>type='DNE'</code>.
Colors can be customized by altering the <code>convexCol</code> and <code>concaveCol</code> arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DNE_output &lt;- DNE(Tooth)
DNEpie(DNE_output)
</code></pre>

<hr>
<h2 id='Hills'>Hills surface mesh</h2><span id='topic+Hills'></span><span id='topic+Hills.mesh'></span>

<h3>Description</h3>

<p>Sample mesh created with the formula: 'z=3cos(x/2)+3sin(y/2)
</p>
<p>A triangular mesh representing a sine-cosine plane - called by data(Hills)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Hills)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"mesh3d"</code>
</p>
<p><code>Hills</code>: triangular mesh representing a sine-cosine plane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hills)
DNE_Output &lt;- DNE(Hills)
DNE3d(DNE_Output)
</code></pre>

<hr>
<h2 id='molaR_Batch'>Run molaR analyses on a batch of specimens</h2><span id='topic+molaR_Batch'></span>

<h3>Description</h3>

<p>A function that automates molaR analyses on multiple specimens. Several
different analyses can be performed on each surface, with specifications for
analysis parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>molaR_Batch(
  pathName = getwd(),
  fileName = "molaR_Batch.csv",
  DNE = TRUE,
  RFI = TRUE,
  OPCr = TRUE,
  OPC = FALSE,
  Slope = TRUE,
  details = TRUE,
  parameters = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="molaR_Batch_+3A_pathname">pathName</code></td>
<td>
<p>The path to the folder containing all ply surfaces to be
analyzed. Defaults to the working directory.</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_filename">fileName</code></td>
<td>
<p>Name for the output .csv file containing results and parameters</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_dne">DNE</code></td>
<td>
<p>Logical indicating whether or not to perform the DNE calculation</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_rfi">RFI</code></td>
<td>
<p>Logical indicating whether or not to perform the RFI calculation</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_opcr">OPCr</code></td>
<td>
<p>Logical indicating whether or not to perform the OPCr calculation</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_opc">OPC</code></td>
<td>
<p>Logical indicating whether or not to perform the OPC calculation</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_slope">Slope</code></td>
<td>
<p>Logical indicating whether or not to perform the Slope calculation</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_details">details</code></td>
<td>
<p>Logical indicating whether or not to save additional output from
some of the topographic analyses</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_parameters">parameters</code></td>
<td>
<p>Logical indicating whether or not to save the list of analysis
parameters used in the batch run</p>
</td></tr>
<tr><td><code id="molaR_Batch_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the topographic analysis functions.
See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows a user to set the analyses from molaR they want
to run on a batch of ply files. Output is saved to a csv file. By default, the
batch function will perform specified analyses on all ply files in the working
directory. A different folder can be specified with <code>pathName</code>. Output saves
as .csv to the folder that contains the analyzed ply files.
</p>
<p>Any of the default arguments of the various topographic analysis functions can
be modified for the batch by specifying them when calling <code>molaR_Batch</code>, e.g.,
the DNE <code>kappa</code> value can be changed to 'X' by specifying <code>kappa = X</code>. Users
are <strong>strongly</strong> encouraged to review the documentation for <code><a href="#topic+DNE">DNE()</a></code>,
<code><a href="#topic+RFI">RFI()</a></code>, <code><a href="#topic+OPCr">OPCr()</a></code>, <code><a href="#topic+OPC">OPC()</a></code>,
and <code><a href="#topic+Slope">Slope()</a></code> and to understand the effects of alterations before making
changes. A recommended practice for analyzing RFI in a batch of specimens is to enable
<code>findAlpha = TRUE</code> given that the ideal <code>alpha</code> value is likely to vary among different
specimens. However, this will increase calculation time (see documentation for
<code><a href="#topic+RFI">RFI</a></code>).
</p>
<p>By default, the batch output will retain some additional details of the analysis.
These include, in the case of DNE: convex and concave DNE values, convex and
concave surface areas; in the case of RFI: 3D and 2D surface areas and analysis
<code>alpha</code> values; in the case of OPCr: the surface OPC value calculated at each
rotation; and in the case of OPC: the patch count for each bin. These results
will be discarded and only the final result of each topographic analysis will
be retained if <code>details = FALSE</code>.
</p>
<p>The function will save a list of all parameters used in all batch analyses
to the output .csv file, below the results. This can be suppressed with
<code>parameters = FALSE</code>, but is recommended as a check on how analyses were
performed when returning to results in the future. If the function is assigned
to an object in R, the parameters are not included in the resultant data.frame,
but will still be included in the .csv file by default.
</p>
<p>Note that batch processing updates will not display by default if using RGui
for Windows. Disable Misc -&gt; Buffered output (Ctrl+W) if you wish to view
batch processing progress in RGui for Windows.
</p>

<hr>
<h2 id='molaR_Clean'>Clean up problem ply files</h2><span id='topic+molaR_Clean'></span>

<h3>Description</h3>

<p>Function will remove floating verticies, and faces with zero
area. These can cause issues when using molaR's primary
functions of DNE, RFI, and OPC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>molaR_Clean(plyFile, cleanType = "Both", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="molaR_Clean_+3A_plyfile">plyFile</code></td>
<td>
<p>An object of classes 'mesh3d' and 'shape3d'</p>
</td></tr>
<tr><td><code id="molaR_Clean_+3A_cleantype">cleanType</code></td>
<td>
<p>String with three arguments defining what to clean: Vertices,
Faces, or Both. Defaults to Both.</p>
</td></tr>
<tr><td><code id="molaR_Clean_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if the function should report changes to ply</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function cleans up problematic ply files. Some
smoothed files will have faces of zero area, or floating
vertices. DNE and OPC cannot be calculated on these files.
Running the plys through this function will allow those
calculations to be made.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Tooth &lt;- molaR_Clean(Tooth)
</code></pre>

<hr>
<h2 id='OPC'>Calculate orientation patch count of a surface</h2><span id='topic+OPC'></span>

<h3>Description</h3>

<p>A function that bins patches of a mesh surface that share general orientation and
sums the number of unique patches given certain parameters Modified into
3D from the original 2.5D method described by Evans et al. (2007) High-level
similarity of dentitions in carnivorans and rodents. Nature 445:78-81 doi:
<a href="https://www.nature.com/articles/nature05433">10.1038/nature05433</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OPC(plyFile, rotation = 0, minimum_faces = 3, minimum_area = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OPC_+3A_plyfile">plyFile</code></td>
<td>
<p>An object of classes &quot;mesh3d&quot; and &quot;shape3d&quot; with
calculated vertex normals</p>
</td></tr>
<tr><td><code id="OPC_+3A_rotation">rotation</code></td>
<td>
<p>Rotates the file in degrees about the center vertical
axis</p>
</td></tr>
<tr><td><code id="OPC_+3A_minimum_faces">minimum_faces</code></td>
<td>
<p>Minimum number of ply faces required
for a patch to be counted towards the total patch count</p>
</td></tr>
<tr><td><code id="OPC_+3A_minimum_area">minimum_area</code></td>
<td>
<p>Minimum proportion (100%=1.0) of total surface area a
patch must occupy to be counted towards the total patch count</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires a mesh object created by reading in a ply file utilizing
either the, <code><a href="Rvcg.html#topic+vcgPlyRead">vcgPlyRead</a></code> function.
</p>
<p>Orientation patch count is calculated on meshes that represent specimen surfaces
and have already been downsampled to 10,000 faces and pre-smoothed in a 3D
data editing program. Alignment of the surface will have a large effect on patch
orientation and must be performed in a 3D data editing program such as Avizo. The
occlusal surface of the specimen must be made parallel to the X- and Y-axes and
perpendicular to the Z-axis.
</p>
<p>The default for minimum_faces is to ignore patches consisting of two or fewer faces
on the mesh. Changing the minimum_area value will disable minimum_faces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OPC_output &lt;- OPC(Tooth)
summary(OPC_output)
</code></pre>

<hr>
<h2 id='OPC3d'>Plot results of OPC analysis of a surface</h2><span id='topic+OPC3d'></span>

<h3>Description</h3>

<p>A function that produces a three-dimensional rendering of face
orientation on a surface. The <code>OPC</code> function will identify the
orientations of mesh faces and assign them to patches. It must be
performed prior to using the OPC3d function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OPC3d(
  OPC_File,
  binColors = hsv(h = (seq(10, 290, 40)/360), s = 0.9, v = 0.85),
  patchOutline = FALSE,
  outlineColor = "black",
  maskDiscard = FALSE,
  legend = TRUE,
  main = "",
  cex = 1,
  scaleLegend = FALSE,
  legendTextCol = "black",
  legendLineCol = "black",
  leftOffset = 1,
  fieldofview = 0,
  fileName = NA,
  binary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OPC3d_+3A_opc_file">OPC_File</code></td>
<td>
<p>An object that stores the output of the <code>OPC()</code> function</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_bincolors">binColors</code></td>
<td>
<p>Allows the user to define the fill colors for
each directional bin</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_patchoutline">patchOutline</code></td>
<td>
<p>Logical whether or not to outline the patches</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_outlinecolor">outlineColor</code></td>
<td>
<p>Parameter defining the patch outline color</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_maskdiscard">maskDiscard</code></td>
<td>
<p>Logical indicating whether or not to mask (in black) the
patches excluded from the OPC value</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether or not a legend should
be displayed</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_main">main</code></td>
<td>
<p>String indicating plot title</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_cex">cex</code></td>
<td>
<p>Numeric setting the relative size of the legend and title</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_scalelegend">scaleLegend</code></td>
<td>
<p>Logical indicating if legend bins should scale to patch counts</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_legendtextcol">legendTextCol</code></td>
<td>
<p>Parameter defining color for the legend text</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_legendlinecol">legendLineCol</code></td>
<td>
<p>Parameter defining the color for the legend lines</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_leftoffset">leftOffset</code></td>
<td>
<p>Numeric between -1 and 1 setting the amount of offset for
the plotted surface to the left. Larger values push surface farther to right.</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_fieldofview">fieldofview</code></td>
<td>
<p>Passes an argument to <code>par3d()</code> changing the field of
view in degrees of the resulting surface plot</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_filename">fileName</code></td>
<td>
<p>String indicating a name to save the plotted surface to as a
*.ply file; default of 'NA' will not save a file</p>
</td></tr>
<tr><td><code id="OPC3d_+3A_binary">binary</code></td>
<td>
<p>Logical indicating whether or not the saved surface plot should
be binary, passed to <code>vcgPlyWrite()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will assign a uniform color to all faces on the mesh
surface that share one of the orientation bins identified by the OPC function. The
function returns a colored mesh so that patches can be visually inspected.
</p>
<p><code>binColors</code> will support any vector of colors, in any coloration scheme. Default
draws from the HSV color space to evenly space color information, however the user
can supply a list of RGB values or character strings in place. If there are fewer
colors than directional bins, remaining bins will default to white.
</p>
<p>A title can be added to the plot by supplying a character string to the <code>main</code>
argument. Title and legend size are controlled with the <code>cex</code> argument,
analogous to that in the default R graphics device.
</p>
<p>Several legend plotting options are available. The default legend shape is a
circular pie with sectors indicating the orientation of directional bins, shaded
according to the color scheme in <code>binColors</code>. By setting <code>scaleLegend = TRUE</code>,
the legend sectors will scale proportionally to the number of patches in each
directional bin. The legend text and line colors can be customized with
<code>legendTextCol</code> and <code>legendLineCol</code>, which both default to black.
</p>
<p>The <code>leftOffset</code> value sets how far to the left the surface will plot, intended
to help avoid overlap with the legend. Value of 0 will center the surface and
should be invoked if the <code>legend</code> argument is disabled. Higher values will push
the surface farther left and negative values will push it to the right. It is
recommended that these values be restricted between -1 and 1 to avoid plotting
the surface outside of the rgl window.
</p>
<p><code>fieldofview</code> is set to a default of 0, which is an isometric projection.
Increasing it alters the degree of parallax in the perspective view, up to
a maximum of 179 degrees (see <code><a href="rgl.html#topic+par3d">rgl::par3d()</a></code>).
</p>
<p>The plotted, colorized surface can be saved as a *.ply to the working directory
by changing the <code>fileName</code> argument from <code>NA</code> to a string (e.g., &quot;OPCPlot&quot;). The
resultant ply file can be opened and manipulated in other 3D visualizing programs,
such as <a href="https://www.meshlab.net/">MeshLab</a>, but will <strong>NOT</strong> retain its legend
(a background of the plotting window). To retain the legend, the user is
encouraged to utilize the <code><a href="rgl.html#topic+snapshot3d">rgl::snapshot3d()</a></code> function.
The <code>binary</code> argument saves a file in ascii format by default, which is supported by
more 3D visualization software than is binary. However, binary files will be
considerably smaller.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OPC_output &lt;- OPC(Tooth)
OPC3d(OPC_output)
</code></pre>

<hr>
<h2 id='OPCbinareas'>Visualize surface area distribution into separate OPC orientation bins.</h2><span id='topic+OPCbinareas'></span>

<h3>Description</h3>

<p>This function will make either a bar plot or pie
chart showing the surface area assigned to each
OPC orientation bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OPCbinareas(
  OPC_File,
  main = "",
  binColors = hsv(h = (seq(10, 290, 40)/360), s = 0.9, v = 0.85),
  type = "bar"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OPCbinareas_+3A_opc_file">OPC_File</code></td>
<td>
<p>An object that stores the output
of an OPC analysis using <code>OPC()</code>.</p>
</td></tr>
<tr><td><code id="OPCbinareas_+3A_main">main</code></td>
<td>
<p>Title for plot.</p>
</td></tr>
<tr><td><code id="OPCbinareas_+3A_bincolors">binColors</code></td>
<td>
<p>Allows the user to define the fill colors for
each directional bin. see details</p>
</td></tr>
<tr><td><code id="OPCbinareas_+3A_type">type</code></td>
<td>
<p>String argument to determine type of plot, either
bar' or 'pie'. Default is set to 'bar'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will create either bar or pie chats visualising
the distribution of surface area into each of the OPC orientation
bins. Colors can be customized but are meant to match the
default settings in the <code>OPC3d()</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OPC_Object &lt;- OPC(Tooth)
OPCbinareas(OPC_Object) 
</code></pre>

<hr>
<h2 id='OPCr'>Calculate average orientation patch count after several rotations</h2><span id='topic+OPCr'></span>

<h3>Description</h3>

<p>A function that calls OPC iteratively after rotating mesh a selected
number of degrees around the Z-axis following Evans and Jernvall
(2009) Patterns and constraints in carnivoran and rodent dental
complexity and tooth size. J Vert Paleo 29:24A
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OPCr(plyFile, steps = 8, stepSize = 5.625, minimum_faces = 3, minimum_area = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OPCr_+3A_plyfile">plyFile</code></td>
<td>
<p>An object of classes 'mesh3d' and 'shape3d' with
calculated normals</p>
</td></tr>
<tr><td><code id="OPCr_+3A_steps">steps</code></td>
<td>
<p>Number of iterations to run the <code>OPC()</code> function on
the mesh</p>
</td></tr>
<tr><td><code id="OPCr_+3A_stepsize">stepSize</code></td>
<td>
<p>Amount of rotation (in degrees) about the Z-axis
to adjust mesh surface by between each iteration of <code>OPC()</code></p>
</td></tr>
<tr><td><code id="OPCr_+3A_minimum_faces">minimum_faces</code></td>
<td>
<p>Argument to pass to the <code>OPC()</code> function</p>
</td></tr>
<tr><td><code id="OPCr_+3A_minimum_area">minimum_area</code></td>
<td>
<p>Argument to pass to the <code>OPC()</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires a mesh object created by reading in a ply file utilizing
either the, <code><a href="Rvcg.html#topic+vcgPlyRead">vcgPlyRead</a></code> function.
</p>
<p>Default number of steps is 8, with a stepSize of 5.625 degrees, following the
original published definition of OPCR.
</p>
<p>See the details for the <code><a href="#topic+OPC">OPC</a></code> function for more information about
preparing mesh surfaces and the effects of <code>minimum_faces</code> and <code>minimum_area</code>.
</p>

<hr>
<h2 id='OPCr_Example1'>OPCr_Example1 - object created by OPCr function used as an example.</h2><span id='topic+OPCr_Example1'></span><span id='topic+OPCr_Example1.list'></span>

<h3>Description</h3>

<p>This object is needed to pass the CRAN upload requirements and still keep the vignette.
</p>


<h3>Format</h3>

<p><code>OPCr_Example1</code>: molaR produced object.
</p>

<hr>
<h2 id='OPCr_Example2'>OPCr_Example2 - object created by OPCr function used as an example.</h2><span id='topic+OPCr_Example2'></span><span id='topic+OPCr_Example2.list'></span>

<h3>Description</h3>

<p>This object is needed to pass the CRAN upload requirements and still keep the vignette.
</p>


<h3>Format</h3>

<p><code>OPCr_Example2</code>: molaR produced object.
</p>

<hr>
<h2 id='plyPlaneCut'>Cut a PLY Mesh Along a Specified Plane</h2><span id='topic+plyPlaneCut'></span>

<h3>Description</h3>

<p><code>plyPlaneCut</code> permits several different approaches for specifying a cutting plane
and returns either a portion of the original mesh from one side of the plane, or
both portions from each side of the plane stored as separate list elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plyPlaneCut(
  plyFile,
  axis = "Z",
  vertIndex = NA,
  keepBoth = FALSE,
  plane = NA,
  col = "rainbow",
  flipAxis = FALSE,
  displayNew = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plyPlaneCut_+3A_plyfile">plyFile</code></td>
<td>
<p>An object of class 'mesh3d'.</p>
</td></tr>
<tr><td><code id="plyPlaneCut_+3A_axis">axis</code></td>
<td>
<p>String indicating the axis plane on which to cut the mesh. May be <code>'X'</code>, <code>'Y'</code>,
or <code>'Z'</code>, Defaults to <code>'Z'</code>. Ignored if <code>plane</code> is specified, see details.</p>
</td></tr>
<tr><td><code id="plyPlaneCut_+3A_vertindex">vertIndex</code></td>
<td>
<p>Numeric index of a mesh vertex to define clipping plane. Ignored
if <code>plane</code> is specified, see details.</p>
</td></tr>
<tr><td><code id="plyPlaneCut_+3A_keepboth">keepBoth</code></td>
<td>
<p>Logical indicating if both sides of the cut mesh should be returned,
defaults to <code>FALSE</code>. If <code>TRUE</code> (and the cutting plane intersects the mesh), the function
output is a list containing <code>meshA</code> and <code>meshB</code> representing the two portions.</p>
</td></tr>
<tr><td><code id="plyPlaneCut_+3A_plane">plane</code></td>
<td>
<p>Requires four numeric values specifying the coordinates of the plane normal
(<em>a, b, c</em>) and the &quot;offset&quot; (<em>d</em>). Overrides input for <code>axis</code> and <code>vertIndex</code>, see details.</p>
</td></tr>
<tr><td><code id="plyPlaneCut_+3A_col">col</code></td>
<td>
<p>Vector indicating the color for vertex drawing when interactively choosing
cutting plane. Defaults to <code>"rainbow"</code>, a magenta-to-red color ramp along the specified
<code>axis</code>.</p>
</td></tr>
<tr><td><code id="plyPlaneCut_+3A_flipaxis">flipAxis</code></td>
<td>
<p>Logical indicating whether or not to reverse the output about the
normal of the plane, defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plyPlaneCut_+3A_displaynew">displayNew</code></td>
<td>
<p>Logical indicating whether or not to display the function results
when a value is supplied to either <code>vertIndex</code> or <code>plane</code>, defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plyPlaneCut</code> draws a cutting plane using the parametrization <em>ax + by + cz + d = 0</em>
(Hesse normal form), wherein &lt;<em>a, b, c</em>&gt; constitute the normal to the plane, and <em>d</em> is the
&quot;offset&quot; value. See <code><a href="rgl.html#topic+planes3d">planes3d</a></code> for further information. Users can supply
any parameters for <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> in the <code>plane</code> argument to produce an arbitrary
cutting plane (see Examples), however the function is designed to aid users in choosing a
cutting plane without foreknowledge of the desired parameters.
</p>
<p>When <code>plane</code> is <code>NA</code>, the function will cut the mesh along a plane orthogonal to one of
the primary axes (X, Y, or Z, as indicated by <code>axis</code>) at the location of a focal vertex.
The focal vertex can be defined by its index value, supplied to <code>vertIndex</code>. If no value
is given for either <code>plane</code> or <code>vertIndex</code>, then an interactive 3D window allows the
user to select the focal vertex. A 3D window will open displaying all mesh vertices,
colored according to <code>col</code>, with a semi-transparent mesh surface. The display can be
rotated with the left mouse button and zoomed with the mouse wheel. The right mouse
button allows the user to define a rectangular region in which to identify the focal
vertex. The focal vertex is the vertex in the user-selected region with the <em>minimum value</em>
in the dimension indicated by the <code>axis</code> argument. A preview of the resulting cutting
will be supplied, and for the function to finish users must supply a &quot;Y&quot; or &quot;y&quot;
confirmation to the <code style="white-space: pre;">&#8288;Cut mesh?:&#8288;</code> prompt in the terminal. Any other response will
restart the selection process.
</p>
<p>The <code>col</code> argument is only invoked when choosing a focal vertex in an interactive 3D
window (i.e., <code>vertIndex</code> and <code>plane</code> are set to <code>NA</code>). This argument will apply any
acceptable color vector to the displayed vertices. Alternatively, users can specify
a color ramp by supplying a string, including: <code>"rainbow"</code>, <code>"heat.colors"</code>,
<code>"terrain.colors"</code>, <code>"topo.colors"</code>, <code>"cm.colors"</code>, or <code>"gray.colors"</code>; see
<code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code> and <code><a href="grDevices.html#topic+gray.colors">gray.colors</a></code> for
further details. Color ramps will plot along the axis specified by <code>axis</code> and reverse
if <code>flipAxis = TRUE</code>.
</p>
<p>If users prefer that the function is inverted with respect to mesh geometry (i.e., that it
identifies the focal vertex as the <em>maximum value</em> with respect to <code>axis</code>, or that the
resulting mesh be that along the <em>negative</em> normal to the plane), then they should set
<code>flipAxis = TRUE</code>. If <code>keepBoth</code> is enabled, the function will return a list of two
'mesh3d' objects: <code>meshA</code>, and <code>meshB</code>. Enabling <code>keepBoth</code> but providing a plane
that does not intersect the mesh will result in a list with one of the objects set
to <code>NULL</code> (see Examples).
</p>
<p>This function can be used to cut meshes representing tooth surfaces so as to retain
only the area of the tooth crown above the lowest point of the occlusal basin. This
cropping procedure is consistent with the one used to prepare surfaces for
measurement of occlusal relief (OR) by Ungar &amp; M'Kirera (2003) &quot;A solution to the
worn tooth conundrum in primate functional anatomy&quot; PNAS 100(7):3874-3877
Unreferenced vertices can cause errors, so users are encouraged to clean their mesh
with <code><a href="#topic+molaR_Clean">molaR_Clean</a></code> prior to using this function.
</p>


<h3>Value</h3>

<p>An object of class 'mesh3d' corresponding to the portion of the mesh on one side
of the cutting plane. If <code>keepBoth</code> is enabled, a list of two such objects corresponding
to the portions from both sides of the plane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Result from providing plane parameters and keeping meshes from both sides of plane

cutMesh &lt;- plyPlaneCut(Tooth, plane = c(0.5, 0.5, 0.5, -4), keepBoth = TRUE)
open3d()
shade3d(cutMesh$meshA, col = "gray")
wire3d(cutMesh$meshB)
planes3d(0.5, 0.5, 0.5, -4, col = "red", alpha = 0.66)


# Result from providing parameters for a plane that does not intersect the mesh

cutMesh &lt;- plyPlaneCut(Tooth, plane = c(1, 0.75, 0.5, -11))
identical(Tooth, cutMesh)

cutMesh &lt;- plyPlaneCut(Tooth, plane = c(1, 0.75, 0.5, -11), keepBoth = TRUE)
identical(Tooth, cutMesh)

</code></pre>

<hr>
<h2 id='RFI'>Calculate relief index for a surface</h2><span id='topic+RFI'></span>

<h3>Description</h3>

<p>A function that calculates relief index following Boyer (2008) Relief index of
second mandibular molars is a correlate of diet among prosimian primates and
other mammals. J Hum Evol 55:1118-1137 doi:
<a href="https://www.sciencedirect.com/science/article/pii/S0047248408001565">10.1016/j.jhevol.2008.08.002</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RFI(plyFile, alpha = 0.075, findAlpha = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RFI_+3A_plyfile">plyFile</code></td>
<td>
<p>An object of classes 'mesh3d' and 'shape3d'</p>
</td></tr>
<tr><td><code id="RFI_+3A_alpha">alpha</code></td>
<td>
<p>Step size for calculating the outline. See details.</p>
</td></tr>
<tr><td><code id="RFI_+3A_findalpha">findAlpha</code></td>
<td>
<p>Logical indicating that alpha will be auto-calculated. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires an object created by reading in a ply file utilizing
either the <code><a href="Rvcg.html#topic+vcgPlyRead">vcgPlyRead</a></code> function.
</p>
<p>Relief index is calculated by the ratio of three-dimensional surface area to two
dimensional area on meshes that represent specimen surfaces and have already
been pre-smoothed in a 3D data editing program. Surface alignment will have a
large effect on 2D area calculation and must be performed prior to creating and
reading in the ply file. The mesh must be oriented such that the occlusal plane
is parallel to the X- and Y-axes and perpendicular to the Z-axis (i.e., tooth
cusps pointing towards +Z).
</p>
<p>The <code>alpha</code> parameter traces the outline of the 2D footprint. An <code>alpha</code> that is
too low will result in a tracing error (returning an <code>"Alpha adjustment required"</code>
message), while an <code>alpha</code> value that is too high may result in an overestimate
of the 2D footprint area by failing to take into account infoldings. The user is
encouraged to carefully review results using the <code><a href="#topic+RFI3d">RFI3d</a></code> or
<code><a href="#topic+Check2D">Check2D</a></code> functions.
</p>
<p>Alternatively, the <code>findAlpha</code> argument can be used to compute an ideal <code>alpha</code>
value for a particular PLY file for use in the RFI calculation. This is defined as the
lowest value (to the nearest thousandth) returning no error or warning messages.
This feature ensures accuracy, but may increase computing time significantly,
depending on the number of <code>alpha</code> values tested. Unfortunately, there is no way
to guess an appropriate <code>alpha</code> value a priori. After 100 unsuccessful attempts to
find an appropriate <code>alpha</code>, the function will terminate.
</p>
<p>The <code>alpha</code> value used in the calculation (whether chosen by the user or auto-
computed with <code>findAlpha</code>) is returned in the analysis results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RFI_output &lt;- RFI(Tooth, alpha=0.5, findAlpha = FALSE)
summary(RFI_output)
</code></pre>

<hr>
<h2 id='RFI3d'>Plot 3D and 2D areas of a mesh used to calculate relief index</h2><span id='topic+RFI3d'></span>

<h3>Description</h3>

<p>A function that plots a three-dimensional model of the mesh
surface and includes a footprint of the two-dimensional area for
visual comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RFI3d(
  RFI_File,
  displacement = -1.9,
  SurfaceColor = "gray",
  FootColor = "red",
  FootPts = FALSE,
  FootPtsColor = "black",
  Opacity = 1,
  legend = F,
  main = "",
  cex = 1,
  leftOffset = 0,
  fieldofview = 0,
  fileName = NA,
  binary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RFI3d_+3A_rfi_file">RFI_File</code></td>
<td>
<p>An object that stores the output of the RFI
function</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_displacement">displacement</code></td>
<td>
<p>Numeric that moves the surface footprint some
proportion of the height of the mesh. 0 is in the vertical center of the
surface, negative values displace the footprint downward.</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_surfacecolor">SurfaceColor</code></td>
<td>
<p>String that controls the color of the 3D surface mesh</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_footcolor">FootColor</code></td>
<td>
<p>String that controls the color of the 2D surface footprint</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_footpts">FootPts</code></td>
<td>
<p>Logical indicating whether to plot the
flattened points of the footprint from the original ply file</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_footptscolor">FootPtsColor</code></td>
<td>
<p>Color of the plotted footprint points if <code>FootPts = TRUE</code></p>
</td></tr>
<tr><td><code id="RFI3d_+3A_opacity">Opacity</code></td>
<td>
<p>Numeric that adjusts the opacity of the 3D mesh surface</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether or not to include a
legend of the colors chosen to represent the 3D surface and
footprint</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_main">main</code></td>
<td>
<p>String indicating plot title</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_cex">cex</code></td>
<td>
<p>Numeric setting the relative size of the legend and title</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_leftoffset">leftOffset</code></td>
<td>
<p>Numeric between -1 and 1 setting the amount of offset for
the plotted surface to the left. Larger values push surface farther to right.</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_fieldofview">fieldofview</code></td>
<td>
<p>Passes an argument to <code>par3d()</code> changing the field of
view in degrees of the resulting surface plot</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_filename">fileName</code></td>
<td>
<p>String indicating a name to save the plotted surface to as a
*.ply file; default of 'NA' will not save a file</p>
</td></tr>
<tr><td><code id="RFI3d_+3A_binary">binary</code></td>
<td>
<p>Logical indicating whether or not the saved surface plot should
be binary, passed to <code>vcgPlyWrite()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can help to visualize the three-dimensional and two
dimensional areas that are used in calculating the relief index of a surface by
displaying both at the same time. The RFI function must be performed first.
</p>
<p><code>Opacity</code> can be adjusted in a range from fully opaque (<code>1</code>) to fully
transparent (<code>0</code>) in order to help visualize the footprint. The vertical
placement of the footprint along the Z axis can be altered with <code>displacement</code>,
depending on how the user wishes to view the surface, or on the original
mesh orientation.
</p>
<p>A title can be added to the plot by supplying a character string to the <code>main</code>
argument. Title and legend size are controlled with the <code>cex</code> argument,
analogous to that in the default R graphics device.
</p>
<p>The <code>leftOffset</code> value sets how far to the left the surface will plot, intended
to help avoid overlap with the legend. Value of 0 will center the surface and
should be invoked if the <code>legend</code> argument is disabled. Higher values will push
the surface farther left and negative values will push it to the right. It is
recommended that these values be restricted between -1 and 1 to avoid plotting
the surface outside of the rgl window.
</p>
<p><code>fieldofview</code> is set to a default of 0, which is an isometric projection.
Increasing it alters the degree of parallax in the perspective view, up to
a maximum of 179 degrees (see <code><a href="rgl.html#topic+par3d">rgl::par3d()</a></code>).
</p>
<p>The plotted, colorized surface can be saved as a *.ply to the working directory
by changing the <code>fileName</code> argument from <code>NA</code> to a string (e.g., &quot;RFIPlot&quot;). The
resultant ply file can be opened and manipulated in other 3D visualizing programs,
such as <a href="https://www.meshlab.net/">MeshLab</a>, but will <strong>NOT</strong> retain its legend
(a background of the plotting window). To retain the legend, the user is
encouraged to utilize the function 'snapshot3d()' in the rgl package. (see <code><a href="rgl.html#topic+rgl.snapshot">rgl::rgl.snapshot()</a></code>)
The <code>binary</code> argument saves a file in ascii format by default, which is supported by
more 3D visualization software than is binary. However, binary files will be
considerably smaller.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RFI_File &lt;- RFI(Tooth, alpha=0.5)
RFI3d(RFI_File)
</code></pre>

<hr>
<h2 id='Slope'>Function to calculate the average slope of a surface</h2><span id='topic+Slope'></span>

<h3>Description</h3>

<p>A function that calculates the average slope over a tooth
or some other 3D surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slope(plyFile, Guess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slope_+3A_plyfile">plyFile</code></td>
<td>
<p>An object of classes 'mesh3d' and 'shape3d' with calculated normals</p>
</td></tr>
<tr><td><code id="Slope_+3A_guess">Guess</code></td>
<td>
<p>Logical indicating whether the function should
'guess' as to the 'up' direction for the surface and to remove negative
slopes from the calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a ply file. It will calculate the slope on each face
of the surface and will average the slope across the surface. This is functionally
equivalent to the slope calculation used by Ungar and M'Kirera &quot;A solution to the worn
tooth conundrum  in primate functional anatomy&quot; PNAS (2003) 100(7):3874-3877
</p>
<p>In the case of applying this function to teeth (its intended purpose), the function expects a
surface with the occlusal plane normal to the Z-axis.
</p>
<p>The <code>Guess</code> parameter is a logical asking whether or not you want the function to both
guess as to the right side up of the surface, and to then discard all of the 'negative' slopes,
i.e. surfaces which are over-hangs, as is frequently found on the sidewalls of teeth. If
<code>Guess</code> is not engaged the mean slope will include the negative values of the overhang
and will likely underestimate the average slope of the surface.
</p>
<p>Regardless of if the <code>Guess</code> parameter is engaged, the function will also return a vector
containing all of the face slope values (&quot;Face_Slopes&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Slope_output &lt;- Slope(Tooth)
summary(Slope_output)
</code></pre>

<hr>
<h2 id='Slope3d'>Plot results of a Slope analysis of a surface</h2><span id='topic+Slope3d'></span>

<h3>Description</h3>

<p>A function that produces a three-dimensional rendering of surface slope.
The Slope function will identify the slope of each mesh face. It must be
performed prior to using the Slope3d function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slope3d(
  Slope_File,
  colors = c("blue", "cornflowerblue", "green", "yellowgreen", "yellow", "orangered",
    "red"),
  maskNegatives = TRUE,
  legend = TRUE,
  main = "",
  cex = 1,
  leftOffset = 1,
  fieldofview = 0,
  fileName = NA,
  binary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slope3d_+3A_slope_file">Slope_File</code></td>
<td>
<p>An object that stores the output of the
Slope function</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_colors">colors</code></td>
<td>
<p>String of colors to build the color gradient</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_masknegatives">maskNegatives</code></td>
<td>
<p>Logical indicating whether or not to mask (in  black)
negative slopes, or to reflect them into positive slopes</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether or not a legend
should be displayed</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_main">main</code></td>
<td>
<p>String indicating plot title</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_cex">cex</code></td>
<td>
<p>Numeric setting the relative size of the legend and title</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_leftoffset">leftOffset</code></td>
<td>
<p>Numeric between -1 and 1 setting the amount of offset for
the plotted surface to the left. Larger values push surface farther to right.</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_fieldofview">fieldofview</code></td>
<td>
<p>Passes an argument to <code>par3d()</code> changing the field of
view in degrees of the resulting surface plot</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_filename">fileName</code></td>
<td>
<p>String indicating a name to save the plotted surface to as a
*.ply file; default of 'NA' will not save a file</p>
</td></tr>
<tr><td><code id="Slope3d_+3A_binary">binary</code></td>
<td>
<p>Logical indicating whether or not the saved surface plot should
be binary, passed to <code>vcgPlyWrite()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a heat map on the mesh surface
corresponding to the slope of each face calculated by
the Slope function.
</p>
<p>Colors are taken as a series inputs to define a color ramp and can be customized
indefinitely in value or order. The default is suggested as an intuitive display
of increasing color heat corresponding with steeper face slope.
</p>
<p>A title can be added to the plot by supplying a character string to the <code>main</code>
argument. Title and legend size are controlled with the <code>cex</code> argument,
analogous to that in the default R graphics device.
</p>
<p>The <code>leftOffset</code> value sets how far to the left the surface will plot, intended
to help avoid overlap with the legend. Value of 0 will center the surface and
should be invoked if the <code>legend</code> argument is disabled. Higher values will push
the surface farther left and negative values will push it to the right. It is
recommended that these values be restricted between -1 and 1 to avoid plotting
the surface outside of the rgl window.
</p>
<p><code>fieldofview</code> is set to a default of 0, which is an isometric projection.
Increasing it alters the degree of parallax in the perspective view, up to
a maximum of 179 degrees (see <code><a href="rgl.html#topic+par3d">rgl::par3d()</a></code>).
</p>
<p>The plotted, colorized surface can be saved as a *.ply to the working directory
by changing the <code>fileName</code> argument from <code>NA</code> to a string (e.g., &quot;SlopePlot&quot;). The
resultant ply file can be opened and manipulated in other 3D visualizing programs,
such as <a href="https://www.meshlab.net/">MeshLab</a>, but will <strong>NOT</strong> retain its legend
(a background of the plotting window). To retain the legend, the user is
encouraged to utilize the function 'snapshot3d()' in the rgl package. (see <code><a href="rgl.html#topic+rgl.snapshot">rgl::rgl.snapshot()</a></code>)
The <code>binary</code> argument saves a file in ascii format by default, which is supported by
more 3D visualization software than is binary. However, binary files will be
considerably smaller.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Slope_output &lt;- Slope(Tooth)
Slope3d(Slope_output)
</code></pre>

<hr>
<h2 id='Tooth'>Tooth a surface mesh of a tooth.</h2><span id='topic+Tooth'></span><span id='topic+Tooth.mesh'></span>

<h3>Description</h3>

<p>Tooth scan of USNM_112176 lower M~1~ from <em>Chlorocebus sp.</em>
</p>
<p>A triangular mesh representing a lower M1 Chlorocebus spp. tooth - called by data(Tooth)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Tooth)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"mesh3d"</code>
</p>
<p><code>Tooth</code>: triangular mesh representing a sine-cosine plane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Tooth)
DNE_Output &lt;- DNE(Tooth)
DNE3d(DNE_Output)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
