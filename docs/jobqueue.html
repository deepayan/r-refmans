<!DOCTYPE html><html lang="en"><head><title>Help for package jobqueue</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jobqueue}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Job'><p>How to Evaluate an R Expression</p></a></li>
<li><a href='#Queue'><p>Assigns Jobs to a Set of Workers</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#Worker'><p>A Background Process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Run Interruptible Code Asynchronously</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-28</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Takes an R expression and returns a Job object with a $stop() method
    which can be called to terminate the background job. Also provides timeouts
    and other mechanisms for automatically terminating a background job. The
    result of the expression is available synchronously via $result or
    asynchronously with callbacks or through the 'promises' package framework.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cmmr.github.io/jobqueue/">https://cmmr.github.io/jobqueue/</a>, <a href="https://github.com/cmmr/jobqueue">https://github.com/cmmr/jobqueue</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cmmr/jobqueue/issues">https://github.com/cmmr/jobqueue/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, later, magrittr, parallelly, promises, ps, R6, rlang,
semaphore, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glue, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-28 17:59:28 UTC; Daniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel P. Smith <a href="https://orcid.org/0000-0002-2479-2044"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alkek Center for Metagenomics and Microbiome Research [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel P. Smith &lt;dansmith01@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-28 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Job'>How to Evaluate an R Expression</h2><span id='topic+Job'></span>

<h3>Description</h3>

<p>The Job object encapsulates an expression and its evaluation parameters. It
also provides a way to check for and retrieve the result.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>expr</code></dt><dd><p>R expression that will be run by this Job.</p>
</dd>
<dt><code>vars</code></dt><dd><p>Get or set - List of variables that will be placed into the expression's
environment before evaluation.</p>
</dd>
<dt><code>reformat</code></dt><dd><p>Get or set - <code style="white-space: pre;">&#8288;function (job)&#8288;</code> for defining <code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code>.</p>
</dd>
<dt><code>signal</code></dt><dd><p>Get or set - Conditions to signal.</p>
</dd>
<dt><code>cpus</code></dt><dd><p>Get or set - Number of CPUs to reserve for evaluating <code>expr</code>.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>Get or set - Time limits to apply to this Job.</p>
</dd>
<dt><code>proxy</code></dt><dd><p>Get or set - Job to proxy in place of running <code>expr</code>.</p>
</dd>
<dt><code>state</code></dt><dd><p>Get or set - The Job's state: <code>'created'</code>, <code>'submitted'</code>, <code>'queued'</code>,
<code>'dispatched'</code>, <code>'starting'</code>, <code>'running'</code>, or <code>'done'</code>.
<em>Assigning to <code style="white-space: pre;">&#8288;&lt;Job&gt;$state&#8288;</code> will trigger callback hooks.</em></p>
</dd>
<dt><code>output</code></dt><dd><p>Get or set - Job's raw output.
<em>Assigning to <code style="white-space: pre;">&#8288;&lt;Job&gt;$output&#8288;</code> will change the Job's state to <code>'done'</code>.</em></p>
</dd>
<dt><code>result</code></dt><dd><p>Result of <code>expr</code>. Will block until Job is finished.</p>
</dd>
<dt><code>hooks</code></dt><dd><p>Currently registered callback hooks as a named list of functions.
Set new hooks with <code style="white-space: pre;">&#8288;&lt;Job&gt;$on()&#8288;</code>.</p>
</dd>
<dt><code>is_done</code></dt><dd><p><code>TRUE</code> or <code>FALSE</code> depending on if the Job's result is ready.</p>
</dd>
<dt><code>uid</code></dt><dd><p>A short string, e.g. <code>'J16'</code>, that uniquely identifies this Job.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Job-new"><code>Job$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Job-print"><code>Job$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Job-on"><code>Job$on()</code></a>
</p>
</li>
<li> <p><a href="#method-Job-wait"><code>Job$wait()</code></a>
</p>
</li>
<li> <p><a href="#method-Job-stop"><code>Job$stop()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Job-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a Job object defining how to run an expression on a background worker process.
</p>
<p><em>Typically you won't need to call <code>Job$new()</code>. Instead, create a <a href="#topic+Queue">Queue</a> and use
<code style="white-space: pre;">&#8288;&lt;Queue&gt;$run()&#8288;</code> to generate Job objects.</em>
</p>


<h5>Usage</h5>

<div class="r"><pre>Job$new(
  expr,
  vars = NULL,
  timeout = NULL,
  hooks = NULL,
  reformat = NULL,
  signal = FALSE,
  cpus = 1L,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt><dd><p>A call or R expression wrapped in curly braces to evaluate on a
worker. Will have access to any variables defined by <code>vars</code>, as well
as the Worker's <code>globals</code>, <code>packages</code>, and <code>init</code> configuration.
See <code>vignette('eval')</code>.</p>
</dd>
<dt><code>vars</code></dt><dd><p>A named list of variables to make available to <code>expr</code> during
evaluation. Alternatively, an object that can be coerced to a named
list with <code>as.list()</code>, e.g. named vector, data.frame, or environment.
Or a <code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns such an object.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>A named numeric vector indicating the maximum number of
seconds allowed for each state the job passes through, or 'total' to
apply a single timeout from 'submitted' to 'done'. Or a
<code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns the same. Example:
<code>timeout = c(total = 2.5, running = 1)</code>. See <code>vignette('stops')</code>.</p>
</dd>
<dt><code>hooks</code></dt><dd><p>A named list of functions to run when the Job state changes,
of the form <code>hooks = list(created = function (worker) {...})</code>. Or a
<code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns the same. Names of worker hooks are
typically <code>'created'</code>, <code>'submitted'</code>, <code>'queued'</code>, <code>'dispatched'</code>,
<code>'starting'</code>, <code>'running'</code>, <code>'done'</code>, or <code>'*'</code> (duplicates okay).
See <code>vignette('hooks')</code>.</p>
</dd>
<dt><code>reformat</code></dt><dd><p>Set <code style="white-space: pre;">&#8288;reformat = function (job)&#8288;</code> to define what
<code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code> should return. The default, <code>reformat = NULL</code> passes
<code style="white-space: pre;">&#8288;&lt;Job&gt;$output&#8288;</code> to <code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code> unchanged.
See <code>vignette('results')</code>.</p>
</dd>
<dt><code>signal</code></dt><dd><p>Should calling <code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code> signal on condition objects?
When <code>FALSE</code>, <code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code> will return the object without
taking additional action. Setting to <code>TRUE</code> or a character vector of
condition classes, e.g. <code>c('interrupt', 'error', 'warning')</code>, will
cause the equivalent of <code style="white-space: pre;">&#8288;stop(&lt;condition&gt;)&#8288;</code> to be called when those
conditions are produced. Alternatively, a <code style="white-space: pre;">&#8288;function (job)&#8288;</code> that
returns <code>TRUE</code> or <code>FALSE</code>. See <code>vignette('results')</code>.</p>
</dd>
<dt><code>cpus</code></dt><dd><p>How many CPU cores to reserve for this Job.  Or a
<code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns the same. Used to limit the number of
Jobs running simultaneously to respect <code style="white-space: pre;">&#8288;&lt;Queue&gt;$max_cpus&#8288;</code>. Does not
prevent a Job from using more CPUs than reserved.</p>
</dd>
<dt><code>...</code></dt><dd><p>Arbitrary named values to add to the returned Job object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A Job object.
</p>


<hr>
<a id="method-Job-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method for a Job.
</p>


<h5>Usage</h5>

<div class="r"><pre>Job$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments are not used currently.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This Job, invisibly.
</p>


<hr>
<a id="method-Job-on"></a>



<h4>Method <code>on()</code></h4>

<p>Attach a callback function to execute when the Job enters <code>state</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Job$on(state, func)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>The name of a Job state. Typically one of:
</p>

<ul>
<li> <p><code>'*'</code> -          Every time the state changes.
</p>
</li>
<li> <p><code>'.next'</code> -      Only one time, the next time the state changes.
</p>
</li>
<li> <p><code>'created'</code> -    After <code>Job$new()</code> initialization.
</p>
</li>
<li> <p><code>'submitted'</code> -  After <code style="white-space: pre;">&#8288;&lt;Job&gt;$queue&#8288;</code> is assigned.
</p>
</li>
<li> <p><code>'queued'</code> -     After <code>stop_id</code> and <code>copy_id</code> are resolved.
</p>
</li>
<li> <p><code>'dispatched'</code> - After <code style="white-space: pre;">&#8288;&lt;Job&gt;$worker&#8288;</code> is assigned.
</p>
</li>
<li> <p><code>'starting'</code> -   Before evaluation begins.
</p>
</li>
<li> <p><code>'running'</code> -    After evaluation begins.
</p>
</li>
<li> <p><code>'done'</code> -       After <code style="white-space: pre;">&#8288;&lt;Job&gt;$output&#8288;</code> is assigned.
</p>
</li></ul>

<p>Custom states can also be specified.</p>
</dd>
<dt><code>func</code></dt><dd><p>A function that accepts a Job object as input. You can call
<code style="white-space: pre;">&#8288;&lt;Job&gt;$stop()&#8288;</code> or edit <code style="white-space: pre;">&#8288;&lt;Job&gt;$&#8288;</code> values and the changes will be
persisted (since Jobs are reference class objects). You can also
edit/stop other queued jobs by modifying the Jobs in
<code style="white-space: pre;">&#8288;&lt;Job&gt;$queue$jobs&#8288;</code>. Return value is ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A function that when called removes this callback from the Job.
</p>


<hr>
<a id="method-Job-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Blocks until the Job enters the given state.
</p>


<h5>Usage</h5>

<div class="r"><pre>Job$wait(state = "done", timeout = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>The name of a Job state. Typically one of:
</p>

<ul>
<li> <p><code>'*'</code> -          Every time the state changes.
</p>
</li>
<li> <p><code>'.next'</code> -      Only one time, the next time the state changes.
</p>
</li>
<li> <p><code>'created'</code> -    After <code>Job$new()</code> initialization.
</p>
</li>
<li> <p><code>'submitted'</code> -  After <code style="white-space: pre;">&#8288;&lt;Job&gt;$queue&#8288;</code> is assigned.
</p>
</li>
<li> <p><code>'queued'</code> -     After <code>stop_id</code> and <code>copy_id</code> are resolved.
</p>
</li>
<li> <p><code>'dispatched'</code> - After <code style="white-space: pre;">&#8288;&lt;Job&gt;$worker&#8288;</code> is assigned.
</p>
</li>
<li> <p><code>'starting'</code> -   Before evaluation begins.
</p>
</li>
<li> <p><code>'running'</code> -    After evaluation begins.
</p>
</li>
<li> <p><code>'done'</code> -       After <code style="white-space: pre;">&#8288;&lt;Job&gt;$output&#8288;</code> is assigned.
</p>
</li></ul>

<p>Custom states can also be specified.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>Stop the Job if it takes longer than this number of seconds, or <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This Job, invisibly.
</p>


<hr>
<a id="method-Job-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Stop this Job. If the Job is running, its Worker will be restarted.
</p>


<h5>Usage</h5>

<div class="r"><pre>Job$stop(reason = "job stopped by user", cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>reason</code></dt><dd><p>A message to include in the 'interrupt' condition object that
will be returned as the Job's result. Or a condition object.</p>
</dd>
<dt><code>cls</code></dt><dd><p>Character vector of additional classes to prepend to
<code>c('interrupt', 'condition')</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This Job, invisibly.
</p>



<hr>
<h2 id='Queue'>Assigns Jobs to a Set of Workers</h2><span id='topic+Queue'></span>

<h3>Description</h3>

<p>Jobs go in. Results come out.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>hooks</code></dt><dd><p>A named list of currently registered callback hooks.</p>
</dd>
<dt><code>jobs</code></dt><dd><p>Get or set - List of <a href="#topic+Job">Jobs</a> currently managed by this Queue.</p>
</dd>
<dt><code>state</code></dt><dd><p>The Queue's state: <code>'starting'</code>, <code>'idle'</code>, <code>'busy'</code>, <code>'stopped'</code>, or <code>'error.'</code></p>
</dd>
<dt><code>uid</code></dt><dd><p>Get or set - Unique identifier, e.g. <code>'Q1'</code>.</p>
</dd>
<dt><code>tmp</code></dt><dd><p>The Queue's temporary directory.</p>
</dd>
<dt><code>workers</code></dt><dd><p>Get or set - List of <a href="#topic+Worker">Workers</a> used for processing Jobs.</p>
</dd>
<dt><code>cnd</code></dt><dd><p>The error that caused the Queue to stop.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Queue-new"><code>Queue$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-print"><code>Queue$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-run"><code>Queue$run()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-submit"><code>Queue$submit()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-wait"><code>Queue$wait()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-on"><code>Queue$on()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-stop"><code>Queue$stop()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Queue-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a pool of background processes for handling <code style="white-space: pre;">&#8288;$run()&#8288;</code> and
<code style="white-space: pre;">&#8288;$submit()&#8288;</code> calls. These workers are initialized according to the
<code>globals</code>, <code>packages</code>, and <code>init</code> arguments.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$new(
  globals = NULL,
  packages = NULL,
  namespace = NULL,
  init = NULL,
  max_cpus = availableCores(),
  workers = ceiling(max_cpus * 1.2),
  timeout = NULL,
  hooks = NULL,
  reformat = NULL,
  signal = FALSE,
  cpus = 1L,
  stop_id = NULL,
  copy_id = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>globals</code></dt><dd><p>A named list of variables that all <code style="white-space: pre;">&#8288;&lt;Job&gt;$expr&#8288;</code>s will have
access to. Alternatively, an object that can be coerced to a named
list with <code>as.list()</code>, e.g. named vector, data.frame, or environment.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of package names to load on workers.</p>
</dd>
<dt><code>namespace</code></dt><dd><p>The name of a package to attach to the worker's
environment.</p>
</dd>
<dt><code>init</code></dt><dd><p>A call or R expression wrapped in curly braces to evaluate on
each worker just once, immediately after start-up. Will have access
to variables defined by <code>globals</code> and assets from <code>packages</code> and
<code>namespace</code>. Returned value is ignored.</p>
</dd>
<dt><code>max_cpus</code></dt><dd><p>Total number of CPU cores that can be reserved by all
running Jobs (<code style="white-space: pre;">&#8288;sum(&lt;Job&gt;$cpus)&#8288;</code>). Does not enforce limits on actual
CPU utilization.</p>
</dd>
<dt><code>workers</code></dt><dd><p>How many background <a href="#topic+Worker">Worker</a> processes to start. Set to more
than <code>max_cpus</code> to enable standby Workers to quickly swap out with
Workers that need to restart.</p>
</dd>
<dt><code>timeout, hooks, reformat, signal, cpus, stop_id, copy_id</code></dt><dd><p>Defaults for this Queue's <code style="white-space: pre;">&#8288;$run()&#8288;</code> method. Here only, <code>stop_id</code>
and <code>copy_id</code> must be either a <code style="white-space: pre;">&#8288;function (job)&#8288;</code> or <code>NULL</code>.
<code>hooks</code> can set queue, worker, and/or job hooks - see the
&quot;Attaching&quot; section in <code>vignette('hooks')</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Queue</code> object.
</p>


<hr>
<a id="method-Queue-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method for a <code>Queue</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments are not used currently.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Queue-run"></a>



<h4>Method <code>run()</code></h4>

<p>Creates a Job object and submits it to the queue for running.
Any <code>NA</code> arguments will be replaced with their value from <code>Queue$new()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$run(
  expr,
  vars = list(),
  timeout = NA,
  hooks = NA,
  reformat = NA,
  signal = NA,
  cpus = NA,
  stop_id = NA,
  copy_id = NA,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt><dd><p>A call or R expression wrapped in curly braces to evaluate on a
worker. Will have access to any variables defined by <code>vars</code>, as well
as the Worker's <code>globals</code>, <code>packages</code>, and <code>init</code> configuration.
See <code>vignette('eval')</code>.</p>
</dd>
<dt><code>vars</code></dt><dd><p>A named list of variables to make available to <code>expr</code> during
evaluation. Alternatively, an object that can be coerced to a named
list with <code>as.list()</code>, e.g. named vector, data.frame, or environment.
Or a <code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns such an object.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>A named numeric vector indicating the maximum number of
seconds allowed for each state the job passes through, or 'total' to
apply a single timeout from 'submitted' to 'done'. Can also limit the
'starting' state for Workers. A <code style="white-space: pre;">&#8288;function (job)&#8288;</code> can be used in place
of a number. Example: <code>timeout = c(total = 2.5, running = 1)</code>.
See <code>vignette('stops')</code>.</p>
</dd>
<dt><code>hooks</code></dt><dd><p>A named list of functions to run when the Job state changes,
of the form <code>hooks = list(created = function (worker) {...})</code>. Or a
<code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns the same. Names of worker hooks are
typically <code>'created'</code>, <code>'submitted'</code>, <code>'queued'</code>, <code>'dispatched'</code>,
<code>'starting'</code>, <code>'running'</code>, <code>'done'</code>, or <code>'*'</code> (duplicates okay).
See <code>vignette('hooks')</code>.</p>
</dd>
<dt><code>reformat</code></dt><dd><p>Set <code style="white-space: pre;">&#8288;reformat = function (job)&#8288;</code> to define what
<code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code> should return. The default, <code>reformat = NULL</code> passes
<code style="white-space: pre;">&#8288;&lt;Job&gt;$output&#8288;</code> to <code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code> unchanged.
See <code>vignette('results')</code>.</p>
</dd>
<dt><code>signal</code></dt><dd><p>Should calling <code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code> signal on condition objects?
When <code>FALSE</code>, <code style="white-space: pre;">&#8288;&lt;Job&gt;$result&#8288;</code> will return the object without
taking additional action. Setting to <code>TRUE</code> or a character vector of
condition classes, e.g. <code>c('interrupt', 'error', 'warning')</code>, will
cause the equivalent of <code style="white-space: pre;">&#8288;stop(&lt;condition&gt;)&#8288;</code> to be called when those
conditions are produced. Alternatively, a <code style="white-space: pre;">&#8288;function (job)&#8288;</code> that
returns <code>TRUE</code> or <code>FALSE</code>. See <code>vignette('results')</code>.</p>
</dd>
<dt><code>cpus</code></dt><dd><p>How many CPU cores to reserve for this Job.  Or a
<code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns the same. Used to limit the number of
Jobs running simultaneously to respect <code style="white-space: pre;">&#8288;&lt;Queue&gt;$max_cpus&#8288;</code>. Does not
prevent a Job from using more CPUs than reserved.</p>
</dd>
<dt><code>stop_id</code></dt><dd><p>If an existing <a href="#topic+Job">Job</a> in the Queue has the same <code>stop_id</code>,
that Job will be stopped and return an 'interrupt' condition object
as its result. <code>stop_id</code> can also be a <code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns
the <code>stop_id</code> to assign to a given Job. A <code>stop_id</code> of <code>NULL</code>
disables this feature. See <code>vignette('stops')</code>.</p>
</dd>
<dt><code>copy_id</code></dt><dd><p>If an existing <a href="#topic+Job">Job</a> in the Queue has the same <code>copy_id</code>,
the newly submitted Job will become a &quot;proxy&quot; for that earlier Job,
returning whatever result the earlier Job returns. <code>copy_id</code> can also
be a <code style="white-space: pre;">&#8288;function (job)&#8288;</code> that returns the <code>copy_id</code> to assign to a given
Job. A <code>copy_id</code> of <code>NULL</code> disables this feature.
See <code>vignette('stops')</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Arbitrary named values to add to the returned Job object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The new <a href="#topic+Job">Job</a> object.
</p>


<hr>
<a id="method-Queue-submit"></a>



<h4>Method <code>submit()</code></h4>

<p>Adds a Job to the Queue for running on a background process.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$submit(job)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>job</code></dt><dd><p>A <a href="#topic+Job">Job</a> object, as created by <code>Job$new()</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This Queue, invisibly.
</p>


<hr>
<a id="method-Queue-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Blocks until the Queue enters the given state.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$wait(state = "idle", timeout = NULL, signal = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>The name of a Queue state. Typically one of:
</p>

<ul>
<li> <p><code>'*'</code> -        Every time the state changes.
</p>
</li>
<li> <p><code>'.next'</code> -    Only one time, the next time the state changes.
</p>
</li>
<li> <p><code>'starting'</code> - Workers are starting.
</p>
</li>
<li> <p><code>'idle'</code> -     All workers are ready/idle.
</p>
</li>
<li> <p><code>'busy'</code> -     At least one worker is busy.
</p>
</li>
<li> <p><code>'stopped'</code> -  Shutdown is complete.
</p>
</li></ul>
</dd>
<dt><code>timeout</code></dt><dd><p>Stop the Queue if it takes longer than this number of seconds, or <code>NULL</code>.</p>
</dd>
<dt><code>signal</code></dt><dd><p>Raise an error if encountered (will also be recorded in <code style="white-space: pre;">&#8288;&lt;Queue&gt;$cnd&#8288;</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This Queue, invisibly.
</p>


<hr>
<a id="method-Queue-on"></a>



<h4>Method <code>on()</code></h4>

<p>Attach a callback function to execute when the Queue enters <code>state</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$on(state, func)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>The name of a Queue state. Typically one of:
</p>

<ul>
<li> <p><code>'*'</code> -        Every time the state changes.
</p>
</li>
<li> <p><code>'.next'</code> -    Only one time, the next time the state changes.
</p>
</li>
<li> <p><code>'starting'</code> - Workers are starting.
</p>
</li>
<li> <p><code>'idle'</code> -     All workers are ready/idle.
</p>
</li>
<li> <p><code>'busy'</code> -     At least one worker is busy.
</p>
</li>
<li> <p><code>'stopped'</code> -  Shutdown is complete.
</p>
</li></ul>
</dd>
<dt><code>func</code></dt><dd><p>A function that accepts a Queue object as input. Return value
is ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A function that when called removes this callback from the Queue.
</p>


<hr>
<a id="method-Queue-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Stop all jobs and workers.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$stop(reason = "job queue shut down by user", cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>reason</code></dt><dd><p>Passed to <code style="white-space: pre;">&#8288;&lt;Job&gt;$stop()&#8288;</code> for any Jobs currently managed by
this Queue.</p>
</dd>
<dt><code>cls</code></dt><dd><p>Passed to <code style="white-space: pre;">&#8288;&lt;Job&gt;$stop()&#8288;</code> for any Jobs currently managed by
this Queue.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This Queue, invisibly.
</p>



<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3C+3E+25'></span><span id='topic++25+3E+25'></span><span id='topic+later'></span><span id='topic+run_now'></span><span id='topic+availableCores'></span><span id='topic++25...+3E+25'></span><span id='topic++25...T+3E+25'></span><span id='topic+as.promise'></span><span id='topic+promise_all'></span><span id='topic+promise_map'></span><span id='topic+promise_race'></span><span id='topic+promise_reduce'></span><span id='topic+then'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>later</dt><dd><p><code><a href="later.html#topic+later">later</a></code>, <code><a href="later.html#topic+run_now">run_now</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+compound">%&lt;&gt;%</a></code>, <code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>parallelly</dt><dd><p><code><a href="parallelly.html#topic+availableCores">availableCores</a></code></p>
</dd>
<dt>promises</dt><dd><p><code><a href="promises.html#topic+pipes">%...&gt;%</a></code>, <code><a href="promises.html#topic+pipes">%...T&gt;%</a></code>, <code><a href="promises.html#topic+is.promise">as.promise</a></code>, <code><a href="promises.html#topic+promise_all">promise_all</a></code>, <code><a href="promises.html#topic+promise_map">promise_map</a></code>, <code><a href="promises.html#topic+promise_all">promise_race</a></code>, <code><a href="promises.html#topic+promise_reduce">promise_reduce</a></code>, <code><a href="promises.html#topic+then">then</a></code></p>
</dd>
</dl>

<hr>
<h2 id='Worker'>A Background Process</h2><span id='topic+Worker'></span>

<h3>Description</h3>

<p>Where <a href="#topic+Job">Job</a> expressions are evaluated.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>hooks</code></dt><dd><p>A named list of currently registered callback hooks.</p>
</dd>
<dt><code>job</code></dt><dd><p>The currently running Job.</p>
</dd>
<dt><code>ps</code></dt><dd><p>The <code>ps::ps_handle()</code> object for the background process.</p>
</dd>
<dt><code>state</code></dt><dd><p>The Worker's state: <code>'starting'</code>, <code>'idle'</code>, <code>'busy'</code>, or <code>'stopped'</code>.</p>
</dd>
<dt><code>uid</code></dt><dd><p>A short string, e.g. <code>'W11'</code>, that uniquely identifies this Worker.</p>
</dd>
<dt><code>tmp</code></dt><dd><p>The Worker's temporary directory.</p>
</dd>
<dt><code>cnd</code></dt><dd><p>The error that caused the Worker to stop.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Worker-new"><code>Worker$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Worker-print"><code>Worker$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Worker-start"><code>Worker$start()</code></a>
</p>
</li>
<li> <p><a href="#method-Worker-stop"><code>Worker$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-Worker-restart"><code>Worker$restart()</code></a>
</p>
</li>
<li> <p><a href="#method-Worker-on"><code>Worker$on()</code></a>
</p>
</li>
<li> <p><a href="#method-Worker-wait"><code>Worker$wait()</code></a>
</p>
</li>
<li> <p><a href="#method-Worker-run"><code>Worker$run()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Worker-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a background R process for running <a href="#topic+Job">Job</a>s.
</p>


<h5>Usage</h5>

<div class="r"><pre>Worker$new(
  globals = NULL,
  packages = NULL,
  namespace = NULL,
  init = NULL,
  hooks = NULL,
  wait = TRUE,
  timeout = Inf
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>globals</code></dt><dd><p>A named list of variables that all <code style="white-space: pre;">&#8288;&lt;Job&gt;$expr&#8288;</code>s will have
access to. Alternatively, an object that can be coerced to a named
list with <code>as.list()</code>, e.g. named vector, data.frame, or environment.</p>
</dd>
<dt><code>packages</code></dt><dd><p>Character vector of package names to load on workers.</p>
</dd>
<dt><code>namespace</code></dt><dd><p>The name of a package to attach to the worker's
environment.</p>
</dd>
<dt><code>init</code></dt><dd><p>A call or R expression wrapped in curly braces to evaluate on
each worker just once, immediately after start-up. Will have access
to variables defined by <code>globals</code> and assets from <code>packages</code> and
<code>namespace</code>. Returned value is ignored.</p>
</dd>
<dt><code>hooks</code></dt><dd><p>A named list of functions to run when the Worker state
changes, of the form <code>hooks = list(idle = function (worker) {...})</code>.
Names of worker hooks are typically <code>starting</code>, <code>idle</code>, <code>busy</code>,
<code>stopped</code>, or <code>'*'</code> (duplicates okay). See <code>vignette('hooks')</code>.</p>
</dd>
<dt><code>wait</code></dt><dd><p>If <code>TRUE</code>, blocks until the Worker is 'idle'. If <code>FALSE</code>, the
Worker object is returned in the 'starting' state.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>How long to wait for the worker to finish starting (in seconds).
If <code>NA</code>, defaults to the <code>Worker$new()</code> argument.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A Worker object.
</p>


<hr>
<a id="method-Worker-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method for a <code>Worker</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Worker$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments are not used currently.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The Worker, invisibly.
</p>


<hr>
<a id="method-Worker-start"></a>



<h4>Method <code>start()</code></h4>

<p>Restarts a stopped Worker.
</p>


<h5>Usage</h5>

<div class="r"><pre>Worker$start(wait = TRUE, timeout = NA)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>wait</code></dt><dd><p>If <code>TRUE</code>, blocks until the Worker is 'idle'. If <code>FALSE</code>, the
Worker object is returned in the 'starting' state.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>How long to wait for the worker to finish starting (in seconds).
If <code>NA</code>, defaults to the <code>Worker$new()</code> argument.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The Worker, invisibly.
</p>


<hr>
<a id="method-Worker-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Stops a Worker by terminating the background process and calling
<code style="white-space: pre;">&#8288;&lt;Job&gt;$stop(reason)&#8288;</code> on any Jobs currently assigned to this Worker.
</p>


<h5>Usage</h5>

<div class="r"><pre>Worker$stop(reason = "worker stopped by user", cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>reason</code></dt><dd><p>Passed to <code style="white-space: pre;">&#8288;&lt;Job&gt;$stop()&#8288;</code> for any Jobs currently managed by
this Worker.</p>
</dd>
<dt><code>cls</code></dt><dd><p>Passed to <code style="white-space: pre;">&#8288;&lt;Job&gt;$stop()&#8288;</code> for any Jobs currently managed by this
Worker.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The Worker, invisibly.
</p>


<hr>
<a id="method-Worker-restart"></a>



<h4>Method <code>restart()</code></h4>

<p>Restarts a Worker by calling <code style="white-space: pre;">&#8288;&lt;Worker&gt;$stop(reason)&#8288;</code> and
<code style="white-space: pre;">&#8288;&lt;Worker&gt;$start()&#8288;</code> in succession.
</p>


<h5>Usage</h5>

<div class="r"><pre>Worker$restart(
  wait = TRUE,
  timeout = NA,
  reason = "restarting worker",
  cls = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>wait</code></dt><dd><p>If <code>TRUE</code>, blocks until the Worker is 'idle'. If <code>FALSE</code>, the
Worker object is returned in the 'starting' state.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>How long to wait for the worker to finish starting (in seconds).
If <code>NA</code>, defaults to the <code>Worker$new()</code> argument.</p>
</dd>
<dt><code>reason</code></dt><dd><p>Passed to <code style="white-space: pre;">&#8288;&lt;Job&gt;$stop()&#8288;</code> for any Jobs currently managed by
this Worker.</p>
</dd>
<dt><code>cls</code></dt><dd><p>Passed to <code style="white-space: pre;">&#8288;&lt;Job&gt;$stop()&#8288;</code> for any Jobs currently managed by this
Worker.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The Worker, invisibly.
</p>


<hr>
<a id="method-Worker-on"></a>



<h4>Method <code>on()</code></h4>

<p>Attach a callback function to execute when the Worker enters <code>state</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Worker$on(state, func)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>The name of a Worker state. Typically one of:
</p>

<ul>
<li> <p><code>'*'</code> -        Every time the state changes.
</p>
</li>
<li> <p><code>'.next'</code> -    Only one time, the next time the state changes.
</p>
</li>
<li> <p><code>'starting'</code> - Waiting for the background process to load.
</p>
</li>
<li> <p><code>'idle'</code> -     Waiting for Jobs to be <code style="white-space: pre;">&#8288;$run()&#8288;</code>.
</p>
</li>
<li> <p><code>'busy'</code> -     While a Job is running.
</p>
</li>
<li> <p><code>'stopped'</code> -  After <code style="white-space: pre;">&#8288;&lt;Worker&gt;$stop()&#8288;</code> is called.
</p>
</li></ul>
</dd>
<dt><code>func</code></dt><dd><p>A function that accepts a Worker object as input. You can call
<code style="white-space: pre;">&#8288;&lt;Worker&gt;$stop()&#8288;</code> and other <code style="white-space: pre;">&#8288;&lt;Worker&gt;$&#8288;</code> methods.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A function that when called removes this callback from the Worker.
</p>


<hr>
<a id="method-Worker-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Blocks until the Worker enters the given state.
</p>


<h5>Usage</h5>

<div class="r"><pre>Worker$wait(state = "idle", timeout = Inf, signal = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>The name of a Worker state. Typically one of:
</p>

<ul>
<li> <p><code>'*'</code> -        Every time the state changes.
</p>
</li>
<li> <p><code>'.next'</code> -    Only one time, the next time the state changes.
</p>
</li>
<li> <p><code>'starting'</code> - Waiting for the background process to load.
</p>
</li>
<li> <p><code>'idle'</code> -     Waiting for Jobs to be <code style="white-space: pre;">&#8288;$run()&#8288;</code>.
</p>
</li>
<li> <p><code>'busy'</code> -     While a Job is running.
</p>
</li>
<li> <p><code>'stopped'</code> -  After <code style="white-space: pre;">&#8288;&lt;Worker&gt;$stop()&#8288;</code> is called.
</p>
</li></ul>
</dd>
<dt><code>timeout</code></dt><dd><p>Stop the Worker if it takes longer than this number of seconds.</p>
</dd>
<dt><code>signal</code></dt><dd><p>Raise an error if encountered (will also be recorded in <code style="white-space: pre;">&#8288;&lt;Worker&gt;$cnd&#8288;</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This Worker, invisibly.
</p>


<hr>
<a id="method-Worker-run"></a>



<h4>Method <code>run()</code></h4>

<p>Assigns a Job to this Worker for evaluation on the background
process.
</p>


<h5>Usage</h5>

<div class="r"><pre>Worker$run(job)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>job</code></dt><dd><p>A <a href="#topic+Job">Job</a> object, as created by <code>Job$new()</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This Worker, invisibly.
</p>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
