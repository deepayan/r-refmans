<!DOCTYPE html><html lang="en"><head><title>Help for package pricelevels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pricelevels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bilateral.index'><p>Bilateral price indices</p></a></li>
<li><a href='#cpd'><p>CPD and NLCPD methods</p></a></li>
<li><a href='#geks'><p>GEKS method</p></a></li>
<li><a href='#gerardi'><p>Gerardi index</p></a></li>
<li><a href='#gkhamis'><p>Multilateral systems of equations</p></a></li>
<li><a href='#neighbors'><p>Price matrix characteristics</p></a></li>
<li><a href='#pricelevels'><p>Spatial price indices</p></a></li>
<li><a href='#ratios'><p>Calculation of price ratios</p></a></li>
<li><a href='#rdata'><p>Simulate random price and quantity data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Price Level Comparisons</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Price comparisons within or between countries provide an overall measure of the relative difference in prices, often denoted as price levels. This package provides index number methods for such price comparisons (e.g., The World Bank, 2011, &lt;<a href="https://doi.org/10.1596%2F978-0-8213-9728-2">doi:10.1596/978-0-8213-9728-2</a>&gt;). Moreover, it contains functions for sampling and characterizing price data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://joinup.ec.europa.eu/software/page/eupl">EUPL version 1.1</a> | <a href="https://joinup.ec.europa.eu/software/page/eupl">EUPL version 1.2</a> [expanded from: EUPL]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.14.0), minpack.lm (&ge; 1.2-1)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sweinand/pricelevels">https://github.com/sweinand/pricelevels</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sweinand/pricelevels/issues">https://github.com/sweinand/pricelevels/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-22 08:30:33 UTC; Sebastian</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Weinand [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Weinand &lt;s.weinand90@googlemail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-22 08:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bilateral.index'>Bilateral price indices</h2><span id='topic+bilateral.index'></span><span id='topic+bmw'></span><span id='topic+jevons'></span><span id='topic+carli'></span><span id='topic+dutot'></span><span id='topic+harmonic'></span><span id='topic+cswd'></span><span id='topic+laspeyres'></span><span id='topic+paasche'></span><span id='topic+fisher'></span><span id='topic+walsh'></span><span id='topic+toernqvist'></span><span id='topic+medgeworth'></span><span id='topic+theil'></span><span id='topic+svartia'></span><span id='topic+palgrave'></span><span id='topic+drobisch'></span><span id='topic+geolaspeyres'></span><span id='topic+geopaasche'></span><span id='topic+geowalsh'></span><span id='topic+lowe'></span><span id='topic+young'></span><span id='topic+uvalue'></span><span id='topic+davies'></span><span id='topic+banerjee'></span><span id='topic+lehr'></span>

<h3>Description</h3>

<p>Calculation of bilateral price indices. Currently, the following ones are implemented (see below in alphabetic order).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>banerjee(p, r, n, q, base=NULL, settings=list())

bmw(p, r, n, base=NULL, settings=list())

carli(p, r, n, base=NULL, settings=list())

cswd(p, r, n, base=NULL, settings=list())

davies(p, r, n, q, base=NULL, settings=list())

drobisch(p, r, n, q, w=NULL, base=NULL, settings=list())

dutot(p, r, n, base=NULL, settings=list())

fisher(p, r, n, q, w=NULL, base=NULL, settings=list())

geolaspeyres(p, r, n, q, w=NULL, base=NULL, settings=list())

geopaasche(p, r, n, q, w=NULL, base=NULL, settings=list())

geowalsh(p, r, n, q, w=NULL, base=NULL, settings=list())

harmonic(p, r, n, base=NULL, settings=list())

jevons(p, r, n, base=NULL, settings=list())

laspeyres(p, r, n, q, w=NULL, base=NULL, settings=list())

lehr(p, r, n, q, base=NULL, settings=list())

lowe(p, r, n, q, base=NULL, settings=list())

medgeworth(p, r, n, q, base=NULL, settings=list())

paasche(p, r, n, q, w=NULL, base=NULL, settings=list())

palgrave(p, r, n, q, w=NULL, base=NULL, settings=list())

svartia(p, r, n, q, w=NULL, base=NULL, settings=list())

toernqvist(p, r, n, q, w=NULL, base=NULL, settings=list())

theil(p, r, n, q, w=NULL, base=NULL, settings=list())

uvalue(p, r, n, q, base=NULL, settings=list())

walsh(p, r, n, q, w=NULL, base=NULL, settings=list())

young(p, r, n, q, base=NULL, settings=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bilateral.index_+3A_p">p</code></td>
<td>
<p>A numeric vector of prices.</p>
</td></tr>
<tr><td><code id="bilateral.index_+3A_r">r</code>, <code id="bilateral.index_+3A_n">n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td></tr>
<tr><td><code id="bilateral.index_+3A_q">q</code>, <code id="bilateral.index_+3A_w">w</code></td>
<td>
<p>A numeric vector of non-negative quantities <code>q</code> or expenditure share weights <code>w</code> (see details). Either <code>q</code> or <code>w</code> must be provided for weighted indices. If both <code>q</code> and <code>w</code> are provided, <code>q</code> will be used.</p>
</td></tr>
<tr><td><code id="bilateral.index_+3A_base">base</code></td>
<td>
<p>A character specifying the base region to which all price levels are expressed. If <code>NULL</code>, base region is set internally.</p>
</td></tr>
<tr><td><code id="bilateral.index_+3A_settings">settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>chatty</code> : A logical specifying if warnings and info messages should be printed or not. The default is <code>getOption("pricelevels.chatty")</code>.
</p>
</li>
<li> <p><code>connect</code> : A logical specifying if the data should be checked for connectedness or not. The default is <code>getOption("pricelevels.connect")</code>. If the data are not connected, price levels are computed within the biggest block of connected regions or the block of regions to which the <code>base</code> region belongs. See also <code><a href="#topic+connect">connect</a>()</code>.
</p>
</li>
<li> <p><code>plot</code> : A logical specifying if the calculated price levels should be plotted or not. If <code>TRUE</code>, the price ratios of each region are displayed as boxplots and the price levels are added as colored points. The default is <code>getOption("pricelevels.plot")</code>.
</p>
</li>
<li> <p><code>qbase</code> : A character specifying the region <code class="reqn">b</code> whose quantities (and prices) should be used in <code>lowe()</code> and <code>young()</code>. If <code>NULL</code>, prices are averaged and quantities added up for each product, i.e. <code class="reqn">p_i^b=\sum_{r=1}^{R} p_i^r / R</code> and <code class="reqn">q_i^b=\sum_{r=1}^{R} q_i^r</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Before calculations start, missing values are excluded and duplicated observations for <code>r</code> and <code>n</code> are aggregated, that is, duplicated prices <code>p</code> and weights <code>w</code> are averaged and duplicated quantities <code>q</code> added up.
</p>
<p>The weights <code>w</code> must represent expenditure shares defined as <code class="reqn">w_i^r = p_i^r q_i^r / \sum_{j=1}^{N} p_j^r q_j^r</code>. They are internally (re-)normalized such that they add up to 1 for each region <code>r</code>.
</p>


<h3>Value</h3>

<p>A named vector of price levels.</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>ILO, IMF, OECD, UNECE, Eurostat and World Bank (2020). <em>Consumer Price Index Manual: Concepts and Methods</em>. Washington DC: International Monetary Fund.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample complete price data:
set.seed(123)
dt1 &lt;- rdata(R=3, B=1, N=5)

# compute jevons and toernqvist index:
dt1[, jevons(p=price, r=region, n=product, base="1")]
dt1[, toernqvist(p=price, r=region, n=product, q=quantity, base="1")]

# compute lowe index using quantities of region 2:
dt1[, lowe(p=price, r=region, n=product, q=quantity, base="1",
           settings=list(qbase="2"))]

# add price data:
dt2 &lt;- rdata(R=4, B=1, N=4)
dt2[, "region":=factor(region, labels=4:7)]
dt2[, "product":=factor(product, labels=6:9)]
dt &lt;- rbind(dt1, dt2)
dt[, is.connected(r=region, n=product)] # non-connected now

# compute jevons and toernqvist index:
dt[, jevons(p=price, r=region, n=product, base="1")]

# change base region:
dt[, jevons(p=price, r=region, n=product, base="4")]
</code></pre>

<hr>
<h2 id='cpd'>CPD and NLCPD methods</h2><span id='topic+cpd'></span><span id='topic+nlcpd'></span>

<h3>Description</h3>

<p>Function <code>cpd()</code> estimates regional price levels by the Country-Product-Dummy (CPD) method, originally developed by Summers (1973). Auer and Weinand (2022) recently proposed a generalization of the CPD method. This nonlinear CPD method (NLCPD method) is implemented in function <code>nlcpd()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpd(p, r, n, q=NULL, w=NULL, base=NULL, simplify=TRUE, settings=list())

nlcpd(p, r, n, q=NULL, w=NULL, base=NULL, simplify=TRUE, settings=list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpd_+3A_p">p</code></td>
<td>
<p>A numeric vector of prices.</p>
</td></tr>
<tr><td><code id="cpd_+3A_r">r</code>, <code id="cpd_+3A_n">n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td></tr>
<tr><td><code id="cpd_+3A_q">q</code>, <code id="cpd_+3A_w">w</code></td>
<td>
<p>A numeric vector of non-negative quantities <code>q</code> or weights <code>w</code>. By default, no weights are used in the regression (<code>q=NULL</code> and <code>w=NULL</code>). While <code>w</code> can be any weights considered as appropriate for weighted regression, <code>q</code> will result in an expenditure share weighted regression (see details). If both <code>q</code> and <code>w</code> are provided, <code>q</code> will be used.</p>
</td></tr>
<tr><td><code id="cpd_+3A_base">base</code></td>
<td>
<p>A character specifying the base to which the estimated logarithmic regional price levels are expressed. When <code>NULL</code>, they refer to the (unweighted) regional average, similar to <code><a href="stats.html#topic+contr.sum">contr.sum</a></code>.</p>
</td></tr>
<tr><td><code id="cpd_+3A_simplify">simplify</code></td>
<td>
<p>A logical indicating whether the full regression-object should be provided (<code>FALSE</code>) or a named vector of estimated regional price levels (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cpd_+3A_settings">settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>chatty</code> : A logical specifying if warnings and info messages should be printed or not. The default is <code>getOption("pricelevels.chatty")</code>.
</p>
</li>
<li> <p><code>connect</code> : A logical specifying if the data should be checked for connectedness or not. The default is <code>getOption("pricelevels.connect")</code>. If the data are not connected, price levels are computed within the biggest block of connected regions or the block of regions to which the <code>base</code> region belongs. See also <code><a href="#topic+connect">connect</a>()</code>.
</p>
</li>
<li> <p><code>norm.weights</code> : A logical specifying if the weights <code>w</code> should be renormalized such that they add up to 1 for each region <code>r</code> or not. The default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>plot</code> : A logical specifying if the calculated price levels should be plotted or not. If <code>TRUE</code>, the price ratios of each region are displayed as boxplots and the price levels are added as colored points. The default is <code>getOption("pricelevels.plot")</code>.
</p>
</li>
<li> <p><code>self.start</code> : Only if <code>par=NULL</code>, the strategy how parameter start values are internally derived by <code>nlcpd()</code>. Currently, values <code>s1</code>, <code>s2</code> and <code>s3</code> are allowed. For <code>s1</code>, simple price averages across products and regions are used as start values, while these are derived by the CPD method for strategies <code>s2</code> and <code>s3</code>. Start values for <code>delta</code> are either set to 1 or derived by their first-order condition if <code>s3</code>. By default, <code>self.start='s1'</code>.

</p>
</li>
<li> <p><code>use.jac</code> : A logical indicating if the jacobian matrix should be used by <code>nlcpd()</code> for the nonlinear optimization or not. The default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>w.delta</code> : A named vector of weights for the <code>delta</code>-parameter (see Details). Vector length must be equal to the number of products, while names must match product names. If not supplied, <code class="reqn">\delta_i</code> weights are derived internally by <code>nlcpd()</code> from the weights <code>w</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cpd_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="minpack.lm.html#topic+nls.lm">nls.lm</a></code>, typically arguments <code>control</code>, <code>par</code>, <code>upper</code>, and <code>lower</code>. For <code>par</code>, <code>upper</code>, and <code>lower</code>, vectors must have names for each parameter separated by a dot, e.g., <code>lnP.1</code>, <code>pi.2</code>, or <code>delta.3</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CPD method is a linear regression model that explains the logarithmic price of product <code class="reqn">i</code> in region <code class="reqn">r</code>, <code class="reqn">\ln p_i^r</code>, by the general product price, <code class="reqn">\ln \pi_i</code>, and the overall price level, <code class="reqn">\ln P^r</code>:
</p>
<p style="text-align: center;"><code class="reqn">\ln p_i^r = \ln \pi_i + \ln P^r + u_i^r</code>
</p>

<p>The NLCPD method inflates the CPD model by product-specific elasticities <code class="reqn">\delta_i</code>:
</p>
<p style="text-align: center;"><code class="reqn">\ln p_i^r = \ln \pi_i + \delta_i \ln P^r + u_i^r</code>
</p>

<p>Note that both the CPD and the NLCPD method require a normalization of the estimated price levels <code class="reqn">\widehat{\ln P^r}</code> to avoid multicollinearity. If <code>base=NULL</code>, normalization <code class="reqn">\sum_{r=1}^{R} \widehat{\ln P^r}=0</code> is used in both functions; otherwise, one price level is set to 0. The NLCPD method additionally imposes the restriction <code class="reqn">\sum_{i=1}^{N} w_i \widehat{\delta_i}=1</code>, where the weights <code class="reqn">w_i</code> can be defined by <code>settings$w.delta</code>. In <code>nlcpd()</code>, it is always the parameter <code class="reqn">\widehat{\delta_1}</code> that is derived residually from this restriction.
</p>
<p>Before calculations start, missing values are excluded and duplicated observations for <code>r</code> and <code>n</code> are aggregated, that is, duplicated prices <code>p</code> and weights <code>w</code> are averaged and duplicated quantities <code>q</code> added up.
</p>
<p>If <code>q</code> is provided, expenditure shares are derived as <code class="reqn">w_i^r = p_i^r q_i^r / \sum_{j=1}^{N} p_j^r q_j^r</code> and used as weights in the regression. If only <code>w</code> is provided, the weights <code>w</code> are (re-)normalized by default. If the weights <code>w</code> do not represent expenditure shares, the (re-)normalization can be turned off by <code>settings=list(norm.weights=FALSE)</code>.
</p>


<h3>Value</h3>

<p>For <code>simplify=TRUE</code>, a named vector of (unlogged) regional price levels. Otherwise, for <code>cpd()</code>, a <code>lm</code>-object containing the full regression output, and for <code>nlcpd()</code> the full output of <code>nls.lm()</code> plus element <code>w.delta</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>Auer, L. v. and Weinand, S. (2022). <em>A Nonlinear Generalization of the Country-Product-
Dummy Method.</em> Discussion Paper 2022/45, Deutsche Bundesbank.
</p>
<p>Summers, R. (1973). International Price Comparisons based upon Incomplete Data. <em>Review of Income and Wealth</em>, 19 (1), 1-16.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+dummy.coef">dummy.coef</a></code>, <code><a href="minpack.lm.html#topic+nls.lm">nls.lm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># sample complete price data:
set.seed(123)
R &lt;- 3 # number of regions
B &lt;- 1 # number of product groups
N &lt;- 5 # number of products
dt1 &lt;- rdata(R=R, B=B, N=N)

# compute expenditure share weighted cpd and nlcpd index:
dt1[, cpd(p=price, r=region, n=product, q=quantity)]
dt1[, nlcpd(p=price, r=region, n=product, q=quantity)]

# set individual start values in nlcpd():
par.init &lt;- list("lnP"=setNames(rep(0, R), 1:R),
                 "pi"=setNames(rep(2, N), 1:N),
                 "delta"=setNames(rep(1, N), 1:N))
dt1[, nlcpd(p=price, r=region, n=product, q=quantity, par=par.init)]

# use lower and upper bounds on parameters:
dt1[, nlcpd(p=price, r=region, n=product, q=quantity,
            lower=unlist(par.init)-0.1, upper=unlist(par.init)+0.1)]

# change internal calculation of start values:
dt1[, nlcpd(p=price, r=region, n=product, q=quantity, settings=list(self.start="s2"))]

# add price data:
dt2 &lt;- rdata(R=4, B=1, N=4)
dt2[, "region":=factor(region, labels=4:7)]
dt2[, "product":=factor(product, labels=6:9)]
dt &lt;- rbind(dt1, dt2)
dt[, is.connected(r=region, n=product)] # non-connected now

# compute expenditure share weighted cpd and nlcpd index:
dt[, cpd(p=price, r=region, n=product, q=quantity, base="1")]
dt[, nlcpd(p=price, r=region, n=product, q=quantity, base="1")]

# compare with toernqvist index:
dt[, toernqvist(p=price, r=region, n=product, q=quantity, base="1")]


# computational speed in nlcpd() usually increases if use.jac=TRUE:
set.seed(123)
dt3 &lt;- rdata(R=20, B=1, N=30)
system.time(m1 &lt;- dt3[, nlcpd(p=price, r=region, n=product, q=quantity,
                              settings=list(use.jac=FALSE), simplify=FALSE,
                              control=minpack.lm::nls.lm.control("maxiter"=200))])
system.time(m2 &lt;- dt3[, nlcpd(p=price, r=region, n=product, q=quantity,
                              settings=list(use.jac=TRUE), simplify=FALSE,
                              control=minpack.lm::nls.lm.control("maxiter"=200))])
all.equal(m1$par, m2$par, tol=1e-05)

</code></pre>

<hr>
<h2 id='geks'>GEKS method</h2><span id='topic+geks'></span><span id='topic+index.pairs'></span>

<h3>Description</h3>

<p>Function <code>index.pairs()</code> computes bilateral index numbers for all pairs of regions. Based on that, function <code>geks()</code> derives regional price levels using the GEKS method proposed by Gini (1924, 1931), Elteto and Koves (1964), and Szulc (1964).</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.pairs(p, r, n, q=NULL, w=NULL, settings=list())

geks(p, r, n, q=NULL, w=NULL, base=NULL, simplify=TRUE, settings=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geks_+3A_p">p</code></td>
<td>
<p>A numeric vector of prices.</p>
</td></tr>
<tr><td><code id="geks_+3A_r">r</code>, <code id="geks_+3A_n">n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td></tr>
<tr><td><code id="geks_+3A_q">q</code>, <code id="geks_+3A_w">w</code></td>
<td>
<p>A numeric vector of non-negative quantities <code>q</code> or expenditure share weights <code>w</code> (see details) to be used in the computation of weighted bilateral index numbers. Can be <code>NULL</code>, if the index formula specified in <code>type</code> does not require quantities or weights. If both <code>q</code> and <code>w</code> are provided, <code>q</code> will be used.</p>
</td></tr>
<tr><td><code id="geks_+3A_base">base</code></td>
<td>
<p>A character specifying the base region to which all price levels are expressed. When <code>NULL</code>, they refer to the (unweighted) regional average.</p>
</td></tr>
<tr><td><code id="geks_+3A_simplify">simplify</code></td>
<td>
<p>A logical indicating whether the full regression-object should be provided (<code>FALSE</code>) or a named vector of estimated regional price levels (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="geks_+3A_settings">settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>chatty</code> : A logical specifying if warnings and info messages should be printed or not. The default is <code>getOption("pricelevels.chatty")</code>.
</p>
</li>
<li> <p><code>connect</code> : A logical specifying if the data should be checked for connectedness or not. The default is <code>getOption("pricelevels.connect")</code> for <code>geks()</code> and <code>FALSE</code> for <code>index.pairs()</code>. If the data are not connected, price levels are computed within the biggest block of connected regions or the block of regions to which the <code>base</code> region belongs. See also <code><a href="#topic+connect">connect</a>()</code>.
</p>
</li>
<li> <p><code>plot</code> : A logical specifying if the calculated price levels should be plotted or not. If <code>TRUE</code>, the price ratios of each region are displayed as boxplots and the price levels are added as colored points. The default is <code>getOption("pricelevels.plot")</code>. Used only by <code>geks()</code>.
</p>
</li>
<li> <p><code>all.pairs</code> : Logical indicating whether index numbers should be computed for all region pairs (<code>TRUE</code>) or only for non-redundant ones (<code>FALSE</code>), e.g. the index number of regions <code>AB</code> should be the same as the inverse of <code>BA</code>. The default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>type</code> : A character specifying the index method(s) used to aggregate prices into bilateral price indices for each pair of regions (first step of GEKS). See <code><a href="#topic+bilateral.index">bilateral.index</a></code> for allowed values. Multiple choices allowed. The default is <code>jevons</code>.
</p>
</li>
<li> <p><code>wmethod</code> : the weighting method (second step of GEKS). Allowed values are <code>none</code> for equal weighting of all bilateral price indices, <code>obs</code> for weighting the bilateral price indices according to the underlying number of intersecting observations, or <code>shares</code> for weighting according to the intersecting expenditure shares. The default is <code>none</code>. Used only by <code>geks()</code>.
</p>
</li>
<li> <p><code>qbase</code> : relevant only for <code>type='lowe'</code> and <code>type='young'</code>, see <code><a href="#topic+bilateral.index">bilateral.index</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The GEKS index is a two-step approach. First, prices are aggregated into bilateral index numbers using the index given in <code>type</code>. This is done for all pairs of regions via function <code>index.pairs()</code>. Second, these bilateral index numbers are transformed into a set of multilateral, transitive index numbers.
</p>
<p>Note that the quantities <code>q</code> or weights <code>w</code> are used within the aggregation of prices into index numbers (first stage) while the subsequent transformation of these index numbers (second stage) usually does not rely on any weights (but can if specified in <code>settings$wmethod</code>).
</p>
<p>Before calculations start, missing values are excluded and duplicated observations for <code>r</code> and <code>n</code> are aggregated, that is, duplicated prices <code>p</code> and weights <code>w</code> are averaged and duplicated quantities <code>q</code> added up.
</p>
<p>The weights <code>w</code> must represent expenditure shares defined as <code class="reqn">w_i^r = p_i^r q_i^r / \sum_{j=1}^{N} p_j^r q_j^r</code>. They are internally (re-)normalized such that they add up to 1 for each region <code>r</code>.
</p>


<h3>Value</h3>

<p>For <code>index.pairs()</code>, a data.table with variables <code>base</code> (the base region), <code>region</code> (the comparison region), and <code>eval(settings$type)</code> (the price level between the two regions).
</p>
<p>For <code>geks()</code>, a named vector or matrix of (unlogged) regional price levels if <code>simplify=TRUE</code>. Otherwise, for <code>simplify=FALSE</code>, a <code>lm</code>-object containing the full regression output.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>Gini, C. (1924). Quelques Considerations au Sujet de la Construction des Nombres Indices des Prix et des Questions Analogues. <em>Mentron</em>, 4 (1), 3-162.
</p>
<p>Gini, C. (1931). On the Circular Test of Index Numbers. <em>International Statistical Review</em>, 9 (2), 3-25.
</p>
<p>Elteto, O. and Koves, P. (1964). On a Problem of Index Number Computation Relating to International Comparison. <em>Statisztikai Szemle</em>, 42, 507-518.
</p>
<p>Szulc, B. J. (1964). Indices for Multiregional Comparisons. <em>Przeglad Statystyczny</em>, 3, 239-254.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bilateral.index">bilateral.index</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># example data:
set.seed(123)
dt1 &lt;- rdata(R=3, B=1, N=5)

### Index pairs

# matrix of bilateral index numbers:
Pje &lt;- dt1[, index.pairs(p=price, r=region, n=product, settings=list(type="jevons"))]
# if the underlying index satisfies the country-reversal
# test (like the Jevons index), the price index numbers of
# the upper-right triangle are the same as the inverse of
# the price index numbers of the lower-left triangle.
all.equal(Pje$jevons[3], 1/Pje$jevons[7]) # true
# hence, one could set all.pairs=FALSE without loosing any
# information. however, this is no longer true for indices
# that do not satisfy this test (like the Carli index):
Pca &lt;- dt1[, index.pairs(p=price, r=region, n=product, settings=list(type="carli"))]
all.equal(Pca$carli[3], 1/Pca$carli[7]) # false

### GEKS method

# for complete price data (no gaps), the jevons index is transitive.
# hence, no adjustment is needed by the geks approach, which is
# why the index numbers are the same:
all.equal(
  dt1[, geks(p=price, r=region, n=product, base="1", settings=list(type="jevons"))],
  dt1[, jevons(p=price, r=region, n=product, base="1")]
) # true

# this is no longer true when there are gaps in the data:
dt1.gaps &lt;- dt1[!rgaps(region, product, amount=0.25), ]
all.equal(
  dt1.gaps[, geks(p=price, r=region, n=product, base="1", settings=list(type="jevons"))],
  dt1.gaps[, jevons(p=price, r=region, n=product, base="1")]
) # now, differences

# weighting at the second step of GEKS can be done with respect
# to the intersection of products for each pair of region:
dt1.gaps[, geks(p=price, r=region, n=product, base="1",
                settings=list(type="jevons", wmethod="obs"))]

# add price data:
dt2 &lt;- rdata(R=4, B=1, N=4)
dt2[, "region":=factor(region, labels=4:7)]
dt2[, "product":=factor(product, labels=6:9)]
dt &lt;- rbind(dt1, dt2)
dt[, is.connected(r=region, n=product)] # non-connected now

# compute all index pairs and geks:
require(data.table)
as.matrix(dcast(
  data=dt[, index.pairs(p=price, r=region, n=product)],
  formula=base~region,
  value.var="jevons"), rownames="base")
dt[, geks(p=price, r=region, n=product, base="1", settings=list(type="jevons"))]
</code></pre>

<hr>
<h2 id='gerardi'>Gerardi index</h2><span id='topic+gerardi'></span>

<h3>Description</h3>

<p>Calculation of regional price levels using the multilateral Gerardi index (Eurostat, 1978).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gerardi(p, r, n, q, w=NULL, base=NULL, simplify=TRUE, settings=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gerardi_+3A_p">p</code></td>
<td>
<p>A numeric vector of prices.</p>
</td></tr>
<tr><td><code id="gerardi_+3A_r">r</code>, <code id="gerardi_+3A_n">n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td></tr>
<tr><td><code id="gerardi_+3A_q">q</code>, <code id="gerardi_+3A_w">w</code></td>
<td>
<p>A numeric vector of non-negative quantities <code>q</code> or expenditure share weights <code>w</code> (see details). If both <code>q</code> and <code>w</code> are provided, <code>q</code> will be used.</p>
</td></tr>
<tr><td><code id="gerardi_+3A_base">base</code></td>
<td>
<p>A character specifying the base region to which all price levels are expressed. When <code>NULL</code>, they refer to the (unweighted) regional average.</p>
</td></tr>
<tr><td><code id="gerardi_+3A_simplify">simplify</code></td>
<td>
<p>A logical indicating whether a named vector of estimated regional price levels (<code>TRUE</code>) should be returned, or also the average product prices.</p>
</td></tr>
<tr><td><code id="gerardi_+3A_settings">settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>chatty</code> : A logical specifying if warnings and info messages should be printed or not. The default is <code>getOption("pricelevels.chatty")</code>.
</p>
</li>
<li> <p><code>connect</code> : A logical specifying if the data should be checked for connectedness or not. The default is <code>getOption("pricelevels.connect")</code>. If the data are not connected, price levels are computed within the biggest block of connected regions or the block of regions to which the <code>base</code> region belongs. See also <code><a href="#topic+connect">connect</a>()</code>.
</p>
</li>
<li> <p><code>plot</code> : A logical specifying if the calculated price levels should be plotted or not. If <code>TRUE</code>, the price ratios of each region are displayed as boxplots and the price levels are added as colored points. The default is <code>getOption("pricelevels.plot")</code>.
</p>
</li>
<li> <p><code>variant</code> : for <code>original</code>, the international prices are calculated as unweighted geometric means. This is the original approach. With <code>adjusted</code>, the international prices are calculated as weighted geometric means.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Before calculations start, missing values are excluded and duplicated observations for <code>r</code> and <code>n</code> are aggregated, that is, duplicated prices <code>p</code> and weights <code>w</code> are averaged and duplicated quantities <code>q</code> added up.
</p>
<p>The weights <code>w</code> must represent expenditure shares defined as <code class="reqn">w_i^r = p_i^r q_i^r / \sum_{j=1}^{N} p_j^r q_j^r</code>. They are internally (re-)normalized such that they add up to 1 for each region <code>r</code>.
</p>


<h3>Value</h3>

<p>For <code>simplify=TRUE</code>, a named vector of regional price levels. Otherwise, for <code>simplify=FALSE</code>, a list containing the named vector of international product prices and regional price levels.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>Balk, B. M. (1996). A comparison of ten methods for multilateral international
price and volume comparisons. <em>Journal of Official Statistics</em>, 12 (1), 199-222.
</p>
<p>Eurostat (1978), <em>Comparison in real values of the aggregates of ESA 1975</em>, Publications Office, Luxembourg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(data.table)

# example data:
set.seed(123)
dt1 &lt;- rdata(R=3, B=1, N=5)

# Gerardi price index:
dt1[, gerardi(p=price, q=quantity, r=region, n=product)]

# add price data:
dt2 &lt;- rdata(R=4, B=1, N=4)
dt2[, "region":=factor(region, labels=4:7)]
dt2[, "product":=factor(product, labels=6:9)]
dt &lt;- rbind(dt1, dt2)
dt[, is.connected(r=region, n=product)] # non-connected now

# compute expenditure share weights:
dt[, "share" := price*quantity/sum(price*quantity), by="region"]

# Gerardi index with quantites or expenditure share weights:
dt[, gerardi(p=price, q=quantity, r=region, n=product)]
dt[, gerardi(p=price, w=share, r=region, n=product)]
</code></pre>

<hr>
<h2 id='gkhamis'>Multilateral systems of equations</h2><span id='topic+gkhamis'></span><span id='topic+ikle'></span><span id='topic+rao'></span><span id='topic+rhajargasht'></span>

<h3>Description</h3>

<p>Calculation of regional price levels using the
</p>

<ul>
<li><p> Geary-Khamis method (Geary, 1958; Khamis, 1972): <code>gkhamis()</code>
</p>
</li>
<li><p> Iklé method (Ikle, 1972; Dikhanov, 1997; Balk, 1996): <code>ikle()</code>
</p>
</li>
<li><p> Rao system (Rao, 1990): <code>rao()</code>
</p>
</li>
<li><p> Rao-Hajargasht method (Rao and Hajargasht, 2016): <code>rhajargasht()</code>
</p>
</li></ul>

<p>All methods have in common that they set up a system of interrelated equations of international product prices and price levels, which must be solved iteratively. It is only the definition of the international product prices and price levels that differ between the methods (see package vignette).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gkhamis(p, r, n, q=NULL, base=NULL, simplify=TRUE, settings=list())

ikle(p, r, n, q=NULL, w=NULL, base=NULL, simplify=TRUE, settings=list())

rao(p, r, n, q=NULL, w=NULL, base=NULL, simplify=TRUE, settings=list())

rhajargasht(p, r, n, q=NULL, w=NULL, base=NULL, simplify=TRUE, settings=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gkhamis_+3A_p">p</code></td>
<td>
<p>A numeric vector of prices.</p>
</td></tr>
<tr><td><code id="gkhamis_+3A_r">r</code>, <code id="gkhamis_+3A_n">n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td></tr>
<tr><td><code id="gkhamis_+3A_q">q</code>, <code id="gkhamis_+3A_w">w</code></td>
<td>
<p>A numeric vector of non-negative quantities <code>q</code> or expenditure share weights <code>w</code> (see details). If both <code>q</code> and <code>w</code> are provided, <code>q</code> will be used. Note that <code>gkhamis()</code> does not use weights <code>w</code>.</p>
</td></tr>
<tr><td><code id="gkhamis_+3A_base">base</code></td>
<td>
<p>A character specifying the base region to which all price levels are expressed. When <code>NULL</code>, they refer to the (unweighted) regional average.</p>
</td></tr>
<tr><td><code id="gkhamis_+3A_simplify">simplify</code></td>
<td>
<p>A logical indicating whether a named vector of estimated regional price levels (<code>TRUE</code>) should be returned, or also the average product prices.</p>
</td></tr>
<tr><td><code id="gkhamis_+3A_settings">settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>chatty</code> : A logical specifying if warnings and info messages should be printed or not. The default is <code>getOption("pricelevels.chatty")</code>.
</p>
</li>
<li> <p><code>connect</code> : A logical specifying if the data should be checked for connectedness or not. The default is <code>getOption("pricelevels.connect")</code> for <code>geks()</code> and <code>FALSE</code> for <code>index.pairs()</code>. If the data are not connected, price levels are computed within the biggest block of connected regions or the block of regions to which the <code>base</code> region belongs. See also <code><a href="#topic+connect">connect</a>()</code>.
</p>
</li>
<li> <p><code>plot</code> : A logical specifying if the calculated price levels should be plotted or not. If <code>TRUE</code>, the price ratios of each region are displayed as boxplots and the price levels are added as colored points. The default is <code>getOption("pricelevels.plot")</code>.
</p>
</li>
<li> <p><code>solve</code> : the method used for solving the system of equations. The default for all indices is <code>iterative</code> for iterative solving until convergence. For <code>gkhamis()</code>, the analytical solution proposed by Diewert (1999) is also allowed by setting to <code>matrix</code>.
</p>
</li>
<li> <p><code>tol</code> : the tolerance level when convergence is achieved if <code>type="iterative"</code>. The default is <code>1e-9</code>.
</p>
</li>
<li> <p><code>max.iter</code> : the maximum number of iterations if <code>type="iterative"</code>. The default is <code>99</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>In their original form, the above index methods use quantities (or weights). However, Rao and Hajargasht (2016, p. 417) have shown that similar solutions exist for the unweighted definitions of international product prices and price levels. This is implemented in the functions where
</p>

<ul>
<li> <p><code>gkhamis(q=NULL)</code> corresponds to a multilateral Dutot index;
</p>
</li>
<li> <p><code>ikle(q=NULL, w=NULL)</code> to a multilateral Harmonic mean index;
</p>
</li>
<li> <p><code>rao(q=NULL, w=NULL)</code> to a multilateral Jevons index;
</p>
</li>
<li> <p><code>rhajargasht(q=NULL, w=NULL)</code> to a multilateral Carli index.
</p>
</li></ul>

<p>Before calculations start, missing values are excluded and duplicated observations for <code>r</code> and <code>n</code> are aggregated, that is, duplicated prices <code>p</code> and weights <code>w</code> are averaged and duplicated quantities <code>q</code> added up.
</p>
<p>The weights <code>w</code> must represent expenditure shares defined as <code class="reqn">w_i^r = p_i^r q_i^r / \sum_{j=1}^{N} p_j^r q_j^r</code>. They are internally (re-)normalized such that they add up to 1 for each region <code>r</code>.
</p>


<h3>Value</h3>

<p>For <code>simplify=TRUE</code>, a named vector of regional price levels. Otherwise, for <code>simplify=FALSE</code>, a list containing the named vector of international product prices and regional price levels, the number of iterations until convergence, and the achieved difference at convergence.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>Balk, B. M. (1996). A comparison of ten methods for multilateral international
price and volume comparisons. <em>Journal of Official Statistics</em>, 12 (1), 199-222.
</p>
<p>Diewert, W. E. (1999). Axiomatic and Economic Approaches to International Comparisons. In: <em>International and Interarea Comparisons of Income, Output and Prices</em>, edited by A. Heston and R. E Lipsey. Chicago: The University of Chicago Press.
</p>
<p>Dikhanov, Y. (1994). Sensitivity of PPP-based income estimates to the choice of aggregation procedures. The World Bank, Washington D.C., June 10, paper presented at 23rd General Conference of the International Association for Research in Income and Wealth, St. Andrews, Canada.
</p>
<p>Geary, R. C. (1958). A Note on the Comparison of Exchange Rates and Purchasing
Power Between Countries. <em>Journal of the Royal Statistical Society. Series A
(General)</em>, 121 (1), 97–99.
</p>
<p>Ikle, D. M. (1972). A new approach to the index number problem. <em>The Quarterly Journal of Economics</em>, 86 (2), 188-211.
</p>
<p>Khamis, S. H. (1972). A New System of Index Numbers for National and International
Purposes. <em>Journal of the Royal Statistical Society. Series A (General)</em>,
135 (1), 96–121.
</p>
<p>Rao, D. S. P. (1990). A system of log-change index numbers for multilateral comparisons. In: <em>Comparisons of prices and real products in Latin America. Contributions to Economic Analysis Series</em>, edited by Salazar-Carrillo and Rao. Amsterdam: North-Holland Publishing Company.
</p>
<p>Rao, D. S. P. and G. Hajargasht (2016). Stochastic approach to computation of purchasing power parities in the International Comparison Program. <em>Journal of Econometrics</em>, 191 (2016), 414-425.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(data.table)

# example data:
set.seed(123)
dt1 &lt;- rdata(R=3, B=1, N=5)

# Gery-Khamis price index can be obtained in two ways:
dt1[, gkhamis(p=price, q=quantity, r=region, n=product, settings=list(solve="iterative"))]
dt1[, gkhamis(p=price, q=quantity, r=region, n=product, settings=list(solve="matrix"))]

# gkhamis(), ikle() and gerardi() yield same results if quantites the same:
dt1[, "quantity2" := 1000*rleidv(product)]
dt1[, gkhamis(p=price, r=region, n=product, q=quantity2)]
dt1[, gerardi(p=price, r=region, n=product, q=quantity2)]
dt1[, ikle(p=price, r=region, n=product, q=quantity2)]
dt1[, "quantity2":=NULL]

# add price data:
dt2 &lt;- rdata(R=4, B=1, N=4)
dt2[, "region":=factor(region, labels=4:7)]
dt2[, "product":=factor(product, labels=6:9)]
dt &lt;- rbind(dt1, dt2)
dt[, is.connected(r=region, n=product)] # non-connected now

# compute expenditure share weights:
dt[, "share" := price*quantity/sum(price*quantity), by="region"]

# Ikle index with quantites or expenditure share weights:
dt[, ikle(p=price, q=quantity, r=region, n=product)]
dt[, ikle(p=price, w=share, r=region, n=product)]
</code></pre>

<hr>
<h2 id='neighbors'>Price matrix characteristics</h2><span id='topic+neighbors'></span><span id='topic+connect'></span><span id='topic+comparisons'></span><span id='topic+is.connected'></span><span id='topic+sparsity'></span>

<h3>Description</h3>

<p>A price matrix or price tableau typically consists of prices for multiple products and regions.
</p>
<p>Function <code>is.connected()</code> checks if all regions in the price matrix are connected either directly or indirectly by some bridging region. <code>neighbors()</code> divides the regions into groups of connected regions. <code>connect()</code> is a simple wrapper of <code>neighbors()</code>, connecting some price data by relying on the group with the maximum number of observations. <code>comparisons()</code> derives the amount of bilateral (or pairwise) comparisons that could be computed for each of those groups of regions. <code>sparsity()</code> indicates the sparsity of the price matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.connected(r, n)

neighbors(r, n, simplify=FALSE)

connect(r, n)

comparisons(r, n, ngbs=NULL)

sparsity(r, n, useable=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighbors_+3A_r">r</code>, <code id="neighbors_+3A_n">n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td></tr>
<tr><td><code id="neighbors_+3A_simplify">simplify</code></td>
<td>
<p>A logical indicating whether the results should be simplified to a factor of group identifiers (<code>TRUE</code>) or not (<code>FALSE</code>). In the latter case the output will be a list of connected regions.</p>
</td></tr>
<tr><td><code id="neighbors_+3A_ngbs">ngbs</code></td>
<td>
<p>Either <code>NULL</code> or a list of connected regions derived from <code>neighbors()</code>. The latter case will allow for small performance gains in terms of processing times.</p>
</td></tr>
<tr><td><code id="neighbors_+3A_useable">useable</code></td>
<td>
<p>A logical indicating whether only observations should be taken into account that could be used for interregional comparisons (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following World Bank (2013, p. 98), a &quot;price tableau is said to be connected if the price data are such that it is not possible to place the countries in two groups in which no item priced by any country in one group is priced by any other country in the second group&quot;.
</p>


<h3>Value</h3>

<p>Function <code>is.connected()</code> prints a single logical indicating the connectedness while <code>connect()</code> returns a logical vector of the same length as the input vectors. <code>neighbors()</code> gives a list or vector of connected regions. <code>sparsity()</code> returns a single numeric showing the sparsity of the price matrix. <code>comparisons()</code> outputs a data.table with the following variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>group_id</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> group identifier</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>group_members</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> regions belonging to that group</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>group_size</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of regions belonging to that group</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>total</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of (non-redundant) regional pairs that could be computed, following the formula <code class="reqn">R*(R-1)/2</code></td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>direct</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of regional pairs that traces back to direct connections, e.g. when two regions have priced the same product </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>indirect</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of regional pairs that traces back to indirect connections, e.g. when two regions are connected via a third bridging region</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>n_obs</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of observations containing interregional information</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>World Bank (2013). <em>Measuring the Real Size of the World Economy: The Framework, Methodology, and Results of the International Comparison Program</em>. Washington, D.C.: World Bank.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### connected price data:
set.seed(123)
dt1 &lt;- rdata(R=4, B=1, N=3)

dt1[, sparsity(r = region, n = product)]
dt1[, is.connected(r = region, n = product)] # true
dt1[, neighbors(r = region, n = product, simplify = TRUE)]
dt1[, comparisons(r = region, n = product)]

### non-connected price data:
dt2 &lt;- data.table::data.table(
          "region" = c("a","a","h","b","a","a","c","c","d","e","e","f",NA),
          "product" = c(1,1,"bla",1,2,3,3,4,4,5,6,6,7),
          "price" = runif(13,5,6),
          stringsAsFactors = TRUE)

dt2[, is.connected(r = region, n = product)] # false
with(dt2, neighbors(r=region, n=product))
dt2[, comparisons(region, product)]
# note that the region-product-combination [NA,7] is dropped
# from the output, while [a,2] and [e,5] are not included in
# the calculation of 'n_obs' as both are not useable in terms
# of regional price comparisons. also sparsity() takes this
# into account, if wanted:
dt2[, sparsity(region, product, useable=TRUE)]
dt2[, sparsity(region, product)]

# connect the price data:
dt2[connect(r=region, n=product),]
</code></pre>

<hr>
<h2 id='pricelevels'>Spatial price indices</h2><span id='topic+pricelevels'></span><span id='topic+list.indices'></span>

<h3>Description</h3>

<p>Calculation of multiple spatial price indices at once.</p>


<h3>Usage</h3>

<pre><code class='language-R'># list all available price indices:
list.indices()

# compute all price indices:
pricelevels(p, r, n, q=NULL, w=NULL, base=NULL, settings=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pricelevels_+3A_p">p</code></td>
<td>
<p>A numeric vector of prices.</p>
</td></tr>
<tr><td><code id="pricelevels_+3A_r">r</code>, <code id="pricelevels_+3A_n">n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td></tr>
<tr><td><code id="pricelevels_+3A_q">q</code>, <code id="pricelevels_+3A_w">w</code></td>
<td>
<p>A numeric vector of non-negative quantities <code>q</code> or expenditure share weights <code>w</code> (see details). Either <code>q</code> or <code>w</code> must be provided for weighted indices. If both <code>q</code> and <code>w</code> are provided, <code>q</code> will be used.</p>
</td></tr>
<tr><td><code id="pricelevels_+3A_base">base</code></td>
<td>
<p>A character specifying the base region to which all price levels are expressed. If <code>NULL</code>, base region is set internally.</p>
</td></tr>
<tr><td><code id="pricelevels_+3A_settings">settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>chatty</code> : A logical specifying if warnings and info messages should be printed or not. The default is <code>getOption("pricelevels.chatty")</code>.
</p>
</li>
<li> <p><code>connect</code> : A logical specifying if the data should be checked for connectedness or not. The default is <code>getOption("pricelevels.connect")</code>. If the data are not connected, price levels are computed within the biggest block of connected regions or the block of regions to which the <code>base</code> region belongs. See also <code><a href="#topic+connect">connect</a>()</code>.
</p>
</li>
<li> <p><code>plot</code> : A logical specifying if the calculated price levels should be plotted or not. If <code>TRUE</code>, the price ratios of each region are displayed as boxplots and the price levels are added as colored points. The default is <code>getOption("pricelevels.plot")</code>.
</p>
</li>
<li> <p><code>type</code> : A vector specifying the index methods used to aggregate prices into price indices. See <code>list.indices()</code> for allowed values. The default is <code>NULL</code> in which case all possible price indices are computed.
</p>
</li>
<li> <p><code>...</code> : Further settings allowed for the index methods.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Before calculations start, missing values are excluded and duplicated observations for <code>r</code> and <code>n</code> are aggregated, that is, duplicated prices <code>p</code> and weights <code>w</code> are averaged and duplicated quantities <code>q</code> added up.
</p>
<p>The weights <code>w</code> must represent expenditure shares defined as <code class="reqn">w_i^r = p_i^r q_i^r / \sum_{j=1}^{N} p_j^r q_j^r</code>. They are internally (re-)normalized such that they add up to 1 for each region <code>r</code>.
</p>


<h3>Value</h3>

<p>A matrix of price levels where the rows contain the index methods and the columns the regions.</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample complete price data:
set.seed(123)
dt1 &lt;- rdata(R=3, B=1, N=5)

# compute unweighted indices:
dt1[, pricelevels(p=price, r=region, n=product, base="1")]

# compute all indices relying on quantities:
dt1[, pricelevels(p=price, r=region, n=product, q=quantity, base="1")]

# add price data:
dt2 &lt;- rdata(R=4, B=1, N=4)
dt2[, "region":=factor(region, labels=4:7)]
dt2[, "product":=factor(product, labels=6:9)]
dt &lt;- rbind(dt1, dt2)
dt[, is.connected(r=region, n=product)] # non-connected now

# compute all unweighted indices:
dt[, pricelevels(p=price, r=region, n=product, base="1")]

# change base region:
dt[, pricelevels(p=price, r=region, n=product, base="4")]
</code></pre>

<hr>
<h2 id='ratios'>Calculation of price ratios</h2><span id='topic+ratios'></span>

<h3>Description</h3>

<p>Calculation of regional price ratios per product with flexible setting of base prices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratios(p, r, n, base=NULL, static=FALSE, settings=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ratios_+3A_p">p</code></td>
<td>
<p>A numeric vector of prices.</p>
</td></tr>
<tr><td><code id="ratios_+3A_r">r</code>, <code id="ratios_+3A_n">n</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code> and products <code>n</code>, respectively.</p>
</td></tr>
<tr><td><code id="ratios_+3A_base">base</code></td>
<td>
<p>A character specifying the base region to be used for the calculation of price ratios, i.e., <code class="reqn">p_n^r / p_n^{base}</code>. If <code>NULL</code>, price ratios are calculated with reference to the average price of a product, i.e., <code class="reqn">p_n^r / \bar{p}_n</code>, with <code class="reqn">\bar{p}_n = (1/R) \sum_{s=1}^{R} p_n^s</code>.</p>
</td></tr>
<tr><td><code id="ratios_+3A_static">static</code></td>
<td>
<p>A logical indicating whether the <code>base</code> region is static (<code>TRUE</code>), i.e. always the same as <code>base</code>, or if another region than <code>base</code> is allowed to be used when prices for <code>base</code> are not available or missing (=<code>NA</code>). Only relevant if <code>base</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ratios_+3A_settings">settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>chatty</code> : A logical specifying if warnings and info messages should be printed or not. The default is <code>getOption("pricelevels.chatty")</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>base</code> is not available for a specific product, <code class="reqn">n</code>, and <code>static=FALSE</code>, another base region is used instead. This is particularly important in cases of missing prices. Otherwise, for <code>static=TRUE</code>, computation is not possible and gives <code>NA</code>.
</p>
<p>If there are duplicated observations, only one of these duplicates is used as the base price. For example, if two prices are available for product <code class="reqn">n</code> in base region <code class="reqn">r</code>, <code>ratios()</code> divides both prices by the first one.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>p</code>. If <code>base</code> has been adjusted for some products, the attribute <code>attr("base")</code> is added to the output, providing the respective base region.</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>Examples</h3>

<pre><code class='language-R'>### (1) unique price observations; no missings

set.seed(123)
dt1 &lt;- rdata(R=3, B=1, N=4)
levels(dt1$region) &lt;- c("a","b","c")

# calculate price ratios by product:
dt1[, ratios(p=price, r=region, n=product, base="b")]


### (2) unique price observations; missings


# drop two observations:
dt2 &lt;- dt1[-c(5,10), ]

# now, region 'a' is base for product 2:
(pr &lt;- dt2[, ratios(p=price, r=region, n=product, base="b")])

# base region prices are stored in attributes:
attr(pr, "base")

# with static base, NAs are produced:
dt2[, ratios(p=price, r=region, n=product, base="b", static=TRUE)]


### (3) treatment of duplicates and missing prices (not NAs):

# insert duplicates and missings:
dt3 &lt;- rbind(dt1[2,], dt1[-c(1,10),])
dt3[1, "price" := dt1[2,price]+abs(rnorm(1))]
anyDuplicated(dt3, by=c("region","product"))

# duplicated prices are divided by the first base price:
dt3[, ratios(p=price, r=region, n=product, base="b")]
</code></pre>

<hr>
<h2 id='rdata'>Simulate random price and quantity data</h2><span id='topic+rdata'></span><span id='topic+rgaps'></span><span id='topic+rweights'></span>

<h3>Description</h3>

<p>Simulate random price and quantity data for a specified number of regions <code class="reqn">(r=1,\ldots,R)</code>, product groups <code class="reqn">(b=1,\ldots,B)</code>, and individual products <code class="reqn">(n=1,\ldots,N_{b})</code> using function <code>rdata()</code>.
</p>
<p>The sampling of prices relies on the NLCPD model (see <code><a href="#topic+nlcpd">nlcpd</a>()</code>), while expenditure weights for product groups are sampled using function <code>rweights()</code>. Purchased quantities are assigned to individual products. Moreover, random sales and gaps (using function <code>rgaps()</code>) can be introduced in the sampled data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgaps(r, n, amount=0, prob=NULL, pairs=FALSE, exclude=NULL)

rweights(r, b, type=~1)

rdata(R, B, N, gaps=0, weights=~b+r, sales=0, settings=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdata_+3A_r">r</code>, <code id="rdata_+3A_n">n</code>, <code id="rdata_+3A_b">b</code></td>
<td>
<p>A character vector or factor of regional entities <code>r</code>, individual products <code>n</code>, and product groups (or basic headings) <code>b</code>, respectively.</p>
</td></tr>
<tr><td><code id="rdata_+3A_r">R</code>, <code id="rdata_+3A_b">B</code>, <code id="rdata_+3A_n">N</code></td>
<td>
<p>A single integer specifying the number of regions <code>R</code> and product groups <code>B</code>, respectively, and a vector of length <code>B</code> specifying the number of individual products <code>N</code> in each product group.</p>
</td></tr>
<tr><td><code id="rdata_+3A_weights">weights</code>, <code id="rdata_+3A_type">type</code></td>
<td>
<p>A formula specifying the sampling of expenditure weights for product groups. If <code>type=~1</code>, product groups receive identical weights, while weights are product group specific for <code>type=~b</code>. If weights should vary among product groups and regions, use <code>type=~b+r</code>. As long as there are no data gaps, the weights add up to 1 for each region.</p>
</td></tr>
<tr><td><code id="rdata_+3A_gaps">gaps</code>, <code id="rdata_+3A_sales">sales</code>, <code id="rdata_+3A_amount">amount</code></td>
<td>
<p>Percentage amount of gaps and sales (between 0 and 1), respectively, to be introduced in the data.</p>
</td></tr>
<tr><td><code id="rdata_+3A_prob">prob</code></td>
<td>
<p>A vector of probability weights, see also <code><a href="base.html#topic+sample">sample</a>()</code>. Either <code>NULL</code> or the same length as <code>r</code> and <code>n</code>. Larger values make gaps occur more likely at this position.</p>
</td></tr>
<tr><td><code id="rdata_+3A_pairs">pairs</code></td>
<td>
<p>A logical indicating if gaps should be introduced such that there are always at least two observations per product available (<code>pairs=TRUE</code>). Only in this case, all products provide valuable information for a spatial price comparison. Otherwise, if <code>pairs=FALSE</code>, there can be products with only one observation. See also the Details section.</p>
</td></tr>
<tr><td><code id="rdata_+3A_exclude">exclude</code></td>
<td>
<p>Data.frame of two (character) variables <code>r</code> and <code>n</code>, specifying regions and products to be excluded from introducing gaps. Default is <code>NULL</code>, meaning that gaps are allowed to occur in all regions and products present in the data. Missing values (<code>NA</code>) are translated into no gaps for the corresponding product or region, e.g. <code>data.frame(r="r1", n=NA)</code> means that there will be no gaps in region <code>r1</code>.</p>
</td></tr>
<tr><td><code id="rdata_+3A_settings">settings</code></td>
<td>
<p>A list of control settings to be used. The following settings are supported:
</p>

<ul>
<li> <p><code>gaps.prob</code> : See argument <code>prob</code>.
</p>
</li>
<li> <p><code>gaps.pairs</code> : See argument <code>pairs</code>.
</p>
</li>
<li> <p><code>gaps.exclude</code> : See argument <code>exclude</code>.
</p>
</li>
<li> <p><code>sales.max.rebate</code> : Maximum allowed percentage price rebate for a sale (between 0 and 1). Default is <code>1/4</code>.
</p>
</li>
<li> <p><code>sales.max.qi</code> : Maximum allowed percentage quantity decrease for a sale (between 0 and 1). Default is <code>2</code>.
</p>
</li>
<li> <p><code>par.sd</code> : named vector specifying the standard deviations used for sampling true parameters and errors. Default is <code>c(lnP=0.1, pi=exp(1), delta=0.5, error=0.01)</code>.
</p>
</li>
<li> <p><code>par.add</code> : logical, specifying if the parameters underlying the data generating process should be added the function output. This is particularly useful if <code>rdata()</code> is applied in simulations. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>round</code> : logical, specifying if prices should be rounded to two decimals or not. While prices usually have two decimal places in reality, this rounding can cause small differences between estimated and true parameter values. For simulation purposes, it is therefore recommended to use unrounded prices by setting <code>round=FALSE</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>rgaps()</code> ensures that gaps do not lead to non-connected price data (see <code><a href="#topic+is.connected">is.connected</a>()</code>). Therefore, it could happen that the amount of gaps specified in <code>rgaps()</code> is only approximate, in particular, in cases where certain regions and/or products should additionally be excluded from exhibiting gaps by <code>exclude</code>.
</p>
<p>If <code>rgaps(pairs=FALSE)</code>, the minimum number of observations for a connected data set is <code class="reqn">R+N-1</code>. Otherwise, for <code>rgaps(pairs=TRUE)</code>, this number is defined by <code class="reqn">2N+\text{max}(0, R-N-1)</code>.
</p>
<p>Note that setting <code>sales&gt;0</code> in function <code>rdata()</code> distorts the initial price generating process. Consequently, parameter estimates may deviate stronger from their true values. Note also that the sampled expenditure weights <code>weight</code> represent the relevance of product groups as (often) derived from national accounts and other data sources. Therefore, they cannot be derived from the sampled prices and quantities in the data, which would represent the expenditure shares of available products.</p>


<h3>Value</h3>

<p>Function <code>rgaps()</code> returns a logical vector of the same length as <code>r</code> where <code>TRUE</code>s indicate gaps and <code>FALSE</code>s no gaps.
</p>
<p>Function <code>rweights()</code> returns a numeric vector of (non-negative) expenditure share weights of the same length as <code>r</code>.
</p>
<p>Function <code>rdata()</code> returns a data.table with the following variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>group</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> product group identifier (factor)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>weight</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> expenditure weight of product groups (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>region</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> region identifier (factor)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>product</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> product identifier (factor)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>sale</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> are prices and quantities affected by sales (logical)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>price</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> sampled price (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>quantity</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> consumed quantity (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>share</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> expenditure share weights (numeric)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>or a list with the sampled data and its underlying parameter values, if <code>settings=list(par.add=TRUE)</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample price data for ten regions and five product groups
# containing three individual products each:
set.seed(1)
dt &lt;- rdata(R=10, B=5, N=3)
boxplot(price~paste(group, product, sep=":"), data=dt)

# sample price data for ten regions and five product groups
# containing one to five individual products:
set.seed(1)
dt &lt;- rdata(R=10, B=5, N=c(1,2,3,4,5))
boxplot(price~paste(group, product, sep=":"), data=dt)

# sample price data for three product groups (with one product each) in four regions:
dt &lt;- rdata(R=4, B=3, N=1)

# add expenditure share weights:
dt[, "w1" := rweights(r=region, b=group, type=~1)] # constant
dt[, "w2" := rweights(r=region, b=group, type=~b)] # product-specific
dt[, "w3" := rweights(r=region, b=group, type=~b+r)] # product-region-specific

# weights add up to 1:
dt[, list("w1"=sum(w1),"w2"=sum(w2),"w3"=sum(w3)), by="region"]

# introduce 25% random gaps:
dt.gaps &lt;- dt[!rgaps(r=region, n=product, amount=0.25), ]

# weights no longer add up to 1 in each region:
dt.gaps[, list("w1"=sum(w1),"w2"=sum(w2),"w3"=sum(w3)), by="region"]

# approx. 25% random gaps, but keep observation for product "n2"
# in region "r1" and all observations in region "r2":
no_gaps &lt;- data.frame(r=c("r1","r2"), n=c("n2",NA))

# apply to data:
dt[!rgaps(r=region, n=product, amount=0.25, exclude=no_gaps), ]

# or, directly, in one step:
dt &lt;- rdata(R=4, B=3, N=1, gaps=0.25, settings=list("gaps.exclude"=no_gaps))

# introduce systematic gaps:
dt &lt;- rdata(R=15, B=1, N=10)
dt[, "prob" := data.table::rleidv(product)] # probability for gaps increases per product
dt.gaps &lt;- dt[!rgaps(r=region, n=product, amount=0.25, prob=prob), ]
plot(table(dt.gaps$product), type="l")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
