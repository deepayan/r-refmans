<!DOCTYPE html><html><head><title>Help for package RCBR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RCBR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bounds.KW2'><p>Prediction of Bounds on Marginal Effects</p></a></li>
<li><a href='#GH'><p>Current Status Linear Regression</p></a></li>
<li><a href='#GH.se'><p>Current Status Linear Regression Standard Errors</p></a></li>
<li><a href='#GK.control'><p>Control parameters for Gautier-Kitamura bivariate random coefficient binary response</p></a></li>
<li><a href='#Horowitz93'><p>Horowitz (1993) Modal Choice Data</p></a></li>
<li><a href='#KW.control'><p>Control parameters for NPMLE of bivariate random coefficient binary response</p></a></li>
<li><a href='#KWDual'><p>Dual optimization for Kiefer-Wolfowitz problems</p></a></li>
<li><a href='#logLik.GK'><p>log likelihood for Gautier Kitamura procedure</p></a></li>
<li><a href='#logLik.KW1'><p>log likelihood for KW1 procedure</p></a></li>
<li><a href='#neighbours'><p>Check Neighbouring Cell Counts</p></a></li>
<li><a href='#NICER'><p>New Incremental Cell Enumeration (in) R</p></a></li>
<li><a href='#NICERd'><p>New (Accelerated) Incremental Cell Enumeration (in) R</p></a></li>
<li><a href='#plot.GK'><p>Plot a GK object</p></a></li>
<li><a href='#plot.KW2'><p>Plot a KW2 object</p></a></li>
<li><a href='#polycount'><p>Check Cell Count  for degenerate hyperplane arrangements</p></a></li>
<li><a href='#polyzone'><p>Identify crossed polygons from existing cells when adding a new line (works only for dim = 2)</p></a></li>
<li><a href='#prcbr'><p>Profiling estimation methods for RCBR models</p></a></li>
<li><a href='#predict.GK'><p>Prediction of Marginal Effects</p></a></li>
<li><a href='#predict.KW2'><p>Prediction of Marginal Effects</p></a></li>
<li><a href='#rcbr'><p>Estimation of Random Coefficient Binary Response Models</p></a></li>
<li><a href='#rcbr.fit'><p>Fitting of Random Coefficient Binary Response Models</p></a></li>
<li><a href='#rcbr.fit.GK'><p>Gautier and Kitamura (2013) bivariate random coefficient binary response</p></a></li>
<li><a href='#rcbr.fit.KW1'><p>NPMLE fitting for the Cosslett random coefficient binary response model</p></a></li>
<li><a href='#rcbr.fit.KW2'><p>NPMLE fitting for random coefficient binary response model</p></a></li>
<li><a href='#witness'><p>Find witness point</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Random Coefficient Binary Response Estimation</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonparametric maximum likelihood estimation methods
    for random coefficient binary response  models and some related
    functionality for sequential processing of hyperplane arrangements.
    See J. Gu and R. Koenker (2020) &lt;<a href="https://doi.org/10.1080%2F01621459.2020.1802284">doi:10.1080/01621459.2020.1802284</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger Koenker &lt;rkoenker@uiuc.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, digest</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rmosek, REBayes, orthopolynom, Formula, mvtnorm</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>MOSEK (http://www.mosek.com) and MOSEK License for
use of Rmosek,</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Koenker [aut, cre],
  Jiaying Gu [aut]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-08 07:49:48 UTC; roger</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-08 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bounds.KW2'>Prediction of Bounds on Marginal Effects</h2><span id='topic+bounds.KW2'></span>

<h3>Description</h3>

<p>Given a fitted model by the exact NPMLE procedure prediction is made
at a new design point with lower and upper bounds for the prediction due
to ambiguity of the assignment of mass within the cell enumerated polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds.KW2(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds.KW2_+3A_object">object</code></td>
<td>
<p>is the fitted NPMLE object</p>
</td></tr>
<tr><td><code id="bounds.KW2_+3A_...">...</code></td>
<td>
<p>is expected to contain an argument <code>newdata</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list consisting of the following components:
</p>

<dl>
<dt>phat</dt><dd><p>Point prediction</p>
</dd>
<dt>lower</dt><dd><p>lower bound prediction</p>
</dd>
<dt>upper</dt><dd><p>upper bound prediction</p>
</dd>
<dt>xpoly</dt><dd><p>indices of crossed polygons</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jiaying Gu
</p>


<h3>See Also</h3>

<p><code>predict.KW2</code> for a simpler prediction function without bounds
</p>

<hr>
<h2 id='GH'>Current Status Linear Regression</h2><span id='topic+GH'></span>

<h3>Description</h3>

<p>Groeneboom and Hendrickx semiparametric binary response estimator (scalar case)
score estimator based on NPMLE avoids any smoothing
proposed by Groneboom and Hendrickx (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GH(b, X, y, eps = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GH_+3A_b">b</code></td>
<td>
<p>parameter vector (fix last entry as a known number, usually 1 or -1, for normalization)</p>
</td></tr>
<tr><td><code id="GH_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="GH_+3A_y">y</code></td>
<td>
<p>binary response vector</p>
</td></tr>
<tr><td><code id="GH_+3A_eps">eps</code></td>
<td>
<p>trimming tolerance parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li><p>  evaluation of a score function at parameter value
</p>
</li>
<li><p>  estimated standard error 
</p>
</li>
<li><p>  sindex single index linear predictor
</p>
</li></ul>



<h3>References</h3>

<p>Groeneboom, P. and K. Hendrickx (2018) Current Status Linear Regression, 
Annals of Statistics, 46, 1415-1444,
</p>

<hr>
<h2 id='GH.se'>Current Status Linear Regression Standard Errors</h2><span id='topic+GH.se'></span>

<h3>Description</h3>

<p>Groeneboom and Hendrickx semiparametric binary response estimator (scalar case)
score estimator based on NPMLE avoids any smoothing
proposed by Groneboom and Hendrickx (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GH.se(bstar, X, y, eps = 0.001, hc = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GH.se_+3A_bstar">bstar</code></td>
<td>
<p>parameter vector (fix last entry as a known number, usually 1 or -1, for normalization)</p>
</td></tr>
<tr><td><code id="GH.se_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="GH.se_+3A_y">y</code></td>
<td>
<p>binary response vector</p>
</td></tr>
<tr><td><code id="GH.se_+3A_eps">eps</code></td>
<td>
<p>trimming tolerance parameter</p>
</td></tr>
<tr><td><code id="GH.se_+3A_hc">hc</code></td>
<td>
<p>kernel bandwidth (used for the standard error estimation)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li><p>  evaluation of a score function at parameter value
</p>
</li>
<li><p>  estimated standard error 
</p>
</li>
<li><p>  sindex single index linear predictor
</p>
</li></ul>



<h3>References</h3>

<p>Groeneboom, P. and K. Hendrickx (2018) Current Status Linear Regression, 
Annals of Statistics, 46, 1415-1444,
</p>

<hr>
<h2 id='GK.control'>Control parameters for Gautier-Kitamura bivariate random coefficient binary response</h2><span id='topic+GK.control'></span>

<h3>Description</h3>

<p>These parameters can be passed via the <code>...</code> argument of the <code>rcbr</code> function.
defaults as suggested in Gautier and Kitamura matlab code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GK.control(n, u = -20:20/10, v = -20:20/10, T = 3, TX = 10, Mn = 1/log(n)^2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GK.control_+3A_n">n</code></td>
<td>
<p>the sample size</p>
</td></tr>
<tr><td><code id="GK.control_+3A_u">u</code></td>
<td>
<p>grid values for intercept coordinate</p>
</td></tr>
<tr><td><code id="GK.control_+3A_v">v</code></td>
<td>
<p>grid values for slope coordinate</p>
</td></tr>
<tr><td><code id="GK.control_+3A_t">T</code></td>
<td>
<p>Truncation parameter for numerator must grow &quot;sufficiently slowly with n&quot;</p>
</td></tr>
<tr><td><code id="GK.control_+3A_tx">TX</code></td>
<td>
<p>Truncation parameter for denomerator must grow &quot;sufficiently slowly with n&quot;</p>
</td></tr>
<tr><td><code id="GK.control_+3A_mn">Mn</code></td>
<td>
<p>Trimming parameter &quot;chosen to go to 0 slowly with n&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated list
</p>

<hr>
<h2 id='Horowitz93'>Horowitz (1993) Modal Choice Data</h2><span id='topic+Horowitz93'></span>

<h3>Description</h3>

<p>Modal choice data for journey to work in the Washington DC area
from  the late 1960's.  The variables are:
* 'DCOST': difference in cost of car versus transit (transit - car)
* 'CARS': number of cars at home 
* 'DOVTT': difference in out of vehicle time (transit - car)
* 'DIVTT': difference in in vehicle time (transit - car)
* 'DEPEND': coded 1 if by car, 0 if by mass transit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Horowitz93
</code></pre>


<h3>Format</h3>

<p>A data frame with 842 observations on 5 variables:
</p>


<h3>Source</h3>

<p><a href="https://www.gams.com/latest/gamslib_ml/libhtml/gamslib_mws.html">https://www.gams.com/latest/gamslib_ml/libhtml/gamslib_mws.html</a>
</p>


<h3>References</h3>

<p>Horowitz, J L, (1993) Semiparametric estimation of a work-trip mode choice model.
Journal of Econometrics, 58, 49-70.
</p>

<hr>
<h2 id='KW.control'>Control parameters for NPMLE of bivariate random coefficient binary response</h2><span id='topic+KW.control'></span>

<h3>Description</h3>

<p>These parameters can be passed via the <code>...</code> argument of the <code>rcbr</code> function.
The first three arguments are only relevant if full cell enumeration is employed for
bivariate version of the NPMLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KW.control(
  uv = NULL,
  u = NULL,
  v = NULL,
  initial = c(0, 0),
  epsbound = 1,
  epstol = 1e-07,
  presolve = 1,
  verb = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KW.control_+3A_uv">uv</code></td>
<td>
<p>matrix of evaluation points for potential mass points</p>
</td></tr>
<tr><td><code id="KW.control_+3A_u">u</code></td>
<td>
<p>grid of evaluation points for potential mass points</p>
</td></tr>
<tr><td><code id="KW.control_+3A_v">v</code></td>
<td>
<p>grid of evaluation points for potential mass points</p>
</td></tr>
<tr><td><code id="KW.control_+3A_initial">initial</code></td>
<td>
<p>initial point for cell enumeration algorithm</p>
</td></tr>
<tr><td><code id="KW.control_+3A_epsbound">epsbound</code></td>
<td>
<p>controls how close witness points can be to vertices of a cell</p>
</td></tr>
<tr><td><code id="KW.control_+3A_epstol">epstol</code></td>
<td>
<p>zero tolerance for witness solutions</p>
</td></tr>
<tr><td><code id="KW.control_+3A_presolve">presolve</code></td>
<td>
<p>controls whether Mosek does a presolve of the LP</p>
</td></tr>
<tr><td><code id="KW.control_+3A_verb">verb</code></td>
<td>
<p>controls verbosity of Mosek solver 0 implies it is quiet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated list
</p>

<hr>
<h2 id='KWDual'>Dual optimization for Kiefer-Wolfowitz problems</h2><span id='topic+KWDual'></span>

<h3>Description</h3>

<p>Interface function for calls to optimizer from various REBayes functions
There is currently only one option for the optimization that based on  Mosek. 
It relies on the <span class="pkg">Rmosek</span> interface to R see installation instructions in
the Readme file in the inst directory of this package.  This version of the function
is intended to work with versions of Mosek after 7.0.  A more experimental option
employing the <span class="pkg">pogs</span> package available from <a href="https://github.com/foges/pogs">https://github.com/foges/pogs</a>
and employing an ADMM (Alternating Direction Method of Multipliers) approach has
been deprecated, those interested could try installing version 1.4 of REBayes, and
following the instructions provided there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KWDual(A, d, w, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KWDual_+3A_a">A</code></td>
<td>
<p>Linear constraint matrix</p>
</td></tr>
<tr><td><code id="KWDual_+3A_d">d</code></td>
<td>
<p>constraint vector</p>
</td></tr>
<tr><td><code id="KWDual_+3A_w">w</code></td>
<td>
<p>weights for <code>x</code> should sum to one.</p>
</td></tr>
<tr><td><code id="KWDual_+3A_...">...</code></td>
<td>
<p>other parameters passed to control optimization:  These may
include <code>rtol</code> the relative tolerance for dual gap convergence criterion,
<code>verb</code> to control verbosity desired from mosek, <code>verb = 0</code> is quiet,
<code>verb = 5</code> produces a fairly detailed iteration log,
<code>control</code> is a control list consisting of sublists <code>iparam</code>,
<code>dparam</code>, and <code>sparam</code>, containing elements of various mosek
control parameters.  See the Rmosek and Mosek manuals for further details.
A prime example is <code>rtol</code> which should eventually be deprecated and
folded into <code>control</code>, but will persist for a while for compatibility
reasons.  The default for <code>rtol</code> is 1e-6, but in some cases it is
desirable to tighten this, say to 1e-10.  Another example that motivated the introduction of
<code>control</code> would be <code>control = list(iparam = list(num_threads =
1))</code>, which forces Mosek to use a single threaded process.  The default
allows Mosek to uses multiple threads (cores) if available, which is
generally desirable, but may have unintended (undesirable) consequences when running
simulations on clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with components: </p>
<table>
<tr><td><code>f</code></td>
<td>
<p>dual solution vector, the
mixing density</p>
</td></tr> <tr><td><code>g</code></td>
<td>
<p>primal solution vector, the mixture density
evaluated at the data points</p>
</td></tr> <tr><td><code>logLik</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>return status from Mosek</p>
</td></tr></table>
<p>.  Mosek termination messages are
treated as warnings from an R perspective since solutions producing, for example,
MSK_RES_TRM_STALL: The optimizer is terminated due to slow progress, may still
provide a satisfactory solution, especially when the return status variable is
&quot;optimal&quot;.
</p>


<h3>Author(s)</h3>

<p>R. Koenker
</p>


<h3>References</h3>

<p>Koenker, R and I. Mizera, (2013) &ldquo;Convex Optimization, Shape Constraints,
Compound Decisions, and Empirical Bayes Rules,&rdquo; <em>JASA</em>, 109, 674&ndash;685.
</p>
<p>Mosek Aps (2015) Users Guide to the R-to-Mosek Optimization Interface, 
<a href="https://docs.mosek.com/8.1/rmosek/index.html">https://docs.mosek.com/8.1/rmosek/index.html</a>.  
</p>
<p>Koenker, R. and J. Gu, (2017) REBayes: An R Package for Empirical Bayes Mixture Methods,
<em>Journal of Statistical Software</em>, 82, 1&ndash;26.
</p>

<hr>
<h2 id='logLik.GK'>log likelihood for Gautier Kitamura procedure</h2><span id='topic+logLik.GK'></span>

<h3>Description</h3>

<p>log likelihood for Gautier Kitamura procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GK'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.GK_+3A_object">object</code></td>
<td>
<p>a fitted object of class &quot;GK&quot;</p>
</td></tr>
<tr><td><code id="logLik.GK_+3A_...">...</code></td>
<td>
<p>other parameters for logLik</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar log likelihood
</p>

<hr>
<h2 id='logLik.KW1'>log likelihood for KW1 procedure</h2><span id='topic+logLik.KW1'></span>

<h3>Description</h3>

<p>log likelihood for KW1 procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KW1'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.KW1_+3A_object">object</code></td>
<td>
<p>a fitted object of class &quot;KW1&quot;</p>
</td></tr>
<tr><td><code id="logLik.KW1_+3A_...">...</code></td>
<td>
<p>other parameters for logLik</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar log likelihood
</p>

<hr>
<h2 id='neighbours'>Check Neighbouring Cell Counts</h2><span id='topic+neighbours'></span>

<h3>Description</h3>

<p>Compare cell counts for each cell with its neighbours and return indices
of the locally maximal cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbours(SignVector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbours_+3A_signvector">SignVector</code></td>
<td>
<p>n by m matrix of signs produced by NICER</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column indices of the cells that are locally maximal, i.e. those
whose neighbours have strictly fewer cell counts.  The corresponding
interior points of these cells can be used as potential mass points
for the NPMLE function <code>rcbr.fit.KW</code>.
</p>

<hr>
<h2 id='NICER'>New Incremental Cell Enumeration (in) R</h2><span id='topic+NICER'></span>

<h3>Description</h3>

<p>Find interior points and cell counts of the polygons (cells) formed by a
line arrangement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NICER(A, b, initial = c(0, 0), verb = TRUE, epsbound = 1, epstol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NICER_+3A_a">A</code></td>
<td>
<p>is a n by 2 matrix of slope coefficients</p>
</td></tr>
<tr><td><code id="NICER_+3A_b">b</code></td>
<td>
<p>is an n vector of intercept coefficients</p>
</td></tr>
<tr><td><code id="NICER_+3A_initial">initial</code></td>
<td>
<p>origin for the interior point vectors <code>w</code></p>
</td></tr>
<tr><td><code id="NICER_+3A_verb">verb</code></td>
<td>
<p>controls verbosity of Mosek solution</p>
</td></tr>
<tr><td><code id="NICER_+3A_epsbound">epsbound</code></td>
<td>
<p>is a scalar tolerance controlling how close the witness point
can be to an edge of the polytope</p>
</td></tr>
<tr><td><code id="NICER_+3A_epstol">epstol</code></td>
<td>
<p>is a scalar tolerance for the LP convergence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modified version of the algorithm of Rada and Cerny (2018).
The main modifications include preprocessing as hyperplanes are added
to determine which new cells are created, thereby reducing the number of
calls to the witness function to solve LPs, and treatment of degenerate
configurations as well as those in &quot;general position.&quot;  When the hyperplanes
are in general position the number of polytopes (cells) is determined by the
elegant formula of Zazlavsky (1975) </p>
<p style="text-align: center;"><code class="reqn">m = {n \choose d} + n + 1</code>
</p>
<p>.  In
degenerate cases, i.e. when hyperplanes are not in general position, the
number of cells is more complicated as considered by Alexanderson and Wetzel (1981).
The function <code>polycount</code> is provided to check agreement with their results
in an effort to aid in the selection of tolerances for the <code>witness</code> function.
Current version is intended for use with <code class="reqn">d = 2</code>, but the algorithm is adaptable to
<code class="reqn">d &gt; 2</code>, and there is an experimental version called <code>NICERd</code> in the package.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li><p>  SignVector a n by m matrix of signs determining position of cell relative 
to each hyperplane.
</p>
</li>
<li><p>  w a d by m matrix of interior points for the m cells
</p>
</li></ul>



<h3>References</h3>

<p>Alexanderson, G.L and J.E. Wetzel, (1981) Arrangements of planes in space, 
Discrete Math, 34, 219&ndash;240.
Gu, J. and R. Koenker (2020)  Nonparametric Maximum Likelihood Methods for
Binary Response Models with Random Coefficients, <em>J. Am. Stat Assoc</em>
Rada, M. and M. Cerny (2018) A new algorithm for the enumeration of cells 
of hyperplane arrangements and a comparison with Avis and Fukada's reverse 
search, SIAM J. of Discrete Math, 32, 455-473.
Zaslavsky, T. (1975) Facing up to arrangements:  Face-Count Formulas for 
Partitions of Space by Hyperplanes, Memoirs of the AMS, Number 154.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
if(packageVersion("Rmosek") &gt; "8.0.0"){
    A = cbind(c(1,-1,1,-2,2,1,3), c(1,1,1,1,1,-1,-2))
    B = matrix(c(3,1,7,-2,7,-1,1), ncol = 1)
    plot(NULL,xlim = c(-10,10),ylim = c(-10,10))
    for (i in 1:nrow(A))
	  abline(a = B[i,1]/A[i,2], b = -A[i,1]/A[i,2],col = i)
    f = NICER(A, B)
    for (j in 1:ncol(f$SignVector))
    	  points(f$w[1,j], f$w[2,j], cex = 0.5)
    }
}
</code></pre>

<hr>
<h2 id='NICERd'>New (Accelerated) Incremental Cell Enumeration (in) R</h2><span id='topic+NICERd'></span>

<h3>Description</h3>

<p>Find interior points and cell counts of the polygons (polytopes) formed by a
hyperplane arrangement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NICERd(
  A,
  b,
  initial = rep(0, ncol(A)),
  verb = TRUE,
  accelerate = FALSE,
  epsbound = 1,
  epstol = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NICERd_+3A_a">A</code></td>
<td>
<p>is a n by d matrix of hyperplane slope coefficients</p>
</td></tr>
<tr><td><code id="NICERd_+3A_b">b</code></td>
<td>
<p>is an n vector of hyperplane intercept coefficients</p>
</td></tr>
<tr><td><code id="NICERd_+3A_initial">initial</code></td>
<td>
<p>origin for the interior point vectors <code>w</code></p>
</td></tr>
<tr><td><code id="NICERd_+3A_verb">verb</code></td>
<td>
<p>controls verbosity of Mosek solution</p>
</td></tr>
<tr><td><code id="NICERd_+3A_accelerate">accelerate</code></td>
<td>
<p>allows the option to turn off acceleration step (turned off by default)</p>
</td></tr>
<tr><td><code id="NICERd_+3A_epsbound">epsbound</code></td>
<td>
<p>is a scalar tolerance controlling how close the witness point
can be to an edge of the polytope</p>
</td></tr>
<tr><td><code id="NICERd_+3A_epstol">epstol</code></td>
<td>
<p>is a scalar tolerance for the LP convergence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modified version of the algorithm of Rada and Cerny (2018).
The main modifications include preprocessing as hyperplanes are added
to determine which new cells are created, thereby reducing the number of
calls to the witness function to solve LPs, and treatment of degenerate
configurations as well as those in &quot;general position.&quot; (for <code class="reqn">d=2</code> for now).  When the hyperplanes
are in general position the number of cells (polytopes) is determined by the
elegant formula of Zaslavsky (1975) </p>
<p style="text-align: center;"><code class="reqn">m = {n \choose d} + n + 1</code>
</p>
<p>.  In
degenerate cases, i.e. when hyperplanes are not in general position, the
number of cells is more complicated as considered by Alexanderson and Wetzel (1981).
The function <code>polycount</code> is provided to check agreement with their results
in an effort to aid in the selection of tolerances for the <code>witness</code> function for arrangement in <code class="reqn">d=2</code>.
The current version is intended mainly for use with <code class="reqn">d = 2</code>, but the algorithm is adapted to
the general position setting with <code class="reqn">d &gt; 2</code>, although it requires hyperplanes in general position and may require some patience when both
the sample size is large.
if hyperplanes not general position (i.e. all cross at origin), turn off accelerate
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li><p>  SignVector a n by m matrix of signs determining position of cell relative 
to each hyperplane.
</p>
</li>
<li><p>  w a d by m matrix of interior points for the m cells
</p>
</li></ul>



<h3>References</h3>

<p>Alexanderson, G.L and J.E. Wetzel, (1981) Arrangements of planes in space, 
Discrete Math, 34, 219&ndash;240.
Rada, M. and M. Cerny (2018) A new algorithm for the enumeration of cells 
of hyperplane arrangements and a comparison with Avis and Fukada's reverse 
search, SIAM J. of Discrete Math, 32, 455-473.
Zaslavsky, T. (1975) Facing up to arrangements:  Face-Count Formulas for 
Partitions of Space by Hyperplanes, Memoirs of the AMS, Number 154.
</p>

<hr>
<h2 id='plot.GK'>Plot a GK object</h2><span id='topic+plot.GK'></span>

<h3>Description</h3>

<p>Given a fitted model by the Guatier-Kitamura procedure plot the estimated density contours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GK'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.GK_+3A_x">x</code></td>
<td>
<p>is the fitted GK object</p>
</td></tr>
<tr><td><code id="plot.GK_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code>contour</code>, notably e.g. <code>add = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing (invisibly)
</p>

<hr>
<h2 id='plot.KW2'>Plot a KW2 object</h2><span id='topic+plot.KW2'></span>

<h3>Description</h3>

<p>Given a fitted model by the rcbr NPMLE procedure plot the estimated mass points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KW2'
plot(x, smooth = 0, pal = NULL, inches = 1/6, N = 25, tol = 0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.KW2_+3A_x">x</code></td>
<td>
<p>is the fitted NPMLE object</p>
</td></tr>
<tr><td><code id="plot.KW2_+3A_smooth">smooth</code></td>
<td>
<p>is a parameter to control bandwidth of the smoothing if a contour plot
of the estimated density is desired, default is no smoothing and only
the mass points of the discrete estimate are plotted.</p>
</td></tr>
<tr><td><code id="plot.KW2_+3A_pal">pal</code></td>
<td>
<p>a color palette</p>
</td></tr>
<tr><td><code id="plot.KW2_+3A_inches">inches</code></td>
<td>
<p>as used in <code>symbols</code> to control size of mass points</p>
</td></tr>
<tr><td><code id="plot.KW2_+3A_n">N</code></td>
<td>
<p>scaling of the color palette</p>
</td></tr>
<tr><td><code id="plot.KW2_+3A_tol">tol</code></td>
<td>
<p>tolerance for size of mass points</p>
</td></tr>
<tr><td><code id="plot.KW2_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code>symbols</code>, notably e.g. <code>add = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing (invisibly)
</p>

<hr>
<h2 id='polycount'>Check Cell Count  for degenerate hyperplane arrangements</h2><span id='topic+polycount'></span>

<h3>Description</h3>

<p>When the hyperplane arrangement is degenerate, i.e. not in general position,
the number of distinct cells can be checked against the formula of
Alexanderson and Wetzel (1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polycount(A, b, maxints = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polycount_+3A_a">A</code></td>
<td>
<p>is a n by m matrix of hyperplane slope coefficients</p>
</td></tr>
<tr><td><code id="polycount_+3A_b">b</code></td>
<td>
<p>is an n vector of hyperplane intercept coefficients</p>
</td></tr>
<tr><td><code id="polycount_+3A_maxints">maxints</code></td>
<td>
<p>is maximum number of lines allowed to cross at the same vertex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of distinct cells
</p>


<h3>References</h3>

<p>Alexanderson, G.L and J.E. Wetzel, (1981) Arrangements of planes in space, 
Discrete Math, 34, 219&ndash;240.
</p>

<hr>
<h2 id='polyzone'>Identify crossed polygons from existing cells when adding a new line (works only for dim = 2)</h2><span id='topic+polyzone'></span>

<h3>Description</h3>

<p>Given an existing cell configuration represented by the Signvector and
associated interior points w, identify the polygons crossed by the next
new line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyzone(SignVector, w, A, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyzone_+3A_signvector">SignVector</code></td>
<td>
<p>current SignvVctor matrix</p>
</td></tr>
<tr><td><code id="polyzone_+3A_w">w</code></td>
<td>
<p>associated interior points</p>
</td></tr>
<tr><td><code id="polyzone_+3A_a">A</code></td>
<td>
<p>design matrix for full problem aka [1,z]</p>
</td></tr>
<tr><td><code id="polyzone_+3A_b">b</code></td>
<td>
<p>associated final column of design matrix aka [v]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of indices of crossed polygons
</p>


<h3>Author(s)</h3>

<p>Jiaying Gu
</p>

<hr>
<h2 id='prcbr'>Profiling estimation methods for RCBR models</h2><span id='topic+prcbr'></span>

<h3>Description</h3>

<p>Profile likelihood and (GEE) score methods for estimation of random coefficient binary
response models.  This function is a wrapper for <code>rcbr</code> that uses the offset
argument to implement estimation of additional fixed parameters.  It may be useful to
restrict the domain of the optimization over the profiled parameters, this can be
accomplished, at least for box constraints by setting <code>omethod = "L-BFGS-B"</code>
and specifying the <code>lo</code> and <code>up</code> accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prcbr(
  formula,
  b0,
  data,
  logL = TRUE,
  omethod = "BFGS",
  lo = -Inf,
  up = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prcbr_+3A_formula">formula</code></td>
<td>
<p>is of the extended form enabled by the <span class="pkg">Formula</span> package.
In the Cosslett, or current status, model the formula takes the form 
<code>y ~ v | z</code> where <code>v</code> is the covariate designated to have coefficient
one, and <code>z</code> is another covariate or group of covariates that are assumed
fixed coefficients that are to be estimated.</p>
</td></tr>
<tr><td><code id="prcbr_+3A_b0">b0</code></td>
<td>
<p>is either an initial value of the parameter for the Z covariates
or a matrix of such values, in which case optimization occurs over this discrete
set, when there is only one covariate then b0 is either scalar, or a vector.</p>
</td></tr>
<tr><td><code id="prcbr_+3A_data">data</code></td>
<td>
<p>data frame for formula variables</p>
</td></tr>
<tr><td><code id="prcbr_+3A_logl">logL</code></td>
<td>
<p>if logL is TRUE the log likelihood is optimized, otherwise
a GEE score criterion is minimized.</p>
</td></tr>
<tr><td><code id="prcbr_+3A_omethod">omethod</code></td>
<td>
<p>optimization method for <code>optim</code>, default &quot;BFGS&quot;.</p>
</td></tr>
<tr><td><code id="prcbr_+3A_lo">lo</code></td>
<td>
<p>lower bound(s) for the parameter domain</p>
</td></tr>
<tr><td><code id="prcbr_+3A_up">up</code></td>
<td>
<p>upper bound(s) for the parameter domain</p>
</td></tr>
<tr><td><code id="prcbr_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code>rcbr.fit</code> to control fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list comprising the components:
</p>

<dl>
<dt>bopt</dt><dd><p>output of the optimizer for the profiled parameters beta</p>
</dd>
<dt>fopt</dt><dd><p>output of the optimizer for the random coefficients eta</p>
</dd>
</dl>


<hr>
<h2 id='predict.GK'>Prediction of Marginal Effects</h2><span id='topic+predict.GK'></span>

<h3>Description</h3>

<p>Given a fitted model by the Gautier Kitamura procedure predictions are made
at new design points given by the <code>newdata</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GK'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.GK_+3A_object">object</code></td>
<td>
<p>is the fitted object of class &quot;GK&quot;</p>
</td></tr>
<tr><td><code id="predict.GK_+3A_...">...</code></td>
<td>
<p>is expected to contain an argument <code>newdata</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector pf predicted probabilities
</p>

<hr>
<h2 id='predict.KW2'>Prediction of Marginal Effects</h2><span id='topic+predict.KW2'></span>

<h3>Description</h3>

<p>Given a fitted model by the rcbr NPMLE procedure predictions are made
at new design points given by the <code>newdata</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KW2'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.KW2_+3A_object">object</code></td>
<td>
<p>is the fitted NPMLE object</p>
</td></tr>
<tr><td><code id="predict.KW2_+3A_...">...</code></td>
<td>
<p>is expected to contain an argument <code>newdata</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector pf predicted probabilities
</p>


<h3>See Also</h3>

<p><code>bound.KW2</code> for a prediction function with bounds
</p>

<hr>
<h2 id='rcbr'>Estimation of Random Coefficient Binary Response Models</h2><span id='topic+rcbr'></span>

<h3>Description</h3>

<p>Two methods are implemented for estimating binary response models  
with random coefficients:  A nonparametric maximum likelihood method
proposed by Cosslett (1986) and extended by Ichimura and Thompson (1998),
and a (hemispherical) deconvolution method proposed by Gautier and
and Kitamura (2013).  The former is closely related to the NPMLE
for mixture models of Kiefer and Wolfowitz (1956).  The latter is an
R translation of the matlab implementation of Gautier and Kitamura.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcbr(formula, data, subset, offset, mode = "GK", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcbr_+3A_formula">formula</code></td>
<td>
<p>an expression of the generic form <code>y ~ z + v</code> where
<code>y</code> is the observed binary response, <code>z</code> is an observed covariate
with a random coefficient, and <code>v</code> is an observed covariate with
coefficient normalize to be one.  If <code>z</code> is not present then the
model has only a random &quot;intercept&quot; coefficient  and thus corresponds
to the basic model of Cosslett (1983);  this model is also referred to
as the current status model in the biostatistics literature, see Groeneboom
and Hendrikx (2016).  When <code>z</code> is present there are random coefficients
associated with both the intercept and <code>z</code>.</p>
</td></tr>
<tr><td><code id="rcbr_+3A_data">data</code></td>
<td>
<p>is a <code>data.frame</code> containing the data referenced in the
formula.</p>
</td></tr>
<tr><td><code id="rcbr_+3A_subset">subset</code></td>
<td>
<p>specifies a subsample of the data used for fitting the model</p>
</td></tr>
<tr><td><code id="rcbr_+3A_offset">offset</code></td>
<td>
<p>specifies a fixed shift in <code>v</code> representing the
potential effect of other covariates having fixed coefficients that may be
useful for profile likelihood computations.  (Should be vector of the same
length as <code>v</code>.</p>
</td></tr>
<tr><td><code id="rcbr_+3A_mode">mode</code></td>
<td>
<p>controls whether the Gautier and Kitamura, &quot;GK&quot;, or Kiefer and
Wolfowitz, &quot;KW&quot; methods are used.</p>
</td></tr>
<tr><td><code id="rcbr_+3A_...">...</code></td>
<td>
<p>miscellaneous other arguments to control fitting.
See <code>GK.control</code> and <code>KW.control</code> for further details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>predict</code> method produces estimates of the probability of a &quot;success&quot;
(y = 1) for a particular vector, <code>(z,v)</code>,  when aggregated over the estimated
distribution of random coefficients.
</p>
<p>The <code>logLik</code> produces an evaluation of the log likelihood value
associated with a fitted model.
</p>


<h3>Value</h3>

<p>of object of class <code>GK</code>, <code>KW1</code>, with components described in 
further detail in the respective fitting functions.
</p>


<h3>Author(s)</h3>

<p>Jiaying Gu and Roger Koenker
</p>


<h3>References</h3>

<p>Kiefer, J. and J. Wolfowitz (1956) Consistency of the Maximum
Likelihood Estimator in the Presence of Infinitely Many Incidental
Parameters, <em>Ann. Math. Statist</em>, 27, 887-906.
</p>
<p>Cosslett, S. (1983) Distribution Free Maximum Likelihood Estimator of the 
Binary Choice Model, <em>Econometrica</em>, 51, 765-782.
</p>
<p>Gautier, E. and Y. Kitamura (2013)  Nonparametric estimation in random coefficients
binary choice models, <em>Ecoonmetrica</em>, 81, 581-607.
</p>
<p>Gu, J. and R. Koenker (2020)  Nonparametric Maximum Likelihood Methods for 
Binary Response Models with Random Coefficients, <em>J. Am. Stat Assoc</em> 
</p>
<p>Groeneboom, P. and K. Hendrickx (2016) Current Status Linear Regression,
preprint available from <a href="https://arxiv.org/abs/1601.00202">https://arxiv.org/abs/1601.00202</a>.
</p>
<p>Ichimura, H. and T. S. Thompson, (1998) Maximum likelihood estimation of a binary 
choice model with random coefficients of unknown distribution,&quot; 
<em>Journal of Econometrics</em>,  86, 269-295.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
if(packageVersion("Rmosek") &gt; "8.0.0"){
    # Simple Test Problem for rcbr
    n &lt;- 60
    B0 = rbind(c(0.7,-0.7,1),c(-0.7,0.7,1))
    z &lt;- rnorm(n)
    v &lt;- rnorm(n)
    s &lt;- sample(0:1, n, replace = TRUE)
    XB0 &lt;- cbind(1,z,v) %*% t(B0)
    u &lt;- s * XB0[,1] + (1-s) * XB0[,2]
    y &lt;- (u &gt; 0) - 0
    D &lt;- data.frame(z = z, v = v, y = y)
    f &lt;- rcbr(y ~ z + v, mode = "KW", data = D)
    plot(f)
    # Simple Test Problem for rcbr
    set.seed(15)
    n &lt;- 100
    B0 = rbind(c(0.7,-0.7,1),c(-0.7,0.7,1))
    z &lt;- rnorm(n)
    v &lt;- rnorm(n)
    s &lt;- sample(0:1, n, replace = TRUE)
    XB0 &lt;- cbind(1,z,v) %*% t(B0)
    u &lt;- s * XB0[,1] + (1-s) * XB0[,2]
    y &lt;- (u &gt; 0) - 0
    D &lt;- data.frame(z = z, v = v, y = y)
    f &lt;- rcbr(y ~ z + v, mode = "GK", data = D)
    contour(f$u, f$v, matrix(f$w, length(f$u)))
    points(x = 0.7, y = -0.7, col = 2)
    points(x = -0.7, y = 0.7, col = 2)
    f &lt;- rcbr(y ~ z + v, mode = "GK", data = D, T = 7)
    contour(f$u, f$v, matrix(f$w, length(f$u)))
    points(x = 0.7, y = -0.7, col = 2)
    points(x = -0.7, y = 0.7, col = 2)
    }
}
</code></pre>

<hr>
<h2 id='rcbr.fit'>Fitting of Random Coefficient Binary Response Models</h2><span id='topic+rcbr.fit'></span>

<h3>Description</h3>

<p>Two methods are implemented for estimating binary response models  
with random coefficients:  A nonparametric maximum likelihood method
proposed by Cosslett (1986) and extended by Ichimura and Thompson (1998),
and a (hemispherical) deconvolution method proposed by Gautier and
and Kitamura (2013).  The former is closely related to the NPMLE
for mixture models of Kiefer and Wolfowitz (1956).  The latter is an
R translation of the matlab implementation of Gautier and Kitamura.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcbr.fit(x, y, offset = NULL, mode = "KW", control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcbr.fit_+3A_x">x</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="rcbr.fit_+3A_y">y</code></td>
<td>
<p>binary response vector</p>
</td></tr>
<tr><td><code id="rcbr.fit_+3A_offset">offset</code></td>
<td>
<p>specifies a fixed shift in <code>v</code> representing the
potential effect of other covariates having fixed coefficients that may be
useful for profile likelihood computations.  (Should be vector of the same
length as <code>v</code>.</p>
</td></tr>
<tr><td><code id="rcbr.fit_+3A_mode">mode</code></td>
<td>
<p>controls whether the Gautier and Kitamura, &quot;GK&quot;, or Kiefer and
Wolfowitz, &quot;KW&quot; methods are used.</p>
</td></tr>
<tr><td><code id="rcbr.fit_+3A_control">control</code></td>
<td>
<p>control parameters for fitting methods
See <code>GK.control</code> and <code>KW.control</code> for further details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>predict</code> method produces estimates of the probability of a &quot;success&quot;
(y = 1) for a particular vector, <code>(z,v)</code>,  when aggregated over the estimated
distribution of random coefficients.
</p>


<h3>Value</h3>

<p>of object of class <code>GK</code>, <code>KW1</code>, with components described in 
further detail in the respective fitting functions.
</p>


<h3>Author(s)</h3>

<p>Jiaying Gu and Roger Koenker
</p>


<h3>References</h3>

<p>Kiefer, J. and J. Wolfowitz (1956) Consistency of the Maximum
Likelihood Estimator in the Presence of Infinitely Many Incidental
Parameters, <em>Ann. Math. Statist</em>, 27, 887-906.
</p>
<p>Cosslett, S. (1983) Distribution Free Maximum Likelihood Estimator of the 
Binary Choice Model, <em>Econometrica</em>, 51, 765-782.
Gautier, E. and Y. Kitamura (2013)  Nonparametric estimation in random coefficients
binary choice models, <em>Ecoonmetrica</em>, 81, 581-607.
</p>
<p>Groeneboom, P. and K. Hendrickx (2016) Current Status Linear Regression,
preprint available from <a href="https://arxiv.org/abs/1601.00202">https://arxiv.org/abs/1601.00202</a>.
</p>
<p>Ichimuma, H. and T. S. Thompson, (1998) Maximum likelihood estimation of a binary 
choice model with random coefficients of unknown distribution,&quot; 
<em>Journal of Econometrics</em>,  86, 269-295.
</p>

<hr>
<h2 id='rcbr.fit.GK'>Gautier and Kitamura (2013) bivariate random coefficient binary response</h2><span id='topic+rcbr.fit.GK'></span>

<h3>Description</h3>

<p>This is an implementation based on the matlab version of Gautier and
Kitamura's deconvolution method for the bivariate random coefficient 
binary response model.  Methods based on the fitted object are provided
for <code>predict</code>, <code>logLik</code> and <code>plot</code>.requires orthopolynom
package for Gegenbauer polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcbr.fit.GK(X, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcbr.fit.GK_+3A_x">X</code></td>
<td>
<p>the design matrix expected to have an intercept column of
ones as the first column.</p>
</td></tr>
<tr><td><code id="rcbr.fit.GK_+3A_y">y</code></td>
<td>
<p>the binary response.</p>
</td></tr>
<tr><td><code id="rcbr.fit.GK_+3A_control">control</code></td>
<td>
<p>is a list of tuning parameters for the fitting,see
<code>GK.control</code> for further details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>

<dl>
<dt>u</dt><dd><p>grid values</p>
</dd>
<dt>v</dt><dd><p>grid values</p>
</dd>
<dt>w</dt><dd><p>estimated function values on 2d u x v grid</p>
</dd>
<dt>X</dt><dd><p>design matrix</p>
</dd>
<dt>y</dt><dd><p>response vector</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Gautier and Kitamura for original matlab version, Jiaying Gu
and Roger Koenker for the R translation.
</p>


<h3>References</h3>

<p>Gautier, E. and Y. Kitamura (2013)  Nonparametric estimation in random coefficients
binary choice models, <em>Ecoonmetrica</em>, 81, 581-607.
</p>

<hr>
<h2 id='rcbr.fit.KW1'>NPMLE fitting for the Cosslett random coefficient binary response model</h2><span id='topic+rcbr.fit.KW1'></span>

<h3>Description</h3>

<p>This is the original one dimensional version of the Cosslett model, also
known as the current status model:
</p>
<p style="text-align: center;"><code class="reqn">P(y = 1 | v) = \int I (\eta &gt; v)dF(\eta).</code>
</p>

<p>invoked with the formula <code>y ~ v</code>.  By default the algorithm computes a vector
of potential locations for the mass points of <code class="reqn">\hat F</code> by finding interior
points of the intervals between the ordered <code>v</code>, and then solving a convex
optimization problem to determine these masses.  Alternatively, a vector of
predetermined locations can be passed via the control argument.  Additional
covariate effects can be accommodated by either specifying a fixed offset in
the call to <code>rcbr</code> or by using the profile likelihood function <code>prcbr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcbr.fit.KW1(X, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcbr.fit.KW1_+3A_x">X</code></td>
<td>
<p>the design matrix expected to have an intercept column of
ones as the first column, the last column is presumed to contain values of
the covariate that is designated to have coefficient one.</p>
</td></tr>
<tr><td><code id="rcbr.fit.KW1_+3A_y">y</code></td>
<td>
<p>the binary response.</p>
</td></tr>
<tr><td><code id="rcbr.fit.KW1_+3A_control">control</code></td>
<td>
<p>is a list of parameters for the fitting, see
<code>KW.control</code> for further details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li><p>  x evaluation points for the fitted distribution
</p>
</li>
<li><p>  y estimated mass associated with the <code>v</code> points
</p>
</li>
<li><p>  logLik the loglikelihood value of the fit
</p>
</li>
<li><p>  status mosek solution status
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jiaying Gu and Roger Koenker
</p>


<h3>References</h3>

<p>Gu, J. and R. Koenker (2018)  Nonparametric maximum likelihood estimation 
of the random coefficients binary choice model, preprint.
</p>

<hr>
<h2 id='rcbr.fit.KW2'>NPMLE fitting for random coefficient binary response model</h2><span id='topic+rcbr.fit.KW2'></span>

<h3>Description</h3>

<p>Exact NPMLE fitting requires that the <code>uv</code> argument contain a matrix
whose rows represent points in the interior of the locally maximal polytopes
determined by the hyperplane arrangement of the observations.  If it is not
provided it will be computed afresh here; since this can be somewhat time
consuming, <code>uv</code> is included in the returned object so that it can be
reused if desired.  Approximate NPMLE fitting can be achieved by specifying
an equally spaced grid of points at which the NPMLE can assign mass using
the arguments <code>u</code> and <code>v</code>.  If the design matrix <code>X</code> contains
only 2 columns, so we have the Cosslett, aka current status, model then the
polygons in the prior description collapse to intervals and the default method
computes the locally maximal count intervals and passes their interior points
to the optimizer of the log likelihood.  Alternatively, as in the bivariate
case one can specify a grid to obtain an approximate solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcbr.fit.KW2(x, y, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcbr.fit.KW2_+3A_x">x</code></td>
<td>
<p>the design matrix expected to have an intercept column of
ones as the first column, the last column is presumed to contain values of
the covariate that is designated to have coefficient one.</p>
</td></tr>
<tr><td><code id="rcbr.fit.KW2_+3A_y">y</code></td>
<td>
<p>the binary response.</p>
</td></tr>
<tr><td><code id="rcbr.fit.KW2_+3A_control">control</code></td>
<td>
<p>is a list of parameters for the fitting, see
<code>KW.control</code> for further details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li><p>  uv evaluation points for the fitted distribution
</p>
</li>
<li><p>  W estimated mass associated with the <code>uv</code> points
</p>
</li>
<li><p>  logLik the loglikelihood value of the fit
</p>
</li>
<li><p>  status mosek solution status
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jiaying Gu and Roger Koenker
</p>


<h3>References</h3>

<p>Gu, J. and R. Koenker (2018)  Nonparametric maximum likelihood estimation 
of the random coefficients binary choice model, preprint.
</p>

<hr>
<h2 id='witness'>Find witness point</h2><span id='topic+witness'></span>

<h3>Description</h3>

<p>Find (if possible) an interior point of a polytope solving a linear program
</p>


<h3>Usage</h3>

<pre><code class='language-R'>witness(A, b, s, epsbound = 1, epstol = 1e-07, presolve = 1, verb = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="witness_+3A_a">A</code></td>
<td>
<p>Is a n by d matrix of hyperplane slope coefficients.</p>
</td></tr>
<tr><td><code id="witness_+3A_b">b</code></td>
<td>
<p>Is an n vector of hyperplane intercept coefficients.</p>
</td></tr>
<tr><td><code id="witness_+3A_s">s</code></td>
<td>
<p>Is an n vector of signs.</p>
</td></tr>
<tr><td><code id="witness_+3A_epsbound">epsbound</code></td>
<td>
<p>Is a scalar tolerance controlling how close the witness 
point can be to an edge of the polytope.</p>
</td></tr>
<tr><td><code id="witness_+3A_epstol">epstol</code></td>
<td>
<p>Is a scalar tolerance for the LP convergence.</p>
</td></tr>
<tr><td><code id="witness_+3A_presolve">presolve</code></td>
<td>
<p>Controls whether Mosek should presolve the LP.</p>
</td></tr>
<tr><td><code id="witness_+3A_verb">verb</code></td>
<td>
<p>Controls verbosity of Mosek solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solves LP:  <code class="reqn">max over {w,eps} {eps | SAw - eps &gt;= Sb, 0 &lt; eps &lt;= epsbound}</code>
S is diag(s),  if at the solution eps &gt; 0, then w is a valid interior point
otherwise the LP fails to find an interior point, another s must be tried.
Constructs a problem formulation that can be passed to Rmosek for solution.
</p>


<h3>Value</h3>

<p>List with components:
</p>

<ul>
<li><p>  w proposed interior point at solution 
</p>
</li>
<li><p>  fail indicator of whether w is a valid interior point
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
