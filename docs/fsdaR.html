<!DOCTYPE html><html><head><title>Help for package fsdaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fsdaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bank_data'><p>Bank data (Riani et al., 2014).</p></a></li>
<li><a href='#carbikeplot'><p>Produces the carbike plot to find best relevant clustering solutions obtained by <code>tclustICsol</code></p></a></li>
<li><a href='#corfwdplot'><p>Monitoring the correlations between consecutive distances or residuals</p></a></li>
<li><a href='#covplot'><p>Monitoring of the covariance matrix</p></a></li>
<li><a href='#diabetes'><p>Diabetes data</p></a></li>
<li><a href='#emilia2001'><p>Demographic data from the 341 miniciplaities in Emilia Romagna (an Italian region).</p></a></li>
<li><a href='#fishery'><p>Fishery data.</p></a></li>
<li><a href='#flea'><p>Flea</p></a></li>
<li><a href='#forbes'><p>Forbes' data on air pressure in the Alps and the boiling point of water (Weisberg, 1985).</p></a></li>
<li><a href='#fsdalms.object'><p>Description of <code>fsdalms</code> Objects</p></a></li>
<li><a href='#fsdalts.object'><p>Description of <code>fsdalts</code> Objects</p></a></li>
<li><a href='#fsmeda.object'><p>Description of <code>fsmeda.object</code> Objects</p></a></li>
<li><a href='#fsmmmdrs'><p>Performs random start monitoring of minimum Mahalanobis distance</p></a></li>
<li><a href='#fsmmmdrs.object'><p>Description of <code>fsmmmdrs.object</code> Objects</p></a></li>
<li><a href='#fsmult'><p>Gives an automatic outlier detection procedure in multivariate analysis</p></a></li>
<li><a href='#fsmult.object'><p>Description of <code>fsmult.object</code> Objects</p></a></li>
<li><a href='#FSR_control'>
<p>Creates an <code>FSR_control</code> object</p></a></li>
<li><a href='#fsr.object'><p>Description of <code>fsr</code> Objects</p></a></li>
<li><a href='#fsrbase'>
<p>fsrbase: an automatic outlier detection procedure in linear regression</p></a></li>
<li><a href='#FSReda_control'>
<p>Creates an <code>FSReda_control</code> object</p></a></li>
<li><a href='#fsreda.object'><p>Description of <code>fsreda</code> Objects</p></a></li>
<li><a href='#fsreg'>
<p>fsreg: an automatic outlier detection procedure in linear regression</p></a></li>
<li><a href='#fsrfan'><p>Robust transformations for regression</p></a></li>
<li><a href='#fsrfan.object'><p>Objects returned by the function <code>fsrfan</code></p></a></li>
<li><a href='#geyser2'><p>Old Faithful Geyser Data.</p></a></li>
<li><a href='#hawkins'><p>Hawkins data.</p></a></li>
<li><a href='#hospital'><p>Hospital data (Neter et al., 1996)</p></a></li>
<li><a href='#Income1'><p>Income1</p></a></li>
<li><a href='#Income2'><p>Income2</p></a></li>
<li><a href='#levfwdplot'>
<p>Plots the trajectories of the monitored scaled (squared) residuals</p></a></li>
<li><a href='#loyalty'>
<p>Loyalty data</p></a></li>
<li><a href='#LXS_control'>
<p>Creates an <code>LSX_control</code> object</p></a></li>
<li><a href='#M5data'><p>Mixture M5 Data.</p></a></li>
<li><a href='#malfwdplot'><p>Plots the trajectories of scaled Mahalanobis distances along the search</p></a></li>
<li><a href='#malindexplot'><p>Plots the trajectory of minimum Mahalanobis distance (mmd)</p></a></li>
<li><a href='#mdrplot'>
<p>Plots the trajectory of minimum deletion residual (mdr)</p></a></li>
<li><a href='#mmdplot'><p>Plots the trajectory of minimum Mahalanobis distance (mmd)</p></a></li>
<li><a href='#mmdrsplot'><p>Plots the trajectories of minimum Mahalanobis distances from different starting points</p></a></li>
<li><a href='#mmmult'><p>Computes MM estimators in multivariate analysis with auxiliary S-scale</p></a></li>
<li><a href='#mmmult.object'><p>Description of <code>mmmult.object</code> Objects</p></a></li>
<li><a href='#mmmulteda.object'><p>Description of <code>mmmulteda.object</code> Objects</p></a></li>
<li><a href='#MMreg_control'>
<p>Creates an <code>MMreg_control</code> object</p></a></li>
<li><a href='#mmreg.object'><p>Description of mmreg Objects</p></a></li>
<li><a href='#MMregeda_control'>
<p>Creates an <code>MMregeda_control</code> object</p></a></li>
<li><a href='#mmregeda.object'><p>Description of <code>mmregeda</code> Objects</p></a></li>
<li><a href='#multiple_regression'><p>Multiple regression data showing the effect of masking (Atkinson and Riani, 2000).</p></a></li>
<li><a href='#mussels'><p>Mussels data.</p></a></li>
<li><a href='#myrng'><p>Set seed for the MATLAB random number generator</p></a></li>
<li><a href='#poison'><p>Poison</p></a></li>
<li><a href='#psifun'><p>Finds the tuning constant(s) associated to the supplied breakdown point or asymptotic efficiency for different psi functions</p></a></li>
<li><a href='#regspmplot'><p>Interactive scatterplot matrix for regression</p></a></li>
<li><a href='#resfwdplot'>
<p>Plots the trajectories of the monitored scaled (squared) residuals</p></a></li>
<li><a href='#resindexplot'>
<p>Plots the residuals from a regression analysis versus index number or any other variable</p></a></li>
<li><a href='#score'><p>Computes the score test for transformation in regression</p></a></li>
<li><a href='#score.object'><p>Objects returned by the function <code>score</code></p></a></li>
<li><a href='#smult'><p>Computes  S estimators in multivariate analysis</p></a></li>
<li><a href='#smult.object'><p>Description of <code>smult.object</code> Objects</p></a></li>
<li><a href='#smulteda.object'><p>Description of <code>smulteda.object</code> Objects</p></a></li>
<li><a href='#spmplot'><p>Interactive scatterplot matrix</p></a></li>
<li><a href='#Sreg_control'>
<p>Creates an <code>Sreg_control</code> object</p></a></li>
<li><a href='#sreg.object'><p>Description of sreg Objects</p></a></li>
<li><a href='#Sregeda_control'>
<p>Creates an <code>Sregeda_control</code> object</p></a></li>
<li><a href='#sregeda.object'><p>Description of <code>sregeda</code> Objects</p></a></li>
<li><a href='#summary.fsdalms'><p>Summary Method for <code>fsdalms</code> objects</p></a></li>
<li><a href='#summary.fsdalts'><p>Summary Method for <code>fsdalts</code> objects</p></a></li>
<li><a href='#summary.fsr'><p>Summary Method for FSR objects</p></a></li>
<li><a href='#swissbanknotes'>
<p>Swiss banknote data</p></a></li>
<li><a href='#swissheads'>
<p>Swiss heads data</p></a></li>
<li><a href='#tclusteda.object'><p>Objects returned by the function <code>tclustfsda</code> with the option <code>monitoring=TRUE</code></p></a></li>
<li><a href='#tclustfsda'><p>Computes trimmed clustering with scatter restrictions</p></a></li>
<li><a href='#tclustfsda.object'><p>Objects returned by the function <code>tclustfsda</code></p></a></li>
<li><a href='#tclustIC'><p>Performs cluster analysis by calling <code>tclustfsda</code> for different</p>
number of groups <code>k</code> and restriction factors <code>c</code></a></li>
<li><a href='#tclustic.object'><p>Objects returned by the function <code>tclustIC</code></p></a></li>
<li><a href='#tclustICplot'><p>Plots information criterion as a function of <code>c</code> and <code>k</code>, based on the solutions obtained by <code>tclustIC</code></p></a></li>
<li><a href='#tclustICsol'><p>Extracts a set of best relevant solutions obtained by <code>tclustIC</code></p></a></li>
<li><a href='#tclusticsol.object'><p>Objects returned by the function <code>tclustICsol</code></p></a></li>
<li><a href='#tclustreg'><p>Computes robust linear grouping analysis</p></a></li>
<li><a href='#tclustreg.object'><p>Objects returned by the function <code>tclustreg</code></p></a></li>
<li><a href='#tclustregIC'><p>Computes <code>tclustreg</code> for different number of groups <code>k</code></p>
and restriction factors <code>c</code>.</a></li>
<li><a href='#wool'><p>Wool data.</p></a></li>
<li><a href='#X'><p>Simulated data X.</p></a></li>
<li><a href='#z1'><p>z1</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Robust Data Analysis Through Monitoring and Dynamic
Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-0</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Released 0.8-1 on 2023-03-09 on CRAN</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides interface to the 'MATLAB' toolbox 'Flexible Statistical Data Analysis
    (FSDA)' which is comprehensive and computationally efficient
    software package for robust statistics in regression, multivariate
    and categorical data analysis. The current R version implements tools
    for regression: (forward search, S- and MM-estimation, least trimmed
    squares (LTS) and least median of squares (LMS)), for multivariate analysis
    (forward search, S- and MM-estimation), for cluster analysis and cluster-wise regression.
    The distinctive feature of our package is the possibility of
    monitoring the statistics of interest as a function of breakdown point,
    efficiency or subset size, depending on the estimator. This is
    accompanied by a rich set of graphical features, such as dynamic
    brushing, linking, particularly useful for exploratory data analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rJava, methods, stats4, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>robustbase, rrcov, MASS</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>(license-free) MATLAB Runtime (MCR) V 9.12, Java
(&gt;=8)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/UniprJRC/fsdaR">https://github.com/UniprJRC/fsdaR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/UniprJRC/fsdaR/issues">https://github.com/UniprJRC/fsdaR/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 21:23:26 UTC; valen</td>
</tr>
<tr>
<td>Author:</td>
<td>Valentin Todorov <a href="https://orcid.org/0000-0003-4215-0245"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Emmanuele Sordini [aut],
  Aldo Corbellini [ctb],
  Francesca Torti [ctb],
  Marco Riani [ctb],
  Domenico Perrotta [ctb],
  Andrea Cerioli [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valentin Todorov &lt;valentin.todorov@chello.at&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 03:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bank_data'>Bank data (Riani et al., 2014).</h2><span id='topic+bank_data'></span>

<h3>Description</h3>

<p>There are 60 observations on a response y with the values of three explanatory variables.
The scatter plot matrix of the data shows y increasing with each of x1, x2 and x3.
The plot of residuals against fitted values shows no obvious pattern. However the
FS finds that there are 6 masked outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bank_data)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1949 rows and 14 variables.
The variables are as follows:
</p>

<ul>
<li><p> x1: Personal loans
</p>
</li>
<li><p> x2: Financing and hire-purchase
</p>
</li>
<li><p> x3: Mortgages
</p>
</li>
<li><p> x4: Life insurance
</p>
</li>
<li><p> x5: Share amount
</p>
</li>
<li><p> x6: Bond account
</p>
</li>
<li><p> x7: Current account
</p>
</li>
<li><p> x8: Salary deposits
</p>
</li>
<li><p> x9: Debit cards
</p>
</li>
<li><p> x10: Credit cards
</p>
</li>
<li><p> x11: Telephone banking
</p>
</li>
<li><p> x12: Domestic direct debits
</p>
</li>
<li><p> x13: Money transfers
</p>
</li>
<li><p> y: Profit/loss
</p>
</li></ul>



<h3>Source</h3>

<p>Riani, M., Cerioli, A., Atkinson, A. C., and Perrotta, D. (2014). Supplement to &rdquo;Monitoring robust regression&rdquo;. doi:10.1214/14-EJS897SUPP.
</p>


<h3>References</h3>

<p>Riani, M., Cerioli, A., Atkinson, A. C., and Perrotta, D. (2014). Monitoring robust regression. <em>Electronic Journal of Statistics</em>, 8, 642-673.
</p>

<hr>
<h2 id='carbikeplot'>Produces the carbike plot to find best relevant clustering solutions obtained by <code><a href="#topic+tclustICsol">tclustICsol</a></code></h2><span id='topic+carbikeplot'></span>

<h3>Description</h3>

<p>Takes as input the output of function  <code><a href="#topic+tclustICsol">tclustICsol</a></code>
(that is a structure containing the best relevant solutions) and produces the
car-bike plot. This plot provides a concise summary of the best relevant solutions.
This plot shows on the horizontal axis the value of <code>c</code> and on the vertical axis
the value of <code>k</code>. For each solution we draw a rectangle for the interval of
values for which the solution is best and stable and a horizontal line which departs
from the rectangle for the values of <code>c</code> in which the solution is only stable.
Finally, for the best value of <code>c</code> associated to the solution, we show a circle
with two numbers, the first number indicates the ranked solution among those which are
not spurious and the second one the ranked number including the spurious solutions.
This plot has been baptized 'car-bike', because the first best solutions (in general
2 or 3) are generally best and stable for a large number of values of <code>c</code> and
therefore will have large rectangles. In addition, these solutions are likely to
be stable for additional values of <code>c</code> and therefore are likely to have horizontal
lines departing from the rectangles (from here the name 'cars'). Finally, local minor
solutions (which are associated with particular values of <code>c</code> and <code>k</code>) do not
generally present rectangles or lines and are shown with circles (from here the
name 'bikes').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carbikeplot(out, SpuriousSolutions = FALSE, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carbikeplot_+3A_out">out</code></td>
<td>
<p>An S3 object of class <code><a href="#topic+tclusticsol.object">tclusticsol.object</a></code>,
(output of <code><a href="#topic+tclustICsol">tclustICsol</a></code>) containing the relevant solutions.</p>
</td></tr>
<tr><td><code id="carbikeplot_+3A_spurioussolutions">SpuriousSolutions</code></td>
<td>
<p>Wheather to include or not spurious solutions. By default spurios
solutions are not included into the plot.</p>
</td></tr>
<tr><td><code id="carbikeplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="carbikeplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Cerioli, A., Garcia-Escudero, L.A., Mayo-Iscar, A. and Riani M. (2017).
Finding the Number of Groups in Model-Based Clustering via Constrained Likelihoods,
<em>Journal of Computational and Graphical Statistics</em>, pp. 404-416,
https://doi.org/10.1080/10618600.2017.1390469.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 

 ##  Car-bike plot for the geyser data ========================

 data(geyser2)
 out &lt;- tclustIC(geyser2, whichIC="MIXMIX", plot=FALSE, alpha=0.1)

 ## Find the best solutions using as Information criterion MIXMIX
 print("Best solutions using MIXMIX")
 outMIXMIX &lt;- tclustICsol(out, whichIC="MIXMIX", plot=FALSE, NumberOfBestSolutions=6)

 print(outMIXMIX$MIXMIXbs)

 carbikeplot(outMIXMIX)

 ##  Car-bike plot for the flea data ==========================

 data(flea)
 Y &lt;- as.matrix(flea[, 1:(ncol(flea)-1)])    # select only the numeric variables
 rownames(Y) &lt;- 1:nrow(Y)
 head(Y)

 out &lt;- tclustIC(Y, whichIC="CLACLA", plot=FALSE, alpha=0.1, nsamp=100)

 ##  Find the best solutions using as Information criterion CLACLA
 print("Best solutions using CLACLA")
 outCLACLA &lt;- tclustICsol(out,whichIC="CLACLA", plot=FALSE, NumberOfBestSolutions=66)
 ##  Produce the car-bike plot
 carbikeplot(outCLACLA)

 
## End(Not run)
</code></pre>

<hr>
<h2 id='corfwdplot'>Monitoring the correlations between consecutive distances or residuals</h2><span id='topic+corfwdplot'></span>

<h3>Description</h3>

<p>Provides a method for obtaining the maximum empirical efficiency
(in case of MM estimates) or maximum empirical breakdownplot (in case of S estimates) or
maximum subset size (in case of forward search),
using various measures of correlation between the <code>n</code> Mahalanobis distances or residuals at
adjacent values of efficiecy, breakdown point or subset size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corfwdplot(out, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corfwdplot_+3A_out">out</code></td>
<td>
<p>An object of S3 class returned by one of the estimation functions with the
monitoring option selected (<code>monitoring=TRUE</code>):
<code><a href="#topic+fsreda.object">fsreda.object</a></code>, <code><a href="#topic+sregeda.object">sregeda.object</a></code>, <code><a href="#topic+mmregeda.object">mmregeda.object</a></code>,
<code><a href="#topic+fsmeda.object">fsmeda.object</a></code>, <code><a href="#topic+smulteda.object">smulteda.object</a></code> or <code><a href="#topic+mmmulteda.object">mmmulteda.object</a></code>.
This is a list containing the monitoring of minimum Mahalanobis distance in case of
multivariate analysis or the monitoring of residuals in case of regression.
</p>
<p>The needed elements of <code>out</code> are
</p>

<ol>
<li> <p><code>MAL</code>: matrix containing the squared Mahalanobis distances monitored in each
step of the forward search. Every row is associated with a unit (row of data matrix Y).
This matrix can be created using one of the functions <code><a href="#topic+fsmult">fsmult</a></code>,
<code><a href="#topic+smult">smult</a></code> or <code><a href="#topic+mmmult">mmmult</a></code> with the monitoring option selected, i.e. <code>monitoring=TRUE</code>.
</p>
</li>
<li> <p><code>RES</code>: matrix containing the residuals monitored in each
step of the forward search. Every row is associated with a unit (row of data matrix Y).
This matrix can be created using the function <code><a href="#topic+fsreg">fsreg</a></code>  with
the monitoring option selected, i.e. <code>monitoring=TRUE</code> .
</p>
</li>
<li> <p><code>bdp</code>: a vector containing breakdown point values that have been used, in case of S estimates.
</p>
</li>
<li> <p><code>eff</code>: a vector containing efficiency values that have been used, in case of MM estimates.
</p>
</li></ol>
</td></tr>
<tr><td><code id="corfwdplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="corfwdplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> plot object which can be printed on screen or to a file.
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 

 data(hbk, package="robustbase")
 (out &lt;- fsmult(hbk[,1:3], monitoring=TRUE))
 corfwdplot(out)

 (out1 &lt;- smult(hbk, monitoring=TRUE, trace=TRUE))
 corfwdplot(out1)

 (out2 &lt;- mmmult(hbk[,1:3], monitoring=TRUE, trace=TRUE))
 corfwdplot(out2)

 (out3 &lt;- fsreg(hbk[,1:3], hbk[,4], monitoring=TRUE, trace=TRUE, method="FS"))
 corfwdplot(out3)

 (out4 &lt;- fsreg(hbk[,1:3], hbk[,4], monitoring=TRUE, trace=TRUE, method="S"))
 corfwdplot(out4)

 (out5 &lt;- fsreg(hbk[,1:3], hbk[,4], monitoring=TRUE, trace=TRUE, method="MM"))
 corfwdplot(out5)

 
## End(Not run)

</code></pre>

<hr>
<h2 id='covplot'>Monitoring of the covariance matrix</h2><span id='topic+covplot'></span>

<h3>Description</h3>

<p>Plots the trajectories of the elements of the covariance (correlation) matrix monitored
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covplot(
  out,
  xlim,
  ylim,
  xlab,
  ylab,
  main,
  lwd,
  lty,
  col,
  cex.lab,
  cex.axis,
  subsize,
  fg.thresh,
  fg.unit,
  fg.labstep,
  fg.lwd,
  fg.lty,
  fg.col,
  fg.mark,
  fg.cex,
  standard,
  fground,
  tag,
  datatooltip,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covplot_+3A_out">out</code></td>
<td>
<p>An object of S3 class <code><a href="#topic+fsmeda.object">fsmeda.object</a></code> returned by
<code><a href="#topic+fsmult">fsmult</a></code> with <code>monitoring=TRUE</code> -
a list containing the monitoring of minimum Mahalanobis distance.
</p>
<p>The needed elements of <code>out</code> are
</p>

<ol>
<li> <p><code>S2cov</code>: matrix containing the monitoring of the elements
of the covariance matrix in each step of the forward search:
</p>
</li>
<li> <p><code>Un</code>: matrix containing the order of entry of each unit
(necessary if datatooltip or databrush is selected).
</p>
</li>
<li> <p><code>X</code>: The data matrix.
</p>
</li></ol>
</td></tr>
<tr><td><code id="covplot_+3A_xlim">xlim</code></td>
<td>
<p>Controls the <code>x</code> scale in the plot. <code>xlim</code> is a vector with two elements controlling
minimum and maximum on the <code>x</code>-axis. Default is to use automatic scale.</p>
</td></tr>
<tr><td><code id="covplot_+3A_ylim">ylim</code></td>
<td>
<p>Controls the <code>y</code> scale in the plot. <code>ylim</code> is a vector with two elements controlling
minimum and maximum on the <code>y</code>-axis. Default is to use automatic scale.</p>
</td></tr>
<tr><td><code id="covplot_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis</p>
</td></tr>
<tr><td><code id="covplot_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis</p>
</td></tr>
<tr><td><code id="covplot_+3A_main">main</code></td>
<td>
<p>An overall title for the plot</p>
</td></tr>
<tr><td><code id="covplot_+3A_lwd">lwd</code></td>
<td>
<p>The line width, a positive number, defaulting to 1</p>
</td></tr>
<tr><td><code id="covplot_+3A_lty">lty</code></td>
<td>
<p>The line type. Line types can either be specified as an integer (1=solid (default), 2=dashed,
3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;solid&quot;,
&quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;.
The latter two are not supported by Matlab.</p>
</td></tr>
<tr><td><code id="covplot_+3A_col">col</code></td>
<td>
<p>Colors to be used for the highlighted units</p>
</td></tr>
<tr><td><code id="covplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The magnification to be used for x and y labels relative to the current setting of cex</p>
</td></tr>
<tr><td><code id="covplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to the current setting of cex</p>
</td></tr>
<tr><td><code id="covplot_+3A_subsize">subsize</code></td>
<td>
<p>Numeric vector containing the subset size with length equal to the number of columns of
matrix of mahalanobis distances. The default value of subsize is <code>(nrow(MAL) - ncol(MAL) + 1):nrow(MAL)</code></p>
</td></tr>
<tr><td><code id="covplot_+3A_fg.thresh">fg.thresh</code></td>
<td>
<p>(alternative to fg.unit) numeric vector of length 1 or 2 which specifies
the highlighted trajectories.
If <code>length(fg.thresh) == 1</code> the highlighted trajectories are those of units that throughtout
the search had at leat once a mahalanobis distance greater than <code>fg.thresh</code>.
The default value is <code>fg.thresh=2.5</code>. If <code>length(fg.thresh) == 2</code> the highlighted
trajectories are those of units that throughtout the search had a mahalanobis distance at
least once bigger than <code>fg.thresh[2]</code> or smaller than <code>fg.thresh[1]</code>.</p>
</td></tr>
<tr><td><code id="covplot_+3A_fg.unit">fg.unit</code></td>
<td>
<p>(alternative to fg.thresh), vector containing the list of the units to be highlighted.
If <code>fg.unit</code> is supplied, <code>fg.thresh</code> is ignored.</p>
</td></tr>
<tr><td><code id="covplot_+3A_fg.labstep">fg.labstep</code></td>
<td>
<p>numeric vector which specifies the steps of the search where to put labels for
the highlighted trajectories (units). The default is to put the labels at the
initial and final steps of the search. <code>fg.labstep=''</code> means no label.</p>
</td></tr>
<tr><td><code id="covplot_+3A_fg.lwd">fg.lwd</code></td>
<td>
<p>The line width for the highlighted trajectories (units). Default is 1.</p>
</td></tr>
<tr><td><code id="covplot_+3A_fg.lty">fg.lty</code></td>
<td>
<p>The line type for the highlighted trajectories (units). Line types can
either be specified as an integer (1=solid (default), 2=dashed,
3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;solid&quot;,
&quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;.
The latter two are not supported by Matlab.</p>
</td></tr>
<tr><td><code id="covplot_+3A_fg.col">fg.col</code></td>
<td>
<p>colors to be used for the highlighted units.</p>
</td></tr>
<tr><td><code id="covplot_+3A_fg.mark">fg.mark</code></td>
<td>
<p>Controlls whether to plot highlighted trajectories as symbols.
if <code>fg.mark==TRUE</code> each line is plotted using a different
symbol else no marker is used (default).</p>
</td></tr>
<tr><td><code id="covplot_+3A_fg.cex">fg.cex</code></td>
<td>
<p>Controls the font size of the labels of the trajectories in foreground. If
<code>fg.cex=0</code> no labels will be shown - equivalent to <code>fg.labstop=""</code>.</p>
</td></tr>
<tr><td><code id="covplot_+3A_standard">standard</code></td>
<td>
<p>MATLAB-style arguments -  appearance of the plot in terms of xlim, ylim, axes labels
and their font size style, color of the lines, etc.</p>
</td></tr>
<tr><td><code id="covplot_+3A_fground">fground</code></td>
<td>
<p>MATLAB-style arguments - for the trajectories in foregroud.</p>
</td></tr>
<tr><td><code id="covplot_+3A_tag">tag</code></td>
<td>
<p>Plot handle. String which identifies the handle of the plot which is about to be created.
The default is <code>tag='pl_mmd'</code>. Notice that if the program finds a plot which has
a tag equal to the one specified by the user, then the output of the new plot overwrites
the existing one in the same window else a new window is created.</p>
</td></tr>
<tr><td><code id="covplot_+3A_datatooltip">datatooltip</code></td>
<td>
<p>If datatooltip is not empty the user can use the mouse in order to have
information about the unit selected, the step in which the unit enters the search and
the associated label. If datatooltip is a list, it is possible to control the aspect
of the data cursor (see MATLAB function <code>datacursormode()</code> for more details or
see the examples below). The default options are <code>DisplayStyle="Window"</code> and <code>SnapToDataVertex="on"</code>.</p>
</td></tr>
<tr><td><code id="covplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="covplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 X &lt;- iris[,1:4]
 out &lt;- fsmult(X, monitoring=TRUE)

 ##  Produce monitoring covariances plot with all the default options
 covplot(out)

 
## End(Not run)

</code></pre>

<hr>
<h2 id='diabetes'>Diabetes data
</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>The diabetes dataset, introduced by Reaven and Miller (1979),
consists of 145 observations (patients). For each patient three
measurements are reported: plasma glucose response to oral glucose,
plasma insulin response to oral glucose, degree of insulin resistance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    data("diabetes")
</code></pre>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<dl>
<dt>glucose</dt><dd><p>Area under plasma glucose curve after a three hour oral glucose tolerance test (OGTT).</p>
</dd>
<dt>insulin</dt><dd><p>Area under plasma insulin curve after a three hour oral glucose tolerance test (OGTT).</p>
</dd>
<dt>sspg</dt><dd><p>Steady state plasma glucose.</p>
</dd>
<dt>class</dt><dd><p>The type of diabete: <code>Normal</code>, <code>Overt</code>, and <code>Chemical</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Reaven, G. M. and Miller, R. G. (1979). An attempt to define the nature of 
chemical diabetes using a multidimensional analysis. 
<em>Diabetologia</em> 16:17-24.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rrcov)
data(diabetes)
head(diabetes)
plot(CovMcd(diabetes[, 1:3]), which="pairs", col=diabetes$class)
</code></pre>

<hr>
<h2 id='emilia2001'>Demographic data from the 341 miniciplaities in Emilia Romagna (an Italian region).</h2><span id='topic+emilia2001'></span>

<h3>Description</h3>

<p>A data set containing 28 demographic variables for 341 municipalities in Emilia Romagna (an Italian region).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(emilia2001)
</code></pre>


<h3>Format</h3>

<p>A data frame with 341 rows and 28 variables
The variables are as follows:
</p>

<ul>
<li><p> less10: population aged less than 10
</p>
</li>
<li><p> more75: population aged more than 75
</p>
</li>
<li><p> single single-member families
</p>
</li>
<li><p> divorced&quot;: divorsed
</p>
</li>
<li><p> widows: widows and widowers
</p>
</li>
<li><p> graduates: population aged more than 25 who are graduates
</p>
</li>
<li><p> no_education:  of those aged over 6 having no education
</p>
</li>
<li><p> employed: activity rate
</p>
</li>
<li><p> unemployed: unemployment rate
</p>
</li>
<li><p> increase_popul: standardised natural increase in population
</p>
</li>
<li><p> migration: standardised change in population due to migration
</p>
</li>
<li><p> birth_92_94: average birth rate over 1992-94
</p>
</li>
<li><p> fecundity: three-year average birth rate amongst women of child-bearing age
</p>
</li>
<li><p> houses: occupied houses built since 1982
</p>
</li>
<li><p> houses_2WCs: occupied houses with 2 or more WCs
</p>
</li>
<li><p> houses_heating: occupied houses with fixed heating system
</p>
</li>
<li><p> TV: TV licence holders
</p>
</li>
<li><p> cars: number of cars for 100 inhabitants
</p>
</li>
<li><p> luxury_cars: luxury cars
</p>
</li>
<li><p> hotels: working in hotels and restaurants
</p>
</li>
<li><p> banking: working in banking and finance
</p>
</li>
<li><p> income: average declared income amongst those filing income tax returns
</p>
</li>
<li><p> income_tax_returns: inhabitants filing income tax returns
</p>
</li>
<li><p> factories: residents employed in factories and public services
</p>
</li>
<li><p> factories_more10: employees employed in factories withy more tha 10 employees
</p>
</li>
<li><p> factories_more50: employees employed in factories withy more tha 50 employees
</p>
</li>
<li><p> artisanal: artisanal enterprises
</p>
</li>
<li><p> entrepreneurs: enterpreneous and skilled self-employed among those of working age
</p>
</li></ul>

<p>@references
Atkinson, A. C., Riani, M., and Cerioli, A. (2004). <em>Exploring Multivariate Data with the Forward Search</em>. Springer-Verlag, New York.
</p>

<hr>
<h2 id='fishery'>Fishery data.</h2><span id='topic+fishery'></span>

<h3>Description</h3>

<p>The fishery data consist of 677 transactions of a fishery product in Europe.
For each transaction the Value in 1000 euro and the quantity in Tons are reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fishery)
</code></pre>


<h3>Format</h3>

<p>A data frame with 677 rows and 2 variables
</p>

<hr>
<h2 id='flea'>Flea</h2><span id='topic+flea'></span>

<h3>Description</h3>

<p>Flea-beetle measurements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flea)
</code></pre>


<h3>Format</h3>

<p>A data frame with 74 rows and 7 variables: six explanatory and one response variable - <code>species</code>.
The variables are as follows:
</p>

<ul>
<li><p> tars1: width of the first joint of the first tarsus in microns (the sum of measurements for both tarsi)
</p>
</li>
<li><p> tars2: the same for the second joint
</p>
</li>
<li><p> head: the maximal width of the head between the external edges of the eyes in 0.01 mm
</p>
</li>
<li><p> ade1: the maximal width of the aedeagus in the fore-part in microns
</p>
</li>
<li><p> ade2: the front angle of the aedeagus ( 1 unit = 7.5 degrees)
</p>
</li>
<li><p> ade3: the aedeagus width from the side in microns
</p>
</li>
<li><p> species, which species is being examined - <code>Concinna</code>, <code>Heptapotamica</code>, <code>Heikertingeri</code>
</p>
</li></ul>



<h3>References</h3>

<p>A. A. Lubischew (1962), On the Use of Discriminant Functions in Taxonomy, <em>Biometrics</em>, <b>18</b>4 pp.455&ndash;477.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(flea)
 head(flea)

</code></pre>

<hr>
<h2 id='forbes'>Forbes' data on air pressure in the Alps and the boiling point of water (Weisberg, 1985).</h2><span id='topic+forbes'></span>

<h3>Description</h3>

<p>A data set on air pressure in the Alps and the boiling point of water (Weisberg, 1985).
There are 17 observations on the boiling point of water at different pressures, obtained
from measurements at a variety of elevations in the Alps. The purpose of the experiment was
to allow prediction of pressure from boiling point, which is easily measured, and so to
provide an estimate of altitude: the higher the altitude, the lower the pressure.
The dataset is characterized by one clear outlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(forbes)
</code></pre>


<h3>Format</h3>

<p>A data frame with 17 rows and 2 variables
The variables are as follows:
</p>

<ul>
<li><p> x: boiling point
</p>
</li>
<li><p> y: 100 x log(pressure)
</p>
</li></ul>



<h3>References</h3>

<p>Weisberg, S. (1985). <em>Applied Linear Regression</em>. Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(forbes)
 plot(y~x, data=forbes)

</code></pre>

<hr>
<h2 id='fsdalms.object'>Description of <code>fsdalms</code> Objects</h2><span id='topic+fsdalms.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+fsdalms.object">fsdalms.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsreg">fsreg</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>rew</code></td>
<td>
<p>If <code>rew=TRUE</code> all subsequent output refers to reweighted else no reweighting is done.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>p-by-1 vector containing the estimated regression parameters.</p>
</td></tr>
<tr><td><code>bs</code></td>
<td>
<p>p x 1 vector containing the units forming subset associated with bLMS (bLTS).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>scale estimate of the residuals.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Vector like y containing weights. The elements of this vector are 0 or 1. 
These weights identify the h observations which are used to compute the final 
LTS (LMS) estimate. sum(weights)=h if there is not a perfect fit otherwise 
sum(weights) can be greater than h</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>The number of observations that have determined the LTS (LMS) estimator, i.e. the value of h.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>vector containing the list of the units declared as outliers using confidence level specified in input scalar conflev.</p>
</td></tr>
<tr><td><code>conflev</code></td>
<td>
<p>confidence level which is used to declare outliers. 
Remark: <code>conflev</code> will be used to draw the horizontal lines (confidence bands) in the plots. Default value is 0.975</p>
</td></tr>
<tr><td><code>singsub</code></td>
<td>
<p>Number of subsets wihtout full rank. Notice that if this number 
is greater than 0.1*(number of subsamples) a warning is produced</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector y</p>
</td></tr>
</table>
<p>The object has class <code>"fsdalms"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="LMS"))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsdalts.object'>Description of <code>fsdalts</code> Objects</h2><span id='topic+fsdalts.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+fsdalts.object">fsdalts.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsreg">fsreg</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>rew</code></td>
<td>
<p>If <code>rew=TRUE</code> all subsequent output refers to reweighted else no reweighting is done.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>p-by-1 vector containing the estimated regression parameters.</p>
</td></tr>
<tr><td><code>bs</code></td>
<td>
<p>p x 1 vector containing the units forming subset associated with bLMS (bLTS).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>scale estimate of the residuals.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Vector like y containing weights. The elements of this vector are 0 or 1. 
These weights identify the h observations which are used to compute the final 
LTS (LMS) estimate. sum(weights)=h if there is not a perfect fit otherwise 
sum(weights) can be greater than h</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>The number of observations that have determined the LTS (LMS) estimator, i.e. the value of h.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>vector containing the list of the units declared as outliers using confidence level specified in input scalar conflev.</p>
</td></tr>
<tr><td><code>conflev</code></td>
<td>
<p>confidence level which is used to declare outliers. 
Remark: <code>conflev</code> will be used to draw the horizontal lines (confidence bands) in the plots. Default value is 0.975</p>
</td></tr>
<tr><td><code>singsub</code></td>
<td>
<p>Number of subsets wihtout full rank. Notice that if this number 
is greater than 0.1*(number of subsamples) a warning is produced</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector y</p>
</td></tr>
</table>
<p>The object has class <code>"fsdalts"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="LTS"))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsmeda.object'>Description of <code>fsmeda.object</code> Objects</h2><span id='topic+fsmeda.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+fsmeda.object">fsmeda.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsmult">fsmult</a></code> when called with parameter 
<code>monitoring=TRUE</code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<p><code>MAL</code>: n x (n-init+1) matrix containing the monitoring of 
Each row represents the distance Mahalanobis distance for the corresponding unit.
</p>
<p><code>BB</code>: n x (n-init+1) matrix containing the information about the units belonging
to the subset at each step of the forward search. The first column contains the 
indexes of the units forming subset in the initial step and each further column - 
the indexes of the units forming the corresponding step. The last column contains 
the units forming subset in the final step (all units).
</p>
<p><code>md</code>: n-by-1 vector containing the estimates of the robust 
Mahalanobis distances (in squared units). This vector contains 
the distances of each observation from the location of the data, 
relative to the scatter matrix cov.
</p>
<p><code>mmd</code>: (n-init) x 3 matrix. which contains the monitoring of minimum
MD or (m+1)th ordered MD  at each step of
the forward search.
</p>

<ul>
<li><p> 1st column = fwd search index (from init to n-1)
</p>
</li>
<li><p> 2nd column = minimum MD
</p>
</li>
<li><p> 3rd column = (m+1)th-ordered MD
</p>
</li></ul>

<p><code>msr</code>: (n-init+1) x 3 matrix which contains the monitoring of maximum
MD or m-th ordered MD  at each step of the forward search.
</p>

<ul>
<li><p> 1st column = fwd search index (from init to n)
</p>
</li>
<li><p> 2nd column = maximum MD
</p>
</li>
<li><p> 3rd column = mth-ordered MD
</p>
</li></ul>

<p><code>gap</code>: (n-init+1) x 3 matrix which contains the monitoring of the gap
(difference between minMD outside subset and max inside).
</p>

<ul>
<li><p> 1st column = fwd search index (from init to n)
</p>
</li>
<li><p> 2nd column = min MD - max MD
</p>
</li>
<li><p> 3rd column = (m+1)th-ordered MD - mth ordered distance
</p>
</li></ul>

<p><code>Loc</code>: (n-init+1) x (p+1) matrix which contains the monitoring 
of the estimated means at each step of the fwd search.
</p>
<p><code>S2cov</code>: (n-init+1) x (p*(p+1)/2+1) matrix which contains the monitoring of the 
of the elements of the covariance matrix in each step of the forward search.
</p>

<ul>
<li><p> 1st column = fwd search index (from init to n)
</p>
</li>
<li><p> 2nd column = monitoring of S[1,1]
</p>
</li>
<li><p> 3rd column = monitoring of S[1,2]
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> last column = monitoring of S[p,p]
</p>
</li></ul>

<p><code>detS</code>: (n-init+1) x 2 matrix which contains the monitoring 
of the determinant of the covariance matrix in each step of 
the forward search.
</p>
<p><code>Un</code>: (n-init)-by-11 matrix which contains the unit(s) included
in the subset at each step of the fwd search.
REMARK: in every step the new subset is compared with the
old subset. Un contains the unit(s) present in the new
subset but not in the old one. Un[1 ,2] for example contains 
the unit included in step init+1.
Un[end, 2] contains the units included in the final step
of the search.   
</p>
<p><code>X</code>: the data matrix X.
</p>
<p>The object has class <code>"fsmeda"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
    data(hbk, package="robustbase")
    (out &lt;- fsmult(hbk[,1:3], monitoring=TRUE))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsmmmdrs'>Performs random start monitoring of minimum Mahalanobis distance</h2><span id='topic+fsmmmdrs'></span>

<h3>Description</h3>

<p>The trajectories originate from many different random initial subsets
and provide information on the presence of groups in the data. Groups are
investigated by monitoring the minimum Mahalanobis distance outside
the forward search subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsmmmdrs(
  x,
  plot = FALSE,
  init,
  bsbsteps,
  nsimul = 200,
  nocheck = FALSE,
  numpool,
  cleanpool = FALSE,
  msg = FALSE,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsmmmdrs_+3A_x">x</code></td>
<td>
<p>An n x p data matrix (n observations and p variables).
Rows of x represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_plot">plot</code></td>
<td>
<p>Plots the random starts minimum Mahalanobis distance with 1
If <code>plot=FALSE</code> (default) or <code>plot=0</code>  no plot is produced.
The scale (ylim) for the y axis is defined as follows:
</p>

<ul>
<li><p> ylim[2] is the maximum between the values of <code>mmd</code> in steps <code>[n*0.2 n]</code> and the final
value of the 99 per cent envelope multiplied by 1.1.
</p>
</li>
<li><p> ylim[1] is the minimum between the values of <code>mmd</code> in steps <code>[n*0.2 n]</code> and the 1 per cent envelope multiplied by 0.9.
</p>
</li></ul>

<p>Remark: the plot which is produced is very simple. In order to control a series of options
in this plot (including the y scale) and in order to connect it dynamically to the other
forward plots it is necessary to use function <code><a href="#topic+mmdrsplot">mmdrsplot</a></code>.</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_init">init</code></td>
<td>
<p>Point where to start monitoring required diagnostics.
If <code>init</code> is not specified it will be set equal to <code>(p+1)</code>.</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_bsbsteps">bsbsteps</code></td>
<td>
<p>A vector which specifies for which steps of the forward
search it is necessary to save the units forming subset for each
random start. if <code>bsbsteps = 0</code> for each random start we store
the units forming subset in all steps. The default is store the
units forming subset in all steps if <code>n &lt;= 500</code> else to store
the units forming subset at step init and steps which are multiple
of 100. For example, if <code>n = 753</code> and <code>init = 6</code>,
units forming subset are stored for <code>m=init, 100, 200, 300, 400, 500 and 600</code>.
</p>
<p>REMARK: The vector bsbsteps must contain numbers from init to n.
if <code>min(bsbsteps) &lt; init</code> a warning message will be issued.</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_nsimul">nsimul</code></td>
<td>
<p>Number of random starts. Default value is <code>nsimul=200</code>.</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_nocheck">nocheck</code></td>
<td>
<p>It controls whether to perform checks on matrix Y. If <code>nocheck=TRUE</code>,
no check is performed.</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_numpool">numpool</code></td>
<td>
<p>If <code>numpool &gt; 1</code>, the routine automatically checks if the
Parallel Computing Toolbox is installed and distributes the random starts over
numpool parallel processes. If <code>numpool &lt;= 1</code>, the random starts are run
sequentially. By default, numpool is set equal to the number of physical cores
available in the CPU (this choice may be inconvenient if other applications
are running concurrently). The same happens if the numpool value chosen by
the user exceeds the available number of cores.
</p>
<p>REMARK: up to R2013b, there was a limitation on the maximum number of cores that
could be addressed by the parallel processing toolbox (8 and, more recently, 12).
From R2014a, it is possible to run a local cluster of more than 12 workers.
</p>
<p>REMARK: Unless you adjust the cluster profile, the default maximum number of
workers is the same as the number of computational (physical) cores on the machine.
</p>
<p>REMARK: In modern computers the number of logical cores is larger than the number
of physical cores. By default, MATLAB is not using all logical cores because,
normally, hyper-threading is enabled and some cores are reserved to this feature.
</p>
<p>REMARK: It is because of Remarks 3 that we have chosen as default value for
numpool the number of physical cores rather than the number of logical ones.
The user can increase the number of parallel pool workers allocated to the
multiple start monitoring by:
</p>

<ul>
<li><p> setting the NumWorkers option in the local cluster profile settings to
the number of logical cores (Remark 2). To do so go on the menu
<em>Home|Parallel|Manage Cluster Profile</em> and set the desired
&quot;Number of workers to start on your local machine&quot;.
</p>
</li>
<li><p> setting numpool to the desired number of workers
</p>
</li></ul>

<p>Therefore, *if a parallel pool is not already open*, UserOption numpool (if set)
overwrites the number of workers set in the local/current profile. Similarly,
the number of workers in the local/current profile overwrites default value of
<code>numpool</code> obtained as feature('numCores') (i.e. the number of physical cores).</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_cleanpool">cleanpool</code></td>
<td>
<p>Set cleanpool <code>cleanpool=TRUE</code> if the parallel pool has to be cleaned
after the execution of the random starts. Otherwise (default) <code>cleanpool=FALSE</code>.
Clearly this option has an effect just if previous option <code>numpool &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_msg">msg</code></td>
<td>
<p>Level of output to sidplay. It controls whether to display or not messages
about random start progress. More precisely, if previous option <code>numpool &gt; 1</code>,
then a progress bar is displayed, on the other hand a message will be displayed on
the screen when 10
</p>
<p>REMARK: in order to create the progress bar when <code>nparpool &gt; 1</code> the program
writes on a temporary .txt file in the folder where the user is working.
Therefore it is necessary to work in a folder where the user has write
permission. If this is not the case and the user (say) is working without
write permission in folder C:/Program Files/MATLAB the following message
will appear on the screen:
</p>
<p><em>Error using ProgressBar (line 57) Do you have write permissions for C:/Program Files/MATLAB?&quot;</em></p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fsmmmdrs_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+fsmmmdrs.object">fsmmmdrs.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Atkinson, A.C., Riani, M., and Cerioli, A. (2006), Random Start Forward
Searches with Envelopes for Detecting Clusters in Multivariate Data,
in: Zani S., Cerioli A., Riani M., Vichi M., Eds., <em>Data Analysis,
Classification and the Forward Search</em>, pp. 163-172, Springer Verlag.
</p>
<p>Atkinson, A.C. and Riani, M., (2007), Exploratory Tools for Clustering
Multivariate Data, <em>Computational Statistics and Data Analysis</em>,
Vol. 52, pp. 272-285, doi:10.1016/j.csda.2006.12.034
</p>
<p>Riani, M., Cerioli, A., Atkinson, A.C., Perrotta, D. and Torti, F. (2008),
Fitting Mixtures of Regression Lines with the Forward Search, in:
<em>Mining Massive Data Sets for Security</em>, F. Fogelman-Soulie
et al. Eds., pp. 271-286, IOS Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 data(hbk, package="robustbase")
 out &lt;- fsmmmdrs(hbk[,1:3])
 class(out)
 summary(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='fsmmmdrs.object'>Description of <code>fsmmmdrs.object</code> Objects</h2><span id='topic+fsmmmdrs.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+fsmmmdrs.object">fsmmmdrs.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsmmmdrs">fsmmmdrs</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<p><code>mmdrs</code>: Minimum Mahalanobis distance, (n-init) by (nsimul+1) matrix which contains the monitoring of minimum
Mahalanobis distance at each step of the forward search.
</p>

<ul>
<li><p> 1st column  = fwd search index (from init to n-1)
</p>
</li>
<li><p> 2nd column  = minimum Mahalanobis distance for random start 1
</p>
</li>
<li><p> 3rd column ... 
</p>
</li>
<li><p> nsimul+1 column minimum Mahalanobis distance for random start nsimul
</p>
</li></ul>

<p><code>BBrs</code>: Units belonging to the subset at the steps specified by input option bsbsteps. 
If <code>bsbsteps=0</code> <code>BBrs</code> has size <code>n-by-(n-init+1)-by-nsimul</code>. In this 
case <code>BBrs[,,j]</code> with j=1, 2, ..., nsimul has the following structure:
</p>

<ul>
<li><p> 1st row  = has number 1 in correspondence of the steps in which unit 1 is included inside subset and a missing value for the other steps
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> (n-1)-th row = has number n-1 in correspondence of the steps in which unit n-1 is included inside subset and a missing value for the other steps
</p>
</li>
<li><p> n-th row = has the number n in correspondence of the steps in which unit n is included inside subset and a missing value for the other steps
</p>
</li></ul>

<p>If, on the other hand, bsbsteps is a vector which specifies the steps of the search in which 
it is necessary to store subset, BBrs has size <code>n-by-length(bsbsteps)-by-nsimul</code>.
In other words, <code>BBrs[,,j]</code> with <code>j=1, 2, ..., nsimul</code> has the same structure 
as before, but now contains just <code>length(bsbsteps)</code> columns.
</p>
<p><code>X</code>: the data matrix X.
</p>
<p>The object has class <code>"fsmmmdrs"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(hbk, package="robustbase")
    out &lt;- fsmmmdrs(hbk[,1:3])
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsmult'>Gives an automatic outlier detection procedure in multivariate analysis</h2><span id='topic+fsmult'></span>

<h3>Description</h3>

<p>Gives an automatic outlier detection procedure in multivariate analysis and
performs forward search in multivariate analysis with exploratory data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsmult(
  x,
  bsb,
  monitoring = FALSE,
  crit = c("md", "biv", "uni"),
  rf = 0.95,
  init,
  plot = FALSE,
  bonflev,
  msg = TRUE,
  nocheck = FALSE,
  scaled = FALSE,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsmult_+3A_x">x</code></td>
<td>
<p>An n x p data matrix (n observations and p variables).
Rows of x represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_bsb">bsb</code></td>
<td>
<p>List of units forming the initial subset or size of the initial subset.
If <code>monitoring=FALSE</code> the default is to start the search with <code>p+1</code>
units, containing those observations
which are not outlying on any scatterplot, found as the intersection of all points lying
within a robust contour containing a specified portion of the data (Riani and Zani 1997)
and inside the univariate boxplot.
</p>
<p>Remark: if bsb is a vector, the option crit is ignored.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_monitoring">monitoring</code></td>
<td>
<p>Wheather to perform monitoring of Mahalanobis distances and other specific quantities</p>
</td></tr>
<tr><td><code id="fsmult_+3A_crit">crit</code></td>
<td>
<p>If specified, the criterion to be used to initialize the search.
</p>

<ul>
<li><p> If <code>crit="md"</code> the units which form initial subset are those which have the
smallest <code>m0</code> pseudo Mahalanobis distances computed using procedure <code>unibiv()</code> (bivariate robust ellipses).
</p>
</li>
<li><p> If <code>crit="biv"</code> sorting is done first in terms of times units fell outside robust bivariate ellipses
and then in terms of pseudoMD. In other words, the units forming initial subset are chosen first
among the set of those which never fell outside robust bivariate ellipses then among those which
fell only once outside bivariate ellipses ... up to reach <code>m0</code>.
</p>
</li>
<li><p> If <code>crit="uni"</code> sorting is done first in terms of times units fell outside univariate boxplots and
then in terms of pseudoMD. In other words, the units forming initial subset are chosen first among
the set of those which never fell outside univariate boxplots then among those which fell only
once outside univariate boxplots... up to reach <code>m0</code>.
</p>
</li></ul>

<p>Remark: as the user can see the starting point of the search is not going to affect at all the results
of the analysis. The user can explore this point with his own datasets.
</p>
<p>Remark: if <code>crit="biv"</code> the user can also supply in scalar rf (see below) the confidence level of
the bivariate ellipses.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_rf">rf</code></td>
<td>
<p>Confidence level for bivariate ellipses. The default is 0.95. This option is useful only if <code>crit='biv'</code>.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_init">init</code></td>
<td>
<p>Point where to start monitoring required diagnostics. Note that if a vector <code>m0</code> is
supplied, <code>init &gt;= length(m0)</code>. If <code>init</code> is not specified it will be set equal to <code>floor(n*0.6)</code>.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_plot">plot</code></td>
<td>
<p>Plots the minimum Mahalanobis distance. If <code>plot=FALSE</code> (default) or <code>plot=0</code>  no plot is produced.
If <code>plot=TRUE</code> the plot of minimum MD with envelopes based on n observations and the
scatterplot matrix with the outliers highlighted is produced.
If <code>plot=2</code> the additional plots of envelope resuperimposition are produced.
If plot is a list it may contain the following fields:
</p>

<ul>
<li><p> ylim vector with two elements controlling minimum and maximum on the y axis.
Default value is &rdquo; (automatic scale)
</p>
</li>
<li><p> xlim vector with two elements controlling minimum and maximum on the x axis.
Default value is &rdquo; (automatic scale)
</p>
</li>
<li><p> resuper vector which specifies for which steps it is necessary to show the plots
of resuperimposed envelopes if resuper is not supplied a plot of each step in which
the envelope is resuperimposed is shown. Example: if <code>resuper = c(85 87)</code>
plots of resuperimposedenvelopes are shown at steps <code>m=85</code> and <code>m=87</code>
</p>
</li>
<li><p> ncoord If <code>ncoord=1</code> plots are shown in normal coordinates else (default)
plots are shown in traditional mmd coordinates
</p>
</li>
<li><p> labeladd If <code>labeladd=1</code>, the outliers in the spm are labelled with the unit
row index. The default value is <code>labeladd=""</code>, i.e. no label is added
</p>
</li>
<li><p> nameY character vector containing the labels of the variables. As default value,
the labels which are added are Y1, ...Yp.
</p>
</li>
<li><p> lwd controls line width of the curve which contains the monitoring of minimum
Mahalanobis distance. Default is <code>lwd=2</code>.
</p>
</li>
<li><p> lwdenv Controls linewidth of the envelopes. Default is <code>lwdenv=2</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fsmult_+3A_bonflev">bonflev</code></td>
<td>
<p>Option that might be used to identify extreme outliers when the distribution of
the data is strongly non normal. In these circumstances, the general signal detection rule
based on consecutive exceedances cannot be used. In this case <code>bonflev</code> can be:
</p>

<ol>
<li><p> a scalar smaller than 1, which specifies the confidence level for a signal and a stopping rule
based on the comparison of the minimum deletion residual with a Bonferroni bound.
For example if <code>bonflev=0.99</code> the procedure stops when the trajectory exceeds
for the first time the 99 per cent bonferroni bound.
</p>
</li>
<li><p> a scalar value greater than 1. In this case the procedure stops when the
residual trajectory exceeds for the first time this value.
</p>
</li></ol>

<p>Default value is empty, which means to rely on general rules based on consecutive exceedances.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_msg">msg</code></td>
<td>
<p>It controls whether to display or not messages on the screen. If <code>msg=TRUE</code>
(default) messages about the progression of the search are displayed on the screen
otherwise only error messages will be displayed.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_nocheck">nocheck</code></td>
<td>
<p>It controls whether to perform checks on matrix Y. If <code>nocheck=TRUE</code>, no check is performed.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_scaled">scaled</code></td>
<td>
<p>Controls whether to monitor scaled Mahalanobis distances (only if <code>monitoring=TRUE</code>). If <code>scaled=TRUE</code>
Mahalanobis distances monitored during the search are scaled using ratio of determinant.
If <code>scaled=2</code> Mahalanobis distances monitored during the search are scaled using
asymptotic consistency factor. The default is <code>scaled=FALSE</code>, that is Mahalanobis distances are not scaled.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fsmult_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input parameter <code>monitoring</code>, one of
the following objects will be returned:
</p>

<ol>
<li> <p><code><a href="#topic+fsmult.object">fsmult.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fsmeda.object">fsmeda.object</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Riani, M., Atkinson A.C., Cerioli A. (2009). Finding an unknown
number of multivariate outliers. Journal of the Royal Statistical
Society Series B, Vol. 71, pp. 201-221.
</p>
<p>Cerioli A., Farcomeni A., Riani M., (2014). Strong consistency and robustness
of the Forward Search estimator of multivariate location and scatter,
Journal of Multivariate Analysis, Vol. 126, pp. 167-183,
http://dx.doi.org/10.1016/j.jmva.2013.12.010.
</p>
<p>Atkinson Riani and Cerioli (2004), <em>Exploring multivariate data with the
forward search</em> Springer Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 

 data(hbk, package="robustbase")
 (out &lt;- fsmult(hbk[,1:3]))
 class(out)
 summary(out)

 ##  Generate contaminated data (200,3)
 n &lt;- 200
 p &lt;- 3
 set.seed(123456)
 X &lt;- matrix(rnorm(n*p), nrow=n)
 Xcont &lt;- X
 Xcont[1:5, ] &lt;- Xcont[1:5,] + 3

 out1 &lt;- fsmult(Xcont, trace=TRUE)           # no plots (plot defaults to FALSE)
 names(out1)

 (out1 &lt;- fsmult(Xcont, trace=TRUE, plot=TRUE))    # identical to plot=1

 ## plot=1 - minimum MD with envelopes based on n observations
 ##  and the scatterplot matrix with the outliers highlighted
 (out1 &lt;- fsmult(Xcont, trace=TRUE, plot=1))

 ## plot=2 - additional plots of envelope resuperimposition
 (out1 &lt;- fsmult(Xcont, trace=TRUE, plot=2))

 ## plots is a list: plots showing envelope superimposition in normal coordinates.
 (out1 &lt;- fsmult(Xcont, trace=TRUE, plot=list(ncoord=1)))

 ##  Choosing an initial subset formed by the three observations with
 ##  the smallest Mahalanobis Distance.

 (out1 &lt;- fsmult(Xcont, m0=5, crit="md", trace=TRUE))

 ## fsmult() with monitoring
 (out2 &lt;- fsmult(Xcont, monitoring=TRUE, trace=TRUE))
 names(out2)

 ## Monitor the exceedances from m=200 without showing plots.
 n &lt;- 1000
 p &lt;- 10
 Y &lt;- matrix(rnorm(10000), ncol=10)
 (out &lt;- fsmult(Y, init=200))

 ##  Forgery Swiss banknotes examples.

 data(swissbanknotes)

 ## Monitor the exceedances of Minimum Mahalanobis Distance
 (out1 &lt;- fsmult(swissbanknotes[101:200,], plot=1))

 ##  Control minimum and maximum on the x axis
 (out1 &lt;- fsmult(swissbanknotes[101:200,], plot=list(xlim=c(60,90))))

 ##  Monitor the exceedances of Minimum Mahalanobis Distance using
 ##  normal coordinates for mmd.
 (out1 &lt;- fsmult(swissbanknotes[101:200,], plot=list(ncoord=1)))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='fsmult.object'>Description of <code>fsmult.object</code> Objects</h2><span id='topic+fsmult.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+fsmult.object">fsmult.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsmult">fsmult</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>outliers</code></td>
<td>
<p>kx1 vector containing the list of the k units declared as outliers or NULL if the sample is homogeneous.</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>p-by-1  vector containing location of the data.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>p-by-p robust estimate of covariance matrix.</p>
</td></tr>
<tr><td><code>md</code></td>
<td>
<p>n-by-1 vector containing the estimates of the robust 
Mahalanobis distances (in squared units). This vector contains 
the distances of each observation from the location of the data, 
relative to the scatter matrix cov.</p>
</td></tr>
<tr><td><code>mmd</code></td>
<td>
<p>(n-init)-by-2 matrix. 1st col is the forward search index; 
2nd col is the value of minimum Mahalanobis Distance in each step of the fwd search.</p>
</td></tr>
<tr><td><code>Un</code></td>
<td>
<p>(n-init)-by-11 matrix which contains the unit(s) included
in the subset at each step of the fwd search.
REMARK: in every step the new subset is compared with the
old subset. Un contains the unit(s) present in the new
subset but not in the old one. Un[1 ,2] for example contains 
the unit included in step init+1.
Un[end, 2] contains the units included in the final step
of the search.</p>
</td></tr>
<tr><td><code>nout</code></td>
<td>
<p>2 x 5 matrix containing the number of times mdr went out
of particular quantiles.
First row contains quantiles 1 99 99.9 99.99 99.999.
Second row contains the frequency distribution.
It is NULL if bonflev threshold is used.</p>
</td></tr>
<tr><td><code>constr</code></td>
<td>
<p>This output is produced only if the search found at a
certain step is a non singular matrix X. In this case the
search run in a constrained mode, that is including the
units which produced a singular matrix in the last n-constr
steps. out.constr is a vector which contains the list of
units which produced a singular X matrix.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
</table>
<p>The object has class <code>"fsmult"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
    data(hbk, package="robustbase")
    (out &lt;- fsmult(hbk[,1:3]))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='FSR_control'>
Creates an <code>FSR_control</code> object
</h2><span id='topic+FSR_control'></span>

<h3>Description</h3>

<p>Creates an object of class <code>FSR_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSR_control(intercept = TRUE, h, nsamp = 1000, lms = 1, init, nocheck = FALSE, 
    bonflev = "", msg = TRUE, bsbmfullrank = TRUE, 
    plot = FALSE, bivarfit = FALSE, multivarfit = FALSE, 
    labeladd = FALSE, nameX, namey, ylim, xlim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FSR_control_+3A_intercept">intercept</code></td>
<td>

<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_h">h</code></td>
<td>

<p>The number of observations that have determined the least trimmed squares 
estimator,  scalar. <code>h</code> is an integer greater or equal than <code>p</code> 
but smaller then <code>n</code>. Generally if the purpose is outlier detection 
<code>h=[0.5*(n+p+1)]</code> (default value). <code>h</code> can be smaller than this 
threshold if the purpose is to find subgroups of homogeneous observations. 
In this function the LTS/LMS estimator is used just to initialize the search.
</p>
</td></tr>  
<tr><td><code id="FSR_control_+3A_nsamp">nsamp</code></td>
<td>

<p>Number of subsamples which will be extracted to find the robust estimator, 
scalar. If <code>nsamp=0</code> all subsets will be extracted. They will be 
<code>(n choose p)</code>. If the number of all possible subset is <code>&lt;1000</code> 
the default is to extract all subsets otherwise just 1000.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_lms">lms</code></td>
<td>

<p>Criterion to use to find the initial subset to initialize the search 
(LMS, LTS with concentration steps, LTS without concentration steps 
or subset supplied directly by the user). The default value is 1 
(Least Median of Squares is computed to initialize the search). 
On the other hand, if the user wants to initialze the search with 
LTS with all the default options for concentration steps then lms=2. 
If the user wants to use LTS without concentration steps, lms can be 
a scalar different from 1 or 2. If lms is a list it is possible 
to control a series of options for concentration steps (for more 
details see option <code>lms</code> inside <code>LXS_control</code>). 
If, on the other hand, the user wants to initialize the search with 
a prespecified set of units there are two possibilities: 
</p>

<ol>
<li><p> lms can be a vector 
with length greater than 1 which contains the list of units forming the initial 
subset. For example, if the user wants to initialize the search with units 
4, 6 and 10 then <code>lms=c(4, 6, 10)</code>; 
</p>
</li>
<li><p> lms is a struct which contains a field named bsb which contains the list of 
units to initialize the search. For example, in the case of simple regression 
through the origin with just one explanatory variable, if the user wants to 
initialize the search with unit 3 then <code>lms=list(bsb=3)</code>.
</p>
</li></ol>

</td></tr>
<tr><td><code id="FSR_control_+3A_init">init</code></td>
<td>

<p>Search initialization, scalar. It specifies the initial subset size to 
start monitoring exceedances of minimum deletion residual, if init is 
not specified it set equal to: <code>p+1</code>, if the sample size is smaller 
than 40 or <code>min(3*p+1,floor(0.5*(n+p+1)))</code>, otherwise. For example, 
if <code>init=100</code>, the procedure starts monitoring from step <code>m=100</code>.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_nocheck">nocheck</code></td>
<td>

<p>Check input arguments, scalar. If <code>nocheck=TRUE</code> no check is performed 
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code> 
are left unchanged. In other words the additional column of ones for the 
intercept is not added. As default <code>nocheck=FALSE</code>. </p>
</td></tr>
<tr><td><code id="FSR_control_+3A_bonflev">bonflev</code></td>
<td>

<p>Option to be used if the distribution of the data is strongly non normal and, 
thus, the general signal detection rule based on consecutive exceedances 
cannot be used. In this case bonflev can be:
</p>

<ol>
<li><p> a scalar smaller than 1 which specifies the confidence level for a signal 
and a stopping rule based on the comparison of the minimum MD with a Bonferroni 
bound. For example if bonflev=0.99 the procedure stops when the trajectory 
exceeds for the first time the 99% bonferroni bound.
</p>
</li>
<li><p> A scalar value greater than 1. In this case the procedure stops when 
the residual trajectory exceeds for the first time this value.
</p>
</li></ol>

<p>Default value is &rdquo;, which means to rely on general rules based on consecutive exceedances.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_msg">msg</code></td>
<td>

<p>Controls whether to display or not messages on the screen If <code>msg==1</code> (default) 
messages are displayed on the screen about step in which signal took place else 
no message is displayed on the screen.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_bsbmfullrank">bsbmfullrank</code></td>
<td>

<p>How to behave in case subset at step m (say bsbm) produces a singular X. 
In other words, this options controls what to do when <code>rank(X[bsbm, ])</code> is 
smaller then number of explanatory variables. If <code>bsbmfullrank=1</code> (default) 
these units (whose number is say mnofullrank) are constrained to enter 
the search in the final n-mnofullrank steps else the search continues using 
as estimate of beta at step m the estimate of beta found in the previous step.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_plot">plot</code></td>
<td>

<p>Plot on the screen. Scalar. If <code>plot=TRUE</code> the plot of minimum deletion 
residual with envelopes based on n observations and the scatterplot matrix with 
the outliers highlighted is produced. If <code>plot=2</code> the user can also monitor 
the intermediate plots based on envelope superimposition. 
If <code>plot=FALSE</code> (default) no plot is produced.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_bivarfit">bivarfit</code></td>
<td>
<p>Wheather to superimpose bivariate least square lines on the plot (if <code>plot=TRUE</code>.
This option adds one or more least squares lines, based on SIMPLE REGRESSION of y on Xi, 
to the plots of y|Xi. The default is <code>bivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. If <code>bivarfit=2</code>, two OLS lines are fitted: 
one to all points and another to the group of the genuine observations. 
The group of the potential outliers is not fitted. If <code>bivarfit=0</code> 
one OLS line is fitted to each group. This is useful for the purpose of 
fitting mixtures of regression lines. If <code>bivarfit='i1'</code> or 
<code>bivarfit='i2'</code>, etc. an OLS line is fitted to a specific group, 
the one with index 'i' equal to 1, 2, 3 etc. 
Again, useful in case of mixtures.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_multivarfit">multivarfit</code></td>
<td>
<p>Wheather to superimpose multivariate least square lines. 
This option adds one or more least square lines, based on MULTIVARIATE REGRESSION 
of y on X, to the plots of y|Xi. 
The default is <code>multivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. The line added to the scatter plot y|Xi is 
avconst + Ci*Xi, where Ci is the coefficient of Xi in the multivariate regression 
and avconst is the effect of all the other explanatory variables different 
from Xi evaluated at their centroid (that is overline(y)'C)). 
If <code>multivarfit=2</code>, same action as with <code>multivarfit=1</code> but this time 
we also add the line based on the group of unselected observations 
(i.e. the normal units).
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_labeladd">labeladd</code></td>
<td>
<p>Add outlier labels in plot. If <code>labeladd=TRUE</code>, we label the outliers 
with the unit row index in matrices X and y. 
The default value is <code>labeladd=FALSE</code>, i.e. no label is added.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in plot. A vector of strings of length <code>p</code> 
containing the labels of the variables of the regression dataset. 
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_namey">namey</code></td>
<td>
<p>Add response label. A string containing the label of the response
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_ylim">ylim</code></td>
<td>
<p>Control <code>y</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the y axis. Default is to use automatic scale.
</p>
</td></tr>
<tr><td><code id="FSR_control_+3A_xlim">xlim</code></td>
<td>
<p>Control <code>x</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the x axis. Default is to use automatic scale.
</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>Creates an object of class <code>FSR_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>"FSR_control"</code> which is basically a
<code><a href="base.html#topic+list">list</a></code> with components the input arguments of 
the function mapped accordingly to the corresponding Matlab function. 
</p>


<h3>Author(s)</h3>

<p>FSDA team</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Sreg_control">Sreg_control</a></code>, <code><a href="#topic+MMreg_control">MMreg_control</a></code>, <code><a href="#topic+LXS_control">LXS_control</a></code>,
<code><a href="#topic+FSReda_control">FSReda_control</a></code>, <code><a href="#topic+Sregeda_control">Sregeda_control</a></code> and <code><a href="#topic+MMregeda_control">MMregeda_control</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hbk, package="robustbase")
(out &lt;- fsreg(Y~., data=hbk, method="FS", control=FSR_control(h=56, nsamp=500, lms=2)))
summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsr.object'>Description of <code>fsr</code> Objects</h2><span id='topic+fsr.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+fsr.object">fsr.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsreg">fsreg</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>p-by-1 vector containing the estimated regression parameters (in step n-k).</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>scalar containing the estimate of the scale (sigma).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>fittedvalues</code></td>
<td>
<p>fitted values.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>kx1 vector containing the list of the k units declared as outliers or NULL if the sample is homogeneous.</p>
</td></tr>
<tr><td><code>mdr</code></td>
<td>
<p>(n-init) x 2 matrix 1st col = fwd search index, 2nd col = value of minimum deletion residual in each step of the fwd search</p>
</td></tr>
<tr><td><code>Un</code></td>
<td>
<p>(n-init) x 11 matrix which contains the unit(s) included
in the subset at each step of the fwd search.
REMARK: in every step the new subset is compared with the
old subset. Un contains the unit(s) present in the new
subset but not in the old one.
Un(1,2) for example contains the unit included in step
init+1.
Un(end,2) contains the units included in the final step
of the search.</p>
</td></tr>
<tr><td><code>nout</code></td>
<td>
<p>2 x 5 matrix containing the number of times mdr went out
of particular quantiles.
First row contains quantiles 1 99 99.9 99.99 99.999.
Second row contains the frequency distribution.</p>
</td></tr>
<tr><td><code>constr</code></td>
<td>
<p>This output is produced only if the search found at a
certain step is a non singular matrix X. In this case the
search run in a constrained mode, that is including the
units which produced a singular matrix in the last n-constr
steps. out.constr is a vector which contains the list of
units which produced a singular X matrix.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector y</p>
</td></tr>
</table>
<p>The object has class <code>"fsr"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="FS"))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsrbase'>
fsrbase: an automatic outlier detection procedure in linear regression
</h2><span id='topic+fsrbase'></span><span id='topic+fsrbase.default'></span><span id='topic+fsrbase.formula'></span>

<h3>Description</h3>

<p>An automatic outlier detection procedure in linear regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
fsrbase(x, ...) 

## S3 method for class 'formula'
fsrbase(formula, data, subset, weights, na.action,
       model = TRUE, x.ret = FALSE, y.ret = FALSE,
       contrasts = NULL, offset, ...)

## Default S3 method:
fsrbase(x, y, bsb, intercept = TRUE, 
        monitoring = FALSE, control, trace = FALSE,
        ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsrbase_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> of the form <code>y ~ x1 + x2 + ...</code>.</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_data">data</code></td>
<td>
<p>data frame from which variables specified in
<code>formula</code> are to be taken.</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used
in the fitting process. <b>NOT USED YET</b>.



</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &ldquo;factory-fresh&rdquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_model">model</code>, <code id="fsrbase_+3A_x.ret">x.ret</code>, <code id="fsrbase_+3A_y.ret">y.ret</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>s indicating if the
model frame, the model matrix and the response are to be returned,
respectively.</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list.  See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em>
known component to be included in the linear predictor
during fitting.  An <code><a href="stats.html#topic+offset">offset</a></code> term can be included in the
formula instead or as well, and if both are specified their sum is used.</p>
</td></tr> 
<tr><td><code id="fsrbase_+3A_x">x</code></td>
<td>

<p>Predictor variables. Matrix. Matrix of explanatory
variables (also called 'regressors') of dimension n x (p-1)
where p denotes the number of explanatory variables
including the intercept.
Rows of X represent observations, and columns represent
variables. By default, there is a constant term in the
model, unless you explicitly remove it using input option
<code>intercept=FALSE</code>, so do not include a column of 1s in X. Missing
values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values
will automatically be excluded from the computations.
</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_y">y</code></td>
<td>

<p>Response variable. Vector. Response variable, specified as
a vector of length n, where n is the number of
observations. Each entry in y is the response for the
corresponding row of X.
Missing values (NA's) and infinite values (Inf's) are
allowed, since observations (rows) with missing or infinite
values will automatically be excluded from the
computations.
</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_bsb">bsb</code></td>
<td>
<p>Initial subset - vector of indices. If <code>bsb=0</code> (default) then 
the procedure starts with p units randomly chosen. If bsb is not 0 the search 
will start with <code>m0=length(bsb)</code>.
</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_intercept">intercept</code></td>
<td>
<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_monitoring">monitoring</code></td>
<td>
<p>wheather to perform monitoring for several quantities 
in each step of the forward search. Deafault is <code>monitoring=FALSE</code>.</p>
</td></tr> 
<tr><td><code id="fsrbase_+3A_control">control</code></td>
<td>
<p> A control object (S3) containing estimation options, as returned 
by <code><a href="#topic+FSR_control">FSR_control</a></code>. Use the function <code><a href="#topic+FSR_control">FSR_control</a></code> and see its help page. If the 
control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, 
they will override the corresponding elements of the control object.</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fsrbase_+3A_...">...</code></td>
<td>

<p>Potential further optional arguments, see the help of the function <code><a href="#topic+FSR_control">FSR_control</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input parameter <code>monitoring</code>, one of 
the following objects will be returned: 
</p>

<ol>
<li> <p><code><a href="#topic+fsr.object">fsr.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fsreda.object">fsreda.object</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team
</p>


<h3>References</h3>

<p>Riani, M., Atkinson A.C., Cerioli A. (2009). Finding an unknown
number of multivariate outliers. Journal of the Royal Statistical
Society Series B, Vol. 71, pp. 201-221.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run: 

    n &lt;- 200
    p &lt;- 3
    
    X &lt;- matrix(data=rnorm(n*p), nrow=n, ncol=p)
    y &lt;- matrix(data=rnorm(n*1), nrow=n, ncol=1)
    (out = fsrbase(X, y))

    ## Now we use the formula interface:
    (out1 = fsrbase(y~X, control=FSR_control(plot=FALSE)))

    ## Or use the variables in a data frame
    (out2 = fsrbase(Y~., data=hbk, control=FSR_control(plot=FALSE)))

    ## let us compare to the LTS solution
    (out3 = ltsReg(Y~., data=hbk))
    
    ## Now compute the model without intercept
    (out4 = fsrbase(Y~.-1, data=hbk, control=FSR_control(plot=FALSE)))
    
    ## And compare again with the LTS solution
    (out5 = ltsReg(Y~.-1, data=hbk))

    ## using default (optional arguments)        
    (out6 = fsrbase(Y~.-1, data=hbk, control=FSR_control(plot=FALSE, nsamp=1500, h=50)))
    
## End(Not run)
</code></pre>

<hr>
<h2 id='FSReda_control'>
Creates an <code>FSReda_control</code> object
</h2><span id='topic+FSReda_control'></span>

<h3>Description</h3>

<p>Creates an object of class <code>FSReda_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSReda_control(intercept = TRUE, init, nocheck = FALSE, 
    tstat = c("trad", "scal"), conflev = c(0.95, 0.99))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FSReda_control_+3A_intercept">intercept</code></td>
<td>

<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="FSReda_control_+3A_init">init</code></td>
<td>

<p>Search initialization, scalar. It specifies the initial subset size to 
start monitoring exceedances of minimum deletion residual, if init is 
not specified it set equal to: <code>p+1</code>, if the sample size is smaller 
than 40 or <code>min(3*p+1,floor(0.5*(n+p+1)))</code>, otherwise. For example, 
if <code>init=100</code>, the procedure starts monitoring from step <code>m=100</code>.</p>
</td></tr>
<tr><td><code id="FSReda_control_+3A_nocheck">nocheck</code></td>
<td>

<p>Check input arguments, scalar. If <code>nocheck=TRUE</code> no check is performed 
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code> 
are left unchanged. In other words the additional column of ones for the 
intercept is not added. As default <code>nocheck=FALSE</code>. </p>
</td></tr>
<tr><td><code id="FSReda_control_+3A_tstat">tstat</code></td>
<td>
<p>The kind of t-statistics which have to be monitored. 
<code>tstat="trad"</code> implies monitoring of traditional t statistics 
(<code>out$Tols</code>). In this case the estimate of s2 at step m is based 
on s2m (notice that s2m&lt;&lt;s2 when m/n is small) <code>tstat="scal"</code> (default) 
implies monitoring of rescaled t statistics. In this case the estimate 
of s2 at step m is based on s2m/vartruncnorm(m/n) where vartruncnorm(m/n) 
is the variance of the truncated normal distribution.</p>
</td></tr>
<tr><td><code id="FSReda_control_+3A_conflev">conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Usually conflev=0.95, 0.975, 0.99 (individual alpha) or 
conflev=1-0.05/n, 1-0.025/n, 1-0.01/n (simultaneous alpha). 
Default value is 0.975.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an object of class <code>FSReda_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>"FSReda_control"</code> which is basically a
<code><a href="base.html#topic+list">list</a></code> with components the input arguments of 
the function mapped accordingly to the corresponding Matlab function. 
</p>


<h3>Author(s)</h3>

<p>FSDA team</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+FSR_control">FSR_control</a></code>, <code><a href="#topic+MMreg_control">MMreg_control</a></code> and <code><a href="#topic+LXS_control">LXS_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hbk, package="robustbase")
(out &lt;- fsreg(Y~., data=hbk, method="FS", monitoring=TRUE, 
    control=FSReda_control(tstat="scal")))

## End(Not run)
</code></pre>

<hr>
<h2 id='fsreda.object'>Description of <code>fsreda</code> Objects</h2><span id='topic+fsreda.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+fsreda.object">fsreda.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsreg">fsreg</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>RES</code></td>
<td>
<p>n x (n-init+1) matrix containing the monitoring of scaled residuals: 
the first row is the residual for the first unit, ..., n-th row is 
the residual for the n-th unit.</p>
</td></tr>
<tr><td><code>LEV</code></td>
<td>
<p>(n+1) x (n-init+1) matrix containing the monitoring of leverage: the first row 
is the leverage for the first unit, ..., n-th row is 
the leverage for the n-th unit.</p>
</td></tr>
<tr><td><code>BB</code></td>
<td>
<p>n x (n-init+1) matrix containing the information about the units 
belonging to the subset at each step of the forward search: first col 
contains indexes of the units forming subset in the initial step; ...; 
last column contains units forming subset in the final step (all units).</p>
</td></tr>
<tr><td><code>mdr</code></td>
<td>
<p>n-init x 3 matrix which contains the monitoring of minimum 
deletion residual or (m+1)-ordered residual at each step of the 
forward search: first col is the fwd search index (from init to n-1);
2nd col = minimum deletion residual; 3rd col = (m+1)-ordered residual.
</p>
<p>Remark: these quantities are stored with sign, that is the min deletion 
residual is stored with negative sign if it corresponds to a negative 
residual.</p>
</td></tr>
<tr><td><code>msr</code></td>
<td>
<p>n-init+1 x 3 matrix which contains the monitoring of maximum 
studentized residual or m-th ordered residual: first col is the 
fwd search index (from init to n); 2nd col = maximum studentized residual; 
3rd col = (m)-ordered studentized residual.</p>
</td></tr>
<tr><td><code>nor</code></td>
<td>
<p>(n-init+1) x 4 matrix containing the monitoring of normality 
test in each step of the forward search: first col = fwd search 
index (from init to n); 2nd col = Asymmetry test; 
3rd col = Kurtosis test; 4th col = Normality test.</p>
</td></tr>
<tr><td><code>Bols</code></td>
<td>
<p>(n-init+1) x (p+1) matrix containing the monitoring of 
estimated beta coefficients in each step of the forward search.</p>
</td></tr>
<tr><td><code>S2</code></td>
<td>
<p>(n-init+1) x 5 matrix containing the monitoring of S2 or R2 and F-test 
in each step of the forward search: 
</p>

<ol>
<li><p> 1st col = fwd search index (from init to n);
</p>
</li>
<li><p> 2nd col = monitoring of S2;
</p>
</li>
<li><p> 3rd col = monitoring of R2;
</p>
</li>
<li><p> 4th col = monitoring of rescaled S2. In this case the
estimated of sigma^2 at step m is divided by the
consistency factor (to make the estimate asymptotically
unbiased)
</p>
</li>
<li><p> 5th col = monitoring of F test. Note that an asymptotic
unbiased estimate of sigma^2 is used.
</p>
</li></ol>

<p>In this case the estimated of s2 at step m is divided by the 
consistency factor (to make the estimate asymptotically unbiased).</p>
</td></tr>
<tr><td><code>coo</code></td>
<td>
<p>(n-init+1) x 3 matrix containing the monitoring of Cook or 
modified Cook distance in each step of the forward search:
</p>

<ol>
<li><p> 1st col = fwd search index (from init to n);
</p>
</li>
<li><p> 2nd col = monitoring of Cook distance;
</p>
</li>
<li><p> 3rd col = monitoring of modified Cook distance.
</p>
</li></ol>
</td></tr>
<tr><td><code>Tols</code></td>
<td>
<p>(n-init+1) x (p+1) matrix containing the monitoring of 
estimated t-statistics (as specified in option input 'tstat') 
in each step of the forward search</p>
</td></tr>
<tr><td><code>Un</code></td>
<td>
<p>(n-init) x 11 matrix which contains the unit(s) included in the 
subset at each step of the fwd search. 
</p>
<p>REMARK: in every step the new subset is compared with the old subset. 
Un contains the unit(s) present in the new subset but not in the old 
one Un(1,2) for example contains the unit included in step init+1 
Un(end,2) contains the units included in the final step of the search.</p>
</td></tr>
<tr><td><code>betaINT</code></td>
<td>
<p>Confidence intervals for the elements of 
&beta;. betaINT is 
a (n-init+1)-by-2*length(confint)-by-p 3D array. Each third dimension 
refers to an element of beta: 
</p>

<ol>
<li> <p><code>betaINT[,,1]</code> is associated with first element of beta;
</p>
</li>
<li><p> ...;
</p>
</li>
<li> <p><code>betaINT[,,p]</code> is associated with last element of beta.
</p>
</li></ol>

<p>The first two columns contain the lower and upper confidence 
limits associated with conflev(1). Columns three and four contain 
the lower and upper confidence limits associated with conflev(2); ...;
The last two columns contain the lower and upper confidence 
limits associated with conflev(end).
For example <code>betaINT[,3:4,5]</code> contain the lower and upper confidence limits 
for the fifth element of beta using confidence level specified in 
the second element of input option <code>conflev</code>.</p>
</td></tr>
<tr><td><code>sigma2INT</code></td>
<td>
<p>confidence interval for s2.
</p>

<ol>
<li><p> 1st col = fwd search index;
</p>
</li>
<li><p> 2nd col = lower confidence limit based on conflev(1);
</p>
</li>
<li><p> 3rd col = upper confidence limit based on conflev(1);
</p>
</li>
<li><p> 4th col = lower confidence limit based on conflev(2);
</p>
</li>
<li><p> 5th col = upper confidence limit based on conflev(2);
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> penultimate col = lower confidence limit based on conflev(end);
</p>
</li>
<li><p> last col = upper confidence limit based on conflev(end).
</p>
</li></ol>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector y</p>
</td></tr>
</table>
<p>The object has class <code>"fsreda"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="FS", monitoring=TRUE))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='fsreg'>
fsreg: an automatic outlier detection procedure in linear regression
</h2><span id='topic+fsreg'></span><span id='topic+fsreg.default'></span><span id='topic+fsreg.formula'></span><span id='topic+print.fsr'></span><span id='topic+print.sreg'></span><span id='topic+print.mmreg'></span><span id='topic+print.fsdalms'></span><span id='topic+print.fsdalts'></span><span id='topic+print.fsreda'></span><span id='topic+print.sregeda'></span><span id='topic+print.mmregeda'></span>

<h3>Description</h3>

<p>An automatic outlier detection procedure in linear regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
fsreg(x, ...) 

## S3 method for class 'formula'
fsreg(formula, data, subset, weights, na.action,
       model = TRUE, x.ret = FALSE, y.ret = FALSE,
       contrasts = NULL, offset, ...)

## Default S3 method:
fsreg(x, y, bsb, intercept = TRUE, 
        family = c("homo", "hetero", "bayes"),
		method = c("FS", "S", "MM", "LTS", "LMS"),
        monitoring = FALSE, control, trace = FALSE,
        ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsreg_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> of the form <code>y ~ x1 + x2 + ...</code>.</p>
</td></tr>
<tr><td><code id="fsreg_+3A_data">data</code></td>
<td>
<p>data frame from which variables specified in
<code>formula</code> are to be taken.</p>
</td></tr>
<tr><td><code id="fsreg_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="fsreg_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used
in the fitting process. <b>NOT USED YET</b>.



</p>
</td></tr>
<tr><td><code id="fsreg_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &ldquo;factory-fresh&rdquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="fsreg_+3A_model">model</code>, <code id="fsreg_+3A_x.ret">x.ret</code>, <code id="fsreg_+3A_y.ret">y.ret</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>s indicating if the
model frame, the model matrix and the response are to be returned,
respectively.</p>
</td></tr>
<tr><td><code id="fsreg_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list.  See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="fsreg_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em>
known component to be included in the linear predictor
during fitting.  An <code><a href="stats.html#topic+offset">offset</a></code> term can be included in the
formula instead or as well, and if both are specified their sum is used.</p>
</td></tr> 
<tr><td><code id="fsreg_+3A_family">family</code></td>
<td>
<p>family of robust regression models, can be 'homo' for 
homoscedastic (same variance) regression model, 'hetero' for 
heteroskedastic regression model or 'bayes' Bayesian 
linear regression.  The default is <code>family='homo'</code> for homoscedastic 
regression model.</p>
</td></tr> 
<tr><td><code id="fsreg_+3A_method">method</code></td>
<td>
<p>robust regression estimation model, can be 'FS' for 
Forward search, 'S' for S regression, 'MM' for MM regression, 'LMS' or 'LTS'.  
The default is <code>method='FS'</code> for forward search estimation.</p>
</td></tr> 
<tr><td><code id="fsreg_+3A_monitoring">monitoring</code></td>
<td>
<p>wheather to perform monitoring for several quantities 
in each step of the forward search or for series of values of the 
breakdown point in case of S estimates or for series of values of the 
efficiency in case of MM estimates. Deafault is <code>monitoring=FALSE</code>.</p>
</td></tr> 
<tr><td><code id="fsreg_+3A_y">y</code></td>
<td>

<p>Response variable. Vector. Response variable, specified as
a vector of length n, where n is the number of
observations. Each entry in y is the response for the
corresponding row of X.
Missing values (NA's) and infinite values (Inf's) are
allowed, since observations (rows) with missing or infinite
values will automatically be excluded from the
computations.
</p>
</td></tr>
<tr><td><code id="fsreg_+3A_x">x</code></td>
<td>

<p>Predictor variables. Matrix. Matrix of explanatory
variables (also called 'regressors') of dimension n x (p-1)
where p denotes the number of explanatory variables
including the intercept.
Rows of X represent observations, and columns represent
variables. By default, there is a constant term in the
model, unless you explicitly remove it using input option
<code>intercept=FALSE</code>, so do not include a column of 1s in X. Missing
values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values
will automatically be excluded from the computations.
</p>
</td></tr>
<tr><td><code id="fsreg_+3A_bsb">bsb</code></td>
<td>
<p>Initial subset - vector of indices. If <code>bsb=0</code> (default) then 
the procedure starts with p units randomly chosen. If bsb is not 0 the search 
will start with <code>m0=length(bsb)</code>.
</p>
</td></tr>
<tr><td><code id="fsreg_+3A_intercept">intercept</code></td>
<td>
<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="fsreg_+3A_control">control</code></td>
<td>
<p> A control object (S3) containing estimation options. If the 
control object is supplied, the parameters from it
will be used. If parameters are passed also in the invocation statement, 
they will override the corresponding elements of the control object.</p>
</td></tr>
<tr><td><code id="fsreg_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fsreg_+3A_...">...</code></td>
<td>

<p>potential further arguments passed to lower level functions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input parameters <code>family</code> and <code>method</code>, one of 
the following objects will be returned: 
</p>

<ol>
<li> <p><code><a href="#topic+fsr.object">fsr.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+sreg.object">sreg.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mmreg.object">mmreg.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fsdalms.object">fsdalms.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fsdalts.object">fsdalts.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fsreda.object">fsreda.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+sregeda.object">sregeda.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mmregeda.object">mmregeda.object</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team
</p>


<h3>References</h3>

<p>Riani, M., Atkinson A.C., Cerioli A. (2009). Finding an unknown
number of multivariate outliers. Journal of the Royal Statistical
Society Series B, Vol. 71, pp. 201-221.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run: 

    library(robustbase)
    
    n &lt;- 200
    p &lt;- 3
    
    X &lt;- matrix(data=rnorm(n*p), nrow=n, ncol=p)
    y &lt;- matrix(data=rnorm(n*1), nrow=n, ncol=1)
    (out = fsreg(X, y))

    ## Now we use the formula interface:
    (out1 = fsreg(y~X, control=FSR_control(plot=FALSE)))

    ## Or use the variables in a data frame
    (out2 = fsreg(Y~., data=hbk, control=FSR_control(plot=FALSE)))

    ## let us compare to the LTS solution
    library(robustbase)
    (out3 = ltsReg(Y~., data=hbk))
    
    ## Now compute the model without intercept
    (out4 = fsreg(Y~.-1, data=hbk, control=FSR_control(plot=FALSE)))
    
    ## And compare again with the LTS solution
    (out5 = ltsReg(Y~.-1, data=hbk))

    ## using default (optional arguments)        
    (out6 = fsreg(Y~.-1, data=hbk, control=FSR_control(plot=FALSE, nsamp=1500, h=50)))
    
## End(Not run)
</code></pre>

<hr>
<h2 id='fsrfan'>Robust transformations for regression</h2><span id='topic+fsrfan'></span><span id='topic+fsrfan.formula'></span><span id='topic+fsrfan.default'></span><span id='topic+plot.fsrfan'></span>

<h3>Description</h3>

<p>The transformations for negative and positive responses were determined
by Yeo and Johnson (2000) by imposing the smoothness condition that the second
derivative of zYJ (<code class="reqn">\lambda</code>) with respect to y be smooth at y = 0. However some authors,
for example Weisberg (2005), query the physical interpretability of this constraint
which is oftern violated in data analysis. Accordingly, Atkinson et al. (2019) and (2020)
extend the Yeo-Johnson transformation to allow two values of the transformations
parameter: <code class="reqn">\lambda_N</code> for negative observations and <code class="reqn">\lambda_P</code> for non-negative ones.
</p>
<p>FSRfan monitors:
</p>

<ol>
<li><p> the t test associated with the constructed variable computed assuming the same transformation
parameter for positive and negative observations fixed. In short we call this test,
&quot;global score test for positive observations&quot;.
</p>
</li>
<li><p> the t test associated with the constructed variable computed assuming a different
transformation for positive observations keeping the value of the transformation parameter
for negative observations fixed. In short we call this test, &quot;test for positive observations&quot;.
</p>
</li>
<li><p> the t test associated with the constructed variable computed assuming a different
transformation for negative observations keeping the value of the transformation parameter
for positive observations fixed. In short we call this test, &quot;test for negative observations&quot;.
</p>
</li>
<li><p> the F test for the joint presence of the two constructed variables described in points 2) and 3).
</p>
</li>
<li><p> the F likelihood ratio test based on the MLE of <code class="reqn">\lambda_P</code> and <code class="reqn">\lambda_N</code>.
In this case the residual sum of squares of the null model bsaed on a single trasnformation
parameter <code class="reqn">\lambda</code> is compared with the residual sum of squares of the model based
on data transformed data using MLE of <code class="reqn">\lambda_P</code> and <code class="reqn">\lambda_N</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>fsrfan(x, ...)

## S3 method for class 'formula'
fsrfan(
  formula,
  data,
  subset,
  weights,
  na.action,
  model = TRUE,
  x.ret = FALSE,
  y.ret = FALSE,
  contrasts = NULL,
  offset,
  ...
)

## Default S3 method:
fsrfan(
  x,
  y,
  intercept = TRUE,
  plot = FALSE,
  family = c("BoxCox", "YJ", "YJpn", "YJall"),
  la = c(-1, -0.5, 0, 0.5, 1),
  lms,
  alpha = 0.75,
  h,
  init,
  msg = FALSE,
  nocheck = FALSE,
  nsamp = 1000,
  conflev = 0.99,
  xlab,
  ylab,
  main,
  xlim,
  ylim,
  lwd = 2,
  lwd.env = 1,
  trace = FALSE,
  ...
)

## S3 method for class 'fsrfan'
plot(
  x,
  conflev = 0.99,
  xlim,
  ylim,
  xlab = "Subset of size m",
  ylab = "Score test statistic",
  main = "Fan plot",
  col,
  lty,
  lwd = 2.5,
  lwd.env = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsrfan_+3A_x">x</code></td>
<td>
<p>An <code>n x p</code> data matrix (<code>n</code> observations and <code>p</code> variables).
Rows of <code>x</code> represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> of the form <code>y ~ x1 + x2 + ...</code>.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_data">data</code></td>
<td>
<p>data frame from which variables specified in
<code>formula</code> are to be taken.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used



<b>NOT USED YET</b>.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &ldquo;factory-fresh&rdquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_model">model</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the
model frame, is to be returned.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_x.ret">x.ret</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the
the model matrixis to be returned.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_y.ret">y.ret</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the
response is to be returned.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list.  See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em>
known component to be included in the linear predictor
during fitting.  An <code><a href="stats.html#topic+offset">offset</a></code> term can be included in the</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_y">y</code></td>
<td>
<p>Response variable. A vector with <code>n</code> elements that
contains the response variable.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_intercept">intercept</code></td>
<td>
<p>wheather to use constant term (default is <code>intercept=TRUE</code></p>
</td></tr>
<tr><td><code id="fsrfan_+3A_plot">plot</code></td>
<td>
<p>If <code>plot=FALSE</code> (default) no plot is produced.
If <code>plot=TRUE</code> a fan plot is shown.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_family">family</code></td>
<td>
<p>string which identifies the family of transformations which must be used. Possible values are
<code>c('BoxCox', 'YJ', 'YJpn', 'YJall')</code>. Default is <code>'BoxCox'</code>. The Box-Cox family of power
transformations equals <code class="reqn">(y^{\lambda}-1)/\lambda</code> for <code class="reqn">\lambda</code> not equal to zero, and <code class="reqn">\log(y)</code>
if <code class="reqn">\lambda = 0</code>.
The Yeo-Johnson (YJ) transformation is the Box-Cox transformation of <code class="reqn">y+1</code> for nonnegative values, and of
<code class="reqn">|y|+1</code> with parameter <code class="reqn">2-\lambda</code> for <code class="reqn">y</code> negative. Remember that BoxCox can be used only
if input y is positive. Yeo-Johnson family of transformations does not have this limitation.
If <code>family='YJpn'</code> Yeo-Johnson family is applied but in this case it is also possible
to monitor (in the output arguments <code>Scorep</code> and <code>Scoren</code>) the score test for
positive and negative observations respectively. If <code>family='YJall'</code>, it is also
possible to monitor the joint F test for the presence of the two constructed variables
for positive and negative observations.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_la">la</code></td>
<td>
<p>values of the transformation parameter for which it is necessary
to compute the score test. Default value of lambda is
<code>la=c(-1, -0.5, 0, 0.5, 1)</code>, i.e., the five most common values of lambda.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_lms">lms</code></td>
<td>
<p>how to find the initlal subset to initialize the search. If <code>lms=1</code> (default)
Least Median of Squares (LMS) is computed, else Least Trimmed Squares (LTS) is computed.
If, <code>lms</code> is matrix of size <code>p - 1 + intercept X length(la)</code> it contains in column
<code>j=1,..., lenght(la)</code> the list of units forming the initial subset for the search
associated with <code>la(j)</code>. In this case the input option <code>nsamp</code> is ignored.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_alpha">alpha</code></td>
<td>
<p>the percentage (roughly) of squared residuals whose sum will be minimized,
by default <code>alpha=0.5</code>. In general, alpha must between 0.5 and 1.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_h">h</code></td>
<td>
<p>The number of observations that have determined the least trimmed squares
estimator,  scalar. <code>h</code> is an integer greater or equal than <code>p</code> but smaller
then <code>n</code>. Generally <code>h=[0.5*(n+p+1)]</code> (default value).</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_init">init</code></td>
<td>
<p>Search initialization. It specifies the initial subset size to start
monitoring the value of the score test. If <code>init</code> is not specified it will
be set equal to: <code>p+1</code>, if the sample size is smaller than 40 or
<code>min(3 * p + 1, floor(0.5 * (n+p+1)))</code>, otherwise.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_msg">msg</code></td>
<td>
<p>Controls whether to display or not messages on the screen. If <code>msg==TRUE</code>
messages are displayed on the screen. If <code>msg=2</code>, detailed messages are displayed,
for example the information at iteration level.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_nocheck">nocheck</code></td>
<td>
<p>Whether to check input arguments. If <code>nocheck=TRUE</code> no check is performed
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code>
are left unchanged. In other words the additional column of ones for the
intercept is not added. The default is <code>nocheck=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_nsamp">nsamp</code></td>
<td>
<p>number of subsamples which will be extracted to find the robust estimator. If <code>nsamp=0</code>
all subsets will be extracted. They will be <code>n choose p</code>.
</p>
<p>Remark: if the number of all possible subset is &lt;1000 the default is to extract all subsets
otherwise just 1000. If <code>nsamp</code> is a matrix of size <code>r-by-p</code>, it contains in the rows
the subsets which sill have to be extracted. For example, if <code>p=3</code> and <code>nsamp=c(2,4,9; 23, 45, 49; 90, 34, 1)</code>
the first subset is made up of units <code>c(2, 4, 9)</code>, the second subset of units <code>c(23, 45, 49)</code>
and the third subset of units <code>c(90 34 1)</code>.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_conflev">conflev</code></td>
<td>
<p>Confidence level for the bands (default is 0.99, that is,
we plot two horizontal lines corresponding to values -2.58 and 2.58).</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_xlab">xlab</code></td>
<td>
<p>A label for the X-axis, default is 'Subset size m'</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_ylab">ylab</code></td>
<td>
<p>A label for the Y-axis, default is 'Score test statistic'</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_main">main</code></td>
<td>
<p>A label for the title, default is 'Fan plot'</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_xlim">xlim</code></td>
<td>
<p>Minimum and maximum for the X-axis</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_ylim">ylim</code></td>
<td>
<p>Minimum and maximum for the Y-axis</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_lwd">lwd</code></td>
<td>
<p>The line width of the curves which contain the score test, a positive number, default is <code>lwd=2</code></p>
</td></tr>
<tr><td><code id="fsrfan_+3A_lwd.env">lwd.env</code></td>
<td>
<p>The line width of the lines associated with the envelopes, a positive number, default is <code>lwd.env=1</code></p>
</td></tr>
<tr><td><code id="fsrfan_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_col">col</code></td>
<td>
<p>a vector specifying the colors for the lines, each
one corresponding to a <code>la</code> value. if <code>length(col) &lt; length(la)</code>,
the colors will be recycled.</p>
</td></tr>
<tr><td><code id="fsrfan_+3A_lty">lty</code></td>
<td>
<p>a vector specifying the line types for the lines, each
one corresponding to a <code>la</code> value. if <code>length(col) &lt; length(la)</code>,
the colors will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code><a href="#topic+fsrfan.object">fsrfan.object</a></code> will be returned which is basically a list
containing the following elements:
</p>

<ol>
<li> <p><code>la</code>: vector containing the values of lambda for which fan plot is constructed
</p>
</li>
<li> <p><code>bs</code>: matrix of size <code>p X length(la)</code> containing the units forming
the initial subset for each value of lambda
</p>
</li>
<li> <p><code>Score</code>: a matrix containing the values of the score test for
each value of the transformation parameter:
</p>

<ul>
<li><p> 1st col = fwd search index;
</p>
</li>
<li><p> 2nd col = value of the score test in each step of the fwd search for la[1]
</p>
</li>
<li><p> ...
</p>
</li></ul>

</li>
<li> <p><code>Scorep</code>: matrix containing the values of the score test for positive
observations for each value of the transformation parameter.
</p>
<p>Note: this output is present only if input option <code>family='YJpn'</code> or <code>family='YJall'</code>.
</p>
</li>
<li> <p><code>Scoren</code>: matrix containing the values of the score test for negative observations
for each value of the transformation parameter.
</p>
<p>Note: this output is present only if input option 'family' is 'YJpn' or 'YJall'.
</p>
</li>
<li> <p><code>Scoreb</code>: matrix containing the values of the score test for the joint
presence of both constructed variables (associated with positive and negative
observations) for each value of the transformation parameter. In this case
the reference distribution is the <code class="reqn">F</code> with 2 and <code>subset_size - p</code>
degrees of freedom.
</p>
<p>Note: this output is present only if input option <code>family='YJall'</code>.
</p>
</li>
<li> <p><code>Un</code>: a three-dimensional array containing <code>length(la)</code> matrices of
size <code>retnUn=(n-init) X retpUn=11</code>. Each matrix contains
the unit(s) included in the subset at each step in the search associated
with the corresponding element of <code>la</code>.
</p>
<p>REMARK: at each step the new subset is compared with the old subset.
<code>Un</code> contains the unit(s) present in the new subset but not in the old one.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Atkinson, A.C. and Riani, M. (2000), <em>Robust Diagnostic Regression Analysis</em> Springer Verlag, New York.
</p>
<p>Atkinson, A.C. and Riani, M. (2002), Tests in the fan plot for robust, diagnostic transformations in regression,
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>60</b>, pp. 87&ndash;100.
</p>
<p>Atkinson, A.C. Riani, M. and  Corbellini A. (2019), The analysis of transformations for profit-and-loss data,
<em>Journal of the Royal Statistical Society, Series C, &quot;Applied Statistics&quot;</em>, <b>69</b>, pp. 251&ndash;275.
<a href="https://doi.org/10.1111/rssc.12389">doi:10.1111/rssc.12389</a>
</p>
<p>Atkinson, A.C. Riani, M. and Corbellini A. (2021), The Box-Cox Transformation: Review and Extensions,
<em>Statistical Science</em>, <b>36</b>(2), pp. 239&ndash;255. <a href="https://doi.org/10.1214/20-STS778">doi:10.1214/20-STS778</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
   data(wool)
   XX &lt;- wool
   y &lt;- XX[, ncol(XX)]
   X &lt;- XX[, 1:(ncol(XX)-1), drop=FALSE]

   out &lt;- fsrfan(X, y)                   # call 'fsrfan' with all default parameters
   out &lt;- fsrfan(cycles~., data=wool)    # use the formula interface

   set.seed(10)
   out &lt;- fsrfan(cycles~., data=wool, plot=TRUE) # call 'fsrfan' and produce the plot
   plot(out)                               # use the plot method on the fsrfan object
   plot(out, conflev=c(0.9, 0.95, 0.99))   # change the confidence leel in the plot method

 ##======================
 ##
 ##  fsrfan() with all default options.

 ##  Store values of the score test statistic for the five most common
 ##  values of $\lambda$. Produce also a fan plot and display it on the screen.
 ##  Common part to all examples: load 'wool' data set.
 data(wool)
 head(wool)
 dim(wool)
 ##  The function fsrfan() stores the score test statistic.
 ##  In this case we use the five most common values of lambda are considered

 out &lt;- fsrfan(cycles~., data=wool)
 plot(out)
 ##  fanplot(out)                # Not yet implemented in fsdaR

 ##  The fan plot shows the log transformation is diffused throughout the data
 ##  and does not depend on the presence of particular observations.
 ##======================
 ##
 ##  Example specifying 'lambda'.
 ##      Produce a fan plot for each value of 'lambda' in the vector 'la'.
 ##      Extract in matrix 'Un' the units which entered the search in each step

     data(wool)
     out &lt;- fsrfan(cycles~., data=wool, la=c(-1, -0.5, 0, 0.5), plot=TRUE)
     plot(out)

     out$Un[,2,]

 ##======================
 ##  Example specifying the confidence level and the initial starting point for monitoring.
 ##  Construct the fan plot specifying the confidence level and the initial starting point
 ##  for monitoring.
     data(wool)
     out &lt;- fsrfan(cycles~., data=wool, init=ncol(wool)+1, nsamp=0, conflev=0.95, plots=TRUE)
     plot(out, conflev=0.95)

 ##=====================
 ##  Example with starting point based on LTS.
 ##  Extract all subsamples, construct a fan plot specifying the confidence level
 ##  and the initial starting point for monitoring based on p+2 observations,
 ##  strong line width for lines associated with the confidence bands.
     data(wool)
     out &lt;- fsrfan(cycles~., data=wool, init=ncol(wool)+1, nsamp=0, lms=0,
         lwd.env=3, plot=TRUE)
     plot(out, lwd.env=3)

 ##=====================
 ##  Fan plot using the loyalty cards data.
 ##  In this example, 'la' is the vector contanining the most common values
 ##  of the transformation parameter.
 ##  Store the score test statistics for the specified values of lambda
 ##  and automatically produce the fan plot
     data(loyalty)
     head(loyalty)
     dim(loyalty)

 ##  la is a vector contanining the most common values of the transformation parameter
     out &lt;- fsrfan(amount_spent~., data=loyalty, la=c(0, 1/3, 0.4, 0.5),
           init=ncol(loyalty)+1, plot=TRUE, lwd=3)
     plot(out, lwd=3)

 ##  The fan plot shows that even if the third root is the best value of the transformation
 ##  parameter at the end of the search, in earlier steps it lies very close to the upper
 ##  rejection region. The best value of the transformation parameter seems to be the one
 ##  associated with la=0.4, which is always the confidence bands but at the end of search,
 ##  due to the presence of particular observations it goes below the lower rejection line.

 ##=====================
 ##  Compare BoxCox with Yeo and Johnson transformation.
 ##  Store values of the score test statistic for the five most common
 ##  values of lambda. Produce also a fan plot and display it on the screen.
 ##  Common part to all examples: load wool dataset.

     data(wool)

     ##  Store the score test statistic using Box Cox transformation.
     outBC &lt;- fsrfan(cycles~., data=wool, nsamp=0)

     ##  Store the score test statistic using Yeo and Johnson transformation.
     outYJ &lt;- fsrfan(cycles~., data=wool, family="YJ", nsamp=0)

     ## Not yet fully implemented
     ##  fanplot(outBC, main="Box Cox")
     ##  fanplot(outYJ,main="Yeo and Johnson")

     plot(outBC, main="Box Cox")
     plot(outYJ, main="Yeo and Johnson")

     cat("\nMaximum difference in absolute value: ",
         max(max(abs(outYJ$Score - outBC$Score), na.rm=TRUE)), "\n")




 ##======================
   ## Call 'fsrfan' with Yeo-Johnson (YJ) transformation
   out &lt;- fsrfan(cycles~., data=wool, family="YJ")
   plot(out)


## End(Not run)

</code></pre>

<hr>
<h2 id='fsrfan.object'>Objects returned by the function <code><a href="#topic+fsrfan">fsrfan</a></code></h2><span id='topic+fsrfan.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+fsrfan.object">fsrfan.object</a></code> holds information about
the result of a call to <code><a href="#topic+fsrfan">fsrfan</a></code>.
</p>


<h3>Value</h3>

<p>The functions <code>print()</code> and <code>summary()</code> are used to obtain and print a
summary of the results. An object of class <code>fsrfan</code> is a list containing at least the following components:
</p>

<ol>
<li> <p><code>la</code> vector containing the values of lambda for which fan plot is constructed
</p>
</li>
<li> <p><code>bs</code> matrix of size <code>p X length(la)</code> containing the units forming
the initial subset for each value of lambda
</p>
</li>
<li> <p><code>Score</code> a matrix containing the values of the score test for
each value of the transformation parameter:
</p>

<ul>
<li><p> 1st col = fwd search index;
</p>
</li>
<li><p> 2nd col = value of the score test in each step of the fwd search for la[1]
</p>
</li>
<li><p> ...
</p>
</li></ul>

</li>
<li> <p><code>Scorep</code> matrix containing the values of the score test for positive
observations for each value of the transformation parameter.
</p>
<p>Note: this output is present only if input option <code>family='YJpn'</code> or <code>family='YJall'</code>.
</p>
</li>
<li> <p><code>Scoren</code> matrix containing the values of the score test for negative observations
for each value of the transformation parameter.
</p>
<p>Note: this output is present only if input option 'family' is 'YJpn' or 'YJall'.
</p>
</li>
<li> <p><code>Scoreb</code> matrix containing the values of the score test for the joint
presence of both constructed variables (associated with positive and negative
observations) for each value of the transformation parameter. In this case
the reference distribution is the <code class="reqn">F</code> with 2 and <code>subset_size - p</code>
degrees of freedom.
</p>
<p>Note: this output is present only if input option <code>family='YJall'</code>.
</p>
</li>
<li> <p><code>Un</code> a three-dimensional array containing <code>length(la)</code> matrices of
size <code>retnUn=(n-init) X retpUn=11</code>. Each matrix contains
the unit(s) included in the subset at each step in the search associated
with the corresponding element of <code>la</code>.
</p>
<p>REMARK: at each step the new subset is compared with the old subset.
<code>Un</code> contains the unit(s) present in the new subset but not in the old one.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   data(wool)
   XX &lt;- wool
   y &lt;- XX[, ncol(XX)]
   X &lt;- XX[, 1:(ncol(XX)-1), drop=FALSE]

   out &lt;- fsrfan(X, y)

   class(out)
   summary(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='geyser2'>Old Faithful Geyser Data.</h2><span id='topic+geyser2'></span>

<h3>Description</h3>

<p>A bivariate data set obtained from the Old Faithful Geyser, containing the eruption
length and the length of the previous eruption for 271 eruptions of this geyser in minutes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geyser2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 271 rows and 2 variables
The variables are as follows:
</p>

<ul>
<li><p> Eruption length: The eruption length in minutes.
</p>
</li>
<li><p> Previous eruption length: The length of the previous eruption in minutes.
</p>
</li></ul>



<h3>References</h3>

<p>Garcia-Escudero, L.A., Gordaliza, A. (1999). Robustness properties of k-means and trimmed k-means,
<em>Journal of the American Statistical Assoc.</em>, Vol.<strong>94</strong>, No.447, 956-969.
</p>
<p>Haerdle, W. (1991). <em>Smoothing Techniques with Implementation in S</em>, New York: Springer.
</p>

<hr>
<h2 id='hawkins'>Hawkins data.</h2><span id='topic+hawkins'></span>

<h3>Description</h3>

<p>These data, simulated by Hawkins, consist of 128 observations
and eight explanatory variables <code>(X1, ..., X8)</code> and one dependent variable, <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hawkins)
</code></pre>


<h3>Format</h3>

<p>A data frame with 128 rows and 9 variables
</p>

<hr>
<h2 id='hospital'>Hospital data (Neter et al., 1996)</h2><span id='topic+hospital'></span>

<h3>Description</h3>

<p>Data on the logged survival time of 108 patients undergoing liver surgery,
together with four potential explanatory variables. Data are composed of
54 observations plus other 54 observations, introduced to check the model
fitted to the first 54. Their comparison suggests there is no systematic
difference between the two sets. However by looking at some FS plots
(Riani and Atkinson, 2007), we conclude that these two groups are significantly
different
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hospital)
</code></pre>


<h3>Format</h3>

<p>A data frame with 108 rows and 5 variables
The variables are as follows:
</p>

<ul>
<li><p> X1
</p>
</li>
<li><p> X2
</p>
</li>
<li><p> X3
</p>
</li>
<li><p> X4
</p>
</li>
<li><p> y
</p>
</li></ul>

<p>@source
J. NETER, M. H. KUTNER, C. J. NACHTSHEIM, W.WASSERMAN, <em>Applied Linear Statistical Models</em> (4th edition). McGraw-Hill, New York, 1996.
</p>
<p>@references
A. C. ATKINSON, M. RIANI, <em>Robust Diagnostic Regression Analysis</em>. Springer-Verlag, New York, 2000.
</p>

<hr>
<h2 id='Income1'>Income1</h2><span id='topic+Income1'></span>

<h3>Description</h3>

<p>Income data taken from the United States Census Bureau. The data are
a random sample of 200 observations referred to four variables.
The goal is to predict HTOTVAL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Income1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 4 variables.
The variables are as follows:
</p>

<ul>
<li><p> H_NUMPER: Number of persons in household
</p>
</li>
<li><p> HOTHVAL: All other types of income except HEARNVAL Recode - Total other household income
</p>
</li>
<li><p> HSSVAL: household income - social security
</p>
</li>
<li><p> HTOTVAL: total household income (dollar amount)
</p>
</li></ul>



<h3>Source</h3>

<p>United States Census Bureau (2021). Annual Social and Economic Supplements
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(Income1)
 head(Income1)

</code></pre>

<hr>
<h2 id='Income2'>Income2</h2><span id='topic+Income2'></span>

<h3>Description</h3>

<p>A sample of 200 observations of full time employees from a municipality
in Northern Italy who have declared extra income from investment
sources. The variables are as follows.
The goal is the possibility in predicting income level based on
the individual's personal information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Income2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 6 variables.
The variables are as follows:
</p>

<ul>
<li><p> Age:  Age of the person (the minimum is 19 and the maximum is 73).
</p>
</li>
<li><p> Education: Number of years of education (the minimum value of 5 is
primary school, and the maximum value is 16 bachelor degree)
</p>
</li>
<li><p> Gender: A factor - Male or Female
</p>
</li>
<li><p> ExtraGain: Income from investment sources (profit-losses)
apart from wages/salary
</p>
</li>
<li><p> Hours: total number of declared hours worked during the week.
The minimum value is 35 and the maximum is 99
</p>
</li>
<li><p> Income: total yearly income (Euro amount)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> data(Income2)
 head(Income2)

</code></pre>

<hr>
<h2 id='levfwdplot'>
Plots the trajectories of the monitored scaled (squared) residuals
</h2><span id='topic+levfwdplot'></span>

<h3>Description</h3>

<p>Plots the trajectories of the monitored scaled (squared) residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levfwdplot(out, 
    xlim, ylim, xlab, ylab, main, lwd, lty, col, cex.lab, cex.axis, 
    xvalues, 
    fg.thresh, fg.unit, fg.labstep, fg.lwd, fg.lty, fg.col, fg.mark, fg.cex, 
    bg.thresh, bg.style, 
    xground=c("lev", "res"), tag, datatooltip, label, nameX, namey, msg, databrush, 
    standard, fground, bground, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levfwdplot_+3A_out">out</code></td>
<td>

<p>An object containing monitoring of leverage, <code><a href="#topic+fsreda.object">fsreda.object</a></code>.
</p>
<p>The needed elements of <code>out</code> are 
</p>

<ol>
<li> <p><code>LEV</code>: matrix containing the leverage monitored in each step 
of the forward search. Every row is associated with a unit.
This matrix can be created using function <code>fsreg()</code> with <code>method="FS", monitoring=TRUE</code>.
</p>
</li>
<li> <p><code>Un</code>: (for FSR only) - matrix containing the order of entry in the subset of each unit 
(required only when datatooltip is true or databrush is not empty).
</p>
</li>
<li> <p><code>y</code>: a vector containing the response (required only when option databrush is requested).
</p>
</li>
<li> <p><code>X</code>: a matrix containing the explanatory variables (required only when option databrush is requested).
</p>
</li>
<li> <p><code>Bols</code>: (n-init+1) x (p+1) matrix containing the estimated beta coefficients monitored in 
each step of the robust procedure (required only when option databrush is requested and suboption multivarfit is requested).
</p>
</li></ol>

</td></tr>
<tr><td><code id="levfwdplot_+3A_ylim">ylim</code></td>
<td>
<p>Control <code>y</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the y axis. Default is to use automatic scale.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_xlim">xlim</code></td>
<td>
<p>Control <code>x</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the x axis. Default is to use automatic scale.
</p>
</td></tr>   
<tr><td><code id="levfwdplot_+3A_xlab">xlab</code></td>
<td>

<p>a title for the x axis
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_ylab">ylab</code></td>
<td>

<p>a title for the y axis
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_main">main</code></td>
<td>

<p>an overall title for the plot
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_lwd">lwd</code></td>
<td>

<p>The line width, a positive number, defaulting to 1
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_lty">lty</code></td>
<td>

<p>The line type. Line types can either be specified as an integer (1=solid (default), 2=dashed, 
3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;solid&quot;, 
&quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;. 
The latter two are not supported by Matlab.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_col">col</code></td>
<td>

<p>colors to be used for the highlighted units
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_cex.lab">cex.lab</code></td>
<td>

<p>The magnification to be used for x and y labels relative to the current setting of cex
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_cex.axis">cex.axis</code></td>
<td>

<p>The magnification to be used for axis annotation relative to the current setting of cex
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_xvalues">xvalues</code></td>
<td>

<p>values for the x axis. Numeric vector of <code>ncol(RES)</code> controlling the x axis coordinates. 
The default value of xvalues is <code>(nrow(RES) - ncol(RES) + 1):nrow(RES)</code>
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fg.thresh">fg.thresh</code></td>
<td>

<p>(alternative to fg.unit) numeric vector of length 1 or 2 which specifies the highlighted trajectories.
If <code>length(fthresh) == 1</code> the highlighted trajectories are those of units that throughtout 
the search had at leat once a residual greater (in absolute value) than thresh. 
The default value is <code>fg.thresh=2.5</code>. If <code>length(fthresh) == 2</code> the highlighted 
trajectories are those of units that throughtout the search had a residual at 
leat once bigger than <code>fg.thresh[2]</code> or smaller than <code>fg.thresh[1]</code>.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fg.unit">fg.unit</code></td>
<td>

<p>(alternative to fg.thresh), vector containing the list of the units to be highlighted. 
If <code>fg.unit</code> is supplied, <code>fg.thresh</code> is ignored.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fg.labstep">fg.labstep</code></td>
<td>

<p>numeric vector which specifies the steps of the search where to put labels for 
the highlighted trajectories (units). The default is to put the labels at the 
initial and final steps of the search. <code>flabstep=''</code> means no label.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fg.lwd">fg.lwd</code></td>
<td>

<p>The line width for the highlighted trajectories (units). Default is 1.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fg.lty">fg.lty</code></td>
<td>

<p>The line type for the highlighted trajectories (units). Line types can 
either be specified as an integer (1=solid (default), 2=dashed, 
3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;solid&quot;, 
&quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;. 
The latter two are not supported by Matlab.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fg.col">fg.col</code></td>
<td>

<p>colors to be used for the highlighted units.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fg.mark">fg.mark</code></td>
<td>

<p>Controlls whether to plot highlighted trajectories as symbols.
if <code>fg.mark==TRUE</code> each line is plotted using a different 
symbol else no marker is used (default).
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fg.cex">fg.cex</code></td>
<td>

<p>controls the font size of the labels of the trajectories in foreground.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_bg.thresh">bg.thresh</code></td>
<td>

<p>numeric vector of length 1 or 2 which specifies how to define the unimmportant trajectories.
Unimmportant trajectories will be plotted using a colormap, in greysh or will be hidden.
If <code>length(thresh) == 1</code> the irrelevant units are those which always 
had a residual smaller (in absolute value) than thresh.
If <code>length(bthresh) == 2</code> the irrelevant units are those which always 
had a residual greater than bthresh(1) and smaller than bthresh(2). The default is:
<code>bg.thresh=2.5</code> if <code>n &gt; 100</code> and <code>bg.thresh=-Inf</code> if <code>n &lt;= 100</code> 
i.e. to treat all trajectories as important if <code>n &lt;= 100</code> and, if <code>n &gt; 100</code>, 
to reduce emphasis only to trajectories having in all steps of the search a value 
of scaled residual smaller than 2.5.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_bg.style">bg.style</code></td>
<td>

<p>specifies how to plot the unimportant trajectories as defined in option bthresh.
</p>

<ol>
<li> <p><code>bg.style="faint"</code>: unimportant trajectories are plotted using a colormap.
</p>
</li>
<li> <p><code>bg.style="hide"</code>: unimportant trajectories are hidden.
</p>
</li>
<li> <p><code>bg.style="greyish"</code>: unimportant trajectories are displayed in a faint grey.
</p>
</li></ol>

<p>When <code>n&gt;100</code> the default option is <code>bg.style='faint'</code>. When <code>n &lt;= 100</code> 
and <code>bg.thresh == -Inf</code> option bstyle is ignored.
Remark: bground=&rdquo; is equivalent to -Inf that is all trajectories are considered relevant.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_tag">tag</code></td>
<td>

<p>Plot handle. String which identifies the handle of the plot which is about to be created. 
The default is to use tag 'pl_resfwd'. Notice that if the program finds a plot which has 
a tag equal to the one specified by the user, then the output of the new plot overwrites 
the existing one in the same window else a new window is created.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_xground">xground</code></td>
<td>

<p>trajectories to highlight in connection with resfwdplot. If <code>xground="lev"</code> (default), 
the levfwdplot trajectories are put in foreground or in background depending 
on the leverage values. If <code>xground="res"</code>, the levfwdplot trajectories 
are put in foreground or in background depending on the residual values. See options 
<code>bg.thresh</code> and <code>fg.thresh</code>.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_datatooltip">datatooltip</code></td>
<td>

<p>Interactive clicking. It is inactive if this parameter is missing or empty. 
The default is <code>datatooltip=TRUE</code>, i.e. the user can select with the 
mouse an individual residual trajectory in order to have information about 
the corresponding unit. The information displayed depends on the estimator in use.
</p>
<p>For example for class <code><a href="#topic+fsreda.object">fsreda.object</a></code> the information concerns the 
label and the step of the search in which the unit enters the subset. If datatooltip 
is a list it may contain the following fields:
</p>

<ol>
<li><p> DisplayStyle determines how the data cursor displays. Possible values are 
<code>'datatip'</code> and <code>'window'</code> (default). <code>'datatip'</code> displays 
data cursor information in a small yellow text box attached to a black 
square marker at a data point you interactively select. <code>'window'</code> 
displays data cursor information for the data point you interactively 
select in a floating window within the figure.
</p>
</li>
<li><p> SnapToDataVertex: specifies whether the data cursor snaps to the nearest data value or 
is located at the actual pointer position. 
Possible values are <code>SnapToDataVertex='on'</code> (default) and <code>SnapToDataVertex='off'</code>.
</p>
</li>
<li><p> LineColor: controls the color of the trajectory selected with the mouse. It can be an RGB triplet 
of values between 0 and 1, or character vector indicating a color name. Note that a RGB vector 
can be conveniently chosen with our MATLAB class FSColor, see documentation.
</p>
</li>
<li><p> SubsetLinesColor: enables to control the color of the trajectories of the units that are 
in the subset at a given step of the search (if <code>levfwdplot()</code> is applied to an 
object of class <code><a href="#topic+fsreda.object">fsreda.object</a></code>) or have a weight greater than 0.9 (if 
<code>levfwdplot()</code> is applied to an object of class <code><a href="#topic+sregeda.object">sregeda.object</a></code> 
or <code><a href="#topic+mmregeda.object">mmregeda.object</a></code>). This can be done (repeatedly) with a left mouse 
click in proximity of the step of interest. A right mouse click will terminate the 
selection by marking with a up-arrow the step corresponding to the highlighted 
lines. The highlighted lines by default are in red, but a different color can be 
specified as RGB triplet or character of color name. Note that a RGB vector can 
be conveniently chosen with our MATLAB class FSColor, see documentation. 
By default <code>SubsetLinesColor=""</code>, i.e. the modality is not active.
Any initialization for <code>SubsetLinesColor</code> which cannot be interpreted as 
RGB vector will be converted to blue, i.e. <code>SubsetLinesColor</code> will be forced to be [0 0 1].
If <code>SubsetLinesColor</code> is not empty the previous option <code>LineColor</code> is ignored.
</p>
</li></ol>

</td></tr>
<tr><td><code id="levfwdplot_+3A_label">label</code></td>
<td>

<p>Character vector containing the labels of the units (optional argument used when 
<code>datatooltip=TRUE</code>. If this field is not present labels 
row1, ..., rown will be automatically created and included 
in the pop up datatooltip window).
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in plot. A vector of strings of length <code>p</code> 
containing the labels of the variables of the regression dataset. 
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_namey">namey</code></td>
<td>
<p>Add response label. A string containing the label of the response</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_msg">msg</code></td>
<td>

<p>Controls whether to display or not messages on the screen If <code>msg==1</code> (default) 
messages are displayed on the screen about step in which signal took place else 
no message is displayed on the screen.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_databrush">databrush</code></td>
<td>

<p>interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is a scalar or a list) enables the user to select 
a set of trajectories in the current plot and to see them highlighted in the y|X plot, 
i.e. a matrix of scatter plots of y against each column of X, grouped according to the 
selection(s) done by brushing. If the plot y|X does not exist it is automatically created.
In addition, brushed units are automatically highlighted in the minimum deletion residual 
plot if it is already open. The extension to the following plots will be available in future 
versions of the toolbox:
</p>

<ol>
<li><p> monitoring leverage plot;
</p>
</li>
<li><p> maximum studentized residual;
</p>
</li>
<li><p> s^2 and R^2;
</p>
</li>
<li><p> Cook distance and modified Cook distance;
</p>
</li>
<li><p> deletion t statistics.
</p>
</li></ol>

<p>Note that the window style of the other figures is set equal to that which contains the 
monitoring residual plot. In other words, if the monitoring residual plot is docked all 
the other figures will be docked too 
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and 
it is possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of 
function <code>selectdataFS()</code> and the following optional argument:
</p>

<ol>
<li> <p><code>persist</code>. Persist is an empty value or a character containing 'on' or 'off'. 
The default value is <code>persist=""</code>, that is brushing is allowed only once.    
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as 
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are 
added to those previously brushed. It is possible, every time a new brushing is 
done, to use a different color for the brushed units. If <code>persist='off'</code> 
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>bivarfit</code>. Wheather to superimpose bivariate least square lines on the plot (if <code>plot=TRUE</code>.
This option adds one or more least squares lines, based on SIMPLE REGRESSION of y on Xi, 
to the plots of y|Xi. The default is <code>bivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. If <code>bivarfit=2</code>, two OLS lines are fitted: 
one to all points and another to the group of the genuine observations. 
The group of the potential outliers is not fitted. If <code>bivarfit=0</code> 
one OLS line is fitted to each group. This is useful for the purpose of 
fitting mixtures of regression lines. If <code>bivarfit='i1'</code> or 
<code>bivarfit='i2'</code>, etc. an OLS line is fitted to a specific group, 
the one with index 'i' equal to 1, 2, 3 etc. 
Again, useful in case of mixtures.
</p>
</li>
<li> <p><code>multivarfit</code>. Wheather to superimpose multivariate least square lines. 
This option adds one or more least square lines, based on MULTIVARIATE REGRESSION 
of y on X, to the plots of y|Xi. 
The default is <code>multivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. The line added to the scatter plot y|Xi is 
avconst + Ci*Xi, where Ci is the coefficient of Xi in the multivariate regression 
and avconst is the effect of all the other explanatory variables different 
from Xi evaluated at their centroid (that is overline(y)'C)). 
If <code>multivarfit=2</code>, same action as with <code>multivarfit=1</code> but this time 
we also add the line based on the group of unselected observations 
(i.e. the normal units).
</p>
</li>
<li> <p><code>labeladd</code>. Add outlier labels in plot. If <code>labeladd=TRUE</code>, we label the outliers 
with the unit row index in matrices X and y. 
The default value is <code>labeladd=FALSE</code>, i.e. no label is added.
</p>
</li></ol>

</td></tr>
<tr><td><code id="levfwdplot_+3A_standard">standard</code></td>
<td>

<p>(MATLAB-style arguments) appearance of the plot in terms of xlim, ylim, axes labels 
and their font size style, color of the lines, etc.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_fground">fground</code></td>
<td>

<p>MATLAB-style arguments for the fground trajectories in foregroud.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_bground">bground</code></td>
<td>

<p>MATLAB-style arguments for the fground trajectories in backgroud.
</p>
</td></tr>
<tr><td><code id="levfwdplot_+3A_...">...</code></td>
<td>

<p>potential further arguments passed to lower level functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>No value returned
</p>


<h3>Author(s)</h3>

<p>FSDA team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

n &lt;- 100
y &lt;- rnorm(n)
X &lt;- matrix(rnorm(n*4), nrow=n)

out &lt;- fsreg(y~X, method="LTS")
out &lt;- fsreg(y~X, method="FS", bsb=out$bs, monitoring=TRUE)
levfwdplot(out)


## End(Not run)
</code></pre>

<hr>
<h2 id='loyalty'>
Loyalty data
</h2><span id='topic+loyalty'></span>

<h3>Description</h3>

<p>The loyalty data consist of 509 observations on the behaviour of 
customers with loyalty cards from a supermarket chain in Northern 
Italy. The response <code>y</code> is the amount in euros spent at the 
shop over six months and the explanatory variables are: 
X1, the number of visits to the supermarket in the six month period; 
X2, the age of the customer; 
X3, the number of members of the customers' family. 
To find out more about this data set please see Atkinson and Riani (2006), JCGS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("loyalty")</code></pre>


<h3>Format</h3>

<p>A data frame with 509 observations on the following 4 variables.
</p>

<dl>
<dt><code>visits</code></dt><dd><p>the number of visits to the supermarket in the six month period</p>
</dd>
<dt><code>age</code></dt><dd><p>the age of the customer</p>
</dd>
<dt><code>family</code></dt><dd><p>the number of members of the customers' family</p>
</dd>
<dt><code>amount_spent</code></dt><dd><p>the amount in euros spent at the shop over six months</p>
</dd>
</dl>



<h3>Details</h3>

<p>To find out more about this data set please see Atkinson and Riani (2006), JCGS
</p>


<h3>Source</h3>

<p>The data are themselves a random sample from a larger database. The sample of 509
observations is available at <a href="http://www.riani.it/trimmed/">http://www.riani.it/trimmed/</a>.
</p>


<h3>References</h3>

<p>Atkinson, A. and Riani, M (2006) Distribution Theory and Simulations for Tests of 
Outliers in Regression, <em>Journal of Computational and Graphical Statistics</em>, <b>15</b> 2, pp 460&ndash;476.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(loyalty)
</code></pre>

<hr>
<h2 id='LXS_control'>
Creates an <code>LSX_control</code> object
</h2><span id='topic+LXS_control'></span>

<h3>Description</h3>

<p>Creates an object of class <code>LXS_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    LXS_control(intercept = TRUE, lms, h, bdp, nsamp, rew = FALSE, conflev = 0, 
        msg = TRUE, nocheck = FALSE, nomes = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LXS_control_+3A_intercept">intercept</code></td>
<td>

<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="LXS_control_+3A_lms">lms</code></td>
<td>

<p>Criterion to use to find the initial subset to initialize the search 
(LMS, LTS with concentration steps, LTS without concentration steps 
or subset supplied directly by the user). The default value is 1 
(Least Median of Squares is computed to initialize the search). 
On the other hand, if the user wants to initialze the search with 
LTS with all the default options for concentration steps then lms=2. 
If the user wants to use LTS without concentration steps, lms can be 
a scalar different from 1 or 2. If lms is a list it is possible 
to control a series of options for concentration steps (for more 
details see option <code>lms</code> inside <code>LXS_control</code>). 
If, on the other hand, the user wants to initialize the search with 
a prespecified set of units there are two possibilities: 
</p>

<ol>
<li><p> lms can be a vector 
with length greater than 1 which contains the list of units forming the initial 
subset. For example, if the user wants to initialize the search with units 
4, 6 and 10 then <code>lms=c(4, 6, 10)</code>; 
</p>
</li>
<li><p> lms is a struct which contains a field named bsb which contains the list of 
units to initialize the search. For example, in the case of simple regression 
through the origin with just one explanatory variable, if the user wants to 
initialize the search with unit 3 then <code>lms=list(bsb=3)</code>.
</p>
</li></ol>

</td></tr>
<tr><td><code id="LXS_control_+3A_h">h</code></td>
<td>

<p>The number of observations that have determined the least trimmed squares 
estimator,  scalar. <code>h</code> is an integer greater or equal than <code>p</code> 
but smaller then <code>n</code>. Generally if the purpose is outlier detection 
<code>h=[0.5*(n+p+1)]</code> (default value). <code>h</code> can be smaller than this 
threshold if the purpose is to find subgroups of homogeneous observations. 
In this function the LTS/LMS estimator is used just to initialize the search.</p>
</td></tr>  
<tr><td><code id="LXS_control_+3A_bdp">bdp</code></td>
<td>
<p>Breakdown point. It measures the fraction of outliers the algorithm 
should resist. In this case any value greater than 0 but smaller or equal than 
0.5 will do fine. If on the other hand the purpose is subgroups detection then 
bdp can be greater than 0.5. In any case however n*(1-bdp) must be greater 
than p. If this condition is not fulfilled an error will be given. 
Please specify h or bdp not both.</p>
</td></tr>
<tr><td><code id="LXS_control_+3A_nsamp">nsamp</code></td>
<td>

<p>Number of subsamples which will be extracted to find the robust estimator, 
scalar. If <code>nsamp=0</code> all subsets will be extracted. They will be 
<code>(n choose p)</code>. If the number of all possible subset is <code>&lt;1000</code> 
the default is to extract all subsets otherwise just 1000.</p>
</td></tr>
<tr><td><code id="LXS_control_+3A_rew">rew</code></td>
<td>
<p>LXS reweighted - if rew=1 the reweighted version of LTS (LMS) is 
used and the output quantities refer to the reweighted version else no 
reweighting is performed (default).</p>
</td></tr>
<tr><td><code id="LXS_control_+3A_conflev">conflev</code></td>
<td>

<p>Confidence level which is used to declare units as outliers, usually <code>conflev=0.95, 0.975, 0.99</code>
(individual alpha) or 1-0.05/n, 1-0.025/n, 1-0.01/n (simultaneous alpha). Default value is 0.975.</p>
</td></tr>
<tr><td><code id="LXS_control_+3A_msg">msg</code></td>
<td>

<p>Controls whether to display or not messages on the screen If <code>msg==1</code> (default) 
messages are displayed on the screen about step in which signal took place else 
no message is displayed on the screen.</p>
</td></tr>
<tr><td><code id="LXS_control_+3A_nocheck">nocheck</code></td>
<td>

<p>Check input arguments, scalar. If <code>nocheck=TRUE</code> no check is performed 
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code> 
are left unchanged. In other words the additional column of ones for the 
intercept is not added. As default <code>nocheck=FALSE</code>. </p>
</td></tr>
<tr><td><code id="LXS_control_+3A_nomes">nomes</code></td>
<td>
<p>It controls whether to display or not on the screen messages 
about estimated time to compute LMS (LTS). If nomes is equal to 1 no message 
about estimated time to compute LMS (LTS) is displayed, else if nomes is 
equal to 0 (default), a message about estimated time is displayed.</p>
</td></tr>
<tr><td><code id="LXS_control_+3A_plot">plot</code></td>
<td>

<p>Plot on the screen. Scalar. If <code>plots=TRUE</code> the plot of minimum deletion 
residual with envelopes based on n observations and the scatterplot matrix with 
the outliers highlighted is produced. If <code>plots=2</code> the user can also monitor 
the intermediate plots based on envelope superimposition. 
If <code>plots=FALSE</code> (default) no plot is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an object of class <code>FSR_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>"LXS_control"</code> which is basically a
<code><a href="base.html#topic+list">list</a></code> with components the input arguments of 
the function mapped accordingly to the corresponding Matlab function. 
</p>


<h3>Author(s)</h3>

<p>FSDA team</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+Sreg_control">Sreg_control</a></code>, <code><a href="#topic+MMreg_control">MMreg_control</a></code> and <code><a href="#topic+FSR_control">FSR_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
data(hbk, package="robustbase")
(out &lt;- fsreg(Y~., data=hbk, method="LMS", control=LXS_control(h=56, nsamp=500, lms=2)))

## End(Not run)
</code></pre>

<hr>
<h2 id='M5data'>Mixture M5 Data.</h2><span id='topic+M5data'></span>

<h3>Description</h3>

<p>A bivariate data set obtained from three normal bivariate distributions with different scales and
proportions 1:2:2. One of the components is strongly overlapping with another one. A 10
noise is added uniformly distributed in a rectangle containing the three normal components and not
strongly overlapping with the three mixture components. A precise description of the M5 data set
can be found in Garcia-Escudero et al. (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(M5data)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 3 variables
The first two columns are the two variables. The last column is the true classification vector where symbol &quot;0&quot; stands for the contaminating data points.
</p>


<h3>Source</h3>

<p>Garcia-Escudero, L.A., Gordaliza, A., Matran, C. and Mayo-Iscar, A. (2008). A General Trimming Approach to Robust Cluster Analysis,
<em>Annals of Statistics</em>, Vol.<strong>36</strong>, 1324-1345. <a href="https://doi.org/10.1214/07-AOS515">doi:10.1214/07-AOS515</a>.
</p>

<hr>
<h2 id='malfwdplot'>Plots the trajectories of scaled Mahalanobis distances along the search</h2><span id='topic+malfwdplot'></span>

<h3>Description</h3>

<p>Plots the trajectories of scaled Mahalanobis distances along the forward search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>malfwdplot(
  out,
  xlim,
  ylim,
  xlab,
  ylab,
  main,
  lwd,
  lty,
  col,
  cex.lab,
  cex.axis,
  subsize,
  fg.thresh,
  fg.unit,
  fg.labstep,
  fg.lwd,
  fg.lty,
  fg.col,
  fg.mark,
  fg.cex,
  bg.thresh,
  bg.style,
  standard,
  fground,
  bground,
  tag,
  datatooltip,
  label,
  nameX,
  databrush,
  conflev,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="malfwdplot_+3A_out">out</code></td>
<td>
<p>An object of S3 class <code><a href="#topic+fsmeda.object">fsmeda.object</a></code> returned by
<code><a href="#topic+fsmult">fsmult</a></code> with <code>monitoring=TRUE</code> -
a list containing the monitoring of minimum Mahalanobis distance.
</p>
<p>The needed elements of <code>out</code> are
</p>

<ol>
<li> <p><code>MAL</code>: matrix containing the squared Mahalanobis distances monitored in each
step of the forward search. Every row is associated with a unit (row of data matrix X).
</p>
</li>
<li> <p><code>Un</code>: matrix containing the order of entry of each unit
(necessary if datatooltip or databrush is selected).
</p>
</li>
<li> <p><code>X</code>: The data matrix.
</p>
</li></ol>
</td></tr>
<tr><td><code id="malfwdplot_+3A_xlim">xlim</code></td>
<td>
<p>Controls the <code>x</code> scale in the plot. <code>xlim</code> is a vector with two elements controlling
minimum and maximum on the <code>x</code>-axis. Default is to use automatic scale.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_ylim">ylim</code></td>
<td>
<p>Controls the <code>y</code> scale in the plot. <code>ylim</code> is a vector with two elements controlling
minimum and maximum on the <code>y</code>-axis. Default is to use automatic scale.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis, deafult is &quot;Squared Mahalanobis distances&quot;.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_main">main</code></td>
<td>
<p>An overall title for the plot</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_lwd">lwd</code></td>
<td>
<p>The line width, a positive number, defaulting to 1</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_lty">lty</code></td>
<td>
<p>The line type. Line types can either be specified as an integer (1=solid (default), 2=dashed,
3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;solid&quot;,
&quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;.
The latter two are not supported by Matlab.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_col">col</code></td>
<td>
<p>Colors to be used for the highlighted units</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The magnification to be used for x and y labels relative to the current setting of cex</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to the current setting of cex</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_subsize">subsize</code></td>
<td>
<p>Numeric vector containing the subset size with length equal to the number of columns of
matrix of mahalanobis distances. The default value of subsize is <code>(nrow(MAL) - ncol(MAL) + 1):nrow(MAL)</code></p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fg.thresh">fg.thresh</code></td>
<td>
<p>(alternative to fg.unit) numeric vector of length 1 or 2 which specifies
the highlighted trajectories.
If <code>length(fg.thresh) == 1</code> the highlighted trajectories are those of units that throughtout
the search had at leat once a mahalanobis distance greater than <code>fg.thresh</code>.
The default value is <code>fg.thresh=2.5</code>. If <code>length(fg.thresh) == 2</code> the highlighted
trajectories are those of units that throughtout the search had a mahalanobis distance at
least once bigger than <code>fg.thresh[2]</code> or smaller than <code>fg.thresh[1]</code>.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fg.unit">fg.unit</code></td>
<td>
<p>(alternative to fg.thresh), vector containing the list of the units to be highlighted.
If <code>fg.unit</code> is supplied, <code>fg.thresh</code> is ignored.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fg.labstep">fg.labstep</code></td>
<td>
<p>numeric vector which specifies the steps of the search where to put labels for
the highlighted trajectories (units). The default is to put the labels at the
initial and final steps of the search. <code>fg.labstep=''</code> means no label.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fg.lwd">fg.lwd</code></td>
<td>
<p>The line width for the highlighted trajectories (units). Default is 1.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fg.lty">fg.lty</code></td>
<td>
<p>The line type for the highlighted trajectories (units). Line types can
either be specified as an integer (1=solid (default), 2=dashed,
3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;solid&quot;,
&quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;.
The latter two are not supported by Matlab.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fg.col">fg.col</code></td>
<td>
<p>colors to be used for the highlighted units.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fg.mark">fg.mark</code></td>
<td>
<p>Controlls whether to plot highlighted trajectories as symbols.
if <code>fg.mark==TRUE</code> each line is plotted using a different
symbol else no marker is used (default).</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fg.cex">fg.cex</code></td>
<td>
<p>Controls the font size of the labels of the trajectories in foreground. If
<code>fg.cex=0</code> no labels will be shown - equivalent to <code>fg.labstop=""</code>.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_bg.thresh">bg.thresh</code></td>
<td>
<p>Numeric vector of length 1 or 2 which specifies how to define the <em>unimmportant trajectories</em>.
Unimmportant trajectories will be plotted using a colormap, in greysh or will be hidden.
If <code>length(bg.thresh) == 1</code> the irrelevant units are those which always
had a mahalanobis distance smaller than <code>bg.thresh</code>.
If <code>length(bg.thresh) == 2</code> the irrelevant units are those which always
had a mahalanobis distance greater than <code>bg.thresh[1]</code> and smaller than <code>bg.thresh[2]</code>.
The default is <code>bg.thresh=2.5</code> if <code>n &gt; 100</code> and <code>bg.thresh=-Inf</code> if <code>n &lt;= 100</code>
i.e. to treat all trajectories as important if <code>n &lt;= 100</code> and, if <code>n &gt; 100</code>,
to reduce emphasis only to trajectories having in all steps of the search a value
of mahalanobis distance smaller than 2.5.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_bg.style">bg.style</code></td>
<td>
<p>Specifies how to plot the unimportant trajectories as defined in option bg.thresh.
</p>

<ol>
<li> <p><code>bg.style="faint"</code>: unimportant trajectories are plotted using a colormap.
</p>
</li>
<li> <p><code>bg.style="hide"</code>: unimportant trajectories are hidden.
</p>
</li>
<li> <p><code>bg.style="greyish"</code>: unimportant trajectories are displayed in a faint grey.
</p>
</li></ol>

<p>When <code>n &gt; 100</code> the default option is <code>bg.style='faint'</code>. When <code>n &lt;= 100</code>
and <code>bg.thresh == -Inf</code> option bg.style is ignored.
Remark: bground=&rdquo; is equivalent to -Inf that is all trajectories are considered relevant.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_standard">standard</code></td>
<td>
<p>MATLAB-style arguments -  appearance of the plot in terms of xlim, ylim, axes labels
and their font size style, color of the lines, etc.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_fground">fground</code></td>
<td>
<p>MATLAB-style arguments - for the trajectories in foregroud.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_bground">bground</code></td>
<td>
<p>MATLAB-style arguments - for the trajectories in backgroud.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_tag">tag</code></td>
<td>
<p>Plot handle. String which identifies the handle of the plot which is about to be created.
The default is to use tag 'pl_resfwd'. Notice that if the program finds a plot which has
a tag equal to the one specified by the user, then the output of the new plot overwrites
the existing one in the same window else a new window is created.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_datatooltip">datatooltip</code></td>
<td>
<p>Interactive clicking. It is inactive if this parameter is set to FALSE.
The default is <code>datatooltip=TRUE</code>, the user can select with the mouse an individual
mahalanobis distance trajectory in order to have information about the corresponding unit, the associated
label and the step of the search in which the unit enters the subset.
If datatooltip is a list it may contain the following fields:
</p>

<ol>
<li><p> DisplayStyle determines how the data cursor displays. Possible values are
<code>'datatip'</code> and <code>'window'</code> (default). <code>'datatip'</code> displays
data cursor information in a small yellow text box attached to a black
square marker at a data point you interactively select. <code>'window'</code>
displays data cursor information for the data point you interactively
select in a floating window within the figure.
</p>
</li>
<li><p> SnapToDataVertex: specifies whether the data cursor snaps to the nearest data value or
is located at the actual pointer position.
Possible values are <code>SnapToDataVertex='on'</code> (default) and <code>SnapToDataVertex='off'</code>.
</p>
</li>
<li><p> LineColor: controls the color of the trajectory selected with the mouse. It can be an RGB triplet
of values between 0 and 1, or character vector indicating a color name. Note that a RGB vector
can be conveniently chosen with our MATLAB class FSColor, see documentation.
</p>
</li>
<li><p> SubsetLinesColor: enables to control the color of the trajectories of the units that are
in the subset at a given step of the search (if <code>resfwdplot()</code> is applied to an
object of class <code><a href="#topic+fsreda.object">fsreda.object</a></code>) or have a weight greater than 0.9 (if
<code>resfwdplot()</code> is applied to an object of class <code><a href="#topic+sregeda.object">sregeda.object</a></code>
or <code><a href="#topic+mmregeda.object">mmregeda.object</a></code>). This can be done (repeatedly) with a left mouse
click in proximity of the step of interest. A right mouse click will terminate the
selection by marking with a up-arrow the step corresponding to the highlighted
lines. The highlighted lines by default are in red, but a different color can be
specified as RGB triplet or character of color name. Note that a RGB vector can
be conveniently chosen with our MATLAB class FSColor, see documentation.
By default <code>SubsetLinesColor=""</code>, i.e. the modality is not active.
Any initialization for <code>SubsetLinesColor</code> which cannot be interpreted as
RGB vector will be converted to blue, i.e. <code>SubsetLinesColor</code> will be forced to be [0 0 1].
If <code>SubsetLinesColor</code> is not empty the previous option <code>LineColor</code> is ignored.
</p>
</li></ol>
</td></tr>
<tr><td><code id="malfwdplot_+3A_label">label</code></td>
<td>
<p>Character vector containing the labels of the units (optional argument used when
<code>datatooltip=TRUE</code>. If this field is not present labels
row1, ..., rown will be automatically created and included
in the pop up datatooltip window).</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in plot. A vector of strings of length <code>p</code>
containing the labels of the variables in the dataset.
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_databrush">databrush</code></td>
<td>
<p>Interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is <code>TRUE</code> or a list) enables the user to select
a set of trajectories in the current plot and to see them highlighted in the scatterplot matrix.
If the scatterplot matrix does not exist it is automatically created.
In addition, brushed units can be highlighted in the monitoring mahalanobis distance plot.
Note that the window style of the other figures is set equal to that which contains the monitoring mahalanobis distance plot.
In other words, if the monitoring mahalanobis distance plot is docked all the other figures will be docked too.
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and it is
possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of
the MATLAB function <code>selectdataFS()</code> and the following optional arguments:
</p>

<ul>
<li><p> persist. Persist is an empty value or a character containing 'on' or 'off'.
The default value is <code>persist=""</code>, that is brushing is allowed only once.
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are
added to those previously brushed. It is possible, every time a new brushing is
done, to use a different color for the brushed units. If <code>persist='off'</code>
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>label</code>: add labels of brushed units in the monitoring plot.
</p>
</li>
<li> <p><code>labeladd</code>: add labels of brushed units in the scatterplot matrix.
If this option is '1', we label the units of the last selected group with
the unit row index in the matrix X. The default value is labeladd=&rdquo;,
i.e. no label is added.
</p>
</li></ul>
</td></tr>
<tr><td><code id="malfwdplot_+3A_conflev">conflev</code></td>
<td>
<p>confidence interval for the horizontal bands. It can be a vector of
different confidence level values, e.g. c(0.95, 0.99, 0.999).
The confidence interval is based on the $chi^2$ distribution.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="malfwdplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Atkinson A.C., Riani M. and Cerioli A. (2004), Exploring Multivariate Data with the Forward Search, Springer Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 ## Produce monitoring MD plot with all the default options.
 ##  Generate input structure for malfwdplot
 n &lt;- 100
 p &lt;- 4
 Y &lt;- matrix(rnorm(n*p), ncol=p)
 Y[1:10,] &lt;- Y[1:10,] + 4

 out &lt;- fsmult(Y, monitoring=TRUE, init=30)

 ##  Produce monitoring MD plot with all the default options
 malfwdplot(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='malindexplot'>Plots the trajectory of minimum Mahalanobis distance (mmd)</h2><span id='topic+malindexplot'></span>

<h3>Description</h3>

<p>Plots the trajectory of minimum Mahalanobis distance (mmd)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>malindexplot(
  out,
  p,
  xlab,
  ylab,
  main,
  nameX,
  conflev,
  numlab,
  tag,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="malindexplot_+3A_out">out</code></td>
<td>
<p>a numeric vector or an object of S3 class (one of <code><a href="#topic+fsmult.object">fsmult.object</a></code>,
<code><a href="#topic+smult.object">smult.object</a></code> or <code><a href="#topic+mmmult.object">mmmult.object</a></code>) returned by
one of the functions
<code><a href="#topic+fsmult">fsmult</a></code> or <code><a href="#topic+smult">smult</a></code> or <code><a href="#topic+mmmult">mmmult</a></code> -
a list containing the monitoring of minimum Mahalanobis distance</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_p">p</code></td>
<td>
<p>If <code>out</code> is a vector, p is the number of variables of the
original data matrix which have been used to compute md.</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_main">main</code></td>
<td>
<p>An overall title for the plot</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in the plot. A vector of strings of length <code>p</code>
containing the labels of the variables of the original data matrix <code>X</code>.
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_conflev">conflev</code></td>
<td>
<p>confidence interval for the horizontal bands. It can be a vector of
different confidence level values, e.g. c(0.95, 0.99, 0.999).
The confidence interval is based on the chi^2 distribution.</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_numlab">numlab</code></td>
<td>
<p>Number of points to be labeled in the plot. If <code>numlab</code> is a
single number, e.g. <code>numlab]k</code>, the units with the <code>k</code> largest
md are labelled in the plots. If <code>numlab</code> is a vector, the units indexed
by the vector are labelled in the plot. Default is <code>numlab=5</code>, i.e. the 5 units
units with the largest md are labelled. Use <code>numlab=""</code> for no labelling.</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_tag">tag</code></td>
<td>
<p>Tag of the figure which will host the malindexplot. The default tag is <code>tag="pl_malindex"</code>.</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="malindexplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Atkinson and Riani (2000), Robust Diagnostic Regression Analysis, Springer Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 ##  Mahalanobis distance plot of 100 random numbers.
 ##  Numbers are from from the chisq with 5 degrees of freedom

 malindexplot(rchisq(100, 5), 5)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='mdrplot'>
Plots the trajectory of minimum deletion residual (mdr)
</h2><span id='topic+mdrplot'></span>

<h3>Description</h3>

<p>Plots the trajectory of minimum deletion residual (mdr).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mdrplot(out, quant = c(0.01, 0.5, 0.99), sign = TRUE, 
        mplus1 = FALSE, envm, 
        xlim, ylim, xlab, ylab, main, 
        lwdenv, lwd, cex.lab, cex.axis, 
        tag, datatooltip, label, nameX, namey, databrush, 
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdrplot_+3A_out">out</code></td>
<td>

<p>An object returned by FSReda() (see <code><a href="#topic+FSReda_control">FSReda_control</a></code>).
</p>
<p>The needed elements of <code>out</code> are 
</p>

<ol>
<li> <p><code>mdr</code>: Minimum deletion residual. A matrix containing the monitoring of 
minimum deletion residual in each step of the forward search. The first column 
of mdr must contain the fwd search index. 
</p>
</li>
<li> <p><code>Un</code>: (for FSR only) - matrix containing the order of entry in the subset of each unit 
(required only when datatooltip is true or databrush is not empty).
</p>
</li>
<li> <p><code>y</code>: a vector containing the response (required only when option databrush is requested).
</p>
</li>
<li> <p><code>X</code>: a matrix containing the explanatory variables (required only when option databrush is requested).
</p>
</li>
<li> <p><code>Bols</code>: (n-init+1) x (p+1) matrix containing the estimated beta coefficients monitored in 
each step of the robust procedure (required only when option databrush 
is requested and suboption multivarfit is requested).
</p>
</li></ol>

</td></tr>
<tr><td><code id="mdrplot_+3A_quant">quant</code></td>
<td>

<p>Quantiles for which envelopes have to be computed. The default is to 
produce 1%, 50% and 99% envelopes. In other words the default 
is <code>quant=c(0.01, 0.5, 0.99)</code>.
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_sign">sign</code></td>
<td>

<p>Wheather to use MDR with sign: if <code>sign=TRUE</code> (default) we 
distinguish steps for which minimum deletion 
residual was associated with positive or negative value of the residual. 
Steps associated with positive values of mdr are plotted in black, 
while other steps are plotted in red.
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_mplus1">mplus1</code></td>
<td>

<p>Wheather to plot the (m+1)-th order statistic. Specifies if it is necessary to plot 
the curve associated with (m+1)-th order statistic.
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_envm">envm</code></td>
<td>

<p>Sample size for drawing enevlopes. Specifies the size of the sample which is 
used to superimpose the envelope. The default is to add an envelope based on 
all the observations (size n envelope).
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_ylim">ylim</code></td>
<td>
<p>Control <code>y</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the y axis. Default is to use automatic scale.
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_xlim">xlim</code></td>
<td>
<p>Control <code>x</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the x axis. Default is to use automatic scale.
</p>
</td></tr>   
<tr><td><code id="mdrplot_+3A_xlab">xlab</code></td>
<td>

<p>a title for the x axis
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_ylab">ylab</code></td>
<td>

<p>a title for the y axis
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_main">main</code></td>
<td>

<p>an overall title for the plot
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_lwdenv">lwdenv</code></td>
<td>

<p>Controls the width of the lines associated with the envelopes, default is <code>lvdenv=1</code>.
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_lwd">lwd</code></td>
<td>

<p>Controls the linewidth of the curve which contains the monitoring of minimum deletion residual.
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_cex.lab">cex.lab</code></td>
<td>

<p>The magnification to be used for x and y labels relative to the current setting of cex
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_cex.axis">cex.axis</code></td>
<td>

<p>The magnification to be used for axis annotation relative to the current setting of cex
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_tag">tag</code></td>
<td>

<p>Plot handle. String which identifies the handle of the plot which is about to be created. 
The default is to use tag 'pl_mdr'. Notice that if the program finds a plot which has 
a tag equal to the one specified by the user, then the output of the new plot overwrites 
the existing one in the same window else a new window is created.
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_datatooltip">datatooltip</code></td>
<td>
<p>If datatooltip is not empty the user can use the mouse in order to have
information about the unit selected, the step in which the unit enters the search and
the associated label. If datatooltip is a list, it is possible to control the aspect
of the data cursor (see MATLAB function <code>datacursormode()</code> for more details or
see the examples below). The default options are <code>DisplayStyle="Window"</code> and <code>SnapToDataVertex="on"</code>.
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_label">label</code></td>
<td>

<p>Character vector containing the labels of the units (optional argument used when 
<code>datatooltip=TRUE</code>. If this field is not present labels 
row1, ..., rown will be automatically created and included 
in the pop up datatooltip window).
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in plot. A vector of strings of length <code>p</code> 
containing the labels of the variables of the regression dataset. 
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically
</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_namey">namey</code></td>
<td>
<p>Add response label. A string containing the label of the response</p>
</td></tr>
<tr><td><code id="mdrplot_+3A_databrush">databrush</code></td>
<td>

<p>interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is a scalar or a list) enables the user to select 
a set of trajectories in the current plot and to see them highlighted in the y|X plot, 
i.e. a matrix of scatter plots of y against each column of X, grouped according to the 
selection(s) done by brushing. If the plot y|X does not exist it is automatically created.
In addition, brushed units are automatically highlighted in the minimum deletion residual 
plot if it is already open. The extension to the following plots will be available in future 
versions of the toolbox:
</p>

<ol>
<li><p> monitoring leverage plot;
</p>
</li>
<li><p> maximum studentized residual;
</p>
</li>
<li><p> s^2 and R^2;
</p>
</li>
<li><p> Cook distance and modified Cook distance;
</p>
</li>
<li><p> deletion t statistics.
</p>
</li></ol>

<p>Note that the window style of the other figures is set equal to that which contains the 
monitoring residual plot. In other words, if the monitoring residual plot is docked all 
the other figures will be docked too 
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and 
it is possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of 
function <code>selectdataFS()</code> and the following optional argument:
</p>

<ol>
<li> <p><code>persist</code>. Persist is an empty value or a character containing 'on' or 'off'. 
The default value is <code>persist=""</code>, that is brushing is allowed only once.    
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as 
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are 
added to those previously brushed. It is possible, every time a new brushing is 
done, to use a different color for the brushed units. If <code>persist='off'</code> 
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>bivarfit</code>. Wheather to superimpose bivariate least square lines on the plot (if <code>plot=TRUE</code>.
This option adds one or more least squares lines, based on SIMPLE REGRESSION of y on Xi, 
to the plots of y|Xi. The default is <code>bivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. If <code>bivarfit=2</code>, two OLS lines are fitted: 
one to all points and another to the group of the genuine observations. 
The group of the potential outliers is not fitted. If <code>bivarfit=0</code> 
one OLS line is fitted to each group. This is useful for the purpose of 
fitting mixtures of regression lines. If <code>bivarfit='i1'</code> or 
<code>bivarfit='i2'</code>, etc. an OLS line is fitted to a specific group, 
the one with index 'i' equal to 1, 2, 3 etc. 
Again, useful in case of mixtures.
</p>
</li>
<li> <p><code>multivarfit</code>. Wheather to superimpose multivariate least square lines. 
This option adds one or more least square lines, based on MULTIVARIATE REGRESSION 
of y on X, to the plots of y|Xi. 
The default is <code>multivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. The line added to the scatter plot y|Xi is 
avconst + Ci*Xi, where Ci is the coefficient of Xi in the multivariate regression 
and avconst is the effect of all the other explanatory variables different 
from Xi evaluated at their centroid (that is overline(y)'C)). 
If <code>multivarfit=2</code>, same action as with <code>multivarfit=1</code> but this time 
we also add the line based on the group of unselected observations 
(i.e. the normal units).
</p>
</li>
<li> <p><code>labeladd</code>. Add outlier labels in plot. If <code>labeladd=TRUE</code>, we label the outliers 
with the unit row index in matrices X and y. 
The default value is <code>labeladd=FALSE</code>, i.e. no label is added.    
</p>
</li></ol>

</td></tr>
<tr><td><code id="mdrplot_+3A_...">...</code></td>
<td>

<p>potential further arguments passed to lower level functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>No value returned
</p>


<h3>Author(s)</h3>

<p>FSDA team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

n &lt;- 100
y &lt;- rnorm(n)
X &lt;- matrix(rnorm(n*4), nrow=n)

out &lt;- fsreg(y~X, method="LTS")
out &lt;- fsreg(y~X, method="FS", bsb=out$bs, monitoring=TRUE)
mdrplot(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='mmdplot'>Plots the trajectory of minimum Mahalanobis distance (mmd)</h2><span id='topic+mmdplot'></span>

<h3>Description</h3>

<p>Plots the trajectory of minimum Mahalanobis distance (mmd)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmdplot(
  out,
  quant = c(0.01, 0.5, 0.99),
  mplus1 = FALSE,
  envm,
  lwd,
  lwdenv,
  xlim,
  ylim,
  tag,
  datatooltip,
  label,
  xlab,
  ylab,
  main,
  nameX,
  cex.lab,
  cex.axis,
  databrush,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmdplot_+3A_out">out</code></td>
<td>
<p>An object of S3 class <code><a href="#topic+fsmeda.object">fsmeda.object</a></code> returned by
<code><a href="#topic+fsmult">fsmult</a></code> with <code>monitoring=TRUE</code> -
a list containing the monitoring of minimum Mahalanobis distance</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_quant">quant</code></td>
<td>
<p>Quantiles for which envelopes have to be computed.
The default is to produce 1%, 50% and 99% envelopes. In other
words the default is <code>quant=c(0.01, 0.5, 0.99)</code>.</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_mplus1">mplus1</code></td>
<td>
<p>Wheather to plot the (m+1)-th order statistic.</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_envm">envm</code></td>
<td>
<p>Sample size for drawing enevlopes. Specifies the size of the sample which is
used to superimpose the envelope. The default is to add an envelope based on
all the observations (size <code>n</code> envelope).</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_lwd">lwd</code></td>
<td>
<p>Controls the line width of the curve which contains the monitoring
of minimum deletion residual.</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_lwdenv">lwdenv</code></td>
<td>
<p>Controls the width of the lines associated with the envelopes. Default is <code>lwdenv=1</code></p>
</td></tr>
<tr><td><code id="mmdplot_+3A_xlim">xlim</code></td>
<td>
<p>Control the x scale in plot. Vector with two elements controlling
minimum and maximum on the x axis. Default is to use automatic scale.</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_ylim">ylim</code></td>
<td>
<p>Control the y scale in plot. Vector with two elements controlling
minimum and maximum on the y axis. Default is to use automatic scale.</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_tag">tag</code></td>
<td>
<p>Plot handle. String which identifies the handle of the plot which is about to be created.
The default is <code>tag='pl_mmd'</code>. Notice that if the program finds a plot which has
a tag equal to the one specified by the user, then the output of the new plot overwrites
the existing one in the same window else a new window is created.</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_datatooltip">datatooltip</code></td>
<td>
<p>If datatooltip is not empty the user can use the mouse in order to have
information about the unit selected, the step in which the unit enters the search and
the associated label. If datatooltip is a list, it is possible to control the aspect
of the data cursor (see MATLAB function <code>datacursormode()</code> for more details or
see the examples below). The default options are <code>DisplayStyle="Window"</code> and <code>SnapToDataVertex="on"</code>.</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_label">label</code></td>
<td>
<p>Row labels. Character vector containing the labels of the units (optional argument used
when <code>datatooltip=TRUE</code>. If this field is not present labels
row1, ..., rown will be automatically created and included in the pop up datatooltip window).</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_main">main</code></td>
<td>
<p>An overall title for the plot</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in the plot. A vector of strings of length <code>p</code>
containing the labels of the variables of the original data matrix <code>X</code>.
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The magnification to be used for x and y labels relative to the current setting of cex</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to the current setting of cex</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_databrush">databrush</code></td>
<td>
<p>Interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is TRUE or a list) enables the user to select
a set of trajectories in the current plot and to see them highlighted in the scatterplot matrix.
If the scatterplot matrix does not exist it is automatically created.
In addition, brushed units can be highlighted in the monitoring MD plot. Note that the window
style of the other figures is set equal to that which contains the monitoring residual plot.
In other words, if the monitoring residual plot is docked all the other figures will be docked too.
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and it is
possible to brush only once (that is persist=&rdquo;).
</p>
<p>Note that the window style of the other figures is set equal to that which contains the
monitoring residual plot. In other words, if the monitoring residual plot is docked all
the other figures will be docked too
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and
it is possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of
the MATLAB function <code>selectdataFS()</code> and the following optional arguments:
</p>

<ul>
<li> <p><code>persist</code>: This option can be an empty value or a character containing 'on' or 'off'.
The default value is <code>persist=""</code>, that is brushing is allowed only once.
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are
added to those previously brushed. It is possible, every time a new brushing is
done, to use a different color for the brushed units. If <code>persist='off'</code>
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>labeladd</code>: add labels of brushed units in the scatterplot matrix.
If this option is '1', we label the units of the last selected group with
the unit row index in the matrix X. The default value is labeladd=&rdquo;,
i.e. no label is added.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mmdplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="mmdplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Atkinson and Riani (2000), Robust Diagnostic Regression Analysis, Springer Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 data(hbk, package="robustbase")
 (out &lt;- fsmult(hbk[,1:3], monitoring=TRUE))
 mmdplot(out)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='mmdrsplot'>Plots the trajectories of minimum Mahalanobis distances from different starting points</h2><span id='topic+mmdrsplot'></span>

<h3>Description</h3>

<p>Plots the trajectories of minimum Mahalanobis distances from different starting points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmdrsplot(
  out,
  quant = c(0.01, 0.5, 0.99),
  envm,
  lwd,
  lwdenv,
  xlim,
  ylim,
  tag,
  datatooltip,
  label,
  xlab,
  ylab,
  envlab = TRUE,
  main,
  nameX,
  cex.lab,
  cex.axis,
  databrush,
  scaled = FALSE,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmdrsplot_+3A_out">out</code></td>
<td>
<p>An object of S3 class <code><a href="#topic+fsmmmdrs.object">fsmmmdrs.object</a></code> returned by
<code><a href="#topic+fsmmmdrs">fsmmmdrs</a></code> -
a list containing the following elements:
</p>

<ul>
<li> <p><code>mmdrs</code> = a matrix of size (n-ninit)-by-(nsimul+1) containing the monitoring
of minimum Mahalanobis distance in each step of the forward search for each
of the nsimul random starts. The first column of mmdrs must contain the forward search index.
This matrix can be created using function <code><a href="#topic+fsmmmdrs">fsmmmdrs</a></code>.
</p>
</li>
<li> <p><code>BBrs</code> = 3D array of size n-by-n-(init)-by-nsimul containing
units forming subset for rach random start. This field is necessary
if datatooltip is true or databrush is not empty.
</p>
</li>
<li> <p><code>X</code> = n-by-v matrix containing the original data matrix. This
field is necessary if datatooltip is true or databrush is not empty.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_quant">quant</code></td>
<td>
<p>Quantiles for which envelopes have to be computed.
The default is to produce 1%, 50% and 99% envelopes. In other
words the default is <code>quant=c(0.01, 0.5, 0.99)</code>.</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_envm">envm</code></td>
<td>
<p>Sample size for drawing enevlopes. Specifies the size of the sample which is
used to superimpose the envelope. The default is to add an envelope based on
all the observations (size <code>n</code> envelope).</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_lwd">lwd</code></td>
<td>
<p>Controls the linewidth of the curve which contains the monitoring
of minimum deletion residual.</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_lwdenv">lwdenv</code></td>
<td>
<p>line width: a scalar which controls the width of the lines associated
with the envelopes. Default is <code>lwdenv=1</code></p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_xlim">xlim</code></td>
<td>
<p>Control the x scale in plot. Vector with two elements controlling
minimum and maximum on the x axis. Default is to use automatic scale.</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_ylim">ylim</code></td>
<td>
<p>Control the y scale in plot. Vector with two elements controlling
minimum and maximum on the y axis. Default is to use automatic scale.</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_tag">tag</code></td>
<td>
<p>Plot handle. String which identifies the handle of the plot which is about to be created.
The default is <code>tag='pl_mmdrs'</code>. Notice that if the program finds a plot which has
a tag equal to the one specified by the user, then the output of the new plot overwrites
the existing one in the same window else a new window is created.</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_datatooltip">datatooltip</code></td>
<td>
<p>If datatooltip is not empty the user can use the mouse in order to have
information about the unit selected, the step in which the unit enters the search and
the associated label. If datatooltip is a list, it is possible to control the aspect
of the data cursor (see MATLAB function <code>datacursormode()</code> for more details or
see the examples below). The default options are <code>DisplayStyle="Window"</code> and <code>SnapToDataVertex="on"</code>.</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_label">label</code></td>
<td>
<p>Row labels. Character vector containing the labels of the units (optional argument used
when <code>datatooltip=TRUE</code>. If this field is not present labels
row1, ..., rown will be automatically created and included in the pop up datatooltip window).</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_envlab">envlab</code></td>
<td>
<p>wheather to label the envelopes. If <code>envlab</code> is true (default)
labels of the confidence envelopes which are used are added on the y axis.</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_main">main</code></td>
<td>
<p>An overall title for the plot</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in the plot. A vector of strings of length <code>p</code>
containing the labels of the variables of the original data matrix <code>X</code>.
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The magnification to be used for x and y labels relative to the current setting of cex</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to the current setting of cex</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_databrush">databrush</code></td>
<td>
<p>Interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is TRUE or a list) enables the user to select
a set of trajectories in the current plot and to see them highlighted in the scatterplot matrix.
If the scatterplot matrix does not exist it is automatically created.
In addition, brushed units can be highlighted in the monitoring MD plot. Note that the window
style of the other figures is set equal to that which contains the monitoring residual plot.
In other words, if the monitoring residual plot is docked all the other figures will be docked too.
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and it is
possible to brush only once (that is persist=&rdquo;).
</p>
<p>Note that the window style of the other figures is set equal to that which contains the
monitoring residual plot. In other words, if the monitoring residual plot is docked all
the other figures will be docked too
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and
it is possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of
the MATLAB function <code>selectdataFS()</code> and the following optional arguments:
</p>

<ol>
<li><p> persist. Persist is an empty value or a character containing 'on' or 'off'.
The default value is <code>persist=""</code>, that is brushing is allowed only once.
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are
added to those previously brushed. It is possible, every time a new brushing is
done, to use a different color for the brushed units. If <code>persist='off'</code>
every time a new brush is performed units previously brushed are removed.
</p>
</li></ol>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_scaled">scaled</code></td>
<td>
<p>Wheather to use scaled or unscaled envelopes. If <code>scaled=TRUE</code>
the envelopes are produced for scaled Mahalanobis distances (no consistency factor
is applied) else the traditional consistency factor is applied.
Default is <code>scaled=FALSE</code></p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="mmdrsplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Atkinson, A.C., Riani, M. and Cerioli, A. (2004), '<em>Exploring multivariate data with the forward search</em>, Springer Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 data(hbk, package="robustbase")
 out &lt;- fsmmmdrs(hbk[,1:3])
 mmdrsplot(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='mmmult'>Computes MM estimators in multivariate analysis with auxiliary S-scale</h2><span id='topic+mmmult'></span>

<h3>Description</h3>

<p>Computes MM estimators in multivariate analysis with auxiliary S-scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmmult(
  x,
  monitoring = FALSE,
  plot = FALSE,
  eff,
  conflev = 0.975,
  nocheck = FALSE,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmmult_+3A_x">x</code></td>
<td>
<p>An n x p data matrix (n observations and p variables).
Rows of x represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="mmmult_+3A_monitoring">monitoring</code></td>
<td>
<p>Wheather to perform monitoring of Mahalanobis distances and other specific quantities</p>
</td></tr>
<tr><td><code id="mmmult_+3A_plot">plot</code></td>
<td>
<p>Plots the Mahalanobis distances against index number. If <code>plot=FALSE</code>
(default) or <code>plot=0</code>  no plot is produced. The confidence
level used to draw the confidence bands for the MD is given by the input option conflev.
If conflev is not specified a nominal 0.975 confidence interval will be used.
If <code>plot=2</code>  a scatter plot matrix with the outliers highlighted is produced.
If plot is a list it may contain the following fields:
</p>

<ul>
<li><p> labeladd If <code>labeladd=1</code>, the outliers in the spm are labelled with the unit
row index. The default value is <code>labeladd=""</code>, i.e. no label is added
</p>
</li>
<li><p> nameY character vector containing the labels of the variables. As default value,
the labels which are added are Y1, ...Yp.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mmmult_+3A_eff">eff</code></td>
<td>
<p>Defining the nominal efficiency (i.e. a number between 0.5 and 0.99). The default value is <code>eff=0.95</code>.</p>
</td></tr>
<tr><td><code id="mmmult_+3A_conflev">conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers (scalar).
Usually <code>conflev=0.95</code>, <code>conflev=0.975</code> or <code>conflev=0.99</code> (individual alpha)
<code>conflev=1-0.05/n</code>, <code>conflev=1-0.025/n</code> or <code>conflev=1-0.01/n</code> (simultaneous alpha).
Default value is <code>convlev=0.975</code>.</p>
</td></tr>
<tr><td><code id="mmmult_+3A_nocheck">nocheck</code></td>
<td>
<p>It controls whether to perform checks on matrix Y. If <code>nocheck=TRUE</code>, no check is performed.</p>
</td></tr>
<tr><td><code id="mmmult_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="mmmult_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function follows the lines of MATLAB/R code developed during the years by many authors.
For more details see http://www.econ.kuleuven.be/public/NDBAE06/programs/ and
the R package <a href="rrcov.html#topic+CovMMest">CovMMest</a>
The core of these routines, e.g. the resampling approach, however, has been
completely redesigned, with considerable increase of the computational performance.
</p>


<h3>Value</h3>

<p>Depending on the input parameter <code>monitoring</code>, one of
the following objects will be returned:
</p>

<ol>
<li> <p><code><a href="#topic+mmmult.object">mmmult.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mmmulteda.object">mmmulteda.object</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Maronna, R.A., Martin D. and Yohai V.J. (2006), Robust Statistics, Theory and Methods, Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 data(hbk, package="robustbase")
 (out &lt;- mmmult(hbk[,1:3]))
 class(out)
 summary(out)

 ##  Generate contaminated data (200,3)
 n &lt;- 200
 p &lt;- 3
 set.seed(123456)
 X &lt;- matrix(rnorm(n*p), nrow=n)
 Xcont &lt;- X
 Xcont[1:5, ] &lt;- Xcont[1:5,] + 3

 out1 &lt;- mmmult(Xcont, trace=TRUE)           # no plots (plot defaults to FALSE)
 names(out1)

 ## plot=TRUE - generates: (1) a plot of Mahalanobis distances against
 ##    index number. The confidence level used to draw the confidence bands for
 ##    the MD is given by the input option conflev. If conflev is
 ##    not specified a nominal 0.975 confidence interval will be used and
 ##    (2) a scatter plot matrix with the outliers highlighted.

 (out1 &lt;- mmmult(Xcont, trace=TRUE, plot=TRUE))

 ## plots is a list: the spm shows the labels of the outliers.
 (out1 &lt;- mmmult(Xcont, trace=TRUE, plot=list(labeladd="1")))

 ## plots is a list: the spm uses the variable names provided by 'nameY'.
 (out1 &lt;- mmmult(Xcont, trace=TRUE, plot=list(nameY=c("A", "B", "C"))))

 ## mmmult() with monitoring
 (out2 &lt;- mmmult(Xcont, monitoring=TRUE, trace=TRUE))
 names(out2)

 ##  Forgery Swiss banknotes examples.

 data(swissbanknotes)

 (out1 &lt;- mmmult(swissbanknotes[101:200,], plot=TRUE))

 (out1 &lt;- mmmult(swissbanknotes[101:200,], plot=list(labeladd="1")))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='mmmult.object'>Description of <code>mmmult.object</code> Objects</h2><span id='topic+mmmult.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+mmmult.object">mmmult.object</a></code> holds information about 
the result of a call to <code><a href="#topic+mmmult">mmmult</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>loc</code></td>
<td>
<p>p-by-1  vector containing MM estimate of location.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>p-by-p matrix with MM estimate of the shape matrix.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>matrix with MM estimate of the covariance matrix.
Remark: <code>covariance = auxscale^2 * shape</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>A vector containing the estimates of the weights.</p>
</td></tr>     
<tr><td><code>outliers</code></td>
<td>
<p>A vector containing the list of the units declared 
as outliers using confidence level specified in input scalar 
<code>conflev</code>.</p>
</td></tr>     
<tr><td><code>Sloc</code></td>
<td>
<p>A vector with S estimate of location.</p>
</td></tr>     
<tr><td><code>Sshape</code></td>
<td>
<p>A matrix with S estimate of the shape matrix.</p>
</td></tr>     
<tr><td><code>Scov</code></td>
<td>
<p>A matrix with S estimate of the covariance matrix.</p>
</td></tr>     
<tr><td><code>auxscale</code></td>
<td>
<p>S estimate of the scale.</p>
</td></tr>     
<tr><td><code>md</code></td>
<td>
<p>n-by-1 vector containing the estimates of the robust 
Mahalanobis distances (in squared units).</p>
</td></tr>
<tr><td><code>conflev</code></td>
<td>
<p>Confidence level that was used to declare outliers.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
</table>
<p>The object has class <code>"mmmult"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- mmmult(hbk[,1:3]))
    class(out)
    summary(out)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='mmmulteda.object'>Description of <code>mmmulteda.object</code> Objects</h2><span id='topic+mmmulteda.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+mmmulteda.object">mmmulteda.object</a></code> holds information about 
the result of a call to <code><a href="#topic+mmmult">mmmult</a></code> with <code>monitoring=TRUE</code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>Loc</code></td>
<td>
<p>length(eff)-by-p  matrix containing MM estimate of location 
for each value of <code>eff</code>.</p>
</td></tr>
<tr><td><code>Shape</code></td>
<td>
<p>p-by-p-by-length(eff) 3D array  containing robust estimate 
of the shape for each value of eff. Remark: det|shape|=1.</p>
</td></tr>
<tr><td><code>Scale</code></td>
<td>
<p>length(eff) vector containing robust estimate of the scale
for each value of eff.</p>
</td></tr>
<tr><td><code>Cov</code></td>
<td>
<p>p-by-p-by-length(eff) 3D array  containing robust estimate 
of covariance matrix for each value of <code>eff</code>.
Note that <code>scale(i)^2 * shape[,,i]</code> = robust estimate of 
covariance matrix.</p>
</td></tr>
<tr><td><code>Bs</code></td>
<td>
<p>(p+1)-by-length(eff) matrix containing the units forming best subset 
for each value of eff.</p>
</td></tr>
<tr><td><code>MAL</code></td>
<td>
<p>n-by-length(eff) matrix containing the estimates of the robust 
Mahalanobis distances (in squared units) for each value of eff.</p>
</td></tr>
<tr><td><code>Outliers</code></td>
<td>
<p>n-by-length(eff) matrix containing flags for the outliers. 
Boolean matrix containing the list of the 
units declared as outliers for each value of eff using confidence 
level specified in input scalar <code>conflev</code></p>
</td></tr>     
<tr><td><code>Weights</code></td>
<td>
<p>n x length(eff) matrix containing the weights for each 
value of eff.</p>
</td></tr>     
<tr><td><code>conflev</code></td>
<td>
<p>Confidence level that was used to declare outliers.</p>
</td></tr>
<tr><td><code>singsub</code></td>
<td>
<p>Number of subsets without full rank. Notice that 
<code>singsub &gt; 0.1*(number of subsamples)</code> produces a warning.</p>
</td></tr>
<tr><td><code>eff</code></td>
<td>
<p>vector which contains the values of eff which have been used.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X.</p>
</td></tr>
</table>
<p>The object has class <code>"mmmulteda"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- mmmult(hbk[,1:3], monitoring=TRUE))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='MMreg_control'>
Creates an <code>MMreg_control</code> object
</h2><span id='topic+MMreg_control'></span>

<h3>Description</h3>

<p>Creates an object of class <code>MMreg_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters for calling the MATLAB function <code>MMreg()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MMreg_control(intercept = TRUE, InitialEst, eff, effshape, 
    rhofunc = c("bisquare", "optimal", "hyperbolic", "hampel", "mdpd", "AS"), 
    rhofuncparam, refsteps = 3, tol = 1e-07, conflev, 
    nocheck = FALSE, Smsg = TRUE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MMreg_control_+3A_intercept">intercept</code></td>
<td>

<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_initialest">InitialEst</code></td>
<td>
<p>Starting values of the MM-estimator, a list with the fiollowing
elements: <code>loc</code>, a $p x 1$ vector, location vector estimate and
<code>scale</code>, a scaler, estimate of the scale. If empty (default) the program 
will use S estimators. In this last case it is possible to specify the 
options given in function Sreg.
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_eff">eff</code></td>
<td>
<p>Scalar defining nominal efficiency (i.e. a number between 
0.5 and 0.99). The default value is 0.95.
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_effshape">effshape</code></td>
<td>
<p>Location or scale efficiency. If <code>effshape=1</code> 
efficiency refers to shape efficiency else (default) efficiency 
refers to location efficiency.
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_rhofunc">rhofunc</code></td>
<td>

<p>Specifies the rho function which must be used to weight 
the residuals. Possible values are 'bisquare' 'optimal' 'hyperbolic' 'hampel'.
</p>

<ol>
<li><p> 'bisquare' uses Tukey's rho and psi functions. See TBrho and TBpsi.
</p>
</li>
<li><p> 'optimal' uses optimal rho and psi functions. See OPTrho and OPTpsi.
</p>
</li>
<li><p> 'hyperbolic' uses hyperbolic rho and psi functions. See HYPrho and HYPpsi.
</p>
</li>
<li><p> 'hampel' uses Hampel rho and psi functions. See HArho and HApsi.
</p>
</li></ol>

<p>The default is 'bisquare'.
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_rhofuncparam">rhofuncparam</code></td>
<td>

<p>Additional parameters for the specified rho function. 
For hyperbolic rho function it is possible to set up the 
value of k = sup CVC (the default value of k is 4.5).
</p>
<p>For Hampel rho function it is possible to define parameters 
a, b and c (the default values are a=2, b=4, c=8)
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_refsteps">refsteps</code></td>
<td>

<p>Number of refining iterations in each subsample (default is <code>refsteps=3</code>).
<code>refsteps = 0</code> means &quot;raw-subsampling&quot; without iterations.
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_tol">tol</code></td>
<td>

<p>Scalar controlling tolerance in the MM loop. The default value is <code>tol=1e-6</code>
</p>
</td></tr>    
<tr><td><code id="MMreg_control_+3A_conflev">conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Usually conflev=0.95, 0.975, 0.99 (individual alpha) or 
conflev=1-0.05/n, 1-0.025/n, 1-0.01/n (simultaneous alpha). 
Default value is 0.975
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_nocheck">nocheck</code></td>
<td>

<p>Check input arguments, scalar. If <code>nocheck=TRUE</code> no check is performed 
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code> 
are left unchanged. In other words the additional column of ones for the 
intercept is not added. As default <code>nocheck=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_smsg">Smsg</code></td>
<td>

<p>Controls whether to display or not messages on the screen If <code>Smsg==TRUE</code> (default) 
messages are displayed on the screen about step in which signal took place else 
no message is displayed on the screen.
</p>
</td></tr>
<tr><td><code id="MMreg_control_+3A_plot">plot</code></td>
<td>

<p>Plot on the screen. Scalar. If <code>plots=TRUE</code> the plot of minimum deletion 
residual with envelopes based on n observations and the scatterplot matrix with 
the outliers highlighted is produced. If <code>plots=2</code> the user can also monitor 
the intermediate plots based on envelope superimposition. 
If <code>plots=FALSE</code> (default) no plot is produced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an object of class <code>MMreg_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>"MMreg_control"</code> which is basically a
<code><a href="base.html#topic+list">list</a></code> with components the input arguments of 
the function mapped accordingly to the corresponding Matlab function. 
</p>


<h3>Author(s)</h3>

<p>FSDA team
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+FSR_control">FSR_control</a></code>, <code><a href="#topic+MMreg_control">MMreg_control</a></code> and <code><a href="#topic+LXS_control">LXS_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:   
data(hbk, package="robustbase")
(out &lt;- fsreg(Y~., data=hbk, method="MM", control=MMreg_control(eff=0.99, rhofunc="optimal")))

## End(Not run)
</code></pre>

<hr>
<h2 id='mmreg.object'>Description of mmreg Objects</h2><span id='topic+mmreg.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+mmreg.object">mmreg.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsreg">fsreg</a></code> with <code>method="MM"</code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>p-by-1 vector containing the MM estimate of regression coefficients.</p>
</td></tr>
<tr><td><code>auxscale</code></td>
<td>
<p>scalar, S estimate of the scale (or supplied external estimate of scale, if option InitialEst is not empty).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>fittedvalues</code></td>
<td>
<p>fitted values.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>n x 1 vector. Weights assigned to each observation.</p>
</td></tr>
<tr><td><code>Sbeta</code></td>
<td>
<p>p x 1 vector containing S estimate of regression coefficients 
(or supplied initial external estimate of regression coefficients, 
if option InitialEst is not empty)</p>
</td></tr>
<tr><td><code>Ssingsub</code></td>
<td>
<p>Number of subsets without full rank in the S preliminary part. 
Notice that out.singsub &gt; 0.1*(number of subsamples) produces a warning.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>kx1 vector containing the list of the k units declared as outliers or NULL if the sample is homogeneous.</p>
</td></tr>
<tr><td><code>conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Usually <code>conflev=0.95, 0.975, 0.99</code> (individual alpha) or 
<code>conflev=1-0.05/n, 1-0.025/n, 1-0.01/n</code> (simultaneous alpha). 
Default value is 0.975</p>
</td></tr>
<tr><td><code>rhofunc</code></td>
<td>
<p>Specifies the rho function which has been used to weight 
the residuals. If a different rho function is specified for S and MM 
loop then insted of <code>rhofunc</code> we will have <code>rhofuncS</code> and 
<code>rhofuncMM</code>.
</p>
</td></tr>
<tr><td><code>rhofuncparam</code></td>
<td>
<p>Vector which contains the additional parameters for the specified 
rho function which has been used. For hyperbolic rho function the value of k =sup CVC. 
For Hampel rho function the parameters a, b and c. If a different rho function is 
specified for S and MM loop then insted of <code>rhofuncparam</code> we will have 
<code>rhofuncparamS</code> and <code>rhofuncparamMM</code>.
</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector y</p>
</td></tr>
</table>
<p>The object has class <code>"mmreg"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="MM"))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='MMregeda_control'>
Creates an <code>MMregeda_control</code> object
</h2><span id='topic+MMregeda_control'></span>

<h3>Description</h3>

<p>Creates an object of class <code>MMregeda_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    MMregeda_control(intercept = TRUE, InitialEst, Soptions, eff, effshape, 
    rhofunc = c("bisquare", "optimal", "hyperbolic", "hampel", "mdpd", "AS"), 
    rhofuncparam, refsteps = 3, tol = 1e-07, conflev, nocheck = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MMregeda_control_+3A_intercept">intercept</code></td>
<td>

<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_initialest">InitialEst</code></td>
<td>
<p>Starting values of the MM-estimator, a list with the fiollowing
elements: <code>loc</code>, a $p x 1$ vector, location vector estimate and
<code>scale</code>, a scaler, estimate of the scale. If empty (default) the program 
will use S estimators. In this last case it is possible to specify the 
options given in function Sreg.
</p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_soptions">Soptions</code></td>
<td>
<p>Options to pass to Sreg, an <code><a href="#topic+Sreg_control">Sreg_control</a></code> object. 

The options are: Srhofunc, Snsamp, Srefsteps, Sreftol, Srefstepsbestr, Sreftolbestr, Sminsctol, Sbestr.
See function <code><a href="#topic+Sreg_control">Sreg_control</a></code> for more details on these options. 
</p>
<p>It is necessary to add to the S options the letter S at the beginning. 
For example, if you want to use the optimal rho function the supplied 
option is 'Srhofunc','optimal'. For example, if you want to use 3000 
subsets, the supplied option is 'Snsamp',3000 </p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_eff">eff</code></td>
<td>
<p>Vector defining nominal efficiency (i.e. a series of numbers 
between 0.5 and 0.99). The default value is the sequence <code>seq(0.5, 0.99, 0.01)</code> </p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_effshape">effshape</code></td>
<td>
<p>Location or scale efficiency. If <code>effshape=1</code> 
efficiency refers to shape efficiency else (default) efficiency 
refers to location efficiency. </p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_rhofunc">rhofunc</code></td>
<td>

<p>Specifies the rho function which must be used to weight 
the residuals. Possible values are 'bisquare' 'optimal' 'hyperbolic' 'hampel'.
</p>

<ol>
<li><p> 'bisquare' uses Tukey's rho and psi functions. See TBrho and TBpsi.
</p>
</li>
<li><p> 'optimal' uses optimal rho and psi functions. See OPTrho and OPTpsi.
</p>
</li>
<li><p> 'hyperbolic' uses hyperbolic rho and psi functions. See HYPrho and HYPpsi.
</p>
</li>
<li><p> 'hampel' uses Hampel rho and psi functions. See HArho and HApsi.
</p>
</li></ol>

<p>The default is 'bisquare'.
</p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_rhofuncparam">rhofuncparam</code></td>
<td>

<p>Additional parameters for the specified rho function. 
For hyperbolic rho function it is possible to set up the 
value of k = sup CVC (the default value of k is 4.5).
</p>
<p>For Hampel rho function it is possible to define parameters 
a, b and c (the default values are a=2, b=4, c=8)
</p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_refsteps">refsteps</code></td>
<td>

<p>Number of refining iterations in each subsample (default is <code>refsteps=3</code>).
<code>refsteps = 0</code> means &quot;raw-subsampling&quot; without iterations. </p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_tol">tol</code></td>
<td>

<p>Scalar controlling tolerance in the MM loop. The default value is <code>tol=1e-6</code>. </p>
</td></tr>    
<tr><td><code id="MMregeda_control_+3A_conflev">conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Usually conflev=0.95, 0.975, 0.99 (individual alpha) or 
conflev=1-0.05/n, 1-0.025/n, 1-0.01/n (simultaneous alpha). 
Default value is 0.975</p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_nocheck">nocheck</code></td>
<td>

<p>Check input arguments, scalar. If <code>nocheck=TRUE</code> no check is performed 
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code> 
are left unchanged. In other words the additional column of ones for the 
intercept is not added. As default <code>nocheck=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MMregeda_control_+3A_plot">plot</code></td>
<td>

<p>Plot on the screen. Scalar. If <code>plots=TRUE</code> the plot of minimum deletion 
residual with envelopes based on n observations and the scatterplot matrix with 
the outliers highlighted is produced. If <code>plots=2</code> the user can also monitor 
the intermediate plots based on envelope superimposition. 
If <code>plots=FALSE</code> (default) no plot is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an object of class <code>MMregeda_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>"MMregeda_control"</code> which is basically a
<code><a href="base.html#topic+list">list</a></code> with components the input arguments of 
the function mapped accordingly to the corresponding Matlab function. 
</p>


<h3>Author(s)</h3>

<p>FSDA team</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+FSR_control">FSR_control</a></code>, <code><a href="#topic+Sreg_control">Sreg_control</a></code>, <code><a href="#topic+MMreg_control">MMreg_control</a></code> and <code><a href="#topic+LXS_control">LXS_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
data(hbk, package="robustbase")
(out &lt;- fsreg(Y~., data=hbk, method="MM", monitoring=TRUE, 
    control=MMregeda_control(eff=seq(0.75, 0.99, 0.01))))

## End(Not run)
</code></pre>

<hr>
<h2 id='mmregeda.object'>Description of <code>mmregeda</code> Objects</h2><span id='topic+mmregeda.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+mmregeda.object">mmregeda.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsreg">fsreg</a></code> when <code>method="MM"</code> and 
<code>monitoring=TRUE</code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>auxscale</code></td>
<td>
<p>scalar, S estimate of the scale (or supplied external estimate of scale, if option InitialEst is not empty).</p>
</td></tr>
<tr><td><code>Beta</code></td>
<td>
<p>p x length(eff) matrix containing MM estimate of regression coefficients for each value of eff.</p>
</td></tr>
<tr><td><code>RES</code></td>
<td>
<p>n x length(eff) matrix containing the monitoring 
of scaled residuals for each value of <code>eff</code>.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>n x length(eff) matrix containing the estimates of the weights for each value of eff</p>
</td></tr>
<tr><td><code>Outliers</code></td>
<td>
<p>Boolean matrix containing the list of the units declared as outliers for each value of eff using confidence level specified in input scalar conflev.</p>
</td></tr>
<tr><td><code>conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Remark: conflev will be used to draw the horizontal line (confidence band) in the plot.</p>
</td></tr>
<tr><td><code>Ssingsub</code></td>
<td>
<p>Number of subsets wihtout full rank. 
Notice that  Notice that singsub &gt; 0.1*(number of subsamples) produces a warning</p>
</td></tr>
<tr><td><code>rhofunc</code></td>
<td>
<p>string identifying the rho function which has been used. </p>
</td></tr>
<tr><td><code>rhofuncparam</code></td>
<td>
<p>vector which contains the additional parameters for the 
specified rho function which have been used. For hyperbolic rho function 
the value of k =sup CVC. For Hampel rho function the parameters a, b and c. </p>
</td></tr>
<tr><td><code>eff</code></td>
<td>
<p>vector containing the value of eff which have been used.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector y</p>
</td></tr>
</table>
<p>The object has class <code>"mmregeda"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="MM", monitoring=TRUE))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='multiple_regression'>Multiple regression data showing the effect of masking (Atkinson and Riani, 2000).</h2><span id='topic+multiple_regression'></span>

<h3>Description</h3>

<p>There are 60 observations on a response y with the values of three explanatory variables.
The scatter plot matrix of the data shows y increasing with each of x1, x2 and x3.
The plot of residuals against fitted values shows no obvious pattern. However the
FS finds that there are 6 masked outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(multiple_regression)
</code></pre>


<h3>Format</h3>

<p>A data frame with 60 rows and 4 variables
The variables are as follows:
</p>

<ul>
<li><p> X1
</p>
</li>
<li><p> X2
</p>
</li>
<li><p> X3
</p>
</li>
<li><p> y
</p>
</li></ul>

<p>@references
Atkinson, A. C., and Riani, M. (2000). <em>Robust Diagnostic Regression Analysis</em>. Springer-Verlag, New York.
</p>

<hr>
<h2 id='mussels'>Mussels data.</h2><span id='topic+mussels'></span>

<h3>Description</h3>

<p>These data, introduced by Cook and Weisberg (1994), consist of 82 observations on horse mussels from
New Zeland. The variables are shell length, width, height, mass and muscle mass
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mussels)
</code></pre>


<h3>Format</h3>

<p>A data frame with 82 rows and 5 variables
</p>

<hr>
<h2 id='myrng'>Set seed for the MATLAB random number generator</h2><span id='topic+myrng'></span>

<h3>Description</h3>

<p>Initializes the MATLAB random generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myrng(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myrng_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as an integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer, the seed value with which the MATLAB random number generator was initialized.
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   data(wool)
   XX &lt;- wool
   y &lt;- XX[, ncol(XX)]
   X &lt;- XX[, 1:(ncol(XX)-1), drop=FALSE]

   seed &lt;- myrng()                       #i nitialized the RNG and keep the seed

   myrng(seed)                           # repeat the computations with the same seed
   (out2 &lt;- fsreg(X, y, method="LTS"))

   all.equal(out1, out2)

 
## End(Not run)

</code></pre>

<hr>
<h2 id='poison'>Poison</h2><span id='topic+poison'></span>

<h3>Description</h3>

<p>The poison data (by Box and Cox, 1964) are about the time to death of animals in a <code>3 x 4</code>
factorial experiment with four observations at each factor combination. There are no outliers
or influential observations that cannot be reconciled with the greater part of the data by a
suitable transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(poison)
</code></pre>


<h3>Format</h3>

<p>A data frame with 48 rows and 7 variables: six explanatory and one response variable.
</p>


<h3>Source</h3>

<p>G. E. P. Box and D. R. Cox (1964). An Analysis of Transformations,
<em>Journal of the Royal Statistical Society. Series B</em>, <b>26</b>2 pp. 211&ndash;252.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(poison)
 head(poison)

</code></pre>

<hr>
<h2 id='psifun'>Finds the tuning constant(s) associated to the supplied breakdown point or asymptotic efficiency for different psi functions</h2><span id='topic+psifun'></span>

<h3>Description</h3>

<p>Finds the tuning constant(s) associated to the supplied
breakdown point or asymptotic efficiency or computes breakdown point and
efficiency associated with the supplied constant(s) for the following psi functions:
TB=Tukey biweight, HA=Hampel, HU=Huber, HYP=Hyperbolic, OPT=Optimal, PD=mdpd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psifun(
  u = vector(mode = "double", length = 0),
  p = 1,
  fun = c("TB", "bisquare", "biweight", "HA", "hampel", "HU", "huber", "HYP",
    "hyperbolic", "OPT", "optimal", "PD", "mdpd"),
  bdp,
  eff,
  const,
  param,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psifun_+3A_u">u</code></td>
<td>
<p>optional vector containing scaled residuals or Mahalanobis
distances for the <code>n</code> units of the sample. If not provided,
rho, psi, psider, psix and weights are not computed</p>
</td></tr>
<tr><td><code id="psifun_+3A_p">p</code></td>
<td>
<p>number of variables (<code>p=1</code> for regression)</p>
</td></tr>
<tr><td><code id="psifun_+3A_fun">fun</code></td>
<td>
<p>psi function class. One of TB, HA, HU, HP, OPT or PD.</p>
</td></tr>
<tr><td><code id="psifun_+3A_bdp">bdp</code></td>
<td>
<p>requested breakdown point</p>
</td></tr>
<tr><td><code id="psifun_+3A_eff">eff</code></td>
<td>
<p>requested asymptotic efficiency</p>
</td></tr>
<tr><td><code id="psifun_+3A_const">const</code></td>
<td>
<p>tuning constant c</p>
</td></tr>
<tr><td><code id="psifun_+3A_param">param</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="psifun_+3A_trace">trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list will be returned
containing the following elements:
</p>

<ol>
<li> <p><code>class</code>:  link function which has be used. Possible values are
'bisquare', 'optimal', 'hyperbolic', 'hampel', 'huber' or 'mdpd'
</p>
</li>
<li> <p><code>bdp</code>: breakdown point
</p>
</li>
<li> <p><code>eff</code>: asymptotic efficiency
</p>
</li>
<li> <p><code>c1</code>: consistency factor (and other parameters) associated
to required breakdown point or nominal efficiency.
</p>
</li>
<li> <p><code>kc1</code>: Expectation of rho associated with <code>c1</code> to get a
consistent estimator at the model distribution
<code>kc1 = E(rho) = sup(rho)*bdp</code>
</p>
</li>
<li> <p><code>rho</code>: vector of length <code>n</code> which contains the rho
function associated to the residuals or Mahalanobis distances
for the <code>n</code> units of the sample. Empty if <code>u</code> is not provided.
</p>
</li>
<li> <p><code>psi</code>: vector of length <code>n</code> which contains the psi
function associated with the residuals or Mahalanobis distances
for the <code>n</code> units of the sample. Empty if <code>u</code> is not provided.
</p>
</li>
<li> <p><code>psider</code>: vector of length <code>n</code> which contains the derivative of the
psi function associated with the residuals or Mahalanobis distances
for the <code>n</code> units of the sample. Empty if <code>u</code> is not provided.
</p>
</li>
<li> <p><code>psix</code>: vector of length <code>n</code> which contains
the psi function mutiplied by u
associated with the residuals or Mahalanobis distances
for the <code>n</code> units of the sample. Empty if <code>u</code> is not provided.
</p>
</li>
<li> <p><code>wei</code>: vector of length <code>n</code> which contains the weights
associated with the residuals or Mahalanobis distances
for the <code>n</code> units of the sample. Empty if <code>u</code> is not provided.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Hoaglin, D.C. and Mosteller, F. and Tukey, J.W. (1982), <em>Understanding Robust and Exploratory Data Analysis</em>, Wiley, New York.
</p>
<p>Huber, P.J. (1981), <em>Robust Statistics</em>, Wiley.
</p>
<p>Huber, P.J. and Ronchetti, E.M. (2009), <em>Robust Statistics, 2nd Edition</em>, Wiley.
</p>
<p>Hampel, F.R. and Rousseeuw, P.J. and  Ronchetti E. (1981), The Change-of-Variance Curve and Optimal Redescending M-Estimators,
<em>Journal of the American Statistical Association</em>, <b>76</b>, pp. 643&ndash;648.
</p>
<p>Maronna, R.A. and Martin D. and Yohai V.J. (2006), <em>Robust Statistics, Theory and Methods</em>, Wiley, New York.
</p>
<p>Riani, M. and Atkinson, A. C.  and Corbellini, A.  and Perrotta, D. (2020)
Robust regression with density power divergence: Theory, comparisons,
and data analysis, <em>Entropy</em> <b>22</b>. doi:10.3390/e22040399.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 ##  Find c for given bdp for the Tukey biweight function
 ##  The constant c associated to a breakdown point of
 ##  50 percent in regression is
 ##      c=1.547644980928226
     psifun(bdp=0.5)
     psifun(c=1.547644980928226)

 ##  Find c for given bdp for the Hampel function
 psifun(bdp=0.5, fun="hampel")

 ## Plot Huber rho function.
 x &lt;- seq(-3, 3, 0.001)
 c &lt;- 1.345;

 HUc1 &lt;- psifun(u=x, p=1, fun="HU", const=c)
 rhoHU &lt;- HUc1$rho

 plot(x, rhoHU, type="l", lty="solid", lwd=2, col="blue",
     xlab="u", ylab="rho (u,1.345)", ylim=c(0.16, 4.5))
 lines(x, x^2/2, type="l", lty="dotted", lwd=1.5, col="red")
 legend(-1, 4.6, legend=c("Huber rho function", "u^2/2"),
     lty=c("solid", "dotted"), lwd=c(2,1.5), col=c("blue", "red"))

 yc &lt;- 0.13;
 text(-c, yc, paste0("-c=", -c), adj=1)
 text(c,yc, paste0("c=",c), adj=0)

 segments(c, 0, c, c**2/2, col="red")
 segments(-c, 0, -c, c**2/2, col="red")
 points(c, c**2/2, col="red")
 points(-c, c**2/2, col="red")

 
## End(Not run)

</code></pre>

<hr>
<h2 id='regspmplot'>Interactive scatterplot matrix for regression</h2><span id='topic+regspmplot'></span>

<h3>Description</h3>

<p>Produces an interactive scatterplot of the responce <code>y</code>
against each variable of the predictor matrix <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regspmplot(
  y,
  X,
  group,
  plot,
  namey,
  nameX,
  col,
  cex,
  pch,
  labeladd,
  legend,
  xlim,
  ylim,
  tag,
  datatooltip,
  databrush,
  subsize,
  selstep,
  selunit,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regspmplot_+3A_y">y</code></td>
<td>
<p>responce variable or an object containing the responce,
the predictors and possibly other variable resulting from monitoring
of regression.
</p>
<p>If <code>y</code> is a vector, a data matrix <code>X</code> must be present as an argument
If <code>y</code> is a list containing just <code>y</code> and <code>X</code>, the call is equivallent to
<code>regspmplot(y, X)</code>. Otherwise <code>y</code> must be an an object of S3 class
<code><a href="#topic+fsreda.object">fsreda.object</a></code> returned by
<code><a href="#topic+fsreg">fsreg</a></code> with <code>monitoring=TRUE</code> - a list containing
the monitoring along a search</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_x">X</code></td>
<td>
<p>Predictor variables. Data matrix of explanatory variables (also called 'regressors') of
dimension <code>n</code> by <code>p</code> if the argument <code>y</code> is a vector. The rows of <code>X</code>
represent observations, and the columns represent variables.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_group">group</code></td>
<td>
<p>grouping variable. Vector with <code>n</code> elements. Specifies
a grouping variable defined as a categorical variable (factor), numeric, or array of strings,
or string matrix, and it must have the same number of rows as <code>X</code>.
This grouping variable determines the marker and color assigned to each point.
Remark: if <code>group</code> is used to distinguish a set of outliers from
a set of good units, the id number for the outliers should be the larger
(see optional field <code>labeladd</code> of parameter <code>plo</code> for details).</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_plot">plot</code></td>
<td>
<p>This option controls the names which are displayed in the margins
of the scatterplot matrix as well as the labels of the legend.
If <code>plot=FALSE</code>, then namey, nameX and labeladd are both set to
the empty string (default), and no label and no name is added to the plot.
If <code>plot=TRUE</code> the names y, and X1,..., Xp are added to the margins of
the the scatter plot matrix else nothing is shown.
If <code>plot</code> is a list, it is possible to control not only the names but also,
point labels, colors and symbols. More precisely list <code>plot</code> may contain the following elements:
</p>

<ol>
<li> <p><code>labeladd</code> - see parameter <code>labeladd</code>
</p>
</li>
<li> <p><code>namey</code> - a character string containing the response variable name. See parameter <code>namey</code>.
</p>
</li>
<li> <p><code>nameX</code> - a vector of character strings containing the labels of
the explanatory variables. As default value, the labels which are
added are <code>Y1, ..., Yp</code>. See parameter <code>nameX</code>.
</p>
</li>
<li> <p><code>clr</code> - see parameter <code>col</code>
</p>
</li>
<li> <p><code>sym</code> - see parameter <code>pch</code>
</p>
</li>
<li> <p><code>siz</code> - see parameter <code>cex</code>
</p>
</li>
<li> <p><code>doleg</code> - see parameter <code>legend</code>
</p>
</li>
<li> <p><code>xlimx</code> - see parameter <code>xlim</code>
</p>
</li>
<li> <p><code>ylimy</code> - see parameter <code>ylim</code>
</p>
</li></ol>
</td></tr>
<tr><td><code id="regspmplot_+3A_namey">namey</code></td>
<td>
<p>a character string with the name of the responce variable</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_namex">nameX</code></td>
<td>
<p>a vector of character strings with the names of the explanatory variables</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_col">col</code></td>
<td>
<p>color specification for the data point. Can be different for each group.
By default, the order of the colors is <em>blue</em>, <em>red</em>, <em>black</em>,
<em>magenta</em>, <em>green</em>, <em>cyan</em> and <em>yelow</em>.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_cex">cex</code></td>
<td>
<p>the size of the symbols used for plotting. By default <code>cex=1</code>
the symbol size depends on the number of plots and the size of the
figure window. Values larger than 1 will increase the size and
values smaller than 1 will decrease the size.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_pch">pch</code></td>
<td>
<p>specification of the symbols to use. For example, if
there are three groups, and <code>pch=c(1, 3, 4)</code>, the first group will be
plotted with a circle, the second with a plus, and the third with a 'x' (see <code>?pch</code> or <code>?points</code> for
a list of symbols. NOTE: not all symbols available in R can be mapped to the symbols in MATLAB.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_labeladd">labeladd</code></td>
<td>
<p>logical, controls wheather the elements belonging to the last group
in the scatterplot matrix are labelled with their unit row index
or their rowname. The rowname is taken from the parameter <code>label</code>
or if it is missing, from the sequence <code>1:n</code>. The default value is
<code>labeladd=FALSE</code>, i.e. no label is added.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_legend">legend</code></td>
<td>
<p>logical, controls where a legend is shown or not.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_xlim">xlim</code></td>
<td>
<p>x limits. A vector with two elements controlling minimum
and maximum on the x axis. By defaul automatic scale is used.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_ylim">ylim</code></td>
<td>
<p>y limits. A vector with two elements controlling minimum
and maximum on the y axis. By defaul automatic scale is used.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_tag">tag</code></td>
<td>
<p>Plot handle. String which identifies the handle of the plot which is about to be created.
The default is <code>tag='pl_mmd'</code>. Notice that if the program finds a plot which has
a tag equal to the one specified by the user, then the output of the new plot overwrites
the existing one in the same window else a new window is created.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_datatooltip">datatooltip</code></td>
<td>
<p>If datatooltip is not empty the user can use the mouse in order to have
information about the unit selected, the step in which the unit enters the search and
the associated label. If datatooltip is a list, it is possible to control the aspect
of the data cursor (see MATLAB function <code>datacursormode()</code> for more details or
see the examples below). The default options are <code>DisplayStyle="Window"</code> and <code>SnapToDataVertex="on"</code>.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_databrush">databrush</code></td>
<td>
<p>Interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is TRUE or a list) enables the user to select
a set of trajectories in the current plot and to see them highlighted in the scatterplot matrix.
If the scatterplot matrix does not exist it is automatically created.
In addition, brushed units can be highlighted in the monitoring MD plot. Note that the window
style of the other figures is set equal to that which contains the monitoring residual plot.
In other words, if the monitoring residual plot is docked all the other figures will be docked too.
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and it is
possible to brush only once (that is persist=&rdquo;).
</p>
<p>Note that the window style of the other figures is set equal to that which contains the
monitoring residual plot. In other words, if the monitoring residual plot is docked all
the other figures will be docked too
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and
it is possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of
the MATLAB function <code>selectdataFS()</code> and the following optional arguments:
</p>

<ul>
<li> <p><code>persist</code>: This option can be an empty value or a character containing 'on' or 'off'.
The default value is <code>persist=""</code>, that is brushing is allowed only once.
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are
added to those previously brushed. It is possible, every time a new brushing is
done, to use a different color for the brushed units. If <code>persist='off'</code>
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>labeladd</code>: add labels of brushed units in the scatterplot matrix.
If this option is '1', we label the units of the last selected group with
the unit row index in the matrix X. The default value is labeladd=&rdquo;,
i.e. no label is added.
</p>
</li></ul>
</td></tr>
<tr><td><code id="regspmplot_+3A_subsize">subsize</code></td>
<td>
<p>x axis control, a numeric vector containing the subset size
with length equal to the number of columns of matrix residuals. If it is
not specified it will be set equal to <code>(nrow(residuals) - ncol(residuals) + 1) : nrow(residuals)</code>.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_selstep">selstep</code></td>
<td>
<p>Text shown in selected steps, a numeric vector which specifies
for which steps of the forward search textlabels are added in the monitoring
residual plot after a brushing action in the yXplot. The default is to
write the labels at the initial and final step. The default is
<code>selstep=c(m0, n)</code> where <code>m0</code> and <code>n</code> are respectively
the first and final step of the search.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_selunit">selunit</code></td>
<td>
<p>Unit labelling. A vector of strings, a string, or a numeric
vector for labelling units. If out is an object the threshold is associated
with the trajectories of the residuals monitored along the search else it
refers to the values of the response variable. If it is a vector of strings,
only the lines associated with the units that in at least one step of the
search had a residual smaller than <code>selunit[1]</code> or greater than
<code>sellunit[2]</code> will have a textbox. If it is a string it specifies
the threshold above which labels have to be put. For example <code>selunit='2.6'</code>
means that the text labels are written only for the units which have
in at least one step of the search a value of the scaled residual
greater than 2.6 in absolute value. If it is a numeric vector it
contains the list of the units for which it is necessary to put
the text labels. The default value of selunit is string <code>'2.5'</code>
if <code>y</code> is an object else it is an empty value.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="regspmplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spmplot">spmplot</a></code>, <code><a href="#topic+mdrplot">mdrplot</a></code>, <code><a href="#topic+resfwdplot">resfwdplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 ##  Example of the use of function regspmplot with all the default options
 ##  regsmplot() with first argument vector y and no option.
 ##  In the first example as input there are two matrices: y and X respectively
 ##  A simple plot is created

 n &lt;- 100
 p &lt;- 3
 X &lt;- matrix(data=rnorm(n*p), nrow=n, ncol=p)
 y &lt;- matrix(data=rnorm(n*1), nrow=n, ncol=1)
 regspmplot(y, X)

 ##  Example of the use of function regspmplot with first argument
 ##  vector y and third argument group.
 ##  Different groups are shown in the yXplot

 group &lt;- rep(0, n)
 group[1:(n/2)] &lt;- rep(1, n/2)
 regspmplot(y, X, group)

 ##  Example of the use of function regspmplot with first argument
 ##  vector y, third argument group and fourth argument plot
 ##  (Ex1) plot=TRUE

 regspmplot(y, X, group, plot=TRUE)

 ##  (Ex1) Set the scale for the x axes, the y axis and control symbol type
 regspmplot(y, X, group, xlim=c(-1,2), ylim=c(0,2), pch=c(10,11), trace=TRUE)

 ##  When the first input argument is an object.
 ##  In the following example the input is an object which also contains
 ##  information about the forward search.
     (out &lt;- fsreg(y~X, method="LMS", control=LXS_control(nsamp=1000)))
     (out &lt;- fsreg(y~X, bsb=out$bs, monitoring=TRUE))

     regspmplot(out, plot=0)

 
## End(Not run)

</code></pre>

<hr>
<h2 id='resfwdplot'>
Plots the trajectories of the monitored scaled (squared) residuals
</h2><span id='topic+resfwdplot'></span>

<h3>Description</h3>

<p>Plots the trajectories of the monitored scaled (squared) residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resfwdplot(out, 
    xlim, ylim, xlab, ylab, main, lwd, lty, col, cex.lab, cex.axis, 
    xvalues, 
    fg.thresh, fg.unit, fg.labstep, fg.lwd, fg.lty, fg.col, fg.mark, fg.cex, 
    bg.thresh, bg.style, 
    tag, datatooltip, label, nameX, namey, msg, databrush, 
    standard, fground, bground, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resfwdplot_+3A_out">out</code></td>
<td>

<p>An object returned by one of the monitoring functions (see <code><a href="#topic+FSReda_control">FSReda_control</a></code>, 
<code><a href="#topic+Sregeda_control">Sregeda_control</a></code> and <code><a href="#topic+MMregeda_control">MMregeda_control</a></code>). The object is one of
<code><a href="#topic+fsreda.object">fsreda.object</a></code>, <code><a href="#topic+sregeda.object">sregeda.object</a></code> or <code><a href="#topic+mmregeda.object">mmregeda.object</a></code>.
</p>
<p>The needed elements of <code>out</code> are 
</p>

<ol>
<li> <p><code>RES</code>: matrix containing the residuals monitored in each step of the forward 
search or any other robust procedure. Every row is associated with a residual (unit). 
This matrix can be created using function FSReda, Sregeda, MMregeda.
</p>
</li>
<li> <p><code>Un</code>: (for FSR only) - matrix containing the order of entry in the subset of each unit 
(required only when datatooltip is true or databrush is not empty).
</p>
</li>
<li> <p><code>bdp</code>: (for Sreg only) - vector containing a sequence of breakdown point values to monitor on.
</p>
</li>
<li> <p><code>eff</code>: (for MMreg only) - vector containing a sequence of efficiency values to monitor on.
</p>
</li>
<li> <p><code>y</code>: a vector containing the response (required only when option databrush is requested).
</p>
</li>
<li> <p><code>X</code>: a matrix containing the explanatory variables (required only when option databrush is requested).
</p>
</li>
<li> <p><code>Bols</code>: (n-init+1) x (p+1) matrix containing the estimated beta coefficients monitored in 
each step of the robust procedure (required only when option databrush is requested and suboption multivarfit is requested).
</p>
</li></ol>

</td></tr>
<tr><td><code id="resfwdplot_+3A_ylim">ylim</code></td>
<td>
<p>Control <code>y</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the y axis. Default is to use automatic scale.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_xlim">xlim</code></td>
<td>
<p>Control <code>x</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the x axis. Default is to use automatic scale.
</p>
</td></tr>   
<tr><td><code id="resfwdplot_+3A_xlab">xlab</code></td>
<td>

<p>a title for the x axis
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_ylab">ylab</code></td>
<td>

<p>a title for the y axis
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_main">main</code></td>
<td>

<p>an overall title for the plot
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_lwd">lwd</code></td>
<td>

<p>The line width, a positive number, defaulting to 1
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_lty">lty</code></td>
<td>

<p>The line type. Line types can either be specified as an integer (1=solid (default), 2=dashed, 
3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;solid&quot;, 
&quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;. 
The latter two are not supported by Matlab.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_col">col</code></td>
<td>

<p>colors to be used for the highlighted units
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_cex.lab">cex.lab</code></td>
<td>

<p>The magnification to be used for x and y labels relative to the current setting of cex
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_cex.axis">cex.axis</code></td>
<td>

<p>The magnification to be used for axis annotation relative to the current setting of cex
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_xvalues">xvalues</code></td>
<td>

<p>values for the x axis. Numeric vector of <code>ncol(RES)</code> controlling the x axis coordinates. 
The default value of xvalues is <code>(nrow(RES) - ncol(RES) + 1):nrow(RES)</code>
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fg.thresh">fg.thresh</code></td>
<td>

<p>(alternative to fg.unit) numeric vector of length 1 or 2 which specifies the highlighted trajectories.
If <code>length(fthresh) == 1</code> the highlighted trajectories are those of units that throughtout 
the search had at leat once a residual greater (in absolute value) than thresh. 
The default value is <code>fg.thresh=2.5</code>. If <code>length(fthresh) == 2</code> the highlighted 
trajectories are those of units that throughtout the search had a residual at 
leat once bigger than <code>fg.thresh[2]</code> or smaller than <code>fg.thresh[1]</code>.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fg.unit">fg.unit</code></td>
<td>

<p>(alternative to fg.thresh), vector containing the list of the units to be highlighted. 
If <code>fg.unit</code> is supplied, <code>fg.thresh</code> is ignored.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fg.labstep">fg.labstep</code></td>
<td>

<p>numeric vector which specifies the steps of the search where to put labels for 
the highlighted trajectories (units). The default is to put the labels at the 
initial and final steps of the search. <code>fg.labstep=''</code> means no label.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fg.lwd">fg.lwd</code></td>
<td>

<p>The line width for the highlighted trajectories (units). Default is 1.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fg.lty">fg.lty</code></td>
<td>

<p>The line type for the highlighted trajectories (units). Line types can 
either be specified as an integer (1=solid (default), 2=dashed, 
3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;solid&quot;, 
&quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;. 
The latter two are not supported by Matlab.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fg.col">fg.col</code></td>
<td>

<p>colors to be used for the highlighted units.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fg.mark">fg.mark</code></td>
<td>

<p>Controlls whether to plot highlighted trajectories as symbols.
if <code>fg.mark==TRUE</code> each line is plotted using a different 
symbol else no marker is used (default).
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fg.cex">fg.cex</code></td>
<td>

<p>controls the font size of the labels of the trajectories in foreground.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_bg.thresh">bg.thresh</code></td>
<td>

<p>numeric vector of length 1 or 2 which specifies how to define the unimmportant trajectories.
Unimmportant trajectories will be plotted using a colormap, in greysh or will be hidden.
If <code>length(thresh) == 1</code> the irrelevant units are those which always 
had a residual smaller (in absolute value) than thresh.
If <code>length(bthresh) == 2</code> the irrelevant units are those which always 
had a residual greater than bthresh(1) and smaller than bthresh(2). The default is:
<code>bg.thresh=2.5</code> if <code>n &gt; 100</code> and <code>bg.thresh=-Inf</code> if <code>n &lt;= 100</code> 
i.e. to treat all trajectories as important if <code>n &lt;= 100</code> and, if <code>n &gt; 100</code>, 
to reduce emphasis only to trajectories having in all steps of the search a value 
of scaled residual smaller than 2.5.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_bg.style">bg.style</code></td>
<td>

<p>specifies how to plot the unimportant trajectories as defined in option bthresh.
</p>

<ol>
<li> <p><code>bg.style="faint"</code>: unimportant trajectories are plotted using a colormap.
</p>
</li>
<li> <p><code>bg.style="hide"</code>: unimportant trajectories are hidden.
</p>
</li>
<li> <p><code>bg.style="greyish"</code>: unimportant trajectories are displayed in a faint grey.
</p>
</li></ol>

<p>When <code>n&gt;100</code> the default option is <code>bg.style='faint'</code>. When <code>n &lt;= 100</code> 
and <code>bg.thresh == -Inf</code> option bstyle is ignored.
Remark: bground=&rdquo; is equivalent to -Inf that is all trajectories are considered relevant.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_tag">tag</code></td>
<td>

<p>Plot handle. String which identifies the handle of the plot which is about to be created. 
The default is to use tag 'pl_resfwd'. Notice that if the program finds a plot which has 
a tag equal to the one specified by the user, then the output of the new plot overwrites 
the existing one in the same window else a new window is created.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_datatooltip">datatooltip</code></td>
<td>

<p>Interactive clicking. It is inactive if this parameter is missing or empty. 
The default is <code>datatooltip=TRUE</code>, i.e. the user can select with the 
mouse an individual residual trajectory in order to have information about 
the corresponding unit. The information displayed depends on the estimator in use.
</p>
<p>For example for class <code><a href="#topic+fsreda.object">fsreda.object</a></code> the information concerns the 
label and the step of the search in which the unit enters the subset. If datatooltip 
is a list it may contain the following fields:
</p>

<ol>
<li><p> DisplayStyle determines how the data cursor displays. Possible values are 
<code>'datatip'</code> and <code>'window'</code> (default). <code>'datatip'</code> displays 
data cursor information in a small yellow text box attached to a black 
square marker at a data point you interactively select. <code>'window'</code> 
displays data cursor information for the data point you interactively 
select in a floating window within the figure.
</p>
</li>
<li><p> SnapToDataVertex: specifies whether the data cursor snaps to the nearest data value or 
is located at the actual pointer position. 
Possible values are <code>SnapToDataVertex='on'</code> (default) and <code>SnapToDataVertex='off'</code>.
</p>
</li>
<li><p> LineColor: controls the color of the trajectory selected with the mouse. It can be an RGB triplet 
of values between 0 and 1, or character vector indicating a color name. Note that a RGB vector 
can be conveniently chosen with our MATLAB class FSColor, see documentation.
</p>
</li>
<li><p> SubsetLinesColor: enables to control the color of the trajectories of the units that are 
in the subset at a given step of the search (if <code>resfwdplot()</code> is applied to an 
object of class <code><a href="#topic+fsreda.object">fsreda.object</a></code>) or have a weight greater than 0.9 (if 
<code>resfwdplot()</code> is applied to an object of class <code><a href="#topic+sregeda.object">sregeda.object</a></code> 
or <code><a href="#topic+mmregeda.object">mmregeda.object</a></code>). This can be done (repeatedly) with a left mouse 
click in proximity of the step of interest. A right mouse click will terminate the 
selection by marking with a up-arrow the step corresponding to the highlighted 
lines. The highlighted lines by default are in red, but a different color can be 
specified as RGB triplet or character of color name. Note that a RGB vector can 
be conveniently chosen with our MATLAB class FSColor, see documentation. 
By default <code>SubsetLinesColor=""</code>, i.e. the modality is not active.
Any initialization for <code>SubsetLinesColor</code> which cannot be interpreted as 
RGB vector will be converted to blue, i.e. <code>SubsetLinesColor</code> will be forced to be [0 0 1].
If <code>SubsetLinesColor</code> is not empty the previous option <code>LineColor</code> is ignored.
</p>
</li></ol>

</td></tr>
<tr><td><code id="resfwdplot_+3A_label">label</code></td>
<td>

<p>Character vector containing the labels of the units (optional argument used when 
<code>datatooltip=TRUE</code>). If this field is not present labels 
row1, ..., rown will be automatically created and included 
in the pop up datatooltip window).
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in plot. A vector of strings of length <code>p</code> 
containing the labels of the variables of the regression dataset. 
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_namey">namey</code></td>
<td>
<p>Add response label. A string containing the label of the response</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_msg">msg</code></td>
<td>

<p>Controls whether to display or not messages on the screen If <code>msg==1</code> (default) 
messages are displayed on the screen about step in which signal took place else 
no message is displayed on the screen.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_databrush">databrush</code></td>
<td>

<p>interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is a scalar or a list) enables the user to select 
a set of trajectories in the current plot and to see them highlighted in the y|X plot, 
i.e. a matrix of scatter plots of y against each column of X, grouped according to the 
selection(s) done by brushing. If the plot y|X does not exist it is automatically created.
In addition, brushed units are automatically highlighted in the minimum deletion residual 
plot if it is already open. The extension to the following plots will be available in future 
versions of the toolbox:
</p>

<ol>
<li><p> monitoring leverage plot;
</p>
</li>
<li><p> maximum studentized residual;
</p>
</li>
<li><p> s^2 and R^2;
</p>
</li>
<li><p> Cook distance and modified Cook distance;
</p>
</li>
<li><p> deletion t statistics.
</p>
</li></ol>

<p>Note that the window style of the other figures is set equal to that which contains the 
monitoring residual plot. In other words, if the monitoring residual plot is docked all 
the other figures will be docked too 
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and 
it is possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of 
function <code>selectdataFS()</code> and the following optional argument:
</p>

<ol>
<li> <p><code>persist</code>. Persist is an empty value or a character containing 'on' or 'off'. 
The default value is <code>persist=""</code>, that is brushing is allowed only once.    
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as 
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are 
added to those previously brushed. It is possible, every time a new brushing is 
done, to use a different color for the brushed units. If <code>persist='off'</code> 
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>bivarfit</code>. Wheather to superimpose bivariate least square lines on the plot (if <code>plot=TRUE</code>.
This option adds one or more least squares lines, based on SIMPLE REGRESSION of y on Xi, 
to the plots of y|Xi. The default is <code>bivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. If <code>bivarfit=2</code>, two OLS lines are fitted: 
one to all points and another to the group of the genuine observations. 
The group of the potential outliers is not fitted. If <code>bivarfit=0</code> 
one OLS line is fitted to each group. This is useful for the purpose of 
fitting mixtures of regression lines. If <code>bivarfit='i1'</code> or 
<code>bivarfit='i2'</code>, etc. an OLS line is fitted to a specific group, 
the one with index 'i' equal to 1, 2, 3 etc. 
Again, useful in case of mixtures.
</p>
</li>
<li> <p><code>multivarfit</code>. Wheather to superimpose multivariate least square lines. 
This option adds one or more least square lines, based on MULTIVARIATE REGRESSION 
of y on X, to the plots of y|Xi. 
The default is <code>multivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. The line added to the scatter plot y|Xi is 
avconst + Ci*Xi, where Ci is the coefficient of Xi in the multivariate regression 
and avconst is the effect of all the other explanatory variables different 
from Xi evaluated at their centroid (that is overline(y)'C)). 
If <code>multivarfit=2</code>, same action as with <code>multivarfit=1</code> but this time 
we also add the line based on the group of unselected observations 
(i.e. the normal units).
</p>
</li>
<li> <p><code>labeladd</code>. Add outlier labels in plot. If <code>labeladd=TRUE</code>, we label the outliers 
with the unit row index in matrices X and y. 
The default value is <code>labeladd=FALSE</code>, i.e. no label is added.
</p>
</li></ol>

</td></tr>
<tr><td><code id="resfwdplot_+3A_standard">standard</code></td>
<td>

<p>(MATLAB-style arguments) appearance of the plot in terms of xlim, ylim, axes labels 
and their font size style, color of the lines, etc.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_fground">fground</code></td>
<td>

<p>MATLAB-style arguments for the fground trajectories in foregroud.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_bground">bground</code></td>
<td>

<p>MATLAB-style arguments for the fground trajectories in backgroud.
</p>
</td></tr>
<tr><td><code id="resfwdplot_+3A_...">...</code></td>
<td>

<p>potential further arguments passed to lower level functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>No value returned
</p>


<h3>Author(s)</h3>

<p>FSDA team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

n &lt;- 100
y &lt;- rnorm(n)
X &lt;- matrix(rnorm(n*4), nrow=n)

out &lt;- fsreg(y~X, method="LTS")
out &lt;- fsreg(y~X, method="FS", bsb=out$bs, monitoring=TRUE)
resfwdplot(out)


## End(Not run)
</code></pre>

<hr>
<h2 id='resindexplot'>
Plots the residuals from a regression analysis versus index number or any other variable
</h2><span id='topic+resindexplot'></span>

<h3>Description</h3>

<p>The function <code>resindexplot()</code> plots the residuals from a regression analysis
versus index number or any other variable. The residuals come from an output
object of any of the regression fucntions or a simply a vector of values.
In order to use the databrush option, the residuals must come from one of
the fsdaR regression functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resindexplot(out, x, xlim, ylim, xlab, ylab, main, numlab, indlab, conflev, cex.axis, 
    cex.lab, lwd, nameX, namey, tag, col, cex, databrush, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resindexplot_+3A_out">out</code></td>
<td>

<p>A vector containing the residuals from a regression analysis or an object returned by one of 
the regression functions (see <code><a href="#topic+FSR_control">FSR_control</a></code>, <code><a href="#topic+LXS_control">LXS_control</a></code>, 
<code><a href="#topic+Sreg_control">Sreg_control</a></code> and <code><a href="#topic+MMreg_control">MMreg_control</a></code>). The object is one of
<code><a href="#topic+fsr.object">fsr.object</a></code>, <code><a href="#topic+fsdalts.object">fsdalts.object</a></code>, <code><a href="#topic+fsdalms.object">fsdalms.object</a></code>, 
<code><a href="#topic+sreg.object">sreg.object</a></code> or <code><a href="#topic+mmreg.object">mmreg.object</a></code>. The needed elements of <code>out</code> are 
at least <code>residuals</code>, but if the option <code>databrush</code> is used, also <code>X</code> amd <code>y</code> will be needed.
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_x">x</code></td>
<td>

<p>The vector to be plotted on the x-axis. As default the sequence 1:length(residuals) will be used
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_xlim">xlim</code></td>
<td>
<p>Control <code>x</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the x axis. Default is to use automatic scale.
</p>
</td></tr>   
<tr><td><code id="resindexplot_+3A_ylim">ylim</code></td>
<td>
<p>Control <code>y</code> scale in plot. Vector with two elements controlling 
minimum and maximum on the y axis. Default is to use automatic scale.
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_xlab">xlab</code></td>
<td>

<p>a title for the x axis
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_ylab">ylab</code></td>
<td>

<p>a title for the y axis
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_main">main</code></td>
<td>

<p>an overall title for the plot
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_numlab">numlab</code></td>
<td>

<p>Number of points to be identified in plots (see also <code>indlab</code>) . By default the five points with largest values will be identified.
If numlab is a single number containing scalar k, the units with the k largest residuals are labelled in the plots.
If numlab is a vector, the units inside vector numlab are labelled in the plots. 
The default value of <code>numlab=5</code> and the units with the 5 largest residuals will be labelled. If <code>numlib=0</code> or 
<code>numlib=NULL</code> no labelling will be done.
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_indlab">indlab</code></td>
<td>

<p>Which points to be identified in plots (see also <code>numlab</code>) - the units with indexes in the vector indlab are labelled in the plots. 
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_conflev">conflev</code></td>
<td>

<p>Confidence interval for the horizontal bands (a numeric vector). 
It can be a vector of different confidence level values. 
</p>
<p>Remark: confidence interval is based on the chi^2 distribution
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_cex.axis">cex.axis</code></td>
<td>

<p>The magnification to be used for axis annotation relative to the current setting of cex
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_cex.lab">cex.lab</code></td>
<td>

<p>The magnification to be used for x and y labels relative to the current setting of cex  
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_lwd">lwd</code></td>
<td>

<p>The line width, a positive number, defaulting to 1
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_tag">tag</code></td>
<td>

<p>Figure tag (character). Tag of the figure which will host the <code>resindexplot</code>. 
The default tag is <code>pl_resindex</code>.
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_col">col</code></td>
<td>

<p>Fill color for markers that are closed shapes (circle, square, diamond, pentagram, hexagram, and the four triangles).
Can be <code>'none'</code> or <code>'auto'</code> or color name(string) or  RGB triplet.
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_cex">cex</code></td>
<td>

<p>Size of the point symbols. The magnification to be used relative to the current setting of cex.
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_namex">nameX</code></td>
<td>
<p>Add variable labels in plot. A vector of strings of length <code>p</code> 
containing the labels of the variables of the regression dataset. 
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically
</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_namey">namey</code></td>
<td>
<p>Add response label. A string containing the label of the response</p>
</td></tr>
<tr><td><code id="resindexplot_+3A_databrush">databrush</code></td>
<td>

<p>Interactive mouse brushing. If databrush is missing or empty (default) or <code>databrush=FALSE</code>, no brushing is done.
The activation of this option (databrush is a scalar or a list) enables the user to select 
a set of trajectories in the current plot and to see them highlighted in the y|X plot, 
i.e. a matrix of scatter plots of y against each column of X, grouped according to the 
selection(s) done by brushing. If the plot y|X does not exist it is automatically created.
In addition, brushed units are automatically highlighted in the minimum deletion residual 
plot if it is already open. The extension to the following plots will be available in future 
versions of the package:
</p>

<ol>
<li><p> monitoring leverage plot;
</p>
</li>
<li><p> maximum studentized residual;
</p>
</li>
<li><p> s^2 and R^2;
</p>
</li>
<li><p> Cook distance and modified Cook distance;
</p>
</li>
<li><p> deletion t statistics.
</p>
</li></ol>

<p>Note that the window style of the other figures is set equal to that which contains the 
monitoring residual plot. In other words, if the monitoring residual plot is docked all 
the other figures will be docked too 
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and 
it is possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of 
function <code>selectdataFS()</code> and the following optional argument:
</p>

<ol>
<li> <p><code>persist</code>. Persist is an empty value or a character containing 'on' or 'off'. 
The default value is <code>persist=""</code>, that is brushing is allowed only once.    
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as 
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are 
added to those previously brushed. It is possible, every time a new brushing is 
done, to use a different color for the brushed units. If <code>persist='off'</code> 
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>bivarfit</code>. This option adds one or more least square lines based on 
SIMPLE REGRESSION to the plots of y|X, depending on the selected groups.
The default is <code>bivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. If <code>bivarfit=2</code>, two OLS lines are fitted: 
one to all points and another to the group of the genuine observations. 
The group of the potential outliers is not fitted. If <code>bivarfit=0</code> 
one OLS line is fitted to each group. This is useful for the purpose of 
fitting mixtures of regression lines. If <code>bivarfit='i1'</code> or 
<code>bivarfit='i2'</code>, etc. an OLS line is fitted to a specific group, 
the one with index 'i' equal to 1, 2, 3 etc. 
Again, useful in case of mixtures.
</p>
</li>
<li> <p><code>multivarfit</code>.  Wheather to superimpose multivariate least square lines. 
This option adds one or more least square lines, based on MULTIVARIATE REGRESSION 
of y on X, to the plots of y|Xi. 
The default is <code>multivarfit=FALSE</code>: no line is fitted. 
If <code>bivarfit=1</code>, a single OLS line is fitted to all points of each bivariate 
plot in the scatter matrix y|X. The line added to the scatter plot y|Xi is 
avconst + Ci*Xi, where Ci is the coefficient of Xi in the multivariate regression 
and avconst is the effect of all the other explanatory variables different 
from Xi evaluated at their centroid (that is overline(y)'C)). 
If <code>multivarfit=2</code>, same action as with <code>multivarfit=1</code> but this time 
we also add the line based on the group of unselected observations 
(i.e. the normal units).
</p>
</li>
<li> <p><code>labeladd</code>. Add outlier labels in plot. If <code>labeladd=TRUE</code>, we label the outliers 
with the unit row index in matrices X and y. 
The default value is <code>labeladd=FALSE</code>, i.e. no label is added.
</p>
</li></ol>

</td></tr>
<tr><td><code id="resindexplot_+3A_...">...</code></td>
<td>

<p>potential further arguments passed to lower level functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details
</p>


<h3>Value</h3>

<p>No value returned
</p>


<h3>Author(s)</h3>

<p>FSDA team
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out &lt;- fsreg(stack.loss~., data=stackloss)
resindexplot(out, conflev=c(0.95,0.99), col="green")

## End(Not run)
</code></pre>

<hr>
<h2 id='score'>Computes the score test for transformation in regression</h2><span id='topic+score'></span><span id='topic+score.formula'></span><span id='topic+score.default'></span>

<h3>Description</h3>

<p>Computes the score test for transformation in regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(x, ...)

## S3 method for class 'formula'
score(
  formula,
  data,
  subset,
  weights,
  na.action,
  model = TRUE,
  contrasts = NULL,
  offset,
  ...
)

## Default S3 method:
score(
  x,
  y,
  intercept = TRUE,
  la = c(-1, -0.5, 0, 0.5, 1),
  lik = FALSE,
  nocheck = FALSE,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_x">x</code></td>
<td>
<p>An <code>n x p</code> data matrix (<code>n</code> observations and <code>p</code> variables).
Rows of <code>x</code> represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="score_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
<tr><td><code id="score_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> of the form <code>y ~ x1 + x2 + ...</code>.</p>
</td></tr>
<tr><td><code id="score_+3A_data">data</code></td>
<td>
<p>data frame from which variables specified in
<code>formula</code> are to be taken.</p>
</td></tr>
<tr><td><code id="score_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="score_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used



<b>NOT USED YET</b>.</p>
</td></tr>
<tr><td><code id="score_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &ldquo;factory-fresh&rdquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="score_+3A_model">model</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the
model frame, is to be returned.</p>
</td></tr>
<tr><td><code id="score_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list.  See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="score_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em>
known component to be included in the linear predictor
during fitting.  An <code><a href="stats.html#topic+offset">offset</a></code> term can be included in the</p>
</td></tr>
<tr><td><code id="score_+3A_y">y</code></td>
<td>
<p>Response variable. A vector with <code>n</code> elements that
contains the response variable.</p>
</td></tr>
<tr><td><code id="score_+3A_intercept">intercept</code></td>
<td>
<p>wheather to use constant term (default is <code>intercept=TRUE</code></p>
</td></tr>
<tr><td><code id="score_+3A_la">la</code></td>
<td>
<p>values of the transformation parameter for which it is necessary
to compute the score test. Default value of lambda is
<code>la=c(-1, -0.5, 0, 0.5, 1)</code>, i.e., the five most common values of lambda.</p>
</td></tr>
<tr><td><code id="score_+3A_lik">lik</code></td>
<td>
<p>likelihood for the augmented model. If true the value of the likelihood
for the augmented model will be calculated and returend otherwise (default) only
the value of the score test will be given</p>
</td></tr>
<tr><td><code id="score_+3A_nocheck">nocheck</code></td>
<td>
<p>Whether to check input arguments. If <code>nocheck=TRUE</code> no check is performed
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code>
are left unchanged. In other words the additional column of ones for the
intercept is not added. The default is <code>nocheck=FALSE</code>.</p>
</td></tr>
<tr><td><code id="score_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code><a href="#topic+score.object">score.object</a></code> will be returned which is basically a list
containing the following elements:
</p>

<ol>
<li> <p><code>la</code>: vector containing the values of lambda for which fan plot is constructed
</p>
</li>
<li> <p><code>Score</code>: a vector containing the values of the score test for
each value of the transformation parameter.
</p>
</li>
<li> <p><code>Lik</code>: value of the likelihood. This output is produced only if lik=TRUE.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Atkinson, A.C. and Riani, M. (2000), <em>Robust Diagnostic Regression Analysis</em> Springer Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   data(wool)
   XX &lt;- wool
   y &lt;- XX[, ncol(XX)]
   X &lt;- XX[, 1:(ncol(XX)-1), drop=FALSE]

   (out &lt;- score(X, y))                          # call 'score' with all default parameters
   (out &lt;- score(cycles~., data=wool))           # use the formula interface
   (out &lt;- score(cycles~., data=wool, lik=TRUE)) # return the likelihood

   data(loyalty)
   head(loyalty)
   ##    la is a vector containing the values of \lambda which have to be tested
   (out &lt;- score(amount_spent~., data=loyalty, la=c(0.25, 1/3, 0.4, 0.5)))
   (out &lt;- score(amount_spent~., data=loyalty, la=c(0.25, 1/3, 0.4, 0.5), lik=TRUE))
 
## End(Not run)

</code></pre>

<hr>
<h2 id='score.object'>Objects returned by the function <code><a href="#topic+score">score</a></code></h2><span id='topic+score.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+score.object">score.object</a></code> holds information about
the result of a call to <code><a href="#topic+score">score</a></code>.
</p>


<h3>Value</h3>

<p>The functions <code>print()</code> and <code>summary()</code> are used to obtain and print a
summary of the results. An object of class <code>score</code> is a list containing at least the following components:
</p>

<ol>
<li> <p><code>la</code>: vector containing the values of lambda for which fan plot is constructed
</p>
</li>
<li> <p><code>Score</code>: a vector containing the values of the score test for
each value of the transformation parameter.
</p>
</li>
<li> <p><code>Lik</code>: value of the likelihood. This output is produced only if lik=TRUE.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
   data(wool)
   (out &lt;- score(cycles~., data=wool, lik=TRUE))

   class(out)
   summary(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smult'>Computes  S estimators in multivariate analysis</h2><span id='topic+smult'></span>

<h3>Description</h3>

<p>Computes  S estimators in multivariate analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smult(
  x,
  monitoring = FALSE,
  plot = FALSE,
  bdp,
  nsamp,
  conflev = 0.975,
  nocheck = FALSE,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smult_+3A_x">x</code></td>
<td>
<p>An n x p data matrix (n observations and p variables).
Rows of x represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="smult_+3A_monitoring">monitoring</code></td>
<td>
<p>Wheather to perform monitoring of Mahalanobis distances and other specific quantities</p>
</td></tr>
<tr><td><code id="smult_+3A_plot">plot</code></td>
<td>
<p>Plots the Mahalanobis distances against index number. If <code>plot=FALSE</code>
(default) or <code>plot=0</code>  no plot is produced. The confidence
level used to draw the confidence bands for the MD is given by the input option conflev.
If conflev is not specified a nominal 0.975 confidence interval will be used.
If <code>plot=2</code>  a scatter plot matrix with the outliers highlighted is produced.
If plot is a list it may contain the following fields:
</p>

<ul>
<li><p> labeladd If <code>labeladd=1</code>, the outliers in the spm are labelled with the unit
row index. The default value is <code>labeladd=""</code>, i.e. no label is added
</p>
</li>
<li><p> nameY character vector containing the labels of the variables. As default value,
the labels which are added are Y1, ...Yp.
</p>
</li></ul>
</td></tr>
<tr><td><code id="smult_+3A_bdp">bdp</code></td>
<td>
<p>Measures the fraction of outliers the algorithm should resist.
In this case any value greater than 0 but smaller or equal than 0.5 will do fine (default is <code>bdp=0.5</code>).
Note that given bdp nominal efficiency is automatically determined.</p>
</td></tr>
<tr><td><code id="smult_+3A_nsamp">nsamp</code></td>
<td>
<p>Number of subsamples which will be extracted to find the robust estimator.
If <code>nsamp=0</code> all subsets will be extracted. They will be
<code>(n choose p)</code>. If the number of all possible subset is <code>&lt;1000</code>
the default is to extract all subsets otherwise just 1000.</p>
</td></tr>
<tr><td><code id="smult_+3A_conflev">conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers (scalar).
Usually <code>conflev=0.95</code>, <code>conflev=0.975</code> or <code>conflev=0.99</code> (individual alpha)
<code>conflev=1-0.05/n</code>, <code>conflev=1-0.025/n</code> or <code>conflev=1-0.01/n</code> (simultaneous alpha).
Default value is <code>convlev=0.975</code>.</p>
</td></tr>
<tr><td><code id="smult_+3A_nocheck">nocheck</code></td>
<td>
<p>It controls whether to perform checks on matrix Y. If <code>nocheck=TRUE</code>, no check is performed.</p>
</td></tr>
<tr><td><code id="smult_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="smult_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function follows the lines of MATLAB/R code developed during the years by many authors.
For more details see http://www.econ.kuleuven.be/public/NDBAE06/programs/ and
the R package <a href="rrcov.html#topic+CovSest">CovSest</a>
The core of these routines, e.g. the resampling approach, however, has been
completely redesigned, with considerable increase of the computational performance.
</p>


<h3>Value</h3>

<p>Depending on the input parameter <code>monitoring</code>, one of
the following objects will be returned:
</p>

<ol>
<li> <p><code><a href="#topic+smult.object">smult.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+smulteda.object">smulteda.object</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Maronna, R.A., Martin D. and Yohai V.J. (2006), Robust Statistics, Theory and Methods, Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 data(hbk, package="robustbase")
 (out &lt;- smult(hbk[,1:3]))
 class(out)
 summary(out)

 ##  Generate contaminated data (200,3)
 n &lt;- 200
 p &lt;- 3
 set.seed(123456)
 X &lt;- matrix(rnorm(n*p), nrow=n)
 Xcont &lt;- X
 Xcont[1:5, ] &lt;- Xcont[1:5,] + 3

 out1 &lt;- smult(Xcont, trace=TRUE)           # no plots (plot defaults to FALSE)
 names(out1)

 ## plot=TRUE - generates: (1) a plot of Mahalanobis distances against
 ##    index number. The confidence level used to draw the confidence bands for
 ##    the MD is given by the input option conflev. If conflev is
 ##    not specified a nominal 0.975 confidence interval will be used and
 ##    (2) a scatter plot matrix with the outliers highlighted.

 (out1 &lt;- smult(Xcont, trace=TRUE, plot=TRUE))

 ## plots is a list: the spm shows the labels of the outliers.
 (out1 &lt;- smult(Xcont, trace=TRUE, plot=list(labeladd="1")))

 ## plots is a list: the spm uses the variable names provided by 'nameY'.
 (out1 &lt;- smult(Xcont, trace=TRUE, plot=list(nameY=c("A", "B", "C"))))

 ## smult() with monitoring
 (out2 &lt;- smult(Xcont, monitoring=TRUE, trace=TRUE))
 names(out2)

 ##  Forgery Swiss banknotes examples.

 data(swissbanknotes)

 (out1 &lt;- smult(swissbanknotes[101:200,], plot=TRUE))

 (out1 &lt;- smult(swissbanknotes[101:200,], plot=list(labeladd="1")))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smult.object'>Description of <code>smult.object</code> Objects</h2><span id='topic+smult.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+smult.object">smult.object</a></code> holds information about 
the result of a call to <code><a href="#topic+smult">smult</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>loc</code></td>
<td>
<p>p-by-1  vector containing S estimate of location.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>p-by-p matrix containing robust estimate of the shape
matrix. Remark: det|shape|=1.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>robust estimate of the scale.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p><code>scale^2 * shape</code>: robust estimate of 
covariance matrix.</p>
</td></tr>
<tr><td><code>bs</code></td>
<td>
<p>a (p+1) vector containing the units forming best subset 
associated with S estimate of location.</p>
</td></tr>
<tr><td><code>md</code></td>
<td>
<p>n-by-1 vector containing the estimates of the robust 
Mahalanobis distances (in squared units). This vector contains 
the distances of each observation from the location of the data, 
relative to the scatter matrix cov.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>A vector containing the list of the units declared 
as outliers using confidence level specified in input scalar 
<code>conflev</code>.</p>
</td></tr>     
<tr><td><code>conflev</code></td>
<td>
<p>Confidence level that was used to declare outliers.</p>
</td></tr>
<tr><td><code>singsub</code></td>
<td>
<p>Number of subsets without full rank. Notice that 
<code>singsub &gt; 0.1*(number of subsamples)</code> produces a warning.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>n x 1 vector containing the estimates of the weights.</p>
</td></tr>     
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
</table>
<p>The object has class <code>"smult"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- smult(hbk[,1:3]))
    class(out)
    summary(out)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='smulteda.object'>Description of <code>smulteda.object</code> Objects</h2><span id='topic+smulteda.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+smulteda.object">smulteda.object</a></code> holds information about 
the result of a call to <code><a href="#topic+smult">smult</a></code> with <code>monitoring=TRUE</code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>Loc</code></td>
<td>
<p>length(bdp)-by-p  matrix containing S estimate of location for each value of <code>bdp</code>.</p>
</td></tr>
<tr><td><code>Shape</code></td>
<td>
<p>p-by-p-by-length(bdp) 3D array  containing robust estimate of the shape 
for each value of bdp. Remark: det|shape|=1.</p>
</td></tr>
<tr><td><code>Scale</code></td>
<td>
<p>length(bdp) vector containing robust estimate of the scale
for each value of bdp.</p>
</td></tr>
<tr><td><code>Cov</code></td>
<td>
<p>p-by-p-by-length(bdp) 3D array  containing robust estimate 
of covariance matrix for each value of <code>bdp</code>.
Note that <code>scale(i)^2 * shape[,,i]</code> = robust estimate of 
covariance matrix.</p>
</td></tr>
<tr><td><code>Bs</code></td>
<td>
<p>(p+1)-by-length(bdp) matrix containing the units forming best subset 
for each value of bdp.</p>
</td></tr>
<tr><td><code>MAL</code></td>
<td>
<p>n-by-length(bdp) matrix containing the estimates of the robust 
Mahalanobis distances (in squared units) for each value of bdp.</p>
</td></tr>
<tr><td><code>Outliers</code></td>
<td>
<p>n-by-length(bdp) matrix containing flags for the outliers. 
Boolean matrix containing the list of the 
units declared as outliers for each value of bdp using confidence 
level specified in input scalar <code>conflev</code></p>
</td></tr>     
<tr><td><code>Weights</code></td>
<td>
<p>n x length(bdp) matrix containing the weights for each 
value of bdp.</p>
</td></tr>     
<tr><td><code>conflev</code></td>
<td>
<p>Confidence level that was used to declare outliers.</p>
</td></tr>
<tr><td><code>singsub</code></td>
<td>
<p>Number of subsets without full rank. Notice that 
<code>singsub &gt; 0.1*(number of subsamples)</code> produces a warning.</p>
</td></tr>
<tr><td><code>bdp</code></td>
<td>
<p>vector which contains the values of bdp which have been used.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X.</p>
</td></tr>
</table>
<p>The object has class <code>"smulteda"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- smult(hbk[,1:3], monitoring=TRUE))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='spmplot'>Interactive scatterplot matrix</h2><span id='topic+spmplot'></span>

<h3>Description</h3>

<p>Produces an interactive scatterplot matrix with boxplots or histograms on the main
diagonal and possibly robust bivariate contours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spmplot(
  X,
  group,
  plot,
  variables,
  col,
  cex,
  pch,
  labeladd,
  label,
  legend,
  dispopt = c("hist", "box"),
  tag,
  datatooltip,
  databrush,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spmplot_+3A_x">X</code></td>
<td>
<p>data matrix (2D array) containing <code>n</code> observations on <code>p</code> variables
or an object of S3 class <code><a href="#topic+fsmeda.object">fsmeda.object</a></code> returned by
<code><a href="#topic+fsmult">fsmult</a></code> with <code>monitoring=TRUE</code> - a list containing
the monitoring of minimum Mahalanobis distance</p>
</td></tr>
<tr><td><code id="spmplot_+3A_group">group</code></td>
<td>
<p>grouping variable. Vector with <code>n</code> elements. Specifies
a grouping variable defined as a categorical variable (factor), numeric, or array of strings,
or string matrix, and it must have the same number of rows as <code>X</code>.
This grouping variable determines the marker and color assigned to each point.
Remark: if <code>group</code> is used to distinguish a set of outliers from
a set of good units, the id number for the outliers should be the larger
(see optional field <code>labeladd</code> of parameter <code>plot</code> for details).</p>
</td></tr>
<tr><td><code id="spmplot_+3A_plot">plot</code></td>
<td>
<p>controls the names which are displayed in the margins of the
scatter-plot matrix, the labels of the legend the colors and the symbols.
If <code>plot</code> is <em>empty</em> (<code>plot=FALSE</code> or <code>plot=0</code> or <code>plot=c()</code>
or <code>plot=NULL</code>) empty strings are displayed and no label and no name is added
to the plot. If <code>plot=TRUE</code> or <code>plot=1</code>, the names <code>Y1,..., Yp</code>
are added to the margins of the the scatter plot matrix else nothing is added.
If <code>plot</code> is a list, it is possible to control not only the names but also,
point labels, colors and symbols. More precisely list <code>plot</code> may contain the following elements:
</p>

<ol>
<li> <p><code>labeladd</code> - see parameter <code>labeladd</code>
</p>
</li>
<li> <p><code>nameY</code> - a character string containing the labels of
the variables. As default value, the labels which are
added are <code>Y1, ..., Yp</code>. See parameter <code>variables</code>.
</p>
</li>
<li> <p><code>clr</code> - see parameter <code>col</code>
</p>
</li>
<li> <p><code>sym</code> - see parameter <code>pch</code>
</p>
</li>
<li> <p><code>siz</code> - see parameter <code>cex</code>
</p>
</li>
<li> <p><code>doleg</code> - see parameter <code>legend</code>
</p>
</li>
<li> <p><code>label</code> - see parameter <code>label</code>
</p>
</li></ol>
</td></tr>
<tr><td><code id="spmplot_+3A_variables">variables</code></td>
<td>
<p>a character string with the names of the variables</p>
</td></tr>
<tr><td><code id="spmplot_+3A_col">col</code></td>
<td>
<p>color specification for the data point. Can be different for each group.
By default, the order of the colors is <em>blue</em>, <em>red</em>, <em>black</em>,
<em>magenta</em>, <em>green</em>, <em>cyan</em> and <em>yelow</em>.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_cex">cex</code></td>
<td>
<p>the size of the symbols used for plotting. By default <code>cex=1</code>
the symbol size depends on the number of plots and the size of the
figure window. Values larger than 1 will increase the size and
values smaller than 1 will decrease the size.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_pch">pch</code></td>
<td>
<p>specification of the symbols to use. For example, if
there are three groups, and <code>pch=c(1, 3, 4)</code>, the first group will be
plotted with a circle, the second with a plus, and the third with a 'x' (see <code>?pch</code> or <code>?points</code> for
a list of symbols. NOTE: not all symbols available in R can be mapped to the symbols in MATLAB.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_labeladd">labeladd</code></td>
<td>
<p>logical, controls wheather the elements belonging to the last group
in the scatterplot matrix are labelled with their unit row index
or their rowname. The rowname is taken from the parameter <code>label</code>
or if it is missing, from the sequence <code>1:n</code>. The default value is
<code>labeladd=FALSE</code>, i.e. no label is added.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_label">label</code></td>
<td>
<p>a character vector of length <code>n</code> (the number of rows in the data matrix)
containing the labels of the units. If this field is empty
the sequence <code>1:n</code> will be used to label the units.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_legend">legend</code></td>
<td>
<p>logical, controls where a legend is shown or not.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_dispopt">dispopt</code></td>
<td>
<p>controls how to fill the diagonals in the plot (main diagonal of
the scatter plot matrix). Set <code>dispopt='hist'</code> (default) to plot histograms,
or <code>dispopt='box'</code> to plot boxplots. The style which is used for univariate
boxplots is traditional, if the number of groups is less or equal 5, else it is
'compact' (plot boxes using a smaller box style designed for plots with many groups).</p>
</td></tr>
<tr><td><code id="spmplot_+3A_tag">tag</code></td>
<td>
<p>Plot handle. String which identifies the handle of the plot which is about to be created.
The default is <code>tag='pl_mmd'</code>. Notice that if the program finds a plot which has
a tag equal to the one specified by the user, then the output of the new plot overwrites
the existing one in the same window else a new window is created.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_datatooltip">datatooltip</code></td>
<td>
<p>If datatooltip is not empty the user can use the mouse in order to have
information about the unit selected, the step in which the unit enters the search and
the associated label. If datatooltip is a list, it is possible to control the aspect
of the data cursor (see MATLAB function <code>datacursormode()</code> for more details or
see the examples below). The default options are <code>DisplayStyle="Window"</code> and <code>SnapToDataVertex="on"</code>.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_databrush">databrush</code></td>
<td>
<p>Interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is TRUE or a list) enables the user to select
a set of trajectories in the current plot and to see them highlighted in the scatterplot matrix.
If the scatterplot matrix does not exist it is automatically created.
In addition, brushed units can be highlighted in the monitoring MD plot.
Note that the window
style of the other figures is set equal to that which contains the monitoring residual plot.
In other words, if the monitoring residual plot is docked all the other figures will be docked too.
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and it is
possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of
the MATLAB function <code>selectdataFS()</code> and the following optional arguments:
</p>

<ul>
<li> <p><code>persist</code>: This option can be an empty value or a character containing 'on' or 'off'.
The default value is <code>persist=""</code>, that is brushing is allowed only once.
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are
added to those previously brushed. It is possible, every time a new brushing is
done, to use a different color for the brushed units. If <code>persist='off'</code>
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>labeladd</code>: add labels of brushed units in the scatterplot matrix.
If this option is '1', we label the units of the last selected group with
the unit row index in the matrix X. The default value is labeladd=&rdquo;,
i.e. no label is added.
</p>
</li></ul>
</td></tr>
<tr><td><code id="spmplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="spmplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 ##  Call of spmplot() without optional parameters.
 ##  Iris data: scatter plot matrix with univariate boxplots on the main
 ##  diagonal.

 X &lt;- iris[,1:4]
 group &lt;- iris[,5]
 spmplot(X, group, variables=c('SL','SW','PL','PW'), dispopt="box")


 ##  Example of spmplot() called by routine fsmult().
 ##  Generate contaminated data.
     n &lt;- 200; p &lt;- 3
     X &lt;- matrix(rnorm(n*p), ncol=3)
     Xcont &lt;- X
     Xcont[1:5,] &lt;- Xcont[1:5,] + 3

 ##  spmplot is called automatically by all outlier detection methods, e.g. fsmult()
     out &lt;- fsmult(Xcont, plot=TRUE);

 ##  Now test the direct use of fsmult(). Set two groups, e.g. those obtained
 ##  from fsmult().

     group = rep(0, n)
     group[out$outliers] &lt;- 1
 ##  option 'labeladd' is used to label the outliers
 ##  By default, the legend identifies the groups with the identifiers
 ##  given in vector 'group'.
 ##  Set the colors for the two groups to blue and red.

     spmplot(Xcont, group, col=c("blue", "red"), labeladd=1, dispopt="box")
 
## End(Not run)

</code></pre>

<hr>
<h2 id='Sreg_control'>
Creates an <code>Sreg_control</code> object
</h2><span id='topic+Sreg_control'></span>

<h3>Description</h3>

<p>Creates an object of class <code>Sreg_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters for calling the MATLAB function <code>Sreg()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sreg_control(intercept = TRUE, bdp = 0.5, 
    rhofunc = c("bisquare", "optimal", "hyperbolic", "hampel", "mdpd", "AS"), 
    rhofuncparam, nsamp = 1000, refsteps = 3, reftol = 1e-06, 
    refstepsbestr = 50, reftolbestr = 1e-08, 
    minsctol = 1e-07, bestr = 5, 
    conflev, msg = TRUE, nocheck = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sreg_control_+3A_intercept">intercept</code></td>
<td>

<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_bdp">bdp</code></td>
<td>

<p>Breakdown point. It measures the fraction of outliers the algorithm 
should resist. In this case any value greater than 0 but smaller 
or equal than 0.5 will do fine. 
</p>
<p>Note that given bdp nominal efficiency is automatically determined.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_rhofunc">rhofunc</code></td>
<td>

<p>Specifies the rho function which must be used to weight 
the residuals. Possible values are 'bisquare' 'optimal' 'hyperbolic' 'hampel'.
</p>

<ol>
<li><p> 'bisquare' uses Tukey's rho and psi functions. See TBrho and TBpsi.
</p>
</li>
<li><p> 'optimal' uses optimal rho and psi functions. See OPTrho and OPTpsi.
</p>
</li>
<li><p> 'hyperbolic' uses hyperbolic rho and psi functions. See HYPrho and HYPpsi.
</p>
</li>
<li><p> 'hampel' uses Hampel rho and psi functions. See HArho and HApsi.
</p>
</li></ol>

<p>The default is 'bisquare'.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_rhofuncparam">rhofuncparam</code></td>
<td>

<p>Additional parameters for the specified rho function. 
For hyperbolic rho function it is possible to set up the 
value of k = sup CVC (the default value of k is 4.5).
</p>
<p>For Hampel rho function it is possible to define parameters 
a, b and c (the default values are a=2, b=4, c=8)
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_nsamp">nsamp</code></td>
<td>

<p>Number of subsamples which will be extracted to find the robust estimator, 
scalar. If <code>nsamp=0</code> all subsets will be extracted. They will be 
<code>(n choose p)</code>. If the number of all possible subset is <code>&lt;1000</code> 
the default is to extract all subsets otherwise just 1000.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_refsteps">refsteps</code></td>
<td>

<p>Number of refining iterations in each subsample (default is <code>refsteps=3</code>).
<code>refsteps = 0</code> means &quot;raw-subsampling&quot; without iterations.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_reftol">reftol</code></td>
<td>

<p>Tolerance for the refining steps. The default value is 1e-6
</p>
</td></tr>    
<tr><td><code id="Sreg_control_+3A_refstepsbestr">refstepsbestr</code></td>
<td>

<p>Scalar defining number of refining iterations for each best subset (default = 50).
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_reftolbestr">reftolbestr</code></td>
<td>

<p>Tolerance for the refining steps for each of the best subsets. The default value is <code>reftolbestr=1e-8</code>.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_minsctol">minsctol</code></td>
<td>

<p>Value of tolerance for the iterative procedure for finding the minimum 
value of the scale for each subset and each of the best subsets 
(It is used by subroutine <code>minscale.m</code>).
The default value is <code>minsctol=1e-7</code>.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_bestr">bestr</code></td>
<td>

<p>Defins the number of &quot;best betas&quot; to remember from the subsamples. 
These will be later iterated until convergence (default is <code>bestr=5</code>).
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_conflev">conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Usually conflev=0.95, 0.975, 0.99 (individual alpha) or 
conflev=1-0.05/n, 1-0.025/n, 1-0.01/n (simultaneous alpha). 
Default value is 0.975
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_msg">msg</code></td>
<td>

<p>Controls whether to display or not messages on the screen If <code>msg==1</code> (default) 
messages are displayed on the screen about step in which signal took place else 
no message is displayed on the screen.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_nocheck">nocheck</code></td>
<td>

<p>Check input arguments, scalar. If <code>nocheck=TRUE</code> no check is performed 
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code> 
are left unchanged. In other words the additional column of ones for the 
intercept is not added. As default <code>nocheck=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="Sreg_control_+3A_plot">plot</code></td>
<td>

<p>Plot on the screen. Scalar. If <code>plots=TRUE</code> the plot of minimum deletion 
residual with envelopes based on n observations and the scatterplot matrix with 
the outliers highlighted is produced. If <code>plots=2</code> the user can also monitor 
the intermediate plots based on envelope superimposition. 
If <code>plots=FALSE</code> (default) no plot is produced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an object of class <code>Sreg_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>"Sreg_control"</code> which is basically a
<code><a href="base.html#topic+list">list</a></code> with components the input arguments of 
the function mapped accordingly to the corresponding Matlab function. 
</p>


<h3>Author(s)</h3>

<p>FSDA team
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+FSR_control">FSR_control</a></code>, <code><a href="#topic+MMreg_control">MMreg_control</a></code> and <code><a href="#topic+LXS_control">LXS_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="S", control=Sreg_control(bdp=0.25, nsamp=500)))

## End(Not run)
</code></pre>

<hr>
<h2 id='sreg.object'>Description of sreg Objects</h2><span id='topic+sreg.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+sreg.object">sreg.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsreg">fsreg</a></code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>p-by-1 vector containing the estimated regression parameters (in step n-k).</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>scalar containing the estimate of the scale (sigma).</p>
</td></tr>
<tr><td><code>bs</code></td>
<td>
<p>p x 1 vector containing the units forming best subset associated with S estimate of regression coefficient.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>fittedvalues</code></td>
<td>
<p>fitted values.</p>
</td></tr>
<tr><td><code>outliers</code></td>
<td>
<p>kx1 vector containing the list of the k units declared as outliers or NULL if the sample is homogeneous.</p>
</td></tr>
<tr><td><code>conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Usually <code>conflev=0.95, 0.975, 0.99</code> (individual alpha) or 
<code>conflev=1-0.05/n, 1-0.025/n, 1-0.01/n</code> (simultaneous alpha). 
Default value is 0.975</p>
</td></tr>
<tr><td><code>singsub</code></td>
<td>
<p>Number of subsets wihtout full rank. Notice that 
<code>singsub &gt; 0.1*(number of subsamples)</code> produces a warning</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>n x 1 vector containing the estimates of the weights</p>
</td></tr>
<tr><td><code>rhofunc</code></td>
<td>
<p>Specifies the rho function which has been used to weight 
the residuals. </p>
</td></tr>
<tr><td><code>rhofuncparam</code></td>
<td>
<p>Vector which contains the additional parameters for the specified 
rho function which has been used. For hyperbolic rho function the value of k =sup CVC. 
For Hampel rho function the parameters a, b and c. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector y</p>
</td></tr>
</table>
<p>The object has class <code>"sreg"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="S"))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='Sregeda_control'>
Creates an <code>Sregeda_control</code> object
</h2><span id='topic+Sregeda_control'></span>

<h3>Description</h3>

<p>Creates an object of class <code>Sregeda_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sregeda_control(intercept = TRUE, bdp = seq(0.5, 0.01, -0.01), 
    rhofunc = c("bisquare", "optimal", "hyperbolic", "hampel", "mdpd", "AS"), 
    rhofuncparam, nsamp = 1000, refsteps = 3, reftol = 1e-06, 
    refstepsbestr = 50, reftolbestr = 1e-08, 
    minsctol = 1e-07, bestr = 5, 
    conflev, msg = TRUE, nocheck = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sregeda_control_+3A_intercept">intercept</code></td>
<td>

<p>Indicator for constant term. Scalar. If <code>intercept=TRUE</code>, 
a model with constant term will be fitted (default), else, 
no constant term will be included.
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_bdp">bdp</code></td>
<td>

<p>Breakdown point. It measures the fraction of outliers the algorithm 
should resist. In this case any value greater than 0 but smaller 
or equal than 0.5 will do fine. 
</p>
<p>The default value of bdp is a sequence from 0.5 to 0.01 with step 0.01    
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_rhofunc">rhofunc</code></td>
<td>

<p>Specifies the rho function which must be used to weight 
the residuals. Possible values are 'bisquare' 'optimal' 'hyperbolic' 'hampel'.
</p>

<ol>
<li><p> 'bisquare' uses Tukey's rho and psi functions. See TBrho and TBpsi.
</p>
</li>
<li><p> 'optimal' uses optimal rho and psi functions. See OPTrho and OPTpsi.
</p>
</li>
<li><p> 'hyperbolic' uses hyperbolic rho and psi functions. See HYPrho and HYPpsi.
</p>
</li>
<li><p> 'hampel' uses Hampel rho and psi functions. See HArho and HApsi.
</p>
</li></ol>

<p>The default is 'bisquare'.
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_rhofuncparam">rhofuncparam</code></td>
<td>

<p>Additional parameters for the specified rho function. 
For hyperbolic rho function it is possible to set up the 
value of k = sup CVC (the default value of k is 4.5).
</p>
<p>For Hampel rho function it is possible to define parameters 
a, b and c (the default values are a=2, b=4, c=8)
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_nsamp">nsamp</code></td>
<td>

<p>Number of subsamples which will be extracted to find the robust estimator, 
scalar. If <code>nsamp=0</code> all subsets will be extracted. They will be 
<code>(n choose p)</code>. If the number of all possible subset is <code>&lt;1000</code> 
the default is to extract all subsets otherwise just 1000.
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_refsteps">refsteps</code></td>
<td>

<p>Number of refining iterations in each subsample (default is <code>refsteps=3</code>).
<code>refsteps = 0</code> means &quot;raw-subsampling&quot; without iterations.
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_reftol">reftol</code></td>
<td>

<p>Tolerance for the refining steps. The default value is 1e-6
</p>
</td></tr>    
<tr><td><code id="Sregeda_control_+3A_refstepsbestr">refstepsbestr</code></td>
<td>

<p>Scalar defining number of refining iterations for each best subset (default = 50).
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_reftolbestr">reftolbestr</code></td>
<td>

<p>Tolerance for the refining steps for each of the best subsets. The default value is <code>reftolbestr=1e-8</code>.
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_minsctol">minsctol</code></td>
<td>

<p>Value of tolerance for the iterative procedure for finding the minimum 
value of the scale for each subset and each of the best subsets 
(It is used by subroutine <code>minscale.m</code>).
The default value is <code>minsctol=1e-7</code>.
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_bestr">bestr</code></td>
<td>

<p>Defins the number of &quot;best betas&quot; to remember from the subsamples. 
These will be later iterated until convergence (default is <code>bestr=5</code>).
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_conflev">conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Usually conflev=0.95, 0.975, 0.99 (individual alpha) or 
conflev=1-0.05/n, 1-0.025/n, 1-0.01/n (simultaneous alpha). 
Default value is 0.975
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_msg">msg</code></td>
<td>

<p>Controls whether to display or not messages on the screen If <code>msg==1</code> (default) 
messages are displayed on the screen about step in which signal took place else 
no message is displayed on the screen.
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_nocheck">nocheck</code></td>
<td>

<p>Check input arguments, scalar. If <code>nocheck=TRUE</code> no check is performed 
on matrix <code>y</code> and matrix <code>X</code>. Notice that <code>y</code> and <code>X</code> 
are left unchanged. In other words the additional column of ones for the 
intercept is not added. As default <code>nocheck=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="Sregeda_control_+3A_plot">plot</code></td>
<td>

<p>Plot on the screen. Scalar. If <code>plots=TRUE</code> the plot of minimum deletion 
residual with envelopes based on n observations and the scatterplot matrix with 
the outliers highlighted is produced. If <code>plots=2</code> the user can also monitor 
the intermediate plots based on envelope superimposition. 
If <code>plots=FALSE</code> (default) no plot is produced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an object of class <code>Sregeda_control</code> to be used with the <code>fsreg()</code> function,
containing various control parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>"Sregeda_control"</code> which is basically a
<code><a href="base.html#topic+list">list</a></code> with components the input arguments of 
the function mapped accordingly to the corresponding Matlab function. 
</p>


<h3>Author(s)</h3>

<p>FSDA team</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+FSR_control">FSR_control</a></code>, <code><a href="#topic+MMreg_control">MMreg_control</a></code> and <code><a href="#topic+LXS_control">LXS_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(hbk, package="robustbase")
(out &lt;- fsreg(Y~., data=hbk, method="S", monitoring=TRUE, 
    control=Sregeda_control(nsamp=500, rhofunc='hyperbolic')))

## End(Not run)
</code></pre>

<hr>
<h2 id='sregeda.object'>Description of <code>sregeda</code> Objects</h2><span id='topic+sregeda.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+sregeda.object">sregeda.object</a></code> holds information about 
the result of a call to <code><a href="#topic+fsreg">fsreg</a></code> when <code>method="S"</code> and 
<code>monitoring=TRUE</code>.
</p>


<h3>Value</h3>

<p>The object itself is basically a <code><a href="base.html#topic+list">list</a></code> with the following 
components: 
</p>
<table>
<tr><td><code>Beta</code></td>
<td>
<p>matrix containing the S estimator of regression coefficients for each value of bdp.</p>
</td></tr>
<tr><td><code>Scale</code></td>
<td>
<p>vector containing the estimate of the scale (sigma) for each value of bdp. This is the value of the objective function.</p>
</td></tr>
<tr><td><code>BS</code></td>
<td>
<p>p x 1 vector containing the units forming best subset associated with S estimate of regression coefficient.</p>
</td></tr>
<tr><td><code>RES</code></td>
<td>
<p>n x length(bdp) matrix containing the monitoring 
of scaled residuals for each value of <code>bdp</code>.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>n x length(bdp) matrix containing the estimates of the weights for each value of bdp</p>
</td></tr>
<tr><td><code>Outliers</code></td>
<td>
<p>Boolean matrix containing the list of the units declared as outliers for each value of bdp using confidence level specified in input scalar conflev.</p>
</td></tr>
<tr><td><code>conflev</code></td>
<td>
<p>Confidence level which is used to declare units as outliers. 
Remark: conflev will be used to draw the horizontal line (confidence band) in the plot.</p>
</td></tr>
<tr><td><code>Singsub</code></td>
<td>
<p>Number of subsets wihtout full rank. 
Notice that singsub[bdp[jj]] &gt; 0.1*(number of subsamples) produces a warning</p>
</td></tr>
<tr><td><code>rhofunc</code></td>
<td>
<p>Specifies the rho function which has been used to weight 
the residuals. </p>
</td></tr>
<tr><td><code>rhofuncparam</code></td>
<td>
<p>Vector which contains the additional parameters for the specified 
rho function which has been used. For hyperbolic rho function the value of k =sup CVC. 
For Hampel rho function the parameters a, b and c. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the data matrix X</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector y</p>
</td></tr>
</table>
<p>The object has class <code>"sregeda"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(hbk, package="robustbase")
    (out &lt;- fsreg(Y~., data=hbk, method="S", monitoring=TRUE))
    class(out)
    summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.fsdalms'>Summary Method for <code>fsdalms</code> objects</h2><span id='topic+summary.fsdalms'></span><span id='topic+print.summary.fsdalms'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> method for class <code>"fsdalms"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsdalms'
summary(object, correlation = FALSE, ...)
## S3 method for class 'summary.fsdalms'
print(x, digits = max(3, getOption("digits") - 3),
     signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fsdalms_+3A_object">object</code>, <code id="summary.fsdalms_+3A_x">x</code></td>
<td>
<p>an object of class <code>"fsdalms"</code> (or <code>"summary.fsdalms"</code>);
usually, a result of a call to <code><a href="#topic+fsreg">fsreg</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fsdalms_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.fsdalms_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.fsdalms_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical indicating if &ldquo;significance stars&rdquo;
should be printer, see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fsdalms_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.fsdalms()</code>, the S3 method, simply returns an (S3) object of class <code>"<a href="#topic+summary.fsdalms">summary.fsdalms</a>"</code>
for which there's a <code><a href="base.html#topic+print">print</a></code> method:
</p>
<p><code>print.summary.fsdalms</code> prints summary statistics for the forward search (FS) regression estimates.
While the function <code><a href="#topic+print.fsdalms">print.fsdalms</a></code> prints only the robust estimates
of the coefficients, <code>print.summary.fsdalms</code> will print also the regression table.
</p>


<h3>Value</h3>

<p><code>summary.fsdalms</code> returns an <code>summary.fsdalms</code> object, whereas the
<code>print</code> methods returns its first argument via
<code><a href="base.html#topic+invisible">invisible</a></code>, as all <code>print</code> methods do.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fsreg">fsreg</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

    data(Animals, package = "MASS")
    brain &lt;- Animals[c(1:24, 26:25, 27:28),]
    lbrain &lt;- log(brain)
    (fs &lt;- fsreg(brain~body, data=lbrain, method="LTS"))
    summary(fs)

    ## compare to the result of ltsReg() from 'robustbase'
    library(robustbase)
    (lts &lt;- ltsReg(brain~body, data=lbrain))
    summary(lts)

## End(Not run)    
</code></pre>

<hr>
<h2 id='summary.fsdalts'>Summary Method for <code>fsdalts</code> objects</h2><span id='topic+summary.fsdalts'></span><span id='topic+print.summary.fsdalts'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> method for class <code>"fsdalts"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsdalts'
summary(object, correlation = FALSE, ...)
## S3 method for class 'summary.fsdalts'
print(x, digits = max(3, getOption("digits") - 3),
     signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fsdalts_+3A_object">object</code>, <code id="summary.fsdalts_+3A_x">x</code></td>
<td>
<p>an object of class <code>"fsdalts"</code> (or <code>"summary.fsdalts"</code>);
usually, a result of a call to <code><a href="#topic+fsreg">fsreg</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fsdalts_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.fsdalts_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.fsdalts_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical indicating if &ldquo;significance stars&rdquo;
should be printer, see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fsdalts_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.fsdalts()</code>, the S3 method, simply returns an (S3) object of class <code>"<a href="#topic+summary.fsdalts">summary.fsdalts</a>"</code>
for which there's a <code><a href="base.html#topic+print">print</a></code> method:
</p>
<p><code>print.summary.fsdalts</code> prints summary statistics for the forward search (FS) regression estimates.
While the function <code><a href="#topic+print.fsdalts">print.fsdalts</a></code> prints only the robust estimates
of the coefficients, <code>print.summary.fsdalts</code> will print also the regression table.
</p>


<h3>Value</h3>

<p><code>summary.fsdalts</code> returns an <code>summary.fsdalts</code> object, whereas the
<code>print</code> methods returns its first argument via
<code><a href="base.html#topic+invisible">invisible</a></code>, as all <code>print</code> methods do.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fsreg">fsreg</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

    data(Animals, package = "MASS")
    brain &lt;- Animals[c(1:24, 26:25, 27:28),]
    lbrain &lt;- log(brain)
    (fs &lt;- fsreg(brain~body, data=lbrain, method="LTS"))
    summary(fs)

    ## compare to the result of ltsReg() from 'robustbase'
    library(robustbase)
    (lts &lt;- ltsReg(brain~body, data=lbrain))
    summary(lts)

## End(Not run)    
</code></pre>

<hr>
<h2 id='summary.fsr'>Summary Method for FSR objects</h2><span id='topic+summary.fsr'></span><span id='topic+print.summary.fsr'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> method for class <code>"fsr"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsr'
summary(object, correlation = FALSE, ...)
## S3 method for class 'summary.fsr'
print(x, digits = max(3, getOption("digits") - 3),
     signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fsr_+3A_object">object</code>, <code id="summary.fsr_+3A_x">x</code></td>
<td>
<p>an object of class <code>"fsr"</code> (or <code>"summary.fsr"</code>);
usually, a result of a call to <code><a href="#topic+fsreg">fsreg</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fsr_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.fsr_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.fsr_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical indicating if &ldquo;significance stars&rdquo;
should be printer, see <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.fsr()</code>, the S3 method, simply returns an (S3) object of class <code>"<a href="#topic+summary.fsr">summary.fsr</a>"</code>
for which there's a <code><a href="base.html#topic+print">print</a></code> method:
</p>
<p><code>print.summary.fsr</code> prints summary statistics for the forward search (FS) regression estimates.
While the function <code><a href="#topic+print.fsr">print.fsr</a></code> prints only the robust estimates
of the coefficients, <code>print.summary.fsr</code> will print also the regression table.
</p>


<h3>Value</h3>

<p><code>summary.fsr</code> returns an <code>summary.fsr</code> object, whereas the
<code>print</code> methods returns its first argument via
<code><a href="base.html#topic+invisible">invisible</a></code>, as all <code>print</code> methods do.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fsreg">fsreg</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

    data(Animals, package = "MASS")
    brain &lt;- Animals[c(1:24, 26:25, 27:28),]
    lbrain &lt;- log(brain)
    (fs &lt;- fsreg(brain~body, data=lbrain, method="FS"))
    summary(fs)

## End(Not run)
</code></pre>

<hr>
<h2 id='swissbanknotes'>
Swiss banknote data
</h2><span id='topic+swissbanknotes'></span>

<h3>Description</h3>

<p>Six variables measured on 100 genuine and 100 counterfeit 
old (printed before the second world war) Swiss 1000-franc bank notes 
(Flury and Riedwyl, 1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swissbanknotes)</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 7 variables.
</p>

<dl>
<dt><code>length</code></dt><dd><p>Length of bill, mm</p>
</dd>
<dt><code>left</code></dt><dd><p>Width of left edge, mm</p>
</dd>
<dt><code>right</code></dt><dd><p>Width of right edge, mm</p>
</dd>
<dt><code>bottom</code></dt><dd><p>Bottom margin width, mm</p>
</dd>
<dt><code>top</code></dt><dd><p>Top margin width, mm</p>
</dd>
<dt><code>diagonal</code></dt><dd><p>Length of image diagonal, mm</p>
</dd>
<dt><code>class</code></dt><dd><p>1 = genuine, 2 = counterfeit</p>
</dd>
</dl>



<h3>Source</h3>

<p>Flury, B. and Riedwyl, H. (1988). <em>Multivariate Statistics: A practical approach.</em> London: Chapman &amp; Hall.
</p>


<h3>References</h3>

<p>Weisberg, S. (2005).  <em>Applied Linear Regression</em>, 3rd edition. New York: Wiley, Problem 12.5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rrcov)
data(swissbanknotes)
head(swissbanknotes)
plot(CovMcd(swissbanknotes[, 1:6]), which="pairs", col=swissbanknotes$class)
</code></pre>

<hr>
<h2 id='swissheads'>
Swiss heads data
</h2><span id='topic+swissheads'></span>

<h3>Description</h3>

<p>Six dimensions in millimetres of the heads of 200 twenty year old Swiss soldiers (Flury and Riedwyl, 
1988, p. 218 and also Flury, 1997, p. 6).
</p>
<p>The data were collected to determine the variability in size and shape
of heads of young men in order to help in the design of a new protection
mask for the Swiss army.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swissheads)</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 6 variables.
</p>

<dl>
<dt><code>minimal_frontal_breadth</code></dt><dd><p>Minimal frontal breadth, mm</p>
</dd>
<dt><code>breadth_angulus_mandibulae</code></dt><dd><p>Breadth of angulus mandibulae, mm</p>
</dd>
<dt><code>true_facial_height</code></dt><dd><p>True facial height, mm</p>
</dd>
<dt><code>length_glabella_nasi</code></dt><dd><p>Length from glabella to apex nasi, mm</p>
</dd>
<dt><code>length_tragion_nasion</code></dt><dd><p>Length from tragion to nasion, mm</p>
</dd>
<dt><code>length_tragion_gnathion</code></dt><dd><p>Length from tragion to gnathion, mm</p>
</dd>
</dl>



<h3>Source</h3>

<p>Flury, B. and Riedwyl, H. (1988). <em>Multivariate Statistics: A practical approach.</em> London: Chapman &amp; Hall.
</p>


<h3>References</h3>

<p>Atkinson, A. C., Riani, M. and Cerioli, A. (2004) <em>Exploring multivariate data with the forward search</em>, New York: Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rrcov)
data(swissheads)
head(swissheads)
plot(CovMcd(swissheads), which="pairs")
</code></pre>

<hr>
<h2 id='tclusteda.object'>Objects returned by the function <code><a href="#topic+tclustfsda">tclustfsda</a></code> with the option <code>monitoring=TRUE</code></h2><span id='topic+tclusteda.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+tclusteda.object">tclusteda.object</a></code> holds information about
the result of a call to <code><a href="#topic+tclustfsda">tclustfsda</a></code> with the option <code>monitoring=TRUE</code>.
</p>


<h3>Value</h3>

<p>The functions <code>print()</code> and <code>summary()</code> are used to obtain and print a
summary of the results. An object of class <code>tclusteda</code> is a list containing at least the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>trimming level</p>
</td></tr>
<tr><td><code>restrfactor</code></td>
<td>
<p>restriction factor</p>
</td></tr>
<tr><td><code>IDX</code></td>
<td>
<p>an <code>n-by-length(alpha)</code> vector containing assignment of each unit to each of the <code>k</code>
groups. Cluster names are integer numbers from 1 to k.
0 indicates trimmed observations. The first column refers to <code>alpha[1]</code>, the second column
refers to <code>alpha[2]</code>, ..., the last column refers to <code>alpha[length(alpha)]</code>.</p>
</td></tr>
<tr><td><code>MU</code></td>
<td>
<p>a 3 dimensional array of size k-by-p-by-length(alpha) containing the monitoring
of the centroid for each value of alpha. <code>MU[,,1]</code>, refers to <code>alpha[1]</code> ...,
<code>MU(,,length(alpha)]</code> refers to <code>alpha[length(alpha)]</code>.
The first row in each slice refers to group 1, second row refers to group 2, etc.</p>
</td></tr>
<tr><td><code>SIGMA</code></td>
<td>
<p> A list of length <code>length(alpha)</code> containing in element <code>j</code>,
with <code>j=1, 2, ..., length(alpha)</code>, the 3D array of size p-by-p-by-k containing
the <code>k</code> (constrained) estimated covariance matrices associated with <code>alpha[j]</code>. </p>
</td></tr>
<tr><td><code>Amon</code></td>
<td>
<p>Amon stands for alpha monitoring. Matrix of size <code>(length(alpha)-1)-by-4</code> which
contains for two consecutive values of alpha the monitoring of three quantities
(change in classification, change in centroid location, change in covariance location).
</p>

<ul>
<li><p> 1st col = value of alpha.
</p>
</li>
<li><p> 2nd col = ARI index.
</p>
</li>
<li><p> 3rd col = squared Euclidean distance between centroids.
</p>
</li>
<li><p> 4th col = squared Euclidean distance between covariance matrices.
</p>
</li></ul>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 data(hbk, package="robustbase")
 (out &lt;- tclustfsda(hbk[, 1:3], k=2, monitoring=TRUE))
 class(out)
 summary(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclustfsda'>Computes trimmed clustering with scatter restrictions</h2><span id='topic+tclustfsda'></span>

<h3>Description</h3>

<p>Partitions the points in the n-by-v data matrix
<code>Y</code> into <code>k</code> clusters. This partition minimizes the trimmed sum,
over all clusters, of the within-cluster sums of point-to-cluster-centroid
distances. Rows of Y correspond to points, columns correspond to variables.
Returns in the output object of class <code><a href="#topic+tclustfsda.object">tclustfsda.object</a></code> an n-by-1 vector
<code>idx</code> containing the cluster indices of each point. By default,
<code>tclustfsda()</code> uses (squared), possibly constrained, Mahalanobis distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclustfsda(
  x,
  k,
  alpha,
  restrfactor = 12,
  monitoring = FALSE,
  plot = FALSE,
  nsamp,
  refsteps = 15,
  reftol = 1e-13,
  equalweights = FALSE,
  mixt = 0,
  msg = FALSE,
  nocheck = FALSE,
  startv1 = 1,
  RandNumbForNini,
  restrtype = c("eigen", "deter"),
  UnitsSameGroup,
  numpool,
  cleanpool,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tclustfsda_+3A_x">x</code></td>
<td>
<p>An n x p data matrix (n observations and p variables).
Rows of x represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_k">k</code></td>
<td>
<p>Number of groups.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_alpha">alpha</code></td>
<td>
<p>A scalar between 0 and 0.5 or an integer specifying the number of
observations which have to be trimmed. If <code>alpha=0</code>, <code>tclust</code> reduces to
traditional model based or mixture clustering (mclust): see for example the
Matlab function <code>gmdistribution</code>.
</p>
<p>More in detail, if <code>0 &lt; alpha &lt; 1</code> clustering is based on <code>h = floor(n * (1-alpha))</code>
observations, else if alpha is an integer greater than 1 clustering is based on <code>h = n - floor(alpha)</code>.
If <code>monitoring=TRUE</code>, <code>alpha</code> is a vector which specifies the values of
trimming levels which have to be considered - contains decresing elements which
lie in the interval 0 and 0.5.
For example if <code>alpha=c(0.1, 0.05, 0)</code>, <code>tclust()</code> considers these 3 values of trimming level.
The default for alpha is vector <code>alpha=c(0.1, 0.05, 0)</code>. The sequence is
forced to be monotonically decreasing.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_restrfactor">restrfactor</code></td>
<td>
<p>Positive scalar which constrains the allowed differences among group scatters.
Larger values imply larger differences of group scatters. On the other hand
a value of 1 specifies the strongest restriction forcing all
eigenvalues/determinants to be equal and so the method looks
for similarly scattered (respectively spherical) clusters.
The default is to apply <code>restrfactor</code> to eigenvalues. In order to
apply <code>restrfactor</code> to determinants it is necessary to use the
optional input argument <code>restrtype</code>.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_monitoring">monitoring</code></td>
<td>
<p>If <code>monitoring=TRUE</code> TCLUST is performed for a series of values
of the trimming factor <code>alpha</code> given <code>k</code> (number of groups) and given
<code>c</code> (restriction factor).</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_plot">plot</code></td>
<td>
<p>If <code>plot=FALSE</code> (default) or <code>plot=0</code>  no plot is produced.
If <code>plot=TRUE</code> and <code>monitoring=FALSE</code> a plot with the classification
is shown (using the spmplot function). The plot can be:
</p>

<ul>
<li><p> for <code>p = 1</code>, a histogram of the univariate data,
</p>
</li>
<li><p> for <code>p = 2</code>, a bivariate scatterplot,
</p>
</li>
<li><p> for <code>p &gt; 2</code>, a scatterplot matrix generated by the MATLAB function <code>spmplot()</code>.
</p>
</li></ul>

<p>When <code>p &gt;= 2</code> the following additional features are offered
(for <code>p = 1</code> the behaviour is forced to be as for <code>plots=TRUE</code>):
</p>

<ul>
<li> <p><code>plot = 'contourf'</code> adds in the background of the bivariate scatterplots a
filled contour plot. The colormap of the filled contour is based on grey levels as default.
This argument may also be inserted in a field named 'type' of a list. In the latter case
it is possible to specify the additional field 'cmap', which changes the default colors
of the color map used. The field 'cmap' may be a three-column matrix of values in the
range [0,1] where each row is an RGB triplet that defines one color. Check the colormap
function for additional informations.
</p>
</li>
<li> <p><code>plot = 'contour'</code> adds in the background of the bivariate scatterplots a contour plot.
The colormap of the contour is based on grey levels as default. This argument may also be
inserted in a field named <code>type</code> of a list. In the latter case it is possible to specify
the additional field <code>cmap</code>, which changes the default colors of the color map used. The field
<code>cmap</code> may be a three-column matrix of values in the range [0,1] where each row is an RGB
triplet that defines one color. Check the <code>colormap()</code> (MATLAB) function for additional information.
</p>
</li>
<li> <p><code>plot = 'ellipse'</code> superimposes confidence ellipses to each group in the bivariate
scatterplots. The size of the ellipse is <code>qchisq(0.95, 2)</code>, i.e. the confidence level used
by default is 95 percent. This argument may also be inserted in a field named <code>type</code> of
a list. In the latter case it is possible to specify the additional field <code>conflev</code>,
which specifies the confidence level to use and it is a value between 0 and 1.
</p>
</li>
<li> <p><code>plot = 'boxplotb'</code> superimposes on the bivariate scatterplots the bivariate boxplots
for each group, using the boxplotb function. This argument may also be inserted in a field
named <code>type</code> of a list.
</p>
</li></ul>

<p>The parameter <code>plot</code> can be also a list and in this case its elements are:
</p>

<ul>
<li> <p><code>type</code> - specifies the type of plot as when plot option is a character.
Therefore, plots$type can be one of 'contourf', 'contour', 'ellipse' or 'boxplotb'.
</p>
</li>
<li> <p><code>cmap</code> - used to set a colormap for the plot type (MATLAB style). For example, plot$cmap = 'autumn'.
See the MATLAB help of colormap for a list of colormap possiblilites.
</p>
</li>
<li> <p><code>conflev</code> - this is the confidence level for the confidence ellipses.
It must me a scalar between 0 and 1.
</p>
</li></ul>

<p>If <code>plot=TRUE</code> and <code>monitoring=TRUE</code> two plots are shown.
The first plot (<em>monitor plot</em>) shows three panels with the monitoring between two
consecutive values of alpha: (i) the change in classification using ARI index (top panel),
(ii) the change in centroids using squared euclidean distances (central panel) and
(iii) the change in covariance matrices using squared euclidean distance (bottom panel).
</p>
<p>The second plot (<em>gscatter plot</em>) shows a series of subplots which monitor the classification
for each value of <code>alpha</code>. In order to make sure that consistent labels are used for the
groups, between two consecutive values of <code>alpha</code>, we assign label <code>r</code> to a group if
this group shows the smallest distance with group <code>r</code> for the previous value of <code>alpha</code>.
The type of plot which is used to monitor the stability of the classification depends on the
data dimensionality <code>p</code>.
</p>

<ul>
<li><p> for <code>p = 1</code>, a histogram of the univariate data (the MATLAB function <code>histFS()</code> is called),
</p>
</li>
<li><p> for <code>p = 2</code>, a bivariate scatterplot (the MATLAB function <code>gscatter()</code> is called),
</p>
</li>
<li><p> for <code>p &gt; 2</code>, a scatterplot of the first two principal components (function <code>gscatter()</code>
is called and we show on the axes titles the percentage of variance explained by the first
two principal components).
</p>
</li></ul>

<p>Also in the case of <code>monitoring=TRUE</code> the parameter <code>plot</code> can be a list and its elements are:
</p>

<ul>
<li><p> name:  character vector which enables to specify which plot to display.
<code>name = "gscatter"</code> produces a figure with a series of subplots which show the
classification for each value of <code>alpha</code>. <code>name = "monitor"</code> shows a figure
with three panels which monitor between two consecutive values of alpha the change in
classification using ARI index (top panel), the change in centroids using squared
euclidean distances (central panel), the change in covariance matrices using squared
euclidean distance (bottom panel). If this field is not specified, by default
<code>name=c("gscatter", "monitor")</code> and both figures will be shown.
</p>
</li>
<li><p> alphasel: a numeric vector which specifies for which values of alpha it
is possible to see the classification. For example if <code>alphasel = c(0.05, 0.02)</code>,
the classification will be shown just for <code>alpha=0.05</code> and <code>alpha=0.02</code>.
If this field is not specified <code>alphasel=alpha</code> and therefore the classification
is shown for each value of alpha.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tclustfsda_+3A_nsamp">nsamp</code></td>
<td>
<p>If a scalar, it contains the number of subsamples which will be extracted.
If <code>nsamp = 0</code> all subsets will be extracted. Remark - if the number of all possible
subset is greater than 300 the default is to extract all subsets, otherwise just 300.
If <code>nsamp</code> is a matrix it contains in the rows the indexes of the subsets which
have to be extracted. <code>nsamp</code> in this case can be conveniently generated by
function <code>subsets()</code>. <code>nsamp</code> can have <code>k</code> columns or <code>k * (p + 1)</code>
columns. If <code>nsamp</code> has <code>k</code> columns the <code>k</code> initial centroids each
iteration i are given by <code>X[nsamp[i,] ,]</code> and the covariance matrices are equal
to the identity.
</p>
<p>If <code>nsamp</code> has <code>k * (p + 1)</code> columns, the initial centroids and covariance
matrices in iteration <code>i</code> are computed as follows:
</p>

<ul>
<li><p> X1 &lt;- X[nsamp[i ,] ,]
</p>
</li>
<li><p> mean(X1[1:p + 1, ]) contains the initial centroid for group 1
</p>
</li>
<li><p> cov(X1[1:p + 1, ]) contains the initial cov matrix for group 1
</p>
</li>
<li><p> mean(X1[(p + 2):(2*p + 2), ]) contains the initial centroid for group 2
</p>
</li>
<li><p> cov(X1[(p + 2):(2*p + 2), ]) contains the initial cov matrix for group 2
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> mean(X1[(k-1)*p+1):(k*(p+1), ]) contains the initial centroids for group k
</p>
</li>
<li><p> cov(X1[(k-1)*p+1):(k*(p+1), ]) contains the initial cov matrix for group k.
</p>
</li></ul>

<p>REMARK: If <code>nsamp</code> is not a scalar, the option <code>startv1</code> given below is ignored.
More precisely, if <code>nsamp</code> has <code>k</code> columns <code>startv1 = 0</code> else if
<code>nsamp</code> has <code>k*(p+1)</code> columns option <code>startv1=1</code>.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_refsteps">refsteps</code></td>
<td>
<p>Number of refining iterations in each subsample. Default is <code>refsteps=15</code>.
<code>refsteps = 0</code> means &quot;raw-subsampling&quot; without iterations.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_reftol">reftol</code></td>
<td>
<p>Tolerance of the refining steps. The default value is 1e-14</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_equalweights">equalweights</code></td>
<td>
<p>A logical specifying wheather cluster weights in the concentration
and assignment steps shall be considered. If <code>equalweights=TRUE</code> we are (ideally)
assuming equally sized groups, else if <code>equalweights = false</code> (default) we allow for
different group weights. Please, check in the given references which functions
are maximized in both cases.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_mixt">mixt</code></td>
<td>
<p>Specifies whether mixture modelling or crisp assignment approach to model
based clustering must be used. In the case of mixture modelling parameter mixt also
controls which is the criterion to find the untrimmed units in each step of the maximization.
If <code>mixt &gt;=1</code> mixture modelling is assumed else crisp assignment.
The default value is <code>mixt=0</code>, i.e. crisp assignment. Please see
for details the provided references.
The parameter <code>mixt</code> also controls the criterion to select the units to trim.
If <code>mixt = 2</code> the <code>h</code> units are those which give the largest contribution
to the likelihood, else if <code>mixt=1</code> the criterion to select the <code>h</code> units is
exactly the same as the one which is used in crisp assignment.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_msg">msg</code></td>
<td>
<p>Controls whether to display or not messages on the screen. If <code>msg==TRUE</code>
messages are displayed on the screen. If <code>msg=2</code>, detailed messages are displayed,
for example the information at iteration level.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_nocheck">nocheck</code></td>
<td>
<p>Check input arguments. If <code>nocheck=TRUE</code> no check is performed
on matrix <code>X</code>. The default <code>nocheck=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_startv1">startv1</code></td>
<td>
<p>How to initialize centroids and covariance matrices. Scalar.
If <code>startv1=1</code> then initial centroids and covariance matrices are based
on <code>(p+1)</code> observations randomly chosen, else each centroid is initialized
taking a random row of input data matrix and covariance matrices are initialized
with identity matrices. The default value is<code>startv1=1</code>.
</p>
<p>Remark 1: in order to start with a routine which is in the required parameter space,
eigenvalue restrictions are immediately applied.
</p>
<p>Remark 2 - option <code>startv1</code> is used just if <code>nsamp</code> is a scalar
(see for more details the help associated with <code>nsamp</code>).</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_randnumbfornini">RandNumbForNini</code></td>
<td>
<p>pre-extracted random numbers to initialize proportions.
Matrix of size k-by-nrow(nsamp) containing the random numbers which
are used to initialize the proportions of the groups. This option is effective just if
<code>nsamp</code> is a matrix which contains pre-extracted subsamples. The purpose of this
option is to enable to user to replicate the results in case routine <code>tclustreg*()</code>
is called using a parfor instruction (as it happens for example in routine IC, where
<code>tclustreg()</code> is called through a parfor for different values of the restriction factor).
The default is that <code>RandNumbForNini</code> is empty - then uniform random numbers are used.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_restrtype">restrtype</code></td>
<td>
<p>Type of restriction to be applied on the cluster scatter matrices.
Valid values are <code>'eigen'</code> (default), or <code>'deter'</code>.
<code>"eigen"</code> implies restriction on the eigenvalues while <code>"deter"</code>
implies restriction on the determinants.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_unitssamegroup">UnitsSameGroup</code></td>
<td>
<p>List of the units which must (whenever possible) have
a particular label. For example <code>UnitsSameGroup=c(20, 26)</code>, means that
group which contains unit 20 is always labelled with number 1. Similarly,
the group which contains unit 26 is always labelled with number 2, (unless
it is found that unit 26 already belongs to group 1).
In general, group which contains unit <code>UnitsSameGroup(r)</code> where <code>r=2, ...length(kk)-1</code>
is labelled with number <code>r</code> (unless it is found that unit <code>UnitsSameGroup(r)</code>
has already been assigned to groups <code>1, 2, ..., r-1</code>.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_numpool">numpool</code></td>
<td>
<p>The number of parallel sessions to open. If numpool is not defined,
then it is set equal to the number of physical cores in the computer.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_cleanpool">cleanpool</code></td>
<td>
<p>Logical, indicating if the open pool must be closed or not.
It is useful to leave it open if there are subsequent parallel sessions to execute,
so that to save the time required to open a new pool.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tclustfsda_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This iterative algorithm initializes <code>k</code> clusters randomly and performs
concentration steps in order to improve the current cluster assignment. The number of
maximum concentration steps to be performed is given by input parameter <code>refsteps</code>.
For approximately obtaining the global optimum, the system is initialized <code>nsamp</code>
times and concentration steps are performed until convergence or <code>refsteps</code> is
reached. When processing more complex data sets higher values of <code>nsamp</code> and
<code>refsteps</code> have to be specified (obviously implying extra computation time).
However, if more then 10 per cent of the iterations do not converge, a warning message
is issued, indicating that <code>nsamp</code> has to be increased.
</p>


<h3>Value</h3>

<p>Depending on the input parameter <code>monitoring</code>, one of
the following objects will be returned:
</p>

<ol>
<li> <p><code><a href="#topic+tclustfsda.object">tclustfsda.object</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tclusteda.object">tclusteda.object</a></code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Garcia-Escudero, L.A., Gordaliza, A., Matran, C. and Mayo-Iscar, A. (2008).
A General Trimming Approach to Robust Cluster Analysis. Annals of Statistics,
Vol. 36, 1324-1345. <a href="https://doi.org/10.1214/07-AOS515">doi:10.1214/07-AOS515</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 

 data(hbk, package="robustbase")
 (out &lt;- tclustfsda(hbk[, 1:3], k=2))
 class(out)
 summary(out)

 ##  TCLUST of Gayser data with three groups (k=3), 10%% trimming (alpha=0.1)
 ##      and restriction factor (c=10000)
 data(geyser2)
 (out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000))

 ## Use the plot options to produce more complex plots ----------

 ##  Plot with all default options
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000, plot=TRUE)

 ##  Default confidence ellipses.
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000, plot="ellipse")

 ##  Confidence ellipses specified by the user: confidence ellipses set to 0.5
 plots &lt;- list(type="ellipse", conflev=0.5)
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000, plot=plots)

 ##  Confidence ellipses set to 0.9
 plots &lt;- list(type="ellipse", conflev=0.9)
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000, plot=plots)

 ##  Contour plots
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000, plot="contour")

 ##  Filled contour plots with additional options: contourf plot with a named colormap.
 ##  Here we define four MATLAB-like colormaps, but the user can define anything else,
 ##  presented by a matrix with three columns which are the RGB triplets.

 summer &lt;- as.matrix(data.frame(x1=seq(from=0, to=1, length=65),
                                x2=seq(from=0.5, to=1, length=65),
                                x3=rep(0.4, 65)))
 spring &lt;- as.matrix(data.frame(x1=rep(1, 65),
                                x2=seq(from=0, to=1, length=65),
                                x3=seq(from=1, to=0, length=65)))
 winter &lt;- as.matrix(data.frame(x1=rep(0, 65),
                                x2=seq(from=0, to=1, length=65),
                                x3=seq(from=1, to=0, length=65)))
 autumn &lt;- as.matrix(data.frame(x1=rep(1, 65),
                                x2=seq(from=0, to=1, length=65),
                                x3=rep(0, 65)))

 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000,
       plot=list(type="contourf", cmap=autumn))
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000,
       plot=list(type="contourf", cmap=winter))
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000,
       plot=list(type="contourf", cmap=spring))
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000,
       plot=list(type="contourf", cmap=summer))


 ##  We compare the output using three different values of restriction factor
 ##      nsamp is the number of subsamples which will be extracted
 data(geyser2)
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10000, nsamp=500, plot="ellipse")
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=10, nsamp=500, refsteps=10, plot="ellipse")
 out &lt;- tclustfsda(geyser2, k=3, alpha=0.1, restrfactor=1, nsamp=500, refsteps=10, plot="ellipse")

 ##  TCLUST applied to M5 data: A bivariate data set obtained from three normal
 ##  bivariate distributions with different scales and proportions 1:2:2. One of the
 ##  components is very overlapped with another one. A 10 per cent background noise is
 ##  added uniformly distributed in a rectangle containing the three normal components
 ##  and not very overlapped with the three mixture components. A precise description
 ##  of the M5 data set can be found in Garcia-Escudero et al. (2008).
 ##

 data(M5data)
 plot(M5data[, 1:2])

 ##  Scatter plot matrix
 library(rrcov)
 plot(CovClassic(M5data[,1:2]), which="pairs")

 out &lt;- tclustfsda(M5data[,1:2], k=3, alpha=0, restrfactor=1000, nsamp=100, plot=TRUE)
 out &lt;- tclustfsda(M5data[,1:2], k=3, alpha=0, restrfactor=10, nsamp=100, plot=TRUE)
 out &lt;- tclustfsda(M5data[,1:2], k=3, alpha=0.1, restrfactor=1, nsamp=1000,
         plot=TRUE, equalweights=TRUE)
 out &lt;- tclustfsda(M5data[,1:2], k=3, alpha=0.1, restrfactor=1000, nsamp=100, plot=TRUE)

 ##  TCLUST with simulated data: 5 groups and 5 variables
 ##
 n1 &lt;- 100
 n2 &lt;- 80
 n3 &lt;- 50
 n4 &lt;- 80
 n5 &lt;- 70
 p &lt;- 5
 Y1 &lt;- matrix(rnorm(n1 * p) + 5, ncol=p)
 Y2 &lt;- matrix(rnorm(n2 * p) + 3, ncol=p)
 Y3 &lt;- matrix(rnorm(n3 * p) - 2, ncol=p)
 Y4 &lt;- matrix(rnorm(n4 * p) + 2, ncol=p)
 Y5 &lt;- matrix(rnorm(n5 * p), ncol=p)

 group &lt;- c(rep(1, n1), rep(2, n2), rep(3, n3), rep(4, n4), rep(5, n5))
 Y &lt;- Y1
 Y &lt;- rbind(Y, Y2)
 Y &lt;- rbind(Y, Y3)
 Y &lt;- rbind(Y, Y4)
 Y &lt;- rbind(Y, Y5)
 dim(Y)
 table(group)
 out &lt;- tclustfsda(Y, k=5, alpha=0.05, restrfactor=1.3, refsteps=20, plot=TRUE)

 ##  Automatic choice of best number of groups for Geyser data ------------------------
 ##
 data(geyser2)
 maxk &lt;- 6
 CLACLA &lt;- matrix(0, nrow=maxk, ncol=2)
 CLACLA[,1] &lt;- 1:maxk
 MIXCLA &lt;- MIXMIX &lt;- CLACLA

 for(j in 1:maxk) {
     out &lt;- tclustfsda(geyser2, k=j, alpha=0.1, restrfactor=5)
     CLACLA[j, 2] &lt;- out$CLACLA
 }

 for(j in 1:maxk) {
     out &lt;- tclustfsda(geyser2, k=j, alpha=0.1, restrfactor=5, mixt=2)
     MIXMIX[j ,2] &lt;- out$MIXMIX
     MIXCLA[j, 2] &lt;- out$MIXCLA
 }

 oldpar &lt;- par(mfrow=c(1,3))
 plot(CLACLA[,1:2], type="l", xlim=c(1, maxk), xlab="Number of groups", ylab="CLACLA")
 plot(MIXMIX[,1:2], type="l", xlim=c(1, maxk), xlab="Number of groups", ylab="MIXMIX")
 plot(MIXCLA[,1:2], type="l", xlim=c(1, maxk), xlab="Number of groups", ylab="MIXCLA")
 par(oldpar)


 ##  Monitoring examples ------------------------------------------

 ##  Monitoring using Geyser data

 ##  Monitoring using Geyser data (all default options)
 ##  alpha and restriction factor are not specified therefore alpha=c(0.10, 0.05, 0)
 ##  is used while the restriction factor is set to c=12
 out &lt;- tclustfsda(geyser2, k=3, monitoring=TRUE)

 ##  Monitoring using Geyser data with alpha and c specified.
 out &lt;- tclustfsda(geyser2, k=3, restrfac=100, alpha=seq(0.10, 0, by=-0.01), monitoring=TRUE)

 ##  Monitoring using Geyser data with plot argument specified as a list.
 ##      The trimming levels to consider in this case are 31 values of alpha
 ##
 out &lt;- tclustfsda(geyser2, k=3, restrfac=100, alpha=seq(0.30, 0, by=-0.01), monitoring=TRUE,
         plot=list(alphasel=c(0.2, 0.10, 0.05, 0.01)), trace=TRUE)

 ##  Monitoring using Geyser data with argument UnitsSameGroup
 ##
 ##      Make sure that group containing unit 10 is in a group which is labelled "group 1"
 ##      and group containing unit 12 is in group which is labelled "group 2"
 ##
 ##      Mixture model is used (mixt=2)
 ##
 out &lt;- tclustfsda(geyser2, k=3, restrfac=100, alpha=seq(0.30, 0, by=-0.01), monitoring=TRUE,
         mixt=2, UnitsSameGroup=c(10, 12), trace=TRUE)

 ##  Monitoring using M5 data
 data(M5data)

 ##  alphavec=vector which contains the trimming levels to consider
 ##  in this case 31 values of alpha are considered
 alphavec &lt;- seq(0.10, 0, by=-0.02)
 out &lt;- tclustfsda(M5data[, 1:2], 3, alpha=alphavec, restrfac=1000, monitoring=TRUE,
     nsamp=1000, plots=TRUE)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclustfsda.object'>Objects returned by the function <code><a href="#topic+tclustfsda">tclustfsda</a></code></h2><span id='topic+tclustfsda.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+tclustfsda.object">tclustfsda.object</a></code> holds information about
the result of a call to <code><a href="#topic+tclustfsda">tclustfsda</a></code>.
</p>


<h3>Value</h3>

<p>The functions <code>print()</code> and <code>summary()</code> are used to obtain and print a
summary of the results. An object of class <code>tclustfsda</code> is a list containing at least the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>muopt</code></td>
<td>
<p>a k-by-p matrix containing cluster centroid locations. Robust estimate of final centroids of the groups</p>
</td></tr>
<tr><td><code>sigmaopt</code></td>
<td>
<p>a p-by-p-by-k array rray containing estimated constrained covariance for the k groups</p>
</td></tr>
<tr><td><code>idx</code></td>
<td>
<p>a vector of length n containing assignment of each unit to each of the k groups. Cluster names are integer numbers from 1 to k. 0 indicates trimmed observations.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>a matrix of size (k+1)-by-3. The 1st col is sequence from 0 to k (cluster name); the 2nd col is the number of observations in each cluster; the 3rd col is the percentage of observations in each cluster.
</p>
<p>Remark: 0 denotes unassigned units.</p>
</td></tr>
<tr><td><code>postprob</code></td>
<td>
<p>n-by-k matrix containing posterior probabilities. <code>postprob[i, j]</code> contains posterior probabilitiy of unit <code>i</code> from component (cluster) <code>j</code>. For the trimmed units posterior probabilities are 0.</p>
</td></tr>
<tr><td><code>emp</code></td>
<td>
<p>&quot;Empirical&quot; statistics computed on final classification. When convergence is reached, 
<code>emp=0</code>. When convergence is not obtained, this field is a list which contains the statistics 
of interest: <code>idxemp</code> (ordered from 0 to k*, k* being the number of groups with 
at least one observation and 0 representing the possible group of outliers), 
<code>muemp</code>, <code>sigmaemp</code> and <code>sizemp</code>, which are the empirical counterparts of 
<code>idx</code>, <code>muopt</code>, <code>sigmaopt</code> and <code>size</code>.</p>
</td></tr>
<tr><td><code>MIXMIX</code></td>
<td>
<p>BIC which uses parameters estimated using the mixture loglikelihood and 
the maximized mixture likelihood as goodness of fit measure.
</p>
<p>Remark: this output is present just if <code>mixt &gt; 0</code>.</p>
</td></tr>
<tr><td><code>MIXCLA</code></td>
<td>
<p>BIC which uses parameters estimated using the mixture loglikelihood 
and the maximized mixture likelihood as goodness of fit measure.
</p>
<p>Remark: this output is present just if <code>mixt &gt; 0</code>.</p>
</td></tr>
<tr><td><code>CLACLA</code></td>
<td>
<p>BIC which uses the classification likelihood based on parameters estimated using the classification likelihood.
</p>
<p>Remark: this output is present just if <code>mixt &gt; 0</code>.</p>
</td></tr>
<tr><td><code>notconver</code></td>
<td>
<p>number of subsets without convergence</p>
</td></tr>
<tr><td><code>bs</code></td>
<td>
<p>a vector of length <code>k</code> containing the units forming initial subset associated with muopt.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>value of the objective function which is minimized (value of the best returned solution).</p>
</td></tr>
<tr><td><code>equalweights</code></td>
<td>
<p>if <code>equalweights=TRUE</code> means that in the clustering procedure we 
(ideally) assumed equal cluster weights else (<code>equalweitghts=FALSE</code> 
means that we allowed for different cluster sizes.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>number of observations that have determined the centroids (number of untrimmed units).</p>
</td></tr>
<tr><td><code>fullsol</code></td>
<td>
<p>a vector of size <code>nsamp</code> which contains the value of the objective function at the end of the iterative process for each extracted subsample.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the original data matrix X.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 data(hbk, package="robustbase")
 (out &lt;- tclustfsda(hbk[, 1:3], k=2))
 class(out)
 summary(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclustIC'>Performs cluster analysis by calling <code><a href="#topic+tclustfsda">tclustfsda</a></code> for different
number of groups <code>k</code> and restriction factors <code>c</code></h2><span id='topic+tclustIC'></span>

<h3>Description</h3>

<p>Computes the values of BIC (MIXMIX), ICL (MIXCLA) or CLA (CLACLA),
for different values of <code>k</code> (number of groups) and different values of <code>c</code>
(restriction factor), for a prespecified level of trimming (the last two letters in the name
stand for 'Information Criterion'). In order to minimize
randomness, given <code>k</code>, the same subsets are used for each value of <code>c</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclustIC(
  x,
  kk = 1:5,
  cc = c(1, 2, 4, 8, 16, 32, 64, 128),
  alpha = 0,
  whichIC = c("ALL", "MIXMIX", "MIXCLA", "CLACLA"),
  nsamp,
  refsteps = 15,
  reftol = 1e-14,
  equalweights = FALSE,
  msg = TRUE,
  nocheck = FALSE,
  plot = FALSE,
  startv1 = 1,
  restrtype = c("eigen", "deter"),
  UnitsSameGroup,
  numpool,
  cleanpool,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tclustIC_+3A_x">x</code></td>
<td>
<p>An n x p data matrix (n observations and p variables).
Rows of x represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_kk">kk</code></td>
<td>
<p>an integer vector specifying the number of mixture components (clusters) for which the BIC is to be calculated. By default <code>kk=1:5</code>.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_cc">cc</code></td>
<td>
<p>an  vector specifying the values of the restriction factor which have to be considered. By default <code>cc=c(1, 2, 4, 8, 16, 32, 64, 128)</code>.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_alpha">alpha</code></td>
<td>
<p>Global trimming level. A scalar between 0 and 0.5 or an integer specifying the number of
observations which have to be trimmed. If <code>alpha=0</code> all observations are considered. By default <code>alpha=0</code>.
</p>
<p>More in detail, if <code>0 &lt; alpha &lt; 1</code> clustering is based on <code>h = fix(n * (1-alpha))</code>
observations, else if alpha is an integer greater than 1 clustering is based on <code>h = n - floor(alpha)</code>.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_whichic">whichIC</code></td>
<td>
<p>A character value which specifies which information criteria must be computed
for each <code>k</code> (number of groups) and each value of the restriction factor <code>c</code>. Possible values for <code>whichIC</code> are:
</p>

<ul>
<li><p> &quot;MIXMIX&quot;: a mixture model is fitted and for computing the information criterion
the mixture likelihood is used. This option corresponds to the use of the Bayesian
Information criterion (BIC). In output just the matrix <code>MIXMIX</code> is given.
</p>
</li>
<li><p> &quot;MIXCLA&quot;: a mixture model is fitted but to compute the information criterion
the classification likelihood is used. This option corresponds to the use of the
Integrated Complete Likelihood (ICL). In the output just the matrix <code>MIXCLA</code> is given.
</p>
</li>
<li><p> &quot;CLACLA&quot;: everything is based on the classification likelihood. This information
criterion will be called CLA. In the output just the matrix <code>CLACLA</code> is given.
</p>
</li>
<li><p> &quot;ALL&quot;: both classification and mixture likelihood are used. In this case all
three information criteria CLA, ICL and BIC are computed. In the output all
three matrices <code>MIXMIX</code>, <code>MIXCLA</code> and <code>CLACLA</code> are given.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tclustIC_+3A_nsamp">nsamp</code></td>
<td>
<p>If a scalar, it contains the number of subsamples which will be extracted.
If <code>nsamp = 0</code> all subsets will be extracted. Remark - if the number of all possible
subset is greater than 300 the default is to extract all subsets, otherwise just 300.
If <code>nsamp</code> is a matrix it contains in the rows the indexes of the subsets which
have to be extracted. <code>nsamp</code> in this case can be conveniently generated by
function <code>subsets()</code>. <code>nsamp</code> can have <code>k</code> columns or <code>k * (p + 1)</code>
columns. If <code>nsamp</code> has <code>k</code> columns the <code>k</code> initial centroids each
iteration i are given by <code>X[nsamp[i,] ,]</code> and the covariance matrices are equal
to the identity.
</p>
<p>If <code>nsamp</code> has <code>k * (p + 1)</code> columns, the initial centroids and covariance
matrices in iteration <code>i</code> are computed as follows:
</p>

<ul>
<li><p> X1 &lt;- X[nsamp[i ,] ,]
</p>
</li>
<li><p> mean(X1[1:p + 1, ]) contains the initial centroid for group 1
</p>
</li>
<li><p> cov(X1[1:p + 1, ]) contains the initial cov matrix for group 1
</p>
</li>
<li><p> mean(X1[(p + 2):(2*p + 2), ]) contains the initial centroid for group 2
</p>
</li>
<li><p> cov(X1[(p + 2):(2*p + 2), ]) contains the initial cov matrix for group 2
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> mean(X1[(k-1)*p+1):(k*(p+1), ]) contains the initial centroids for group k
</p>
</li>
<li><p> cov(X1[(k-1)*p+1):(k*(p+1), ]) contains the initial cov matrix for group k.
</p>
</li></ul>

<p>REMARK: If <code>nsamp</code> is not a scalar, the option <code>startv1</code> given below is ignored.
More precisely, if <code>nsamp</code> has <code>k</code> columns <code>startv1 = 0</code> else if
<code>nsamp</code> has <code>k*(p+1)</code> columns option <code>startv1=1</code>.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_refsteps">refsteps</code></td>
<td>
<p>Number of refining iterations in each subsample. Default is <code>refsteps=15</code>.
<code>refsteps = 0</code> means &quot;raw-subsampling&quot; without iterations.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_reftol">reftol</code></td>
<td>
<p>Tolerance of the refining steps. The default value is 1e-14</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_equalweights">equalweights</code></td>
<td>
<p>A logical specifying wheather cluster weights in the concentration
and assignment steps shall be considered. If <code>equalweights=TRUE</code> we are (ideally)
assuming equally sized groups, else if <code>equalweights = false</code> (default) we allow for
different group weights. Please, check in the given references which functions
are maximized in both cases.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_msg">msg</code></td>
<td>
<p>Controls whether to display or not messages on the screen If <code>msg==TRUE</code> (default)
messages are displayed on the screen. If <code>msg=2</code>, detailed messages are displayed,
for example the information at iteration level.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_nocheck">nocheck</code></td>
<td>
<p>Check input arguments. If <code>nocheck=TRUE</code> no check is performed
on matrix <code>X</code>. The default <code>nocheck=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_plot">plot</code></td>
<td>
<p>If <code>plot=TRUE</code>, a plot of the BIC (MIXMIX), ICL (MIXCLA) curve
and CLACLA is shown on the screen. The plots which are shown depend on
the input option <code>whichIC</code>.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_startv1">startv1</code></td>
<td>
<p>How to initialize centroids and covariance matrices. Scalar.
If <code>startv1=1</code> then initial centroids and covariance matrices are based
on <code>(p+1)</code> observations randomly chosen, else each centroid is initialized
taking a random row of input data matrix and covariance matrices are initialized
with identity matrices. The default value is<code>startv1=1</code>.
</p>
<p>Remark 1: in order to start with a routine which is in the required parameter space,
eigenvalue restrictions are immediately applied.
</p>
<p>Remark 2 - option <code>startv1</code> is used just if <code>nsamp</code> is a scalar
(see for more details the help associated with <code>nsamp</code>).</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_restrtype">restrtype</code></td>
<td>
<p>Type of restriction to be applied on the cluster scatter matrices.
Valid values are <code>'eigen'</code> (default), or <code>'deter'</code>.
<code>"eigen"</code> implies restriction on the eigenvalues while <code>"deter"</code>
implies restriction on the determinants.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_unitssamegroup">UnitsSameGroup</code></td>
<td>
<p>List of the units which must (whenever possible) have
a particular label. For example <code>UnitsSameGroup=c(20, 26)</code>, means that
group which contains unit 20 is always labelled with number 1. Similarly,
the group which contains unit 26 is always labelled with number 2, (unless
it is found that unit 26 already belongs to group 1).
In general, group which contains unit <code>UnitsSameGroup(r)</code> where <code>r=2, ...length(kk)-1</code>
is labelled with number <code>r</code> (unless it is found that unit <code>UnitsSameGroup(r)</code>
has already been assigned to groups <code>1, 2, ..., r-1</code>.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_numpool">numpool</code></td>
<td>
<p>The number of parallel sessions to open. If numpool is not defined,
then it is set equal to the number of physical cores in the computer.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_cleanpool">cleanpool</code></td>
<td>
<p>Logical, indicating if the open pool must be closed or not.
It is useful to leave it open if there are subsequent parallel sessions to execute,
so that to save the time required to open a new pool.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tclustIC_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code><a href="#topic+tclustic.object">tclustic.object</a></code>
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Cerioli, A., Garcia-Escudero, L.A., Mayo-Iscar, A. and Riani M. (2017).
Finding the Number of Groups in Model-Based Clustering via Constrained Likelihoods,
<em>Journal of Computational and Graphical Statistics</em>, pp. 404-416,
https://doi.org/10.1080/10618600.2017.1390469.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tclustfsda">tclustfsda</a></code>, <code><a href="#topic+tclustICplot">tclustICplot</a></code>, <code><a href="#topic+tclustICsol">tclustICsol</a></code>, <code><a href="#topic+carbikeplot">carbikeplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 data(geyser2)
 (out &lt;- tclustIC(geyser2, whichIC="MIXMIX", plot=FALSE, alpha=0.1))
 summary(out)
 
## End(Not run)

 ## Not run: 
 data(flea)
 Y &lt;- as.matrix(flea[, 1:(ncol(flea)-1)])    # select only the numeric variables
 rownames(Y) &lt;- 1:nrow(Y)
 head(Y)

 (out &lt;- tclustIC(Y, whichIC="CLACLA", plot=FALSE, alpha=0.1, nsamp=100, numpool=1))
 summary(out)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='tclustic.object'>Objects returned by the function <code><a href="#topic+tclustIC">tclustIC</a></code></h2><span id='topic+tclustic.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+tclustic.object">tclustic.object</a></code> holds information about
the result of a call to <code><a href="#topic+tclustIC">tclustIC</a></code>.
</p>


<h3>Value</h3>

<p>The functions <code>print()</code> and <code>summary()</code> are used to obtain and print a
summary of the results. An object of class <code>tclustic</code> is a list containing at least the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>kk</code></td>
<td>
<p>a vector containing the values of <code>k</code> (number of components) which have been considered.
This vector is identical to the optional argument <code>kk</code> (default is <code>kk=1:5</code>.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>a vector containing the values of <code>c</code> (values of the restriction factor) which
have been considered. This vector is identical to the optional argument <code>cc</code> (defalt is <code>cc=c(1, 2, 4, 8, 16, 32, 64, 128)</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>trimming level</p>
</td></tr>
<tr><td><code>whichIC</code></td>
<td>
<p>Information criteria used</p>
</td></tr>
<tr><td><code>CLACLA</code></td>
<td>
<p>a matrix of size <code>length(kk)-times-length(cc)</code> containinig the value of
the penalized classification likelihood. This output is present only if <code>whichIC="CLACLA"</code> or  <code>whichIC="ALL"</code>.</p>
</td></tr>
<tr><td><code>IDXCLA</code></td>
<td>
<p>a matrix of lists of size <code>length(kk)-times-length(cc)</code> containinig the assignment of each unit
using the classification model. This output is present only if <code>whichIC="CLACLA"</code> or  <code>whichIC="ALL"</code>.</p>
</td></tr>
<tr><td><code>MIXMIX</code></td>
<td>
<p>a matrix of size <code>length(kk)-times-length(cc)</code> containinig the value of
the penalized mixtrue likelihood. This output is present only if <code>whichIC="MIXMIX"</code> or  <code>whichIC="ALL"</code>.</p>
</td></tr>
<tr><td><code>IDXMIX</code></td>
<td>
<p>a matrix of lists of size <code>length(kk)-times-length(cc)</code> containinig the assignment of each unit
using the classification model. This output is present only if <code>whichIC="MIXMIX"</code> or  <code>whichIC="ALL"</code>.</p>
</td></tr>
<tr><td><code>MIXCLA</code></td>
<td>
<p>a matrix of size <code>length(kk)-times-length(cc)</code> containinig the value of
the ICL criterion. This output is present only if <code>whichIC="MIXCLA"</code> or  <code>whichIC="ALL"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 data(hbk, package="robustbase")
 (out &lt;- tclustIC(hbk[, 1:3]))
 class(out)
 summary(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclustICplot'>Plots information criterion as a function of <code>c</code> and <code>k</code>, based on the solutions obtained by <code><a href="#topic+tclustIC">tclustIC</a></code></h2><span id='topic+tclustICplot'></span>

<h3>Description</h3>

<p>The function <code>tclustICplot()</code> takes as input an object of class
<code><a href="#topic+tclustic.object">tclustic.object</a></code>, the output
of function <code><a href="#topic+tclustIC">tclustIC</a></code> (that is a series of matrices which contain
the values of the information criteria BIC/ICL/CLA for different values of <code>k</code>
and <code>c</code>) and plots them as function of <code>c</code> or of <code>k</code>. The plot enables
interaction in the sense that, if option <code>databrush</code> has been activated, it is
possible to click on a point in the plot and to see the associated classification
in the scatter plot matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclustICplot(
  out,
  whichIC = c("ALL", "MIXMIX", "MIXCLA", "CLACLA"),
  tag,
  datatooltip,
  databrush,
  nameY,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tclustICplot_+3A_out">out</code></td>
<td>
<p>An S3 object of class <code><a href="#topic+tclustic.object">tclustic.object</a></code>
(output of <code><a href="#topic+tclustIC">tclustIC</a></code>) containing the values
of the information criteria BIC (MIXMIX), ICL (MIXCLA) or CLA (CLACLA),
for different values of k (number of groups) and different
values of c (restriction factor), for a prespecified level of trimming.</p>
</td></tr>
<tr><td><code id="tclustICplot_+3A_whichic">whichIC</code></td>
<td>
<p>Specifies the information criterion to use for the plot.
See <code>tclustIC()</code> for the possible values of whichIC.</p>
</td></tr>
<tr><td><code id="tclustICplot_+3A_tag">tag</code></td>
<td>
<p>plot handle. String which identifies the handle of the plot which is about to be created.
The default is to use tag 'pl_IC'. Notice that if the program finds a plot which has
a tag equal to the one specified by the user, then the output of the new plot overwrites
the existing one in the same window else a new window is created.</p>
</td></tr>
<tr><td><code id="tclustICplot_+3A_datatooltip">datatooltip</code></td>
<td>
<p>Interactive clicking. It is inactive if this parameter is set to FALSE.
If <code>datatooltip=TRUE</code>, the user can select with the mouse a solution
in order to have the following information:
</p>

<ul>
<li><p> 1) value of <code>k</code> which has been selected
</p>
</li>
<li><p> 2) value of <code>c</code> which has been selected
</p>
</li>
<li><p> 3) values of the information criterion
</p>
</li>
<li><p> 4) frequency distribution of the associated classification.
</p>
</li></ul>

<p>If datatooltip is a list it may contain the following fields:
</p>

<ol>
<li><p> DisplayStyle determines how the data cursor displays. Possible values are
<code>'datatip'</code> and <code>'window'</code> (default). <code>'datatip'</code> displays
data cursor information in a small yellow text box attached to a black
square marker at a data point you interactively select. <code>'window'</code>
displays data cursor information for the data point you interactively
select in a floating window within the figure.
</p>
</li>
<li><p> SnapToDataVertex: specifies whether the data cursor snaps to the nearest data value or
is located at the actual pointer position.
Possible values are <code>SnapToDataVertex='on'</code> (default) and <code>SnapToDataVertex='off'</code>.
</p>
</li></ol>
</td></tr>
<tr><td><code id="tclustICplot_+3A_databrush">databrush</code></td>
<td>
<p>Interactive mouse brushing. If databrush is missing or empty (default), no brushing is done.
The activation of this option (databrush is <code>TRUE</code> or a list) enables the user to select
a set of values of IC in the current plot and to see thecorresponding classification highlighted in the scatterplot matrix.
If the scatterplot matrix does not exist it is automatically created.
Note that the window style of the other figures is set equal to that which contains the IC plot.
In other words, if the IC plot is docked all the other figures will be docked too.
</p>
<p>If <code>databrush=TRUE</code> the default selection tool is a rectangular brush and it is
possible to brush only once (that is persist=&rdquo;).
</p>
<p>If <code>databrush=list(...)</code>, it is possible to use all optional arguments of
the MATLAB function <code>selectdataFS()</code> and the following optional arguments:
</p>

<ul>
<li> <p><code>persist</code>: Persist is an empty value or a character containing 'on' or 'off'.
The default value is <code>persist=""</code>, that is brushing is allowed only once.
If <code>persist="on"</code> or <code>persis="off"</code> brushing can be done as many time as
the user requires. If <code>persist='on'</code> then the unit(s) currently brushed are
added to those previously brushed. It is possible, every time a new brushing is
done, to use a different color for the brushed units. If <code>persist='off'</code>
every time a new brush is performed units previously brushed are removed.
</p>
</li>
<li> <p><code>label</code>: add labels of brushed units in the monitoring plot.
</p>
</li>
<li> <p><code>dispopt</code>: controls how to fill the diagonals in the scatterplot matrix
of the brushed solutions. Set <code>dispopt="hist"</code> (default) to plot histograms,
or <code>dispopt="box"</code> to plot boxplots.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tclustICplot_+3A_namey">nameY</code></td>
<td>
<p>Add variable labels in plot. A vector of strings of length <code>p</code>
containing the labels of the variables in the dataset.
If it is empty (default) the sequence <code>X1, ..., Xp</code> will be created automatically</p>
</td></tr>
<tr><td><code id="tclustICplot_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tclustICplot_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Cerioli, A., Garcia-Escudero, L.A., Mayo-Iscar, A. and Riani M. (2017).
Finding the Number of Groups in Model-Based Clustering via Constrained Likelihoods,
<em>Journal of Computational and Graphical Statistics</em>, pp. 404-416,
https://doi.org/10.1080/10618600.2017.1390469.
</p>
<p>Hubert L. and Arabie P. (1985), Comparing Partitions, <em>Journal of Classification</em>,
Vol. 2, pp. 193-218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tclustIC">tclustIC</a></code>, <code><a href="#topic+tclustfsda">tclustfsda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 data(geyser2)
 out &lt;- tclustIC(geyser2, whichIC="MIXMIX", plot=FALSE, alpha=0.1)

 tclustICplot(out, whichIC="MIXMIX")

 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclustICsol'>Extracts a set of best relevant solutions obtained by <code><a href="#topic+tclustIC">tclustIC</a></code></h2><span id='topic+tclustICsol'></span>

<h3>Description</h3>

<p>The function <code>tclustICsol()</code> takes as input an object of class
<code><a href="#topic+tclustic.object">tclustic.object</a></code>, the output
of function <code><a href="#topic+tclustIC">tclustIC</a></code> (that is a series of matrices which contain
the values of the information criteria BIC/ICL/CLA for different values of <code>k</code>
and <code>c</code>) and extracts the first best solutions. Two solutions are considered
equivalent if the value of the adjusted Rand index (or the adjusted Fowlkes and
Mallows index) is above a certain threshold. For each tentative solution the program
checks the adjacent values of <code>c</code> for which the solution is stable.
A matrix with adjusted Rand indexes is given for the extracted solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclustICsol(
  out,
  NumberOfBestSolutions = 5,
  ThreshRandIndex = 0.7,
  whichIC = c("ALL", "CLACLA", "MIXMIX", "MIXCLA"),
  Rand = TRUE,
  msg = TRUE,
  plot = FALSE,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tclustICsol_+3A_out">out</code></td>
<td>
<p>An S3 object of class <code><a href="#topic+tclustic.object">tclustic.object</a></code>
(output of <code><a href="#topic+tclustIC">tclustIC</a></code>) containing the values
of the information criteria BIC (MIXMIX), ICL (MIXCLA) or CLA (CLACLA),
for different values of k (number of groups) and different
values of c (restriction factor), for a prespecified level of trimming.</p>
</td></tr>
<tr><td><code id="tclustICsol_+3A_numberofbestsolutions">NumberOfBestSolutions</code></td>
<td>
<p>Number of best solutions to extract from BIC/ICL matrix.
The default value of NumberOfBestSolutions is 5</p>
</td></tr>
<tr><td><code id="tclustICsol_+3A_threshrandindex">ThreshRandIndex</code></td>
<td>
<p>Threshold to identify spurious solutions - the threshold
of the adjusted Rand index to use to consider two solutions as equivalent.
The default value of ThreshRandIndex is 0.7</p>
</td></tr>
<tr><td><code id="tclustICsol_+3A_whichic">whichIC</code></td>
<td>
<p>Specifies the information criterion to use to extract best solutions.
Possible values for whichIC are:
</p>

<ul>
<li> <p><code>CLACLA</code> = in this case best solutions are referred to the classification likelihood.
</p>
</li>
<li> <p><code>MIXMIX</code> = in this case in this case best solutions are referred to the mixture likelihood (BIC).
</p>
</li>
<li> <p><code>MIXCLA</code> = in this case in this case best solutions are referred to ICL.
</p>
</li>
<li> <p><code>ALL</code> = in this case best solutions both three solutions using classification
and mixture likelihood are produced. In the output class <code>out</code> all the
three matrices <code>MIXMIXbs</code>, <code>CLACLAbs</code> and <code>MIXCLAbs</code> are given.
</p>
</li></ul>

<p>The default value is <code>whichIC="ALL"</code>.</p>
</td></tr>
<tr><td><code id="tclustICsol_+3A_rand">Rand</code></td>
<td>
<p>Index to use to compare partitions. If <code>Rand=TRUE</code> (default) the adjusted Rand
index is used, else the adjusted Fowlkes and Mallows index is used.</p>
</td></tr>
<tr><td><code id="tclustICsol_+3A_msg">msg</code></td>
<td>
<p>It controls whether to display or not messages (from MATLAB) on the screen. If <code>msg=TRUE</code>
(default) messages about the progression of the search are displayed on the screen
otherwise only error messages will be displayed.</p>
</td></tr>
<tr><td><code id="tclustICsol_+3A_plot">plot</code></td>
<td>
<p>If <code>plot=TRUE</code>, the best solutions which have been found are shown on the screen.</p>
</td></tr>
<tr><td><code id="tclustICsol_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tclustICsol_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code><a href="#topic+tclusticsol.object">tclusticsol.object</a></code>
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Cerioli, A., Garcia-Escudero, L.A., Mayo-Iscar, A. and Riani M. (2017).
Finding the Number of Groups in Model-Based Clustering via Constrained Likelihoods,
<em>Journal of Computational and Graphical Statistics</em>, pp. 404-416,
https://doi.org/10.1080/10618600.2017.1390469.
</p>
<p>Hubert L. and Arabie P. (1985), Comparing Partitions, <em>Journal of Classification</em>,
Vol. 2, pp. 193-218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tclustIC">tclustIC</a></code>, <code><a href="#topic+tclustfsda">tclustfsda</a></code>, <code><a href="#topic+carbikeplot">carbikeplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 data(geyser2)
 out &lt;- tclustIC(geyser2, whichIC="MIXMIX", plot=FALSE, alpha=0.1)

 ## Plot first two best solutions using as Information criterion MIXMIX
 print("Best solutions using MIXMIX")
 outMIXMIX &lt;- tclustICsol(out, whichIC="MIXMIX", plot=TRUE, NumberOfBestSolutions=2)

 print(outMIXMIX$MIXMIXbs)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclusticsol.object'>Objects returned by the function <code><a href="#topic+tclustICsol">tclustICsol</a></code></h2><span id='topic+tclusticsol.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+tclusticsol.object">tclusticsol.object</a></code> holds information about
the result of a call to <code><a href="#topic+tclustICsol">tclustICsol</a></code>.
</p>


<h3>Value</h3>

<p>The functions <code>print()</code> and <code>summary()</code> are used to obtain and print a
summary of the results. An object of class <code>tclusticsol</code> is a list containing at least the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>kk</code></td>
<td>
<p>a vector containing the values of <code>k</code> (number of components) which have been considered.
This vector is identical to the optional argument <code>kk</code> (default is <code>kk=1:5</code>.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>a vector containing the values of <code>c</code> (values of the restriction factor) which
have been considered. This vector is identical to the optional argument <code>cc</code> (defalt is <code>cc=c(1, 2, 4, 8, 16, 32, 64, 128)</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>trimming level</p>
</td></tr>
<tr><td><code>whichIC</code></td>
<td>
<p>Information criteria used</p>
</td></tr>
<tr><td><code>MIXMIXbs</code></td>
<td>
<p>a matrix of lists of size <code>NumberOfBestSolutions-times-5</code> which
contains the details of the best solutions for MIXMIX (BIC). Each row refers to a
solution. The information which is stored in the columns is as follows.
</p>

<ul>
<li><p> 1st col = value of k for which solution takes place
</p>
</li>
<li><p> 2nd col = value of c for which solution takes place;
</p>
</li>
<li><p> 3rd col = a vector of length <code>d</code> which contains the values of <code>c</code>
for which the solution is uniformly better.
</p>
</li>
<li><p> 4th col = a vector of length <code>d + r</code> which contains the values of <code>c</code>
for which the solution is considered stable (i.e. for which the value
of the adjusted Rand index (or the adjusted Fowlkes and Mallows index)
does not go below the threshold defined in input option <code>ThreshRandIndex</code>).
</p>
</li>
<li><p> 5th col = string which contains 'true' or 'spurious'. The solution is labelled
spurious if the value of the adjusted Rand index with the previous solutions
is greater than ThreshRandIndex.
</p>
</li></ul>

<p>Remark: the field MIXMIXbs is present only if <code>whichIC=ALL</code> or <code>whichIC="MIXMIX"</code>.
</p>
</td></tr>
<tr><td><code>MIXMIXbsari</code></td>
<td>
<p>a matrix of adjusted Rand indexes (or Fowlkes and Mallows indexes)
associated with the best solutions for MIXMIX. A matrix of size <code>NumberOfBestSolutions-times-NumberOfBestSolutions</code>
whose <code>i,j</code>-th entry contains the adjusted Rand index between classification produced by solution
<code>i</code> and solution <code>j</code>, <code>i,j=1,2, ...,NumberOfBestSolutions</code>.
</p>
<p>Remark: the field <code>MIXMIXbsari</code> is present only if <code>whichIC=ALL</code> or <code>whichIC="MIXMIX"</code>.
</p>
</td></tr>
<tr><td><code>ARIMIX</code></td>
<td>
<p>a matrix of adjusted Rand indexes between two consecutive value of <code>c</code>.
Matrix of size <code>k-by-length(cc)-1</code>. The first column contains the ARI indexes
between <code>cc[2]</code> and <code>cc[1]</code> given <code>k</code>.
The second column contains the the ARI indexes between <code>cc[3]</code> and <code>cc[2]</code> given <code>k</code>.
</p>
<p>Remark: the field <code>ARIMIX</code> is present only if <code>whichIC=ALL</code> or <code>whichIC="MIXMIX"</code> or <code>whichIC="MIXCLA"</code>.
</p>
</td></tr>
<tr><td><code>MIXCLAbs</code></td>
<td>
<p>has the same structure as <code>MIXMIXbs</code> but referres to MIXCLA.
</p>
<p>Remark: the field MIXCLAbs is present only if <code>whichIC=ALL</code> or <code>whichIC="MIXCLA"</code>.
</p>
</td></tr>
<tr><td><code>MIXCLAbsari</code></td>
<td>
<p>has the same structure as <code>MIXMIXbsari</code> but referres to MIXCLA.
</p>
<p>Remark: the field <code>MIXMIXbsari</code> is present only if <code>whichIC=ALL</code> or <code>whichIC="MIXCLA"</code>.
</p>
</td></tr>
<tr><td><code>CLACLAbs</code></td>
<td>
<p>has the same structure as <code>MIXMIXbs</code> but referres to CLACLA.
</p>
<p>Remark: the field CLACLAbs is present only if <code>whichIC=ALL</code> or <code>whichIC="CLACLA"</code>.
</p>
</td></tr>
<tr><td><code>CLACLAbsari</code></td>
<td>
<p>has the same structure as <code>MIXMIXbsari</code> but referres to CLACLA.
</p>
<p>Remark: the field <code>CLACLAbsari</code> is present only if <code>whichIC=ALL</code> or <code>whichIC="CLACLA"</code>.
</p>
</td></tr>
<tr><td><code>ARICLA</code></td>
<td>
<p>a matrix of adjusted Rand indexes between two consecutive value of <code>c</code>.
Matrix of size <code>k-by-length(cc)-1</code>. The first column contains the ARI indexes
between <code>cc[2]</code> and <code>cc[1]</code> given <code>k</code>.
The second column contains the the ARI indexes between <code>cc[3]</code> and <code>cc[2]</code> given <code>k</code>.
</p>
<p>Remark: the field <code>ARICLA</code> is present only if <code>whichIC=ALL</code> or <code>whichIC="CLACLA"</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tclustICsol">tclustICsol</a></code>, <code><a href="#topic+carbikeplot">carbikeplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 data(hbk, package="robustbase")
 (out &lt;- tclustIC(hbk[, 1:3]))

  ## Plot first two best solutions using as Information criterion MIXMIX
  print("Best solutions using MIXMIX")
  outMIXMIX &lt;- tclustICsol(out, whichIC="MIXMIX", plot=TRUE, NumberOfBestSolutions=2)
  class(outMIXMIX)
  summary(outMIXMIX)
  print(outMIXMIX$MIXMIXbs)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclustreg'>Computes robust linear grouping analysis</h2><span id='topic+tclustreg'></span>

<h3>Description</h3>

<p>Performs robust linear grouping analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclustreg(
  y,
  x,
  k,
  alphaLik,
  alphaX,
  restrfactor = 12,
  intercept = TRUE,
  plot = FALSE,
  nsamp,
  refsteps = 10,
  reftol = 1e-13,
  equalweights = FALSE,
  mixt = 0,
  wtrim = 0,
  we,
  msg = TRUE,
  RandNumbForNini,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tclustreg_+3A_y">y</code></td>
<td>
<p>Response variable. A vector with <code>n</code> elements that
contains the response variable.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_x">x</code></td>
<td>
<p>An n x p data matrix (n observations and p variables).
Rows of x represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_k">k</code></td>
<td>
<p>Number of groups.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_alphalik">alphaLik</code></td>
<td>
<p>Trimming level, a scalar between 0 and 0.5 or an
integer specifying the number of observations which have to be trimmed.
If <code>alphaLik=0</code>, there is no trimming.  More in detail, if <code>0 &lt; alphaLik &lt; 1</code>
clustering is based on <code>h = floor(n * (1 - alphaLik))</code> observations.
If <code>alphaLik</code> is an integer greater than 1 clustering is
based on <code>h = n - floor(alphaLik)</code>. More in detail, likelihood
contributions are sorted and the units associated with the smallest <code>n - h</code>
contributions are trimmed.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_alphax">alphaX</code></td>
<td>
<p>Second-level trimming or constrained weighted model for <code>x</code>.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_restrfactor">restrfactor</code></td>
<td>
<p>Restriction factor for regression residuals and
covariance matrices of the explanatory variables. Scalar or vector
with two elements. If <code>restrfactor</code> is a scalar it controls the differences
among group scatters of the residuals. The value 1 is the strongest
restriction. If <code>restrfactor</code> is a vector with two elements
the first element controls the differences among group scatters of
the residuals and the second the differences among covariance
matrices of the explanatory variables. Note that <code>restrfactor[2]</code>
is used just if <code>alphaX=1</code>, that is if constrained weighted model
for <code>x</code> is assumed.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_intercept">intercept</code></td>
<td>
<p>wheather to use constant term (default is <code>intercept=TRUE</code></p>
</td></tr>
<tr><td><code id="tclustreg_+3A_plot">plot</code></td>
<td>
<p>If <code>plot=FALSE</code> (default) or <code>plot=0</code>  no plot is produced.
If <code>plot=TRUE</code> a plot with the final allocation is shown (using the spmplot function).
If <code>X</code> is 2-dimensional, the lines associated to the groups are shown too.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_nsamp">nsamp</code></td>
<td>
<p>If a scalar, it contains the number of subsamples which will be extracted.
If <code>nsamp = 0</code> all subsets will be extracted. Remark - if the number of all possible
subset is greater than 300 the default is to extract all subsets, otherwise just 300.
If <code>nsamp</code> is a matrix it contains in the rows the indexes of the subsets which
have to be extracted. <code>nsamp</code> in this case can be conveniently generated by
function <code>subsets()</code>. <code>nsamp</code> must have <code>k * p</code> columns. The first <code>p</code>
columns are used to estimate the regression coefficient of group 1, ..., the last <code>p</code>
columns are used to estimate the regression coefficient of group <code>k</code>.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_refsteps">refsteps</code></td>
<td>
<p>Number of refining iterations in each subsample. Default is <code>refsteps=10</code>.
<code>refsteps = 0</code> means &quot;raw-subsampling&quot; without iterations.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_reftol">reftol</code></td>
<td>
<p>Tolerance of the refining steps. The default value is 1e-14</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_equalweights">equalweights</code></td>
<td>
<p>A logical specifying wheather cluster weights in the concentration
and assignment steps shall be considered. If <code>equalweights=TRUE</code> we are (ideally)
assuming equally sized groups, else if <code>equalweights = false</code> (default) we allow for
different group weights. Please, check in the given references which functions
are maximized in both cases.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_mixt">mixt</code></td>
<td>
<p>Specifies whether mixture modelling or crisp assignment approach to model
based clustering must be used. In the case of mixture modelling parameter mixt also
controls which is the criterion to find the untrimmed units in each step of the maximization.
If <code>mixt&gt;=1</code> mixture modelling is assumed else crisp assignment.
The default value is <code>mixt=0</code>, i.e. crisp assignment. Please see
for details the provided references.
The parameter <code>mixt</code> also controls the criterion to select the units to trim.
If <code>mixt = 2</code> the <code>h</code> units are those which give the largest contribution
to the likelihood, else if <code>mixt=1</code> the criterion to select the <code>h</code> units is
exactly the same as the one which is used in crisp assignment.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_wtrim">wtrim</code></td>
<td>
<p>How to apply the weights on the observations - a flag taking values in c(0, 1, 2, 3, 4).
</p>

<ul>
<li><p> If <code>wtrim==0</code> (no weights), the algorithm reduces to the standard <code>tclustreg</code> algorithm.
</p>
</li>
<li><p> If <code>wtrim==1</code>, trimming is done by weighting the observations using values specified in vector
<code>we</code>. In this case, vector <code>we</code> must be supplied by the user.
</p>
</li>
<li><p> If <code>wtrim==2</code>, trimming is again done by weighting the observations
using values specified in vector <code>we</code>. In this case, vector <code>we</code>
is computed from the data as a function of the density estimate pdfe.
Specifically, the weight of each observation is the probability of retaining
the observation, computed as
</p>
<p style="text-align: center;"><code class="reqn">pretain_{ig} = 1-pdfe_{ig}/max_{ig}(pdfe_{ig})</code>
</p>

</li>
<li><p> If <code>wtrim==3</code>, trimming is again done by weighting the observations using
values specified in vector <code>we</code>. In this case, each element wei of vector
<code>we</code> is a Bernoulli random variable with probability of success
<code class="reqn">pdfe_{ig}</code>.
In the clustering framework this is done under the constraint that no group is empty.
</p>
</li>
<li><p> If <code>wtrim==4</code>, trimming is done with the tandem approach of Cerioli and Perrotta (2014).
</p>
</li></ul>
</td></tr>
<tr><td><code id="tclustreg_+3A_we">we</code></td>
<td>
<p>Weights. A vector of size n-by-1 containing application-specific weights
Default is a vector of ones.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_msg">msg</code></td>
<td>
<p>Controls whether to display or not messages on the screen If <code>msg==TRUE</code> (default)
messages are displayed on the screen. If <code>msg=2</code>, detailed messages are displayed,
for example the information at iteration level.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_randnumbfornini">RandNumbForNini</code></td>
<td>
<p>pre-extracted random numbers to initialize proportions.
Matrix of size k-by-nrow(nsamp) containing the random numbers which
are used to initialize the proportions of the groups. This option is effective only if
<code>nsamp</code> is a matrix which contains pre-extracted subsamples. The purpose of this
option is to enable the user to replicate the results when the function <code>tclustreg()</code>
is called using a parfor instruction (as it happens for example in routine IC, where
<code>tclustreg()</code> is called through a parfor for different values of the restriction factor).
The default is that <code>RandNumbForNini</code> is empty - then uniform random numbers are used.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tclustreg_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code><a href="#topic+tclustreg.object">tclustreg.object</a></code>
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Mayo-Iscar A. (2016). The joint role of trimming and constraints in robust
estimation for mixtures of gaussian factor analyzers,
Computational Statistics and Data Analysis&quot;, Vol. 99, pp. 131-147.
</p>
<p>Garcia-Escudero, L.A., Gordaliza, A., Greselin, F., Ingrassia, S. and Mayo-Iscar, A. (2017),
Robust estimation of mixtures of regressions with random covariates, via trimming and constraints,
Statistics and Computing, Vol. 27, pp. 377-402.
</p>
<p>Garcia-Escudero, L.A., Gordaliza A., Mayo-Iscar A., and San Martin R. (2010).
Robust clusterwise linear regression through trimming,
Computational Statistics and Data Analysis, Vol. 54, pp.3057-3069.
</p>
<p>Cerioli, A. and Perrotta, D. (2014). Robust Clustering Around Regression Lines with High Density Regions.
Advances in Data Analysis and Classification, Vol. 8, pp. 5-26.
</p>
<p>Torti F., Perrotta D., Riani, M. and Cerioli A. (2019). Assessing Robust Methodologies for Clustering Linear Regression Data,
Advances in Data Analysis and Classification, Vol. 13, pp 227-257.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 ## The X data have been introduced by Gordaliza, Garcia-Escudero &amp; Mayo-Iscar (2013).
 ## The dataset presents two parallel components without contamination.

 data(X)
 y1 = X[, ncol(X)]
 X1 = X[,-ncol(X), drop=FALSE]

 (out &lt;- tclustreg(y1, X1, k=2, alphaLik=0.05, alphaX=0.01, restrfactor=5, plot=TRUE, trace=TRUE))

 (out &lt;- tclustreg(y1, X1, k=2, alphaLik=0.05, alphaX=0.01, restrfactor=2,
         mixt=2, plot=TRUE, trace=TRUE))

 ##  Examples with fishery data

 data(fishery)
 X &lt;- fishery

 ## some jittering is necessary because duplicated units are not treated:
 ## this needs to be addressed
 X &lt;- X + 10^(-8) * abs(matrix(rnorm(nrow(X)*ncol(X)), ncol=2))

 y1 &lt;- X[, ncol(X)]
 X1 &lt;- X[, -ncol(X), drop=FALSE]

 (out &lt;- tclustreg(y1, X1, k=3, restrfact=50, alphaLik=0.04, alphaX=0.01, trace=TRUE))
 ## Example 2:

 ## Define some arbitrary weightssome arbitrary weights for the units
     we &lt;- sqrt(X1)/sum(sqrt(X1))

 ##  tclustreg required parameters
     k &lt;- 2; restrfact &lt;- 50; alpha1 &lt;- 0.04; alpha2 &lt;- 0.01

 ##  Now tclust is run on each combination of mixt and wtrim options

     cat("\nmixt=0; wtrim=0",
         "\nStandard tclustreg, with classification likelihood and without thinning\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=0, wtrim=0, trace=TRUE))

     cat("\nmixt=2; wtrim=0",
         "\nMixture likelihood, no thinning\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=2, wtrim=0, trace=TRUE))

     cat("\nmixt=0; wtrim=1",
         "\nClassification likelihood, thinning based on user weights\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=0, we=we, wtrim=1, trace=TRUE))

     cat("\nmixt=2; wtrim=1",
         "\nMixture likelihood, thinning based on user weights\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=2, we=we, wtrim=1, trace=TRUE))

     cat("\nmixt=0; wtrim=2",
         "\nClassification likelihood, thinning based on retention probabilities\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=0, wtrim=2, trace=TRUE))

     cat("\nmixt=2; wtrim=2",
         "\nMixture likelihood, thinning based on retention probabilities\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=2, wtrim=2, trace=TRUE))

     cat("\nmixt=0; wtrim=3",
         "\nClassification likelihood, thinning based on bernoulli weights\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=0, wtrim=3, trace=TRUE))

     cat("\nmixt=2; wtrim=3",
         "\nMixture likelihood, thinning based on bernoulli weights\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=2, wtrim=3, trace=TRUE))

     cat("\nmixt=0; wtrim=4",
         "\nClassification likelihood, tandem thinning based on bernoulli weights\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=0, wtrim=4, trace=TRUE))

     cat("\nmixt=2; wtrim=4",
         "\nMixture likelihood, tandem thinning based on bernoulli weights\n")
     (out &lt;- tclustreg(y1, X1, k=k, restrfact=restrfact, alphaLik=alpha1, alphaX=alpha2,
             mixt=2, wtrim=4, trace=TRUE))

 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclustreg.object'>Objects returned by the function <code><a href="#topic+tclustreg">tclustreg</a></code></h2><span id='topic+tclustreg.object'></span>

<h3>Description</h3>

<p>An object of class <code><a href="#topic+tclustreg.object">tclustreg.object</a></code> holds information about
the result of a call to <code><a href="#topic+tclustreg">tclustreg</a></code>.
</p>


<h3>Value</h3>

<p>The functions <code>print()</code> and <code>summary()</code> are used to obtain and print a
summary of the results. An object of class <code>tclustreg</code> is a list containing at least the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tclustreg">tclustreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 

 ## The X data have been introduced by Gordaliza, Garcia-Escudero &amp; Mayo-Iscar (2013).
 ## The dataset presents two parallel components without contamination.

 data(X)
 y1 = X[, ncol(X)]
 X1 = X[,-ncol(X), drop=FALSE]

 out &lt;- tclustreg(y1, X1, k=2, alphaLik=0.05, alphaX=0.01, restrfactor=5, trace=TRUE)
 class(out)
 str(out)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='tclustregIC'>Computes <code>tclustreg</code> for different number of groups <code>k</code>
and restriction factors <code>c</code>.</h2><span id='topic+tclustregIC'></span>

<h3>Description</h3>

<p>(the last two letters stand for 'Information Criterion') computes
the values of BIC (MIXMIX), ICL (MIXCLA) or CLA (CLACLA), for different values
of <code>k</code> (number of groups) and different values of <code>c</code>
(restriction factor for the variances of the residuals), for
a prespecified level of trimming. In order to minimize randomness, given <code>k</code>,
the same subsets are used for each value of <code>c</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclustregIC(
  y,
  x,
  alphaLik,
  alphaX,
  intercept = TRUE,
  plot = FALSE,
  nsamp,
  refsteps = 10,
  reftol = 1e-13,
  equalweights = FALSE,
  wtrim = 0,
  we,
  msg = TRUE,
  RandNumbForNini,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tclustregIC_+3A_y">y</code></td>
<td>
<p>Response variable. A vector with <code>n</code> elements that
contains the response variable.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_x">x</code></td>
<td>
<p>An n x p data matrix (n observations and p variables).
Rows of x represent observations, and columns represent variables.
</p>
<p>Missing values (NA's) and infinite values (Inf's) are allowed,
since observations (rows) with missing or infinite values will
automatically be excluded from the computations.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_alphalik">alphaLik</code></td>
<td>
<p>Trimming level, a scalar between 0 and 0.5 or an
integer specifying the number of observations which have to be trimmed.
If <code>alphaLik=0</code>, there is no trimming.  More in detail, if <code>0 &lt; alphaLik &lt; 1</code>
clustering is based on <code>h = floor(n * (1 - alphaLik))</code> observations.
If <code>alphaLik</code> is an integer greater than 1 clustering is
based on <code>h = n - floor(alphaLik)</code>. More in detail, likelihood
contributions are sorted and the units associated with the smallest <code>n - h</code>
contributions are trimmed.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_alphax">alphaX</code></td>
<td>
<p>Second-level trimming or constrained weighted model for <code>x</code>.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_intercept">intercept</code></td>
<td>
<p>wheather to use constant term (default is <code>intercept=TRUE</code></p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_plot">plot</code></td>
<td>
<p>If <code>plot=FALSE</code> (default) or <code>plot=0</code>  no plot is produced.
If <code>plot=TRUE</code> a plot with the final allocation is shown (using the spmplot function).
If <code>X</code> is 2-dimensional, the lines associated to the groups are shown too.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_nsamp">nsamp</code></td>
<td>
<p>If a scalar, it contains the number of subsamples which will be extracted.
If <code>nsamp = 0</code> all subsets will be extracted. Remark - if the number of all possible
subset is greater than 300 the default is to extract all subsets, otherwise just 300.
If <code>nsamp</code> is a matrix it contains in the rows the indexes of the subsets which
have to be extracted. <code>nsamp</code> in this case can be conveniently generated by
function <code>subsets()</code>. <code>nsamp</code> must have <code>k * p</code> columns. The first <code>p</code>
columns are used to estimate the regression coefficient of group 1, ..., the last <code>p</code>
columns are used to estimate the regression coefficient of group <code>k</code>.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_refsteps">refsteps</code></td>
<td>
<p>Number of refining iterations in each subsample. Default is <code>refsteps=10</code>.
<code>refsteps = 0</code> means &quot;raw-subsampling&quot; without iterations.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_reftol">reftol</code></td>
<td>
<p>Tolerance of the refining steps. The default value is 1e-14</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_equalweights">equalweights</code></td>
<td>
<p>A logical specifying wheather cluster weights in the concentration
and assignment steps shall be considered. If <code>equalweights=TRUE</code> we are (ideally)
assuming equally sized groups, else if <code>equalweights = false</code> (default) we allow for
different group weights. Please, check in the given references which functions
are maximized in both cases.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_wtrim">wtrim</code></td>
<td>
<p>How to apply the weights on the observations - a flag taking values in c(0, 1, 2, 3, 4).
</p>

<ul>
<li><p> If <code>wtrim==0</code> (no weights), the algorithm reduces to the standard <code>tclustreg</code> algorithm.
</p>
</li>
<li><p> If <code>wtrim==1</code>, trimming is done by weighting the observations using values specified in vector
<code>we</code>. In this case, vector <code>we</code> must be supplied by the user.
</p>
</li>
<li><p> If <code>wtrim==2</code>, trimming is again done by weighting the observations
using values specified in vector <code>we</code>. In this case, vector <code>we</code>
is computed from the data as a function of the density estimate pdfe.
Specifically, the weight of each observation is the probability of retaining
the observation, computed as
</p>
<p style="text-align: center;"><code class="reqn">pretain_{ig} = 1-pdfe_{ig}/max_{ig}(pdfe_{ig})</code>
</p>

</li>
<li><p> If <code>wtrim==3</code>, trimming is again done by weighting the observations using
values specified in vector <code>we</code>. In this case, each element wei of vector
<code>we</code> is a Bernoulli random variable with probability of success
<code class="reqn">pdfe_{ig}</code>.
In the clustering framework this is done under the constraint that no group is empty.
</p>
</li>
<li><p> If <code>wtrim==4</code>, trimming is done with the tandem approach of Cerioli and Perrotta (2014).
</p>
</li></ul>
</td></tr>
<tr><td><code id="tclustregIC_+3A_we">we</code></td>
<td>
<p>Weights. A vector of size n-by-1 containing application-specific weights
Default is a vector of ones.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_msg">msg</code></td>
<td>
<p>Controls whether to display or not messages on the screen If <code>msg==TRUE</code> (default)
messages are displayed on the screen. If <code>msg=2</code>, detailed messages are displayed,
for example the information at iteration level.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_randnumbfornini">RandNumbForNini</code></td>
<td>
<p>pre-extracted random numbers to initialize proportions.
Matrix of size k-by-nrow(nsamp) containing the random numbers which
are used to initialize the proportions of the groups. This option is effective only if
<code>nsamp</code> is a matrix which contains pre-extracted subsamples. The purpose of this
option is to enable the user to replicate the results when the function <code>tclustreg()</code>
is called using a parfor instruction (as it happens for example in routine IC, where
<code>tclustreg()</code> is called through a parfor for different values of the restriction factor).
The default is that <code>RandNumbForNini</code> is empty - then uniform random numbers are used.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_trace">trace</code></td>
<td>
<p>Whether to print intermediate results. Default is <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="tclustregIC_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code><a href="#topic+tclustreg.object">tclustreg.object</a></code>
</p>


<h3>Author(s)</h3>

<p>FSDA team, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Torti F., Perrotta D., Riani, M. and Cerioli A. (2019). Assessing Robust Methodologies for Clustering Linear Regression Data,
Advances in Data Analysis and Classification, Vol. 13, pp 227-257.
</p>

<hr>
<h2 id='wool'>Wool data.</h2><span id='topic+wool'></span>

<h3>Description</h3>

<p>The wool data give the number of cycles to failure of a worsted yarn under
cycles of repeated loading. The variables are: length of test specimen;
amplitude of loading cycle; load
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wool)
</code></pre>


<h3>Format</h3>

<p>A data frame with 27 rows and 4 variables
</p>

<hr>
<h2 id='X'>Simulated data X.</h2><span id='topic+X'></span>

<h3>Description</h3>

<p>The X dataset has been simulated by Gordaliza, Garcia-Escudero and Mayo-Iscar during the Workshop
ADVANCES IN ROBUST DATA ANALYSIS AND CLUSTERING held in Ispra on October 21st-25th 2013. It is
a bivariate dataset of 200 observations. It presents two parallel components without contamination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(X)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 2 variables
</p>

<hr>
<h2 id='z1'>z1</h2><span id='topic+z1'></span>

<h3>Description</h3>

<p>Simulated data to test tclustIC() and tclustICsol(), carbike() functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(z1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows and 2 variables.
The variables are as follows:
</p>

<ul>
<li><p> X1
</p>
</li>
<li><p> X2
</p>
</li></ul>



<h3>References</h3>

<p>Maitra, R. and Melnykov, V. (2010), Simulating data to study performance
of finite mixture modeling and clustering algorithms, <em>The Journal of
Computational and Graphical Statistics</em>, Vol. 19, pp. 354-376.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(z1)
 head(z1)
 ## Not run: 
 (out &lt;- tclustIC(z1, plots=FALSE, whichIC="CLACLA"))
 (outCLACLA &lt;- tclustICsol(out, whichIC="CLACLA", plot=FALSE))
 carbikeplot(outCLACLA)
 
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
