<!DOCTYPE html><html><head><title>Help for package PSCBS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PSCBS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PSCBS-package'><p>Package PSCBS</p></a></li>
<li><a href='#AbstractCBS'><p>The AbstractCBS class</p></a></li>
<li><a href='#as.CBS.DNAcopy'><p>Coerces a DNAcopy object to a CBS object</p></a></li>
<li><a href='#as.data.frame.AbstractCBS'><p>Gets the table of segments</p></a></li>
<li><a href='#as.data.frame.CBS'><p>Gets the table of segments</p></a></li>
<li><a href='#as.DNAcopy.CBS'><p>Coerces a CBS object to a DNAcopy object</p></a></li>
<li><a href='#bootstrapTCNandDHByRegion.PairedPSCBS'><p>Estimate confidence intervals of TCN and DH segment levels</p></a></li>
<li><a href='#c.CBS'><p>Concatenates segmentation results</p></a></li>
<li><a href='#callAB.PairedPSCBS'><p>Calls segments that are in allelic balance</p></a></li>
<li><a href='#callAllelicBalanceByDH.PairedPSCBS'><p>Calls segments that are in allelic balance</p></a></li>
<li><a href='#callAmplifications.CBS'><p>Calls (focal) amplifications</p></a></li>
<li><a href='#callCopyNeutral.PairedPSCBS'><p>Calls segments that have a neutral total copy number</p></a></li>
<li><a href='#callCopyNeutralByTCNofAB.PairedPSCBS'><p>Calls regions that are copy neutral</p></a></li>
<li><a href='#callGainsAndLosses.CBS'><p>Calls gains and losses</p></a></li>
<li><a href='#callGNL.PairedPSCBS'><p>Calls segments that are gained, copy neutral, or lost</p></a></li>
<li><a href='#callLOH.PairedPSCBS'><p>Calls segments that are in LOH</p></a></li>
<li><a href='#callOutliers.CBS'><p>Calls outliers</p></a></li>
<li><a href='#callROH.PairedPSCBS'><p>Calls segments that are in ROH</p></a></li>
<li><a href='#callSegmentationOutliers'><p>Calls/drops single-locus outliers along the genome</p></a></li>
<li><a href='#CBS'><p>The CBS class</p></a></li>
<li><a href='#dropChangePoints.AbstractCBS'><p>Drops zero or more change points</p></a></li>
<li><a href='#dropRegions.AbstractCBS'><p>Drops chromosomal regions (a connected set of segments)</p></a></li>
<li><a href='#estimateDeltaAB.PairedPSCBS'><p>Estimate a threshold for calling allelic balance from DH</p></a></li>
<li><a href='#estimateDeltaABBySmallDH.PairedPSCBS'><p>Estimate a threshold for calling allelic balance from DH</p></a></li>
<li><a href='#estimateDeltaCN.PairedPSCBS'><p>Estimates the length of one total copy-number (TCN) unit</p></a></li>
<li><a href='#estimateDeltaLOH.PairedPSCBS'><p>Estimate a threshold for calling LOH from DH</p></a></li>
<li><a href='#estimateDeltaLOHByMinC1ForNonAB.PairedPSCBS'><p>Estimate a threshold for calling LOH from DH</p></a></li>
<li><a href='#estimateKappa.PairedPSCBS'><p>Estimate global background in segmented copy numbers</p></a></li>
<li><a href='#estimateKappaByC1Density.PairedPSCBS'><p>Estimate global background in segmented copy numbers</p></a></li>
<li><a href='#estimateStandardDeviation.CBS'><p>Estimates the whole-genome standard deviation of the signals</p></a></li>
<li><a href='#exampleData'><p>Gets an example data set</p></a></li>
<li><a href='#extractMinorMajorCNs.PairedPSCBS'><p>Extract minor and major copy-number mean levels per segment</p></a></li>
<li><a href='#extractSegmentMeansByLocus.CBS'><p>Extracts segments means at each locus</p></a></li>
<li><a href='#extractTCNAndDHs.PairedPSCBS'><p>Extract TCN and DH mean levels per segment</p></a></li>
<li><a href='#findLargeGaps'><p>Identifies gaps of a genome where there exist no observations</p></a></li>
<li><a href='#findNeutralCopyNumberState'><p>Call segments to be copy neutral based on allelic imbalance calls and total copy number estimates</p></a></li>
<li><a href='#gapsToSegments.data.frame'><p>Gets the genomic segments that are complementary to the gaps</p></a></li>
<li><a href='#getBootstrapLocusSets.PairedPSCBS'><p>Generates original and bootstrapped segment-specific index sets</p></a></li>
<li><a href='#getCallStatistics.CBS'><p>Calculates various call statistics per chromosome</p></a></li>
<li><a href='#getChromosomes.AbstractCBS'><p>Gets the set of chromosomes</p></a></li>
<li><a href='#getFractionOfGenomeLost.CBS'><p>Calculates the fraction of the genome lost, gained, or aberrant either way</p></a></li>
<li><a href='#getLocusData.AbstractCBS'><p>Gets the locus-level data</p></a></li>
<li><a href='#getSampleName.AbstractCBS'><p>Gets the name of the sample segmented</p></a></li>
<li><a href='#getSegments.AbstractCBS'><p>Gets the segments</p></a></li>
<li><a href='#getSegments.PSCBS'><p>Gets the segments</p></a></li>
<li><a href='#getSmoothLocusData.CBS'><p>Gets smoothed locus-level data</p></a></li>
<li><a href='#hclustCNs.AbstractCBS'><p>Performs a hierarchical clustering of the CN mean levels</p></a></li>
<li><a href='#installDNAcopy'><p>Install the DNAcopy package</p></a></li>
<li><a href='#joinSegments.CBS'><p>Joins neighboring segments such that there is no gap in between them</p></a></li>
<li><a href='#mergeNonCalledSegments.CBS'><p>Merge neighboring segments that are not called</p></a></li>
<li><a href='#mergeThreeSegments.AbstractCBS'><p>Merge a segment and its two flanking segments</p></a></li>
<li><a href='#mergeTwoSegments.AbstractCBS'><p>Merge two neighboring segments</p></a></li>
<li><a href='#mergeTwoSegments.PairedPSCBS'><p>Merge two neighboring segments</p></a></li>
<li><a href='#nbrOfChangePoints.AbstractCBS'><p>Gets the number of change points</p></a></li>
<li><a href='#nbrOfChromosomes.AbstractCBS'><p>Gets the number of chromosomes</p></a></li>
<li><a href='#nbrOfLoci.AbstractCBS'><p>Gets the number of loci</p></a></li>
<li><a href='#nbrOfSegments.AbstractCBS'><p>Gets the number of segments</p></a></li>
<li><a href='#Non-documented objects'><p>Non-documented objects</p></a></li>
<li><a href='#NonPairedPSCBS'><p>The NonPairedPSCBS class</p></a></li>
<li><a href='#normalizeTotalCNs.AbstractCBS'><p>Normalizes copy numbers such that the whole-genome average total copy number is two</p></a></li>
<li><a href='#PairedPSCBS'><p>The PairedPSCBS class</p></a></li>
<li><a href='#ploidy.AbstractCBS'><p>Gets and sets ploidy</p></a></li>
<li><a href='#plotTracks.AbstractCBS'><p>Plots the segmentation result along the genome</p></a></li>
<li><a href='#plotTracks.CBS'><p>Plots copy numbers along the genome</p></a></li>
<li><a href='#plotTracks1.PairedPSCBS'><p>Plots parental specific copy numbers along the genome</p></a></li>
<li><a href='#pruneByDP.AbstractCBS'><p>Prunes the CN profile using dynamical programming</p></a></li>
<li><a href='#pruneByHClust.AbstractCBS'><p>Prunes the CN profile by pruning and merging through hierarchical clustering</p></a></li>
<li><a href='#pruneBySdUndo.CBS'><p>Prune the CBS profile by dropping change points that are too small</p></a></li>
<li><a href='#PSCBS'><p>The PSCBS class</p></a></li>
<li><a href='#randomSeed'><p>Sets and resets the .Random.seed in the global environment</p></a></li>
<li><a href='#report.AbstractCBS'><p>Generates a report of the segmentation results</p></a></li>
<li><a href='#resetSegments.AbstractCBS'><p>Reset the segments</p></a></li>
<li><a href='#Restructuring AbstractCBS objects'><p>Restructuring AbstractCBS objects</p></a></li>
<li><a href='#segmentByCBS'><p>Segment genomic signals using the CBS method</p></a></li>
<li><a href='#segmentByNonPairedPSCBS'><p>Segment total copy numbers and allele B fractions using the Non-paired PSCBS method</p></a></li>
<li><a href='#segmentByPairedPSCBS'><p>Segment total copy numbers and allele B fractions using the Paired PSCBS method</p></a></li>
<li><a href='#setSampleName.AbstractCBS'><p>Sets the name of the sample segmented</p></a></li>
<li><a href='#testROH.numeric'><p>Tests if a segment is in Run-of-Homozygosity (ROH)</p></a></li>
<li><a href='#updateMeans.AbstractCBS'><p>Updates the CN mean levels for each segment independently</p></a></li>
<li><a href='#updateMeansTogether.AbstractCBS'><p>Updates the CN mean levels jointly in sets of segments</p></a></li>
<li><a href='#weightedQuantile'><p>Weighted Quantile Value</p></a></li>
<li><a href='#writeSegments.CBS'><p>Writes the table of segments to file</p></a></li>
<li><a href='#writeSegments.PSCBS'><p>Writes the table of segments to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.67.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R.methodsS3 (&ge; 1.8.2), R.oo (&ge; 1.25.0), R.utils (&ge; 2.12.0),
R.cache (&ge; 0.16.0), matrixStats (&ge; 0.62.0), aroma.light (&ge;
2.4.0), DNAcopy (&ge; 1.42.0), listenv (&ge; 0.8.0), future (&ge;
1.28.0), parallel, graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp (&ge; 0.45.0), R.devices (&ge; 2.17.1), ggplot2 (&ge; 3.2.1)</td>
</tr>
<tr>
<td>SuggestsNote:</td>
<td>BioC (&gt;= 3.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Parent-Specific DNA Copy Numbers</td>
</tr>
<tr>
<td>Description:</td>
<td>Segmentation of allele-specific DNA copy number data and detection of regions with abnormal copy number within each parental chromosome.  Both tumor-normal paired and tumor-only analyses are supported.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>biocViews:</td>
<td>aCGH, CopyNumberVariants, SNP, Microarray, OneChannel,
TwoChannel, Genetics</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/HenrikBengtsson/PSCBS">https://github.com/HenrikBengtsson/PSCBS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HenrikBengtsson/PSCBS/issues">https://github.com/HenrikBengtsson/PSCBS/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-17 18:25:19 UTC; henrik</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Bengtsson [aut, cre, cph],
  Pierre Neuvial [aut],
  Venkatraman E. Seshan [aut],
  Adam B. Olshen [aut],
  Paul T. Spellman [aut],
  Richard A. Olshen [aut],
  Frank E Harrell Jr [ctb] (Weighted quantile estimator adopted from
    Hmisc::wtd.quantile())</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Bengtsson &lt;henrikb@braju.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-17 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PSCBS-package'>Package PSCBS</h2><span id='topic+PSCBS-package'></span>

<h3>Description</h3>

<p>Segmentation of allele-specific DNA copy number data and detection of regions with abnormal copy number within each parental chromosome.  Both tumor-normal paired and tumor-only analyses are supported..
</p>
<p>This package should be considered to be in an alpha or beta phase.
You should expect the API to be changing over time.
</p>


<h3>Installation and updates</h3>

<p>To install this package, use <code>install.packages("PSCBS")</code>.
</p>


<h3>To get started</h3>

<p>To get started, see:
</p>

<ol>
<li><p> Vignettes '<a href="../doc/index.html">Parent-specific copy-number segmentation using Paired PSCBS</a>' and '<a href="../doc/index.html">Total copy-number segmentation using CBS</a>'.
</p>
</li>
<li> <p><code><a href="#topic+segmentByCBS">segmentByCBS</a></code>() - segments total copy-numbers, or any
other unimodal genomic signals, using the CBS method [3,4].
</p>
</li>
<li> <p><code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>() - segments allele-specific
tumor signal from a tumor <em>with</em> a matched normal
using the Paired PSCBS method [1,2].
</p>
</li>
<li> <p><code><a href="#topic+segmentByNonPairedPSCBS">segmentByNonPairedPSCBS</a></code>() - segments allele-specific
tumor signal from a tumor <em>without</em> a matched normal
using the Non-Paired PSCBS method adopted from [1,2].
</p>
</li></ol>



<h3>How to cite</h3>

<p>Please use [1] and [2] to cite when using Paired PSCBS,
and [3] and [4] when using CBS.
When using Non-Paired PSCBS, please cite [1] and [2] as well.
</p>


<h3>License</h3>

<p>GPL (&gt;= 2).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] A.B. Olshen, H. Bengtsson, P. Neuvial, P.T. Spellman, R.A. Olshen, V.E. Seshan, <em>Parent-specific copy number in paired tumor-normal studies using circular binary segmentation</em>, Bioinformatics, 2011
<br />
[2] H. Bengtsson, P. Neuvial and T.P. Speed, <em>TumorBoost: Normalization of allele-specific tumor copy numbers from a single pair of tumor-normal genotyping microarrays</em>, BMC Bioinformatics, 2010
<br />
[3] A.B. Olshen, E.S. Venkatraman (aka Venkatraman E. Seshan), R. Lucito and M. Wigler, <em>Circular binary segmentation for the analysis of array-based DNA copy number data</em>, Biostatistics, 2004
<br />
[4] E.S. Venkatraman and A.B. Olshen, <em>A faster circular binary segmentation algorithm for the analysis of array CGH data</em>, Bioinformatics, 2007
<br />
</p>

<hr>
<h2 id='AbstractCBS'>The AbstractCBS class</h2><span id='topic+AbstractCBS'></span>

<h3>Description</h3>

<p>Package:  PSCBS <br />
<b>Class AbstractCBS</b><br />
</p>
<p><code>list</code><br />
<code>~~|</code><br />
<code>~~+--</code><em><code>AbstractCBS</code></em><br />
</p>
<p><b>Directly known subclasses:</b><br />
<em><a href="#topic+CBS">CBS</a></em>, <em><a href="#topic+NonPairedPSCBS">NonPairedPSCBS</a></em>, <em><a href="#topic+PSCBS">PSCBS</a></em>, <em><a href="#topic+PairedPSCBS">PairedPSCBS</a></em><br />
</p>
<p>public abstract class <b>AbstractCBS</b><br />
extends list<br />
</p>
<p>All CBS-style segmentation results extend this class, e.g.
<code><a href="#topic+CBS">CBS</a></code> and <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AbstractCBS(fit=list(), sampleName=fit$sampleName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbstractCBS_+3A_fit">fit</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> structure containing the segmentation results.</p>
</td></tr>
<tr><td><code id="AbstractCBS_+3A_samplename">sampleName</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string.</p>
</td></tr>
<tr><td><code id="AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Fields and Methods</h3>

<p><b>Methods:</b><br />
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>adjustPloidyScale</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>extractCNs</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getChangePoints</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getChromosomes</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getLocusData</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getSegmentSizes</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>getSegments</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>mergeThreeSegments</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>nbrOfChangePoints</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>nbrOfChromosomes</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>nbrOfLoci</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>nbrOfSegments</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>normalizeTotalCNs</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>ploidy</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>ploidy&lt;-</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>plotTracks</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>sampleCNs</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>writeWIG</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><b>Methods inherited from list</b>:<br />
Ops,nonStructure,vector-method, Ops,structure,vector-method, Ops,vector,nonStructure-method, Ops,vector,structure-method, all.equal, as.data.frame, attachLocally, callHooks, coerce,ANY,list-method, relist, type.convert, within
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='as.CBS.DNAcopy'>Coerces a DNAcopy object to a CBS object</h2><span id='topic+as.CBS.DNAcopy'></span><span id='topic+DNAcopy.as.CBS'></span><span id='topic+as.CBS+2CDNAcopy-method'></span>

<h3>Description</h3>

<p>Coerces a DNAcopy object to a CBS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DNAcopy'
as.CBS(fit, sample=1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.CBS.DNAcopy_+3A_fit">fit</code></td>
<td>
<p>A <code>DNAcopy</code> object (of the <span class="pkg">DNAcopy</span> package.)</p>
</td></tr>
<tr><td><code id="as.CBS.DNAcopy_+3A_sample">sample</code></td>
<td>
<p>An index specifying which sample to extract,
if more than one exists.</p>
</td></tr>
<tr><td><code id="as.CBS.DNAcopy_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+CBS">CBS</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.DNAcopy.CBS">as.DNAcopy()</a></code>.
For more information see <code>DNAcopy</code>.
</p>

<hr>
<h2 id='as.data.frame.AbstractCBS'>Gets the table of segments</h2><span id='topic+as.data.frame.AbstractCBS'></span><span id='topic+AbstractCBS.as.data.frame'></span><span id='topic+as.data.frame+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Gets the table of segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>, where each row corresponds to
a unique segment.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Utilizes <code><a href="#topic+getSegments.AbstractCBS">*getSegments</a>()</code>.
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>..
</p>

<hr>
<h2 id='as.data.frame.CBS'>Gets the table of segments</h2><span id='topic+as.data.frame.CBS'></span><span id='topic+CBS.as.data.frame'></span><span id='topic+as.data.frame+2CCBS-method'></span>

<h3>Description</h3>

<p>Gets the table of segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>, where each row corresponds to
a unique segment.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Utilizes <code><a href="#topic+getSegments.CBS">*getSegments</a>()</code>.
For more information see <code><a href="#topic+CBS">CBS</a></code>..
</p>

<hr>
<h2 id='as.DNAcopy.CBS'>Coerces a CBS object to a DNAcopy object</h2><span id='topic+as.DNAcopy.CBS'></span><span id='topic+CBS.as.DNAcopy'></span><span id='topic+as.DNAcopy+2CCBS-method'></span>

<h3>Description</h3>

<p>Coerces a CBS object to a DNAcopy object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
as.DNAcopy(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.DNAcopy.CBS_+3A_fit">fit</code></td>
<td>
<p>A <code><a href="#topic+CBS">CBS</a></code> object.&quot;</p>
</td></tr>
<tr><td><code id="as.DNAcopy.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>DNAcopy</code> object (of the <span class="pkg">DNAcopy</span> package).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.CBS.DNAcopy">as.CBS()</a></code>.
For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Simulating copy-number data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
set.seed(0xBEEF)

# Number of loci
J &lt;- 1000

mu &lt;- double(J)
mu[200:300] &lt;- mu[200:300] + 1
mu[350:400] &lt;- NA # centromere
mu[650:800] &lt;- mu[650:800] - 1
eps &lt;- rnorm(J, sd=1/2)
y &lt;- mu + eps
x &lt;- sort(runif(length(y), max=length(y))) * 1e5
w &lt;- runif(J)
w[650:800] &lt;- 0.001


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Segmentation
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fit &lt;- segmentByCBS(y, x=x)
print(fit)
plotTracks(fit)


 
# Coerce an CBS object to a DNAcopy object
fitD &lt;- as.DNAcopy(fit)

# Coerce an DNAcopy object to a CBS object
fitC &lt;- as.CBS(fitD)

# Sanity check
fitD2 &lt;- as.DNAcopy(fit)
stopifnot(all.equal(fitD2, fitD))

fitC2 &lt;- as.CBS(fitD2)
stopifnot(all.equal(fitC2, fitC))

</code></pre>

<hr>
<h2 id='bootstrapTCNandDHByRegion.PairedPSCBS'>Estimate confidence intervals of TCN and DH segment levels</h2><span id='topic+bootstrapTCNandDHByRegion.PairedPSCBS'></span><span id='topic+PairedPSCBS.bootstrapTCNandDHByRegion'></span><span id='topic+bootstrapTCNandDHByRegion+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Estimate confidence intervals of TCN and DH segment levels using bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
bootstrapTCNandDHByRegion(fit, B=1000L, boot=NULL, ..., probs=c(0.025, 0.05, 0.95,
  0.975), statsFcn=NULL, what=c("segment", "changepoint"), force=FALSE, verbose=FALSE,
  .debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_b">B</code></td>
<td>
<p>A positive <code><a href="base.html#topic+integer">integer</a></code> specifying the number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_boot">boot</code></td>
<td>
<p>Alternatively, to generating <code>B</code> bootstrap samples,
this specifies a pre-generated set of bootstrap samples as
returned by <code>bootstrapSegmentsAndChangepoints()</code>.</p>
</td></tr>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>bootstrapSegmentsAndChangepoints()</code>.</p>
</td></tr>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_probs">probs</code></td>
<td>
<p>The default quantiles to be estimated.</p>
</td></tr>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_statsfcn">statsFcn</code></td>
<td>
<p>A (optional) <code><a href="base.html#topic+function">function</a></code> that estimates confidence
intervals given locus-level data.
If <code><a href="base.html#topic+NULL">NULL</a></code>, the <code><a href="stats.html#topic+quantile">quantile</a></code> function is used.</p>
</td></tr>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_what">what</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> <code><a href="base.html#topic+vector">vector</a></code> specifying what to bootstrap.</p>
</td></tr>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_force">force</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, already existing estimates are ignored,
otherwise not.</p>
</td></tr>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
<tr><td><code id="bootstrapTCNandDHByRegion.PairedPSCBS_+3A_.debug">.debug</code></td>
<td>
<p>(internal) If <code><a href="base.html#topic+logical">TRUE</a></code>, additional sanity checks are
performed internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='c.CBS'>Concatenates segmentation results</h2><span id='topic+c.CBS'></span><span id='topic+CBS.c'></span><span id='topic+c+2CCBS-method'></span><span id='topic+c.PSCBS'></span>

<h3>Description</h3>

<p>Concatenates segmentation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
c(..., addSplit=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.CBS_+3A_...">...</code></td>
<td>
<p>One or more <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> objects to be combined.</p>
</td></tr>
<tr><td><code id="c.CBS_+3A_addsplit">addSplit</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, a &quot;divider&quot; is added between chromosomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> object of the same class in ....
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='callAB.PairedPSCBS'>Calls segments that are in allelic balance</h2><span id='topic+callAB.PairedPSCBS'></span><span id='topic+PairedPSCBS.callAB'></span><span id='topic+callAB+2CPairedPSCBS-method'></span><span id='topic+PairedPSCBS.callAllelicBalance'></span><span id='topic+callAllelicBalance.PairedPSCBS'></span><span id='topic+callAllelicBalance+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Calls segments that are in allelic balance, i.e. that have equal minor and major copy numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
callAB(fit, flavor=c("DeltaAB*"), ..., minSize=1, xorCalls=TRUE, force=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callAB.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which type of
call to use.</p>
</td></tr>
<tr><td><code id="callAB.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the caller.</p>
</td></tr>
<tr><td><code id="callAB.PairedPSCBS_+3A_minsize">minSize</code></td>
<td>
<p>An optional <code><a href="base.html#topic+integer">integer</a></code> specifying the minimum number
of data points in order to call a segments.  If fewer data points,
then the call is set to <code><a href="base.html#topic+NA">NA</a></code> regardless.</p>
</td></tr>
<tr><td><code id="callAB.PairedPSCBS_+3A_xorcalls">xorCalls</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, a region already called LOH, will
for consistency never be called AB, resulting in either an AB
call set to <code><a href="base.html#topic+logical">FALSE</a></code> or <code><a href="base.html#topic+NA">NA</a></code> (as explained below).</p>
</td></tr>
<tr><td><code id="callAB.PairedPSCBS_+3A_force">force</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">FALSE</a></code>, and allelic-balance calls already exits,
then nothing is done, otherwise the calls are done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> object with allelic-balance calls.
</p>


<h3>AB and LOH consistency</h3>

<p>Biologically, a segment can not be both in allelic balance (AB) and
in loss-of-heterozygosity (LOH) at the same time.
To avoid reporting such inconsistencies, the LOH caller will,
if argument <code>xorCalls=TRUE</code>, never report a segment to be in
LOH if it is already called to be in AB.
However, regardless of of the AB call, a segment is still always
tested for LOH, to check weather the LOH caller is consistent with the
AB caller or not.  Thus, in order to distinguish the case where
the AB caller and LOH caller agree from when they disagree,
we report either (AB,LOH)=(TRUE,FALSE) or (TRUE,NA).  The former is
reported when they are consistent, and the latter when they are not,
or when the AB caller could not call it.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally, one of the following methods are used:
<code><a href="#topic+callAllelicBalanceByDH.PairedPSCBS">*callAllelicBalanceByDH</a>()</code>.
</p>

<hr>
<h2 id='callAllelicBalanceByDH.PairedPSCBS'>Calls segments that are in allelic balance</h2><span id='topic+callAllelicBalanceByDH.PairedPSCBS'></span><span id='topic+PairedPSCBS.callAllelicBalanceByDH'></span><span id='topic+callAllelicBalanceByDH+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Calls segments that are in allelic balance by thresholding on DH using a predetermined threshold.
The variability of the DH mean levels is taken into account via a
bootstrap estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
callAllelicBalanceByDH(fit, delta=estimateDeltaAB(fit, flavor = "qq(DH)"), alpha=0.05,
  ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callAllelicBalanceByDH.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which type of
call to use.</p>
</td></tr>
<tr><td><code id="callAllelicBalanceByDH.PairedPSCBS_+3A_delta">delta</code></td>
<td>
<p>(Tuning parameter) A non-negative <code><a href="base.html#topic+numeric">numeric</a></code> threshold.</p>
</td></tr>
<tr><td><code id="callAllelicBalanceByDH.PairedPSCBS_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> in [0,1] specifying the upper and lower
quantiles calculated by the bootstrap estimator.</p>
</td></tr>
<tr><td><code id="callAllelicBalanceByDH.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the bootstrap estimator
<code><a href="#topic+bootstrapTCNandDHByRegion.PairedPSCBS">*bootstrapTCNandDHByRegion</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> object with allelic-balance calls.
</p>


<h3>Algorithm</h3>


<ul>
<li><p> Foo
</p>
</li>
<li><p> Bar
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Instead of calling this method explicitly, it is recommended
to use the <code><a href="#topic+callAllelicBalance.PairedPSCBS">*callAllelicBalance</a>()</code> method.
</p>

<hr>
<h2 id='callAmplifications.CBS'>Calls (focal) amplifications</h2><span id='topic+callAmplifications.CBS'></span><span id='topic+CBS.callAmplifications'></span><span id='topic+callAmplifications+2CCBS-method'></span>

<h3>Description</h3>

<p>Calls (focal) amplifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
callAmplifications(fit, adjust=1, maxLength=2e+07, method=c("ucsf-exp"), ...,
  verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callAmplifications.CBS_+3A_adjust">adjust</code></td>
<td>
<p>A positive scale factor adjusting the sensitivity of the
caller, where a value less (greater) than 1.0 makes the caller
less (more) sensitive.</p>
</td></tr>
<tr><td><code id="callAmplifications.CBS_+3A_maxlength">maxLength</code></td>
<td>
<p>A <code><a href="base.html#topic+double">double</a></code> scalar specifying the maximum length of a segment
in order for it to be considered a focal amplification.</p>
</td></tr>
<tr><td><code id="callAmplifications.CBS_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the calling algorithm to use.</p>
</td></tr>
<tr><td><code id="callAmplifications.CBS_+3A_...">...</code></td>
<td>
<p>Additional/optional arguments used to override the default
parameters used by the caller.</p>
</td></tr>
<tr><td><code id="callAmplifications.CBS_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+CBS">CBS</a></code> object where <code><a href="base.html#topic+logical">logical</a></code> column
'amplificationCall' has been appended to the segmentation table.
</p>


<h3>The UCSF caller</h3>

<p>If <code>method == "ucsf-exp"</code>, then segments are called using [1], i.e.
a segment is called an amplification if ...
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] Fridlyand et al. <em>Breast tumor copy number aberration
phenotypes and genomic instability</em>, BMC Cancer, 2006. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callGainsAndLosses.CBS">*callGainsAndLosses</a>()</code>.
<code><a href="#topic+callOutliers.CBS">*callOutliers</a>()</code>.
For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='callCopyNeutral.PairedPSCBS'>Calls segments that have a neutral total copy number</h2><span id='topic+callCopyNeutral.PairedPSCBS'></span><span id='topic+PairedPSCBS.callCopyNeutral'></span><span id='topic+callCopyNeutral+2CPairedPSCBS-method'></span><span id='topic+PairedPSCBS.callNTCN'></span><span id='topic+callNTCN.PairedPSCBS'></span><span id='topic+callNTCN+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Calls segments that have a neutral total copy number (NTCN),
i.e. that have a TCN that corresponds to the ploidy of the genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
callCopyNeutral(fit, flavor=c("TCN|AB"), ..., minSize=1, force=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callCopyNeutral.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which type of
call to use.</p>
</td></tr>
<tr><td><code id="callCopyNeutral.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the caller.</p>
</td></tr>
<tr><td><code id="callCopyNeutral.PairedPSCBS_+3A_minsize">minSize</code></td>
<td>
<p>An optional <code><a href="base.html#topic+integer">integer</a></code> specifying the minimum number
of data points in order to call a segments.  If fewer data points,
then the call is set to <code><a href="base.html#topic+NA">NA</a></code> regardless.</p>
</td></tr>
<tr><td><code id="callCopyNeutral.PairedPSCBS_+3A_force">force</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">FALSE</a></code>, and copy-neutral calls already exits,
then nothing is done, otherwise the calls are done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> object with copy-neutral calls.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally, one of the following methods are used:
<code><a href="#topic+callCopyNeutralByTCNofAB.PairedPSCBS">*callCopyNeutralByTCNofAB</a>()</code>.
</p>

<hr>
<h2 id='callCopyNeutralByTCNofAB.PairedPSCBS'>Calls regions that are copy neutral</h2><span id='topic+callCopyNeutralByTCNofAB.PairedPSCBS'></span><span id='topic+PairedPSCBS.callCopyNeutralByTCNofAB'></span><span id='topic+callCopyNeutralByTCNofAB+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Calls regions that are copy neutral from the total copy numbers (TCNs) of segments
in allelic balance (AB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
callCopyNeutralByTCNofAB(fit, delta=estimateDeltaCN(fit), alpha=0.05, ..., force=FALSE,
  verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callCopyNeutralByTCNofAB.PairedPSCBS_+3A_fit">fit</code></td>
<td>
<p>A PairedPSCBS fit object as returned by
<code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>.</p>
</td></tr>
<tr><td><code id="callCopyNeutralByTCNofAB.PairedPSCBS_+3A_delta">delta</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+double">double</a></code> specifying the width of the
&quot;acceptance&quot; region.
Defaults to half of the distance between two integer TCN states,
i.e. 1/2.  This argument should be shrunken as a function of
the amount of the normal contamination and other background signals.</p>
</td></tr>
<tr><td><code id="callCopyNeutralByTCNofAB.PairedPSCBS_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+double">double</a></code> in [0,0.5] specifying the significance level
of the confidence intervals used.</p>
</td></tr>
<tr><td><code id="callCopyNeutralByTCNofAB.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+calcStatsForCopyNeutralABs.PairedPSCBS">*calcStatsForCopyNeutralABs</a>()</code>.</p>
</td></tr>
<tr><td><code id="callCopyNeutralByTCNofAB.PairedPSCBS_+3A_force">force</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, an already called object is skipped, otherwise not.</p>
</td></tr>
<tr><td><code id="callCopyNeutralByTCNofAB.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>...
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> fit object where a column
with the copy-neutral call.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='callGainsAndLosses.CBS'>Calls gains and losses</h2><span id='topic+callGainsAndLosses.CBS'></span><span id='topic+CBS.callGainsAndLosses'></span><span id='topic+callGainsAndLosses+2CCBS-method'></span>

<h3>Description</h3>

<p>Calls gains and losses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
callGainsAndLosses(fit, adjust=1, method=c("ucsf-mad", "ucsf-dmad"), ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callGainsAndLosses.CBS_+3A_adjust">adjust</code></td>
<td>
<p>A positive scale factor adjusting the sensitivity of the
caller, where a value less (greater) than 1.0 makes the caller
less (more) sensitive.</p>
</td></tr>
<tr><td><code id="callGainsAndLosses.CBS_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the calling algorithm to use.</p>
</td></tr>
<tr><td><code id="callGainsAndLosses.CBS_+3A_...">...</code></td>
<td>
<p>Additional/optional arguments used to override the default
parameters used by the caller.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+CBS">CBS</a></code> object where <code><a href="base.html#topic+logical">logical</a></code> columns
'lossCall' and 'gainCall' have been appended to the segmentation table.
</p>


<h3>The UCSF caller</h3>

<p>If <code>method == "ucsf-mad"</code>, then segments are called using [1], i.e.
a segment is called gained or lost if its segment level is
at least two standard deviations away from the median segment level
on Chr1-22, where standard deviation is estimated using MAD.
Then same is done for <code>method == "ucsf-dmad"</code> with the difference
that the standard deviation is estimated using a robust first order
variance estimator.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] Fridlyand et al. <em>Breast tumor copy number aberration
phenotypes and genomic instability</em>, BMC Cancer, 2006. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callAmplifications.CBS">*callAmplifications</a>()</code>.
<code><a href="#topic+callOutliers.CBS">*callOutliers</a>()</code>.
For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Simulating copy-number data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
set.seed(0xBEEF)

# Number of loci
J &lt;- 1000

mu &lt;- double(J)
mu[200:300] &lt;- mu[200:300] + 1
mu[350:400] &lt;- NA # centromere
mu[650:800] &lt;- mu[650:800] - 1
eps &lt;- rnorm(J, sd=1/2)
y &lt;- mu + eps
x &lt;- sort(runif(length(y), max=length(y))) * 1e5
w &lt;- runif(J)
w[650:800] &lt;- 0.001


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Segmentation
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fit &lt;- segmentByCBS(y, x=x)
print(fit)
plotTracks(fit)


 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CALLS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Call gains and losses by segments
fitC &lt;- callGainsAndLosses(fit)

# Call amplifications by segments
fitC &lt;- callAmplifications(fitC)

# Call outliers by loci
fitC &lt;- callOutliers(fitC)

</code></pre>

<hr>
<h2 id='callGNL.PairedPSCBS'>Calls segments that are gained, copy neutral, or lost</h2><span id='topic+callGNL.PairedPSCBS'></span><span id='topic+PairedPSCBS.callGNL'></span><span id='topic+callGNL+2CPairedPSCBS-method'></span><span id='topic+PairedPSCBS.callGainNeutralLoss'></span><span id='topic+callGainNeutralLoss.PairedPSCBS'></span><span id='topic+callGainNeutralLoss+2CPairedPSCBS-method'></span><span id='topic+callGNLByTCNofAB'></span><span id='topic+PairedPSCBS.callGNLByTCNofAB'></span><span id='topic+callGNLByTCNofAB.PairedPSCBS'></span><span id='topic+callGNLByTCNofAB+2CPairedPSCBS-method'></span><span id='topic+callGNLByTCNofABv1'></span><span id='topic+PairedPSCBS.callGNLByTCNofABv1'></span><span id='topic+callGNLByTCNofABv1.PairedPSCBS'></span><span id='topic+callGNLByTCNofABv1+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Calls segments that are gained, copy neutral, or lost, where copy neutral means having a total copy number
that corresponds to the ploidy of the genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
callGNL(fit, flavor=c("TCN|AB"), ..., minSize=1, force=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callGNL.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which type of
call to use.</p>
</td></tr>
<tr><td><code id="callGNL.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the caller.</p>
</td></tr>
<tr><td><code id="callGNL.PairedPSCBS_+3A_minsize">minSize</code></td>
<td>
<p>An optional <code><a href="base.html#topic+integer">integer</a></code> specifying the minimum number
of data points in order to call a segments.  If fewer data points,
then the call is set to <code><a href="base.html#topic+NA">NA</a></code> regardless.</p>
</td></tr>
<tr><td><code id="callGNL.PairedPSCBS_+3A_force">force</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">FALSE</a></code>, and copy-neutral calls already exits,
then nothing is done, otherwise the calls are done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> object with added calls.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally, one of the following methods are used:
<code>callGNLByTCNofAB()</code>.
</p>

<hr>
<h2 id='callLOH.PairedPSCBS'>Calls segments that are in LOH</h2><span id='topic+callLOH.PairedPSCBS'></span><span id='topic+PairedPSCBS.callLOH'></span><span id='topic+callLOH+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Calls segments that are in LOH, i.e. that have &quot;zero&quot; minor copy number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
callLOH(fit, flavor=c("SmallC1", "LargeDH"), ..., minSize=1, xorCalls=TRUE, force=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callLOH.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which type of
call to use.</p>
</td></tr>
<tr><td><code id="callLOH.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the caller.</p>
</td></tr>
<tr><td><code id="callLOH.PairedPSCBS_+3A_minsize">minSize</code></td>
<td>
<p>An optional <code><a href="base.html#topic+integer">integer</a></code> specifying the minimum number
of data points in order to call a segments.  If fewer data points,
then the call is set to <code><a href="base.html#topic+NA">NA</a></code> regardless.</p>
</td></tr>
<tr><td><code id="callLOH.PairedPSCBS_+3A_xorcalls">xorCalls</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, a region already called AB, will
for consistency never be called LOH, resulting in either an LOH
call set to <code><a href="base.html#topic+logical">FALSE</a></code> or <code><a href="base.html#topic+NA">NA</a></code> (as explained below).</p>
</td></tr>
<tr><td><code id="callLOH.PairedPSCBS_+3A_force">force</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">FALSE</a></code>, and allelic-balance calls already exits,
then nothing is done, otherwise the calls are done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> object with LOH calls.
</p>


<h3>AB and LOH consistency</h3>

<p>Biologically, a segment can not be both in allelic balance (AB) and
in loss-of-heterozygosity (LOH) at the same time.
To avoid reporting such inconsistencies, the LOH caller will,
if argument <code>xorCalls=TRUE</code>, never report a segment to be in
LOH if it is already called to be in AB.
However, regardless of of the AB call, a segment is still always
tested for LOH, to check weather the LOH caller is consistent with the
AB caller or not.  Thus, in order to distinguish the case where
the AB caller and LOH caller agree from when they disagree,
we report either (AB,LOH)=(TRUE,FALSE) or (TRUE,NA).  The former is
reported when they are consistent, and the latter when they are not,
or when the LOH caller could not call it.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally, one of the following methods are used:
<code><a href="#topic+callLowC1ByC1.PairedPSCBS">*callLowC1ByC1</a>()</code>,
<code><a href="#topic+callExtremeAllelicImbalanceByDH.PairedPSCBS">*callExtremeAllelicImbalanceByDH</a>()</code>.
</p>

<hr>
<h2 id='callOutliers.CBS'>Calls outliers</h2><span id='topic+callOutliers.CBS'></span><span id='topic+CBS.callOutliers'></span><span id='topic+callOutliers+2CCBS-method'></span>

<h3>Description</h3>

<p>Calls outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
callOutliers(fit, adjust=1, method=c("ucsf-mad"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callOutliers.CBS_+3A_adjust">adjust</code></td>
<td>
<p>A positive scale factor adjusting the sensitivity of the
caller, where a value less (greater) than 1.0 makes the caller
less (more) sensitive.</p>
</td></tr>
<tr><td><code id="callOutliers.CBS_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the calling algorithm to use.</p>
</td></tr>
<tr><td><code id="callOutliers.CBS_+3A_...">...</code></td>
<td>
<p>Additional/optional arguments used to override the default
parameters used by the caller.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+CBS">CBS</a></code> object where <code><a href="base.html#topic+logical">logical</a></code> columns
'negOutlierCall' and 'posOutlierCall' have been appended
to the segmentation table.
</p>


<h3>The UCSF caller</h3>

<p>If <code>method == "ucsf-mad"</code>, then loci are called using [1]
&quot;Finally, to identify single technical or biological outliers such
as high level amplifications, the presence of the outliers within
a segment was allowed by assigning the original observed log2ratio
to the clones for which the observed values were more than four
tumor-specific MAD away from the smoothed values.&quot; [1; Suppl. Mat.]
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] Fridlyand et al. <em>Breast tumor copy number aberration
phenotypes and genomic instability</em>, BMC Cancer, 2006. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callGainsAndLosses.CBS">*callGainsAndLosses</a>()</code>.
<code><a href="#topic+callAmplifications.CBS">*callAmplifications</a>()</code>.
For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='callROH.PairedPSCBS'>Calls segments that are in ROH</h2><span id='topic+callROH.PairedPSCBS'></span><span id='topic+PairedPSCBS.callROH'></span><span id='topic+callROH+2CPairedPSCBS-method'></span><span id='topic+callROH.NonPairedPSCBS'></span>

<h3>Description</h3>

<p>Calls segments that are in ROH, i.e. that have no (true) heterozygous genotypes.
Run of homozygosity (ROH) is a property of the normal (germline) sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
callROH(fit, ..., updateMeans=TRUE, force=FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callROH.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+testROH">testROH</a></code>().</p>
</td></tr>
<tr><td><code id="callROH.PairedPSCBS_+3A_updatemeans">updateMeans</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, DH and (C1,C2) mean levels are set
to <code><a href="base.html#topic+NA">NA</a></code> for segments called ROH, otherwise not.</p>
</td></tr>
<tr><td><code id="callROH.PairedPSCBS_+3A_force">force</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">FALSE</a></code>, and ROH calls already exits,
then nothing is done, otherwise the calls are done.</p>
</td></tr>
<tr><td><code id="callROH.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> object with ROH calls.
</p>


<h3>Author(s)</h3>

<p>Pierre Neuvial, Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally, <code><a href="#topic+testROH">testROH</a></code>() is used.
To call allelic balance (AB) see <code><a href="#topic+callAB.PairedPSCBS">*callAB</a>()</code>.
To call loss of heterozygosity (LOH) see <code><a href="#topic+callLOH.PairedPSCBS">*callLOH</a>()</code>.
</p>

<hr>
<h2 id='callSegmentationOutliers'>Calls/drops single-locus outliers along the genome</h2><span id='topic+callSegmentationOutliers'></span><span id='topic+callSegmentationOutliers.default'></span><span id='topic+callSegmentationOutliers.data.frame'></span><span id='topic+dropSegmentationOutliers'></span><span id='topic+dropSegmentationOutliers.default'></span><span id='topic+dropSegmentationOutliers.data.frame'></span>

<h3>Description</h3>

<p>Calls/drops single-locus outliers along the genome that have a signal that differ significantly from the
neighboring loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## Default S3 method:
callSegmentationOutliers(y, chromosome=0, x=NULL, method="DNAcopy::smooth.CNA", ...,
  verbose=FALSE)
 ## S3 method for class 'data.frame'
callSegmentationOutliers(y, ...)
 ## Default S3 method:
dropSegmentationOutliers(y, ...)
 ## S3 method for class 'data.frame'
dropSegmentationOutliers(y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callSegmentationOutliers_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J genomic signals to be segmented.</p>
</td></tr>
<tr><td><code id="callSegmentationOutliers_+3A_chromosome">chromosome</code></td>
<td>
<p>(Optional) An <code><a href="base.html#topic+integer">integer</a></code> scalar
(or a <code><a href="base.html#topic+vector">vector</a></code> of length J contain a unique value).
Only used for annotation purposes.</p>
</td></tr>
<tr><td><code id="callSegmentationOutliers_+3A_x">x</code></td>
<td>
<p>Optional <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J genomic locations.
If <code><a href="base.html#topic+NULL">NULL</a></code>, index locations <code>1:J</code> are used.</p>
</td></tr>
<tr><td><code id="callSegmentationOutliers_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the method
used for calling outliers.</p>
</td></tr>
<tr><td><code id="callSegmentationOutliers_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to internal outlier
detection method.</p>
</td></tr>
<tr><td><code id="callSegmentationOutliers_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>callSegmentationOutliers()</code> returns a <code><a href="base.html#topic+logical">logical</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length J.
<code>dropSegmentationOutliers()</code> returns an object of the same type
as argument <code>y</code>, where the signals for which outliers were called
have been set to <code><a href="base.html#topic+NA">NA</a></code>.
</p>


<h3>Missing and non-finite values</h3>

<p>Signals as well as genomic positions may contain missing
values, i.e. <code><a href="base.html#topic+NA">NA</a></code>s or <code><a href="base.html#topic+is.finite">NaN</a></code>s.  By definition, these cannot
be outliers.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally <code><a href="DNAcopy.html#topic+smooth.CNA">smooth.CNA</a></code> is utilized to identify
the outliers.
</p>

<hr>
<h2 id='CBS'>The CBS class</h2><span id='topic+CBS'></span>

<h3>Description</h3>

<p>A CBS object holds results from the
Circular Binary Segmentation (CBS) method
for <em>one</em> sample for one or more chromosomes.
</p>
<p>Package:  PSCBS <br />
<b>Class CBS</b><br />
</p>
<p><code>list</code><br />
<code>~~|</code><br />
<code>~~+--</code><code><a href="#topic+AbstractCBS">AbstractCBS</a></code><br />
<code>~~~~~~~|</code><br />
<code>~~~~~~~+--</code><em><code>CBS</code></em><br />
</p>
<p><b>Directly known subclasses:</b><br />
<br />
</p>
<p>public abstract class <b>CBS</b><br />
extends <em><a href="#topic+AbstractCBS">AbstractCBS</a></em><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBS(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to the constructor of <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.</p>
</td></tr>
</table>


<h3>Fields and Methods</h3>

<p><b>Methods:</b><br />
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>as</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>c</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>estimateStandardDeviation</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>plotTracks</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>pruneBySdUndo</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>segmentByCBS</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>seqOfSegmentsByDP</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>writeSegments</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><b>Methods inherited from AbstractCBS</b>:<br />
adjustPloidyScale, all.equal, as.data.frame, clearCalls, drawChangePoints, drawKnownSegments, dropChangePoint, dropChangePoints, dropRegion, dropRegions, extractCNs, extractChromosome, extractChromosomes, extractRegions, extractSegments, extractWIG, getChangePoints, getChromosomeOffsets, getChromosomeRanges, getChromosomes, getLocusData, getLocusSignalNames, getMeanEstimators, getSampleName, getSegmentSizes, getSegmentTrackPrefixes, getSegments, mergeThreeSegments, mergeTwoSegments, nbrOfChangePoints, nbrOfChromosomes, nbrOfLoci, nbrOfSegments, normalizeTotalCNs, ploidy, ploidy&lt;-, plotTracks, print, pruneByDP, pruneByHClust, renameChromosomes, report, resegment, resetSegments, sampleCNs, sampleName, sampleName&lt;-, seqOfSegmentsByDP, setLocusData, setMeanEstimators, setPloidy, setSampleName, setSegments, shiftTCN, tileChromosomes, updateMeans, writeWIG
</p>
<p><b>Methods inherited from list</b>:<br />
Ops,nonStructure,vector-method, Ops,structure,vector-method, Ops,vector,nonStructure-method, Ops,vector,structure-method, all.equal, as.data.frame, attachLocally, callHooks, coerce,ANY,list-method, relist, type.convert, within
</p>


<h3>Difference to DNAcopy object</h3>

<p>A CBS object is similar to DNAcopy objects with the major
difference that a CBS object holds only one sample, whereas
a DNAcopy object can hold more than one sample.
</p>


<h3>See also</h3>

<p>The <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>() method returns an object of this class.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='dropChangePoints.AbstractCBS'>Drops zero or more change points</h2><span id='topic+dropChangePoints.AbstractCBS'></span><span id='topic+AbstractCBS.dropChangePoints'></span><span id='topic+dropChangePoints+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Drops zero or more change points, which is done by dropping one change point at the
time using <code><a href="#topic+dropChangePoint.AbstractCBS">*dropChangePoint</a>()</code>
and recalculating the segment statistics at the end.
</p>
<p><em>NOTE: This method only works if there is only one chromosome.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
dropChangePoints(fit, idxs, update=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropChangePoints.AbstractCBS_+3A_idxs">idxs</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> specifying the change points to be dropped.</p>
</td></tr>
<tr><td><code id="dropChangePoints.AbstractCBS_+3A_update">update</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, segment statistics are updated.</p>
</td></tr>
<tr><td><code id="dropChangePoints.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+dropChangePoint.AbstractCBS">*dropChangePoint</a>()</code>
and <code><a href="#topic+updateMeans.AbstractCBS">*updateMeans</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> of the same class with
<code>length(idxs)</code> segments.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='dropRegions.AbstractCBS'>Drops chromosomal regions (a connected set of segments)</h2><span id='topic+dropRegions.AbstractCBS'></span><span id='topic+AbstractCBS.dropRegions'></span><span id='topic+dropRegions+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.dropRegion'></span><span id='topic+dropRegion.AbstractCBS'></span><span id='topic+dropRegion+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Drops chromosomal regions (a connected set of segments) each of a certain size (number of segments).
<em>None of the statistics are recalculated</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
dropRegions(this, regions, H=1, ..., asMissing=FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropRegions.AbstractCBS_+3A_regions">regions</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length R specifying the indices
of the left most segment in each of the R regions to be dropped.</p>
</td></tr>
<tr><td><code id="dropRegions.AbstractCBS_+3A_h">H</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+integer">integer</a></code> specifying the size of each region,
i.e. the number of segments per region.</p>
</td></tr>
<tr><td><code id="dropRegions.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+extractRegions.AbstractCBS">*extractRegions</a>()</code>.</p>
</td></tr>
<tr><td><code id="dropRegions.AbstractCBS_+3A_asmissing">asMissing</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, dropped segments are replaced by missing values,
otherwise they are truly dropped.</p>
</td></tr>
<tr><td><code id="dropRegions.AbstractCBS_+3A_verbose">verbose</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> or a <code><a href="R.utils.html#topic+Verbose">Verbose</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> object of the same class with (at most)
R*H segments dropped.
If some regions overlap (share segments), then fewer than R*H segments
are dropped.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally <code><a href="#topic+extractRegions.AbstractCBS">*extractRegions</a>()</code> is used.
See also <code><a href="#topic+dropChangePoint.AbstractCBS">*dropChangePoint</a>()</code> and <code><a href="#topic+mergeTwoSegments.AbstractCBS">*mergeTwoSegments</a>()</code>.
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='estimateDeltaAB.PairedPSCBS'>Estimate a threshold for calling allelic balance from DH</h2><span id='topic+estimateDeltaAB.PairedPSCBS'></span><span id='topic+PairedPSCBS.estimateDeltaAB'></span><span id='topic+estimateDeltaAB+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Estimate a threshold for calling allelic balance from DH to be used by the <code><a href="#topic+callAB.PairedPSCBS">*callAB</a>()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
estimateDeltaAB(this, scale=NULL, flavor=c("qq(DH)", "q(DH)", "mad(hBAF)", "median(DH)"),
  ..., max=Inf, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateDeltaAB.PairedPSCBS_+3A_scale">scale</code></td>
<td>
<p>An optional <code><a href="base.html#topic+numeric">numeric</a></code> scale factor.</p>
</td></tr>
<tr><td><code id="estimateDeltaAB.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which type of
estimator to use.</p>
</td></tr>
<tr><td><code id="estimateDeltaAB.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the estimator.</p>
</td></tr>
<tr><td><code id="estimateDeltaAB.PairedPSCBS_+3A_max">max</code></td>
<td>
<p>(Optional) The maximum estimate allowed. If greater than
this value, the estimate will be truncated.</p>
</td></tr>
<tr><td><code id="estimateDeltaAB.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the threshold estimate as a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally, one of the following methods are used:
<code><a href="#topic+estimateDeltaABBySmallDH.PairedPSCBS">*estimateDeltaABBySmallDH</a>()</code>,
<code><a href="#topic+estimateStdDevForHeterozygousBAF.PairedPSCBS">*estimateStdDevForHeterozygousBAF</a>()</code>,
<code><a href="#topic+estimateMeanForDH.PairedPSCBS">*estimateMeanForDH</a>()</code>, and
<code><a href="#topic+estimateHighDHQuantileAtAB.PairedPSCBS">*estimateHighDHQuantileAtAB</a>()</code>.
</p>

<hr>
<h2 id='estimateDeltaABBySmallDH.PairedPSCBS'>Estimate a threshold for calling allelic balance from DH</h2><span id='topic+estimateDeltaABBySmallDH.PairedPSCBS'></span><span id='topic+PairedPSCBS.estimateDeltaABBySmallDH'></span><span id='topic+estimateDeltaABBySmallDH+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Estimate a threshold for calling allelic balance from DH.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
estimateDeltaABBySmallDH(fit, q1=0.05, q2=0.9, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateDeltaABBySmallDH.PairedPSCBS_+3A_q1">q1</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value specifying the weighted quantile of the
segment-level DHs used to identify segments with small DH means.</p>
</td></tr>
<tr><td><code id="estimateDeltaABBySmallDH.PairedPSCBS_+3A_q2">q2</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value specifying the quantile of the locus-level
DH signals for those segments with small DH mean levels.</p>
</td></tr>
<tr><td><code id="estimateDeltaABBySmallDH.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="estimateDeltaABBySmallDH.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the threshold estimate as a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>


<h3>Algorithm</h3>


<ul>
<li><p> Grabs the segment-level DH estimates.
</p>
</li>
<li><p> Calculate segment weights proportional to the number
of heterozygous SNPs.
</p>
</li>
<li><p> Calculate <code class="reqn">\Delta</code> as the 5% quantile of the weighted DH means.
</p>
</li>
<li><p> Choose the segments with means less than <code class="reqn">\Delta</code>.
</p>
</li>
<li><p> Calculate threshold <code class="reqn">\Delta_{AB}</code> as the 90% &quot;symmetric&quot; quantile
of the observed locus-level DHs from the selected segments
in Step 4.
The q:th &quot;symmetric&quot; quantile is estimated by estimating
the ((1-q), 50%) quantiles, calculating their distance as
&quot;50%-(1-q)&quot; and add to the median (50%), i.e.
&quot;median + (median-(1-q))&quot; = &quot;2*median-1 + q&quot;, which should
equal q if the distribution is symmetric.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Instead of calling this method explicitly, it is recommended
to use the <code><a href="#topic+estimateDeltaAB.PairedPSCBS">*estimateDeltaAB</a>()</code> method.
</p>

<hr>
<h2 id='estimateDeltaCN.PairedPSCBS'>Estimates the length of one total copy-number (TCN) unit</h2><span id='topic+estimateDeltaCN.PairedPSCBS'></span><span id='topic+PairedPSCBS.estimateDeltaCN'></span><span id='topic+estimateDeltaCN+2CPairedPSCBS-method'></span><span id='topic+estimateDeltaCN'></span><span id='topic+estimateDeltaCN.CBS'></span>

<h3>Description</h3>

<p>Estimates the length of one total copy-number (TCN) unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
estimateDeltaCN(fit, scale=1, flavor=c("1-kappa", "delta(mode)"),
  kappa=estimateKappa(fit), adjust=0.2, quantile=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateDeltaCN.PairedPSCBS_+3A_scale">scale</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> scale factor in (0,Inf) used for rescaling
(multiplying) the final estimate with.</p>
</td></tr>
<tr><td><code id="estimateDeltaCN.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>Specifies which type of estimator should be used.</p>
</td></tr>
<tr><td><code id="estimateDeltaCN.PairedPSCBS_+3A_kappa">kappa</code></td>
<td>
<p>Estimate of background signal (used by the <code>"1-kappa"</code> method).</p>
</td></tr>
<tr><td><code id="estimateDeltaCN.PairedPSCBS_+3A_adjust">adjust</code>, <code id="estimateDeltaCN.PairedPSCBS_+3A_quantile">quantile</code></td>
<td>
<p>Tuning parameters (used by the <code>"delta(mode)"</code> method).</p>
</td></tr>
<tr><td><code id="estimateDeltaCN.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For parent-specific copy-number (PSCN) data, the TCN unit length is
estimated as <code class="reqn">(1-kappa)/2</code>, where <code class="reqn">kappa</code> is estimated from
data (by <code><a href="#topic+estimateKappa">estimateKappa</a></code>).
</p>
<p>For total copy-number (TCN) data (only),
</p>


<h3>Value</h3>

<p>Returns a positive scalar <code><a href="base.html#topic+numeric">numeric</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code>.
</p>

<hr>
<h2 id='estimateDeltaLOH.PairedPSCBS'>Estimate a threshold for calling LOH from DH</h2><span id='topic+estimateDeltaLOH.PairedPSCBS'></span><span id='topic+PairedPSCBS.estimateDeltaLOH'></span><span id='topic+estimateDeltaLOH+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Estimate a threshold for calling LOH from DH to be used by the <code><a href="#topic+callLOH.PairedPSCBS">*callLOH</a>()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
estimateDeltaLOH(this, flavor=c("minC1|nonAB"), ..., max=Inf, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateDeltaLOH.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which type of
estimator to use.</p>
</td></tr>
<tr><td><code id="estimateDeltaLOH.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the estimator.</p>
</td></tr>
<tr><td><code id="estimateDeltaLOH.PairedPSCBS_+3A_max">max</code></td>
<td>
<p>(Optional) The maximum estimate allowed. If greater than
this value, the estimate will be truncated.</p>
</td></tr>
<tr><td><code id="estimateDeltaLOH.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the threshold estimate as a <code><a href="base.html#topic+numeric">numeric</a></code> scalar or -<code><a href="base.html#topic+is.finite">Inf</a></code>.
In case it is not possible to estimate the LOH threshold, then
-<code><a href="base.html#topic+is.finite">Inf</a></code> is returned.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally, one of the following methods are used:
<code><a href="#topic+estimateDeltaLOHByMinC1ForNonAB.PairedPSCBS">*estimateDeltaLOHByMinC1ForNonAB</a>()</code>.
</p>

<hr>
<h2 id='estimateDeltaLOHByMinC1ForNonAB.PairedPSCBS'>Estimate a threshold for calling LOH from DH</h2><span id='topic+estimateDeltaLOHByMinC1ForNonAB.PairedPSCBS'></span><span id='topic+PairedPSCBS.estimateDeltaLOHByMinC1ForNonAB'></span><span id='topic+estimateDeltaLOHByMinC1ForNonAB+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Estimate a threshold for calling LOH from DH based on the location of guessed C1=0 and C1=1 peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
estimateDeltaLOHByMinC1ForNonAB(this, midpoint=1/2, maxC=3 * (ploidy(this)/2), ...,
  verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateDeltaLOHByMinC1ForNonAB.PairedPSCBS_+3A_midpoint">midpoint</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> scalar in [0,1] specifying the relative
position of the midpoint between the estimated locations of
C1=0 and C1=1 mean parameters.</p>
</td></tr>
<tr><td><code id="estimateDeltaLOHByMinC1ForNonAB.PairedPSCBS_+3A_maxc">maxC</code></td>
<td>
<p>Maximum total copy number of a segment in order to
be included in the initial set of segments.</p>
</td></tr>
<tr><td><code id="estimateDeltaLOHByMinC1ForNonAB.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="estimateDeltaLOHByMinC1ForNonAB.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method requires that calls for allelic balances already have
been me made, cf. <code><a href="#topic+callAllelicBalance.PairedPSCBS">*callAllelicBalance</a>()</code>.
</p>


<h3>Value</h3>

<p>Returns the estimated LOH threshold as a <code><a href="base.html#topic+numeric">numeric</a></code> scalar or -<code><a href="base.html#topic+is.finite">Inf</a></code>.
In case it is not possible to estimate the LOH threshold, then
-<code><a href="base.html#topic+is.finite">Inf</a></code> is returned.
</p>


<h3>Algorithm</h3>


<ul>
<li><p> Grabs the segment-level C1 estimates.
</p>
</li>
<li><p> Calculate segment weights proportional to the number of heterozygous SNPs.
</p>
</li>
<li><p> Estimate the C1=1 location as the weighted median C1 for segments that have been called to be in allelic balance.
</p>
</li>
<li><p> Estimate the C1=0 location as the smallest C1 among segments that are not in allelic balance.
</p>
</li>
<li><p> Let the LOH threshold be the midpoint of the estimates C1=0 and C1=1 locations.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Instead of calling this method explicitly, it is recommended
to use the <code><a href="#topic+estimateDeltaLOH.PairedPSCBS">*estimateDeltaLOH</a>()</code> method.
</p>

<hr>
<h2 id='estimateKappa.PairedPSCBS'>Estimate global background in segmented copy numbers</h2><span id='topic+estimateKappa.PairedPSCBS'></span><span id='topic+PairedPSCBS.estimateKappa'></span><span id='topic+estimateKappa+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Estimate global background in segmented copy numbers.
The global background, here called <code class="reqn">\kappa</code>,
may have multiple origins where normal contamination is one,
but not necessarily the only one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
estimateKappa(this, flavor=c("density(C1)"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateKappa.PairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying which type of
estimator to use.</p>
</td></tr>
<tr><td><code id="estimateKappa.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the estimator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the background estimate as a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally, one of the following methods are used:
<code><a href="#topic+estimateKappaByC1Density.PairedPSCBS">*estimateKappaByC1Density</a>()</code>.
</p>

<hr>
<h2 id='estimateKappaByC1Density.PairedPSCBS'>Estimate global background in segmented copy numbers</h2><span id='topic+estimateKappaByC1Density.PairedPSCBS'></span><span id='topic+PairedPSCBS.estimateKappaByC1Density'></span><span id='topic+estimateKappaByC1Density+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Estimate global background in segmented copy numbers based on the location of peaks in a weighted
density estimator of the minor copy number mean levels.
</p>
<p>The global background, here called <code class="reqn">\kappa</code>,
may have multiple origins where normal contamination is one,
but not necessarily the only one.
</p>
<p><em>Assumptions:</em>  This estimator assumes that there are segments
with C1=0 and C1=1, i.e. some deletions and, typically, some normal
segements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
estimateKappaByC1Density(this, typeOfWeights=c("dhNbrOfLoci", "sqrt(dhNbrOfLoci)"),
  adjust=1, from=0, minDensity=0.2, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateKappaByC1Density.PairedPSCBS_+3A_typeofweights">typeOfWeights</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying how weights
are calculated.</p>
</td></tr>
<tr><td><code id="estimateKappaByC1Density.PairedPSCBS_+3A_adjust">adjust</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> scale factor specifying the size of
the bandwidth parameter used by the density estimator.</p>
</td></tr>
<tr><td><code id="estimateKappaByC1Density.PairedPSCBS_+3A_from">from</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> scalar specifying the lower bound for the
support of the estimated density.</p>
</td></tr>
<tr><td><code id="estimateKappaByC1Density.PairedPSCBS_+3A_mindensity">minDensity</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+numeric">numeric</a></code> threshold specifying
the minimum density a peak should have in order to consider
it a peak.</p>
</td></tr>
<tr><td><code id="estimateKappaByC1Density.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="estimateKappaByC1Density.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the background estimate as a <code><a href="base.html#topic+numeric">numeric</a></code> scalar.
</p>


<h3>Algorithm</h3>


<ul>
<li><p> Retrieve segment-level minor copy numbers and corresponding weights:
</p>

<ol>
<li><p> Grabs the segment-level C1 estimates.
</p>
</li>
<li><p> Calculate segment weights.
The default (<code>typeOfWeights="dhNbrOfLoci"</code>) is to use
weights proportional to the number of heterozygous SNPs.
An alternative (<code>typeOfWeights="sqrt(dhNbrOfLoci)"</code>) is
to use the square root of those counts.
</p>
</li></ol>

</li>
<li><p> Identify subset of regions with C1=0:
</p>

<ol>
<li><p> Estimates the weighted empirical density function
(truncated at zero below).  Tuning parameter 'adjust'.
</p>
</li>
<li><p> Find the first two peaks
(with a density greater than tuning parameter 'minDensity').
</p>
</li>
<li><p> Assumes that the two peaks corresponds to C1=0 and C1=1.
</p>
</li>
<li><p> Defines threshold Delta0.5 as the center location between
these two peaks.
</p>
</li></ol>

</li>
<li><p> Estimate the global background signal:
</p>

<ol>
<li><p> For all segments with C1 &lt; Delta0.5, calculate the weighted
median of their C1:s.
</p>
</li>
<li><p> Let kappa be the above weighted median.
This is the estimated background.
</p>
</li></ol>

</li></ul>



<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Instead of calling this method explicitly, it is recommended
to use the <code><a href="#topic+estimateKappa.PairedPSCBS">*estimateKappa</a>()</code> method.
</p>

<hr>
<h2 id='estimateStandardDeviation.CBS'>Estimates the whole-genome standard deviation of the signals</h2><span id='topic+estimateStandardDeviation.CBS'></span><span id='topic+CBS.estimateStandardDeviation'></span><span id='topic+estimateStandardDeviation+2CCBS-method'></span>

<h3>Description</h3>

<p>Estimates the whole-genome standard deviation of the signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
estimateStandardDeviation(fit, chromosomes=NULL, method=c("diff", "res", "abs",
  "DNAcopy"), estimator=c("mad", "sd"), na.rm=TRUE, weights=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateStandardDeviation.CBS_+3A_chromosomes">chromosomes</code></td>
<td>
<p>An optional <code><a href="base.html#topic+vector">vector</a></code> specifying the subset of
chromosomes used for the estimate.  If <code><a href="base.html#topic+NULL">NULL</a></code>, all chromosomes are used.</p>
</td></tr>
<tr><td><code id="estimateStandardDeviation.CBS_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the method used.</p>
</td></tr>
<tr><td><code id="estimateStandardDeviation.CBS_+3A_estimator">estimator</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string or a <code><a href="base.html#topic+function">function</a></code> specifying the
internal estimator.</p>
</td></tr>
<tr><td><code id="estimateStandardDeviation.CBS_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, missing values are dropped, otherwise not.</p>
</td></tr>
<tr><td><code id="estimateStandardDeviation.CBS_+3A_weights">weights</code></td>
<td>
<p>An optional <code><a href="base.html#topic+double">double</a></code> <code><a href="base.html#topic+vector">vector</a></code> of <code>nbrOfLoci()</code>
non-negative weights.</p>
</td></tr>
<tr><td><code id="estimateStandardDeviation.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a non-negative <code><a href="base.html#topic+numeric">numeric</a></code> scale.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='exampleData'>Gets an example data set</h2><span id='topic+exampleData.default'></span><span id='topic+exampleData'></span>

<h3>Description</h3>

<p>Gets an example data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
exampleData(name=c("paired.chr01"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exampleData_+3A_name">name</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the name of the data set.</p>
</td></tr>
<tr><td><code id="exampleData_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='extractMinorMajorCNs.PairedPSCBS'>Extract minor and major copy-number mean levels per segment</h2><span id='topic+extractMinorMajorCNs.PairedPSCBS'></span><span id='topic+PairedPSCBS.extractMinorMajorCNs'></span><span id='topic+extractMinorMajorCNs+2CPairedPSCBS-method'></span><span id='topic+PairedPSCBS.extractC1C2'></span><span id='topic+extractC1C2.PairedPSCBS'></span><span id='topic+extractC1C2+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Extract minor and major copy-number mean levels per segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
extractMinorMajorCNs(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractMinorMajorCNs.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+extractTCNAndDHs.PairedPSCBS">*extractTCNAndDHs</a>()</code>
For more information see <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code>.
</p>

<hr>
<h2 id='extractSegmentMeansByLocus.CBS'>Extracts segments means at each locus</h2><span id='topic+extractSegmentMeansByLocus.CBS'></span><span id='topic+CBS.extractSegmentMeansByLocus'></span><span id='topic+extractSegmentMeansByLocus+2CCBS-method'></span>

<h3>Description</h3>

<p>Extracts segments means at each locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
extractSegmentMeansByLocus(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractSegmentMeansByLocus.CBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+getLocusData.CBS">*getLocusData</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length <code>nbrOfLoci()</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='extractTCNAndDHs.PairedPSCBS'>Extract TCN and DH mean levels per segment</h2><span id='topic+extractTCNAndDHs.PairedPSCBS'></span><span id='topic+PairedPSCBS.extractTCNAndDHs'></span><span id='topic+extractTCNAndDHs+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Extract TCN and DH mean levels per segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
extractTCNAndDHs(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractTCNAndDHs.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>getSegments()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+extractMinorMajorCNs.PairedPSCBS">*extractMinorMajorCNs</a>()</code>.
For more information see <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code>.
</p>

<hr>
<h2 id='findLargeGaps'>Identifies gaps of a genome where there exist no observations</h2><span id='topic+findLargeGaps.default'></span><span id='topic+findLargeGaps'></span><span id='topic+findLargeGaps.data.frame'></span>

<h3>Description</h3>

<p>Identifies gaps of a genome where there exist no observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
findLargeGaps(chromosome=NULL, x, minLength, resolution=1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findLargeGaps_+3A_chromosome">chromosome</code></td>
<td>
<p>(Optional) An <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length J of
chromosome indices.</p>
</td></tr>
<tr><td><code id="findLargeGaps_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J of genomic locations.</p>
</td></tr>
<tr><td><code id="findLargeGaps_+3A_minlength">minLength</code></td>
<td>
<p>A positive <code><a href="base.html#topic+numeric">numeric</a></code> scalar specifying the minimum
length of a gap.</p>
</td></tr>
<tr><td><code id="findLargeGaps_+3A_resolution">resolution</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+numeric">numeric</a></code> specifying the minimum
length unit, which by default equals one nucleotide/base pair.</p>
</td></tr>
<tr><td><code id="findLargeGaps_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code><a href="base.html#topic+data.frame">data.frame</a></code> zero or more rows and with columns
<code>chromosome</code> (if given), <code>start</code>, <code>stop</code>,
and <code>length</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+gapsToSegments">gapsToSegments</a></code>() to turn the set of identified gaps into
the complementary set of segments such that they can be passed
to <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>(), <code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>() and
<code><a href="#topic+segmentByNonPairedPSCBS">segmentByNonPairedPSCBS</a></code>() via argument <code>knownSegments</code>.
</p>

<hr>
<h2 id='findNeutralCopyNumberState'>Call segments to be copy neutral based on allelic imbalance calls and total copy number estimates</h2><span id='topic+findNeutralCopyNumberState.default'></span><span id='topic+findNeutralCopyNumberState'></span>

<h3>Description</h3>

<p>Call segments to be copy neutral based on allelic imbalance calls and total copy number estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
findNeutralCopyNumberState(C, isAI, weights=NULL, ..., minDensity=1e-10,
  flavor=c("firstPeak", "maxPeak"), verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNeutralCopyNumberState_+3A_c">C</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of region-level total copy number estimates.</p>
</td></tr>
<tr><td><code id="findNeutralCopyNumberState_+3A_isai">isAI</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> <code><a href="base.html#topic+vector">vector</a></code> of &quot;allelic imbalance&quot; calls.</p>
</td></tr>
<tr><td><code id="findNeutralCopyNumberState_+3A_weights">weights</code></td>
<td>
<p>An optional <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of non-negative weights.</p>
</td></tr>
<tr><td><code id="findNeutralCopyNumberState_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the density estimation
function.</p>
</td></tr>
<tr><td><code id="findNeutralCopyNumberState_+3A_mindensity">minDensity</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value, below which density peaks are
discarded.</p>
</td></tr>
<tr><td><code id="findNeutralCopyNumberState_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying how to identify the
mode of the AB segments.</p>
</td></tr>
<tr><td><code id="findNeutralCopyNumberState_+3A_verbose">verbose</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, extra information is output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+logical">logical</a></code> <code><a href="base.html#topic+vector">vector</a></code> of &quot;neutral copy number state&quot; calls.
</p>


<h3>Author(s)</h3>

<p>Pierre Neuvial, Henrik Bengtsson</p>

<hr>
<h2 id='gapsToSegments.data.frame'>Gets the genomic segments that are complementary to the gaps</h2><span id='topic+gapsToSegments.data.frame'></span><span id='topic+gapsToSegments'></span>

<h3>Description</h3>

<p>Gets the genomic segments that are complementary to the gaps, with default chromosome boundaries being <code>-Inf</code>
and <code>+Inf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
gapsToSegments(gaps, resolution=1L, minLength=0L, dropGaps=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapsToSegments.data.frame_+3A_gaps">gaps</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns <code>chromosome</code>, <code>start</code>,
and <code>stop</code>. Any overlapping gaps will throw an error.</p>
</td></tr>
<tr><td><code id="gapsToSegments.data.frame_+3A_resolution">resolution</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+numeric">numeric</a></code> specifying the minimum
length unit, which by default equals one nucleotide/base pair.</p>
</td></tr>
<tr><td><code id="gapsToSegments.data.frame_+3A_minlength">minLength</code></td>
<td>
<p>Minimum length of segments to be kept.</p>
</td></tr>
<tr><td><code id="gapsToSegments.data.frame_+3A_dropgaps">dropGaps</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the gaps themselves are not part of the output.</p>
</td></tr>
<tr><td><code id="gapsToSegments.data.frame_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code><a href="base.html#topic+data.frame">data.frame</a></code> of least one row with columns <code>chromosome</code>
if that argument is given), <code>start</code>, <code>stop</code> and <code>length</code>.
The segments are ordered along the genome.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+findLargeGaps">findLargeGaps</a></code>().
</p>

<hr>
<h2 id='getBootstrapLocusSets.PairedPSCBS'>Generates original and bootstrapped segment-specific index sets</h2><span id='topic+getBootstrapLocusSets.PairedPSCBS'></span><span id='topic+PairedPSCBS.getBootstrapLocusSets'></span><span id='topic+getBootstrapLocusSets+2CPairedPSCBS-method'></span><span id='topic+getBootstrapLocusSets'></span>

<h3>Description</h3>

<p>Generates original and bootstrapped segment-specific index sets, which can be used to calculate various bootstrap summaries,
e.g. segment mean levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
getBootstrapLocusSets(fit, B=1000L, by=c("betaTN", "betaT"), seed=NULL, verbose=FALSE,
  .validate=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBootstrapLocusSets.PairedPSCBS_+3A_b">B</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+integer">integer</a></code> specifying the number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="getBootstrapLocusSets.PairedPSCBS_+3A_by">by</code></td>
<td>
<p>Should <code>betaTN</code> or <code>betaT</code> be used?</p>
</td></tr>
<tr><td><code id="getBootstrapLocusSets.PairedPSCBS_+3A_seed">seed</code></td>
<td>
<p>An (optional) <code><a href="base.html#topic+integer">integer</a></code> specifying the random seed to be
set before sampling indices.  The random seed is set to its original
state when exiting.  If <code><a href="base.html#topic+NULL">NULL</a></code>, it is not set.</p>
</td></tr>
<tr><td><code id="getBootstrapLocusSets.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
<tr><td><code id="getBootstrapLocusSets.PairedPSCBS_+3A_.validate">.validate</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, additional sanity checks are performed
to validate the correctness.  This is only needed for troubleshooting
if it is suspected there is a bug.</p>
</td></tr>
<tr><td><code id="getBootstrapLocusSets.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+list">list</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>This is used internally by various bootstrap methods.
</p>

<hr>
<h2 id='getCallStatistics.CBS'>Calculates various call statistics per chromosome</h2><span id='topic+getCallStatistics.CBS'></span><span id='topic+CBS.getCallStatistics'></span><span id='topic+getCallStatistics+2CCBS-method'></span>

<h3>Description</h3>

<p>Calculates various call statistics per chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
getCallStatistics(fit, regions=NULL, shrinkRegions=TRUE, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCallStatistics.CBS_+3A_regions">regions</code></td>
<td>
<p>An optional <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns &quot;chromosome&quot;,
&quot;start&quot;, and &quot;end&quot; specifying the regions of interest to calculate
statistics for.  If <code><a href="base.html#topic+NULL">NULL</a></code>, all of the genome is used.</p>
</td></tr>
<tr><td><code id="getCallStatistics.CBS_+3A_shrinkregions">shrinkRegions</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, regions are shrunk to the support of
the data.</p>
</td></tr>
<tr><td><code id="getCallStatistics.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="getCallStatistics.CBS_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimators implemented here are based solely on the
segmentation results, which is very fast.
In the original proposal by Fridlyand et al. [1], the authors
estimates the parameters by converting segment-level calls back
to locus-level calls and there do the calculations.
The difference between the two approaches should be minor,
particularly for large density arrays.
</p>


<h3>Value</h3>

<p>Returns a CxK <code><a href="base.html#topic+data.frame">data.frame</a></code>, where C is the number of regions that
meet the criteria setup by argument <code>regions</code>
and (K-4)/2 is the number of call types.
The first column is the chromosome index, the second and the third
are the first and last position, and the fourth the length
(=last-first+1) of the chromosome.
The following columns contains call summaries per chromosome.
For each chromosome and call type, the total length of such calls
on that chromosome is reported together how large of a fraction
of the chromosome such calls occupy.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] Fridlyand et al. <em>Breast tumor copy number aberration
phenotypes and genomic instability</em>, BMC Cancer, 2006. <br />
</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='getChromosomes.AbstractCBS'>Gets the set of chromosomes</h2><span id='topic+getChromosomes.AbstractCBS'></span><span id='topic+AbstractCBS.getChromosomes'></span><span id='topic+getChromosomes+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Gets the set of chromosomes in the segmentation result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
getChromosomes(this, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getChromosomes.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+getSegments.AbstractCBS">*getSegments</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a unique and sorted <code><a href="base.html#topic+vector">vector</a></code> of chromosomes segmented.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbrOfChromosomes.AbstractCBS">*nbrOfChromosomes</a>()</code>.
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='getFractionOfGenomeLost.CBS'>Calculates the fraction of the genome lost, gained, or aberrant either way</h2><span id='topic+getFractionOfGenomeLost.CBS'></span><span id='topic+CBS.getFractionOfGenomeLost'></span><span id='topic+getFractionOfGenomeLost+2CCBS-method'></span><span id='topic+CBS.getFractionOfGenomeGained'></span><span id='topic+getFractionOfGenomeGained.CBS'></span><span id='topic+getFractionOfGenomeGained+2CCBS-method'></span><span id='topic+CBS.getFractionOfGenomeAltered'></span><span id='topic+getFractionOfGenomeAltered.CBS'></span><span id='topic+getFractionOfGenomeAltered+2CCBS-method'></span><span id='topic+CBS.getFGL'></span><span id='topic+getFGL.CBS'></span><span id='topic+getFGL+2CCBS-method'></span><span id='topic+CBS.getFGG'></span><span id='topic+getFGG.CBS'></span><span id='topic+getFGG+2CCBS-method'></span><span id='topic+CBS.getFGA'></span><span id='topic+getFGA.CBS'></span><span id='topic+getFGA+2CCBS-method'></span>

<h3>Description</h3>

<p>Calculates the fraction of the genome lost, gained, or aberrant either way (in sense of total copy numbers),
using definitions closely related to those presented in [1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
getFractionOfGenomeLost(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFractionOfGenomeLost.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+double">double</a></code> in [0,1].
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] Fridlyand et al. <em>Breast tumor copy number aberration
phenotypes and genomic instability</em>, BMC Cancer, 2006. <br />
</p>


<h3>See Also</h3>

<p>Internally, <code><a href="#topic+getCallStatistics.CBS">*getCallStatistics</a>()</code> is used.
For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='getLocusData.AbstractCBS'>Gets the locus-level data</h2><span id='topic+getLocusData.AbstractCBS'></span><span id='topic+AbstractCBS.getLocusData'></span><span id='topic+getLocusData+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.setLocusData'></span><span id='topic+setLocusData.AbstractCBS'></span><span id='topic+setLocusData+2CAbstractCBS-method'></span><span id='topic+setLocusData.AbstractCBS'></span>

<h3>Description</h3>

<p>Gets the locus-level data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
getLocusData(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLocusData.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a JxL <code><a href="base.html#topic+data.frame">data.frame</a></code>, where J in the number of loci,
and L is the number of locus-specific fields.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='getSampleName.AbstractCBS'>Gets the name of the sample segmented</h2><span id='topic+getSampleName.AbstractCBS'></span><span id='topic+AbstractCBS.getSampleName'></span><span id='topic+getSampleName+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.sampleName'></span><span id='topic+sampleName.AbstractCBS'></span><span id='topic+sampleName+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Gets the name of the sample segmented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
getSampleName(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSampleName.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+character">character</a></code> string.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+setSampleName.AbstractCBS">*setSampleName</a>()</code>.
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>..
</p>

<hr>
<h2 id='getSegments.AbstractCBS'>Gets the segments</h2><span id='topic+getSegments.AbstractCBS'></span><span id='topic+AbstractCBS.getSegments'></span><span id='topic+getSegments+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.setSegments'></span><span id='topic+setSegments.AbstractCBS'></span><span id='topic+setSegments+2CAbstractCBS-method'></span><span id='topic+setSegments.AbstractCBS'></span>

<h3>Description</h3>

<p>Gets the segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
getSegments(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSegments.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a SxK <code><a href="base.html#topic+data.frame">data.frame</a></code>, where S in the number of segments,
and K is the number of segment-specific fields.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='getSegments.PSCBS'>Gets the segments</h2><span id='topic+getSegments.PSCBS'></span><span id='topic+PSCBS.getSegments'></span><span id='topic+getSegments+2CPSCBS-method'></span>

<h3>Description</h3>

<p>Gets the segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PSCBS'
getSegments(fit, simplify=FALSE, splitters=TRUE, addGaps=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSegments.PSCBS_+3A_simplify">simplify</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, redundant and intermediate information is dropped.</p>
</td></tr></table>
<p>#  </p>
<table>
<tr><td><code id="getSegments.PSCBS_+3A_splitters">splitters</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, &quot;splitters&quot; between chromosomes are
preserved, otherwise dropped.</p>
</td></tr>
<tr><td><code id="getSegments.PSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a SxK <code><a href="base.html#topic+data.frame">data.frame</a></code>, where S in the number of segments,
and K is the number of segment-specific fields.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+PSCBS">PSCBS</a></code>.
</p>

<hr>
<h2 id='getSmoothLocusData.CBS'>Gets smoothed locus-level data</h2><span id='topic+getSmoothLocusData.CBS'></span><span id='topic+CBS.getSmoothLocusData'></span><span id='topic+getSmoothLocusData+2CCBS-method'></span>

<h3>Description</h3>

<p>Gets smoothed locus-level data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
getSmoothLocusData(fit, by, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSmoothLocusData.CBS_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+CBS">CBS</a></code> object.</p>
</td></tr>
<tr><td><code id="getSmoothLocusData.CBS_+3A_by">by</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> scalar specifying the bin size.</p>
</td></tr>
<tr><td><code id="getSmoothLocusData.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> where the
first three columns are 'chromosome', 'x' (position),
and 'count' (number of loci average over for the given bin),
and the remaining ones are the smoothed locus-level data.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='hclustCNs.AbstractCBS'>Performs a hierarchical clustering of the CN mean levels</h2><span id='topic+hclustCNs.AbstractCBS'></span><span id='topic+AbstractCBS.hclustCNs'></span><span id='topic+hclustCNs+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Performs a hierarchical clustering of the CN mean levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
hclustCNs(fit, size=NULL, distMethod="euclidean", hclustMethod="ward.D", ...,
  verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hclustCNs.AbstractCBS_+3A_size">size</code></td>
<td>
<p>Argument passed to <code><a href="#topic+sampleCNs.AbstractCBS">*sampleCNs</a>()</code>.</p>
</td></tr>
<tr><td><code id="hclustCNs.AbstractCBS_+3A_distmethod">distMethod</code>, <code id="hclustCNs.AbstractCBS_+3A_hclustmethod">hclustMethod</code></td>
<td>
<p>Argument <code>method</code> for
<code><a href="stats.html#topic+dist">dist</a></code> and &quot;stats::hclust&quot;, respectively.</p>
</td></tr>
<tr><td><code id="hclustCNs.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="hclustCNs.AbstractCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>hclust</code> object as returned by <code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>This method is utilized by <code><a href="#topic+pruneByHClust.AbstractCBS">*pruneByHClust</a>()</code>.
</p>

<hr>
<h2 id='installDNAcopy'>Install the DNAcopy package</h2><span id='topic+installDNAcopy.default'></span><span id='topic+installDNAcopy'></span>

<h3>Description</h3>

<p>Install the DNAcopy package, if missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
installDNAcopy(..., force=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="installDNAcopy_+3A_...">...</code></td>
<td>
<p>Arguments passed to the install function.</p>
</td></tr>
<tr><td><code id="installDNAcopy_+3A_force">force</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">FALSE</a></code> and the <span class="pkg">DNAcopy</span> package is already
installed, then it will not be re-install.
If <code><a href="base.html#topic+logical">TRUE</a></code>, it will be installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is will download and call the <code>biocLite()</code>
installation function from the Bioconductor Project website.
This function will also make sure that <span class="pkg">DNAcopy</span> is loaded so
that it is reported by <code><a href="utils.html#topic+sessionInfo">sessionInfo</a></code>.
</p>


<h3>Value</h3>

<p>Returns nothing.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='joinSegments.CBS'>Joins neighboring segments such that there is no gap in between them</h2><span id='topic+joinSegments.CBS'></span><span id='topic+CBS.joinSegments'></span><span id='topic+joinSegments+2CCBS-method'></span>

<h3>Description</h3>

<p>Joins neighboring segments such that there is no gap in between them.
For instance, consider two neighboring segments [x1,x2] and [x3,x4]
with x1 &lt; x2 &lt; x3 &lt; x4.  After join the segments, they are
[x1,x23] and [x23,x4] where x23 = (x2 + x3)/2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
joinSegments(fit, range=NULL, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinSegments.CBS_+3A_range">range</code></td>
<td>
<p>(optional) A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length two.</p>
</td></tr>
<tr><td><code id="joinSegments.CBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
<tr><td><code id="joinSegments.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes only chromosome exists.
If more, an error will be thrown.
</p>


<h3>Value</h3>

<p>Returns an updated <code><a href="#topic+CBS">CBS</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='mergeNonCalledSegments.CBS'>Merge neighboring segments that are not called</h2><span id='topic+mergeNonCalledSegments.CBS'></span><span id='topic+CBS.mergeNonCalledSegments'></span><span id='topic+mergeNonCalledSegments+2CCBS-method'></span>

<h3>Description</h3>

<p>Merge neighboring segments that are not called
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
mergeNonCalledSegments(fit, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeNonCalledSegments.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="mergeNonCalledSegments.CBS_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the same class
with the same of fewer number of segments.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+CBS">CBS</a></code>.
</p>

<hr>
<h2 id='mergeThreeSegments.AbstractCBS'>Merge a segment and its two flanking segments</h2><span id='topic+mergeThreeSegments.AbstractCBS'></span><span id='topic+AbstractCBS.mergeThreeSegments'></span><span id='topic+mergeThreeSegments+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Merge a segment and its two flanking segments into one segment, and recalculating the segment statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
mergeThreeSegments(fit, middle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeThreeSegments.AbstractCBS_+3A_middle">middle</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the three segments
(middle-1, middle, middle+1) to be merged.</p>
</td></tr>
<tr><td><code id="mergeThreeSegments.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+mergeTwoSegments.AbstractCBS">*mergeTwoSegments</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> of the same class with two less segment.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally <code><a href="#topic+mergeTwoSegments.AbstractCBS">*mergeTwoSegments</a>()</code> is used.
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='mergeTwoSegments.AbstractCBS'>Merge two neighboring segments</h2><span id='topic+mergeTwoSegments.AbstractCBS'></span><span id='topic+AbstractCBS.mergeTwoSegments'></span><span id='topic+mergeTwoSegments+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.dropChangePoint'></span><span id='topic+dropChangePoint.AbstractCBS'></span><span id='topic+dropChangePoint+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Merge two neighboring segments into one segment, which is done by dropping their
common change point and recalculating the segment statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
mergeTwoSegments(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTwoSegments.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> of the same class with one less segment.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>To merge a segment and its two flanking segments, see
<code><a href="#topic+mergeThreeSegments.AbstractCBS">*mergeThreeSegments</a>()</code>.
To drop regions (a connected set of segments)
see <code><a href="#topic+dropRegions.AbstractCBS">*dropRegions</a>()</code>.
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='mergeTwoSegments.PairedPSCBS'>Merge two neighboring segments</h2><span id='topic+mergeTwoSegments.PairedPSCBS'></span><span id='topic+PairedPSCBS.mergeTwoSegments'></span><span id='topic+mergeTwoSegments+2CPairedPSCBS-method'></span>

<h3>Description</h3>

<p>Merge two neighboring segments by recalculating segment statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
mergeTwoSegments(this, left, update=TRUE, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTwoSegments.PairedPSCBS_+3A_left">left</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the segments (left, left+1)
to be merged.</p>
</td></tr>
<tr><td><code id="mergeTwoSegments.PairedPSCBS_+3A_update">update</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, segment statistics are updated.</p>
</td></tr>
<tr><td><code id="mergeTwoSegments.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> or a <code><a href="R.utils.html#topic+Verbose">Verbose</a></code> object.</p>
</td></tr>
<tr><td><code id="mergeTwoSegments.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> with one less segment.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>To drop regions (a connected set of segments) see <code>dropRegions()</code>.
For more information see <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code>.
</p>

<hr>
<h2 id='nbrOfChangePoints.AbstractCBS'>Gets the number of change points</h2><span id='topic+nbrOfChangePoints.AbstractCBS'></span><span id='topic+AbstractCBS.nbrOfChangePoints'></span><span id='topic+nbrOfChangePoints+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Gets the number of change points, which is defined as the number of segments minus
the number of chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
nbrOfChangePoints(fit, ignoreGaps=FALSE, dropEmptySegments=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbrOfChangePoints.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="base.html#topic+integer">integer</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbrOfSegments.AbstractCBS">*nbrOfSegments</a>()</code>
<code><a href="#topic+nbrOfChromosomes.AbstractCBS">*nbrOfChromosomes</a>()</code>
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='nbrOfChromosomes.AbstractCBS'>Gets the number of chromosomes</h2><span id='topic+nbrOfChromosomes.AbstractCBS'></span><span id='topic+AbstractCBS.nbrOfChromosomes'></span><span id='topic+nbrOfChromosomes+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Gets the number of chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
nbrOfChromosomes(this, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbrOfChromosomes.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+getChromosomes.AbstractCBS">*getChromosomes</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="base.html#topic+integer">integer</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+getChromosomes.AbstractCBS">*getChromosomes</a>()</code>.
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='nbrOfLoci.AbstractCBS'>Gets the number of loci</h2><span id='topic+nbrOfLoci.AbstractCBS'></span><span id='topic+AbstractCBS.nbrOfLoci'></span><span id='topic+nbrOfLoci+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Gets the number of loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
nbrOfLoci(fit, splitters=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbrOfLoci.AbstractCBS_+3A_splitters">splitters</code>, <code id="nbrOfLoci.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+getLocusData.AbstractCBS">*getLocusData</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="base.html#topic+integer">integer</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='nbrOfSegments.AbstractCBS'>Gets the number of segments</h2><span id='topic+nbrOfSegments.AbstractCBS'></span><span id='topic+AbstractCBS.nbrOfSegments'></span><span id='topic+nbrOfSegments+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Gets the number of segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
nbrOfSegments(this, splitters=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbrOfSegments.AbstractCBS_+3A_splitters">splitters</code>, <code id="nbrOfSegments.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+getSegments.AbstractCBS">*getSegments</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="base.html#topic+integer">integer</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+nbrOfChangePoints.AbstractCBS">*nbrOfChangePoints</a>()</code>
<code><a href="#topic+nbrOfChromosomes.AbstractCBS">*nbrOfChromosomes</a>()</code>
For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='Non-documented+20objects'>Non-documented objects</h2><span id='topic+Non-documented+20objects'></span><span id='topic+extractWIG'></span><span id='topic+extractWIG.AbstractCBS'></span><span id='topic+extractWIG.CBS'></span><span id='topic+extractWIG.PSCBS'></span><span id='topic+all.equal.AbstractCBS'></span><span id='topic+all.equal.CBS'></span><span id='topic+applyByRegion'></span><span id='topic+applyByRegion.PairedPSCBS'></span><span id='topic+arrowsC1C2'></span><span id='topic+arrowsC1C2.PairedPSCBS'></span><span id='topic+arrowsDeltaC1C2'></span><span id='topic+arrowsDeltaC1C2.PairedPSCBS'></span><span id='topic+as.CBS'></span><span id='topic+as.DNAcopy'></span><span id='topic+as.character.CBS'></span><span id='topic+as.data.frame.PSCBS'></span><span id='topic+bootstrapCIs'></span><span id='topic+bootstrapCIs.PairedPSCBS'></span><span id='topic+bootstrapDHByRegion'></span><span id='topic+bootstrapDHByRegion.PairedPSCBS'></span><span id='topic+bootstrapTCNandDHByRegion'></span><span id='topic+callAB'></span><span id='topic+callABandHighAI'></span><span id='topic+callABandHighAI.PairedPSCBS'></span><span id='topic+callABandLowC1'></span><span id='topic+callABandLowC1.PairedPSCBS'></span><span id='topic+callAllelicBalance'></span><span id='topic+callAllelicBalance.default'></span><span id='topic+callAllelicBalanceByDH'></span><span id='topic+callAmplifications'></span><span id='topic+callArms'></span><span id='topic+callArms.CBS'></span><span id='topic+callExtremeAllelicImbalanceByDH'></span><span id='topic+callExtremeAllelicImbalanceByDH.PairedPSCBS'></span><span id='topic+callGainsAndLosses'></span><span id='topic+callLOH'></span><span id='topic+callLowC1ByC1'></span><span id='topic+callLowC1ByC1.PairedPSCBS'></span><span id='topic+callOutliers'></span><span id='topic+drawCentromeres'></span><span id='topic+drawCentromeres.CBS'></span><span id='topic+drawChromosomes'></span><span id='topic+drawChromosomes.CBS'></span><span id='topic+drawConfidenceBands'></span><span id='topic+drawConfidenceBands.PairedPSCBS'></span><span id='topic+drawLevels'></span><span id='topic+drawLevels.CBS'></span><span id='topic+drawLevels.DNAcopy'></span><span id='topic+drawLevels.PairedPSCBS'></span><span id='topic+dropChangePoint'></span><span id='topic+dropRegion'></span><span id='topic+dropRegions'></span><span id='topic+estimateDeltaAB'></span><span id='topic+estimateDeltaABBySmallDH'></span><span id='topic+estimateDeltaLOH'></span><span id='topic+estimateDeltaLOHByMinC1ForNonAB'></span><span id='topic+estimateHighDHQuantileAtAB'></span><span id='topic+estimateHighDHQuantileAtAB.PairedPSCBS'></span><span id='topic+estimateKappa'></span><span id='topic+estimateKappaByC1Density'></span><span id='topic+estimateMeanForDH'></span><span id='topic+estimateMeanForDH.PairedPSCBS'></span><span id='topic+estimateStandardDeviation'></span><span id='topic+estimateStandardDeviation.DNAcopy'></span><span id='topic+estimateStdDevForHeterozygousBAF'></span><span id='topic+estimateStdDevForHeterozygousBAF.PairedPSCBS'></span><span id='topic+extractC1C2'></span><span id='topic+extractCallsByLocus'></span><span id='topic+extractCallsByLocus.PairedPSCBS'></span><span id='topic+extractCallsByLocus.CBS'></span><span id='topic+extractChromosome'></span><span id='topic+extractChromosome.AbstractCBS'></span><span id='topic+extractChromosomes'></span><span id='topic+extractChromosomes.AbstractCBS'></span><span id='topic+extractChromosomes.CBS'></span><span id='topic+extractChromosomes.PSCBS'></span><span id='topic+extractDeltaC1C2'></span><span id='topic+extractDeltaC1C2.PairedPSCBS'></span><span id='topic+extractLocusLevelC1C2'></span><span id='topic+extractLocusLevelC1C2.PairedPSCBS'></span><span id='topic+extractLocusLevelTCN'></span><span id='topic+extractLocusLevelTCN.PairedPSCBS'></span><span id='topic+extractMinorMajorCNs'></span><span id='topic+extractRegion'></span><span id='topic+extractRegion.AbstractCBS'></span><span id='topic+extractRegions'></span><span id='topic+extractRegions.AbstractCBS'></span><span id='topic+extractSegmentMeansByLocus'></span><span id='topic+extractSegmentMeansByLocus.DNAcopy'></span><span id='topic+extractTCNAndDHs'></span><span id='topic+getCallStatistics'></span><span id='topic+getCallStatisticsByArms'></span><span id='topic+getCallStatisticsByArms.CBS'></span><span id='topic+getChromosomeOffsets'></span><span id='topic+getChromosomeRanges'></span><span id='topic+getChromosomeRanges.CBS'></span><span id='topic+getChromosomes'></span><span id='topic+getChromosomes.DNAcopy'></span><span id='topic+getFGA'></span><span id='topic+getFGG'></span><span id='topic+getFGL'></span><span id='topic+getFractionOfGenomeAltered'></span><span id='topic+getFractionOfGenomeGained'></span><span id='topic+getFractionOfGenomeLost'></span><span id='topic+getLocusData'></span><span id='topic+getLocusData.CBS'></span><span id='topic+getLocusData.PSCBS'></span><span id='topic+getSampleName'></span><span id='topic+getSampleNames'></span><span id='topic+getSampleNames.DNAcopy'></span><span id='topic+getSegments'></span><span id='topic+getSegments.CBS'></span><span id='topic+getSignalType'></span><span id='topic+getSignalType.CBS'></span><span id='topic+highlightArmCalls'></span><span id='topic+highlightArmCalls.CBS'></span><span id='topic+highlightCalls'></span><span id='topic+highlightCalls.CBS'></span><span id='topic+highlightLocusCalls'></span><span id='topic+highlightLocusCalls.CBS'></span><span id='topic+isWholeChromosomeGained'></span><span id='topic+isWholeChromosomeGained.CBS'></span><span id='topic+isWholeChromosomeLost'></span><span id='topic+isWholeChromosomeLost.CBS'></span><span id='topic+joinSegments'></span><span id='topic+linesC1C2'></span><span id='topic+linesC1C2.PairedPSCBS'></span><span id='topic+linesDeltaC1C2'></span><span id='topic+linesDeltaC1C2.PairedPSCBS'></span><span id='topic+mergeNonCalledSegments'></span><span id='topic+mergeTwoSegments'></span><span id='topic+mergeTwoSegments.CBS'></span><span id='topic+nbrOfAmplifications'></span><span id='topic+nbrOfAmplifications.CBS'></span><span id='topic+nbrOfChangePoints'></span><span id='topic+nbrOfChromosomes'></span><span id='topic+nbrOfGains'></span><span id='topic+nbrOfGains.CBS'></span><span id='topic+nbrOfLoci'></span><span id='topic+nbrOfLoci.DNAcopy'></span><span id='topic+nbrOfLosses'></span><span id='topic+nbrOfLosses.CBS'></span><span id='topic+nbrOfSamples'></span><span id='topic+nbrOfSamples.DNAcopy'></span><span id='topic+nbrOfSegments'></span><span id='topic+nbrOfSegments.DNAcopy'></span><span id='topic+plot.CBS'></span><span id='topic+plot.PairedPSCBS'></span><span id='topic+plotC1C2'></span><span id='topic+plotC1C2.PairedPSCBS'></span><span id='topic+plotDeltaC1C2'></span><span id='topic+plotDeltaC1C2.PairedPSCBS'></span><span id='topic+plotTracksManyChromosomes.CBS'></span><span id='topic+pointsC1C2'></span><span id='topic+pointsC1C2.PairedPSCBS'></span><span id='topic+pointsDeltaC1C2'></span><span id='topic+pointsDeltaC1C2.PairedPSCBS'></span><span id='topic+postsegmentTCN'></span><span id='topic+postsegmentTCN.PairedPSCBS'></span><span id='topic+print.AbstractCBS'></span><span id='topic+sampleName'></span><span id='topic+sampleName+3C-'></span><span id='topic+setLocusData'></span><span id='topic+setSampleName'></span><span id='topic+setSegments'></span><span id='topic+signalType'></span><span id='topic+signalType.CBS'></span><span id='topic+signalType+3C-'></span><span id='topic+signalType+3C-.CBS'></span><span id='topic+subset.CBS'></span><span id='topic+tileChromosomes'></span><span id='topic+tileChromosomes.AbstractCBS'></span><span id='topic+tileChromosomes.CBS'></span><span id='topic+tileChromosomes.PairedPSCBS'></span><span id='topic+writeLocusData'></span><span id='topic+writeLocusData.CBS'></span><span id='topic+writeSegments'></span><span id='topic+extractSegments.AbstractCBS'></span><span id='topic+extractSegment.AbstractCBS'></span><span id='topic+extractSegment'></span><span id='topic+extractSegments'></span><span id='topic+extractSegments.CBS'></span><span id='topic+extractSegments.PairedPSCBS'></span><span id='topic+isSegmentSplitter'></span><span id='topic+isSegmentSplitter.CBS'></span><span id='topic+isSegmentSplitter.PSCBS'></span><span id='topic+extractCNs'></span><span id='topic+extractCNs.AbstractCBS'></span><span id='topic+extractCNs.CBS'></span><span id='topic+extractCNs.PairedPSCBS'></span><span id='topic+extractTotalCNs'></span><span id='topic+extractTotalCNs.CBS'></span><span id='topic+getSegmentSizes'></span><span id='topic+getSegmentSizes.AbstractCBS'></span><span id='topic+getSegmentSizes.CBS'></span><span id='topic+getSegmentSizes.PSCBS'></span><span id='topic+sampleCNs'></span><span id='topic+sampleCNs.AbstractCBS'></span><span id='topic+mergeThreeSegments'></span><span id='topic+callROH'></span><span id='topic+callROHOneSegment'></span><span id='topic+callROHOneSegment.PairedPSCBS'></span><span id='topic+testROH'></span><span id='topic+pruneBySdUndo'></span><span id='topic+updateBoundaries'></span><span id='topic+updateBoundaries.CBS'></span><span id='topic+resegment'></span><span id='topic+resegment.AbstractCBS'></span><span id='topic+resegment.CBS'></span><span id='topic+resegment.PairedPSCBS'></span><span id='topic+hclustCNs'></span><span id='topic+pruneByHClust'></span><span id='topic+updateMeansTogether'></span><span id='topic+updateMeans'></span><span id='topic+drawChangePoints'></span><span id='topic+drawChangePoints.AbstractCBS'></span><span id='topic+drawKnownSegments'></span><span id='topic+drawKnownSegments.AbstractCBS'></span><span id='topic+drawChangePoints.CBS'></span><span id='topic+drawChangePoints.PSCBS'></span><span id='topic+drawChangePointsC1C2'></span><span id='topic+drawChangePointsC1C2.PairedPSCBS'></span><span id='topic+extractDhSegment'></span><span id='topic+extractDhSegment.PairedPSCBS'></span><span id='topic+callNTCN'></span><span id='topic+callCopyNeutral'></span><span id='topic+callCopyNeutralByTCNofAB'></span><span id='topic+dropChangePoints'></span><span id='topic+calcStatsForCopyNeutralABs'></span><span id='topic+calcStatsForCopyNeutralABs.PairedPSCBS'></span><span id='topic+callGainNeutralLoss'></span><span id='topic+callGNL'></span><span id='topic+renameChromosomes'></span><span id='topic+renameChromosomes.AbstractCBS'></span><span id='topic+report'></span><span id='topic+writeSegments.DNAcopy'></span><span id='topic+shiftTCN'></span><span id='topic+shiftTCN.AbstractCBS'></span><span id='topic+shiftTCN.CBS'></span><span id='topic+shiftTCN.PairedPSCBS'></span><span id='topic+getChromosomeOffsets.AbstractCBS'></span><span id='topic+getChromosomeRanges.PairedPSCBS'></span><span id='topic+getChromosomeRanges.AbstractCBS'></span><span id='topic+seqOfSegmentsByDP'></span><span id='topic+seqOfSegmentsByDP.AbstractCBS'></span><span id='topic+seqOfSegmentsByDP.CBS'></span><span id='topic+seqOfSegmentsByDP.PairedPSCBS'></span><span id='topic+seqOfSegmentsByDP.matrix'></span><span id='topic+getChromosomeOffsets.PairedPSCBS'></span><span id='topic+getLocusSignalNames'></span><span id='topic+getLocusSignalNames.AbstractCBS'></span><span id='topic+getLocusSignalNames.CBS'></span><span id='topic+getLocusSignalNames.PSCBS'></span><span id='topic+getSegmentTrackPrefixes'></span><span id='topic+getSegmentTrackPrefixes.AbstractCBS'></span><span id='topic+getSegmentTrackPrefixes.CBS'></span><span id='topic+getSegmentTrackPrefixes.PSCBS'></span><span id='topic+pruneByDP'></span><span id='topic+getMeanEstimators'></span><span id='topic+getMeanEstimators.AbstractCBS'></span><span id='topic+resegment.NonPairedPSCBS'></span><span id='topic+setMeanEstimators'></span><span id='topic+setMeanEstimators.AbstractCBS'></span><span id='topic+resetSegments'></span><span id='topic+getLocusData.NonPairedPSCBS'></span><span id='topic+getLocusData.PairedPSCBS'></span><span id='topic+plotTracks'></span><span id='topic+plotTracks1'></span><span id='topic+plotTracks2'></span><span id='topic+plotTracksManyChromosomes'></span><span id='topic+getSmoothLocusData'></span><span id='topic+bootstrapSegmentsAndChangepoints'></span><span id='topic+bootstrapSegmentsAndChangepoints.PairedPSCBS'></span><span id='topic+getChangePoints'></span><span id='topic+getChangePoints.AbstractCBS'></span><span id='topic+getChangePoints.CBS'></span><span id='topic+getChangePoints.PSCBS'></span><span id='topic+clearBootstrapSummaries'></span><span id='topic+clearBootstrapSummaries.PairedPSCBS'></span><span id='topic+findBootstrapSummaries'></span><span id='topic+findBootstrapSummaries.PairedPSCBS'></span><span id='topic+hasBootstrapSummaries'></span><span id='topic+hasBootstrapSummaries.PairedPSCBS'></span><span id='topic+clearCalls'></span><span id='topic+clearCalls.AbstractCBS'></span><span id='topic+extractSegmentDataByLocus'></span><span id='topic+extractSegmentDataByLocus.PairedPSCBS'></span><span id='topic+updateMeansC1C2'></span><span id='topic+updateMeansC1C2.PairedPSCBS'></span><span id='topic+encodeCalls'></span><span id='topic+encodeCalls.data.frame'></span><span id='topic+callGLAO'></span><span id='topic+callGLAO.CBS'></span><span id='topic+unTumorBoost'></span><span id='topic+unTumorBoost.PairedPSCBS'></span><span id='topic+isLocallyPhased'></span><span id='topic+isLocallyPhased.PSCBS'></span>

<h3>Description</h3>

<p>This page contains aliases for all &quot;non-documented&quot; objects that
<code>R CMD check</code> detects in this package.
</p>
<p>Almost all of them are <em>generic</em> functions that have specific
document for the corresponding method coupled to a specific class.
Other functions are re-defined by <code>setMethodS3()</code> to
<em>default</em> methods. Neither of these two classes are non-documented
in reality.
The rest are deprecated methods.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='NonPairedPSCBS'>The NonPairedPSCBS class</h2><span id='topic+NonPairedPSCBS'></span>

<h3>Description</h3>

<p>Package:  PSCBS <br />
<b>Class NonPairedPSCBS</b><br />
</p>
<p><code>list</code><br />
<code>~~|</code><br />
<code>~~+--</code><code><a href="#topic+AbstractCBS">AbstractCBS</a></code><br />
<code>~~~~~~~|</code><br />
<code>~~~~~~~+--</code><code><a href="#topic+PSCBS">PSCBS</a></code><br />
<code>~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~+--</code><em><code>NonPairedPSCBS</code></em><br />
</p>
<p><b>Directly known subclasses:</b><br />
<br />
</p>
<p>public abstract class <b>NonPairedPSCBS</b><br />
extends <em><a href="#topic+PSCBS">PSCBS</a></em><br />
</p>
<p>A NonPairedPSCBS is an object containing the results from the
Non-paired PSCBS method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NonPairedPSCBS(fit=list(), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NonPairedPSCBS_+3A_fit">fit</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> structure containing the Non-paired PSCBS results.</p>
</td></tr>
<tr><td><code id="NonPairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Fields and Methods</h3>

<p><b>Methods:</b><br />
<em>No methods defined</em>.
</p>
<p><b>Methods inherited from PSCBS</b>:<br />
as.data.frame, c, drawChangePoints, extractChromosomes, extractWIG, getLocusData, getLocusSignalNames, getSegmentTrackPrefixes, isLocallyPhased, isSegmentSplitter, normalizeTotalCNs, writeSegments
</p>
<p><b>Methods inherited from AbstractCBS</b>:<br />
adjustPloidyScale, all.equal, as.data.frame, clearCalls, drawChangePoints, drawKnownSegments, dropChangePoint, dropChangePoints, dropRegion, dropRegions, extractCNs, extractChromosome, extractChromosomes, extractRegions, extractSegments, extractWIG, getChangePoints, getChromosomeOffsets, getChromosomeRanges, getChromosomes, getLocusData, getLocusSignalNames, getMeanEstimators, getSampleName, getSegmentSizes, getSegmentTrackPrefixes, getSegments, mergeThreeSegments, mergeTwoSegments, nbrOfChangePoints, nbrOfChromosomes, nbrOfLoci, nbrOfSegments, normalizeTotalCNs, ploidy, ploidy&lt;-, plotTracks, print, pruneByDP, pruneByHClust, renameChromosomes, report, resegment, resetSegments, sampleCNs, sampleName, sampleName&lt;-, seqOfSegmentsByDP, setLocusData, setMeanEstimators, setPloidy, setSampleName, setSegments, shiftTCN, tileChromosomes, updateMeans, writeWIG
</p>
<p><b>Methods inherited from list</b>:<br />
Ops,nonStructure,vector-method, Ops,structure,vector-method, Ops,vector,nonStructure-method, Ops,vector,structure-method, all.equal, as.data.frame, attachLocally, callHooks, coerce,ANY,list-method, relist, type.convert, within
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+segmentByNonPairedPSCBS">segmentByNonPairedPSCBS</a></code>() method returns an object of this class.
</p>

<hr>
<h2 id='normalizeTotalCNs.AbstractCBS'>Normalizes copy numbers such that the whole-genome average total copy number is two</h2><span id='topic+normalizeTotalCNs.AbstractCBS'></span><span id='topic+AbstractCBS.normalizeTotalCNs'></span><span id='topic+normalizeTotalCNs+2CAbstractCBS-method'></span><span id='topic+normalizeTotalCNs'></span><span id='topic+normalizeTotalCNs.PSCBS'></span>

<h3>Description</h3>

<p>Normalizes copy numbers such that the whole-genome average total copy number is two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
normalizeTotalCNs(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeTotalCNs.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the normalization method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a normalized AbstractCBS object of the same class as <code>fit</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>..
</p>

<hr>
<h2 id='PairedPSCBS'>The PairedPSCBS class</h2><span id='topic+PairedPSCBS'></span>

<h3>Description</h3>

<p>Package:  PSCBS <br />
<b>Class PairedPSCBS</b><br />
</p>
<p><code>list</code><br />
<code>~~|</code><br />
<code>~~+--</code><code><a href="#topic+AbstractCBS">AbstractCBS</a></code><br />
<code>~~~~~~~|</code><br />
<code>~~~~~~~+--</code><code><a href="#topic+PSCBS">PSCBS</a></code><br />
<code>~~~~~~~~~~~~|</code><br />
<code>~~~~~~~~~~~~+--</code><em><code>PairedPSCBS</code></em><br />
</p>
<p><b>Directly known subclasses:</b><br />
<br />
</p>
<p>public abstract class <b>PairedPSCBS</b><br />
extends <em><a href="#topic+PSCBS">PSCBS</a></em><br />
</p>
<p>A PairedPSCBS is an object containing the results from the
Paired PSCBS method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PairedPSCBS(fit=list(), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PairedPSCBS_+3A_fit">fit</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> structure containing the Paired PSCBS results.</p>
</td></tr>
<tr><td><code id="PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Fields and Methods</h3>

<p><b>Methods:</b><br />
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>callAB</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>callCopyNeutral</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>callGNL</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>callGNLByTCNofAB</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>callGainNeutralLoss</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>callLOH</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>callNTCN</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>callROH</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>estimateDeltaAB</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>estimateDeltaLOH</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>estimateKappa</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>extractCNs</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>hasBootstrapSummaries</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>plotTracks</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>segmentByNonPairedPSCBS</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>segmentByPairedPSCBS</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>seqOfSegmentsByDP</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><b>Methods inherited from PSCBS</b>:<br />
as.data.frame, c, drawChangePoints, extractChromosomes, extractWIG, getLocusData, getLocusSignalNames, getSegmentTrackPrefixes, isLocallyPhased, isSegmentSplitter, normalizeTotalCNs, writeSegments
</p>
<p><b>Methods inherited from AbstractCBS</b>:<br />
adjustPloidyScale, all.equal, as.data.frame, clearCalls, drawChangePoints, drawKnownSegments, dropChangePoint, dropChangePoints, dropRegion, dropRegions, extractCNs, extractChromosome, extractChromosomes, extractRegions, extractSegments, extractWIG, getChangePoints, getChromosomeOffsets, getChromosomeRanges, getChromosomes, getLocusData, getLocusSignalNames, getMeanEstimators, getSampleName, getSegmentSizes, getSegmentTrackPrefixes, getSegments, mergeThreeSegments, mergeTwoSegments, nbrOfChangePoints, nbrOfChromosomes, nbrOfLoci, nbrOfSegments, normalizeTotalCNs, ploidy, ploidy&lt;-, plotTracks, print, pruneByDP, pruneByHClust, renameChromosomes, report, resegment, resetSegments, sampleCNs, sampleName, sampleName&lt;-, seqOfSegmentsByDP, setLocusData, setMeanEstimators, setPloidy, setSampleName, setSegments, shiftTCN, tileChromosomes, updateMeans, writeWIG
</p>
<p><b>Methods inherited from list</b>:<br />
Ops,nonStructure,vector-method, Ops,structure,vector-method, Ops,vector,nonStructure-method, Ops,vector,structure-method, all.equal, as.data.frame, attachLocally, callHooks, coerce,ANY,list-method, relist, type.convert, within
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>() method returns an object of this class.
</p>

<hr>
<h2 id='ploidy.AbstractCBS'>Gets and sets ploidy</h2><span id='topic+ploidy.AbstractCBS'></span><span id='topic+AbstractCBS.ploidy'></span><span id='topic+ploidy+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.ploidy+3C-'></span><span id='topic+ploidy+3C-.AbstractCBS'></span><span id='topic+ploidy+3C-+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.setPloidy'></span><span id='topic+setPloidy.AbstractCBS'></span><span id='topic+setPloidy+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.adjustPloidyScale'></span><span id='topic+adjustPloidyScale.AbstractCBS'></span><span id='topic+adjustPloidyScale+2CAbstractCBS-method'></span><span id='topic+adjustPloidyScale.PairedPSCBS'></span><span id='topic+adjustPloidyScale'></span><span id='topic+ploidy'></span><span id='topic+ploidy+3C-'></span><span id='topic+setPloidy'></span>

<h3>Description</h3>

<p>Gets and sets ploidy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'AbstractCBS'
ploidy(fit, ...)
  ## S3 replacement method for class 'AbstractCBS'
ploidy(fit) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ploidy.AbstractCBS_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> object.</p>
</td></tr>
<tr><td><code id="ploidy.AbstractCBS_+3A_value">value</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> (in <code class="reqn">1,2,\ldots</code>) specifying the genome ploidy .</p>
</td></tr>
<tr><td><code id="ploidy.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (invisibly) an updated object.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>..
</p>

<hr>
<h2 id='plotTracks.AbstractCBS'>Plots the segmentation result along the genome</h2><span id='topic+plotTracks.AbstractCBS'></span><span id='topic+AbstractCBS.plotTracks'></span><span id='topic+plotTracks+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Plots the segmentation result along the genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
plotTracks(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTracks.AbstractCBS_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='plotTracks.CBS'>Plots copy numbers along the genome</h2><span id='topic+plotTracks.CBS'></span><span id='topic+CBS.plotTracks'></span><span id='topic+plotTracks+2CCBS-method'></span>

<h3>Description</h3>

<p>Plots copy numbers along the genome for one or more chromosomes.
Each type of track is plotted in its own panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
plotTracks(x, scatter=TRUE, pch=20, col="gray", meanCol="purple", cex=1, grid=FALSE,
  Clim="auto", xScale=1e-06, Clab="auto", ..., byIndex=FALSE, mar=NULL, add=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTracks.CBS_+3A_x">x</code></td>
<td>
<p>A result object returned by <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>().</p>
</td></tr>
<tr><td><code id="plotTracks.CBS_+3A_pch">pch</code></td>
<td>
<p>The type of points to use.</p>
</td></tr>
<tr><td><code id="plotTracks.CBS_+3A_clim">Clim</code></td>
<td>
<p>The range of copy numbers.</p>
</td></tr>
<tr><td><code id="plotTracks.CBS_+3A_xscale">xScale</code></td>
<td>
<p>The scale factor used for genomic positions.</p>
</td></tr>
<tr><td><code id="plotTracks.CBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plotTracks.CBS_+3A_add">add</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the panels plotted are added to the existing plot,
otherwise a new plot is created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='plotTracks1.PairedPSCBS'>Plots parental specific copy numbers along the genome</h2><span id='topic+plotTracks1.PairedPSCBS'></span><span id='topic+PairedPSCBS.plotTracks1'></span><span id='topic+plotTracks1+2CPairedPSCBS-method'></span><span id='topic+PairedPSCBS.plotTracks'></span><span id='topic+plotTracks.PairedPSCBS'></span><span id='topic+plotTracks+2CPairedPSCBS-method'></span><span id='topic+PairedPSCBS.plotTracks2'></span><span id='topic+plotTracks2.PairedPSCBS'></span><span id='topic+plotTracks2+2CPairedPSCBS-method'></span><span id='topic+PairedPSCBS.plotTracksManyChromosomes'></span><span id='topic+plotTracksManyChromosomes.PairedPSCBS'></span><span id='topic+plotTracksManyChromosomes+2CPairedPSCBS-method'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Plots parental specific copy numbers along the genome for one or more chromosomes.
It is possible to specify what type of tracks to plot.
Each type of track is plotted in its own panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PairedPSCBS'
plotTracks1(x, tracks=c("tcn", "dh", "tcn,c1,c2", "tcn,c1", "tcn,c2", "c1,c2", "betaN",
  "betaT", "betaTN")[1:3], scatter="*", calls=".*", pch=".", col=NULL, cex=1,
  changepoints=FALSE, grid=FALSE, quantiles=c(0.05, 0.95), xlim=NULL,
  Clim=c(0, 3 * ploidy(x)), Blim=c(0, 1), xScale=1e-06, ..., add=FALSE,
  subplots=!add &amp;&amp; (length(tracks) &gt; 1), verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_x">x</code></td>
<td>
<p>A result object returned by <code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>().</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_tracks">tracks</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> <code><a href="base.html#topic+vector">vector</a></code> specifying what types of tracks to plot.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_scatter">scatter</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> <code><a href="base.html#topic+vector">vector</a></code> specifying which of the tracks should
have scatter plot.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_calls">calls</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> <code><a href="base.html#topic+vector">vector</a></code> of regular expression identifying
call labels to be highlighted in the panels.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_pch">pch</code></td>
<td>
<p>The type of the scatter points, if any.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_col">col</code></td>
<td>
<p>The color of the scatter points, if any.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_cex">cex</code></td>
<td>
<p>The size of the scatter points, if any.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_changepoints">changepoints</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, changepoints are drawn as vertical lines.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_grid">grid</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, horizontal lines are displayed.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_quantiles">quantiles</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> in [0,1] specifying the quantiles
of the confidence bands to be drawn, if any.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_xlim">xlim</code></td>
<td>
<p>(Optional) The genomic range to plot.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_clim">Clim</code></td>
<td>
<p>The range of copy numbers.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_blim">Blim</code></td>
<td>
<p>The range of allele B fractions (BAFs) and
decrease of heterozygosity (DHs).</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_xscale">xScale</code></td>
<td>
<p>The scale factor used for genomic positions.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_add">add</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the panels plotted are added to the existing plot,
otherwise a new plot is created.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_subplots">subplots</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, then subplots are automatically setup.</p>
</td></tr>
<tr><td><code id="plotTracks1.PairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='pruneByDP.AbstractCBS'>Prunes the CN profile using dynamical programming</h2><span id='topic+pruneByDP.AbstractCBS'></span><span id='topic+AbstractCBS.pruneByDP'></span><span id='topic+pruneByDP+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Prunes the CN profile using dynamical programming by specifying the target number of segments or alternative
how of many change points to drop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
pruneByDP(fit, nbrOfSegments, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruneByDP.AbstractCBS_+3A_nbrofsegments">nbrOfSegments</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the number of segments after
pruning. If negative, the it specifies the number of change points
to drop.</p>
</td></tr>
<tr><td><code id="pruneByDP.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="#topic+seqOfSegmentsByDP.AbstractCBS">*seqOfSegmentsByDP</a>()</code>.</p>
</td></tr>
<tr><td><code id="pruneByDP.AbstractCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a pruned object of the same class.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson, Pierre Neuvial</p>


<h3>References</h3>

<p>[1] ... <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 # Drop two segments
 fitP &lt;- pruneByDP(fit, nbrOfSegments=-2)

## End(Not run)</code></pre>

<hr>
<h2 id='pruneByHClust.AbstractCBS'>Prunes the CN profile by pruning and merging through hierarchical clustering</h2><span id='topic+pruneByHClust.AbstractCBS'></span><span id='topic+AbstractCBS.pruneByHClust'></span><span id='topic+pruneByHClust+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Prunes the CN profile by pruning and merging through hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
pruneByHClust(fit, ..., size=NULL, distMethod="euclidean", hclustMethod="ward.D",
  merge=TRUE, update=TRUE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruneByHClust.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="stats.html#topic+cutree">cutree</a></code>,
particularly either of thresholds <code>h</code> or <code>k</code>.</p>
</td></tr>
<tr><td><code id="pruneByHClust.AbstractCBS_+3A_size">size</code>, <code id="pruneByHClust.AbstractCBS_+3A_distmethod">distMethod</code>, <code id="pruneByHClust.AbstractCBS_+3A_hclustmethod">hclustMethod</code></td>
<td>
<p>Arguments (as well as
some of <code>...</code>) passed to <code><a href="#topic+hclustCNs.AbstractCBS">*hclustCNs</a>()</code>.</p>
</td></tr>
<tr><td><code id="pruneByHClust.AbstractCBS_+3A_merge">merge</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, consecutive segments that belong to the
same PSCN cluster will be merged into one large segment.</p>
</td></tr>
<tr><td><code id="pruneByHClust.AbstractCBS_+3A_update">update</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, segment means are updated afterwards, otherwise not.</p>
</td></tr>
<tr><td><code id="pruneByHClust.AbstractCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a pruned object of the same class.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 fitP &lt;- pruneByHClust(fit, h=0.25)

## End(Not run)</code></pre>

<hr>
<h2 id='pruneBySdUndo.CBS'>Prune the CBS profile by dropping change points that are too small</h2><span id='topic+pruneBySdUndo.CBS'></span><span id='topic+CBS.pruneBySdUndo'></span><span id='topic+pruneBySdUndo+2CCBS-method'></span>

<h3>Description</h3>

<p>Prune the CBS profile by dropping change points that are too small, where &quot;too small&quot; means that the amplitude of the
change points is less than a multiple of the overall standard deviation
of the copy-number signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
pruneBySdUndo(fit, rho=3, sigma="DNAcopy", ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruneBySdUndo.CBS_+3A_fit">fit</code></td>
<td>
<p>A <code><a href="#topic+CBS">CBS</a></code> object.</p>
</td></tr>
<tr><td><code id="pruneBySdUndo.CBS_+3A_rho">rho</code></td>
<td>
<p>A positive <code><a href="base.html#topic+double">double</a></code> scalar specifying the number of standard
deviations (<code>rho*sigma</code>) required in order to keep a change point.
More change points are dropped the greater this value is.</p>
</td></tr>
<tr><td><code id="pruneBySdUndo.CBS_+3A_sigma">sigma</code></td>
<td>
<p>The whole-genome standard deviation of the locus-level
copy number signals.  The default is to calculate it from the data
and as done in the <span class="pkg">DNAcopy</span> package.</p>
</td></tr>
<tr><td><code id="pruneBySdUndo.CBS_+3A_...">...</code></td>
<td>
<p>(Optional) Additional arguments passed to the standard
deviation estimator function.</p>
</td></tr>
<tr><td><code id="pruneBySdUndo.CBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method corresponds to using the <code>undo</code> argument when calling
<code><a href="#topic+segmentByCBS">segmentByCBS</a></code>(), which in turn corresponds to using the
<code>undo.splits="sdundo"</code> and <code>undo.SD</code> of the underlying
<code><a href="DNAcopy.html#topic+segment">segment</a></code> method.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+CBS">CBS</a></code> object (of the same class as <code>fit</code>).
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson, Pierre Neuvial</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Simulating copy-number data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
set.seed(0xBEEF)

# Number of loci
J &lt;- 1000

mu &lt;- double(J)
mu[1:100] &lt;- mu[1:100] + 0.3
mu[200:300] &lt;- mu[200:300] + 1
mu[350:400] &lt;- NA # centromere
mu[650:800] &lt;- mu[650:800] - 1
eps &lt;- rnorm(J, sd=1/2)
y &lt;- mu + eps
x &lt;- sort(runif(length(y), max=length(y))) * 1e5
w &lt;- runif(J)
w[650:800] &lt;- 0.001


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Segmentation
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fit &lt;- segmentByCBS(y, x=x)
print(fit)
plotTracks(fit)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Post-segmentation pruning
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fitP &lt;- pruneBySdUndo(fit, rho=1)
drawLevels(fitP, col="red")
</code></pre>

<hr>
<h2 id='PSCBS'>The PSCBS class</h2><span id='topic+PSCBS'></span>

<h3>Description</h3>

<p>Package:  PSCBS <br />
<b>Class PSCBS</b><br />
</p>
<p><code>list</code><br />
<code>~~|</code><br />
<code>~~+--</code><code><a href="#topic+AbstractCBS">AbstractCBS</a></code><br />
<code>~~~~~~~|</code><br />
<code>~~~~~~~+--</code><em><code>PSCBS</code></em><br />
</p>
<p><b>Directly known subclasses:</b><br />
<em><a href="#topic+NonPairedPSCBS">NonPairedPSCBS</a></em>, <em><a href="#topic+PairedPSCBS">PairedPSCBS</a></em><br />
</p>
<p>public abstract class <b>PSCBS</b><br />
extends <em><a href="#topic+AbstractCBS">AbstractCBS</a></em><br />
</p>
<p>A PSCBS is an object containing results from parent-specific copy-number
(PSCN) segmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSCBS(fit=list(), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSCBS_+3A_fit">fit</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> structure containing the PSCN segmentation results.</p>
</td></tr>
<tr><td><code id="PSCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Fields and Methods</h3>

<p><b>Methods:</b><br />
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>c</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>isLocallyPhased</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>normalizeTotalCNs</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>writeSegments</code> </td><td style="text-align: left;">  -</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><b>Methods inherited from AbstractCBS</b>:<br />
adjustPloidyScale, all.equal, as.data.frame, clearCalls, drawChangePoints, drawKnownSegments, dropChangePoint, dropChangePoints, dropRegion, dropRegions, extractCNs, extractChromosome, extractChromosomes, extractRegions, extractSegments, extractWIG, getChangePoints, getChromosomeOffsets, getChromosomeRanges, getChromosomes, getLocusData, getLocusSignalNames, getMeanEstimators, getSampleName, getSegmentSizes, getSegmentTrackPrefixes, getSegments, mergeThreeSegments, mergeTwoSegments, nbrOfChangePoints, nbrOfChromosomes, nbrOfLoci, nbrOfSegments, normalizeTotalCNs, ploidy, ploidy&lt;-, plotTracks, print, pruneByDP, pruneByHClust, renameChromosomes, report, resegment, resetSegments, sampleCNs, sampleName, sampleName&lt;-, seqOfSegmentsByDP, setLocusData, setMeanEstimators, setPloidy, setSampleName, setSegments, shiftTCN, tileChromosomes, updateMeans, writeWIG
</p>
<p><b>Methods inherited from list</b>:<br />
Ops,nonStructure,vector-method, Ops,structure,vector-method, Ops,vector,nonStructure-method, Ops,vector,structure-method, all.equal, as.data.frame, attachLocally, callHooks, coerce,ANY,list-method, relist, type.convert, within
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code>.
</p>

<hr>
<h2 id='randomSeed'>Sets and resets the .Random.seed in the global environment</h2><span id='topic+randomSeed'></span>

<h3>Description</h3>

<p>Sets and resets the .Random.seed in the global environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> randomSeed(action=c("set", "advance", "reset", "get"), seed=NULL, kind=NULL, n=1L,
  backup=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomSeed_+3A_action">action</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the action.</p>
</td></tr>
<tr><td><code id="randomSeed_+3A_seed">seed</code></td>
<td>
<p>Random seed to be set; only for <code>action="set"</code>.
If <code>length(seed) == 1</code>, then <code>set.seed(seed)</code> is
used, otherwise <code>.Random.seed</code> is assigned the value.</p>
</td></tr>
<tr><td><code id="randomSeed_+3A_kind">kind</code></td>
<td>
<p>(optional) A <code><a href="base.html#topic+character">character</a></code> string specifying type of
random number generator to use, cf. <code><a href="base.html#topic+RNGkind">RNGkind</a></code>().</p>
</td></tr>
<tr><td><code id="randomSeed_+3A_n">n</code></td>
<td>
<p>Number of random seeds to generate by <code>action</code>.</p>
</td></tr>
<tr><td><code id="randomSeed_+3A_backup">backup</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, the previous (seed, kind) state is recorded
such that it can be reset later.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>.Random.seed</code>.
If more than one is returned, the they are returned as a <code><a href="base.html#topic+list">list</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='report.AbstractCBS'>Generates a report of the segmentation results</h2><span id='topic+report.AbstractCBS'></span><span id='topic+AbstractCBS.report'></span><span id='topic+report+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Generates a report of the segmentation results.
Currently reports can be generated for segmentation results of class
<code><a href="#topic+CBS">CBS</a></code> and <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
report(fit, sampleName=getSampleName(fit), studyName, ..., rspTags=NULL,
  rootPath="reports/", .filename="*", skip=TRUE, envir=new.env(), verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report.AbstractCBS_+3A_fit">fit</code></td>
<td>
<p>An <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> object.</p>
</td></tr>
<tr><td><code id="report.AbstractCBS_+3A_samplename">sampleName</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the name of the
sample segmented.</p>
</td></tr>
<tr><td><code id="report.AbstractCBS_+3A_studyname">studyName</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the name of study/project.</p>
</td></tr>
<tr><td><code id="report.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the RSP template.</p>
</td></tr>
<tr><td><code id="report.AbstractCBS_+3A_rsptags">rspTags</code></td>
<td>
<p>Optional <code><a href="base.html#topic+character">character</a></code> <code><a href="base.html#topic+vector">vector</a></code> of tags for further specifying
which RSP report to generate.</p>
</td></tr>
<tr><td><code id="report.AbstractCBS_+3A_rootpath">rootPath</code></td>
<td>
<p>The root directory where to write the report.</p>
</td></tr>
<tr><td><code id="report.AbstractCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the pathname of the generated PDF.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='resetSegments.AbstractCBS'>Reset the segments</h2><span id='topic+resetSegments.AbstractCBS'></span><span id='topic+AbstractCBS.resetSegments'></span><span id='topic+resetSegments+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Reset the segments.  More precisely, it removes columns in the segmentation
result table that have been added by methods after the actual
segmentation method, e.g. bootstrap estimated mean level quantiles
and various calls.
It leave the basic segmentation results untouched,
i.e. the partitioning and the segment means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
resetSegments(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetSegments.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object if the same class as the input result.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='Restructuring+20AbstractCBS+20objects'>Restructuring AbstractCBS objects</h2><span id='topic+Restructuring+20AbstractCBS+20objects'></span><span id='topic+RestructPSCBS'></span>

<h3>Description</h3>

<p>This page describes available methods for restructuring an
<code><a href="#topic+AbstractCBS">AbstractCBS</a></code> object.
</p>

<ul>
<li> <p><code><a href="#topic+extractChromosomes.AbstractCBS">*extractChromosomes</a>()</code> /
<code><a href="#topic+extractChromosome.AbstractCBS">*extractChromosome</a>()</code>
- Extracts an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> with the specified chromosomes.
</p>
</li>
<li> <p><code><a href="#topic+extractSegments.AbstractCBS">*extractSegments</a>()</code> /
<code><a href="#topic+extractSegment.AbstractCBS">*extractSegment</a>()</code>
- Extracts an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> with the specified segments.
</p>
</li>
<li> <p><code><a href="#topic+extractRegions.AbstractCBS">*extractRegions</a>()</code> /
<code><a href="#topic+extractRegion.AbstractCBS">*extractRegion</a>()</code>
- Extracts an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code> with the specified regions
each of a certain size, where a region is defined as a
connected set of segments.
</p>
</li>
<li> <p><code><a href="#topic+dropRegions.AbstractCBS">*dropRegions</a>()</code> /
<code><a href="#topic+dropRegion.AbstractCBS">*dropRegion</a>()</code>
- Drops specified regions and returns an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>
without them.
</p>
</li>
<li> <p><code><a href="#topic+dropChangePoint.AbstractCBS">*dropChangePoint</a>()</code> /
<code><a href="#topic+mergeTwoSegments.AbstractCBS">*mergeTwoSegments</a>()</code>
- Drops a change point by merging two neighboring segments
and recalculates the statistics for the merged segment
before returning an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+dropChangePoints.AbstractCBS">*dropChangePoints</a>()</code>
- Drops zero or more change points
and recalculates the segment statistics
before returning an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+mergeThreeSegments.AbstractCBS">*mergeThreeSegments</a>()</code>
- Merges a segment with its two flanking segments
and recalculates the statistics for the merged segment
before returning an <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>
</li></ul>

<p>All of the above methods are implemented for <code><a href="#topic+CBS">CBS</a></code> and
<code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>.
</p>

<hr>
<h2 id='segmentByCBS'>Segment genomic signals using the CBS method</h2><span id='topic+segmentByCBS.default'></span><span id='topic+segmentByCBS'></span><span id='topic+segmentByCBS.data.frame'></span><span id='topic+segmentByCBS.CBS'></span><span id='topic+segmentByCBS.CNA'></span><span id='topic+segmentByCBS'></span>

<h3>Description</h3>

<p>Segment genomic signals using the CBS method of the <span class="pkg">DNAcopy</span> package.
This is a convenient low-level wrapper for the <code>DNAcopy::segment()</code>
method.  It is intended to be applied to a sample at the time.
For more details on the Circular Binary Segmentation (CBS) method
see [1,2].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
segmentByCBS(y, chromosome=0L, x=NULL, index=seq_along(y), w=NULL, undo=0,
  avg=c("mean", "median"), ..., joinSegments=TRUE, knownSegments=NULL, seed=NULL,
  verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentByCBS_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J genomic signals to be segmented.</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_chromosome">chromosome</code></td>
<td>
<p>Optional <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length J, specifying
the chromosome of each loci.  If a scalar, it is expanded to
a vector of length J.</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_x">x</code></td>
<td>
<p>Optional <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J genomic locations.
If <code><a href="base.html#topic+NULL">NULL</a></code>, index locations <code>1:J</code> are used.</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_index">index</code></td>
<td>
<p>An optional <code><a href="base.html#topic+integer">integer</a></code> <code><a href="base.html#topic+vector">vector</a></code> of length J specifying
the genomewide indices of the loci.</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_w">w</code></td>
<td>
<p>Optional <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> in [0,1] of J weights.</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_undo">undo</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+numeric">numeric</a></code>.  If greater than zero, then
arguments <code>undo.splits="sdundo"</code> and <code>undo.SD=undo</code>
are passed to <code>DNAcopy::segment()</code>.
In the special case when <code>undo</code> is +<code><a href="base.html#topic+is.finite">Inf</a></code>, the segmentation
result will not contain any changepoints (in addition to what
is specified by argument <code>knownSegments</code>).</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_avg">avg</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying how to calculating
segment mean levels <em>after</em> change points have been
identified.</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>DNAcopy::segment()</code>
segmentation function.</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_joinsegments">joinSegments</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, there are no gaps between neighboring
segments.
If <code><a href="base.html#topic+logical">FALSE</a></code>, the boundaries of a segment are defined by the support
that the loci in the segments provides, i.e. there exist a locus
at each end point of each segment.  This also means that there
is a gap between any neighboring segments, unless the change point
is in the middle of multiple loci with the same position.
The latter is what <code>DNAcopy::segment()</code> returns.
</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_knownsegments">knownSegments</code></td>
<td>
<p>Optional <code><a href="base.html#topic+data.frame">data.frame</a></code> specifying
<em>non-overlapping</em> known segments.  These segments must
not share loci.  See <code><a href="#topic+findLargeGaps">findLargeGaps</a></code>() and <code><a href="#topic+gapsToSegments">gapsToSegments</a></code>().</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_seed">seed</code></td>
<td>
<p>An (optional) <code><a href="base.html#topic+integer">integer</a></code> specifying the random seed to be
set before calling the segmentation method.  The random seed is
set to its original state when exiting.  If <code><a href="base.html#topic+NULL">NULL</a></code>, it is not set.</p>
</td></tr>
<tr><td><code id="segmentByCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally <code><a href="DNAcopy.html#topic+segment">segment</a></code> of <span class="pkg">DNAcopy</span> is used to
segment the signals.
This segmentation method support weighted segmentation.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+CBS">CBS</a></code> object.
</p>


<h3>Reproducibility</h3>

<p>The <code>DNAcopy::segment()</code> implementation of CBS uses approximation
through random sampling for some estimates.  Because of this,
repeated calls using the same signals may result in slightly
different results, unless the random seed is set/fixed.
</p>


<h3>Missing and non-finite values</h3>

<p>Signals may contain missing values (<code><a href="base.html#topic+NA">NA</a></code> or <code><a href="base.html#topic+is.finite">NaN</a></code>), but not
infinite values (+/-<code><a href="base.html#topic+is.finite">Inf</a></code>).  Loci with missing-value signals
are preserved and keep in the result.
</p>
<p>Likewise, genomic positions may contain missing values.
However, if they do, such loci are silently excluded before
performing the segmentation, and are not kept in the results.
The mapping between the input locus-level data and ditto of
the result can be inferred from the <code>index</code> column of
the locus-level data of the result.
</p>
<p>None of the input data may have infinite values,
i.e. -<code><a href="base.html#topic+is.finite">Inf</a></code> or +<code><a href="base.html#topic+is.finite">Inf</a></code>. If so, an informative error is thrown.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] A.B. Olshen, E.S. Venkatraman (aka Venkatraman E. Seshan), R. Lucito and M. Wigler, <em>Circular binary segmentation for the analysis of array-based DNA copy number data</em>, Biostatistics, 2004
<br />
[2] E.S. Venkatraman and A.B. Olshen, <em>A faster circular binary segmentation algorithm for the analysis of array CGH data</em>, Bioinformatics, 2007
<br />
</p>


<h3>See Also</h3>

<p>To segment allele-specific tumor copy-number signals from a tumor
<em>with</em> a matched normal, see <code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>().
For the same <em>without</em> a matched normal,
see <code><a href="#topic+segmentByNonPairedPSCBS">segmentByNonPairedPSCBS</a></code>().
</p>
<p>It is also possible to prune change points after segmentation (with
identical results) using
<code><a href="#topic+pruneBySdUndo.CBS">pruneBySdUndo</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Simulating copy-number data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
set.seed(0xBEEF)

# Number of loci
J &lt;- 1000

mu &lt;- double(J)
mu[200:300] &lt;- mu[200:300] + 1
mu[350:400] &lt;- NA # centromere
mu[650:800] &lt;- mu[650:800] - 1
eps &lt;- rnorm(J, sd=1/2)
y &lt;- mu + eps
x &lt;- sort(runif(length(y), max=length(y))) * 1e5
w &lt;- runif(J)
w[650:800] &lt;- 0.001


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Segmentation
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fit &lt;- segmentByCBS(y, x=x)
print(fit)
plotTracks(fit)


     
xlab &lt;- "Position (Mb)"
ylim &lt;- c(-3,3)
xMb &lt;- x/1e6
plot(xMb,y, pch=20, col="#aaaaaa", xlab=xlab, ylim=ylim)
drawLevels(fit, col="red", lwd=2, xScale=1e-6)

 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# TESTS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fit &lt;- segmentByCBS(y, x=x, seed=0xBEEF)
print(fit)
##   id chromosome       start      end nbrOfLoci    mean
## 1  y          0    55167.82 20774251       201  0.0164
## 2  y          0 20774250.85 29320105        99  1.0474
## 3  y          0 29320104.86 65874675       349 -0.0227
## 4  y          0 65874675.06 81348129       151 -1.0813
## 5  y          0 81348129.20 99910827       200 -0.0612


# Test #1: Reverse the ordering and segment
fitR &lt;- segmentByCBS(rev(y), x=rev(x), seed=0xBEEF)
# Sanity check
stopifnot(all.equal(getSegments(fitR), getSegments(fit)))
# Sanity check
stopifnot(all.equal(rev(getLocusData(fitR)$index), getLocusData(fit)$index))

# Test #2: Reverse, but preserve ordering of 'data' object
fitRP &lt;- segmentByCBS(rev(y), x=rev(x), preserveOrder=TRUE)
stopifnot(all.equal(getSegments(fitRP), getSegments(fit)))


# (Test #3: Change points inbetween data points at the same locus)
x[650:654] &lt;- x[649]
fitC &lt;- segmentByCBS(rev(y), x=rev(x), preserveOrder=TRUE, seed=0xBEEF)

# Test #4: Allow for some missing values in signals
y[450] &lt;- NA
fitD &lt;- segmentByCBS(y, x=x, seed=0xBEEF)


# Test #5: Allow for some missing genomic annotations
x[495] &lt;- NA
fitE &lt;- segmentByCBS(y, x=x, seed=0xBEEF)


# Test #6: Undo all change points found
fitF &lt;- segmentByCBS(y, x=x, undo=Inf, seed=0xBEEF)
print(fitF)
stopifnot(nbrOfSegments(fitF) == 1L)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# MISC.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Emulate a centromere
x[650:699] &lt;- NA
fit &lt;- segmentByCBS(y, x=x, seed=0xBEEF)
xMb &lt;- x/1e6
plot(xMb,y, pch=20, col="#aaaaaa", xlab=xlab, ylim=ylim)
drawLevels(fit, col="red", lwd=2, xScale=1e-6)

fitC &lt;- segmentByCBS(y, x=x, joinSegments=FALSE, seed=0xBEEF)
drawLevels(fitC, col="blue", lwd=2, xScale=1e-6)



# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Multiple chromosomes
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Appending CBS results
fit1 &lt;- segmentByCBS(y, chromosome=1, x=x)
fit2 &lt;- segmentByCBS(y, chromosome=2, x=x)
fit &lt;- c(fit1, fit2)
print(fit)
plotTracks(fit, subset=NULL, lwd=2, Clim=c(-3,3))


# Segmenting multiple chromosomes at once
chromosomeWG &lt;- rep(1:2, each=J)
xWG &lt;- rep(x, times=2)
yWG &lt;- rep(y, times=2)
fitWG &lt;- segmentByCBS(yWG, chromosome=chromosomeWG, x=xWG)
print(fitWG)
plotTracks(fitWG, subset=NULL, lwd=2, Clim=c(-3,3))

# Assert same results
fit$data[,"index"] &lt;- getLocusData(fitWG)[,"index"] # Ignore 'index'
stopifnot(all.equal(getLocusData(fitWG), getLocusData(fit)))
stopifnot(all.equal(getSegments(fitWG), getSegments(fit)))

</code></pre>

<hr>
<h2 id='segmentByNonPairedPSCBS'>Segment total copy numbers and allele B fractions using the Non-paired PSCBS method</h2><span id='topic+segmentByNonPairedPSCBS.default'></span><span id='topic+segmentByNonPairedPSCBS'></span><span id='topic+segmentByNonPairedPSCBS.data.frame'></span><span id='topic+segmentByNonPairedPSCBS.PairedPSCBS'></span><span id='topic+segmentByNonPairedPSCBS'></span>

<h3>Description</h3>

<p>Segment total copy numbers and allele B fractions using the Non-paired PSCBS method [1].
This method does not requires matched normals.
This is a low-level segmentation method.
It is intended to be applied to one tumor sample at the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
segmentByNonPairedPSCBS(CT, betaT, ..., flavor=c("tcn", "tcn&amp;dh", "tcn,dh",
  "sqrt(tcn),dh", "sqrt(tcn)&amp;dh"), tauA=NA, tauB=1 - tauA, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentByNonPairedPSCBS_+3A_ct">CT</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J tumor total copy number (TCN)
ratios in [0,+<code><a href="base.html#topic+is.finite">Inf</a></code>) (due to noise, small negative values are
also allowed).  The TCN ratios are typically scaled such that
copy-neutral diploid loci have a mean of two.</p>
</td></tr>
<tr><td><code id="segmentByNonPairedPSCBS_+3A_betat">betaT</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J tumor allele B fractions (BAFs)
in [0,1] (due to noise, values may be slightly outside as well)
or <code><a href="base.html#topic+NA">NA</a></code> for non-polymorphic loci.</p>
</td></tr>
<tr><td><code id="segmentByNonPairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>().</p>
</td></tr>
<tr><td><code id="segmentByNonPairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying what type of segmentation and
calling algorithm to be used.</p>
</td></tr>
<tr><td><code id="segmentByNonPairedPSCBS_+3A_taua">tauA</code>, <code id="segmentByNonPairedPSCBS_+3A_taub">tauB</code></td>
<td>
<p>Lower and upper thresholds (<code>tauA &lt; tauB</code> for
calling SNPs  heterozygous based on the tumor allele B fractions
(<code>betaT</code>).  If <code><a href="base.html#topic+NA">NA</a></code>, then they are estimates from data.
</p>
</td></tr>
<tr><td><code id="segmentByNonPairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally <code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>() is used for segmentation.
This segmentation method does <em>not</em> support weights.
</p>


<h3>Value</h3>

<p>Returns the segmentation results as a <code><a href="#topic+NonPairedPSCBS">NonPairedPSCBS</a></code> object.
</p>


<h3>Reproducibility</h3>

<p>The &quot;DNAcopy::segment&quot; implementation of CBS uses approximation
through random sampling for some estimates.  Because of this,
repeated calls using the same signals may result in slightly
different results, unless the random seed is set/fixed.
</p>


<h3>Whole-genome segmentation is preferred</h3>

<p>Although it is possible to segment each chromosome independently
using Paired PSCBS, we strongly recommend to segment whole-genome
(TCN,BAF) data at once.  The reason for this is that downstream
CN-state calling methods, such as the AB and the LOH callers,
performs much better on whole-genome data.  In fact, they may
fail to provide valid calls if done chromosome by chromosome.
</p>


<h3>Missing and non-finite values</h3>

<p>The total copy number signals as well as any optional positions
must not contain missing values, i.e. <code><a href="base.html#topic+NA">NA</a></code>s or <code><a href="base.html#topic+is.finite">NaN</a></code>s.
If there are any, an informative error is thrown.
Allele B fractions may contain missing values, because such are
interpreted as representing non-polymorphic loci.
</p>
<p>None of the input signals may have infinite values, i.e. -<code><a href="base.html#topic+is.finite">Inf</a></code> or +<code><a href="base.html#topic+is.finite">Inf</a></code>.
If so, an informative error is thrown.
</p>


<h3>Non-Paired PSCBS with known genotypes</h3>

<p>If allele B fractions for the matched normal (<code>betaN</code>) are
not available, but genotypes (<code>muN</code>) are, then it is possible
to run Paired PSCBS.   See <code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>() for details.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] A.B. Olshen, H. Bengtsson, P. Neuvial, P.T. Spellman, R.A. Olshen, V.E. Seshan, <em>Parent-specific copy number in paired tumor-normal studies using circular binary segmentation</em>, Bioinformatics, 2011
<br />
[2] H. Bengtsson, P. Neuvial and T.P. Speed, <em>TumorBoost: Normalization of allele-specific tumor copy numbers from a single pair of tumor-normal genotyping microarrays</em>, BMC Bioinformatics, 2010
<br />
</p>


<h3>See Also</h3>

<p>To segment paired tumor-normal total copy numbers and allele B fractions,
see <code><a href="#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>().
</p>
<p>To segment total copy numbers, or any other unimodal signals,
see <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>verbose &lt;- R.utils::Arguments$getVerbose(-10*interactive(), timestamp=TRUE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load SNP microarray data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
data &lt;- PSCBS::exampleData("paired.chr01")
str(data)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Paired PSCBS segmentation
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Drop single-locus outliers
dataS &lt;- dropSegmentationOutliers(data)

# Speed up example by segmenting fewer loci
dataS &lt;- dataS[seq(from=1, to=nrow(data), by=20),]

str(dataS)

R.oo::attachLocally(dataS)

# Non-Paired PSCBS segmentation
fit &lt;- segmentByNonPairedPSCBS(CT, betaT=betaT,
                            chromosome=chromosome, x=x,
                            seed=0xBEEF, verbose=verbose)
print(fit)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Bootstrap segment level estimates
# (used by the AB caller, which, if skipped here,
#  will do it automatically)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fit &lt;- bootstrapTCNandDHByRegion(fit, B=100, verbose=verbose)
print(fit)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Calling segments in allelic balance (AB)
# NOTE: Ideally, this should be done on whole-genome data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Explicitly estimate the threshold in DH for calling AB
# (which be done by default by the caller, if skipped here)
deltaAB &lt;- estimateDeltaAB(fit, flavor="qq(DH)", verbose=verbose)
print(deltaAB)

fit &lt;- callAB(fit, delta=deltaAB, verbose=verbose)
print(fit)


# Even if not explicitly specified, the estimated
# threshold parameter is returned by the caller
stopifnot(fit$params$deltaAB == deltaAB)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Calling segments in loss-of-heterozygosity (LOH)
# NOTE: Ideally, this should be done on whole-genome data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Explicitly estimate the threshold in C1 for calling LOH
# (which be done by default by the caller, if skipped here)
deltaLOH &lt;- estimateDeltaLOH(fit, flavor="minC1|nonAB", verbose=verbose)
print(deltaLOH)

fit &lt;- callLOH(fit, delta=deltaLOH, verbose=verbose)
print(fit)
plotTracks(fit)

# Even if not explicitly specified, the estimated
# threshold parameter is returned by the caller
stopifnot(fit$params$deltaLOH == deltaLOH)
</code></pre>

<hr>
<h2 id='segmentByPairedPSCBS'>Segment total copy numbers and allele B fractions using the Paired PSCBS method</h2><span id='topic+segmentByPairedPSCBS.default'></span><span id='topic+segmentByPairedPSCBS'></span><span id='topic+segmentByPairedPSCBS.data.frame'></span><span id='topic+segmentByPairedPSCBS.PairedPSCBS'></span><span id='topic+segmentByPairedPSCBS'></span>

<h3>Description</h3>

<p>Segment total copy numbers and allele B fractions using the Paired PSCBS method [1].
This method requires matched normals.
This is a low-level segmentation method.
It is intended to be applied to one tumor-normal sample at the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
segmentByPairedPSCBS(CT, thetaT=NULL, thetaN=NULL, betaT=NULL, betaN=NULL, muN=NULL,
  rho=NULL, chromosome=0, x=NULL, alphaTCN=0.009, alphaDH=0.001, undoTCN=0, undoDH=0,
  ..., avgTCN=c("mean", "median"), avgDH=c("mean", "median"),
  flavor=c("tcn&amp;dh", "tcn,dh", "sqrt(tcn),dh", "sqrt(tcn)&amp;dh", "tcn"), tbn=is.null(rho),
  joinSegments=TRUE, knownSegments=NULL, dropMissingCT=TRUE, seed=NULL, verbose=FALSE,
  preserveScale=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentByPairedPSCBS_+3A_ct">CT</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J tumor total copy number (TCN)
ratios in [0,+<code><a href="base.html#topic+is.finite">Inf</a></code>) (due to noise, small negative values are
also allowed).  The TCN ratios are typically scaled such that
copy-neutral diploid loci have a mean of two.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_thetat">thetaT</code>, <code id="segmentByPairedPSCBS_+3A_thetan">thetaN</code></td>
<td>
<p>(alternative) As an alternative to specifying
tumor TCN <em>ratios</em> relative to the match normal by
argument <code>CT</code>, on may specify total tumor and normal
signals seperately, in which case the TCN ratios <code>CT</code> are
calculated as <code class="reqn">CT = 2*thetaT/thetaN</code>.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_betat">betaT</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J tumor allele B fractions (BAFs)
in [0,1] (due to noise, values may be slightly outside as well)
or <code><a href="base.html#topic+NA">NA</a></code> for non-polymorphic loci.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_betan">betaN</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J matched normal BAFs in [0,1]
(due to noise, values may be slightly outside as well) or <code><a href="base.html#topic+NA">NA</a></code>
for non-polymorphic loci.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_mun">muN</code></td>
<td>
<p>An optional <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J genotype calls in
{0,1/2,1} for AA, AB, and BB, respectively,
and <code><a href="base.html#topic+NA">NA</a></code> for non-polymorphic loci.
If not given, they are estimated from the normal BAFs using
<code><a href="aroma.light.html#topic+callNaiveGenotypes">callNaiveGenotypes</a></code> as described in [2].</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_rho">rho</code></td>
<td>
<p>(alternative to <code>betaT</code> and <code>betaN</code>/<code>muN</code>)
A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J decrease-of-heterozygosity signals (DHs)
in [0,1] (due to noise, values may be slightly larger than one
as well).  By definition, DH should be <code><a href="base.html#topic+NA">NA</a></code> for homozygous loci
and for non-polymorphic loci.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_chromosome">chromosome</code></td>
<td>
<p>(Optional) An <code><a href="base.html#topic+integer">integer</a></code> scalar (or a <code><a href="base.html#topic+vector">vector</a></code> of length J),
which can be used to specify which chromosome each locus belongs to
in case multiple chromosomes are segments.
This argument is also used for annotation purposes.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_x">x</code></td>
<td>
<p>Optional <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J genomic locations.
If <code><a href="base.html#topic+NULL">NULL</a></code>, index locations <code>1:J</code> are used.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_alphatcn">alphaTCN</code>, <code id="segmentByPairedPSCBS_+3A_alphadh">alphaDH</code></td>
<td>
<p>The significance levels for segmenting total
copy numbers (TCNs) and decrease-in-heterozygosity signals (DHs),
respectively.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_undotcn">undoTCN</code>, <code id="segmentByPairedPSCBS_+3A_undodh">undoDH</code></td>
<td>
<p>Non-negative <code><a href="base.html#topic+numeric">numeric</a></code>s.  If greater than 0,
then a cleanup of segmentions post segmentation is done.
See argument <code>undo</code> of <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>() for more
details.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_avgtcn">avgTCN</code>, <code id="segmentByPairedPSCBS_+3A_avgdh">avgDH</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying how to calculating
segment mean levels <em>after</em> change points have been
identified.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>().</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_flavor">flavor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying what type of segmentation and
calling algorithm to be used.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_tbn">tbn</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, <code>betaT</code> is normalized before segmentation
using the TumorBoost method [2], otherwise not.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_joinsegments">joinSegments</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, there are no gaps between neighboring
segments.
If <code><a href="base.html#topic+logical">FALSE</a></code>, the boundaries of a segment are defined by the support
that the loci in the segments provides, i.e. there exist a locus
at each end point of each segment.  This also means that there
is a gap between any neighboring segments, unless the change point
is in the middle of multiple loci with the same position.
The latter is what <code>DNAcopy::segment()</code> returns.
</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_knownsegments">knownSegments</code></td>
<td>
<p>Optional <code><a href="base.html#topic+data.frame">data.frame</a></code> specifying
<em>non-overlapping</em> known segments.  These segments must
not share loci.  See <code><a href="#topic+findLargeGaps">findLargeGaps</a></code>() and <code><a href="#topic+gapsToSegments">gapsToSegments</a></code>().</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_dropmissingct">dropMissingCT</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, loci for which 'CT' is missing
are dropped, otherwise not.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_seed">seed</code></td>
<td>
<p>An (optional) <code><a href="base.html#topic+integer">integer</a></code> specifying the random seed to be
set before calling the segmentation method.  The random seed is
set to its original state when exiting.  If <code><a href="base.html#topic+NULL">NULL</a></code>, it is not set.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
<tr><td><code id="segmentByPairedPSCBS_+3A_preservescale">preserveScale</code></td>
<td>
<p><em>Defunct - gives an error is specified.</em></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>() is used for segmentation.
The Paired PSCBS segmentation method does <em>not</em> support weights.
</p>


<h3>Value</h3>

<p>Returns the segmentation results as a <code><a href="#topic+PairedPSCBS">PairedPSCBS</a></code> object.
</p>


<h3>Reproducibility</h3>

<p>The &quot;DNAcopy::segment&quot; implementation of CBS uses approximation
through random sampling for some estimates.  Because of this,
repeated calls using the same signals may result in slightly
different results, unless the random seed is set/fixed.
</p>


<h3>Whole-genome segmentation is preferred</h3>

<p>Although it is possible to segment each chromosome independently
using Paired PSCBS, we strongly recommend to segment whole-genome
(TCN,BAF) data at once.  The reason for this is that downstream
CN-state calling methods, such as the AB and the LOH callers,
performs much better on whole-genome data.  In fact, they may
fail to provide valid calls if done chromosome by chromosome.
</p>


<h3>Missing and non-finite values</h3>

<p>The total copy number signals as well as any optional positions
must not contain missing values, i.e. <code><a href="base.html#topic+NA">NA</a></code>s or <code><a href="base.html#topic+is.finite">NaN</a></code>s.
If there are any, an informative error is thrown.
Allele B fractions may contain missing values, because such are
interpreted as representing non-polymorphic loci.
</p>
<p>None of the input signals may have infinite values, i.e. -<code><a href="base.html#topic+is.finite">Inf</a></code> or +<code><a href="base.html#topic+is.finite">Inf</a></code>.
If so, an informative error is thrown.
</p>


<h3>Paired PSCBS with only genotypes</h3>

<p>If allele B fractions for the matched normal (<code>betaN</code>) are
not available, but genotypes (<code>muN</code>) are, then it is possible
to run a version of Paired PSCBS where TumorBoost normalization
of the tumor allele B fractions is skipped.  In order for this
to work, argument <code>tbn</code> must be set to <code><a href="base.html#topic+logical">FALSE</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] A.B. Olshen, H. Bengtsson, P. Neuvial, P.T. Spellman, R.A. Olshen, V.E. Seshan, <em>Parent-specific copy number in paired tumor-normal studies using circular binary segmentation</em>, Bioinformatics, 2011
<br />
[2] H. Bengtsson, P. Neuvial and T.P. Speed, <em>TumorBoost: Normalization of allele-specific tumor copy numbers from a single pair of tumor-normal genotyping microarrays</em>, BMC Bioinformatics, 2010
<br />
</p>


<h3>See Also</h3>

<p>Internally, <code><a href="aroma.light.html#topic+callNaiveGenotypes">callNaiveGenotypes</a></code> is used to
call naive genotypes, <code><a href="aroma.light.html#topic+normalizeTumorBoost">normalizeTumorBoost</a></code> is
used for TumorBoost normalization, and <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>() is used
to segment TCN and DH separately.
</p>
<p>To segment tumor total copy numbers and allele B fractions
<em>without</em> a matched normal, see <code><a href="#topic+segmentByNonPairedPSCBS">segmentByNonPairedPSCBS</a></code>().
</p>
<p>To segment total copy-numbers, or any other unimodal signals,
see <code><a href="#topic+segmentByCBS">segmentByCBS</a></code>().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>verbose &lt;- R.utils::Arguments$getVerbose(-10*interactive(), timestamp=TRUE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Load SNP microarray data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
data &lt;- PSCBS::exampleData("paired.chr01")
str(data)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Paired PSCBS segmentation
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Drop single-locus outliers
dataS &lt;- dropSegmentationOutliers(data)

# Speed up example by segmenting fewer loci
dataS &lt;- dataS[seq(from=1, to=nrow(data), by=10),]

str(dataS)

R.oo::attachLocally(dataS)

# Paired PSCBS segmentation
fit &lt;- segmentByPairedPSCBS(CT, betaT=betaT, betaN=betaN,
                            chromosome=chromosome, x=x,
                            seed=0xBEEF, verbose=verbose)
print(fit)

# Plot results
plotTracks(fit)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Bootstrap segment level estimates
# (used by the AB caller, which, if skipped here,
#  will do it automatically)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
fit &lt;- bootstrapTCNandDHByRegion(fit, B=100, verbose=verbose)
print(fit)
plotTracks(fit)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Calling segments in allelic balance (AB)
# NOTE: Ideally, this should be done on whole-genome data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Explicitly estimate the threshold in DH for calling AB
# (which be done by default by the caller, if skipped here)
deltaAB &lt;- estimateDeltaAB(fit, flavor="qq(DH)", verbose=verbose)
print(deltaAB)
## [1] 0.1657131

fit &lt;- callAB(fit, delta=deltaAB, verbose=verbose)
print(fit)
plotTracks(fit)

# Even if not explicitly specified, the estimated
# threshold parameter is returned by the caller
stopifnot(fit$params$deltaAB == deltaAB)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Calling segments in loss-of-heterozygosity (LOH)
# NOTE: Ideally, this should be done on whole-genome data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Explicitly estimate the threshold in C1 for calling LOH
# (which be done by default by the caller, if skipped here)
deltaLOH &lt;- estimateDeltaLOH(fit, flavor="minC1|nonAB", verbose=verbose)
print(deltaLOH)
## [1] 0.625175

fit &lt;- callLOH(fit, delta=deltaLOH, verbose=verbose)
print(fit)
plotTracks(fit)

# Even if not explicitly specified, the estimated
# threshold parameter is returned by the caller
stopifnot(fit$params$deltaLOH == deltaLOH)
</code></pre>

<hr>
<h2 id='setSampleName.AbstractCBS'>Sets the name of the sample segmented</h2><span id='topic+setSampleName.AbstractCBS'></span><span id='topic+AbstractCBS.setSampleName'></span><span id='topic+setSampleName+2CAbstractCBS-method'></span><span id='topic+AbstractCBS.sampleName+3C-'></span><span id='topic+sampleName+3C-.AbstractCBS'></span><span id='topic+sampleName+3C-+2CAbstractCBS-method'></span>

<h3>Description</h3>

<p>Sets the name of the sample segmented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
setSampleName(fit, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSampleName.AbstractCBS_+3A_name">name</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string.</p>
</td></tr>
<tr><td><code id="setSampleName.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (invisibly) an updated object.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>For more information see <code><a href="#topic+AbstractCBS">AbstractCBS</a></code>..
</p>

<hr>
<h2 id='testROH.numeric'>Tests if a segment is in Run-of-Homozygosity (ROH)</h2><span id='topic+testROH.numeric'></span>

<h3>Description</h3>

<p>Tests if a segment is in Run-of-Homozygosity (ROH).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
testROH(muN, csN=NULL, betaN=NULL, minNbrOfSnps=1, delta=1/12, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testROH.numeric_+3A_mun">muN</code></td>
<td>
<p>An <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J genotype calls in
{0,1/2,1} for AA, AB, and BB, respectively,
and <code><a href="base.html#topic+NA">NA</a></code> for non-polymorphic loci.</p>
</td></tr>
<tr><td><code id="testROH.numeric_+3A_csn">csN</code></td>
<td>
<p>(optional) A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J genotype confidence scores.
If <code><a href="base.html#topic+NULL">NULL</a></code>, ad hoc scores calculated from <code>betaN</code> are used.</p>
</td></tr>
<tr><td><code id="testROH.numeric_+3A_betan">betaN</code></td>
<td>
<p>(optional) A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of J matched normal BAFs
in [0,1] (due to noise, values may be slightly outside as well)
or <code><a href="base.html#topic+NA">NA</a></code> for non-polymorphic loci.</p>
</td></tr>
<tr><td><code id="testROH.numeric_+3A_minnbrofsnps">minNbrOfSnps</code></td>
<td>
<p>Minimum number of SNPs required to test segment.
If not tested, <code><a href="base.html#topic+NA">NA</a></code> is returned.</p>
</td></tr>
<tr><td><code id="testROH.numeric_+3A_delta">delta</code></td>
<td>
<p>A <code><a href="base.html#topic+double">double</a></code> scalar specifying the maximum (weighted)
proportion of heterozygous SNPs allowed in an ROH region.</p>
</td></tr>
<tr><td><code id="testROH.numeric_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="testROH.numeric_+3A_verbose">verbose</code></td>
<td>
<p>See <code><a href="R.utils.html#topic+Verbose">Verbose</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+logical">logical</a></code>.
</p>


<h3>Author(s)</h3>

<p>Pierre Neuvial, Henrik Bengtsson</p>

<hr>
<h2 id='updateMeans.AbstractCBS'>Updates the CN mean levels for each segment independently</h2><span id='topic+updateMeans.AbstractCBS'></span><span id='topic+AbstractCBS.updateMeans'></span><span id='topic+updateMeans+2CAbstractCBS-method'></span><span id='topic+updateMeans.CBS'></span><span id='topic+updateMeans.NonPairedPSCBS'></span><span id='topic+updateMeans.PairedPSCBS'></span>

<h3>Description</h3>

<p>Updates the CN mean levels for each segment independently as if they were one large segment.
The locus-level data is not updated/modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
updateMeans(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateMeans.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Arguments specific to the class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the same class.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>

<hr>
<h2 id='updateMeansTogether.AbstractCBS'>Updates the CN mean levels jointly in sets of segments</h2><span id='topic+updateMeansTogether.AbstractCBS'></span><span id='topic+AbstractCBS.updateMeansTogether'></span><span id='topic+updateMeansTogether+2CAbstractCBS-method'></span><span id='topic+updateMeansTogether.CBS'></span><span id='topic+updateMeansTogether.PairedPSCBS'></span>

<h3>Description</h3>

<p>Updates the CN mean levels jointly in sets of segments as if they were one large segment.
The locus-level data is not updated/modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AbstractCBS'
updateMeansTogether(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateMeansTogether.AbstractCBS_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of the same class.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>This method is utilized by <code><a href="#topic+pruneByHClust.AbstractCBS">*pruneByHClust</a>()</code>.
</p>

<hr>
<h2 id='weightedQuantile'>Weighted Quantile Value</h2><span id='topic+weightedQuantile.default'></span><span id='topic+weightedQuantile'></span>

<h3>Description</h3>

<p>Computes a weighted quantile of a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
weightedQuantile(x, w, probs=c(0, 0.25, 0.5, 0.75, 1), na.rm=TRUE,
  method=c("wtd.quantile"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightedQuantile_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> containing the values whose weighted
quantile is to be computed.</p>
</td></tr>
<tr><td><code id="weightedQuantile_+3A_w">w</code></td>
<td>
<p>a numeric <code><a href="base.html#topic+vector">vector</a></code> of weights the same length as
<code>x</code> giving the weights to use for each element of <code>x</code>.
Negative weights are treated as zero weights.
Default value is equal weight to all values.</p>
</td></tr>
<tr><td><code id="weightedQuantile_+3A_probs">probs</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+vector">vector</a></code> of quantiles in [0,1] to be retrieved.</p>
</td></tr>
<tr><td><code id="weightedQuantile_+3A_na.rm">na.rm</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> value indicating whether <code><a href="base.html#topic+NA">NA</a></code> values in
<code>x</code> should be stripped before the computation proceeds,
or not.</p>
</td></tr>
<tr><td><code id="weightedQuantile_+3A_method">method</code></td>
<td>
<p>If <code>"wtd.quantile"</code>, then an internal copy of
<code>Hmisc::wtd.quantile()</code> is used.
No other methods are currently supported.</p>
</td></tr>
<tr><td><code id="weightedQuantile_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the estimator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the weighted quantile.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Internally the following functions may be used:
<code><a href="stats.html#topic+quantile">quantile</a></code> (if no weights are specified), or an internal
copy of <code>Hmisc::wtd.quantile()</code>.
For a weighted median estimator, <code><a href="matrixStats.html#topic+weightedMedian">weightedMedian</a></code>
of the <span class="pkg">matrixStats</span> package.
</p>

<hr>
<h2 id='writeSegments.CBS'>Writes the table of segments to file</h2><span id='topic+writeSegments.CBS'></span><span id='topic+CBS.writeSegments'></span><span id='topic+writeSegments+2CCBS-method'></span><span id='topic+writeWIG'></span><span id='topic+writeWIG.AbstractCBS'></span>

<h3>Description</h3>

<p>Writes the table of segments to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBS'
writeSegments(fit, name=getSampleName(fit), tags=NULL, ext="tsv", path=NULL,
  addHeader=TRUE, createdBy=NULL, sep="\t", nbrOfDecimals=4L, splitters=FALSE,
  overwrite=FALSE, skip=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeSegments.CBS_+3A_name">name</code>, <code id="writeSegments.CBS_+3A_tags">tags</code></td>
<td>
<p>Name and optional tags part of the filename</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="writeSegments.CBS_+3A_path">path</code></td>
<td>
<p>The directory where the file will be written.</p>
</td></tr>
<tr><td><code id="writeSegments.CBS_+3A_addheader">addHeader</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, header comments are written.</p>
</td></tr>
<tr><td><code id="writeSegments.CBS_+3A_createdby">createdBy</code></td>
<td>
<p>A header comment of whom created the file.</p>
</td></tr>
<tr><td><code id="writeSegments.CBS_+3A_splitters">splitters</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, each chromosome is separated by a row
of missing values.</p>
</td></tr>
<tr><td><code id="writeSegments.CBS_+3A_overwrite">overwrite</code>, <code id="writeSegments.CBS_+3A_skip">skip</code></td>
<td>
<p>If an output file already exists, these
arguments specifies what should happen.</p>
</td></tr>
<tr><td><code id="writeSegments.CBS_+3A_...">...</code></td>
<td>
<p>Additional arguments pass to <code>getSegments()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the pathname of the the file written.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Utilizes <code><a href="#topic+getSegments.CBS">*getSegments</a>()</code>.
For more information see <code><a href="#topic+CBS">CBS</a></code>..
</p>

<hr>
<h2 id='writeSegments.PSCBS'>Writes the table of segments to file</h2><span id='topic+writeSegments.PSCBS'></span><span id='topic+PSCBS.writeSegments'></span><span id='topic+writeSegments+2CPSCBS-method'></span>

<h3>Description</h3>

<p>Writes the table of segments to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PSCBS'
writeSegments(fit, name=getSampleName(fit), tags=NULL, ext="tsv", path=NULL,
  addHeader=TRUE, createdBy=NULL, sep="\t", nbrOfDecimals=4L, splitters=FALSE,
  overwrite=FALSE, skip=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeSegments.PSCBS_+3A_name">name</code>, <code id="writeSegments.PSCBS_+3A_tags">tags</code></td>
<td>
<p>Name and optional tags part of the filename</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="writeSegments.PSCBS_+3A_path">path</code></td>
<td>
<p>The directory where the file will be written.</p>
</td></tr>
<tr><td><code id="writeSegments.PSCBS_+3A_addheader">addHeader</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, header comments are written.</p>
</td></tr>
<tr><td><code id="writeSegments.PSCBS_+3A_createdby">createdBy</code></td>
<td>
<p>A header comment of whom created the file.</p>
</td></tr>
<tr><td><code id="writeSegments.PSCBS_+3A_splitters">splitters</code></td>
<td>
<p>If <code><a href="base.html#topic+logical">TRUE</a></code>, each chromosome is separated by a row
of missing values.</p>
</td></tr>
<tr><td><code id="writeSegments.PSCBS_+3A_overwrite">overwrite</code>, <code id="writeSegments.PSCBS_+3A_skip">skip</code></td>
<td>
<p>If an output file already exists, these
arguments specifies what should happen.</p>
</td></tr>
<tr><td><code id="writeSegments.PSCBS_+3A_...">...</code></td>
<td>
<p>Additional arguments pass to <code>getSegments()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the pathname of the the file written.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p>Utilizes <code><a href="#topic+getSegments.PSCBS">*getSegments</a>()</code>.
For more information see <code><a href="#topic+PSCBS">PSCBS</a></code>..
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
