<!DOCTYPE html><html><head><title>Help for package pliman</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pliman}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze_objects'><p>Analyzes objects in an image</p></a></li>
<li><a href='#analyze_objects_shp'><p>Analyzes objects using shapefiles</p></a></li>
<li><a href='#apply_fun_to_imgs'><p>Apply a function to images</p></a></li>
<li><a href='#as_image'><p>Create an <code>Image</code> object</p></a></li>
<li><a href='#calibrate'><p>Calibrates distances of landmarks</p></a></li>
<li><a href='#contours'><p>Contour outlines from five leaves</p></a></li>
<li><a href='#custom_palette'><p>Generate Custom Color Palette</p></a></li>
<li><a href='#dist_transform'><p>Distance map transform</p></a></li>
<li><a href='#efourier'><p>Elliptical Fourier Analysis</p></a></li>
<li><a href='#efourier_coefs'><p>Get Fourier coefficients</p></a></li>
<li><a href='#efourier_error'><p>Erros between the original and reconstructed outline</p></a></li>
<li><a href='#efourier_inv'><p>Inverse Elliptical Fourier Analysis</p></a></li>
<li><a href='#efourier_norm'><p>Normalized Fourier coefficients</p></a></li>
<li><a href='#efourier_power'><p>Power in Fourier Analysis</p></a></li>
<li><a href='#efourier_shape'><p>Draw shapes based on Fourier coefficients</p></a></li>
<li><a href='#ellipse'><p>Confidence ellipse</p></a></li>
<li><a href='#get_pliman_viewer'><p>Get the value of the pliman_viewer option</p></a></li>
<li><a href='#ggplot_color'><p>ggplot2-like colors generation</p></a></li>
<li><a href='#image_align'><p>Aligns an <code>Image</code> object by hand</p></a></li>
<li><a href='#image_augment'><p>Augment Images</p></a></li>
<li><a href='#image_binary'><p>Creates a binary image</p></a></li>
<li><a href='#image_combine'><p>Combines images to a grid</p></a></li>
<li><a href='#image_create'><p>Create an <code>Image</code> object of a given color</p></a></li>
<li><a href='#image_expand'><p>Expands an image</p></a></li>
<li><a href='#image_index'><p>Image indexes</p></a></li>
<li><a href='#image_prepare'><p>Prepare an image</p></a></li>
<li><a href='#image_segment'><p>Image segmentation</p></a></li>
<li><a href='#image_segment_kmeans'><p>Image segmentation using k-means clustering</p></a></li>
<li><a href='#image_segment_manual'><p>Image segmentation by hand</p></a></li>
<li><a href='#image_segment_mask'><p>Segment an <code>Image</code> object using a brush mask</p></a></li>
<li><a href='#image_shp'><p>Construct a shape file from an image</p></a></li>
<li><a href='#image_square'><p>Squares an image</p></a></li>
<li><a href='#image_thinning_guo_hall'><p>Perform Guo-Hall thinning on a binary image or list of binary images</p></a></li>
<li><a href='#image_to_mat'><p>Convert an image to a data.frame</p></a></li>
<li><a href='#image_view'><p>Create an interactive map view of an image</p></a></li>
<li><a href='#landmarks'><p>Create image landmarks</p></a></li>
<li><a href='#landmarks_add'><p>Artificially inflates the number of landmarks</p></a></li>
<li><a href='#landmarks_angle'><p>Angles between landmarks</p></a></li>
<li><a href='#landmarks_dist'><p>Distances between landmarks</p></a></li>
<li><a href='#landmarks_regradi'><p>Pseudolandmarks with equally spaced angles</p></a></li>
<li><a href='#leading_zeros'><p>Add leading zeros to a numeric sequence</p></a></li>
<li><a href='#make_brush'><p>Makes a brush</p></a></li>
<li><a href='#make_mask'><p>Makes a mask in an image</p></a></li>
<li><a href='#measure_disease'><p>Performs plant disease measurements</p></a></li>
<li><a href='#measure_disease_byl'><p>Performs plant disease measurements by leaf</p></a></li>
<li><a href='#measure_disease_shp'><p>Measure disease using shapefiles</p></a></li>
<li><a href='#mosaic_crop'><p>Crop a mosaic</p></a></li>
<li><a href='#mosaic_index'><p>Mosaic Index</p></a></li>
<li><a href='#mosaic_input'><p>Create and Export mosaics</p></a></li>
<li><a href='#mosaic_prepare'><p>Prepare a mosaic</p></a></li>
<li><a href='#mosaic_to_pliman'><p>Mosaic to pliman</p></a></li>
<li><a href='#mosaic_to_rgb'><p>Mosaic to RGB</p></a></li>
<li><a href='#mosaic_view'><p>Mosaic View</p></a></li>
<li><a href='#object_edge'><p>Object edges</p></a></li>
<li><a href='#object_export'><p>Export multiple objects from an image to multiple images</p></a></li>
<li><a href='#object_export_shp'><p>Export multiple objects from an image to multiple images</p></a></li>
<li><a href='#object_label'><p>Labels objects</p></a></li>
<li><a href='#object_map'><p>Map Object Distances</p></a></li>
<li><a href='#object_mark'><p>Mark Object Points</p></a></li>
<li><a href='#object_rgb'><p>Extract red, green and blue values from objects</p></a></li>
<li><a href='#object_split'><p>Splits objects from an image into multiple images</p></a></li>
<li><a href='#object_split_shp'><p>Splits image objects based on a shape file</p></a></li>
<li><a href='#object_to_color'><p>Apply color to image objects</p></a></li>
<li><a href='#otsu'><p>Calculate Otsu's threshold</p></a></li>
<li><a href='#palettes'><p>Create image palettes</p></a></li>
<li><a href='#pipe'><p>Forward-pipe operator</p></a></li>
<li><a href='#pixel_index'><p>Get the pixel indices for a given row of a binary image</p></a></li>
<li><a href='#pliman_images'><p>Sample images</p></a></li>
<li><a href='#pliman_viewer'><p>Global option for controlling the viewer in pliman package</p></a></li>
<li><a href='#plot_index'><p>Plot an image index</p></a></li>
<li><a href='#plot_index_shp'><p>Plot rectangles colored by a quantitative attribute and overlay on an RGB</p>
image</a></li>
<li><a href='#plot_lw'><p>Plot length and width lines on objects</p></a></li>
<li><a href='#plot.image_shp'><p>S3 method <code>plot</code> for <code>image_shp</code> objects</p></a></li>
<li><a href='#poly_apex_base_angle'><p>Calculate the apex and base angles of an object</p></a></li>
<li><a href='#poly_pcv'><p>Compute Perimeter Complexity Value (PCV)</p></a></li>
<li><a href='#poly_width_at'><p>Width at a given height</p></a></li>
<li><a href='#prepare_to_shp'><p>Prepare images to analyze_objects_shp()</p></a></li>
<li><a href='#random_color'><p>Random built-in color names</p></a></li>
<li><a href='#sad'><p>Produces Santandard Area Diagrams</p></a></li>
<li><a href='#separate_col'><p>Turns a single character column into multiple columns.</p></a></li>
<li><a href='#set_pliman_viewer'><p>Set the value of the pliman_viewer option</p></a></li>
<li><a href='#summary_index'><p>Summary an object index</p></a></li>
<li><a href='#utils_colorspace'><p>Convert between colour spaces</p></a></li>
<li><a href='#utils_dpi'><p>Utilities for image resolution</p></a></li>
<li><a href='#utils_file'><p>Utilities for file manipulation</p></a></li>
<li><a href='#utils_image'><p>Import and export images</p></a></li>
<li><a href='#utils_measures'><p>Utilities for object measures</p></a></li>
<li><a href='#utils_objects'><p>Utilities for working with image objects</p></a></li>
<li><a href='#utils_pca'><p>Utilities for Principal Component Axis analysis</p></a></li>
<li><a href='#utils_pick'><p>Utilities for picking up points in an image</p></a></li>
<li><a href='#utils_polygon'><p>Utilities for Polygons</p></a></li>
<li><a href='#utils_polygon_plot'><p>Utilities for plotting polygons</p></a></li>
<li><a href='#utils_rows_cols'><p>Utilities for handling with rows and columns</p></a></li>
<li><a href='#utils_shapes'><p>Utilities for drawing coordinates of known shapes</p></a></li>
<li><a href='#utils_stats'><p>These functions applies common statistics to a list of objects, returning a</p>
numeric vector.</a></li>
<li><a href='#utils_transform'><p>Spatial transformations</p></a></li>
<li><a href='#utils_wd'><p>Set and get the Working Directory quicky</p></a></li>
<li><a href='#watershed2'><p>Alternative watershed algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Plant Image Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for single or batch image manipulation and analysis as
    described by Olivoto (2022) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13803">doi:10.1111/2041-210X.13803</a>&gt; that can be
    used to quantify plant leaf area, assess disease severity, count
    objects, obtain shape measures, object landmarks, and compute
    Elliptical Fourier Analysis of the object outline, as described by
    Claude (2008) &lt;<a href="https://doi.org/10.1007%2F978-0-387-77789-4">doi:10.1007/978-0-387-77789-4</a>&gt;. Additionally, the
    package includes tools for analyzing grids, which enables high
    throughput field phenotyping using RGB imagery captured by unmanned
    aerial vehicles.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TiagoOlivoto/pliman">https://github.com/TiagoOlivoto/pliman</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TiagoOlivoto/pliman/issues">https://github.com/TiagoOlivoto/pliman/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, Rcpp, sf, stars, terra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocManager, EBImage, knitr, leafem (&ge; 0.2.0), leaflet (&ge;
2.1.2), mapedit (&ge; 0.6.0), mapview (&ge; 2.11.0), rmarkdown,
rstudioapi</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-14 17:16:27 UTC; tiago</td>
</tr>
<tr>
<td>Author:</td>
<td>Tiago Olivoto <a href="https://orcid.org/0000-0002-0241-9636"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tiago Olivoto &lt;tiagoolivoto@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-14 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze_objects'>Analyzes objects in an image</h2><span id='topic+analyze_objects'></span><span id='topic+plot.anal_obj'></span><span id='topic+analyze_objects_iter'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+analyze_objects">analyze_objects()</a></code> provides tools for counting and extracting object
features (e.g., area, perimeter, radius, pixel intensity) in an image. See
more at the <strong>Details</strong> section.
</p>
</li>
<li> <p><code><a href="#topic+analyze_objects_iter">analyze_objects_iter()</a></code> provides an iterative section to measure object
features using an object with a known area.
</p>
</li>
<li> <p><code><a href="#topic+plot.anal_obj">plot.anal_obj()</a></code> produces a histogram for the R, G, and B values when
argument <code>object_index</code> is used in the function <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>analyze_objects(
  img,
  foreground = NULL,
  background = NULL,
  pick_palettes = FALSE,
  segment_objects = TRUE,
  viewer = get_pliman_viewer(),
  reference = FALSE,
  reference_area = NULL,
  back_fore_index = "R/(G/B)",
  fore_ref_index = "B-R",
  reference_larger = FALSE,
  reference_smaller = FALSE,
  pattern = NULL,
  parallel = FALSE,
  workers = NULL,
  watershed = TRUE,
  veins = FALSE,
  sigma_veins = 1,
  ab_angles = FALSE,
  ab_angles_percentiles = c(0.25, 0.75),
  width_at = FALSE,
  width_at_percentiles = c(0.05, 0.25, 0.5, 0.75, 0.95),
  haralick = FALSE,
  har_nbins = 32,
  har_scales = 1,
  har_band = 1,
  pcv = FALSE,
  pcv_niter = 100,
  resize = FALSE,
  trim = FALSE,
  fill_hull = FALSE,
  filter = FALSE,
  invert = FALSE,
  object_size = "medium",
  index = "NB",
  r = 1,
  g = 2,
  b = 3,
  re = 4,
  nir = 5,
  object_index = NULL,
  pixel_level_index = FALSE,
  return_mask = FALSE,
  efourier = FALSE,
  nharm = 10,
  threshold = "Otsu",
  k = 0.1,
  windowsize = NULL,
  tolerance = NULL,
  extension = NULL,
  lower_noise = 0.1,
  lower_size = NULL,
  upper_size = NULL,
  topn_lower = NULL,
  topn_upper = NULL,
  lower_eccent = NULL,
  upper_eccent = NULL,
  lower_circ = NULL,
  upper_circ = NULL,
  randomize = TRUE,
  nrows = 1000,
  plot = TRUE,
  show_original = TRUE,
  show_chull = FALSE,
  show_contour = TRUE,
  contour_col = "red",
  contour_size = 1,
  show_lw = FALSE,
  show_background = TRUE,
  show_segmentation = FALSE,
  col_foreground = NULL,
  col_background = NULL,
  marker = FALSE,
  marker_col = NULL,
  marker_size = NULL,
  save_image = FALSE,
  prefix = "proc_",
  dir_original = NULL,
  dir_processed = NULL,
  verbose = TRUE
)

## S3 method for class 'anal_obj'
plot(
  x,
  which = "measure",
  measure = "area",
  type = c("density", "histogram"),
  ...
)

analyze_objects_iter(pattern, known_area, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_objects_+3A_img">img</code></td>
<td>
<p>The image to be analyzed.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_foreground">foreground</code>, <code id="analyze_objects_+3A_background">background</code></td>
<td>
<p>A color palette for the foregrond and background,
respectively (optional). If a chacarceter is used (eg., <code>foreground = "fore"</code>), the function will search in the current working directory a valid
image named &quot;fore&quot;.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_pick_palettes">pick_palettes</code></td>
<td>
<p>Logical argument indicating wheater the user needs to
pick up the color palettes for foreground and background for the image. If
<code>TRUE</code> <code><a href="#topic+pick_palette">pick_palette()</a></code> will be called internally so that the user can sample
color points representing foreground and background.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_segment_objects">segment_objects</code></td>
<td>
<p>Segment objects in the image? Defaults to <code>TRUE</code>. In
this case, objects are segmented using the index defined in the <code>index</code>
argument, and each object is analyzed individually. If <code>segment_objects = FALSE</code> is used, the objects are not segmented and the entire image is
analyzed. This is useful, for example, when analyzing an image without
background, where an <code>object_index</code> could be computed for the entire image,
like the index of a crop canopy.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. This option controls the type of viewer to
use for interactive plotting (eg., when <code>pick_palettes = TRUE</code>).  If not
provided, the value is retrieved using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_reference">reference</code></td>
<td>
<p>Logical to indicate if a reference object is present in the
image. This is useful to adjust measures when images are not obtained with
standard resolution (e.g., field images). See more in the details section.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_reference_area">reference_area</code></td>
<td>
<p>The known area of the reference objects. The measures of
all the objects in the image will be corrected using the same unit of the
area informed here.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_back_fore_index">back_fore_index</code></td>
<td>
<p>A character value to indicate the index to segment the
foreground (objects and reference) from the background. Defaults to
<code>"R/(G/B)"</code>. This index is optimized to segment white backgrounds from green
leaves and a blue reference object.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_fore_ref_index">fore_ref_index</code></td>
<td>
<p>A character value to indicate the index to segment
objects and the reference object. It can be either an available index in
<code>pliman</code> (see <code><a href="#topic+pliman_indexes">pliman_indexes()</a></code> or an own index computed with the R, G, and
B bands. Defaults to <code>"B-R"</code>. This index is optimized to segment green
leaves from a blue reference object after a white background has been
removed.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_reference_larger">reference_larger</code>, <code id="analyze_objects_+3A_reference_smaller">reference_smaller</code></td>
<td>
<p>Logical argument indicating when the
larger/smaller object in the image must be used as the reference object.
This only is valid when <code>reference</code> is set to <code>TRUE</code> and <code>reference_area</code>
indicates the area of the reference object. IMPORTANT. When
<code>reference_smaller</code> is used, objects with an area smaller than 1% of the
mean of all the objects are ignored. This is used to remove possible noise
in the image such as dust. So, be sure the reference object has an area that
will be not removed by that cutpoint.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_pattern">pattern</code></td>
<td>
<p>A pattern of file name used to identify images to be imported.
For example, if <code>pattern = "im"</code> all images in the current working directory
that the name matches the pattern (e.g., img1.-, image1.-, im2.-) will be
imported as a list. Providing any number as pattern (e.g., <code>pattern = "1"</code>)
will select images that are named as 1.-, 2.-, and so on. An error will be
returned if the pattern matches any file that is not supported (e.g.,
img1.pdf).</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> processes the images asynchronously (in parallel) in
separate R sessions running in the background on the same machine. It may
speed up the processing time, especially when <code>pattern</code> is used is informed.
When <code>object_index</code> is informed, multiple sections will be used to extract
the RGB values for each object in the image. This may significantly speed up
processing time when an image has lots of objects (say &gt;1000).</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the number
of parallel processes that can be active at the same time. By default, the
number of sections is set up to 30% of available cores.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_watershed">watershed</code></td>
<td>
<p>If <code>TRUE</code> (default) performs watershed-based object
detection. This will detect objects even when they are touching one other.
If <code>FALSE</code>, all pixels for each connected set of foreground pixels are set
to a unique object. This is faster but is not able to segment touching
objects.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_veins">veins</code></td>
<td>
<p>Logical argument indicating whether vein features are computed.
This will call <code><a href="#topic+object_edge">object_edge()</a></code> and applies the Sobel-Feldman Operator to
detect edges. The result is the proportion of edges in relation to the
entire area of the object(s) in the image. Note that <strong>THIS WILL BE AN
OPERATION ON AN IMAGE LEVEL, NOT OBJECT!</strong>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_sigma_veins">sigma_veins</code></td>
<td>
<p>Gaussian kernel standard deviation used in the gaussian
blur in the edge detection algorithm</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_ab_angles">ab_angles</code></td>
<td>
<p>Logical argument indicating whether apex and base angles
should be computed. Defaults to <code>FALSE</code>. If <code>TRUE</code>, <code>poly_apex_base_angle()</code>
are called and the base and apex angles are computed considering the 25th
and 75th percentiles of the object height. These percentiles can be changed
with the argument <code>ab_angles_percentiles</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_ab_angles_percentiles">ab_angles_percentiles</code></td>
<td>
<p>The percentiles indicating the heights of the
object for which the angle should be computed (from the apex and the
bottom). Defaults to c(0.25, 0.75), which means considering the 25th and
75th percentiles of the object height.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_width_at">width_at</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the widths of the object at a given set
of quantiles of the height are computed.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_width_at_percentiles">width_at_percentiles</code></td>
<td>
<p>A vector of heights along the vertical axis of
the object at which the width will be computed. The default value is
c(0.05, 0.25, 0.5, 0.75, 0.95), which means the function will return the
width at the 5th, 25th, 50th, 75th, and 95th percentiles of the object's
height.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_haralick">haralick</code></td>
<td>
<p>Logical value indicating whether Haralick features are
computed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_har_nbins">har_nbins</code></td>
<td>
<p>An integer indicating the number of bins using to compute the
Haralick matrix. Defaults to 32. See Details</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_har_scales">har_scales</code></td>
<td>
<p>A integer vector indicating the number of scales to use to
compute the Haralick features. See Details.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_har_band">har_band</code></td>
<td>
<p>The band to compute the Haralick features (1 = R, 2 = G, 3 =
B). Defaults to 1.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_pcv">pcv</code></td>
<td>
<p>Computes the Perimeter Complexity Value? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_pcv_niter">pcv_niter</code></td>
<td>
<p>An integer specifying the number of smoothing iterations for
computing the  Perimeter Complexity Value. Defaults to 100.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_resize">resize</code></td>
<td>
<p>Resize the image before processing? Defaults to <code>FALSE</code>. Use a
numeric value of range 0-100 (proportion of the size of the original image).</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_trim">trim</code></td>
<td>
<p>Number of pixels removed from edges in the analysis. The edges of
images are often shaded, which can affect image analysis. The edges of
images can be removed by specifying the number of pixels. Defaults to
<code>FALSE</code> (no trimmed edges).</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the binary image? Defaults to <code>FALSE</code>. This is
useful to fill holes in objects that have portions with a color similar to
the background. IMPORTANT: Objects touching each other can be combined into
one single object, which may underestimate the number of objects in an
image.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code><a href="#topic+image_filter">image_filter()</a></code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing noise,
but adversely affect edges.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image if desired. This is useful to process
images with a black background. Defaults to <code>FALSE</code>. If <code>reference = TRUE</code>
is use, <code>invert</code> can be declared as a logical vector of length 2 (eg.,
<code style="white-space: pre;">&#8288;invert = c(FALSE, TRUE&#8288;</code>). In this case, the segmentation of objects and
reference from the foreground using <code>back_fore_index</code> is performed using the
default (not inverted), and the segmentation of objects from the reference
is performed by inverting the selection (selecting pixels higher than the
threshold).</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_object_size">object_size</code></td>
<td>
<p>The size of the object. Used to automatically set up
<code>tolerance</code> and <code>extension</code> parameters. One of the following. <code>"small"</code>
(e.g, wheat grains), <code>"medium"</code> (e.g, soybean grains), <code>"large"</code>(e.g, peanut
grains), and <code>"elarge"</code> (e.g, soybean pods)'.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_index">index</code></td>
<td>
<p>A character value specifying the target mode for conversion to
binary image when <code>foreground</code> and <code>background</code> are not declared. Defaults
to <code>"NB"</code> (normalized blue). See <code><a href="#topic+image_index">image_index()</a></code> for more details. User can
also calculate your own index using the bands names, e.g. <code>index = "R+B/G"</code></p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_r">r</code>, <code id="analyze_objects_+3A_g">g</code>, <code id="analyze_objects_+3A_b">b</code>, <code id="analyze_objects_+3A_re">re</code>, <code id="analyze_objects_+3A_nir">nir</code></td>
<td>
<p>The red, green, blue, red-edge, and near-infrared bands
of the image, respectively. Defaults to 1, 2, 3, 4, and 5, respectively. If
a multispectral image is provided (5 bands), check the order of bands,
which are frequently presented in the 'BGR' format.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_object_index">object_index</code></td>
<td>
<p>Defaults to <code>FALSE</code>. If an index is informed, the average
value for each object is returned. It can be the R, G, and B values or any
operation involving them, e.g., <code>object_index = "R/B"</code>. In this case, it
will return for each object in the image, the average value of the R/B
ratio. Use <code><a href="#topic+pliman_indexes_eq">pliman_indexes_eq()</a></code> to see the equations of available indexes.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_pixel_level_index">pixel_level_index</code></td>
<td>
<p>Return the indexes computed in <code>object_index</code> in the
pixel level? Defaults to <code>FALSE</code> to avoid returning large data.frames.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_return_mask">return_mask</code></td>
<td>
<p>Returns the mask for the analyzed image? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_efourier">efourier</code></td>
<td>
<p>Logical argument indicating if Elliptical Fourier should be
computed for each object. This will call <code><a href="#topic+efourier">efourier()</a></code> internally. It
<code>efourier = TRUE</code> is used, both standard and normalized Fourier coefficients
are returned.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_nharm">nharm</code></td>
<td>
<p>An integer indicating the number of harmonics to use. Defaults to
10. For more details see <code><a href="#topic+efourier">efourier()</a></code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_threshold">threshold</code></td>
<td>
<p>The theshold method to be used.
</p>

<ul>
<li><p> By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image. If
a numeric value is informed, this value will be used as a threshold.
</p>
</li>
<li><p> If <code>threshold = "adaptive"</code>, adaptive thresholding (Shafait et al. 2008)
is used, and will depend on the <code>k</code> and <code>windowsize</code> arguments.
</p>
</li>
<li><p> If any non-numeric value different than <code>"Otsu"</code> and <code>"adaptive"</code> is used,
an iterative section will allow you to choose the threshold based on a
raster plot showing pixel intensity of the index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="analyze_objects_+3A_k">k</code></td>
<td>
<p>a numeric in the range 0-1. when <code>k</code> is high, local threshold
values tend to be lower. when <code>k</code> is low, local threshold value tend to be
higher.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_windowsize">windowsize</code></td>
<td>
<p>windowsize controls the number of local neighborhood in
adaptive thresholding. By default it is set to <code>1/3 * minxy</code>, where
<code>minxy</code> is the minimum dimension of the image (in pixels).</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_tolerance">tolerance</code></td>
<td>
<p>The minimum height of the object in the units of image
intensity between its highest point (seed) and the point where it contacts
another object (checked for every contact pixel). If the height is smaller
than the tolerance, the object will be combined with one of its neighbors,
which is the highest.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_extension">extension</code></td>
<td>
<p>Radius of the neighborhood in pixels for the detection of
neighboring objects. Higher value smooths out small objects.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_lower_noise">lower_noise</code></td>
<td>
<p>To prevent noise from affecting the image analysis, objects
with lesser than 10% of the mean area of all objects are removed
(<code>lower_noise = 0.1</code>). Increasing this value will remove larger noises (such
as dust points), but can remove desired objects too. To define an explicit
lower or upper size, use the <code>lower_size</code> and <code>upper_size</code> arguments.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_lower_size">lower_size</code>, <code id="analyze_objects_+3A_upper_size">upper_size</code></td>
<td>
<p>Lower and upper limits for size for the image
analysis. Plant images often contain dirt and dust.  Upper limit is set to
<code>NULL</code>, i.e., no upper limit used. One can set a known area or use
<code>lower_limit = 0</code> to select all objects (not advised). Objects that matches
the size of a given range of sizes can be selected by setting up the two
arguments. For example, if <code>lower_size = 120</code> and <code>upper_size = 140</code>,
objects with size greater than or equal 120 and less than or equal 140 will
be considered.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_topn_lower">topn_lower</code>, <code id="analyze_objects_+3A_topn_upper">topn_upper</code></td>
<td>
<p>Select the top <code>n</code> objects based on its area.
<code>topn_lower</code> selects the <code>n</code> elements with the smallest area whereas
<code>topn_upper</code> selects the <code>n</code> objects with the largest area.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_lower_eccent">lower_eccent</code>, <code id="analyze_objects_+3A_upper_eccent">upper_eccent</code>, <code id="analyze_objects_+3A_lower_circ">lower_circ</code>, <code id="analyze_objects_+3A_upper_circ">upper_circ</code></td>
<td>
<p>Lower and upper limit
for object eccentricity/circularity for the image analysis. Users may use
these arguments to remove objects such as square papers for scale (low
eccentricity) or cut petioles (high eccentricity) from the images. Defaults
to <code>NULL</code> (i.e., no lower and upper limits).</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_randomize">randomize</code></td>
<td>
<p>Randomize the lines before training the model?</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_nrows">nrows</code></td>
<td>
<p>The number of lines to be used in training step. Defaults to
2000.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_plot">plot</code></td>
<td>
<p>Show image after processing?</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_show_original">show_original</code></td>
<td>
<p>Show the count objects in the original image?</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_show_chull">show_chull</code></td>
<td>
<p>Show the convex hull around the objects? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_show_contour">show_contour</code></td>
<td>
<p>Show a contour line around the objects? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_contour_col">contour_col</code>, <code id="analyze_objects_+3A_contour_size">contour_size</code></td>
<td>
<p>The color and size for the contour line around
objects. Defaults to <code>contour_col = "red"</code> and <code>contour_size = 1</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_show_lw">show_lw</code></td>
<td>
<p>If <code>TRUE</code>, plots the length and width lines on each object
calling <code><a href="#topic+plot_lw">plot_lw()</a></code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_show_background">show_background</code></td>
<td>
<p>Show the background? Defaults to <code>TRUE</code>. A white
background is shown by default when <code>show_original = FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_show_segmentation">show_segmentation</code></td>
<td>
<p>Shows the object segmentation colored with random
permutations. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_col_foreground">col_foreground</code>, <code id="analyze_objects_+3A_col_background">col_background</code></td>
<td>
<p>Foreground and background color after
image processing. Defaults to <code>NULL</code>, in which <code>"black"</code>, and <code>"white"</code> are
used, respectively.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_marker">marker</code>, <code id="analyze_objects_+3A_marker_col">marker_col</code>, <code id="analyze_objects_+3A_marker_size">marker_size</code></td>
<td>
<p>The type, color and size of the object
marker. Defaults to <code>NULL</code>, which plots the object id. Use <code>marker = "point"</code> to show a point in each object or <code>marker = FALSE</code> to omit object
marker.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_save_image">save_image</code></td>
<td>
<p>Save the image after processing? The image is saved in the
current working directory named as <code style="white-space: pre;">&#8288;proc_*&#8288;</code> where <code>*</code> is the image name
given in <code>img</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_prefix">prefix</code></td>
<td>
<p>The prefix to be included in the processed images. Defaults to
<code>"proc_"</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_dir_original">dir_original</code>, <code id="analyze_objects_+3A_dir_processed">dir_processed</code></td>
<td>
<p>The directory containing the original and
processed images. Defaults to <code>NULL</code>. In this case, the function will search
for the image <code>img</code> in the current working directory. After processing, when
<code>save_image = TRUE</code>, the processed image will be also saved in such a
directory. It can be either a full path, e.g., <code>"C:/Desktop/imgs"</code>, or a
subfolder within the current working directory, e.g., <code>"/imgs"</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_x">x</code></td>
<td>
<p>An object of class <code>anal_obj</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_which">which</code></td>
<td>
<p>Which to plot. Either 'measure' (object measures) or 'index'
(object index). Defaults to <code>"measure"</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_measure">measure</code></td>
<td>
<p>The measure to plot. Defaults to <code>"area"</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_type">type</code></td>
<td>
<p>The type of plot. Either <code>"hist"</code> or <code>"density"</code>. Partial matches
are recognized.</p>
</td></tr>
<tr><td><code id="analyze_objects_+3A_...">...</code></td>
<td>
<p>Depends on the function:
</p>

<ul>
<li><p> For <code><a href="#topic+analyze_objects_iter">analyze_objects_iter()</a></code>, further arguments passed on to
<code><a href="#topic+analyze_objects">analyze_objects()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="analyze_objects_+3A_known_area">known_area</code></td>
<td>
<p>The known area of the template object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A binary image is first generated to segment the foreground and
background. The argument <code>index</code> is useful to choose a proper index to
segment the image (see <code><a href="#topic+image_binary">image_binary()</a></code> for more details). It is also
possible to provide color palettes for background and foreground (arguments
<code>background</code> and <code>foreground</code>, respectively). When this is used, a general
linear model (binomial family) fitted to the RGB values to segment fore- and
background.
</p>
<p>Then, the number of objects in the  foreground is counted. By setting up
arguments such as <code>lower_size</code> and <code>upper_size</code>, it is possible to set a
threshold for lower and upper sizes of the objects, respectively. The
argument <code>object_size</code> can be used to set up pre-defined values of
<code>tolerance</code> and <code>extension</code> depending on the image resolution. This will
influence the watershed-based object segmentation. Users can also tune up
<code>tolerance</code> and <code>extension</code> explicitly for a better precision of watershed
segmentation.
</p>
<p>If <code>watershed = FALSE</code> is used, all pixels for each connected set of
foreground pixels in <code>img</code> are set to a unique object. This is faster,
especially for a large number of objects, but it is not able to segment
touching objects.
</p>
<p>There are some ways to correct the measures based on a reference object. If
a reference object with a known area (<code>reference_area</code>) is used in the image
and <code>reference = TRUE</code> is used, the measures of the objects will be
corrected, considering the unit of measure informed in <code>reference_area</code>.
There are two main ways to work with reference objects.
</p>

<ul>
<li><p> The first, is to provide a reference object that has a contrasting color with
both the background and object of interest. In this case, the arguments
<code>back_fore_index</code> and <code>fore_ref_index</code> can be used to define an index to
first segment the reference object and objects to be measured from the
background, then the reference object from objects to be measured.
</p>
</li>
<li><p> The second one is to use a reference object that has a similar color to the
objects to be measured, but has a contrasting size. For example, if we are
counting small brown grains, we can use a brown reference template that has
an area larger (says 3 times the area of the grains) and then uses
<code>reference_larger = TRUE</code>. With this, the larger object in the image will be
used as the reference object. This is particularly useful when images are
captured with background light, such as the example  2. Some types: (i) It
is suggested that the reference object is not too much larger than the
objects of interest (mainly when the <code>watershed = TRUE</code>). In some cases, the
reference object can be broken into several pieces due to the watershed
algorithm. (ii) Since the reference object will increase the mean area of
the object, the argument <code>lower_noise</code> can be increased. By default
(<code>lower_noise = 0.1</code>) objects with lesser than 10% of the mean area of all
objects are removed. Since the mean area will be increased, increasing
<code>lower_noise</code> will remove dust and noises more reliably. The argument
<code>reference_smaller</code> can be used in the same way
</p>
</li></ul>

<p>By using <code>pattern</code>, it is possible to process several images with common
pattern names that are stored in the current working directory or in the
subdirectory informed in <code>dir_original</code>. To speed up the computation time,
one can set <code>parallel = TRUE</code>.
</p>
<p><code><a href="#topic+analyze_objects_iter">analyze_objects_iter()</a></code> can be used to process several images using an
object with a known area as a template. In this case, all the images in the
current working directory that match the <code>pattern</code> will be processed. For
each image, the function will compute the features for the objects and show
the identification (id) of each object. The user only needs to inform which
is the id of the known object. Then, given the <code>known_area</code>, all the
measures will be adjusted. In the end, a data.frame with the adjusted
measures will be returned. This is useful when the images are taken at
different heights. In such cases, the image resolution cannot be conserved.
Consequently, the measures cannot be adjusted using the argument <code>dpi</code> from
<code><a href="#topic+get_measures">get_measures()</a></code>, since each image will have a different resolution. NOTE:
This will only work in an interactive section.
</p>

<ul>
<li><p> Additional measures: By default, some measures are not computed, mainly due to
computational efficiency when the user only needs simple measures such as
area, length, and width.
</p>

<ul>
<li><p> If <code>haralick = TRUE</code>, The function computes 13 Haralick texture features for
each object based on a gray-level co-occurrence matrix (Haralick et al.
1979). Haralick features depend on the configuration of the parameters
<code>har_nbins</code> and <code>har_scales</code>. <code>har_nbins</code> controls the number of bins used
to compute the Haralick matrix. A smaller <code>har_nbins</code> can give more accurate
estimates of the correlation because the number of events per bin is higher.
While a higher value will give more sensitivity. <code>har_scales</code> controls the
number of scales used to compute the Haralick features. Since Haralick
features compute the correlation of intensities of neighboring pixels it is
possible to identify textures with different scales, e.g., a texture that is
repeated every two pixels or 10 pixels. By default, the Haralick features
are computed with the R band. To chance this default, use the argument
<code>har_band</code>. For example, <code>har_band = 2</code> will compute the features with the
green band.
</p>
</li>
<li><p> If <code>efourier = TRUE</code> is used, an Elliptical Fourier Analysis (Kuhl and
Giardina, 1982) is computed for each object contour using <code><a href="#topic+efourier">efourier()</a></code>.
</p>
</li>
<li><p> If <code>veins = TRUE</code> (experimental), vein features are computed. This will call
<code><a href="#topic+object_edge">object_edge()</a></code> and applies the Sobel-Feldman Operator to detect edges. The
result is the proportion of edges in relation to the entire area of the
object(s) in the image. Note that THIS WILL BE AN OPERATION ON AN IMAGE
LEVEL, NOT an OBJECT LEVEL! So, If vein features need to be computed for
leaves, it is strongly suggested to use one leaf per image.
</p>
</li>
<li><p> If <code>ab_angles = TRUE</code> the apex and base angles of each object are
computed with <code><a href="#topic+poly_apex_base_angle">poly_apex_base_angle()</a></code>. By default, the function computes
the angle from the first pixel of the apex of the object to the two pixels
that slice the object at the 25th percentile of the object height (apex
angle). The base angle is computed in the same way but from the first base
pixel.
</p>
</li>
<li><p> If <code>width_at = TRUE</code>, the width at the  5th, 25th, 50th, 75th, and 95th
percentiles of the object height are computed by default. These quantiles can
be adjusted with the <code>width_at_percentiles</code> argument.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p><code>analyze_objects()</code> returns a list with the following objects:
</p>

<ul>
<li> <p><code>results</code> A data frame with the following variables for each object in the
image:
</p>

<ul>
<li> <p><code>id</code>:  object identification.
</p>
</li>
<li> <p><code>x</code>,<code>y</code>:  x and y coordinates for the center of mass of the object.
</p>
</li>
<li> <p><code>area</code>:  area of the object (in pixels).
</p>
</li>
<li> <p><code>area_ch</code>:  the area of the convex hull around object (in pixels).
</p>
</li>
<li> <p><code>perimeter</code>: perimeter (in pixels).
</p>
</li>
<li> <p><code>radius_min</code>, <code>radius_mean</code>, and <code>radius_max</code>: The minimum, mean, and
maximum radius (in pixels), respectively.
</p>
</li>
<li> <p><code>radius_sd</code>: standard deviation of the mean radius (in pixels).
</p>
</li>
<li> <p><code>diam_min</code>, <code>diam_mean</code>, and <code>diam_max</code>: The minimum, mean, and
maximum diameter (in pixels), respectively.
</p>
</li>
<li> <p><code>major_axis</code>, <code>minor_axis</code>: elliptical fit for major and minor axes (in
pixels).
</p>
</li>
<li> <p><code>caliper</code>: The longest distance between any two points on the margin
of the object. See <code><a href="#topic+poly_caliper">poly_caliper()</a></code> for more details
</p>
</li>
<li> <p><code>length</code>, <code>width</code> The length and width of objects (in pixels). These
measures are obtained as the range of x and y coordinates after aligning
each object with <code><a href="#topic+poly_align">poly_align()</a></code>.
</p>
</li>
<li> <p><code>radius_ratio</code>: radius ratio given by <code>radius_max / radius_min</code>.
</p>
</li>
<li> <p><code>theta</code>: object angle (in radians).
</p>
</li>
<li> <p><code>eccentricity</code>: elliptical eccentricity computed using the
ratio of the eigen values (inertia axes of coordinates).
</p>
</li>
<li> <p><code>form_factor</code> (Wu et al., 2007):  the difference between a leaf and a
circle. It is defined as <code>4*pi*A/P</code>, where A is the area and P is the
perimeter of the object.
</p>
</li>
<li> <p><code>narrow_factor</code> (Wu et al., 2007): Narrow factor (<code>caliper / length</code>).
</p>
</li>
<li> <p><code>asp_ratio</code> (Wu et al., 2007): Aspect ratio (<code>length / width</code>).
</p>
</li>
<li> <p><code>rectangularity</code> (Wu et al., 2007): The similarity between a leaf and
a rectangle (<code>length * width/ area</code>).
</p>
</li>
<li> <p><code>pd_ratio</code> (Wu et al., 2007): Ratio of perimeter to diameter
(<code>perimeter / caliper</code>)
</p>
</li>
<li> <p><code>plw_ratio</code> (Wu et al., 2007): Perimeter ratio of length and width
(<code>perimeter / (length + width)</code>)
</p>
</li>
<li> <p><code>solidity</code>: object solidity given by <code>area / area_ch</code>.
</p>
</li>
<li> <p><code>convexity</code>: The convexity of the object computed using the ratio
between the perimeter of the convex hull and the perimeter of the polygon.
</p>
</li>
<li> <p><code>elongation</code>: The elongation of the object computed as <code>1 - width / length</code>.
</p>
</li>
<li> <p><code>circularity</code>: The object circularity given by <code>perimeter ^ 2 / area</code>.
</p>
</li>
<li> <p><code>circularity_haralick</code>: The Haralick's circularity (CH), computed as
<code>CH =  m/sd</code>, where <code>m</code> and <code>sd</code> are the mean and standard deviations
from each pixels of the perimeter to the centroid of the object.
</p>
</li>
<li> <p><code>circularity_norm</code>: The normalized circularity (Cn), to be unity for a
circle. This measure is computed as <code>Cn = perimeter ^ 2 / 4*pi*area</code> and
is invariant under translation, rotation, scaling transformations, and
dimensionless.
</p>
</li>
<li> <p><code>asm</code>: The angular second-moment feature.
</p>
</li>
<li> <p><code>con</code>: The contrast feature
</p>
</li>
<li> <p><code>cor</code>: Correlation measures the linear dependency of gray levels of
neighboring pixels.
</p>
</li>
<li> <p><code>var</code>: The variance of gray levels pixels.
</p>
</li>
<li> <p><code>idm</code>: The Inverse Difference Moment (IDM), i.e., the local
homogeneity.
</p>
</li>
<li> <p><code>sav</code>: The Sum Average.
</p>
</li>
<li> <p><code>sva</code>: The Sum Variance.
</p>
</li>
<li> <p><code>sen</code>: Sum Entropy.
</p>
</li>
<li> <p><code>dva</code>: Difference Variance.
</p>
</li>
<li> <p><code>den</code>: Difference Entropy
</p>
</li>
<li> <p><code>f12</code>: Difference Variance.
</p>
</li>
<li> <p><code>f13</code>: The angular second-moment feature.
</p>
</li></ul>

</li>
<li> <p><code>statistics</code>: A data frame with the summary statistics for the area of the
objects.
</p>
</li>
<li> <p><code>count</code>: If <code>pattern</code> is used, shows the number of objects in each image.
</p>
</li>
<li> <p><code>obj_rgb</code>: If <code>object_index</code> is used, returns the R, G, and B values
for each pixel of each object.
</p>
</li>
<li> <p><code>object_index</code>: If <code>object_index</code> is used, returns the index computed for
each object.
</p>
</li>
<li><p> Elliptical Fourier Analysis: If <code>efourier = TRUE</code> is used, the following
objects are returned.
</p>

<ul>
<li> <p><code>efourier</code>: The Fourier coefficients.  For more details see
<code><a href="#topic+efourier">efourier()</a></code>.
</p>
</li>
<li> <p><code>efourier_norm</code>: The normalized Fourier coefficients. For more details
see <code><a href="#topic+efourier_norm">efourier_norm()</a></code>.
</p>
</li>
<li> <p><code>efourier_error</code>: The error between original data and  reconstructed
outline. For more details see <code><a href="#topic+efourier_error">efourier_error()</a></code>.
</p>
</li>
<li> <p><code>efourier_power</code>: The spectrum of harmonic Fourier power.
For more details see <code><a href="#topic+efourier_power">efourier_power()</a></code>.
</p>
</li></ul>

</li>
<li> <p><code>veins</code>: If <code>veins = TRUE</code> is used, returns, for each image, the
proportion of veins (in fact the object edges) related to the total object(s)' area.
</p>
</li>
<li> <p><code>analyze_objects_iter()</code> returns a data.frame containing the features
described in the <code>results</code> object of <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.
</p>
</li>
<li> <p><code>plot.anal_obj()</code> returns a <code>trellis</code> object containing the distribution
of the pixels, optionally  for each object when <code>facet = TRUE</code> is used.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>
<p>Gupta, S., Rosenthal, D. M., Stinchcombe, J. R., &amp; Baucom, R. S. (2020). The
remarkable morphological diversity of leaf shape in sweet potato (Ipomoea
batatas): the influence of genetics, environment, and GE. New Phytologist,
225(5), 21832195. <a href="https://doi.org/10.1111/NPH.16286">doi:10.1111/NPH.16286</a>
</p>
<p>Haralick, R.M., K. Shanmugam, and I. Dinstein. 1973. Textural Features for Image
Classification. IEEE Transactions on Systems, Man, and Cybernetics SMC-3(6): 610621.
<a href="https://doi.org/10.1109/TSMC.1973.4309314">doi:10.1109/TSMC.1973.4309314</a>
</p>
<p>Kuhl, F. P., and Giardina, C. R. (1982). Elliptic Fourier features of a
closed contour. Computer Graphics and Image Processing 18, 236258. doi:
<a href="https://doi.org/10.1016/0146-664X%2882%2990034-X">doi:10.1016/0146-664X(82)90034-X</a>
</p>
<p>Lee, Y., &amp; Lim, W. (2017). Shoelace Formula: Connecting the Area of a Polygon
and the Vector Cross Product. The Mathematics Teacher, 110(8), 631636.
<a href="https://doi.org/10.5951/mathteacher.110.8.0631">doi:10.5951/mathteacher.110.8.0631</a>
</p>
<p>Montero, R. S., Bribiesca, E., Santiago, R., &amp; Bribiesca, E. (2009). State
of the Art of Compactness and Circularity Measures. International
Mathematical Forum, 4(27), 13051335.
</p>
<p>Chen, C.H., and P.S.P. Wang. 2005. Handbook of Pattern Recognition and
Computer Vision. 3rd ed. World Scientific.
</p>
<p>Wu, S. G., Bao, F. S., Xu, E. Y., Wang, Y.-X., Chang, Y.-F., and Xiang, Q.-L.
(2007). A Leaf Recognition Algorithm for Plant Classification Using
Probabilistic Neural Network. in 2007 IEEE International Symposium on Signal
Processing and Information Technology, 1116.
<a href="https://doi.org/10.1109/ISSPIT.2007.4458016">doi:10.1109/ISSPIT.2007.4458016</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
obj &lt;- analyze_objects(img)
obj$statistics

########################### Example 1 #########################
# Enumerate the objects in the original image
# Return the top-5 grains with the largest area
top &lt;-
 analyze_objects(img,
                 marker = "id",
                 topn_upper = 5)
top$results


#' ########################### Example 1 #########################
# Correct the measures based on the area of the largest object
# note that since the reference object

img &lt;- image_pliman("flax_grains.jpg")
res &lt;-
  analyze_objects(img,
                  index = "GRAY",
                  marker = "point",
                  show_contour = FALSE,
                  reference = TRUE,
                  reference_area = 6,
                  reference_larger = TRUE,
                  lower_noise = 0.3)



library(pliman)

img &lt;- image_pliman("soy_green.jpg")
# Segment the foreground (grains) using the normalized blue index (NB, default)
# Shows the average value of the blue index in each object

rgb &lt;-
   analyze_objects(img,
                   marker = "id",
                   object_index = "B",
                   pixel_level_index = TRUE)
# density of area
plot(rgb)

# histogram of perimeter
plot(rgb, measure = "perimeter", type = "histogram") # or 'hist'

# density of the blue (B) index
plot(rgb, which = "index")

</code></pre>

<hr>
<h2 id='analyze_objects_shp'>Analyzes objects using shapefiles</h2><span id='topic+analyze_objects_shp'></span>

<h3>Description</h3>

<p>Analyzes objects using shapefiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_objects_shp(
  img,
  nrow = 1,
  ncol = 1,
  buffer_x = 0,
  buffer_y = 0,
  prepare = FALSE,
  segment_objects = TRUE,
  viewer = get_pliman_viewer(),
  index = "R",
  r = 1,
  g = 2,
  b = 3,
  re = 4,
  nir = 5,
  shapefile = NULL,
  interactive = FALSE,
  plot = FALSE,
  parallel = FALSE,
  workers = NULL,
  watershed = TRUE,
  filter = FALSE,
  object_size = "medium",
  efourier = FALSE,
  object_index = NULL,
  veins = FALSE,
  width_at = FALSE,
  verbose = TRUE,
  invert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_objects_shp_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_nrow">nrow</code>, <code id="analyze_objects_shp_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows and columns to generate the shapefile
when <code>shapefile</code> is not declared. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_buffer_x">buffer_x</code>, <code id="analyze_objects_shp_+3A_buffer_y">buffer_y</code></td>
<td>
<p>Buffering factor for the width and height,
respectively, of each individual shape's side. A value between 0 and 0.5 where 0
means no buffering and 0.5 means complete buffering (default: 0). A value of
0.25 will buffer the shape by 25% on each side.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_prepare">prepare</code></td>
<td>
<p>Logical value indicating whether to prepare the image for
analysis using <code><a href="#topic+image_prepare">image_prepare()</a></code> function. Defaults to <code>FALSE</code>. Set to
<code>TRUE</code> to interactively align and crop the image before processing.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_segment_objects">segment_objects</code></td>
<td>
<p>Segment objects in the image? Defaults to <code>TRUE</code>. In
this case, objects are segmented using the index defined in the <code>index</code>
argument, and each object is analyzed individually. If <code>segment_objects = FALSE</code> is used, the objects are not segmented and the entire image is
analyzed. This is useful, for example, when analyzing an image without
background, where an <code>object_index</code> could be computed for the entire image,
like the index of a crop canopy.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_index">index</code></td>
<td>
<p>A character value specifying the target mode for conversion to
binary image when <code>foreground</code> and <code>background</code> are not declared. Defaults
to <code>"NB"</code> (normalized blue). See <code><a href="#topic+image_index">image_index()</a></code> for more details. User can
also calculate your own index using the bands names, e.g. <code>index = "R+B/G"</code></p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_r">r</code>, <code id="analyze_objects_shp_+3A_g">g</code>, <code id="analyze_objects_shp_+3A_b">b</code>, <code id="analyze_objects_shp_+3A_re">re</code>, <code id="analyze_objects_shp_+3A_nir">nir</code></td>
<td>
<p>The red, green, blue, red-edge, and near-infrared bands
of the image, respectively. Defaults to 1, 2, 3, 4, and 5, respectively. If
a multispectral image is provided (5 bands), check the order of bands,
which are frequently presented in the 'BGR' format.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_shapefile">shapefile</code></td>
<td>
<p>(Optional) An object created with <code><a href="#topic+image_shp">image_shp()</a></code>. If <code>NULL</code>
(default), both <code>nrow</code> and <code>ncol</code> must be declared.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_interactive">interactive</code></td>
<td>
<p>If <code>FALSE</code> (default) the grid is created automatically
based on the image dimension and number of nrow/columns. If <code>interactive = TRUE</code>, users must draw points at the diagonal of the desired bounding box
that will contain the grid.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_plot">plot</code></td>
<td>
<p>Plots the processed images? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> processes the images asynchronously (in parallel) in
separate R sessions running in the background on the same machine. It may
speed up the processing time, especially when <code>pattern</code> is used is informed.
When <code>object_index</code> is informed, multiple sections will be used to extract
the RGB values for each object in the image. This may significantly speed up
processing time when an image has lots of objects (say &gt;1000).</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the number
of parallel processes that can be active at the same time. By default, the
number of sections is set up to 30% of available cores.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_watershed">watershed</code></td>
<td>
<p>If <code>TRUE</code> (default) performs watershed-based object
detection. This will detect objects even when they are touching one other.
If <code>FALSE</code>, all pixels for each connected set of foreground pixels are set
to a unique object. This is faster but is not able to segment touching
objects.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code><a href="#topic+image_filter">image_filter()</a></code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing noise,
but adversely affect edges.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_object_size">object_size</code></td>
<td>
<p>Argument to control control the watershed segmentation.
See <code><a href="#topic+analyze_objects">analyze_objects()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_efourier">efourier</code></td>
<td>
<p>Logical argument indicating if Elliptical Fourier should be
computed for each object. This will call <code><a href="#topic+efourier">efourier()</a></code> internally. It
<code>efourier = TRUE</code> is used, both standard and normalized Fourier coefficients
are returned.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_object_index">object_index</code></td>
<td>
<p>Defaults to <code>FALSE</code>. If an index is informed, the average
value for each object is returned. It can be the R, G, and B values or any
operation involving them, e.g., <code>object_index = "R/B"</code>. In this case, it
will return for each object in the image, the average value of the R/B
ratio. Use <code><a href="#topic+pliman_indexes_eq">pliman_indexes_eq()</a></code> to see the equations of available indexes.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_veins">veins</code></td>
<td>
<p>Logical argument indicating whether vein features are computed.
This will call <code><a href="#topic+object_edge">object_edge()</a></code> and applies the Sobel-Feldman Operator to
detect edges. The result is the proportion of edges in relation to the
entire area of the object(s) in the image. Note that <strong>THIS WILL BE AN
OPERATION ON AN IMAGE LEVEL, NOT OBJECT!</strong>.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_width_at">width_at</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the widths of the object at a given set
of quantiles of the height are computed.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image if desired. This is useful to process
images with a black background. Defaults to <code>FALSE</code>. If <code>reference = TRUE</code>
is use, <code>invert</code> can be declared as a logical vector of length 2 (eg.,
<code style="white-space: pre;">&#8288;invert = c(FALSE, TRUE&#8288;</code>). In this case, the segmentation of objects and
reference from the foreground using <code>back_fore_index</code> is performed using the
default (not inverted), and the segmentation of objects from the reference
is performed by inverting the selection (selecting pixels higher than the
threshold).</p>
</td></tr>
<tr><td><code id="analyze_objects_shp_+3A_...">...</code></td>
<td>
<p>Aditional arguments passed on to <a href="#topic+analyze_objects">analyze_objects</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>analyze_objects_shp</code> function performs object analysis on an
image and generates shapefiles representing the analyzed objects. The
function first prepares the image for analysis using the <code><a href="#topic+image_prepare">image_prepare()</a></code>
function if the <code>prepare</code> argument is set to <code>TRUE</code>. If a shapefile object is
provided, the number of rows and columns for splitting the image is obtained
from the shapefile. Otherwise, the image is split into multiple sub-images
based on the specified number of rows and columns using the
<code><a href="#topic+object_split_shp">object_split_shp()</a></code> function. The objects in each sub-image are analyzed
using the <code><a href="#topic+analyze_objects">analyze_objects()</a></code> function, and the results are stored in a list.
If parallel processing is enabled, the analysis is performed in parallel
using multiple workers.
</p>
<p>The output object provides access to various components of the analysis
results, such as the analyzed object coordinates and properties.
Additionally, the shapefiles representing the analyzed objects are included
in the output object for further analysis or visualization.
</p>


<h3>Value</h3>

<p>An object of class <code>anal_obj</code>. See more details in the <code>Value</code>
section of <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)

# Computes the DGCI index for each flax leaf
flax &lt;- image_pliman("flax_leaves.jpg", plot =TRUE)
res &lt;-
   analyze_objects_shp(flax,
                       nrow = 3,
                       ncol = 5,
                       plot = FALSE,
                       object_index = "DGCI")
plot(flax)
plot(res$shapefiles)
plot_measures(res, measure = "DGCI")
}
</code></pre>

<hr>
<h2 id='apply_fun_to_imgs'>Apply a function to images</h2><span id='topic+apply_fun_to_imgs'></span>

<h3>Description</h3>

<p>Most of the functions in pliman can be applied to a list of images, but this can be not
ideal to deal with lots of images, mainly if they have a high resolution. For
curiosity, a 6000 x 4000 image use nearly 570 Megabytes of RAM. So, it would be
impossible to deal with lots of images within R. <code>apply_fun_to_img()</code> applies a
function to images stored in a given directory as follows:
</p>

<ul>
<li><p> Create a vector of image names that contain a given pattern of name.
</p>
</li>
<li><p> Import each image of such a list.
</p>
</li>
<li><p> Apply a function to the imported image.
</p>
</li>
<li><p> Export the mutated image to the computer.
</p>
</li></ul>

<p>If parallel is set to <code>FALSE</code> (default), the images are processed sequentially, which
means that one image needs to be imported, processed, and exported so that the other
image can be processed. If parallel is set to <code>TRUE</code>,  the images are processed
asynchronously (in parallel) in separate R sessions (3) running in the background on
the same machine. It may speed up the processing time when lots of images need to be
processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_fun_to_imgs(
  pattern,
  fun,
  ...,
  dir_original = NULL,
  dir_processed = NULL,
  prefix = "",
  suffix = "",
  parallel = FALSE,
  workers = 3,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_fun_to_imgs_+3A_pattern">pattern</code></td>
<td>
<p>A pattern to match the images' names.</p>
</td></tr>
<tr><td><code id="apply_fun_to_imgs_+3A_fun">fun</code></td>
<td>
<p>A function to apply to the images.</p>
</td></tr>
<tr><td><code id="apply_fun_to_imgs_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="apply_fun_to_imgs_+3A_dir_original">dir_original</code>, <code id="apply_fun_to_imgs_+3A_dir_processed">dir_processed</code></td>
<td>
<p>The directory containing the original and processed
images. Defaults to <code>NULL</code>, which means that the current working directory will be
considered. <strong>The processed image will overwrite the original image unless a
prefix/suffix be used or a subfolder is informed in dir_processed argument</strong>.</p>
</td></tr>
<tr><td><code id="apply_fun_to_imgs_+3A_prefix">prefix</code>, <code id="apply_fun_to_imgs_+3A_suffix">suffix</code></td>
<td>
<p>A prefix and/or suffix to be included in the name of processed
images. Defaults to <code>""</code>.</p>
</td></tr>
<tr><td><code id="apply_fun_to_imgs_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> processes the images asynchronously (in parallel) in separate
R sessions (3 by default) running in the background on the same machine. It may speed
up the processing time, especially when pattern is used is informed.</p>
</td></tr>
<tr><td><code id="apply_fun_to_imgs_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the number of
parallel processes that can be active at the same time. Defaults to 3.</p>
</td></tr>
<tr><td><code id="apply_fun_to_imgs_+3A_verbose">verbose</code></td>
<td>
<p>Shows the progress in console? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. The processed images are saved to the current working directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># apply_fun_to_imgs("pattern", image_resize, rel_size = 50)
</code></pre>

<hr>
<h2 id='as_image'>Create an <code>Image</code> object</h2><span id='topic+as_image'></span>

<h3>Description</h3>

<p>This function is a simple wrapper around <code><a href="EBImage.html#topic+Image">EBImage::Image()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_image(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_image_+3A_data">data</code></td>
<td>
<p>A vector or array containing the pixel intensities of an image.
If missing, the default 1x1 zero-filled array is used.</p>
</td></tr>
<tr><td><code id="as_image_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="EBImage.html#topic+Image">EBImage::Image()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Image</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;-
as_image(rnorm(150 * 150 * 3),
         dim = c(150, 150, 3),
         colormode = 'Color')
plot(img)
</code></pre>

<hr>
<h2 id='calibrate'>Calibrates distances of landmarks</h2><span id='topic+calibrate'></span>

<h3>Description</h3>

<p>Calibrating the actual size is possible if any interlandmark distance on the
image is known. calibrate() can be used to determine the size of a known
distance (cm) on the graph. I invite users to photograph the object together
with a scale (e.g., ruler, micrometer...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate(img, viewer = get_pliman_viewer())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object</p>
</td></tr>
<tr><td><code id="calibrate_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric (<code>double</code>) scalar value indicating the scale (in pixels per
unit of known distance).
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(isTRUE(interactive())){
library(pliman)
#### compute scale (dots per unit of known distance) ####
# only works in an interactive section
# objects_300dpi.jpg has a known resolution of 300 dpi
img &lt;- image_pliman("objects_300dpi.jpg")
# Larger square: 10 x 10 cm
# 1) Run the function calibrate()
# 2) Use the left mouse button to create a line in the larger square
# 3) Declare a known distance (10 cm)
# 4) See the computed scale (pixels per cm)
calibrate(img)

# scale ~118
# 118 * 2.54 ~300 DPI
}
</code></pre>

<hr>
<h2 id='contours'>Contour outlines from five leaves</h2><span id='topic+contours'></span>

<h3>Description</h3>

<p>A list of contour outlines from five leaves. It may be used as
example in some functions such as <code><a href="#topic+efourier">efourier()</a></code>
</p>


<h3>Format</h3>

<p>A list with five objects
</p>

<ul>
<li> <p><code>leaf_1</code>
</p>
</li>
<li> <p><code>leaf_2</code>
</p>
</li>
<li> <p><code>leaf_3</code>
</p>
</li>
<li> <p><code>leaf_4</code>
</p>
</li>
<li> <p><code>leaf_5</code>
</p>
</li></ul>

<p>Each object is a <code>data.frame</code> with the coordinates for the outline perimeter
</p>


<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Source</h3>

<p>Personal data. The images were obtained in the Flavia data set
downlodable at <a href="https://flavia.sourceforge.net/">https://flavia.sourceforge.net/</a>
</p>

<hr>
<h2 id='custom_palette'>Generate Custom Color Palette</h2><span id='topic+custom_palette'></span>

<h3>Description</h3>

<p>This function generates a custom color palette using the specified colors and
number of colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_palette(
  colors = c("#4B0055", "#00588B", "#009B95", "#53CC67", "yellow"),
  n = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_palette_+3A_colors">colors</code></td>
<td>
<p>A vector of colors to create the color palette. Default is
c(&quot;steelblue&quot;, &quot;salmon&quot;, &quot;forestgreen&quot;).</p>
</td></tr>
<tr><td><code id="custom_palette_+3A_n">n</code></td>
<td>
<p>The number of gradient colors in the color palette. Default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of colors representing the custom color palette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a custom color palette with default colors and 10 colors
custom_palette()

# Generate a custom color palette with specified colors and 20 colors
custom_palette(colors = c("blue", "red"), n = 20)

# example code
library(pliman)
custom_palette(n = 5)

</code></pre>

<hr>
<h2 id='dist_transform'>Distance map transform</h2><span id='topic+dist_transform'></span>

<h3>Description</h3>

<p>Computes the distance map transform of a binary image. The distance map is a
matrix which contains for each pixel the distance to its nearest background
pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_transform(binary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_transform_+3A_binary">binary</code></td>
<td>
<p>A binary image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Image</code> object or an array, with pixels containing the distances
to the nearest background points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
binary &lt;- image_binary(img, "B")[[1]]
wts &lt;- dist_transform(binary)
range(wts)
</code></pre>

<hr>
<h2 id='efourier'>Elliptical Fourier Analysis</h2><span id='topic+efourier'></span>

<h3>Description</h3>

<p>Computes Elliptical Fourier Analysis of closed outlines based on <code>x</code> and
<code>y</code>-coordinates coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efourier(x, nharm = 10, align = FALSE, center = FALSE, smooth_iter = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efourier_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code>, a <code>data.frame</code> a <code>list</code> of perimeter coordinates, often
produced with <code><a href="#topic+object_contour">object_contour()</a></code> or a vector of landmarks produced with
<code><a href="#topic+landmarks">landmarks()</a></code> or <code><a href="#topic+landmarks_regradi">landmarks_regradi()</a></code>.</p>
</td></tr>
<tr><td><code id="efourier_+3A_nharm">nharm</code></td>
<td>
<p>An integer indicating the number of harmonics to use. Defaults
to 10.</p>
</td></tr>
<tr><td><code id="efourier_+3A_align">align</code></td>
<td>
<p>Align the objects before computing Fourier analysis? Defaults to
<code>FALSE</code>. If <code>TRUE</code>, the object is first aligned along the major caliper
with <code><a href="#topic+poly_align">poly_align()</a></code>.</p>
</td></tr>
<tr><td><code id="efourier_+3A_center">center</code></td>
<td>
<p>Center the objects on the origin before computing Fourier
analysis? Defaults to <code>FALSE</code>. If <code>TRUE</code>, the object is first centered on
the origin with <code><a href="#topic+poly_center">poly_center()</a></code>.</p>
</td></tr>
<tr><td><code id="efourier_+3A_smooth_iter">smooth_iter</code></td>
<td>
<p>The number of smoothing iterations to perform. This will
smooth the perimeter of the objects using <code><a href="#topic+poly_smooth">poly_smooth()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adapted from Claude (2008). pp. 222-223.
</p>


<h3>Value</h3>

<p>A list of class <code>efourier</code> with:
</p>

<ul>
<li><p> the harmonic coefficients (<code>an</code>, <code>bn</code>, <code>cn</code> and <code>dn</code>)
</p>
</li>
<li><p> the estimates of the coordinates of the centroid of the configuration
(<code>a0</code> and <code>c0</code>).
</p>
</li>
<li><p> The number of rows (points) of the perimeter outline (<code>nr</code>).
</p>
</li>
<li><p> The number of harmonics used (<code>nharm</code>).
</p>
</li>
<li><p> The original coordinates (<code>coords</code>).
</p>
</li></ul>

<p>If <code>x</code> is a list of perimeter coordinates, a list of <code>efourier</code> objects will
be returned as an object of class <code>iefourier_lst</code>.
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>
<p>Kuhl, F. P., and Giardina, C. R. (1982). Elliptic Fourier features of a
closed contour. Computer Graphics and Image Processing 18, 236258. doi:
<a href="https://doi.org/10.1016/0146-664X%2882%2990034-X">doi:10.1016/0146-664X(82)90034-X</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
leaf1 &lt;- contours[[4]]
plot_polygon(leaf1)

#### default options
# 10 harmonics (default)
# without alignment

ef &lt;- efourier(leaf1)
efourier_coefs(ef)

# object is aligned along the major caliper with `poly_align()`
# object is centered on the origin with `poly_center()`
# using a list of object coordinates
ef2 &lt;- efourier(contours, align = TRUE, center = TRUE)
efourier_coefs(ef2)

# reconstruct the perimeter of the object
# Use only the first one for simplicity
plot_polygon(contours[[1]] |&gt; poly_align() |&gt; poly_center())
efourier_inv(ef2[[1]]) |&gt; plot_contour(col = "red", lwd = 4)
</code></pre>

<hr>
<h2 id='efourier_coefs'>Get Fourier coefficients</h2><span id='topic+efourier_coefs'></span>

<h3>Description</h3>

<p>Extracts the Fourier coefficients from objects computed with <code><a href="#topic+efourier">efourier()</a></code> and
<code><a href="#topic+efourier_norm">efourier_norm()</a></code> returning a 'ready-to-analyze' data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efourier_coefs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efourier_coefs_+3A_x">x</code></td>
<td>
<p>An object computed with <code><a href="#topic+efourier">efourier()</a></code> or <code><a href="#topic+efourier_norm">efourier_norm()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)

# a list of objects
efourier(contours) |&gt; efourier_coefs()

# one object, normalized coefficients
efourier(contours[[4]]) |&gt;
  efourier_norm() |&gt;
  efourier_coefs()
</code></pre>

<hr>
<h2 id='efourier_error'>Erros between the original and reconstructed outline</h2><span id='topic+efourier_error'></span>

<h3>Description</h3>

<p>Computes the sum of squared distances between the original data and
reconstructed outline. It allows examining reconstructed outlines with the
addition of successive contributing harmonics indicated in the argument
<code>nharm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efourier_error(
  x,
  nharm = NULL,
  type = c("error", "outline", "deviations"),
  plot = TRUE,
  ncol = NULL,
  nrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efourier_error_+3A_x">x</code></td>
<td>
<p>An object computed with <code><a href="#topic+efourier">efourier()</a></code>.</p>
</td></tr>
<tr><td><code id="efourier_error_+3A_nharm">nharm</code></td>
<td>
<p>An integer or vector of integers indicating the number of
harmonics to use. If not specified the number of harmonics used in <code>x</code> is
used.</p>
</td></tr>
<tr><td><code id="efourier_error_+3A_type">type</code></td>
<td>
<p>The type of plot to produce. By default, a line plot with the sum
of squared distances (y-axis) and the number of harmonics (x-axis) is
produced. If <code>type = "outline"</code> is used, a plot with the original polygon
and the constructed outline is produced. If <code>type = "deviations"</code> is used,
a plot with the deviations from the original outline and reconstructed
outline (y-axis) and points along the outline (x-axis) is produced.</p>
</td></tr>
<tr><td><code id="efourier_error_+3A_plot">plot</code></td>
<td>
<p>A logical to inform if a plot should be produced. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="efourier_error_+3A_ncol">ncol</code>, <code id="efourier_error_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the objects:
</p>

<ul>
<li> <p><code>dev_points</code> A list with the deviations (distances) from original and
predicted outline for each pixel of the outline.
</p>
</li>
<li> <p><code>data.frame</code> object with the minimum, maximum and average
deviations (based on the outline points).
</p>
</li></ul>

<p>If <code>x</code> is an object of class <code>efourier_lst</code>, a list will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
ef &lt;-
  contours[[1]] |&gt;
  efourier(nharm = 30)

efourier_error(ef)

efourier_error(ef,
               nharm = 30,
               type = "outline")

efourier_error(ef,
               nharm = c(1, 4, 20),
               type = "deviations")
</code></pre>

<hr>
<h2 id='efourier_inv'>Inverse Elliptical Fourier Analysis</h2><span id='topic+efourier_inv'></span>

<h3>Description</h3>

<p>Performs an inverse elliptical Fourier transformation to construct a shape,
given a list with Fourier coefficients computed with <code><a href="#topic+efourier">efourier()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efourier_inv(x, nharm = NULL, a0 = NULL, c0 = NULL, npoints = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efourier_inv_+3A_x">x</code></td>
<td>
<p>An object of class <code>efourier</code> or <code>efourier_lst</code> computed with
<code><a href="#topic+efourier">efourier()</a></code>.</p>
</td></tr>
<tr><td><code id="efourier_inv_+3A_nharm">nharm</code></td>
<td>
<p>An integer indicating the number of harmonics to use. If not
specified the number of harmonics used in <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="efourier_inv_+3A_a0">a0</code>, <code id="efourier_inv_+3A_c0">c0</code></td>
<td>
<p>the estimates of the coordinates of the centroid of the
configuration. If <code>NULL</code> (default), the generated coordinates will be
centered on the position of the original shape given by <code><a href="#topic+efourier">efourier()</a></code>.</p>
</td></tr>
<tr><td><code id="efourier_inv_+3A_npoints">npoints</code></td>
<td>
<p>The number of interpolated points on the constructed outline.
Defaults to 500.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adapted from Claude (2008). pp. 223.
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
plot_polygon(contours, aspect_ratio = 1)
# without alignment
ef &lt;- efourier(contours, nharm = 10, align = FALSE)
ief &lt;- efourier_inv(ef)
plot_contour(ief, col = "red", lwd = 2)
</code></pre>

<hr>
<h2 id='efourier_norm'>Normalized Fourier coefficients</h2><span id='topic+efourier_norm'></span>

<h3>Description</h3>

<p>The first harmonic defines an ellipse that best fits the outlines. One can
use the parameters of the first harmonic to normalize the data so that they
can be invariant to size, rotation, and starting position of the outline
trace. This approach is referred to in the literature as the normalized
elliptic Fourier. <code><a href="#topic+efourier_norm">efourier_norm()</a></code> calculates a new set of Fourier
coefficients <code>An</code>, <code>Bn</code>, <code>Cn</code>, <code>Dn</code> that one can use for further multivariate
analyses (Claude, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efourier_norm(x, start = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efourier_norm_+3A_x">x</code></td>
<td>
<p>An object computed with <code><a href="#topic+efourier">efourier()</a></code>.</p>
</td></tr>
<tr><td><code id="efourier_norm_+3A_start">start</code></td>
<td>
<p>Logical value telling whether the position of the starting point
has to be preserved or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adapted from Claude (2008). pp. 226.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li> <p><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> for harmonic coefficients.
</p>
</li>
<li> <p><code>size</code> the magnitude of the semi-major axis of the first fitting ellipse.
</p>
</li>
<li> <p><code>theta</code> angle, in radians, between the starting and the semi-major axis of
the first fitting ellipse.
</p>
</li>
<li> <p><code>psi</code> orientation of the first fitting ellipse
</p>
</li>
<li> <p><code>a0</code> and <code>c0</code>, harmonic coefficients.
</p>
</li>
<li> <p><code>lnef</code> the concatenation of coefficients.
</p>
</li>
<li> <p><code>nharm</code> the number of harmonics used.
</p>
</li></ul>



<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
leaf1 &lt;- contours[[4]]
plot_polygon(leaf1)

# compute the Fourier coefficients
ef &lt;- efourier(leaf1)
efourier_coefs(ef)

# Normalized Fourier coefficients

efn &lt;- efourier_norm(ef)
efourier_coefs(efn)
</code></pre>

<hr>
<h2 id='efourier_power'>Power in Fourier Analysis</h2><span id='topic+efourier_power'></span>

<h3>Description</h3>

<p>Computes an spectrum of harmonic Fourier power. The power is proportional to
the harmonic amplitude and can be considered as a measure of shape
information. As the rank of harmonic increases, the power decreases and adds
less and less information. We can evaluate the number of harmonics that we
must select, so their cumulative power gathers 99% of the total cumulative
power (Claude, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efourier_power(
  x,
  first = TRUE,
  thresh = c(0.8, 0.85, 0.9, 0.95, 0.99, 0.999),
  plot = TRUE,
  ncol = NULL,
  nrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efourier_power_+3A_x">x</code></td>
<td>
<p>An object of class <code>efourier</code>computed with <code><a href="#topic+efourier">efourier()</a></code>.</p>
</td></tr>
<tr><td><code id="efourier_power_+3A_first">first</code></td>
<td>
<p>Logical argument indicating whether to include the first
harmonic for computing the power. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="efourier_power_+3A_thresh">thresh</code></td>
<td>
<p>A numeric vector indicating the threshold power. The number of
harmonics needed for such thresholds will then be computed.</p>
</td></tr>
<tr><td><code id="efourier_power_+3A_plot">plot</code></td>
<td>
<p>Logical argument indicating whether to produce a plot.</p>
</td></tr>
<tr><td><code id="efourier_power_+3A_ncol">ncol</code>, <code id="efourier_power_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the shape &quot;information&quot; is contained in the first harmonic.
This is not surprising because this is the harmonic that best fits the
outline, and the size of ellipses decreases as for explaining successive
residual variation. However, one may think that the first ellipse does not
contain relevant shape information, especially when differences one wants
to investigate concern complex outlines. By using <code>first = FALSE</code> it is
possible to remove the first harmonic for this computation. When working on
a set of outlines, high-rank-harmonics can contain information that may
allow groups to be distinguished (Claude, 2008).
</p>
<p>Adapted from Claude (2008). pp. 229.
</p>


<h3>Value</h3>

<p>A list with the objects:
</p>

<ul>
<li> <p><code>cum_power</code>, a <code>data.frame</code> object with the accumulated power depending on
the number of harmonics
</p>
</li>
<li> 
</li></ul>



<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
pw &lt;- efourier(contours) |&gt; efourier_power()

</code></pre>

<hr>
<h2 id='efourier_shape'>Draw shapes based on Fourier coefficients</h2><span id='topic+efourier_shape'></span>

<h3>Description</h3>

<p>Calculates a 'Fourier elliptical shape' given Fourier coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efourier_shape(
  an = NULL,
  bn = NULL,
  cn = NULL,
  dn = NULL,
  n = 1,
  nharm = NULL,
  npoints = 150,
  alpha = 4,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efourier_shape_+3A_an">an</code></td>
<td>
<p>The <code class="reqn">a_n</code> Fourier coefficients on which to calculate a shape.</p>
</td></tr>
<tr><td><code id="efourier_shape_+3A_bn">bn</code></td>
<td>
<p>The <code class="reqn">b_n</code> Fourier coefficients on which to calculate a shape.</p>
</td></tr>
<tr><td><code id="efourier_shape_+3A_cn">cn</code></td>
<td>
<p>The <code class="reqn">c_n</code> Fourier coefficients on which to calculate a shape.</p>
</td></tr>
<tr><td><code id="efourier_shape_+3A_dn">dn</code></td>
<td>
<p>The <code class="reqn">d_n</code> Fourier coefficients on which to calculate a shape.</p>
</td></tr>
<tr><td><code id="efourier_shape_+3A_n">n</code></td>
<td>
<p>The number of shapes to generate. Defaults to 1. If more than one
shape is used, a list of coordinates is returned.</p>
</td></tr>
<tr><td><code id="efourier_shape_+3A_nharm">nharm</code></td>
<td>
<p>The number of harmonics to use. It must be less than or equal to
the length of <code style="white-space: pre;">&#8288;*_n&#8288;</code> coefficients.</p>
</td></tr>
<tr><td><code id="efourier_shape_+3A_npoints">npoints</code></td>
<td>
<p>The number of points to calculate.</p>
</td></tr>
<tr><td><code id="efourier_shape_+3A_alpha">alpha</code></td>
<td>
<p>The power coefficient associated with the (usually decreasing)
amplitude of the Fourier coefficients.</p>
</td></tr>
<tr><td><code id="efourier_shape_+3A_plot">plot</code></td>
<td>
<p>Logical indicating Whether to plot the shape. Defaults to TRUE'</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>efourier_shape</code> can be used by specifying <code>nharm</code> and
<code>alpha</code>. The coefficients are then sampled in an uniform distribution
<code class="reqn">(-\pi ; \pi)</code> and this amplitude is then divided by <code class="reqn">harmonicrank ^
alpha</code>. If <code>alpha</code> is lower than 1, consecutive coefficients will thus
increase. See Claude (2008) pp.223 for the maths behind inverse ellipitical
Fourier
</p>
<p>Adapted from Claude (2008). pp. 223.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li> <p><code>x</code> vector of x-coordrdinates
</p>
</li>
<li> <p><code>y</code> vector of y-coordrdinates.
</p>
</li></ul>



<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
# approximation of the third leaf's perimeter
# 4 harmonics
image_pliman("potato_leaves.jpg", plot = TRUE)

efourier_shape(an = c(-7.34,  1.81,  -1.32, 0.50),
               bn = c(-113.88, 21.90, -0.31, -6.14),
               cn = c(-147.51, -20.89, 0.66, -14.06),
               dn = c(-0.48, 2.36, -4.36, 3.03))

</code></pre>

<hr>
<h2 id='ellipse'>Confidence ellipse</h2><span id='topic+ellipse'></span>

<h3>Description</h3>

<p>Produces a confidence ellipse that is an iso-contour of the Gaussian
distribution, allowing to visualize a 2D confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(
  x,
  conf = 0.95,
  np = 100,
  plot = TRUE,
  fill = "green",
  alpha = 0.3,
  random_fill = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code>, a <code>data.frame</code> or a <code>list</code> of perimeter coordinates, often
produced with <code><a href="#topic+object_contour">object_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_conf">conf</code></td>
<td>
<p>The confidence level. Defaults to <code>0.95</code></p>
</td></tr>
<tr><td><code id="ellipse_+3A_np">np</code></td>
<td>
<p>Number of sampled points on the ellipse.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_plot">plot</code></td>
<td>
<p>Create a plot? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_fill">fill</code></td>
<td>
<p>The color to fill the ellipse. Defaults to <code>"green"</code>.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_alpha">alpha</code></td>
<td>
<p>The alpha value to define the opacity of ellipse. Defaults to
<code>0.3</code></p>
</td></tr>
<tr><td><code id="ellipse_+3A_random_fill">random_fill</code></td>
<td>
<p>Fill multiple ellipses with random colors? Defaults to
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with coordinates of points sampled on the ellipse.
</p>


<h3>Note</h3>

<p>Borrowed from Claude (2008), pp. 85
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
ellipse(contours)
</code></pre>

<hr>
<h2 id='get_pliman_viewer'>Get the value of the pliman_viewer option</h2><span id='topic+get_pliman_viewer'></span>

<h3>Description</h3>

<p>Retrieves the current value of the pliman_viewer option used in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pliman_viewer()
</code></pre>


<h3>Value</h3>

<p>The current value of the pliman_viewer option.
</p>

<hr>
<h2 id='ggplot_color'>ggplot2-like colors generation</h2><span id='topic+ggplot_color'></span>

<h3>Description</h3>

<p>Generate ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_color(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_color_+3A_n">n</code></td>
<td>
<p>The number of colors. This works well for up to about eight colours,
but after that it becomes hard to tell the different colours apart.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
ggplot_color(n = 3)
</code></pre>

<hr>
<h2 id='image_align'>Aligns an <code>Image</code> object by hand</h2><span id='topic+image_align'></span>

<h3>Description</h3>

<p><code><a href="#topic+image_align">image_align()</a></code> rotate an image given a line of desired aligment along the y
axis that corresponds to the alignment of the objects (e.g., field plots). By
default, the aligment will be to the vertical, which means that if the drawed
line have an angle &lt; 90 parallel to the x axis, the rotation angle wil be
negative (anticlocwise rotation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_align(
  img,
  align = c("vertical", "horizontal"),
  viewer = get_pliman_viewer(),
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_align_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object</p>
</td></tr>
<tr><td><code id="image_align_+3A_align">align</code></td>
<td>
<p>The desired alignment. Either <code>"vertical"</code> (default) or
<code>"horizontal"</code>.</p>
</td></tr>
<tr><td><code id="image_align_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="image_align_+3A_plot">plot</code></td>
<td>
<p>Plots the aligned image? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>image_align</code> function aligns an image along the vertical or horizontal
axis based on user-selected points. The alignment can be performed in either
the base plotting system or using the mapview package for interactive
visualization. If the viewer option is set to &quot;base&quot;, the function prompts
the user to select two points on the image to define the alignment line. If
the viewer option is set to &quot;mapview&quot;, the function opens an interactive map
where the user can draw a polyline to define the alignment line. The
alignment angle is calculated based on the selected points, and the image is
rotated accordingly using the <code>image_rotate</code> function. The function returns
the aligned image object.
</p>


<h3>Value</h3>

<p>The <code>img</code> aligned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
flax &lt;- image_pliman("flax_leaves.jpg", plot = TRUE)
aligned &lt;- image_align(flax)
}
</code></pre>

<hr>
<h2 id='image_augment'>Augment Images</h2><span id='topic+image_augment'></span>

<h3>Description</h3>

<p>This function takes an image and augments it by rotating it multiple times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_augment(
  img,
  pattern = NULL,
  times = 12,
  type = "export",
  dir_original = NULL,
  dir_processed = NULL,
  parallel = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_augment_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object.</p>
</td></tr>
<tr><td><code id="image_augment_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression pattern to select multiple images from a
directory.</p>
</td></tr>
<tr><td><code id="image_augment_+3A_times">times</code></td>
<td>
<p>The number of times to rotate the image.</p>
</td></tr>
<tr><td><code id="image_augment_+3A_type">type</code></td>
<td>
<p>The type of output: &quot;export&quot; to save images or &quot;return&quot; to return
a list of augmented images.</p>
</td></tr>
<tr><td><code id="image_augment_+3A_dir_original">dir_original</code></td>
<td>
<p>The directory where original images are located.</p>
</td></tr>
<tr><td><code id="image_augment_+3A_dir_processed">dir_processed</code></td>
<td>
<p>The directory where processed images will be saved.</p>
</td></tr>
<tr><td><code id="image_augment_+3A_parallel">parallel</code></td>
<td>
<p>Whether to perform image augmentation in parallel.</p>
</td></tr>
<tr><td><code id="image_augment_+3A_verbose">verbose</code></td>
<td>
<p>Whether to display progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If type is &quot;export,&quot; augmented images are saved. If type is &quot;return,&quot;
a list of augmented images is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
img &lt;- image_pliman("sev_leaf.jpg")
imgs &lt;- image_augment(img, type = "return", times = 4)
image_combine(imgs)
}

</code></pre>

<hr>
<h2 id='image_binary'>Creates a binary image</h2><span id='topic+image_binary'></span>

<h3>Description</h3>

<p>Reduce a color, color near-infrared, or grayscale images to a binary image
using a given color channel (red, green blue) or even color indexes. The
Otsu's thresholding method (Otsu, 1979) is used to automatically perform
clustering-based image thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_binary(
  img,
  index = "R",
  r = 1,
  g = 2,
  b = 3,
  re = 4,
  nir = 5,
  return_class = "ebimage",
  threshold = c("Otsu", "adaptive"),
  k = 0.1,
  windowsize = NULL,
  has_white_bg = FALSE,
  resize = FALSE,
  fill_hull = FALSE,
  filter = FALSE,
  invert = FALSE,
  plot = TRUE,
  nrow = NULL,
  ncol = NULL,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_binary_+3A_img">img</code></td>
<td>
<p>An image object.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_index">index</code></td>
<td>
<p>A character value (or a vector of characters) specifying the
target mode for conversion to binary image. See the available indexes with
<code><a href="#topic+pliman_indexes">pliman_indexes()</a></code> and <code><a href="#topic+image_index">image_index()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_r">r</code>, <code id="image_binary_+3A_g">g</code>, <code id="image_binary_+3A_b">b</code>, <code id="image_binary_+3A_re">re</code>, <code id="image_binary_+3A_nir">nir</code></td>
<td>
<p>The red, green, blue, red-edge, and near-infrared bands
of the image, respectively. Defaults to 1, 2, 3, 4, and 5, respectively. If
a multispectral image is provided (5 bands), check the order of bands,
which are frequently presented in the 'BGR' format.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_return_class">return_class</code></td>
<td>
<p>The class of object to be returned. If <code style="white-space: pre;">&#8288;"terra&#8288;</code> returns a
SpatRaster object with the number of layers equal to the number of indexes
computed. If <code>"ebimage"</code> (default) returns a list of <code>Image</code> objects, where
each element is one index computed.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_threshold">threshold</code></td>
<td>
<p>The theshold method to be used.
</p>

<ul>
<li><p> By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image. If
a numeric value is informed, this value will be used as a threshold.
</p>
</li>
<li><p> If <code>threshold = "adaptive"</code>, adaptive thresholding (Shafait et al. 2008)
is used, and will depend on the <code>k</code> and <code>windowsize</code> arguments.
</p>
</li>
<li><p> If any non-numeric value different than <code>"Otsu"</code> and <code>"adaptive"</code> is used,
an iterative section will allow you to choose the threshold based on a
raster plot showing pixel intensity of the index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="image_binary_+3A_k">k</code></td>
<td>
<p>a numeric in the range 0-1. when <code>k</code> is high, local threshold
values tend to be lower. when <code>k</code> is low, local threshold value tend to be
higher.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_windowsize">windowsize</code></td>
<td>
<p>windowsize controls the number of local neighborhood in
adaptive thresholding. By default it is set to <code>1/3 * minxy</code>, where
<code>minxy</code> is the minimum dimension of the image (in pixels).</p>
</td></tr>
<tr><td><code id="image_binary_+3A_has_white_bg">has_white_bg</code></td>
<td>
<p>Logical indicating whether a white background is present.
If <code>TRUE</code>, pixels that have R, G, and B values equals to 1 will be
considered as <code>NA</code>. This may be useful to compute an image index for
objects that have, for example, a white background. In such cases, the
background will not be considered for the threshold computation.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_resize">resize</code></td>
<td>
<p>Resize the image before processing? Defaults to <code>FALSE</code>. Use a
numeric value as the percentage of desired resizing. For example, if
<code>resize = 30</code>, the resized image will have 30% of the size of original
image.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the objects? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? (Defaults to
<code>FALSE</code>). Provide a positive integer &gt; 1 to indicate the size of the median
filtering. Higher values are more efficient to remove noise in the
background but can dramatically impact the perimeter of objects, mainly for
irregular perimeters such as leaves with serrated edges.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image, if desired.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_plot">plot</code></td>
<td>
<p>Show image after processing?</p>
</td></tr>
<tr><td><code id="image_binary_+3A_nrow">nrow</code>, <code id="image_binary_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time when <code>image</code> is a list. The number of sections is set
up to 70% of available cores.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="image_binary_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing binary images. The length will depend on the number
of indexes used.
</p>


<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Otsu, N. 1979. Threshold selection method from gray-level histograms. IEEE
Trans Syst Man Cybern SMC-9(1): 6266. <a href="https://doi.org/10.1109/tsmc.1979.4310076">doi:10.1109/tsmc.1979.4310076</a>
</p>
<p>Shafait, F., D. Keysers, and T.M. Breuel. 2008. Efficient implementation of
local adaptive thresholding techniques using integral images. Document
Recognition and Retrieval XV. SPIE. p. 317322 <a href="https://doi.org/10.1117/12.767755">doi:10.1117/12.767755</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
image_binary(img, index = c("R, G"))

</code></pre>

<hr>
<h2 id='image_combine'>Combines images to a grid</h2><span id='topic+image_combine'></span>

<h3>Description</h3>

<p>Combines several images to a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_combine(
  ...,
  labels = NULL,
  nrow = NULL,
  ncol = NULL,
  col = "black",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_combine_+3A_...">...</code></td>
<td>
<p>a comma-separated name of image objects or a list containing image
objects.</p>
</td></tr>
<tr><td><code id="image_combine_+3A_labels">labels</code></td>
<td>
<p>A character vector with the same length of the number of
objects in <code>...</code> to indicate the plot labels.</p>
</td></tr>
<tr><td><code id="image_combine_+3A_nrow">nrow</code>, <code id="image_combine_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
<tr><td><code id="image_combine_+3A_col">col</code></td>
<td>
<p>The color for the plot labels. Defaults to <code>col = "black"</code>.</p>
</td></tr>
<tr><td><code id="image_combine_+3A_verbose">verbose</code></td>
<td>
<p>Shows the name of objects declared in <code>...</code> or a numeric
sequence if a list with no names is provided. Set to <code>FALSE</code> to supress the
text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid with the images in <code>...</code>
</p>


<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img1 &lt;- image_pliman("sev_leaf.jpg")
img2 &lt;- image_pliman("sev_leaf_nb.jpg")
image_combine(img1, img2)
</code></pre>

<hr>
<h2 id='image_create'>Create an <code>Image</code> object of a given color</h2><span id='topic+image_create'></span>

<h3>Description</h3>

<p>image_create() can be used to create an <code>Image</code> object with a desired color and size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_create(color, width = 200, heigth = 200, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_create_+3A_color">color</code></td>
<td>
<p>either a color name (as listed by <code><a href="grDevices.html#topic+colors">grDevices::colors()</a></code>), or a hexadecimal
string of the form <code>"#rrggbb"</code>.</p>
</td></tr>
<tr><td><code id="image_create_+3A_width">width</code>, <code id="image_create_+3A_heigth">heigth</code></td>
<td>
<p>The width and heigth of the image in pixel units.</p>
</td></tr>
<tr><td><code id="image_create_+3A_plot">plot</code></td>
<td>
<p>Plots the image after creating it? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>Image</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image_create("red")
image_create("#009E73", width = 300, heigth = 100)
</code></pre>

<hr>
<h2 id='image_expand'>Expands an image</h2><span id='topic+image_expand'></span>

<h3>Description</h3>

<p>Expands an image towards the left, top, right, or bottom by sampling pixels
from the image edge. Users can choose how many pixels (rows or columns) are
sampled and how many pixels the expansion will have.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_expand(
  img,
  left = NULL,
  top = NULL,
  right = NULL,
  bottom = NULL,
  edge = NULL,
  sample_left = 10,
  sample_top = 10,
  sample_right = 10,
  sample_bottom = 10,
  random = FALSE,
  filter = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_expand_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object.</p>
</td></tr>
<tr><td><code id="image_expand_+3A_left">left</code>, <code id="image_expand_+3A_top">top</code>, <code id="image_expand_+3A_right">right</code>, <code id="image_expand_+3A_bottom">bottom</code></td>
<td>
<p>The number of pixels to expand in the left, top,
right, and bottom directions, respectively.</p>
</td></tr>
<tr><td><code id="image_expand_+3A_edge">edge</code></td>
<td>
<p>The number of pixels to expand in all directions. This can be
used to avoid calling all the above arguments</p>
</td></tr>
<tr><td><code id="image_expand_+3A_sample_left">sample_left</code>, <code id="image_expand_+3A_sample_top">sample_top</code>, <code id="image_expand_+3A_sample_right">sample_right</code>, <code id="image_expand_+3A_sample_bottom">sample_bottom</code></td>
<td>
<p>The number of pixels
to sample from each side. Defaults to 20.</p>
</td></tr>
<tr><td><code id="image_expand_+3A_random">random</code></td>
<td>
<p>Randomly sampling of the edge's pixels? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="image_expand_+3A_filter">filter</code></td>
<td>
<p>Apply a median filter in the sampled pixels? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="image_expand_+3A_plot">plot</code></td>
<td>
<p>Plots the extended image? defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Image</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
image_expand(img, left = 200)
image_expand(img, right = 150, bottom = 250, filter = 5)

</code></pre>

<hr>
<h2 id='image_index'>Image indexes</h2><span id='topic+image_index'></span><span id='topic+plot.image_index'></span>

<h3>Description</h3>

<p><code>image_index()</code> Builds image indexes using Red, Green, Blue, Red-Edge, and NIR bands.
</p>
<p>Generates a raster or density plot of the index values computed with
<code>image_index()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_index(
  img,
  index = NULL,
  r = 1,
  g = 2,
  b = 3,
  re = 4,
  nir = 5,
  return_class = c("ebimage", "terra"),
  resize = FALSE,
  has_white_bg = FALSE,
  plot = TRUE,
  nrow = NULL,
  ncol = NULL,
  max_pixels = 1e+05,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'image_index'
plot(x, type = c("raster", "density"), nrow = NULL, ncol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_index_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object. Multispectral mosaics can be converted to an
<code>Image</code> object using <code>mosaic_as_ebimage()</code>.</p>
</td></tr>
<tr><td><code id="image_index_+3A_index">index</code></td>
<td>
<p>A character value (or a vector of characters) specifying the
target mode for conversion to a binary image. Use <code><a href="#topic+pliman_indexes">pliman_indexes()</a></code> or the
<code>details</code> section to see the available indexes. Defaults to <code>NULL</code>
(normalized Red, Green, and Blue). You can also use &quot;RGB&quot; for RGB only,
&quot;NRGB&quot; for normalized RGB,  &quot;MULTISPECTRAL&quot; for multispectral indices
(provided NIR and RE bands are available) or &quot;all&quot; for all indexes. Users
can also calculate their own index using the band names, e.g., <code>index = "R+B/G"</code>.</p>
</td></tr>
<tr><td><code id="image_index_+3A_r">r</code>, <code id="image_index_+3A_g">g</code>, <code id="image_index_+3A_b">b</code>, <code id="image_index_+3A_re">re</code>, <code id="image_index_+3A_nir">nir</code></td>
<td>
<p>The red, green, blue, red-edge, and near-infrared bands
of the image, respectively. Defaults to 1, 2, 3, 4, and 5, respectively. If
a multispectral image is provided (5 bands), check the order of bands,
which are frequently presented in the 'BGR' format.</p>
</td></tr>
<tr><td><code id="image_index_+3A_return_class">return_class</code></td>
<td>
<p>The class of object to be returned. If <code style="white-space: pre;">&#8288;"terra&#8288;</code> returns a
SpatRaster object with the number of layers equal to the number of indexes
computed. If <code>"ebimage"</code> (default) returns a list of <code>Image</code> objects, where
each element is one index computed.</p>
</td></tr>
<tr><td><code id="image_index_+3A_resize">resize</code></td>
<td>
<p>Resize the image before processing? Defaults to <code>resize = FALSE</code>. Use <code>resize = 50</code>, which resizes the image to 50% of the original
size to speed up image processing.</p>
</td></tr>
<tr><td><code id="image_index_+3A_has_white_bg">has_white_bg</code></td>
<td>
<p>Logical indicating whether a white background is present.
If TRUE, pixels that have R, G, and B values equals to 1 will be considered
as NA. This may be useful to compute an image index for objects that have,
for example, a white background. In such cases, the background will not be
considered for the threshold computation.</p>
</td></tr>
<tr><td><code id="image_index_+3A_plot">plot</code></td>
<td>
<p>Show image after processing?</p>
</td></tr>
<tr><td><code id="image_index_+3A_nrow">nrow</code>, <code id="image_index_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
<tr><td><code id="image_index_+3A_max_pixels">max_pixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to plot the index. If
<code>max_pixels &lt; npixels(img)</code>, downsampling is performed before plotting the
index. Using a large number of pixels may slow down the plotting time.</p>
</td></tr>
<tr><td><code id="image_index_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time when <code>image</code> is a list. The number of sections is set
up to 70% of available cores.</p>
</td></tr>
<tr><td><code id="image_index_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="image_index_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="image_index_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plot_index">plot_index()</a></code> for customization.</p>
</td></tr>
<tr><td><code id="image_index_+3A_x">x</code></td>
<td>
<p>An object of class <code>image_index</code>.</p>
</td></tr>
<tr><td><code id="image_index_+3A_type">type</code></td>
<td>
<p>The type of plot. Use <code>type = "raster"</code> (default) to produce a
raster plot showing the intensity of the pixels for each image index or
<code>type = "density"</code> to produce a density plot with the pixels' intensity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following indexes are available in pliman.
</p>

<ul>
<li><p> RGB color space
</p>
</li></ul>


<ul>
<li> <p><code>R</code> red
</p>
</li>
<li> <p><code>G</code> green
</p>
</li>
<li> <p><code>B</code> blue
</p>
</li>
<li> <p><code>NR</code> normalized red <code>R/(R+G+B)</code>.
</p>
</li>
<li> <p><code>NG</code> normalized green <code>G/(R+G+B)</code>
</p>
</li>
<li> <p><code>NB</code> normalized blue <code>B/(R+G+B)</code>
</p>
</li>
<li> <p><code>GB</code> green blue ratio <code>G/B</code>
</p>
</li>
<li> <p><code>RB</code> red blue ratio <code>R/B</code>
</p>
</li>
<li> <p><code>GR</code> green red ratio <code>G/R</code>
</p>
</li>
<li> <p><code>BI</code> brightness Index <code>sqrt((R^2+G^2+B^2)/3)</code>
</p>
</li>
<li> <p><code>BIM</code> brightness Index 2 <code>sqrt((R*2+G*2+B*2)/3)</code>
</p>
</li>
<li> <p><code>SCI</code> Soil Colour Index <code>(R-G)/(R+G)</code>
</p>
</li>
<li> <p><code>GLI</code> Green leaf index Vis Louhaichi et al. (2001) <code>(2*G-R-B)/(2*G+R+B)</code>
</p>
</li>
<li> <p><code>HI</code> Primary colours Hue Index    (2*R-G-B)/(G-B)
</p>
</li>
<li> <p><code>NDGRI</code> Normalized green red difference index (Tucker, 1979) <code>(G-R)/(G+R)</code>
</p>
</li>
<li> <p><code>NDGBI</code> Normalized green blue difference index <code>(G-B)/(G+B)</code>
</p>
</li>
<li> <p><code>NDRBI</code> Normalized red blue difference index <code>(R-B)/(R+B)</code>
</p>
</li>
<li> <p><code>I</code>     R+G+B
</p>
</li>
<li> <p><code>S</code>     <code>((R+G+B)-3*B)/(R+G+B)</code>
</p>
</li>
<li> <p><code>L</code>     R+G+B/3
</p>
</li>
<li> <p><code>VARI</code> A Visible Atmospherically Resistant Index <code>(G-R)/(G+R-B)</code>
</p>
</li>
<li> <p><code>HUE</code> Overall Hue Index <code>atan(2*(B-G-R)/30.5*(G-R))</code>
</p>
</li>
<li> <p><code>HUE2</code>  atan(2*(R-G-R)/30.5*(G-B))
</p>
</li>
<li> <p><code>BGI</code>   B/G
</p>
</li>
<li> <p><code>GRAY</code>	<code>0.299*R + 0.587*G + 0.114*B</code>
</p>
</li>
<li> <p><code>GRAY2</code> <code>((R^2.2+(1.5*G)^2.2+(0.6*B)^2.2)/(1+1.5^2.2+0.6^2.2))^1/2.2</code>
</p>
</li>
<li> <p><code>GLAI</code> <code>(25*(G-R)/(G+R-B)+1.25)</code>
</p>
</li>
<li> <p><code>CI</code> Coloration Index <code>(R-B)/R</code>
</p>
</li>
<li> <p><code>SAT</code> Overhall Saturation Index <code>(max(R,G,B) - min(R,G,B)) / max(R,G,B)</code>
</p>
</li>
<li> <p><code>SHP</code> Shape Index <code>2*(R-G-B)/(G-B)</code>
</p>
</li>
<li> <p><code>RI</code> Redness Index <code>R**2/(B*G**3)</code>
</p>
</li></ul>


<ul>
<li><p> HSB color space
</p>
</li>
<li> <p><code>DGCI</code> Dark Green Color Index, based on HSB color space <code style="white-space: pre;">&#8288;60\*((G - B) / (max(R, G, B) - min(R, G, B)))&#8288;</code>
</p>
</li>
<li><p> CIE-Lab color space
</p>
</li></ul>


<ul>
<li> <p><code style="white-space: pre;">&#8288;L*&#8288;</code>: relative luminance <code>(0.2126 * R + 0.7152 * G + 0.0722 * B)</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;a*&#8288;</code>: <code>0.55*( (R - (0.2126 * R + 0.7152 * G + 0.0722 * B)) / (1.0 - 0.2126))</code>
</p>
</li></ul>

<p>When <code>type = "raster"</code> (default), the function calls <code><a href="#topic+plot_index">plot_index()</a></code>
to create a raster plot for each index present in <code>x</code>. If <code>type = "density"</code>,
a for loop is used to create a density plot for each index. Both types of
plots can be arranged in a grid controlled by the <code>ncol</code> and <code>nrow</code>
arguments.
</p>


<h3>Value</h3>

<p>A list containing Grayscale images. The length will depend on the
number of indexes used.
</p>
<p>A <code>NULL</code> object
</p>


<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Nobuyuki Otsu, &quot;A threshold selection method from gray-level
histograms&quot;. IEEE Trans. Sys., Man., Cyber. 9 (1): 62-66. 1979.
<a href="https://doi.org/10.1109/TSMC.1979.4310076">doi:10.1109/TSMC.1979.4310076</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
image_index(img, index = c("R, NR"))

# Example for S3 method plot()
library(pliman)
img &lt;- image_pliman("sev_leaf.jpg")
# compute the index
ind &lt;- image_index(img, index = c("R, G, B, NGRDI"), plot = FALSE)
plot(ind)

# density plot
plot(ind, type = "density")
</code></pre>

<hr>
<h2 id='image_prepare'>Prepare an image</h2><span id='topic+image_prepare'></span>

<h3>Description</h3>

<p>This function aligns and crops the image using either base or mapview
visualization. This is useful to prepare the images to be analyzed with
<code><a href="#topic+analyze_objects_shp">analyze_objects_shp()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_prepare(img, viewer = get_pliman_viewer())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_prepare_+3A_img">img</code></td>
<td>
<p>An optional <code>Image</code> object</p>
</td></tr>
<tr><td><code id="image_prepare_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The alighed/cropped image for further visualization or analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
if(interactive()){
img &lt;- image_pliman("mult_leaves.jpg")
image_prepare(img, viewer = "mapview")
}
</code></pre>

<hr>
<h2 id='image_segment'>Image segmentation</h2><span id='topic+image_segment'></span><span id='topic+image_segment_iter'></span>

<h3>Description</h3>


<ul>
<li> <p><code>image_segment()</code> reduces a color, color near-infrared, or grayscale images
to a segmented image using a given color channel (red, green blue) or even
color indexes (See <code><a href="#topic+image_index">image_index()</a></code> for more details). The Otsu's thresholding
method (Otsu, 1979) is used to automatically perform clustering-based image
thresholding.
</p>
</li>
<li> <p><code>image_segment_iter()</code> Provides an iterative image segmentation, returning
the proportions of segmented pixels.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>image_segment(
  img,
  index = NULL,
  r = 1,
  g = 2,
  b = 3,
  re = 4,
  nir = 5,
  threshold = c("Otsu", "adaptive"),
  k = 0.1,
  windowsize = NULL,
  col_background = NULL,
  has_white_bg = FALSE,
  fill_hull = FALSE,
  filter = FALSE,
  invert = FALSE,
  plot = TRUE,
  nrow = NULL,
  ncol = NULL,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE
)

image_segment_iter(
  img,
  nseg = 2,
  index = NULL,
  invert = NULL,
  threshold = NULL,
  k = 0.1,
  windowsize = NULL,
  has_white_bg = FALSE,
  plot = TRUE,
  verbose = TRUE,
  nrow = NULL,
  ncol = NULL,
  parallel = FALSE,
  workers = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_segment_+3A_img">img</code></td>
<td>
<p>An image object or a list of image objects.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_index">index</code></td>
<td>

<ul>
<li><p> For <code>image_segment()</code>, a character value (or a vector of characters)
specifying the target mode for conversion to binary image. See the available
indexes with <code><a href="#topic+pliman_indexes">pliman_indexes()</a></code>.  See <code><a href="#topic+image_index">image_index()</a></code> for more details.
</p>
</li>
<li><p> For <code>image_segment_iter()</code> a character or a vector of characters with the
same length of <code>nseg</code>. It can be either an available index (described above)
or any operation involving the RGB values (e.g., <code>"B/R+G"</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="image_segment_+3A_r">r</code>, <code id="image_segment_+3A_g">g</code>, <code id="image_segment_+3A_b">b</code>, <code id="image_segment_+3A_re">re</code>, <code id="image_segment_+3A_nir">nir</code></td>
<td>
<p>The red, green, blue, red-edge, and near-infrared bands
of the image, respectively. Defaults to 1, 2, 3, 4, and 5, respectively. If
a multispectral image is provided (5 bands), check the order of bands,
which are frequently presented in the 'BGR' format.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_threshold">threshold</code></td>
<td>
<p>The theshold method to be used.
</p>

<ul>
<li><p> By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image. If
a numeric value is informed, this value will be used as a threshold.
</p>
</li>
<li><p> If <code>threshold = "adaptive"</code>, adaptive thresholding (Shafait et al. 2008)
is used, and will depend on the <code>k</code> and <code>windowsize</code> arguments.
</p>
</li>
<li><p> If any non-numeric value different than <code>"Otsu"</code> and <code>"adaptive"</code> is used,
an iterative section will allow you to choose the threshold based on a
raster plot showing pixel intensity of the index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="image_segment_+3A_k">k</code></td>
<td>
<p>a numeric in the range 0-1. when <code>k</code> is high, local threshold
values tend to be lower. when <code>k</code> is low, local threshold value tend to be
higher.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_windowsize">windowsize</code></td>
<td>
<p>windowsize controls the number of local neighborhood in
adaptive thresholding. By default it is set to <code>1/3 * minxy</code>, where
<code>minxy</code> is the minimum dimension of the image (in pixels).</p>
</td></tr>
<tr><td><code id="image_segment_+3A_col_background">col_background</code></td>
<td>
<p>The color of the segmented background. Defaults to
<code>NULL</code> (white background).</p>
</td></tr>
<tr><td><code id="image_segment_+3A_has_white_bg">has_white_bg</code></td>
<td>
<p>Logical indicating whether a white background is present.
If <code>TRUE</code>, pixels that have R, G, and B values equals to 1 will be
considered as <code>NA</code>. This may be useful to compute an image index for
objects that have, for example, a white background. In such cases, the
background will not be considered for the threshold computation.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the objects? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code><a href="#topic+image_filter">image_filter()</a></code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing
noise, but adversely affect edges.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image, if desired. For
<code>image_segmentation_iter()</code> use a vector with the same length of <code>nseg</code>.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_plot">plot</code></td>
<td>
<p>Show image after processing?</p>
</td></tr>
<tr><td><code id="image_segment_+3A_nrow">nrow</code>, <code id="image_segment_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time when <code>image</code> is a list. The number of sections is set
up to 70% of available cores.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_nseg">nseg</code></td>
<td>
<p>The number of iterative segmentation steps to be performed.</p>
</td></tr>
<tr><td><code id="image_segment_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>image_segment()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>image_segment()</code> returns list containing <code>n</code> objects where <code>n</code> is the
number of indexes used. Each objects contains:
</p>

<ul>
<li> <p><code>image</code> an image with the RGB bands (layers) for the segmented object.
</p>
</li>
<li> <p><code>mask</code> A mask with logical values of 0 and 1 for the segmented image.
</p>
</li></ul>

</li>
<li> <p><code>image_segment_iter()</code> returns a list with (1) a data frame with the
proportion of pixels in the segmented images and (2) the segmented images.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>References</h3>

<p>Nobuyuki Otsu, &quot;A threshold selection method from gray-level
histograms&quot;. IEEE Trans. Sys., Man., Cyber. 9 (1): 62-66. 1979.
<a href="https://doi.org/10.1109/TSMC.1979.4310076">doi:10.1109/TSMC.1979.4310076</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("soybean_touch.jpg", plot = TRUE)
image_segment(img, index = c("R, G, B"))

# adaptive thresholding

</code></pre>

<hr>
<h2 id='image_segment_kmeans'>Image segmentation using k-means clustering</h2><span id='topic+image_segment_kmeans'></span>

<h3>Description</h3>

<p>Segments image objects using clustering by the k-means clustering algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_segment_kmeans(
  img,
  bands = 1:3,
  nclasses = 2,
  invert = FALSE,
  filter = FALSE,
  fill_hull = FALSE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_segment_kmeans_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object.</p>
</td></tr>
<tr><td><code id="image_segment_kmeans_+3A_bands">bands</code></td>
<td>
<p>A numeric integer/vector indicating the RGB band used in the
segmentation. Defaults to <code>1:3</code>, i.e., all the RGB bands are used.</p>
</td></tr>
<tr><td><code id="image_segment_kmeans_+3A_nclasses">nclasses</code></td>
<td>
<p>The number of desired classes after image segmentation.</p>
</td></tr>
<tr><td><code id="image_segment_kmeans_+3A_invert">invert</code></td>
<td>
<p>Invert the segmentation? Defaults to <code>FALSE</code>. If <code>TRUE</code> the
binary matrix is inverted.</p>
</td></tr>
<tr><td><code id="image_segment_kmeans_+3A_filter">filter</code></td>
<td>
<p>Applies a median filtering in the binary matrix? Defaults to
<code>FALSE</code>. Use a numeric integer to indicate the size of the median filter.</p>
</td></tr>
<tr><td><code id="image_segment_kmeans_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the objects? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="image_segment_kmeans_+3A_plot">plot</code></td>
<td>
<p>Plot the segmented image?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following values:
</p>

<ul>
<li> <p><code>image</code> The segmented image considering only two classes (foreground and
background)
</p>
</li>
<li> <p><code>clusters</code> The class of each pixel. For example, if <code>ncluster = 3</code>,
<code>clusters</code> will be a two-way matrix with values ranging from 1 to 3.
<code>masks</code> A list with the binary matrices showing the segmentation.
</p>
</li></ul>



<h3>References</h3>

<p>Hartigan, J. A. and Wong, M. A. (1979). Algorithm AS 136: A
K-means clustering algorithm. Applied Statistics, 28, 100108.
<a href="https://doi.org/10.2307/2346830">doi:10.2307/2346830</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- image_pliman("la_leaves.jpg", plot = TRUE)
seg &lt;- image_segment_kmeans(img)
seg &lt;- image_segment_kmeans(img, fill_hull = TRUE, invert = TRUE, filter = 10)
</code></pre>

<hr>
<h2 id='image_segment_manual'>Image segmentation by hand</h2><span id='topic+image_segment_manual'></span>

<h3>Description</h3>

<p>This R code is a function that allows the user to manually segment an image based on the parameters provided. This only works in an interactive section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_segment_manual(
  img,
  shape = c("free", "circle", "rectangle"),
  type = c("select", "remove"),
  viewer = get_pliman_viewer(),
  resize = TRUE,
  edge = 5,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_segment_manual_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object.</p>
</td></tr>
<tr><td><code id="image_segment_manual_+3A_shape">shape</code></td>
<td>
<p>The type of shape to use. Defaults to &quot;free&quot;. Other possible
values are &quot;circle&quot; and &quot;rectangle&quot;. Partial matching is allowed.</p>
</td></tr>
<tr><td><code id="image_segment_manual_+3A_type">type</code></td>
<td>
<p>The type of segmentation. By default (<code>type = "select"</code>) objects
are selected. Use <code>type = "remove"</code> to remove the selected area from the
image.</p>
</td></tr>
<tr><td><code id="image_segment_manual_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="image_segment_manual_+3A_resize">resize</code></td>
<td>
<p>By default, the segmented object is resized to fill the
original image size. Use <code>resize = FALSE</code> to keep the segmented object in
the original scale.</p>
</td></tr>
<tr><td><code id="image_segment_manual_+3A_edge">edge</code></td>
<td>
<p>Number of pixels to add in the edge of the segmented object when
<code>resize = TRUE</code>. Defaults to 5.</p>
</td></tr>
<tr><td><code id="image_segment_manual_+3A_plot">plot</code></td>
<td>
<p>Plot the segmented object? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the shape is &quot;free&quot;, it allows the user to draw a perimeter to
select/remove objects. If the shape is &quot;circle&quot;, it allows the user to
click on the center and edge of the circle to define the desired area. If
the shape is &quot;rectangle&quot;, it allows the user to select two points to define
the area.
</p>


<h3>Value</h3>

<p>A list with the segmented image and the mask used for segmentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
img &lt;- image_pliman("la_leaves.jpg")
seg &lt;- image_segment_manual(img)
plot(seg$mask)

}
</code></pre>

<hr>
<h2 id='image_segment_mask'>Segment an <code>Image</code> object using a brush mask</h2><span id='topic+image_segment_mask'></span>

<h3>Description</h3>

<p>It combines <code><a href="#topic+make_mask">make_mask()</a></code> and <code><a href="#topic+make_brush">make_brush()</a></code> to segment an <code>Image</code> object
using a brush of desired size, shape, and position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_segment_mask(
  img,
  size,
  shape = "disc",
  rel_pos_x = 0.5,
  rel_pos_y = 0.5,
  type = c("binary", "shadow"),
  col_background = "white",
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_segment_mask_+3A_img">img</code></td>
<td>
<p>A <code>Image</code> object</p>
</td></tr>
<tr><td><code id="image_segment_mask_+3A_size">size</code></td>
<td>
<p>A numeric containing the size of the brush in pixels. This should
be an odd number; even numbers are rounded to the next odd one.</p>
</td></tr>
<tr><td><code id="image_segment_mask_+3A_shape">shape</code></td>
<td>
<p>A character vector indicating the shape of the brush. Can be
<code>"box"</code>, <code>"disc"</code>, <code>"diamond"</code>, <code>"Gaussian"</code> or <code>"line"</code> Defaults to
<code>"disc"</code>.</p>
</td></tr>
<tr><td><code id="image_segment_mask_+3A_rel_pos_x">rel_pos_x</code>, <code id="image_segment_mask_+3A_rel_pos_y">rel_pos_y</code></td>
<td>
<p>A relative position to include the brush in the
image. Defaults to 0.5. This means that the brush will be centered in the
original image. Smaller values move the brush toward the left and top,
respectively.</p>
</td></tr>
<tr><td><code id="image_segment_mask_+3A_type">type</code></td>
<td>
<p>Defines the type of the mask. By default, a binary mask is
applied. This results in white pixels in the original image that matches
the 0s pixels in the brush. If <code>type = "shadow"</code> is used, a shadow mask is produced</p>
</td></tr>
<tr><td><code id="image_segment_mask_+3A_col_background">col_background</code></td>
<td>
<p>Background color after image segmentation. Defaults to
<code>"white"</code>.</p>
</td></tr>
<tr><td><code id="image_segment_mask_+3A_plot">plot</code></td>
<td>
<p>Plots the generated mask? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="image_segment_mask_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="EBImage.html#topic+morphology">EBImage::makeBrush()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A color <code>Image</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- image_pliman("soybean_touch.jpg")
plot(img)
image_segment_mask(img, size = 601)
image_segment_mask(img,
                   size = 401,
                   shape = "diamond",
                   rel_pos_x = 0,
                   rel_pos_y = 0,
                   type = "shadow")
</code></pre>

<hr>
<h2 id='image_shp'>Construct a shape file from an image</h2><span id='topic+image_shp'></span>

<h3>Description</h3>

<p>Creates a list of object coordinates given the desired number of nrow and
columns. It starts by selecting 4 points at the corners of objects of
interest in the plot space. Then, given <code>nrow</code> and <code>ncol</code>, a grid is drawn
and the objects' coordinates are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_shp(
  img,
  nrow = 1,
  ncol = 1,
  buffer_x = 0,
  buffer_y = 0,
  interactive = FALSE,
  viewer = get_pliman_viewer(),
  col_line = "red",
  size_line = 2,
  col_text = "red",
  size_text = 1,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_shp_+3A_img">img</code></td>
<td>
<p>An object of class <code>Image</code></p>
</td></tr>
<tr><td><code id="image_shp_+3A_nrow">nrow</code></td>
<td>
<p>The number of desired rows in the grid. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="image_shp_+3A_ncol">ncol</code></td>
<td>
<p>The number of desired columns in the grid. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="image_shp_+3A_buffer_x">buffer_x</code>, <code id="image_shp_+3A_buffer_y">buffer_y</code></td>
<td>
<p>Buffering factor for the width and height,
respectively, of each individual shape's side. A value between 0 and 0.5 where 0
means no buffering and 0.5 means complete buffering (default: 0). A value of
0.25 will buffer the shape by 25% on each side.</p>
</td></tr>
<tr><td><code id="image_shp_+3A_interactive">interactive</code></td>
<td>
<p>If <code>FALSE</code> (default) the grid is created automatically
based on the image dimension and number of rows/columns. If <code>interactive = TRUE</code>, users must draw points at the diagonal of the desired bounding box
that will contain the grid.</p>
</td></tr>
<tr><td><code id="image_shp_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are <code>"base"</code> and
<code>"mapview"</code>. If set to &quot;base&quot;, the base R graphics system is used for
interactive plotting. If set to &quot;mapview&quot;, the mapview package is used. To
set this argument globally for all functions in the package, you can use
the <code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="image_shp_+3A_col_line">col_line</code>, <code id="image_shp_+3A_col_text">col_text</code></td>
<td>
<p>The color of the line/text in the grid. Defaults to
<code>"red"</code>.</p>
</td></tr>
<tr><td><code id="image_shp_+3A_size_line">size_line</code>, <code id="image_shp_+3A_size_text">size_text</code></td>
<td>
<p>The size of the line/text in the grid. Defaults to
<code>2.5</code>.</p>
</td></tr>
<tr><td><code id="image_shp_+3A_plot">plot</code></td>
<td>
<p>Plots the grid on the image? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>row * col</code> objects containing the plot coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
flax &lt;- image_pliman("flax_leaves.jpg")
shape &lt;- image_shp(flax, nrow = 3, ncol = 5)

</code></pre>

<hr>
<h2 id='image_square'>Squares an image</h2><span id='topic+image_square'></span>

<h3>Description</h3>

<p>Converts a rectangular image into a square image by expanding the
rows/columns using <code><a href="#topic+image_expand">image_expand()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_square(img, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_square_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object.</p>
</td></tr>
<tr><td><code id="image_square_+3A_plot">plot</code></td>
<td>
<p>Plots the extended image? defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="image_square_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+image_expand">image_expand()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <code>Image</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
dim(img)
square &lt;- image_square(img)
dim(square)
</code></pre>

<hr>
<h2 id='image_thinning_guo_hall'>Perform Guo-Hall thinning on a binary image or list of binary images</h2><span id='topic+image_thinning_guo_hall'></span>

<h3>Description</h3>

<p>This function performs the Guo-Hall thinning algorithm (Guo and Hall, 1989)
on a binary image or a list of binary images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_thinning_guo_hall(
  img,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_thinning_guo_hall_+3A_img">img</code></td>
<td>
<p>The binary image or a list of binary images to be thinned. It can
be either a single binary image of class 'Image' or a list of binary
images.</p>
</td></tr>
<tr><td><code id="image_thinning_guo_hall_+3A_parallel">parallel</code></td>
<td>
<p>Logical, whether to perform thinning using multiple cores
(parallel processing). If TRUE, the function will use multiple cores for
processing if available. Default is FALSE.</p>
</td></tr>
<tr><td><code id="image_thinning_guo_hall_+3A_workers">workers</code></td>
<td>
<p>Integer, the number of workers (cores) to use for parallel
processing. If NULL (default), it will use 40% of available cores.</p>
</td></tr>
<tr><td><code id="image_thinning_guo_hall_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to display progress messages during parallel
processing. Default is TRUE.</p>
</td></tr>
<tr><td><code id="image_thinning_guo_hall_+3A_plot">plot</code></td>
<td>
<p>Logical, whether to plot the thinned images. Default is FALSE.</p>
</td></tr>
<tr><td><code id="image_thinning_guo_hall_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+image_binary">image_binary()</a></code> if
<code>img</code> is not a binary image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>img</code> is a single binary image, the function returns the
thinned binary image. If <code>img</code> is a list of binary images, the
function returns a list containing the thinned binary images.
</p>


<h3>References</h3>

<p>Guo, Z., and R.W. Hall. 1989. Parallel thinning with
two-subiteration algorithms. Commun. ACM 32(3): 359373.
<a href="https://doi.org/10.1145/62065.62074">doi:10.1145/62065.62074</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("potato_leaves.jpg", plot = TRUE)
image_thinning_guo_hall(img, index = "R", plot = TRUE)


</code></pre>

<hr>
<h2 id='image_to_mat'>Convert an image to a data.frame</h2><span id='topic+image_to_mat'></span>

<h3>Description</h3>

<p>Given an object image, converts it into a data frame where each row corresponds to the intensity values of each pixel in the image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_to_mat(img, parallel = FALSE, workers = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_to_mat_+3A_img">img</code></td>
<td>
<p>An image object.</p>
</td></tr>
<tr><td><code id="image_to_mat_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time when <code>image</code> is a list. The number of sections is set
up to 70% of available cores.</p>
</td></tr>
<tr><td><code id="image_to_mat_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="image_to_mat_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three matrices (R, G, and B), and a data frame
containing four columns: the name of the image in <code>image</code> and the R, G, B
values.
</p>


<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("sev_leaf.jpg")
dim(img)
mat &lt;- image_to_mat(img)
dim(mat[[1]])
</code></pre>

<hr>
<h2 id='image_view'>Create an interactive map view of an image</h2><span id='topic+image_view'></span>

<h3>Description</h3>

<p>This function allows users to interactively edit and analyze an image using
mapview and mapedit packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_view(
  img,
  object = NULL,
  r = 1,
  g = 2,
  b = 3,
  alpha = 0.7,
  attribute = "area",
  title = "Edit the image",
  show = c("rgb", "index"),
  index = "B",
  max_pixels = 1e+06,
  downsample = NULL,
  color_regions = custom_palette(),
  quantiles = c(0, 1),
  domain = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_view_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object.</p>
</td></tr>
<tr><td><code id="image_view_+3A_object">object</code></td>
<td>
<p>(Optional). An object computed with <code><a href="#topic+analyze_objects">analyze_objects()</a></code>. If an
object is informed, an additional layer is added to the plot, showing the
contour of the analyzed objects, with a color gradient defined by
<code>attribute</code>.</p>
</td></tr>
<tr><td><code id="image_view_+3A_r">r</code>, <code id="image_view_+3A_g">g</code>, <code id="image_view_+3A_b">b</code></td>
<td>
<p>The layer for the Red, Green and Blue band, respectively.
Defaults to <code>1</code>, <code>2</code>, and <code>3</code>.</p>
</td></tr>
<tr><td><code id="image_view_+3A_alpha">alpha</code></td>
<td>
<p>The transparency level of the rectangles' color (between 0 and 1).</p>
</td></tr>
<tr><td><code id="image_view_+3A_attribute">attribute</code></td>
<td>
<p>The name of the quantitative variable in the
<code>object_index</code> to be used for coloring the rectangles.</p>
</td></tr>
<tr><td><code id="image_view_+3A_title">title</code></td>
<td>
<p>The title of the map view. Use to provide short orientations to
the user.</p>
</td></tr>
<tr><td><code id="image_view_+3A_show">show</code></td>
<td>
<p>The display option for the map view. Options are &quot;rgb&quot; for RGB
view and &quot;index&quot; for index view.</p>
</td></tr>
<tr><td><code id="image_view_+3A_index">index</code></td>
<td>
<p>The index to use for the index view. Defaults to &quot;B&quot;.</p>
</td></tr>
<tr><td><code id="image_view_+3A_max_pixels">max_pixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to use for the plot.
If <code>max_pixels &lt; npixels(img)</code>, regular sampling is used before plotting.</p>
</td></tr>
<tr><td><code id="image_view_+3A_downsample">downsample</code></td>
<td>
<p>integer; for each dimension the number of
pixels/lines/bands etc that will be skipped; Defaults to <code>NULL</code>, which will
find the best downsampling factor to approximate the <code>max_pixels</code> value.</p>
</td></tr>
<tr><td><code id="image_view_+3A_color_regions">color_regions</code></td>
<td>
<p>The color palette for displaying index values. Default
is <code><a href="#topic+custom_palette">custom_palette()</a></code>.</p>
</td></tr>
<tr><td><code id="image_view_+3A_quantiles">quantiles</code></td>
<td>
<p>the upper and lower quantiles used for color stretching. If
set to <code>NULL</code>, stretching is performed basing on 'domain' argument.</p>
</td></tr>
<tr><td><code id="image_view_+3A_domain">domain</code></td>
<td>
<p>the upper and lower values used for color stretching. This is
used only if <code>'quantiles'</code> is <code>NULL</code>. If both '<code style="white-space: pre;">&#8288;domain'&#8288;</code> and <code>'quantiles'</code>
are set to <code>NULL</code>, stretching is applied based on min-max values.</p>
</td></tr>
<tr><td><code id="image_view_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>downsample_fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> object, the same object returned by <code><a href="mapedit.html#topic+editMap">mapedit::editMap()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# Example usage:
img &lt;- image_pliman("sev_leaf.jpg")
image_view(img)
}

</code></pre>

<hr>
<h2 id='landmarks'>Create image landmarks</h2><span id='topic+landmarks'></span>

<h3>Description</h3>

<p>An interactive section where the user will be able to click on the image to
select landmarks manually is open. With each mouse click, a point is drawn
and an upward counter is shown in the console. After <code>n</code> counts or after the
user press Esc, the interactive process is interrupted and a <code>data.frame</code>
with the <code>x</code> and <code>y</code> coordinates for the landmarks is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarks(
  img,
  n = Inf,
  viewer = get_pliman_viewer(),
  scale = NULL,
  calibrate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landmarks_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object.</p>
</td></tr>
<tr><td><code id="landmarks_+3A_n">n</code></td>
<td>
<p>The number of landmarks to produce. Defaults to <code>Inf</code>. In this case,
landmarks are chosen up to the user press Esc.</p>
</td></tr>
<tr><td><code id="landmarks_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="landmarks_+3A_scale">scale</code></td>
<td>
<p>A known scale of the coordinate values. If <code>NULL</code> (default)
<code>scale = 1</code> is used.</p>
</td></tr>
<tr><td><code id="landmarks_+3A_calibrate">calibrate</code></td>
<td>
<p>A logical argument indicating whether a calibration step
must be performed before picking up the landmarks. If so, <code><a href="#topic+calibrate">calibrate()</a></code> is
called internally. Users must then select two points and indicate a known
distance. A scale value will internally be computed and used in the
correction of the coordinates (from pixels to the unit of the known
distance).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the <code>x</code> and <code>y</code>-coordinates from the landmarks.
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(isTRUE(interactive())){
library(pliman)
img &lt;- image_pliman("potato_leaves.jpg")
x &lt;- landmarks(img)
}
</code></pre>

<hr>
<h2 id='landmarks_add'>Artificially inflates the number of landmarks</h2><span id='topic+landmarks_add'></span>

<h3>Description</h3>

<p>Interpolates supplementary landmarks that correspond to the mean coordinates
of two adjacent landmarks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarks_add(x, n = 3, smooth_iter = 0, plot = TRUE, nrow = NULL, ncol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landmarks_add_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code>, a <code>data.frame</code> a <code>list</code> of perimeter coordinates, often
produced with <code><a href="#topic+object_contour">object_contour()</a></code>, <code><a href="#topic+landmarks">landmarks()</a></code>, or <code><a href="#topic+landmarks_regradi">landmarks_regradi()</a></code>.</p>
</td></tr>
<tr><td><code id="landmarks_add_+3A_n">n</code></td>
<td>
<p>The number of iterations. Defaults to 3.</p>
</td></tr>
<tr><td><code id="landmarks_add_+3A_smooth_iter">smooth_iter</code></td>
<td>
<p>The number of smoothing iterations to perform. This will
smooth the perimeter of the interpolated landmarks using <code><a href="#topic+poly_smooth">poly_smooth()</a></code>.</p>
</td></tr>
<tr><td><code id="landmarks_add_+3A_plot">plot</code></td>
<td>
<p>Creates a plot? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="landmarks_add_+3A_ncol">ncol</code>, <code id="landmarks_add_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows or columns in the plot grid when a <code>list</code>
is used in <code>x</code>. Defaults to <code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Matrix of interpolated coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)

# equally spaced landmarks
plot_polygon(contours[[4]])
ldm &lt;- landmarks_regradi(contours[[4]], plot = FALSE)
points(ldm$coords, pch = 16)
segments(mean(ldm$coords[,1]),
         mean(ldm$coords[,2]),
         ldm$coords[,1],
         ldm$coords[,2])

ldm_add &lt;- landmarks_add(ldm, plot = FALSE)
points(ldm_add, col = "red")
points(ldm$coords, pch = 16)

# smoothed version
ldm_add_smo &lt;- landmarks_add(ldm, plot = FALSE, smooth_iter = 10)
lines(ldm_add_smo, col = "blue", lwd = 3)
</code></pre>

<hr>
<h2 id='landmarks_angle'>Angles between landmarks</h2><span id='topic+landmarks_angle'></span>

<h3>Description</h3>

<p>Computes the angle from two interlandmark vectors using the difference of
their arguments using complex vectors (Claude, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarks_angle(x, unit = c("rad", "deg"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landmarks_angle_+3A_x">x</code></td>
<td>
<p>An object computed with <code><a href="#topic+landmarks">landmarks()</a></code>.</p>
</td></tr>
<tr><td><code id="landmarks_angle_+3A_unit">unit</code></td>
<td>
<p>The unit of the angle. Defaults to radian (rad). Use <code>unit = "deg"</code> to return the angles in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the angles for each landmark combination.
</p>


<h3>Note</h3>

<p>Borrowed from Claude (2008), pp. 50
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(isTRUE(interactive())){
library(pliman)
img &lt;- image_pliman("potato_leaves.jpg")
x &lt;- landmarks(img)
landmarks_angle(x)
}
</code></pre>

<hr>
<h2 id='landmarks_dist'>Distances between landmarks</h2><span id='topic+landmarks_dist'></span>

<h3>Description</h3>

<p>Computes the distance between two landmarks as the square root of the sum of
the squared differences between each coordinate (Claude, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarks_dist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landmarks_dist_+3A_x">x</code></td>
<td>
<p>An object computed with <code><a href="#topic+landmarks">landmarks()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the distances for each landmark combination.
</p>


<h3>Note</h3>

<p>Borrowed from Claude (2008), pp. 49
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(isTRUE(interactive())){
library(pliman)
img &lt;- image_pliman("potato_leaves.jpg")
x &lt;- landmarks(img)
landmarks_dist(x)
}

</code></pre>

<hr>
<h2 id='landmarks_regradi'>Pseudolandmarks with equally spaced angles</h2><span id='topic+landmarks_regradi'></span>

<h3>Description</h3>

<p>Select <code>n</code> landmarks that are spaced with a regular sequence of angles taken
between the outline coordinates and the centroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarks_regradi(
  x,
  n = 50,
  close = TRUE,
  plot = TRUE,
  ncol = NULL,
  nrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landmarks_regradi_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code>, a <code>data.frame</code> a <code>list</code> of perimeter coordinates, often
produced with <code><a href="#topic+object_contour">object_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="landmarks_regradi_+3A_n">n</code></td>
<td>
<p>Number of points to be sampled. Defaults to 50.</p>
</td></tr>
<tr><td><code id="landmarks_regradi_+3A_close">close</code></td>
<td>
<p>Return a closed polygon? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="landmarks_regradi_+3A_plot">plot</code></td>
<td>
<p>Create a plot? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="landmarks_regradi_+3A_ncol">ncol</code>, <code id="landmarks_regradi_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows or columns in the plot grid when a <code>list</code>
is used in <code>x</code>. Defaults to <code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following objects:
</p>

<ul>
<li> <p><code>pixindices</code>: Vector of radius indices.
</p>
</li>
<li> <p><code>radii</code>: Vector of sampled radii lengths.
</p>
</li>
<li> <p><code>Xc</code>: The centroid coordinate of <code>x</code> axis.
</p>
</li>
<li> <p><code>Yc</code>: The centroid coordinate of <code>y</code> axis.
</p>
</li>
<li> <p><code>coords</code>: Coordinates of sampled points arranged in a two-column matrix.
</p>
</li></ul>

<p>If <code>x</code> is a list, a list of objects described above is returned.
</p>


<h3>Note</h3>

<p>Borrowed from Claude (2008), pp. 53
</p>


<h3>References</h3>

<p>Claude, J. (2008) <em>Morphometrics with R</em>, Use R! series,
Springer 316 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
plot_polygon(contours[[1]])
ldm &lt;- landmarks_regradi(contours)

</code></pre>

<hr>
<h2 id='leading_zeros'>Add leading zeros to a numeric sequence</h2><span id='topic+leading_zeros'></span>

<h3>Description</h3>

<p>Add <code>n</code> leading zeros to a numeric sequence. This is useful to create a
character vector to rename files in a folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leading_zeros(x, n = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leading_zeros_+3A_x">x</code></td>
<td>
<p>A numeric vector or a list of numeric vectors.</p>
</td></tr>
<tr><td><code id="leading_zeros_+3A_n">n</code></td>
<td>
<p>The number of leading zeros to add. Defaults to <code>3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector or a list of character vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
leading_zeros(1:5)
leading_zeros(list(a = 1:3,
                   b = 1:5),
              n = 2)
</code></pre>

<hr>
<h2 id='make_brush'>Makes a brush</h2><span id='topic+make_brush'></span>

<h3>Description</h3>

<p>Generates brushes of various sizes and shapes that can be used as structuring
elements. See <code><a href="EBImage.html#topic+morphology">EBImage::makeBrush()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_brush(size, shape = "disc", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_brush_+3A_size">size</code></td>
<td>
<p>A numeric containing the size of the brush in pixels. This should
be an odd number; even numbers are rounded to the next odd one.</p>
</td></tr>
<tr><td><code id="make_brush_+3A_shape">shape</code></td>
<td>
<p>A character vector indicating the shape of the brush. Can be
<code>"box"</code>, <code>"disc"</code>, <code>"diamond"</code>, <code>"Gaussian"</code> or <code>"line"</code> Defaults to
<code>"disc"</code>.</p>
</td></tr>
<tr><td><code id="make_brush_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="EBImage.html#topic+morphology">EBImage::makeBrush()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2D matrix of 0s and 1s containing the desired brush.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_brush(size = 51) |&gt; image()
make_brush(size = 51, shape = "diamond") |&gt; image()
</code></pre>

<hr>
<h2 id='make_mask'>Makes a mask in an image</h2><span id='topic+make_mask'></span>

<h3>Description</h3>

<p>Make a mask using an <code>Image</code> object and a brush.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mask(img, brush, rel_pos_x = 0.5, rel_pos_y = 0.5, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mask_+3A_img">img</code></td>
<td>
<p>A <code>Image</code> object</p>
</td></tr>
<tr><td><code id="make_mask_+3A_brush">brush</code></td>
<td>
<p>An object created with <code>make_brush()</code></p>
</td></tr>
<tr><td><code id="make_mask_+3A_rel_pos_x">rel_pos_x</code>, <code id="make_mask_+3A_rel_pos_y">rel_pos_y</code></td>
<td>
<p>A relative position to include the brush in the
image. Defaults to 0.5. This means that the brush will be centered in the
original image. Smaller values move the brush toward the left and top,
respectively.</p>
</td></tr>
<tr><td><code id="make_mask_+3A_plot">plot</code></td>
<td>
<p>Plots the generated mask? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It applies a brush to an Image, selecting the <code>Image</code> pixels that match the
brush values equal to 1. The position of the brush in the original image is
controlled by the relative positions x (<code>rel_pos_x</code>) and y (<code>rel_pos_y</code>)
arguments.  The size of the brush must be smaller or equal to the smaller
dimension of <code>image</code>.
</p>


<h3>Value</h3>

<p>A binary image with 0s and 1s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- image_pliman("soybean_touch.jpg")
make_mask(img, brush = make_brush(size = 201))
make_mask(img,
          brush = make_brush(size = 401, shape = "diamond"),
          rel_pos_x = 0.1,
          rel_pos_y = 0.8)
</code></pre>

<hr>
<h2 id='measure_disease'>Performs plant disease measurements</h2><span id='topic+measure_disease'></span><span id='topic+measure_disease_iter'></span>

<h3>Description</h3>


<ul>
<li> <p><code>measure_disease()</code> computes the percentage of symptomatic leaf area and
(optionally) counts and compute shapes (area, perimeter, radius, etc.) of
lesions in a sample or entire leaf using color palettes. See more at
<strong>Details</strong>.
</p>
</li>
<li> <p><code>measure_disease_iter()</code> provides an iterative section for
<code>measure_disease()</code>, where the user picks up samples in the image to create
the needed color palettes.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>measure_disease(
  img,
  img_healthy = NULL,
  img_symptoms = NULL,
  img_background = NULL,
  pattern = NULL,
  filter = 10,
  parallel = FALSE,
  workers = NULL,
  resize = FALSE,
  fill_hull = TRUE,
  index_lb = NULL,
  index_dh = "GLI",
  has_white_bg = FALSE,
  threshold = NULL,
  invert = FALSE,
  lower_size = NULL,
  upper_size = NULL,
  topn_lower = NULL,
  topn_upper = NULL,
  randomize = TRUE,
  nsample = 3000,
  watershed = FALSE,
  lesion_size = "medium",
  tolerance = NULL,
  extension = NULL,
  show_features = FALSE,
  show_segmentation = FALSE,
  plot = TRUE,
  show_original = TRUE,
  show_background = TRUE,
  show_contour = TRUE,
  contour_col = "white",
  contour_size = 1,
  col_leaf = NULL,
  col_lesions = NULL,
  col_background = NULL,
  marker = FALSE,
  marker_col = NULL,
  marker_size = NULL,
  save_image = FALSE,
  prefix = "proc_",
  name = NULL,
  dir_original = NULL,
  dir_processed = NULL,
  verbose = TRUE
)

measure_disease_iter(
  img,
  has_background = TRUE,
  r = 2,
  viewer = get_pliman_viewer(),
  show = "rgb",
  index = "NGRDI",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measure_disease_+3A_img">img</code></td>
<td>
<p>The image to be analyzed.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_img_healthy">img_healthy</code></td>
<td>
<p>A color palette of healthy tissues.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_img_symptoms">img_symptoms</code></td>
<td>
<p>A color palette of lesioned tissues.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_img_background">img_background</code></td>
<td>
<p>A color palette of the background (if exists). These
arguments can be either an <code>Image</code> object stored in the global environment
or a character value. If a chacarceter is used (eg., <code>img_healthy = "leaf"</code>), the function will search in the current working directory a valid
image that contains &quot;<code style="white-space: pre;">&#8288;leaf"&#8288;</code> in the name. Note that if two images matches
this pattern, an error will occour.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_pattern">pattern</code></td>
<td>
<p>A pattern of file name used to identify images to be
processed. For example, if <code>pattern = "im"</code> all images that the name
matches the pattern (e.g., img1.-, image1.-, im2.-) will be analyzed.
Providing any number as pattern (e.g., <code>pattern = "1"</code>) will select
images that are named as 1.-, 2.-, and so on.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image that segments the
leaf from background? By default, a median filter of <code>size = 10</code> is applied.
This is useful to reduce the noise and segment the leaf and background more
accurately. See more at <code><a href="#topic+image_filter">image_filter()</a></code>. Set to <code>FALSE</code> to cancel median
filtering.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time, especially when <code>pattern</code> is used is informed. The
number of sections is set up to 30% of available cores.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_resize">resize</code></td>
<td>
<p>Resize the image before processing? Defaults to <code>FALSE</code>. Use a
numeric value of range 0-100 (proportion of the size of the original
image).</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the image? Defaults to <code>TRUE</code>. This is useful
to fill holes in leaves, e.g., those caused by insect attack, ensuring the
hole area will be accounted for the leaf, not background.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_index_lb">index_lb</code></td>
<td>
<p>The index used to segment the foreground (e.g., leaf) from
the background. If not declared, the entire image area (pixels) will be
considered in the computation of the severity.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_index_dh">index_dh</code></td>
<td>
<p>The index used to segment diseased from healthy tissues when
<code>img_healthy</code> and <code>img_symptoms</code> are not declared. Defaults to <code>"GLI"</code>. See
<code><a href="#topic+image_index">image_index()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_has_white_bg">has_white_bg</code></td>
<td>
<p>Logical indicating whether a white background is present.
If <code>TRUE</code>, pixels that have R, G, and B values equals to 1 will be
considered as <code>NA</code>. This may be useful to compute an image index for
objects that have, for example, a white background. In such cases, the
background will not be considered for the threshold computation.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_threshold">threshold</code></td>
<td>
<p>By default (<code>threshold = NULL</code>), a threshold value based on
Otsu's method is used to reduce the grayscale image to a binary image. If a
numeric value is informed, this value will be used as a threshold. Inform
any non-numeric value different than &quot;Otsu&quot; to iteratively choose the
threshold based on a raster plot showing pixel intensity of the index. Must
be a vector of length 2 to indicate the threshold for <code>index_lb</code> and
<code>index_dh</code>, respectively.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image if desired. This is useful to process
images with black background. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_lower_size">lower_size</code></td>
<td>
<p>Lower limit for size for the image analysis. Leaf images
often contain dirt and dust. To prevent dust from affecting the image
analysis, the lower limit of analyzed size is set to 0.1, i.e., objects
with lesser than 10% of the mean of all objects are removed. One can set a
known area or use <code>lower_limit = 0</code> to select all objects (not advised).</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_upper_size">upper_size</code></td>
<td>
<p>Upper limit for size for the image analysis. Defaults to
<code>NULL</code>, i.e., no upper limit used.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_topn_lower">topn_lower</code>, <code id="measure_disease_+3A_topn_upper">topn_upper</code></td>
<td>
<p>Select the top <code>n</code> lesions based on its area.
<code>topn_lower</code> selects the <code>n</code> lesions with the smallest area whereas
<code>topn_upper</code> selects the <code>n</code> lesions with the largest area.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_randomize">randomize</code></td>
<td>
<p>Randomize the lines before training the model? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_nsample">nsample</code></td>
<td>
<p>The number of sample pixels to be used in training step.
Defaults to <code>3000</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_watershed">watershed</code></td>
<td>
<p>If <code>TRUE</code> (Default) implements the Watershed Algorithm to
segment lesions connected by a fairly few pixels that could be considered
as two distinct lesions. If <code>FALSE</code>, lesions that are connected by any
pixel are considered unique lesions. For more details see
<code><a href="EBImage.html#topic+watershed">EBImage::watershed()</a></code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_lesion_size">lesion_size</code></td>
<td>
<p>The size of the lesion. Used to automatically tune
<code>tolerance</code> and <code>extension</code> parameters. One of the following. <code>"small"</code>
(2-5 mm in diameter, e.g, rust pustules), <code>"medium"</code> (0.5-1.0 cm in
diameter, e.g, wheat leaf spot), <code>"large"</code> (1-2 cm in diameter, and
<code>"elarge"</code> (2-3 cm in diameter, e.g, target spot of soybean).</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_tolerance">tolerance</code></td>
<td>
<p>The minimum height of the object in the units of image
intensity between its highest point (seed) and the point where it contacts
another object (checked for every contact pixel). If the height is smaller
than the tolerance, the object will be combined with one of its neighbors,
which is the highest. Defaults to <code>NULL</code>, i.e., starting values are set up
according to the argument <code>lesion_size</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_extension">extension</code></td>
<td>
<p>Radius of the neighborhood in pixels for the detection of
neighboring objects. Defaults to 20. Higher value smooths out small
objects.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_show_features">show_features</code></td>
<td>
<p>If <code>TRUE</code> returnS the lesion features such as number,
area, perimeter, and radius. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_show_segmentation">show_segmentation</code></td>
<td>
<p>Shows the object segmentation colored with random
permutations. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_plot">plot</code></td>
<td>
<p>Show image after processing? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_show_original">show_original</code></td>
<td>
<p>Show the symptoms in the original image?</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_show_background">show_background</code></td>
<td>
<p>Show the background? Defaults to <code>TRUE</code>. A white
background is shown by default when <code>show_original = FALSE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_show_contour">show_contour</code></td>
<td>
<p>Show a contour line around the lesions? Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_contour_col">contour_col</code>, <code id="measure_disease_+3A_contour_size">contour_size</code></td>
<td>
<p>The color and size for the contour line
around objects. Defaults to <code>contour_col = "white"</code> and <code>contour_size = 1</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_col_leaf">col_leaf</code></td>
<td>
<p>Leaf color after image processing. Defaults to <code>"green"</code></p>
</td></tr>
<tr><td><code id="measure_disease_+3A_col_lesions">col_lesions</code></td>
<td>
<p>Symptoms color after image processing. Defaults to
<code>"red"</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_col_background">col_background</code></td>
<td>
<p>Background color after image processing. Defaults to
<code>"NULL"</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_marker">marker</code>, <code id="measure_disease_+3A_marker_col">marker_col</code>, <code id="measure_disease_+3A_marker_size">marker_size</code></td>
<td>
<p>The type, color and size of the object
marker. Defaults to <code>NULL</code>, which shows nothing. Use <code>marker = "point"</code> to
show a point in each lesion or <code>marker = "*"</code> where <code>"*"</code> is any variable
name of the <code>shape</code> data frame returned by the function.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_save_image">save_image</code></td>
<td>
<p>Save the image after processing? The image is saved in the
current working directory named as <code style="white-space: pre;">&#8288;proc_*&#8288;</code> where <code>*</code> is the image name
given in <code>img</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_prefix">prefix</code></td>
<td>
<p>The prefix to be included in the processed images. Defaults to
<code>"proc_"</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_name">name</code></td>
<td>
<p>The name of the image to save. Use this to overwrite the name of
the image in <code>img</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_dir_original">dir_original</code>, <code id="measure_disease_+3A_dir_processed">dir_processed</code></td>
<td>
<p>The directory containing the original and
processed images. Defaults to <code>NULL</code>. In this case, the function will
search for the image <code>img</code> in the current working directory. After
processing, when <code>save_image = TRUE</code>, the processed image will be also
saved in such a directory. It can be either a full path, e.g.,
<code>"C:/Desktop/imgs"</code>, or a subfolder within the current working directory,
e.g., <code>"/imgs"</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_has_background">has_background</code></td>
<td>
<p>A logical indicating if the image has a background to
be segmented before processing.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_r">r</code></td>
<td>
<p>The radius of neighborhood pixels. Defaults to <code>2</code>. A square is
drawn indicating the selected pixels.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_show">show</code></td>
<td>
<p>The show option for the mapview viewer, either <code>"rgb"</code> or
<code>"index"</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_index">index</code></td>
<td>
<p>The index to be shown when <code>show = "rgb"</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_+3A_...">...</code></td>
<td>
<p>Further parameters passed on to <code>measure_disease()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>measure_disease()</code>, a general linear model (binomial family) fitted to
the RGB values is used to segment the lesions from the healthy leaf. If a
pallet of background is provided, the function takes care of the details to
isolate it before computing the number and area of lesions. By using <code>pattern</code>
it is possible to process several images with common pattern names that are
stored in the current working directory or in the subdirectory informed in
<code>dir_original</code>.
</p>
<p>If <code>img_healthy</code> and <code>img_symptoms</code> are not declared, RGB-based phenotyping of
foliar disease severity is performed using the index informed in <code>index_lb</code> to
first segment leaf from background and <code>index_dh</code> to segment diseased from
healthy tissues.
</p>
<p><code>measure_disease_iter()</code> only run in an interactive section. In this function,
users will be able to pick up samples of images to iteratively create the
needed color palettes. This process calls <code><a href="#topic+pick_palette">pick_palette()</a></code> internally. If
<code>has_background</code> is TRUE (default) the color palette for the background is
first created. The sample of colors is performed in each left-button mouse
click and continues until the user press Esc. Then, a new sampling process is
performed to sample the color of healthy tissues and then diseased tissues.
The generated palettes are then passed on to measure_disease(). All the
arguments of such function can be passed using the ... (three dots).
</p>
<p>When <code>show_features = TRUE</code>, the function computes a total of 36 lesion
features (23 shape features and 13 texture features). The Haralick texture
features for each object based on a gray-level co-occurrence matrix (Haralick
et al. 1979). See more details in <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>measure_disease()</code> returns a list with the following objects:
</p>

<ul>
<li> <p><code>severity</code> A data frame with the percentage of healthy and symptomatic
areas.
</p>
</li>
<li> <p><code>shape</code>,<code>statistics</code> If <code>show_features = TRUE</code> is used, returns the shape
(area, perimeter, etc.) for each lesion and a summary statistic of the
results.
</p>
</li></ul>

</li>
<li> <p><code>measure_disease_iter()</code> returns a list with the following objects:
</p>

<ul>
<li> <p><code>results</code> A list with the objects returned by <code>measure_disease()</code>.
</p>
</li>
<li> <p><code>leaf</code> The color palettes for the healthy leaf.
</p>
</li>
<li> <p><code>disease</code> The color palettes for the diseased leaf.
</p>
</li>
<li> <p><code>background</code> The color palettes for the background.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
img &lt;- image_pliman("sev_leaf_nb.jpg")
healthy &lt;- image_pliman("sev_healthy.jpg")
lesions &lt;- image_pliman("sev_sympt.jpg")
image_combine(img, healthy, lesions, ncol = 3)

sev &lt;-
 measure_disease(img = img,
                 img_healthy = healthy,
                 img_symptoms = lesions,
                 lesion_size = "large",
                 plot = TRUE)

# an interactive section
measure_disease_iter(img)


</code></pre>

<hr>
<h2 id='measure_disease_byl'>Performs plant disease measurements by leaf</h2><span id='topic+measure_disease_byl'></span>

<h3>Description</h3>

<p>Computes the percentage of symptomatic leaf area using color palettes or RGB
indexes <code>by</code> each <code>l</code>eaf of an image. This allows, for example, processing
replicates of the same treatment  and obtaining the results for each
replication with a single image. To do that, leaf samples are first splitten
with <code><a href="#topic+object_split">object_split()</a></code> and then, <code><a href="#topic+measure_disease">measure_disease()</a></code> is applied to the list of
leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_disease_byl(
  img,
  index = "B",
  index_lb = "B",
  index_dh = "NGRDI",
  lower_size = NULL,
  watershed = TRUE,
  invert = FALSE,
  fill_hull = FALSE,
  filter = 3,
  threshold = "Otsu",
  extension = NULL,
  tolerance = NULL,
  object_size = "large",
  img_healthy = NULL,
  img_symptoms = NULL,
  plot = TRUE,
  save_image = FALSE,
  dir_original = NULL,
  dir_processed = NULL,
  pattern = NULL,
  parallel = FALSE,
  workers = NULL,
  show_features = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measure_disease_byl_+3A_img">img</code></td>
<td>
<p>The image to be analyzed.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_index">index</code></td>
<td>
<p>A character value specifying the target mode for
conversion to binary to segment the leaves from background. Defaults to &quot;B&quot;
(blue). See <code><a href="#topic+image_index">image_index()</a></code> for more details. Personalized indexes can be
informed as, e.g., <code style="white-space: pre;">&#8288;index = "R*G/B&#8288;</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_index_lb">index_lb</code></td>
<td>
<p>The index used to segment the foreground (e.g., leaf) from
the background. If not declared, the entire image area (pixels) will be
considered in the computation of the severity.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_index_dh">index_dh</code></td>
<td>
<p>The index used to segment diseased from healthy tissues when
<code>img_healthy</code> and <code>img_symptoms</code> are not declared. Defaults to <code>"GLI"</code>. See
<code><a href="#topic+image_index">image_index()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_lower_size">lower_size</code></td>
<td>
<p>To prevent dust from affecting object segmentation, objects
with lesser than <code style="white-space: pre;">&#8288;10%&#8288;</code> of the mean of all objects are removed. . One can
set a known area or use <code>lower_limit = 0</code> to select all objects (not
advised).</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_watershed">watershed</code></td>
<td>
<p>If <code>TRUE</code> (default) performs watershed-based object
detection. This will detect objects even when they are touching one other.
If <code>FALSE</code>, all pixels for each connected set of foreground pixels are set
to a unique object. This is faster but is not able to segment touching
objects.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image if desired. This is useful to process
images with a black background. Defaults to <code>FALSE</code>. If <code>reference = TRUE</code>
is use, <code>invert</code> can be declared as a logical vector of length 2 (eg.,
<code style="white-space: pre;">&#8288;invert = c(FALSE, TRUE&#8288;</code>). In this case, the segmentation of objects and
reference from the foreground using <code>back_fore_index</code> is performed using the
default (not inverted), and the segmentation of objects from the reference
is performed by inverting the selection (selecting pixels higher than the
threshold).</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the binary image? Defaults to <code>FALSE</code>. This is
useful to fill holes in objects that have portions with a color similar to
the background. IMPORTANT: Objects touching each other can be combined into
one single object, which may underestimate the number of objects in an
image.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code><a href="#topic+image_filter">image_filter()</a></code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing noise,
but adversely affect edges.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_threshold">threshold</code></td>
<td>
<p>The theshold method to be used.
</p>

<ul>
<li><p> By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image. If
a numeric value is informed, this value will be used as a threshold.
</p>
</li>
<li><p> If <code>threshold = "adaptive"</code>, adaptive thresholding (Shafait et al. 2008)
is used, and will depend on the <code>k</code> and <code>windowsize</code> arguments.
</p>
</li>
<li><p> If any non-numeric value different than <code>"Otsu"</code> and <code>"adaptive"</code> is used,
an iterative section will allow you to choose the threshold based on a
raster plot showing pixel intensity of the index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_extension">extension</code></td>
<td>
<p>Radius of the neighborhood in pixels for the detection of
neighboring objects. Higher value smooths out small objects.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_tolerance">tolerance</code></td>
<td>
<p>The minimum height of the object in the units of image
intensity between its highest point (seed) and the point where it contacts
another object (checked for every contact pixel). If the height is smaller
than the tolerance, the object will be combined with one of its neighbors,
which is the highest.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_object_size">object_size</code></td>
<td>
<p>The size of the object. Used to automatically set up
<code>tolerance</code> and <code>extension</code> parameters. One of the following. <code>"small"</code>
(e.g, wheat grains), <code>"medium"</code> (e.g, soybean grains), <code>"large"</code>(e.g, peanut
grains), and <code>"elarge"</code> (e.g, soybean pods)'.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_img_healthy">img_healthy</code></td>
<td>
<p>A color palette of healthy tissues.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_img_symptoms">img_symptoms</code></td>
<td>
<p>A color palette of lesioned tissues.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_plot">plot</code></td>
<td>
<p>Show image after processing?</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_save_image">save_image</code></td>
<td>
<p>Save the image after processing? The image is saved in the
current working directory named as <code style="white-space: pre;">&#8288;proc_*&#8288;</code> where <code>*</code> is the image name
given in <code>img</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_dir_original">dir_original</code>, <code id="measure_disease_byl_+3A_dir_processed">dir_processed</code></td>
<td>
<p>The directory containing the original and
processed images. Defaults to <code>NULL</code>. In this case, the function will
search for the image <code>img</code> in the current working directory. After
processing, when <code>save_image = TRUE</code>, the processed image will be also
saved in such a directory. It can be either a full path, e.g.,
<code>"C:/Desktop/imgs"</code>, or a subfolder within the current working directory,
e.g., <code>"/imgs"</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_pattern">pattern</code></td>
<td>
<p>A pattern of file name used to identify images to be
processed. For example, if <code>pattern = "im"</code> all images that the name
matches the pattern (e.g., img1.-, image1.-, im2.-) will be analyzed.
Providing any number as pattern (e.g., <code>pattern = "1"</code>) will select
images that are named as 1.-, 2.-, and so on.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time, especially when <code>pattern</code> is used is informed. The
number of sections is set up to 30% of available cores.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_show_features">show_features</code></td>
<td>
<p>If <code>TRUE</code> returnS the lesion features such as number,
area, perimeter, and radius. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="measure_disease_byl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="#topic+measure_disease">measure_disease()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> A list with the following objects:
</p>

<ul>
<li> <p><code>severity</code> A data frame with the percentage of healthy and symptomatic
areas for each leaf in the image(s).
</p>
</li>
<li> <p><code>shape</code>,<code>statistics</code> If <code>show_features = TRUE</code> is used, returns the shape
(area, perimeter, etc.) for each lesion and a summary statistic of the
results.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("mult_leaves.jpg", plot = TRUE)
sev &lt;-
 measure_disease_byl(img = img,
                     index_lb = "B",
                     index_dh = "NGRDI",
                     workers = 2)
sev$severity


</code></pre>

<hr>
<h2 id='measure_disease_shp'>Measure disease using shapefiles</h2><span id='topic+measure_disease_shp'></span>

<h3>Description</h3>

<p>This function calls <code><a href="#topic+measure_disease">measure_disease()</a></code> in each image polygon of a shapefile
object generated with <code><a href="#topic+image_shp">image_shp()</a></code> and bind the results into read-ready data
frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_disease_shp(
  img,
  nrow = 1,
  ncol = 1,
  buffer_x = 0,
  buffer_y = 0,
  prepare = FALSE,
  viewer = "mapview",
  index_lb = "HUE2",
  index_dh = "NGRDI",
  pattern = NULL,
  threshold = NULL,
  invert = FALSE,
  dir_original = NULL,
  show_features = FALSE,
  interactive = FALSE,
  plot = TRUE,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measure_disease_shp_+3A_img">img</code></td>
<td>
<p>The image to be analyzed. Either an image of class <code>Image</code> or a
character string containing the image name. In the last, the image will be
searched in the root directory. Declare dir_original to inform a subfolder
that contains the images to be processed.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_nrow">nrow</code>, <code id="measure_disease_shp_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows and columns to generate the shapefile.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_buffer_x">buffer_x</code>, <code id="measure_disease_shp_+3A_buffer_y">buffer_y</code></td>
<td>
<p>Buffering factor for the width and height,
respectively, of each individual shape's side. A value between 0 and 0.5 where 0
means no buffering and 0.5 means complete buffering (default: 0). A value of
0.25 will buffer the shape by 25% on each side.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_prepare">prepare</code></td>
<td>
<p>Logical value indicating whether to prepare the image for
analysis using <code><a href="#topic+image_prepare">image_prepare()</a></code> function. This allows to align and crop
the image before processing. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_index_lb">index_lb</code></td>
<td>
<p>The index used to segment the foreground (e.g., leaf) from
the background. If not declared, the entire image area (pixels) will be
considered in the computation of the severity.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_index_dh">index_dh</code></td>
<td>
<p>The index used to segment diseased from healthy tissues when
<code>img_healthy</code> and <code>img_symptoms</code> are not declared. Defaults to <code>"GLI"</code>. See
<code><a href="#topic+image_index">image_index()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_pattern">pattern</code></td>
<td>
<p>A pattern of file name used to identify images to be
processed. For example, if <code>pattern = "im"</code> all images that the name
matches the pattern (e.g., img1.-, image1.-, im2.-) will be analyzed.
Providing any number as pattern (e.g., <code>pattern = "1"</code>) will select
images that are named as 1.-, 2.-, and so on.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_threshold">threshold</code></td>
<td>
<p>By default (<code>threshold = NULL</code>), a threshold value based on
Otsu's method is used to reduce the grayscale image to a binary image. If a
numeric value is informed, this value will be used as a threshold. Inform
any non-numeric value different than &quot;Otsu&quot; to iteratively choose the
threshold based on a raster plot showing pixel intensity of the index. Must
be a vector of length 2 to indicate the threshold for <code>index_lb</code> and
<code>index_dh</code>, respectively.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image if desired. This is useful to process
images with black background. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_dir_original">dir_original</code></td>
<td>
<p>The directory containing the original and processed images.
Defaults to <code>NULL</code>. In this case, the function will search for the image <code>img</code> in the
current working directory.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_show_features">show_features</code></td>
<td>
<p>If <code>TRUE</code> returnS the lesion features such as number,
area, perimeter, and radius. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_interactive">interactive</code></td>
<td>
<p>If <code>FALSE</code> (default) the grid is created automatically
based on the image dimension and number of rows/columns. If <code>interactive = TRUE</code>, users must draw points at the diagonal of the desired bounding box
that will contain the grid.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_plot">plot</code></td>
<td>
<p>Show image after processing? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time, especially when <code>pattern</code> is used is informed. The
number of sections is set up to 30% of available cores.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="measure_disease_shp_+3A_...">...</code></td>
<td>
<p>Aditional arguments passed on to <a href="#topic+measure_disease">measure_disease</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>plm_disease_byl</code>. See more details in the <code>Value</code>
section of <code><a href="#topic+measure_disease">measure_disease()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# severity for the three leaflets (from left to right)
img &lt;- image_pliman("mult_leaves.jpg", plot = TRUE)
sev &lt;-
 measure_disease_shp(img = img,
                     nrow = 1,
                     ncol = 3,
                     index_lb = "B",
                     index_dh = "NGRDI")
sev$severity
}
</code></pre>

<hr>
<h2 id='mosaic_crop'>Crop a mosaic</h2><span id='topic+mosaic_crop'></span>

<h3>Description</h3>

<p>Crop a <code>SpatRaster</code> object based on user-defined selection using an
interactive map or plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_crop(
  mosaic,
  r = 3,
  g = 2,
  b = 1,
  re = 4,
  nir = 5,
  show = c("rgb", "index"),
  index = "R",
  max_pixels = 5e+05,
  downsample = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_crop_+3A_mosaic">mosaic</code></td>
<td>
<p>A mosaic of class <code>SpatRaster</code>, generally imported with
<code><a href="#topic+mosaic_input">mosaic_input()</a></code>.</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_r">r</code></td>
<td>
<p>The layer for the Red band (default: 3).</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_g">g</code></td>
<td>
<p>The layer for the Green band (default: 2).</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_b">b</code></td>
<td>
<p>The layer for the Blue band (default: 1).</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_re">re</code></td>
<td>
<p>The layer for the Red-edge band (default: 4).</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_nir">nir</code></td>
<td>
<p>The layer for the Near-infrared band(default: 5).</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_show">show</code></td>
<td>
<p>The display option for the map view. Options are &quot;rgb&quot; for RGB
view and &quot;index&quot; for index view.</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_index">index</code></td>
<td>
<p>The index to use for the index view. Defaults to &quot;B&quot;.</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_max_pixels">max_pixels</code></td>
<td>
<p>Maximum number of pixels to render in the map or plot
(default: 500000).</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_downsample">downsample</code></td>
<td>
<p>Downsampling factor to reduce the number of pixels
(default: NULL). In this case, if the number of pixels in the image (width
x height) is greater than <code>max_pixels</code> a downsampling factor will be
automatically chosen so that the number of plotted pixels approximates the
<code>max_pixels</code>.</p>
</td></tr>
<tr><td><code id="mosaic_crop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+mosaic_view">mosaic_view()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>mosaic_view</code> function to display an
interactive map or plot of the mosaic raster, allowing users to draw a
rectangle to select the cropping area. The selected area is then cropped
from the input mosaic and returned as a new <code>SpatRaster</code> object.
</p>


<h3>Value</h3>

<p>A cropped version of <code>mosaic</code> based on the user-defined selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
# Load a raster showing the elevation of Luxembourg
mosaic &lt;- mosaic_input(system.file("ex/elev.tif", package="terra"))

# Generate an interactive map using 'mapview' (works only in an interactive section)
cropped &lt;- mosaic_crop(mosaic)
mosaic_view(cropped)
}

</code></pre>

<hr>
<h2 id='mosaic_index'>Mosaic Index</h2><span id='topic+mosaic_index'></span>

<h3>Description</h3>

<p>Compute or extract an index layer from a multi-band mosaic raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_index(mosaic, index = "R", r = 3, g = 2, b = 1, re = 4, nir = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_index_+3A_mosaic">mosaic</code></td>
<td>
<p>A mosaic of class <code>SpatRaster</code>, generally imported with
<code><a href="#topic+mosaic_input">mosaic_input()</a></code>.</p>
</td></tr>
<tr><td><code id="mosaic_index_+3A_index">index</code></td>
<td>
<p>The index to use for the index view. Defaults to &quot;B&quot;.</p>
</td></tr>
<tr><td><code id="mosaic_index_+3A_r">r</code></td>
<td>
<p>The layer for the Red band (default: 3).</p>
</td></tr>
<tr><td><code id="mosaic_index_+3A_g">g</code></td>
<td>
<p>The layer for the Green band (default: 2).</p>
</td></tr>
<tr><td><code id="mosaic_index_+3A_b">b</code></td>
<td>
<p>The layer for the Blue band (default: 1).</p>
</td></tr>
<tr><td><code id="mosaic_index_+3A_re">re</code></td>
<td>
<p>The layer for the Red-edge band (default: 4).</p>
</td></tr>
<tr><td><code id="mosaic_index_+3A_nir">nir</code></td>
<td>
<p>The layer for the Near-infrared band(default: 5).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes or extracts an index layer from the input
mosaic raster based on the specified index name. If the index is not found
in the package's predefined index list (see <code><a href="#topic+image_index">image_index()</a></code> for more
details), it attempts to compute the index using the specified band
indices. The resulting index layer is returned as an <code>SpatRaster</code> object.
</p>


<h3>Value</h3>

<p>An index layer extracted/computed from the mosaic raster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
library(terra)
mosaic &lt;- mosaic_input(system.file("ex/elev.tif", package="terra"))
confusion &lt;-
     matrix(rnorm(90*95, 100, 30),
            nrow = nrow(mosaic),
            ncol = ncol(mosaic))
confusion &lt;- mosaic_input(confusion)
terra::ext(confusion) &lt;- terra::ext(mosaic)
terra::crs(confusion) &lt;- terra::crs(mosaic)
names(confusion) &lt;- "confusion"
two_layers &lt;- c(mosaic, confusion)
final &lt;- mosaic_index(two_layers, "B+R", b = 1, r = 2)
mosaic_view(mosaic_input(final), viewer = "base")

</code></pre>

<hr>
<h2 id='mosaic_input'>Create and Export mosaics</h2><span id='topic+mosaic_input'></span><span id='topic+mosaic_export'></span>

<h3>Description</h3>

<p>Create and Export mosaics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_input(mosaic, ...)

mosaic_export(mosaic, filename, overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_input_+3A_mosaic">mosaic</code></td>
<td>

<ul>
<li><p> For <code>mosaic_input()</code>, a file path to the raster to imported, a matrix,
array or a list of <code>SpatRaster</code> objects.
</p>
</li>
<li><p> For <code>mosaic_export()</code>, an <code>SpatRaster</code> object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mosaic_input_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="terra.html#topic+rast">terra::rast()</a></code> (<code>mosaic_input()</code>)
or  <code><a href="terra.html#topic+writeRaster">terra::writeRaster()</a></code> (<code>mosaic_output()</code>)</p>
</td></tr>
<tr><td><code id="mosaic_input_+3A_filename">filename</code></td>
<td>
<p>character. The Output filename.</p>
</td></tr>
<tr><td><code id="mosaic_input_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, filename is overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>mosaic_input()</code> is a simply wrapper around <code><a href="terra.html#topic+rast">terra::rast()</a></code>. It creates a
<code>SpatRaster</code> object from scratch, from a filename, or from another object.
</p>
</li>
<li> <p><code>mosaic_export()</code> is a simply wrapper around <code><a href="terra.html#topic+writeRaster">terra::writeRaster()</a></code>. It write
a <code>SpatRaster</code> object to a file.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>mosaic_input()</code> returns an <code>SpatRaster</code> object.
</p>
</li>
<li> <p><code>mosaic_export()</code> do not return an object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)

# create an SpatRaster object based on a matrix
x &lt;- matrix(1:20, nrow = 4, ncol = 5)
rast &lt;- mosaic_input(x)
mosaic_view(rast, viewer = "base", axes = TRUE)

# create a temporary filename for the example
f &lt;- file.path(tempdir(), "test.tif")
mosaic_export(rast, f, overwrite=TRUE)
list.files(tempdir())

</code></pre>

<hr>
<h2 id='mosaic_prepare'>Prepare a mosaic</h2><span id='topic+mosaic_prepare'></span>

<h3>Description</h3>

<p>Prepare an <code>SpatRaster</code> object to be analyzed in pliman. This includes
cropping the original mosaic, aligning it, and cropping the aligned object.
The resulting object is an object of class <code>Image</code> that can be further
analyzed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_prepare(
  mosaic,
  r = 3,
  g = 2,
  b = 1,
  re = 4,
  nir = 5,
  crop_mosaic = FALSE,
  align = TRUE,
  crop_aligned = TRUE,
  rescale = TRUE,
  coef = 0,
  viewer = "mapview",
  max_pixels = 5e+05,
  show = "rgb",
  index = "R"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_prepare_+3A_mosaic">mosaic</code></td>
<td>
<p>A mosaic of class <code>SpatRaster</code>, generally imported with
<code><a href="#topic+mosaic_input">mosaic_input()</a></code>.</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_r">r</code></td>
<td>
<p>The layer for the Red band (default: 3).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_g">g</code></td>
<td>
<p>The layer for the Green band (default: 2).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_b">b</code></td>
<td>
<p>The layer for the Blue band (default: 1).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_re">re</code></td>
<td>
<p>The layer for the Red-edge band (default: 4).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_nir">nir</code></td>
<td>
<p>The layer for the Near-infrared band(default: 5).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_crop_mosaic">crop_mosaic</code></td>
<td>
<p>Logical, whether to crop the mosaic interactively before
aligning it (default: FALSE).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_align">align</code></td>
<td>
<p>Logical, whether to align the mosaic interactively (default:
TRUE).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_crop_aligned">crop_aligned</code></td>
<td>
<p>Logical, whether to crop the aligned mosaic interactively
(default: TRUE).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_rescale">rescale</code></td>
<td>
<p>Rescale the final values? If <code>TRUE</code> the final values are
rescaled so that the maximum value is 1.</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_coef">coef</code></td>
<td>
<p>An addition coefficient applied to the resulting object. This is
useful to adjust the brightness of the final image. Defaults to 0.</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_max_pixels">max_pixels</code></td>
<td>
<p>Maximum number of pixels to render in the map or plot
(default: 500000).</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_show">show</code></td>
<td>
<p>The display option for the map view. Options are &quot;rgb&quot; for RGB
view and &quot;index&quot; for index view.</p>
</td></tr>
<tr><td><code id="mosaic_prepare_+3A_index">index</code></td>
<td>
<p>The index to use for the index view. Defaults to &quot;B&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A prepared object of class <code>Image</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
mosaic &lt;- mosaic_input(system.file("ex/elev.tif", package="terra"))
mosaic_prepare(mosaic)
}

</code></pre>

<hr>
<h2 id='mosaic_to_pliman'>Mosaic to pliman</h2><span id='topic+mosaic_to_pliman'></span>

<h3>Description</h3>

<p>Convert an <code>SpatRaster</code> object to a <code>Image</code> object with optional scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_to_pliman(
  mosaic,
  r = 3,
  g = 2,
  b = 1,
  re = 4,
  nir = 5,
  rescale = TRUE,
  coef = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_to_pliman_+3A_mosaic">mosaic</code></td>
<td>
<p>A mosaic of class <code>SpatRaster</code>, generally imported with
<code><a href="#topic+mosaic_input">mosaic_input()</a></code>.</p>
</td></tr>
<tr><td><code id="mosaic_to_pliman_+3A_r">r</code></td>
<td>
<p>The layer for the Red band (default: 3).</p>
</td></tr>
<tr><td><code id="mosaic_to_pliman_+3A_g">g</code></td>
<td>
<p>The layer for the Green band (default: 2).</p>
</td></tr>
<tr><td><code id="mosaic_to_pliman_+3A_b">b</code></td>
<td>
<p>The layer for the Blue band (default: 1).</p>
</td></tr>
<tr><td><code id="mosaic_to_pliman_+3A_re">re</code></td>
<td>
<p>The layer for the Red-edge band (default: 4).</p>
</td></tr>
<tr><td><code id="mosaic_to_pliman_+3A_nir">nir</code></td>
<td>
<p>The layer for the Near-infrared band(default: 5).</p>
</td></tr>
<tr><td><code id="mosaic_to_pliman_+3A_rescale">rescale</code></td>
<td>
<p>Rescale the final values? If <code>TRUE</code> the final values are
rescaled so that the maximum value is 1.</p>
</td></tr>
<tr><td><code id="mosaic_to_pliman_+3A_coef">coef</code></td>
<td>
<p>An addition coefficient applied to the resulting object. This is
useful to adjust the brightness of the final image. Defaults to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts <code>SpatRaster</code> into an <code>Image</code> object, which
can be used for image analysis in <code>pliman</code>. Note that if a large
<code>SpatRaster</code> is loaded, the resulting object may increase considerably the
memory usage.
</p>


<h3>Value</h3>

<p>An <code>Image</code> object with the same number of layers as <code>mosaic</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
# Convert a mosaic raster to an Image object
mosaic &lt;- mosaic_input(system.file("ex/elev.tif", package="terra"))
pliman_image &lt;- mosaic_to_pliman(mosaic)
plot(pliman_image)

</code></pre>

<hr>
<h2 id='mosaic_to_rgb'>Mosaic to RGB</h2><span id='topic+mosaic_to_rgb'></span>

<h3>Description</h3>

<p>Convert an <code>SpatRaster</code> to a three-band RGB image of class <code>Image</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_to_rgb(mosaic, r = 3, g = 2, b = 1, coef = 0, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_to_rgb_+3A_mosaic">mosaic</code></td>
<td>
<p>A mosaic of class <code>SpatRaster</code>, generally imported with
<code><a href="#topic+mosaic_input">mosaic_input()</a></code>.</p>
</td></tr>
<tr><td><code id="mosaic_to_rgb_+3A_r">r</code></td>
<td>
<p>The layer for the Red band (default: 3).</p>
</td></tr>
<tr><td><code id="mosaic_to_rgb_+3A_g">g</code></td>
<td>
<p>The layer for the Green band (default: 2).</p>
</td></tr>
<tr><td><code id="mosaic_to_rgb_+3A_b">b</code></td>
<td>
<p>The layer for the Blue band (default: 1).</p>
</td></tr>
<tr><td><code id="mosaic_to_rgb_+3A_coef">coef</code></td>
<td>
<p>An addition coefficient applied to the resulting object. This is
useful to adjust the brightness of the final image. Defaults to 0.</p>
</td></tr>
<tr><td><code id="mosaic_to_rgb_+3A_plot">plot</code></td>
<td>
<p>Logical, whether to display the resulting RGB image (default:
TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts <code>SpatRaster</code> that contains the RGB bands into
a three-band RGB image using pliman (EBImage). It allows you to specify the
band indices for the red, green, and blue channels, as well as apply a
scaling coefficient to the final image. By default, the resulting RGB image
is displayed, but this behavior can be controlled using the <code>plot</code>
parameter.
</p>


<h3>Value</h3>

<p>A three-band RGB image represented as a pliman (EBImage) object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
# Convert a mosaic raster to an RGB image and display it
mosaic &lt;- mosaic_input(system.file("ex/elev.tif", package="terra"))

# Convert a mosaic raster to an RGB image without displaying it
rgb_image &lt;- mosaic_to_rgb(c(mosaic * 2, mosaic - 0.3, mosaic * 0.8))
plot(rgb_image)


</code></pre>

<hr>
<h2 id='mosaic_view'>Mosaic View</h2><span id='topic+mosaic_view'></span>

<h3>Description</h3>

<p>Mosaic View
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic_view(
  mosaic,
  r = 3,
  g = 2,
  b = 1,
  re = 4,
  nir = 5,
  title = "",
  viewer = c("mapview", "base"),
  show = c("rgb", "index"),
  index = "B",
  max_pixels = 5e+05,
  downsample = NULL,
  alpha = 1,
  quantiles = c(0, 1),
  domain = NULL,
  color_regions = custom_palette(),
  axes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_view_+3A_mosaic">mosaic</code></td>
<td>
<p>A mosaic of class <code>SpatRaster</code>, generally imported with
<code><a href="#topic+mosaic_input">mosaic_input()</a></code>.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_r">r</code></td>
<td>
<p>The layer for the Red band (default: 3).</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_g">g</code></td>
<td>
<p>The layer for the Green band (default: 2).</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_b">b</code></td>
<td>
<p>The layer for the Blue band (default: 1).</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_re">re</code></td>
<td>
<p>The layer for the Red-edge band (default: 4).</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_nir">nir</code></td>
<td>
<p>The layer for the Near-infrared band(default: 5).</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_title">title</code></td>
<td>
<p>A title for the generated map or plot (default: &quot;&quot;).</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_show">show</code></td>
<td>
<p>The display option for the map view. Options are &quot;rgb&quot; for RGB
view and &quot;index&quot; for index view.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_index">index</code></td>
<td>
<p>The index to use for the index view. Defaults to &quot;B&quot;.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_max_pixels">max_pixels</code></td>
<td>
<p>Maximum number of pixels to render in the map or plot
(default: 500000).</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_downsample">downsample</code></td>
<td>
<p>Downsampling factor to reduce the number of pixels
(default: NULL). In this case, if the number of pixels in the image (width
x height) is greater than <code>max_pixels</code> a downsampling factor will be
automatically chosen so that the number of plotted pixels approximates the
<code>max_pixels</code>.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_alpha">alpha</code></td>
<td>
<p>opacity of the fill color of the raster layer(s).</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_quantiles">quantiles</code></td>
<td>
<p>the upper and lower quantiles used for color stretching. If
set to <code>NULL</code>, stretching is performed basing on 'domain' argument.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_domain">domain</code></td>
<td>
<p>the upper and lower values used for color stretching. This is
used only if <code>'quantiles'</code> is <code>NULL</code>. If both '<code style="white-space: pre;">&#8288;domain'&#8288;</code> and <code>'quantiles'</code> are
set to <code>NULL</code>, stretching is applied based on min-max values.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_color_regions">color_regions</code></td>
<td>
<p>The color palette for displaying index values. Default
is <code><a href="#topic+custom_palette">custom_palette()</a></code>.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_axes">axes</code></td>
<td>
<p>logical. Draw axes? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mosaic_view_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="terra.html#topic+plot">terra::plot()</a></code> when <code>viewer = "base"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can generate either an interactive map using the
'mapview' package or a static plot using the 'base' package, depending on
the <code>viewer</code> and <code>show</code> parameters. If show = &quot;index&quot; is used, the function
first computes an image index that can be either an RGB-based index or a
multispectral index, if a multispectral mosaic is provided.
</p>


<h3>Value</h3>

<p>An sf object, the same object returned by <code><a href="mapedit.html#topic+editMap">mapedit::editMap()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
# Load a raster showing the elevation of Luxembourg
mosaic &lt;- mosaic_input(system.file("ex/elev.tif", package="terra"))

# Generate an interactive map using 'mapview'
mosaic_view(mosaic)

# Generate a static plot using 'base'
mosaic_view(mosaic, viewer = "base")
}


</code></pre>

<hr>
<h2 id='object_edge'>Object edges</h2><span id='topic+object_edge'></span>

<h3>Description</h3>

<p>Applies the Sobel-Feldman Operator to detect edges. The operator is based on
convolving the image with a small, separable, and integer-valued filter in
the horizontal and vertical directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_edge(img, sigma = 1, threshold = "Otsu", thinning = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_edge_+3A_img">img</code></td>
<td>
<p>An image or a list of images of class <code>Image</code>.</p>
</td></tr>
<tr><td><code id="object_edge_+3A_sigma">sigma</code></td>
<td>
<p>Gaussian kernel standard deviation used in the gaussian blur.</p>
</td></tr>
<tr><td><code id="object_edge_+3A_threshold">threshold</code></td>
<td>
<p>The theshold method to be used.  If <code>threshold = "Otsu"</code>
(default), a threshold value based on Otsu's method is used to reduce the
grayscale image to a binary image. If any non-numeric value different than
<code>"Otsu"</code> is used, an iterative section will allow you to choose the
threshold based on a raster plot showing pixel intensity of the index.
Alternatively, provide a numeric value to be used as the threshold value.</p>
</td></tr>
<tr><td><code id="object_edge_+3A_thinning">thinning</code></td>
<td>
<p>Logical value indicating whether a thinning procedure should
be applied to the detected edges. See <code><a href="#topic+image_skeleton">image_skeleton()</a></code></p>
</td></tr>
<tr><td><code id="object_edge_+3A_plot">plot</code></td>
<td>
<p>Logical value indicating whether a plot should be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary version of <code>image</code>.
</p>


<h3>References</h3>

<p>Sobel, I., and G. Feldman. 1973. A 33 isotropic gradient
operator for image processing. Pattern Classification and Scene Analysis:
271272.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("sev_leaf_nb.jpg", plot = TRUE)
object_edge(img)

</code></pre>

<hr>
<h2 id='object_export'>Export multiple objects from an image to multiple images</h2><span id='topic+object_export'></span>

<h3>Description</h3>

<p>Givin an image with multiple objects, <code>object_export()</code> will split the
objects into a list of objects using <code><a href="#topic+object_split">object_split()</a></code> and then export them to
multiple images into the current working directory (or a subfolder). Batch
processing is performed by declaring a file name pattern that matches the
images within the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_export(
  img,
  pattern = NULL,
  dir_original = NULL,
  dir_processed = NULL,
  format = ".jpg",
  squarize = FALSE,
  augment = FALSE,
  times = 12,
  index = "NB",
  lower_size = NULL,
  watershed = FALSE,
  invert = FALSE,
  fill_hull = FALSE,
  filter = 2,
  threshold = "Otsu",
  extension = NULL,
  tolerance = NULL,
  object_size = "medium",
  edge = 20,
  remove_bg = FALSE,
  parallel = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_export_+3A_img">img</code></td>
<td>
<p>The image to be analyzed.</p>
</td></tr>
<tr><td><code id="object_export_+3A_pattern">pattern</code></td>
<td>
<p>A pattern of file name used to identify images to be
processed. For example, if <code>pattern = "im"</code> all images in the current
working directory that the name matches the pattern (e.g., img1.-,
image1.-, im2.-) will be imported and processed. Providing any number as
pattern (e.g., <code>pattern = "1"</code>) will select images that are named as 1.-,
2.-, and so on. An error will be returned if the pattern matches any file
that is not supported (e.g., img1.pdf).</p>
</td></tr>
<tr><td><code id="object_export_+3A_dir_original">dir_original</code></td>
<td>
<p>The directory containing the original images. Defaults to
<code>NULL</code>. It can be either a full path, e.g., <code>"C:/Desktop/imgs"</code>, or a
subfolder within the current working directory, e.g., <code>"/imgs"</code>.</p>
</td></tr>
<tr><td><code id="object_export_+3A_dir_processed">dir_processed</code></td>
<td>
<p>Optional character string indicating a subfolder within the
current working directory to save the image(s). If the folder doesn't
exist, it will be created.</p>
</td></tr>
<tr><td><code id="object_export_+3A_format">format</code></td>
<td>
<p>The format of image to be exported.</p>
</td></tr>
<tr><td><code id="object_export_+3A_squarize">squarize</code></td>
<td>
<p>Squarizes the image before the exportation? If <code>TRUE</code>,
<code><a href="#topic+image_square">image_square()</a></code> will be called internally.</p>
</td></tr>
<tr><td><code id="object_export_+3A_augment">augment</code></td>
<td>
<p>A logical indicating if exported objects should be augmented using
<code><a href="#topic+image_augment">image_augment()</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="object_export_+3A_times">times</code></td>
<td>
<p>The number of times to rotate the image.</p>
</td></tr>
<tr><td><code id="object_export_+3A_index">index</code></td>
<td>
<p>A character value specifying the target mode for conversion to
binary image when <code>foreground</code> and <code>background</code> are not declared. Defaults
to <code>"NB"</code> (normalized blue). See <code><a href="#topic+image_index">image_index()</a></code> for more details. User can
also calculate your own index using the bands names, e.g. <code>index = "R+B/G"</code></p>
</td></tr>
<tr><td><code id="object_export_+3A_lower_size">lower_size</code></td>
<td>
<p>Plant images often contain dirt and dust. To prevent dust from
affecting the image analysis, objects with lesser than 10% of the mean of all objects
are removed. Set <code>lower_limit = 0</code> to keep all the objects.</p>
</td></tr>
<tr><td><code id="object_export_+3A_watershed">watershed</code></td>
<td>
<p>If <code>TRUE</code> (default) performs watershed-based object
detection. This will detect objects even when they are touching one other.
If <code>FALSE</code>, all pixels for each connected set of foreground pixels are set
to a unique object. This is faster but is not able to segment touching
objects.</p>
</td></tr>
<tr><td><code id="object_export_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image if desired. This is useful to process
images with a black background. Defaults to <code>FALSE</code>. If <code>reference = TRUE</code>
is use, <code>invert</code> can be declared as a logical vector of length 2 (eg.,
<code style="white-space: pre;">&#8288;invert = c(FALSE, TRUE&#8288;</code>). In this case, the segmentation of objects and
reference from the foreground using <code>back_fore_index</code> is performed using the
default (not inverted), and the segmentation of objects from the reference
is performed by inverting the selection (selecting pixels higher than the
threshold).</p>
</td></tr>
<tr><td><code id="object_export_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the binary image? Defaults to <code>FALSE</code>. This is
useful to fill holes in objects that have portions with a color similar to
the background. IMPORTANT: Objects touching each other can be combined into
one single object, which may underestimate the number of objects in an
image.</p>
</td></tr>
<tr><td><code id="object_export_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code><a href="#topic+image_filter">image_filter()</a></code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing noise,
but adversely affect edges.</p>
</td></tr>
<tr><td><code id="object_export_+3A_threshold">threshold</code></td>
<td>
<p>The theshold method to be used.
</p>

<ul>
<li><p> By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image. If
a numeric value is informed, this value will be used as a threshold.
</p>
</li>
<li><p> If <code>threshold = "adaptive"</code>, adaptive thresholding (Shafait et al. 2008)
is used, and will depend on the <code>k</code> and <code>windowsize</code> arguments.
</p>
</li>
<li><p> If any non-numeric value different than <code>"Otsu"</code> and <code>"adaptive"</code> is used,
an iterative section will allow you to choose the threshold based on a
raster plot showing pixel intensity of the index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="object_export_+3A_extension">extension</code></td>
<td>
<p>Radius of the neighborhood in pixels for the detection of
neighboring objects. Higher value smooths out small objects.</p>
</td></tr>
<tr><td><code id="object_export_+3A_tolerance">tolerance</code></td>
<td>
<p>The minimum height of the object in the units of image
intensity between its highest point (seed) and the point where it contacts
another object (checked for every contact pixel). If the height is smaller
than the tolerance, the object will be combined with one of its neighbors,
which is the highest.</p>
</td></tr>
<tr><td><code id="object_export_+3A_object_size">object_size</code></td>
<td>
<p>The size of the object. Used to automatically set up
<code>tolerance</code> and <code>extension</code> parameters. One of the following. <code>"small"</code>
(e.g, wheat grains), <code>"medium"</code> (e.g, soybean grains), <code>"large"</code>(e.g, peanut
grains), and <code>"elarge"</code> (e.g, soybean pods)'.</p>
</td></tr>
<tr><td><code id="object_export_+3A_edge">edge</code></td>
<td>
<p>The number of pixels to be added in the edge of the segmented
object. Defaults to 5.</p>
</td></tr>
<tr><td><code id="object_export_+3A_remove_bg">remove_bg</code></td>
<td>
<p>If <code>TRUE</code>, the pixels that are not part of objects are
converted to white.</p>
</td></tr>
<tr><td><code id="object_export_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> processes the images asynchronously (in parallel) in
separate R sessions running in the background on the same machine. It may
speed up the processing time, especially when <code>pattern</code> is used is informed.
When <code>object_index</code> is informed, multiple sections will be used to extract
the RGB values for each object in the image. This may significantly speed up
processing time when an image has lots of objects (say &gt;1000).</p>
</td></tr>
<tr><td><code id="object_export_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>NULL</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
img &lt;- image_pliman("potato_leaves.jpg")
object_export(img,
              remove_bg = TRUE)
}
</code></pre>

<hr>
<h2 id='object_export_shp'>Export multiple objects from an image to multiple images</h2><span id='topic+object_export_shp'></span>

<h3>Description</h3>

<p>Givin an image with multiple objects, <code>object_export_shp()</code> will split the
objects into a list of objects using <code><a href="#topic+object_split_shp">object_split_shp()</a></code> and then export
them to multiple images into the current working directory (or a subfolder).
Batch processing is performed by declaring a file name pattern that matches
the images within the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_export_shp(
  img,
  pattern = NULL,
  dir_original = NULL,
  dir_processed = NULL,
  format = ".jpg",
  subfolder = NULL,
  squarize = FALSE,
  nrow = 1,
  ncol = 1,
  buffer_x = 0,
  buffer_y = 0,
  interactive = FALSE,
  parallel = FALSE,
  verbose = TRUE,
  viewer = get_pliman_viewer()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_export_shp_+3A_img">img</code></td>
<td>
<p>An object of class <code>Image</code></p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_pattern">pattern</code></td>
<td>
<p>A pattern of file name used to identify images to be
processed. For example, if <code>pattern = "im"</code> all images in the current
working directory that the name matches the pattern (e.g., img1.-,
image1.-, im2.-) will be imported and processed. Providing any number as
pattern (e.g., <code>pattern = "1"</code>) will select images that are named as 1.-,
2.-, and so on. An error will be returned if the pattern matches any file
that is not supported (e.g., img1.pdf).</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_dir_original">dir_original</code></td>
<td>
<p>The directory containing the original images. Defaults to
<code>NULL</code>. It can be either a full path, e.g., <code>"C:/Desktop/imgs"</code>, or a
subfolder within the current working directory, e.g., <code>"/imgs"</code>.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_dir_processed">dir_processed</code></td>
<td>
<p>Optional character string indicating a subfolder within the
current working directory to save the image(s). If the folder doesn't
exist, it will be created.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_format">format</code></td>
<td>
<p>The format of image to be exported.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_subfolder">subfolder</code></td>
<td>
<p>Optional character string indicating a subfolder within the
current working directory to save the image(s). If the folder doesn't
exist, it will be created.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_squarize">squarize</code></td>
<td>
<p>Squarizes the image before the exportation? If <code>TRUE</code>,
<code><a href="#topic+image_square">image_square()</a></code> will be called internally.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_nrow">nrow</code></td>
<td>
<p>The number of desired rows in the grid. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_ncol">ncol</code></td>
<td>
<p>The number of desired columns in the grid. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_buffer_x">buffer_x</code>, <code id="object_export_shp_+3A_buffer_y">buffer_y</code></td>
<td>
<p>Buffering factor for the width and height,
respectively, of each individual shape's side. A value between 0 and 0.5 where 0
means no buffering and 0.5 means complete buffering (default: 0). A value of
0.25 will buffer the shape by 25% on each side.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_interactive">interactive</code></td>
<td>
<p>If <code>FALSE</code> (default) the grid is created automatically
based on the image dimension and number of rows/columns. If <code>interactive = TRUE</code>, users must draw points at the diagonal of the desired bounding box
that will contain the grid.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> processes the images asynchronously (in parallel) in
separate R sessions running in the background on the same machine. It may
speed up the processing time, especially when <code>pattern</code> is used is informed.
When <code>object_index</code> is informed, multiple sections will be used to extract
the RGB values for each object in the image. This may significantly speed up
processing time when an image has lots of objects (say &gt;1000).</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="object_export_shp_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are <code>"base"</code> and
<code>"mapview"</code>. If set to &quot;base&quot;, the base R graphics system is used for
interactive plotting. If set to &quot;mapview&quot;, the mapview package is used. To
set this argument globally for all functions in the package, you can use
the <code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>NULL</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
flax &lt;- image_pliman("flax_leaves.jpg", plot = TRUE)
object_export_shp(flax)

}
</code></pre>

<hr>
<h2 id='object_label'>Labels objects</h2><span id='topic+object_label'></span>

<h3>Description</h3>

<p>All pixels for each connected set of foreground (non-zero) pixels in x are
set to an unique increasing integer, starting from 1. Hence, max(x) gives the
number of connected objects in x. This is a wrapper to <a href="EBImage.html#topic+bwlabel">EBImage::bwlabel</a> or
<a href="EBImage.html#topic+watershed">EBImage::watershed</a> (if <code>watershed = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_label(
  img,
  index = "B",
  invert = FALSE,
  fill_hull = FALSE,
  threshold = "Otsu",
  k = 0.1,
  windowsize = NULL,
  filter = FALSE,
  watershed = FALSE,
  tolerance = NULL,
  extension = NULL,
  object_size = "medium",
  plot = TRUE,
  ncol = NULL,
  nrow = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_label_+3A_img">img</code></td>
<td>
<p>An image object.</p>
</td></tr>
<tr><td><code id="object_label_+3A_index">index</code></td>
<td>
<p>A character value (or a vector of characters) specifying the
target mode for conversion to binary image. See the available indexes with
<code><a href="#topic+pliman_indexes">pliman_indexes()</a></code> and <code><a href="#topic+image_index">image_index()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="object_label_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image, if desired.</p>
</td></tr>
<tr><td><code id="object_label_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the objects? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="object_label_+3A_threshold">threshold</code></td>
<td>
<p>The theshold method to be used.
</p>

<ul>
<li><p> By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image. If
a numeric value is informed, this value will be used as a threshold.
</p>
</li>
<li><p> If <code>threshold = "adaptive"</code>, adaptive thresholding (Shafait et al. 2008)
is used, and will depend on the <code>k</code> and <code>windowsize</code> arguments.
</p>
</li>
<li><p> If any non-numeric value different than <code>"Otsu"</code> and <code>"adaptive"</code> is used,
an iterative section will allow you to choose the threshold based on a
raster plot showing pixel intensity of the index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="object_label_+3A_k">k</code></td>
<td>
<p>a numeric in the range 0-1. when <code>k</code> is high, local threshold
values tend to be lower. when <code>k</code> is low, local threshold value tend to be
higher.</p>
</td></tr>
<tr><td><code id="object_label_+3A_windowsize">windowsize</code></td>
<td>
<p>windowsize controls the number of local neighborhood in
adaptive thresholding. By default it is set to <code>1/3 * minxy</code>, where
<code>minxy</code> is the minimum dimension of the image (in pixels).</p>
</td></tr>
<tr><td><code id="object_label_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? (Defaults to
<code>FALSE</code>). Provide a positive integer &gt; 1 to indicate the size of the median
filtering. Higher values are more efficient to remove noise in the
background but can dramatically impact the perimeter of objects, mainly for
irregular perimeters such as leaves with serrated edges.</p>
</td></tr>
<tr><td><code id="object_label_+3A_watershed">watershed</code></td>
<td>
<p>If <code>TRUE</code> (default) performs watershed-based object
detection. This will detect objects even when they are touching one other.
If <code>FALSE</code>, all pixels for each connected set of foreground pixels are set
to a unique object. This is faster but is not able to segment touching
objects.</p>
</td></tr>
<tr><td><code id="object_label_+3A_tolerance">tolerance</code></td>
<td>
<p>The minimum height of the object in the units of image
intensity between its highest point (seed) and the point where it contacts
another object (checked for every contact pixel). If the height is smaller
than the tolerance, the object will be combined with one of its neighbors,
which is the highest.</p>
</td></tr>
<tr><td><code id="object_label_+3A_extension">extension</code></td>
<td>
<p>Radius of the neighborhood in pixels for the detection of
neighboring objects. Higher value smooths out small objects.</p>
</td></tr>
<tr><td><code id="object_label_+3A_object_size">object_size</code></td>
<td>
<p>The size of the object. Used to automatically set up
<code>tolerance</code> and <code>extension</code> parameters. One of the following. <code>"small"</code>
(e.g, wheat grains), <code>"medium"</code> (e.g, soybean grains), <code>"large"</code>(e.g, peanut
grains), and <code>"elarge"</code> (e.g, soybean pods)'.</p>
</td></tr>
<tr><td><code id="object_label_+3A_plot">plot</code></td>
<td>
<p>Show image after processing?</p>
</td></tr>
<tr><td><code id="object_label_+3A_nrow">nrow</code>, <code id="object_label_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
<tr><td><code id="object_label_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same length of <code>img</code> containing the labeled objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- image_pliman("soybean_touch.jpg")
# segment the objects using the "B" (blue) band.
object_label(img, index = "B")
object_label(img, index = "B", watershed = TRUE)
</code></pre>

<hr>
<h2 id='object_map'>Map Object Distances</h2><span id='topic+object_map'></span>

<h3>Description</h3>

<p>Computes distances between objects in an <code>anal_obj</code> object and returns a list
of distances, coefficient of variation (CV), and means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_map(object, by_column = "img", direction = c("horizontal", "vertical"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_map_+3A_object">object</code></td>
<td>
<p>An <code>anal_obj</code> object computed with <code>analyze_objects_shp()</code>.</p>
</td></tr>
<tr><td><code id="object_map_+3A_by_column">by_column</code></td>
<td>
<p>The column name in the object's results data frame to group
objects by. Default is &quot;img&quot;.</p>
</td></tr>
<tr><td><code id="object_map_+3A_direction">direction</code></td>
<td>
<p>The direction of mapping. Should be one of &quot;horizontal&quot; or
&quot;vertical&quot;. Default is &quot;horizontal&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>A list of distances between objects grouped by unique values
in the specified column/row.</p>
</td></tr>
<tr><td><code>cvs</code></td>
<td>
<p>A vector of coefficient of variation (CV) values for each column/row.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>A vector of mean distances for each column/row.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+analyze_objects_shp">analyze_objects_shp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
flax &lt;- image_pliman("flax_leaves.jpg", plot =TRUE)
res &lt;-
   analyze_objects_shp(flax,
                       nrow = 3,
                       ncol = 1,
                       watershed = FALSE,
                       index = "R/(G/B)",
                       plot = FALSE)
plot(res$final_image_mask)
plot(res$shapefiles)

# distance from each leave within each row
result &lt;- object_map(res)
result$distances
result$cvs
result$means
}
</code></pre>

<hr>
<h2 id='object_mark'>Mark Object Points</h2><span id='topic+object_mark'></span>

<h3>Description</h3>

<p>Marks the coordinates of objects in an <code>anal_obj</code> object on a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_mark(object, col = "white")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_mark_+3A_object">object</code></td>
<td>
<p>An <code>anal_obj</code> object computed with <code>analyze_objects_shp()</code> or
<code>analyze_objects_shp()</code>.</p>
</td></tr>
<tr><td><code id="object_mark_+3A_col">col</code></td>
<td>
<p>The color of the marked points. Default is &quot;white&quot;.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+analyze_objects_shp">analyze_objects_shp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
flax &lt;- image_pliman("flax_leaves.jpg", plot =TRUE)
res &lt;-
   analyze_objects(flax,
                       watershed = FALSE,
                       index = "R/(G/B)",
                       plot = FALSE)
object_mark(res)
</code></pre>

<hr>
<h2 id='object_rgb'>Extract red, green and blue values from objects</h2><span id='topic+object_rgb'></span>

<h3>Description</h3>

<p>Given an image and a matrix of labels that identify each object, the function
extracts the red, green, and blue values from each object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_rgb(img, labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_rgb_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object</p>
</td></tr>
<tr><td><code id="object_rgb_+3A_labels">labels</code></td>
<td>
<p>A mask containing the labels for each object. This can be
obtained with <code><a href="EBImage.html#topic+bwlabel">EBImage::bwlabel()</a></code> or <code><a href="EBImage.html#topic+watershed">EBImage::watershed()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with <code>n</code> rows (number of pixels for all the objects) and
the following columns:
</p>

<ul>
<li> <p><code>id</code>: the object id;
</p>
</li>
<li> <p><code>R</code>: the value for the red band;
</p>
</li>
<li> <p><code>G</code>: the value for the blue band;
</p>
</li>
<li> <p><code>B</code>: the value for the green band;
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
# segment the objects using the "B" (blue) band (default)

labs &lt;- object_label(img, watershed = TRUE)
rgb &lt;- object_rgb(img, labs[[1]])
head(rgb)
</code></pre>

<hr>
<h2 id='object_split'>Splits objects from an image into multiple images</h2><span id='topic+object_split'></span>

<h3>Description</h3>

<p>Using threshold-based segmentation, objects are first isolated from
background. Then, a new image is created for each single object. A list of
images is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_split(
  img,
  index = "NB",
  lower_size = NULL,
  watershed = TRUE,
  invert = FALSE,
  fill_hull = FALSE,
  filter = 2,
  threshold = "Otsu",
  extension = NULL,
  tolerance = NULL,
  object_size = "medium",
  edge = 3,
  remove_bg = FALSE,
  plot = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_split_+3A_img">img</code></td>
<td>
<p>The image to be analyzed.</p>
</td></tr>
<tr><td><code id="object_split_+3A_index">index</code></td>
<td>
<p>A character value specifying the target mode for conversion to
binary image when <code>foreground</code> and <code>background</code> are not declared. Defaults
to <code>"NB"</code> (normalized blue). See <code><a href="#topic+image_index">image_index()</a></code> for more details. User can
also calculate your own index using the bands names, e.g. <code>index = "R+B/G"</code></p>
</td></tr>
<tr><td><code id="object_split_+3A_lower_size">lower_size</code></td>
<td>
<p>Plant images often contain dirt and dust. To prevent dust from
affecting the image analysis, objects with lesser than 10% of the mean of all objects
are removed. Set <code>lower_limit = 0</code> to keep all the objects.</p>
</td></tr>
<tr><td><code id="object_split_+3A_watershed">watershed</code></td>
<td>
<p>If <code>TRUE</code> (default) performs watershed-based object
detection. This will detect objects even when they are touching one other.
If <code>FALSE</code>, all pixels for each connected set of foreground pixels are set
to a unique object. This is faster but is not able to segment touching
objects.</p>
</td></tr>
<tr><td><code id="object_split_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image if desired. This is useful to process
images with a black background. Defaults to <code>FALSE</code>. If <code>reference = TRUE</code>
is use, <code>invert</code> can be declared as a logical vector of length 2 (eg.,
<code style="white-space: pre;">&#8288;invert = c(FALSE, TRUE&#8288;</code>). In this case, the segmentation of objects and
reference from the foreground using <code>back_fore_index</code> is performed using the
default (not inverted), and the segmentation of objects from the reference
is performed by inverting the selection (selecting pixels higher than the
threshold).</p>
</td></tr>
<tr><td><code id="object_split_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the binary image? Defaults to <code>FALSE</code>. This is
useful to fill holes in objects that have portions with a color similar to
the background. IMPORTANT: Objects touching each other can be combined into
one single object, which may underestimate the number of objects in an
image.</p>
</td></tr>
<tr><td><code id="object_split_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code><a href="#topic+image_filter">image_filter()</a></code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing noise,
but adversely affect edges.</p>
</td></tr>
<tr><td><code id="object_split_+3A_threshold">threshold</code></td>
<td>
<p>The theshold method to be used.
</p>

<ul>
<li><p> By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image. If
a numeric value is informed, this value will be used as a threshold.
</p>
</li>
<li><p> If <code>threshold = "adaptive"</code>, adaptive thresholding (Shafait et al. 2008)
is used, and will depend on the <code>k</code> and <code>windowsize</code> arguments.
</p>
</li>
<li><p> If any non-numeric value different than <code>"Otsu"</code> and <code>"adaptive"</code> is used,
an iterative section will allow you to choose the threshold based on a
raster plot showing pixel intensity of the index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="object_split_+3A_extension">extension</code></td>
<td>
<p>Radius of the neighborhood in pixels for the detection of
neighboring objects. Higher value smooths out small objects.</p>
</td></tr>
<tr><td><code id="object_split_+3A_tolerance">tolerance</code></td>
<td>
<p>The minimum height of the object in the units of image
intensity between its highest point (seed) and the point where it contacts
another object (checked for every contact pixel). If the height is smaller
than the tolerance, the object will be combined with one of its neighbors,
which is the highest.</p>
</td></tr>
<tr><td><code id="object_split_+3A_object_size">object_size</code></td>
<td>
<p>The size of the object. Used to automatically set up
<code>tolerance</code> and <code>extension</code> parameters. One of the following. <code>"small"</code>
(e.g, wheat grains), <code>"medium"</code> (e.g, soybean grains), <code>"large"</code>(e.g, peanut
grains), and <code>"elarge"</code> (e.g, soybean pods)'.</p>
</td></tr>
<tr><td><code id="object_split_+3A_edge">edge</code></td>
<td>
<p>The number of pixels to be added in the edge of the segmented
object. Defaults to 5.</p>
</td></tr>
<tr><td><code id="object_split_+3A_remove_bg">remove_bg</code></td>
<td>
<p>If <code>TRUE</code>, the pixels that are not part of objects are
converted to white.</p>
</td></tr>
<tr><td><code id="object_split_+3A_plot">plot</code></td>
<td>
<p>Show image after processing?</p>
</td></tr>
<tr><td><code id="object_split_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="object_split_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="#topic+image_combine">image_combine()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of class <code>Image</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze_objects">analyze_objects()</a></code>, <code><a href="#topic+image_binary">image_binary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("la_leaves.jpg", plot = TRUE)
imgs &lt;- object_split(img) # set to NULL to use 50% of the cores

</code></pre>

<hr>
<h2 id='object_split_shp'>Splits image objects based on a shape file</h2><span id='topic+object_split_shp'></span>

<h3>Description</h3>

<p>Here, <code><a href="#topic+image_shp">image_shp()</a></code> is used to create a shape file based on the desired
number of rows and columns. Then, using the object coordinates, a list of
<code>Image</code> objects is created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_split_shp(
  img,
  nrow = 1,
  ncol = 1,
  buffer_x = 0,
  buffer_y = 0,
  interactive = FALSE,
  viewer = get_pliman_viewer(),
  only_shp = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_split_shp_+3A_img">img</code></td>
<td>
<p>An object of class <code>Image</code></p>
</td></tr>
<tr><td><code id="object_split_shp_+3A_nrow">nrow</code></td>
<td>
<p>The number of desired rows in the grid. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="object_split_shp_+3A_ncol">ncol</code></td>
<td>
<p>The number of desired columns in the grid. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="object_split_shp_+3A_buffer_x">buffer_x</code>, <code id="object_split_shp_+3A_buffer_y">buffer_y</code></td>
<td>
<p>Buffering factor for the width and height,
respectively, of each individual shape's side. A value between 0 and 0.5 where 0
means no buffering and 0.5 means complete buffering (default: 0). A value of
0.25 will buffer the shape by 25% on each side.</p>
</td></tr>
<tr><td><code id="object_split_shp_+3A_interactive">interactive</code></td>
<td>
<p>If <code>FALSE</code> (default) the grid is created automatically
based on the image dimension and number of rows/columns. If <code>interactive = TRUE</code>, users must draw points at the diagonal of the desired bounding box
that will contain the grid.</p>
</td></tr>
<tr><td><code id="object_split_shp_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are <code>"base"</code> and
<code>"mapview"</code>. If set to &quot;base&quot;, the base R graphics system is used for
interactive plotting. If set to &quot;mapview&quot;, the mapview package is used. To
set this argument globally for all functions in the package, you can use
the <code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="object_split_shp_+3A_only_shp">only_shp</code></td>
<td>
<p>If <code>TRUE</code> returns only the shapefiles with the coordinates
for each image. If <code>FALSE</code> (default) returns the splitted image according
to <code>nrow</code> and <code>ncol</code> arguments.</p>
</td></tr>
<tr><td><code id="object_split_shp_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+image_shp">image_shp()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>Image</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
flax &lt;- image_pliman("flax_leaves.jpg", plot = TRUE)
objects &lt;- object_split_shp(flax, nrow = 3, ncol = 5)
image_combine(objects$imgs)
}
</code></pre>

<hr>
<h2 id='object_to_color'>Apply color to image objects</h2><span id='topic+object_to_color'></span>

<h3>Description</h3>

<p>The function applies the color informed in the argument <code>color</code> to segmented
objects in the image. The segmentation is performed using image indexes. Use
<code><a href="#topic+image_index">image_index()</a></code> to identify the better candidate index to segment objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_to_color(img, index = "NB", color = "blue", plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_to_color_+3A_img">img</code></td>
<td>
<p>An image object.</p>
</td></tr>
<tr><td><code id="object_to_color_+3A_index">index</code></td>
<td>
<p>A character value (or a vector of characters) specifying the
target mode for conversion to binary image. See the available indexes with
<code><a href="#topic+pliman_indexes">pliman_indexes()</a></code> and <code><a href="#topic+image_index">image_index()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="object_to_color_+3A_color">color</code></td>
<td>
<p>The color to apply in the image objects. Defaults to <code>"blue"</code>.</p>
</td></tr>
<tr><td><code id="object_to_color_+3A_plot">plot</code></td>
<td>
<p>Plots the modified image? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="object_to_color_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="#topic+image_binary">image_binary()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>Image</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("la_leaves.jpg")
img2 &lt;- object_to_color(img, index = "G-R")
image_combine(img, img2)

</code></pre>

<hr>
<h2 id='otsu'>Calculate Otsu's threshold</h2><span id='topic+otsu'></span>

<h3>Description</h3>

<p>Given a numeric vector with the pixel's intensities, returns the threshold
value based on Otsu's method, which minimizes the combined intra-class
variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otsu(values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otsu_+3A_values">values</code></td>
<td>
<p>A numeric vector with the pixel values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double (threshold value).
</p>


<h3>References</h3>

<p>Otsu, N. 1979. Threshold selection method from gray-level
histograms. IEEE Trans Syst Man Cybern SMC-9(1): 6266. doi:
<a href="https://doi.org/10.1109/tsmc.1979.4310076">doi:10.1109/tsmc.1979.4310076</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- image_pliman("soybean_touch.jpg")
thresh &lt;- otsu(img@.Data[,,3])
plot(img[,,3] &lt; thresh)

</code></pre>

<hr>
<h2 id='palettes'>Create image palettes</h2><span id='topic+palettes'></span><span id='topic+image_palette'></span>

<h3>Description</h3>

<p><code>image_palette()</code>  creates image palettes by applying the k-means algorithm
to the RGB values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_palette(img, npal = 5, proportional = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palettes_+3A_img">img</code></td>
<td>
<p>An image object.</p>
</td></tr>
<tr><td><code id="palettes_+3A_npal">npal</code></td>
<td>
<p>The number of color palettes.</p>
</td></tr>
<tr><td><code id="palettes_+3A_proportional">proportional</code></td>
<td>
<p>Creates a joint palette with proportional size equal to
the number of pixels in the image? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="palettes_+3A_plot">plot</code></td>
<td>
<p>Plot the generated palette? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>image_palette()</code> returns a list with two elements:
</p>

<ul>
<li> <p><code>palette_list</code> A list with <code>npal</code> color palettes of class <code>Image</code>.
</p>
</li>
<li> <p><code>joint</code> An object of class <code>Image</code> with the color palettes
</p>
</li>
<li> <p><code>proportions</code> The proportion of the entire image corresponding to each color in the palette
</p>
</li>
<li> <p><code>rgbs</code> The average RGB value for each palette
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
img &lt;- image_pliman("sev_leaf.jpg")
pal &lt;- image_palette(img, npal = 4)

image_combine(pal$palette_list)


</code></pre>

<hr>
<h2 id='pipe'>Forward-pipe operator</h2><span id='topic+pipe'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe an object forward into a function or call expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pipe_+3A_lhs">lhs</code></td>
<td>
<p>The result you are piping.</p>
</td></tr>
<tr><td><code id="pipe_+3A_rhs">rhs</code></td>
<td>
<p>Where you are piping the result to.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathan Eastwood <a href="mailto:nathan.eastwood@icloud.com">nathan.eastwood@icloud.com</a> and Antoine Fabri
<a href="mailto:antoine.fabri@gmail.com">antoine.fabri@gmail.com</a>. The code was obtained from poorman package
at <a href="https://github.com/nathaneastwood/poorman/blob/master/R/pipe.R">https://github.com/nathaneastwood/poorman/blob/master/R/pipe.R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)

# Basic use:
 iris %&gt;% head()

# use to apply several functions to an image
img &lt;- image_pliman("la_leaves.jpg")

img %&gt;%
 image_resize(50) %&gt;%        # resize to 50% of the original size
 object_isolate(id = 1) %&gt;%  # isolate object 1
 image_filter() %&gt;%          # apply a median filter
 plot()                      # plot

</code></pre>

<hr>
<h2 id='pixel_index'>Get the pixel indices for a given row of a binary image</h2><span id='topic+pixel_index'></span>

<h3>Description</h3>

<p>This function finds the first row in the bin matrix that has a value greater
than 0 (TRUE). It then calculates the minimum, median, and maximum values for
the pixels in that row and creates an array containing the row index, the
minimum pixel index, the median pixel index, and the maximum pixel index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixel_index(bin, row = NULL, direction = "updown")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pixel_index_+3A_bin">bin</code></td>
<td>
<p>A logical matrix representing a binary image</p>
</td></tr>
<tr><td><code id="pixel_index_+3A_row">row</code></td>
<td>
<p>An optional row index. If not provided, the function selects the
first non-zero row.</p>
</td></tr>
<tr><td><code id="pixel_index_+3A_direction">direction</code></td>
<td>
<p>The direction for row selection when row is not provided.
If set to <code>"updown"</code>, the function starts scanning from the top of the image
towards the bottom. If set to <code>"downup"</code>, the function starts scanning from
the bottom towards the top.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the row index, the minimum pixel index,
the median pixel index, and the maximum pixel index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
leaf &lt;- image_pliman("sev_leaf.jpg")
bin &lt;- image_binary(leaf, "NB")[[1]]

# first row with leaf (17)
pixel_index(bin)

# index at the row 100
pixel_index(bin, row = 100)

plot(leaf)
points(x = 248, y = 17, pch = 16, col = "red", cex = 2)
points(x = 163, y = 100, pch = 16, col = "red", cex = 2)
points(x = 333, y = 100, pch = 16, col = "red", cex = 2)


</code></pre>

<hr>
<h2 id='pliman_images'>Sample images</h2><span id='topic+pliman_images'></span>

<h3>Description</h3>

<p>Sample images installed with the <span class="pkg">pliman</span> package
</p>


<h3>Format</h3>

<p><code style="white-space: pre;">&#8288;*.jpg&#8288;</code> format
</p>

<ul>
<li> <p><code>flax_leaves.jpg</code> Flax leaves in a white background
</p>
</li>
<li> <p><code>flax_grains.jpg</code> Flax grains with background light.
</p>
</li>
<li> <p><code>la_back.jpg</code> A cyan palette representing the background of images
la_pattern, la_leaves, and soybean_touch.
</p>
</li>
<li> <p><code>la_leaf.jpg</code> A sample of the leaves in <code>la_leaves</code>
</p>
</li>
<li> <p><code>la_leaves.jpg</code> Tree leaves with a sample of known area.
</p>
</li>
<li> <p><code>mult_leaves.jpg</code> Three soybean leaflets with soybean rust symptoms.
</p>
</li>
<li> <p><code>objects_300dpi.jpg</code> An image with 300 dpi resolution.
</p>
</li>
<li> <p><code>potato_leaves.jpg</code> Three potato leaves, which were gathered from Gupta et
al. (2020).
</p>
</li>
<li> <p><code>sev_leaf.jpg</code> A soybean leaf with a blue background.
</p>
</li>
<li> <p><code>sev_leaf_nb.jpg</code> A soybean leaf without background.
</p>
</li>
<li> <p><code>sev_back.jpg</code> A blue palette representing the background of <code>sev_leaf</code>.
</p>
</li>
<li> <p><code>sev_healthy.jpg</code> Healthy area of <code>sev_leaf</code>.
</p>
</li>
<li> <p><code>sev_sympt.jpg</code> The symptomatic area <code>sev_leaf</code>.
</p>
</li>
<li> <p><code>shadow.jpg</code> A shaded leaf, useful to test adaptive thresholding
</p>
</li>
<li> <p><code>soy_green.jpg</code> Soybean grains with a white background.
</p>
</li>
<li> <p><code>soybean_grain.jpg</code> A sample palette of the grains in <code>soy_green</code>.
</p>
</li>
<li> <p><code>soybean_touch.jpg</code> Soybean grains with a cyan background touching one each
other.
</p>
</li>
<li> <p><code>field_mosaic.jpg</code> An UVA image from a soybean field.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Source</h3>

<p>Personal data, Gupta et al. (2020).
</p>


<h3>References</h3>

<p>Gupta, S., Rosenthal, D. M., Stinchcombe, J. R., &amp; Baucom, R. S.
(2020). The remarkable morphological diversity of leaf shape in sweet
potato (Ipomoea batatas): the influence of genetics, environment, and GE.
New Phytologist, 225(5), 21832195. <a href="https://doi.org/10.1111/NPH.16286">doi:10.1111/NPH.16286</a>
</p>

<hr>
<h2 id='pliman_viewer'>Global option for controlling the viewer in pliman package</h2><span id='topic+pliman_viewer'></span>

<h3>Description</h3>

<p>Users can set the value of this option using <code>options("pliman_viewer", value)</code>.
The default value is &quot;base&quot;. Use &quot;mapview&quot; to allow image to be
plotted/edited using the R packages mapview and mapedit
</p>

<hr>
<h2 id='plot_index'>Plot an image index</h2><span id='topic+plot_index'></span>

<h3>Description</h3>

<p>Plot an image index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_index(
  img = NULL,
  object = NULL,
  index = NULL,
  remove_bg = TRUE,
  viewer = get_pliman_viewer(),
  all_layers = TRUE,
  layer = 1,
  max_pixels = 5e+05,
  downsample = NULL,
  downsample_fun = NULL,
  color_regions = custom_palette(),
  ncol = NULL,
  nrow = NULL,
  aspect_ratio = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_index_+3A_img">img</code></td>
<td>
<p>An optional <code>Image</code> object or an object computed with
<code><a href="#topic+image_index">image_index()</a></code>. If <code>object</code> is provided, then the input image is obtained
internally.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_object">object</code></td>
<td>
<p>An object computed with <code><a href="#topic+analyze_objects_shp">analyze_objects_shp()</a></code>. By using this
object you can ignore <code>img</code>.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_index">index</code></td>
<td>
<p>The index to plot. Defaults to the index computed from the
<code>object</code> if provided. Otherwise, the <code>B</code> index is computed. See
<code><a href="#topic+image_index">image_index()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_remove_bg">remove_bg</code></td>
<td>
<p>Logical value indicating whether to remove the background
when <code>object</code> is provided. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_all_layers">all_layers</code></td>
<td>
<p>Render all layers when <code>img</code> is an object computed with
<code><a href="#topic+image_index">image_index()</a></code> and <code>viewer = "mapview"</code>?.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_layer">layer</code></td>
<td>
<p>The layer to plot when <code>img</code> is an object computed with
<code><a href="#topic+image_index">image_index()</a></code> and <code>viewer = "mapview"</code>. Defaults to the first layer
(first index computed).</p>
</td></tr>
<tr><td><code id="plot_index_+3A_max_pixels">max_pixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to plot the index. If
<code>max_pixels &lt; npixels(img)</code>, downsampling is performed before plotting the
index. Using a large number of pixels may slow down the plotting time.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_downsample">downsample</code></td>
<td>
<p>integer; for each dimension the number of
pixels/lines/bands etc that will be skipped; Defaults to <code>NULL</code>, which will
find the best downsampling factor to approximate the <code>max_pixels</code> value.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_downsample_fun">downsample_fun</code></td>
<td>
<p>function; if given, downsampling will apply
<code style="white-space: pre;">&#8288;downsample_fun`` &#8288;</code> to each of the the subtiles.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_color_regions">color_regions</code></td>
<td>
<p>The color palette for displaying index values. Default
is <code><a href="#topic+custom_palette">custom_palette()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_nrow">nrow</code>, <code id="plot_index_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows or columns in the plot grid. Defaults to
<code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
<tr><td><code id="plot_index_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Numeric, giving the aspect ratio y/x. Defaults to <code>NA</code>.
See <code><a href="graphics.html#topic+plot.window">graphics::plot.window()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# Example usage:
library(pliman)
img &lt;- image_pliman("sev_leaf.jpg")
plot_index(img, index = "B")
}

</code></pre>

<hr>
<h2 id='plot_index_shp'>Plot rectangles colored by a quantitative attribute and overlay on an RGB
image</h2><span id='topic+plot_index_shp'></span>

<h3>Description</h3>

<p>This function plots rectangles on top of an RGB image, where each rectangle
is colored based on a quantitative variable. The quantitative variable is
specified in the <code>attribute</code> argument and should be present in the
<code>object_index</code> of the <code>object</code> computed using <code><a href="#topic+analyze_objects_shp">analyze_objects_shp()</a></code>. The
rectangles are colored using a color scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_index_shp(
  object,
  attribute = "coverage",
  color = c("red", "green"),
  viewer = c("mapview", "base"),
  max_pixels = 5e+05,
  downsample = NULL,
  downsample_fun = NULL,
  alpha = 0.5,
  legend.position = "bottom",
  na.color = "gray",
  classes = 6,
  round = 3,
  horiz = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_index_shp_+3A_object">object</code></td>
<td>
<p>An object computed with <code><a href="#topic+analyze_objects_shp">analyze_objects_shp()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_attribute">attribute</code></td>
<td>
<p>The name of the quantitative variable in the
<code>object_index</code> to be used for coloring the rectangles.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_color">color</code></td>
<td>
<p>A vector of two colors to be used for the color scale.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are <code>"base"</code> and
<code>"mapview"</code>. If set to &quot;base&quot;, the base R graphics system is used for
interactive plotting. If set to &quot;mapview&quot;, the mapview package is used. To
set this argument globally for all functions in the package, you can use
the <code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_max_pixels">max_pixels</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to plot the index. If
<code>max_pixels &lt; npixels(img)</code>, downsampling is performed before plotting the
index. Using a large number of pixels may slow down the plotting time.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_downsample">downsample</code></td>
<td>
<p>integer; for each dimension the number of
pixels/lines/bands etc that will be skipped; Defaults to <code>NULL</code>, which will
find the best downsampling factor to approximate the <code>max_pixels</code> value.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_downsample_fun">downsample_fun</code></td>
<td>
<p>function; if given, downsampling will apply
<code style="white-space: pre;">&#8288;downsample_fun`` &#8288;</code> to each of the the subtiles.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_alpha">alpha</code></td>
<td>
<p>The transparency level of the rectangles' color (between 0 and 1).</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_legend.position">legend.position</code></td>
<td>
<p>The position of the color legend, either
<code>"bottom"</code> or <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_na.color">na.color</code></td>
<td>
<p>The color to be used for rectangles with missing values in
the quantitative variable.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_classes">classes</code></td>
<td>
<p>The number of classes in the color scale.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_round">round</code></td>
<td>
<p>The number of decimal places to round the legend values.</p>
</td></tr>
<tr><td><code id="plot_index_shp_+3A_horiz">horiz</code></td>
<td>
<p>Logical, whether the legend should be horizontal (<code>TRUE</code>)
or vertical (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function plots rectangles colored by the specified quantitative
variable on top of the RGB image and shows the continuous color legend
outside the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)

# Computes the DGCI index for each flax leaf
flax &lt;- image_pliman("flax_leaves.jpg", plot =TRUE)
res &lt;-
   analyze_objects_shp(flax,
                       buffer_x = 0.2,
                       buffer_y = 0.2,
                       nrow = 3,
                       ncol = 5,
                       plot = FALSE,
                       object_index = "DGCI")
plot(res$final_image)
plot_index_shp(res)
}

</code></pre>

<hr>
<h2 id='plot_lw'>Plot length and width lines on objects</h2><span id='topic+plot_lw'></span>

<h3>Description</h3>

<p>This function plots the length and width lines given an <code>object</code> computed
with <code><a href="#topic+analyze_objects">analyze_objects()</a></code>. The function does not call <code>plot.new</code>, so it must
be called after an image is plotted. This can be done either using, e.g.,
<code>plot(img)</code>, or <code>analyze_objects(..., plot = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lw(
  object,
  col_length = "red",
  col_width = "green",
  lwd_length = 2,
  lwd_width = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lw_+3A_object">object</code></td>
<td>
<p>An object computed with <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_lw_+3A_col_length">col_length</code></td>
<td>
<p>The color of the length line. Default is <code>"red"</code>.</p>
</td></tr>
<tr><td><code id="plot_lw_+3A_col_width">col_width</code></td>
<td>
<p>The color of the width line. Default is <code>"green"</code>.</p>
</td></tr>
<tr><td><code id="plot_lw_+3A_lwd_length">lwd_length</code></td>
<td>
<p>The line width of the length line. Default is 2.</p>
</td></tr>
<tr><td><code id="plot_lw_+3A_lwd_width">lwd_width</code></td>
<td>
<p>The line width of the width line. Default is 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes an object computed with <code><a href="#topic+analyze_objects">analyze_objects()</a></code> and
plots the length and width lines of each object onto an image. The length
and width lines are calculated based on the position and orientation of the
object, and are plotted using the specified colors and line widths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- image_pliman("flax_leaves.jpg")
res &lt;- analyze_objects(img, watershed = FALSE, show_contour = FALSE)
plot_lw(res)
</code></pre>

<hr>
<h2 id='plot.image_shp'>S3 method <code>plot</code> for <code>image_shp</code> objects</h2><span id='topic+plot.image_shp'></span>

<h3>Description</h3>

<p>Draws the bounding boxes for each object computed with <code><a href="#topic+image_shp">image_shp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'image_shp'
plot(
  x,
  img = NULL,
  col_line = "black",
  size_line = 2,
  col_text = "black",
  size_text = 0.75,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.image_shp_+3A_x">x</code></td>
<td>
<p>An object computed with <code><a href="#topic+image_shp">image_shp()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.image_shp_+3A_img">img</code></td>
<td>
<p>The image that was used to compute the shapefile (optional)</p>
</td></tr>
<tr><td><code id="plot.image_shp_+3A_col_line">col_line</code>, <code id="plot.image_shp_+3A_col_text">col_text</code></td>
<td>
<p>The color of the line/text in the grid. Defaults to
<code>"red"</code>.</p>
</td></tr>
<tr><td><code id="plot.image_shp_+3A_size_line">size_line</code>, <code id="plot.image_shp_+3A_size_text">size_text</code></td>
<td>
<p>The size of the line/text in the grid. Defaults to
<code>2.5</code>.</p>
</td></tr>
<tr><td><code id="plot.image_shp_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>NULL</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
flax &lt;- image_pliman("flax_leaves.jpg")
shape &lt;- image_shp(flax, nrow = 3, ncol = 5)

# grid on the existing image
plot(flax)
plot(shape)
</code></pre>

<hr>
<h2 id='poly_apex_base_angle'>Calculate the apex and base angles of an object</h2><span id='topic+poly_apex_base_angle'></span>

<h3>Description</h3>

<p>This function calculates the apex and base angles of an object. It takes as
input a matrix of coordinates and returns the apex angle, base angle, and the
coordinates of the apex and base as a list. The angles are computed after the
object is aligned in the vertical axis with <code>poly_align()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_apex_base_angle(
  x,
  percentiles = c(0.25, 0.75),
  invert = FALSE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_apex_base_angle_+3A_x">x</code></td>
<td>
<p>A matrix of coordinates representing the contour of the object,
often obtained with <code><a href="#topic+object_contour">object_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="poly_apex_base_angle_+3A_percentiles">percentiles</code></td>
<td>
<p>A numeric vector of two percentiles between 0 and 1
indicating the height of the points from the top to the bottom. The function
calculates the apex angle between the two percentiles and the base angle
between the lowest point and the highest point.</p>
</td></tr>
<tr><td><code id="poly_apex_base_angle_+3A_invert">invert</code></td>
<td>
<p>If <code>TRUE</code>, aligns the object along the horizontal axis.</p>
</td></tr>
<tr><td><code id="poly_apex_base_angle_+3A_plot">plot</code></td>
<td>
<p>Plots the polygon with the points? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the apex angle, base angle, apex coordinates, and
base coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
# a matrix of coordinates
angls &lt;- poly_apex_base_angle(contours[[2]])
angls

# or a list of coordinates
poly_apex_base_angle(contours)
</code></pre>

<hr>
<h2 id='poly_pcv'>Compute Perimeter Complexity Value (PCV)</h2><span id='topic+poly_pcv'></span>

<h3>Description</h3>

<p>This function calculates the Perimeter Complexity Value (PCV) for a given set
of coordinates representing a contour. The PCV measures the variation of
distances between the original coordinates and the smoothed coordinates
relative to the perimeter length of the original contour. See more in
<code>details</code> section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_pcv(x, niter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_pcv_+3A_x">x</code></td>
<td>
<p>A matrix or a list of matrices representing the coordinates of the
polygon(s).</p>
</td></tr>
<tr><td><code id="poly_pcv_+3A_niter">niter</code></td>
<td>
<p>An integer specifying the number of smoothing iterations. See
<code><a href="#topic+poly_smooth">poly_smooth()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PCV is computed using the following formula: </p>
<p style="text-align: center;"><code class="reqn">PCV =
\frac{sum(dists) \times sd(dists)}{perim}</code>
</p>
<p> where <code class="reqn">dists</code>
represents the distances between corresponding points in the original and
smoothed coordinates, and <code class="reqn">perim</code> is the perimeter length of the smoothed
contour.
</p>
<p>The PCV is computed by first smoothing the input contour using a specified
number of iterations. The smoothed contour is then used to compute the
distances between corresponding points in the original and smoothed
coordinates. These distances reflect the variations in the contour shape
after smoothing. The sum of these distances represents the overall magnitude
of the variations. Next, the sum of distances is multiplied by the standard
deviation of the distances to capture the dispersion or spread of the
variations. Finally, this value is divided by the perimeter length of the
original contour to provide a relative measure of complexity. Therefore, the
PCV provides a relative measure of complexity by considering both the
magnitude and spread of the variations in the contour shape after smoothing.
</p>


<h3>Value</h3>

<p>The PCV value(s) computed for the contour(s).
</p>
<p>If <code>x</code> is a matrix, returns the complexity value of the polygon's
perimeter. If <code>x</code> is a list of matrices, returns a numeric vector of
complexity values for each polygon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
set.seed(20)
shp &lt;- efourier_shape(npoints = 1000)
poly_pcv(shp)

# increase the complexity of the outline
shp2 &lt;- poly_jitter(shp, noise_x = 20, noise_y = 250, plot = TRUE)

smo &lt;- poly_smooth(shp2, niter = 100, plot = FALSE)
plot_contour(smo, col = "red")
poly_pcv(shp2)

</code></pre>

<hr>
<h2 id='poly_width_at'>Width at a given height</h2><span id='topic+poly_width_at'></span>

<h3>Description</h3>

<p>The function computes the polygonal convex hull of the points in x and then
returns the number of points that lie below a specified set of heights along
the vertical axis of the convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_width_at(
  x,
  at = c(0.05, 0.25, 0.5, 0.75, 0.95),
  unify = FALSE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_width_at_+3A_x">x</code></td>
<td>
<p>A vector containing two-dimensional data points (often produced with
<a href="#topic+object_contour">object_contour</a>).</p>
</td></tr>
<tr><td><code id="poly_width_at_+3A_at">at</code></td>
<td>
<p>A vector of heights along the vertical axis of the convex hull at
which to count the number of points below. The default value is <code>c(0.05, 0.25, 0.5, 0.75, 0.95)</code>, which means the function will return the number of
points below the 5th, 25th, 50th, 75th, and 95th percentiles of the convex
hull. If <code>at = "heights"</code> is used, the function returns the width for each
point of the object length.</p>
</td></tr>
<tr><td><code id="poly_width_at_+3A_unify">unify</code></td>
<td>
<p>A logical value indicating whether to use the unified convex
hull calculation method. If unify = TRUE, coordinates in x will be
first bound before computing the convex hull.</p>
</td></tr>
<tr><td><code id="poly_width_at_+3A_plot">plot</code></td>
<td>
<p>A logical value that specifies whether the widths should be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The convex hull computed from x is aligned along the major axis and then
converted to a binary image. For each height in the at vector, the function
computes the corresponding row number in the binary image (i.e., the row
number that corresponds to the specified height along the vertical axis of
the convex hull) and sums the values in that row to obtain the number of
points that lie below the specified height. If the convex hull contains
multiple polygons and unify = FALSE, the function loops over each polygon
and returns a list of the number of points below the specified heights for
each polygon. If the convex hull contains only one polygon or multiple
polygons and unify = TRUE, the function returns a vector of the number of
points below the specified heights for that single polygon.
</p>


<h3>Value</h3>

<p>A vector with the widths of the convex hull at the specified heights
or a list of vectors with the widths of each component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cont &lt;- contours[[2]]
plot_polygon(cont |&gt; conv_hull() |&gt; poly_align())
#  width below 5th, 25th, 50th, 75th, and 95th percentiles of the length
wd &lt;- poly_width_at(cont)
wd

# width along the height
poly_width_at(cont, at = "height", plot = TRUE)


</code></pre>

<hr>
<h2 id='prepare_to_shp'>Prepare images to analyze_objects_shp()</h2><span id='topic+prepare_to_shp'></span>

<h3>Description</h3>

<p>It is a simple wrapper around <code><a href="#topic+image_align">image_align()</a></code> and <code><a href="#topic+image_crop">image_crop()</a></code>. In this case, only the option <code>viewer = "base"</code> is used. To use <code>viewer = "mapview"</code>, please, use such functions separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_to_shp(img, align = "vertical")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_to_shp_+3A_img">img</code></td>
<td>
<p>A <code>Image</code> object</p>
</td></tr>
<tr><td><code id="prepare_to_shp_+3A_align">align</code></td>
<td>
<p>The desired alignment. Either <code>"vertical"</code> (default) or
<code>"horizontal"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An aligned and cropped <code>Image</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
img &lt;- image_pliman("flax_leaves.jpg")
prepare_to_shp(img)
}
</code></pre>

<hr>
<h2 id='random_color'>Random built-in color names</h2><span id='topic+random_color'></span>

<h3>Description</h3>

<p>Randomly chooses single or multiple built-in color names which R knows about.
See more at <code><a href="grDevices.html#topic+colors">grDevices::colors()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_color(n = 1, distinct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_color_+3A_n">n</code></td>
<td>
<p>The number of color names. Defaults to 1.</p>
</td></tr>
<tr><td><code id="random_color_+3A_distinct">distinct</code></td>
<td>
<p>Logical indicating if the colors returned should all be
distinct. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of color names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
random_color(n = 3)
</code></pre>

<hr>
<h2 id='sad'>Produces Santandard Area Diagrams</h2><span id='topic+sad'></span>

<h3>Description</h3>

<p>Given an object computed with <code><a href="#topic+measure_disease">measure_disease()</a></code> or <code><a href="#topic+measure_disease_byl">measure_disease_byl()</a></code>
a Standard Area Diagram (SAD) with <code>n</code> images are returned with the
respective severity values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sad(
  object,
  n,
  show_original = FALSE,
  show_contour = FALSE,
  nrow = NULL,
  ncol = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sad_+3A_object">object</code></td>
<td>
<p>An object computed with <code><a href="#topic+measure_disease">measure_disease()</a></code> or
<code><a href="#topic+measure_disease_byl">measure_disease_byl()</a></code>.</p>
</td></tr>
<tr><td><code id="sad_+3A_n">n</code></td>
<td>
<p>The number of leaves in the Standard Area Diagram.</p>
</td></tr>
<tr><td><code id="sad_+3A_show_original">show_original</code></td>
<td>
<p>Show original images? Defaults to <code>FALSE</code>, i.e., a mask
is returned.</p>
</td></tr>
<tr><td><code id="sad_+3A_show_contour">show_contour</code></td>
<td>
<p>Show original images? Defaults to <code>FALSE</code>, i.e., a mask
is returned.</p>
</td></tr>
<tr><td><code id="sad_+3A_nrow">nrow</code>, <code id="sad_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows and columns in the plot. See
[image_combine())]
</p>
<p>[image_combine())]: R:image_combine())</p>
</td></tr>
<tr><td><code id="sad_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+measure_disease">measure_disease()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The leaves with the smallest and highest severity will always be in the SAD.
If <code>n = 1</code>, the leaf with the smallest severity will be returned. The others
are sampled sequentially to achieve the <code>n</code> images after severity has been
ordered in an ascending order. For example, if there are 30 leaves and n is
set to 3, the leaves sampled will be the 1st, 15th, and 30th with the
smallest severity values.
</p>
<p>The SAD can be only computed if an image pattern name is used in argument
<code>pattern</code> of <code><a href="#topic+measure_disease">measure_disease()</a></code>. If the images are saved, the <code>n</code> images
will be retrevied from <code>dir_processed</code> directory. Otherwise, the severity
will be computed again to generate the images.
</p>


<h3>Value</h3>

<p>A data frame with the severity values for the <code>n</code> sampled leaves. A plot with
the standard area diagram can be saved by wrapping <code><a href="#topic+sad">sad()</a></code> with <code><a href="grDevices.html#topic+png">png()</a></code>.
</p>


<h3>References</h3>

<p>Del Ponte EM, Pethybridge SJ, Bock CH, et al (2017) Standard area
diagrams for aiding severity estimation: Scientometrics, pathosystems, and
methodological trends in the last 25 years. Phytopathology 107:11611174.
<a href="https://doi.org/10.1094/PHYTO-02-17-0069-FI">doi:10.1094/PHYTO-02-17-0069-FI</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pliman)
sev &lt;-
measure_disease(pattern = "sev_leaf",
                img_healthy = "sev_healthy",
                img_symptoms = "sev_sympt",
                img_background  = "sev_back",
                plot = FALSE,
                save_image = TRUE,
                show_original = FALSE,
                dir_original = image_pliman(),
                dir_processed = tempdir())
sad(sev, n = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='separate_col'>Turns a single character column into multiple columns.</h2><span id='topic+separate_col'></span>

<h3>Description</h3>

<p>Given either a regular expression or a vector of character positions,
<code>separate_col()</code> turns a single character column into multiple columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_col(.data, col, into, sep = "[^[:alnum:]]+")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_col_+3A_.data">.data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="separate_col_+3A_col">col</code></td>
<td>
<p>Column name</p>
</td></tr>
<tr><td><code id="separate_col_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector</p>
</td></tr>
<tr><td><code id="separate_col_+3A_sep">sep</code></td>
<td>
<p>The separator between columns. By default, a regular expression
that matches any sequence of non-alphanumeric values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mutated <code>.data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
df &lt;- data.frame(x = paste0("TRAT_", 1:5),
                 y = 1:5)
df
separate_col(df, x, into = c("TRAT", "REP"))
</code></pre>

<hr>
<h2 id='set_pliman_viewer'>Set the value of the pliman_viewer option</h2><span id='topic+set_pliman_viewer'></span>

<h3>Description</h3>

<p>Sets the value of the pliman_viewer option used in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_pliman_viewer(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_pliman_viewer_+3A_value">value</code></td>
<td>
<p>The value to be set for the pliman_viewer option.</p>
</td></tr>
</table>

<hr>
<h2 id='summary_index'>Summary an object index</h2><span id='topic+summary_index'></span>

<h3>Description</h3>

<p>If more than one index is available, the function performs a Principal
Component Analysis and produces a plot showing the contribution of the
indexes to the PC1 (see <code><a href="#topic+pca">pca()</a></code>). If an index is declared in
<code>index</code> and a cut point in <code>cut_point</code>, the number and proportion of objects
with mean value of <code>index</code> bellow and above <code>cut_point</code> are returned.
Additionaly, the number and proportion of pixels bellow and above the
cutpoint is shown for each object (id).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_index(
  object,
  index = NULL,
  cut_point = NULL,
  select_higher = FALSE,
  plot = TRUE,
  type = "var",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_index_+3A_object">object</code></td>
<td>
<p>An object computed with <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.</p>
</td></tr>
<tr><td><code id="summary_index_+3A_index">index</code></td>
<td>
<p>The index desired, e.g., <code>"B"</code>. Note that these value must match
the index(es) used in the argument <code>object_index</code> of <code>analyze_objects()</code>.</p>
</td></tr>
<tr><td><code id="summary_index_+3A_cut_point">cut_point</code></td>
<td>
<p>The cut point.</p>
</td></tr>
<tr><td><code id="summary_index_+3A_select_higher">select_higher</code></td>
<td>
<p>If <code>FALSE</code> (default) selects the objects with <code>index</code>
smaller than the <code>cut_point</code>. Use <code>select_higher = TRUE</code> to select the
objects with <code>index</code> higher than <code>cut_point</code>.</p>
</td></tr>
<tr><td><code id="summary_index_+3A_plot">plot</code></td>
<td>
<p>Shows the contribution plot when more than one index is
available? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary_index_+3A_type">type</code></td>
<td>
<p>The type of plot to produce. Defaults to <code>"var"</code>. See more at
<code><a href="#topic+get_biplot">get_biplot()</a></code>.</p>
</td></tr>
<tr><td><code id="summary_index_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+get_biplot">get_biplot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>ids</code> The identification of selected objects.
</p>
</li>
<li> <p><code>between_id</code> A data frame with the following columns
</p>

<ul>
<li> <p><code>n</code> The number of objects.
</p>
</li>
<li> <p><code>nsel</code> The number of selected objects.
</p>
</li>
<li> <p><code>prop</code> The proportion of objects selected.
</p>
</li>
<li> <p><code>mean_index_sel</code>, and <code>mean_index_nsel</code> The mean value of <code>index</code> for the
selected and non-selected objects, respectively.
</p>
</li></ul>

</li>
<li> <p><code>within_id</code> A data frame with the following columns
</p>

<ul>
<li> <p><code>id</code> The object identification
</p>
</li>
<li> <p><code>n_less</code> The number of pixels with values lesser than or equal to
<code>cut_point</code>.
</p>
</li>
<li> <p><code>n_greater</code> The number of pixels with values greater than <code>cut_point</code>.
</p>
</li>
<li> <p><code>less_ratio</code> The proportion of pixels with values lesser than or equal to
<code>cut_point</code>.
</p>
</li>
<li> <p><code>greater_ratio</code> The proportion of pixels with values greater than
<code>cut_point</code>.
</p>
</li></ul>

</li>
<li> <p><code>pca_res</code> An object computed with <code><a href="#topic+pca">pca()</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
soy &lt;- image_pliman("soy_green.jpg")
anal &lt;- analyze_objects(soy, object_index = "G", pixel_level_index = TRUE)
plot_measures(anal, measure = "G")

summary_index(anal, index = "G", cut_point = 0.5)
</code></pre>

<hr>
<h2 id='utils_colorspace'>Convert between colour spaces</h2><span id='topic+utils_colorspace'></span><span id='topic+rgb_to_hsb'></span><span id='topic+rgb_to_srgb'></span><span id='topic+rgb_to_lab'></span>

<h3>Description</h3>

<p><code>rgb_to_srgb()</code> Transforms colors from RGB space (red/green/blue) to
Standard Red Green Blue (sRGB), using a gamma correction of 2.2.
</p>

<ul>
<li> <p><code>rgb_to_hsb()</code> Transforms colors from RGB space (red/green/blue) to HSB
space (hue/saturation/brightness).
</p>
</li>
<li> <p><code>rgb_to_lab()</code> Transforms colors from RGB space (red/green/blue) to
CIE-LAB space
</p>
</li></ul>

<p>It is assumed that
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb_to_hsb(object)

rgb_to_srgb(object)

rgb_to_lab(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_colorspace_+3A_object">object</code></td>
<td>
<p>An <code>Image</code> object, an object computed with
<code>analyze_objects()</code> with a valid <code>object_index</code> argument, or a
<code>data.frame/matrix</code>. For the last, a three-column data (R, G, and B, respectively)
is required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the columns of the converted color space
</p>


<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
img &lt;- image_pliman("sev_leaf.jpg")
rgb_to_lab(img)

# analyze the object and convert the pixels
anal &lt;- analyze_objects(img, object_index = "B", pixel_level_index = TRUE)
rgb_to_lab(anal)
}
</code></pre>

<hr>
<h2 id='utils_dpi'>Utilities for image resolution</h2><span id='topic+utils_dpi'></span><span id='topic+dpi_to_cm'></span><span id='topic+cm_to_dpi'></span><span id='topic+pixels_to_cm'></span><span id='topic+cm_to_pixels'></span><span id='topic+npixels'></span><span id='topic+dpi'></span><span id='topic+distance'></span>

<h3>Description</h3>

<p>Provides useful conversions between size (cm), number of pixels (px) and
dots per inch (dpi).
</p>

<ul>
<li> <p><code><a href="#topic+dpi_to_cm">dpi_to_cm()</a></code> converts a known dpi value to centimeters.
</p>
</li>
<li> <p><code><a href="#topic+cm_to_dpi">cm_to_dpi()</a></code> converts a known centimeter values to dpi.
</p>
</li>
<li> <p><code><a href="#topic+pixels_to_cm">pixels_to_cm()</a></code> converts the number of pixels to centimeters, given a
known resolution (dpi).
</p>
</li>
<li> <p><code><a href="#topic+cm_to_pixels">cm_to_pixels()</a></code> converts a distance (cm) to number of pixels, given a
known resolution (dpi).
</p>
</li>
<li> <p><code><a href="#topic+distance">distance()</a></code> Computes the distance between two points in an image based on
the Pythagorean theorem.
</p>
</li>
<li> <p><code><a href="#topic+dpi">dpi()</a></code> An interactive function to compute the image resolution given a
known distance informed by the user. See more information in the <strong>Details</strong>
section.
</p>
</li>
<li> <p><code><a href="#topic+npixels">npixels()</a></code> returns the number of pixels of an image.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dpi_to_cm(dpi)

cm_to_dpi(cm)

pixels_to_cm(px, dpi)

cm_to_pixels(cm, dpi)

npixels(img)

dpi(img, viewer = get_pliman_viewer())

distance(img, viewer = get_pliman_viewer())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_dpi_+3A_dpi">dpi</code></td>
<td>
<p>The image resolution in dots per inch.</p>
</td></tr>
<tr><td><code id="utils_dpi_+3A_cm">cm</code></td>
<td>
<p>The size in centimeters.</p>
</td></tr>
<tr><td><code id="utils_dpi_+3A_px">px</code></td>
<td>
<p>The number of pixels.</p>
</td></tr>
<tr><td><code id="utils_dpi_+3A_img">img</code></td>
<td>
<p>An image object.</p>
</td></tr>
<tr><td><code id="utils_dpi_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+dpi">dpi()</a></code> only run in an interactive section. To compute the image
resolution (dpi) the user must use the left button mouse to create a line
of known distance. This can be done, for example, using a template with
known distance in the image (e.g., <code>la_leaves.jpg</code>).
</p>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+dpi_to_cm">dpi_to_cm()</a></code>, <code><a href="#topic+cm_to_dpi">cm_to_dpi()</a></code>, <code><a href="#topic+pixels_to_cm">pixels_to_cm()</a></code>, and <code><a href="#topic+cm_to_pixels">cm_to_pixels()</a></code> return
a numeric value or a vector of numeric values if the input data is a vector.
</p>
</li>
<li> <p><code><a href="#topic+dpi">dpi()</a></code> returns the computed dpi (dots per inch) given the known distance
informed in the plot.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
# Convert  dots per inch to centimeter
dpi_to_cm(c(1, 2, 3))

# Convert centimeters to dots per inch
cm_to_dpi(c(1, 2, 3))

# Convert centimeters to number of pixels with resolution of 96 dpi.
cm_to_pixels(c(1, 2, 3), 96)

# Convert number of pixels to cm with resolution of 96 dpi.
pixels_to_cm(c(1, 2, 3), 96)

if(isTRUE(interactive())){
#### compute the dpi (dots per inch) resolution ####
# only works in an interactive section
# objects_300dpi.jpg has a known resolution of 300 dpi
img &lt;- image_pliman("objects_300dpi.jpg")
# Higher square: 10 x 10 cm
# 1) Run the function dpi()
# 2) Use the left mouse button to create a line in the higher square
# 3) Declare a known distance (10 cm)
# 4) See the computed dpi
dpi(img)


img2 &lt;- image_pliman("la_leaves.jpg")
# square leaf sample (2 x 2 cm)
dpi(img2)
}
</code></pre>

<hr>
<h2 id='utils_file'>Utilities for file manipulation</h2><span id='topic+utils_file'></span><span id='topic+file_extension'></span><span id='topic+file_name'></span><span id='topic+file_dir'></span><span id='topic+manipulate_files'></span><span id='topic+pliman_indexes'></span><span id='topic+pliman_indexes_eq'></span>

<h3>Description</h3>


<ul>
<li> <p><code>file_extension()</code> Get the extension of a file.
</p>
</li>
<li> <p><code>file_name()</code> Get the name of a file.
</p>
</li>
<li> <p><code>file_dir()</code> Get or directory of a file
</p>
</li>
<li> <p><code>manipulate_files()</code> Manipulate files in a directory with options to rename
(insert prefix or suffix) and save the new files to the same or other provided
directory.
</p>
</li>
<li> <p><code>pliman_indexes()</code> Get the indexes available in pliman.
</p>
</li>
<li> <p><code>pliman_indexes_eq()</code> Get the equation of the indexes available
in pliman.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>file_extension(file)

file_name(file)

file_dir(file)

manipulate_files(
  pattern,
  dir = NULL,
  prefix = NULL,
  name = NULL,
  suffix = NULL,
  extension = NULL,
  sep = "",
  save_to = NULL,
  overwrite = FALSE,
  remove_original = FALSE,
  verbose = TRUE
)

pliman_indexes()

pliman_indexes_eq()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_file_+3A_file">file</code></td>
<td>
<p>The file name.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_pattern">pattern</code></td>
<td>
<p>A file name pattern.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_dir">dir</code></td>
<td>
<p>The working directory containing the files to be manipulated.
Defaults to the current working directory.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_prefix">prefix</code>, <code id="utils_file_+3A_suffix">suffix</code></td>
<td>
<p>A prefix or suffix to be added in the new file names.
Defaults to <code>NULL</code> (no prefix or suffix).</p>
</td></tr>
<tr><td><code id="utils_file_+3A_name">name</code></td>
<td>
<p>The name of the new files. Defaults to <code>NULL</code> (original names).
<code>name</code> can be either a single value or a character vector of the same
length as the number of files manipulated. If one value is informed, a
sequential vector of names will be created as &quot;<code>name</code>_1&quot;, &quot;<code>name</code>_2&quot;, and
so on.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_extension">extension</code></td>
<td>
<p>The new extension of the file. If not declared (default),
the original extensions will be used.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_sep">sep</code></td>
<td>
<p>An optional separator. Defaults to <code>""</code>.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_save_to">save_to</code></td>
<td>
<p>The directory to save the new files. Defaults to the current
working directory. If the file name of a file is not changed, nothing will
occur. If <code>save_to</code> refers to a subfolder in the current working directory,
the files will be saved to the given folder. In case of the folder doesn't
exist, it will be created. By default, the files will not be overwritten.
Set <code>overwrite = TRUE</code> to overwrite the files.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_overwrite">overwrite</code></td>
<td>
<p>Overwrite the files? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_remove_original">remove_original</code></td>
<td>
<p>Remove original files after manipulation? defaults to
<code>FALSE</code>. If <code>TRUE</code> the files in <code>pattern</code> will be removed.</p>
</td></tr>
<tr><td><code id="utils_file_+3A_verbose">verbose</code></td>
<td>
<p>If <code>FALSE</code>, the code is run silently.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>file_extension()</code>,  <code>file_name()</code>, and <code>file_dir()</code> return a character
string.
</p>
</li>
<li> <p><code>manipulate_files()</code> No return value. If <code>verbose == TRUE</code>, a message is
printed indicating which operation succeeded (or not) for each of the files
attempted.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
# get file name, directory and extension
file &lt;- "E:/my_folder/my_subfolder/image1.png"
file_dir(file)
file_name(file)
file_extension(file)

# manipulate files
dir &lt;- tempdir()
list.files(dir)
file.create(paste0(dir, "/test.txt"))
list.files(dir)
manipulate_files("test",
                 dir = paste0(dir, "\\"),
                prefix = "chang_",
                save_to = paste0(dir, "\\"),
                overwrite = TRUE)
list.files(dir)

</code></pre>

<hr>
<h2 id='utils_image'>Import and export images</h2><span id='topic+utils_image'></span><span id='topic+image_import'></span><span id='topic+image_export'></span><span id='topic+image_pliman'></span>

<h3>Description</h3>

<p>Import images from files and URLs and write images to files, possibly with
batch processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_import(
  img,
  ...,
  which = 1,
  pattern = NULL,
  path = NULL,
  resize = FALSE,
  plot = FALSE,
  nrow = NULL,
  ncol = NULL
)

image_export(img, name, prefix = "", extension = NULL, subfolder = NULL, ...)

image_pliman(img, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_image_+3A_img">img</code></td>
<td>

<ul>
<li><p> For <code>image_import()</code>, a character vector of file names or URLs.
</p>
</li>
<li><p> For <code>image_export()</code>, an Image object, an array or a list of images.
</p>
</li>
<li><p> For <code>image_pliman()</code>, a charactere value specifying the image example. See
<code>?pliman_images</code> for more details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_image_+3A_...">...</code></td>
<td>
<p>Alternative arguments passed to the corresponding functions from
the <code>jpeg</code>, <code>png</code>, and <code>tiff</code> packages.</p>
</td></tr>
<tr><td><code id="utils_image_+3A_which">which</code></td>
<td>
<p>logical scalar or integer vector to indicate which image are
imported if a TIFF files is informed. Defaults to <code>1</code> (the first image is
returned).</p>
</td></tr>
<tr><td><code id="utils_image_+3A_pattern">pattern</code></td>
<td>
<p>A pattern of file name used to identify images to be imported.
For example, if <code>pattern = "im"</code> all images in the current working
directory that the name matches the pattern (e.g., img1.-, image1.-, im2.-)
will be imported as a list. Providing any number as pattern (e.g., <code>pattern = "1"</code>) will select images that are named as 1.-, 2.-, and so on. An error
will be returned if the pattern matches any file that is not supported
(e.g., img1.pdf).</p>
</td></tr>
<tr><td><code id="utils_image_+3A_path">path</code></td>
<td>
<p>A character vector of full path names; the default corresponds to
the working directory, <code><a href="base.html#topic+getwd">getwd()</a></code>. It will overwrite (if given) the path
informed in <code>image</code> argument.</p>
</td></tr>
<tr><td><code id="utils_image_+3A_resize">resize</code></td>
<td>
<p>Resize the image after importation? Defaults to <code>FALSE</code>. Use a
numeric value of range 0-100 (proportion of the size of the original
image).</p>
</td></tr>
<tr><td><code id="utils_image_+3A_plot">plot</code></td>
<td>
<p>Plots the image after importing? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="utils_image_+3A_nrow">nrow</code>, <code id="utils_image_+3A_ncol">ncol</code></td>
<td>
<p>Passed on to <code><a href="#topic+image_combine">image_combine()</a></code>. The number of rows and
columns to use in the composite image when <code>plot = TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_image_+3A_name">name</code></td>
<td>
<p>An string specifying the name of the image. It can be either a
character with the image name (e.g., &quot;img1&quot;) or name and extension (e.g.,
&quot;img1.jpg&quot;). If none file extension is provided, the image will be saved as
a *.jpg file.</p>
</td></tr>
<tr><td><code id="utils_image_+3A_prefix">prefix</code></td>
<td>
<p>A prefix to include in the image name when exporting a list of
images. Defaults to <code>""</code>, i.e., no prefix.</p>
</td></tr>
<tr><td><code id="utils_image_+3A_extension">extension</code></td>
<td>
<p>When <code>image</code> is a list, <code>extension</code> can be used to define
the extension of exported files. This will overwrite the file extensions
given in <code>image</code>.</p>
</td></tr>
<tr><td><code id="utils_image_+3A_subfolder">subfolder</code></td>
<td>
<p>Optional character string indicating a subfolder within the
current working directory to save the image(s). If the folder doesn't
exist, it will be created.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>image_import()</code> returns a new <code>Image</code> object.
</p>
</li>
<li> <p><code>image_export()</code> returns an invisible vector of file names.
</p>
</li>
<li> <p><code>image_pliman()</code> returns a new <code>Image</code> object with the example image
required. If an empty call is used, the path to the <code>tmp_images</code> directory
installed with the package is returned.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
folder &lt;- image_pliman()
full_path &lt;- paste0(folder, "/sev_leaf.jpg")
(path &lt;- file_dir(full_path))
(file &lt;- basename(full_path))
image_import(img = full_path)
image_import(img = file, path = path)
</code></pre>

<hr>
<h2 id='utils_measures'>Utilities for object measures</h2><span id='topic+utils_measures'></span><span id='topic+get_measures'></span><span id='topic+plot_measures'></span>

<h3>Description</h3>


<ul>
<li> <p><code>get_measures()</code> computes object measures (area, perimeter, radius) by using
either a known resolution (dpi) or an object with known measurements.
</p>
</li>
<li> <p><code>plot_measures()</code> draws the object measures given in an object to the
current plot. The object identification (<code>"id"</code>) is drawn by default.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_measures(
  object,
  measure = NULL,
  id = NULL,
  dpi = NULL,
  sep = "\\_|-",
  verbose = TRUE,
  digits = 5
)

plot_measures(
  object,
  measure = "id",
  id = NULL,
  hjust = NULL,
  vjust = NULL,
  digits = 2,
  size = 0.9,
  col = "white",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_measures_+3A_object">object</code></td>
<td>
<p>An object computed with <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.</p>
</td></tr>
<tr><td><code id="utils_measures_+3A_measure">measure</code></td>
<td>
<p>For <code>plot_measures()</code>, a character string; for
<code>get_measures()</code>, a two-sided formula, e.g., <code>measure = area ~ 100</code>
indicating the known value of object <code>id</code>. The right-hand side is the known
value and the left-hand side can be one of the following.
</p>

<ul>
<li> <p><code>area</code> The known area of the object.
</p>
</li>
<li> <p><code>perimeter</code> The known perimeter of the object.
</p>
</li>
<li> <p><code>radius_mean</code> The known radius of the object.
</p>
</li>
<li> <p><code>radius_min</code> The known minimum radius of the object. If the object is a
square, then the <code>radius_min</code> of such object will be <code>L/2</code> where <code>L</code> is the
length of the square side.
</p>
</li>
<li> <p><code>radius_max</code> The known maximum radius of the object. If the object is a
square, then the <code>radius_max</code> of such object according to the Pythagorean
theorem will be <code style="white-space: pre;">&#8288;L x sqrt(2) / 2&#8288;</code> where <code>L</code> is the length of the square side.
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_measures_+3A_id">id</code></td>
<td>
<p>An object in the image to indicate a known value.</p>
</td></tr>
<tr><td><code id="utils_measures_+3A_dpi">dpi</code></td>
<td>
<p>A known resolution of the image in DPI (dots per inch).</p>
</td></tr>
<tr><td><code id="utils_measures_+3A_sep">sep</code></td>
<td>
<p>Regular expression to manage file names. The function combines in
the <code>merge</code> object the object measures (sum of area and mean of all the
other measures) of all images that share the same filename prefix, defined
as the part of the filename preceding the first hyphen (-) or underscore
(_) (no hyphen or underscore is required). For example, the measures of
images named <code style="white-space: pre;">&#8288;L1-1.jpeg&#8288;</code>, <code style="white-space: pre;">&#8288;L1-2.jpeg&#8288;</code>, and <code style="white-space: pre;">&#8288;L1-3.jpeg&#8288;</code> would be combined
into a single image information (L1). This feature allows the user to treat
multiple images as belonging to a single sample, if desired. Defaults to
<code>sep = "\\_|-"</code>.</p>
</td></tr>
<tr><td><code id="utils_measures_+3A_verbose">verbose</code></td>
<td>
<p>If <code>FALSE</code>, runs the code silently.</p>
</td></tr>
<tr><td><code id="utils_measures_+3A_digits">digits</code></td>
<td>
<p>The number of significant figures. Defaults to <code>2.</code></p>
</td></tr>
<tr><td><code id="utils_measures_+3A_hjust">hjust</code>, <code id="utils_measures_+3A_vjust">vjust</code></td>
<td>
<p>A numeric value to adjust the labels horizontally and
vertically. Positive values will move labels to right (hjust) and top
(vjust). Negative values will move the labels to left and bottom,
respectively.</p>
</td></tr>
<tr><td><code id="utils_measures_+3A_size">size</code></td>
<td>
<p>The size of the text. Defaults to <code>0.9</code>.</p>
</td></tr>
<tr><td><code id="utils_measures_+3A_col">col</code></td>
<td>
<p>The color of the text. Defaults to <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="utils_measures_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="graphics.html#topic+text">graphics::text()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>get_measures()</code>, if <code>measure</code> is informed, the pixel values will be
corrected by the value of the known object, given in the unit of the
right-hand side of <code>meae</code>. If <code>dpi</code> is informed, then all the measures
will be adjusted to the knosurwn <code>dpi</code>.
</p>
</li></ul>


<ul>
<li><p> If applied to an object of class <code>anal_obj</code>, returns a data frame with the
object <code>id</code> and the (corrected) measures.
</p>

<ul>
<li><p> If applied to an object of class <code>anal_obj_ls</code>, returns a list of class
<code>measures_ls</code>, with two objects: (i) <code>results</code>, a data frame containing
the identification of each image (img) and object within each image (id);
and (ii) <code>summary</code> a data frame containing the values for each image. If
more than one object is detected in a given image, the number of objects
(<code>n</code>), total area (<code>area_sum</code>), mean area (<code>area_mean</code>) and the standard
deviation of the area (<code>area_sd</code>) will be computed. For the other measures
(perimeter and radius), the mean values are presented.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>plot_measures()</code> returns a <code>NULL</code> object, drawing the text according to
the x and y coordinates of the objects in <code>object</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
img &lt;- image_pliman("objects_300dpi.jpg")
plot(img)
# Image with four objects with a known resolution of 300 dpi
# Higher square: 10 x 10 cm
# Lower square: 5 x 5 cm
# Rectangle: 4 x 2 cm
# Circle: 3 cm in diameter

# Count the objects using the blue band to segment the image
results &lt;-
   analyze_objects(img,
                 index = "B",
                 lower_noise = 0.1)
plot_measures(results, measure = "id")

# Get object measures by declaring the known resolution in dots per inch
(measures &lt;- get_measures(results, dpi = 300))

# Calculated diagonal of the object 1
# 10 * sqrt(2) = 14.14

# Observed diagonal of the object 1
measures[1, "radius_max"] * 2


# Get object measures by declaring the known area of object 1
get_measures(results,
             id = 1,
             area ~ 100)



</code></pre>

<hr>
<h2 id='utils_objects'>Utilities for working with image objects</h2><span id='topic+utils_objects'></span><span id='topic+object_coord'></span><span id='topic+object_contour'></span><span id='topic+object_isolate'></span><span id='topic+object_id'></span>

<h3>Description</h3>


<ul>
<li> <p><code>object_id()</code> get the object identification in an image.
</p>
</li>
<li> <p><code>object_coord()</code> get the object coordinates and (optionally) draw a
bounding rectangle around multiple objects in an image.
</p>
</li>
<li> <p><code>object_contour()</code> returns the coordinates (<code>x</code> and <code>y</code>) for the contours
of each object in the image.
</p>
</li>
<li> <p><code>object_isolate()</code> isolates an object from an image.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>object_coord(
  img,
  id = NULL,
  index = "NB",
  watershed = TRUE,
  invert = FALSE,
  filter = FALSE,
  fill_hull = FALSE,
  threshold = "Otsu",
  edge = 2,
  extension = NULL,
  tolerance = NULL,
  object_size = "medium",
  parallel = FALSE,
  workers = NULL,
  plot = TRUE
)

object_contour(
  img,
  pattern = NULL,
  dir_original = NULL,
  center = FALSE,
  index = "NB",
  invert = FALSE,
  filter = FALSE,
  fill_hull = FALSE,
  threshold = "Otsu",
  watershed = TRUE,
  extension = NULL,
  tolerance = NULL,
  object_size = "medium",
  parallel = FALSE,
  workers = NULL,
  plot = TRUE,
  verbose = TRUE
)

object_isolate(img, id = NULL, parallel = FALSE, workers = NULL, ...)

object_id(img, parallel = FALSE, workers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_objects_+3A_img">img</code></td>
<td>
<p>An image of class <code>Image</code> or a list of <code>Image</code> objects.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_id">id</code></td>
<td>

<ul>
<li><p> For <code>object_coord()</code>, a vector (or scalar) of object <code>id</code> to compute the
bounding rectangle. Object ids can be obtained with <code><a href="#topic+object_id">object_id()</a></code>. Set <code>id = "all"</code> to compute the coordinates for all objects in the image. If <code>id = NULL</code> (default) a bounding rectangle is drawn including all the objects.
</p>
</li>
<li><p> For <code>object_isolate()</code>, a scalar that identifies the object to be extracted.
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_objects_+3A_index">index</code></td>
<td>
<p>The index to produce a binary image used to compute bounding
rectangle coordinates. See <code><a href="#topic+image_binary">image_binary()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_watershed">watershed</code></td>
<td>
<p>If <code>TRUE</code> (default) performs watershed-based object
detection. This will detect objects even when they are touching one other.
If <code>FALSE</code>, all pixels for each connected set of foreground pixels are set
to a unique object. This is faster but is not able to segment touching
objects.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_invert">invert</code></td>
<td>
<p>Inverts the binary image, if desired. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image? See more at
<code><a href="#topic+image_filter">image_filter()</a></code>. Defaults to <code>FALSE</code>. Use a positive integer to define the
size of the median filtering. Larger values are effective at removing
noise, but adversely affect edges.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_fill_hull">fill_hull</code></td>
<td>
<p>Fill holes in the objects? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_threshold">threshold</code></td>
<td>
<p>By default (<code>threshold = "Otsu"</code>), a threshold value based
on Otsu's method is used to reduce the grayscale image to a binary image.
If a numeric value is informed, this value will be used as a threshold.
Inform any non-numeric value different than &quot;Otsu&quot; to iteratively chosen
the threshold based on a raster plot showing pixel intensity of the index.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_edge">edge</code></td>
<td>
<p>The number of pixels in the edge of the bounding rectangle.
Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_extension">extension</code>, <code id="utils_objects_+3A_tolerance">tolerance</code>, <code id="utils_objects_+3A_object_size">object_size</code></td>
<td>
<p>Controls the watershed segmentation of
objects in the image. See <code><a href="#topic+analyze_objects">analyze_objects()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time when <code>image</code> is a list. The number of sections is set
up to 50% of available cores.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_plot">plot</code></td>
<td>
<p>Shows the image with bounding rectangles? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_pattern">pattern</code></td>
<td>
<p>A pattern of file name used to identify images to be imported.
For example, if <code>pattern = "im"</code> all images in the current working directory
that the name matches the pattern (e.g., img1.-, image1.-, im2.-) will be
imported as a list. Providing any number as pattern (e.g., <code>pattern = "1"</code>)
will select images that are named as 1.-, 2.-, and so on. An error will be
returned if the pattern matches any file that is not supported (e.g.,
img1.pdf).</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_dir_original">dir_original</code></td>
<td>
<p>The directory containing the original images. Defaults
to <code>NULL</code>, which means that the current working directory will be
considered.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_center">center</code></td>
<td>
<p>If <code>TRUE</code> returns the object contours centered on the origin.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="utils_objects_+3A_...">...</code></td>
<td>

<ul>
<li><p> For <code>object_isolate()</code>, further arguments passed on to <code><a href="#topic+object_coord">object_coord()</a></code>.
</p>
</li>
<li><p> For <code>object_id()</code>, further arguments passed on to <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>object_id()</code> An image of class <code>"Image"</code> containing the object's
identification.
</p>
</li>
<li> <p><code>object_coord()</code> A list with the coordinates for the bounding rectangles.
If <code>id = "all"</code> or a numeric vector, a list with a vector of coordinates is
returned.
</p>
</li>
<li> <p><code>object_isolate()</code> An image of class <code>"Image"</code> containing the isolated
object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
img &lt;- image_pliman("la_leaves.jpg")
# Get the object's (leaves) identification
object_id(img)

# Get the coordinates and draw a bounding rectangle around leaves 1 and 3
object_coord(img, id = c(1, 3))

# Isolate leaf 3
isolated &lt;- object_isolate(img, id = 3)
plot(isolated)


</code></pre>

<hr>
<h2 id='utils_pca'>Utilities for Principal Component Axis analysis</h2><span id='topic+utils_pca'></span><span id='topic+pca'></span><span id='topic+get_biplot'></span><span id='topic+plot.pca'></span>

<h3>Description</h3>


<ul>
<li> <p><code>pca()</code> Computes a Principal Component Analysis. It wrappers
<code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>, but returns more results such as data, scores,
contributions and quality of measurements for individuals and variables.
</p>
</li>
<li> <p><code>get_biplot()</code>: Produces a biplot for an object computed with <code>pca()</code>.
</p>
</li>
<li> <p><code>plot.pca()</code>: Produces several types of plots, depending on the <code>type</code> and <code>which</code>
arguments.
</p>

<ul>
<li> <p><code>type = "var"</code> Produces a barplot with the contribution (<code>which =  "contrib"</code>), qualitity of adjustment <code>which = "cos2"</code>, and a scatter plot
with coordinates (<code>which = "coord"</code>) for the variables.
</p>
</li>
<li> <p><code>type = "ind"</code> Produces a barplot with the contribution (<code>which =  "contrib"</code>), qualitity of adjustment <code>which = "cos2"</code>, and a scatter plot
with coordinates (<code>which = "coord"</code>) for the individuals.
</p>
</li>
<li> <p><code>type = "biplot"</code> Produces a biplot.
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>pca(x, scale = TRUE)

get_biplot(
  x,
  axes = c(1, 2),
  show = c("both"),
  show_ind_id = TRUE,
  show_unit_circle = TRUE,
  expand = NULL
)

## S3 method for class 'pca'
plot(x, type = "var", which = "contrib", axis = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_pca_+3A_x">x</code></td>
<td>

<ul>
<li><p> For <code>pca()</code>, a numeric or complex matrix (or data frame) which provides the
data for the principal components analysis.
</p>
</li>
<li><p> For <code>plot.pca()</code> and <code>get_biplot()</code>, an object computed with <code>pca()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_pca_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating whether the variables should be
scaled to have unit variance before the analysis takes place. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_axes">axes</code></td>
<td>
<p>The principal component axes to plot. Defaults to <code>axes = c(1, 2)</code>,
i.e., the first and second interaction principal component axis.</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_show">show</code></td>
<td>
<p>Which to show in the biplot. Defaults to <code>"both"</code> (both variables
and individuals). One can also use <code>"var"</code>, or <code>"ind"</code>.</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_show_ind_id">show_ind_id</code></td>
<td>
<p>Shows the labels for individuals? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_show_unit_circle">show_unit_circle</code></td>
<td>
<p>Shows the unit variance circle? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_expand">expand</code></td>
<td>
<p>An expansion factor to apply when plotting the second set of
points relative to the first. This can be used to tweak the scaling of the
two sets to a physically comparable scale. Setting to <code>TRUE</code> will
automatically compute the expansion factor. Alternatively, a numeric value
can be informed.</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_type">type</code></td>
<td>
<p>One of <code>"var"</code> (to plot variables), <code>"ind"</code> (to plot
individuals), or <code>"biplot"</code> to create a biplot.</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_which">which</code></td>
<td>
<p>Which measure to plot. Either <code>which = "contribution"</code>
(default),  <code>which = "cos2"</code> (quality of representation), or <code>which = "coord"</code> (coordinates)</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_axis">axis</code></td>
<td>
<p>The axist to plot the contribution/cos2. Defaults to 1.</p>
</td></tr>
<tr><td><code id="utils_pca_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+get_biplot">get_biplot()</a></code> when <code>type = "biplot"</code>. Otherwise, When <code>which = "coord"</code>, further arguments passed on
to <code><a href="#topic+get_biplot">get_biplot()</a></code>. When <code>which = "contrib"</code>, or <code>which = "cos2"</code> further
arguments passed on to <code><a href="graphics.html#topic+barplot">graphics::barplot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>pca()</code> returns a list including:
</p>

<ul>
<li> <p><code>data</code>: The raw data used to compute the PCA.
</p>
</li>
<li> <p><code>variances</code>: Variances (eigenvalues), and proportion of explained
variance for each component.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;center,scale&#8288;</code>: the centering and scaling used.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;ind,var&#8288;</code> A list with the following objects for individuals/variables, respectively.
</p>
</li>
<li> <p><code>coord</code>: coordinates for the individuals/variables (loadings * the
component standard deviations)
</p>
</li>
<li> <p><code>cos2</code>: cos2 for the individuals/variables (coord^2)
</p>
</li>
<li> <p><code>contrib</code>: The contribution  (in percentage) of a variable to a given
principal component: (cos2 * 100) / (total cos2 of the component)
</p>
</li></ul>

</li>
<li> <p><code>plot.pca()</code> returns a list with the coordinates used.
</p>
</li>
<li> <p><code>get_biplot()</code> returns a <code>NULL</code> object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
pc &lt;- pca(mtcars[1:10 ,1:6])
plot(pc)
plot(pc, type = "ind")
plot(pc, type = "var", which = "coord")
plot(pc, type = "ind", which = "coord")
plot(pc, type = "biplot")
</code></pre>

<hr>
<h2 id='utils_pick'>Utilities for picking up points in an image</h2><span id='topic+utils_pick'></span><span id='topic+pick_count'></span><span id='topic+pick_coords'></span><span id='topic+pick_rgb'></span><span id='topic+pick_palette'></span>

<h3>Description</h3>


<ul>
<li> <p><code>pick_count()</code> opens an interactive section where the user will be able to
click in the image to count objects (points) manually. In each mouse click, a
point is drawn and an upward counter is shown in the console. After <code>n</code>
counts or after the user press Esc, the interactive process is terminated and
the number of counts is returned.
</p>
</li>
<li> <p><code>pick_coord()</code> Picks coordinates from the image
</p>
</li>
<li> <p><code>pick_palette()</code>  creates an image palette by picking up color point(s)
from the image.
</p>
</li>
<li> <p><code>pick_rgb()</code> Picks up the RGB values from selected point(s) in the image.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>pick_count(
  img,
  n = Inf,
  col = "red",
  viewer = get_pliman_viewer(),
  size = 0.8,
  plot = TRUE,
  verbose = TRUE
)

pick_coords(
  img,
  n = Inf,
  col = "red",
  viewer = get_pliman_viewer(),
  size = 0.8,
  verbose = TRUE
)

pick_rgb(
  img,
  n = Inf,
  col = "red",
  viewer = get_pliman_viewer(),
  size = 0.8,
  plot = TRUE,
  verbose = TRUE
)

pick_palette(
  img,
  n = Inf,
  r = 1,
  shape = "box",
  viewer = get_pliman_viewer(),
  show = "rgb",
  title = "Pick colors in the image",
  index = "B",
  random = TRUE,
  width = 100,
  height = 100,
  col = "red",
  size = 0.8,
  plot = TRUE,
  palette = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_pick_+3A_img">img</code></td>
<td>
<p>An <code>Image</code> object.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_n">n</code></td>
<td>
<p>The number of points of the <code style="white-space: pre;">&#8288;pick_*&#8288;</code> function. Defaults to <code>Inf</code>.
This means that picking will run until the user press Esc.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_col">col</code>, <code id="utils_pick_+3A_size">size</code></td>
<td>
<p>The color and size for the marker point.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_plot">plot</code></td>
<td>
<p>Call a new <code>plot(img)</code> before processing? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) shows a counter in the console.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_r">r</code></td>
<td>
<p>The radius of neighborhood pixels. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_shape">shape</code></td>
<td>
<p>A character vector indicating the shape of the brush around the
selected pixel. It  can be <code>"box"</code>, <code>"disc"</code>, <code>"diamond"</code>, <code>"Gaussian"</code> or
<code>"line"</code>. Defaults to <code>"box"</code>. In this case, if <code>'r = 1'</code>, all the 8
surrounding pixels are sampled. Setting to <code>"disc"</code> and increasing the
radius (<code>r</code>) will select surrounding pixels towards the format of a sphere
around the selected pixel.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_show">show</code></td>
<td>
<p>How to plot in mapview viewer, either <code style="white-space: pre;">&#8288;'rgb&#8288;</code> or <code>'index'</code>.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_title">title</code></td>
<td>
<p>The title of the map view when <code>viewer</code>is used.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_index">index</code></td>
<td>
<p>The index to use for the index view. Defaults to 'B'.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_random">random</code></td>
<td>
<p>Randomize the selected pixels? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_width">width</code>, <code id="utils_pick_+3A_height">height</code></td>
<td>
<p>The width and height of the generated palette. Defaults
to <code>100</code> for both, i.e., a square image of 100 x 100.</p>
</td></tr>
<tr><td><code id="utils_pick_+3A_palette">palette</code></td>
<td>
<p>Plot the generated palette? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>pick_count()</code> returns <code>data.frame</code> with the <code>x</code> and <code>y</code> coordinates of the
selected point(x).
</p>
</li>
<li> <p><code>pick_rgb()</code> returns a <code>data.frame</code> with the R, G, and B values of the
selected point(s).
</p>
</li>
<li> <p><code>pick_palette()</code> returns an object of class <code>Image</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")

# start a counting process
pick_count(img)

# get rgb from point(s)
pick_rgb(img)

# create a palette from point(s)
pick_palette(img)
}
</code></pre>

<hr>
<h2 id='utils_polygon'>Utilities for Polygons</h2><span id='topic+utils_polygon'></span><span id='topic+poly_check'></span><span id='topic+poly_is_closed'></span><span id='topic+poly_close'></span><span id='topic+poly_unclose'></span><span id='topic+poly_angles'></span><span id='topic+poly_limits'></span><span id='topic+conv_hull'></span><span id='topic+conv_hull_unified'></span><span id='topic+poly_area'></span><span id='topic+poly_slide'></span><span id='topic+poly_distpts'></span><span id='topic+poly_centdist'></span><span id='topic+poly_perimeter'></span><span id='topic+poly_rotate'></span><span id='topic+poly_align'></span><span id='topic+poly_center'></span><span id='topic+poly_lw'></span><span id='topic+poly_eccentricity'></span><span id='topic+poly_convexity'></span><span id='topic+poly_caliper'></span><span id='topic+poly_elongation'></span><span id='topic+poly_solidity'></span><span id='topic+poly_flip_y'></span><span id='topic+poly_flip_x'></span><span id='topic+poly_sample'></span><span id='topic+poly_sample_prop'></span><span id='topic+poly_jitter'></span><span id='topic+poly_circularity'></span><span id='topic+poly_circularity_norm'></span><span id='topic+poly_circularity_haralick'></span><span id='topic+poly_mass'></span><span id='topic+poly_spline'></span><span id='topic+poly_smooth'></span><span id='topic+poly_measures'></span>

<h3>Description</h3>

<p>Several useful functions for analyzing polygons. All of them are based on a
set of coordinate points that describe the edge of the object(s). If a list
of polygons is provided, it loops through the list and computes what is
needed for each element of the list.
</p>

<ul>
<li><p> Polygon measures
</p>

<ul>
<li> <p><code>conv_hull()</code> Computes the convex hull of a set of points.
</p>
</li>
<li> <p><code>conv_hull_unified()</code> Computes the convex hull of a set of points. Compared
to <code>conv_hull()</code>, <code>conv_hull_unified()</code> binds (unifies) the coordinates when
x is a list of coordinates.
</p>
</li>
<li> <p><code>poly_area()</code> Computes the area of a polygon given by the vertices in the
vectors x and y using the Shoelace formula, as follows (Lee and Lim,
2017): </p>
<p style="text-align: center;"><code class="reqn">A=\frac{1}{2}\left|\sum_{i=1}^{n}\left(x_{i} y_{i+1}-x_{i+1}
y_{i}\right)\right|</code>
</p>
<p> where <code>x</code> and <code>y</code> are the coordinates that form the
corners of a polygon, and <code>n</code> is the number of coordinates.
</p>
</li>
<li> <p><code>poly_angles()</code> Calculates the internal angles of the polygon using the
law of cosines.
</p>
</li>
<li> <p><code>poly_lw()</code> Returns the length and width of a polygon based on its
alignment to the y-axis (with poly_align()). The length is defined as the
range along the x-axis, and the width is defined as the range on the y-axis.
</p>
</li>
<li> <p><code>poly_mass()</code> Computes the center of mass of a polygon given by the
vertices in the vectors in <code>x</code>.
</p>
</li>
<li> <p><code>poly_solidity()</code> Computes the solidity of a shape as the ratio of
the shape area and the convex hull area.
</p>
</li></ul>

</li>
<li><p> Perimeter measures
</p>

<ul>
<li> <p><code>poly_slide()</code> Slides the coordinates of a polygon given by the vertices
in the vectors x and y so that the id-th point becomes the first one.
</p>
</li>
<li> <p><code>poly_distpts()</code> Computes the Euclidean distance between every point
of a polygon given by the vertices in the vectors x and y.
</p>
</li>
<li> <p><code>poly_centdist()</code> Computes the Euclidean distance between every point on
the perimeter and the centroid of the object.
</p>
</li>
<li> <p><code>poly_perimeter()</code> Computes the perimeter of a polygon given by the
vertices in the vectors x and y.
</p>
</li>
<li> <p><code>poly_caliper()</code> Computes the caliper (also called the Feret's diameter)
of a polygon given by the vertices in the vectors x and y.
</p>
</li></ul>

</li>
<li><p> Circularity measures (Montero et al. 2009).
</p>

<ul>
<li> <p><code>poly_circularity()</code> computes the circularity (C), also called shape
compactness or roundness measure, of an object. It is given by <code>C = P^2 / A</code>,
where P is the perimeter and A is the area of the object.
</p>
</li>
<li> <p><code>poly_circularity_norm()</code> computes the normalized circularity (Cn), which
is unity for a circle. This measure is invariant under translation,
rotation, scaling transformations, and is dimensionless. It is given by:
<code>Cn = P^2 / 4*pi*A</code>.
</p>
</li>
<li> <p><code>poly_circularity_haralick()</code> computes Haralick's circularity (CH). The
method is based on computing all Euclidean distances from the object
centroid to each boundary pixel. With this set of distances, the mean (<code>m</code>)
and the standard deviation (<code>sd</code>) are computed. These statistical parameters
are used to calculate the circularity, CH, of a shape as <code>CH = m/sd</code>.
</p>
</li>
<li> <p><code>poly_convexity()</code> computes the convexity of a shape using the ratio
between the perimeter of the convex hull and the perimeter of the polygon.
</p>
</li>
<li> <p><code>poly_eccentricity()</code> computes the eccentricity of a shape using the
ratio of the eigenvalues (inertia axes of coordinates).
</p>
</li>
<li> <p><code>poly_elongation()</code> computes the elongation of a shape as <code>1 - width / length</code>.
</p>
</li></ul>

</li>
<li><p> Utilities for polygons
</p>

<ul>
<li> <p><code>poly_check()</code> Checks a set of coordinate points and returns a matrix
with x and y columns.
</p>
</li>
<li> <p><code>poly_is_closed()</code> Returns a logical value indicating if a polygon is
closed.
</p>
</li>
<li> <p><code>poly_close()</code> and <code>poly_unclose()</code> close and unclose a polygon,
respectively.
</p>
</li>
<li> <p><code>poly_rotate() </code>Rotates the polygon coordinates by an angle (0-360
degrees) in the counterclockwise direction.
</p>
</li>
<li> <p><code>poly_flip_x()</code>, <code>poly_flip_y()</code> flip shapes along the x-axis and y-axis,
respectively.
</p>
</li>
<li> <p><code>poly_align()</code> Aligns the coordinates along their longer axis using the
var-cov matrix and eigen values.
</p>
</li>
<li> <p><code>poly_center()</code> Centers the coordinates on the origin.
</p>
</li>
<li> <p><code>poly_sample()</code> Samples n coordinates from existing points. Defaults
to 50.
</p>
</li>
<li> <p><code>poly_sample_prop()</code> Samples a proportion of coordinates from existing
points. Defaults to 0.1.
</p>
</li>
<li> <p><code>poly_spline()</code> Interpolates the polygon contour.
</p>
</li>
<li> <p><code>poly_smooth()</code> Smooths the polygon contour using a simple moving average.
</p>
</li>
<li> <p><code>poly_jitter()</code> Adds a small amount of noise to a set of point
coordinates. See <code><a href="base.html#topic+jitter">base::jitter()</a></code> for more details.
</p>
</li></ul>

</li>
<li> <p><code>poly_measures()</code> Is a wrapper around the <code style="white-space: pre;">&#8288;poly_*()&#8288;</code> functions.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>poly_check(x)

poly_is_closed(x)

poly_close(x)

poly_unclose(x)

poly_angles(x)

poly_limits(x)

conv_hull(x)

conv_hull_unified(x)

poly_area(x)

poly_slide(x, fp = 1)

poly_distpts(x)

poly_centdist(x)

poly_perimeter(x)

poly_rotate(x, angle, plot = TRUE)

poly_align(x, plot = TRUE)

poly_center(x, plot = TRUE)

poly_lw(x)

poly_eccentricity(x)

poly_convexity(x)

poly_caliper(x)

poly_elongation(x)

poly_solidity(x)

poly_flip_y(x)

poly_flip_x(x)

poly_sample(x, n = 50)

poly_sample_prop(x, prop = 0.1)

poly_jitter(x, noise_x = 1, noise_y = 1, plot = TRUE)

poly_circularity(x)

poly_circularity_norm(x)

poly_circularity_haralick(x)

poly_mass(x)

poly_spline(x, vertices = 100, k = 2)

poly_smooth(x, niter = 10, n = NULL, prop = NULL, plot = TRUE)

poly_measures(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_polygon_+3A_x">x</code></td>
<td>
<p>A 2-column matrix with the <code>x</code> and <code>y</code> coordinates. If <code>x</code> is a list
of vector coordinates, the function will be applied to each element using
<code><a href="base.html#topic+lapply">base::lapply()</a></code> or <code><a href="base.html#topic+lapply">base::sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="utils_polygon_+3A_fp">fp</code></td>
<td>
<p>The ID of the point that will become the new first point. Defaults
to 1.</p>
</td></tr>
<tr><td><code id="utils_polygon_+3A_angle">angle</code></td>
<td>
<p>The angle (0-360) to rotate the object.</p>
</td></tr>
<tr><td><code id="utils_polygon_+3A_plot">plot</code></td>
<td>
<p>Should the object be plotted? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_polygon_+3A_n">n</code>, <code id="utils_polygon_+3A_prop">prop</code></td>
<td>
<p>The number and proportion of coordinates to sample from the
perimeter coordinates. In<code> poly_smooth()</code>, these arguments can be used to
sample points from the object's perimeter before smoothing.</p>
</td></tr>
<tr><td><code id="utils_polygon_+3A_noise_x">noise_x</code>, <code id="utils_polygon_+3A_noise_y">noise_y</code></td>
<td>
<p>A numeric factor to define the noise added to the <code>x</code>
and <code>y</code> axes, respectively. See <code><a href="base.html#topic+jitter">base::jitter()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="utils_polygon_+3A_vertices">vertices</code></td>
<td>
<p>The number of spline vertices to create.</p>
</td></tr>
<tr><td><code id="utils_polygon_+3A_k">k</code></td>
<td>
<p>The number of points to wrap around the ends to obtain a smooth
periodic spline.</p>
</td></tr>
<tr><td><code id="utils_polygon_+3A_niter">niter</code></td>
<td>
<p>An integer indicating the number of smoothing iterations.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>conv_hull()</code> and <code>poly_spline()</code> returns a matrix with <code>x</code> and <code>y</code>
coordinates for the convex hull/smooth line in clockwise order. If <code>x</code> is a
list, a list of points is returned.
</p>
</li>
<li> <p><code>poly_area()</code> returns a <code>double</code>, or a numeric vector if <code>x</code> is a list of
vector points.
</p>
</li>
<li> <p><code>poly_mass()</code> returns a <code>data.frame</code> containing the coordinates for the
center of mass, as well as for the maximum and minimum distance from contour
to the center of mass.
</p>
</li>
<li> <p><code>poly_slides()</code>, <code>poly_distpts()</code>, <code>poly_spline()</code>, <code>poly_close()</code>,
<code>poly_unclose()</code>, <code>poly_rotate()</code>, <code>poly_jitter()</code>, <code>poly_sample()</code>,
<code>poly_sample_prop()</code>, and <code>poly_measures</code> returns a <code>data.frame</code>.
</p>
</li>
<li> <p><code>poly_perimeter()</code>, <code>poly_lw()</code>, <code>poly_eccentricity()</code>,
<code>poly_convexity()</code>, <code>poly_caliper()</code>, <code>poly_elongation()</code>,
<code>poly_circularity_norm()</code>, <code>poly_circularity_haralick()</code> returns a <code>double</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Lee, Y., &amp; Lim, W. (2017). Shoelace Formula: Connecting the Area of a
Polygon and the Vector Cross Product. The Mathematics Teacher, 110(8),
631636. <a href="https://doi.org/10.5951/mathteacher.110.8.0631">doi:10.5951/mathteacher.110.8.0631</a>
</p>
<p>Montero, R. S., Bribiesca, E., Santiago, R., &amp; Bribiesca, E. (2009). State
of the Art of Compactness and Circularity Measures. International
Mathematical Forum, 4(27), 13051335.
</p>
<p>Chen, C.H., and P.S.P. Wang. 2005. Handbook of Pattern Recognition and
Computer Vision. 3rd ed. World Scientific.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
# A 2 x 2 square
df &lt;- draw_square(side = 2)

# square area
poly_area(df)

# polygon perimeter
poly_perimeter(df)

# center of mass of the square
cm &lt;- poly_mass(df)
plot_mass(cm)

# The convex hull will be the vertices of the square
(conv_square &lt;- conv_hull(df) |&gt; poly_close())
plot_contour(conv_square,
             col = "blue",
             lwd = 6)
poly_area(conv_square)


################### Example with a polygon ##################
x &lt;- c(0, 1,   2, 3,  5, 2, -1, 0, 0)
y &lt;- c(5, 6.5, 7, 3,  1, 1,  0, 2, 5)
df_poly &lt;- cbind(x, y)

# area of the polygon
plot_polygon(df_poly, fill = "red")
poly_area(df_poly)

# perimeter of the polygon
poly_perimeter(df_poly)

# center of mass of polygon
cm &lt;- poly_mass(df_poly)
plot_mass(cm,  col = "blue")

# vertices of the convex hull
(conv_poly &lt;- conv_hull(df_poly))

# area of the convex hull
poly_area(conv_poly)

plot_polygon(conv_poly,
             fill = "red",
             alpha = 0.2,
             add = TRUE)


############ example of circularity measures ################
tri &lt;- draw_circle(n = 200, plot = FALSE)
plot_polygon(tri, aspect_ratio = 1)
poly_circularity_norm(tri)

set.seed(1)
tri2 &lt;-
  draw_circle(n = 200, plot = FALSE) |&gt;
  poly_jitter(noise_x = 100, noise_y = 100, plot = FALSE)

plot_polygon(tri2, aspect_ratio = 1)
poly_circularity_norm(tri2)

</code></pre>

<hr>
<h2 id='utils_polygon_plot'>Utilities for plotting polygons</h2><span id='topic+utils_polygon_plot'></span><span id='topic+plot_contour'></span><span id='topic+plot_polygon'></span><span id='topic+plot_mass'></span><span id='topic+plot_ellipse'></span>

<h3>Description</h3>


<ul>
<li> <p><code>plot_contour()</code> Plot contour lines.
</p>
</li>
<li> <p><code>plot_polygon()</code> Plots a polygon describing the objects.
</p>
</li>
<li> <p><code>plot_mass()</code> Plots the center of mass along with maximum and minimum
radius.
</p>
</li>
<li> <p><code>plot_ellipse()</code> Plots an ellipse that fits the major and minor axis for
each object.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plot_contour(x, id = NULL, col = "black", lwd = 1, ...)

plot_polygon(
  x,
  fill = "gray",
  random_fill = TRUE,
  points = FALSE,
  merge = TRUE,
  border = "black",
  alpha = 1,
  add = FALSE,
  nrow = NULL,
  ncol = NULL,
  aspect_ratio = 1,
  show_id = TRUE,
  xlim = NULL,
  ylim = NULL,
  ...
)

plot_mass(x, id = NULL, col = "black", cex = 1, lwd = 1)

plot_ellipse(object, id = NULL, col = "black", lwd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_polygon_plot_+3A_x">x</code></td>
<td>
<p>A 2-column matrix with the <code>x</code> and <code>y</code> coordinates.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_id">id</code></td>
<td>
<p>The object identification (numeric) to plot the contour/ellipse. By
default (<code>id = NULL</code>), the contour is plotted to all objects.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_col">col</code>, <code id="utils_polygon_plot_+3A_lwd">lwd</code>, <code id="utils_polygon_plot_+3A_cex">cex</code></td>
<td>
<p>The color, width of the lines, and size of point,
respectively.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_...">...</code></td>
<td>

<ul>
<li><p> For <code>plot_contour()</code> and <code>plot_ellipse()</code> further arguments passed on to
<code><a href="graphics.html#topic+lines">graphics::lines()</a></code>.
</p>
</li>
<li><p> For <code>plot_mass()</code>, further arguments passed on to <code><a href="graphics.html#topic+points">graphics::points()</a></code>.
</p>
</li>
<li><p> For <code>plot_polygon()</code>, further arguments passed on to
<code><a href="graphics.html#topic+polygon">graphics::polygon()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_fill">fill</code>, <code id="utils_polygon_plot_+3A_border">border</code>, <code id="utils_polygon_plot_+3A_alpha">alpha</code></td>
<td>
<p>The color to fill the polygon, the color of the
polygon's border, and the alpha transparency (1 opaque, 0 transparent).</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_random_fill">random_fill</code></td>
<td>
<p>Fill multiple objects with random colors? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_points">points</code></td>
<td>
<p>Plot the points? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_merge">merge</code></td>
<td>
<p>Merge multiple objects into a single plot? Defaults to <code>TRUE</code>.
If <code>FALSE</code>, a single call <code>plot()</code> will be used for each objects. Use
<code>nrow</code> and <code>ncol</code> to control the number of rows and columns of the window.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_add">add</code></td>
<td>
<p>Add the current plot to a previous one? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_nrow">nrow</code>, <code id="utils_polygon_plot_+3A_ncol">ncol</code></td>
<td>
<p>The number of rows and columns to use in the composite
image. Defaults to <code>NULL</code>, i.e., a square grid is produced.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>The x/y aspect ratio. Defaults to <code>1</code>. This will set up
the window so that one data unit in the y direction is equal to one data
unit in the x direction. Set <code>aspect_ratio = NULL</code> to fit the object to the
window size.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_show_id">show_id</code></td>
<td>
<p>Shows the object id? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_xlim">xlim</code>, <code id="utils_polygon_plot_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 (min; max) indicating the range
of <code>x</code> and <code>y</code>-axes.</p>
</td></tr>
<tr><td><code id="utils_polygon_plot_+3A_object">object</code></td>
<td>
<p>An object computed with <code><a href="#topic+analyze_objects">analyze_objects()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_polygon(contours)
plot_contour(contours[[1]], id = 6, col = "red", lwd = 3)
</code></pre>

<hr>
<h2 id='utils_rows_cols'>Utilities for handling with rows and columns</h2><span id='topic+utils_rows_cols'></span><span id='topic+column_to_rownames'></span><span id='topic+rownames_to_column'></span><span id='topic+remove_rownames'></span><span id='topic+round_cols'></span>

<h3>Description</h3>


<ul>
<li> <p><code>columns_to_rownames()</code>: Move a column of <code>.data</code> to its row
names.
</p>
</li>
<li> <p><code>rownames_to_column()</code>: Move the row names of <code>.data</code> to a new
column.
</p>
</li>
<li> <p><code>remove_rownames()</code>: Remove the row names of <code>.data</code>.
</p>
</li>
<li> <p><code>round_cols()</code> Rounds the values of all numeric variables to the specified
number of decimal places (default 2).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>column_to_rownames(.data, var = "rowname")

rownames_to_column(.data, var = "rowname")

remove_rownames(.data)

round_cols(.data, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_rows_cols_+3A_.data">.data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="utils_rows_cols_+3A_var">var</code></td>
<td>
<p>Name of column to use for rownames.</p>
</td></tr>
<tr><td><code id="utils_rows_cols_+3A_digits">digits</code></td>
<td>
<p>The number of significant figures. Defaults to <code>2.</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pliman)
iris2 &lt;- iris |&gt; rownames_to_column()
head(iris2)
iris2$rowname &lt;- paste0("r", iris2$rowname)
iris2 |&gt; column_to_rownames("rowname") |&gt; head()


</code></pre>

<hr>
<h2 id='utils_shapes'>Utilities for drawing coordinates of known shapes</h2><span id='topic+utils_shapes'></span><span id='topic+draw_circle'></span><span id='topic+draw_square'></span><span id='topic+draw_rectangle'></span><span id='topic+draw_trian_equi'></span><span id='topic+draw_trian_rect'></span><span id='topic+draw_n_tagon'></span>

<h3>Description</h3>

<p>The functions computes the coordinates of common shapes such as
squares triangles, rectangles and circles.
</p>

<ul>
<li> <p><code>draw_circle()</code> Draws a perfect circle with a desired radius.
</p>
</li>
<li> <p><code>draw_square()</code> Draws a square with a desired side.
</p>
</li>
<li> <p><code>draw_rectangle()</code> Draws a rectangle given two desired sides.
</p>
</li>
<li> <p><code>draw_trian_equi()</code> Draws an equilateral triangle with a desired side.
</p>
</li>
<li> <p><code>draw_trian_rect()</code> Draws a triangle rectangle given two cathetus.
</p>
</li>
<li> <p><code>draw_n_tagon()</code> Draws polygons with <code>n</code> sides
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>draw_circle(radius = 1, n = 1000, plot = TRUE)

draw_square(side = 2, plot = TRUE)

draw_rectangle(side1 = 2, side2 = 3, plot = TRUE)

draw_trian_equi(side = 2, plot = TRUE)

draw_trian_rect(cat1 = 1, cat2 = 2, plot = TRUE)

draw_n_tagon(n, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_shapes_+3A_radius">radius</code></td>
<td>
<p>The radius of the circle. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="utils_shapes_+3A_n">n</code></td>
<td>
<p>The number of sides in the <code>n</code>-tagon.</p>
</td></tr>
<tr><td><code id="utils_shapes_+3A_plot">plot</code></td>
<td>
<p>Plots the result? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="utils_shapes_+3A_side">side</code></td>
<td>
<p>The side of the square/equilateral triangle. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="utils_shapes_+3A_side1">side1</code>, <code id="utils_shapes_+3A_side2">side2</code></td>
<td>
<p>The first and second sides of the rectangle. Defaults to
<code>2</code> and <code>3</code>, respectively.</p>
</td></tr>
<tr><td><code id="utils_shapes_+3A_cat1">cat1</code>, <code id="utils_shapes_+3A_cat2">cat2</code></td>
<td>
<p>The first and second cathetus of the right triangle.
Defaults to <code>1</code>, and <code>2</code>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the <code>x</code> and <code>y</code> coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########## An example of a circle ##########
library(pliman)
radius &lt;- 3
circ &lt;- draw_circle(radius = radius)

# area
pi * radius ^ 2
poly_area(circ)

# perimeter
2 * pi * radius
poly_perimeter(circ)

############ An example of a square ############
side &lt;- 2
(square &lt;- draw_square(side = side))

# area
side ^ 2
poly_area(square)

# perimeter
side * 4
poly_perimeter(square)

############ An example of a rectangle ############
side1 &lt;- 2
side2 &lt;- 3
(rect &lt;- draw_rectangle())

# area
poly_area(rect)

# perimeter
poly_perimeter(rect)
###########  An example of an equilateral triangle #########
side &lt;- 1 # defaults
(trig &lt;- draw_trian_equi(side = side))

### area (b*h / 2)
# height of the triangle
(h &lt;- (side * sqrt(3)) / 2)
side * h / 2

poly_area(trig)

### perimeter (side * 3)
poly_perimeter(trig)

########### An example of a rectangle triangle ##########
cat1 &lt;- 2
cat2 &lt;- 3
(df &lt;- draw_trian_rect(cat1, cat2))
# area
(cat1 * cat2) / 2
poly_area(df)

# perimeter
cat1 + cat2 + sqrt(cat1^2 + cat2^2)
poly_perimeter(df)
############ An creating shapes with n sides ############
side &lt;- 2
(square &lt;- draw_square(side = side))

# area
side ^ 2
poly_area(square)

# perimeter
side * 4
poly_perimeter(square)
</code></pre>

<hr>
<h2 id='utils_stats'>These functions applies common statistics to a list of objects, returning a
numeric vector.</h2><span id='topic+utils_stats'></span><span id='topic+mean_list'></span><span id='topic+sd_list'></span><span id='topic+max_list'></span><span id='topic+min_list'></span>

<h3>Description</h3>

<p>These functions applies common statistics to a list of objects, returning a
numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_list(x, ...)

sd_list(x, ...)

max_list(x, ...)

min_list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_stats_+3A_x">x</code></td>
<td>
<p>A data.frame or matrix with numeric values.</p>
</td></tr>
<tr><td><code id="utils_stats_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the R base function (e.g, mean(),
sd(), etc.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean_list(list(a = 1:10, b = 2:20))
</code></pre>

<hr>
<h2 id='utils_transform'>Spatial transformations</h2><span id='topic+utils_transform'></span><span id='topic+image_autocrop'></span><span id='topic+image_crop'></span><span id='topic+image_dimension'></span><span id='topic+image_rotate'></span><span id='topic+image_horizontal'></span><span id='topic+image_vertical'></span><span id='topic+image_hreflect'></span><span id='topic+image_vreflect'></span><span id='topic+image_resize'></span><span id='topic+image_trim'></span><span id='topic+image_dilate'></span><span id='topic+image_erode'></span><span id='topic+image_opening'></span><span id='topic+image_closing'></span><span id='topic+image_skeleton'></span><span id='topic+image_thinning'></span><span id='topic+image_filter'></span><span id='topic+image_blur'></span><span id='topic+image_contrast'></span>

<h3>Description</h3>

<p>Performs image rotation and reflection
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;image autocrop()&#8288;</code> Crops automatically  an image to the area of objects.
</p>
</li>
<li> <p><code>image_crop()</code> Crops an image to the desired area.
</p>
</li>
<li> <p><code>image_trim()</code> Remove pixels from the edges of an image (20 by default).
</p>
</li>
<li> <p><code>image_dimension()</code> Gives the dimension (width and height) of an image.
</p>
</li>
<li> <p><code>image_rotate()</code> Rotates the image clockwise by the given angle.
</p>
</li>
<li> <p><code>image_horizontal()</code> Converts (if needed) an image to a horizontal image.
</p>
</li>
<li> <p><code>image_vertical()</code> Converts (if needed) an image to a vertical image.
</p>
</li>
<li> <p><code>image_hreflect()</code> Performs horizontal reflection of the <code>image</code>.
</p>
</li>
<li> <p><code>image_vreflect()</code> Performs vertical reflection of the <code>image</code>.
</p>
</li>
<li> <p><code>image_resize()</code> Resize the <code>image</code>. See more at <code><a href="EBImage.html#topic+spatial">EBImage::resize()</a></code>.
</p>
</li>
<li> <p><code>image_contrast()</code> Improve contrast locally by performing adaptive
histogram equalization. See more at <code><a href="EBImage.html#topic+clahe">EBImage::clahe()</a></code>.
</p>
</li>
<li> <p><code>image_dilate()</code> Performs image dilatation. See more at <code><a href="EBImage.html#topic+morphology">EBImage::dilate()</a></code>.
</p>
</li>
<li> <p><code>image_erode()</code> Performs image erosion. See more at <code><a href="EBImage.html#topic+morphology">EBImage::erode()</a></code>.
</p>
</li>
<li> <p><code>image_opening()</code> Performs an erosion followed by a dilation. See more at
<code><a href="EBImage.html#topic+morphology">EBImage::opening()</a></code>.
</p>
</li>
<li> <p><code>image_closing()</code> Performs a dilation followed by an erosion. See more at
<code><a href="EBImage.html#topic+morphology">EBImage::closing()</a></code>.
</p>
</li>
<li> <p><code>image_filter()</code> Performs median filtering in constant time. See more at
<code><a href="EBImage.html#topic+medianFilter">EBImage::medianFilter()</a></code>.
</p>
</li>
<li> <p><code>image_blur()</code> Performs blurring filter of images. See more at
<code><a href="EBImage.html#topic+gblur">EBImage::gblur()</a></code>.
</p>
</li>
<li> <p><code>image_skeleton()</code> Performs image skeletonization.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>image_autocrop(
  img,
  index = "NB",
  edge = 5,
  filter = 3,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_crop(
  img,
  width = NULL,
  height = NULL,
  viewer = get_pliman_viewer(),
  show = "rgb",
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_dimension(img, parallel = FALSE, workers = NULL, verbose = TRUE)

image_rotate(
  img,
  angle,
  bg_col = "white",
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = TRUE
)

image_horizontal(
  img,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_vertical(
  img,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_hreflect(
  img,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_vreflect(
  img,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_resize(
  img,
  rel_size = 100,
  width,
  height,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_trim(
  img,
  edge = NULL,
  top = NULL,
  bottom = NULL,
  left = NULL,
  right = NULL,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_dilate(
  img,
  kern = NULL,
  size = NULL,
  shape = "disc",
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_erode(
  img,
  kern = NULL,
  size = NULL,
  shape = "disc",
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_opening(
  img,
  kern = NULL,
  size = NULL,
  shape = "disc",
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_closing(
  img,
  kern = NULL,
  size = NULL,
  shape = "disc",
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_skeleton(
  img,
  kern = NULL,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE,
  ...
)

image_thinning(
  img,
  niter = 3,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE,
  ...
)

image_filter(
  img,
  size = 2,
  cache = 512,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_blur(
  img,
  sigma = 3,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)

image_contrast(
  img,
  parallel = FALSE,
  workers = NULL,
  verbose = TRUE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_transform_+3A_img">img</code></td>
<td>
<p>An image or a list of images of class <code>Image</code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_index">index</code></td>
<td>
<p>The index to segment the image. See <code><a href="#topic+image_index">image_index()</a></code> for more
details. Defaults to <code>"NB"</code> (normalized blue).</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_edge">edge</code></td>
<td>

<ul>
<li><p> for <code><a href="#topic+image_autocrop">image_autocrop()</a></code> the number of pixels in the edge of the cropped
image. If <code>edge = 0</code> the image will be cropped to create a bounding rectangle
(x and y coordinates) around the image objects.
</p>
</li>
<li><p> for <code><a href="#topic+image_trim">image_trim()</a></code>, the number of pixels removed from the edges. By
default, 20 pixels are removed from all the edges.
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_transform_+3A_filter">filter</code></td>
<td>
<p>Performs median filtering in the binary image. This is useful
to remove noise (like dust) and improve the image autocropping method. See
more at <code><a href="#topic+image_filter">image_filter()</a></code>. Set to <code>FALSE</code> to remove the median filtering.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_parallel">parallel</code></td>
<td>
<p>Processes the images asynchronously (in parallel) in separate
R sessions running in the background on the same machine. It may speed up
the processing time when <code>image</code> is a list. The number of sections is set
up to 70% of available cores.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_workers">workers</code></td>
<td>
<p>A positive numeric scalar or a function specifying the maximum
number of parallel processes that can be active at the same time.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default) a summary is shown in the console.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code> plots the modified image. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_width">width</code>, <code id="utils_transform_+3A_height">height</code></td>
<td>

<ul>
<li><p> For <code>image_resize()</code> the Width and height of the resized image. These arguments
can be missing. In this case, the image is resized according to the
relative size informed in <code>rel_size</code>.
</p>
</li>
<li><p> For <code>image_crop()</code> a numeric vector indicating the pixel range (x and y,
respectively) that will be maintained in the cropped image, e.g., width =
100:200
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_transform_+3A_viewer">viewer</code></td>
<td>
<p>The viewer option. If not provided, the value is retrieved
using <code><a href="#topic+get_pliman_viewer">get_pliman_viewer()</a></code>. This option controls the type of viewer to use
for interactive plotting. The available options are &quot;base&quot; and &quot;mapview&quot;.
If set to &quot;base&quot;, the base R graphics system is used for interactive
plotting. If set to &quot;mapview&quot;, the mapview package is used. To set this
argument globally for all functions in the package, you can use the
<code><a href="#topic+set_pliman_viewer">set_pliman_viewer()</a></code> function. For example, you can run
<code>set_pliman_viewer("mapview")</code> to set the viewer option to &quot;mapview&quot; for
all functions.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_show">show</code></td>
<td>
<p>How to plot in mapview viewer, either <code>"rgb"</code> or <code>"index"</code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_angle">angle</code></td>
<td>
<p>The rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_bg_col">bg_col</code></td>
<td>
<p>Color used to fill the background pixels, defaults to <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_rel_size">rel_size</code></td>
<td>
<p>The relative size of the resized image. Defaults to 100. For
example, setting <code>rel_size = 50</code> to an image of width <code style="white-space: pre;">&#8288;1280 x 720&#8288;</code>, the new
image will have a size of <code style="white-space: pre;">&#8288;640 x 360&#8288;</code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_top">top</code>, <code id="utils_transform_+3A_bottom">bottom</code>, <code id="utils_transform_+3A_left">left</code>, <code id="utils_transform_+3A_right">right</code></td>
<td>
<p>The number of pixels removed from <code>top</code>,
<code>bottom</code>, <code>left</code>, and <code>right</code> when using <code><a href="#topic+image_trim">image_trim()</a></code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_kern">kern</code></td>
<td>
<p>An <code>Image</code> object or an array, containing the structuring
element. Defaults to a brushe generated with <code><a href="EBImage.html#topic+morphology">EBImage::makeBrush()</a></code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_size">size</code></td>
<td>

<ul>
<li><p> For <code>image_filter()</code> is the median filter radius (integer). Defaults to <code>3</code>.
</p>
</li>
<li><p> For <code>image_dilate()</code> and <code>image_erode()</code> is an odd number containing the
size of the brush in pixels. Even numbers are rounded to the next odd one.
The default depends on the image resolution and is computed as the image
resolution (megapixels) times 20.
</p>
</li></ul>
</td></tr>
<tr><td><code id="utils_transform_+3A_shape">shape</code></td>
<td>
<p>A character vector indicating the shape of the brush. Can be
<code>box</code>, <code>disc</code>, <code>diamond</code>, <code>Gaussian</code> or <code>line</code>. Default is <code>disc</code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="#topic+image_binary">image_binary()</a></code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_niter">niter</code></td>
<td>
<p>The number of iterations to perform in the thinning procedure.
Defaults to 3. Set to <code>NULL</code> to iterate until the binary image is no longer
changing.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_cache">cache</code></td>
<td>
<p>The the L2 cache size of the system CPU in kB (integer).
Defaults to <code>512</code>.</p>
</td></tr>
<tr><td><code id="utils_transform_+3A_sigma">sigma</code></td>
<td>
<p>A numeric denoting the standard deviation of the Gaussian filter
used for blurring. Defaults to <code>3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>image_skeleton()</code> returns a binary <code>Image</code> object.
</p>
</li>
<li><p> All other functions returns a  modified version of <code>image</code> depending on the
<code style="white-space: pre;">&#8288;image_*()&#8288;</code> function used.
</p>
</li>
<li><p> If <code>image</code> is a list, a list of the same length will be returned.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiago Olivoto <a href="mailto:tiagoolivoto@gmail.com">tiagoolivoto@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("sev_leaf.jpg")
plot(img)
img &lt;- image_resize(img, 50)
img1 &lt;- image_rotate(img, 45)
img2 &lt;- image_hreflect(img)
img3 &lt;- image_vreflect(img)
img4 &lt;- image_vertical(img)
image_combine(img1, img2, img3, img4)
</code></pre>

<hr>
<h2 id='utils_wd'>Set and get the Working Directory quicky</h2><span id='topic+utils_wd'></span><span id='topic+set_wd_here'></span><span id='topic+get_wd_here'></span><span id='topic+open_wd_here'></span><span id='topic+open_wd'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+get_wd_here">get_wd_here()</a></code> gets the working directory to the path of the current script.
</p>
</li>
<li> <p><code><a href="#topic+set_wd_here">set_wd_here()</a></code> sets the working directory to the path of the current script.
</p>
</li>
<li> <p><code><a href="#topic+open_wd_here">open_wd_here()</a></code> Open the File Explorer at the directory path of the current script.
</p>
</li>
<li> <p><code><a href="#topic+open_wd">open_wd()</a></code> Open the File Explorer at the current working directory.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>set_wd_here(path = NULL)

get_wd_here(path = NULL)

open_wd_here(path = get_wd_here())

open_wd(path = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_wd_+3A_path">path</code></td>
<td>
<p>Path components below the project root. Defaults to <code>NULL</code>. This means that
the directory will be set to the path of the file. If the path doesn't exist, the
user will be asked if he wants to create such a folder.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+get_wd_here">get_wd_here()</a></code> returns a full-path directory name.
</p>
</li>
<li> <p><code><a href="#topic+get_wd_here">get_wd_here()</a></code> returns a message showing the current working directory.
</p>
</li>
<li> <p><code><a href="#topic+open_wd_here">open_wd_here()</a></code> Opens the File Explorer of the path returned by <code>get_wd_here()</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
get_wd_here()
set_wd_here()
open_wd_here()

## End(Not run)
</code></pre>

<hr>
<h2 id='watershed2'>Alternative watershed algorithm</h2><span id='topic+watershed2'></span>

<h3>Description</h3>

<p>This is a basic watershed algorithm that can be used as a faster alternative
to <code><a href="EBImage.html#topic+watershed">EBImage::watershed()</a></code>. I strongly suggest using this only with round
objects, since it doesn't consider both 'extension' and 'tolerance' arguments
of <code><a href="EBImage.html#topic+watershed">EBImage::watershed()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watershed2(binary, dist_thresh = 0.75, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watershed2_+3A_binary">binary</code></td>
<td>
<p>A binary image</p>
</td></tr>
<tr><td><code id="watershed2_+3A_dist_thresh">dist_thresh</code></td>
<td>
<p>The distance threshold to create the</p>
</td></tr>
<tr><td><code id="watershed2_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code> (default) plots the labeled objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The labelled version of <code>binary</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pliman)
img &lt;- image_pliman("soybean_touch.jpg")
binary &lt;- image_binary(img, "B")[[1]]
wts &lt;- watershed2(binary)
range(wts)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
