<!DOCTYPE html><html><head><title>Help for package Irescale</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Irescale}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildStabilityTable'><p>Finds how many iterations are necessary to achieve stability in resampling method.</p></a></li>
<li><a href='#buildStabilityTableForCorrelation'><p>Finds how many iterations are necessary to achieve stability in resampling method for rectifying I through pearson corrrelation.</p></a></li>
<li><a href='#calculateDistMatrixFromBoard'><p>Calculates the distance in a chessboard-alike structure.</p></a></li>
<li><a href='#calculateEuclideanDistance'><p>Given a 2D data structure, it calculates the euclidean distance among all the points.</p></a></li>
<li><a href='#calculateLocalI'><p>Computing the Local Moran's I</p></a></li>
<li><a href='#calculateManhattanDistance'><p>Calculates the manhattan distance.</p></a></li>
<li><a href='#calculateMoranI'><p>Calculates the Moran's I using the algorithm proposed by Chen (Chen 2013).</p></a></li>
<li><a href='#calculatePvalue'><p>p-value calculation.</p></a></li>
<li><a href='#calculateWeightedDistMatrix'><p>Calculates a weighted representation of the distance matrix.</p></a></li>
<li><a href='#convexHull'><p>Plots the convexhull polygon from the data (latitude, longitude), and calculates the center of the convexhull and its area.</p></a></li>
<li><a href='#coor'><p>Transforms a x,y position in a cartesian plane into a position in a 1D array.</p></a></li>
<li><a href='#expectedValueI'><p>Calculates the expected value for local I</p></a></li>
<li><a href='#iCorrection'><p>Scaling process for Moran's I.</p></a></li>
<li><a href='#ItoPearsonCorrelation'><p>Calculate the equivalence r from the I percentile in the I-Null Distribution.</p></a></li>
<li><a href='#loadChessBoard'><p>Loads a chessboard or matrix alike input file.</p></a></li>
<li><a href='#loadDistanceMatrix'><p>Loads a distance matrix. Instead of computing the distance from latitute and longitude</p>
<code>LoadDistanceMatrix</code> Loads the distance matrix, avoiding computing it from latitude and longitude.</a></li>
<li><a href='#loadFile'><p>Loads a file with latitude, longitude and variable of interest</p></a></li>
<li><a href='#loadSatelliteImage'><p>Loads a Satellite image in PNG format</p></a></li>
<li><a href='#localICorrection'><p>Scaling process for Local Moran's I.</p></a></li>
<li><a href='#nullDristribution'><p>Calculate a distribution of how the var of interest is correlated to a</p></a></li>
<li><a href='#plotHistogramOverlayCorrelation'><p>Creates an overlay of the histogram of the data and the theorical normal distribution.</p></a></li>
<li><a href='#plotHistogramOverlayNormal'><p>Creates an overlay of the histogram of the data and the theorical normal distribution.</p></a></li>
<li><a href='#procrustes'><p>Procrustes distance between two surfaces</p></a></li>
<li><a href='#rectifyIrho'><p>Rectify I using a correlation method for all the variables in an input file.</p></a></li>
<li><a href='#resamplingI'><p>Calculates n permutations of the variable of interest to calculate n different I in order to create the <code class="reqn">Null</code> distribution.</p></a></li>
<li><a href='#resamplingLocalI'><p>Calculates n permutations of the variable of interest to calculate n different I in order to create the <code class="reqn">Null</code> distribution.</p></a></li>
<li><a href='#rescaleI'><p>Performs the rescale for all the variables in an input file.</p></a></li>
<li><a href='#saveFile'><p>Saves a report with important statistics to describe the sample.</p></a></li>
<li><a href='#standardize'><p>Standardize the input vector</p></a></li>
<li><a href='#standardizedByColumn'><p>Scales a matrix by column.</p></a></li>
<li><a href='#summaryLocalIVector'><p>Calculates statistic for the received Matrix.</p></a></li>
<li><a href='#summaryVector'><p>Calculates statistic for the received vector.</p></a></li>
<li><a href='#transformImageToList'><p>Transforms the image in the object need it to run the analysis.</p></a></li>
<li><a href='#transformImageToMatrix'><p>Transforms the image to a matrix.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculate and Rectify Moran's I</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Ivan Fuentes, Thomas DeWitt, Thomas Ioerger, Michael Bishop</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan Fuentes &lt;jivfur@tamu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a scaling method to obtain a standardized Moran's I measure. Moran's I is a measure for the spatial autocorrelation of a data set, it gives a measure of similarity between data and its surrounding. The range of this value must be [-1,1], but this does not happen in practice. This package scale the Moran's I value and map it into the theoretical range of [-1,1]. Once the Moran's I value is rescaled, it facilitates the comparison between projects, for instance, a researcher can calculate Moran's I in a city in China, with a sample size of n1 and area of interest a1. Another researcher runs a similar experiment in a city in Mexico with different sample size, n2, and an area of interest a2. Due to the differences between the conditions, it is not possible to compare Moran's I in a straightforward way. In this version of the package, the spatial autocorrelation Moran's I is calculated as proposed in Chen(2013) &lt;<a href="https://doi.org/10.48550/arXiv.1606.03658">doi:10.48550/arXiv.1606.03658</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.tamu.edu/jivfur/rectifiedI">https://github.tamu.edu/jivfur/rectifiedI</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, sp, e1071, graphics, grDevices, stats, utils,Rdpack,
fBasics, imager, reshape2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-21 17:15:53 UTC; jivfur</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-11-21 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildStabilityTable'>Finds how many iterations are necessary to achieve stability in resampling method.</h2><span id='topic+buildStabilityTable'></span>

<h3>Description</h3>

<p><code>buildStabilityTable</code>  finds how many iterations are necessary to achieve stability in resampling method, plotting in a log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildStabilityTable(data, times = 10, samples = 100, plots = TRUE,
  scalingUpTo = "Quantile")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildStabilityTable_+3A_data">data</code></td>
<td>
<p>data structure after loading the file using <code>loadFile</code> function</p>
</td></tr>
<tr><td><code id="buildStabilityTable_+3A_times">times</code></td>
<td>
<p>the number of times <code>rescaleI</code> will be executed. The default value is 100.</p>
</td></tr>
<tr><td><code id="buildStabilityTable_+3A_samples">samples</code></td>
<td>
<p>size of the resampling method. The default value is 1000</p>
</td></tr>
<tr><td><code id="buildStabilityTable_+3A_plots">plots</code></td>
<td>
<p>to draw the significance plot</p>
</td></tr>
<tr><td><code id="buildStabilityTable_+3A_scalingupto">scalingUpTo</code></td>
<td>
<p>the rescaling could be done up to the 0.01% and 99.99% quantile or max and min values. The two possible options are: &quot;MaxMin&quot;, or &quot;Quantile&quot;. The default value for this parameter is &quot;Quantile&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the average <code class="reqn">\log(samples)</code> averages I
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data &lt;- loadFile(fileInput)
resultsChen&lt;-buildStabilityTable(data=data,times=10,samples=100,plots=TRUE,scalingUpTo="Quantile")
</code></pre>

<hr>
<h2 id='buildStabilityTableForCorrelation'>Finds how many iterations are necessary to achieve stability in resampling method for rectifying I through pearson corrrelation.</h2><span id='topic+buildStabilityTableForCorrelation'></span>

<h3>Description</h3>

<p><code>buildStabilityTableForCorrelation</code>  finds how many iterations are necessary to achieve stability in resampling method, plotting in a log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildStabilityTableForCorrelation(data, times = 10, samples = 100,
  plots = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildStabilityTableForCorrelation_+3A_data">data</code></td>
<td>
<p>data structure after loading the file using <code>loadFile</code> function</p>
</td></tr>
<tr><td><code id="buildStabilityTableForCorrelation_+3A_times">times</code></td>
<td>
<p>the number of times <code>rescaleI</code> will be executed. The default value is 100.</p>
</td></tr>
<tr><td><code id="buildStabilityTableForCorrelation_+3A_samples">samples</code></td>
<td>
<p>size of the resampling method. The default value is 1000</p>
</td></tr>
<tr><td><code id="buildStabilityTableForCorrelation_+3A_plots">plots</code></td>
<td>
<p>to draw the significance plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the average <code class="reqn">\log(samples)</code> averages I
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data &lt;- loadFile(fileInput)
resultsChen&lt;-buildStabilityTableForCorrelation(data=data,times=10,samples=100,plots=TRUE)
</code></pre>

<hr>
<h2 id='calculateDistMatrixFromBoard'>Calculates the distance in a chessboard-alike structure.</h2><span id='topic+calculateDistMatrixFromBoard'></span>

<h3>Description</h3>

<p><code>calculateDistMatrixFromBoard</code> calculates the distance matrix when the field is divided in a matrix shape (rows and columns). This board could have different number of columns for each row.
For example:
</p>

<table>
<tr>
 <td style="text-align: center;">
1</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
2</td><td style="text-align: center;"> 2</td><td style="text-align: center;"> 2</td><td style="text-align: center;"> 2</td><td style="text-align: center;"> 2</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
3</td><td style="text-align: center;"> 3</td><td style="text-align: center;"> 3</td><td style="text-align: center;"> 3</td><td style="text-align: center;"> 3</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
4</td><td style="text-align: center;"> 4</td><td style="text-align: center;"> 4</td><td style="text-align: center;"> 4</td><td style="text-align: center;"> 4</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>The dimension of obtained squared matrix is given by the square of the maximumn dimension of the original matrix. In the previous example, the matrix will have a size of (36,36).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateDistMatrixFromBoard(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateDistMatrixFromBoard_+3A_data">data</code></td>
<td>
<p>is a 2D data structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distM the distance between each cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chessboard.csv", package="Irescale")
data&lt;-loadChessBoard(fileInput)
distM&lt;-calculateEuclideanDistance(data$data)
</code></pre>

<hr>
<h2 id='calculateEuclideanDistance'>Given a 2D data structure, it calculates the euclidean distance among all the points.</h2><span id='topic+calculateEuclideanDistance'></span>

<h3>Description</h3>

<p><code>calculateEuclideanDistance</code> Computes the euclidean distance betwen all pairs of nodes provided in the input vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateEuclideanDistance(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateEuclideanDistance_+3A_data">data</code></td>
<td>
<p>2D data structure for latitute and longitute respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the euclidean distance, <code class="reqn">\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}</code>, matrix between each pair of points.
</p>


<h3>Value</h3>

<p>Matrix, of size <code class="reqn">nrow(data) \times nrow(data)</code>, with the distance between all the pair of points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data&lt;-loadFile(fileInput)
distM&lt;-calculateEuclideanDistance(data$data)
</code></pre>

<hr>
<h2 id='calculateLocalI'>Computing the Local Moran's I</h2><span id='topic+calculateLocalI'></span>

<h3>Description</h3>

<p><code>calculateLocalI</code> calculates the local Moran's I without rescaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateLocalI(z, distM, scaling = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateLocalI_+3A_z">z</code></td>
<td>
<p>vector with the var of interest</p>
</td></tr>
<tr><td><code id="calculateLocalI_+3A_distm">distM</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="calculateLocalI_+3A_scaling">scaling</code></td>
<td>
<p>to scale the variable of interest. The default value is set to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the local Moran's I
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
input &lt;- loadFile(fileInput)
distM&lt;-calculateEuclideanDistance(input$data)
localI&lt;-calculateLocalI(input$varOfInterest,distM)
</code></pre>

<hr>
<h2 id='calculateManhattanDistance'>Calculates the manhattan distance.</h2><span id='topic+calculateManhattanDistance'></span>

<h3>Description</h3>

<p><code>calculateManhattanDistance</code> Calculates the manhattan distance between each pair of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateManhattanDistance(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateManhattanDistance_+3A_data">data</code></td>
<td>
<p>2D structure with n rows and 2 colums that represents the coordinate in a plane.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix, of size <code class="reqn">nrow(data) \times nrow(data)</code>, with the distance between each the pair of points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chessboard.csv", package="Irescale")
data&lt;-loadChessBoard(fileInput)
distM&lt;-calculateManhattanDistance(data$data)
</code></pre>

<hr>
<h2 id='calculateMoranI'>Calculates the Moran's I using the algorithm proposed by Chen (Chen 2013).</h2><span id='topic+calculateMoranI'></span>

<h3>Description</h3>

<p><code>calculateMoranI</code> Moran's I computing method.
</p>
<p style="text-align: center;"><code class="reqn">
I = varOfInterest^t \times weightedM \times varOfInterest
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>calculateMoranI(distM, varOfInterest, scaling = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateMoranI_+3A_distm">distM</code></td>
<td>
<p>the distance matrix. Altough the equation asks for weighted distant matrix, the paramenter that is required is only the distance matrix because this procedure calculate calculates the weighted distance mantrix by itself.</p>
</td></tr>
<tr><td><code id="calculateMoranI_+3A_varofinterest">varOfInterest</code></td>
<td>
<p>the variable of interest to calculate Moran's I.</p>
</td></tr>
<tr><td><code id="calculateMoranI_+3A_scaling">scaling</code></td>
<td>
<p>if the values are previously scaled, set this parameter to False. The default value is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Moran's I
</p>


<h3>References</h3>


<p>Chen Y (2013).
&ldquo;New approaches for calculating Moran’s index of spatial autocorrelation.&rdquo;
<em>PloS one</em>, <b>8</b>(7), e68336.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
I&lt;-calculateMoranI(distM = distM,varOfInterest = input$varOfInterest)
</code></pre>

<hr>
<h2 id='calculatePvalue'>p-value calculation.</h2><span id='topic+calculatePvalue'></span>

<h3>Description</h3>

<p><code>calculatePvalue</code> calculates a p-value for the null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculatePvalue(sample, value, mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculatePvalue_+3A_sample">sample</code></td>
<td>
<p>the vector that will be used as reference.</p>
</td></tr>
<tr><td><code id="calculatePvalue_+3A_value">value</code></td>
<td>
<p>the value of interest.</p>
</td></tr>
<tr><td><code id="calculatePvalue_+3A_mean">mean</code></td>
<td>
<p>the mean of interest.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(fileInput)
distM&lt;-calculateEuclideanDistance(input$data)
I&lt;-calculateMoranI(distM = distM,varOfInterest = input$varOfInterest)
vI&lt;-resamplingI(distM, input$varOfInterest, n=1000) # This is the permutation
statsVI&lt;-summaryVector(vI)
corrections&lt;-iCorrection(I,vI)
pv&lt;-calculatePvalue(corrections$scaledData,corrections$newI,corrections$summaryScaledD$mean)
</code></pre>

<hr>
<h2 id='calculateWeightedDistMatrix'>Calculates a weighted representation of the distance matrix.</h2><span id='topic+calculateWeightedDistMatrix'></span>

<h3>Description</h3>

<p><code>calculateWeightedDistMatrix</code> The weighted matrix is used as a standardized version of the distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateWeightedDistMatrix(distM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateWeightedDistMatrix_+3A_distm">distM</code></td>
<td>
<p>2D matrix with the distance among all pair of coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the similarity matrix of the distance by taking the reciprocal of the distance <code class="reqn">\frac{1}{d}</code>. A value of Zero is assigned when this value can not be calculated.
The whole reciprocal matrix is scaled by dividing each value by the sum of all the elements of the matrix.
</p>


<h3>Value</h3>

<p>weighted distance matrix. The sum of this matrix is 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data&lt;-loadFile(fileInput)
distM&lt;-calculateEuclideanDistance(data$data)
distW&lt;-calculateWeightedDistMatrix(distM)
</code></pre>

<hr>
<h2 id='convexHull'>Plots the convexhull polygon from the data (latitude, longitude), and calculates the center of the convexhull and its area.</h2><span id='topic+convexHull'></span>

<h3>Description</h3>

<p><code>convexHull</code> Computes the area and centroid of the convex hull from the (latitute, longitude) vector.
It provides a plot of how the points are dispersed in the field of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convexHull(X, varOfInterest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convexHull_+3A_x">X</code></td>
<td>
<p>dataframe with two colums, latitute and longitude respectively.</p>
</td></tr>
<tr><td><code id="convexHull_+3A_varofinterest">varOfInterest</code></td>
<td>
<p>variable of interest to plot. This variable is needed to color the points on the convexhull.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consideration for this function:
</p>

<ul>
<li><p> It makes usage of chull from rgeos and Polygon from graphics.
</p>
</li>
<li><p> The centroid of the polygon is calculated by averaging the vertices of it.
</p>
</li>
<li><p> The shown plot uses the basic <code>plot</code> command.
</p>
</li></ul>



<h3>Value</h3>

<p>A vector with two elements, the first element is the area and the second one is the centroid.
The centroid is a list of two elements, latitude and longitude that represents the centroid.
To have a visual idea of the returned object, it has the following shape <code class="reqn">[area,[latitude,longitude], plotObject]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data&lt;-loadFile(fileInput)
area_centroid&lt;-convexHull(data$data,data$varOfInterest)
</code></pre>

<hr>
<h2 id='coor'>Transforms a x,y position in a cartesian plane into a position in a 1D array.</h2><span id='topic+coor'></span>

<h3>Description</h3>

<p><code>coor</code> Transforms a x,y position in a cartesian plane into a position in a 1D array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coor(i, j, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coor_+3A_i">i</code></td>
<td>
<p>the value of the row.</p>
</td></tr>
<tr><td><code id="coor_+3A_j">j</code></td>
<td>
<p>the value of the column.</p>
</td></tr>
<tr><td><code id="coor_+3A_size">size</code></td>
<td>
<p>the maximum between row and columns of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer value that represents the position in the array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos&lt;-coor(1,1,10)
</code></pre>

<hr>
<h2 id='expectedValueI'>Calculates the expected value for local I</h2><span id='topic+expectedValueI'></span>

<h3>Description</h3>

<p><code>expectedValueI</code> Calculates the expected value for local I
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedValueI(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedValueI_+3A_w">W</code></td>
<td>
<p>Weighted Distance Matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Expected Value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W&lt;-matrix(1:100,nrow=10,ncol=10)
evI&lt;-expectedValueI(W)
</code></pre>

<hr>
<h2 id='iCorrection'>Scaling process for Moran's I.</h2><span id='topic+iCorrection'></span>

<h3>Description</h3>

<p><code>iCorrection</code> . consists in centering the I value (I-median) and scaling by the difference between the median and 1st or 99th quantile. The correction is according to the following equation:
</p>
<p style="text-align: center;"><code class="reqn">
I = \left\{
\begin{array}{lr}
\frac{(I-median)}{(median - Q1)}&amp; I &lt; median\\
\frac{(I-median)}{(Q99-median)}&amp; I&gt;median\\
\end{array}\right\}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>iCorrection(I, vI, statsVI, scalingUpTo = "Quantile", sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iCorrection_+3A_i">I</code></td>
<td>
<p>Moran's I, It could be computed using calculateMoranI function.</p>
</td></tr>
<tr><td><code id="iCorrection_+3A_vi">vI</code></td>
<td>
<p>the vector obtained by resamplingI.</p>
</td></tr>
<tr><td><code id="iCorrection_+3A_statsvi">statsVI</code></td>
<td>
<p>the statistic vector obtained from summaryVector.</p>
</td></tr>
<tr><td><code id="iCorrection_+3A_scalingupto">scalingUpTo</code></td>
<td>
<p>the rescaling could be done up to the 0.01% and 99.9% quantile or max and min values. The two possible options are: &quot;MaxMin&quot;, or &quot;Quantile&quot;. The default value for this parameter is Quantile.</p>
</td></tr>
<tr><td><code id="iCorrection_+3A_sd">sd</code></td>
<td>
<p>this represents upto which standard deviation you want to scale I</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rescaled I
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
I&lt;-calculateMoranI(distM = distM,varOfInterest = input$varOfInterest)
vI&lt;-resamplingI(distM, input$varOfInterest)
statsVI&lt;-summaryVector(vI)
corrections&lt;-iCorrection(I,vI,scalingUpTo="Quantile")
</code></pre>

<hr>
<h2 id='ItoPearsonCorrelation'>Calculate the equivalence r from the I percentile in the I-Null Distribution.</h2><span id='topic+ItoPearsonCorrelation'></span>

<h3>Description</h3>

<p><code>ItoPearsonCorrelation</code> It calculates the Null distribution of I and determine what is the percentile of the real value of I,
then It calculates the inverse of the Normal Distribution(qnorm) to obtain the value of R to which this percentile belongs to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ItoPearsonCorrelation(vI, n, medianCenter = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ItoPearsonCorrelation_+3A_vi">vI</code></td>
<td>
<p>the vector obtained by resamplingI.</p>
</td></tr>
<tr><td><code id="ItoPearsonCorrelation_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="ItoPearsonCorrelation_+3A_mediancenter">medianCenter</code></td>
<td>
<p>to center all the values to the median. The defaul value is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with r correlation equivalence and the rectified vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data &lt;- loadFile(fileInput)
distM&lt;-calculateEuclideanDistance(data$data)
vI&lt;-resamplingI(distM,data$varOfInterest,n = 1000)
rectifiedI&lt;- ItoPearsonCorrelation(vI, length(data))
</code></pre>

<hr>
<h2 id='loadChessBoard'>Loads a chessboard or matrix alike input file.</h2><span id='topic+loadChessBoard'></span>

<h3>Description</h3>

<p><code>loadChessBoard</code> is used when the input file has a 2D shape, this is a board shape, and it is only one variable of interest.
For example:
</p>

<table>
<tr>
 <td style="text-align: center;">
1</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1</td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
2</td><td style="text-align: center;"> 2</td><td style="text-align: center;"> 2</td><td style="text-align: center;"> 2</td><td style="text-align: center;"> 2</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
3</td><td style="text-align: center;"> 3</td><td style="text-align: center;"> 3</td><td style="text-align: center;"> 3</td><td style="text-align: center;"> 3</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
4</td><td style="text-align: center;"> 4</td><td style="text-align: center;"> 4</td><td style="text-align: center;"> 4</td><td style="text-align: center;"> 4</td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>loadChessBoard(fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadChessBoard_+3A_filename">fileName</code></td>
<td>
<p>the path and file's name to load.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with two variables, the first variable is a vector with coordinate x (latitude) and y (longitude), the second variable contains the values of the variable of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chessboard.csv", package="Irescale")
data&lt;-loadChessBoard(fileInput)
</code></pre>

<hr>
<h2 id='loadDistanceMatrix'>Loads a distance matrix. Instead of computing the distance from latitute and longitude
<code>LoadDistanceMatrix</code> Loads the distance matrix, avoiding computing it from latitude and longitude.</h2><span id='topic+loadDistanceMatrix'></span>

<h3>Description</h3>

<p>Loads a distance matrix. Instead of computing the distance from latitute and longitude
<code>LoadDistanceMatrix</code> Loads the distance matrix, avoiding computing it from latitude and longitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDistanceMatrix(fileName, colnames = TRUE, rownames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadDistanceMatrix_+3A_filename">fileName</code></td>
<td>
<p>file's name and path to the file</p>
</td></tr>
<tr><td><code id="loadDistanceMatrix_+3A_colnames">colnames</code></td>
<td>
<p>If the first row of the file is the names for the columns. The default value is TRUE</p>
</td></tr>
<tr><td><code id="loadDistanceMatrix_+3A_rownames">rownames</code></td>
<td>
<p>If the first column is the the row names. The default value is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chenDistance.csv", package="Irescale")
distM&lt;-loadDistanceMatrix(fileInput)
</code></pre>

<hr>
<h2 id='loadFile'>Loads a file with latitude, longitude and variable of interest</h2><span id='topic+loadFile'></span>

<h3>Description</h3>

<p><code>loadFile</code> loads the input file with the following format:
</p>

<ul>
<li><p> Column 1  represents  the sample Id. It has to be Unique.
</p>
</li>
<li><p> Column 2,3 Lat/Long respectively.
</p>
</li>
<li><p> Column 4 and beyond the variables of interest.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>loadFile(fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadFile_+3A_filename">fileName</code></td>
<td>
<p>the file's name and path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it returns a data frame with two variables <code class="reqn">data</code> and <code class="reqn">varOfInterest</code>. The variable <code class="reqn">data</code> is a 2D list with the latitude and longitude respectly, while the variable <code class="reqn">varOfInterest</code> is a matrix with all the variables to calculate and rescale Moran's I.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chessboard.csv", package="Irescale")
data&lt;-loadFile(fileInput)
</code></pre>

<hr>
<h2 id='loadSatelliteImage'>Loads a Satellite image in PNG format</h2><span id='topic+loadSatelliteImage'></span>

<h3>Description</h3>

<p><code>loadSatelliteImage</code> Loads a Satellite image in PNG format. It does not matter the number of chanells it will return it in grayscale (One channel)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSatelliteImage(fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadSatelliteImage_+3A_filename">fileName</code></td>
<td>
<p>file's name and path to the file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An cimg object in gray scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "imageGray.png", package="Irescale")
img&lt;-loadSatelliteImage(fileInput)
</code></pre>

<hr>
<h2 id='localICorrection'>Scaling process for Local Moran's I.</h2><span id='topic+localICorrection'></span>

<h3>Description</h3>

<p><code>localICorrection</code> . consists in centering the local I value (I-median) and scaling by the difference between the median and 1st or 99th quantile. The correction is according to the following equation:
</p>
<p style="text-align: center;"><code class="reqn">
I = \left\{
\begin{array}{lr}
\frac{(I-median)}{(median - Q1)}&amp; I &lt; median\\
\frac{(I-median)}{(Q99-median)}&amp; I&gt;median\\
\end{array}\right\}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>localICorrection(localI, vI, statsVI, scalingUpTo = "Quantile")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localICorrection_+3A_locali">localI</code></td>
<td>
<p>Local Moran's I, It could be computed using calculateLocalMoranI function.</p>
</td></tr>
<tr><td><code id="localICorrection_+3A_vi">vI</code></td>
<td>
<p>the vector obtained by resamplingI.</p>
</td></tr>
<tr><td><code id="localICorrection_+3A_statsvi">statsVI</code></td>
<td>
<p>the statistic vector obtained from summaryLocalIVector.</p>
</td></tr>
<tr><td><code id="localICorrection_+3A_scalingupto">scalingUpTo</code></td>
<td>
<p>the rescaling could be done up to the 0.01% and 99.9% quantile or max and min values. The two possible options are: &quot;MaxMin&quot;, or &quot;Quantile&quot;. The default value for this parameter is Quantile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rescaled local I vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
localI &lt;- calculateLocalI(input$varOfInterest,distM)
vI&lt;-resamplingLocalI(input$varOfInterest,distM)
statsVI&lt;-summaryLocalIVector(vI)
corrections&lt;-localICorrection(localI,vI,scalingUpTo="Quantile")
</code></pre>

<hr>
<h2 id='nullDristribution'>Calculate a distribution of how the var of interest is correlated to a</h2><span id='topic+nullDristribution'></span>

<h3>Description</h3>

<p><code>nullDristribution</code> Calculate a linear regression between variable of interest and latitude, longitude and latitude*longitude. The residuals of this data set is calculated
The variable of interest is shuffle by numReplicates times and each time the linear regression and residuals are calculated.
At each interation the correlation between the original residuals and the shuffle residuals is calculated
This vector os correlations is returned and plot it as histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullDristribution(data, numReplicates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nullDristribution_+3A_data">data</code></td>
<td>
<p>the distance matrix. Altough the equation asks for weighted distant matrix, the paramenter that is required is only the distance matrix because this procedure calculate calculates the weighted distance mantrix by itself.</p>
</td></tr>
<tr><td><code id="nullDristribution_+3A_numreplicates">numReplicates</code></td>
<td>
<p>the variable of interest to calculate Moran's I.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Histogram and the vector of correlations between residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
c&lt;-nullDristribution(input,1000)
</code></pre>

<hr>
<h2 id='plotHistogramOverlayCorrelation'>Creates an overlay of the histogram of the data and the theorical normal distribution.</h2><span id='topic+plotHistogramOverlayCorrelation'></span>

<h3>Description</h3>

<p><code>plotHistogramOverlayCorrelation</code> Overlays the histogram and the theorical normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHistogramOverlayCorrelation(originalVec, vec, I, n, bins = 50,
  main = "Histogram")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHistogramOverlayCorrelation_+3A_originalvec">originalVec</code></td>
<td>
<p>The original vector of I, it should be sorted.</p>
</td></tr>
<tr><td><code id="plotHistogramOverlayCorrelation_+3A_vec">vec</code></td>
<td>
<p>the vector to plot.</p>
</td></tr>
<tr><td><code id="plotHistogramOverlayCorrelation_+3A_i">I</code></td>
<td>
<p>the value of I to plot</p>
</td></tr>
<tr><td><code id="plotHistogramOverlayCorrelation_+3A_n">n</code></td>
<td>
<p>number of observations in the sample.</p>
</td></tr>
<tr><td><code id="plotHistogramOverlayCorrelation_+3A_bins">bins</code></td>
<td>
<p>the number of bins for the histogram, The default value is 30.</p>
</td></tr>
<tr><td><code id="plotHistogramOverlayCorrelation_+3A_main">main</code></td>
<td>
<p>the title of the histogram, The default value is &quot;Histogram&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
I&lt;-calculateMoranI(distM = distM,varOfInterest = input$varOfInterest)
originalI&lt;-resamplingI(distM, input$varOfInterest)
correlationI&lt;-ItoPearsonCorrelation(originalI,length(input$varOfInterest))
plotHistogramOverlayCorrelation(originalI,correlationI,I,length(input$varOfInterest))
</code></pre>

<hr>
<h2 id='plotHistogramOverlayNormal'>Creates an overlay of the histogram of the data and the theorical normal distribution.</h2><span id='topic+plotHistogramOverlayNormal'></span>

<h3>Description</h3>

<p><code>plotHistogramOverlayNormal</code> Overlays the histogram and the theorical normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHistogramOverlayNormal(vec, stats, bins = 50, main = "Histogram")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHistogramOverlayNormal_+3A_vec">vec</code></td>
<td>
<p>the vector to plot.</p>
</td></tr>
<tr><td><code id="plotHistogramOverlayNormal_+3A_stats">stats</code></td>
<td>
<p>the stats obtained from summaryVector.</p>
</td></tr>
<tr><td><code id="plotHistogramOverlayNormal_+3A_bins">bins</code></td>
<td>
<p>the number of bins for the histogram, The default value is 30.</p>
</td></tr>
<tr><td><code id="plotHistogramOverlayNormal_+3A_main">main</code></td>
<td>
<p>the title of the histogram, The default value is &quot;Histogram&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
I&lt;-calculateMoranI(distM = distM,varOfInterest = input$varOfInterest)
vI&lt;-resamplingI(distM, input$varOfInterest)
statsVI&lt;-summaryVector(vI)
plotHistogramOverlayNormal(vI,statsVI)
</code></pre>

<hr>
<h2 id='procrustes'>Procrustes distance between two surfaces</h2><span id='topic+procrustes'></span>

<h3>Description</h3>

<p><code>procrustes</code> Procrustes distance between two surfaces. The Procrustes distance is used to quantify the similarity or dissimilarity of (3-dimensional) shapes, and extensively used in biological morphometrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procrustes(U, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procrustes_+3A_u">U</code></td>
<td>
<p>Vector of the first surface.</p>
</td></tr>
<tr><td><code id="procrustes_+3A_v">V</code></td>
<td>
<p>Vector of the second surface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Procrustes distance
</p>

<hr>
<h2 id='rectifyIrho'>Rectify I using a correlation method for all the variables in an input file.</h2><span id='topic+rectifyIrho'></span>

<h3>Description</h3>

<p><code>rescaleI</code> It executes the whole rectifying using theorical R distribution for all the measurements in the csv file.
</p>

<ul>
<li><p> It plots the histogram with the theorical distribution.
</p>
</li>
<li><p> It plots the convexHull for each variable.
</p>
</li>
<li><p> It calcualtes the area and centroid of the convex hull for each variable.
</p>
</li>
<li><p> It calculates the I and rescale it for every variable.
</p>
</li>
<li><p> It returns an object with the computations.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>rectifyIrho(data, samples = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectifyIrho_+3A_data">data</code></td>
<td>
<p>the data frame obtained from <code>loadFile</code>.</p>
</td></tr>
<tr><td><code id="rectifyIrho_+3A_samples">samples</code></td>
<td>
<p>number of permutations for the resampling method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with I, rescaleI and statistic summary for the inputs without scaling, the same statistics after scaling them, the p-value and the convexhull information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data &lt;- loadFile(fileInput)
rectifiedI&lt;-rectifyIrho(data,100)
</code></pre>

<hr>
<h2 id='resamplingI'>Calculates n permutations of the variable of interest to calculate n different I in order to create the <code class="reqn">Null</code> distribution.</h2><span id='topic+resamplingI'></span>

<h3>Description</h3>

<p><code>resamplingI</code> Permute n-1 times the values of the variable of interest to calculate a Null distribution for I. It is done n-1, because one order is the original one, to make sure it is included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resamplingI(distM, varOfInterest, n = 1000, scaling = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resamplingI_+3A_distm">distM</code></td>
<td>
<p>the distance matrix. Although the equation requires a weighted distant matrix, the only parameter that will be needed is the distance matrix. This procedure is able to calculate the weighted distance matrix by itself.</p>
</td></tr>
<tr><td><code id="resamplingI_+3A_varofinterest">varOfInterest</code></td>
<td>
<p>the variable name  or position of the variable we are interested to calculate the spatial autocorrelation.</p>
</td></tr>
<tr><td><code id="resamplingI_+3A_n">n</code></td>
<td>
<p>number of permutations. The default value is 1000</p>
</td></tr>
<tr><td><code id="resamplingI_+3A_scaling">scaling</code></td>
<td>
<p>The default value is TRUE. However, if the values are previously scaled, this parameter must be set to FALSE..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the n calculated Moran's I.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
I&lt;-calculateMoranI(distM = distM,varOfInterest = input$varOfInterest)
vI&lt;-resamplingI(distM, input$varOfInterest)
</code></pre>

<hr>
<h2 id='resamplingLocalI'>Calculates n permutations of the variable of interest to calculate n different I in order to create the <code class="reqn">Null</code> distribution.</h2><span id='topic+resamplingLocalI'></span>

<h3>Description</h3>

<p><code>resamplingLocalI</code> Permute n-1 times the values of the variable of interest to calculate a Null distribution for I. It is done n-1, because one order is the original one, to make sure it is included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resamplingLocalI(varOfInterest, distM, n = 1000, scaling = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resamplingLocalI_+3A_varofinterest">varOfInterest</code></td>
<td>
<p>the variable name  or position of the variable we are interested to calculate the spatial autocorrelation.</p>
</td></tr>
<tr><td><code id="resamplingLocalI_+3A_distm">distM</code></td>
<td>
<p>the distance matrix. Although the equation requires a weighted distant matrix, the only parameter that will be needed is the distance matrix. This procedure is able to calculate the weighted distance matrix by itself.</p>
</td></tr>
<tr><td><code id="resamplingLocalI_+3A_n">n</code></td>
<td>
<p>number of permutations.</p>
</td></tr>
<tr><td><code id="resamplingLocalI_+3A_scaling">scaling</code></td>
<td>
<p>The default value is TRUE. However, if the values are previously scaled, this parameter must be set to FALSE..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the n calculated Local Moran's I.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
vI&lt;-resamplingLocalI(input$varOfInterest,distM,n=100)
</code></pre>

<hr>
<h2 id='rescaleI'>Performs the rescale for all the variables in an input file.</h2><span id='topic+rescaleI'></span>

<h3>Description</h3>

<p><code>rescaleI</code> It executes the whole analysis for all the measurements in the field.
</p>

<ul>
<li><p> It plots the histogram with the theorical distribution.
</p>
</li>
<li><p> It plots the convexHull for each variable.
</p>
</li>
<li><p> It calcualtes the area and centroid of the convex hull for each variable.
</p>
</li>
<li><p> It calculates the I and rescale it for every variable.
</p>
</li>
<li><p> It returns an object with the computations.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>rescaleI(data, samples = 10000, scalingUpTo = "Quantile", sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaleI_+3A_data">data</code></td>
<td>
<p>the data frame obtained from <code>loadFile</code>.</p>
</td></tr>
<tr><td><code id="rescaleI_+3A_samples">samples</code></td>
<td>
<p>number of permutations for the resampling method.</p>
</td></tr>
<tr><td><code id="rescaleI_+3A_scalingupto">scalingUpTo</code></td>
<td>
<p>the rescaling could be done up to the 0.01% and 99.99% quantile or max and min values. The two possible options are: &quot;MaxMin&quot;, or &quot;Quantile&quot;. The default value for this parameter is &quot;Quantile&quot;</p>
</td></tr>
<tr><td><code id="rescaleI_+3A_sd">sd</code></td>
<td>
<p>this represents upto which standard deviation you want to scale I</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with I, rescaleI and statistic summary for the inputs without scaling, the same statistics after scaling them, the p-value and the convexhull information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data &lt;- loadFile(fileInput)
scaledI&lt;-rescaleI(data,100)
</code></pre>

<hr>
<h2 id='saveFile'>Saves a report with important statistics to describe the sample.</h2><span id='topic+saveFile'></span>

<h3>Description</h3>

<p><code>saveFile</code> Saves a csv report with the following columns: Convex Hull Area, Convex Hull Centroid X, Convex Hull Centroid Y, Sample Size, Ichen, Iscaled, pvalue , Mean, MeanScaled, STD DEV, SDScaled, Q_1%, Q_1%Scaled, $Q_99%, Q_99%Scaled, Max, Max_Scaled, Min, Min_Scaled, Skew,Skew_Scaled, Kutorsis,Kutorsis_Scaled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveFile(fileName, results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveFile_+3A_filename">fileName</code></td>
<td>
<p>the name  of the file with the path where the CSV file will be saved.</p>
</td></tr>
<tr><td><code id="saveFile_+3A_results">results</code></td>
<td>
<p>is the vector obtained from running the rescaling process over all the variables of interest.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "chen.csv", package="Irescale")
data &lt;- loadFile(fileInput)
scaledI&lt;-rescaleI(data,1000)
fn = file.path(tempdir(),"output.csv",fsep = .Platform$file.sep)
saveFile(fn,scaledI)
if (file.exists(fn)){
    file.remove(fn)
}
</code></pre>

<hr>
<h2 id='standardize'>Standardize the input vector</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p><code>standardize</code> Calculates the z-values of the input vector.
#'</p>
<p style="text-align: center;"><code class="reqn">
z = \frac{vectorI - meanI}{\sqrt{varI}}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>standardize(vectorI, W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_vectori">vectorI</code></td>
<td>
<p>vector to be standardized.</p>
</td></tr>
<tr><td><code id="standardize_+3A_w">W</code></td>
<td>
<p>weighed distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W&lt;-matrix(runif(100, min=0, max=1),nrow=10,ncol=10)
vectorI&lt;-runif(10, min=0, max=1)
standardize(vectorI,W)
</code></pre>

<hr>
<h2 id='standardizedByColumn'>Scales a matrix by column.</h2><span id='topic+standardizedByColumn'></span>

<h3>Description</h3>

<p><code>standardizedByColumn</code> It considers each column independently to scale them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizedByColumn(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardizedByColumn_+3A_m">M</code></td>
<td>
<p>Matrix to be scaled by column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix scaled by column.
</p>

<hr>
<h2 id='summaryLocalIVector'>Calculates statistic for the received Matrix.</h2><span id='topic+summaryLocalIVector'></span>

<h3>Description</h3>

<p><code>summaryLocalIVector</code>. Calculates basic statistic of the received Matrix, like mean, standard deviation, maximum, minimum, 0.1% and 99.9% quantile and median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryLocalIVector(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryLocalIVector_+3A_vec">vec</code></td>
<td>
<p>the vector to calculate the summary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with mean, standard deviation, maximum, minimum, 0.1% and 99.9% quantile and median of the received vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
vI&lt;-resamplingLocalI(input$varOfInterest,distM)
statsVI&lt;-summaryLocalIVector(vI)
</code></pre>

<hr>
<h2 id='summaryVector'>Calculates statistic for the received vector.</h2><span id='topic+summaryVector'></span>

<h3>Description</h3>

<p><code>summaryVector</code>. Calculates basic statistic of the received vector, like mean, standard deviation, maximum, minimum, 0.1% and 99.9% quantile and median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryVector(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryVector_+3A_vec">vec</code></td>
<td>
<p>the vector to calculate the summary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with mean, standard deviation, maximum, minimum, 0.1% and 99.9% quantile and median of the received vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputFileName&lt;-system.file("testdata", "chen.csv", package="Irescale")
input&lt;-loadFile(inputFileName)
distM&lt;-calculateEuclideanDistance(input$data)
I&lt;-calculateMoranI(distM = distM,varOfInterest = input$varOfInterest)
vI&lt;-resamplingI(distM, input$varOfInterest)
statsVI&lt;-summaryVector(vI)
</code></pre>

<hr>
<h2 id='transformImageToList'>Transforms the image in the object need it to run the analysis.</h2><span id='topic+transformImageToList'></span>

<h3>Description</h3>

<p><code>transformImageToList</code> transforms the image into a list with two variables, data and varOfInterest, which are the identificators needed to execute the rectification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformImageToList(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformImageToList_+3A_im">im</code></td>
<td>
<p>cimg object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "imageGray.png", package="Irescale")
img&lt;-loadSatelliteImage(fileInput)
data&lt;-transformImageToList(img)
</code></pre>

<hr>
<h2 id='transformImageToMatrix'>Transforms the image to a matrix.</h2><span id='topic+transformImageToMatrix'></span>

<h3>Description</h3>

<p><code>transformImageToMatrix</code> transforms the image into a 2D matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformImageToMatrix(im)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformImageToMatrix_+3A_im">im</code></td>
<td>
<p>cimg object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fileInput &lt;- system.file("testdata", "imageGray.png", package="Irescale")
img&lt;-loadSatelliteImage(fileInput)
data&lt;-transformImageToList(img)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
