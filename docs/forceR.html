<!DOCTYPE html><html lang="en"><head><title>Help for package forceR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forceR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amp_drift_corr'><p>Charge Amplifier Drift Correction</p></a></li>
<li><a href='#avg_peaks'><p>Average Curves per Group</p></a></li>
<li><a href='#baseline_corr'><p>Automatic or Manual Baseline Correction of Time Series</p></a></li>
<li><a href='#classifier'><p>Classifier</p></a></li>
<li><a href='#convert_measurement'><p>Converts LJStream *.dat file to standard time series.</p></a></li>
<li><a href='#correct_peak'><p>Manually Correct Single Peak</p></a></li>
<li><a href='#crop_measurement'><p>Crop Time Series</p></a></li>
<li><a href='#df.all'><p>Simulated Force Measurements with Taxonomic Info.</p></a></li>
<li><a href='#df.all.200'><p>Simulated Time Series - e.g. Bite Force Measurements</p></a></li>
<li><a href='#df.all.200.tax'><p>Simulated Force Measurements with Taxonomic Info.</p></a></li>
<li><a href='#find_best_fits'><p>Find Best Polynomial Fits for Curves</p></a></li>
<li><a href='#find_strongest_peaks'><p>Find Peaks</p></a></li>
<li><a href='#forceR_example'><p>Get path to forceR example</p></a></li>
<li><a href='#load_mult'><p>Load Multiple Measurements</p></a></li>
<li><a href='#load_single'><p>Load single measurement</p></a></li>
<li><a href='#models'><p>Polynomial Models Describing Average Peak Shapes.</p></a></li>
<li><a href='#peak_duration_max_force'><p>Peak Duration and Maximum Force</p></a></li>
<li><a href='#peak_to_poly'><p>Convert Time Series to Polynomial</p></a></li>
<li><a href='#peaks.df'><p>Starts and Ends of the 5 Strongest Peaks</p></a></li>
<li><a href='#peaks.df.100.avg'><p>Average Peak Shapes per Species</p></a></li>
<li><a href='#peaks.df.norm'><p>Normalized Peak Shapes</p></a></li>
<li><a href='#peaks.df.norm.100'><p>Normalized Peak Shapes with 100 Observations</p></a></li>
<li><a href='#plot_measurement'><p>Plot raw measurement</p></a></li>
<li><a href='#plot_peaks'><p>Plot Peaks</p></a></li>
<li><a href='#print_progress'><p>Print progress</p></a></li>
<li><a href='#red_peaks_100'><p>Reduce Peaks</p></a></li>
<li><a href='#reduce_frq'><p>Reduce Sampling Frequency</p></a></li>
<li><a href='#rescale_peaks'><p>Rescale Peaks</p></a></li>
<li><a href='#rescale_to_range'><p>Scale data series to new minimum and maximum</p></a></li>
<li><a href='#simulate_bites'><p>Simulate bites</p></a></li>
<li><a href='#sort_files'><p>Sorts files after corrections</p></a></li>
<li><a href='#summarize_measurements'><p>Summarize Table</p></a></li>
<li><a href='#today'><p>Get Today's Date as String</p></a></li>
<li><a href='#y_to_force'><p>Convert Time Series to Force</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Force Measurement Analyses</td>
</tr>
<tr>
<td>Description:</td>
<td>For cleaning and analysis of graphs, such as animal closing force 
    measurements. 
    'forceR' was initially written and optimized to deal with insect bite force 
    measurements, but can be used for any time series. Includes a full workflow 
    to load, plot and crop data, correct amplifier and baseline drifts, 
    identify individual peak shapes (bites), rescale (normalize) peak curves, 
    and find best polynomial fits to describe and analyze force curve shapes.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.20</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-28</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Peter-T-Ruehr/forceR">https://github.com/Peter-T-Ruehr/forceR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Peter-T-Ruehr/forceR/issues">https://github.com/Peter-T-Ruehr/forceR/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, graphics, grDevices, filesstrings, magrittr, purrr,
readr, roll, stats, stringr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter T. Rühr &lt;peter.ruehr@gmail.com&gt;</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-28 14:37:38 UTC; pruehr</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter T. Rühr <a href="https://orcid.org/0000-0003-2776-6172"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alexander Blanke <a href="https://orcid.org/0000-0003-4385-6039"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-01 08:22:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='amp_drift_corr'>Charge Amplifier Drift Correction</h2><span id='topic+amp_drift_corr'></span>

<h3>Description</h3>

<p>Removes the systemic, asymptotical drift of charge amplifiers with
resistor-capacitor (RC) circuits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amp_drift_corr(
  filename,
  tau = 9400,
  res.reduction = 10,
  plot.to.screen = FALSE,
  write.data = FALSE,
  write.PDFs = FALSE,
  write.logs = FALSE,
  output.folder = NULL,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amp_drift_corr_+3A_filename">filename</code></td>
<td>
<p>Path to file on which amplifier drift correction should be
performed.</p>
</td></tr>
<tr><td><code id="amp_drift_corr_+3A_tau">tau</code></td>
<td>
<p>Numeric time constant of charge amplifier in the same time unit
as the measurement data.
Default: <code>9400</code></p>
</td></tr>
<tr><td><code id="amp_drift_corr_+3A_res.reduction">res.reduction</code></td>
<td>
<p>A numeric value to reduce the number of time steps by
during plotting. Speeds up
the plotting process and reduces PDF size. Has no effect on the results,
only on the plots. Default: <code>10</code>.</p>
</td></tr>
<tr><td><code id="amp_drift_corr_+3A_plot.to.screen">plot.to.screen</code></td>
<td>
<p>A logical value indicating if results should be
plotted in the current R plot device. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="amp_drift_corr_+3A_write.data">write.data</code></td>
<td>
<p>A logical value indicating if drift-corrected file should
be saved. If yes, it will be saved in <code>output.folder</code>.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="amp_drift_corr_+3A_write.pdfs">write.PDFs</code></td>
<td>
<p>A logical value indicating whether results should be saved
as PDFs. Does not slow
down the process as much as printing to the R plot device and is considered
necessary to quality check the results. If yes, it will be saved in
<code>output.folder/PDFs</code>. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="amp_drift_corr_+3A_write.logs">write.logs</code></td>
<td>
<p>A logical value indicating whether a log file with
information on the method and values used to correct the amplifier drift should be
saved. Is considered necessary for reproducibility. If yes, it will be saved
in <code>output.folder/logs</code>. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="amp_drift_corr_+3A_output.folder">output.folder</code></td>
<td>
<p>Path to folder where data, PDF and log files should
be stored.</p>
</td></tr>
<tr><td><code id="amp_drift_corr_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Slows down the process. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>forceR generally expects file names to start with a leading number specifying the
measurement number (E.g. &quot;0001_G_maculatus.csv&quot;). The number (&quot;0001&quot;) is used to
keep data files, log files, and PDF files of the same measurement associated
with each other.
</p>
<p>The input file should be in the following format:</p>

<table>
<tr>
 <td style="text-align: center;">
   <code>t</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.2</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns a tibble containing the amplifier drift-corrected data in the
following format</p>

<table>
<tr>
 <td style="text-align: center;">
   <code>t</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.2</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># define file for amplifier drift correction
filename &lt;- forceR_example(type = "raw")

# Run amplifier drift correction without saving files or printing to screen:
file.ampdriftcorr &lt;- amp_drift_corr(filename = filename,
                                     tau = 9400,
                                     res.reduction = 10,
                                     plot.to.screen = FALSE,
                                     write.data = FALSE,
                                     write.PDFs = FALSE,
                                     write.logs = FALSE,
                                     output.folder,
                                     show.progress = FALSE)
# file.ampdriftcorr

# Run amplifier drift correction with saving files and printing to screen:
#    - commented out to pass package tests
# file.ampdriftcorr &lt;- amp_drift_corr(filename = filename,
#                                       tau = 9400,
#                                       res.reduction = 10,
#                                       plot.to.screen = TRUE,
#                                       write.data = TRUE,
#                                       write.PDFs = TRUE,
#                                       write.logs = TRUE,
#                                       output.folder = "./ampdriftcorr",
#                                       show.progress = TRUE)
#
# file.ampdriftcorr

</code></pre>

<hr>
<h2 id='avg_peaks'>Average Curves per Group</h2><span id='topic+avg_peaks'></span>

<h3>Description</h3>

<p>Calculates mean curve shape per group (here: species) and rescales result on the y axis to range from 0 to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_peaks(df, path.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avg_peaks_+3A_df">df</code></td>
<td>
<p>The resulting tibble of the function <code>red_peaks_100()</code>. See <code>?red_peaks_100</code> for more details.</p>
</td></tr>
<tr><td><code id="avg_peaks_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results.
If <code>NULL</code>, data will not be saved to disk. Default: <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a tibble made of three columns: <code>species</code> containing the species names, <code>index</code> ranging from 1 to 100 for each species,
and <code>force.norm.100</code> containing the averaged and rescaled curve of each species.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the forceR::df.all.200.tax dataset:

# calculate mean curves per species
peaks.df.100.avg &lt;- avg_peaks(df = forceR::peaks.df.norm.100,
                               path.data = NULL)

# plot averaged normalized curves per species
require(ggplot2)
ggplot(peaks.df.100.avg,
          aes(x = index ,
               y = force.norm.100.avg,
               colour=species)) +
  geom_line()

</code></pre>

<hr>
<h2 id='baseline_corr'>Automatic or Manual Baseline Correction of Time Series</h2><span id='topic+baseline_corr'></span>

<h3>Description</h3>

<p>If baseline (zero-line) of measurement is unstable (e.g. due to temperature fluctuations, wind, ...),
the baseline needs to be continually adjusted throughout the measurement. This script allows an
automatic adjustment of the baseline.
The automatic approach invokes a sliding window, during which the 'minimum' within each sliding window
is stored. A 'minimum' is defined by the <code>quantile.size</code>: if set to <code>0.05</code>, the value below which only 5% of
the measurement data within the sliding window lies, is treated as the current window's minimum. This
prevents the treatment of potential artifacts as minima. In a second iteration, another sliding window
calculates the average of these 'minima'. The resulting values are subtracted from
the original time series. This approach works well for time series with relatively short peaks.
If the automatic approach does not yield acceptable results, an interactive manual approach to correct
the baseline can be performed instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_corr(
  filename,
  corr.type = "auto",
  window.size.mins = 1000,
  window.size.means = NULL,
  quantile.size = 0.05,
  y.scale = 0.5,
  res.reduction = 10,
  Hz = 100,
  plot.to.screen = FALSE,
  write.data = FALSE,
  write.PDFs = FALSE,
  write.logs = FALSE,
  output.folder = NULL,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baseline_corr_+3A_filename">filename</code></td>
<td>
<p>A character string containing the full path to the measurement file that needs correction.
See Details for info on what the file should look like.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_corr.type">corr.type</code></td>
<td>
<p>Character string defining the desired mode of baseline correction. One of <code>"auto"</code>
or <code>"manual"</code>. Default: <code>"auto"</code></p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_window.size.mins">window.size.mins</code></td>
<td>
<p>A numeric value for the size of the search window to find minima in. Should be
in the same time unit as the measurement. Longer peaks require higher values, shorter peaks require
smaller values. Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_window.size.means">window.size.means</code></td>
<td>
<p>A numeric value for the size of the window to average the minima in. Should be
in the same time unit as the measurement. By default (<code>NULL</code>), the same value as specified for
<code>window.size.mins</code> is used.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_quantile.size">quantile.size</code></td>
<td>
<p>A numerical value between <code>0</code> and <code>1</code> to define the quantile which is treated as
the 'minimum' of a sliding window. Default: <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_y.scale">y.scale</code></td>
<td>
<p>A numeric value to reduce the y-axis range during plotting. This simplifies the manual
placement of the points during the manual correction procedure.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_res.reduction">res.reduction</code></td>
<td>
<p>A numeric value to reduce the number of time steps by during plotting. Speeds up
the plotting process and reduces PDF size. Has no effect on the results, only on the plots. Default: <code>10</code>.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_hz">Hz</code></td>
<td>
<p>A numeric value to reduce sampling frequency for temporary analyses. This works as a smoothing
filter during temporary analyses and does not reduce the actual sampling frequency of the data.
Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_plot.to.screen">plot.to.screen</code></td>
<td>
<p>A logical value indicating if results should be
plotted in the current R plot device. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_write.data">write.data</code></td>
<td>
<p>A logical value indicating if drift-corrected file should
be saved. If yes, it will be saved in <code>output.folder</code>.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_write.pdfs">write.PDFs</code></td>
<td>
<p>A logical value indicating whether results should be saved
as PDFs. Does not slow
down the process as much as printing to the R plot device and is considered
necessary to quality check the results. If yes, it will be saved in
<code>output.folder/PDFs</code>. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_write.logs">write.logs</code></td>
<td>
<p>A logical value indicating whether a log file with
information on the method and values used to correct the baseline drift should be
saved. Is considered necessary for reproducibility. If yes, it will be saved
in <code>output.folder/logs</code>. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_output.folder">output.folder</code></td>
<td>
<p>Path to folder where data, PDF and log files should
be stored. Default: <code>NULL.</code></p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>forceR</code> generally expects file names to start with a leading number specifying the
measurement number (E.g. &quot;0001_G_maculatus.csv&quot;). The number (&quot;0001&quot;) is used to
keep data files, log files, and PDF files of the same measurement associated
with each other.
</p>
<p>The input files should to be in the following format:</p>

<table>
<tr>
 <td style="text-align: center;">
   <code>t</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.2</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>In case there are more than two columns, only the first two columns will be used. If the first two columns
are not named 't' and 'y', they will be renamed.
</p>


<h3>Value</h3>

<p>Returns a tibble containing the amplifier baseline drift-corrected data in the
following format</p>

<table>
<tr>
 <td style="text-align: center;">
   <code>t</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.2</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>#'########### AUTOMATIC MODE
# define file to apply the baseline drift correction to
filename &lt;- forceR_example(type = "ampdriftcorr")

# run automatic baseline drift corrections without saving files or
#   printing to screen:
file.baseline_corr &lt;- baseline_corr(filename = filename,
                                     corr.type = "auto",
                                     window.size.mins = 1000,
                                     window.size.means = NULL,
                                     quantile.size = 0.05,
                                     y.scale = 0.5,
                                     res.reduction = 10,
                                     Hz = 100,
                                     plot.to.screen = FALSE,
                                     write.data = FALSE,
                                     write.PDFs = FALSE,
                                     write.logs = FALSE,
                                     show.progress = FALSE)

file.baseline_corr

#'########### MANUAL MODE

# define file to apply the baseline drift correction to
filename &lt;- forceR_example(type = "ampdriftcorr")

# run interactive baseline drift corrections with saving files and
#   printing to screen:  - out-commented to pass package tests

# file.baseline_corr &lt;- baseline_corr(filename = filename,
#                                       corr.type = "manual",
#                                       window.size.mins = 1000,
#                                       window.size.means = NULL,
#                                       quantile.size = 0.05,
#                                       y.scale = 0.5,
#                                       res.reduction = 10,
#                                       Hz = 100,
#                                       plot.to.screen = TRUE,
#                                       output.folder = "./baselinecorr",
#                                       show.progress = TRUE)

# file.baseline_corr
</code></pre>

<hr>
<h2 id='classifier'>Classifier</h2><span id='topic+classifier'></span>

<h3>Description</h3>

<p>Start and end time values of the 5 strongest peaks per species of <code>df.all</code>
with the names of the measurements in which they occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifier
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 5 columns:
</p>

<dl>
<dt>species</dt><dd><p>species names</p>
</dd>
<dt>specimen</dt><dd><p>specimen names</p>
</dd>
<dt>measurement</dt><dd><p>measurement names</p>
</dd>
<dt>amp</dt><dd><p>amplifier values, in V/N</p>
</dd>
<dt>lever.ratio</dt><dd><p>ration of on-lever to out-lever of mesaurement setup</p>
</dd>
</dl>



<h3>Details</h3>

<p>Result of <code>rescale_peaks()</code>.
</p>

<hr>
<h2 id='convert_measurement'>Converts LJStream *.dat file to standard time series.</h2><span id='topic+convert_measurement'></span>

<h3>Description</h3>

<p>Converts LJStream *.dat file to standard time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_measurement(file, path.data = NULL, collect_garbage = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_measurement_+3A_file">file</code></td>
<td>
<p>File path to raw measurement (*.dat file).</p>
</td></tr>
<tr><td><code id="convert_measurement_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results. If <code>NULL</code>,
data is not stored in a file. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="convert_measurement_+3A_collect_garbage">collect_garbage</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the <code>gc()</code> command will be
run silently to try to clean up memory. This may help when running
<code>convert_measurement</code> in a loop, even though memory cluttering cannot be
fully prevented. If such a loop crashes, the loop should be split into
several separate loops to convert all files. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns and, if <code style="white-space: pre;">&#8288;path.data is not NULL&#8288;</code>, saves data in
csv-format in <code>path.data</code>. <br />
<br />
The output tibble has the following format:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <strong><code>y</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># get file path of forceR example file
filename &lt;- forceR_example(type = "LJStream")
file.converted &lt;- convert_measurement (file = filename,
                       path.data = NULL)
file.converted

</code></pre>

<hr>
<h2 id='correct_peak'>Manually Correct Single Peak</h2><span id='topic+correct_peak'></span>

<h3>Description</h3>

<p>Interactive correction of a single peak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_peak(
  df.peaks,
  df.data,
  measurement,
  peak,
  additional.msecs = 500,
  path.data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_peak_+3A_df.peaks">df.peaks</code></td>
<td>
<p>The resulting tibble of the function <code>find_peaks()</code>. See <code>?find_peaks</code> for more details.</p>
</td></tr>
<tr><td><code id="correct_peak_+3A_df.data">df.data</code></td>
<td>
<p>A data frame or tibble in the below format. The columns <code>t</code> (time), <code>force</code>, <code>measurement</code>, and <code>specimen</code>.
(measurement ID) must be present. This will usually be the same table that was used before in <code>find_peaks()</code>.</p>
</td></tr>
<tr><td><code id="correct_peak_+3A_measurement">measurement</code></td>
<td>
<p>A character string defining the measurement ID (e.g. measurement number) of the peak to be corrected. Must be congruent with the
respective measurement ID within <code>df.peaks</code> and <code>df</code>.</p>
</td></tr>
<tr><td><code id="correct_peak_+3A_peak">peak</code></td>
<td>
<p>A numerical value defining the peak to be corrected.</p>
</td></tr>
<tr><td><code id="correct_peak_+3A_additional.msecs">additional.msecs</code></td>
<td>
<p>A numerical value defining the time before and after the originally defined window of the peak to be corrected. Higher
values allow defining start and end points further away from the original start and end points. Default: <code>500</code>.
@param path.data A string character defining where to save the result and log file. If <code>NULL</code> (default),
data is not stored in files. Log files cannot be retrieved in this case.</p>
</td></tr>
<tr><td><code id="correct_peak_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results. If <code>NULL</code> (default),
data is not stored in a file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When running the function, you will be prompted to select the actual start and end of the current <code>peak</code> of the current <code>measurement</code>. If more or less
than exactly 2 points are defined, the process is terminated.
</p>


<h3>Value</h3>

<p>Changes values within <code>df.peaks</code> and returns the changed tibble.
</p>


<h3><code>df.data</code> needs to contain the following columns:</h3>


<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>force</code></strong> </td><td style="text-align: center;"> <strong><code>measurement</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>force.1</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>force.n</code> </td><td style="text-align: center;"> <code>measurement.m</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># Using the forceR::df.all.200.tax dataset:

# This function needs user input.
peaks.df &lt;- correct_peak(df.peaks = forceR::peaks.df,
                        df.data = forceR::df.all.200.tax,
                        measurement = "m_01",
                        peak = 1,
                        additional.msecs = 5)

</code></pre>

<hr>
<h2 id='crop_measurement'>Crop Time Series</h2><span id='topic+crop_measurement'></span>

<h3>Description</h3>

<p>Interactive function to crop a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_measurement(file, path.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop_measurement_+3A_file">file</code></td>
<td>
<p>File path to measurement.</p>
</td></tr>
<tr><td><code id="crop_measurement_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results. If <code>NULL</code>,
data is not stored in a file. Default: <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Select points at start and end of desired part of measurements.
Only the last two points will be
taken into account to allow the user to correct erroneous clicks.
</p>
<p>If a measurement contains two distinct regions of bites with a lot of
unnecessary data and/or measurement artefacts in-between (such as user-made
peaks), I recommend to manually copy the RAW data files, give the copy a
new measurement number (as if it was actually a separate measurement), and
crop the distinct parts containing actual bites separately from the two
copies of the file. For more distinct regions, create more copies.
</p>
<p>I recommend to not crop the files too much in case baseline corrections are
needed later, because then the <code>baseline_corr()</code> function will not be able
to figure out where the actual baseline might be. Leaving several seconds
before and after the first and last bite of a series will prevent such
problems.
</p>


<h3>Value</h3>

<p>Returns and, if <code style="white-space: pre;">&#8288;path.data is not NULL&#8288;</code>, saves data in
csv-format in <code>path.data</code>. <br />
<br />
The tibble has the following format:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <strong><code>y</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># get file path of forceR example file
filename &lt;- forceR_example(type = "raw")

# # crop file without storing result as file - out-commented to pass package tests
# file.cropped &lt;- crop_measurement(file = filename,
#                    path.data = NULL)

# file.cropped

</code></pre>

<hr>
<h2 id='df.all'>Simulated Force Measurements with Taxonomic Info.</h2><span id='topic+df.all'></span>

<h3>Description</h3>

<p>A series of 24 measurements with six simulated peaks each.
Simulated using the <code>simulate_bites()</code> function .
Fits the <code>classifier</code> sheet that is also part of the <code>forceR</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df.all
</code></pre>


<h3>Format</h3>

<p>A data frame with 9,600 rows and 3 columns:
</p>

<dl>
<dt>t</dt><dd><p>time, in ms</p>
</dd>
<dt>y</dt><dd><p>measured values, in V</p>
</dd>
<dt>measurement</dt><dd><p>measurement names</p>
</dd>
</dl>


<hr>
<h2 id='df.all.200'>Simulated Time Series - e.g. Bite Force Measurements</h2><span id='topic+df.all.200'></span>

<h3>Description</h3>

<p>A series of 24 measurements with six simulated peaks each.
Simulated using the <code>simulate_bites()</code> function. Reduced to a sampling
frequency of 200 Hz with <code>reduce_frq()</code>. Fits the <code>classifier</code> sheet that
is also part of the <code>forceR</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df.all.200
</code></pre>


<h3>Format</h3>

<p>A data frame with 1,944 rows and 3 columns:
</p>

<dl>
<dt>t</dt><dd><p>time, in ms</p>
</dd>
<dt>y</dt><dd><p>measured values, in V</p>
</dd>
<dt>measurement</dt><dd><p>measurement names</p>
</dd>
</dl>


<hr>
<h2 id='df.all.200.tax'>Simulated Force Measurements with Taxonomic Info.</h2><span id='topic+df.all.200.tax'></span>

<h3>Description</h3>

<p>A series of 24 measurements with six simulated peaks each.
Simulated using the <code>simulate_bites()</code> function and translated into force
values with <code>y_to_force()</code>. Fits the <code>classifier</code> sheet that
is also part of the <code>forceR</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df.all.200.tax
</code></pre>


<h3>Format</h3>

<p>A data frame with 1,944 rows and 5 columns:
</p>

<dl>
<dt>species</dt><dd><p>species names</p>
</dd>
<dt>specimen</dt><dd><p>specimen names</p>
</dd>
<dt>measurement</dt><dd><p>measurement names</p>
</dd>
<dt>t</dt><dd><p>time, in ms</p>
</dd>
<dt>force</dt><dd><p>measured values, in N</p>
</dd>
</dl>


<hr>
<h2 id='find_best_fits'>Find Best Polynomial Fits for Curves</h2><span id='topic+find_best_fits'></span>

<h3>Description</h3>

<p>Calculates best model fits for all curves based on AIC criterion. The function fits polynomial functions with 1 to 20 coefficients and uses the Akaike Information
Criterion (AIC) to evaluate the goodness of the fits. A model is considered a good fit, when the percentage of change from one model to the next (e.g. a model with
6 coefficients to a model with 7 coefficients) is, e.g. <code style="white-space: pre;">&#8288;&lt; 5%&#8288;</code> when <code>threshold = 5</code>. The first for models meeting this criterion are plotted as colored graphs and the AICs of these models
are visualized in a second plot for each curve. All first four coefficients per curve that fulfill the criterion are stored and in the end, a histogram of how
often which coefficients were good fits is plotted as well. The function returns the numerical value of the coefficient that fulfilled the criterion of a good fit
in most curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_fits(
  df,
  degrees = 1:20,
  threshold = 5,
  zero_threshold = NULL,
  plot.to.screen = FALSE,
  path.data = NULL,
  path.plots = NULL,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_best_fits_+3A_df">df</code></td>
<td>
<p>The resulting tibble of the function <code>avg_peaks()</code>. See below for more details.</p>
</td></tr>
<tr><td><code id="find_best_fits_+3A_degrees">degrees</code></td>
<td>
<p>Numerical vector of polynomial degrees to test. Cannot be infinitely high - if two high, throws error: <code style="white-space: pre;">&#8288;'degree' must be less than number of unique points&#8288;</code>.
Default: <code>1:20</code>.</p>
</td></tr>
<tr><td><code id="find_best_fits_+3A_threshold">threshold</code></td>
<td>
<p>Percentage of AIC change compared to previous degree to fit the good-fit-criteria (s.a.). Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="find_best_fits_+3A_zero_threshold">zero_threshold</code></td>
<td>
<p>Either numerical or <code>NULL</code>: If numerical, the function checks if the graph of the current model starts and ends near zero,
e.g. below 0.2 if <code>zero_threshold = 0.2</code>. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="find_best_fits_+3A_plot.to.screen">plot.to.screen</code></td>
<td>
<p>A logical value indicating if results should be
plotted in the current R plot device. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="find_best_fits_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results. If <code>NULL</code>,
data is not stored in a file. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="find_best_fits_+3A_path.plots">path.plots</code></td>
<td>
<p>A string character defining where to save the plots. If <code>NULL</code>,
plots will not be saved to PDF files. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="find_best_fits_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' This function expects a tibble made of three columns as <code>df</code>: <code>species</code> containing the species names,
<code>index</code> numerical column, e.g. time (but can be arbitrary continuous unit), for each species,
and <code>force.norm.100</code> containing the averaged and rescaled curve of each species.
</p>


<h3>Value</h3>

<p>Returns the a numerical value representing the number of coefficient that was most often under the first 4 models that were followed by an
AIC-change <code style="white-space: pre;">&#8288;&lt;= 5%&#8288;</code> by the next model. Additionally, plots showing the model fits and a histogram of the coefficients that met the 5%-criterion can be
plotted to the plot device or saved as PDFs in <code>path.plots</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the forceR::peaks.df.100.avg dataset:

# find smallest polynomial degree that best describes all curves
best.fit.poly &lt;- find_best_fits(df = forceR::peaks.df.100.avg)

best.fit.poly

</code></pre>

<hr>
<h2 id='find_strongest_peaks'>Find Peaks</h2><span id='topic+find_strongest_peaks'></span>

<h3>Description</h3>

<p>Identifies peaks in a first iteration and optimizes the starts and ends of the strongest peaks per species in a second iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_strongest_peaks(
  df,
  no.of.peaks = 5,
  initial.threshold = 0.05,
  slope.length.start = 5,
  slope.length.end = 5,
  slope.thresh.start = 0.02,
  slope.thresh.end = 0.02,
  path.data = NULL,
  path.plots = NULL,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_strongest_peaks_+3A_df">df</code></td>
<td>
<p>A data frame or tibble in the below format. The columns <code>t</code> (= time), <code>force</code> and <code>measurement</code>
(= measurement ID) must be present.</p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_no.of.peaks">no.of.peaks</code></td>
<td>
<p>A numeric value defining how many peaks per <code>species</code> (not per <code>measurement</code>&quot;) should be identified. The function will always return
the strongest peaks. Default: <code>5</code></p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_initial.threshold">initial.threshold</code></td>
<td>
<p>A numeric value defining the threshold (in % of the maximum force of the measurement)
that is used during the first iteration. Default: <code>0.05</code></p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_slope.length.start">slope.length.start</code></td>
<td>
<p>A numeric value defining the window size (in time steps) of
slope calculation for peak starts during the second iteration. Default: <code>5</code></p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_slope.length.end">slope.length.end</code></td>
<td>
<p>A numeric value defining the window size (in time steps) of
slope calculation for peak ends during the second iteration. Default: <code>5</code></p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_slope.thresh.start">slope.thresh.start</code></td>
<td>
<p>A numeric value defining the threshold at which to stop the sliding window and save the
current time point as the actual start of the current peak. Default: <code>0.04</code></p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_slope.thresh.end">slope.thresh.end</code></td>
<td>
<p>A numeric value defining the threshold at which to stop the sliding window and save the
current time point as the actual end of the current peak. Default: <code>0.04</code></p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results. If <code>NULL</code> (default),
data is not stored in a file. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_path.plots">path.plots</code></td>
<td>
<p>A string character defining where to save the plots. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="find_strongest_peaks_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data frame <code>df</code> needs to contain the following columns:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>force</code></strong> </td><td style="text-align: center;"> <strong><code>measurement</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>force.1</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>force.n</code> </td><td style="text-align: center;"> <code>measurement.m</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Creates a tibble in the following format and saves it as a CSV-file:
The column <strong><code>species</code></strong> contains one species per row<br /> (<code style="white-space: pre;">&#8288;species.1 ... species.n&#8288;</code>).
</p>
<p>The column <strong><code>measurements</code></strong> contains as many measurements as <code>no.of.peaks</code>, separated by '<code style="white-space: pre;">&#8288;;&#8288;</code>':<br /> (<code style="white-space: pre;">&#8288;measurement.1; ...; measurements.no.of.peaks&#8288;</code>).
</p>
<p>The column <strong><code>starts</code></strong> contains as many peak starts as <code>no.of.peaks</code>, separated by '<code style="white-space: pre;">&#8288;;&#8288;</code>':<br /> (<code style="white-space: pre;">&#8288;start.1; ...; start.no.of.peaks&#8288;</code>).
</p>
<p>The column <strong><code>ends</code></strong> contains as many peak ends as <code>no.of.peaks</code>, separated by '<code style="white-space: pre;">&#8288;;&#8288;</code>':<br /> (<code style="white-space: pre;">&#8288;end.1; ...; end.no.of.peaks&#8288;</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(dplyr)
# Using the forceR::df.all.200.tax dataset:

# reduce dataset (only rows 40 to 95 of species A (containing data of
  # measurement 1 and 2 (m_01 and m_02)))
df.all.200.tax_filtered &lt;- forceR::df.all.200.tax[40:95, ] %&gt;%
  filter(species == "species_A")

# find the 4 strongest peaks
peaks.df &lt;- find_strongest_peaks(df = df.all.200.tax_filtered,
                                 no.of.peaks = 4)

# plot results (three peaks in measurement 1, 1 peak in measurement 2):
# plot_peaks(df.peaks = peaks.df,
#            df.data = df.all.200.tax_filtered,
#            additional.msecs = 20)

</code></pre>

<hr>
<h2 id='forceR_example'>Get path to forceR example</h2><span id='topic+forceR_example'></span>

<h3>Description</h3>

<p>forceR comes with example files of short bite force measurements.
The files are stored in <code style="white-space: pre;">&#8288;forceR's&#8288;</code> <code>inst/extdata</code>
folder, and this function returns the path to that folder or one of the
files  so they can be used in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forceR_example(type = "folder")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forceR_example_+3A_type">type</code></td>
<td>
<p>A character string (either <code>"folder"</code>, <code>"raw"</code>, or
<code>"ampdriftcorr"</code>) defining if the path returned be the function
should point to one of the the example files or the folder containing them.
Default: <code>"folder"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type = "folder"</code>: returns the file path to the folder containing
<code>BF_raw.csv</code> and
<code>BF_ampdriftcorr.csv</code>.
</p>
<p>If <code>type = "LJStream"</code>: returns the file path
to <code>BF_raw.csv</code>, which contains a short bite force raw
measurement.
</p>
<p>If <code>type = "raw"</code>: returns the file path
to <code>BF_raw.csv</code>, which contains a short bite force raw
measurement.
</p>
<p>If <code>type = "ampdriftcorr"</code>: returns the file path
to <code>BF_ampdriftcorr.csv</code>, which contains a short bite
force raw measurement where the amplifier drift as been corrected for by
the amp_drift_corr() funcion.
</p>

<hr>
<h2 id='load_mult'>Load Multiple Measurements</h2><span id='topic+load_mult'></span>

<h3>Description</h3>

<p>Loads multiple measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_mult(folder, columns = c(1:2), show.progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_mult_+3A_folder">folder</code></td>
<td>
<p>Character string containing the path to the measurements.</p>
</td></tr>
<tr><td><code id="load_mult_+3A_columns">columns</code></td>
<td>
<p>A vector of column numbers. The first entry will be used as the x-axis values, the second entry as y-axis values.
All other columns will be ignored. Default: <code>c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="load_mult_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input files need to be in the following format (even though column names do not matter):</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>y</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>y.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>All columns except the first two are removed.
</p>


<h3>Value</h3>

<p>Returns a tibble in the format</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>y</code></strong> </td><td style="text-align: center;"> <strong><code>filename</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>y.1</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>y.n</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># store name of folder that contains files
input.folder &lt;- forceR_example(type = "folder")

# load a mutiple files
df.all &lt;- load_mult(folder = input.folder,
                    columns = c(1:2),
                    show.progress = FALSE)
</code></pre>

<hr>
<h2 id='load_single'>Load single measurement</h2><span id='topic+load_single'></span>

<h3>Description</h3>

<p>Loads a single measurement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_single(filename, columns = c(1:2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_single_+3A_filename">filename</code></td>
<td>
<p>Character string containing the path to measurement file.</p>
</td></tr>
<tr><td><code id="load_single_+3A_columns">columns</code></td>
<td>
<p>A vector of column numbers. The first entry will be used as the x-axis values, the second entry as y-axis values.
All other columns will be ignored. Default: <code>c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' The input files need to be in the following format (even though column names do not matter):</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <strong><code>y</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>All columns except the first two are removed.
</p>


<h3>Value</h3>

<p>A tibble with two columns named &quot;t&quot; and &quot;y&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Store filename
filename &lt;- forceR_example(type="raw")

df.1 &lt;- load_single(filename,
                    columns = c(1:2))

</code></pre>

<hr>
<h2 id='models'>Polynomial Models Describing Average Peak Shapes.</h2><span id='topic+models'></span>

<h3>Description</h3>

<p>Extracted from <code>df.all</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>models
</code></pre>


<h3>Format</h3>

<p>A list with 4 named entries, each containing the 4-degree polynomial
model that describes the average peak shape of the given species.
</p>

<hr>
<h2 id='peak_duration_max_force'>Peak Duration and Maximum Force</h2><span id='topic+peak_duration_max_force'></span>

<h3>Description</h3>

<p>Calculate duration and maximum force for each individual peak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak_duration_max_force(
  df.peaks,
  df.data,
  path.data = NULL,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peak_duration_max_force_+3A_df.peaks">df.peaks</code></td>
<td>
<p>The resulting tibble of the function <code>find_peaks()</code>. See <code>?find_peaks</code> for more details.</p>
</td></tr>
<tr><td><code id="peak_duration_max_force_+3A_df.data">df.data</code></td>
<td>
<p>A data frame or tibble in the below format. The columns <code>t</code> (time), <code>force</code>, <code>measurement</code>, and <code>specimen</code>.
(measurement ID) must be present. This will usually be the same table that was used before in <code>find_peaks()</code>.</p>
</td></tr>
<tr><td><code id="peak_duration_max_force_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results. If <code>NULL</code> (default),
data is not stored in a file.</p>
</td></tr>
<tr><td><code id="peak_duration_max_force_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Changes values within <code>df.peaks</code> and returns the changed tibble.
</p>


<h3><code>df.data</code> needs to contain the following columns:</h3>


<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>force</code></strong> </td><td style="text-align: center;"> <strong><code>measurement</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>force.1</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>force.n</code> </td><td style="text-align: center;"> <code>measurement.m</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># Using the forceR::df.all.200.tax dataset:

# This function needs user input.
peaks.df &lt;- correct_peak(df.peaks = forceR::peaks.df,
                        df.data = forceR::df.all.200.tax,
                        measurement = "m_01",
                        peak = 1,
                        additional.msecs = 5)

</code></pre>

<hr>
<h2 id='peak_to_poly'>Convert Time Series to Polynomial</h2><span id='topic+peak_to_poly'></span>

<h3>Description</h3>

<p>Convert Time Series to Polynomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak_to_poly(df, coeff, path.data = NULL, show.progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peak_to_poly_+3A_df">df</code></td>
<td>
<p>The resulting tibble of the function <code>avg_peaks()</code>. See <code>?avg_peaks</code> for more details.</p>
</td></tr>
<tr><td><code id="peak_to_poly_+3A_coeff">coeff</code></td>
<td>
<p>A numerical value indicating the number of coefficients the model used to fit on the time series data should have.</p>
</td></tr>
<tr><td><code id="peak_to_poly_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results as
<code style="white-space: pre;">&#8288;*.csv&#8288;</code> and <code style="white-space: pre;">&#8288;*.R&#8288;</code>. If <code>NULL</code>, data is not stored in files. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="peak_to_poly_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the length equal to the number of unique species within <code>df</code> containing the fitted models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the forceR::peaks.df.100.avg dataset:

# define the number of coefficients the polynomial models should have
number_of_coeffs = 4

# convert curves to polynomial models
models &lt;- peak_to_poly(df = forceR::peaks.df.100.avg,
                        coeff = number_of_coeffs)

models
</code></pre>

<hr>
<h2 id='peaks.df'>Starts and Ends of the 5 Strongest Peaks</h2><span id='topic+peaks.df'></span>

<h3>Description</h3>

<p>Start and end time values of the 5 strongest peaks per species of <code>df.all</code>
with the names of the measurements in which they occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks.df
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 rows and 4 columns:
</p>

<dl>
<dt>species</dt><dd><p>species names</p>
</dd>
<dt>measurements</dt><dd><p>measurement names</p>
</dd>
<dt>starts</dt><dd><p>start values, in ms</p>
</dd>
<dt>ends</dt><dd><p>end values, in ms</p>
</dd>
</dl>



<h3>Details</h3>

<p>Result of <code>rescale_peaks()</code>.
</p>

<hr>
<h2 id='peaks.df.100.avg'>Average Peak Shapes per Species</h2><span id='topic+peaks.df.100.avg'></span>

<h3>Description</h3>

<p>Normalized force values describing the average shape of the 5 strongest peaks
per species of <code>df.all</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks.df.100.avg
</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and 3 columns:
</p>

<dl>
<dt>species</dt><dd><p>species names</p>
</dd>
<dt>index</dt><dd><p>values from 1:100 in each species</p>
</dd>
<dt>force.norm.100.avg</dt><dd><p>normalized values reduced to 100 observations per
species, in N</p>
</dd>
</dl>


<hr>
<h2 id='peaks.df.norm'>Normalized Peak Shapes</h2><span id='topic+peaks.df.norm'></span>

<h3>Description</h3>

<p>Normalized force values describing the shapes of all 5 strongest peaks
per species of <code>df.all</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks.df.norm
</code></pre>


<h3>Format</h3>

<p>A data frame with 223 rows and 6 columns:
</p>

<dl>
<dt>measurement</dt><dd><p>measurement names</p>
</dd>
<dt>peak</dt><dd><p>peak numbers</p>
</dd>
<dt>t.norm</dt><dd><p>time values from 0:1 in each measurement, in ms</p>
</dd>
<dt>force.norm</dt><dd><p>force values from 0:1 in each measurement, in N</p>
</dd>
<dt>species</dt><dd><p>species names</p>
</dd>
<dt>specimen</dt><dd><p>specimen names</p>
</dd>
</dl>



<h3>Details</h3>

<p>Result of <code>rescale_peaks()</code>.
</p>

<hr>
<h2 id='peaks.df.norm.100'>Normalized Peak Shapes with 100 Observations</h2><span id='topic+peaks.df.norm.100'></span>

<h3>Description</h3>

<p>Normalized force values describing the shapes of all 5 strongest peaks
per species of <code>df.all</code>, reduced to 100 observations per measurement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks.df.norm.100
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 6 columns:
</p>

<dl>
<dt>species</dt><dd><p>species names</p>
</dd>
<dt>measurement</dt><dd><p>measurement names</p>
</dd>
<dt>specimen</dt><dd><p>specimen names</p>
</dd>
<dt>peak</dt><dd><p>peak numbers</p>
</dd>
<dt>index</dt><dd><p>values from 1:100 in each measurement</p>
</dd>
<dt>force.norm.100</dt><dd><p>normalized values reduced to 100 observations per
measurement, in N</p>
</dd>
</dl>



<h3>Details</h3>

<p>Result of <code>rescale_peaks()</code>.
</p>

<hr>
<h2 id='plot_measurement'>Plot raw measurement</h2><span id='topic+plot_measurement'></span>

<h3>Description</h3>

<p>Plots a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_measurement(file, columns = c(1:2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_measurement_+3A_file">file</code></td>
<td>
<p>File path to measurement.</p>
</td></tr>
<tr><td><code id="plot_measurement_+3A_columns">columns</code></td>
<td>
<p>A vector of column numbers. The first entry will be used as the x-axis values, the second entry as y-axis values.
All other columns will be ignored. Default: <code>c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' The input files need to be in the following format (even though column names do not matter):</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <strong><code>y</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;">  </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Creates a plot in the current plot device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename = forceR_example(type = "raw")
plot_measurement(filename)

</code></pre>

<hr>
<h2 id='plot_peaks'>Plot Peaks</h2><span id='topic+plot_peaks'></span>

<h3>Description</h3>

<p>Plots the peaks identified by the function <code>find_peaks()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_peaks(
  df.peaks,
  df.data,
  additional.msecs = 2000,
  plot.to.screen = TRUE,
  path.plots = NULL,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_peaks_+3A_df.peaks">df.peaks</code></td>
<td>
<p>df.peaks The resulting tibble of the function <code>find_peaks()</code>. See <code>?find_peaks</code> for more details.</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_df.data">df.data</code></td>
<td>
<p>A data frame or tibble in the below format. The columns <code>t</code> (time), <code>force</code> and <code>measurement</code>
(measurement ID) must be present. This will usually be the same table that was used before in <code>find_peaks()</code>.</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_additional.msecs">additional.msecs</code></td>
<td>
<p>A numeric value indicating how many m.secs before and after the actual peak curve should be plotted. Default: <code>2000</code></p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_plot.to.screen">plot.to.screen</code></td>
<td>
<p>A logical value indicating if results should be
plotted in the current R plot device. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_path.plots">path.plots</code></td>
<td>
<p>A string character defining where to save the plots. If <code>NULL</code>,
plots will not be saved to PDF files. Default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>df.peaks</code> at least needs to contain the following columns:
</p>
<p><strong><code>measurements</code></strong> |  <strong><code>starts</code></strong> |  <strong><code>ends</code></strong> |
| :&mdash;-: | :&mdash;-: |:&mdash;-: |:&mdash;-: |
| <code>measurements.1</code> | <code>starts.1</code> | <code>ends.1</code> |
| <code>...</code> |  <code>...</code> |  <code>...</code> |
| <code>measurements.n</code> | <code>starts.m</code> | <code>ends.m</code> |
</p>
<p>Check <code>forceR::peaks.df</code> to see an example tibble.
</p>
<p><code>df.data</code> at least needs to contain the following columns:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>force</code></strong> </td><td style="text-align: center;"> <strong><code>measurement</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>force.1</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>force.n</code> </td><td style="text-align: center;"> <code>measurement.m</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>Check <code>forceR::df.all.200.tax</code> to see an example tibble.
</p>


<h3>Value</h3>

<p>Plots one graph per peak curve and, if <code>plot.to.pdf == TURE</code>, saves all peak curves as one PDF at <code>path.plots</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the first row of forceR::peaks.df and the forceR::df.all.200.tax dataset:

# plot peaks
plot_peaks(df.peaks = forceR::peaks.df[1, ],
           df.data = forceR::df.all.200.tax,
           additional.msecs = 20) # instead of the default (2000) because of
                                  # the highly downsampled example dataset.

</code></pre>

<hr>
<h2 id='print_progress'>Print progress</h2><span id='topic+print_progress'></span>

<h3>Description</h3>

<p>Prints loop progress in <code style="white-space: pre;">&#8288;[%]&#8288;</code> to console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_progress(current, end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_progress_+3A_current">current</code></td>
<td>
<p>Numeric value of current loop iteration.</p>
</td></tr>
<tr><td><code id="print_progress_+3A_end">end</code></td>
<td>
<p>Numeric value number last loop iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints percentage of loop progress to console.
</p>

<hr>
<h2 id='red_peaks_100'>Reduce Peaks</h2><span id='topic+red_peaks_100'></span>

<h3>Description</h3>

<p>Reduces curves to 100 observations per peak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>red_peaks_100(
  df,
  plot.to.screen = FALSE,
  path.data = NULL,
  path.plots = NULL,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="red_peaks_100_+3A_df">df</code></td>
<td>
<p>The resulting tibble of the function <code>rescale_peaks()</code>. The columns <code>species</code>, <code>specimen</code>, <code>measurement</code>, <code>peak</code>, and <code>force.norm</code> must be present.
See <code>?rescale_peaks</code> for more details.</p>
</td></tr>
<tr><td><code id="red_peaks_100_+3A_plot.to.screen">plot.to.screen</code></td>
<td>
<p>A logical value indicating if results should be
plotted in the current R plot device. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="red_peaks_100_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results.
If <code>NULL</code>, data will not be saved to disk. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="red_peaks_100_+3A_path.plots">path.plots</code></td>
<td>
<p>A string character defining where to save result plots.
If <code>NULL</code>, plots will not be saved to disk. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="red_peaks_100_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a tibble with a similar format as <code>df</code>, but the columns <code>t</code>, <code>force</code>, <code>t.norm</code> and <code>force.norm</code> are replaced
by the columns <code>index</code>, ranging from 1 to 100, and <code>force.norm.100</code>, containing the rescaled force data ranging from 0 to 1. Since the time series
has been reduced to 100 observations, this tibble will always contain 100 rows per peak.
</p>


<h3><code>df</code> needs to contain the following columns:</h3>


<table>
<tr>
 <td style="text-align: center;">
   <strong><code>force</code></strong> </td><td style="text-align: center;"> <strong><code>measurement</code></strong> </td><td style="text-align: center;"> <strong><code>peak</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>force.norm.norm.1</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td><td style="text-align: center;"> <code>peak.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>force.norm.n</code> </td><td style="text-align: center;"> <code>measurement.m</code> </td><td style="text-align: center;"> <code>peak.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># Using the forceR::df.all.200.tax dataset:
peaks.df.norm.100 &lt;- red_peaks_100(df = forceR::peaks.df.norm,
                                   path.data = NULL,
                                   path.plots = NULL,
                                   show.progress = FALSE)

peaks.df.norm.100

</code></pre>

<hr>
<h2 id='reduce_frq'>Reduce Sampling Frequency</h2><span id='topic+reduce_frq'></span>

<h3>Description</h3>

<p>Reduces the sampling frequency to a certain Hz value. If the desired frequency is smaller than the
original frequency, the data remains unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_frq(df, Hz = 200, measurement.col = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduce_frq_+3A_df">df</code></td>
<td>
<p>Data frame or tibble in the below mentioned format.</p>
</td></tr>
<tr><td><code id="reduce_frq_+3A_hz">Hz</code></td>
<td>
<p>Numeric value of desired frequency. Default <code>200</code></p>
</td></tr>
<tr><td><code id="reduce_frq_+3A_measurement.col">measurement.col</code></td>
<td>
<p>Character string. If <code>measurement.col</code> is not defined, the whole input data frames will be
treated as if it was just one single time series. This is okay for data frames like that indeed only contain one
time series, but for data frames
with multiple time series, a grouping column needs to be defined. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data frame or tibble should have the following format:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>y</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>y.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>or, if <code>measurement.col</code> is not <code>NULL</code>, then</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>y</code></strong> </td><td style="text-align: center;"> <strong><code>measurement.col</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>y.1</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>y.n</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>Since, when not <code>NULL</code>, the <code>measurement.col</code> is called by its character string, the position of the column does not matter, except it
must not be among the first two columns which are reserved for <code>t</code> and <code>y</code>.
</p>
<p>All columns except the first two are removed. Values in <code>t</code> are expected to be in m.secs.
</p>


<h3>Value</h3>

<p>Returns a tibble reduced to the desired frequency in the following format:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>y</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>y.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>y.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>or, if <code>measurement.col</code> is not <code>NULL</code>, then</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>y</code></strong> </td><td style="text-align: center;"> <strong><code>measurement.col</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>y.1</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>y.n</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>require(dplyr)
# Using the forceR::df.all dataset that was
# simulated with forceR::simulate_bites()

# reduce sampling frequency to 200 Hz
df.all.200 &lt;- reduce_frq(df = df.all,
                         Hz = 200,
                         measurement.col = "measurement")

plot(df.all.200 %&gt;%
       filter(measurement == "m_02") %&gt;%
       select(t, y),
     type = "l", col = "black")
lines(df.all.200 %&gt;%
       filter(measurement == "m_01") %&gt;%
       select(t, y),
     type = "l", col = "blue")
</code></pre>

<hr>
<h2 id='rescale_peaks'>Rescale Peaks</h2><span id='topic+rescale_peaks'></span>

<h3>Description</h3>

<p>Rescales time series in x and y to values ranging from 0 to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_peaks(
  df.peaks,
  df.data,
  plot.to.screen = FALSE,
  path.data = NULL,
  show.progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_peaks_+3A_df.peaks">df.peaks</code></td>
<td>
<p>The resulting tibble of the function <code>find_strongest_peaks()</code>. See <code>?find_strongest_peaks</code> for more details.</p>
</td></tr>
<tr><td><code id="rescale_peaks_+3A_df.data">df.data</code></td>
<td>
<p>A data frame or tibble in the below format. The columns <code>t</code> (time), <code>force</code> and <code>measurement</code>
(measurement ID) must be present. This will usually be the same table that was used before in <code>find_strongest_peaks()</code>.</p>
</td></tr>
<tr><td><code id="rescale_peaks_+3A_plot.to.screen">plot.to.screen</code></td>
<td>
<p>A logical value indicating if results should be
plotted in the current R plot device. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rescale_peaks_+3A_path.data">path.data</code></td>
<td>
<p>A string character defining where to save the results.
If <code>NULL</code>, data will not be saved to disk. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rescale_peaks_+3A_show.progress">show.progress</code></td>
<td>
<p>A logical value indicating if progress should be
printed to the console. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>df.peaks</code> at least needs to contain the following columns:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>species</code></strong> </td><td style="text-align: center;"> <strong><code>measurements</code></strong> </td><td style="text-align: center;"> <strong><code>starts</code></strong> </td><td style="text-align: center;"> <strong><code>ends</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>species.1</code> </td><td style="text-align: center;"> <code>measurements.1</code> </td><td style="text-align: center;"> <code>starts.1</code> </td><td style="text-align: center;"> <code>ends.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>species.n</code> </td><td style="text-align: center;"> <code>measurements.n</code> </td><td style="text-align: center;"> <code>starts.m</code> </td><td style="text-align: center;"> <code>ends.m</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>Check <code>forceR::peaks.df</code> to see an example tibble.
</p>
<p><code>df.data</code> at least needs to contain the following columns:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>force</code></strong> </td><td style="text-align: center;"> <strong><code>measurement</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>force.1</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>force.n</code> </td><td style="text-align: center;"> <code>measurement.m</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>Check <code>forceR::df.all.200.tax</code> to see an example tibble.
</p>


<h3>Value</h3>

<p>This function returns a tibble in the same format as <code>df</code>, but with
the additional columns <code>t.norm</code> and <code>force.norm</code> which will contain the
rescaled time and force data both ranging from 0 to 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the forceR::df.all.200.tax and forceR::df.all.200.tax datasets:

# rescale bites
peaks.df.norm &lt;- rescale_peaks(df.peaks = forceR::peaks.df,
                               df.data = forceR::df.all.200.tax,
                               plot.to.screen = FALSE,
                               path.data = NULL,
                               show.progress = FALSE)


# maximum values of time and force both range from 0 - 1:
range(peaks.df.norm$t.norm)
range(peaks.df.norm$force.norm)

</code></pre>

<hr>
<h2 id='rescale_to_range'>Scale data series to new minimum and maximum</h2><span id='topic+rescale_to_range'></span>

<h3>Description</h3>

<p>Maps a series of numeric values to a new range defined by minimum (from) and maximum (to).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_to_range(data, from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_to_range_+3A_data">data</code></td>
<td>
<p>numeric vector containing the data to be scaled</p>
</td></tr>
<tr><td><code id="rescale_to_range_+3A_from">from</code></td>
<td>
<p>minimum of new range</p>
</td></tr>
<tr><td><code id="rescale_to_range_+3A_to">to</code></td>
<td>
<p>maximum of new range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with scaled data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rescale_to_range(data = 1:10,
                  from = 1,
                  to = 100)
</code></pre>

<hr>
<h2 id='simulate_bites'>Simulate bites</h2><span id='topic+simulate_bites'></span>

<h3>Description</h3>

<p>Simulates either sinusoidal or plateau-like bites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_bites(
  no.of.bites = 5,
  length.of.bite = 1000,
  length.of.series = 10000,
  max.y = 1,
  max.y.jit = NULL,
  peak.pos = 50,
  slope.perc.start = 10,
  slope.perc.end = slope.perc.start,
  jit = NULL,
  bite.type = "sin",
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_bites_+3A_no.of.bites">no.of.bites</code></td>
<td>
<p>Number of bites in time series. Default: <code>5</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_length.of.bite">length.of.bite</code></td>
<td>
<p>Length of each bite. Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_length.of.series">length.of.series</code></td>
<td>
<p>Length of the whole time series. Default: <code>10000</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_max.y">max.y</code></td>
<td>
<p>Maximum y value. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_max.y.jit">max.y.jit</code></td>
<td>
<p>Jitter above and below maximum y value in <code style="white-space: pre;">&#8288;[%]&#8288;</code> of maximum y value. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_peak.pos">peak.pos</code></td>
<td>
<p>Position (in percent) of peak within peak curve.
Only applies to <code style="white-space: pre;">&#8288;bite.type = "sin&#8288;</code> (sinusoidal bites.) Default: same as <code>50</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_slope.perc.start">slope.perc.start</code></td>
<td>
<p>Percentage of how much of the whole bite is defined by the ascending slope.
Only applies to <code style="white-space: pre;">&#8288;bite.type = "plat&#8288;</code> (plateau-like bites.) Default: <code>10</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_slope.perc.end">slope.perc.end</code></td>
<td>
<p>Percentage of how much of the whole bite is defined by the descending slope.
Only applies to <code style="white-space: pre;">&#8288;bite.type = "plat&#8288;</code> (plateau-like bites.) Default: same as <code>slope.perc.start</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_jit">jit</code></td>
<td>
<p>Jitter along the whole time series. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_bite.type">bite.type</code></td>
<td>
<p>String: either &quot;sin&quot; or &quot;plat&quot; for sinusoidal or plateau-like bites, respectively. Default: <code>"sin"</code>.</p>
</td></tr>
<tr><td><code id="simulate_bites_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the simulated time series will be plotted to the active plot device. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with the columns <code>t</code> and <code>y</code> containing simulated bites.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a time series with sinusoidal bites
# where the peaks are located in the centers of the bites.
simulate_bites(no.of.bites = 5,
                length.of.bite = 1000,
                length.of.series = 10000,
                max.y = 5,
                max.y.jit = 15,
                jit = 0.5,
                peak.pos = 0.5,
                bite.type = "sin",
                plot = TRUE)

# simulate a time series with sinusoidal bites
# where the peaks are located towards the ends of the bites.
simulate_bites(no.of.bites = 5,
                length.of.bite = 1000,
                length.of.series = 10000,
                max.y = 5,
                max.y.jit = 15,
                jit = 0.5,
                peak.pos = 0.8,
                bite.type = "sin",
                plot = TRUE)

# simulate a time series with plateau-like bites
simulate_bites(no.of.bites = 5,
                length.of.bite = 1000,
                length.of.series = 10000,
                max.y = 5,
                max.y.jit = 15,
                jit = 1,
                bite.type = "plat",
                plot = TRUE)

# simulate a time series with plateau-like bites
# with slowly ascending bite start and abprupt bite end.
simulate_bites(no.of.bites = 5,
                length.of.bite = 1000,
                length.of.series = 10000,
                max.y = 5,
                max.y.jit = 15,
                slope.perc.start = 60,
                slope.perc.end = 10,
                jit = 1,
                bite.type = "plat",
                plot = TRUE)
</code></pre>

<hr>
<h2 id='sort_files'>Sorts files after corrections</h2><span id='topic+sort_files'></span>

<h3>Description</h3>

<p>The files of each of the various possible correction steps (cropping, amplififer correction, drift correction)
are all located in their own folders. This function gets all files that represent the last correction step of a
given measurement out of all those folders and saves them in the <code>results.folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_files(data.folders, results.folder, move = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_files_+3A_data.folders">data.folders</code></td>
<td>
<p>Character vector containing full folder paths of folders to check. This list must be sorted
according to the chronology of previous file editing. If a measurement exists in the last folder,
this is copied or moved into the <code>results.folder</code>, and files of the same measurement located in the
other folders will be ignored. Hence, the one file per measurement that underwent most correction steps
will be stored in the <code>results.folder</code>, while the rest of the files of the same measurement remain in place.</p>
</td></tr>
<tr><td><code id="sort_files_+3A_results.folder">results.folder</code></td>
<td>
<p>Character string defining the full path to the folder where the desired files will be stored.</p>
</td></tr>
<tr><td><code id="sort_files_+3A_move">move</code></td>
<td>
<p>A logical value specifying if files should be moved (<code>move = TRUE</code>) or copied (<code>move = FALSE</code>). Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will look for leading numbers in the file names specifying the measurement number to find corresponding
files in the different folders. E.g., it will identify &quot;0001_ABCD.csv&quot;, &quot;0001_ABCD_ampdriftcorr.csv&quot;, and
&quot;0001_ABCD_ampdriftcorr_baselincorr.csv&quot; as stemming from the same measurement and sort them accordingly.
</p>


<h3>Value</h3>

<p>This functions does not create new files but sorts existing files. It does, however, create the <code>results.folder</code>
in case it did not exist before.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define data.folders
data.folders &lt;- c("./raw",
                   "./cropped",
                   "./ampdriftcorr",
                   "./baselinecorr")

# define the folder in which one corrected file per original raw measurement
#   should be stored.
results.folder &lt;- "./corrected"

# run the file sorting - commented out to pass package tests
# sort_files(data.folders = data.folders,
#               results.folder = results.folder,
#               move = FALSE)
</code></pre>

<hr>
<h2 id='summarize_measurements'>Summarize Table</h2><span id='topic+summarize_measurements'></span>

<h3>Description</h3>

<p>Finds minimum, maximum and standard deviation of force per measurement and taxon and
creates summary tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_measurements(df, var1, var2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_measurements_+3A_df">df</code></td>
<td>
<p>Data frame or tibble containing at least three columns. The column names must contain the
grouping variables defined in <code>var1</code> and <code>var2</code> and the column <code>force</code> (time series of force measurements).</p>
</td></tr>
<tr><td><code id="summarize_measurements_+3A_var1">var1</code></td>
<td>
<p>A character string defining the column to calculate minimal and maximal force values per measurement.
This must be the column that contains the unique measurement ID, e.g. measurement number.</p>
</td></tr>
<tr><td><code id="summarize_measurements_+3A_var2">var2</code></td>
<td>
<p>A character string defining the column for which the summary should be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble summarizing the input data frame <code>df</code>. The resulting tibble will contain
the columns <code>t</code>, <code>force</code>, <code>measurement</code>, <code>species</code>, <code>specimen</code>, <code>amp</code>, <code>lever.ratio</code>,
<code>max.F.measurement</code>, <code>mean.F.specimen</code>, <code>max.F.specimen</code>, <code>sdv.max.F.specimen</code>, <code>n.measurements.in.specimen</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the forceR::df.all.200.tax dataset:

# sumarize by measurement and specimen
df.summary.specimen &lt;- summarize_measurements(df = df.all.200.tax,
                                              var1 = "measurement",
                                              var2 = "specimen")


#  plot results
## Not run: 
require(ggplot2)
ggplot(data = df.summary.specimen, mapping = aes(x=specimen,y=max.F.measurement)) +
  geom_jitter(aes(color='blue'),alpha=0.7) +
  geom_boxplot(fill="bisque",color="black",alpha=0.3) +
  # scale_y_log10() +
  labs(y="max(F)/specimen") +
  guides(color="none") +
  theme_minimal()

## End(Not run)
</code></pre>

<hr>
<h2 id='today'>Get Today's Date as String</h2><span id='topic+today'></span>

<h3>Description</h3>

<p>Creates a character string containing today's date
in the format &quot;yyyy_mm_dd&quot; which can be used in file names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>today()
</code></pre>


<h3>Value</h3>


<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>date.string</code> </td><td style="text-align: left;"> a character string of today's date in the format "yyyy_mm_dd" </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='y_to_force'>Convert Time Series to Force</h2><span id='topic+y_to_force'></span>

<h3>Description</h3>

<p>Converts a time series, e.g. a continuous voltage measurement from a sensor to force data
according to an amplification value and, depending on the measurement setup, the lever ratio of the
rocker forwarding the force from the point the force acts on to the sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y_to_force(df, classifier, measurement.col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="y_to_force_+3A_df">df</code></td>
<td>
<p>Data frame or tibble in the below mentioned format. This should contain the time series, with
one line per time step and measurement.</p>
</td></tr>
<tr><td><code id="y_to_force_+3A_classifier">classifier</code></td>
<td>
<p>Classifier in the below mentioned format.</p>
</td></tr>
<tr><td><code id="y_to_force_+3A_measurement.col">measurement.col</code></td>
<td>
<p>Character string. If <code>measurement.col</code> is not defined, the whole input data frames will be
treated as if it was just one single time series. This is okay for data frames like that indeed only contain one
time series, but for data frames
with multiple time series, a grouping column needs to be defined. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These values should be stored in a <code>classifier</code> (s. below). At the same, it adds <code>specimen</code> and <code>species</code>
info from the respective columns of the <code>classifier</code>.
</p>
<p>The <code>classifier</code> should have the following format:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>species</code></strong> </td><td style="text-align: center;"> <strong><code>specimen</code></strong> </td><td style="text-align: center;"> <strong><code>measurement</code></strong> </td><td style="text-align: center;"> <strong><code>amp</code></strong> </td><td style="text-align: center;"> <strong><code>lever.ratio</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>species.1</code> </td><td style="text-align: center;"> <code>specimen.1</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td><td style="text-align: center;"> <code>amp.1</code> </td><td style="text-align: center;"> <code>lever.ratio.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>species.n</code> </td><td style="text-align: center;"> <code>specimen.n</code> </td><td style="text-align: center;"> <code>measurement.n</code> </td><td style="text-align: center;"> <code>amp.n</code> </td><td style="text-align: center;"> <code>lever.ratio.n</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>It must contain one row per unique measurement number that is present in the
df.
</p>
<p>The force (<code>F</code>) in Newton is calculated <em>via</em> the following formula:
</p>
<p><code>F = y * lever.ratio * (1 / amp)</code>
</p>
<p>where <code>y</code> is the measurement series, e.g. in <code>V</code>, <br />
<code>amp</code> is the amplification value, e.g. in <code>V/N</code>, <br />
and <code>lever.ratio</code> is the mechanical lever ratio of the measurement setup.
</p>
<p><code>df</code> should have the following format:</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong><code>t</code></strong> </td><td style="text-align: center;"> <strong><code>y</code></strong> </td><td style="text-align: center;"> <strong><code>measurement</code></strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>y.1</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.2</code> </td><td style="text-align: center;"> <code>y.2</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.n</code> </td><td style="text-align: center;"> <code>y.n</code> </td><td style="text-align: center;"> <code>measurement.1</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.1</code> </td><td style="text-align: center;"> <code>y.1</code> </td><td style="text-align: center;"> <code>measurement.2</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.2</code> </td><td style="text-align: center;"> <code>y.2</code> </td><td style="text-align: center;"> <code>measurement.2</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.m</code> </td><td style="text-align: center;"> <code>y.m</code> </td><td style="text-align: center;"> <code>measurement.2</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td><td style="text-align: center;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>t.o</code> </td><td style="text-align: center;"> <code>y.o</code> </td><td style="text-align: center;"> <code>measurement.o</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns a tibble in the same format as the input tibble with an additional column called '&quot;'<code>force</code>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert y column of df.all to force column and add taxonomic data
# using info from classifier
df.all.tax &lt;- y_to_force(df = forceR::df.all.200,
                      classifier = forceR::classifier,
                      measurement.col = "measurement")

df.all.tax

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
