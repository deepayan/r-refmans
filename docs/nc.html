<!DOCTYPE html><html lang="en"><head><title>Help for package nc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alternatives'><p>alternatives</p></a></li>
<li><a href='#alternatives_with_shared_groups'><p>alternatives with shared groups</p></a></li>
<li><a href='#altlist'><p>altlist</p></a></li>
<li><a href='#apply_type_funs'><p>apply type funs</p></a></li>
<li><a href='#capture_all_str'><p>Capture all matches in a single subject string</p></a></li>
<li><a href='#capture_first_df'><p>Capture first match in columns of a data frame</p></a></li>
<li><a href='#capture_first_glob'><p>capture first glob</p></a></li>
<li><a href='#capture_first_vec'><p>Capture first match in each character vector element</p></a></li>
<li><a href='#capture_longer_spec'><p>capture longer spec</p></a></li>
<li><a href='#capture_melt_multiple'><p>Capture and melt into multiple columns</p></a></li>
<li><a href='#capture_melt_single'><p>Capture and melt into a single column</p></a></li>
<li><a href='#check_df_names'><p>check df names</p></a></li>
<li><a href='#check_names'><p>check names</p></a></li>
<li><a href='#collapse_some'><p>collapse some</p></a></li>
<li><a href='#field'><p>Capture a field</p></a></li>
<li><a href='#group'><p>Capture group</p></a></li>
<li><a href='#measure'><p>measure</p></a></li>
<li><a href='#measure_multiple'><p>measure multiple</p></a></li>
<li><a href='#measure_single'><p>measure single</p></a></li>
<li><a href='#melt_list'><p>melt list</p></a></li>
<li><a href='#only_captures'><p>only captures</p></a></li>
<li><a href='#quantifier'><p>quantifier</p></a></li>
<li><a href='#stop_for_capture_same_as_id'><p>stop for capture same as id</p></a></li>
<li><a href='#stop_for_engine'><p>stop for engine</p></a></li>
<li><a href='#stop_for_subject'><p>stop for subject</p></a></li>
<li><a href='#subject_var_args'><p>subject var args</p></a></li>
<li><a href='#try_or_stop_print_pattern'><p>try or stop print pattern</p></a></li>
<li><a href='#var_args_list'><p>var args list</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2025.1.21</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Named Capture to Data Tables</td>
</tr>
<tr>
<td>Description:</td>
<td>User-friendly functions for extracting a data
 table (row for each match, column for each group)
 from non-tabular text data using regular expressions,
 and for melting columns that match a regular expression.
 Patterns are defined using a readable syntax
 that makes it easy to build complex patterns
 in terms of simpler, re-usable sub-patterns.
 Named R arguments are translated to column names
 in the output; capture groups without names are used
 internally in order to provide a standard interface
 to three regular expression 'C' libraries
 ('PCRE', 'RE2', 'ICU').
 Output can also include numeric columns via
 user-specified type conversion functions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.15.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, re2, stringi, ggplot2, tidyr (&ge; 1.0.0), cdata,
reshape2, knitr, markdown, rmarkdown, R.utils, covr, arrow</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tdhock/nc">https://github.com/tdhock/nc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tdhock/nc/issues">https://github.com/tdhock/nc/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-21 11:15:11 UTC; tdhock</td>
</tr>
<tr>
<td>Author:</td>
<td>Toby Hocking [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Toby Hocking &lt;toby.hocking@r-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-21 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alternatives'>alternatives</h2><span id='topic+alternatives'></span>

<h3>Description</h3>

<p>Make a pattern that matches one of the specified alternatives. The
<code><a href="#topic+altlist">altlist</a></code> function can be helpful for defining named sub-patterns
that are used in several alternatives.</p>


<h3>Usage</h3>

<pre><code class='language-R'>alternatives(...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alternatives_+3A_...">...</code></td>
<td>
<p>Each argument is a different alternative pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pattern list.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple example.
subject &lt;- c("foooo1", "barrr2")
str(foo.or.bar &lt;- nc::alternatives(bar="bar+", foo="fo+"))
str(foo.or.bar &lt;- list(bar="bar+", "|", foo="fo+"))#same
nc::capture_first_vec(subject, foo.or.bar, number="[12]")

## More complicated regular expression for matching the JobID column
## of SLURM sacct output.
JobID &lt;- c(
  "13937810_25", "13937810_25.batch",
  "13937810_25.extern", "14022192_[1-3]", "14022204_[4]")
int.pattern &lt;- list("[0-9]+", as.integer)
## Match the whole range inside square brackets.
range.pattern &lt;- list(
  "[[]",
  task.start=int.pattern,
  nc::quantifier("-", task.end=int.pattern, "?"),
  "[]]")
nc::capture_first_vec(JobID, range.pattern, nomatch.error=FALSE)

## Match either a single task ID or a range, after an underscore.
task.pattern &lt;- list(job="[0-9]+", "_", nc::alternatives(
  task.id=int.pattern,
  range.pattern))
nc::capture_first_vec(JobID, task.pattern)

</code></pre>

<hr>
<h2 id='alternatives_with_shared_groups'>alternatives with shared groups</h2><span id='topic+alternatives_with_shared_groups'></span>

<h3>Description</h3>

<p>Create a pattern which matches <code><a href="#topic+alternatives">alternatives</a></code> with common
sub-pattern groups.</p>


<h3>Usage</h3>

<pre><code class='language-R'>alternatives_with_shared_groups(...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alternatives_with_shared_groups_+3A_...">...</code></td>
<td>
<p>named arguments are sub-pattern groups, un-named arguments are
alternative patterns which can refer to argument names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pattern created by first using <code><a href="#topic+altlist">altlist</a></code> on named arguments to
create a list of sub-patterns, then using <code><a href="#topic+alternatives">alternatives</a></code> on un-named
arguments (evaluated using the names defined in the sub-pattern
list).</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 0: matching family and given names.
nc::capture_first_vec(
  c("Toby Dylan Hocking","Hocking, Toby Dylan"),
  nc::alternatives_with_shared_groups(
    family="[A-Z][a-z]+",
    given="[^,]+",
    list(given, " ", family),
    list(family, ", ", given)
  )
)

## Example 1: matching dates in different formats, but always same
## type in each alternative.
subject.vec &lt;- c("mar 17, 1983", "26 sep 2017", "17 mar 1984")
## Another way is with alternative regular expressions.
pattern &lt;- nc::alternatives_with_shared_groups(
  month="[a-z]{3}",
  day="[0-9]{2}",
  year="[0-9]{4}",
  list(american=list(month, " ", day, ", ", year)),
  list(european=list(day, " ", month, " ", year)))
(match.dt &lt;- nc::capture_first_vec(subject.vec, pattern))
match.dt[, data.table::as.IDate(paste0(month, day, year), format="%b%d%Y")]
## american and european columns can be searched to see which
## alternative matched.
match.dt[european!=""]

## Example 2: matching dates in different formats, but with
## different types in different alternatives.
subject.vec &lt;- c("3/17/1983", "26 sep 2017")
month2int &lt;- c(#this approach is locale-indepdendent.
  jan=1L, feb=2L, mar=3L, apr=4L,  may=5L,  jun=6L,
  jul=7L, aug=8L, sep=9L, oct=10L, nov=11L, dec=12L)
pattern &lt;- nc::alternatives_with_shared_groups(
  day=list("[0-9]{2}", as.integer),
  year=list("[0-9]{4}", as.integer),
  list(month="[0-9]", as.integer, "/", day, "/", year),
  list(day, " ", month="[a-z]{3}", function(m)month2int[m], " ", year))
match.dt &lt;- nc::capture_first_vec(subject.vec, pattern)
print(match.dt, class=TRUE)

## Example 3: three alternatives with four groups each.
subject.vec &lt;- c(
  "EUR 5.00 Theft in delivery inserted in wire transfer 11/02/2021",
  "EUR 50.00 - Refund for theft in delivery - 30/07/2020",
  "EUR68.50 - Refund for theft in delivery 02/07/2020",
  "45.00 EUR 29/10/2020 Refund for theft in delivery",
  "53.00\u20ac Refund for theft in delivery 24/09/2020")
sep &lt;- function(x, y, ...){
  if(missing(y)){
    list("^", x, "$")
  }else{
    sep(list(x, list(" - | |"), y), ...)
  }
}
pattern &lt;- nc::alternatives_with_shared_groups(
  currency="EUR|\u20ac",
  amount=list("[0-9.]+", as.numeric),
  reason="[A-Za-z ]+?",
  date=list(
    "[0-9]{2}/[0-9]{2}/[0-9]{4}",
    function(d)data.table::as.IDate(d, format="%d/%m/%Y")),
  sep(currency, amount, reason, date),
  sep(amount, currency, date, reason),
  sep(amount, currency, reason, date))
match.dt &lt;- nc::capture_first_vec(subject.vec, pattern)
print(match.dt, class=TRUE)

</code></pre>

<hr>
<h2 id='altlist'>altlist</h2><span id='topic+altlist'></span>

<h3>Description</h3>

<p>Create a named list containing named patterns, useful for creating
a named list of named sub-pattern groups to be used with
<code><a href="#topic+alternatives">alternatives</a></code>. This function is used to implement the more
user-friendly <code><a href="#topic+alternatives_with_shared_groups">alternatives_with_shared_groups</a></code>, which should be
preferred.</p>


<h3>Usage</h3>

<pre><code class='language-R'>altlist(...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="altlist_+3A_...">...</code></td>
<td>
<p>Named patterns which will be used as sub-pattern groups in <code><a href="#topic+alternatives">alternatives</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of patterns to be used for constructing <code><a href="#topic+alternatives">alternatives</a></code>
using <code><a href="base.html#topic+with">with</a></code>, see examples.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1: matching dates in different formats, but always same
## type in each alternative.
subject.vec &lt;- c("mar 17, 1983", "26 sep 2017", "17 mar 1984")
pat.list &lt;- nc::altlist(month="[a-z]{3}", day="[0-9]{2}", year="[0-9]{4}")
pattern &lt;- with(pat.list, nc::alternatives(
  american=list(month, " ", day, ", ", year),
  european=list(day, " ", month, " ", year)))
match.dt &lt;- nc::capture_first_vec(subject.vec, pattern)
print(match.dt, class=TRUE)
match.dt[, data.table::as.IDate(paste0(month, day, year), format="%b%d%Y")]

## Example 2: matching dates in different formats, but with
## different types in different alternatives.
subject.vec &lt;- c("3/17/1983", "26 sep 2017")
month2int &lt;- c(#this approach is locale-indepdendent.
  jan=1L, feb=2L, mar=3L, apr=4L,  may=5L,  jun=6L,
  jul=7L, aug=8L, sep=9L, oct=10L, nov=11L, dec=12L)
pat.list &lt;- nc::altlist(
  day=list("[0-9]{2}", as.integer),
  year=list("[0-9]{4}", as.integer))
pattern &lt;- with(pat.list, nc::alternatives(
  american=list(month="[0-9]", as.integer, "/", day, "/", year),
  european=list(
    day, " ", month="[a-z]{3}", function(m)month2int[m], " ", year)))
match.dt &lt;- nc::capture_first_vec(subject.vec, pattern)
print(match.dt, class=TRUE)

</code></pre>

<hr>
<h2 id='apply_type_funs'>apply type funs</h2><span id='topic+apply_type_funs'></span>

<h3>Description</h3>

<p>Convert columns of <code>match.mat</code> using corresponding functions from
<code>fun.list</code>, then handle any duplicate capture <code><a href="#topic+group">group</a></code> names.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_type_funs(match.mat, 
    fun.list)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_type_funs_+3A_match.mat">match.mat</code></td>
<td>
<p>Character matrix (matches X groups).</p>
</td></tr>
<tr><td><code id="apply_type_funs_+3A_fun.list">fun.list</code></td>
<td>
<p>Named list of functions to apply to captured groups. If there are
any duplicate names, they must be in <code><a href="#topic+alternatives">alternatives</a></code> (only one match
per unique <code><a href="#topic+group">group</a></code> name, otherwise error).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with columns defined by calling the functions in
<code>fun.list</code> on the corresponding column of <code>match.mat</code>. Even if
<code>fun.list</code> has duplicated names, the output data.table will have
unique column names (identically named capture groups in
<code><a href="#topic+alternatives">alternatives</a></code> will be combined into a single output column).</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='capture_all_str'>Capture all matches in a single subject string</h2><span id='topic+capture_all_str'></span>

<h3>Description</h3>

<p>Capture each match of a regex pattern from one multi-line subject
string or text file. It can be used to convert any regular text
file (web page, log, etc) to a data table, see examples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_all_str(..., 
    engine = getOption("nc.engine", 
        "PCRE"), collapse = "\n", 
    type.convert = getOption("nc.type.convert", 
        FALSE))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capture_all_str_+3A_...">...</code></td>
<td>
<p>subject, name1=pattern1, fun1, etc. The first argument must be a
subject character vector (or file name which is read via
<code><a href="base.html#topic+readLines">readLines</a></code> to get a subject). After removing missing values,
we use <code><a href="base.html#topic+paste">paste</a></code> to <code>collapse</code> the subject (by default using
newline) and treat it as single character string to
search. Arguments after the first specify the regex/conversion and
must be string/function/list, as documented in <code><a href="#topic+capture_first_vec">capture_first_vec</a></code>.</p>
</td></tr>
<tr><td><code id="capture_all_str_+3A_engine">engine</code></td>
<td>
<p>character string, one of PCRE, ICU, RE2</p>
</td></tr>
<tr><td><code id="capture_all_str_+3A_collapse">collapse</code></td>
<td>
<p>separator string for combining elements of subject into a single
string, used as <code>collapse</code> argument of <code><a href="base.html#topic+paste">paste</a></code>.</p>
</td></tr>
<tr><td><code id="capture_all_str_+3A_type.convert">type.convert</code></td>
<td>
<p>Default conversion function, which will be used on each capture
<code><a href="#topic+group">group</a></code>, unless a specific conversion is specified for that
<code><a href="#topic+group">group</a></code>. If TRUE, use <code><a href="utils.html#topic+type.convert">type.convert</a></code>; if FALSE, use
<code><a href="base.html#topic+identity">identity</a></code>; otherwise must be a function of at least one
argument (character), returning an atomic vector of the same
length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with one row for each match, and one column for each
capture <code><a href="#topic+group">group</a></code>.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.table::setDTthreads(1)

chr.pos.vec &lt;- c(
  "chr10:213,054,000-213,055,000",
  "chrM:111,000-222,000",
  "this will not match",
  NA, # neither will this.
  "chr1:110-111 chr2:220-222") # two possible matches.
keep.digits &lt;- function(x)as.integer(gsub("[^0-9]", "", x))
## By default elements of subject are treated as separate lines (and
## NAs are removed). Named arguments are used to create capture
## groups, and conversion functions such as keep.digits are used to
## convert the previously named group.
int.pattern &lt;- list("[0-9,]+", keep.digits)
(match.dt &lt;- nc::capture_all_str(
  chr.pos.vec,
  chrom="chr.*?",
  ":",
  chromStart=int.pattern,
  "-",
  chromEnd=int.pattern))
str(match.dt)

## Extract all fields from each alignment block, using two regex
## patterns, then dcast.
info.txt.gz &lt;- system.file(
  "extdata", "SweeD_Info.txt.gz", package="nc")
info.vec &lt;- readLines(info.txt.gz)
info.vec[24:40]
info.dt &lt;- nc::capture_all_str(
  sub("Alignment ", "//", info.vec),
  "//",
  alignment="[0-9]+",
  fields="[^/]+")
(fields.dt &lt;- info.dt[, nc::capture_all_str(
  fields,
  "\t+",
  variable="[^:]+",
  ":\t*",
  value=".*"),
  by=alignment])
(fields.wide &lt;- data.table::dcast(fields.dt, alignment ~ variable))

## Capture all csv tables in report -- the file name can be given as
## the subject to nc::capture_all_str, which calls readLines to get
## data to parse.
(report.txt.gz &lt;- system.file(
  "extdata", "SweeD_Report.txt.gz", package="nc"))
(report.dt &lt;- nc::capture_all_str(
  report.txt.gz,
  "//",
  alignment="[0-9]+",
  "\n",
  csv="[^/]+"
)[, {
  data.table::fread(text=csv)
}, by=alignment])

## Join report with info fields.
report.dt[fields.wide, on=.(alignment)]

## parsing nbib citation file.
(pmc.nbib &lt;- system.file(
  "extdata", "PMC3045577.nbib", package="nc"))
blank &lt;- "\n      "
pmc.dt &lt;- nc::capture_all_str(
  pmc.nbib,
  Abbreviation="[A-Z]+",
  " *- ",
  value=list(
    ".*",
    list(blank, ".*"), "*"),
  function(x)sub(blank, "", x))
str(pmc.dt)

## What do the variable fields mean? It is explained on
## https://www.nlm.nih.gov/bsd/mms/medlineelements.html which has a
## local copy in this package (downloaded 18 Sep 2019).
fields.html &lt;- system.file(
  "extdata", "MEDLINE_Fields.html", package="nc")
if(interactive())browseURL(fields.html)
fields.vec &lt;- readLines(fields.html)

## It is pretty easy to capture fields and abbreviations if gsub
## used to remove some tags first.
no.strong &lt;- gsub("&lt;/?strong&gt;", "", fields.vec)
no.comments &lt;- gsub("&lt;!--.*?--&gt;", "", no.strong)
## grep then capture_first_vec can be used if each desired row in
## the output comes from a single line of the input file.
(h3.vec &lt;- grep("&lt;h3", no.comments, value=TRUE))
h3.pattern &lt;- list(
  nc::field("name", '="', '[^"]+'),
  '"&gt;&lt;/a&gt;',
  fields.abbrevs="[^&lt;]+")
first.fields.dt &lt;- nc::capture_first_vec(
  h3.vec, h3.pattern)
field.abbrev.pattern &lt;- list(
  Field=".*?",
  " \\(",
  Abbreviation="[^)]+",
  "\\)",
  "(?: and |$)?")
(first.each.field &lt;- first.fields.dt[, nc::capture_all_str(
  fields.abbrevs, field.abbrev.pattern),
  by=fields.abbrevs])

## If we want to capture the information after the initial h3 line
## of the input, e.g. the rest column below which contains a
## description/example for each field, then capture_all_str can be
## used on the full input file.
h3.fields.dt &lt;- nc::capture_all_str(
  no.comments,
  h3.pattern,
  '&lt;/h3&gt;\n',
  rest="(?:.*\n)+?", #exercise: get the examples.
  "&lt;hr /&gt;\n")
(h3.each.field &lt;- h3.fields.dt[, nc::capture_all_str(
  fields.abbrevs, field.abbrev.pattern),
  by=fields.abbrevs])

## Either method of capturing abbreviations gives the same result.
identical(first.each.field, h3.each.field)

## but the capture_all_str method returns the additional rest column
## which contains data after the initial h3 line.
names(first.fields.dt)
names(h3.fields.dt)
cat(h3.fields.dt[fields.abbrevs=="Volume (VI)", rest])

## There are 66 Field rows across three tables.
a.href &lt;- list('&lt;a href=[^&gt;]+&gt;')
(td.vec &lt;- fields.vec[240:280])
fields.pattern &lt;- list(
  "&lt;td.*?&gt;",
  a.href,
  Fields="[^()&lt;]+",
  "&lt;/a&gt;&lt;/td&gt;\n")
(td.only.Fields &lt;- nc::capture_all_str(fields.vec, fields.pattern))

## Extract Fields and Abbreviations. Careful: most fields have one
## abbreviation, but one field has none, and two fields have two.
(td.fields.dt &lt;- nc::capture_all_str(
  fields.vec,
  fields.pattern,
  "&lt;td[^&gt;]*&gt;",
  "(?:\n&lt;div&gt;)?",
  a.href, "?",
  abbrevs=".*?",
  "&lt;/"))

## Get each individual abbreviation from the previously captured td
## data.
td.each.field &lt;- td.fields.dt[, {
  f &lt;- nc::capture_all_str(
    Fields,
    Field=".*?",
    "(?:$| and )")
  a &lt;- nc::capture_all_str(
    abbrevs,
    "\\(",
    Abbreviation="[^)]+",
    "\\)")
  if(nrow(a)==0)list() else cbind(f, a)
}, by=Fields]
str(td.each.field)
td.each.field[td.fields.dt, .(
  count=.N
), on=.(Fields), by=.EACHI][order(count)]

## There is a typo in the data captured from the h3 headings.
td.each.field[!Field %in% h3.each.field$Field]
h3.each.field[!Field %in% td.each.field$Field]

## Abbreviations are consistent.
td.each.field[!Abbreviation %in% h3.each.field$Abbreviation]
h3.each.field[!Abbreviation %in% td.each.field$Abbreviation]

## There is a a table that provides a description of each comment
## type.
(comment.vec &lt;- fields.vec[840:860])
comment.dt &lt;- nc::capture_all_str(
  fields.vec,
  "&lt;td&gt;&lt;strong&gt;",
  Field="[^&lt;]+",
  "&lt;/strong&gt;&lt;/td&gt;\n",
  "&lt;td&gt;&lt;strong&gt;\\(",
  Abbreviation="[^)]+",
  "\\)&lt;/strong&gt;&lt;/td&gt;\n",
  "&lt;td&gt;",
  description=".*",
  "&lt;/td&gt;\n")
str(comment.dt)

## Join to original PMC citation file in order to see what the
## abbreviations used in that file mean.
all.abbrevs &lt;- rbind(
  td.each.field[, .(Field, Abbreviation)],
  comment.dt[, .(Field, Abbreviation)])
all.abbrevs[pmc.dt, .(
  Abbreviation,
  Field,
  value=substr(value, 1, 20)
), on=.(Abbreviation)]

## There is a listing of examples for each comment type.
(comment.ex.dt &lt;- nc::capture_all_str(
  fields.vec[938],
  "br /&gt;\\s*",
  Abbreviation="[A-Z]+",
  "\\s*-\\s*",
  citation="[^&lt;]+?",
  list(
    "[.] ",
    nc::field("PMID", ": ", "[0-9]+")
  ), "?",
  "&lt;"))

## Join abbreviations to see what kind of comments.
all.abbrevs[comment.ex.dt, on=.(Abbreviation)]

## parsing bibtex file.
refs.bib &lt;- system.file(
  "extdata", "namedCapture-refs.bib", package="nc")
refs.vec &lt;- readLines(refs.bib)
at.lines &lt;- grep("@", refs.vec, value=TRUE)
str(at.lines)
refs.dt &lt;- nc::capture_all_str(
  refs.vec,
  "@",
  type="[^{]+",
  "[{]",
  ref="[^,]+",
  ",\n",
  fields="(?:.*\n)+?.*",
  "[}]\\s*(?:$|\n)")
str(refs.dt)

## parsing each field of each entry.
eq.lines &lt;- grep("=", refs.vec, value=TRUE)
str(eq.lines)
strip &lt;- function(x)sub("^\\s*\\{*", "", sub("\\}*,?$", "", x))
refs.fields &lt;- refs.dt[, nc::capture_all_str(
  fields,
  "\\s+",
  variable="\\S+",
  "\\s+=",
  value=".*", strip),
  by=.(type, ref)]
str(refs.fields)
with(refs.fields[ref=="HockingUseR2011"], structure(
  as.list(value), names=variable))
## the URL of my talk is now
## https://user2011.r-project.org/TalkSlides/Lightening/2-StatisticsAndProg_3-Hocking.pdf

if(!grepl("solaris", R.version$platform)){#To avoid CRAN check error on solaris
  ## Parsing wikimedia tables: each begins with {| and ends with |}.
  emoji.txt.gz &lt;- system.file(
    "extdata", "wikipedia-emoji-text.txt.gz", package="nc")
  tables &lt;- nc::capture_all_str(
    emoji.txt.gz,
    "\n[{][|]",
    first=".*",
    '\n[|][+] style="',
    nc::field("font-size", ":", '.*?'),
    '" [|] ',
    title=".*",
    lines="(?:\n.*)*?",
    "\n[|][}]")
  str(tables)
  ## Rows are separated by |-
  rows.dt &lt;- tables[, {
    row.vec &lt;- strsplit(lines, "|-", fixed=TRUE)[[1]][-1]
    .(row.i=seq_along(row.vec), row=row.vec)
  }, by=title]
  str(rows.dt)
  ## Try to parse columns from each row. Doesn't work for second table
  ## https://en.wikipedia.org/w/index.php?title=Emoji&amp;oldid=920745513#Skin_color
  ## because some entries have rowspan=2.
  contents.dt &lt;- rows.dt[, nc::capture_all_str(
    row,
    "[|] ",
    content=".*?",
    "(?: [|]|\n|$)"),
    by=.(title, row.i)]
  contents.dt[, .(cols=.N), by=.(title, row.i)]
  ## Make data table from
  ## https://en.wikipedia.org/w/index.php?title=Emoji&amp;oldid=920745513#Emoji_versus_text_presentation
  contents.dt[, col.i := 1:.N, by=.(title, row.i)]
  data.table::dcast(
    contents.dt[title=="Sample emoji variation sequences"],
    row.i ~ col.i,
    value.var="content")
}

## Simple way to extract code chunks from Rmd.
vignette.Rmd &lt;- system.file(
  "extdata", "vignette.Rmd", package="nc")
non.greedy.lines &lt;- list(
  list(".*\n"), "*?")
optional.name &lt;- list(
  list(" ", name="[^,}]+"), "?")
Rmd.dt &lt;- nc::capture_all_str(
  vignette.Rmd,
  before=non.greedy.lines,
  "```\\{r",
  optional.name,
  parameters=".*",
  "\\}\n",
  code=non.greedy.lines,
  "```")
Rmd.dt[, chunk := 1:.N]
Rmd.dt[, .(chunk, name, parameters, some.code=substr(code, 1, 20))]

## Extract individual parameter names and values.
Rmd.dt[, nc::capture_all_str(
  parameters,
  ", *",
  variable="[^= ]+",
  " *= *",
  value="[^ ,]+"),
  by=chunk]

## Simple way to extract code chunks from Rnw.
vignette.Rnw &lt;- system.file(
  "extdata", "vignette.Rnw", package="nc")
Rnw.dt &lt;- nc::capture_all_str(
  vignette.Rnw,
  before=non.greedy.lines,
  "&lt;&lt;",
  name="[^,&gt;]*",
  parameters=".*",
  "&gt;&gt;=\n",
  code=non.greedy.lines,
  "@")
Rnw.dt[, .(name, parameters, some.code=substr(code, 1, 20))]

## The next example involves timing some compression programs that
## were run on a 159 megabyte input/uncompressed text file. Here is
## how to get a data table from the time command line output.
times.out &lt;- system.file(
  "extdata", "compress-times.out", package="nc", mustWork=TRUE)
times.dt &lt;- nc::capture_all_str(
  times.out,
  "coverage.bedGraph ",
  program=".*?",
  " coverage.bedGraph.",
  suffix=".*",
  "\n\nreal\t",
  minutes.only="[0-9]+", as.numeric,
  "m",
  seconds.only="[0-9.]+", as.numeric)
times.dt[, seconds := minutes.only*60+seconds.only]
times.dt

## join with output from du command line program.
sizes.out &lt;- system.file(
  "extdata", "compress-sizes.out", package="nc", mustWork=TRUE)
sizes.dt &lt;- data.table::fread(
  file=sizes.out,
  col.names=c("megabytes", "file"))
sizes.dt[, suffix := sub("coverage.bedGraph.?", "", file)]
join.dt &lt;- times.dt[sizes.dt, on="suffix"][order(megabytes)]
join.dt[file=="coverage.bedGraph", seconds := 0]
join.dt

## visualize with ggplot2.
if(require(ggplot2)){
  ggplot(join.dt, aes(
    seconds, megabytes, label=suffix))+
    geom_text(vjust=-0.5)+
    geom_point()+
    scale_x_log10()+
    scale_y_log10()
}

</code></pre>

<hr>
<h2 id='capture_first_df'>Capture first match in columns of a data frame</h2><span id='topic+capture_first_df'></span>

<h3>Description</h3>

<p>Capture first matching text from one or more character columns of
a data frame, using a different regular expression for each
column.</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_first_df(..., 
    nomatch.error = getOption("nc.nomatch.error", 
        TRUE), existing.error = getOption("nc.existing.error", 
        TRUE), engine = getOption("nc.engine", 
        "PCRE"), type.convert = getOption("nc.type.convert", 
        FALSE))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capture_first_df_+3A_...">...</code></td>
<td>
<p>subject data frame, colName1=list(groupName1=pattern1, fun1, etc),
colName2=list(etc), etc. First argument must be a data frame with
one or more character columns of subjects for matching. If the
first argument is a data table then it will be modified using
<code><a href="data.table.html#topic+set">set</a></code> (for memory efficiency, to avoid copying the whole
data table); otherwise the input data frame will be copied to a
new data table. Each other argument must be named using a column
name of the subject data frame, e.g. colName1, colName2. Each
other argument value must be a list that specifies the
regex/conversion to use (in string/function/list format as
documented in <code><a href="#topic+capture_first_vec">capture_first_vec</a></code>, which is used on each named
column), and possibly a column-specific <code>engine</code> to use.</p>
</td></tr>
<tr><td><code id="capture_first_df_+3A_nomatch.error">nomatch.error</code></td>
<td>
<p>if TRUE (default), stop with an error if any subject does not
match; otherwise subjects that do not match are reported as
missing/NA rows of the result.</p>
</td></tr>
<tr><td><code id="capture_first_df_+3A_existing.error">existing.error</code></td>
<td>
<p>if TRUE (default to avoid data loss), stop with an error if any
capture groups have the same name as an existing column of
subject.</p>
</td></tr>
<tr><td><code id="capture_first_df_+3A_engine">engine</code></td>
<td>
<p>character string, one of PCRE, ICU, RE2. This <code>engine</code> will be used
for each column, unless another <code>engine</code> is specified for that
column in <code>...</code></p>
</td></tr>
<tr><td><code id="capture_first_df_+3A_type.convert">type.convert</code></td>
<td>
<p>Default conversion function, which will be used on each capture
<code><a href="#topic+group">group</a></code>, unless a specific conversion is specified for that
<code><a href="#topic+group">group</a></code>. If TRUE, use <code><a href="utils.html#topic+type.convert">type.convert</a></code>; if FALSE, use
<code><a href="base.html#topic+identity">identity</a></code>; otherwise must be a function of at least one
argument (character), returning an atomic vector of the same
length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with same number of rows as subject, with an additional
column for each named capture <code><a href="#topic+group">group</a></code> specified in <code>...</code></p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The JobID column can be match with a complicated regular
## expression, that we will build up from small sub-pattern list
## variables that are easy to understand independently.
(sacct.df &lt;- data.frame(
  JobID = c(
    "13937810_25", "13937810_25.batch",
    "13937810_25.extern", "14022192_[1-3]", "14022204_[4]"),
  Elapsed = c(
    "07:04:42", "07:04:42", "07:04:49",
    "00:00:00", "00:00:00"),
  stringsAsFactors=FALSE))

## Just match the end of the range.
int.pattern &lt;- list("[0-9]+", as.integer)
end.pattern &lt;- list(
  "-",
  task.end=int.pattern)
nc::capture_first_df(sacct.df, JobID=list(
  end.pattern, nomatch.error=FALSE))

## Match the whole range inside square brackets.
range.pattern &lt;- list(
  "[[]",
  task.start=int.pattern,
  end.pattern, "?", #end is optional.
  "[]]")
nc::capture_first_df(sacct.df, JobID=list(
  range.pattern, nomatch.error=FALSE))

## Match either a single task ID or a range, after an underscore.
task.pattern &lt;- list(
  "_",
  list(
    task.id=int.pattern,
    "|",#either one task(above) or range(below)
    range.pattern))
nc::capture_first_df(sacct.df, JobID=task.pattern)

## Match type suffix alone.
type.pattern &lt;- list(
  "[.]",
  type=".*")
nc::capture_first_df(sacct.df, JobID=list(
  type.pattern, nomatch.error=FALSE))

## Match task and optional type suffix.
task.type.pattern &lt;- list(
  task.pattern,
  type.pattern, "?")
nc::capture_first_df(sacct.df, JobID=task.type.pattern)

## Match full JobID and Elapsed columns.
nc::capture_first_df(
  sacct.df,
  JobID=list(
    job=int.pattern,
    task.type.pattern),
  Elapsed=list(
    hours=int.pattern,
    ":",
    minutes=int.pattern,
    ":",
    seconds=int.pattern))

## If input is data table then it is modified for memory efficiency,
## to avoid copying entire table.
sacct.DT &lt;- data.table::as.data.table(sacct.df)
nc::capture_first_df(sacct.df, JobID=task.pattern)
sacct.df #not modified.
nc::capture_first_df(sacct.DT, JobID=task.pattern)
sacct.DT #modified!

</code></pre>

<hr>
<h2 id='capture_first_glob'>capture first glob</h2><span id='topic+capture_first_glob'></span>

<h3>Description</h3>

<p>Glob files, then use <code><a href="#topic+capture_first_vec">capture_first_vec</a></code> to get meta-data from each
file name, and combine with contents of each file.</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_first_glob(glob, 
    ..., READ = fread)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capture_first_glob_+3A_glob">glob</code></td>
<td>
<p>string: <code>glob</code> specifying files to read.</p>
</td></tr>
<tr><td><code id="capture_first_glob_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+capture_first_vec">capture_first_vec</a></code>, should include pattern used on vector
of file names to get meta-data.</p>
</td></tr>
<tr><td><code id="capture_first_glob_+3A_read">READ</code></td>
<td>
<p>function of one argument (file name) which returns a data table,
default <code><a href="data.table.html#topic+fread">fread</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data table with columns of meta-data specified by pattern, plus
contents of all files specified by <code>glob</code>.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.table::setDTthreads(1)

## Example 0: iris data, one file per species.
library(data.table)
dir.create(iris.dir &lt;- tempfile())
icsv &lt;- function(sp)file.path(iris.dir, paste0(sp, ".csv"))
data.table(iris)[, fwrite(.SD, icsv(Species)), by=Species]
dir(iris.dir)
data.table::fread(file.path(iris.dir,"setosa.csv"), nrows=2)
(iglob &lt;- file.path(iris.dir,"*.csv"))
nc::capture_first_glob(iglob, Species="[^/]+", "[.]csv")

## Example 1: four files, two capture groups, custom read function.
db &lt;- system.file("extdata/chip-seq-chunk-db", package="nc", mustWork=TRUE)
suffix &lt;- if(interactive())"gz" else "head"
(glob &lt;- paste0(db, "/*/*/counts/*", suffix))
Sys.glob(glob)
read.bedGraph &lt;- function(f)data.table::fread(
  f, skip=1, col.names = c("chrom","start", "end", "count"))
data.chunk.pattern &lt;- list(
  data="H.*?",
  "/",
  chunk="[0-9]+", as.integer)
(data.chunk.dt &lt;- nc::capture_first_glob(glob, data.chunk.pattern, READ=read.bedGraph))

## Write same data set in Hive partition, then re-read.
if(requireNamespace("arrow") &amp;&amp; arrow::arrow_with_dataset()){
  path &lt;- tempfile()
  max_rows_per_file &lt;- if(interactive())3 else 1000
  arrow::write_dataset(
    dataset=data.chunk.dt,
    path=path,
    format="csv",
    partitioning=c("data","chunk"),
    max_rows_per_file=max_rows_per_file)
  hive.glob &lt;- file.path(path, "*", "*", "*.csv")
  hive.pattern &lt;- list(
    nc::field("data","=",".*?"),
    "/",
    nc::field("chunk","=",".*?", as.integer),
    "/",
    nc::field("part","-","[0-9]+", as.integer))
  hive.dt &lt;- nc::capture_first_glob(hive.glob, hive.pattern)
  hive.dt[, .(rows=.N), by=.(data,chunk,part)]
}

## Example 2: more complex pattern.
count.dt &lt;- nc::capture_first_glob(
  glob,
  data.chunk.pattern,
  "/counts/", 
  name=list("McGill", id="[0-9]+", as.integer),
  READ=read.bedGraph)
count.dt[, .(count=.N), by=.(data, chunk, name, chrom)]

if(require(ggplot2)){
  ggplot()+
    facet_wrap(~data+chunk+name+chrom, labeller=label_both, scales="free")+
    geom_step(aes(
      start, count),
      data=count.dt)
}

## Example 3: parsing non-CSV data.
vignettes &lt;- system.file("extdata/vignettes", package="nc", mustWork=TRUE)
non.greedy.lines &lt;- list(
  list(".*\n"), "*?")
optional.name &lt;- list(
  list(" ", chunk_name="[^,}]+"), "?")
chunk.pattern &lt;- list(
  before=non.greedy.lines,
  "```\\{r",
  optional.name,
  parameters=".*",
  "\\}\n",
  code=non.greedy.lines,
  "```")
chunk.dt &lt;- nc::capture_first_glob(
  paste0(vignettes, "/*.Rmd"),
  "/v",
  vignette_number="[0-9]", as.integer,
  "-",
  vignette_name=".*?",
  ".Rmd",
  READ=function(f)nc::capture_all_str(f, chunk.pattern))
chunk.dt[, chunk_number := seq_along(chunk_name), by=vignette_number]
chunk.dt[, .(
  vignette_number, vignette_name, chunk_number, chunk_name, 
  lines=nchar(code))]
cat(chunk.dt$code[2])
  
</code></pre>

<hr>
<h2 id='capture_first_vec'>Capture first match in each character vector element</h2><span id='topic+capture_first_vec'></span><span id='topic+nc'></span>

<h3>Description</h3>

<p>Use a regular expression (regex) with capture groups to extract
the first matching text from each of several subject strings. For
all matches in one multi-line text file or string use
<code><a href="#topic+capture_all_str">capture_all_str</a></code>. For the first match in every row of a data.frame,
using a different regex for each column, use <code><a href="#topic+capture_first_df">capture_first_df</a></code>. For
reading regularly named files, use <code><a href="#topic+capture_first_glob">capture_first_glob</a></code>. For
matching column names in a wide data frame and then
melting/reshaping those columns to a taller/longer data frame, see
<code><a href="#topic+capture_melt_single">capture_melt_single</a></code> and <code><a href="#topic+capture_melt_multiple">capture_melt_multiple</a></code>. To simplify the
definition of the regex you can use <code><a href="#topic+field">field</a></code>, <code><a href="#topic+quantifier">quantifier</a></code>, and
<code><a href="#topic+alternatives">alternatives</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_first_vec(..., 
    nomatch.error = getOption("nc.nomatch.error", 
        TRUE), engine = getOption("nc.engine", 
        "PCRE"), type.convert = getOption("nc.type.convert", 
        FALSE))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capture_first_vec_+3A_...">...</code></td>
<td>
<p>subject, name1=pattern1, fun1, etc. The first argument must be a
character vector of length&gt;0 (subject strings to parse with a
regex). Arguments after the first specify the regex/conversion and
must be string/list/function. All character strings are pasted
together to obtain the final regex used for matching. Each
string/list with a named argument in R becomes a capture <code><a href="#topic+group">group</a></code> in
the regex, and the name is used for the corresponding column of
the output data table. Each function must be un-named, and is used
to convert the previous capture <code><a href="#topic+group">group</a></code>. Each un-named list becomes
a non-capturing <code><a href="#topic+group">group</a></code>. Elements in each list are parsed
recursively using these rules.</p>
</td></tr>
<tr><td><code id="capture_first_vec_+3A_nomatch.error">nomatch.error</code></td>
<td>
<p>if TRUE (default), stop with an error if any subject does not
match; otherwise subjects that do not match are reported as
missing/NA rows of the result.</p>
</td></tr>
<tr><td><code id="capture_first_vec_+3A_engine">engine</code></td>
<td>
<p>character string, one of PCRE, ICU, RE2</p>
</td></tr>
<tr><td><code id="capture_first_vec_+3A_type.convert">type.convert</code></td>
<td>
<p>Default conversion function, which will be used on each capture
<code><a href="#topic+group">group</a></code>, unless a specific conversion is specified for that
<code><a href="#topic+group">group</a></code>. If TRUE, use <code><a href="utils.html#topic+type.convert">type.convert</a></code>; if FALSE, use
<code><a href="base.html#topic+identity">identity</a></code>; otherwise must be a function of at least one
argument (character), returning an atomic vector of the same
length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with one row for each subject, and one column for each
capture <code><a href="#topic+group">group</a></code>.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chr.pos.vec &lt;- c(
  "chr10:213,054,000-213,055,000",
  "chrM:111,000",
  "chr1:110-111 chr2:220-222") # two possible matches.
## Find the first match in each element of the subject character
## vector. Named argument values are used to create capture groups
## in the generated regex, and argument names become column names in
## the result.
(dt.chr.cols &lt;- nc::capture_first_vec(
  chr.pos.vec,
  chrom="chr.*?",
  ":",
  chromStart="[0-9,]+"))

## Even when no type conversion functions are specified, the result
## is always a data.table:
str(dt.chr.cols)

## Conversion functions are used to convert the previously named
## group, and patterns may be saved in lists for re-use.
keep.digits &lt;- function(x)as.integer(gsub("[^0-9]", "", x))
int.pattern &lt;- list("[0-9,]+", keep.digits)
range.pattern &lt;- list(
  chrom="chr.*?",
  ":",
  chromStart=int.pattern,
  list( # un-named list becomes non-capturing group.
    "-",
    chromEnd=int.pattern
  ), "?") # chromEnd is optional.
(dt.int.cols &lt;- nc::capture_first_vec(
  chr.pos.vec, range.pattern))

## Conversion functions used to create non-char columns.
str(dt.int.cols)

## NA used to indicate no match or missing subject.
na.vec &lt;- c(
  "this will not match",
  NA, # neither will this.
  chr.pos.vec)
nc::capture_first_vec(na.vec, range.pattern, nomatch.error=FALSE)

## another subject from https://adventofcode.com/2024/day/14
## type.convert=TRUE means to use utils::type.convert as default
## conversion function
pvxy.subject &lt;- c("p=0,4 v=3,-3","p=6,3 v=-1,-3")
nc::capture_first_vec(
  pvxy.subject,
  "p=",
  px="[0-9]",
  ",",
  py="[0-9]",
  " v=",
  vx="[-0-9]+",
  ",",
  vy="[-0-9]+",
  type.convert=TRUE)

## to do the same as above but with less repetition:
g &lt;- function(prefix,suffix)nc::group(
  name=paste0(prefix,suffix),
  "[-0-9]+")
xy &lt;- function(prefix)list(
  prefix,
  "=",
  g(prefix,"x"),
  ",",
  g(prefix,"y"))
nc::capture_first_vec(
  pvxy.subject,
  xy("p"),
  " ",
  xy("v"),
  type.convert=TRUE)

## or use a sub-pattern list without type.convert arg:
ipat &lt;- list("[-0-9]+", as.integer)
nc::capture_first_vec(
  pvxy.subject,
  "p=",
  px=ipat,
  ",",
  py=ipat,
  " v=",
  vx=ipat,
  ",",
  vy=ipat)

</code></pre>

<hr>
<h2 id='capture_longer_spec'>capture longer spec</h2><span id='topic+capture_longer_spec'></span>

<h3>Description</h3>

<p>Create a spec <code>data</code> table for input to <code><a href="tidyr.html#topic+pivot_longer_spec">pivot_longer_spec</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_longer_spec(data, 
    ..., values_to = "value")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capture_longer_spec_+3A_data">data</code></td>
<td>
<p>Data table to reshape (actually the <code>data</code> are ignored, and only the
column names are used).</p>
</td></tr>
<tr><td><code id="capture_longer_spec_+3A_...">...</code></td>
<td>
<p>Regex and conversion as described in <code><a href="#topic+capture_first_vec">capture_first_vec</a></code>. This is
processed by <code><a href="#topic+measure">measure</a></code> so if &quot;column&quot; is used as an argument name
then there will be multiple output columns in the reshaped <code>data</code>
(analogous to names_to=&quot;.value&quot; in <code><a href="tidyr.html#topic+pivot_longer">pivot_longer</a></code>).</p>
</td></tr>
<tr><td><code id="capture_longer_spec_+3A_values_to">values_to</code></td>
<td>
<p>string to use for name of value column in output (only used if
there is a single output column in the reshaped <code>data</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> table describing a reshape longer operation.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(one.iris &lt;- iris[1,])
(single.spec &lt;- nc::capture_longer_spec(iris, part=".*", "[.]", dim=".*", values_to="cm"))
(multiple.spec &lt;- nc::capture_longer_spec(iris, part=".*", "[.]", column=".*"))
if(requireNamespace("tidyr")){
  tidyr::pivot_longer_spec(one.iris, single.spec)
  tidyr::pivot_longer_spec(one.iris, multiple.spec)
}

</code></pre>

<hr>
<h2 id='capture_melt_multiple'>Capture and melt into multiple columns</h2><span id='topic+capture_melt_multiple'></span>

<h3>Description</h3>

<p>Match a regex to column names of a wide data frame (many
columns/few rows), then melt/reshape the matching columns into
multiple result columns in a taller/longer data table (fewer
columns/more rows). Input should be a data frame with four or more
regularly named columns of possibly different types to reshape,
and output is a data table with at least two columns of reshaped
data. For melting into a single result column, see
<code><a href="#topic+capture_melt_single">capture_melt_single</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_melt_multiple(..., 
    fill = FALSE, na.rm = FALSE, 
    verbose = getOption("datatable.verbose"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capture_melt_multiple_+3A_...">...</code></td>
<td>
<p>First argument must be a data frame to melt/reshape; column names
of this data frame will be used as the subjects for regex
matching. Other arguments (regex/conversion/engine) are passed to
<code><a href="#topic+capture_first_vec">capture_first_vec</a></code> along with nomatch.error=FALSE. The regex must
define a <code><a href="#topic+group">group</a></code> named &quot;column&quot; &ndash; each unique value captured in
this <code><a href="#topic+group">group</a></code> becomes a column name for the reshaped data in the
output. There must also be at least one other <code><a href="#topic+group">group</a></code>, and the
output will contain a column for each other <code><a href="#topic+group">group</a></code> &ndash; see
examples.</p>
</td></tr>
<tr><td><code id="capture_melt_multiple_+3A_fill">fill</code></td>
<td>
<p>If TRUE, <code>fill</code> missing input reshape columns with runs of rows with
missing values in the output reshape columns. Otherwise stop with
an error (default).</p>
</td></tr>
<tr><td><code id="capture_melt_multiple_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove missing values from melted data? (passed to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>)</p>
</td></tr>
<tr><td><code id="capture_melt_multiple_+3A_verbose">verbose</code></td>
<td>
<p>Print <code>verbose</code> output messages? (passed to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data table of reshaped/melted/tall/long data, with a new column
for each unique value of the capture <code><a href="#topic+group">group</a></code> named &quot;column&quot;, and a
new column for each other capture <code><a href="#topic+group">group</a></code>.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data.table::setDTthreads(1)

  ## Example 1: melt iris columns to compare Sepal and Petal dims, as
  ## in cdata package, https://winvector.github.io/cdata/
  (iris.part.cols &lt;- nc::capture_melt_multiple(
    iris,
    column=".*?",
    "[.]",
    dim=".*"))
  iris.part.cols[Sepal&lt;Petal] #Sepals are never smaller than Petals.
  if(require("ggplot2")){
    ggplot()+
      theme_bw()+
      theme(panel.spacing=grid::unit(0, "lines"))+
      facet_grid(dim ~ Species)+
      coord_equal()+
      geom_abline(slope=1, intercept=0, color="grey")+
      geom_point(aes(
        Petal, Sepal),
        shape=1,
        data=iris.part.cols)
  }

  ## Example 2. melt iris to Length and Width columns.
  (iris.dim.cols &lt;- nc::capture_melt_multiple(
    iris,
    part=".*?",
    "[.]",
    column=".*"))
  iris.dim.cols[Length&lt;Width] #Length is never less than Width.

  ## Example 3. Lots of column types, from example(melt.data.table).
  set.seed(1)
  DT &lt;- data.table::data.table(
    i_1 = c(1:5, NA),
    i_2 = c(NA,6:10),
    f_1 = factor(sample(c(letters[1:3], NA), 6, TRUE)),
    f_2 = factor(c("z", "a", "x", "c", "x", "x"), ordered=TRUE),
    c_1 = sample(c(letters[1:3], NA), 6, TRUE),
    l_2 = list(NULL, NA, c(NA,NA), logical(), 1:2, TRUE),
    d_1 = as.Date(c(1:3,NA,4:5), origin="2013-09-01"),
    d_2 = as.Date(6:1, origin="2012-01-01"))
  ## nc syntax melts to three output columns of different types using
  ## a single regex (na.rm=FALSE by default in order to avoid losing
  ## information).
  nc::capture_melt_multiple(
    DT,
    column="[dfi]",
    "_",
    number="[12]", as.integer)

  ## fill=TRUE means to output NA in positions that correspond to
  ## missing input columns (in this case, there is no l_1 nor c_2).
  nc::capture_melt_multiple(
    DT,
    column=".*",
    "_",
    number="[12]", as.integer,
    fill=TRUE)

  ## Example 4, three children, one family per row, from data.table
  ## vignette.
  family.dt &lt;- data.table::fread(text="
family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
1         30 1998-11-26 2000-01-29         NA             1             2            NA
2         27 1996-06-22         NA         NA             2            NA            NA
3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
5         29 2000-12-05 2005-02-28         NA             2             1            NA")
  ## nc::field can be used to define group name and pattern at the
  ## same time, to avoid repetitive code.
  (children.nc &lt;- nc::capture_melt_multiple(
    family.dt,
    column=".+",
    "_",
    nc::field("child", "", "[1-3]", as.integer), 
    na.rm=TRUE))

  ## Example 5: wide data CSV with 100 possible peaks per row, each
  ## peak has three attributes (Allele, Height, Size) from
  ## https://lftdi.camden.rutgers.edu/repository/PROVEDIt_1-5-Person%20CSVs%20Filtered.zip
  PROVEDIt.csv &lt;- system.file(
    "extdata", "RD12-0002_PP16HS_5sec_GM_F_1P.csv",
    package="nc", mustWork=TRUE)
  PROVEDIt.wide &lt;- data.table::fread(PROVEDIt.csv)
  names(PROVEDIt.wide)
  PROVEDIt.tall &lt;- nc::capture_melt_multiple(
    PROVEDIt.wide,
    column=".*",
    " ",
    peak="[0-9]+", as.integer,
    na.rm=TRUE)
  head(PROVEDIt.tall)

  ## plot number of peaks per row.
  peaks.per.sample.marker &lt;- PROVEDIt.tall[, .(
    peaks=.N
  ), by=.(`Sample File`, Marker)][order(peaks)]
  if(require(ggplot2)){
    ggplot()+
      geom_histogram(aes(
        peaks),
        data=peaks.per.sample.marker,
        binwidth=1)
  }

  ## which row has the most peaks?
  (most &lt;- PROVEDIt.tall[which.max(peak), .(`Sample File`, Marker, Dye)])
  PROVEDIt.tall[most, on=names(most)]
  PROVEDIt.wide[most, on=names(most)]

</code></pre>

<hr>
<h2 id='capture_melt_single'>Capture and melt into a single column</h2><span id='topic+capture_melt_single'></span>

<h3>Description</h3>

<p>Match a regex to column names of a wide data frame (many
columns/few rows), then melt/reshape the matching columns into a
single result column in a taller/longer data table (fewer columns/more
rows). It is for the common case of melting several columns of
the same type in a &quot;wide&quot; input data table which has several
distinct pieces of information encoded in each column name. For
melting into several result columns of possibly different types,
see <code><a href="#topic+capture_melt_multiple">capture_melt_multiple</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_melt_single(..., 
    value.name = "value", 
    na.rm = TRUE, verbose = getOption("datatable.verbose"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capture_melt_single_+3A_...">...</code></td>
<td>
<p>First argument must be a data frame to melt/reshape; column names
of this data frame will be used as the subjects for regex
matching. Other arguments (regex/conversion/engine) are passed to
<code><a href="#topic+capture_first_vec">capture_first_vec</a></code> along with nomatch.error=FALSE.</p>
</td></tr>
<tr><td><code id="capture_melt_single_+3A_value.name">value.name</code></td>
<td>
<p>Name of the column in output which has values taken from
melted/reshaped column values of input (passed to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>).</p>
</td></tr>
<tr><td><code id="capture_melt_single_+3A_na.rm">na.rm</code></td>
<td>
<p>remove missing values from melted data? (passed to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>)</p>
</td></tr>
<tr><td><code id="capture_melt_single_+3A_verbose">verbose</code></td>
<td>
<p>Print <code>verbose</code> output messages? (passed to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data table of reshaped/melted/tall/long data, with a new column
for each named argument in the pattern, and additionally
variable/value columns.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.table::setDTthreads(1)

## Example 1: melt iris data and barplot for each numeric variable.
(iris.tall &lt;- nc::capture_melt_single(
  iris,
  part=".*",
  "[.]",
  dim=".*",
  value.name="cm"))
## Histogram of cm for each variable.
if(require("ggplot2")){
  ggplot()+
    theme_bw()+
    theme(panel.spacing=grid::unit(0, "lines"))+
    facet_grid(part ~ dim)+
    geom_bar(aes(cm), data=iris.tall)
}

## Example 2: melt who data and use type conversion functions for
## year limits (e.g. for censored regression).
if(requireNamespace("tidyr")){
  data(who, package="tidyr", envir=environment())
  ##2.1 just extract diagnosis and gender to chr columns.
  new.diag.gender &lt;- list(#save pattern as list for re-use later.
    "new_?",
    diagnosis=".*",
    "_",
    gender=".")
  who.tall.chr &lt;- nc::capture_melt_single(who, new.diag.gender, na.rm=TRUE)
  print(head(who.tall.chr))
  str(who.tall.chr)
  ##2.2 also extract ages and convert to numeric output columns.
  who.tall.num &lt;- nc::capture_melt_single(
    who,
    new.diag.gender,#previous pattern for matching diagnosis and gender.
    ages=list(#new pattern for matching age range.
      min.years="0|[0-9]{2}", as.numeric,#in-line type conversion functions.
      max.years="[0-9]{0,2}", function(x)ifelse(x=="", Inf, as.numeric(x))),
    value.name="count",
    na.rm=TRUE)
  print(head(who.tall.num))
  str(who.tall.num)
  ##2.3 compute total count for each age range then display the
  ##subset with max.years lower than a threshold.
  who.age.counts &lt;- who.tall.num[, .(
    total=sum(count)
  ), by=.(min.years, max.years)]
  print(who.age.counts[max.years &lt; 50])
}

## Example 3: pepseq data.
if(requireNamespace("R.utils")){#for reading gz files with data.table
  pepseq.dt &lt;- data.table::fread(
    system.file("extdata", "pepseq.txt", package="nc", mustWork=TRUE))
  u.pepseq &lt;- pepseq.dt[, unique(names(pepseq.dt)), with=FALSE]
  nc::capture_melt_single(
    u.pepseq,
    "^",
    prefix=".*?",
    nc::field("D", "", ".*?"),
    "[.]",
    middle=".*?",
    "[.]",
    "[0-9]+",
    suffix=".*",
    "$")
}

</code></pre>

<hr>
<h2 id='check_df_names'>check df names</h2><span id='topic+check_df_names'></span>

<h3>Description</h3>

<p>Check that first argument is a data frame and then call
<code><a href="#topic+check_names">check_names</a></code> on its names.</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_df_names(...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_df_names_+3A_...">...</code></td>
<td>
<p>data frame, regex pattern args.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='check_names'>check names</h2><span id='topic+check_names'></span>

<h3>Description</h3>

<p>Check that <code>subject</code> is a vector of unique names and then call
<code><a href="#topic+capture_first_vec">capture_first_vec</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_names(subject, 
    var.args)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_names_+3A_subject">subject</code></td>
<td>
<p>character vector, data frame column names.</p>
</td></tr>
<tr><td><code id="check_names_+3A_var.args">var.args</code></td>
<td>
<p>regex pattern list.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='collapse_some'>collapse some</h2><span id='topic+collapse_some'></span>

<h3>Description</h3>

<p>Create character string with some or all items.</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_some(all.vec, 
    max.first.last = 5, 
    collapse = ",")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_some_+3A_all.vec">all.vec</code></td>
<td>
<p>Vector of all items.</p>
</td></tr>
<tr><td><code id="collapse_some_+3A_max.first.last">max.first.last</code></td>
<td>
<p>Max number of items to show.</p>
</td></tr>
<tr><td><code id="collapse_some_+3A_collapse">collapse</code></td>
<td>
<p>Passed to paste.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string formed by paste with <code>collapse</code> on some items of
<code>all.vec</code> (first/last few items used if length is greater than
max.first.last*2, otherwise all items).</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='field'>Capture a field</h2><span id='topic+field'></span>

<h3>Description</h3>

<p>Capture a field with a pattern of the form
list(&quot;field.name&quot;, <code>between.pattern</code>,
field.name=list(<code>...</code>)) &ndash; see examples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>field(field.name, between.pattern, 
    ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="field_+3A_field.name">field.name</code></td>
<td>
<p>Field name, used as a pattern and as a capture <code><a href="#topic+group">group</a></code> (output
column) name.</p>
</td></tr>
<tr><td><code id="field_+3A_between.pattern">between.pattern</code></td>
<td>
<p>Pattern to match after <code>field.name</code> but before the field value.</p>
</td></tr>
<tr><td><code id="field_+3A_...">...</code></td>
<td>
<p>Pattern(s) for matching field value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pattern list which can be used in <code><a href="#topic+capture_first_vec">capture_first_vec</a></code>,
<code><a href="#topic+capture_first_df">capture_first_df</a></code>, or <code><a href="#topic+capture_all_str">capture_all_str</a></code>.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two ways to create the same pattern.
str(list("Alignment ", Alignment="[0-9]+"))
## To avoid typing Alignment twice use:
str(nc::field("Alignment", " ", "[0-9]+"))

## An example with lots of different fields.
info.txt.gz &lt;- system.file(
  "extdata", "SweeD_Info.txt.gz", package="nc")
info.vec &lt;- readLines(info.txt.gz)
info.vec[24:40]
## For each Alignment there are many fields which have a similar
## pattern, and occur in the same order. One way to capture these
## fields is by coding a pattern that says to look for all of those
## fields in that order. Each field is coded using this helper
## function.
g &lt;- function(name, fun=identity, suffix=list()){
  list(
    "\t+",
    nc::field(name, ":\t+", ".*"),
    fun,
    suffix,
    "\n+")
}
nc::capture_all_str(
  info.vec,
  nc::field("Alignment", " ", "[0-9]+"),
  "\n+",
  g("Chromosome"),
  g("Sequences", as.integer),
  g("Sites", as.integer),
  g("Discarded sites", as.integer),
  g("Processing", as.integer, " seconds"),
  g("Position", as.integer),
  g("Likelihood", as.numeric),
  g("Alpha", as.numeric))

## Another example where field is useful.
trackDb.txt.gz &lt;- system.file(
  "extdata", "trackDb.txt.gz", package="nc")
trackDb.vec &lt;- readLines(trackDb.txt.gz)
cat(trackDb.vec[101:115], sep="\n")
int.pattern &lt;- list("[0-9]+", as.integer)
 cell.sample.type &lt;- list(
  cellType="[^ ]*?",
  "_",
  sampleName=list(
    "McGill",
    sampleID=int.pattern),
  dataType="Coverage|Peaks")
## Each block in the trackDb file begins with track, followed by a
## space, followed by the track name. That pattern is coded below,
## using field:
track.pattern &lt;- nc::field(
  "track",
  " ",
  cell.sample.type,
  "|",
  "[^\n]+")
nc::capture_all_str(trackDb.vec, track.pattern)

## Each line in a block has the same structure (field name, space,
## field value). Below we use the field function to extract the
## color line, along with columns for each of the three channels
## (red, green, blue).
any.lines.pattern &lt;- "(?:\n[^\n]+)*"
nc::capture_all_str(
  trackDb.vec,
  track.pattern,
  any.lines.pattern,
  "\\s+",
  nc::field(
    "color", " ",
    red=int.pattern, ",",
    green=int.pattern, ",",
    blue=int.pattern))

</code></pre>

<hr>
<h2 id='group'>Capture group</h2><span id='topic+group'></span>

<h3>Description</h3>

<p>Create a capture group (named column in output). In the vast
majority of patterns R arguments can/should be used to specify
names, e.g. list(name=pattern). This is a helper function which is
useful for programmatically creating group names (see example for
a typical use case).</p>


<h3>Usage</h3>

<pre><code class='language-R'>group(name, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_+3A_name">name</code></td>
<td>
<p>Column <code>name</code> in output.</p>
</td></tr>
<tr><td><code id="group_+3A_...">...</code></td>
<td>
<p>Regex pattern(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Three ways to create a group named data which matches zero or
## more non-newline characters.
str(list(data=".*"))
str(nc::group("data", ".*"))
g.name &lt;- "data"
str(nc::group(g.name, ".*"))

## Data downloaded from
## https://en.wikipedia.org/wiki/Hindu%E2%80%93Arabic_numeral_system
numerals &lt;- system.file(
  "extdata", "Hindu-Arabic-numerals.txt.gz", package="nc")

## Use engine="ICU" for unicode character classes
## http://userguide.icu-project.org/strings/regexp e.g. match any
## character with a numeric value of 2 (including japanese etc).
if(requireNamespace("stringi"))
  nc::capture_all_str(
  numerals,
  " ",
  two="[\\p{numeric_value=2}]",
  " ",
  engine="ICU")

## Create a table of numerals with script names.
digits.pattern &lt;- list()
for(digit in 0:9){
  digits.pattern[[length(digits.pattern)+1]] &lt;- list(
    "[|]",
    nc::group(paste(digit), "[^{|]+"),
    "[|]")
}
nc::capture_all_str(
  numerals,
  "\n",
  digits.pattern,
  "[|]",
  " *",
  "\\[\\[",
  name="[^\\]|]+")

</code></pre>

<hr>
<h2 id='measure'>measure</h2><span id='topic+measure'></span>

<h3>Description</h3>

<p>Computes a value to be used as measure.vars argument to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>. NOTE: only works on newer versions of
data.table that include the measure function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure(..., cols)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_+3A_...">...</code></td>
<td>
<p>Regular expression pattern list, passed to <code><a href="#topic+capture_first_vec">capture_first_vec</a></code> with
<code>cols</code> as subject.</p>
</td></tr>
<tr><td><code id="measure_+3A_cols">cols</code></td>
<td>
<p>Character vector, column names to match with regex.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+measure_multiple">measure_multiple</a></code> is called if there is a capture <code><a href="#topic+group">group</a></code>
named &quot;column&quot; and <code><a href="#topic+measure_single">measure_single</a></code> is called otherwise.</p>


<h3>Value</h3>

<p>List or vector to use as measure.vars argument to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(data.table)
iris.dt &lt;- data.table(datasets::iris[c(1,150),])
melt(iris.dt, measure=nc::measure(part  =".*", "[.]", dim   =".*"))
melt(iris.dt, measure=nc::measure(column=".*", "[.]", dim   =".*"))
melt(iris.dt, measure=nc::measure(part  =".*", "[.]", column=".*"))

</code></pre>

<hr>
<h2 id='measure_multiple'>measure multiple</h2><span id='topic+measure_multiple'></span>

<h3>Description</h3>

<p>Compute a measure.vars list (indicating multiple output columns)
with variable_table attribute to pass to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_multiple(subject.names, 
    match.dt, no.match, 
    fill = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_multiple_+3A_subject.names">subject.names</code></td>
<td>
<p>character vector of data frame column names.</p>
</td></tr>
<tr><td><code id="measure_multiple_+3A_match.dt">match.dt</code></td>
<td>
<p>data table of matches.</p>
</td></tr>
<tr><td><code id="measure_multiple_+3A_no.match">no.match</code></td>
<td>
<p>logical vector.</p>
</td></tr>
<tr><td><code id="measure_multiple_+3A_fill">fill</code></td>
<td>
<p>logical.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='measure_single'>measure single</h2><span id='topic+measure_single'></span>

<h3>Description</h3>

<p>Compute a measure.vars vector (indicating a single output column)
with variable_table attribute to pass to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_single(subject.names, 
    match.dt, no.match, 
    value.name = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_single_+3A_subject.names">subject.names</code></td>
<td>
<p>character vector of data frame column names.</p>
</td></tr>
<tr><td><code id="measure_single_+3A_match.dt">match.dt</code></td>
<td>
<p>data table of matches.</p>
</td></tr>
<tr><td><code id="measure_single_+3A_no.match">no.match</code></td>
<td>
<p>logical vector.</p>
</td></tr>
<tr><td><code id="measure_single_+3A_value.name">value.name</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='melt_list'>melt list</h2><span id='topic+melt_list'></span>

<h3>Description</h3>

<p>Compute a list of arguments to pass to
<code><a href="data.table.html#topic+melt.data.table">melt.data.table</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>melt_list(measure.fun, 
    dot.args, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="melt_list_+3A_measure.fun">measure.fun</code></td>
<td>
<p><code><a href="#topic+measure_single">measure_single</a></code> or <code><a href="#topic+measure_multiple">measure_multiple</a></code>.</p>
</td></tr>
<tr><td><code id="melt_list_+3A_dot.args">dot.args</code></td>
<td>
<p>list of arguments for <code><a href="#topic+check_df_names">check_df_names</a></code>.</p>
</td></tr>
<tr><td><code id="melt_list_+3A_...">...</code></td>
<td>
<p>passed to <code>measure.fun</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='only_captures'>only captures</h2><span id='topic+only_captures'></span>

<h3>Description</h3>

<p>Extract capture <code><a href="#topic+group">group</a></code> columns from <code>match.mat</code> and assign optional
groups to &quot;&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>only_captures(match.mat, 
    stop.fun)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="only_captures_+3A_match.mat">match.mat</code></td>
<td>
<p>character matrix.</p>
</td></tr>
<tr><td><code id="only_captures_+3A_stop.fun">stop.fun</code></td>
<td>
<p>function to call on logical matrix of missing indicators.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='quantifier'>quantifier</h2><span id='topic+quantifier'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+group">group</a></code> with a quantifier.</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantifier(...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantifier_+3A_...">...</code></td>
<td>
<p>Pattern(s) to be enclosed in a <code><a href="#topic+group">group</a></code>, and a quantifier (last
argument). A quantifier is character string: &quot;?&quot; for zero or one,
&quot;*?&quot;  for non-greedy zero or more, &quot;+&quot; for greedy one or more,
etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pattern list.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## No need to use nc::quantifier when the pattern to be quantified
## is just a string literal.
digits &lt;- "[0-9]+"

## nc::quantifier is useful when there is a sequence of patterns to
## be quantified, here an optional group with a dash (not captured)
## followed by some digits (captured in the chromEnd group).
str(optional.end &lt;- nc::quantifier("-", chromEnd=digits, "?"))
str(optional.end &lt;- list(list("-", chromEnd=digits), "?"))#same

## Use it as a sub-pattern for capturing genomic coordinates.
chr.pos.vec &lt;- c(
  "chr10:213054000-213055000",
  "chrM:111000",
  "chr1:110-111 chr2:220-222") # two possible matches.
nc::capture_first_vec(
  chr.pos.vec,
  chrom="chr.*?",
  ":",
  chromStart=digits,
  optional.end)

## Another example which uses quantifier twice, for extracting code
## chunks from Rmd files.
vignette.Rmd &lt;- system.file(
  "extdata", "vignette.Rmd", package="nc")
non.greedy.lines &lt;- nc::quantifier(".*\n", "*?")
optional.name &lt;- nc::quantifier(" ", name="[^,}]+", "?")
Rmd.dt &lt;- nc::capture_all_str(
  vignette.Rmd,
  before=non.greedy.lines,
  "```\\{r",
  optional.name,
  parameters=".*",
  "\\}\n",
  code=non.greedy.lines,
  "```")
Rmd.dt[, chunk := 1:.N]
Rmd.dt[, .(chunk, name, parameters, some.code=substr(code, 1, 20))]

</code></pre>

<hr>
<h2 id='stop_for_capture_same_as_id'>stop for capture same as id</h2><span id='topic+stop_for_capture_same_as_id'></span>

<h3>Description</h3>

<p>Error if capture names same as <code>id.vars</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_for_capture_same_as_id(capture.vars, 
    id.vars)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_for_capture_same_as_id_+3A_capture.vars">capture.vars</code></td>
<td>
<p>character vector of capture column names.</p>
</td></tr>
<tr><td><code id="stop_for_capture_same_as_id_+3A_id.vars">id.vars</code></td>
<td>
<p>character vector of id column names.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='stop_for_engine'>stop for engine</h2><span id='topic+stop_for_engine'></span>

<h3>Description</h3>

<p>Stop if specified <code>engine</code> is not available.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_for_engine(engine)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_for_engine_+3A_engine">engine</code></td>
<td>
<p>character string: PCRE, RE2, or ICU.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='stop_for_subject'>stop for subject</h2><span id='topic+stop_for_subject'></span>

<h3>Description</h3>

<p>Error if <code>subject</code> incorrect type.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_for_subject(subject)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_for_subject_+3A_subject">subject</code></td>
<td>
<p>character vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='subject_var_args'>subject var args</h2><span id='topic+subject_var_args'></span>

<h3>Description</h3>

<p>Parse the complete argument list including subject.</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject_var_args(..., 
    type.convert = getOption("nc.type.convert", 
        FALSE))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subject_var_args_+3A_...">...</code></td>
<td>
<p>subject, regex/conversion.</p>
</td></tr>
<tr><td><code id="subject_var_args_+3A_type.convert">type.convert</code></td>
<td>
<p>passed to <code><a href="#topic+var_args_list">var_args_list</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of <code><a href="#topic+var_args_list">var_args_list</a></code> plus subject.</p>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='try_or_stop_print_pattern'>try or stop print pattern</h2><span id='topic+try_or_stop_print_pattern'></span>

<h3>Description</h3>

<p>Try to run a capture function. If it fails we wrap the error
message with a more informative message that also includes the
generated pattern.</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_or_stop_print_pattern(expr, 
    pat, engine)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_or_stop_print_pattern_+3A_expr">expr</code></td>
<td>
<p>expression to try.  </p>
</td></tr>
<tr><td><code id="try_or_stop_print_pattern_+3A_pat">pat</code></td>
<td>
<p>regex pattern string.</p>
</td></tr>
<tr><td><code id="try_or_stop_print_pattern_+3A_engine">engine</code></td>
<td>
<p>string: regex <code>engine</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>

<hr>
<h2 id='var_args_list'>var args list</h2><span id='topic+var_args_list'></span>

<h3>Description</h3>

<p>Parse the variable-length argument list used in <code><a href="#topic+capture_first_vec">capture_first_vec</a></code>,
<code><a href="#topic+capture_first_df">capture_first_df</a></code>, and <code><a href="#topic+capture_all_str">capture_all_str</a></code>. This function is mostly
intended for internal use, but is useful if you want to see the
regex pattern generated by the variable argument syntax.</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_args_list(..., type.convert = getOption("nc.type.convert", 
    FALSE))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_args_list_+3A_...">...</code></td>
<td>
<p>character vectors (for regex patterns) or functions (which specify
how to convert extracted character vectors to other types). All
patterns must be character vectors of length 1. If the pattern is
a named argument in R, it becomes a capture <code><a href="#topic+group">group</a></code> in the regex
pattern. All patterns are pasted together to obtain the final
pattern used for matching. Each named pattern may be followed by
at most one function which is used to convert the previous named
pattern. Patterns may also be lists, which are parsed recursively
for convenience.</p>
</td></tr>
<tr><td><code id="var_args_list_+3A_type.convert">type.convert</code></td>
<td>
<p>Default conversion function, which will be used on each capture
<code><a href="#topic+group">group</a></code>, unless a specific conversion is specified for that
<code><a href="#topic+group">group</a></code>. If TRUE, use <code><a href="utils.html#topic+type.convert">type.convert</a></code>; if FALSE, use
<code><a href="base.html#topic+identity">identity</a></code>; otherwise must be a function of at least one
argument (character), returning an atomic vector of the same
length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two named elements
</p>
<table role = "presentation">
<tr><td><code>fun.list</code></td>
<td>
<p>list of conversion functions with names corresponding to capture group(s)</p>
</td></tr>
<tr><td><code>pattern</code></td>
<td>
<p>regular expression string with capture group(s)</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Toby Hocking &lt;toby.hocking@r-project.org&gt; [aut, cre]</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pos.pattern &lt;- list("[0-9]+", as.integer)
nc::var_args_list(
  chrom="chr.*?",
  ":",
  chromStart=pos.pattern,
  list(
    "-",
    chromEnd=pos.pattern
  ), "?")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
