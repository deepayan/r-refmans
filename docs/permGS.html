<!DOCTYPE html><html><head><title>Help for package permGS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {permGS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#permGS'><p>permGS</p></a></li>
<li><a href='#createPermGS'><p>createPermGS</p></a></li>
<li><a href='#exactLR'><p>exactLR</p></a></li>
<li><a href='#imputeHeinze'><p>imputeHeinze</p></a></li>
<li><a href='#imputeIPT'><p>imputeIPT</p></a></li>
<li><a href='#imputeIPZ'><p>imputeIPZ</p></a></li>
<li><a href='#nextStage'><p>nextStage</p></a></li>
<li><a href='#parseFormula'><p>Parse formula of survival model</p></a></li>
<li><a href='#permHeinze'><p>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with Heinze method</p></a></li>
<li><a href='#permIPT'><p>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with IPT method</p></a></li>
<li><a href='#permIPZ'><p>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with IPZ method</p></a></li>
<li><a href='#permLR'><p>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test without imputation</p></a></li>
<li><a href='#permuteHeinze'><p>permuteHeinze</p></a></li>
<li><a href='#permuteIPT'><p>permuteIPT</p></a></li>
<li><a href='#permuteIPZ'><p>permuteIPZ</p></a></li>
<li><a href='#sampleFromCondKM'><p>sampleFromCondKM</p></a></li>
<li><a href='#sampleFromKM'><p>sampleFromKM</p></a></li>
<li><a href='#shuffleBlock'><p>shuffleBlock</p>
Permute block preserving group sizes, randomization blocks</a></li>
<li><a href='#summary.permGS'><p>summary of permGS object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Permutational Group Sequential Test for Time-to-Event Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-08-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Brueckner &lt;matthias.brueckner@posteo.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Permutational group-sequential tests for time-to-event data based on the log-rank test statistic. Supports exact permutation test when the censoring distributions are equal in the treatment and the control group and approximate imputation-permutation methods when the censoring distributions are different. </td>
</tr>
<tr>
<td>Depends:</td>
<td>survival</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, coin, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-08-07 21:02:21 UTC; mwb</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Brueckner [aut, cre],
  Martin Posch [aut],
  Franz Koenig [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-08-07 23:29:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='permGS'>permGS</h2><span id='topic+permGS'></span><span id='topic+permGS-package'></span>

<h3>Description</h3>

<p>This package implements permutational group-sequential tests for time-to-event data based on (weighted) log-rank
test statistics. It supports exact permutation test when the censoring distributions are equal in the treatment
and the control group and the approximate imputation-permutation methods of Heinze et al. (2003) and Wang et al. (2010)
and  when the censoring distributions are different. Permutations can be stratified, i.e. only patients within the
same stratum are treated as exchangeable. Rejection boundaries are monotone and finite even when only a random
subset of all permutations is used. One- and Two-sided testing possible.
</p>


<h3>Author(s)</h3>

<p>Matthias Brueckner <a href="mailto:m.bruckner@lancaster.ac.uk">m.bruckner@lancaster.ac.uk</a>, Franz Koenig <a href="mailto:Franz.Koenig@meduniwien.ac.at">Franz.Koenig@meduniwien.ac.at</a>, Martin Posch <a href="mailto:martin.posch@meduniwien.ac.at">martin.posch@meduniwien.ac.at</a>
</p>


<h3>References</h3>

<p>Brueckner, M., Koenig, F. and Posch, M. Group-sequential permutation tests for time-to-event data.
</p>
<p>Heinze, G., Gnant, M. and Schemper, M. Exact Log-Rank Tests for Unequal Follow-Up. Biometrics, 59(4), December 2003.
</p>
<p>Wang, R., Lagakos, S.~W. and Gray, R.~J. Testing and interval estimation for two-sample survival comparisons with small sample sizes and unequal censoring. Biostatistics, 11(4), 676&ndash;692, January 2010.
</p>
<p>Kelly, P., Zhou, Y., Whitehead, N. J., Stallard, N. and Bowman, C. Sequentially testing for a geneâ€“drug interaction in a genomewide analysis. Statistics in Medicine, 27(11), 2022&ndash;2034, May 2008.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## IPZ method based on logrank test with 1000 restricted random permutations
x &lt;- createPermGS(1000, TRUE, "IPZ", type="logrank")

T &lt;- rexp(100) ## event times
R &lt;- runif(100, 0, 12)  ## recruitment times
Z &lt;- rbinom(100, 1, 0.5)  ## treatment assignment
C &lt;- rexp(100) ## drop-out times

## two-stage design
t1 &lt;- 9  ## calendar time of interim analysis
t2 &lt;- 18  ## calendar time of final analysis

## Stage 1
data.t1 &lt;- data.frame(time=pmin(T, C, max(0, (t1-R))), status=(T&lt;=pmin(C, t1-R)), trt=Z)
data.t1 &lt;- data.t1[R &lt;= t1,] 
x &lt;- nextStage(x, 0.00153, Surv(time, status) ~ trt, data.t1)
summary(x)

if(!x$results$reject[1]) { ## Stage 2
   data.t2 &lt;- data.frame(time=pmin(T, C, max(0, (t2-R))), status=(T&lt;=pmin(C, t2-R)), trt=Z)
   data.t2 &lt;- data.t2[R &lt;= t2,]
   data.t2$strata &lt;- rep.int(c(1,2), c(nrow(data.t1), nrow(data.t2)-nrow(data.t1)))
   x &lt;- nextStage(x, alpha=0.025, Surv(time, status) ~ trt + strata(strata), data.t2)           
   summary(x)
}

</code></pre>

<hr>
<h2 id='createPermGS'>createPermGS</h2><span id='topic+createPermGS'></span>

<h3>Description</h3>

<p>Create permGS object representing a permutational group-sequential trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createPermGS(B = 1000, restricted = TRUE, method = "IPZ", pool = TRUE,
  type = c("logrank", "Gehan-Breslow", "Tarone-Ware", "Prentice",
  "Prentice-Marek", "Andersen-Borgan-Gill-Keiding", "Fleming-Harrington",
  "Self"), imputeData = NULL, permuteData = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createPermGS_+3A_b">B</code></td>
<td>
<p>number of random permutations</p>
</td></tr>
<tr><td><code id="createPermGS_+3A_restricted">restricted</code></td>
<td>
<p>if TRUE only permute within strata</p>
</td></tr>
<tr><td><code id="createPermGS_+3A_method">method</code></td>
<td>
<p>imputation/permuation method IPZ, IPT, Heinze or none (default: IPZ)</p>
</td></tr>
<tr><td><code id="createPermGS_+3A_pool">pool</code></td>
<td>
<p>if TRUE impute event times from Kaplan-Meier estimator calculated from pooled data</p>
</td></tr>
<tr><td><code id="createPermGS_+3A_type">type</code></td>
<td>
<p>logrank weights to be used with coin::logrank_trafo</p>
</td></tr>
<tr><td><code id="createPermGS_+3A_imputedata">imputeData</code></td>
<td>
<p>user-supplied imputation function (ignored if method is given)</p>
</td></tr>
<tr><td><code id="createPermGS_+3A_permutedata">permuteData</code></td>
<td>
<p>user-supplied permutation function (ignore if method is given)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class permGS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## standard permutation test (no imputation, free permutations)
x &lt;- createPermGS(1000, FALSE, "none")
summary(x)
## imputation using IPT method, restricted permutations
y &lt;- createPermGS(1000, TRUE, "IPT")
summary(y)
</code></pre>

<hr>
<h2 id='exactLR'>exactLR</h2><span id='topic+exactLR'></span>

<h3>Description</h3>

<p>One-sided exact / approximate permutation and asymptotic log-rank test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactLR(B, formula, data = parent.frame(), type = "exact")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exactLR_+3A_b">B</code></td>
<td>
<p>number of random permutations (only used if type=&quot;approximate&quot;)</p>
</td></tr>
<tr><td><code id="exactLR_+3A_formula">formula</code></td>
<td>
<p>a formula object, as used by <code><a href="survival.html#topic+coxph">coxph</a></code>, left hand side must be a 'Surv' object, right hand side may only consist of a single term (treatment indicator)</p>
</td></tr>
<tr><td><code id="exactLR_+3A_data">data</code></td>
<td>
<p>data.frame or list containing the variables in &quot;formula&quot;, by default &quot;formula&quot; is evaluated in the parent frame</p>
</td></tr>
<tr><td><code id="exactLR_+3A_type">type</code></td>
<td>
<p>if type=&quot;exact&quot; performs complete enumeration of all permutations, if type=&quot;approximate&quot; draw random permutations, if type=&quot;asymptotic&quot; perform asymptotic log-rank test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a standard exact or approximate permutation test
which is only valid under the extended null hypothesis of equal survival
AND censoring distributions.
</p>


<h3>Value</h3>

<p>A list containing the exact or approximate permutation p-value and the observed test statistic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rexp(20)
C &lt;- rexp(20)
data &lt;- data.frame(time=pmin(T, C), status=(T&lt;=C), trt=rbinom(20, 1, 0.5))

# Approximate permutation test using 1000 random permutations
x &lt;- exactLR(1000, Surv(time, status) ~ trt, data, "approximate")

print(paste("Approximate permutation p-value:", x$p))

# Exact permutation test
y &lt;- exactLR(0, Surv(time, status) ~ trt, data, "exact")
print(paste("Exact permutation p-value:", y$p))

</code></pre>

<hr>
<h2 id='imputeHeinze'>imputeHeinze</h2><span id='topic+imputeHeinze'></span>

<h3>Description</h3>

<p>Impute data according to Heinze et al. method. Output is supposed to be passed to permute.heinze
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeHeinze(data, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeHeinze_+3A_data">data</code></td>
<td>
<p>matrix as returned by as.matrix(generateData(param))</p>
</td></tr>
<tr><td><code id="imputeHeinze_+3A_pool">pool</code></td>
<td>
<p>if TRUE impute events times from pooled Kaplan-Meier estimator (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing Kaplan-Meier estimators of censoring and survival distributions and the original data
</p>


<h3>References</h3>

<p>Heinze, G., Gnant, M. and Schemper, M. Exact Log-Rank Tests for Unequal Follow-Up. Biometrics, 59(4), December 2003.
</p>

<hr>
<h2 id='imputeIPT'>imputeIPT</h2><span id='topic+imputeIPT'></span>

<h3>Description</h3>

<p>Impute data according to IPT method. Output is supposed to be passed to permute.IPT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeIPT(data, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeIPT_+3A_data">data</code></td>
<td>
<p>matrix as returned by as.matrix(generateData(param))</p>
</td></tr>
<tr><td><code id="imputeIPT_+3A_pool">pool</code></td>
<td>
<p>if TRUE impute events times from pooled Kaplan-Meier estimator (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix containing imputed survival and censoring times (columns 1 and 2), and original treatment indicator (column 3)
</p>


<h3>References</h3>

<p>Wang, R., Lagakos, S.~W. and Gray, R.~J. Testing and interval estimation for two-sample survival comparisons with small sample sizes and unequal censoring. Biostatistics, 11(4), 676&ndash;692, January 2010.
</p>

<hr>
<h2 id='imputeIPZ'>imputeIPZ</h2><span id='topic+imputeIPZ'></span>

<h3>Description</h3>

<p>Impute data according to IPZ method. Output is supposed to be passed to permute.IPZ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeIPZ(data, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeIPZ_+3A_data">data</code></td>
<td>
<p>matrix as returned by as.matrix(generateData(param))</p>
</td></tr>
<tr><td><code id="imputeIPZ_+3A_pool">pool</code></td>
<td>
<p>if TRUE impute events times from pooled Kaplan-Meier estimator (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original data with 4 new columns (V1 and V2) containing the imputed observations
</p>


<h3>References</h3>

<p>Wang, R., Lagakos, S.~W. and Gray, R.~J. Testing and interval estimation for two-sample survival comparisons with small sample sizes and unequal censoring. Biostatistics, 11(4), 676&ndash;692, January 2010.
</p>

<hr>
<h2 id='nextStage'>nextStage</h2><span id='topic+nextStage'></span>

<h3>Description</h3>

<p>Imputation permutation group-sequential log-rank test.
Random permutations of a block a reused in all later stages. This automatically
results in blockwise permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextStage(pgs.obj, alpha, formula, data = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextStage_+3A_pgs.obj">pgs.obj</code></td>
<td>
<p>permGS object as returned by <code><a href="#topic+createPermGS">createPermGS</a></code></p>
</td></tr>
<tr><td><code id="nextStage_+3A_alpha">alpha</code></td>
<td>
<p>alpha at current stage</p>
</td></tr>
<tr><td><code id="nextStage_+3A_formula">formula</code></td>
<td>
<p>a formula object, as used by <code><a href="survival.html#topic+coxph">coxph</a></code>, left hand side must be a 'Surv' object, right hand side must only consist of a factor (treatment indicator) and optionally a special strata() term identifying the permutation strata</p>
</td></tr>
<tr><td><code id="nextStage_+3A_data">data</code></td>
<td>
<p>a data.frame or list containing the variables in &quot;formula&quot;, by default &quot;formula&quot; is evaluated in the parent frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated permGS object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two-stage design with one-sided O'Brien-Fleming boundaries using IPZ method
x &lt;- createPermGS(1000, TRUE, "IPZ")

t1 &lt;- 9  ## calendar time of interim analysis
t2 &lt;- 18  ## calendar time of final analysis

T &lt;- rexp(100) ## event times
R &lt;- runif(100, 0, 12)  ## recruitment times
Z &lt;- rbinom(100, 1, 0.5)  ## treatment assignment
C &lt;- rexp(100) ## drop-out times

## Stage 1 data
data.t1 &lt;- data.frame(time=pmin(T, C, max(0, (t1-R))), status=(T&lt;=pmin(C, t1-R)), trt=Z)
data.t1 &lt;- data.t1[R &lt;= t1,]

## Stage 2 data
data.t2 &lt;- data.frame(time=pmin(T, C, max(0, (t2-R))), status=(T&lt;=pmin(C, t2-R)), trt=Z)
data.t2 &lt;- data.t2[R &lt;= t2,] 
x &lt;- nextStage(x, 0.00153, Surv(time, status) ~ trt, data.t1)
summary(x)

if(!x$results$reject[1]) {
   data.t2$strata &lt;- rep.int(c(1,2), c(nrow(data.t1), nrow(data.t2)-nrow(data.t1)))
   x &lt;- nextStage(x, 0.025, Surv(time, status) ~ trt + strata(strata), data.t2)
   summary(x)
}
</code></pre>

<hr>
<h2 id='parseFormula'>Parse formula of survival model</h2><span id='topic+parseFormula'></span>

<h3>Description</h3>

<p>Parse formula of survival model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseFormula(formula, data = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseFormula_+3A_formula">formula</code></td>
<td>
<p>formula object</p>
</td></tr>
<tr><td><code id="parseFormula_+3A_data">data</code></td>
<td>
<p>data.frame (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing the parsed variables
</p>

<hr>
<h2 id='permHeinze'>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with Heinze method</h2><span id='topic+permHeinze'></span>

<h3>Description</h3>

<p>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with Heinze method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permHeinze(formula, data, B = 1000, alpha = 0.05, pool = TRUE,
  type = c("logrank", "Gehan-Breslow", "Tarone-Ware", "Prentice",
  "Prentice-Marek", "Andersen-Borgan-Gill-Keiding", "Fleming-Harrington",
  "Self"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permHeinze_+3A_formula">formula</code></td>
<td>
<p>a formula object, as used by <code><a href="survival.html#topic+coxph">coxph</a></code>, left hand side must be a 'Surv' object, right hand side must only consist of a factor (treatment indicator) and optionally a special strata() term identifying the permutation strata</p>
</td></tr>
<tr><td><code id="permHeinze_+3A_data">data</code></td>
<td>
<p>a data.frame or list containing the variables in &quot;formula&quot;, by default &quot;formula&quot; is evaluated in the parent frame</p>
</td></tr>
<tr><td><code id="permHeinze_+3A_b">B</code></td>
<td>
<p>number of random permutations (default: 1000)</p>
</td></tr>
<tr><td><code id="permHeinze_+3A_alpha">alpha</code></td>
<td>
<p>significance level (default: 0.05)</p>
</td></tr>
<tr><td><code id="permHeinze_+3A_pool">pool</code></td>
<td>
<p>if TRUE impute event times from Kaplan-Meier estimator calculated from pooled data</p>
</td></tr>
<tr><td><code id="permHeinze_+3A_type">type</code></td>
<td>
<p>logrank weights to be used with coin::logrank_trafo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class permGS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rexp(30) ## event times
Z &lt;- rbinom(30, 1, 0.5)  ## treatment assignment
C &lt;- rexp(30) ## drop-out times
data &lt;- data.frame(time=pmin(T,C), status=T&lt;=C, Z=Z)
x &lt;- permHeinze(Surv(time, status) ~ Z, data)
summary(x)
</code></pre>

<hr>
<h2 id='permIPT'>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with IPT method</h2><span id='topic+permIPT'></span>

<h3>Description</h3>

<p>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with IPT method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permIPT(formula, data, B = 1000, alpha = 0.05, pool = TRUE,
  type = c("logrank", "Gehan-Breslow", "Tarone-Ware", "Prentice",
  "Prentice-Marek", "Andersen-Borgan-Gill-Keiding", "Fleming-Harrington",
  "Self"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permIPT_+3A_formula">formula</code></td>
<td>
<p>a formula object, as used by <code><a href="survival.html#topic+coxph">coxph</a></code>, left hand side must be a 'Surv' object, right hand side must only consist of a factor (treatment indicator) and optionally a special strata() term identifying the permutation strata</p>
</td></tr>
<tr><td><code id="permIPT_+3A_data">data</code></td>
<td>
<p>a data.frame or list containing the variables in &quot;formula&quot;, by default &quot;formula&quot; is evaluated in the parent frame</p>
</td></tr>
<tr><td><code id="permIPT_+3A_b">B</code></td>
<td>
<p>number of random permutations (default: 1000)</p>
</td></tr>
<tr><td><code id="permIPT_+3A_alpha">alpha</code></td>
<td>
<p>significance level (default: 0.05)</p>
</td></tr>
<tr><td><code id="permIPT_+3A_pool">pool</code></td>
<td>
<p>if TRUE impute event times from Kaplan-Meier estimator calculated from pooled data</p>
</td></tr>
<tr><td><code id="permIPT_+3A_type">type</code></td>
<td>
<p>logrank weights to be used with coin::logrank_trafo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class permGS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rexp(30) ## event times
Z &lt;- rbinom(30, 1, 0.5)  ## treatment assignment
C &lt;- rexp(30) ## drop-out times
data &lt;- data.frame(time=pmin(T,C), status=T&lt;=C, Z=Z)
x &lt;- permIPT(Surv(time, status) ~ Z, data)
summary(x)
</code></pre>

<hr>
<h2 id='permIPZ'>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with IPZ method</h2><span id='topic+permIPZ'></span>

<h3>Description</h3>

<p>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test with IPZ method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permIPZ(formula, data, B = 1000, alpha = 0.05, pool = TRUE,
  type = c("logrank", "Gehan-Breslow", "Tarone-Ware", "Prentice",
  "Prentice-Marek", "Andersen-Borgan-Gill-Keiding", "Fleming-Harrington",
  "Self"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permIPZ_+3A_formula">formula</code></td>
<td>
<p>a formula object, as used by <code><a href="survival.html#topic+coxph">coxph</a></code>, left hand side must be a 'Surv' object, right hand side must only consist of a factor (treatment indicator) and optionally a special strata() term identifying the permutation strata</p>
</td></tr>
<tr><td><code id="permIPZ_+3A_data">data</code></td>
<td>
<p>a data.frame or list containing the variables in &quot;formula&quot;, by default &quot;formula&quot; is evaluated in the parent frame</p>
</td></tr>
<tr><td><code id="permIPZ_+3A_b">B</code></td>
<td>
<p>number of random permutations (default: 1000)</p>
</td></tr>
<tr><td><code id="permIPZ_+3A_alpha">alpha</code></td>
<td>
<p>significance level (default: 0.05)</p>
</td></tr>
<tr><td><code id="permIPZ_+3A_pool">pool</code></td>
<td>
<p>if TRUE impute event times from Kaplan-Meier estimator calculated from pooled data</p>
</td></tr>
<tr><td><code id="permIPZ_+3A_type">type</code></td>
<td>
<p>logrank weights to be used with coin::logrank_trafo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class permGS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rexp(30) ## event times
Z &lt;- rbinom(30, 1, 0.5)  ## treatment assignment
C &lt;- rexp(30) ## drop-out times
data &lt;- data.frame(time=pmin(T,C), status=T&lt;=C, Z=Z)
x &lt;- permIPZ(Surv(time, status) ~ Z, data)
summary(x)
</code></pre>

<hr>
<h2 id='permLR'>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test without imputation</h2><span id='topic+permLR'></span>

<h3>Description</h3>

<p>Convenience function which calls createPermGS and nextStage to perform fixed sample size permutation test without imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permLR(formula, data, B = 1000, alpha = 0.05, pool = TRUE,
  type = c("logrank", "Gehan-Breslow", "Tarone-Ware", "Prentice",
  "Prentice-Marek", "Andersen-Borgan-Gill-Keiding", "Fleming-Harrington",
  "Self"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permLR_+3A_formula">formula</code></td>
<td>
<p>a formula object, as used by <code><a href="survival.html#topic+coxph">coxph</a></code>, left hand side must be a 'Surv' object, right hand side must only consist of a factor (treatment indicator) and optionally a special strata() term identifying the permutation strata</p>
</td></tr>
<tr><td><code id="permLR_+3A_data">data</code></td>
<td>
<p>a data.frame or list containing the variables in &quot;formula&quot;, by default &quot;formula&quot; is evaluated in the parent frame</p>
</td></tr>
<tr><td><code id="permLR_+3A_b">B</code></td>
<td>
<p>number of random permutations (default: 1000)</p>
</td></tr>
<tr><td><code id="permLR_+3A_alpha">alpha</code></td>
<td>
<p>significance level (default: 0.05)</p>
</td></tr>
<tr><td><code id="permLR_+3A_pool">pool</code></td>
<td>
<p>if TRUE impute event times from Kaplan-Meier estimator calculated from pooled data</p>
</td></tr>
<tr><td><code id="permLR_+3A_type">type</code></td>
<td>
<p>logrank weights to be used with coin::logrank_trafo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class permGS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two-sided permutation test
T &lt;- rexp(100) ## event times
Z &lt;- rbinom(100, 1, 0.5)  ## treatment assignment
C &lt;- rexp(100) ## drop-out times
data &lt;- data.frame(time=pmin(T,C), status=T&lt;=C, Z=Z)
x &lt;- permLR(Surv(time, status) ~ Z, data, alpha=c(0.025, 0.025))
summary(x)
</code></pre>

<hr>
<h2 id='permuteHeinze'>permuteHeinze</h2><span id='topic+permuteHeinze'></span>

<h3>Description</h3>

<p>Perform single imputation and permutation step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuteHeinze(imp, pp, index = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permuteHeinze_+3A_imp">imp</code></td>
<td>
<p>list as returned by impute.heinze</p>
</td></tr>
<tr><td><code id="permuteHeinze_+3A_pp">pp</code></td>
<td>
<p>vector of permuted indices</p>
</td></tr>
<tr><td><code id="permuteHeinze_+3A_index">index</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with time, status, trt columns
</p>


<h3>References</h3>

<p>Heinze, G., Gnant, M. and Schemper, M. Exact Log-Rank Tests for Unequal Follow-Up. Biometrics, 59(4), December 2003.
</p>

<hr>
<h2 id='permuteIPT'>permuteIPT</h2><span id='topic+permuteIPT'></span>

<h3>Description</h3>

<p>Permute survival times after imputation (IPT)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuteIPT(data, pp, index = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permuteIPT_+3A_data">data</code></td>
<td>
<p>matrix as returned by impute.IPT</p>
</td></tr>
<tr><td><code id="permuteIPT_+3A_pp">pp</code></td>
<td>
<p>vector of permuted indices</p>
</td></tr>
<tr><td><code id="permuteIPT_+3A_index">index</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with time, status, trt columns
</p>


<h3>References</h3>

<p>Wang, R., Lagakos, S.~W. and Gray, R.~J. Testing and interval estimation for two-sample survival comparisons with small sample sizes and unequal censoring. Biostatistics, 11(4), 676&ndash;692, January 2010.
</p>

<hr>
<h2 id='permuteIPZ'>permuteIPZ</h2><span id='topic+permuteIPZ'></span>

<h3>Description</h3>

<p>Permute treatment assignment after imputation (IPZ)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuteIPZ(data, pZ, index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permuteIPZ_+3A_data">data</code></td>
<td>
<p>matrix as returned by impute.IPT</p>
</td></tr>
<tr><td><code id="permuteIPZ_+3A_pz">pZ</code></td>
<td>
<p>vector of permuted indices if index is TRUE, else binary vector of treatment assignments</p>
</td></tr>
<tr><td><code id="permuteIPZ_+3A_index">index</code></td>
<td>
<p>indicates if pZ is a vector of indices or a binary vector of treatment assignments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with time, status, Z columns
</p>


<h3>References</h3>

<p>Wang, R., Lagakos, S.~W. and Gray, R.~J. Testing and interval estimation for two-sample survival comparisons with small sample sizes and unequal censoring. Biostatistics, 11(4), 676&ndash;692, January 2010.
</p>

<hr>
<h2 id='sampleFromCondKM'>sampleFromCondKM</h2><span id='topic+sampleFromCondKM'></span>

<h3>Description</h3>

<p>Sample from conditional distribution estimated by Kaplan-Meier estimator. Imputed values &gt; tmax are right-censored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleFromCondKM(U, fit, tmax = NULL, dv = 1, f = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleFromCondKM_+3A_u">U</code></td>
<td>
<p>vector of observed times</p>
</td></tr>
<tr><td><code id="sampleFromCondKM_+3A_fit">fit</code></td>
<td>
<p>Kaplan-Meier fit as returned by survfit</p>
</td></tr>
<tr><td><code id="sampleFromCondKM_+3A_tmax">tmax</code></td>
<td>
<p>largest observation of the pooled sample</p>
</td></tr>
<tr><td><code id="sampleFromCondKM_+3A_dv">dv</code></td>
<td>
<p>1 if imputing events, 0 if imputing censoring times</p>
</td></tr>
<tr><td><code id="sampleFromCondKM_+3A_f">f</code></td>
<td>
<p>interpolated Kaplan-Meier estimate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Random sample of survival times drawn from conditional distribution of T given T &gt; U
</p>

<hr>
<h2 id='sampleFromKM'>sampleFromKM</h2><span id='topic+sampleFromKM'></span>

<h3>Description</h3>

<p>Sample from distribution estimated by Kaplan-Meier estimator. Imputed values &gt; tmax are right-censored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleFromKM(n, fit, start = 0, tmax = NULL, dv = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleFromKM_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="sampleFromKM_+3A_fit">fit</code></td>
<td>
<p>Kaplan-Meier fit as returned by survfit</p>
</td></tr>
<tr><td><code id="sampleFromKM_+3A_start">start</code></td>
<td>
<p>if 0 sample from L(T), else sample from L(T, T &gt; start)</p>
</td></tr>
<tr><td><code id="sampleFromKM_+3A_tmax">tmax</code></td>
<td>
<p>largest observation in pooled sample</p>
</td></tr>
<tr><td><code id="sampleFromKM_+3A_dv">dv</code></td>
<td>
<p>1 if imputing events, 0 if imputing censoring times</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Random sample of survival times
</p>

<hr>
<h2 id='shuffleBlock'>shuffleBlock
Permute block preserving group sizes, randomization blocks</h2><span id='topic+shuffleBlock'></span>

<h3>Description</h3>

<p>shuffleBlock
Permute block preserving group sizes, randomization blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffleBlock(block, strata = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shuffleBlock_+3A_block">block</code></td>
<td>
<p>vector of row indices to be permuted</p>
</td></tr>
<tr><td><code id="shuffleBlock_+3A_strata">strata</code></td>
<td>
<p>factor defining strata with block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>random permutation of each stratum within block
</p>

<hr>
<h2 id='summary.permGS'>summary of permGS object</h2><span id='topic+summary.permGS'></span>

<h3>Description</h3>

<p>summary of permGS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'permGS'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.permGS_+3A_object">object</code></td>
<td>
<p>permGS object as returned by <code><a href="#topic+createPermGS">createPermGS</a></code></p>
</td></tr>
<tr><td><code id="summary.permGS_+3A_...">...</code></td>
<td>
<p>additional parameters (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
