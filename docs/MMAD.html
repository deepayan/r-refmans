<!DOCTYPE html><html><head><title>Help for package MMAD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MMAD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcos'><p>Breast Cosmesis Data</p></a></li>
<li><a href='#cadi'><p>The children’s absenteeism data in Indonesia</p></a></li>
<li><a href='#CoxMM'><p>MM algorithm based on AD technology for Cox model</p></a></li>
<li><a href='#CZIGPMM'><p>MM algorithm based on the AD method for multivariate compound zero-inflated generalized poisson distribution</p></a></li>
<li><a href='#GaFrailtyMM'><p>MM algorithm based on AD technology for gamma frailty model</p></a></li>
<li><a href='#IC2Control'><p>Control IC2Pro object</p></a></li>
<li><a href='#IC2MM'><p>MM algorithm based on the AD method for case II interval-censored data</p></a></li>
<li><a href='#IC2Pro'><p>Calculate non-parametric estimate for case II interval censored survival function</p></a></li>
<li><a href='#kidney'><p>Kidney Infection Data</p></a></li>
<li><a href='#LTNMM'><p>MM algorithm based on the AD method for left-truncated normal distribution</p></a></li>
<li><a href='#lung'><p>NCCTG Lung Cancer Data</p></a></li>
<li><a href='#plot.Cox'><p>Plot the Cox object</p></a></li>
<li><a href='#plot.GaF'><p>Plot the GaF object</p></a></li>
<li><a href='#plot.IC2'><p>Plot the IC2 object</p></a></li>
<li><a href='#summary.Cox'><p>Summary of parameter estimates of a Cox model</p></a></li>
<li><a href='#summary.CZIGP'><p>Summary of parameter estimates of a multivariate compound ZIGP model</p></a></li>
<li><a href='#summary.GaF'><p>Summary of parameter estimates of a gamma frailty model</p></a></li>
<li><a href='#summary.IC2'><p>Summary of parameter estimates of a IC2 model</p></a></li>
<li><a href='#summary.LTN'><p>Summary of parameter estimates of a LTN model</p></a></li>
<li><a href='#summary.ZIGP'><p>Summary of parameter estimates of a Type I multivariate ZIGP model</p></a></li>
<li><a href='#vijc'><p>Voluntary and involuntary job changes data</p></a></li>
<li><a href='#ZIGPMM'><p>MM algorithm based on the AD method for type I multivariate zero-inflated generalized poisson distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>MM Algorithm Based on the Assembly-Decomposition Technology</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dengge Liu &lt;dongge_adam@126.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Minorize-Maximization(MM) algorithm based on Assembly-Decomposition(AD) technology can be used for model estimation of parametric models, semi-parametric models and non-parametric models. We selected parametric models including left truncated normal distribution, type I multivariate zero-inflated generalized poisson distribution and multivariate compound zero-inflated generalized poisson distribution; semiparametric models include Cox model and gamma frailty model; nonparametric model is estimated for type II interval-censored data. These general methods are proposed based on the following papers,
    Tian, Huang and Xu (2019) &lt;<a href="https://doi.org/10.5705%2FSS.202016.0488">doi:10.5705/SS.202016.0488</a>&gt;,
    Huang, Xu and Tian (2019) &lt;<a href="https://doi.org/10.5705%2Fss.202016.0516">doi:10.5705/ss.202016.0516</a>&gt;,
    Zhang and Huang (2022) &lt;<a href="https://doi.org/10.1117%2F12.2642737">doi:10.1117/12.2642737</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, survival</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-08 06:53:07 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Xifen Huang [aut],
  Dengge Liu [aut, cre],
  Yunpeng Zhou [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-08 17:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcos'>Breast Cosmesis Data</h2><span id='topic+bcos'></span>

<h3>Description</h3>

<p>The often used data set for interval censored data, described and given in full in Finkelstein and Wolfe (1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcos
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 94 rows and 3 columns.
</p>


<h3>Value</h3>

<p>Breast cosmesis data contains the following fields:
</p>
<table>
<tr><td><code>left</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code>right</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code>treatment</code></td>
<td>
<p>a factor with levels Rad and RadChem</p>
</td></tr>
</table>


<h3>References</h3>

<p>Finkelstein D.M. and Wolfe R.A.(1985). &quot;A semiparametric model for regression analysis of interval-censored failure time data.&quot; <em>Biometrics</em> <strong>41</strong>, 933-945.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data(bcos)
</code></pre>

<hr>
<h2 id='cadi'>The children’s absenteeism data in Indonesia</h2><span id='topic+cadi'></span>

<h3>Description</h3>

<p>In a survey of Indonesian family life conducted by Strauss et al. the participants included 7000 households sampled from 321 communities randomly selected from 13 of the nation’s 26 Provinces,
in which 83% of the Indonesian population lived. Among those households with one child per household, 437 household heads were asked questions about the health of their children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cadi
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 437 rows and 2 columns.
</p>


<h3>Value</h3>

<p>The children’s absenteeism data in Indonesia contains the following fields:
</p>
<table>
<tr><td><code>y1</code></td>
<td>
<p>The number of days the children missed their primary activities due to illness in the last four weeks</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>
<p>The number of days the children spent in bed due to illness in the last four weeks</p>
</td></tr>
</table>


<h3>References</h3>

<p>Huang X.F., Tian G.L., Zhang, C. and Jiang, X.(2017). &quot;Type I multivariate zero-inflated generalized Poisson distribution with applications.&quot; <em>Statistics and its Interface</em> <strong>10</strong>(2), 291-311.
</p>
<p>Strauss J., Beegle K., Sikoki B., Dawiyanto A., Herawati Y. and Witoelar Y.(2004). &quot;The Third Wave of the Indonesia Family Life Survey (IFLS): Overview and Field Report, WR-144/1-NIA/NICHD, RAND Corporation, Santa Monica, CA.&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data(cadi)
</code></pre>

<hr>
<h2 id='CoxMM'>MM algorithm based on AD technology for Cox model</h2><span id='topic+CoxMM'></span>

<h3>Description</h3>

<p>Let <code class="reqn">T_i, C_i</code> and <code class="reqn">X_i = (x_{i1},\cdots, x_{iq})^T</code> denote the,
survival time, the censoring time and a <code class="reqn">q</code> dimension vector of coefficients for the <code class="reqn">i</code>-th individual, respectively. And assume the censoring time
<code class="reqn">C_i</code> is independent of the survival time <code class="reqn">T_i</code> are mutually independent, and <code class="reqn">I_i = I(T_{i} \leqslant C_{i})</code> is the censoring indicator.
Then the instantaneous hazard rate function of <code class="reqn">T_i</code> is
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t|X_i)=\lambda_{0}(t) \exp(X_{i}^{T} \beta)</code>
</p>

<p>where <code class="reqn">\lambda_{0}(.)</code> is a baseline hazard rate and <code class="reqn">\beta = (\beta_1, \cdots, \beta_q)^{T}</code> is a vector of regression parameters.
We denote <code class="reqn">\Lambda</code> as the accumulative hazard rate. Then the observed data likelihood function is
</p>
<p style="text-align: center;"><code class="reqn"> L(\alpha | Y_{obs}) = \prod_{i=1}^n (\lambda_{0}(t_i) \exp(X_{i}^{T} \beta))^{I_i} \exp(-\Lambda(t_i) \exp(X_{i}^{T} \beta)) </code>
</p>

<p>where <code class="reqn">\alpha = (\beta, \Lambda)</code>. The <code>CoxMM</code> function is used to calculate the Cox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoxMM(formula, data, beta = NULL, Maxiter = 2000, convergence = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoxMM_+3A_formula">formula</code></td>
<td>
<p>A formula object, which contains on the left hand side an object of the type <code>Surv</code>
and on the right hand side is the terms, e.g. <code>formula=Surv(time, status) ~ x</code>.</p>
</td></tr>
<tr><td><code id="CoxMM_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> in which to interpret the variables named in the formula.</p>
</td></tr>
<tr><td><code id="CoxMM_+3A_beta">beta</code></td>
<td>
<p>A vector of unknown regression parameters, default is <code>NULL</code>.
If is <code>NULL</code>, then make all <code>beta=0</code> during calculation.</p>
</td></tr>
<tr><td><code id="CoxMM_+3A_maxiter">Maxiter</code></td>
<td>
<p>The maximum number of iterations is specified by default as 2000.</p>
</td></tr>
<tr><td><code id="CoxMM_+3A_convergence">convergence</code></td>
<td>
<p>Specify the convergence criterion, the default is 1e-6.</p>
</td></tr>
<tr><td><code id="CoxMM_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>CoxMM</code> function is used to calculate the Cox model using MM algorithms
based on AD technology. EM algorithms rely on the fact that, after profiling out the nonparametric component <code class="reqn">\Lambda</code>,
the resulting function is concave. However, when this assumption does not hold, maximizing the resulting function using Newton’s method becomes difficult,
especially when there are a large number of covariates. MM algorithms can avoid the
concavity requirement and bypass the need for Newton method and matrix inversion.
</p>


<h3>Value</h3>

<p>An object of class <code>CoxMM</code> that contains the following fields: the Time, total amount of observations,
total number of failure events, the variable name, the <code class="reqn">\beta</code>, the <code class="reqn">\lambda</code>, the <code class="reqn">\Lambda</code>, convergence result,
the log likelihood value, the standard deviation of the estimated <code class="reqn">\beta</code>, the likelihood-based 95% confidence interval for the <code class="reqn">\beta</code>.
</p>


<h3>References</h3>

<p>D.R. Cox.(1972). 'Regression models and life tables.' <em>Journal of the Royal Statistical Society(Series B)</em> <strong>34</strong>(2), 187-220.
</p>
<p>Zhang L.L. and Huang X.F.(2022). 'On MM algorithms for Cox model with right-censored data.' <em>In International Conference on Cloud Computing, Internet of Things, and Computer Applications (CICA 2022)</em> <strong>12303</strong>, 29-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
CoxMM(Surv(time, status) ~ age + sex, lung)

</code></pre>

<hr>
<h2 id='CZIGPMM'>MM algorithm based on the AD method for multivariate compound zero-inflated generalized poisson distribution</h2><span id='topic+CZIGPMM'></span>

<h3>Description</h3>

<p>Let <code class="reqn">Z_0 \sim Bernoulli(1- \phi_0)</code>, <code class="reqn">\bf{x} = (X_1,\cdots, X_m)^T</code>, <code class="reqn">X_i \sim ZIGP(\phi_i, \lambda_i, \theta_i)</code>, for <code class="reqn">i = 1,\cdots,m</code> , and <code class="reqn">(Z_0,X_1,\cdots, X_m)</code>
be mutually independent. A random vector <code class="reqn">\bf{y}=(Y_1,\cdots, Y_m)^T</code> follows a multivariate compound zero-inflated generalized poisson distribution if
</p>
<p style="text-align: center;"><code class="reqn"> \bf{y} \overset{\rm{d}}= Z_{0}\bf{x}= \left\{ \begin{array}{ll}
\bf{0} &amp; \text{with probability} \ \lambda_0 \\ \bf{x} &amp; \text{with probability} \ 1-\lambda_0 \\ \end{array} \right. </code>
</p>

<p>where <code class="reqn">\lambda_0 \in [0,1)</code>, <code class="reqn">\bf{\phi}=(\phi_1,\cdots, \phi_m)^{T}  \in [0, 1)^m</code>, <code class="reqn">\bf{\lambda}=(\lambda_1,\cdots, \lambda_m)^{T} \in \mathbb{R}_{+}^{m} </code>, <code class="reqn">\bf{\theta}=(\theta_1,\cdots, \theta_m)^{T} \in [0, 1)^m</code>.
The <code>CZIGPMM</code> function is used to calculate the multivariate compound ZIGP model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CZIGPMM(data, phi0, phi, la, th, Maxiter = 2000, convergence = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CZIGPMM_+3A_data">data</code></td>
<td>
<p>Data.frame or Matrix that contains corresponding covariates.</p>
</td></tr>
<tr><td><code id="CZIGPMM_+3A_phi0">phi0</code></td>
<td>
<p>Probability value for the zero-inflated parameter for CZIGP model.</p>
</td></tr>
<tr><td><code id="CZIGPMM_+3A_phi">phi</code></td>
<td>
<p>Probability value for the zero-inflated parameter for ZIGP model.</p>
</td></tr>
<tr><td><code id="CZIGPMM_+3A_la">la</code></td>
<td>
<p>The scale parameter for ZIGP model.</p>
</td></tr>
<tr><td><code id="CZIGPMM_+3A_th">th</code></td>
<td>
<p>The discrete parameter for ZIGP model.</p>
</td></tr>
<tr><td><code id="CZIGPMM_+3A_maxiter">Maxiter</code></td>
<td>
<p>The maximum number of iterations is specified by default as 2000.</p>
</td></tr>
<tr><td><code id="CZIGPMM_+3A_convergence">convergence</code></td>
<td>
<p>Specify the convergence criterion, the default is 1e-6.</p>
</td></tr>
<tr><td><code id="CZIGPMM_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>CZIGPMM</code> function is used to calculate multivariate compound zero-inflated generalized poisson distribution model using MM algorithms
based on AD technology. <code>data</code> is provided by user by default, it can be a data frame or a matrix. In addition, unknown parameters require users to give appropriate initial values,
where <code>0&lt;=phi0&lt;1</code>, each <code>phi</code> should <code>0&lt;=phi&lt;1</code>, <code>th</code> should <code>0&lt;=th&lt;1</code>, and each <code>la</code> should be greater than 0.
</p>


<h3>Value</h3>

<p>An object of class <code>CZIGPMM</code> that contains the following fields: total amount of observations,
the number of iterations, convergence rate, the log likelihood value, estimated results for the unknown parameters,
the standard deviation of estimate for the unknown parameters, the likelihood-based 95% confidence interval for the unknown parameters,
information criterion: AIC value and BIC value.
</p>


<h3>References</h3>

<p>Tian G.L., Huang X.F. and Xu, J.(2019). 'An assembly and decomposition approach for constructing separable minorizing functions in a class of MM algorithms.' <em>Statistica Sinica</em> <strong>29</strong>(2), 961-982.
</p>
<p>Huang X.F., Tian G.L., Zhang, C. and Jiang, X.(2017). 'Type I multivariate zero-inflated generalized Poisson distribution with applications.' <em>Statistics and its Interface</em> <strong>10</strong>(2), 291-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(0,35,23,34,8,19,0,0,0,0)
x2 &lt;- c(38,15,0,25,34,0,0,0,0,0)
y &lt;- cbind(x1, x2)
phi0 = 0.5; phi = rep(0.5,2); la = rep(1,2); th = rep(0.1,2)
CZIGPMM(y, phi0, phi, la, th)

</code></pre>

<hr>
<h2 id='GaFrailtyMM'>MM algorithm based on AD technology for gamma frailty model</h2><span id='topic+GaFrailtyMM'></span>

<h3>Description</h3>

<p>Let <code class="reqn">T_{ij}, C_{ij}</code> and <code class="reqn">X_{ij} = (X_{ij1},\cdots, X_{ijq})^T</code> denote the
survival time, the censoring time and a vector of covariates, respectively. For the <code class="reqn">j</code>-th individual in the <code class="reqn">i</code>-th cluster, for <code class="reqn">j=1, \cdots, M_i </code> and  <code class="reqn">i=1, \cdots, B</code>. And assume the censoring time
<code class="reqn">C_{ij}</code> is independent of the survival time <code class="reqn">T_{ij}</code> given <code class="reqn">X_{ij}</code>, and <code class="reqn">I_{ij} = I(T_{ij} \leqslant C_{ij})</code> is the censoring indicator.
Conditional on a cluster-specific frailty  <code class="reqn">\omega_i</code>,  then the frailty model postulates that the instantaneous hazard rate function of <code class="reqn">T_{ij}</code> is
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t|X_{ij} , \omega_i )=\lambda_{0}(t) \exp(X_{ij}^{T} \beta) \omega_i</code>
</p>

<p>where <code class="reqn">\lambda_{0}(t)</code> is a baseline hazard rate and <code class="reqn">\beta</code> is a vector of regression parameters. We assume that the frailty <code class="reqn">\omega</code> has a gamma distribution
with mean 1, variance <code class="reqn">\theta</code> and density
</p>
<p style="text-align: center;"><code class="reqn"> g(\omega) = \frac{\omega^{\frac{1}{1-\theta}} \exp(-\frac{\omega}{\theta})}{\Gamma( \frac{1}{\theta}) \theta^{\frac{1}{\theta}}} </code>
</p>

<p>and we denote <code class="reqn">\Lambda</code> as the accumulative hazard rate. The <code>GaFrailtyMM</code> function is used to calculate the gamma frailty model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaFrailtyMM(
  formula,
  data,
  beta = NULL,
  theta = NULL,
  lambda = NULL,
  Maxiter = 2000,
  convergence = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaFrailtyMM_+3A_formula">formula</code></td>
<td>
<p>A formula object, which contains on the left hand side an object of the type <code>Surv</code>
and on the right hand side a <code>+cluster(id)</code> statement.
e.g. <code>formula=Surv(time, status) ~ x + cluster(id)</code></p>
</td></tr>
<tr><td><code id="GaFrailtyMM_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> in which to interpret the variables named in the formula.</p>
</td></tr>
<tr><td><code id="GaFrailtyMM_+3A_beta">beta</code></td>
<td>
<p>A vector of unknown regression parameters, default is <code>NULL</code>.
If is <code>NULL</code>, then make all <code>beta=1</code> during calculation.</p>
</td></tr>
<tr><td><code id="GaFrailtyMM_+3A_theta">theta</code></td>
<td>
<p>The variance of frailty factors subject to gamma distribution, default is <code>NULL</code>.
If is <code>NULL</code>, then let <code>theta=1</code> during calculation.</p>
</td></tr>
<tr><td><code id="GaFrailtyMM_+3A_lambda">lambda</code></td>
<td>
<p>Baseline hazard rate, default set to <code>NULL</code>. If is <code>NULL</code>,
then let each <code>lambda</code> equals to <code>1/N</code> during calculation, which <code>N</code> is the number of observed.</p>
</td></tr>
<tr><td><code id="GaFrailtyMM_+3A_maxiter">Maxiter</code></td>
<td>
<p>The maximum number of iterations is specified by default as 2000.</p>
</td></tr>
<tr><td><code id="GaFrailtyMM_+3A_convergence">convergence</code></td>
<td>
<p>Specify the convergence criterion, the default is 1e-6.</p>
</td></tr>
<tr><td><code id="GaFrailtyMM_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>GaFrailtyMM</code> function is used to calculate gamma frailty survival model using MM algorithms
based on AD technology. EM algorithms relies on the fact that, after profiling out the nonparametric component <code class="reqn">\Lambda_0</code>,
the resulting function is concave. When it does not hold, using Newton method to maximize the resulting function is
difficult especially when there exist a large number of covariates. MM algorithms that can avoid the
concavity requirement and bypass Newton method and matrix inversion.
</p>


<h3>Value</h3>

<p>An object of class <code>GaFrailtyMM</code> that contains the following fields: total amount of observations,
the Time, the <code class="reqn">\Lambda</code>, the <code class="reqn">\lambda</code>, total number of failure events, total number of iterations, convergence result, the log likelihood value,
the <code class="reqn">\theta</code>, the standard deviation of the estimated <code class="reqn">\theta</code>,
the likelihood-based 95% confidence interval for the <code class="reqn">\theta</code>, <code class="reqn">\beta</code>,
the standard deviation of the estimated <code class="reqn">\beta</code>, the likelihood-based 95% confidence interval for the <code class="reqn">\beta</code>,
the variable name.
</p>


<h3>References</h3>

<p>Huang X.F., Xu J.F. and Tian G.L.(2019). 'On profile MM algorithms for gamma frailty survival models.' <em>Statistica Sinica</em> <strong>29</strong>(2), 895-916.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
GaFrailtyMM(Surv(time, status) ~ age + sex + cluster(id), data=kidney)

</code></pre>

<hr>
<h2 id='IC2Control'>Control IC2Pro object</h2><span id='topic+IC2Control'></span>

<h3>Description</h3>

<p>Control IC2Pro object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC2Control(Maxiter = 2000, convergence = 1e-06, Idigits = 4, Pdigits = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC2Control_+3A_maxiter">Maxiter</code></td>
<td>
<p>The maximum number of iterations is specified by default as 2000.</p>
</td></tr>
<tr><td><code id="IC2Control_+3A_convergence">convergence</code></td>
<td>
<p>Specify the convergence criterion, the default is 1e-6.</p>
</td></tr>
<tr><td><code id="IC2Control_+3A_idigits">Idigits</code></td>
<td>
<p>The number of decimal places for the survival interval values.</p>
</td></tr>
<tr><td><code id="IC2Control_+3A_pdigits">Pdigits</code></td>
<td>
<p>The number of decimal places for the survival probability values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of Maxiter, convergence, Idigits, Pdigits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IC2Control()
</code></pre>

<hr>
<h2 id='IC2MM'>MM algorithm based on the AD method for case II interval-censored data</h2><span id='topic+IC2MM'></span>

<h3>Description</h3>

<p>The <code>IC2MM</code> function is used to calculate the case II interval-censored data model. A failure time study that consists of <code class="reqn">n</code> independent subjects from a
homogeneous population with survival function <code class="reqn">S_{(t)}</code>. Let <code class="reqn">T_{i}</code> denote the survival time, and <code class="reqn">i=1, \ldots, n</code>. Suppose that interval-censored data on the
<code class="reqn">T_i</code> are observed and given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{obs} = \{ (L_{i}, R_{i}];  i=1, \ldots, n \} </code>
</p>

<p>where <code class="reqn">T_i \in (L_{i}, R_{i}] </code>. Let <code class="reqn"> \{s_i \}_{j=0}^{m} </code> denote the unique ordered elements of <code class="reqn"> {0, L_{i}, R_{i}, i=1, \ldots, n } </code>.
Take <code class="reqn"> \alpha_{ij} = I(s_{j} \in (L_{i}, R_{i}] ) </code> and <code class="reqn">p_{j}= S(s_{j-1}) - S(s_{j}), j= 1, \ldots, m </code>. The log-likelihood function is
</p>
<p style="text-align: center;"><code class="reqn"> \ell( {p} | Y_{obs}) = \sum_{i=1}^{n} \log (S(L_{i}) - S(R_{i}) ) = \sum_{i=1}^{n} \log \left( \sum_{j=1}^{m} \alpha_{ij} p_{j} \right)</code>
</p>

<p>where <code class="reqn">{p} = (p_1, \ldots, p_m)^{T}  </code> and <code class="reqn"> \sum_{j=1}^{m} p_{j} = 1 , p_{j} \geqslant 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC2MM(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC2MM_+3A_formula">formula</code></td>
<td>
<p>A formula object, which contains on the left hand side an object of type = 'interval2' of the type <code>Surv</code>
e.g. <code>formula=Surv(L,R, type = 'interval2') ~ 1</code></p>
</td></tr>
<tr><td><code id="IC2MM_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> in which to interpret the variables named in the formula.</p>
</td></tr>
<tr><td><code id="IC2MM_+3A_...">...</code></td>
<td>
<p>Additional arguments,  e.g. <code>control=IC2Control()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>IC2MM</code> function allows the distributions for multiple strata of dataset to be stored as one <code>IC2</code> object, e.g. <code>data=bcos</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>IC2MM</code> that contains the following fields: <code>error</code>: convergence result; <code>strata</code>: dimensions of each <code>df_tab</code>;
<code>s</code>: unique ordered elements of <code class="reqn"> {0, L_{i}, R_{i}, Inf} </code>, if more than one strata, elements are concatenated; <code>S</code>: the survival function, if more than one strata, values are concatenated;
<code>df_tab</code>: the dataframe of survival intervals and survival probabilities for each interval, if more than one strata, dataframes are concatenated.
</p>


<h3>References</h3>

<p>Tian G.L., Huang X.F. and Xu, J.(2019). 'An assembly and decomposition approach for constructing separable minorizing functions in a class of MM algorithms.' <em>Statistica Sinica</em> <strong>29</strong>(2), 961-982.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC2Pro">IC2Pro</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
L &lt;- c(1.5, 0.1, 1.5, 0.5, 0.4, 0.2, 0.9, 0.2, 0.08, 1.9)
R &lt;- c(2.1, 2.9, 2.7, 1.9, 1.3, 1.4, 2.3, 0.5, 1.5, 4.6 )
data &lt;- data.frame(L, R)
IC2MM(Surv(L,R, type = 'interval2') ~ 1, data )

IC2MM(Surv(L,R, type = 'interval2') ~ 1, data, control=IC2Control(Pdigits=2) )

</code></pre>

<hr>
<h2 id='IC2Pro'>Calculate non-parametric estimate for case II interval censored survival function</h2><span id='topic+IC2Pro'></span>

<h3>Description</h3>

<p>Calculate non-parametric estimate for case II interval censored survival function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC2Pro(L, R, control = IC2Control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC2Pro_+3A_l">L</code></td>
<td>
<p>The numeric vector of left endpoints of censoring interval, the first element of Surv when type=’interval2’.</p>
</td></tr>
<tr><td><code id="IC2Pro_+3A_r">R</code></td>
<td>
<p>The numeric vector of right endpoints of censoring interval, the second element of Surv function when type=’interval2’.</p>
</td></tr>
<tr><td><code id="IC2Pro_+3A_control">control</code></td>
<td>
<p>An object as created by <code>IC2Control</code></p>
</td></tr>
<tr><td><code id="IC2Pro_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>IC2Pro</code> that contains the following fields: <code>error</code>: convergence result; <code>strata</code>: dimensions of <code>df_tab</code>;
<code>s</code>: unique ordered elements of <code class="reqn"> {0, L_{i}, R_{i}, Inf} </code>; <code>S</code>: the survival function;
<code>df_tab</code>: the data frame of survival intervals and survival probabilities for each interval.
</p>


<h3>References</h3>

<p>Tian G.L., Huang X.F. and Xu, J.(2019). 'An assembly and decomposition approach for constructing separable minorizing functions in a class of MM algorithms.' <em>Statistica Sinica</em> <strong>29</strong>(2), 961-982.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC2Control">IC2Control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- c(1.4, 1.5, 1.3, 0.9, 0.4, 0.2, 0.5, 0.03, 1.7, 0.2)
R &lt;- c(2.2, 3, 2.4, 1.2, 2.8, 0.3, 1.6, 2.5, 2.6, 3.4)
IC2Pro(L, R, control=IC2Control())

</code></pre>

<hr>
<h2 id='kidney'>Kidney Infection Data</h2><span id='topic+kidney'></span>

<h3>Description</h3>

<p>The data consisted of the time to first and second infection relapse in 38 kidney disease patients using a portable dialysis machine.
Infection may occur where the catheter was inserted. Catheters are subsequently removed if infection develops and may be removed for other reasons,
in which case observations are censored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kidney
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 76 rows and 7 columns.
</p>


<h3>Value</h3>

<p>Kidney infection data contains the following fields:
</p>
<table>
<tr><td><code>patient</code></td>
<td>
<p>id</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>event status</p>
</td></tr>
<tr><td><code>age</code></td>
<td>
<p>in years</p>
</td></tr>
<tr><td><code>sex</code></td>
<td>
<p>1=male, 2=female</p>
</td></tr>
<tr><td><code>disease</code></td>
<td>
<p>disease type (0=GN, 1=AN, 2=PKD, 3=Other)</p>
</td></tr>
<tr><td><code>frail</code></td>
<td>
<p>frailty estimate from original paper</p>
</td></tr>
</table>


<h3>References</h3>

<p>McGilchrist C.A. and Aisbett C.W.(1991). &quot;Regression with frailty in survival analysis.&quot; <em>Biometrics</em> <strong>47</strong>, 461-466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data(Kidney)
</code></pre>

<hr>
<h2 id='LTNMM'>MM algorithm based on the AD method for left-truncated normal distribution</h2><span id='topic+LTNMM'></span>

<h3>Description</h3>

<p>The <code>LTNMM</code> function is used to calculate a left-truncated normal distribution model. A <code class="reqn"> LTN(\mu, \sigma^2; a) </code> has the density function
</p>
<p style="text-align: center;"><code class="reqn">f(y; \mu, \sigma^2; a) = \frac{1}{c \sqrt{2 \pi \sigma^{2}}} \exp{( -\frac{(y-\mu)^{2}}{2 \sigma^{2}} )} \centerdot I(y \geq a) </code>
</p>

<p>where <code class="reqn">(\mu, \sigma^2)</code> are two unknown parameters, <code class="reqn"> a </code> is a known constant, <code class="reqn"> c = 1- \Phi(\frac{a-u}{ \sigma}) </code>, and  <code class="reqn"> \Phi(\centerdot) </code> is the cdf of the standard normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LTNMM(
  formula,
  a,
  mu = NULL,
  sigma = NULL,
  data = sys.frame(sys.parent()),
  Maxiter = 2000,
  convergence = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LTNMM_+3A_formula">formula</code></td>
<td>
<p>A formula object which symbolically describes the model to calculated.</p>
</td></tr>
<tr><td><code id="LTNMM_+3A_a">a</code></td>
<td>
<p>A numeric scalar of the known left truncation value.</p>
</td></tr>
<tr><td><code id="LTNMM_+3A_mu">mu</code></td>
<td>
<p>The mean of the normal distribution is set to NULL by default. If the distribution is truncated, we use estimates from OLS.</p>
</td></tr>
<tr><td><code id="LTNMM_+3A_sigma">sigma</code></td>
<td>
<p>The variance of the normal distribution is set to NULL by default. If the distribution is truncated, we use estimates from OLS.</p>
</td></tr>
<tr><td><code id="LTNMM_+3A_data">data</code></td>
<td>
<p>List that contains corresponding covariates. If none is provided then assumes objects are in user’s environment.</p>
</td></tr>
<tr><td><code id="LTNMM_+3A_maxiter">Maxiter</code></td>
<td>
<p>The maximum number of iterations is specified by default as 2000.</p>
</td></tr>
<tr><td><code id="LTNMM_+3A_convergence">convergence</code></td>
<td>
<p>Specify the convergence criterion, the default is 1e-6.</p>
</td></tr>
<tr><td><code id="LTNMM_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>LTNMM</code> function is used to calculate a left-truncated normal distribution model using MM algorithms based on AD technology.
The <code>formula</code> parameter can be used to provide the data that needs to be calculated, such as <code>formula=y~1</code>. By default, the
<code>data</code> is provided by the user’s environment. The initial values of the mean and variance of the normal distribution are estimated using OLS.
</p>


<h3>Value</h3>

<p>An object of class <code>LTNMM</code> that contains the following fields: total amount of observations,
the number of iterations, convergence rate, the log likelihood value, estimated results for the unknown parameters,
the standard deviation of estimate for the unknown parameters, the likelihood-based 95% confidence interval for the unknown parameters,
information criterion: AIC value and BIC value.
</p>


<h3>References</h3>

<p>Tian G.L., Huang X.F., and Xu, J.(2019). 'An assembly and decomposition approach for constructing separable minorizing functions in a class of MM algorithms.' <em>Statistica Sinica</em> <strong>29</strong>(2), 961-982.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y=c(8.7, 5.4, 8.9, 5.8, 6.2, 9.9, 7.5, 9.5, 6.5, 6.3); a=5
LTNMM(y~1, a=5)

</code></pre>

<hr>
<h2 id='lung'>NCCTG Lung Cancer Data</h2><span id='topic+lung'></span>

<h3>Description</h3>

<p>Survival in patients with advanced lung cancer from the North Central Cancer Treatment Group. Performance scores rate how well the patient can perform usual daily activities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lung
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 228 rows and 10 columns.
</p>


<h3>Value</h3>

<p>Kidney infection data contains the following fields:
</p>
<table>
<tr><td><code>inst</code></td>
<td>
<p>Institution code</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Survival time in days</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>censoring status 1=censored, 2=dead</p>
</td></tr>
<tr><td><code>age</code></td>
<td>
<p>Age in years</p>
</td></tr>
<tr><td><code>sex</code></td>
<td>
<p>Male=1 Female=2</p>
</td></tr>
<tr><td><code>ph.ecog</code></td>
<td>
<p>ECOG performance score as rated by the physician. 0=asymptomatic, 1= symptomatic but completely ambulatory</p>
</td></tr>
<tr><td><code>ph.karno</code></td>
<td>
<p>Karnofsky performance score (bad=0-good=100) rated by physician</p>
</td></tr>
<tr><td><code>pat.karno</code></td>
<td>
<p>Karnofsky performance score as rated by patient</p>
</td></tr>
<tr><td><code>meal.cal</code></td>
<td>
<p>Calories consumed at meals</p>
</td></tr>
<tr><td><code>wt.loss</code></td>
<td>
<p>Weight loss in last six months (pounds)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Finkelstein D.M. and Wolfe R.A.(1985). &quot;A semiparametric model for regression analysis of interval-censored failure time data.&quot; <em>Biometrics</em> <strong>41</strong>, 933-945.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data(lung)
</code></pre>

<hr>
<h2 id='plot.Cox'>Plot the Cox object</h2><span id='topic+plot.Cox'></span>

<h3>Description</h3>

<p>Plot the Cox object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cox'
plot(
  x,
  xlab = "Time",
  ylab = "Cumulative hazard",
  type = "s",
  lty = 1,
  lwd = 1,
  col = gray(0),
  digits = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Cox_+3A_x">x</code></td>
<td>
<p>The Cox object, see <code><a href="#topic+CoxMM">CoxMM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Cox_+3A_xlab">xlab</code></td>
<td>
<p>x label, default is 'Time'.</p>
</td></tr>
<tr><td><code id="plot.Cox_+3A_ylab">ylab</code></td>
<td>
<p>y label, default is 'Cumulative hazard'.</p>
</td></tr>
<tr><td><code id="plot.Cox_+3A_type">type</code></td>
<td>
<p>type value, default is 's'.</p>
</td></tr>
<tr><td><code id="plot.Cox_+3A_lty">lty</code></td>
<td>
<p>lty value for line, default is 1.</p>
</td></tr>
<tr><td><code id="plot.Cox_+3A_lwd">lwd</code></td>
<td>
<p>line width, default is 1.</p>
</td></tr>
<tr><td><code id="plot.Cox_+3A_col">col</code></td>
<td>
<p>color parameter, default is gray(0).</p>
</td></tr>
<tr><td><code id="plot.Cox_+3A_digits">digits</code></td>
<td>
<p>The digits after the decimal point, default = 4.</p>
</td></tr>
<tr><td><code id="plot.Cox_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dataframe of 'Time' and accumulative hazard <code class="reqn">\Lambda</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
result &lt;- CoxMM(Surv(time, status) ~ age + sex, lung)

plot(result)


</code></pre>

<hr>
<h2 id='plot.GaF'>Plot the GaF object</h2><span id='topic+plot.GaF'></span>

<h3>Description</h3>

<p>Plot the GaF object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GaF'
plot(
  x,
  xlab = "Time",
  ylab = "Cumulative hazard",
  type = "s",
  lty = 1,
  lwd = 1,
  col = gray(0),
  digits = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.GaF_+3A_x">x</code></td>
<td>
<p>The GaF object, see <code><a href="#topic+GaFrailtyMM">GaFrailtyMM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.GaF_+3A_xlab">xlab</code></td>
<td>
<p>x label, default is 'Time'.</p>
</td></tr>
<tr><td><code id="plot.GaF_+3A_ylab">ylab</code></td>
<td>
<p>y label, default is 'Cumulative hazard'.</p>
</td></tr>
<tr><td><code id="plot.GaF_+3A_type">type</code></td>
<td>
<p>type value, default is 's'.</p>
</td></tr>
<tr><td><code id="plot.GaF_+3A_lty">lty</code></td>
<td>
<p>lty value for line, default is 1.</p>
</td></tr>
<tr><td><code id="plot.GaF_+3A_lwd">lwd</code></td>
<td>
<p>line width, default is 1.</p>
</td></tr>
<tr><td><code id="plot.GaF_+3A_col">col</code></td>
<td>
<p>color parameter, default is gray(0).</p>
</td></tr>
<tr><td><code id="plot.GaF_+3A_digits">digits</code></td>
<td>
<p>The digits after the decimal point, default = 4.</p>
</td></tr>
<tr><td><code id="plot.GaF_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the dataframe of 'Time' and accumulative hazard <code class="reqn">\Lambda</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
result &lt;- GaFrailtyMM(Surv(time, status) ~ age + sex + cluster(id), data=kidney)
plot(result)

</code></pre>

<hr>
<h2 id='plot.IC2'>Plot the IC2 object</h2><span id='topic+plot.IC2'></span>

<h3>Description</h3>

<p>Plot the IC2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IC2'
plot(
  x,
  xlab = "Time",
  ylab = "Survival",
  legend = NULL,
  main = "Survival Function",
  lty = 1:9,
  lwd = 1,
  xleg = 0,
  yleg = 0.15,
  col = gray(0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.IC2_+3A_x">x</code></td>
<td>
<p>The IC2 object, see <code><a href="#topic+IC2MM">IC2MM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_xlab">xlab</code></td>
<td>
<p>x label, default is 'Time'.</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_ylab">ylab</code></td>
<td>
<p>y label, default is 'Survival'.</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_legend">legend</code></td>
<td>
<p>legend, default=NULL.</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_main">main</code></td>
<td>
<p>figure title, default is 'Survival Function'</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_lty">lty</code></td>
<td>
<p>lty value for line, default is 1:9.</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_lwd">lwd</code></td>
<td>
<p>line width, default is 1.</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_xleg">xleg</code></td>
<td>
<p>positional parameters of the legend, default=0.</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_yleg">yleg</code></td>
<td>
<p>positional parameters of the legend, default=0.15 .</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_col">col</code></td>
<td>
<p>the color of the drawing, default=gray(0)</p>
</td></tr>
<tr><td><code id="plot.IC2_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arguments for the legend. Values are x, y, legend, fill, lty, bty, col.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
result = IC2MM(Surv(left, right, type = 'interval2') ~ treatment, bcos)

plot(result, col=c('red', 'blue'))


</code></pre>

<hr>
<h2 id='summary.Cox'>Summary of parameter estimates of a Cox model</h2><span id='topic+summary.Cox'></span>

<h3>Description</h3>

<p>This function returns the result of the <code>CoxMM</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cox'
summary(object, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Cox_+3A_object">object</code></td>
<td>
<p>Output from a call to Cox.</p>
</td></tr>
<tr><td><code id="summary.Cox_+3A_digits">digits</code></td>
<td>
<p>The desired number of digits after the decimal point. Default of 4 digits is used.</p>
</td></tr>
<tr><td><code id="summary.Cox_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary for <code>CoxMM</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoxMM">CoxMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
result &lt;- CoxMM(Surv(time, status) ~ age + sex, lung)

summary(result,digits=4)



</code></pre>

<hr>
<h2 id='summary.CZIGP'>Summary of parameter estimates of a multivariate compound ZIGP model</h2><span id='topic+summary.CZIGP'></span>

<h3>Description</h3>

<p>This function returns the result of the <code>CZIGPMM</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CZIGP'
summary(object, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.CZIGP_+3A_object">object</code></td>
<td>
<p>Output from a call to CZIGP.</p>
</td></tr>
<tr><td><code id="summary.CZIGP_+3A_digits">digits</code></td>
<td>
<p>The desired number of digits after the decimal point. Default of 4 digits is used.</p>
</td></tr>
<tr><td><code id="summary.CZIGP_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary for <code>CZIGPMM</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CZIGPMM">CZIGPMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x1 &lt;- c(0,35,23,34,8,19,0,0,0,0)
x2 &lt;- c(38,15,0,25,34,0,0,0,0,0)
y &lt;- cbind(x1, x2)
phi0 = 0.5; phi = rep(0.5,2); la = rep(1,2); th = rep(0.1,2)
result &lt;- CZIGPMM(y, phi0, phi, la, th)

summary(result,digits=4)

</code></pre>

<hr>
<h2 id='summary.GaF'>Summary of parameter estimates of a gamma frailty model</h2><span id='topic+summary.GaF'></span>

<h3>Description</h3>

<p>This function returns the result of the <code>GaFrailtyMM</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GaF'
summary(object, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.GaF_+3A_object">object</code></td>
<td>
<p>Output from a call to GaF.</p>
</td></tr>
<tr><td><code id="summary.GaF_+3A_digits">digits</code></td>
<td>
<p>The desired number of digits after the decimal point. Default of 4 digits is used.</p>
</td></tr>
<tr><td><code id="summary.GaF_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary for <code>GaFrailtyMM</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaFrailtyMM">GaFrailtyMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(survival)
result &lt;- GaFrailtyMM(Surv(time, status) ~ age + sex + cluster(id), data=kidney)

summary(result,digits=4)



</code></pre>

<hr>
<h2 id='summary.IC2'>Summary of parameter estimates of a IC2 model</h2><span id='topic+summary.IC2'></span>

<h3>Description</h3>

<p>This function returns the result of the <code>IC2MM</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IC2'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.IC2_+3A_object">object</code></td>
<td>
<p>Output from a call to IC2.</p>
</td></tr>
<tr><td><code id="summary.IC2_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary for <code>IC2MM</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC2MM">IC2MM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(survival)
result &lt;- IC2MM(Surv(left, right, type = 'interval2') ~ treatment, bcos)

summary(result)



</code></pre>

<hr>
<h2 id='summary.LTN'>Summary of parameter estimates of a LTN model</h2><span id='topic+summary.LTN'></span>

<h3>Description</h3>

<p>This function returns the result of the <code>LTNMM</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LTN'
summary(object, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.LTN_+3A_object">object</code></td>
<td>
<p>Output from a call to LTN.</p>
</td></tr>
<tr><td><code id="summary.LTN_+3A_digits">digits</code></td>
<td>
<p>The desired number of digits after the decimal point. Default of 4 digits is used.</p>
</td></tr>
<tr><td><code id="summary.LTN_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary for <code>LTNMM</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LTNMM">LTNMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

y=c(8.7, 5.4, 8.9, 5.8, 6.2, 9.9, 7.5, 9.5, 6.5, 6.3); a=5
result &lt;- LTNMM(y~1, a=5)

summary(result,digits=4)



</code></pre>

<hr>
<h2 id='summary.ZIGP'>Summary of parameter estimates of a Type I multivariate ZIGP model</h2><span id='topic+summary.ZIGP'></span>

<h3>Description</h3>

<p>This function returns the result of the <code>ZIGPMM</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ZIGP'
summary(object, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ZIGP_+3A_object">object</code></td>
<td>
<p>Output from a call to ZIGP.</p>
</td></tr>
<tr><td><code id="summary.ZIGP_+3A_digits">digits</code></td>
<td>
<p>The desired number of digits after the decimal point. Default of 4 digits is used.</p>
</td></tr>
<tr><td><code id="summary.ZIGP_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary for <code>ZIGPMM</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ZIGPMM">ZIGPMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x1 &lt;- c(0, 0, 0,38, 0,19,25, 0,25, 0)
x2 &lt;- c(0, 0, 0,23, 0,51,24, 0,10, 0)
y &lt;- cbind(x1, x2)
phi0 = 0.5; la = rep(1,2); th = rep(0.1,2)
result &lt;- ZIGPMM(y, phi0, la, th)

summary(result,digits=4)



</code></pre>

<hr>
<h2 id='vijc'>Voluntary and involuntary job changes data</h2><span id='topic+vijc'></span>

<h3>Description</h3>

<p>Jung and Winkelmann(1993) provided data on both the numbers of voluntary and involuntary job changes of males during ten period 1974–1984.
The samples contain 2124 males who started their working career before or in 1974 and did not retire before 1984.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vijc
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 2124 rows and 2 columns.
</p>


<h3>Value</h3>

<p>Voluntary and involuntary job changes data contains the following fields:
</p>
<table>
<tr><td><code>y1</code></td>
<td>
<p>Job changes after experiencing an unemployment spell(assumed to be involuntary)</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>
<p>Direct job to job changes(which are assumed to be voluntary) </p>
</td></tr>
</table>


<h3>References</h3>

<p>Huang X.F., Tian G.L., Zhang, C. and Jiang, X.(2017). &quot;Type I multivariate zero-inflated generalized Poisson distribution with applications.&quot; <em>Statistics and its Interface</em> <strong>10</strong>(2), 291-311.
</p>
<p>Jung R.C. and Winkelmann R.(1993). &quot;Two aspects of labor mobility: A bivariate Poisson regression approach.&quot; <em>Empirical Economics</em> <strong>18</strong>(3), 543–556.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data(vijc)
</code></pre>

<hr>
<h2 id='ZIGPMM'>MM algorithm based on the AD method for type I multivariate zero-inflated generalized poisson distribution</h2><span id='topic+ZIGPMM'></span>

<h3>Description</h3>

<p>Let <code class="reqn">Z \sim Bernoulli(1- \phi)</code>,
<code class="reqn">{x} = (X_1,\cdots, X_m)^T</code>, <code class="reqn">X_i \sim GP(\lambda_i, \theta_i)</code>, for <code class="reqn">i = 1,\cdots,m</code> , and <code class="reqn">(Z,X_1,\cdots, X_m)</code>
are mutually independent. An <code class="reqn">m</code> dimensional discrete random vector <code class="reqn">{y}=(Y_1,\cdots, Y_m)^T</code> is said to have a Type I
multivariate zero-inflated generalized Poisson distribution(ZIGP) distribution if
</p>
<p style="text-align: center;"><code class="reqn"> {y} \overset{\rm{d}}= Z{x}= \left\{ \begin{array}{ll}
{0} &amp; \text{with probability} \ \lambda \\ {x} &amp; \text{with probability} \ 1-\lambda \\ \end{array} \right. </code>
</p>

<p>where <code class="reqn">\lambda \in [0,1)</code>, <code class="reqn">{\lambda}=(\lambda_1,\cdots, \lambda_m)^T </code>, <code class="reqn">{\theta}=(\theta_1,\cdots, \theta_m)^T </code>,
<code class="reqn">max(-1, -\lambda_i/q_i) &lt; \theta_i \leqslant 1</code> and <code class="reqn">q_i \geqslant 4</code> is the largest positive integer for each <code class="reqn">\lambda_i + \theta_{i}q_{i}&gt;0</code> when <code class="reqn">\theta_{i}&lt;0</code>.
The <code>ZIGPMM</code> function is used to calculate the Type I multivariate ZIGP model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZIGPMM(data, phi0, la, th, Maxiter = 2000, convergence = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZIGPMM_+3A_data">data</code></td>
<td>
<p>Data.frame or Matrix that contains corresponding covariates.</p>
</td></tr>
<tr><td><code id="ZIGPMM_+3A_phi0">phi0</code></td>
<td>
<p>Probability value for the zero-inflated parameter for ZIGP model.</p>
</td></tr>
<tr><td><code id="ZIGPMM_+3A_la">la</code></td>
<td>
<p>The scale parameter for Generalized Poisson distribution model.</p>
</td></tr>
<tr><td><code id="ZIGPMM_+3A_th">th</code></td>
<td>
<p>The discrete parameter for Generalized Poisson distribution model.</p>
</td></tr>
<tr><td><code id="ZIGPMM_+3A_maxiter">Maxiter</code></td>
<td>
<p>The maximum number of iterations is specified by default as 2000.</p>
</td></tr>
<tr><td><code id="ZIGPMM_+3A_convergence">convergence</code></td>
<td>
<p>Specify the convergence criterion, the default is 1e-6.</p>
</td></tr>
<tr><td><code id="ZIGPMM_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ZIGPMM</code> function is used to calculate Type I multivariate zero-inflated generalized Poisson distribution model using MM algorithms
based on AD technology. <code>data</code> is provided by user by default, it can be a data frame or a matrix. In addition, the unknown parameters require users to give appropriate initial values,
where <code>0&lt;=phi0&lt;1</code>, each <code>th</code> should satisfy <code>0&lt;=th&lt;1</code>, and each <code>la</code> should be greater than 0.
</p>


<h3>Value</h3>

<p>An object of class <code>ZIGPMM</code> that contains the following fields: total amount of observations,
the number of iterations, convergence rate, the log likelihood value, estimated results for the unknown parameters,
the standard deviation of estimate for the unknown parameters, the likelihood-based 95% confidence interval for the unknown parameters,
information criterion: AIC value and BIC value.
</p>


<h3>References</h3>

<p>Tian G.L., Huang X.F. and Xu, J.(2019). 'An assembly and decomposition approach for constructing separable minorizing functions in a class of MM algorithms.' <em>Statistica Sinica</em> <strong>29</strong>(2), 961-982.
</p>
<p>Huang X.F., Tian G.L., Zhang, C. and Jiang, X.(2017). 'Type I multivariate zero-inflated generalized Poisson distribution with applications.' <em>Statistics and its Interface</em> <strong>10</strong>(2), 291-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(0, 0, 0,38, 0,19,25, 0,25, 0)
x2 &lt;- c(0, 0, 0,23, 0,51,24, 0,10, 0)
y &lt;- cbind(x1, x2)
phi0 = 0.5; la = rep(1,2); th = rep(0.1,2)
ZIGPMM(y, phi0, la, th)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
