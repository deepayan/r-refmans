<!DOCTYPE html><html><head><title>Help for package disordR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {disordR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Arith'><p>Arithmetic operations</p></a></li>
<li><a href='#c'><p>Concatenation</p></a></li>
<li><a href='#Compare-methods'><p>Methods for comparison of <code>disord</code> objects</p></a></li>
<li><a href='#consistent'><p>Check for consistency</p></a></li>
<li><a href='#disindex-class'><p>Experimental class <code>"disindex"</code></p></a></li>
<li><a href='#disord'><p>Functionality for <code>disord</code> objects</p></a></li>
<li><a href='#disord-class'><p>Class <code>"disord"</code></p></a></li>
<li><a href='#drop'><p>Drop redundant information</p></a></li>
<li><a href='#extract'><p>Extraction and replacement methods for class <code>"disord"</code></p></a></li>
<li><a href='#Logic'><p>Logical operations</p></a></li>
<li><a href='#misc'><p>Miscellaneous functions</p></a></li>
<li><a href='#rdis'><p>Random disord objects</p></a></li>
<li><a href='#show'><p>Print method for disord objects</p></a></li>
<li><a href='#summary.disordR'><p>Summaries of disord objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Ordered Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-8.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods,Matrix (&ge; 1.3-3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvp,knitr,rmarkdown,testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionality for manipulating values of associative
  maps.  The package is designed to be used with the 'mvp' class of
  packages that use the STL map class: its purpose is to trap
  plausible idiom that is ill-defined (implementation-specific) and
  return an informative error, rather than returning a possibly
  incorrect result.  To cite the package in publications please use
  Hankin (2022) &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.03856">doi:10.48550/ARXIV.2210.03856</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/disordR">https://github.com/RobinHankin/disordR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/disordR/issues">https://github.com/RobinHankin/disordR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-12 15:07:48 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 19:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='Arith'>Arithmetic operations</h2><span id='topic+Arith'></span><span id='topic+disord_inverse'></span><span id='topic+disord_negative'></span><span id='topic+disord_positive'></span><span id='topic+disord_mod_disord'></span><span id='topic+disord_mod_numeric'></span><span id='topic+numeric_mod_disord'></span><span id='topic+disord_plus_disord'></span><span id='topic+disord_plus_numeric'></span><span id='topic+disord_power_disord'></span><span id='topic+disord_power_numeric'></span><span id='topic+numeric_power_disord'></span><span id='topic+disord_prod_disord'></span><span id='topic+disord_prod_numeric'></span><span id='topic+disord_arith_disord'></span><span id='topic+disord_arith_numeric'></span><span id='topic+disord_arith_unary'></span><span id='topic+disindex_show'></span><span id='topic+disord_unary'></span><span id='topic+numeric_arith_disord'></span>

<h3>Description</h3>

<p>Arithmetic operations including low-level helper functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>disord_inverse(a)
disord_mod_disord(a,b)
disord_mod_numeric(a,b)
disord_negative(a)
disord_plus_disord(a,b)
disord_plus_numeric(a,b)
disord_power_disord(a,b)
disord_power_numeric(a,b)
numeric_power_disord(a,b)
disord_prod_disord(a,b)
disord_prod_numeric(a,b)
disord_arith_unary(e1,e2)
disord_arith_disord(e1,e2)
disord_arith_numeric(e1,e2)
numeric_arith_disord(e1,e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arith_+3A_a">a</code>, <code id="Arith_+3A_b">b</code></td>
<td>
<p>at least one is a disord object</p>
</td></tr>
<tr><td><code id="Arith_+3A_e1">e1</code>, <code id="Arith_+3A_e2">e2</code></td>
<td>
<p>Formal arguments for S4 dispatch</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basic low-level arithmetic operations, intended to be called from
S4 dispatch.
</p>
<p>These functions return a <code>disord</code> object or a regular vector as
appropriate.  Consistency is required.  The hash is set to be that of
the disord object if appropriate.
</p>


<h3>Value</h3>

<p>Return a disord object or logical</p>


<h3>Methods</h3>


<dl>
<dt>Arith</dt><dd><p><code>signature(e1="disord", e2="disord")</code>:
Dispatched to <code>disord_arith_disord()</code></p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1="disord", e2="numeric")</code>:
Dispatched to <code>disord_arith_numeric()</code></p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1="numeric", e2="disord")</code>:
Dispatched to <code>numeric_arith_disord()</code></p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1="disord", e2="missing")</code>:
Dispatched to <code>disord_arith_unary()</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- rdis()
a
a + 2*a
a &gt; 5
a[a &gt; 5] &lt;- a[a &gt; 5] + 100
a
</code></pre>

<hr>
<h2 id='c'>Concatenation</h2><span id='topic+c'></span><span id='topic+c.disord'></span><span id='topic+c+2Cdisord-method'></span>

<h3>Description</h3>

<p>Concatenation simply does not make sense for <code>disord</code> objects.</p>


<h3>Value</h3>

<p>Returns an error.</p>


<h3>Note</h3>

<p>I could not figure out how to stop idiom like &ldquo;<code>c(1,rdis())</code>&rdquo; from
returning a result.  Just don't use it, OK?
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>

<hr>
<h2 id='Compare-methods'>Methods for comparison of <code>disord</code> objects</h2><span id='topic+Compare-methods'></span><span id='topic+Compare+2Cdisord+2CANY-method'></span><span id='topic+Compare+2Cdisord+2Cdisord-method'></span><span id='topic+Compare+2CANY+2Cdisord-method'></span><span id='topic+any_compare_disord'></span><span id='topic+disord_compare_any'></span><span id='topic+disord_compare_disord'></span>

<h3>Description</h3>

<p>Arithmetic comparison methods (greater than, etc) for <code>disord</code>
objects.
</p>


<h3>Methods</h3>


<dl>
<dt>Compare</dt><dd><p><code>signature(e1="disord", e2="disord")</code>:
Dispatched to <code>disord_compare_disord()</code></p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1="disord", e2="ANY")</code>:
Dispatched to <code>disord_compare_any()</code></p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1="ANY", e2="disord")</code>:
Dispatched to <code>any_compare_disord()</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>All the comparison methods use <code>drop=TRUE</code> to avoid inconsistent
results when all the values are the same [that is, all <code>TRUE</code> or
all <code>FALSE</code>].  Comparing two <code>disord</code> objects requires their
hash code to agree as per <span class="pkg">disordR</span> discipline.  Comparing a
<code>disord</code> with a numeric returns a <code>disord</code> object.  In each
case, the hash code of the original object is preserved in the returned
value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdis() &gt; 4
rdis() &gt; 1000
</code></pre>

<hr>
<h2 id='consistent'>Check for consistency</h2><span id='topic+consistent'></span><span id='topic+is.consistent'></span><span id='topic+check_matching_hash'></span><span id='topic++25~+25'></span>

<h3>Description</h3>

<p>The <span class="pkg">disordR</span> package is designed to make permitted operations
transparent and to prevent forbidden operations from being executed.
</p>
<p>Function <code>consistent()</code> checks for matching hash codes of its
arguments and returns a Boolean.  It is called by function
<code>check_matching_hash()</code> which either returns <code>TRUE</code> or
reports an informative error message if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consistent(x,y)
x %~% y
check_matching_hash(e1,e2,use=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consistent_+3A_x">x</code>, <code id="consistent_+3A_y">y</code>, <code id="consistent_+3A_e1">e1</code>, <code id="consistent_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>disord</code></p>
</td></tr>
<tr><td><code id="consistent_+3A_use">use</code></td>
<td>
<p>optional object designed to give a more intelligible error
message; typically <code>match.call()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>consistent()</code> checks that its arguments have the same
hash code, and thus their elements can be paired up (e.g. added).
Idiom <code>a %~% b</code> is equivalent to <code>consistent(a,b)</code>.
</p>
<p>The package generally checks for consistency with function
<code>check_matching_hash()</code> which provides some helpful diagnostics
if <code>consistent()</code> finds a hash mismatch.
</p>


<h3>Value</h3>

<p>Boolean or an error as appropriate</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+disord">disord</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# rdis() + rdis() # this would make check_matching_hash() report an error, if executed

</code></pre>

<hr>
<h2 id='disindex-class'>Experimental class <code>"disindex"</code></h2><span id='topic+disindex-class'></span><span id='topic+disindex'></span><span id='topic+values'></span>

<h3>Description</h3>

<p>Experimental <code>disindex</code> class provides a <code>disordR</code>-compliant
method for indexing <code>disord</code> objects.  The idea is that
<code>which(x)</code>, where <code>x</code> is Boolean of class <code>disord</code>,
should have meaning under <code>disordR</code> discipline.  Thus
<code>which()</code> gives a <code>disindex</code> object.  This object can be
used as an index for other <code>disord</code> objects.  One application
would be the <code>dismat</code> class of matrices, currently under
development.
</p>
<p>Function <code>values()</code> coerces its argument to an integer vector.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("disindex", ...)</code>,
although <code>which()</code> is more natural.
</p>


<h3>Slots</h3>


<dl>
<dt><code>value</code>:</dt><dd><p>Numeric vector</p>
</dd>
<dt><code>hash</code>:</dt><dd><p>Object of class <code>character</code> that
specifies the hash code</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>

(x &lt;- disord(c(1,2,1,2,2,7)))

x==2
w &lt;- which(x==2)
w

x[w] &lt;- 100
x





</code></pre>

<hr>
<h2 id='disord'>Functionality for <code>disord</code> objects</h2><span id='topic+disord'></span><span id='topic+hash'></span><span id='topic+hashcal'></span><span id='topic+as_disord'></span><span id='topic+is.disord'></span><span id='topic+accessors'></span><span id='topic+disord'></span><span id='topic+elements'></span><span id='topic+disord+3C-'></span>

<h3>Description</h3>

<p>Allows arithmetic operators to be used for disord objects; the
canonical application is coefficients of multivariate polynomials (as
in the <a href="https://CRAN.R-project.org/package=mvp"><span class="pkg">mvp</span></a> package).  The issue is that the storage order of
disord objects is implementation-specific but the order (whatever it
is) must be consistent between the list of keys and values in an
associative array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.disord(x)
hash(x)
hashcal(x,ultra_strict=FALSE)
disord(v,h,drop=TRUE)
elements(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disord_+3A_x">x</code></td>
<td>
<p>Object of class <code>disord</code></p>
</td></tr>
<tr><td><code id="disord_+3A_v">v</code></td>
<td>
<p>Vector of coefficients</p>
</td></tr>
<tr><td><code id="disord_+3A_h">h</code></td>
<td>
<p>Hash code</p>
</td></tr>
<tr><td><code id="disord_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return a
disord object and <code>TRUE</code> meaning to call <code>drop()</code> before
returning</p>
</td></tr>
<tr><td><code id="disord_+3A_ultra_strict">ultra_strict</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to use
just <code>x</code> to generate the hash, and <code>TRUE</code> meaning to use
the date and a random number as well [this ensures that the hash is
generated only once]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A detailed vignette is provided that motivates the package.  In
applications such as the <a href="https://CRAN.R-project.org/package=mvp"><span class="pkg">mvp</span></a> or <a href="https://CRAN.R-project.org/package=clifford"><span class="pkg">clifford</span></a> packages,
the user will not need to even think about the <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a>
package: it works in the background.  The purpose of the package is to
trap plausible idiom that is ill-defined (implementation-specific) and
return an informative error, rather than returning a possibly
incorrect result.
</p>
<p>The package provides a single S4 class, <code>disord</code>,
which has two slots, <code>.Data</code> and <code>hash</code>.
</p>
<p>Function <code>disord()</code> takes an R object such as a vector or list
and returns a <code>disord</code> object, which is useful in the context of
the <code>STL</code> map class.
</p>
<p>Function <code>hash()</code> returns the hash of an object (compare
<code>hashcal()</code> which is used to actually calculate the hash code).
</p>
<p>The package detects acceptable and forbidden operations using hash
codes: function <code>consistent()</code> checks for its arguments having
the same hash code, and thus their elements can be paired up
(e.g. added).  Idiomatically, <code>a %~% b</code> is equivalent to
<code>consistent(a,b)</code>.
</p>
<p>Function <code>elements()</code> takes a <code>disord</code> and returns a regular
<span class="rlang"><b>R</b></span> object, typically a vector or a list.
</p>


<h3>Value</h3>

<p>Boolean, hash code, or object of class <code>disord</code> as
appropriate.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(a &lt;- rdis())
(b &lt;- rdis())

a + 2*a + 2^a  # fine
# a + b # this would give an error if executed

a[a&lt;0.5] &lt;- 0       # round down; replacement works as expected

elements(a)

</code></pre>

<hr>
<h2 id='disord-class'>Class <code>"disord"</code></h2><span id='topic+disord-class'></span>

<h3>Description</h3>

<p>The <code>disord</code> class provides basic arithmetic and extract/replace
methods for disord objects.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("disord", ...)</code>,
although functions <code>disord()</code> and (eventually) <code>as.disord()</code>
are more user-friendly.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>vector</code> that specifies the
elements</p>
</dd>
<dt><code>hash</code>:</dt><dd><p>Object of class <code>character</code> that
specifies the hash code</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("disord")</code></pre>

<hr>
<h2 id='drop'>Drop redundant information</h2><span id='topic+drop'></span><span id='topic+drop+2Cdisord-method'></span><span id='topic+allsame'></span>

<h3>Description</h3>

<p>Coerce <code>disord</code> objects to vector when this makes sense</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop(x)
allsame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_+3A_x">x</code></td>
<td>
<p><code>disord</code> object</p>
</td></tr></table>


<h3>Details</h3>

<p>If one has a disord object all of whose elements are identical, one
usually wants to drop the disord attribute and coerce to a vector.
This can be done without breaking <code>disordR</code> discipline.  Function
<code>disord()</code> takes a <code>drop</code> argument, defaulting to
<code>TRUE</code>, which drops the <code>disord</code> class from its return value
if all the elements are the same.
</p>
<p>Similarly, function <code>drop()</code> takes a disord object and if all
elements are identical it returns the elements in the form of a
vector.  Some extraction methods take a <code>drop</code> argument, which
does the same thing if <code>TRUE</code>.  This is only useful for disord
objects created with <code>disord(...,drop=FALSE)</code>
</p>
<p>The <code>drop</code> functionality is conceptually similar to the
<code>drop</code> argument of base <span class="rlang"><b>R</b></span>'s array extraction, as in
</p>
<pre>
     a &lt;- matrix(1:30,5,6)
     a[1,,drop=TRUE]
     a[1,,drop=FALSE]
   </pre>
<p>Function <code>allsame()</code> takes a vector and returns <code>TRUE</code> if
all elements are identical.
</p>


<h3>Value</h3>

<p>Function <code>drop()</code> returns either a vector or object of class
<code>disord</code> as appropriate; <code>allsame()</code> returns a Boolean.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>disord(c(3,3,3,3,3))             # default is drop=TRUE
disord(c(3,3,3,3,3),drop=FALSE)  # retains disord class

drop(disord(c(3,3,3,3),drop=FALSE)) 

## In extraction, argument drop discards disorderliness when possible:
a &lt;- rdis()
a
a[] &lt;- 6 # a becomes a vector
a

</code></pre>

<hr>
<h2 id='extract'>Extraction and replacement methods for class <code>"disord"</code></h2><span id='topic+extract'></span><span id='topic+index-class'></span><span id='topic++5B'></span><span id='topic++5B+5B'></span><span id='topic++5B.disord'></span><span id='topic++5B+2Cdisord-method'></span><span id='topic++5B+2Cdisord+2Cindex+2CANY-method'></span><span id='topic++5B+2Cdisord+2Cindex+2Cmissing-method'></span><span id='topic++5B+2Cdisord+2CANY+2CANY-method'></span><span id='topic++5B+2Cdisord+2Cindex+2Cindex-method'></span><span id='topic++5B+2Cdisord+2Cmissing+2Cindex-method'></span><span id='topic++5B+2Cdisord+2Cdisord+2Cmissing-method'></span><span id='topic++5B+2Cdisord+2Cdisord+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdisord+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cdisord+2Cindex+2CANY+2CANY-method'></span><span id='topic++5B+2Cdisord+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2CANY+2Cdisord+2CANY-method'></span><span id='topic++5B+2Cdisord+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-'></span><span id='topic++5B+3C-.disord'></span><span id='topic++5B+3C-+2Cdisord-method'></span><span id='topic++5B+3C-+2Cdisord+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cdisord+2Cindex+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cdisord+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cdisord+2Cindex+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cdisord+2Cindex+2Cmissing+2Cdisord-method'></span><span id='topic++5B+3C-+2Cdisord+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cdisord+2Cmissing+2Cmissing+2Cdisord-method'></span><span id='topic++5B+3C-+2Cdisord+2Cindex+2Cindex-method'></span><span id='topic++5B+3C-+2Cdisord+2Cindex+2Cmissing-method'></span><span id='topic++5B+3C-+2Cdisord+2Cmissing+2Cindex-method'></span><span id='topic++5B+3C-+2Cdisord+2Cmissing+2Cmissing-method'></span><span id='topic++5B+3C-+2Cdisord+2Cdisord+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cdisord+2Cdisord+2Cmissing+2Cdisord-method'></span><span id='topic++5B+3C-+2Cdisord+2Cdisord+2Cmissing-method'></span><span id='topic++5B+3C-+2Cdisord+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+5B+2Cdisord+2Cindex-method'></span><span id='topic++5B+5B+3C-+2Cdisord+2Cindex-method'></span><span id='topic+Arith+2CANY+2Cdisord-method'></span><span id='topic+Arith+2Cdisord+2CANY-method'></span><span id='topic+Arith+2Cdisord+2Cdisord-method'></span><span id='topic+Arith+2Cdisord+2Cmissing-method'></span><span id='topic++5B+2Cdisord+2Cdisindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdisord+2Cdisindex+2CANY+2CANY-method'></span><span id='topic++5B+2CANY+2Cdisindex+2CANY+2CANY-method'></span><span id='topic++5B+2Cdisord+2Cdisindex+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cdisord+2Cdisindex+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cdisord+2Cdisindex+2Cmissing+2CANY-method'></span><span id='topic++5B+5B+2Cdisord+2Cdisindex-method'></span><span id='topic++5B+5B+2CANY+2Cdisindex-method'></span><span id='topic++5B+5B+3C-+2Cdisord+2Cdisindex+2Cmissing+2CANY-method'></span><span id='topic++5B+5B+3C-+2CANY+2Cdisindex+2CANY+2CANY-method'></span><span id='topic++5B+5B+3C-+2CANY+2Cdisindex+2CANY-method'></span><span id='topic++5B+5B+3C-+2Cdisord+2Cdisindex+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2Cdisord+2Cdisindex+2CANY-method'></span><span id='topic++5B+5B+3C-+2Cdisord+2Cindex+2CANY-method'></span>

<h3>Description</h3>

<p>The <code>disord</code> class provides basic arithmetic and extract/replace
methods for disord objects.
</p>
<p>Class <dfn>index</dfn> is taken from the excellent <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a> package
and is a <code>setClassUnion()</code> of classes <code>numeric</code>,
<code>logical</code>, and <code>character</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "disord", i = "ANY", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "disord", i = "index", j = "index")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "disord", i = "index", j = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "disord", i = "missing", j = "index")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "disord", i = "missing", j = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "disord", i = "matrix", j = "missing")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "disord", i = "index", j = "index")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "disord", i = "index", j = "missing")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "disord", i = "missing", j = "index")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "disord", i = "matrix", j = "missing")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "disord", i = "missing", j = "missing")</code>: ... </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "disord", i = "index")</code>: ... </p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x = "disord", i = "index",value="ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x="disord",i="disindex",j="missing",drop="ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x="disord",i="disindex",j="ANY",drop="ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x="ANY",i="disindex",j="ANY",drop="ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x="disord",i="disindex",j="missing",value="ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x="disord",i="disindex",j="ANY",value="ANY")</code>: ...</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x="disord",i="disindex",j="missing",drop="ANY")</code>: ... </p>
</dd>
<dt>[[</dt><dd><p><code>signature("disord",i="disindex")</code>: ... </p>
</dd>
<dt>[[</dt><dd><p><code>signature("ANY",i="disindex")</code>: ... </p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x="disord",i="disindex",j="missing",value="ANY")</code> ... </p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x="ANY",i="disindex",j="ANY",value="ANY")</code> ... </p>
</dd>
</dl>

<p>The extraction method takes a <code>drop</code> argument which if
<code>TRUE</code>, returns the <code>drop()</code> of its value.  Extraction, as
in <code>x[i]</code>, is rarely useful.  It is only defined if one extracts
either all, or none, of the elements: anything else is undefined.
Note that the hash code is unchanged if all elements are extracted
(because the order might have changed) but unchanged if none are
(because there is only one way to extract no elements).
</p>
<p>Missing arguments for extraction and replacement are slightly
idiosyncratic.  Extraction idiom such as <code>x[]</code> returns an object
identical to <code>x</code> except for the hash code, which is changed.  I
can't quite see a sensible use-case for this, but the method allows
one to define an object <code>y &lt;- x[]</code> for which <code>x</code> and
<code>y</code> are incompatible.  Replacement idiom <code>x[] &lt;- v</code> always
coerces to a vector.
</p>
<p>Double square extraction, as in <code>x[[i]]</code> and <code>x[[i]] &lt;-
  value</code>, is via (experimental) <code>disindex</code> functionality.
</p>


<h3>Note</h3>

<p>Package versions prior to <code>disordR_0.0-9-6</code> allowed idiom such as
</p>
<pre>
    a &lt;- disord(1:9)
    a[a&lt;3] + a[a&gt;7]
  </pre>
<p>but this is now disallowed.  The issue is discussed in
<code>inst/note_on_extraction.Rmd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop">drop</a></code>,<code><a href="#topic+misc">misc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- disord(sample(9))
a
a + 6*a^2
a[a&gt;5]  # "give me all elements of a that exceed 5"

a[] # a disord object, same elements as 'a', but with a different hash

a[a&lt;5] &lt;- a[a&lt;5] + 100  # "replace all elements of 'a' less than 5 with their value plus 100"
a

## Following expressions would return an error if executed:
if(FALSE){
  a[1]
  a[1] &lt;- 44
  a[1:2] &lt;- a[3:4]
}

b &lt;- disord(sample(9))
## Following expressions would also return an error if executed:
if(FALSE){
  a+b  # (not really an example of extraction)
  a[b&gt;5]
  a[b&gt;5] &lt;- 100
  a[b&gt;5] &lt;- a[b&gt;5] + 44
}

</code></pre>

<hr>
<h2 id='Logic'>Logical operations</h2><span id='topic+Logic'></span><span id='topic+disord_logic'></span><span id='topic+disord_logic_disord'></span><span id='topic+disord_logic_any'></span><span id='topic+any_logic_disord'></span><span id='topic+disord_logic_unary'></span><span id='topic+disord_logic_missing'></span><span id='topic+disord_logical_negate'></span>

<h3>Description</h3>

<p>Logical operations including low-level helper functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>disord_logical_negate(x)
disord_logic_disord(e1,e2)
disord_logic_any(e1,e2)
any_logic_disord(e1,e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logic_+3A_e1">e1</code>, <code id="Logic_+3A_e2">e2</code>, <code id="Logic_+3A_x">x</code></td>
<td>
<p>Formal arguments for S4 dispatch: logical
<code>disord</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basic low-level logical operations, intended to be called from
S4 dispatch.
</p>
<p>These functions return a logical <code>disord</code> object.  appropriate.
Consistency is required.  The hash is set to be that of the disord
object if appropriate.
</p>


<h3>Value</h3>

<p>Return a disord object or logical</p>


<h3>Methods</h3>


<dl>
<dt>Logic</dt><dd><p><code>signature(e1="disord", e2="disord")</code>:
Dispatched to <code>disord_logic_disord()</code></p>
</dd>
<dt>Logic</dt><dd><p><code>signature(e1="disord", e2="ANY")</code>:
Dispatched to <code>disord_logic_any()</code></p>
</dd>
<dt>Logic</dt><dd><p><code>signature(e1="ANY", e2="disord")</code>:
Dispatched to <code>any_logic_disord()</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- disord(1:7)
l &lt;- a&gt;3
sum(l)
any(l)
all(l | !l)

</code></pre>

<hr>
<h2 id='misc'>Miscellaneous functions</h2><span id='topic+misc'></span><span id='topic+length'></span><span id='topic+length.disord'></span><span id='topic+length.disindex'></span><span id='topic+length+3C-'></span><span id='topic+length+3C-.disord'></span><span id='topic+length+2Cdisord-method'></span><span id='topic+length+2Cdisindex-method'></span><span id='topic+length+3C-+2Cdisord-method'></span><span id='topic+rev'></span><span id='topic+rev+2Cdisord-method'></span><span id='topic+rev.disord'></span><span id='topic+sort'></span><span id='topic+sort+2Cdisord-method'></span><span id='topic+sort.disord'></span><span id='topic+sapply'></span><span id='topic+sapply+2Cdisord-method'></span><span id='topic+sapply.disord'></span><span id='topic+lapply'></span><span id='topic+lapply+2Cdisord-method'></span><span id='topic+lapply.disord'></span><span id='topic+is.na'></span><span id='topic+is.na.disord'></span><span id='topic+is.na+3C-'></span><span id='topic+is.na+3C-.disord'></span><span id='topic+is.na+2Cdisord-method'></span><span id='topic+is.na+3C-+2Cdisord-method'></span><span id='topic+match'></span><span id='topic+match+2Cdisord-method'></span><span id='topic+match+2Cdisord+2CANY-method'></span><span id='topic+match+2CANY+2Cdisord-method'></span><span id='topic+match+2CANY+2Cdisord-method'></span><span id='topic+match+2Cdisord+2Cdisord-method'></span><span id='topic++25in+25'></span><span id='topic++25in+25+2Cdisord-method'></span><span id='topic++25in+25+2Cdisord+2CANY-method'></span><span id='topic++25in+25+2CANY+2Cdisord-method'></span><span id='topic++25in+25+2CANY+2Cdisord-method'></span><span id='topic++25in+25+2Cdisord+2Cdisord-method'></span><span id='topic++21+2Cdisord-method'></span><span id='topic+as.logical+2Cdisord-method'></span><span id='topic+as.numeric+2Cdisord-method'></span><span id='topic+as.double+2Cdisord-method'></span><span id='topic+as.list+2Cdisord-method'></span><span id='topic+as.character+2Cdisord-method'></span><span id='topic+as.complex+2Cdisord-method'></span><span id='topic+unlist+2Cdisord-method'></span><span id='topic+which+2Cdisord-method'></span><span id='topic+which+2Cdisindex-method'></span><span id='topic+unlist'></span><span id='topic+diff'></span>

<h3>Description</h3>

<p>This page documents various functions that work for disords, and I will
add to these from time to time as I add new functions that make sense
for disord objects.  Functions like <code>sin()</code> and <code>abs()</code> work
as expected: they take and return <code>disord</code> objects with the same
hash as <code>x</code> (which means that idiom like <code>x + sin(x)</code> is
accepted).  However, there are a few functions that are a little more
involved:
</p>

<ul>
<li><p><code>rev()</code> reverses its argument and returns a <code>disord</code>
object with a reversed hash, which ensures that <code>rev(rev(x))==x</code>
(and the two are consistent).
</p>
</li>
<li><p><code>sort()</code> returns a vector of sorted elements (not a
<code>disord</code>)
</p>
</li>
<li><p><code>length()</code> returns the length of the data component of the
object
</p>
</li>
<li><p><code>sapply(X,f)</code> returns a disord object which is the result of
applying <code>f()</code> to each element of <code>X</code>.
</p>
</li>
<li><p><code>match(x,table)</code> should behave as expected but note that if
<code>table</code> is a <code>disord</code>, the result is not defined (because it
is not known where the elements of <code>x</code> occur in <code>table</code>).
Nevertheless <code>x %in% table</code> is defined and returns a
<code>disord</code> object.
</p>
</li>
<li><p><code>lapply(x,f)</code> returns
<code>disord(lapply(elements(x),f,...),h=hash(x))</code>.  Note that double
square bracket extraction, as in <code>x[[i]]</code>, is disallowed (see
<code>extract.Rd</code>).
</p>
</li>
<li><p><code>which()</code> returns a <code>disind</code> object when given a
Boolean  <code>disord</code>
</p>
</li>
<li><p><code>unlist()</code> takes a <code>disord</code> list, flattens it and
returns a <code>disord</code> vector.  It requires the <code>recursive</code> flag
of <code>base::unlist()</code> to be <code>TRUE</code>, which it is by default,
interpreting this to mean &ldquo;kill all the structure in any
sublists&rdquo;.  If the list comprises only length-one vectors, the
returned value retains the same hash as the argument; if not, a new
hash is generated.
</p>
</li>
<li><p><code>diff()</code> is undefined for <code>disord</code> objects.
</p>
</li></ul>



<h3>Arguments</h3>

<table>
<tr><td><code id="misc_+3A_x">x</code></td>
<td>
<p>Object of class <code>disord</code></p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a disord</p>


<h3>Note</h3>

<p>Some functionality is not yet implemented.  Factors, lists, and named
vectors do not behave entirely consistently in the package;
<code>paste()</code> gives inconsistent results when called with disords.
</p>
<p>Also, <code>for()</code> loops are incompatible with disord discipline, as
they impose an ordering (<code>for()</code> accesses the <code>.Data</code> slot of
its argument, which is a regular <span class="rlang"><b>R</b></span> vector).  Thus:
</p>
<pre>
&gt; (a &lt;- disord(1:3))
A disord object with hash 555f6bea49e58a2c2541060a21c2d4f9078c3086 and elements
[1] 1 2 3
(in some order)
&gt; for(i in a){print(i)}
[1] 1
[1] 2
[1] 3
&gt; 
</pre>
<p>Above, we see that <code>for()</code> uses the ordering of the <code>.Data</code>
slot of S4 object <code>a</code>, even though <code>elements()</code> has
not been explicitly called.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract">extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- disord(c(a=1,b=2,c=7))
a
names(a)
length(a)
sqrt(a)


# powers() and vars() in the mvp package return lists; see the vignette
# for more discussion.

l &lt;- disord(list(3,6:9,1:10))  
sapply(l,length)

unlist(l)

## Quick illustration of rev():

revstring &lt;- function(s){paste(rev(unlist(strsplit(s, NULL))),collapse="")}
x &lt;- rdis()
revstring(hash(x)) == hash(rev(x))

</code></pre>

<hr>
<h2 id='rdis'>Random disord objects</h2><span id='topic+rdis'></span><span id='topic+rdisord'></span><span id='topic+rdisordR'></span>

<h3>Description</h3>

<p>Returns a random disord object</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdis(n=9)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdis_+3A_n">n</code></td>
<td>
<p>Set to sample from, as interpreted by <code>sample()</code></p>
</td></tr></table>


<h3>Details</h3>

<p>A simple <code>disord</code> object,  intended as a quick
&ldquo;get you going&rdquo; example</p>


<h3>Value</h3>

<p>A <code>disord</code> object.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdis()
rdis(99)
rdis(letters)
</code></pre>

<hr>
<h2 id='show'>Print method for disord objects</h2><span id='topic+show'></span><span id='topic+print'></span><span id='topic+print.disord'></span><span id='topic+print+2Cdisord-method'></span><span id='topic+show+2Cdisord-method'></span><span id='topic+disord_show'></span>

<h3>Description</h3>

<p>Show methods for disords</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'disord'
show(x)
disord_show(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_x">x</code></td>
<td>
<p>Object of class disord</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method simply prints the object's hash and its elements,
together with a reminder that the elements are listed in an
implementation-specific order.  Function <code>disord_show()</code> is a
helper function, not really intended for the end-user.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(rdis())
</code></pre>

<hr>
<h2 id='summary.disordR'>Summaries of disord objects</h2><span id='topic+summary.disordR'></span><span id='topic+summary.disord'></span><span id='topic+print.summary.disord'></span><span id='topic+summary+2Cdisord-method'></span><span id='topic+summary+2Cdisindex-method'></span>

<h3>Description</h3>

<p>A summary method for disord objects, and a print method for summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'disord'
summary(object, ...)
## S4 method for signature 'disindex'
summary(object, ...)
## S3 method for class 'summary.disord'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.disordR_+3A_object">object</code>, <code id="summary.disordR_+3A_x">x</code></td>
<td>
<p>Object of class <code>disord</code></p>
</td></tr>
<tr><td><code id="summary.disordR_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>summary.disord</code> object is summary of a <code>disord</code> object
<code>x</code>: a list with first element being the <code>hash(x)</code> and the
second being <code>summary(elements(x))</code>.  The print method is just a
wrapper for this.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(rdis(1000))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
