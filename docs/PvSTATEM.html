<!DOCTYPE html><html lang="en"><head><title>Help for package PvSTATEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PvSTATEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_path_equal'><p>Check if two paths are equal</p></a></li>
<li><a href='#clamp'><p>Clamp a value to a range</p></a></li>
<li><a href='#convert_dilutions_to_numeric'><p>Convert dilutions to numeric values</p></a></li>
<li><a href='#create_standard_curve_model_analyte'><p>Create a standard curve model for a certain analyte</p></a></li>
<li><a href='#create_vector_without_holes'><p>Remove holes from a vector</p></a></li>
<li><a href='#detect_mba_format'><p>Try to detect the format of a file</p></a></li>
<li><a href='#dilution_to_rau'><p>Convert dilution to RAU</p></a></li>
<li><a href='#extract_dilution_from_names'><p>Extract dilution factor from the sample name</p></a></li>
<li><a href='#extract_dilutions_from_layout'><p>Extract dilutions from the layout representation</p></a></li>
<li><a href='#extract_sample_names_from_layout'><p>Extract sample names from layout</p></a></li>
<li><a href='#find_layout_file'><p>Find a layout file given plate filepath</p></a></li>
<li><a href='#format_dilutions'><p>Format dilutions</p></a></li>
<li><a href='#generate_levey_jennings_report'><p>Generate a Levey-Jennings Report for Multiple Plates.</p></a></li>
<li><a href='#generate_plate_report'><p>Generate a report for a plate.</p></a></li>
<li><a href='#get_join_value'><p>Determine the Join Value</p></a></li>
<li><a href='#get_location_matrix'><p>Generate the matrix of plate locations</p></a></li>
<li><a href='#get_nmfi'><p>Calculate normalised MFI values for a plate</p></a></li>
<li><a href='#get_output_dir'><p>Get output directory for a given input file</p></a></li>
<li><a href='#handle_datetime'><p>Handle differences in datetimes</p></a></li>
<li><a href='#handle_high_dose_hook'><p>Detect and handle the high dose hook effect</p></a></li>
<li><a href='#is_mba_data_file'><p>Identify if a file is a MBA data file</p></a></li>
<li><a href='#is_mba_format'><p>Check if a mba format is supported</p></a></li>
<li><a href='#is_outlier'><p>Check if a value is an outlier</p></a></li>
<li><a href='#is_valid_data_type'><p>Check validity of given data type</p></a></li>
<li><a href='#is_valid_sample_type'><p>Check validity of given sample type</p></a></li>
<li><a href='#is.decreasing'><p>Check if the vector is monotically decreasing</p></a></li>
<li><a href='#is.scalar'><p>Check if a value is a scalar</p></a></li>
<li><a href='#is.str.number'><p>Check if a string is a number</p></a></li>
<li><a href='#merge_dataframes'><p>Merge dataframes</p></a></li>
<li><a href='#Model'><p>Logistic regression model for the standard curve</p></a></li>
<li><a href='#Plate'><p>Plate object</p></a></li>
<li><a href='#PlateBuilder'><p>PlateBuilder</p></a></li>
<li><a href='#plot_counts'><p>Plot counts in a 96-well plate</p></a></li>
<li><a href='#plot_layout'><p>Plot layout of a 96-well plate</p></a></li>
<li><a href='#plot_levey_jennings'><p>Plot Levey-Jennings chart</p></a></li>
<li><a href='#plot_mfi_for_analyte'><p>Plot MFI value distribution for a given analyte</p></a></li>
<li><a href='#plot_plate'><p>Plot a 96-well plate with coloured wells</p></a></li>
<li><a href='#plot_standard_curve_analyte'><p>Standard curves</p></a></li>
<li><a href='#plot_standard_curve_analyte_with_model'><p>Plot standard curve of a certain analyte with fitted model</p></a></li>
<li><a href='#plot_standard_curve_stacked'><p>Standard curve stacked plot for levey-jennings report</p></a></li>
<li><a href='#plot_standard_curve_thumbnail'><p>Standard curve thumbnail for report</p></a></li>
<li><a href='#predict.Model'><p>Predict the RAU values from the MFI values</p></a></li>
<li><a href='#process_dir'><p>Process a dir of files to generate normalised data and reports</p></a></li>
<li><a href='#process_file'><p>Process a file to generate normalised data and reports</p></a></li>
<li><a href='#process_plate'><p>Process a plate and save output values to a CSV</p></a></li>
<li><a href='#read_intelliflex_format'><p>Read the Intelliflex format data</p></a></li>
<li><a href='#read_layout_data'><p>Read layout data from a file</p></a></li>
<li><a href='#read_luminex_data'><p>Read Luminex Data</p></a></li>
<li><a href='#read_xponent_format'><p>Read the xPONENT format data</p></a></li>
<li><a href='#remove_empty_lists'><p>Remove Empty Lists from a List</p></a></li>
<li><a href='#select_columns'><p>Select Columns from a DataFrame</p></a></li>
<li><a href='#sort_list_by'><p>Sort a flat list by value</p></a></li>
<li><a href='#translate_sample_names_to_sample_types'><p>Translate sample names to sample types</p></a></li>
<li><a href='#validate_filepath_and_output_dir'><p>Validate filepath and output_dir</p></a></li>
<li><a href='#verbose_cat'><p>Verbose Cat</p></a></li>
<li><a href='#verify_character_join'><p>Verify Character Join</p></a></li>
<li><a href='#verify_numeric_join'><p>Verify Numeric Join</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Reading, Quality Control and Preprocessing of MBA (Multiplex
Bead Assay) Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Speeds up the process of loading raw data from MBA (Multiplex Bead Assay) examinations, performs quality control checks, and automatically normalises the data, preparing it for more advanced, downstream tasks. The main objective of the package is to create a simple environment for a user, who does not necessarily have experience with R language. The package is developed within the project of the same name - 'PvSTATEM', which is an international project aiming for malaria elimination.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mini-pw/PvSTATEM/issues">https://github.com/mini-pw/PvSTATEM/issues</a></td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, nplr, R6, readr, readxl, stringi, stringr,
grid, png, tools, ggrepel, lubridate, R.utils, svglite, fs,
scales</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, qpdf, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testfhat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mini-pw/PvSTATEM">https://github.com/mini-pw/PvSTATEM</a>,
<a href="https://mini-pw.github.io/PvSTATEM/">https://mini-pw.github.io/PvSTATEM/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-27 00:16:12 UTC; tymot</td>
</tr>
<tr>
<td>Author:</td>
<td>Tymoteusz Kwiecinski
    <a href="https://orcid.org/0009-0006-7362-9821"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jakub Grzywaczewski [aut],
  Mateusz Nizwantowski [aut],
  Przemyslaw Biecek <a href="https://orcid.org/0000-0001-8423-1823"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths],
  Nuno Sepulveda <a href="https://orcid.org/0000-0002-8542-1706"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tymoteusz Kwiecinski &lt;tymoteuszkwiecinski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-27 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_path_equal'>Check if two paths are equal</h2><span id='topic+check_path_equal'></span>

<h3>Description</h3>

<p>Function checks if two paths are equal after converting them to absolute paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_path_equal(path1, path2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_path_equal_+3A_path1">path1</code></td>
<td>
<p>(<code>character(1)</code>) The first path to be compared.</p>
</td></tr>
<tr><td><code id="check_path_equal_+3A_path2">path2</code></td>
<td>
<p>(<code>character(1)</code>) The second path to be compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>logical(1)</code>) <code>TRUE</code> if the paths are equal, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='clamp'>Clamp a value to a range</h2><span id='topic+clamp'></span>

<h3>Description</h3>

<p>Clamp a value to a range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clamp(x, lower = -Inf, upper = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clamp_+3A_x">x</code></td>
<td>
<p>(<code>numeric()</code>) A numeric value to be clamped.</p>
</td></tr>
<tr><td><code id="clamp_+3A_lower">lower</code></td>
<td>
<p>('numeric(1)') The lower bound of the range.</p>
</td></tr>
<tr><td><code id="clamp_+3A_upper">upper</code></td>
<td>
<p>(<code>numeric(1)</code>) The upper bound of the range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value clamped to the range [<code>lower</code>, <code>upper</code>].
</p>

<hr>
<h2 id='convert_dilutions_to_numeric'>Convert dilutions to numeric values</h2><span id='topic+convert_dilutions_to_numeric'></span>

<h3>Description</h3>

<p>Convert dilutions saved as strings in format <code style="white-space: pre;">&#8288;1/\d+&#8288;</code> into numeric values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_dilutions_to_numeric(dilutions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_dilutions_to_numeric_+3A_dilutions">dilutions</code></td>
<td>
<p>vector of dilutions used during the examination saved
as strings in format <code style="white-space: pre;">&#8288;1/\d+&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of numeric values representing the dilutions
</p>

<hr>
<h2 id='create_standard_curve_model_analyte'>Create a standard curve model for a certain analyte</h2><span id='topic+create_standard_curve_model_analyte'></span>

<h3>Description</h3>

<p>Create a standard curve model for a certain analyte
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_standard_curve_model_analyte(
  plate,
  analyte_name,
  data_type = "Median",
  source_mfi_range_from_all_analytes = FALSE,
  detect_high_dose_hook = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_standard_curve_model_analyte_+3A_plate">plate</code></td>
<td>
<p>(<code>Plate()</code>)
Object of the Plate class</p>
</td></tr>
<tr><td><code id="create_standard_curve_model_analyte_+3A_analyte_name">analyte_name</code></td>
<td>
<p>(<code>character(1)</code>)
Name of the analyte for which we want to create the model</p>
</td></tr>
<tr><td><code id="create_standard_curve_model_analyte_+3A_data_type">data_type</code></td>
<td>
<p>(<code>character(1)</code>)
Data type of the value we want to use to fit the model - the same datatype as in the plate file. By default, it equals to <code>Median</code></p>
</td></tr>
<tr><td><code id="create_standard_curve_model_analyte_+3A_source_mfi_range_from_all_analytes">source_mfi_range_from_all_analytes</code></td>
<td>
<p>(<code>logical(1)</code>)
If <code>TRUE</code>, the MFI range is calculated from all analytes; if <code>FALSE</code>, the MFI range is calculated only for the current analyte
Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="create_standard_curve_model_analyte_+3A_detect_high_dose_hook">detect_high_dose_hook</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, the high dose hook effect is detected and handled.
For more information, please see the <a href="#topic+handle_high_dose_hook">handle_high_dose_hook</a> function documentation.</p>
</td></tr>
<tr><td><code id="create_standard_curve_model_analyte_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the model
</p>
<p>Standard curve samples should not contain <code>na</code> values in mfi values nor in dilutions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>Model()</code>) Standard Curve model
</p>

<hr>
<h2 id='create_vector_without_holes'>Remove holes from a vector</h2><span id='topic+create_vector_without_holes'></span>

<h3>Description</h3>

<p>Function selects the values from the vector at the given locations
and creates a vector &quot;without holes&quot;. Works only for 96-plate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_vector_without_holes(vector, locations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_vector_without_holes_+3A_vector">vector</code></td>
<td>
<p>A vector with values</p>
</td></tr>
<tr><td><code id="create_vector_without_holes_+3A_locations">locations</code></td>
<td>
<p>A vector with locations where the values should be placed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with values at the given locations
</p>

<hr>
<h2 id='detect_mba_format'>Try to detect the format of a file</h2><span id='topic+detect_mba_format'></span>

<h3>Description</h3>

<p>Try to detect the format of a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_mba_format(filepath, format = NULL)
</code></pre>

<hr>
<h2 id='dilution_to_rau'>Convert dilution to RAU</h2><span id='topic+dilution_to_rau'></span>

<h3>Description</h3>

<p>Convert dilution to RAU
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dilution_to_rau(predicted_dilution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dilution_to_rau_+3A_predicted_dilution">predicted_dilution</code></td>
<td>
<p>(<code>numeric()</code>) A numeric value representing the predicted dilution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The RAU value corresponding to the predicted dilution .
</p>

<hr>
<h2 id='extract_dilution_from_names'>Extract dilution factor from the sample name</h2><span id='topic+extract_dilution_from_names'></span>

<h3>Description</h3>

<p>function extracts dilution factor from the sample name - useful for detecting
dilution from sample names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_dilution_from_names(sample_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_dilution_from_names_+3A_sample_name">sample_name</code></td>
<td>
<p>a vector of sample names from which we want to extract the dilutions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of dilutions represented as strings extracted from the sample names
</p>

<hr>
<h2 id='extract_dilutions_from_layout'>Extract dilutions from the layout representation</h2><span id='topic+extract_dilutions_from_layout'></span>

<h3>Description</h3>

<p>Extract dilution factor represented as string from vector of characters.
The matches has to be exact and the dilution factor has to be in the form of <code style="white-space: pre;">&#8288;1/\d+&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_dilutions_from_layout(dilutions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_dilutions_from_layout_+3A_dilutions">dilutions</code></td>
<td>
<p>vector of dilutions used during the examination
due to the nature of data it's a vector of strings,
the numeric vales are created from those strings</p>
</td></tr>
</table>

<hr>
<h2 id='extract_sample_names_from_layout'>Extract sample names from layout</h2><span id='topic+extract_sample_names_from_layout'></span>

<h3>Description</h3>

<p>Function extracts sample names from the layout file based on the provided locations.
Function assumes that the plate is 96-well and extracts
the sample names according to the provided location strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_sample_names_from_layout(layout_names, locations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_sample_names_from_layout_+3A_layout_names">layout_names</code></td>
<td>
<p>a vector of sample names from the layout file</p>
</td></tr>
<tr><td><code id="extract_sample_names_from_layout_+3A_locations">locations</code></td>
<td>
<p>a vector of locations in the form of A1, B2, etc.</p>
</td></tr>
</table>

<hr>
<h2 id='find_layout_file'>Find a layout file given plate filepath</h2><span id='topic+find_layout_file'></span>

<h3>Description</h3>

<p>Find a layout file given plate filepath
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_layout_file(plate_filepath, layout_filepath = NULL)
</code></pre>

<hr>
<h2 id='format_dilutions'>Format dilutions</h2><span id='topic+format_dilutions'></span>

<h3>Description</h3>

<p>The function counts the number of times each dilution factor appears and sorts them in descending order based on the corresponding dilution values.
The output is a string that lists the dilution factors and their counts in the format <code style="white-space: pre;">&#8288;count x dilution_factor&#8288;</code>.
If the dilutions vector looks like <code>c("1/2", "1/2", "1/2", "1/3", "1/3", "1/4")</code>, the output will be <code>"3x1/2, 2x1/3, 1x1/4"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_dilutions(dilutions, dilution_values, sample_types)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_dilutions_+3A_dilutions">dilutions</code></td>
<td>
<p>A vector of dilution factors, taken from plate object.</p>
</td></tr>
<tr><td><code id="format_dilutions_+3A_dilution_values">dilution_values</code></td>
<td>
<p>A vector of dilution values corresponding to the dilution factors, taken from plate object. Used only for sorting purposes.</p>
</td></tr>
<tr><td><code id="format_dilutions_+3A_sample_types">sample_types</code></td>
<td>
<p>A vector of sample types taken from plate object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted string that lists the dilution factors and their counts. Returns <code>NULL</code> if <code>dilutions</code> is <code>NULL</code>.
</p>

<hr>
<h2 id='generate_levey_jennings_report'>Generate a Levey-Jennings Report for Multiple Plates.</h2><span id='topic+generate_levey_jennings_report'></span>

<h3>Description</h3>

<p>This function generates a Levey-Jennings report for a list of plates. The report includes layout plot, levey jennings plot, for each analyte and selected dilutions.
The report also includes stacked standard curves plot in both monochromatic and color versions for each analyte.
The report is generated using the <code>levey_jennings_report_template.Rmd</code> template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_levey_jennings_report(
  list_of_plates,
  report_title,
  dilutions = c("1/100", "1/400"),
  filename = NULL,
  output_dir = "reports",
  additional_notes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_levey_jennings_report_+3A_list_of_plates">list_of_plates</code></td>
<td>
<p>A list of plate objects.</p>
</td></tr>
<tr><td><code id="generate_levey_jennings_report_+3A_report_title">report_title</code></td>
<td>
<p>(<code>character(1)</code>) The title of the report.</p>
</td></tr>
<tr><td><code id="generate_levey_jennings_report_+3A_dilutions">dilutions</code></td>
<td>
<p>(<code>character</code>) A character vector specifying the dilutions to be included in the report. Default is <code>c("1/100", "1/400")</code>.</p>
</td></tr>
<tr><td><code id="generate_levey_jennings_report_+3A_filename">filename</code></td>
<td>
<p>(<code>character(1)</code>) The name of the output HTML report file.
If not provided or set to <code>NULL</code>, the filename will be based on the first plate name, formatted as <code style="white-space: pre;">&#8288;{plate_name}_levey_jennings.html&#8288;</code>.
If the filename does not contain the <code>.html</code> extension, it will be automatically added.
Absolute file paths in <code>filename</code> will override <code>output_dir</code>.
Existing files at the specified path will be overwritten.</p>
</td></tr>
<tr><td><code id="generate_levey_jennings_report_+3A_output_dir">output_dir</code></td>
<td>
<p>(<code>character(1)</code>) The directory where the report will be saved. Defaults to 'reports'.
If <code>NULL</code>, the current working directory will be used. Necessary directories will be created if they do not exist.</p>
</td></tr>
<tr><td><code id="generate_levey_jennings_report_+3A_additional_notes">additional_notes</code></td>
<td>
<p>(<code>character(1)</code>) Additional notes to be included in the report. Markdown formatting is supported. If not provided, the section will be omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Levey-Jennings report in HTML format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>output_dir &lt;- tempdir(check = TRUE)

dir_with_luminex_files &lt;- system.file("extdata", "multiplate_lite",
  package = "PvSTATEM", mustWork = TRUE
)
list_of_plates &lt;- process_dir(dir_with_luminex_files,
  return_plates = TRUE, format = "xPONENT", output_dir = output_dir
)
note &lt;- "This is a Levey-Jennings report.\n**Author**: Jane Doe \n**Tester**: John Doe"

generate_levey_jennings_report(
  list_of_plates = list_of_plates,
  report_title = "QC Report",
  dilutions = c("1/100", "1/200"),
  output_dir = tempdir(),
  additional_notes = note
)

</code></pre>

<hr>
<h2 id='generate_plate_report'>Generate a report for a plate.</h2><span id='topic+generate_plate_report'></span>

<h3>Description</h3>

<p>This function generates a report for a plate. The report contains all the necessary information about the plate, from the general plate parameters, such as examination date, to the breakdown of the analytes' plots.
The report is generated using the <code>plate_report_template.Rmd</code> template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_plate_report(
  plate,
  use_model = TRUE,
  filename = NULL,
  output_dir = "reports",
  counts_lower_threshold = 50,
  counts_higher_threshold = 70,
  additional_notes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_plate_report_+3A_plate">plate</code></td>
<td>
<p>A plate object.</p>
</td></tr>
<tr><td><code id="generate_plate_report_+3A_use_model">use_model</code></td>
<td>
<p>(<code>logical(1)</code>) A logical value indicating whether the model should be used in the report.</p>
</td></tr>
<tr><td><code id="generate_plate_report_+3A_filename">filename</code></td>
<td>
<p>(<code>character(1)</code>) The name of the output HTML report file.
If not provided or equals to <code>NULL</code>, the output filename will be based on the plate name, precisely: <code style="white-space: pre;">&#8288;{plate_name}_report.html&#8288;</code>.
By default the <code>plate_name</code> is the filename of the input file that contains the plate data.
For more details please refer to <a href="#topic+Plate">Plate</a>.
</p>
<p>If the passed filename does not contain <code>.html</code> extension, the default extension <code>.html</code> will be added.
Filename can also be a path to a file, e.g. <code>path/to/file.html</code>. In this case, the <code>output_dir</code> and <code>filename</code> will be joined together.
However, if the passed filepath is an absolute path and the <code>output_dir</code> parameter is also provided, the <code>output_dir</code> parameter will be ignored.
If a file already exists under a specified filepath, the function will overwrite it.</p>
</td></tr>
<tr><td><code id="generate_plate_report_+3A_output_dir">output_dir</code></td>
<td>
<p>(<code>character(1)</code>) The directory where the output CSV file should be saved.
Please note that any directory path provided will create all necessary directories (including parent directories) if they do not exist.
If it equals to <code>NULL</code> the current working directory will be used. Default is 'reports'.</p>
</td></tr>
<tr><td><code id="generate_plate_report_+3A_counts_lower_threshold">counts_lower_threshold</code></td>
<td>
<p>(<code>numeric(1)</code>) The lower threshold for the counts plots (works for each analyte). Default is 50.</p>
</td></tr>
<tr><td><code id="generate_plate_report_+3A_counts_higher_threshold">counts_higher_threshold</code></td>
<td>
<p>(<code>numeric(1)</code>) The higher threshold for the counts plots (works for each analyte). Default is 70.</p>
</td></tr>
<tr><td><code id="generate_plate_report_+3A_additional_notes">additional_notes</code></td>
<td>
<p>(<code>character(1)</code>) Additional notes to be included in the report. Contents of this fields are left to the user's discretion. If not provided, the field will not be included in the report.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A report.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plate_file &lt;- system.file("extdata", "CovidOISExPONTENT_CO_reduced.csv", package = "PvSTATEM")
# a plate file with reduced number of analytes to speed up the computation
layout_file &lt;- system.file("extdata", "CovidOISExPONTENT_CO_layout.xlsx", package = "PvSTATEM")
note &lt;- "This is a test report.\n**Author**: Jane Doe \n**Tester**: John Doe"

plate &lt;- read_luminex_data(plate_file, layout_file, verbose = FALSE)
example_dir &lt;- tempdir(check = TRUE) # a temporary directory
generate_plate_report(plate,
  output_dir = example_dir,
  counts_lower_threshold = 40,
  counts_higher_threshold = 50,
  additional_notes = note
)
</code></pre>

<hr>
<h2 id='get_join_value'>Determine the Join Value</h2><span id='topic+get_join_value'></span>

<h3>Description</h3>

<p>Returns a non-<code>NA</code>/non-<code>NULL</code> value based on the inputs. If either value is <code>NA</code> or <code>NULL</code>, it returns the non-<code>NA</code>/non-<code>NULL</code> value. If both values are equal, it returns that value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_join_value(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_join_value_+3A_x">x</code></td>
<td>
<p>A value to be compared.</p>
</td></tr>
<tr><td><code id="get_join_value_+3A_y">y</code></td>
<td>
<p>A value to be compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A non-<code>NA</code>/non-<code>NULL</code> value or the common value if <code>x</code> equals <code>y</code>. Returns <code>NULL</code> if the values differ and neither is <code>NA</code> or <code>NULL</code>.
</p>

<hr>
<h2 id='get_location_matrix'>Generate the matrix of plate locations</h2><span id='topic+get_location_matrix'></span>

<h3>Description</h3>

<p>The function generates a matrix of plate locations. The locations are represented in a nrow x ncol matrix.
Usually number of rows equals to 8 and number of columns to 12, and the total matrix size is 96.
</p>
<p>The fields are represented as <code>E3</code>, where the letter corresponds to the row and the number to the column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_location_matrix(nrow = 8, ncol = 12, as_vector = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_location_matrix_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows in the plate</p>
</td></tr>
<tr><td><code id="get_location_matrix_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns in the plate</p>
</td></tr>
<tr><td><code id="get_location_matrix_+3A_as_vector">as_vector</code></td>
<td>
<p>logical value indicating whether to return the locations as a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with locations
</p>

<hr>
<h2 id='get_nmfi'>Calculate normalised MFI values for a plate</h2><span id='topic+get_nmfi'></span>

<h3>Description</h3>

<p>The function calculates the normalised MFI (nMFI) values for each of the analytes in the plate.
</p>
<p>The nMFI values are calculated as the ratio of the test samples' MFI values to the standard curve samples with the target dilution.
</p>
<p><strong>When nMFI could be used?</strong>
In general, it is preferred to use Relative Antibody Unit (RAU) values for any analysis.
However, it is sometimes impossible to fit a model to the standard curve samples.
This may happen if the MFI values of test samples are much higher than the MFI of standard curve samples.
Then, the prediction would require significant data extrapolation, which could lead to unreliable results.
</p>
<p>In such cases, the nMFI values could be used as a proxy for RAU values if we want, for instance, to account for plate-to-plate variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nmfi(
  plate,
  reference_dilution = 1/400,
  data_type = "Median",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_nmfi_+3A_plate">plate</code></td>
<td>
<p>(<code>Plate()</code>) a plate object for which to calculate the nMFI values</p>
</td></tr>
<tr><td><code id="get_nmfi_+3A_reference_dilution">reference_dilution</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;numeric(1) or character(1)&#8288;</code>) the dilution value of the standard curve sample
to use as a reference for normalisation. The default is <code>1/400</code>.
It should refer to a dilution of a standard curve sample in the given plate object.
This parameter could be either a numeric value or a string.
In case it is a character string, it should have format <code style="white-space: pre;">&#8288;1/d+&#8288;</code>, where <code style="white-space: pre;">&#8288;d+&#8288;</code> is any positive integer.</p>
</td></tr>
<tr><td><code id="get_nmfi_+3A_data_type">data_type</code></td>
<td>
<p>(<code>character(1)</code>) type of data for the computation. Median is the default</p>
</td></tr>
<tr><td><code id="get_nmfi_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical(1)</code>) print additional information. The default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nmfi (<code>data.frame</code>) a data frame with normalised MFI values for each analyte in the plate and all test samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# read the plate
plate_file &lt;- system.file("extdata", "CovidOISExPONTENT.csv", package = "PvSTATEM")
layout_file &lt;- system.file("extdata", "CovidOISExPONTENT_layout.csv", package = "PvSTATEM")

plate &lt;- read_luminex_data(plate_file, layout_file)

# artificially bump up the MFI values of the test samples (the Median data type is default one)
plate$data[["Median"]][plate$sample_types == "TEST", ] &lt;-
  plate$data[["Median"]][plate$sample_types == "TEST", ] * 10

# calculate the nMFI values
nmfi &lt;- get_nmfi(plate, reference_dilution = 1 / 400)

# we don't do any extrapolation and the values should be comparable across plates
head(nmfi)
# different params
nmfi &lt;- get_nmfi(plate, reference_dilution = "1/50")

</code></pre>

<hr>
<h2 id='get_output_dir'>Get output directory for a given input file</h2><span id='topic+get_output_dir'></span>

<h3>Description</h3>

<p>Get output directory for a given input file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_output_dir(
  input_file,
  input_dir,
  output_dir = NULL,
  flatten_output_dir = FALSE
)
</code></pre>

<hr>
<h2 id='handle_datetime'>Handle differences in datetimes</h2><span id='topic+handle_datetime'></span>

<h3>Description</h3>

<p>Handle differences in the datetime format between xPONENT and INTELLIFLEX
and output POSIXct datetime object containing the correct datetime with the default timezone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_datetime(datetime_str, file_format = "xPONENT")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_datetime_+3A_datetime_str">datetime_str</code></td>
<td>
<p>The datetime string to parse</p>
</td></tr>
<tr><td><code id="handle_datetime_+3A_file_format">file_format</code></td>
<td>
<p>The format of the file. Select from: xPONENT, INTELLIFLEX</p>
</td></tr>
</table>


<h3>Value</h3>

<p>POSIXct datetime object
</p>

<hr>
<h2 id='handle_high_dose_hook'>Detect and handle the high dose hook effect</h2><span id='topic+handle_high_dose_hook'></span>

<h3>Description</h3>

<p>Typically, the MFI values associated with standard curve
samples should decrease as we dilute the samples. However,
sometimes in high dilutions, the MFI presents a non monotonic behavior.
In that case, MFI values associated with dilutions above (or equal to)
<code>high_dose_threshold</code> should be removed from the analysis.
</p>
<p>For more information about this effect please refer to:
Namburi, R. P. et. al. (2014) High-dose hook effect.
</p>
<p>For the <code>nplr</code> model the recommended number of standard curve samples
is at least 4. If the high dose hook effect is detected but the number
of samples below the <code>high_dose_threshold</code> is lower than 4,
additional warning is printed and the samples are not removed.
</p>
<p>The function returns a logical vector that can be used to subset the MFI values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_high_dose_hook(mfi, dilutions, high_dose_threshold = 1/200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_high_dose_hook_+3A_mfi">mfi</code></td>
<td>
<p>(<code>numeric()</code>)</p>
</td></tr>
<tr><td><code id="handle_high_dose_hook_+3A_dilutions">dilutions</code></td>
<td>
<p>(<code>numeric()</code>)</p>
</td></tr>
<tr><td><code id="handle_high_dose_hook_+3A_high_dose_threshold">high_dose_threshold</code></td>
<td>
<p>(<code>numeric(1)</code>) MFI values associated
with dilutions above this threshold should be checked for the high dose hook effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sample selector (<code>logical()</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate_filepath &lt;- system.file(
  "extdata", "CovidOISExPONTENT.csv",
  package = "PvSTATEM", mustWork = TRUE
) # get the filepath of the csv dataset
layout_filepath &lt;- system.file(
  "extdata", "CovidOISExPONTENT_layout.xlsx",
  package = "PvSTATEM", mustWork = TRUE
)
plate &lt;- read_luminex_data(plate_filepath, layout_filepath) # read the data

# here we plot the data with observed high dose hook effect
plot_standard_curve_analyte(plate, "RBD_omicron")

# here we create the model with the high dose hook effect handled
model &lt;- create_standard_curve_model_analyte(plate, "RBD_omicron")

</code></pre>

<hr>
<h2 id='is_mba_data_file'>Identify if a file is a MBA data file</h2><span id='topic+is_mba_data_file'></span>

<h3>Description</h3>

<p>Identify if a file is a MBA data file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mba_data_file(filepath, check_format = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_mba_data_file_+3A_filepath">filepath</code></td>
<td>
<p>(<code>character(1)</code>) The path to the file.</p>
</td></tr>
<tr><td><code id="is_mba_data_file_+3A_check_format">check_format</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, the function will check if the file name contains a supported format. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the file is a MBA data file, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is_mba_format'>Check if a mba format is supported</h2><span id='topic+is_mba_format'></span>

<h3>Description</h3>

<p>Check if a given format is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_mba_format(format, allow_nullable = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_mba_format_+3A_format">format</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;character(1&#8288;</code>) Format string</p>
</td></tr>
<tr><td><code id="is_mba_format_+3A_allow_nullable">allow_nullable</code></td>
<td>
<p>(<code>logical(1)</code>) Set to <code>TRUE</code> if a format can be NULL
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>logical(1)</code>) <code>TRUE</code> if the format is in the supported list, else <code>FALSE</code>
</p>

<hr>
<h2 id='is_outlier'>Check if a value is an outlier</h2><span id='topic+is_outlier'></span>

<h3>Description</h3>

<p>Check if a value is an outlier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_outlier(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_outlier_+3A_x">x</code></td>
<td>
<p>Vector of numeric values from which the outliers are to be detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating whether each value is an outlier.
</p>

<hr>
<h2 id='is_valid_data_type'>Check validity of given data type</h2><span id='topic+is_valid_data_type'></span>

<h3>Description</h3>

<p>Check if the data type is valid. The data type is valid if it is one of the
elements of the <code>VALID_DATA_TYPES</code> vector. The valid data types are:
<br /> <code>c(Median, Net MFI, Count, Avg Net MFI, Mean, Peak)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_data_type(data_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_valid_data_type_+3A_data_type">data_type</code></td>
<td>
<p>A string representing the data type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the data type is valid, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is_valid_sample_type'>Check validity of given sample type</h2><span id='topic+is_valid_sample_type'></span>

<h3>Description</h3>

<p>Check if the sample type is valid. The sample type is valid if it is one of the
elements of the <code>VALID_SAMPLE_TYPES</code> vector. The valid sample types are:
</p>
<p><code>c(ALL, BLANK, TEST, NEGATIVE CONTROL, STANDARD CURVE, POSITIVE CONTROL)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_sample_type(sample_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_valid_sample_type_+3A_sample_type">sample_type</code></td>
<td>
<p>A string representing the sample type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the sample type is valid, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.decreasing'>Check if the vector is monotically decreasing</h2><span id='topic+is.decreasing'></span>

<h3>Description</h3>

<p>Check if the vector is monotically decreasing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.decreasing(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.decreasing_+3A_x">x</code></td>
<td>
<p>(<code>numeric()</code>) Vector of numeric values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>logical(1)</code>) <code>TRUE</code> if the vector is monotonically decreasing, <code>FALSE</code> otherwise
</p>

<hr>
<h2 id='is.scalar'>Check if a value is a scalar</h2><span id='topic+is.scalar'></span>

<h3>Description</h3>

<p>This will return FALSE for NULL and vectors of length bigger than 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.scalar(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.scalar_+3A_x">x</code></td>
<td>
<p>Object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object is a scalar, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='is.str.number'>Check if a string is a number</h2><span id='topic+is.str.number'></span>

<h3>Description</h3>

<p>Check if a string is a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.str.number(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.str.number_+3A_x">x</code></td>
<td>
<p>A string to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the string is a number, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='merge_dataframes'>Merge dataframes</h2><span id='topic+merge_dataframes'></span>

<h3>Description</h3>

<p>Merges a list of dataframes by handling column collisions
through specified strategies: &quot;intersection&quot; or &quot;union&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_dataframes(
  dataframes,
  column_collision_strategy = "intersection",
  fill_value = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_dataframes_+3A_dataframes">dataframes</code></td>
<td>
<p>A list of dataframes to merge.</p>
</td></tr>
<tr><td><code id="merge_dataframes_+3A_column_collision_strategy">column_collision_strategy</code></td>
<td>
<p>A string specifying how to handle column collisions.
&quot;intersection&quot; keeps only columns present in all dataframes,
&quot;union&quot; includes all columns from all dataframes, filling missing values.</p>
</td></tr>
<tr><td><code id="merge_dataframes_+3A_fill_value">fill_value</code></td>
<td>
<p>Value to fill in missing columns if <code>column_collision_strategy</code> is &quot;union&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Merged dataframe
</p>

<hr>
<h2 id='Model'>Logistic regression model for the standard curve</h2><span id='topic+Model'></span>

<h3>Description</h3>

<p>The Model class is a wrapper around the <code>nplr</code> model. It allows to predict the RAU (Relative Antibody Unit) values
directly from the MFI values of a given sample.
</p>
<p>The <code>nplr</code> model is fitted using the formula:
</p>
<p style="text-align: center;"><code class="reqn">y = B + \frac{T - B}{(1 + 10^{b \cdot (x_{mid} - x)})^s},</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">y</code> is the predicted value, MFI in our case,
</p>
</li>
<li> <p><code class="reqn">x</code> is the independent variable, dilution in our case,
</p>
</li>
<li> <p><code class="reqn">B</code> is the bottom plateau - the right horizontal asymptote,
</p>
</li>
<li> <p><code class="reqn">T</code> is the top plateau - the left horizontal asymptote,
</p>
</li>
<li> <p><code class="reqn">b</code> is the slope of the curve at the inflection point,
</p>
</li>
<li> <p><code class="reqn">x_{mid}</code> is the x-coordinate at the inflection point,
</p>
</li>
<li> <p><code class="reqn">s</code> is the asymmetric coefficient.
</p>
</li></ul>

<p>This equation is referred to as the Richards' equation. More information about the model can be found in the <code>nplr</code> package documentation.
</p>
<p>After the model is fitted to the data, the RAU values can be predicted using the <code>predict</code> method.
The RAU value is simply a predicted dilution value (using the standard curve) for a given MFI
multiplied by 1,000 000 to have a more readable value.
For more information about the differences between dilution, RAU and MFI values, please see the
&quot;Normalisation&quot; section in the &quot;Basic PvSTATEM functionalities&quot; vignette.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>analyte</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the analyte for which the model was fitted</p>
</dd>
<dt><code>dilutions</code></dt><dd><p>(<code>numeric()</code>)<br />
Dilutions used to fit the model</p>
</dd>
<dt><code>mfi</code></dt><dd><p>(<code>numeric()</code>)<br />
MFI values used to fit the model</p>
</dd>
<dt><code>mfi_min</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Minimum MFI used for scaling MFI values to the range [0, 1]</p>
</dd>
<dt><code>mfi_max</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Maximum MFI used for scaling MFI values to the range [0, 1]</p>
</dd>
<dt><code>model</code></dt><dd><p>(<code>nplr</code>)<br />
Instance of the <code>nplr</code> model fitted to the data</p>
</dd>
<dt><code>log_dilution</code></dt><dd><p>(<code>logical()</code>)<br />
Indicator should the dilutions be transformed using the <code>log10</code> function</p>
</dd>
<dt><code>log_mfi</code></dt><dd><p>(<code>logical()</code>)<br />
Indicator should the MFI values be transformed using the <code>log10</code> function</p>
</dd>
<dt><code>scale_mfi</code></dt><dd><p>(<code>logical()</code>)<br />
Indicator should the MFI values be scaled to the range [0, 1]</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>top_asymptote</code></dt><dd><p>(<code>numeric(1)</code>)<br />
The top asymptote of the logistic curve</p>
</dd>
<dt><code>bottom_asymptote</code></dt><dd><p>(<code>numeric(1)</code>)<br />
The bottom asymptote of the logistic curve</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Model-new"><code>Model$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-predict"><code>Model$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-get_plot_data"><code>Model$get_plot_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-print"><code>Model$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-clone"><code>Model$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Model-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new instance of Model <a href="R6.html#topic+R6Class">R6</a> class
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$new(
  analyte,
  dilutions,
  mfi,
  npars = 5,
  verbose = TRUE,
  log_dilution = TRUE,
  log_mfi = TRUE,
  scale_mfi = TRUE,
  mfi_min = NULL,
  mfi_max = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>analyte</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the analyte for which the model was fitted.</p>
</dd>
<dt><code>dilutions</code></dt><dd><p>(<code>numeric()</code>)<br />
Dilutions used to fit the model</p>
</dd>
<dt><code>mfi</code></dt><dd><p>MFI (<code>numeric()</code>)<br />
values used to fit the model</p>
</dd>
<dt><code>npars</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Number of parameters to use in the model</p>
</dd>
<dt><code>verbose</code></dt><dd><p>(<code>logical()</code>)<br />
If <code>TRUE</code> prints messages, <code>TRUE</code> by default</p>
</dd>
<dt><code>log_dilution</code></dt><dd><p>(<code>logical()</code>)<br />
If <code>TRUE</code> the dilutions are transformed using the <code>log10</code> function, <code>TRUE</code> by default</p>
</dd>
<dt><code>log_mfi</code></dt><dd><p>(<code>logical()</code>)<br />
If <code>TRUE</code> the MFI values are transformed using the <code>log10</code> function, <code>TRUE</code> by default</p>
</dd>
<dt><code>scale_mfi</code></dt><dd><p>(<code>logical()</code>)<br />
If <code>TRUE</code> the MFI values are scaled to the range [0, 1], <code>TRUE</code> by default</p>
</dd>
<dt><code>mfi_min</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Enables to set the minimum MFI value used for scaling MFI values to the range [0, 1].
Use values before any transformations (e.g., before the <code>log10</code> transformation)</p>
</dd>
<dt><code>mfi_max</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Enables to set the maximum MFI value used for scaling MFI values to the range [0, 1].
Use values before any transformations (e.g., before the <code>log10</code> transformation)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict RAU values from the MFI values
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$predict(mfi, over_max_extrapolation = 0, eps = 1e-06)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mfi</code></dt><dd><p>(<code>numeric()</code>)<br />
MFI values for which we want to predict the RAU values</p>
</dd>
<dt><code>over_max_extrapolation</code></dt><dd><p>(<code>numeric(1)</code>)<br />
How much we can extrapolate the values above the maximum RAU value
seen in standard curve samples <code class="reqn">\text{RAU}_{max}</code>. Defaults to 0.
If the value of the predicted RAU is above <code class="reqn">RAU_{max} + \text{over\_max\_extrapolation}</code>,
the value is censored to the value of that sum.</p>
</dd>
<dt><code>eps</code></dt><dd><p>(<code>numeric(1)</code>)<br />
A small value used to avoid numerical issues close to the asymptotes</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(<code>data.frame()</code>)<br />
Dataframe with the predicted RAU values for given MFI values
The columns are named as follows:
</p>

<ul>
<li> <p><code>RAU</code> - the Relative Antibody Units (RAU) value
</p>
</li>
<li> <p><code>MFI</code> - the predicted MFI value
</p>
</li></ul>



<hr>
<a id="method-Model-get_plot_data"></a>



<h4>Method <code>get_plot_data()</code></h4>

<p>Data that can be used to plot the standard curve.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$get_plot_data()</pre></div>



<h5>Returns</h5>

<p>(<code>data.frame()</code>)<br />
Prediction dataframe for scaled MFI (or logMFI) values in the range [0, 1].
Columns are named as in the <code>predict</code> method
</p>


<hr>
<a id="method-Model-print"></a>



<h4>Method <code>print()</code></h4>

<p>Function prints the basic information about the model
such as the number of parameters or samples used
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$print()</pre></div>


<hr>
<a id="method-Model-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>plate_file &lt;- system.file("extdata", "CovidOISExPONTENT.csv", package = "PvSTATEM")
layout_file &lt;- system.file("extdata", "CovidOISExPONTENT_layout.csv", package = "PvSTATEM")
plate &lt;- read_luminex_data(plate_file, layout_filepath = layout_file)
model &lt;- create_standard_curve_model_analyte(plate, "S2", log_mfi = TRUE)
print(model)

</code></pre>

<hr>
<h2 id='Plate'>Plate object</h2><span id='topic+Plate'></span>

<h3>Description</h3>

<p>A class to represent the luminex plate. It contains information about
the samples and analytes that were examined on the plate as well as
some additional metadata and batch info
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>plate_name</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the plate. Set to the name of the file from which the plate was read.</p>
</dd>
<dt><code>analyte_names</code></dt><dd><p>(<code>character()</code>)<br />
Names of the analytes that were examined on the plate.</p>
</dd>
<dt><code>sample_names</code></dt><dd><p>(<code>character()</code>)<br />
Names of the samples that were examined on the plate. The order of the
samples in this vector is identical with order in the CSV source file.</p>
</dd>
<dt><code>batch_name</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the batch to which the plate belongs.</p>
</dd>
<dt><code>plate_datetime</code></dt><dd><p>(<code>POSIXct()</code>)<br />
A date and time when the plate was created by the machine</p>
</dd>
<dt><code>sample_locations</code></dt><dd><p>(<code>character()</code>)<br />
Locations of the samples on the plate. This vector is in the same order
as the <code>sample_names</code> vector.</p>
</dd>
<dt><code>sample_types</code></dt><dd><p>(<code>character()</code>)<br />
Types of the samples that were examined on the plate.
The possible values are <br /> <code>c(ALL, BLANK, TEST, NEGATIVE CONTROL, STANDARD CURVE, POSITIVE CONTROL)</code>.
This vector is in the same order as the <code>sample_names</code> vector.</p>
</dd>
<dt><code>dilutions</code></dt><dd><p>(<code>character()</code>)<br />
A list containing names of the samples as keys and string representing dilutions as values.
The dilutions are represented as strings. This vector is in the same order as the <code>sample_names</code> vector.</p>
</dd>
<dt><code>dilution_values</code></dt><dd><p>(<code>numeric()</code>)<br />
A list containing names of the samples as keys and numeric values representing dilutions as values.
It is in the same order as the <code>sample_names</code> vector.</p>
</dd>
<dt><code>default_data_type</code></dt><dd><p>(<code>character(1)</code>)<br />
The default data type that will be returned by the <code>get_data</code> method.
By default is set to <code>Median</code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>(<code>list()</code>)<br />
A list containing dataframes with the data for each sample and analyte.
The possible data types - the keys of the list are:
<br /> <code>c(Median, Net MFI, Count, Avg Net MFI, Mean, Peak)</code>.
</p>
<p>In each dataframe, the rows represent samples and the columns represent analytes.</p>
</dd>
<dt><code>batch_info</code></dt><dd><p>(<code>list()</code>)<br />
A list containing additional, technical information about the batch.</p>
</dd>
<dt><code>layout</code></dt><dd><p>(<code>character()</code>)<br />
A list containing information about the layout of the plate.
The layout is read from the separate file and usually provides additional
information about the dilutions, sample names, and the sample layout
on the actual plate.</p>
</dd>
<dt><code>blank_adjusted</code></dt><dd><p>(<code>logical</code>)<br />
A flag indicating whether the blank values have been adjusted.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Plate-new"><code>Plate$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Plate-print"><code>Plate$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Plate-summary"><code>Plate$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-Plate-get_data"><code>Plate$get_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Plate-get_dilution"><code>Plate$get_dilution()</code></a>
</p>
</li>
<li> <p><a href="#method-Plate-get_dilution_values"><code>Plate$get_dilution_values()</code></a>
</p>
</li>
<li> <p><a href="#method-Plate-blank_adjustment"><code>Plate$blank_adjustment()</code></a>
</p>
</li>
<li> <p><a href="#method-Plate-clone"><code>Plate$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Plate-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method to initialize the Plate object
</p>


<h5>Usage</h5>

<div class="r"><pre>Plate$new(
  plate_name,
  sample_names,
  analyte_names,
  batch_name = "",
  plate_datetime = NULL,
  sample_locations = NULL,
  sample_types = NULL,
  dilutions = NULL,
  dilution_values = NULL,
  default_data_type = NULL,
  data = NULL,
  batch_info = NULL,
  layout = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plate_name</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the plate.
By default is set to an empty string,
during the reading process it is set to the name
of the file from which the plate was read.</p>
</dd>
<dt><code>sample_names</code></dt><dd><p>(<code>character()</code>)<br />
Names of the samples that were examined on the plate.</p>
</dd>
<dt><code>analyte_names</code></dt><dd><p>(<code>character()</code>)<br />
Names of the analytes that were examined on the plate.</p>
</dd>
<dt><code>batch_name</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the batch to which the plate belongs.
By default is set to an empty string, during the reading process it is set to
the <code>batch</code> field of the plate</p>
</dd>
<dt><code>plate_datetime</code></dt><dd><p>(<code>POSIXct()</code>)<br />
Datetime object representing the date and time when the plate was created by the machine.</p>
</dd>
<dt><code>sample_locations</code></dt><dd><p>(<code>character()</code>)<br />
Locations of the samples on the plate.</p>
</dd>
<dt><code>sample_types</code></dt><dd><p>(<code>character()</code>)<br />
Types of the samples that were examined on the plate.
The possible values are <br /> <code>c(ALL, BLANK, TEST, NEGATIVE CONTROL, STANDARD CURVE, POSITIVE CONTROL)</code>.</p>
</dd>
<dt><code>dilutions</code></dt><dd><p>(<code>character()</code>)<br />
A list containing names of the samples as keys and string representing dilutions as values.
The dilutions are represented as strings.</p>
</dd>
<dt><code>dilution_values</code></dt><dd><p>(<code>numeric()</code>)<br />
A list containing names of the samples as keys and numeric values representing dilutions as values.</p>
</dd>
<dt><code>default_data_type</code></dt><dd><p>(<code>character(1)</code>)<br />
The default data type that will be returned by the <code>get_data</code> method.
By default is set to <code>Median</code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>(<code>list()</code>)<br />
A list containing dataframes with the data for each sample and analyte.
The possible data types - the keys of the list are <br /> <code>c(Median, Net MFI, Count, Avg Net MFI, Mean, Peak)</code>.
In each dataframe, the rows represent samples and the columns represent analytes.</p>
</dd>
<dt><code>batch_info</code></dt><dd><p>(<code>list()</code>)<br />
A list containing additional, technical information about the batch.</p>
</dd>
<dt><code>layout</code></dt><dd><p>(<code>character()</code>)<br />
A list containing information about the layout of the plate.
The layout is read from the separate file and usually provides additional
information about the dilutions, sample names, and the sample layout
on the actual plate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plate-print"></a>



<h4>Method <code>print()</code></h4>

<p>Function prints the basic information about the plate
such as the number of samples and analytes
</p>


<h5>Usage</h5>

<div class="r"><pre>Plate$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional parameters to be passed to the print function
Print the summary of the plate</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plate-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Function outputs basic information about the plate, such as
examination date, batch name, and sample types.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plate$summary(..., include_names = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional parameters to be passed to the print function
Get data for a specific analyte and sample type</p>
</dd>
<dt><code>include_names</code></dt><dd><p>If <code>include_names</code> parameter is <code>TRUE</code>, a
part from count of control samples, provides also their names.
By default <code>FALSE</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plate-get_data"></a>



<h4>Method <code>get_data()</code></h4>

<p>Function returns data for a specific analyte and sample.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plate$get_data(
  analyte,
  sample_type = "ALL",
  data_type = self$default_data_type
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>analyte</code></dt><dd><p>An analyte name or its id of which data we want to extract.
If set to 'ALL' returns data for all analytes.</p>
</dd>
<dt><code>sample_type</code></dt><dd><p>is a type of the sample we want to extract data from.
The possible values are <br /> <code>c(ALL, BLANK, TEST, NEGATIVE CONTROL, STANDARD CURVE, POSITIVE CONTROL)</code>. Default value is <code>ALL</code>.</p>
</dd>
<dt><code>data_type</code></dt><dd><p>The parameter specifying which data type should be returned.
This parameter has to take one of values: <br /> <code>c(Median, Net MFI, Count, Avg Net MFI, Mean, Peak)</code>.
What's more, the <code>data_type</code> has to be present in the plate's data
Default value is plate's <code>default_data_type</code>, which is usually <code>Median</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Dataframe containing information about a given sample type and analyte
Get the string representation of dilutions
</p>


<hr>
<a id="method-Plate-get_dilution"></a>



<h4>Method <code>get_dilution()</code></h4>

<p>Function returns the dilution represented as strings for a specific sample type.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plate$get_dilution(sample_type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sample_type</code></dt><dd><p>type of the samples that we want to obtain the dilution for.
The possible values are <br /> <code>c(ALL, BLANK, TEST, NEGATIVE CONTROL, STANDARD CURVE, POSITIVE CONTROL)</code> Default value is <code>ALL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list containing names of the samples as keys and string representing dilutions as values.
Get the numeric representation of dilutions
</p>


<hr>
<a id="method-Plate-get_dilution_values"></a>



<h4>Method <code>get_dilution_values()</code></h4>

<p>Function returns the dilution values for a specific sample type.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plate$get_dilution_values(sample_type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sample_type</code></dt><dd><p>type of the samples that we want to obtain the dilution values for.
The possible values are <br /> <code>c(ALL, BLANK, TEST, NEGATIVE CONTROL, STANDARD CURVE, POSITIVE CONTROL)</code> Default value is <code>ALL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list containing names of the samples as keys and numeric values representing dilutions as values.
</p>
<p>Adjust the MFI values by subtracting the background
</p>


<hr>
<a id="method-Plate-blank_adjustment"></a>



<h4>Method <code>blank_adjustment()</code></h4>

<p>Function adjusts the values of samples (all samples excluding the blanks) by clamping the
values to the aggregated value of the <code>BLANK</code> samples for each analyte separately.
</p>
<p>The purpose of this operation is to unify the data by clamping values below the background noise.
how this method works was inspired by the paper https://doi.org/10.1038/s41598-020-57876-0 which covers the quality control in the MBA.
</p>
<p>In short, this operation firstly calculates the aggregate of MFI in the <code>BLANK</code> samples
(available methods are: <code>min</code>, <code>max</code>, <code>mean</code>, <code>median</code>)
and then replaces all values below this threshold with the threshold value.
</p>
<p>Method does not modifies the data of type <code>Count</code>.
</p>
<p>This operation is recommended to be performed before any further analysis, but is optional.
Skipping it before further analysis is allowed, but will result in a warning.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plate$blank_adjustment(threshold = "max", in_place = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>threshold</code></dt><dd><p>The method used to calculate the background value for each analyte.
Every value below this threshold will be clamped to the threshold value.
By default <code>max</code>. Available methods are: <code>min</code>, <code>max</code>, <code>mean</code>, <code>median</code>.</p>
</dd>
<dt><code>in_place</code></dt><dd><p>Whether the method should produce new plate with adjusted
values or not, By default <code>TRUE</code> - operates on the current plate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='PlateBuilder'>PlateBuilder</h2><span id='topic+PlateBuilder'></span>

<h3>Description</h3>

<p>This class helps creating the Plate object.
It is used to store the data and validate the final fields.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>layout_as_vector</code></dt><dd><p>Print the layout associated with the plate as a flattened vector of values.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PlateBuilder-new"><code>PlateBuilder$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_sample_locations"><code>PlateBuilder$set_sample_locations()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_dilutions"><code>PlateBuilder$set_dilutions()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_sample_types"><code>PlateBuilder$set_sample_types()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_sample_names"><code>PlateBuilder$set_sample_names()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_plate_datetime"><code>PlateBuilder$set_plate_datetime()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_data"><code>PlateBuilder$set_data()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_default_data_type"><code>PlateBuilder$set_default_data_type()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_batch_info"><code>PlateBuilder$set_batch_info()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_plate_name"><code>PlateBuilder$set_plate_name()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-set_layout"><code>PlateBuilder$set_layout()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-build"><code>PlateBuilder$build()</code></a>
</p>
</li>
<li> <p><a href="#method-PlateBuilder-clone"><code>PlateBuilder$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PlateBuilder-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the PlateBuilder object
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$new(sample_names, analyte_names, batch_name = "", verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sample_names</code></dt><dd>
<ul>
<li><p> vector of sample names measured during
an examination in the same order as in the data
</p>
</li></ul>
</dd>
<dt><code>analyte_names</code></dt><dd>
<ul>
<li><p> vector of analytes names measured during
an examination in the same order as in the data
</p>
</li></ul>
</dd>
<dt><code>batch_name</code></dt><dd>
<ul>
<li><p> name of the batch during which the plate was examined
obtained from the plate info. An optional parameter, by default set to
<code>""</code> - an empty string.
</p>
</li></ul>
</dd>
<dt><code>verbose</code></dt><dd>
<ul>
<li><p> logical value indicating whether to print additional
information. This parameter is stored as a private attribute of the object
and reused in other methods
</p>
</li></ul>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_sample_locations"></a>



<h4>Method <code>set_sample_locations()</code></h4>

<p>Set the sample types used during the examination
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_sample_locations(sample_locations)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sample_locations</code></dt><dd><p>vector of sample locations pretty name ie. A1, B2</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_dilutions"></a>



<h4>Method <code>set_dilutions()</code></h4>

<p>Extract and set the dilutions from layout, sample names or use a provided vector of values.
The provided vector should be the same length as the number of samples
and should contain dilution factors saved as strings
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_dilutions(use_layout_dilutions = TRUE, values = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_layout_dilutions</code></dt><dd><p>logical value indicating whether to use names
extracted from layout files to extract dilutions. If set to <code>FALSE</code> the
function uses the sample names as a source for dilution</p>
</dd>
<dt><code>values</code></dt><dd><p>a vector of dilutions to overwrite the extraction process
</p>
<p>Set and extract sample types from the sample names.
Optionally use the layout file to extract the sample types</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_sample_types"></a>



<h4>Method <code>set_sample_types()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_sample_types(use_layout_types = TRUE, values = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_layout_types</code></dt><dd><p>logical value indicating whether to use names extracted from layout files
to extract sample types</p>
</dd>
<dt><code>values</code></dt><dd><p>a vector of sample types to overwrite the extraction process</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_sample_names"></a>



<h4>Method <code>set_sample_names()</code></h4>

<p>Set the sample names used during the examination. If the layout is provided,
extract the sample names from the layout file. Otherwise, uses the original sample names from the Luminex file
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_sample_names(use_layout_sample_names = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_layout_sample_names</code></dt><dd><p>logical value indicating whether
to use names extracted from layout files. If set to false, this function only checks if the sample names are provided in the plate</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_plate_datetime"></a>



<h4>Method <code>set_plate_datetime()</code></h4>

<p>Set the plate datetime for the plate
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_plate_datetime(plate_datetime)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plate_datetime</code></dt><dd><p>a POSIXct datetime object
representing the date and time of the examination</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_data"></a>



<h4>Method <code>set_data()</code></h4>

<p>Set the data used during the examination
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_data(data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>a named list of data frames containing information about
the samples and analytes. The list is named by the type of the data
e.g. <code>Median</code>, <code style="white-space: pre;">&#8288;Net MFI&#8288;</code>, etc.
The data frames contain information about the samples and analytes
The rows are different measures, whereas the columns represent
different analytes
Example of how <code>data$Median</code> looks like:</p>

<table>
<tr>
 <td style="text-align: left;">
   Sample </td><td style="text-align: left;"> Analyte1 </td><td style="text-align: left;"> Analyte2 </td><td style="text-align: left;"> Analyte3 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Sample1 </td><td style="text-align: left;"> 1.2 </td><td style="text-align: left;"> 2.3 </td><td style="text-align: left;"> 3.4 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Sample2 </td><td style="text-align: left;"> 4.5 </td><td style="text-align: left;"> 5.6 </td><td style="text-align: left;"> 6.7 </td>
</tr>
<tr>
 <td style="text-align: left;">
   ... </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> ... </td><td style="text-align: left;"> ... </td>
</tr>
<tr>
 <td style="text-align: left;">
   Sample96 </td><td style="text-align: left;"> 7.8 </td><td style="text-align: left;"> 8.9 </td><td style="text-align: left;"> 9.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_default_data_type"></a>



<h4>Method <code>set_default_data_type()</code></h4>

<p>Set the data type used for calculations
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_default_data_type(data_type = "Median")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data_type</code></dt><dd><p>a character value representing the type of data
that is currently used for calculations. By default, it is set to Median</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_batch_info"></a>



<h4>Method <code>set_batch_info()</code></h4>

<p>Set the batch info for the plate
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_batch_info(batch_info)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>batch_info</code></dt><dd><p>a raw list containing metadata about
the plate read from the Luminex file</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_plate_name"></a>



<h4>Method <code>set_plate_name()</code></h4>

<p>Set the plate name for the plate.
The plate name is extracted from the filepath
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_plate_name(file_path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file_path</code></dt><dd><p>a character value representing the path to the file</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-set_layout"></a>



<h4>Method <code>set_layout()</code></h4>

<p>Set the layout matrix for the plate. This function performs basic validation
</p>

<ul>
<li><p> verifies if the plate is a matrix of shape 8x12 with 96 wells
</p>
</li></ul>



<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$set_layout(layout_matrix)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layout_matrix</code></dt><dd><p>a matrix containing information about the sample names. dilutions, etc.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlateBuilder-build"></a>



<h4>Method <code>build()</code></h4>

<p>Create a Plate object from the PlateBuilder object
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$build(validate = TRUE)</pre></div>


<hr>
<a id="method-PlateBuilder-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlateBuilder$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='plot_counts'>Plot counts in a 96-well plate</h2><span id='topic+plot_counts'></span>

<h3>Description</h3>

<p>This function plots counts in a 96-well plate using a colour to represent the count ranges.
There is a possibility of plotting exact counts in each well. <br /> <br />
If the plot window is resized, it's best to re-run the function to adjust the scaling.
Sometimes, when a legend is plotted, the whole layout may be shifted. It's best to stretch the window, and everything will be adjusted automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_counts(
  plate,
  analyte_name,
  plot_counts = TRUE,
  plot_legend = FALSE,
  lower_threshold = 50,
  higher_threshold = 70
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_counts_+3A_plate">plate</code></td>
<td>
<p>The plate object with the counts data</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_analyte_name">analyte_name</code></td>
<td>
<p>The name of the analyte</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_plot_counts">plot_counts</code></td>
<td>
<p>Logical indicating if the counts should be plotted</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_plot_legend">plot_legend</code></td>
<td>
<p>Logical indicating if the legend should be plotted</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_lower_threshold">lower_threshold</code></td>
<td>
<p>The lower threshold for the counts, it separates green and yellow colours</p>
</td></tr>
<tr><td><code id="plot_counts_+3A_higher_threshold">higher_threshold</code></td>
<td>
<p>The higher threshold for the counts, it separates yellow and red colours</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate_filepath &lt;- system.file("extdata", "CovidOISExPONTENT_CO.csv",
  package = "PvSTATEM", mustWork = TRUE
)
layout_filepath &lt;- system.file("extdata", "CovidOISExPONTENT_CO_layout.xlsx",
  package = "PvSTATEM", mustWork = TRUE
)
plate &lt;- read_luminex_data(plate_filepath, layout_filepath)
plot_counts(
  plate = plate, analyte_name = "OC43_NP_NA",
  plot_counts = TRUE, plot_legend = FALSE
)

</code></pre>

<hr>
<h2 id='plot_layout'>Plot layout of a 96-well plate</h2><span id='topic+plot_layout'></span>

<h3>Description</h3>

<p>This function plots the layout of a 96-well plate using a colour to represent the sample types. <br /> <br />
If the plot window is resized, it's best to re-run the function to adjust the scaling.
Sometimes, the whole layout may be shifted when a legend is plotted. It's best to stretch the window, and everything will be adjusted automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_layout(plate, plot_legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_layout_+3A_plate">plate</code></td>
<td>
<p>The plate object with the layout information</p>
</td></tr>
<tr><td><code id="plot_layout_+3A_plot_legend">plot_legend</code></td>
<td>
<p>Logical indicating if the legend should be plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate_filepath &lt;- system.file("extdata", "CovidOISExPONTENT_CO.csv",
  package = "PvSTATEM", mustWork = TRUE
)
layout_filepath &lt;- system.file("extdata", "CovidOISExPONTENT_CO_layout.xlsx",
  package = "PvSTATEM", mustWork = TRUE
)
plate &lt;- read_luminex_data(plate_filepath, layout_filepath)
plot_layout(plate = plate, plot_legend = TRUE)

</code></pre>

<hr>
<h2 id='plot_levey_jennings'>Plot Levey-Jennings chart</h2><span id='topic+plot_levey_jennings'></span>

<h3>Description</h3>

<p>The function plots a Levey-Jennings chart for the given analyte
in the list of plates. The Levey-Jennings chart is a graphical
representation of the data that enables the detection of outliers
and trends. It is a quality control tool that is widely used
in the laboratories across the world.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_levey_jennings(
  list_of_plates,
  analyte_name,
  dilution = "1/400",
  sd_lines = c(1.96),
  data_type = "Median"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_levey_jennings_+3A_list_of_plates">list_of_plates</code></td>
<td>
<p>A list of plate objects for which to plot the
Levey-Jennings chart</p>
</td></tr>
<tr><td><code id="plot_levey_jennings_+3A_analyte_name">analyte_name</code></td>
<td>
<p>(<code>character(1)</code>) the analyte for which to plot the
Levey-Jennings chart</p>
</td></tr>
<tr><td><code id="plot_levey_jennings_+3A_dilution">dilution</code></td>
<td>
<p>(<code>character(1)</code>) the dilution for which to plot the
Levey-Jennings chart. The default is &quot;1/400&quot;</p>
</td></tr>
<tr><td><code id="plot_levey_jennings_+3A_sd_lines">sd_lines</code></td>
<td>
<p>(<code>numeric</code>) the vector of coefficients for the
standard deviation lines to plot, for example, c(1.96, 2.58)
will plot four horizontal lines: mean +/- 1.96<em>sd, mean +/- 2.58</em>sd
default is c(1.96) which will plot two lines mean +/- 1.96*sd</p>
</td></tr>
<tr><td><code id="plot_levey_jennings_+3A_data_type">data_type</code></td>
<td>
<p>(<code>character(1)</code>) the type of data used plot. The default is &quot;Median&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the Levey-Jennings chart
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating temporary directory for the example
output_dir &lt;- tempdir(check = TRUE)

dir_with_luminex_files &lt;- system.file("extdata", "multiplate_reallife_reduced",
  package = "PvSTATEM", mustWork = TRUE
)
list_of_plates &lt;- process_dir(dir_with_luminex_files,
  return_plates = TRUE, format = "xPONENT", output_dir = output_dir
)
list_of_plates &lt;- rep(list_of_plates, 10) # since we have only 3 plates i will repeat them 10 times

plot_levey_jennings(list_of_plates, "ME", dilution = "1/400", sd_lines = c(0.5, 1, 1.96, 2.58))

</code></pre>

<hr>
<h2 id='plot_mfi_for_analyte'>Plot MFI value distribution for a given analyte</h2><span id='topic+plot_mfi_for_analyte'></span>

<h3>Description</h3>

<p>Plot MFI value distribution for a given analyte
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mfi_for_analyte(
  plate,
  analyte_name,
  data_type = "Median",
  plot_type = "violin",
  scale_y = "log10",
  plot_outliers = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mfi_for_analyte_+3A_plate">plate</code></td>
<td>
<p>A plate object</p>
</td></tr>
<tr><td><code id="plot_mfi_for_analyte_+3A_analyte_name">analyte_name</code></td>
<td>
<p>The analyte to plot</p>
</td></tr>
<tr><td><code id="plot_mfi_for_analyte_+3A_data_type">data_type</code></td>
<td>
<p>The type of data to plot. Default is &quot;Median&quot;</p>
</td></tr>
<tr><td><code id="plot_mfi_for_analyte_+3A_plot_type">plot_type</code></td>
<td>
<p>The type of plot to generate. Default is &quot;violin&quot;.
Available options are &quot;boxplot&quot; and &quot;violin&quot;.</p>
</td></tr>
<tr><td><code id="plot_mfi_for_analyte_+3A_scale_y">scale_y</code></td>
<td>
<p>What kind of transformation of the scale to apply.
By default MFI is presented in a &quot;log10&quot; scale. Available options are
described in the documentation of <a href="ggplot2.html#topic+scale_y_continuous">scale_y_continuous</a>
under<code>transform</code> parameter.</p>
</td></tr>
<tr><td><code id="plot_mfi_for_analyte_+3A_plot_outliers">plot_outliers</code></td>
<td>
<p>When using &quot;boxplot&quot; type of a plot
one can set this parameter to TRUE and display the names of samples for
which MFI falls outside the 1.5 IQR interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot_plate'>Plot a 96-well plate with coloured wells</h2><span id='topic+plot_plate'></span>

<h3>Description</h3>

<p>It is a generic function to plot a 96-well plate with coloured wells
used by other functions in this package, mainly to plot layout and counts.
The function uses a background image of a 96-well plate and
plots the colours in the wells using ggplot2.
This function is not intended for the user to use directly.
Rather, it is used by other functions specified in this file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_plate(
  colours,
  plot_numbers = FALSE,
  numbers = NULL,
  plot_title = "Plate",
  plot_legend = FALSE,
  legend_mapping = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_plate_+3A_colours">colours</code></td>
<td>
<p>A vector with 96 colours will be used to colour the wells; the order is from left to right and top to bottom</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_plot_numbers">plot_numbers</code></td>
<td>
<p>Logical value indicating if the well numbers should be plotted, default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot_plate_+3A_numbers">numbers</code></td>
<td>
<p>An optional vector with 96 numbers plotted on the wells. Order is from left to right and top to bottom and must have the same length as colours.
It could be used, for instance, to plot the bead count of each well. Must be provided in case the <code>plot_numbers</code> parameter is set to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot_plate_+3A_plot_title">plot_title</code></td>
<td>
<p>The title of the plot (default is &quot;Plate&quot;)</p>
</td></tr>
<tr><td><code id="plot_plate_+3A_plot_legend">plot_legend</code></td>
<td>
<p>Logical value indicating if the legend should be plotted, default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot_plate_+3A_legend_mapping">legend_mapping</code></td>
<td>
<p>A named vector with the colour mapping used to create the legend</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='plot_standard_curve_analyte'>Standard curves</h2><span id='topic+plot_standard_curve_analyte'></span>

<h3>Description</h3>

<p>Plot standard curve samples of a plate of a given analyte.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_standard_curve_analyte(
  plate,
  analyte_name,
  data_type = "Median",
  decreasing_rau_order = TRUE,
  log_scale = c("all"),
  plot_line = TRUE,
  plot_blank_mean = TRUE,
  plot_rau_bounds = TRUE,
  plot_legend = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_standard_curve_analyte_+3A_plate">plate</code></td>
<td>
<p>A plate object</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_analyte_name">analyte_name</code></td>
<td>
<p>Name of the analyte of which standard curve we want to plot.</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_data_type">data_type</code></td>
<td>
<p>Data type of the value we want to plot - the same datatype as in the plate file. By default equals to <code style="white-space: pre;">&#8288;Net MFI&#8288;</code></p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_decreasing_rau_order">decreasing_rau_order</code></td>
<td>
<p>If <code>TRUE</code> the RAU values are plotted in decreasing order, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_log_scale">log_scale</code></td>
<td>
<p>Which elements on the plot should be displayed in log scale. By default <code>"RAU"</code>. If <code>NULL</code> or <code>c()</code> no log scale is used, if <code>"all"</code> or <code>c("RAU", "MFI")</code> all elements are displayed in log scale.</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_plot_line">plot_line</code></td>
<td>
<p>If <code>TRUE</code> a line is plotted, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_plot_blank_mean">plot_blank_mean</code></td>
<td>
<p>If <code>TRUE</code> the mean of the blank samples is plotted, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_plot_rau_bounds">plot_rau_bounds</code></td>
<td>
<p>If <code>TRUE</code> the RAU values bounds are plotted, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_plot_legend">plot_legend</code></td>
<td>
<p>If <code>TRUE</code> the legend is plotted, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> prints messages, <code>TRUE</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object with the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "CovidOISExPONTENT.csv",
  package = "PvSTATEM", mustWork = TRUE
)
layout_path &lt;- system.file("extdata", "CovidOISExPONTENT_layout.xlsx",
  package = "PvSTATEM", mustWork = TRUE
)
plate &lt;- read_luminex_data(path, layout_filepath = layout_path, verbose = FALSE)
plot_standard_curve_analyte(plate, "Spike_6P", plot_legend = FALSE, data_type = "Median")

</code></pre>

<hr>
<h2 id='plot_standard_curve_analyte_with_model'>Plot standard curve of a certain analyte with fitted model</h2><span id='topic+plot_standard_curve_analyte_with_model'></span>

<h3>Description</h3>

<p>Function plots the values of standard curve samples and the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_standard_curve_analyte_with_model(
  plate,
  model,
  data_type = "Median",
  decreasing_rau_order = TRUE,
  log_scale = c("all"),
  plot_asymptote = TRUE,
  plot_test_predictions = TRUE,
  plot_blank_mean = TRUE,
  plot_rau_bounds = TRUE,
  plot_legend = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_plate">plate</code></td>
<td>
<p>Plate object</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_model">model</code></td>
<td>
<p>fitted <code>Model</code> object, which predictions we want to plot</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_data_type">data_type</code></td>
<td>
<p>Data type of the value we want to plot - the same
datatype as in the plate file. By default equals to <code>Median</code></p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_decreasing_rau_order">decreasing_rau_order</code></td>
<td>
<p>If <code>TRUE</code> the RAU values are plotted in
decreasing order, <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_log_scale">log_scale</code></td>
<td>
<p>Which elements on the plot should be displayed in log scale.
By default <code>"all"</code>. If <code>NULL</code> or <code>c()</code> no log scale is used,
if <code>"all"</code> or <code>c("RAU", "MFI")</code> all elements are displayed in log scale.</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_plot_asymptote">plot_asymptote</code></td>
<td>
<p>If <code>TRUE</code> the asymptotes are plotted, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_plot_test_predictions">plot_test_predictions</code></td>
<td>
<p>If <code>TRUE</code> the predictions for the test samples are plotted, <code>TRUE</code> by default.
The predictions are obtained through extrapolation of the model</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_plot_blank_mean">plot_blank_mean</code></td>
<td>
<p>If <code>TRUE</code> the mean of the blank samples is plotted, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_plot_rau_bounds">plot_rau_bounds</code></td>
<td>
<p>If <code>TRUE</code> the RAU bounds are plotted, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_plot_legend">plot_legend</code></td>
<td>
<p>If <code>TRUE</code> the legend is plotted, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> prints messages, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_analyte_with_model_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>predict</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object with the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "CovidOISExPONTENT.csv",
  package = "PvSTATEM", mustWork = TRUE
)
layout_path &lt;- system.file("extdata", "CovidOISExPONTENT_layout.xlsx",
  package = "PvSTATEM", mustWork = TRUE
)
plate &lt;- read_luminex_data(path, layout_filepath = layout_path, verbose = FALSE)
model &lt;- create_standard_curve_model_analyte(plate, analyte_name = "Spike_B16172")
plot_standard_curve_analyte_with_model(plate, model, decreasing_rau_order = FALSE)

</code></pre>

<hr>
<h2 id='plot_standard_curve_stacked'>Standard curve stacked plot for levey-jennings report</h2><span id='topic+plot_standard_curve_stacked'></span>

<h3>Description</h3>

<p>Function generates a plot of stacked on top of each other standard curves
for a given analyte form a list of plates. The plot is created with the
levey-jennings report in mind, but it can be run by itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_standard_curve_stacked(
  list_of_plates,
  analyte_name,
  data_type = "Median",
  decreasing_dilution_order = TRUE,
  monochromatic = TRUE,
  legend_type = NULL,
  log_scale = c("all"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_standard_curve_stacked_+3A_list_of_plates">list_of_plates</code></td>
<td>
<p>list of Plate objects</p>
</td></tr>
<tr><td><code id="plot_standard_curve_stacked_+3A_analyte_name">analyte_name</code></td>
<td>
<p>Name of the analyte of which standard curves we want to plot.</p>
</td></tr>
<tr><td><code id="plot_standard_curve_stacked_+3A_data_type">data_type</code></td>
<td>
<p>Data type of the value we want to plot - the same
datatype as in the plate file. By default equals to <code>Median</code></p>
</td></tr>
<tr><td><code id="plot_standard_curve_stacked_+3A_decreasing_dilution_order">decreasing_dilution_order</code></td>
<td>
<p>If <code>TRUE</code> the dilution values are
plotted in decreasing order, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_stacked_+3A_monochromatic">monochromatic</code></td>
<td>
<p>If <code>TRUE</code> the color of standard curves changes
from white (the oldest) to blue (the newest) it helps to observe drift in
calibration of the device; otherwise, more varied colours are used, <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_standard_curve_stacked_+3A_legend_type">legend_type</code></td>
<td>
<p>default value is <code>NULL</code>, then legend type is determined
based on monochromatic value. If monochromatic is equal to <code>TRUE</code> then legend
type is set to <code>date</code>, if it is <code>FALSE</code> then legend
type is set to <code>plate_name</code>. User can override this behavior by
setting explicitly <code>legend_type</code> to <code>date</code> or <code>plate_name</code>.</p>
</td></tr>
<tr><td><code id="plot_standard_curve_stacked_+3A_log_scale">log_scale</code></td>
<td>
<p>Which elements on the plot should be displayed in log scale.
By default <code>"all"</code>. If <code>NULL</code> or <code>c()</code> no log scale is used,
if <code>"all"</code> or <code>c("dilutions", "MFI")</code> all elements are displayed in log scale.</p>
</td></tr>
<tr><td><code id="plot_standard_curve_stacked_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> prints messages, <code>TRUE</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object with the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# creating temporary directory for the example
output_dir &lt;- tempdir(check = TRUE)

dir_with_luminex_files &lt;- system.file("extdata", "multiplate_reallife_reduced",
  package = "PvSTATEM", mustWork = TRUE
)
list_of_plates &lt;- process_dir(dir_with_luminex_files,
  return_plates = TRUE, format = "xPONENT", output_dir = output_dir
)
plot_standard_curve_stacked(list_of_plates, "ME", data_type = "Median", monochromatic = FALSE)

</code></pre>

<hr>
<h2 id='plot_standard_curve_thumbnail'>Standard curve thumbnail for report</h2><span id='topic+plot_standard_curve_thumbnail'></span>

<h3>Description</h3>

<p>Function generates a thumbnail of the standard curve for a given analyte.
The thumbnail is used in the plate report. It doesn't have any additional
parameters, because it is used only internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_standard_curve_thumbnail(plate, analyte_name, data_type = "Median")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_standard_curve_thumbnail_+3A_plate">plate</code></td>
<td>
<p>Plate object</p>
</td></tr>
<tr><td><code id="plot_standard_curve_thumbnail_+3A_analyte_name">analyte_name</code></td>
<td>
<p>Name of the analyte of which standard curve we want to plot.</p>
</td></tr>
<tr><td><code id="plot_standard_curve_thumbnail_+3A_data_type">data_type</code></td>
<td>
<p>Data type of the value we want to plot - the same
types as in the plate file. By default equals to <code>median</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object with the plot
</p>

<hr>
<h2 id='predict.Model'>Predict the RAU values from the MFI values</h2><span id='topic+predict.Model'></span>

<h3>Description</h3>

<p>More details can be found here: <a href="#topic+Model">Model</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Model'
predict(object, mfi, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.Model_+3A_object">object</code></td>
<td>
<p>(<code>Model()</code>)
Object of the Model class</p>
</td></tr>
<tr><td><code id="predict.Model_+3A_mfi">mfi</code></td>
<td>
<p>(<code>numeric()</code>)
MFI values for which we want to predict the RAU values
Should be in the same scale as the MFI values used to fit the model</p>
</td></tr>
<tr><td><code id="predict.Model_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>data.frame()</code>)
</p>

<hr>
<h2 id='process_dir'>Process a dir of files to generate normalised data and reports</h2><span id='topic+process_dir'></span>

<h3>Description</h3>

<p>The output files will be created alongside their corresponding input files, preserving
the directory structure of the input directory unless the <code>flatten_output_dir</code> parameter is set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_dir(
  input_dir,
  output_dir = NULL,
  recurse = FALSE,
  flatten_output_dir = FALSE,
  layout_filepath = NULL,
  format = NULL,
  normalisation_types = c("RAU", "nMFI"),
  generate_reports = FALSE,
  merge_outputs = FALSE,
  column_collision_strategy = "intersection",
  return_plates = FALSE,
  dry_run = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_dir_+3A_input_dir">input_dir</code></td>
<td>
<p>(<code>character(1)</code>) The directory containing the input files. It may be nested.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_output_dir">output_dir</code></td>
<td>
<p>(<code>character(1)</code>) Optional overwrite directory where the output files should be saved. The default is <code>NULL</code>.
By default, the output directory is the same as the input directory.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_recurse">recurse</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, the function will search for files recursively in the input directory. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_flatten_output_dir">flatten_output_dir</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, the output files will be saved in the output directory directly. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_layout_filepath">layout_filepath</code></td>
<td>
<p>(<code>character(1)</code>) The path to the layout file. The default is <code>NULL</code>, and the layout file will have to
be determined automatically based on the file name.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_format">format</code></td>
<td>
<p>(<code>character(1)</code>) The format of the Luminex data. The default is <code>NULL</code>, and the format will have to
be determined automatically based on the file name. Available options are <code>xPONENT</code> and <code>INTELLIFLEX</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_normalisation_types">normalisation_types</code></td>
<td>
<p>(<code>character()</code>) A vector of normalisation types to use. The default is <code>c("RAU", "nMFI")</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_generate_reports">generate_reports</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, generate quality control reports for each file. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_merge_outputs">merge_outputs</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, merge the outputs of all plates into a single CSV file for each normalisation type.
The resulting file will be saved in the output directory with the name <code style="white-space: pre;">&#8288;merged_{normalisation_type}_{timestamp}.csv&#8288;</code>.
Example: <code>merged_nMFI_20250115_230735.csv</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_column_collision_strategy">column_collision_strategy</code></td>
<td>
<p>(<code>character(1)</code>) A method for handling missing or additional columns when merging outputs.
Possible options are <code>union</code> and <code>intersection</code>. The default is <code>intersection</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_return_plates">return_plates</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, return a list of processed plates. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_dry_run">dry_run</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, the function will not process any files
but will print the information about the files that would be processed. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical(1)</code>) Print additional information. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="process_dir_+3A_...">...</code></td>
<td>
<p>Additional arguments to for the <code>process_file</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the <code>return_plates</code> parameter is set to <code>TRUE</code> the function returns a list of plates
sorted by the <code>plate_datetime</code> (The time of the experiment noted in the csv file) in increasing order (oldest plates first).
If the <code>return_plates</code> parameters is set to <code>FALSE</code> the function returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Select input directory to process
dir &lt;- system.file("extdata", "multiplate_lite", package = "PvSTATEM", mustWork = TRUE)

# Select output directory
output_dir &lt;- tempdir(check = TRUE)

# Process input directory and return plates
plates &lt;- process_dir(dir, return_plates = TRUE, output_dir = output_dir)

</code></pre>

<hr>
<h2 id='process_file'>Process a file to generate normalised data and reports</h2><span id='topic+process_file'></span>

<h3>Description</h3>

<p>Perform <code>process_plate</code> and <code>generate_plate_report</code> for a given plate file.
In more detail, this function reads the plate file and calls the <code>process_plate</code>
on the processed plate objects across all the normalisation types, including the raw MFI values.
If the user has specified the <code>generate_report</code> flag, it will also call the <code>generate_plate_report</code> function
generating the quality control report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_file(
  plate_filepath,
  layout_filepath,
  output_dir = "normalised_data",
  format = "xPONENT",
  generate_report = FALSE,
  process_plate = TRUE,
  normalisation_types = c("RAU", "nMFI"),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_file_+3A_plate_filepath">plate_filepath</code></td>
<td>
<p>(<code>character(1)</code>) The path to the plate file.</p>
</td></tr>
<tr><td><code id="process_file_+3A_layout_filepath">layout_filepath</code></td>
<td>
<p>(<code>character(1)</code>) The path to the layout file.</p>
</td></tr>
<tr><td><code id="process_file_+3A_output_dir">output_dir</code></td>
<td>
<p>(<code>character(1)</code>) The directory where the output files should be saved. The default is <code>"normalised_data"</code>.</p>
</td></tr>
<tr><td><code id="process_file_+3A_format">format</code></td>
<td>
<p>(<code>character(1)</code>) The format of the Luminex data. The default is <code>"xPONENT"</code>. Available options are <code>"xPONENT"</code> and <code>"INTELLIFLEX"</code>.</p>
</td></tr>
<tr><td><code id="process_file_+3A_generate_report">generate_report</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, generate a quality control report. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="process_file_+3A_process_plate">process_plate</code></td>
<td>
<p>(<code>logical(1)</code>) If <code>TRUE</code>, process the plate. The default is <code>TRUE</code>.
If the value is set to <code>FALSE</code> the function will only read the plate file and return the plate object.</p>
</td></tr>
<tr><td><code id="process_file_+3A_normalisation_types">normalisation_types</code></td>
<td>
<p>(<code>character()</code>) A vector of normalisation types to use. The default is <code>c("RAU", "nMFI")</code>.</p>
</td></tr>
<tr><td><code id="process_file_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical(1)</code>) Print additional information. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="process_file_+3A_...">...</code></td>
<td>
<p>Additional arguments to for the <code>read_luminex_data</code> function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Select an input csv file for processing and corresponding layout file
plate_file &lt;- system.file("extdata", "CovidOISExPONTENT_CO_reduced.csv", package = "PvSTATEM")
layout_file &lt;- system.file("extdata", "CovidOISExPONTENT_CO_layout.xlsx", package = "PvSTATEM")

example_dir &lt;- tempdir(check = TRUE) # a temporary directory
# create and save dataframe with computed dilutions for all suported noramlization types
process_file(plate_file, layout_file, output_dir = example_dir)

example_dir2 &lt;- tempdir(check = TRUE) # a temporary directory
# process the plate for a specific normalization type
process_file(plate_file, layout_file, output_dir = example_dir2, normalisation_types = c("RAU"))

</code></pre>

<hr>
<h2 id='process_plate'>Process a plate and save output values to a CSV</h2><span id='topic+process_plate'></span>

<h3>Description</h3>

<p>Depending on the <code>normalisation_type</code> argument, the function will compute the RAU or nMFI values for each analyte in the plate.
<strong>RAU</strong> is the default normalisation type.
</p>
<p>The behaviour of the function, in the case of RAU normalisation type, can be summarised as follows:
</p>

<ol>
<li><p> Adjust blanks if not already done.
</p>
</li>
<li><p> Fit a model to each analyte using standard curve samples.
</p>
</li>
<li><p> Compute RAU values for each analyte using the corresponding model.
</p>
</li>
<li><p> Aggregate computed RAU values into a single data frame.
</p>
</li>
<li><p> Save the computed RAU values to a CSV file.
</p>
</li></ol>

<p>More info about the RAU normalisation can be found in
<code>create_standard_curve_model_analyte</code> function documentation <a href="#topic+create_standard_curve_model_analyte">create_standard_curve_model_analyte</a> or in the Model reference <a href="#topic+Model">Model</a>.
</p>
<p>In case the normalisation type is <strong>nMFI</strong>, the function will:
</p>

<ol>
<li><p> Adjust blanks if not already done.
</p>
</li>
<li><p> Compute nMFI values for each analyte using the target dilution.
</p>
</li>
<li><p> Aggregate computed nMFI values into a single data frame.
</p>
</li>
<li><p> Save the computed nMFI values to a CSV file.
</p>
</li></ol>

<p>More info about the nMFI normalisation can be found in <code>get_nmfi</code> function documentation <a href="#topic+get_nmfi">get_nmfi</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_plate(
  plate,
  filename = NULL,
  output_dir = "normalised_data",
  write_output = TRUE,
  normalisation_type = "RAU",
  data_type = "Median",
  include_raw_mfi = TRUE,
  adjust_blanks = FALSE,
  verbose = TRUE,
  reference_dilution = 1/400,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_plate_+3A_plate">plate</code></td>
<td>
<p>(<code>Plate()</code>) a plate object</p>
</td></tr>
<tr><td><code id="process_plate_+3A_filename">filename</code></td>
<td>
<p>(<code>character(1)</code>) The name of the output CSV file with normalised MFI values.
If not provided or equals to <code>NULL</code>, the output filename will be based on the normalisation type
and the plate name, precisely: <code style="white-space: pre;">&#8288;{plate_name}_{normalisation_type}.csv&#8288;</code>.
By default the <code>plate_name</code> is the filename of the input file that contains the plate data.
For more details please refer to <a href="#topic+Plate">Plate</a>.
</p>
<p>If the passed filename does not contain <code>.csv</code> extension, the default extension <code>.csv</code> will be added.
Filename can also be a path to a file, e.g. <code>path/to/file.csv</code>. In this case, the <code>output_dir</code> and <code>filename</code> will be joined together.
However, if the passed filepath is an absolute path and the <code>output_dir</code> parameter is also provided, the <code>output_dir</code> parameter will be ignored.
If a file already exists under a specified filepath, the function will overwrite it.</p>
</td></tr>
<tr><td><code id="process_plate_+3A_output_dir">output_dir</code></td>
<td>
<p>(<code>character(1)</code>) The directory where the output CSV file should be saved.
Please note that any directory path provided will create all necessary directories (including parent directories) if they do not exist.
If it equals to <code>NULL</code> the current working directory will be used. Default is 'normalised_data'.</p>
</td></tr>
<tr><td><code id="process_plate_+3A_write_output">write_output</code></td>
<td>
<p>(<code>logical(1)</code>) whether or not to write the output to a file
specified by <code>filename</code> parameter. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="process_plate_+3A_normalisation_type">normalisation_type</code></td>
<td>
<p>(<code>character(1)</code>) type of normalisation to use. Available options are:
<br /> <code>c(RAU, nMFI)</code>.</p>
</td></tr>
<tr><td><code id="process_plate_+3A_data_type">data_type</code></td>
<td>
<p>(<code>character(1)</code>) type of data to use for the computation. Median is the default</p>
</td></tr>
<tr><td><code id="process_plate_+3A_include_raw_mfi">include_raw_mfi</code></td>
<td>
<p>(<code>logical(1)</code>) include raw MFI values in the output. The default is <code>TRUE</code>.
In case this option is <code>TRUE</code>, the output dataframe contains two columns for each analyte: one for the normalised values and one for the raw MFI values.
The normalised columns are named as <code>AnalyteName</code> and <code>AnalyteName_raw</code>, respectively.</p>
</td></tr>
<tr><td><code id="process_plate_+3A_adjust_blanks">adjust_blanks</code></td>
<td>
<p>(<code>logical(1)</code>) adjust blanks before computing RAU values. The default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="process_plate_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical(1)</code>) print additional information. The default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="process_plate_+3A_reference_dilution">reference_dilution</code></td>
<td>
<p>(<code>numeric(1)</code>) target dilution to use as reference for the nMFI normalisation. Ignored in case of RAU normalisation.
Default is <code>1/400</code>.
It should refer to a dilution of a standard curve sample in the given plate object.
This parameter could be either a numeric value or a string.
In case it is a character string, it should have the format <code style="white-space: pre;">&#8288;1/d+&#8288;</code>, where <code style="white-space: pre;">&#8288;d+&#8288;</code> is any positive integer.</p>
</td></tr>
<tr><td><code id="process_plate_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the fit model function (<code>create_standard_curve_model_analyte</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with normalised values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plate_file &lt;- system.file("extdata", "CovidOISExPONTENT_CO_reduced.csv", package = "PvSTATEM")
# a plate file with reduced number of analytes to speed up the computation
layout_file &lt;- system.file("extdata", "CovidOISExPONTENT_CO_layout.xlsx", package = "PvSTATEM")

plate &lt;- read_luminex_data(plate_file, layout_file, verbose = FALSE)

example_dir &lt;- tempdir(check = TRUE) # a temporary directory
# create and save dataframe with computed dilutions
process_plate(plate, output_dir = example_dir)

# process plate without adjusting blanks and save the output to a file with a custom name
process_plate(plate,
  filename = "plate_without_blanks_adjusted.csv",
  output_dir = example_dir, adjust_blanks = FALSE
)


# nMFI normalisation
process_plate(plate,
  output_dir = example_dir,
  normalisation_type = "nMFI", reference_dilution = 1 / 400
)

</code></pre>

<hr>
<h2 id='read_intelliflex_format'>Read the Intelliflex format data</h2><span id='topic+read_intelliflex_format'></span>

<h3>Description</h3>

<p>Read the Intelliflex format data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_intelliflex_format(path, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_intelliflex_format_+3A_path">path</code></td>
<td>
<p>Path to the INTELLIFLEX file</p>
</td></tr>
<tr><td><code id="read_intelliflex_format_+3A_verbose">verbose</code></td>
<td>
<p>Print additional information. Default is <code>TRUE</code></p>
</td></tr>
</table>

<hr>
<h2 id='read_layout_data'>Read layout data from a file</h2><span id='topic+read_layout_data'></span>

<h3>Description</h3>

<p>Read layout data from a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_layout_data(layout_file_path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_layout_data_+3A_layout_file_path">layout_file_path</code></td>
<td>
<p>Path to the layout file</p>
</td></tr>
<tr><td><code id="read_layout_data_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the underlying read function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the layout data.
The row names are supposed to be letters A,B,C, etc.
The column names are supposed to be numbers 1,2,3, etc.
</p>

<hr>
<h2 id='read_luminex_data'>Read Luminex Data</h2><span id='topic+read_luminex_data'></span>

<h3>Description</h3>

<p>Reads a file containing Luminex data and returns a Plate object.
If provided, can also read a layout file, which usually contains
information about the sample names, sample types or its dilutions.
</p>
<p>The function is capable of reading data in two different formats:
</p>

<ul>
<li><p> xPONENT
</p>
</li>
<li><p> INTELLIFLEX
which are produced by two different Luminex machines.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>read_luminex_data(
  plate_filepath,
  layout_filepath = NULL,
  format = "xPONENT",
  plate_file_separator = ",",
  plate_file_encoding = "UTF-8",
  use_layout_sample_names = TRUE,
  use_layout_types = TRUE,
  use_layout_dilutions = TRUE,
  default_data_type = "Median",
  sample_types = NULL,
  dilutions = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_luminex_data_+3A_plate_filepath">plate_filepath</code></td>
<td>
<p>Path to the Luminex plate file</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_layout_filepath">layout_filepath</code></td>
<td>
<p>Path to the Luminex layout file</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_format">format</code></td>
<td>
<p>The format of the Luminex data. Select from: xPONENT, INTELLIFLEX</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_plate_file_separator">plate_file_separator</code></td>
<td>
<p>The separator used in the plate file</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_plate_file_encoding">plate_file_encoding</code></td>
<td>
<p>The encoding used in the plate file</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_use_layout_sample_names">use_layout_sample_names</code></td>
<td>
<p>Whether to use names from the layout file in extracting sample names.</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_use_layout_types">use_layout_types</code></td>
<td>
<p>Whether to use names from the layout file in extracting sample types.
Works only when layout file is provided</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_use_layout_dilutions">use_layout_dilutions</code></td>
<td>
<p>Whether to use dilutions from the layout file in extracting dilutions.
Works only when layout file is provided</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_default_data_type">default_data_type</code></td>
<td>
<p>The default data type to use if none is specified</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_sample_types">sample_types</code></td>
<td>
<p>a vector of sample types to use instead of the extracted ones</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_dilutions">dilutions</code></td>
<td>
<p>a vector of dilutions to use instead of the extracted ones</p>
</td></tr>
<tr><td><code id="read_luminex_data_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print additional information and warnings. <code>TRUE</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plate file containing the Luminex data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plate_file &lt;- system.file("extdata", "CovidOISExPONTENT.csv", package = "PvSTATEM")
layout_file &lt;- system.file("extdata", "CovidOISExPONTENT_layout.csv", package = "PvSTATEM")
plate &lt;- read_luminex_data(plate_file, layout_file)

plate_file &lt;- system.file("extdata", "CovidOISExPONTENT_CO.csv", package = "PvSTATEM")
layout_file &lt;- system.file("extdata", "CovidOISExPONTENT_CO_layout.xlsx", package = "PvSTATEM")
# To suppress warnings and additional information use verbose = FALSE
plate &lt;- read_luminex_data(plate_file, layout_file, verbose = FALSE)

</code></pre>

<hr>
<h2 id='read_xponent_format'>Read the xPONENT format data</h2><span id='topic+read_xponent_format'></span>

<h3>Description</h3>

<p>Read the xPONENT format data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_xponent_format(
  path,
  exact_parse = FALSE,
  encoding = "utf-8",
  separator = ",",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_xponent_format_+3A_path">path</code></td>
<td>
<p>Path to the xPONENT file</p>
</td></tr>
<tr><td><code id="read_xponent_format_+3A_exact_parse">exact_parse</code></td>
<td>
<p>Whether to parse the file exactly or not
Exact parsing means that the batch, calibration and assay metadata will be parsed as well</p>
</td></tr>
<tr><td><code id="read_xponent_format_+3A_encoding">encoding</code></td>
<td>
<p>Encoding of the file</p>
</td></tr>
<tr><td><code id="read_xponent_format_+3A_separator">separator</code></td>
<td>
<p>Separator for the CSV values</p>
</td></tr>
<tr><td><code id="read_xponent_format_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print the progress. Default is <code>TRUE</code></p>
</td></tr>
</table>

<hr>
<h2 id='remove_empty_lists'>Remove Empty Lists from a List</h2><span id='topic+remove_empty_lists'></span>

<h3>Description</h3>

<p>This internal function filters out elements from a list that are empty lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_empty_lists(lst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_empty_lists_+3A_lst">lst</code></td>
<td>
<p>A list to be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with empty lists removed.
</p>

<hr>
<h2 id='select_columns'>Select Columns from a DataFrame</h2><span id='topic+select_columns'></span>

<h3>Description</h3>

<p>Selects specified columns from a dataframe. If a column
does not exist in the dataframe, it will be added with a specified replacement value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_columns(df, columns, replace_value = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_columns_+3A_df">df</code></td>
<td>
<p>A dataframe from which columns are to be selected.</p>
</td></tr>
<tr><td><code id="select_columns_+3A_columns">columns</code></td>
<td>
<p>A vector of column names to select.</p>
</td></tr>
<tr><td><code id="select_columns_+3A_replace_value">replace_value</code></td>
<td>
<p>Value to use for columns that do not exist in the dataframe. Default is NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the specified columns, with missing columns filled with the replacement value.
</p>

<hr>
<h2 id='sort_list_by'>Sort a flat list by value</h2><span id='topic+sort_list_by'></span>

<h3>Description</h3>

<p>Sort a flat list by value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_list_by(list_obj, decreasing = FALSE, value_f = function(elem) elem)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_list_by_+3A_list_obj">list_obj</code></td>
<td>
<p>A list to sort</p>
</td></tr>
<tr><td><code id="sort_list_by_+3A_decreasing">decreasing</code></td>
<td>
<p>Should the sorting by decreasing or increasing</p>
</td></tr>
<tr><td><code id="sort_list_by_+3A_value_f">value_f</code></td>
<td>
<p>Function that expects a element of the list
and returns a value to sort the list by.</p>
</td></tr>
</table>

<hr>
<h2 id='translate_sample_names_to_sample_types'>Translate sample names to sample types</h2><span id='topic+translate_sample_names_to_sample_types'></span>

<h3>Description</h3>

<p>Function translates sample names to sample types based on the sample name
from Luminex file and the sample name from the layout file, which may not
be provided. The function uses regular expressions to match the sample names
to the sample types.
</p>
<p>It parses the names as follows:
</p>
<p>If <code>sample_names</code> or <code>sample_names_from_layout</code> equals to <code>BLANK</code>, <code>BACKGROUND</code> or <code>B</code>,
then SampleType equals to <code>BLANK</code>
</p>
<p>If <code>sample_names</code> or <code>sample_names_from_layout</code> equals to <code style="white-space: pre;">&#8288;STANDARD CURVE&#8288;</code>,
<code>SC</code>, <code>S</code>, contains substring <code style="white-space: pre;">&#8288;1/\d+&#8288;</code> and has prefix <code style="white-space: pre;">&#8288; &#8288;</code>, <code>S_</code>, <code>S </code>,
<code>S</code> or <code>CP3</code>, then SampleType equals to <code style="white-space: pre;">&#8288;STANDARD CURVE&#8288;</code>
</p>
<p>If <code>sample_names</code> or <code>sample_names_from_layout</code> equals to <code style="white-space: pre;">&#8288;NEGATIVE CONTROL&#8288;</code>, <code>N</code>,
or contains substring <code>NEG</code>, then SampleType equals to <code style="white-space: pre;">&#8288;NEGATIVE CONTROL&#8288;</code>
</p>
<p>If <code>sample_names</code> or <code>sample_names_from_layout</code> starts with <code>P</code> followed by
whitespace, <code>POS</code> followed by whitespace, some sample name followed by
substring <code style="white-space: pre;">&#8288;1/\d+&#8288;</code> SampleType equals to <code style="white-space: pre;">&#8288;POSITIVE CONTROL&#8288;</code>
</p>
<p>Otherwise, the returned SampleType is <code>TEST</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_sample_names_to_sample_types(
  sample_names,
  sample_names_from_layout = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_sample_names_to_sample_types_+3A_sample_names">sample_names</code></td>
<td>
<p>(<code>character()</code>)<br />
Vector of sample names from Luminex file</p>
</td></tr>
<tr><td><code id="translate_sample_names_to_sample_types_+3A_sample_names_from_layout">sample_names_from_layout</code></td>
<td>
<p>(<code>character()</code>)<br />
Vector of sample names from Layout file
values in this vector may be different than <code>sample_names</code> and may
contain additional information about the sample type like dilution.
This vector when set has to have at least the length of <code>sample_names</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of valid sample_type strings of length equal to the length of <code>sample_names</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>translate_sample_names_to_sample_types(c("B", "BLANK", "NEG", "TEST1"))
translate_sample_names_to_sample_types(c("S", "CP3"))

</code></pre>

<hr>
<h2 id='validate_filepath_and_output_dir'>Validate filepath and output_dir</h2><span id='topic+validate_filepath_and_output_dir'></span>

<h3>Description</h3>

<p>This function validates the filepath and output_dir arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_filepath_and_output_dir(
  filename,
  output_dir,
  plate_name,
  suffix,
  extension,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_filepath_and_output_dir_+3A_filename">filename</code></td>
<td>
<p>(<code>character(1)</code>) The path to the file.</p>
</td></tr>
<tr><td><code id="validate_filepath_and_output_dir_+3A_output_dir">output_dir</code></td>
<td>
<p>(<code>character(1)</code>) The directory where the file should be saved.</p>
</td></tr>
<tr><td><code id="validate_filepath_and_output_dir_+3A_plate_name">plate_name</code></td>
<td>
<p>(<code>character(1)</code>) The name of the plate.</p>
</td></tr>
<tr><td><code id="validate_filepath_and_output_dir_+3A_suffix">suffix</code></td>
<td>
<p>(<code>character(1)</code>) The suffix to be added to the filename if it is not provided, e.g. <code>RAU</code>.</p>
</td></tr>
<tr><td><code id="validate_filepath_and_output_dir_+3A_extension">extension</code></td>
<td>
<p>(<code>character(1)</code>) The extension to be added to the filename if it does not have one.
Passed without a dot, e.g. <code>csv</code>.</p>
</td></tr>
<tr><td><code id="validate_filepath_and_output_dir_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical(1)</code>) A logical value indicating whether the function should print additional information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An absolute output path.
</p>

<hr>
<h2 id='verbose_cat'>Verbose Cat</h2><span id='topic+verbose_cat'></span>

<h3>Description</h3>

<p>This function prints the input to the console if the <code>verbose</code> argument is <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbose_cat(..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verbose_cat_+3A_...">...</code></td>
<td>
<p>The input to be printed.</p>
</td></tr>
<tr><td><code id="verbose_cat_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether the input should be printed.</p>
</td></tr>
</table>

<hr>
<h2 id='verify_character_join'>Verify Character Join</h2><span id='topic+verify_character_join'></span>

<h3>Description</h3>

<p>Checks if two character values are equal. If either value is <code>NULL</code>, returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_character_join(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_character_join_+3A_x">x</code></td>
<td>
<p>A character value to be compared.</p>
</td></tr>
<tr><td><code id="verify_character_join_+3A_y">y</code></td>
<td>
<p>A character value to be compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the values are equal or if either value is <code>NULL</code>. Returns <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='verify_numeric_join'>Verify Numeric Join</h2><span id='topic+verify_numeric_join'></span>

<h3>Description</h3>

<p>Checks if two numeric values are equal. If either value is <code>NA</code>, returns <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_numeric_join(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_numeric_join_+3A_x">x</code></td>
<td>
<p>A numeric value to be compared.</p>
</td></tr>
<tr><td><code id="verify_numeric_join_+3A_y">y</code></td>
<td>
<p>A numeric value to be compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the values are equal or if either value is <code>NA</code>. Returns <code>FALSE</code> otherwise.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
