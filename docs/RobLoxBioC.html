<!DOCTYPE html><html lang="en"><head><title>Help for package RobLoxBioC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RobLoxBioC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RobLoxBioC-package'>
<p>Infinitesimally robust estimators for preprocessing omics data</p></a></li>
<li><a href='#KolmogorovMinDist'><p>Generic Function for Computing Minimum Kolmogorov Distance for Biological Data</p></a></li>
<li><a href='#robloxbioc'><p>Generic Function for Preprocessing Biological Data</p></a></li>
<li><a href='#SimStudies'><p>Perform Monte-Carlo Study.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Infinitesimally Robust Estimators for Preprocessing -Omics Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the determination of optimally robust influence curves and
            estimators for preprocessing omics data, in particular gene expression data (Kohl
            and Deigner (2010), &lt;<a href="https://doi.org/10.1186%2F1471-2105-11-583">doi:10.1186/1471-2105-11-583</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), methods, distr(&ge; 2.8.0), affy</td>
</tr>
<tr>
<td>Imports:</td>
<td>Biobase, BiocGenerics, beadarray, RobLox(&ge; 1.1.0),
distrMod(&ge; 2.8.0), lattice, RColorBrewer, AnnotationDbi</td>
</tr>
<tr>
<td>Suggests:</td>
<td>affydata, hgu95av2cdf, beadarrayExampleData,
illuminaHumanv3.db</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/robast/">https://r-forge.r-project.org/projects/robast/</a></td>
</tr>
<tr>
<td>LastChangedDate:</td>
<td>{$LastChangedDate: 2025-01-19 17:58:14 +0100 (So, 19.
Jan 2025) $}</td>
</tr>
<tr>
<td>LastChangedRevision:</td>
<td>{$LastChangedRevision: 1333 $}</td>
</tr>
<tr>
<td>VCS/SVNRevision:</td>
<td>1329</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-19 17:00:13 UTC; kohlm</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-19 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RobLoxBioC-package'>
Infinitesimally robust estimators for preprocessing omics data
</h2><span id='topic+RobLoxBioC-package'></span><span id='topic+RobLoxBioC'></span>

<h3>Description</h3>

<p>Functions for the determination of optimally robust influence curves 
and estimators for preprocessing omics data, in particular gene expression data
(Kohl and Deigner (2010)).
</p>


<h3>Package versions</h3>

<p>Note: The first two numbers of package versions do not necessarily reflect
package-individual development, but rather are chosen for the
RobAStXXX family as a whole in order to ease updating &quot;depends&quot;
information.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Maintainer: Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>
<p>Kohl M. and Deigner H.P. (2010). Preprocessing of gene expression data by optimally 
robust estimators. <em>BMC Bioinformatics</em>, 11:583. 
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation 
in General Smoothly Parametrized Models. <em>Statistical Methods and Application</em>, 
<b>19</b>(3):333-354. 
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. <em>Statistical Methods and Applications</em> <b>17</b>(1) 13-40.
</p>


<h3>See Also</h3>

<p><code><a href="RobLox.html#topic+roblox">roblox</a></code>, <code><a href="RobLox.html#topic+rowRoblox">rowRoblox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RobLoxBioC)
</code></pre>

<hr>
<h2 id='KolmogorovMinDist'>Generic Function for Computing Minimum Kolmogorov Distance for Biological Data</h2><span id='topic+KolmogorovMinDist'></span><span id='topic+KolmogorovMinDist-methods'></span><span id='topic+KolmogorovMinDist+2Cmatrix+2CNorm-method'></span><span id='topic+KolmogorovMinDist+2CAffyBatch+2CAbscontDistribution-method'></span><span id='topic+KolmogorovMinDist+2CbeadLevelData+2CAbscontDistribution-method'></span>

<h3>Description</h3>

<p>Generic function for computing minimum Kolmogorov distance for biological data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KolmogorovMinDist(x, D, ...)

## S4 method for signature 'matrix,Norm'
KolmogorovMinDist(x, D, mad0 = 1e-4)

## S4 method for signature 'AffyBatch,AbscontDistribution'
KolmogorovMinDist(x, D, bg.correct = TRUE, pmcorrect = TRUE, 
                  verbose = TRUE)

## S4 method for signature 'beadLevelData,AbscontDistribution'
KolmogorovMinDist(x, D, log = FALSE, what = "Grn", 
                  probes = NULL, arrays = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KolmogorovMinDist_+3A_x">x</code></td>
<td>
<p> biological data. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_d">D</code></td>
<td>
<p> object of class <code>"UnivariateDistribution"</code>. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_...">...</code></td>
<td>
<p> additional parameters. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_mad0">mad0</code></td>
<td>
<p> scale estimate used if computed MAD is equal to zero. 
Median and MAD are used as start parameter for optimization. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_bg.correct">bg.correct</code></td>
<td>
<p> if <code>TRUE</code> MAS 5.0 background correction is performed;
confer <code><a href="affy.html#topic+bgc">bg.correct.mas</a></code>. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_pmcorrect">pmcorrect</code></td>
<td>
<p> if <code>TRUE</code> <code>log2(PM/MM)</code> is used. 
If <code>FALSE</code> only <code>log2(PM)</code> is used. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_log">log</code></td>
<td>
<p> if <code>TRUE</code>, then the log2 intensities for each bead-type are summarized. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_what">what</code></td>
<td>
<p> character string specifying which intensities/values to summarize; 
see <code><a href="beadarray.html#topic+getBeadData">getBeadData</a></code>. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_probes">probes</code></td>
<td>
<p> Specify particular probes to summarize. If left <code>NULL</code> then all
the probes on the first array are used. </p>
</td></tr>
<tr><td><code id="KolmogorovMinDist_+3A_arrays">arrays</code></td>
<td>
<p> integer (scalar or vector) specifying the strips/arrays to summarize. 
If <code>NULL</code>, then all strips/arrays are summarized. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum Kolmogorov distance is computed for each row of a matrix, each
Affymetrix probe, or each Illumina bead, respectively.
</p>
<p>So far, only the minimum distance to the set of normal distributions can be
computed.
</p>


<h3>Value</h3>

<p> List with components <code>dist</code> containing a numeric vector 
or matrix with minimum Kolmogorov distances and <code>n</code> a numeric vector 
or matrix with the corresponding sample sizes. </p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="distrEx.html#topic+KolmogorovDist">KolmogorovDist</a></code>, <code><a href="distrMod.html#topic+MDEstimator">MDEstimator</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # to have reproducible results for package checking

## matrix method for KolmogorovMinDist
ind &lt;- rbinom(200, size=1, prob=0.05) 
X &lt;- matrix(rnorm(200, mean=ind*3, sd=(1-ind) + ind*9), nrow = 2)
KolmogorovMinDist(X, D = Norm())

## using Affymetrix data
data(SpikeIn)
probes &lt;- log2(pm(SpikeIn))
(res &lt;- KolmogorovMinDist(probes, Norm()))
boxplot(res$dist)


## \donttest because of check time
## using Affymetrix data
library(affydata)
data(Dilution)
res &lt;- KolmogorovMinDist(Dilution[,1], Norm())
summary(res$dist)
boxplot(res$dist)
plot(res$n, res$dist, pch = 20, main = "Kolmogorov distance vs. sample size",
     xlab = "sample size", ylab = "Kolmogorov distance",
     ylim = c(0, max(res$dist)))
uni.n &lt;- min(res$n):max(res$n)
lines(uni.n, 1/(2*uni.n), col = "orange", lwd = 2)
legend("topright", legend = "minimal possible distance", fill = "orange")

## Illumina bead level data
library(beadarrayExampleData)
data(exampleBLData)
res &lt;- KolmogorovMinDist(exampleBLData, Norm(), arrays = 1)
res1 &lt;- KolmogorovMinDist(exampleBLData, Norm(), log = TRUE, arrays = 1)
summary(cbind(res$dist, res1$dist))
boxplot(list(res$dist, res1$dist), names = c("raw", "log-raw"))
sort(unique(res1$n))
plot(res1$n, res1$dist, pch = 20, main = "Kolmogorov distance vs. sample size",
     xlab = "sample size", ylab = "Kolmogorov distance",
     ylim = c(0, max(res1$dist)), xlim = c(min(res1$n), 56))
uni.n &lt;- min(res1$n):56
lines(uni.n, 1/(2*uni.n), col = "orange", lwd = 2)
legend("topright", legend = "minimal possible distance", fill = "orange")

</code></pre>

<hr>
<h2 id='robloxbioc'>Generic Function for Preprocessing Biological Data</h2><span id='topic+robloxbioc'></span><span id='topic+robloxbioc-methods'></span><span id='topic+robloxbioc+2Cmatrix-method'></span><span id='topic+robloxbioc+2CAffyBatch-method'></span><span id='topic+robloxbioc+2CbeadLevelData-method'></span>

<h3>Description</h3>

<p>Generic function for preprocessing biological data using optimally robust
(rmx) estimators; confer Rieder (1994), Kohl (2005), Rieder et al (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robloxbioc(x, ...)

## S4 method for signature 'matrix'
robloxbioc(x, eps = NULL, eps.lower = 0, eps.upper = 0.05, steps = 3L, 
           fsCor = TRUE, mad0 = 1e-4)

## S4 method for signature 'AffyBatch'
robloxbioc(x, bg.correct = TRUE, pmcorrect = TRUE, normalize = FALSE, 
           add.constant = 32, verbose = TRUE, eps = NULL, 
           eps.lower = 0, eps.upper = 0.05, steps = 3L, fsCor = TRUE, 
           mad0 = 1e-4, contrast.tau = 0.03, scale.tau = 10, 
           delta = 2^(-20), sc = 500)

## S4 method for signature 'beadLevelData'
robloxbioc(x, channelList = list(greenChannel), probeIDs = NULL, 
           useSampleFac = FALSE, sampleFac = NULL, weightNames = "wts", 
           removeUnMappedProbes = TRUE, eps = NULL, eps.lower = 0, 
           eps.upper = 0.05, steps = 3L, fsCor = TRUE, mad0 = 1e-4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robloxbioc_+3A_x">x</code></td>
<td>
<p> biological data. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_...">...</code></td>
<td>
<p> additional parameters. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_eps">eps</code></td>
<td>
<p> positive real (0 &lt; <code>eps</code> &lt;= 0.5): amount of gross errors. 
See details below. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_eps.lower">eps.lower</code></td>
<td>
<p> positive real (0 &lt;= <code>eps.lower</code> &lt;= <code>eps.upper</code>): 
lower bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_eps.upper">eps.upper</code></td>
<td>
<p> positive real (<code>eps.lower</code> &lt;= <code>eps.upper</code> &lt;= 0.5): 
upper bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_steps">steps</code></td>
<td>
<p> positive integer. k-step is used to compute the optimally robust estimator. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_fscor">fsCor</code></td>
<td>
<p> logical: perform finite-sample correction. See function <code><a href="RobLox.html#topic+finiteSampleCorrection">finiteSampleCorrection</a></code>. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_mad0">mad0</code></td>
<td>
<p> scale estimate used if computed MAD is equal to zero</p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_bg.correct">bg.correct</code></td>
<td>
<p> if <code>TRUE</code> MAS 5.0 background correction is performed;
confer <code><a href="affy.html#topic+bgc">bg.correct.mas</a></code>. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_pmcorrect">pmcorrect</code></td>
<td>
<p> method used for PM correction; <code>TRUE</code> calls an algorithm which is 
comparable to the algorithm of MAS 5.0; confer <code><a href="affy.html#topic+pmcorrect">pmcorrect.mas</a></code>. 
If <code>FALSE</code> only the PM intensities are used. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_normalize">normalize</code></td>
<td>
<p> logical: if <code>TRUE</code>, Affymetrix scale normalization is performed. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_add.constant">add.constant</code></td>
<td>
<p> constant added to the MAS 5.0 expression values before the normalization
step. Improves the variance of the measure one no longer devides by numbers close to 0
when computing fold-changes. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_contrast.tau">contrast.tau</code></td>
<td>
<p> a number denoting the contrast tau parameter; confer the MAS 5.0 
PM correction algorithm. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_scale.tau">scale.tau</code></td>
<td>
<p> a number denoting the scale tau parameter; confer the MAS 5.0 
PM correction algorithm. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_delta">delta</code></td>
<td>
<p> a number denoting the delta parameter; confer the MAS 5.0 
PM correction algorithm. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_sc">sc</code></td>
<td>
<p> value at which all arrays will be scaled to. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_channellist">channelList</code></td>
<td>
<p> List of objects of class illuminaChannel that defines the
summarisation to be performed where in our setup only the slots <code>transFun</code>
and <code>name</code> have an effect on the computations. Setting the slots 
<code>outlierFun</code>, <code>exprFun</code>, and <code>varFun</code> has no effect. In any 
case rmx estimators are applied. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_probeids">probeIDs</code></td>
<td>
<p> Vector of ArrayAddressIDs to be included in the summarized object. 
The default is to summarize all probes. </p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_usesamplefac">useSampleFac</code></td>
<td>
<p>if <code>TRUE</code> sections belonging to the same biological sample
will be combined. The default is to summarize each section separately.</p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_samplefac">sampleFac</code></td>
<td>
<p> optional character vector giving which a sample identifer for each section</p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_weightnames">weightNames</code></td>
<td>
<p> name of column in the <code>beadLevelData</code> to take extract weights</p>
</td></tr>
<tr><td><code id="robloxbioc_+3A_removeunmappedprobes">removeUnMappedProbes</code></td>
<td>
<p> if TRUE and annotation information is stored in the 
<code>beadLevelData</code> object, any ArrayAddressIDs that cannot be mapped to ILMN IDs 
will be removed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimally-robust resp. the radius-minimax (rmx) estimator for normal location 
and scale is used to preprocess biological data. The computation uses a k-step 
construction with median and MAD as starting estimators; cf. Rieder (1994) and 
Kohl (2005).
</p>
<p>If the amount of gross errors (contamination) is known, it can be 
specified by <code>eps</code>. The radius of the corresponding infinitesimal 
contamination neighborhood (infinitesimal version of Tukey's gross error model) 
is obtained by multiplying <code>eps</code> by the square root of the sample size. 
</p>
<p>If the amount of gross errors (contamination) is unknown, which is typically
the case, try to find a rough estimate for the amount of gross errors, such that 
it lies between <code>eps.lower</code> and <code>eps.upper</code>.
</p>
<p>If <code>eps</code> is <code>NULL</code>, the radius-minimax (rmx) estimator in sense of 
Rieder et al. (2001, 2008), respectively Section 2.2 of Kohl (2005) is used.
</p>
<p>The algorithm used for Affymetrix data is similar to MAS 5.0 (cf. Affymetrix (2002)).
The main difference is the substitution of the Tukey one-step estimator by our rmx 
k-step (k &gt;= 1) estimator in the PM/MM correction step. The optional scale normalization 
is performed as given in Affymetrix (2002).
</p>
<p>In case of Illumina data, the rmx estimator is used to summarize the bead types. 
The implementation for the most part copies <code><a href="beadarray.html#topic+summarize">summarize</a></code>
from <span class="pkg">beadarray</span>.
</p>
<p>For sample size &lt;= 2, median and MAD are used for estimation.
</p>
<p>If <code>eps = 0</code>, mean and sd are computed.
</p>


<h3>Value</h3>

<p> Return value depends on the class of <code>x</code>. 
In case of <code>"matrix"</code> a matrix with columns &quot;mean&quot; and &quot;sd&quot; is returned.
In case of <code>"AffyBatch"</code> an object of class <code>"ExpressionSet"</code> is returned. 
In case of <code>"BeadLevelData"</code> an object of class <code>"ExpressionSetIllumina"</code> is returned. 
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
</p>
<p>update for beadarray versions &gt;= 2.0.0 with support by Mark Dunnings and Andy Lynch</p>


<h3>References</h3>

<p>Affymetrix, Inc. (2002). <em>Statistical Algorithms Description Document</em>.
Affymetrix, Santa Clara.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>
<p>Kohl M. and Deigner H.P. (2010). Preprocessing of gene expression data by optimally 
robust estimators. <em>BMC Bioinformatics</em>, 11:583. 
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation 
in General Smoothly Parametrized Models. <em>Statistical Methods and Application</em>, 
<b>19</b>(3):333-354. 
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. <em>Statistical Methods and Applications</em> <b>17</b>(1) 13-40.
</p>


<h3>See Also</h3>

<p><code><a href="RobLox.html#topic+roblox">roblox</a></code>, <code><a href="RobLox.html#topic+rowRoblox">rowRoblox</a></code>,
<code><a href="affy.html#topic+AffyBatch-class">AffyBatch-class</a></code>, 
<code><a href="affy.html#topic+generateExprVal.method.avgdiff">generateExprVal.method.mas</a></code>,
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet-class</a></code>,
<code><a href="beadarray.html#topic+summarize">summarize</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # to have reproducible results for package checking

## similar to rowRoblox of package RobLox
ind &lt;- rbinom(200, size=1, prob=0.05)
X &lt;- matrix(rnorm(200, mean=ind*3, sd=(1-ind) + ind*9), nrow = 2)
robloxbioc(X)
robloxbioc(X, steps = 5)
robloxbioc(X, eps = 0.05)
robloxbioc(X, eps = 0.05, steps = 5)


## \donttest to reduce check time
## the function is designed for large scale problems
X &lt;- matrix(rnorm(50000*20, mean = 1), nrow = 50000)
system.time(robloxbioc(X))

## using Affymetrix data
## confer example to generateExprVal.method.mas
## A more worked out example can be found in the scripts folder
## of the package.
data(SpikeIn)
probes &lt;- pm(SpikeIn) 
mas &lt;- generateExprVal.method.mas(probes)
rl &lt;- 2^robloxbioc(log2(t(probes)))
concentrations &lt;- as.numeric(colnames(SpikeIn))
plot(concentrations, mas$exprs, log="xy", ylim=c(50,10000), type="b",
     ylab = "expression measures")
points(concentrations, rl[,1], pch = 20, col="orange", type="b")
legend("topleft", c("MAS", "roblox"), pch = c(1, 20))

## Affymetrix dilution data
library(affydata)
data(Dilution)
eset &lt;- robloxbioc(Dilution)
## Affymetrix scale normalization
eset1 &lt;- robloxbioc(Dilution, normalize = TRUE)

## Illumina bead level data
library(beadarrayExampleData)
data(exampleBLData)
res &lt;- robloxbioc(exampleBLData, eps.upper = 0.5)
res

</code></pre>

<hr>
<h2 id='SimStudies'>Perform Monte-Carlo Study.</h2><span id='topic+AffySimStudy'></span><span id='topic+IlluminaSimStudy'></span>

<h3>Description</h3>

<p>The function <code>AffySimStudy</code> can be used to perform Monte-Carlo studies 
comparing Tukey's biweight and rmx estimators for normal location and scale. 
The function <code>IlluminaSimStudy</code> can be used to perform Monte-Carlo studies 
comparing Illumina's default method - a Huber-type skipped mean and sd 
(cf. Hampel (1985)) - and rmx estimators for normal location and scale.
In addition, maximum likelihood (ML) estimators (mean and sd) and median and 
MAD are computed. The comparison is based on the empirical MSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AffySimStudy(n, M, eps, seed = 123, eps.lower = 0, eps.upper = 0.05, 
             steps = 3L, fsCor = TRUE, contD, plot1 = FALSE, 
             plot2 = FALSE, plot3 = FALSE)
IlluminaSimStudy(n, M, eps, seed = 123, eps.lower = 0, eps.upper = 0.05, 
                 steps = 3L, fsCor = TRUE, contD, plot1 = FALSE, 
                 plot2 = FALSE, plot3 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimStudies_+3A_n">n</code></td>
<td>
<p>integer; sample size, should be at least 3.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_m">M</code></td>
<td>
<p>integer; Monte-Carlo replications.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_eps">eps</code></td>
<td>
<p>amount of contamination in [0, 0.5].</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_seed">seed</code></td>
<td>
<p>random seed.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_eps.lower">eps.lower</code></td>
<td>
<p>used by rmx estimator.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_eps.upper">eps.upper</code></td>
<td>
<p>used by rmx estimator.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_steps">steps</code></td>
<td>
<p>integer; steps used for estimator construction.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_fscor">fsCor</code></td>
<td>
<p>logical; use finite-sample correction.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_contd">contD</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code>; contaminating distribution.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_plot1">plot1</code></td>
<td>
<p>logical; plot cdf of ideal and real distribution.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_plot2">plot2</code></td>
<td>
<p>logical; plot 20 (or M if M &lt; 20) randomly selected samples.</p>
</td></tr>
<tr><td><code id="SimStudies_+3A_plot3">plot3</code></td>
<td>
<p>logical; generate boxplots of the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normal location and scale with mean = 0 and sd = 1 is used as ideal model (without
restriction due to equivariance).
</p>
<p>Since there is no estimator which yields reliable results if 50 percent or more of the
observations are contaminated, we use a modification where we re-simulate all samples
including at least 50 percent contaminated data.
</p>
<p>We use funtion <code><a href="RobLox.html#topic+rowRoblox">rowRoblox</a></code> for the computation of the rmx estimator.
</p>


<h3>Value</h3>

<p>Data.frame including empirical MSE (standardized by sample size n) and
relMSE with respect to the rmx estimator.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Affymetrix, Inc. (2002). <em>Statistical Algorithms Description Document</em>.
Affymetrix, Santa Clara.
</p>
<p>Hampel F.R. (1985). The breakdown points of the mean combined with some rejection
rules. Technometrics, 27(2):95-107.  
</p>


<h3>See Also</h3>

<p><code><a href="RobLox.html#topic+rowRoblox">rowRoblox</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # to have reproducible results for package checking

AffySimStudy(n = 11, M = 100, eps = 0.02, contD = Norm(mean = 0, sd = 3), 
             plot1 = TRUE, plot2 = TRUE, plot3 = TRUE)
IlluminaSimStudy(n = 30, M = 100, eps = 0.02, contD = Norm(mean = 0, sd = 3), 
                 plot1 = TRUE, plot2 = TRUE, plot3 = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
