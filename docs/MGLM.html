<!DOCTYPE html><html><head><title>Help for package MGLM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MGLM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MGLM-package'><p>MGLM: A package for multivariate response generalized linear models</p></a></li>
<li><a href='#AIC'><p>Akaike's Information Criterion (AIC)</p></a></li>
<li><a href='#BIC'><p>Bayesian information criterion (BIC)</p></a></li>
<li><a href='#coef'><p>Extract Model Coefficients</p></a></li>
<li><a href='#dist'>
<p>Details of the distributions</p></a></li>
<li><a href='#DMD.DM.fit'><p>Fit multivariate discrete distributions</p></a></li>
<li><a href='#dof'><p>Extract degrees of freedom</p></a></li>
<li><a href='#internals'><p>Internal Functions</p></a></li>
<li><a href='#kr'><p>Khatri-Rao product of two matrices</p></a></li>
<li><a href='#logLik'><p>Extract log-likelihood</p></a></li>
<li><a href='#maxlambda'><p>Extract maximum lambda</p></a></li>
<li><a href='#MGLM-deprecated'><p>Deprecated function(s) in the MGLM package</p></a></li>
<li><a href='#MGLMfit-class'><p>Class <code>"MGLMfit"</code></p></a></li>
<li><a href='#MGLMreg'><p>Fit multivariate response GLM regression</p></a></li>
<li><a href='#MGLMreg-class'><p>Class <code>"MGLMreg"</code></p></a></li>
<li><a href='#MGLMsparsereg'><p>Fit multivariate GLM sparse regression</p></a></li>
<li><a href='#MGLMsparsereg-class'><p>Class <code>"MGLMsparsereg"</code></p></a></li>
<li><a href='#MGLMtune'><p>Choose the tuning parameter value in sparse regression</p></a></li>
<li><a href='#MGLMtune-class'><p>Class <code>"MGLMtune"</code></p></a></li>
<li><a href='#path'><p>Extract path</p></a></li>
<li><a href='#predict'><p>Predict method for MGLM Fits</p></a></li>
<li><a href='#rdirmn'><p>The Dirichlet Multinomial Distribution</p></a></li>
<li><a href='#rgdirmn'><p>The Generalized Dirichlet Multinomial Distribution</p></a></li>
<li><a href='#rmn'><p>The Multinomial Distribution</p></a></li>
<li><a href='#rnaseq'><p>RNA-seq count data</p></a></li>
<li><a href='#rnegmn'><p>The Negative Multinomial Distribution</p></a></li>
<li><a href='#show'><p>Show an object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Response Generalized Linear Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Yiwen Zhang &lt;zhangyiwen1015@gmail.com&gt; and Hua Zhou &lt;huazhou@ucla.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juhyun Kim &lt;juhkim111@ucla.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, parallel, stats4</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, plyr, reshape2, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions that (1) fit multivariate discrete distributions, (2) generate random numbers from multivariate discrete distributions, and (3) run regression and penalized regression on the multivariate categorical response data.  Implemented models include: multinomial logit model, Dirichlet multinomial model, generalized Dirichlet multinomial model, and negative multinomial model. Making the best of the minorization-maximization (MM) algorithm and Newton-Raphson method, we derive and implement stable and efficient algorithms to find the maximum likelihood estimates. On a multi-core machine, multi-threading is supported.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-13 23:12:59 UTC; juhyun-kim</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-13 23:32:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='MGLM-package'>MGLM: A package for multivariate response generalized linear models</h2><span id='topic+MGLM-package'></span>

<h3>Description</h3>

<p>The package provides functions that (1) fit multivariate discrete distributions, 
(2) generate random numbers from multivariate discrete distributions, and 
(3) run regression and penalized regression on the multivariate categorical response data. 
Implemented models include: multinomial logit model, Dirichlet multinomial model, 
generalized Dirichlet multinomial model, and negative multinomial model. 
Making the best of the minorization-maximization (MM) algorithm and Newton-Raphson method, 
we derive and implement stable and efficient algorithms to find the maximum likelihood estimates. 
On a multi-core machine, multi-threading is supported.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MGLM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0.9</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-12-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;">  GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0), methods, stats, parallel </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>

<hr>
<h2 id='AIC'>Akaike's Information Criterion (AIC)</h2><span id='topic+AIC'></span><span id='topic+AIC+2CMGLMfit-method'></span><span id='topic+AIC+2CMGLMreg-method'></span><span id='topic+AIC+2CMGLMsparsereg-method'></span><span id='topic+AIC+2CMGLMtune-method'></span>

<h3>Description</h3>

<p>Calculates the Akaike's information criterion (AIC) for a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMfit'
AIC(object)

## S4 method for signature 'MGLMreg'
AIC(object)

## S4 method for signature 'MGLMsparsereg'
AIC(object)

## S4 method for signature 'MGLMtune'
AIC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC_+3A_object">object</code></td>
<td>
<p>MGLM object. <code>"MGLMfit"</code>, <code>"MGLMreg"</code>,
<code>"MGLMsparsereg"</code>, or <code>"MGLMtune"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value with the corresponding AIC.
</p>
<p>For the class <code>"MGLMtune"</code>, the function returns AIC 
based on the optimal tuning parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(124)
n &lt;- 200
d &lt;- 4
alpha &lt;- rep(1, d-1)
beta &lt;- rep(1, d-1)
m &lt;- 50
Y &lt;- rgdirmn(n, m, alpha, beta)
gdmFit &lt;- MGLMfit(Y, dist="GDM")
AIC(gdmFit)
</code></pre>

<hr>
<h2 id='BIC'>Bayesian information criterion (BIC)</h2><span id='topic+BIC'></span><span id='topic+BIC+2CMGLMfit-method'></span><span id='topic+BIC+2CMGLMreg-method'></span><span id='topic+BIC+2CMGLMsparsereg-method'></span><span id='topic+BIC+2CMGLMtune-method'></span>

<h3>Description</h3>

<p>Calculates the Bayesian information criterion (BIC) for a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMfit'
BIC(object)

## S4 method for signature 'MGLMreg'
BIC(object)

## S4 method for signature 'MGLMsparsereg'
BIC(object)

## S4 method for signature 'MGLMtune'
BIC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC_+3A_object">object</code></td>
<td>
<p>MGLM object. <code>"MGLMfit"</code>, <code>"MGLMreg"</code>,
<code>"MGLMsparsereg"</code>, or <code>"MGLMtune"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value with the corresponding BIC.
</p>
<p>For the class <code>"MGLMtune"</code>, the function returns BIC 
based on the optimal tuning parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(124)
n &lt;- 200
d &lt;- 4
alpha &lt;- rep(1, d-1)
beta &lt;- rep(1, d-1)
m &lt;- 50
Y &lt;- rgdirmn(n, m, alpha, beta)
gdmFit &lt;- MGLMfit(Y, dist="GDM")
BIC(gdmFit)
</code></pre>

<hr>
<h2 id='coef'>Extract Model Coefficients</h2><span id='topic+coef'></span><span id='topic+coef+2CMGLMfit-method'></span><span id='topic+coef+2CMGLMreg-method'></span><span id='topic+coef+2CMGLMsparsereg-method'></span><span id='topic+coef+2CMGLMtune-method'></span>

<h3>Description</h3>

<p><code>coef</code> extracts estimated model coefficients of class. <code>coefficients</code> is an <em>alias</em> for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMfit'
coef(object)

## S4 method for signature 'MGLMreg'
coef(object)

## S4 method for signature 'MGLMsparsereg'
coef(object)

## S4 method for signature 'MGLMtune'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is meaningful. 
One of the following classes <code>"MGLMfit"</code>, <code>"MGLMreg"</code>,
<code>"MGLMsparsereg"</code>, <code>"MGLMtune"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method coef.
</p>


<h3>Value</h3>

<p>Coefficients extracted from the model object <code>object</code>.
</p>
<p>For the class <code>"MGLMtune"</code>, the function returns model coefficients 
based on the optimal tuning parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MGLM")
data("rnaseq")
data &lt;- rnaseq[, 1:6]
mnreg &lt;- MGLMreg(formula = cbind(X1, X2, X3, X4, X5, X6) ~ log(totalReads) + 
treatment + age + gender, data = rnaseq, dist = "MN")
coef(mnreg)
</code></pre>

<hr>
<h2 id='dist'>
Details of the distributions
</h2><span id='topic+dist'></span>

<h3>Description</h3>

<p>An object that specifies the distribution to be fitted by the <code>MGLMfit</code> function, or the regression model to be fitted by the <code>MGLMreg</code> or <code>MGLMsparsereg</code> functions.
Can be chosen from <code>"MN"</code>, <code>"DM"</code>, <code>"NegMN"</code>, or <code>"GDM"</code>.
</p>


<h3>Details</h3>



<h4>&quot;MN&quot;: Multinomial distribution</h4>

<p>A multinomial distribution models the counts of <code class="reqn">d</code> possible outcomes.
The counts of categories are negatively correlated. 
The density of a <code class="reqn">d</code> category count vector <code class="reqn">y</code> with parameter 
<code class="reqn">p=(p_1, \ldots, p_d)</code> is
</p>
<p style="text-align: center;"><code class="reqn">
P(y|p) = C_{y_1, \ldots, y_d}^{m} \prod_{j=1}^{d} p_j^{y_j},
</code>
</p>

<p>where <code class="reqn">m = \sum_{j=1}^d y_j</code>, <code class="reqn">0 &lt; p_j &lt; 1</code>, and <code class="reqn">\sum_{j=1}^d p_j = 1</code>. 
Here, <code class="reqn">C_k^n</code>, often read as &quot;<code class="reqn">n</code> choose <code class="reqn">k</code>&quot;, refers the number of <code class="reqn">k</code> combinations from a set of <code class="reqn">n</code> elements.
</p>
<p>The <code><a href="#topic+MGLMreg">MGLMreg</a></code> function with <code>dist="MN"</code> calculates the MLE of regression coefficients <code class="reqn">\beta_j</code> of the multinomial logit model, which has link function <code class="reqn">p_j = exp(X\beta_j)/(1 + \sum_{j=1}^{d-1} exp(X\beta_j))</code>, <code class="reqn">j=1,\ldots,d-1</code>. The <code><a href="#topic+MGLMsparsereg">MGLMsparsereg</a></code> function with <code>dist="MN"</code> fits regularized multinomial logit model.
</p>



<h4>&quot;DM&quot;: Dirichlet multinomial distribution</h4>

<p>When the multivariate count data exhibits over-dispersion, the traditional 
multinomial model is insufficient.  Dirichlet multinomial distribution models the
probabilities of the categories by a Dirichlet distribution.  
The density of a <code class="reqn">d</code> category count vector <code class="reqn">y</code>, with 
parameter <code class="reqn">\alpha = (\alpha_1, \ldots, \alpha_d)</code>,
<code class="reqn">\alpha_j &gt; 0</code>, is
</p>
<p style="text-align: center;"><code class="reqn"> 
  P(y|\alpha) = C_{y_1, \ldots, y_d}^{m} \prod_{j=1}^{d} 
  \frac{\Gamma(\alpha_j+y_j)}{\Gamma(\alpha_j)}
  \frac{\Gamma(\sum_{j'=1}^d \alpha_{j'})}{\Gamma(\sum_{j'=1}^d \alpha_{j'} + \sum_{j'=1}^d y_{j'})},
  </code>
</p>

<p>where <code class="reqn">m=\sum_{j=1}^d y_j</code>. Here, <code class="reqn">C_k^n</code>, often read as &quot;<code class="reqn">n</code> choose <code class="reqn">k</code>&quot;, 
refers the number of <code class="reqn">k</code> combinations from a set of <code class="reqn">n</code> elements.
</p>
<p>The <code><a href="#topic+MGLMfit">MGLMfit</a></code> function with <code>dist="DM"</code> calculates the maximum likelihood estimate (MLE) of <code class="reqn">(\alpha_1, \ldots, \alpha_d)</code>. The <code><a href="#topic+MGLMreg">MGLMreg</a></code> function with <code>dist="DM"</code> calculates the MLE of regression coefficients <code class="reqn">\beta_j</code> of the Dirichlet multinomial regression model, which has link function <code class="reqn">\alpha_j = exp(X\beta_j)</code>, <code class="reqn">j=1,\ldots,d</code>. The <code><a href="#topic+MGLMsparsereg">MGLMsparsereg</a></code> function with <code>dist="DM"</code> fits regularized Dirichlet multinomial regression model.
</p>



<h4>&quot;GDM&quot;: Generalized Dirichlet multinomial distribution</h4>

<p>The more flexible Generalized Dirichlet multinomial model can be used when the counts of categories have both positive and negative correlations. 
The probability mass of a count vector <code class="reqn">y</code> over <code class="reqn">m</code> trials with parameter
<code class="reqn">(\alpha, \beta)=(\alpha_1, \ldots, \alpha_{d-1}, \beta_1, \ldots, \beta_{d-1})</code>,
<code class="reqn">\alpha_j, \beta_j &gt; 0</code>, is
</p>
<p style="text-align: center;"><code class="reqn">
P(y|\alpha,\beta)
=C_{y_1, \ldots, y_d}^{m} \prod_{j=1}^{d-1} 
\frac{\Gamma(\alpha_j+y_j)}{\Gamma(\alpha_j)}
\frac{\Gamma(\beta_j+z_{j+1})}{\Gamma(\beta_j)}
\frac{\Gamma(\alpha_j+\beta_j)}{\Gamma(\alpha_j+\beta_j+z_j)}  ,
</code>
</p>

<p>where <code class="reqn">z_j = \sum_{k=j}^d y_k</code> and <code class="reqn">m=\sum_{j=1}^d y_j</code>. Here, <code class="reqn">C_k^n</code>, often read as &quot;<code class="reqn">n</code> choose <code class="reqn">k</code>&quot;, 
#' refers the number of <code class="reqn">k</code> combinations from a set of <code class="reqn">n</code> elements.
</p>
<p>The <code><a href="#topic+MGLMfit">MGLMfit</a></code> with <code>dist="GDM"</code> calculates the MLE of <code class="reqn">(\alpha, \beta)=(\alpha_1, \ldots, \alpha_{d-1}, \beta_1, \ldots, \beta_{d-1})</code>. The <code><a href="#topic+MGLMreg">MGLMreg</a></code> function with <code>dist="GDM"</code> calculates the MLE of regression coefficients <code class="reqn">\alpha_j, \beta_j</code> of the generalized Dirichlet multinomial regression model, which has link functions <code class="reqn">\alpha_j=exp(X\alpha_j)</code> and <code class="reqn">\beta_j=exp(X\beta_j)</code>, <code class="reqn">j=1, \ldots, d-1</code>. The <code><a href="#topic+MGLMsparsereg">MGLMsparsereg</a></code> function with <code>dist="GDM"</code> fits regularized generalized Dirichlet multinomial regression model.
</p>



<h4>&quot;NegMN&quot;: Negative multinomial distribution</h4>

<p>Both the multinomial distribution and Dirichlet multinomial distribution are good for 
negatively correlated counts.  When the counts of categories are positively 
correlated, the negative multinomial distribution is preferred.  
The probability mass function of a <code class="reqn">d</code> category count vector <code class="reqn">y</code> with parameter
<code class="reqn">(p_1, \ldots, p_{d+1}, \beta)</code>, <code class="reqn">\sum_{j=1}^{d+1} p_j=1</code>, <code class="reqn">p_j &gt; 0</code>, <code class="reqn">\beta &gt; 0</code>, is
</p>
<p style="text-align: center;"><code class="reqn">
P(y|p,\beta) =  C_{m}^{\beta+m-1}  C_{y_1, \ldots, y_d}^{m} 
\prod_{j=1}^d p_j^{y_j} p_{d+1}^\beta \\
= \frac{\beta_m}{m!}  C_{y_1, \ldots, y_d}^{m}  
\prod_{j=1}^d p_j^{y_j} p_{d+1}^\beta,
</code>
</p>

<p>where <code class="reqn">m = \sum_{j=1}^d y_j</code>. Here, <code class="reqn">C_k^n</code>, often read as &quot;<code class="reqn">n</code> choose <code class="reqn">k</code>&quot;, refers the number of <code class="reqn">k</code> combinations from a set of <code class="reqn">n</code> elements.
</p>
<p>The <code><a href="#topic+MGLMfit">MGLMfit</a></code> function with <code>dist="NegMN"</code> calculates the MLE of <code class="reqn">(p_1, \ldots, p_{d+1}, \beta)</code>. The <code><a href="#topic+MGLMreg">MGLMreg</a></code> function with <code>dist="NegMN"</code> and <code>regBeta=FALSE</code> calculates the MLE of regression coefficients <code class="reqn">(\alpha_1,\ldots,\alpha_d, \beta)</code> of the negative multinomial regression model, which has link function <code class="reqn">p_{d+1} = 1/(1 + \sum_{j=1}^d exp(X\alpha_j))</code>, <code class="reqn">p_j = exp(X\alpha_j) p_{d+1}</code>, <code class="reqn">j=1, \ldots, d</code>. When <code>dist="NegMN"</code> and <code>regBeta=TRUE</code>, the overdispersion parameter is linked to covariates via <code class="reqn">\beta=exp(X\alpha_{d+1})</code>, and the 
function <code>MGLMreg</code> outputs an estimated matrix of 
<code class="reqn">(\alpha_1, \ldots, \alpha_{d+1})</code>. The <code><a href="#topic+MGLMsparsereg">MGLMsparsereg</a></code> function with <code>dist="NegMN"</code> fits regularized negative multinomial regression model.
</p>



<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MGLMfit">MGLMfit</a></code>, <code><a href="#topic+MGLMreg">MGLMreg</a></code>, <code><a href="#topic+MGLMsparsereg">MGLMsparsereg</a></code>,
<code><a href="#topic+dmn">dmn</a></code>, <code><a href="#topic+ddirmn">ddirmn</a></code>, <code><a href="#topic+dgdirmn">dgdirmn</a></code>, <code><a href="#topic+dnegmn">dnegmn</a></code>
</p>

<hr>
<h2 id='DMD.DM.fit'>Fit multivariate discrete distributions</h2><span id='topic+DMD.DM.fit'></span><span id='topic+DMD.GDM.fit'></span><span id='topic+DMD.NegMN.fit'></span><span id='topic+MGLMfit'></span>

<h3>Description</h3>

<p>Fit the specified multivariate discrete distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DMD.DM.fit(
  data,
  init,
  weight,
  epsilon = 1e-08,
  maxiters = 150,
  display = FALSE
)

DMD.GDM.fit(
  data,
  init,
  weight,
  epsilon = 1e-08,
  maxiters = 150,
  display = FALSE
)

DMD.NegMN.fit(
  data,
  init,
  weight,
  epsilon = 1e-08,
  maxiters = 150,
  display = FALSE
)

MGLMfit(
  data,
  dist,
  init,
  weight,
  epsilon = 1e-08,
  maxiters = 150,
  display = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DMD.DM.fit_+3A_data">data</code></td>
<td>
<p>a data frame or matrix containing the count data. 
Rows of the matrix represent observations and columns are the categories. 
Rows and columns of all zeros are automatically removed.</p>
</td></tr>
<tr><td><code id="DMD.DM.fit_+3A_init">init</code></td>
<td>
<p>an optional vector of initial value of the parameter estimates. Should have the same dimension as the estimated parameters. See <code><a href="#topic+dist">dist</a></code> for details.</p>
</td></tr>
<tr><td><code id="DMD.DM.fit_+3A_weight">weight</code></td>
<td>
<p>an optional vector of weights assigned to each row of the data. Should be Null or a numeric vector with the length equal to the number of rows of <code>data</code>. 
If <code>weight=NULL</code>, equal weights of all ones will be assigned.</p>
</td></tr>
<tr><td><code id="DMD.DM.fit_+3A_epsilon">epsilon</code></td>
<td>
<p>an optional numeric controlling the stopping criterion. The algorithm terminates when the relative change in the log-likelihoods of two successive iterates is less than <code>epsilon</code>. The default value is <code>epsilon=1e-8</code>.</p>
</td></tr>
<tr><td><code id="DMD.DM.fit_+3A_maxiters">maxiters</code></td>
<td>
<p>an optional number controlling the maximum number of iterations. The default value is <code>maxiters=150</code>.</p>
</td></tr>
<tr><td><code id="DMD.DM.fit_+3A_display">display</code></td>
<td>
<p>an optional logical variable controlling the display of iterations. The default value is FALSE.</p>
</td></tr>
<tr><td><code id="DMD.DM.fit_+3A_dist">dist</code></td>
<td>
<p>a description of the distribution to fit. Choose from <code>"MN"</code>, <code>"DM"</code>, <code>"GDM"</code>, <code>"NegMN"</code>. See <code><a href="#topic+dist">dist</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+dist">dist</a></code> for details about model parameterization.
</p>


<h3>Value</h3>

<p>Returns an object of S4 class <code>"MGLMfit"</code>. An object of class <code>"MGLMfit"</code> is a list containing at least the following components: </p>

<ul>
<li><p><code>estimate</code> the vector of the distribution prameter estimates.
</p>
</li>
<li><p><code>SE</code> the vector of standard errors of the estimates.
</p>
</li>
<li><p><code>vcov</code> the variance-covariance matrix of the estimates.
</p>
</li>
<li><p><code>logL</code> the loglikelihood value.
</p>
</li>
<li><p><code>iter</code> the number of iterations used.
</p>
</li>
<li><p><code>BIC</code> Bayesian information criterion.
</p>
</li>
<li><p><code>AIC</code> Akaike information criterion.
</p>
</li>
<li><p><code>distribution</code> the distribution fitted.
</p>
</li>
<li><p><code>LRT</code> when <code>dist="DM"</code> or <code>"GDM"</code>, it is the likelihood ratio test statistic for comparing the current model to the multinomial model. No LRT provided when <code>dist="NegMN"</code>. 
</p>
</li>
<li><p><code>LRTpvalue</code> the likelihood ratio test P value.
</p>
</li>
<li><p><code>gradient</code> the gradient at the estimated parameter values.
</p>
</li>
<li><p><code>DoF</code> the degrees of freedom of the model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rnaseq)
Y &lt;- as.matrix(rnaseq[, 1:6])
fit &lt;- MGLMfit(data=Y, dist="GDM") 


</code></pre>

<hr>
<h2 id='dof'>Extract degrees of freedom</h2><span id='topic+dof'></span><span id='topic+dof+2CMGLMsparsereg-method'></span>

<h3>Description</h3>

<p><code>dof</code> extracts the degrees of freedom of the estimated parameter 
from the object of class <code>MGLMsparsereg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMsparsereg'
dof(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dof_+3A_object">object</code></td>
<td>
<p>an object of class <code>MGLMsparsereg</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns degrees of freedom of <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MGLM")
dist &lt;- "DM"
n &lt;- 100
p &lt;- 10
d &lt;- 5
set.seed(118)
m &lt;- rbinom(n, 200, 0.8)
X &lt;- matrix(rnorm(n * p), n, p)
alpha &lt;- matrix(0, p, d)
alpha[c(1, 3, 5), ] &lt;- 1
Alpha &lt;- exp(X %*% alpha)
Y &lt;- rdirmn(size = m, alpha = Alpha)
pen &lt;- "group"
ngridpt &lt;- 30
spmodelfit &lt;- MGLMsparsereg(formula = Y ~ 0 + X, dist = dist, 
                            lambda = Inf, penalty = pen)
df &lt;- dof(spmodelfit)
</code></pre>

<hr>
<h2 id='internals'>Internal Functions</h2><span id='topic+dmultn'></span><span id='topic+glm.private'></span><span id='topic+matrix_threshold'></span><span id='topic+lsq_threshold'></span><span id='topic+svt'></span><span id='topic+lsq_thresholding'></span><span id='topic+objfun'></span><span id='topic+objfun.grad'></span><span id='topic+objfun.hessian'></span><span id='topic+MGLM.loss'></span>

<h3>Description</h3>

<p>These functions are for internal use only or not yet documented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmultn(X,Y,B1, weight)
glm.private(Y, start=NULL, weights, X, family)
matrix_threshold(X, lambda, penalty)
lsq_thresholding(b, lambda)
svt(b, lambda)
objfun(alpha, x, y, d, p)
objfun.grad(alpha, x, y, d, p)
objfun.hessian(alpha, x, y, d, p)
MGLM.loss(Y, X, beta, dist, weight, regBeta = FALSE, Beta) 
</code></pre>


<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou</p>

<hr>
<h2 id='kr'>Khatri-Rao product of two matrices</h2><span id='topic+kr'></span>

<h3>Description</h3>

<p>Return the Khatri-Rao product of two matrices, which is a column-wise Kronecker product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kr(A, B, w, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kr_+3A_a">A</code>, <code id="kr_+3A_b">B</code></td>
<td>
<p>matrices. The two matrices <code>A</code> and <code>B</code> should have the same number of columns.
We also give the user an option to do row-wise Kronecker product, to avoid transpose.  
When doing row-wise Kronecker product, the number of rows of A and B should be the same.</p>
</td></tr>
<tr><td><code id="kr_+3A_w">w</code></td>
<td>
<p>the weights vector. The length of the vector should match with the dimension of the matrices.
If performing column-wise Kronecker product, the length of w should be the same as the column number of A and B.  
If performing row-wise Kronecker prodoct, the length of w should be the same as the row number of A and B. 
The default is a vector of 1 if no value provided.</p>
</td></tr>
<tr><td><code id="kr_+3A_byrow">byrow</code></td>
<td>
<p>a logical variable controlling whether to perform row/column-wise Kronecker product.
The default is <code>byrow</code>=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The column/row-wise Kronecker product.
</p>


<h3>Value</h3>

<p>A matrix of the Khatri-Rao product.
</p>


<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(30), 10, 3)
Y &lt;- matrix(runif(50), 10, 5)
C &lt;- kr(X, Y)

</code></pre>

<hr>
<h2 id='logLik'>Extract log-likelihood</h2><span id='topic+logLik'></span><span id='topic+logLik+2CMGLMfit-method'></span><span id='topic+logLik+2CMGLMreg-method'></span><span id='topic+logLik+2CMGLMsparsereg-method'></span>

<h3>Description</h3>

<p><code>logLik</code> extracts log-likelihood for classes <code>"MGLMfit"</code>, 
<code>"MGLMreg"</code>, <code>"MGLMsparsereg"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMfit'
logLik(object)

## S4 method for signature 'MGLMreg'
logLik(object)

## S4 method for signature 'MGLMsparsereg'
logLik(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>an object from which a log-likelihood value can be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a log-likelihood value of <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MGLM")
data("rnaseq")
data &lt;- rnaseq[, 1:6]
dmFit &lt;- MGLMfit(data, dist = "DM")
logLik(dmFit)
</code></pre>

<hr>
<h2 id='maxlambda'>Extract maximum lambda</h2><span id='topic+maxlambda'></span><span id='topic+maxlambda+2CMGLMsparsereg-method'></span>

<h3>Description</h3>

<p><code>maxlambda</code> extracts the maximum tuning parameter that ensures 
the estimated regression coefficients are not all zero for the object of class <code>MGLMsparsereg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMsparsereg'
maxlambda(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxlambda_+3A_object">object</code></td>
<td>
<p>an object of class <code>MGLMsparsereg</code> from which
maximum lambda value can be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a maximum lambda value of <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MGLM")
dist &lt;- "DM"
n &lt;- 100
p &lt;- 10
d &lt;- 5
set.seed(118)
m &lt;- rbinom(n, 200, 0.8)
X &lt;- matrix(rnorm(n * p), n, p)
alpha &lt;- matrix(0, p, d)
alpha[c(1, 3, 5), ] &lt;- 1
Alpha &lt;- exp(X %*% alpha)
Y &lt;- rdirmn(size = m, alpha = Alpha)
pen &lt;- "group"
ngridpt &lt;- 30
spmodelfit &lt;- MGLMsparsereg(formula = Y ~ 0 + X, dist = dist, 
                            lambda = Inf, penalty = pen)
maxlambda &lt;- maxlambda(spmodelfit)
</code></pre>

<hr>
<h2 id='MGLM-deprecated'>Deprecated function(s) in the MGLM package</h2><span id='topic+MGLM-deprecated'></span><span id='topic+ddirm'></span><span id='topic+dgdirm'></span><span id='topic+dneg'></span><span id='topic+rdirm'></span><span id='topic+rgdirm'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older version of
the yourPackageName package.  They may eventually be completely
removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirm(...)

rdirm(...)

dgdirm(...)

rgdirm(...)

dneg(Y, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MGLM-deprecated_+3A_...">...</code></td>
<td>
<p>parameters to be passed to the modern version of the function</p>
</td></tr>
<tr><td><code id="MGLM-deprecated_+3A_y">Y</code>, <code id="MGLM-deprecated_+3A_alpha">alpha</code>, <code id="MGLM-deprecated_+3A_beta">beta</code></td>
<td>
<p>for functions <code>dnegmn</code>, note the change in argument order. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
  <code>ddirm</code> </td><td style="text-align: left;"> now a synonym for <code><a href="#topic+ddirmn">ddirmn</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>dgdirm</code> </td><td style="text-align: left;"> now a synonym for <code><a href="#topic+dgdirmn">dgdirmn</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>dneg</code> </td><td style="text-align: left;"> now a synonym for <code><a href="#topic+dnegmn">dnegmn</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>rdirm</code> </td><td style="text-align: left;"> now a synonym for <code><a href="#topic+rdirmn">rdirmn</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>rgdirm</code> </td><td style="text-align: left;"> now a synonym for <code><a href="#topic+rgdirmn">rgdirmn</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>The function <code>dneg</code> has been deprecated. Use <code>dnegmn</code> instead.
</p>
<p>Note the change in argument order: 
<code>dneg(Y, prob, beta)</code> and <code>dnegmn(Y, alpha, beta)</code> from MGLM_0.0.8 have been deprecated;
use <code>dnegmn(Y, beta, prob = alpha/(rowSums(alpha)+1), alpha=NULL)</code> instead.
</p>

<hr>
<h2 id='MGLMfit-class'>Class <code>"MGLMfit"</code></h2><span id='topic+MGLMfit-class'></span>

<h3>Description</h3>

<p>A class containing the model fitting results from the <code>MGLMfit</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>estimate</code></dt><dd><p>object of class <code>"vector"</code>, containing the parameter estimates.</p>
</dd>
<dt><code>SE</code></dt><dd><p>object of class <code>"vector"</code>,
containing the standard errors of the estimates.</p>
</dd>
<dt><code>vcov</code></dt><dd><p>object of class <code>"matrix"</code>,
the variance covariance matrix of the parameter estimates.</p>
</dd>
<dt><code>logL</code></dt><dd><p>object of class <code>"numeric"</code>, 
the fitted log likelihood.</p>
</dd>
<dt><code>BIC</code></dt><dd><p>object of class <code>"numeric"</code>, 
Bayesian information criterion.</p>
</dd>
<dt><code>AIC</code></dt><dd><p>object of class <code>"numeric"</code>,
Akaike information criterion.</p>
</dd>
<dt><code>LRTpvalue</code></dt><dd><p>object of class <code>"numeric"</code>,
likelihood ratio test p value.</p>
</dd>
<dt><code>gradient</code></dt><dd><p>object of class <code>"numeric"</code> or <code>"matrix"</code>,
containing the gradient.</p>
</dd>
<dt><code>iter</code></dt><dd><p>object of class <code>"numeric"</code>, 
number of iteration used.</p>
</dd>
<dt><code>distribution</code></dt><dd><p>object of class <code>"character"</code>,
the distribution fitted.</p>
</dd>
<dt><code>fitted</code></dt><dd><p>object of class <code>"vector"</code>,
the fitted mean of each category.</p>
</dd>
<dt><code>LRT</code></dt><dd><p>object of class <code>"numeric"</code>, 
the likelihood ratio test statistic.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MGLMfit")

</code></pre>

<hr>
<h2 id='MGLMreg'>Fit multivariate response GLM regression</h2><span id='topic+MGLMreg'></span><span id='topic+MGLMreg.fit'></span>

<h3>Description</h3>

<p><code>MGLMreg</code> fits multivariate response generalized linear models, specified by a symbolic description of the linear predictor and a description of the error distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGLMreg(
  formula,
  data,
  dist,
  init = NULL,
  weight = NULL,
  epsilon = 1e-08,
  maxiters = 150,
  display = FALSE,
  LRT = FALSE,
  parallel = FALSE,
  cores = NULL,
  cl = NULL,
  sys = NULL,
  regBeta = FALSE
)

MGLMreg.fit(
  Y,
  init = NULL,
  X,
  dist,
  weight = NULL,
  epsilon = 1e-08,
  maxiters = 150,
  display = FALSE,
  LRT = FALSE,
  parallel = FALSE,
  cores = NULL,
  cl = NULL,
  sys = NULL,
  regBeta = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MGLMreg_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced to that class): a symbolic description of the model to be fitted. The response has to be on the left hand side of ~.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in <code>data</code> when using function <code>MGLMreg</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>MGLMreg</code> is called.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_dist">dist</code></td>
<td>
<p>a description of the error distribution to fit. See <code><a href="#topic+dist">dist</a></code> for details.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_init">init</code></td>
<td>
<p>an optional matrix of initial value of the parameter estimates. Should have the compatible dimension with <code>data</code>. See <code><a href="#topic+dist">dist</a></code> for details of the dimensions in each distribution.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_weight">weight</code></td>
<td>
<p>an optional vector of weights assigned to each row of the data. Should be <code>NULL</code> or a numeric vector. Could be a variable from <code>data</code>, or a variable from <code>environment(formula)</code> with the length equal to the number of rows of the data. If <code>weight=NULL</code>, equal weights of ones will be assigned. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_epsilon">epsilon</code></td>
<td>
<p>an optional numeric controlling the stopping criterion. The algorithm terminates when the relative change in the loglikelihoods of two successive iterates is less than <code>epsilon</code>.  The default value is <code>epsilon=1e-8</code>.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_maxiters">maxiters</code></td>
<td>
<p>an optional numeric controlling the maximum number of iterations. The default value is <code>maxiters=150</code>.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_display">display</code></td>
<td>
<p>an optional logical variable controlling the display of iterations. The default value is <code>display=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_lrt">LRT</code></td>
<td>
<p>an optional logical variable controlling whether to perform likelihood ratio test on each predictor. The default value is <code>LRT=FALSE</code>, in which case only the Wald test is performed.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_parallel">parallel</code></td>
<td>
<p>an optional logical variable controlling whether to perform parallel computing. On a multi-core Windows machine, a cluster is created based on socket; on a multi-core Linux/Mac machine, a cluster is created based on forking. The default value is <code>parallel=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_cores">cores</code></td>
<td>
<p>an optional value specifying the number of cores to use. Default value is half of the logical cores.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_cl">cl</code></td>
<td>
<p>a cluster object, created by the package <span class="pkg">parallel</span> or by package <span class="pkg">snow</span>. If <code>parallel=TRUE</code>, use the registered default cluster; if <code>parallel=FALSE</code>, any given value to <code>cl</code> will be ignored.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_sys">sys</code></td>
<td>
<p>the operating system.  Will be used when choosing parallel type.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_regbeta">regBeta</code></td>
<td>
<p>an optional logical variable.  When <code>dist="NegMN"</code>, the user can decide whether to run regression on the overdispersion parameter <code class="reqn">\beta</code>.  The default is <code>regBeta=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MGLMreg_+3A_y">Y</code>, <code id="MGLMreg_+3A_x">X</code></td>
<td>
<p>for <code>MGLMreg.fit</code>, <code>X</code> is a design matrix of dimension <code>n*(p+1)</code> and <code>Y</code> is the response matrix of dimension <code>n*d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula should be in the form responses ~ covariates where the responses are the multivariate count matrix or a few columns from a data frame which is specified by <code>data</code>. The covariates are either matrices or from the data frame.  The covariates can be numeric or character or factor. 
See <code><a href="#topic+dist">dist</a></code> for details about distributions. 
</p>
<p>Instead of using the formula, the user can directly input the design matrix and the response vector using <code>MGLMreg.fit</code> function.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"MGLMreg"</code>. An object of class <code>"MGLMreg"</code> is a list containing the following components: </p>

<ul>
<li><p><code>coefficients</code> the estimated regression coefficients.
</p>
</li>
<li><p><code>SE</code> the standard errors of the estimates.
</p>
</li>
<li><p><code>Hessian</code> the Hessian at the estimated parameter values.
</p>
</li>
<li><p><code>gradient</code> the gradient at the estimated parameter values.
</p>
</li>
<li><p><code>wald.value</code> the Wald statistics.
</p>
</li>
<li><p><code>wald.p</code> the p values of Wald test.
</p>
</li>
<li><p><code>test</code> test statistic and the corresponding p-value. If <code>LRT=FALSE</code>, only returns test resultsfrom Wald test; if <code>LRT=TRUE</code>, returns the test results from both Wald test and likelihood ratio test.
</p>
</li>
<li><p><code>logL</code> the final loglikelihood.
</p>
</li>
<li><p><code>BIC</code> Bayesian information criterion. 
</p>
</li>
<li><p><code>AIC</code> Akaike information criterion.
</p>
</li>
<li><p><code>fitted</code> the fitted values from the regression model
</p>
</li>
<li><p><code>iter</code> the number of iterations used.
</p>
</li>
<li><p><code>call</code> the matched call.
</p>
</li>
<li><p><code>distribution</code> the distribution fitted.
</p>
</li>
<li><p><code>data</code> the data used to fit the model.
</p>
</li>
<li><p><code>Dof</code> degrees of freedom.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+MGLMfit">MGLMfit</a></code> for distribution fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##----------------------------------------##
## Generate data
n &lt;- 2000
p &lt;- 5
d &lt;- 4
m &lt;- rep(20, n)
set.seed(1234)
X &lt;- 0.1* matrix(rnorm(n*p),n, p)
alpha &lt;- matrix(1, p, d-1)
beta &lt;- matrix(1, p, d-1)
Alpha &lt;- exp(X %*% alpha)
Beta &lt;- exp(X %*% beta)
gdm.Y &lt;- rgdirmn(n, m, Alpha, Beta)

##----------------------------------------##
## Regression
gdm.reg &lt;- MGLMreg(gdm.Y~X, dist="GDM", LRT=FALSE)


</code></pre>

<hr>
<h2 id='MGLMreg-class'>Class <code>"MGLMreg"</code></h2><span id='topic+MGLMreg-class'></span>

<h3>Description</h3>

<p>Objects can be created by calls of the form <code>new("MGLMreg", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>object of class <code>"call"</code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>object of class <code>"list"</code> ,
consists of both the predictor matrix and the response matrix.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>object of class <code>"list"</code> or <code>"matrix"</code>,
the estimated parameters.</p>
</dd>
<dt><code>SE</code></dt><dd><p>object of class <code>"list"</code> or <code>"matrix"</code>,
the standard errors of the parameters.</p>
</dd>
<dt><code>test</code></dt><dd><p>object of class <code>"matrix"</code>,
the test statistics and p-values.</p>
</dd>
<dt><code>Hessian</code></dt><dd><p>object of class <code>"matrix"</code>,
the Hessian matrix.</p>
</dd>
<dt><code>logL</code></dt><dd><p>object of class <code>"numeric"</code>,
the loglikelihood.</p>
</dd>
<dt><code>BIC</code></dt><dd><p>object of class <code>"numeric"</code>,</p>
</dd>
<dt><code>AIC</code></dt><dd><p>object of class <code>"numeric"</code>,
Akaike information criterion.</p>
</dd>
<dt><code>iter</code></dt><dd><p>object of class <code>"numeric"</code>, 
the number of iteration used.</p>
</dd>
<dt><code>distribution</code></dt><dd><p>object of class <code>"character"</code>,
the distribution fitted.</p>
</dd>
<dt><code>fitted</code></dt><dd><p>object of class <code>"vector"</code>,
the fitted value.</p>
</dd>
<dt><code>gradient</code></dt><dd><p>object of class <code>"numeric"</code> or <code>"matrix"</code>,
the gradient at the estimated parameter values.</p>
</dd>
<dt><code>wald.value</code></dt><dd><p>object of class <code>"numeric"</code> or <code>"logical"</code>,
the Wald statistics.</p>
</dd>
<dt><code>wald.p</code></dt><dd><p>object of class <code>"numeric"</code> or <code>"logical"</code>,
the p values of Wald test.</p>
</dd>
<dt><code>Dof</code></dt><dd><p>object of class <code>"numeric"</code>, 
the degrees of freedom.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MGLMreg")

</code></pre>

<hr>
<h2 id='MGLMsparsereg'>Fit multivariate GLM sparse regression</h2><span id='topic+MGLMsparsereg'></span><span id='topic+MGLMsparsereg.fit'></span>

<h3>Description</h3>

<p>Fit sparse regression in multivariate generalized linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGLMsparsereg(
  formula,
  data,
  dist,
  lambda,
  penalty,
  weight,
  init,
  penidx,
  maxiters = 150,
  ridgedelta,
  epsilon = 1e-05,
  regBeta = FALSE,
  overdisp
)

MGLMsparsereg.fit(
  Y,
  X,
  dist,
  lambda,
  penalty,
  weight,
  init,
  penidx,
  maxiters = 150,
  ridgedelta,
  epsilon = 1e-05,
  regBeta = FALSE,
  overdisp
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MGLMsparsereg_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced
to that class): a symbolic description of the model to be fitted.
The response has to be on the left hand side of ~.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by 
<code>as.data.frame</code> to a data frame) containing the variables in the model.
If not found in <code>data</code> when using function <code>MGLMsparsereg</code>, the variables 
are taken from <code>environment(formula)</code>, typically the environment from
which <code>MGLMsparsereg</code> is called.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_dist">dist</code></td>
<td>
<p>a description of the error distribution to fit. See <code><a href="#topic+dist">dist</a></code> for details.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_lambda">lambda</code></td>
<td>
<p>penalty parameter.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_penalty">penalty</code></td>
<td>
<p>penalty type for the regularization term. Can be chosen from <code>"sweep"</code>, 
<code>"group"</code>, or <code>"nuclear"</code>. See Details for the description of each penalty type.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_weight">weight</code></td>
<td>
<p>an optional vector of weights assigned to each row of the data. 
Should be <code>NULL</code> or a numeric vector. Could be a variable from <code>data</code>, 
or a variable from <code>environment(formula)</code> with the length equal to
the number of rows of the data.
If <code>weight=NULL</code>, equal weights of ones will be assigned.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_init">init</code></td>
<td>
<p>an optional matrix of initial value of the parameter estimates.
Should have the compatible dimension with the data. See <code><a href="#topic+dist">dist</a></code> for
details of the dimensions in each distribution.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_penidx">penidx</code></td>
<td>
<p>a logical vector indicating the variables to be penalized. The default value is <code>rep(TRUE, p)</code>, which means all predictors are subject to regularization. If <code>X</code> contains intercept, use <code>penidx=c(FALSE,rep(TRUE,p-1))</code>.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_maxiters">maxiters</code></td>
<td>
<p>an optional numeric controlling the maximum number of iterations. The default
value is maxiters=150.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_ridgedelta">ridgedelta</code></td>
<td>
<p>an optional numeric controlling the behavior of the Nesterov's accelerated proximal gradient method. The default value is <code class="reqn">\frac{1}{pd}</code>.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_epsilon">epsilon</code></td>
<td>
<p>an optional numeric controlling the stopping criterion. The algorithm terminates when the relative change in the objective values of two successive iterates is less then <code>epsilon</code>.
The default value is <code>epsilon=1e-5</code>.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_regbeta">regBeta</code></td>
<td>
<p>an optional logical variable used when running negative multinomial regression (<code>dist="NegMN"</code>).
<code>regBeta</code> controls whether to run regression on the over-dispersion parameter.
The default is <code>regBeta=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_overdisp">overdisp</code></td>
<td>
<p>an optional numerical variable used only when fitting sparse negative multinomial 
model <code>dist="NegMN"</code> and <code>regBeta=FALSE</code>.  <code>overdisp</code> gives the over dispersion value
for all the observations.  The default value is estimated using negative-multinomial regression.  When <code>dist="MN", "DM", "GDM"</code> or <code>regBeta=TRUE</code>, the value of <code>overdisp</code> is ignored.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_y">Y</code></td>
<td>
<p>a matrix containing the multivariate categorical response data. 
Rows of the matrix represent observations, while columns are the different
categories.  Rows and columns of all zeros are automatically removed when
<code>dist="MN"</code>, <code>"DM"</code>, or <code>"GDM"</code>.</p>
</td></tr>
<tr><td><code id="MGLMsparsereg_+3A_x">X</code></td>
<td>
<p>design matrix (including intercept).
Number of rows of the matrix should match that of <code>Y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, we consider regularization problem
</p>
<p style="text-align: center;"><code class="reqn">
\min_B h(B) = -l(B)+ J(B),
</code>
</p>

<p>where <code class="reqn">l(B)</code> is the loglikelihood function and <code class="reqn">J(B)</code> is the 
regularization function.  
</p>
<p>Sparsity in the individual elements of the parameter matrix <code class="reqn">B</code> is achieved 
by the lasso penalty (<code>dist="sweep"</code>)
</p>
<p style="text-align: center;"><code class="reqn">
J(B) = \lambda \sum_{k\in penidx} \sum_{j=1}^d \|B_{kj}\|
</code>
</p>

<p>Sparsity in the rows of the regression parameter matrix <code class="reqn">B</code> is achieved
by the group penalty (<code>dist="group"</code>)
</p>
<p style="text-align: center;"><code class="reqn">
J(B) = \lambda \sum_{k \in penidx} \|B_{k \cdot}\|_2,
</code>
</p>

<p>where <code class="reqn">\|v\|_2</code> is the <code class="reqn">l_2</code> norm of a vector <code class="reqn">v</code>. In other words, 
<code class="reqn">\|B_{k\cdot}\|_2</code> is the <code class="reqn">l_2</code> norm of the <code class="reqn">k</code>-th row of the 
parameter matrix <code class="reqn">B</code>.
</p>
<p>Sparsity in the rank of the parameter matrix <code class="reqn">B</code> is achieved by the nuclear norm penalty (<code>dist="nuclear"</code>)
</p>
<p style="text-align: center;"><code class="reqn">
J(B) = \lambda \|B\|_*= \lambda \sum_{i=1}^{min(p, d)} \sigma_i(B),
</code>
</p>

<p>where <code class="reqn">\sigma_i(B)</code> are the singular values of the parameter matrix <code class="reqn">B</code>. 
The nuclear norm <code class="reqn">\|B\|_*</code> is a convex relaxation of <code class="reqn">rank(B)=\|\sigma(B)\|_0</code>.
</p>
<p>See <code><a href="#topic+dist">dist</a></code> for details about distributions.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"MGLMsparsereg"</code>. An object of class <code>"MGLMsparsereg"</code> is a list containing at least the following components:  </p>

<ul>
<li><p><code>coefficients</code> the estimated matrix of regression coefficients.
</p>
</li>
<li><p><code>logL</code> the final loglikelihood value.
</p>
</li>
<li><p><code>AIC</code> Akaike information criterion.
</p>
</li>
<li><p><code>BIC</code> Bayesian information criterion.
</p>
</li>
<li><p><code>Dof</code> degrees of freedom of the estimated parameter.
</p>
</li>
<li><p><code>iter</code> number of iterations used. 
</p>
</li>
<li><p><code>maxlambda</code> the maxmum tuning parameter such that 
the estimated coefficients are not all zero.  This value is returned only
when the tuning parameter <code>lambda</code> given to the function is large enough 
such that all the parameter estimates are zero; otherwise, <code>maxlambda</code>
is not computed.
</p>
</li>
<li><p><code>call</code> a matched call.
</p>
</li>
<li><p><code>data</code> the data used to fit the model: a list of the predictor matrix
and the response matrix.
</p>
</li>
<li><p><code>penalty</code> the penalty chosen when running the penalized regression.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate Dirichlet Multinomial data
dist &lt;- "DM"
n &lt;- 100
p &lt;- 15
d &lt;- 5
m &lt;- runif(n, min=0, max=25) + 25
set.seed(134)
X &lt;- matrix(rnorm(n*p),n, p)
alpha &lt;- matrix(0, p, d)
alpha[c(1,3, 5), ] &lt;- 1
Alpha &lt;- exp(X%*%alpha)
Y &lt;- rdirmn(size=m, alpha=Alpha)

## Tuning
ngridpt &lt;- 10
p &lt;- ncol(X)
d &lt;- ncol(Y)
pen &lt;- 'nuclear'
spfit &lt;- MGLMsparsereg(formula=Y~0+X, dist=dist, lambda=Inf, penalty=pen)

</code></pre>

<hr>
<h2 id='MGLMsparsereg-class'>Class <code>"MGLMsparsereg"</code></h2><span id='topic+MGLMsparsereg-class'></span>

<h3>Description</h3>

<p>A class containing the results from the <code>MGLMsparsereg</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>object of class <code>"call"</code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>object of class <code>"list"</code> ,
consists of both the predictor matrix and the response matrix.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>object of class <code>"matrix"</code>,
the estimated parameters.</p>
</dd>
<dt><code>logL</code></dt><dd><p>object of class <code>"numeric"</code>,
the loglikelihood.</p>
</dd>
<dt><code>BIC</code></dt><dd><p>object of class <code>"numeric"</code>,</p>
</dd>
<dt><code>AIC</code></dt><dd><p>object of class <code>"numeric"</code>,
Akaike information criterion.</p>
</dd>
<dt><code>Dof</code></dt><dd><p>object of class <code>"numeric"</code>,
the degrees of freedom.</p>
</dd>
<dt><code>iter</code></dt><dd><p>object of class <code>"numeric"</code>, 
the number of iteration used.</p>
</dd>
<dt><code>maxlambda</code></dt><dd><p>object of class <code>"numeric"</code>,
the maximum tuning parameter that ensures the estimated regression coefficients are not all zero.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>object of class <code>"numeric"</code>,
the tuning parameter used.</p>
</dd>
<dt><code>distribution</code></dt><dd><p>object of class <code>"character"</code>,
the distribution fitted.</p>
</dd>
<dt><code>penalty</code></dt><dd><p>Object of class <code>"character"</code>,
the chosen penalty when running penalized regression.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MGLMsparsereg")
</code></pre>

<hr>
<h2 id='MGLMtune'>Choose the tuning parameter value in sparse regression</h2><span id='topic+MGLMtune'></span>

<h3>Description</h3>

<p>Finds the tuning parameter value that yields the smallest BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGLMtune(
  formula,
  data,
  dist,
  penalty,
  lambdas,
  ngridpt,
  warm.start = TRUE,
  keep.path = FALSE,
  display = FALSE,
  init,
  weight,
  penidx,
  ridgedelta,
  maxiters = 150,
  epsilon = 1e-05,
  regBeta = FALSE,
  overdisp
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MGLMtune_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced to that class): a symbolic description of the model to be fitted. The response has to be on the left hand side of ~.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in <code>data</code> when using function <code>MGLMtune</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>MGLMtune</code> is called.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_dist">dist</code></td>
<td>
<p>a description of the distribution to fit. See <code><a href="#topic+dist">dist</a></code> for the details.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_penalty">penalty</code></td>
<td>
<p>penalty type for the regularization term. Can be chosen from <code>"sweep"</code>, <code>"group"</code>, or <code>"nuclear"</code>. See <a href="#topic+MGLMsparsereg">MGLMsparsereg</a> for the description of each penalty type.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_lambdas">lambdas</code></td>
<td>
<p>an optional vector of the penalty values to tune.  If missing, the vector of penalty values will be set inside the function.  <code>ngridpt</code> must be provided if <code>lambdas</code> is missing.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_ngridpt">ngridpt</code></td>
<td>
<p>an optional numeric variable specifying the number of grid points to tune.  If <code>lambdas</code> is given, <code>ngridpt</code> will be ignored.  Otherwise, the maximum <code class="reqn">\lambda</code> is determined from the data.  The smallest <code class="reqn">\lambda</code>is set to <code class="reqn">1/n</code>, where <code class="reqn">n</code> is the sample size.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_warm.start">warm.start</code></td>
<td>
<p>an optional logical variable to specify whether to give warm start at each tuning grid point.  If <code>warm.start=TRUE</code>, the fitted sparse regression coefficients will be used as the initial value when fitting the sparseregression with the next tuning grid.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_keep.path">keep.path</code></td>
<td>
<p>an optional logical variable controling whether to output the whole solution path. The default is <code>keep.path=FALSE</code>. If <code>keep.path=TRUE</code>, the sparse regression result at each grid point will be kept, and saved in the output object <code>select.list</code>.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_display">display</code></td>
<td>
<p>an optional logical variable to specify whether to show each tuning step.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_init">init</code></td>
<td>
<p>an optional matrix of initial value of the parameter estimates. Should have the compatible dimension with the data. See <code><a href="#topic+dist">dist</a></code> for details of dimensions in each distribution.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_weight">weight</code></td>
<td>
<p>an optional vector of weights assigned to each row of the data. Should be <code>NULL</code> or a numeric vector. Could be a variable from the <code>data</code>, or a variable from <code>environment(formula)</code> with the length equal to the number of rows of the data. If <code>weight=NULL</code>, equal weights of ones will be assigned.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_penidx">penidx</code></td>
<td>
<p>a logical vector indicating the variables to be penalized. The default value is <code>rep(TRUE, p)</code>, which means all predictors are subject to regularization. If <code>X</code> contains intercept, use <code>penidx=c(FALSE,rep(TRUE,p-1))</code>.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_ridgedelta">ridgedelta</code></td>
<td>
<p>an optional numeric controlling the behavior of the Nesterov's accelerated proximal gradient method. The default value is <code class="reqn">\frac{1}{pd}</code>.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_maxiters">maxiters</code></td>
<td>
<p>an optional numeric controlling the maximum number of iterations. The default value is <code>maxiters=150</code>.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_epsilon">epsilon</code></td>
<td>
<p>an optional numeric controlling the stopping criterion. The algorithm terminates when the relative change in the objective values of two successive iterates is less then <code>epsilon</code>. The default value is <code>epsilon=1e-5</code>.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_regbeta">regBeta</code></td>
<td>
<p>an optional logical variable used when running negative multinomial regression (<code>dist="NegMN"</code>). <code>regBeta</code> controls whether to run regression on the over-dispersion parameter. The default is <code>regBeta=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MGLMtune_+3A_overdisp">overdisp</code></td>
<td>
<p>an optional numerical variable used only when fitting sparse negative multinomial model and <code>regBeta=FALSE</code>.  <code>overdisp</code> gives the over-dispersion value for all the observations.  The default value is estimated using negative-multinomial regression.  When <code>dist="MN", "DM", "GDM"</code> or <code>regBeta=TRUE</code>, the value of <code>overdisp</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>select</code> the final sparse regression result, using the optimal tuning parameter.
</p>
</li>
<li><p><code>path</code> a data frame with degrees of freedom and BICs at each lambda.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MGLMsparsereg">MGLMsparsereg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(118)
n &lt;- 50
p &lt;- 10
d &lt;- 5
m &lt;- rbinom(n, 100, 0.8)
X &lt;- matrix(rnorm(n * p), n, p)
alpha &lt;- matrix(0, p, d)
alpha[c(1, 3, 5), ] &lt;- 1
Alpha &lt;- exp(X %*% alpha)
Y &lt;- rdirmn(size=m, alpha=Alpha)
sweep &lt;- MGLMtune(Y ~ 0 + X, dist="DM", penalty="sweep", ngridpt=10)
show(sweep)


</code></pre>

<hr>
<h2 id='MGLMtune-class'>Class <code>"MGLMtune"</code></h2><span id='topic+MGLMtune-class'></span>

<h3>Description</h3>

<p>A class containing the results from the <code>MGLMtune</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>object of class <code>"call"</code>.</p>
</dd>
<dt><code>select</code></dt><dd><p>object of class <code>"MGLMsparsereg"</code>,
regularized regression results given by the optimal tuning parameter.</p>
</dd>
<dt><code>path</code></dt><dd><p>object of class <code>"data.frame"</code>,
the BIC, AIC, log-likelihood and degrees of freedom given each tuning parameter.</p>
</dd>
<dt><code>select.list</code></dt><dd><p>object of class <code>"list"</code>,
the regularized regression results at each tuning grid point.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MGLMtune")

</code></pre>

<hr>
<h2 id='path'>Extract path</h2><span id='topic+path'></span><span id='topic+path+2CMGLMtune-method'></span>

<h3>Description</h3>

<p><code>path</code> extracts from object of the class <code>MGLMtune</code> the path of 
BIC, AIC, log-likelihood and degrees of freedom given each tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMtune'
path(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_+3A_object">object</code></td>
<td>
<p>an object of class <code>MGLMtune</code> from which
path can be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a path of <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MGLM")
dist &lt;- "DM"
n &lt;- 100
p &lt;- 10
d &lt;- 5
set.seed(118)
m &lt;- rbinom(n, 200, 0.8)
X &lt;- matrix(rnorm(n * p), n, p)
alpha &lt;- matrix(0, p, d)
alpha[c(1, 3, 5), ] &lt;- 1
Alpha &lt;- exp(X %*% alpha)
Y &lt;- rdirmn(size = m, alpha = Alpha)
select &lt;- MGLMtune(Y ~ 0 + X, dist = "DM", penalty = "nuclear", 
ngridpt = 10, display = FALSE)
select_path &lt;- path(select)
</code></pre>

<hr>
<h2 id='predict'>Predict method for MGLM Fits</h2><span id='topic+predict'></span><span id='topic+predict+2CMGLMreg+2CANY-method'></span><span id='topic+predict+2CMGLMreg-method'></span><span id='topic+predict+2CMGLMreg'></span>

<h3>Description</h3>

<p>Predict using the fitted model from <code>MGLMreg</code> when given a new set of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMreg'
predict(object, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>new covariates data matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs the probabilities of each category.
</p>
<p>This helps answer questions such as whether certain features increase the probability of observing category j.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200
p &lt;- 5
d &lt;- 4
X &lt;- matrix(runif(p * n), n, p)
alpha &lt;- matrix(c(0.6, 0.8, 1), p, d - 1, byrow=TRUE)
alpha[c(1, 2),] &lt;- 0
Alpha &lt;- exp(X %*% alpha) 
beta &lt;- matrix(c(1.2, 1, 0.6), p, d - 1, byrow=TRUE)
beta[c(1, 2),] &lt;- 0
Beta &lt;- exp(X %*% beta)
m &lt;- runif(n, min=0, max=25) + 25
Y &lt;- rgdirmn(n, m, Alpha, Beta)
gdmReg &lt;- MGLMreg(Y~0+X, dist="GDM")
newX &lt;- matrix(runif(1*p), 1, p)
pred &lt;- predict(gdmReg, newX)

</code></pre>

<hr>
<h2 id='rdirmn'>The Dirichlet Multinomial Distribution</h2><span id='topic+rdirmn'></span><span id='topic+dirmn'></span><span id='topic+ddirmn'></span>

<h3>Description</h3>

<p><code>ddirmn</code> computes the log of the Dirichlet multinomial probability mass function.
<code>rdirmn</code> generates Dirichlet multinomially distributed random number vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirmn(n, size, alpha)

ddirmn(Y, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdirmn_+3A_n">n</code></td>
<td>
<p>number of random vectors to generate.  When <code>size</code> is a scalar and <code>alpha</code> is a vector, 
must specify <code>n</code>.  When <code>size</code> is a vector and <code>alpha</code> is a matrix, <code>n</code> is optional.
The default value of <code>n</code> is the length of <code>size</code>. If given, <code>n</code> should be equal to 
the length of <code>size</code>.</p>
</td></tr>
<tr><td><code id="rdirmn_+3A_size">size</code></td>
<td>
<p>a number or vector specifying the total number of objects that are put
into d categories in the Dirichlet multinomial distribution.</p>
</td></tr>
<tr><td><code id="rdirmn_+3A_alpha">alpha</code></td>
<td>
<p>the parameter of the Dirichlet multinomial distribution. Can be a numerical positive vector or matrix.
For <code>ddirmn</code>, <code>alpha</code> has to match the size of <code>Y</code>. If <code>alpha</code> 
is a vector, it will be replicated <code class="reqn">n</code> times to match the dimension of <code>Y</code>.
</p>
<p>For <code>rdirmn</code>, if <code>alpha</code> is a vector, <code>size</code> must be a scalar, and all the random vectors will
be drawn from the same <code>alpha</code> and <code>size</code>.  
If <code>alpha</code> is a matrix, the number of rows should match the length of 
<code>size</code>, and each random vector 
will be drawn from the corresponding row of <code>alpha</code> and the corresponding
element in the <code>size</code> vector. See Details below.</p>
</td></tr>
<tr><td><code id="rdirmn_+3A_y">Y</code></td>
<td>
<p>The multivariate count matrix with dimensions <code class="reqn">n \times d</code>, where 
<code class="reqn">n = 1,2, \ldots</code> is the number of observations and <code class="reqn">d=2,3, \ldots</code> is the number of categories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the multivariate count data exhibits over-dispersion, the traditional 
multinomial model is insufficient. Dirichlet multinomial distribution models the
probabilities of the categories by a Dirichlet distribution. 
Given the parameter vector <code class="reqn">\alpha = (\alpha_1, \ldots, \alpha_d), \alpha_j&gt;0  </code>, 
the probability mass of <code class="reqn">d</code>-category count vector <code class="reqn">Y=(y_1, \ldots, y_d)</code>, <code class="reqn">d \ge 2</code> 
under Dirichlet multinomial distribution is
</p>
<p style="text-align: center;"><code class="reqn">
 P(y|\alpha) = C_{y_1, \ldots, y_d}^{m} \prod_{j=1}^{d} 
 \frac{\Gamma(\alpha_j+y_j)}{\Gamma(\alpha_j)}
 \frac{\Gamma(\sum_{j'=1}^d \alpha_{j'})}{\Gamma(\sum_{j'=1}^d \alpha_{j'} + \sum_{j'=1}^d y_{j'})},
 </code>
</p>

<p>where <code class="reqn">m=\sum_{j=1}^d y_j</code>. Here, <code class="reqn">C_k^n</code>, often read as &quot;<code class="reqn">n</code> choose <code class="reqn">k</code>&quot;, 
refers the number of <code class="reqn">k</code> combinations from a set of <code class="reqn">n</code> elements.
</p>
<p>The parameter <code class="reqn">\alpha</code> can be a vector of length <code class="reqn">d</code>, 
such as the results from the distribution fitting.
<code class="reqn">\alpha</code> can also be a matrix with <code class="reqn">n</code> rows, such as the inverse link  
calculated from the regression parameter estimate <code class="reqn">exp(X\beta)</code>.
</p>


<h3>Value</h3>

<p>For each count vector and each corresponding parameter vector
<code class="reqn">\alpha</code>, the function <code>ddirmn</code> returns the value <code class="reqn">\log(P(y|\alpha))</code>. 
When <code>Y</code> is a matrix of <code class="reqn">n</code> rows, <code>ddirmn</code> returns a vector of length <code class="reqn">n</code>.
</p>
<p><code>rdirmn</code> returns a <code class="reqn">n\times d</code> matrix of the generated random observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 20
alpha &lt;- c(0.1, 0.2)
dm.Y &lt;- rdirmn(n=10, m, alpha)	
pdfln &lt;- ddirmn(dm.Y, alpha)
</code></pre>

<hr>
<h2 id='rgdirmn'>The Generalized Dirichlet Multinomial Distribution</h2><span id='topic+rgdirmn'></span><span id='topic+gdirmn'></span><span id='topic+dgdirmn'></span>

<h3>Description</h3>

<p><code>rgdirmn</code> generates random observations from the generalized Dirichlet multinomial distribution. 
<code>dgdirmn</code> computes the log of the generalized Dirichlet multinomial probability mass function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgdirmn(n, size, alpha, beta)

dgdirmn(Y, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgdirmn_+3A_n">n</code></td>
<td>
<p>the number of random vectors to generate.  When <code>size</code> is a scalar and <code>alpha</code> is a vector, 
must specify <code>n</code>.  When <code>size</code> is a vector and <code>alpha</code> is a matrix, <code>n</code> is optional.
The default value of <code>n</code> is the length of <code>size</code>. If given, <code>n</code> should be equal to 
the length of <code>size</code>.</p>
</td></tr>
<tr><td><code id="rgdirmn_+3A_size">size</code></td>
<td>
<p>a number or vector specifying the total number of objects that are put
into d categories in the generalized Dirichlet multinomial distribution.</p>
</td></tr>
<tr><td><code id="rgdirmn_+3A_alpha">alpha</code></td>
<td>
<p>the parameter of the generalized Dirichlet multinomial distribution. 
<code>alpha</code> is a numerical positive vector or matrix. 
</p>
<p>For <code>gdirmn</code>, <code>alpha</code> should match the size of <code>Y</code>. If <code>alpha</code> 
is a vector, it will be replicated <code class="reqn">n</code> times to match the dimension of <code>Y</code>. 
</p>
<p>For <code>rdirmn</code>, if <code>alpha</code> is a vector, <code>size</code> must be a scalar.  All the random vectors will
be drawn from the same <code>alpha</code> and <code>size</code>.  If <code>alpha</code> is a matrix, the 
number of rows should match the length of <code>size</code>.  Each random vector 
will be drawn from the corresponding row of <code>alpha</code> and the corresponding element of <code>size</code>.</p>
</td></tr>
<tr><td><code id="rgdirmn_+3A_beta">beta</code></td>
<td>
<p>the parameter of the generalized Dirichlet multinomial distribution. <code>beta</code> should
have the same dimension as <code>alpha</code>.
</p>
<p>For <code>rdirm</code>, if <code>beta</code> is a vector, <code>size</code> must be a scalar.  All the random samples will
be drawn from the same <code>beta</code> and <code>size</code>.  If <code>beta</code> is a matrix, the 
number of rows should match the length of <code>size</code>.  Each random vector 
will be drawn from the corresponding row of <code>beta</code> and the corresponding element of <code>size</code>.</p>
</td></tr>
<tr><td><code id="rgdirmn_+3A_y">Y</code></td>
<td>
<p>the multivariate count matrix with dimensions <code class="reqn">n \times d</code>, where 
<code class="reqn">n = 1,2, \ldots</code> is the number of observations and <code class="reqn">d=3,4,\ldots</code> is the number of categories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">Y=(y_1, \ldots, y_d)</code> are the <code class="reqn">d</code> category count vectors. Given the parameter vector <code class="reqn">\alpha = (\alpha_1, \ldots, \alpha_{d-1}),
\alpha_j&gt;0</code>, and <code class="reqn">\beta=(\beta_1, \ldots, \beta_{d-1}), \beta_j&gt;0</code>,
the generalized Dirichlet multinomial probability mass function is 
</p>
<p style="text-align: center;"><code class="reqn">
  P(y|\alpha,\beta)
  =C_{y_1, \ldots, y_d}^{m} \prod_{j=1}^{d-1} 
  \frac{\Gamma(\alpha_j+y_j)}{\Gamma(\alpha_j)}
  \frac{\Gamma(\beta_j+z_{j+1})}{\Gamma(\beta_j)}
  \frac{\Gamma(\alpha_j+\beta_j)}{\Gamma(\alpha_j+\beta_j+z_j)}  ,
</code>
</p>

<p>where <code class="reqn">z_j = \sum_{k=j}^d y_k</code> and <code class="reqn">m = \sum_{j=1}^d y_j</code>.
Here, <code class="reqn">C_k^n</code>, often read as &quot;<code class="reqn">n</code> choose <code class="reqn">k</code>&quot;, 
refers the number of <code class="reqn">k</code> combinations from a set of <code class="reqn">n</code> elements.
</p>
<p>The <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> parameters can be vectors, like the results from the 
distribution
fitting function, or they can be matrices with <code class="reqn">n</code> rows, 
like the estimate
from the regression function multiplied by the covariate matrix
<code class="reqn">exp(X\alpha)</code> and <code class="reqn">exp(X\beta)</code>
</p>


<h3>Value</h3>

<p><code>dgdirmn</code> returns the value of 
<code class="reqn">\log(P(y|\alpha, \beta))</code>. 
When <code>Y</code> is a matrix of <code class="reqn">n</code> rows, the function <code>dgdirmn</code> returns a vector of length <code class="reqn">n</code>. 
</p>
<p><code>rgdirmn</code> returns a <code class="reqn">n\times d</code> matrix of the generated random observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example 1
m &lt;- 20
alpha &lt;- c(0.2, 0.5)
beta &lt;- c(0.7, 0.4)
Y &lt;- rgdirmn(10, m, alpha, beta)
dgdirmn(Y, alpha, beta)

# example 2 
set.seed(100)
alpha &lt;- matrix(abs(rnorm(40)), 10, 4)
beta &lt;- matrix(abs(rnorm(40)), 10, 4)
size &lt;- rbinom(10, 10, 0.5)
GDM.rdm &lt;- rgdirmn(size=size, alpha=alpha, beta=beta)
GDM.rdm1 &lt;- rgdirmn(n=20, size=10, alpha=abs(rnorm(4)), beta=abs(rnorm(4)))
</code></pre>

<hr>
<h2 id='rmn'>The Multinomial Distribution</h2><span id='topic+rmn'></span><span id='topic+mn'></span><span id='topic+dmn'></span>

<h3>Description</h3>

<p><code>rmn</code> generates random number vectors given <code>alpha</code>. 
The function <code>rmn(n, size, alpha)</code> calls <code>rmultinom(n, size, prob)</code> after converting <code>alpha</code> to probability. 
<code>dmn</code> computes the log of multinomial probability mass function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmn(n, size, alpha)

dmn(Y, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmn_+3A_n">n</code></td>
<td>
<p>number of random vectors to generate.</p>
</td></tr>
<tr><td><code id="rmn_+3A_size">size</code></td>
<td>
<p>a scalar or a vector.</p>
</td></tr>
<tr><td><code id="rmn_+3A_alpha">alpha</code></td>
<td>
<p>a vector or a matrix.</p>
</td></tr>
<tr><td><code id="rmn_+3A_y">Y</code></td>
<td>
<p>the multivariate count matrix with dimension <code class="reqn">n \times d</code>, where 
<code class="reqn">n = 1,2,\ldots</code> is number of observations and <code class="reqn">d=2,\ldots</code> is number of categories.</p>
</td></tr>
<tr><td><code id="rmn_+3A_prob">prob</code></td>
<td>
<p>the probability parameter of the multinomial distribution.  <code>prob</code>
can be either a vector of length <code class="reqn">d</code> or a matrix with matching 
size of <code>Y</code>.  If <code>prob</code> is a vector, it will be replicated <code class="reqn">n</code> 
times to match the dimension of <code>Y</code>. If the sum(s) of <code>prob</code> is not 1, it will be automatically scaled to have sum 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multinomial distribution models the counts of <code class="reqn">d</code> possible outcomes.
The counts of categories are negatively correlated. 
<code class="reqn">y=(y_1, \ldots, y_d)</code> is a <code class="reqn">d</code> category count vector. 
Given the parameter vector <code class="reqn">p = (p_1, \ldots, p_d)</code>, <code class="reqn">0 &lt; p_j &lt; 1</code>, 
<code class="reqn">\sum_{j=1}^d p_j = 1</code>, the function calculates the log of the multinomial pmf
</p>
<p style="text-align: center;"><code class="reqn">
  P(y|p) = C_{y_1, \ldots, y_d}^{m} \prod_{j=1}^{d} p_j^{y_j},
</code>
</p>

<p>where <code class="reqn">m=\sum_{j=1}^d y_j</code>. Here, <code class="reqn">C_k^n</code>, often read as &quot;<code class="reqn">n</code> choose <code class="reqn">k</code>&quot;, 
refers the number of <code class="reqn">k</code> combinations from a set of <code class="reqn">n</code> elements.
</p>
<p>The parameter <code class="reqn">p</code> can be one vector, like the result from the distribution
fitting function; or, <code class="reqn">p</code> can be a matrix with <code class="reqn">n</code> rows, like the estimate
from the regression function, 
</p>
<p style="text-align: center;"><code class="reqn">p_j = \frac{exp(X \beta_j)}{1 + sum_{j'=1}^{d-1} exp(X\beta_{j'})},</code>
</p>
<p> where <code class="reqn">j=1,\ldots,d-1</code>
and <code class="reqn">p_d = \frac{1}{1 + \sum_{j'=1}^{d-1} exp(X\beta_{j'})}</code>.
The <code class="reqn">d</code>-th column of the coefficient matrix <code class="reqn">\beta</code> is set to <code class="reqn">0</code> to avoid the identifiability issue.
</p>


<h3>Value</h3>

<p>The function <code>dmn</code> returns the value of <code class="reqn">\log(P(y|p))</code>. 
When <code>Y</code> is a matrix of <code class="reqn">n</code> rows, the function returns a 
vector of length <code class="reqn">n</code>. 
</p>
<p>The function <code>rmn</code> returns multinomially distributed random number vectors
</p>


<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 20
prob &lt;- c(0.1, 0.2)
dm.Y &lt;- rdirmn(n=10, m, prob)	
pdfln &lt;- dmn(dm.Y, prob)
</code></pre>

<hr>
<h2 id='rnaseq'>RNA-seq count data</h2><span id='topic+rnaseq'></span>

<h3>Description</h3>

<p>RNA-seq data simulated following the standard procedures
(provided by Dr. Wei Sun, weisun@email.unc.edu).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnaseq</code></pre>


<h3>Format</h3>

<p>A data frame containing 10 columns and 100 rows. 
The first 6 columns are the expression counts of 6 exons of a 
gene; the last four columns are the covariates:
age, gender, treatment, and total number of reads.
</p>


<h3>Source</h3>

<p>Dr. Sun Wei, weisun@email.unc.edu</p>

<hr>
<h2 id='rnegmn'>The Negative Multinomial Distribution</h2><span id='topic+rnegmn'></span><span id='topic+negmn'></span><span id='topic+dnegmn'></span>

<h3>Description</h3>

<p><code>dnegmn</code> calculates the log of the negative multinomial probability mass function. 
<code>rnegmn</code> generates random observations from the negative multinomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnegmn(n, beta, prob)

dnegmn(Y, beta, prob = alpha/(rowSums(alpha) + 1), alpha = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnegmn_+3A_n">n</code></td>
<td>
<p>number of random vectors to generate.  When <code>beta</code> is a scalar and <code>prob</code> is a vector, 
must specify <code>n</code>.  When <code>beta</code> is a vector and <code>prob</code> is a matrix, <code>n</code> is optional.
The default value of <code>n</code> is the length of <code>beta</code>. If given, <code>n</code> should be equal to 
the length of <code>beta</code>.</p>
</td></tr>
<tr><td><code id="rnegmn_+3A_beta">beta</code></td>
<td>
<p>the over dispersion parameter of the negative multinomial distribution. <code>beta</code> can be either a scalar or a vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="rnegmn_+3A_prob">prob</code></td>
<td>
<p>the probability parameter of the negative multinomial distribution. Should be a numerical non-negative vector or matrix.
</p>
<p>For <code>dnegmn</code>, <code>prob</code> can be either
a vector of length <code class="reqn">d</code> <code class="reqn">(d \ge 2)</code> or a matrix with matching size of <code>Y</code>.  
If <code>prob</code> is a vector, it will 
be replicated <code class="reqn">n</code> times to match the dimension of <code>Y</code>.  The sum
of each row of <code>prob</code> should be smaller than 1. 
</p>
<p>For <code>rnegmn</code>, If <code>prob</code> is a vector, <code>beta</code>
must be a scalar.  All the <code>n</code> random vectors will be drawn from the
same <code>prob</code> and <code>beta</code>.  If <code>prob</code> is a matrix, the number of rows should 
match the length of <code>beta</code>.  Each random vector will be drawn from
the corresponding row of <code>prob</code> and the corresponding element of <code>beta</code>. Each row of <code>prob</code> should have sum less than 1.</p>
</td></tr>
<tr><td><code id="rnegmn_+3A_y">Y</code></td>
<td>
<p>the multivariate response matrix of dimension <code class="reqn">n \times d</code>, 
where <code class="reqn">n = 1, 2, \ldots</code> is number of observations and <code class="reqn">d=2,3,\ldots</code> is number of categories.</p>
</td></tr>
<tr><td><code id="rnegmn_+3A_alpha">alpha</code></td>
<td>
<p>an alternative way to specify the probability. Default value is <code>NULL</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">y=(y_1, \ldots, y_d)</code> is a <code class="reqn">d</code> category vector. Given the parameter vector <code class="reqn">p= (p_1, \ldots, p_d)</code>,
<code class="reqn">p_{d+1} = 1/(1 + \sum_{j'=1}^d p_{j'})</code>, 
and <code class="reqn">\beta</code>, <code class="reqn">\beta&gt;0</code>, the negative multinomial probability mass function is 
</p>
<p style="text-align: center;"><code class="reqn">
  P(y|p,\beta) =  C_{m}^{\beta+m-1}  C_{y_1, \ldots, y_d}^{m} 
  \prod_{j=1}^d p_j^{y_j} p_{d+1}^\beta = \frac{\beta_m}{m!}  {m \choose y_1, \ldots, y_d} \prod_{j=1}^d p_j^{y_j} p_{d+1}^\beta,
</code>
</p>

<p>where <code class="reqn">m = \sum_{j=1}^d y_j</code>. Here, <code class="reqn">C_k^n</code>, often read as &quot;<code class="reqn">n</code> choose <code class="reqn">k</code>&quot;, 
refers the number of <code class="reqn">k</code> combinations from a set of <code class="reqn">n</code> elements.
</p>
<p><code>alpha</code> is an alternative way to specify the probability: 
</p>
<p style="text-align: center;"><code class="reqn">p_j = \frac{\alpha_j}{(1+\sum_{k=1}^{d} \alpha_k)}</code>
</p>
<p> for <code class="reqn">j=1,\ldots,d</code> and 
<code class="reqn">p_{d+1} = \frac{1}{(1+\sum_{k=1}^{d} \alpha_k)}</code>. 
</p>
<p>The parameter <code>prob</code> can be a vector and <code>beta</code> is a scalar; <code>prob</code> can also
be a matrix with <code class="reqn">n</code> rows, and <code>beta</code> is a vector of length <code class="reqn">n</code>
like the estimate from the regression function
multiplied by the covariate matrix.
</p>


<h3>Value</h3>

<p><code>dnegmn</code> returns the value of 
<code class="reqn">\log(P(y|p, \beta) )</code>.  When <code>Y</code> is a matrix of <code class="reqn">n</code> rows, the function
returns a vector of length <code class="reqn">n</code>.
</p>
<p><code>rnegmn</code> returns a <code class="reqn">n\times d</code> matrix of the generated random observations.
</p>


<h3>Author(s)</h3>

<p>Yiwen Zhang and Hua Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###-----------------------###
set.seed(128)
n &lt;- 100
d &lt;- 4
p &lt;- 5
a &lt;- -matrix(1,p,d)
X &lt;- matrix(runif(n*p), n, p )
alpha &lt;- exp(X%*%a)
prob &lt;- alpha/(rowSums(alpha)+1)
beta &lt;- exp(X%*%matrix(1,p)) 
Y &lt;- rnegmn(n, beta, prob)

###-----------------------###
m &lt;- 20
n &lt;- 10
p &lt;- 5
d &lt;- 6
a &lt;- -matrix(1,p,d)
X &lt;- matrix(runif(n*p), n, p )
alpha &lt;- exp(X%*%a)
prob &lt;- alpha/(rowSums(alpha)+1)
b &lt;- exp(X%*%rep(0.3,p)) 
Y &lt;- rnegmn(prob=prob, beta=rep(10, n))
dnegmn(Y, b, prob)

</code></pre>

<hr>
<h2 id='show'>Show an object</h2><span id='topic+show'></span><span id='topic+show+2CMGLMfit-method'></span><span id='topic+show+2CMGLMreg-method'></span><span id='topic+show+2CMGLMsparsereg-method'></span><span id='topic+show+2CMGLMtune-method'></span>

<h3>Description</h3>

<p>Display the object by printing its class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MGLMfit'
show(object)

## S4 method for signature 'MGLMreg'
show(object)

## S4 method for signature 'MGLMsparsereg'
show(object)

## S4 method for signature 'MGLMtune'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>an object to be printed. Should be of class <code>"MGLMfit"</code>, <code>"MGLMreg"</code>,
<code>"MGLMsparsereg"</code> or <code>"MGLMtune"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library("MGLM")
data("rnaseq")
data &lt;- rnaseq[, 1:6]
gdmFit &lt;- MGLMfit(data, dist = "GDM")
show(gdmFit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
