<!DOCTYPE html><html><head><title>Help for package SpecDetec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpecDetec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculateAffinityMatrix'><p>Calculate the affinity matrix based on the similarity matrix</p></a></li>
<li><a href='#clusterEstimatetNumber'><p>Estimate the number of possible clusters</p></a></li>
<li><a href='#convertToMatrixTimeSeries'><p>Converts the time series to position and value matrix</p></a></li>
<li><a href='#DEVICE1'><p>DEVICE1</p></a></li>
<li><a href='#DEVICE2'><p>DEVICE2</p></a></li>
<li><a href='#DEVICE3'><p>DEVICE3</p></a></li>
<li><a href='#DEVICE4'><p>DEVICE4</p></a></li>
<li><a href='#DEVICE5'><p>DEVICE5</p></a></li>
<li><a href='#DEVICE6'><p>DEVICE6</p></a></li>
<li><a href='#FTIR1'><p>FTIR1</p></a></li>
<li><a href='#FTIR2'><p>FTIR2</p></a></li>
<li><a href='#FTIR3'><p>FTIR3</p></a></li>
<li><a href='#FTIR4'><p>FTIR4</p></a></li>
<li><a href='#FTIR5'><p>FTIR5</p></a></li>
<li><a href='#FTIR6'><p>FTIR6</p></a></li>
<li><a href='#gaussianKernel'><p>Calculate Gaussian Kernel</p></a></li>
<li><a href='#generateEigenvectorMatrix'><p>Calculate the eigenvector of the affinity matrix</p></a></li>
<li><a href='#generateSimilarityMatrix'><p>Calculate Similarity Matrix</p></a></li>
<li><a href='#getClusterFact'><p>Get the Factor of the cluster position in relation to the matrix of eigenvectors</p></a></li>
<li><a href='#getClusterProd'><p>Get the Product of the cluster position in relation to the matrix of eigenvectors</p></a></li>
<li><a href='#getSpectralClusters'><p>Clustering with the smallest eigenvectors from eigenvector Matrix</p></a></li>
<li><a href='#Spec'><p>Calculate change points with spectral cluster</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Change Points Detection with Spectral Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate change point based on spectral clustering with the option to automatically calculate the number of clusters if this information is not available.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, abind</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-10-14 17:16:39 UTC; uzai_</td>
</tr>
<tr>
<td>Author:</td>
<td>Luis Uzai [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luis Uzai &lt;uzai_ff@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-10-19 14:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculateAffinityMatrix'>Calculate the affinity matrix based on the similarity matrix</h2><span id='topic+calculateAffinityMatrix'></span>

<h3>Description</h3>

<p>Calculate the affinity matrix based on the similarity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateAffinityMatrix(similarityMatrix, neighboorsNumber = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateAffinityMatrix_+3A_similaritymatrix">similarityMatrix</code></td>
<td>
<p>Matrix of similarity between all points in the time series</p>
</td></tr>
<tr><td><code id="calculateAffinityMatrix_+3A_neighboorsnumber">neighboorsNumber</code></td>
<td>
<p>Number of neighbors to consider affinity between nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the affinity matrix based on the similarity matrix
If the number of neighbors is equal to or greater than the 
similarity matrix then the similarity and affinity matrix are equal
</p>


<h3>Value</h3>

<p>Affinity matrix based on the similarity matrix
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='clusterEstimatetNumber'>Estimate the number of possible clusters</h2><span id='topic+clusterEstimatetNumber'></span>

<h3>Description</h3>

<p>Adaptation of the bartlett method of the speccalt package to 
estimate the number of clusters in the context of spectral 
clustering to detect change points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterEstimatetNumber(eigenvectorValues, tolerance, maxClusterNumber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterEstimatetNumber_+3A_eigenvectorvalues">eigenvectorValues</code></td>
<td>
<p>Eigenvector matrix based on the affinity matrix</p>
</td></tr>
<tr><td><code id="clusterEstimatetNumber_+3A_tolerance">tolerance</code></td>
<td>
<p>approximation to consider valid clusters</p>
</td></tr>
<tr><td><code id="clusterEstimatetNumber_+3A_maxclusternumber">maxClusterNumber</code></td>
<td>
<p>maximum number of calculable clusters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adaptation of the bartlett method of the speccalt package to 
estimate the number of clusters in the context of spectral 
clustering to detect change points
</p>


<h3>Value</h3>

<p>An estimated number of clusters
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='convertToMatrixTimeSeries'>Converts the time series to position and value matrix</h2><span id='topic+convertToMatrixTimeSeries'></span>

<h3>Description</h3>

<p>Converts the time series to position and value matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToMatrixTimeSeries(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertToMatrixTimeSeries_+3A_data">data</code></td>
<td>
<p>List of values corresponding to the time series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gets a list of values of any size and creates a key and 
value array of all positions
</p>


<h3>Value</h3>

<p>The key matrix and value of the time series.
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='DEVICE1'>DEVICE1</h2><span id='topic+DEVICE1'></span>

<h3>Description</h3>

<p>Derivation of RefrigerationDevices of the UCR Time Series Classification Repository
These problems were taken from data recorded as part of government sponsored study
called Powering the Nation.  The intention was to collect behavioural data about 
how consumers use electricity within the home to help reduce the UK's carbon 
footprint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEVICE1
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='DEVICE2'>DEVICE2</h2><span id='topic+DEVICE2'></span>

<h3>Description</h3>

<p>Derivation of RefrigerationDevices of the UCR Time Series Classification Repository
These problems were taken from data recorded as part of government sponsored study
called Powering the Nation.  The intention was to collect behavioural data about 
how consumers use electricity within the home to help reduce the UK's carbon 
footprint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEVICE2
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='DEVICE3'>DEVICE3</h2><span id='topic+DEVICE3'></span>

<h3>Description</h3>

<p>Derivation of RefrigerationDevices of the UCR Time Series Classification Repository
These problems were taken from data recorded as part of government sponsored study
called Powering the Nation.  The intention was to collect behavioural data about 
how consumers use electricity within the home to help reduce the UK's carbon 
footprint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEVICE3
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='DEVICE4'>DEVICE4</h2><span id='topic+DEVICE4'></span>

<h3>Description</h3>

<p>Derivation of RefrigerationDevices of the UCR Time Series Classification Repository
These problems were taken from data recorded as part of government sponsored study
called Powering the Nation.  The intention was to collect behavioural data about 
how consumers use electricity within the home to help reduce the UK's carbon 
footprint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEVICE4
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='DEVICE5'>DEVICE5</h2><span id='topic+DEVICE5'></span>

<h3>Description</h3>

<p>Derivation of RefrigerationDevices of the UCR Time Series Classification Repository
These problems were taken from data recorded as part of government sponsored study
called Powering the Nation.  The intention was to collect behavioural data about 
how consumers use electricity within the home to help reduce the UK's carbon 
footprint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEVICE5
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='DEVICE6'>DEVICE6</h2><span id='topic+DEVICE6'></span>

<h3>Description</h3>

<p>Derivation of RefrigerationDevices of the UCR Time Series Classification Repository
These problems were taken from data recorded as part of government sponsored study
called Powering the Nation.  The intention was to collect behavioural data about 
how consumers use electricity within the home to help reduce the UK's carbon 
footprint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEVICE6
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='FTIR1'>FTIR1</h2><span id='topic+FTIR1'></span>

<h3>Description</h3>

<p>Derivation of Meat of the UCR Time Series Classification Repository
Food spectrographs are used in chemometrics to classify food types, a task that has 
obvious applications in food safety and quality assurance. The classes are chicken, 
pork and turkey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTIR1
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='FTIR2'>FTIR2</h2><span id='topic+FTIR2'></span>

<h3>Description</h3>

<p>Derivation of Meat of the UCR Time Series Classification Repository
Food spectrographs are used in chemometrics to classify food types, a task that has 
obvious applications in food safety and quality assurance. The classes are chicken, 
pork and turkey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTIR2
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='FTIR3'>FTIR3</h2><span id='topic+FTIR3'></span>

<h3>Description</h3>

<p>Derivation of Meat of the UCR Time Series Classification Repository
Food spectrographs are used in chemometrics to classify food types, a task that has 
obvious applications in food safety and quality assurance. The classes are chicken, 
pork and turkey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTIR3
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='FTIR4'>FTIR4</h2><span id='topic+FTIR4'></span>

<h3>Description</h3>

<p>Derivation of Meat of the UCR Time Series Classification Repository
Food spectrographs are used in chemometrics to classify food types, a task that has 
obvious applications in food safety and quality assurance. The classes are chicken, 
pork and turkey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTIR4
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='FTIR5'>FTIR5</h2><span id='topic+FTIR5'></span>

<h3>Description</h3>

<p>Derivation of Meat of the UCR Time Series Classification Repository
Food spectrographs are used in chemometrics to classify food types, a task that has 
obvious applications in food safety and quality assurance. The classes are chicken, 
pork and turkey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTIR5
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='FTIR6'>FTIR6</h2><span id='topic+FTIR6'></span>

<h3>Description</h3>

<p>Derivation of Meat of the UCR Time Series Classification Repository
Food spectrographs are used in chemometrics to classify food types, a task that has 
obvious applications in food safety and quality assurance. The classes are chicken, 
pork and turkey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTIR6
</code></pre>


<h3>Format</h3>

<p>The format is:
Value        Class
1.063400     1
-0.953410     1
...
-0.596090     2 
...</p>

<hr>
<h2 id='gaussianKernel'>Calculate Gaussian Kernel</h2><span id='topic+gaussianKernel'></span>

<h3>Description</h3>

<p>Measure of similarity between two points represented by x1 and x2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussianKernel(x1, x2, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussianKernel_+3A_x1">x1</code></td>
<td>
<p>first valor to computate</p>
</td></tr>
<tr><td><code id="gaussianKernel_+3A_x2">x2</code></td>
<td>
<p>second valor to computate</p>
</td></tr>
<tr><td><code id="gaussianKernel_+3A_alpha">alpha</code></td>
<td>
<p>Alpha Measure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Measure of similarity between two points represented by x1 and x2
</p>


<h3>Value</h3>

<p>Measure of similarity between two points.
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='generateEigenvectorMatrix'>Calculate the eigenvector of the affinity matrix</h2><span id='topic+generateEigenvectorMatrix'></span>

<h3>Description</h3>

<p>Calculate the eigenvector of the affinity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateEigenvectorMatrix(affinityMatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateEigenvectorMatrix_+3A_affinitymatrix">affinityMatrix</code></td>
<td>
<p>Affinity matrix based on the similarity matrix 
based on key and value matrix of the  time series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the laplacian matrix based on the affinity matrix and 
calculates the auto values of the graph with the eigen function
</p>


<h3>Value</h3>

<p>Eigenvector matrix based on the affinity matrix
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='generateSimilarityMatrix'>Calculate Similarity Matrix</h2><span id='topic+generateSimilarityMatrix'></span>

<h3>Description</h3>

<p>Use some similarity measure to calculate the similarity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSimilarityMatrix(data, similarityMeasure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSimilarityMatrix_+3A_data">data</code></td>
<td>
<p>Key and value matrix of a time series</p>
</td></tr>
<tr><td><code id="generateSimilarityMatrix_+3A_similaritymeasure">similarityMeasure</code></td>
<td>
<p>Measure of similarity between two points represented by x1 and x2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use some similarity measure to calculate the similarity matrix
</p>


<h3>Value</h3>

<p>Matrix of similarity calculated from the key and value matrix.
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='getClusterFact'>Get the Factor of the cluster position in relation to the matrix of eigenvectors</h2><span id='topic+getClusterFact'></span>

<h3>Description</h3>

<p>Get the Factor of the cluster position in relation to the matrix of eigenvectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusterFact(eigenvectorValues, eigenvectorLengthLessOne, clusterNumber,
  reverseClusterNumber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClusterFact_+3A_eigenvectorvalues">eigenvectorValues</code></td>
<td>
<p>Eigenvector matrix based on the affinity matrix</p>
</td></tr>
<tr><td><code id="getClusterFact_+3A_eigenvectorlengthlessone">eigenvectorLengthLessOne</code></td>
<td>
<p>the eigenvector matrix size minus 1</p>
</td></tr>
<tr><td><code id="getClusterFact_+3A_clusternumber">clusterNumber</code></td>
<td>
<p>the cluster position number being tested</p>
</td></tr>
<tr><td><code id="getClusterFact_+3A_reverseclusternumber">reverseClusterNumber</code></td>
<td>
<p>the number of the inverse position of the cluster being tested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gets the factor of the value and its opposite in relation 
to the matrix of the eigenvectors
</p>


<h3>Value</h3>

<p>Factor of the cluster position in relation to the matrix of eigenvectors
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='getClusterProd'>Get the Product of the cluster position in relation to the matrix of eigenvectors</h2><span id='topic+getClusterProd'></span>

<h3>Description</h3>

<p>Get the Product of the cluster position in relation to the matrix of eigenvectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusterProd(eigenvectorValues, eigenvectorLengthLessOne, clusterNumber,
  reverseClusterNumber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClusterProd_+3A_eigenvectorvalues">eigenvectorValues</code></td>
<td>
<p>Eigenvector matrix based on the affinity matrix</p>
</td></tr>
<tr><td><code id="getClusterProd_+3A_eigenvectorlengthlessone">eigenvectorLengthLessOne</code></td>
<td>
<p>the eigenvector matrix size minus 1</p>
</td></tr>
<tr><td><code id="getClusterProd_+3A_clusternumber">clusterNumber</code></td>
<td>
<p>the cluster position number being tested</p>
</td></tr>
<tr><td><code id="getClusterProd_+3A_reverseclusternumber">reverseClusterNumber</code></td>
<td>
<p>the number of the inverse position of the cluster being tested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gets the product of the value and its opposite in relation 
to the matrix of the eigenvectors
</p>


<h3>Value</h3>

<p>Product of the cluster position in relation to the matrix of eigenvectors
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='getSpectralClusters'>Clustering with the smallest eigenvectors from eigenvector Matrix</h2><span id='topic+getSpectralClusters'></span>

<h3>Description</h3>

<p>Clustering with the smallest eigenvectors from eigenvector Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpectralClusters(eigenvectorMatrix, numberOfClusters = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSpectralClusters_+3A_eigenvectormatrix">eigenvectorMatrix</code></td>
<td>
<p>Eigenvector matrix based on the affinity matrix</p>
</td></tr>
<tr><td><code id="getSpectralClusters_+3A_numberofclusters">numberOfClusters</code></td>
<td>
<p>maximum number of clusters for prediction</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modified standard function present in kernlab to perform clustering with
graph spectrum using standard version of K-Means
</p>


<h3>Value</h3>

<p>K-Means Cluster Object
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>

<hr>
<h2 id='Spec'>Calculate change points with spectral cluster</h2><span id='topic+Spec'></span>

<h3>Description</h3>

<p>Calculate change point based on spectral clustering you have the option 
to automatically calculate the number of clusters if this information 
is not available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spec(data, neighboorsNumber = 5, tolerance = 0.01,
  maxNumberOfChangePoints = 19, estimationChangePointsNumber = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spec_+3A_data">data</code></td>
<td>
<p>List of values corresponding to the time series</p>
</td></tr>
<tr><td><code id="Spec_+3A_neighboorsnumber">neighboorsNumber</code></td>
<td>
<p>Number of neighbors to consider affinity between nodes</p>
</td></tr>
<tr><td><code id="Spec_+3A_tolerance">tolerance</code></td>
<td>
<p>approximation to consider valid clusters, used only for calculation of 
forecast of change points, default 0.01</p>
</td></tr>
<tr><td><code id="Spec_+3A_maxnumberofchangepoints">maxNumberOfChangePoints</code></td>
<td>
<p>maximum number of clusters for prediction : default 19</p>
</td></tr>
<tr><td><code id="Spec_+3A_estimationchangepointsnumber">estimationChangePointsNumber</code></td>
<td>
<p>predicted number of change points in the series, if null, 
is automatically calculated: default null</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate change point based on spectral clustering you have the option 
to automatically calculate the number of clusters if this information 
is not available. It uses the Gaussian Kernel for the calculation of 
affinity matrix and Kmeans for the spectral cluster, however, several 
other options can be used and the package must be customized to better 
suit the use.
</p>


<h3>Value</h3>

<p>Numerical array with the position of the change points in the time series
</p>


<h3>Author(s)</h3>

<p>Luis Gustavo Uzai
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- DEVICE1[, 1]
realChangePoints &lt;- c(which(diff(DEVICE1$Class) != 0)) 
calculateChangePoints &lt;- Spec(data, neighboorsNumber = 6, 
         tolerance = 0.005, estimationChangePointsNumber = 2)
minValue &lt;- -99999
maxValue &lt;- 99999
plot(data, type = "l", xlab = "x", ylab = "y")
for (r in 1:length(realChangePoints)) {
    lines(x = c(realChangePoints[r], realChangePoints[r]), 
          y = c(minValue, maxValue), lwd = 2, col = "red")
}
for (n in 1:length(calculateChangePoints)) {
 lines(x = c(calculateChangePoints[n], calculateChangePoints[n]), 
       y = c(minValue, maxValue), lwd = 2, col = "blue")
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
