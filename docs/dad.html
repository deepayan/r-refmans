<!DOCTYPE html><html><head><title>Help for package dad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dad-package'>
<p>Three-Way Data Analysis Through Densities</p></a></li>
<li><a href='#appendtofolderh'>
<p>Adds a data frame to a <code>folderh</code>.</p></a></li>
<li><a href='#as.data.frame.folder'>
<p>Folder to data frame</p></a></li>
<li><a href='#as.data.frame.folderh'>
<p>Hierarchic folder to data frame</p></a></li>
<li><a href='#as.data.frame.foldert'>
<p>foldert to data frame</p></a></li>
<li><a href='#as.folder'>
<p>Coerce to a folder</p></a></li>
<li><a href='#as.folder.data.frame'>
<p>Data frame to folder</p></a></li>
<li><a href='#as.folder.folderh'>
<p>Hierarchic folder to folder</p></a></li>
<li><a href='#as.folderh'>
<p>Coerce to a folderh</p></a></li>
<li><a href='#as.folderh.foldermtg'>
<p>Build a hierarchic folder from an object of class foldermtg</p></a></li>
<li><a href='#as.foldert'>
<p>Coerce to a foldert</p></a></li>
<li><a href='#as.foldert.array'>
<p>Data frame to foldert</p></a></li>
<li><a href='#as.foldert.data.frame'>
<p>Data frame to foldert</p></a></li>
<li><a href='#association+20measures'>
<p>Association measures between several categorical variables of a data frame</p></a></li>
<li><a href='#association+20measures+20for+20folder'>
<p>Association measures between categorical variables of the data frames of a folder</p></a></li>
<li><a href='#bandwidth.parameter'>
<p>Parameter of the normal reference rule</p></a></li>
<li><a href='#castles'>
<p>Alsacian castles by year of building</p></a></li>
<li><a href='#castles.dated'>
<p>Dated Alsacian castles</p></a></li>
<li><a href='#castles.nondated'>
<p>Non dated Alsacian castles</p></a></li>
<li><a href='#cor.folder'>
<p>Correlation matrices of a folder of data sets</p></a></li>
<li><a href='#cut.data.frame'>
<p>Change numeric variables into factors</p></a></li>
<li><a href='#cut.folder'>
<p>In a folder: change numeric variables into factors</p></a></li>
<li><a href='#ddchisqsym'>
<p>Distance between probability distributions of discrete variables given samples</p></a></li>
<li><a href='#ddchisqsympar'>
<p>Distance between discrete probability distributions given the probabilities on their common support</p></a></li>
<li><a href='#ddhellinger'>
<p>Distance between probability distributions of discrete variables given samples</p></a></li>
<li><a href='#ddhellingerpar'>
<p>Distance between discrete probability distributions given the probabilities on their common support</p></a></li>
<li><a href='#ddjeffreys'>
<p>Divergence between probability distributions of discrete variables given samples</p></a></li>
<li><a href='#ddjeffreyspar'>
<p>Distance between discrete probability distributions given the probabilities on their common support</p></a></li>
<li><a href='#ddjensen'>
<p>Divergence between probability distributions of discrete variables given samples</p></a></li>
<li><a href='#ddjensenpar'>
<p>Divergence between discrete probability distributions given the probabilities on their common support</p></a></li>
<li><a href='#ddlp'>
<p>Distance between probability distributions of discrete variables given samples</p></a></li>
<li><a href='#ddlppar'>
<p>Distance between discrete probability distributions given the probabilities on their common support</p></a></li>
<li><a href='#departments'><p>French departments and regions</p></a></li>
<li><a href='#discdd.misclass'>
<p>Misclassification ratio in functional discriminant analysis of discrete probability distributions.</p></a></li>
<li><a href='#discdd.predict'>
<p>Predicting the class of a group of individuals with discriminant analysis of probability distributions.</p></a></li>
<li><a href='#distl2d'>
<p><code class="reqn">L^2</code> distance between probability densities</p></a></li>
<li><a href='#distl2dnorm'>
<p><code class="reqn">L^2</code> distance between <code class="reqn">L^2</code>-normed probability densities</p></a></li>
<li><a href='#distl2dnormpar'>
<p><code class="reqn">L^2</code> distance between <code class="reqn">L^2</code>-normed Gaussian densities given their parameters</p></a></li>
<li><a href='#distl2dpar'>
<p><code class="reqn">L^2</code> distance between Gaussian densities given their parameters</p></a></li>
<li><a href='#dspg'><p>Diploma x Socio professional group</p></a></li>
<li><a href='#dspgd2015'><p>Diploma x Socio professional group by departement in 2015</p></a></li>
<li><a href='#dstatis.inter'>
<p>Dual STATIS method (interstructure stage)</p></a></li>
<li><a href='#fdiscd.misclass'>
<p>Misclassification ratio in functional discriminant analysis of probability densities.</p></a></li>
<li><a href='#fdiscd.predict'>
<p>Predicting the class of a group of individuals with discriminant analysis of probability densities.</p></a></li>
<li><a href='#fhclustd'>
<p>Hierarchic cluster analysis of probability densities</p></a></li>
<li><a href='#floribundity'>
<p>Rose flowering</p></a></li>
<li><a href='#fmdsd'>
<p>Multidimensional scaling of probability densities</p></a></li>
<li><a href='#folder'>
<p>Folder of data sets</p></a></li>
<li><a href='#folderh'>
<p>Hierarchic folder of n data frames related in pairs by (n-1) keys</p></a></li>
<li><a href='#foldermtg'>
<p>foldermtg</p></a></li>
<li><a href='#foldert'>
<p>Folder of data sets among time</p></a></li>
<li><a href='#fpcad'>
<p>Functional PCA of probability densities</p></a></li>
<li><a href='#fpcat'>
<p>Functional PCA of probability densities among time</p></a></li>
<li><a href='#getcol.folder'>
<p>Select columns in all elements of a folder</p></a></li>
<li><a href='#getcol.foldert'>
<p>Select columns in all elements of a foldert</p></a></li>
<li><a href='#getrow.folder'>
<p>Select rows in all elements of a folder</p></a></li>
<li><a href='#getrow.foldert'>
<p>Select rows in all elements of a foldert</p></a></li>
<li><a href='#hclustdd'>
<p>Hierarchic cluster analysis of discrete probability distributions</p></a></li>
<li><a href='#hellinger'>
<p>Hellinger distance between Gaussian densities</p></a></li>
<li><a href='#hellingerpar'>
<p>Hellinger distance between Gaussian densities given their parameters</p></a></li>
<li><a href='#interpret'>
<p>Scores of <code>fmdsd</code>, <code>dstatis</code>, <code>fpcad</code>, or <code>fpcat</code> vs. moments, or scores of <code>mdsdd</code> vs. marginal distributions or association measures</p></a></li>
<li><a href='#interpret.dstatis'>
<p>Scores of the <code>dstatis</code> function vs. moments of the densities</p></a></li>
<li><a href='#interpret.fmdsd'>
<p>Scores of the <code>fmdsd</code> function vs. moments of the densities</p></a></li>
<li><a href='#interpret.fpcad'>
<p>Scores of the <code>fpcad</code> function vs. moments of the densities</p></a></li>
<li><a href='#interpret.fpcat'>
<p>Scores of the <code>"fpcat"</code> function vs. moments of the densities</p></a></li>
<li><a href='#interpret.mdsdd'>
<p>Scores of the <code>mdsdd</code> function vs. marginal probability distributions or association measures</p></a></li>
<li><a href='#is.discdd.misclass'>
<p>Class <code>discdd.misclass</code></p></a></li>
<li><a href='#is.discdd.predict'>
<p>Class <code>discdd.predict</code></p></a></li>
<li><a href='#is.dstatis'>
<p>Class <code>dstatis</code></p></a></li>
<li><a href='#is.fdiscd.misclass'>
<p>Class <code>fdiscd.misclass</code></p></a></li>
<li><a href='#is.fdiscd.predict'>
<p>Class <code>fdiscd.predict</code></p></a></li>
<li><a href='#is.fhclustd'>
<p>Class <code>fhclustd</code></p></a></li>
<li><a href='#is.fmdsd'>
<p>Class <code>fmdsd</code></p></a></li>
<li><a href='#is.folder'>
<p>Class <code>folder</code></p></a></li>
<li><a href='#is.folderh'>
<p>Class <code>folderh</code></p></a></li>
<li><a href='#is.foldermtg'>
<p>Class <code>foldermtg</code></p></a></li>
<li><a href='#is.foldert'>
<p>Class <code>foldert</code></p></a></li>
<li><a href='#is.fpcad'>
<p>Class <code>fpcad</code></p></a></li>
<li><a href='#is.mdsdd'>
<p>Class <code>mdsdd</code></p></a></li>
<li><a href='#jeffreys'>
<p>Jeffreys measure between Gaussian densities</p></a></li>
<li><a href='#jeffreyspar'>
<p>Jeffreys measure between Gaussian densities given their parameters</p></a></li>
<li><a href='#kurtosis.folder'>
<p>Kurtosis coefficients of a folder of data sets</p></a></li>
<li><a href='#l2d'>
<p><code class="reqn">L^2</code> inner product of probability densities</p></a></li>
<li><a href='#l2dpar'>
<p><code class="reqn">L^2</code> inner product of Gaussian densities given their parameters</p></a></li>
<li><a href='#matddchisqsym'>
<p>Matrix of distances between discrete probability densities given samples</p></a></li>
<li><a href='#matddchisqsympar'>
<p>Matrix of distances between discrete probability densities given the probabilities on their common support</p></a></li>
<li><a href='#matddhellinger'>
<p>Matrix of distances between discrete probability densities given samples</p></a></li>
<li><a href='#matddhellingerpar'>
<p>Matrix of distances between discrete probability densities given the probabilities on their common support</p></a></li>
<li><a href='#matddjeffreys'>
<p>Matrix of distances between discrete probability densities given samples</p></a></li>
<li><a href='#matddjeffreyspar'>
<p>Matrix of divergences between discrete probability densities given the probabilities on their common support</p></a></li>
<li><a href='#matddjensen'>
<p>Matrix of divergences between discrete probability densities given samples</p></a></li>
<li><a href='#matddjensenpar'>
<p>Matrix of divergences between discrete probability densities given the probabilities on their common support</p></a></li>
<li><a href='#matddlp'>
<p>Matrix of distances between discrete probability distributions given samples</p></a></li>
<li><a href='#matddlppar'>
<p>Matrix of distances between discrete probability densities given the probabilities on their common support</p></a></li>
<li><a href='#matdistl2d'>
<p>Matrix of <code class="reqn">L^2</code> distances between probability densities</p></a></li>
<li><a href='#matdistl2dnorm'>
<p>Matrix of <code class="reqn">L^2</code> distances between <code class="reqn">L^2</code>-normed probability densities</p></a></li>
<li><a href='#matdistl2dnormpar'>
<p>Matrix of <code class="reqn">L^2</code> distances between <code class="reqn">L^2</code>-normed Gaussian densities given their parameters</p></a></li>
<li><a href='#matdistl2dpar'>
<p>Matrix of <code class="reqn">L^2</code> distances between Gaussian densities given their parameters</p></a></li>
<li><a href='#mathellinger'>
<p>Matrix of Hellinger distances between Gaussian densities</p></a></li>
<li><a href='#mathellingerpar'>
<p>Matrix of Hellinger distances between Gaussian densities given their parameters</p></a></li>
<li><a href='#matipl2d'>
<p>Matrix of <code class="reqn">L^2</code> inner products of probability densities</p></a></li>
<li><a href='#matipl2dpar'>
<p>Matrix of <code class="reqn">L^2</code> inner products of Gaussian densities</p></a></li>
<li><a href='#matjeffreys'>
<p>Matrix of the Jeffreys measures (symmetrised Kullback-Leibler divergences) between Gaussian densities</p></a></li>
<li><a href='#matjeffreyspar'>
<p>Matrix of Jeffreys measures (symmetrised Kullback-Leibler divergences) between Gaussian densities</p></a></li>
<li><a href='#matwasserstein'>
<p>Matrix of 2-Wassterstein distance between Gaussian densities</p></a></li>
<li><a href='#matwassersteinpar'>
<p>Matrix of 2-Wasserstein distances between Gaussian densities</p></a></li>
<li><a href='#mdsdd'>
<p>Multidimensional scaling of discrete probability distributions</p></a></li>
<li><a href='#mean.folder'>
<p>Means of a folder of data sets</p></a></li>
<li><a href='#mtgcomponents'>
<p>Components of upper scale of a vertex</p></a></li>
<li><a href='#mtgorder'>
<p>Branching order of vertices</p></a></li>
<li><a href='#mtgplant1'>
<p>Class <code>foldermtg</code></p></a></li>
<li><a href='#mtgplant2'>
<p>Class <code>foldermtg</code></p></a></li>
<li><a href='#mtgrank'>
<p>Ranks of vertices in a decomposition</p></a></li>
<li><a href='#plot.dstatis'>
<p>Plotting scores of STATIS method (interstructure) analysis</p></a></li>
<li><a href='#plot.fhclustd'>
<p>Plotting a hierarchical clustering</p></a></li>
<li><a href='#plot.fmdsd'>
<p>Plotting scores of multidimensional scaling of density functions</p></a></li>
<li><a href='#plot.foldert'>
<p>Plotting data of a foldert</p></a></li>
<li><a href='#plot.fpcad'>
<p>Plotting scores of principal component analysis of density functions</p></a></li>
<li><a href='#plot.fpcat'>
<p>Plotting scores of principal component analysis of density functions among time</p></a></li>
<li><a href='#plot.hclustdd'>
<p>Plotting a hierarchical clustering of discrete distributions</p></a></li>
<li><a href='#plot.mdsdd'>
<p>Plotting scores of multidimensional scaling analysis of discrete distributions</p></a></li>
<li><a href='#plotframes'>
<p>Plotting of two sets of variables</p></a></li>
<li><a href='#print.discdd.misclass'>
<p>Printing results of discriminant analysis of discrete probability distributions</p></a></li>
<li><a href='#print.discdd.predict'>
<p>Printing results of discriminant analysis of discrete probability distributions</p></a></li>
<li><a href='#print.dstatis'>
<p>Printing results of STATIS method (interstructure) analysis</p></a></li>
<li><a href='#print.fdiscd.misclass'>
<p>Printing results of discriminant analysis of probability density functions</p></a></li>
<li><a href='#print.fdiscd.predict'>
<p>Printing results of discriminant analysis of probability density functions</p></a></li>
<li><a href='#print.fhclustd'>
<p>Printing results of a hierarchical clustering of probability density functions</p></a></li>
<li><a href='#print.fmdsd'>
<p>Printing results of a multidimensional scaling analysis of probability densities</p></a></li>
<li><a href='#print.foldermtg'>
<p>Printing an object of class <code>foldermtg</code></p></a></li>
<li><a href='#print.foldert'>
<p>Printing an object of class <code>foldert</code></p></a></li>
<li><a href='#print.fpcad'>
<p>Printing results of a functional PCA of probability densities</p></a></li>
<li><a href='#print.fpcat'>
<p>Printing results of a functional PCA of probability densities among time</p></a></li>
<li><a href='#print.hclustdd'>
<p>Printing results of a hierarchical clustering of discrete distributions</p></a></li>
<li><a href='#print.mdsdd'>
<p>Printing results of a multidimensional scaling analysis of discrete distributions</p></a></li>
<li><a href='#read.mtg'>
<p>Read a MTG (Multiscale Tree Graph) file</p></a></li>
<li><a href='#rmcol.folder'>
<p>Remove columns in all elements of a folder</p></a></li>
<li><a href='#rmcol.foldert'>
<p>Remove cols in all elements of a foldert</p></a></li>
<li><a href='#rmrow.folder'>
<p>Remove rows in all elements of a folder</p></a></li>
<li><a href='#rmrow.foldert'>
<p>Remove rows in all elements of a foldert</p></a></li>
<li><a href='#roseflowers'>
<p>Rose flowers</p></a></li>
<li><a href='#roseleaves'>
<p>Rose leaves</p></a></li>
<li><a href='#rosephytomer'>
<p>Rose leaf and internode dynamics</p></a></li>
<li><a href='#roses'><p>Roses data</p></a></li>
<li><a href='#skewness.folder'>
<p>Skewness coefficients of a folder of data sets</p></a></li>
<li><a href='#sqrtmatrix'>
<p>Square root of a symmetric, positive semi-definite matrix</p></a></li>
<li><a href='#summary.folder'>
<p>Summarize a folder</p></a></li>
<li><a href='#summary.folderh'>
<p>Summarize a folderh</p></a></li>
<li><a href='#summary.foldermtg'>
<p>Summary of an object of class <code>foldermtg</code></p></a></li>
<li><a href='#summary.foldert'>
<p>Summarize a foldert</p></a></li>
<li><a href='#var.folder'>
<p>Variance matrices of a folder of data sets</p></a></li>
<li><a href='#varietyleaves'>
<p>Rose variety leaves</p></a></li>
<li><a href='#wasserstein'>
<p>2-Wasserstein distance between Gaussian densities</p></a></li>
<li><a href='#wassersteinpar'>
<p>2-Wasserstein distance between Gaussian densities given their parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Three-Way / Multigroup Data Analysis Through Densities</td>
</tr>
<tr>
<td>Version:</td>
<td>4.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Rachid Boumaza[aut, cre],  Pierre Santagostini [aut], Smail Yousfi [aut], Gilles Hunault [ctb], Julie Bourbeillon [ctb], Besnik Pumo [ctb], Sabine Demotes-Mainard [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre Santagostini &lt;pierre.santagostini@agrocampus-ouest.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The data consist of a set of variables measured on several groups of individuals. To each group is associated an estimated probability density function. The package provides tools to create or manage such data and functional methods (principal component analysis, multidimensional scaling, cluster analysis, discriminant analysis...) for such probability densities.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://forgemia.inra.fr/dad/dad">https://forgemia.inra.fr/dad/dad</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://forgemia.inra.fr/dad/dad/-/issues">https://forgemia.inra.fr/dad/dad/-/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, grDevices, utils, ggplot2, e1071,
DescTools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, multigroup, knitr, markdown, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-30 09:22:04 UTC; santagostini</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-30 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dad-package'>
Three-Way Data Analysis Through Densities</h2><span id='topic+dad-package'></span><span id='topic+dad'></span>

<h3>Description</h3>

<p>The three-way data consists of a set of variables measured on several groups of 
individuals. To each group is associated an estimated probability density 
function. The package provides functional methods (principal component 
analysis, multidimensional scaling, cluster analysis, 
discriminant analysis...) for such probability densities.  
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dad</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 4.1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: https://forgemia.inra.fr/dad/dad
BugReports: https://forgemia.inra.fr/dad/dad/issues
</td>
</tr>

</table>

<p>To cite <code>dad</code>, use <code>citation("dad")</code>.
</p>
<p>The main functions applying to the probability densities are: </p>

<ul>
<li><p><code><a href="#topic+fpcad">fpcad</a></code>: functional principal component analysis,
</p>
</li>
<li><p><code><a href="#topic+fpcat">fpcat</a></code>: functional principal component analysis applied to data indexed according to time,
</p>
</li>
<li><p><code><a href="#topic+fmdsd">fmdsd</a></code>: multidimensional scaling,
</p>
</li>
<li><p><code><a href="#topic+fhclustd">fhclustd</a></code>: hierarchical clustering,
</p>
</li>
<li><p><code><a href="#topic+fdiscd.misclass">fdiscd.misclass</a></code>: functional discriminant analysis in order to compute the misclassification ratio with the one-leave-out method,
</p>
</li>
<li><p><code><a href="#topic+fdiscd.predict">fdiscd.predict</a></code>: discriminant analysis in order to predict the class (synonymous with cluster, not to be confused with the class attribute of an R object) of each probability density whose class is unknown,
</p>
</li>
<li><p><code><a href="#topic+mdsdd">mdsdd</a></code>: multidimensional scaling of discrete probability distributions,
</p>
</li>
<li><p><code><a href="#topic+discdd.misclass">discdd.misclass</a></code>: functional discriminant analysis of discrete probability distributions, in order to compute the misclassification ratio with the one-leave-out method,
</p>
</li>
<li><p><code><a href="#topic+discdd.predict">discdd.predict</a></code>: discriminant analysis of discrete probability distributions, in order to predict the class of each probability distribution whose class is unknown,
</p>
</li></ul>

<p>The above functions are completed by: </p>

<ul>
<li><p>A <code>print()</code> method for objects of class <code>fpcad</code>, <code>fmdsd</code>, <code>fdiscd.misclass</code>, <code>fdiscd.predict</code> or <code>mdsdd</code>, in order to display the results of the corresponding function,
</p>
</li>
<li><p>A <code>plot()</code> method for objects of class <code>fpcad</code>, <code>fmdsd</code>, <code>fhclustd</code> or <code>mdsdd</code>, in order to display some useful graphics attached to the corresponding function,
</p>
</li>
<li><p>A generic function <code><a href="#topic+interpret">interpret</a></code> that applies to objects of class <code>fpcad</code> <code>fmdsd</code> or <code>mdsdd</code>, helps the user to interpret the scores returned by the corresponding function, in terms of moments (<code>fpcad</code> or <code>fmdsd</code>) or in terms of marginal probability distributions (<code>mdsdd</code>).
</p>
</li></ul>

<p>We also introduce classes of objects and tools in order to handle collections of data frames: </p>

<ul>
<li><p><code><a href="#topic+folder">folder</a></code> creates an object of class <code>folder</code>, that is a list of data frames which have in common the same columns.
</p>
<p>The following functions apply to a folder and compute some statistics on the columns of its elements: <code><a href="#topic+mean.folder">mean.folder</a></code>, <code><a href="#topic+var.folder">var.folder</a></code>, <code><a href="#topic+cor.folder">cor.folder</a></code>, <code><a href="#topic+skewness.folder">skewness.folder</a></code> or <code><a href="#topic+kurtosis.folder">kurtosis.folder</a></code>.
</p>
</li>
<li><p><code><a href="#topic+folderh">folderh</a></code> creates an object of class <code>folderh</code>, that is a list of data frames with a hierarchic relation between each pair of consecutive data frames.
</p>
</li>
<li><p><code><a href="#topic+foldert">foldert</a></code> creates an object of class <code>foldert</code>, that is a list of data frames indexed according to time, concerning the same individuals and variables or not.
</p>
</li>
<li><p><code><a href="#topic+read.mtg">read.mtg</a></code> creates an object of class <code>foldermtg</code> from an MTG (Multiscale Tree Graph) file containing plant architecture data.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard with the contributions from Gilles Hunault, Julie Bourbeillon and Besnik Pumo
</p>


<h3>References</h3>

<p>Boumaza, R. (1998). Analyse en composantes principales de distributions gaussiennes multidimensionnelles. Revue de Statistique Appliqu?e, XLVI (2), 5-20.
</p>
<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>
<p>Boumaza, R. (2004). Discriminant analysis with independently repeated multivariate measurements: an <code class="reqn">L^2</code> approach. Computational Statistics &amp; Data Analysis, 47, 823-843.
</p>
<p>Delicado, P. (2011). Dimensionality reduction when data are density functions. Computational Statistics &amp; Data Analysis, 55, 401-420.
</p>
<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>
<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>
<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution à l'étude de l'architecture médiévale: les caractéristiques des pierres à bossage des châteaux forts alsaciens. Centre de Recherches Archéologiques Médiévales de Saverne, 5, 5-38.
</p>
<p>Rachev, S.T., Klebanov, L.B., Stoyanov, S.V. and Fabozzi, F.J. (2013). The methods of distances in the theory of probability and statistics. Springer.
</p>
<p>Yousfi, S., Boumaza, R., Aissani, D., Adjabi, S. (2014). Optimal bandwith matrices in functional principal component analysis of density functions. Journal of Statistical Computation and Simulation, 85 (11), 2315-2330.   
</p>

<hr>
<h2 id='appendtofolderh'>
Adds a data frame to a <code>folderh</code>.
</h2><span id='topic+appendtofolderh'></span>

<h3>Description</h3>

<p>Creates an object of class <code>folderh</code> by appending a data frame to an object of class <code>folderh</code>.
The appended data frame will be the first or last element of the returned <code>folderh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendtofolderh(fh, df, key, after = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendtofolderh_+3A_fh">fh</code></td>
<td>

<p>object of class <code><a href="#topic+folderh">folderh</a></code>.
</p>
</td></tr>
<tr><td><code id="appendtofolderh_+3A_df">df</code></td>
<td>

<p>data frame to be appended to <code>fh</code>.
</p>
</td></tr>
<tr><td><code id="appendtofolderh_+3A_key">key</code></td>
<td>

<p>character string. The key defining the relation <code class="reqn">1 to N</code> between <code>df</code> and the first (if after = FALSE, the default value) or last (if after = TRUE) data frame of <code>fh</code>.
</p>
</td></tr>
<tr><td><code id="appendtofolderh_+3A_after">after</code></td>
<td>

<p>logical. If <code>FALSE</code> (default), the data frame <code>df</code> is related to the first data frame of <code>fh</code>, and is appended as the first element of the returned folderh.
If <code>TRUE</code>, <code>df</code> is related to the last data frame of <code>fh</code> and becomes the last element of the returned folderh.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+folderh">folderh</a></code>, that is a list of <code class="reqn">n+1</code> data frames where <code class="reqn">n</code> is the number of data frames of <code>fh</code>.
The value of the attribute <code>attr(, "keys")</code> is <code>c(key, attr(fh, "keys"))</code> if <code>after = FALSE</code>), <code>c(attr(fh, "keys"), key)</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folderh">folderh</a></code>.
</p>

<hr>
<h2 id='as.data.frame.folder'>
Folder to data frame
</h2><span id='topic+as.data.frame.folder'></span>

<h3>Description</h3>

<p>Builds a data frame from an object of class <code>folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'folder'
as.data.frame(x, row.names = NULL, optional = FALSE, ..., group.name = "group")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.folder_+3A_x">x</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="as.data.frame.folder_+3A_row.names">row.names</code>, <code id="as.data.frame.folder_+3A_optional">optional</code></td>
<td>

<p>for consistency with <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. <code>as.data.frame.folder</code> does not take them into account.
</p>
</td></tr>
<tr><td><code id="as.data.frame.folder_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
<tr><td><code id="as.data.frame.folder_+3A_group.name">group.name</code></td>
<td>

<p>the name of the grouping variable. It is the name of the last column of the returned data frame.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame is simply obtained by row binding the data frames of the folder and adding a factor (as last column). The name of this column is given by <code>group.name</code> argument. The levels of this factor are the names of the elements of the folder.
</p>


<h3>Value</h3>

<p><code>as.data.frame.folder</code> returns a data frame.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>: object of class <code>folder</code>.
<code><a href="#topic+as.folder.data.frame">as.folder.data.frame</a></code>: build an object of class <code>folder</code> from a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

iris.fold &lt;- as.folder(iris, "Species")
print(iris.fold)

iris.df &lt;- as.data.frame(iris.fold)
print(iris.df)
</code></pre>

<hr>
<h2 id='as.data.frame.folderh'>
Hierarchic folder to data frame
</h2><span id='topic+as.data.frame.folderh'></span>

<h3>Description</h3>

<p>Builds a data frame from a <code>folderh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'folderh'
as.data.frame(x, row.names = NULL, optional = FALSE, ...,
        elt = names(x)[2], key = attr(x, "keys")[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.folderh_+3A_x">x</code></td>
<td>

<p>object of class <code><a href="#topic+folderh">folderh</a></code> containing N (N&gt;1) data frames: <code>x[[1]]</code>,..., <code>x[[N]]</code>, related by <code>(N-1)</code> keys: <code>keys[1]</code>,..., <code>keys[N-1]</code>.
</p>
</td></tr>
<tr><td><code id="as.data.frame.folderh_+3A_row.names">row.names</code>, <code id="as.data.frame.folderh_+3A_optional">optional</code></td>
<td>

<p>for consistency with <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. Not taken into account.
</p>
</td></tr>
<tr><td><code id="as.data.frame.folderh_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
<tr><td><code id="as.data.frame.folderh_+3A_elt">elt</code></td>
<td>

<p>string. The name of one element of <code>x</code>, that is the data frame, say the <code>j</code>-th, whose rows are the rows of the returned data frame. See details.
</p>
</td></tr>
<tr><td><code id="as.data.frame.folderh_+3A_key">key</code></td>
<td>

<p>string. The name of an element of <code>attr(x, "keys")</code>, that is the key, say the <code>k</code>-th with <code>k</code>&lt;<code>j</code>, which is the factor designating the last column of the returned data frame. See details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.data.frame.folderh</code> returns a data frame whose row names are those of <code>x[[elt]]</code> (that is <code>x[[j]]</code>). The data frame contains the values of <code>x[[elt]]</code> and the corresponding values of the data frames <code>x[[k]]</code>, these correspondances being defined by the keys of the hierarchic folder.
</p>
<p>The column names of the returned data frame are organized in three parts. 
</p>

<ol>
<li><p> The first part consists in the key names <code>keys[k]</code>,..., <code>keys[j-1]</code>.  
</p>
</li>
<li><p> The second part consists in the values of  <code>x[[j]]</code>.
</p>
</li>
<li><p> The third part consists in the values of <code>x[[k]]</code> except the key <code>keys[k]</code>.
</p>
</li></ol>

<p>See the examples to view these details.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>, <code><a href="#topic+folderh">folderh</a></code>, <code><a href="#topic+as.folder.folderh">as.folder.folderh</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: rose flowers               
data(roseflowers)
flg &lt;- roseflowers$variety
flx &lt;- roseflowers$flower

flfh &lt;- folderh(flg, "rose", flx)
print(flfh)

fldf &lt;- as.data.frame(flfh)
print(fldf)

# Second example: castles               
data(castles.dated)
cag &lt;- castles.dated$periods
cax &lt;- castles.dated$stones

cafh &lt;- folderh(cag, "castle", cax)
print(cafh)

cadf &lt;- as.data.frame(cafh)
print(summary(cadf))

# Third example: leaves (example of a folderh with more than two data frames)
data(roseleaves)
lvr &lt;- roseleaves$rose
lvs &lt;- roseleaves$stem
lvl &lt;- roseleaves$leaf
lvll &lt;- roseleaves$leaflet

lfh &lt;- folderh(lvr, "rose", lvs, "stem", lvl, "leaf", lvll)

lf1 &lt;- as.data.frame(lfh, elt = "lvs", key = "rose")
print(lf1)

lf2 &lt;- as.data.frame(lfh, elt = "lvl", key = "rose")
print(lf2)

lf3 &lt;- as.data.frame(lfh, elt = "lvll", key = "rose")
print(lf3)

lf4 &lt;- as.data.frame(lfh, elt = "lvll", key = "stem")
print(lf4)
</code></pre>

<hr>
<h2 id='as.data.frame.foldert'>
foldert to data frame
</h2><span id='topic+as.data.frame.foldert'></span>

<h3>Description</h3>

<p>Builds a data frame from an object of class <code>foldert</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foldert'
as.data.frame(x, row.names = NULL, optional = FALSE, ..., group.name = "time")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.foldert_+3A_x">x</code></td>
<td>

<p>object of class <code><a href="#topic+foldert">foldert</a></code> with the same row names. An object of class <code>foldert</code> is a list of data frames with the same column names, each of them corresponding to a time of observation.
</p>
</td></tr>
<tr><td><code id="as.data.frame.foldert_+3A_row.names">row.names</code>, <code id="as.data.frame.foldert_+3A_optional">optional</code></td>
<td>

<p>for consistency with <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. <code>as.data.frame.foldert</code> does not take them into account.
</p>
</td></tr>
<tr><td><code id="as.data.frame.foldert_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
<tr><td><code id="as.data.frame.foldert_+3A_group.name">group.name</code></td>
<td>

<p>the name of the grouping variable. It is the name of the last column of the returned data frame.
</p>
<p>As the observations are indexed by time, the default value is <code>group.name = "time"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.data.frame.foldert</code> uses <code><a href="#topic+as.data.frame.folder">as.data.frame.folder</a></code>.
</p>


<h3>Value</h3>

<p><code>as.data.frame.foldert</code> returns a data frame.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: object of class <code>foldert</code>.
<code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>: build an object of class <code>foldert</code> from a data frame.
<code><a href="#topic+as.foldert.array">as.foldert.array</a></code>: build an object of class <code>foldert</code> from a <code class="reqn">3d</code>-array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(floribundity)
ftflor &lt;- foldert(floribundity, cols.select = "union", rows.select = "union")
print(ftflor)
dfflor &lt;- as.data.frame(ftflor)
summary(dfflor)
</code></pre>

<hr>
<h2 id='as.folder'>
Coerce to a folder
</h2><span id='topic+as.folder'></span>

<h3>Description</h3>

<p>Coerces a data frame or an object of class <code>"folderh"</code> to an object of class <code>"folder"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.folder(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.folder_+3A_x">x</code></td>
<td>

<p>an object of class <code>data.frame</code> or <code>folderh</code>.
</p>

<ul>
<li> <p><code>data.frame</code>: see <code><a href="#topic+as.folder.data.frame">as.folder.data.frame</a></code>
</p>
</li>
<li> <p><code>folderh</code>: see <code><a href="#topic+as.folder.folderh">as.folder.folderh</a></code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="as.folder_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+folder">folder</a></code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>: objects of class <code>folder</code>.
<code><a href="#topic+as.data.frame.folder">as.data.frame.folder</a></code>: build a data frame from an object of class <code>folder</code>.
<code><a href="#topic+as.folder.data.frame">as.folder.data.frame</a></code>: build an object of class <code>folder</code> from a data frame.
<code><a href="#topic+as.folder.folderh">as.folder.folderh</a></code>: build an object of class <code>folder</code> from an object of class <code>folderh</code>.
</p>

<hr>
<h2 id='as.folder.data.frame'>
Data frame to folder
</h2><span id='topic+as.folder.data.frame'></span>

<h3>Description</h3>

<p>Builds an object of class <code>folder</code> from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as.folder(x, groups = tail(colnames(x), 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.folder.data.frame_+3A_x">x</code></td>
<td>

<p>data frame.
</p>
</td></tr>
<tr><td><code id="as.folder.data.frame_+3A_groups">groups</code></td>
<td>

<p>string. The name of the column of x containing the grouping variable. <code>x[, groups]</code> must be a factor, otherwise, there is an error.
</p>
<p>If omitted, the last column of <code>x</code> is used as grouping variable.
</p>
</td></tr>
<tr><td><code id="as.folder.data.frame_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.folder.data.frame</code> returns an object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
<p>Each element of the folder contains the data corresponding to one level of <code>x[, groups]</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>: objects of class <code>folder</code>.
<code><a href="#topic+as.data.frame.folder">as.data.frame.folder</a></code>: build a data frame from an object of class <code>folder</code>.
<code><a href="#topic+as.folder.folderh">as.folder.folderh</a></code>: build an object of class <code>folder</code> from an object of class <code>folderh</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: iris (Fisher)               
data(iris)
iris.fold &lt;- as.folder(iris, "Species")
print(iris.fold)

# Second example: roses
data(roses)
roses.fold &lt;- as.folder(roses, "rose")
print(roses.fold)
</code></pre>

<hr>
<h2 id='as.folder.folderh'>
Hierarchic folder to folder
</h2><span id='topic+as.folder.folderh'></span>

<h3>Description</h3>

<p>Creates an object of class <code>folder</code>, that is a list of data frames with the same column names, from a <code>folderh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'folderh'
as.folder(x, elt = names(x)[2], key = attr(x, "keys")[1], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.folder.folderh_+3A_x">x</code></td>
<td>

<p>object of class <code><a href="#topic+folderh">folderh</a></code> containing N (N&gt;1) data frames: <code>x[[1]]</code>,..., <code>x[[N]]</code>, related by (N-1) keys: <code>keys[1]</code>,..., <code>keys[N-1]</code>.
</p>
</td></tr>
<tr><td><code id="as.folder.folderh_+3A_elt">elt</code></td>
<td>

<p>string. The name of one element of <code>x</code>, that is data frame, say the <code>j</code>-th, whose rows are distributed among the data frames of the returned folder. See details.
</p>
</td></tr>
<tr><td><code id="as.folder.folderh_+3A_key">key</code></td>
<td>

<p>string. The name of an element of <code>attr(x, "keys")</code>, that is the key, say the <code>k</code>-th  with <code>k</code>&lt;<code>j</code>, which is the factor whose levels are the names of the data frames of the returned folder. See details.
</p>
</td></tr>
<tr><td><code id="as.folder.folderh_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.folder.folderh</code> returns an object of class <code><a href="#topic+folder">folder</a></code>, a list of data frames with the same columns. These data frames contain the values of <code>x[[elt]]</code> (or <code>x[[j]]</code>) and the corresponding values of the data frames <code>x[[j-1]]</code>, ... <code>x[[k]]</code>, these correspondances being defined by the keys of the hierarchic folder. The names of these data frames are given by the levels of the key <code>attr(x, "keys")[k])</code>.
</p>
<p>The rows of the data frame <code>x[[elt]]</code> (or <code>x[[j]]</code>) are distributed among the data frames of the returned folder accordingly to the levels of the key <code>attr(x, "keys")[k]</code>. So the row names of the <code>l</code>-th data frame of the returned folder consist in the rows of <code>x[[j]]</code> corresponding to the <code>l</code>-th level of the key <code>attr(x, "keys")[k]</code>. 
</p>
<p>The column names of the data frames of the returned folder are the union of the column names of the data frames <code>x[[k]]</code>,..., <code>x[[j]]</code> and are organized in two parts. 
</p>

<ol>
<li><p> The first part consists in the columns of <code>x[[k]]</code> except the column corresponding to the key <code>attr(x, "keys")[k]</code>. 
</p>
</li>
<li><p> For each <code>i=k+1,...,j</code> the column names of the data frame <code>x[[i]]</code> are reorganized so that the key <code>attr(x, "keys")[i]</code> is its first column. The columns of the reorganized data frames <code>x[[k+1]]</code>,..., <code>x[[j]]</code> are concatenated. The result forms the second part. 
</p>
</li></ol>
 
<p>Notice that if:
</p>

<ul>
<li><p> the folderh has two data frames <code>df1</code> and <code>df2</code>, where the factor corresponding to the key has <code class="reqn">T</code> levels, and one column of <code>df2</code>, say <code>df2[, "Fa"]</code>, is a factor with levels <code>"a1"</code>, ..., <code>"ap"</code>
</p>
</li>
<li><p> and the folder returned by <code>as.folder</code> includes <code class="reqn">T</code> data frames <code>dat1</code>, ..., <code>datT</code>,
</p>
</li></ul>

<p>then each of <code>dat1</code>, ..., <code>datT</code> has a column named <code>"Fa"</code> which is a factor <b>with the same levels</b> <code>"a1"</code>, ..., <code>"ap"</code> <b>as</b> <code>df2[, "Fa"]</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>, <code><a href="#topic+folderh">folderh</a></code>.
<code><a href="#topic+as.folder.folderh">as.folder.folderh</a></code> to build an object of class <code>folder</code> from an object of class <code>folderh</code>.
<code><a href="#topic+as.data.frame.folder">as.data.frame.folder</a></code> to build a data frame from an object of class <code>folder</code>.
<code><a href="#topic+as.data.frame.folderh">as.data.frame.folderh</a></code> to build a data frame from an object of class <code>folderh</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: flowers               
data(roseflowers)
flg &lt;- roseflowers$variety
flx &lt;- roseflowers$flower

flfh &lt;- folderh(flg, "rose", flx)
print(flfh)

flf &lt;- as.folder(flfh)
print(flf)

# Second example: castles               
data(castles.dated)
cag &lt;- castles.dated$periods
cax &lt;- castles.dated$stones

cafh &lt;- folderh(cag, "castle", cax)
print(cafh)

caf &lt;- as.folder(cafh)
print(caf)

# Third example: leaves (example of a folderh of more than two data frames)
data(roseleaves)
lvr &lt;- roseleaves$rose
lvs &lt;- roseleaves$stem
lvl &lt;- roseleaves$leaf
lvll &lt;- roseleaves$leaflet

lfh &lt;- folderh(lvr, "rose", lvs, "stem", lvl, "leaf", lvll)

lf1 &lt;- as.folder(lfh, elt = "lvs", key = "rose")
print(lf1)

lf2 &lt;- as.folder(lfh, elt = "lvl", key = "rose")
print(lf2)

lf3 &lt;- as.folder(lfh, elt = "lvll", key = "rose")
print(lf3)

lf4 &lt;- as.folder(lfh, elt = "lvll", key = "stem")
print(lf4)
</code></pre>

<hr>
<h2 id='as.folderh'>
Coerce to a folderh
</h2><span id='topic+as.folderh'></span>

<h3>Description</h3>

<p>Coerces an object to an object of class <code><a href="#topic+folderh">folderh</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.folderh(x, classes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.folderh_+3A_x">x</code></td>
<td>

<p>an object to be coerced to an object of class <code>folderh</code>. In the current version, it is an object of class <code>"foldermtg"</code> (see <code><a href="#topic+as.folderh.foldermtg">as.folderh.foldermtg</a></code>).
</p>
</td></tr>
<tr><td><code id="as.folderh_+3A_classes">classes</code></td>
<td>

<p>argument useful for <code><a href="#topic+as.folderh.foldermtg">as.folderh.foldermtg</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+folderh">folderh</a></code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.folderh.foldermtg">as.folderh.foldermtg</a></code>: build an object of class <code>folderh</code> from an object of class <code>foldermtg</code>.
</p>

<hr>
<h2 id='as.folderh.foldermtg'>
Build a hierarchic folder from an object of class foldermtg
</h2><span id='topic+as.folderh.foldermtg'></span>

<h3>Description</h3>

<p>Creates an object of class <code><a href="#topic+folderh">folderh</a></code> from an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foldermtg'
as.folderh(x, classes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.folderh.foldermtg_+3A_x">x</code></td>
<td>

<p>object of class <code><a href="#topic+foldermtg">foldermtg</a></code>.
</p>
</td></tr>
<tr><td><code id="as.folderh.foldermtg_+3A_classes">classes</code></td>
<td>

<p>character vector. Codes of the vertex classes in the returned folderh.
These codes are the names of the elements (data frames) of <code>x</code> containing the features on the vertices corresponding to the codes.
</p>
<p>These codes must be distinct, and the corresponding classes must have distinct scales (see <code><a href="#topic+foldermtg">foldermtg</a></code>). Otherwise, there is an error.
</p>
<p>These codes, except the one with the highest scale, are the keys of the returned folderh.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="#topic+folderh">folderh</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>folderh</code>. Its elements are the data frames of <code>x</code> containing the features on vertices. Hence, each data frame matches with a class of vertex, and a scale. These data frames are in increasing order of the scale.
</p>
<p>A column (factor) is added to the first data frame, containing the identifier of the vertex. 
Two columns are added to the second data frame:
</p>

<ol>
<li><p> the first one is a factor which gives, for each vertex, the name of the vertex of the first data frame which is its &quot;parent&quot;,
</p>
</li>
<li><p> and the second one is also a factor and contains the vertex's identifier.
</p>
</li></ol>

<p>And so on for the third and following data frames, if relevant.
</p>
<p>The column containing the vertex identifiers is redundant with the row names; anyway, it is necessary for <code><a href="#topic+folderh">folderh</a></code>.
</p>
<p>The key of the relationship between the two first data frame is given by the first column of each of these data frames.
If there are more than two data frames, the key of the relationship between the <code class="reqn">n</code>-th and <code class="reqn">(n+1)</code>-th data frames (<code class="reqn">n &gt; 1</code>) is given by the second column of the <code class="reqn">n</code>$th data frame and the first column of the <code class="reqn">(n+1)</code>-th data frame.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>: reads a MTG file and creates an object of class &quot;foldermtg&quot;.
<code><a href="#topic+folderh">folderh</a></code> : object of class <code>folderh</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtgfile &lt;- system.file("extdata/plant1.mtg", package = "dad")
x &lt;- read.mtg(mtgfile)

# folderh containing the plant ("P") and the stems ("A")
as.folderh(x, classes = c("P", "A"))

# folderh containing the plant ("P"), axes ("A") and phytomers ("M")
as.folderh(x, classes = c("P", "A", "M"))

# folderh containing the plant ("P") and the phytomers ("M")
as.folderh(x, classes = c("P", "M"))

# folderh containing the axes and phytomers
fhPM &lt;- as.folderh(x, classes = c("A", "M"))
# coerce this folderh into a folder, and compute statistics on this folder
fPM &lt;- as.folder(fhPM)
mean(fPM)
</code></pre>

<hr>
<h2 id='as.foldert'>
Coerce to a foldert
</h2><span id='topic+as.foldert'></span>

<h3>Description</h3>

<p>Coerces a data frame or array to an object of class <code><a href="#topic+foldert">foldert</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.foldert(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.foldert_+3A_x">x</code></td>
<td>

<p>an object of class <code>data.frame</code> or <code>array</code>.
</p>

<ul>
<li> <p><code>data.frame</code>: see <code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>
</p>
</li>
<li> <p><code>array</code>: see <code><a href="#topic+as.foldert.array">as.foldert.array</a></code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="as.foldert_+3A_...">...</code></td>
<td>

<p>arguments passed to <code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code> or <code><a href="#topic+as.foldert.array">as.foldert.array</a></code>,
further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+foldert">foldert</a></code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>

<hr>
<h2 id='as.foldert.array'>
Data frame to foldert
</h2><span id='topic+as.foldert.array'></span>

<h3>Description</h3>

<p>Builds an object of class <code><a href="#topic+foldert">foldert</a></code> from a <code class="reqn">3d</code>-array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
as.foldert(x, ind = 1, var = 2, time = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.foldert.array_+3A_x">x</code></td>
<td>

<p>a <code class="reqn">3d</code>-array.
</p>
</td></tr>
<tr><td><code id="as.foldert.array_+3A_ind">ind</code>, <code id="as.foldert.array_+3A_var">var</code>, <code id="as.foldert.array_+3A_time">time</code></td>
<td>

<p>three distinct integers among 1, 2 and 3.
</p>
<p><code>ind</code> gives the dimension of the observations,
<code>var</code> gives the dimension of the variables
and <code>ind</code> gives the dimension of the times.
</p>
</td></tr>
<tr><td><code id="as.foldert.array_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object <code>ft</code> of class <code><a href="#topic+foldert">foldert</a></code> that is a list of data frames, each of them corresponding to a time of observation; these data frames have the same column names.
</p>
<p>They necessarily have the same row names (<code>attr(ft, "same.rows")=TRUE</code>).
The <code>"times"</code> attribute of <code>ft</code>: <code>attr(ft, "times")</code> is a numeric vector, an ordered factor or an object of class <code>Date</code>, and contains the values nf the dimension of <code>x</code> given by <code>time</code> argument.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: objects of class <code>foldert</code>.
</p>
<p><code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>: build an object of class <code>foldert</code> from a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(c(rep(0, 5), rep(0, 5), rep(0, 5),
             rnorm(5, 2, 1), rnorm(5, 3, 2), rnorm(5, -2, 0.5),
             rnorm(5, 4, 1), rnorm(5, 5, 3), rnorm(5, -3, 1)),
           dim = c(5, 3, 3),
           dimnames = list(1:5, c("z1", "z2", "z3"), c("t1", "t2", "t3")))
# The individuals which were observed are on the 1st dimension,
# the variables are on the 2nd dimension and the times are on the 3rd dimension.
ft &lt;- as.foldert(x, ind = 1, var = 2, time = 3)
</code></pre>

<hr>
<h2 id='as.foldert.data.frame'>
Data frame to foldert
</h2><span id='topic+as.foldert.data.frame'></span>

<h3>Description</h3>

<p>Builds an object of class <code><a href="#topic+foldert">foldert</a></code> from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as.foldert(x, method = 1, ind = 1, timecol = 2, nvar = NULL, same.rows = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.foldert.data.frame_+3A_x">x</code></td>
<td>

<p>data frame.
</p>
</td></tr>
<tr><td><code id="as.foldert.data.frame_+3A_method">method</code></td>
<td>

<p>1 or 2. Indicates the layout of the data frame x and, therefore, the method used to extract the data and build the foldert.
</p>

<ul>
<li><p>If <code>method = 1</code>, there is a column containing the identifiers of the measured objects and a column containing the times. The other columns contain the observations.
</p>
</li>
<li><p>If <code>method = 2</code>, there is a column containing the identifiers of the measured objects, and the observations are organized as follows:
</p>

<ul>
<li><p>the observations corresponding to the 1st time are on columns <code>timecol : (timecol + nvar - 1)</code>
</p>
</li>
<li><p>the observations corresponding to the 2nd time are on columns <code>(timecol + nvar) : (timecol + 2 * nvar - 1)</code>
</p>
</li>
<li><p>and so on.
</p>
</li></ul>


</li></ul>

</td></tr>
<tr><td><code id="as.foldert.data.frame_+3A_ind">ind</code></td>
<td>

<p>string or numeric. The name of the column of x containing the indentifiers of the measured objects, or the number of this column.
</p>
</td></tr>
<tr><td><code id="as.foldert.data.frame_+3A_timecol">timecol</code></td>
<td>

<p>string or numeric.
</p>

<ul>
<li><p>If <code>method = 1</code>, <code>timecol</code> is the name or the number of the column of x containing the times of observation, or the number of this column. <code>x[, timecol]</code> must be of class <code>"numeric"</code>, <code>"ordered"</code>, <code>"Date"</code>, <code>"POSIXlt"</code> or <code>"POSIXct"</code>, otherwise, there is an error.

</p>
</li>
<li><p>If <code>method=2</code>, <code>timecol</code> is the name or the number of the first column corresponding to the first observation. If there are duplicated column names and several columns are named by <code>timecol</code>, the first one is considered.

</p>
</li></ul>

</td></tr>
<tr><td><code id="as.foldert.data.frame_+3A_nvar">nvar</code></td>
<td>

<p>integer. If <code>method=2</code>, indicates the number of variables observed at each time.
</p>
<p>Omitted if <code>method=1</code>.
</p>
</td></tr>
<tr><td><code id="as.foldert.data.frame_+3A_same.rows">same.rows</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the elements of the returned foldert are data frames with the same row names.
</p>
<p>Necessarily <code>TRUE</code> if <code>method = 2</code>.
</p>
</td></tr>
<tr><td><code id="as.foldert.data.frame_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object <code>ft</code> of class <code><a href="#topic+foldert">foldert</a></code>, that is a list of data frames organised according to time; these data frames have the same column names.
</p>
<p>If <code>method = 1</code>, they can have the same row names (<code>attr(ft, "same.rows") = TRUE</code>) or not (<code>attr(ft, "same.rows") = FALSE</code>).
The time attribute <code>attr(ft, "times")</code> has the same class as <code>x[, timecol]</code> (numeric vector, ordered factor or object of class <code>"Date"</code>, <code>"POSIXlt"</code> or <code>"POSIXct"</code>) and contains the values of <code>x[, timecol]</code>.
</p>
<p>If <code>method = 2</code>, they necessarily have the same row names: <code>attr(ft, "same.rows") = TRUE</code>
and <code>attr(ft, "times")</code> is <code>1:length(ft)</code>.
</p>
<p>The rownames of each data frame are the identifiers of the individuals, as given by <code>x[, ind]</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: objects of class <code>foldert</code>.
</p>
<p><code><a href="#topic+as.data.frame.foldert">as.data.frame.foldert</a></code>: build a data frame from an object of class <code>foldert</code>.
</p>
<p><code><a href="#topic+as.foldert.array">as.foldert.array</a></code>: build an object of class <code>foldert</code> from a <code class="reqn">3d</code>-array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: method = 1

times &lt;- as.Date(c("2017-03-01", "2017-04-01", "2017-05-01"))
x1 &lt;- data.frame(t=times[1], ind=1:6,
                 f=c("a","a","a","b","b","b"), z1=rep(0,6), z2=rep(0,6),
                 stringsAsFactors = TRUE)
x2 &lt;- data.frame(t=times[2], ind=c(1,4,6),
                 f=c("a","b","b"), z1=rnorm(3,1,1), z2=rnorm(3,3,2),
                 stringsAsFactors = TRUE)
x3 &lt;- data.frame(t=times[3], ind=c(1,3:6),
                 f=c("a","a","a","b","b"), z1=rnorm(5,3,2), z2=rnorm(5,6,3),
                 stringsAsFactors = TRUE)
x &lt;- rbind(x1, x2, x3)

ft1 &lt;- as.foldert(x, method = 1, ind = "ind", timecol = "t", same.rows = TRUE)
print(ft1)

ft2 &lt;- as.foldert(x, method = 1, ind = "ind", timecol = "t", same.rows = FALSE)
print(ft2)

data(castles.dated)
periods &lt;- castles.dated$periods
stones &lt;- castles.dated$stones
stones$stone &lt;- rownames(stones)

castledf &lt;- merge(periods, stones, by = "castle")
castledf$period &lt;- as.numeric(castledf$period)
castledf$stone &lt;- as.factor(paste(as.character(castledf$castle),
                            as.character(castledf$stone), sep = "_"))

castfoldt1 &lt;- as.foldert(castledf, method = 1, ind = "stone", timecol = "period",
                         same.rows = FALSE)
summary(castfoldt1)


# Second example: method = 2

times &lt;- as.Date(c("2017-03-01", "2017-04-01", "2017-05-01"))
y1 &lt;- data.frame(z1=rep(0,6), z2=rep(0,6))
y2 &lt;- data.frame(z1=rnorm(6,1,1), z2=rnorm(6,3,2))
y3 &lt;- data.frame(z1=rnorm(6,3,2), z2=rnorm(6,6,3))
y &lt;- cbind(ind = 1:6, y1, y2, y3)

ft3 &lt;- as.foldert(y, method = 2, ind = "ind", timecol = 2, nvar = 2)
print(ft3)
</code></pre>

<hr>
<h2 id='association+20measures'>
Association measures between several categorical variables of a data frame
</h2><span id='topic+cramer.data.frame'></span><span id='topic+tschuprow.data.frame'></span><span id='topic+pearson.data.frame'></span><span id='topic+phi.data.frame'></span>

<h3>Description</h3>

<p>Computes pairwise association measures (Cramer's V, Pearson's contingency coefficient, phi, Tschuprow's T) between the categorical variables of a data frame, using functions of the package <code>DescTools</code> (see <code><a href="DescTools.html#topic+Assocs">Assocs</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramer.data.frame(x, check = TRUE)
pearson.data.frame(x, check = TRUE)
phi.data.frame(x, check = TRUE)
tschuprow.data.frame(x, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="association+2B20measures_+3A_x">x</code></td>
<td>

<p>a data frame (can also be a tibble). Its columns should be factors.
</p>
</td></tr>
<tr><td><code id="association+2B20measures_+3A_check">check</code></td>
<td>

<p>logical. If <code>TRUE</code> (default) the function checks if each column of <code>x</code> is a factor, and there is a warning if it is not.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix whose elements are the pairwise association measures.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
xr = roses[,c("Sha", "Den", "Sym", "rose")]
xr$Sha = cut(xr$Sha, breaks = c(0, 5, 7, 10))
xr$Den = cut(xr$Den, breaks = c(0, 4, 6, 10))
xr$Sym = cut(xr$Sym, breaks = c(0, 6, 8, 10))
cramer.data.frame(xr)
pearson.data.frame(xr)
phi.data.frame(xr)
tschuprow.data.frame(xr)
</code></pre>

<hr>
<h2 id='association+20measures+20for+20folder'>
Association measures between categorical variables of the data frames of a folder
</h2><span id='topic+cramer.folder'></span><span id='topic+tschuprow.folder'></span><span id='topic+pearson.folder'></span><span id='topic+phi.folder'></span>

<h3>Description</h3>

<p>Computes the pairwise association measures (Cramer's V, Pearson's contingency coefficient, phi, Tschuprow's T) between the categorical variables of an object of class <code>folder</code>. The computation is carried out using the functions <code><a href="#topic+cramer.data.frame">cramer.data.frame</a></code>, <code><a href="#topic+tschuprow.data.frame">tschuprow.data.frame</a></code>, <code><a href="#topic+pearson.data.frame">pearson.data.frame</a></code> or <code><a href="#topic+phi.data.frame">phi.data.frame</a></code>. These functions are built from corresponding functions of the package <code>DescTools</code> (see <code><a href="DescTools.html#topic+Assocs">Assocs</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramer.folder(xf)
tschuprow.folder(xf)
pearson.folder(xf)
phi.folder(xf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="association+2B20measures+2B20for+2B20folder_+3A_xf">xf</code></td>
<td>

<p>an object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names. Its columns should be factors, otherwise there is a warning.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list the length of which is equal to the number of data frames of the folder. Each element of the list is a square matrice giving the pairwise association measures of the variables of the corresponding data frame.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
xr = roses[,c("Sha", "Den", "Sym", "rose")]
xr$Sha = cut(xr$Sha, breaks = c(0, 5, 7, 10))
xr$Den = cut(xr$Den, breaks = c(0, 4, 6, 10))
xr$Sym = cut(xr$Sym, breaks = c(0, 6, 8, 10))
xfolder = as.folder(xr, groups = "rose")
cramer.folder(xfolder)
pearson.folder(xfolder)
phi.folder(xfolder)
tschuprow.folder(xfolder)
</code></pre>

<hr>
<h2 id='bandwidth.parameter'>
Parameter of the normal reference rule
</h2><span id='topic+bandwidth.parameter'></span>

<h3>Description</h3>

<p>Computation of the parameter of the normal reference rule in order to estimate the (matrix) bandwidth. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidth.parameter(p, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth.parameter_+3A_p">p</code></td>
<td>

<p>sample dimension.
</p>
</td></tr>
<tr><td><code id="bandwidth.parameter_+3A_n">n</code></td>
<td>

<p>sample size.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter is equal to:
</p>
<p style="text-align: center;"><code class="reqn">h = (\frac{4}{n(p+2)})^{\frac{1}{p+4}}</code>
</p>

<p>It is based on the minimisation of the asymptotic mean integrated square error in density estimation when using the Gaussian kernel method (Wand and Jones, 1995). 
</p>


<h3>Value</h3>

<p>Returns the value required by the functions <code><a href="#topic+fpcad">fpcad</a></code>, <code><a href="#topic+fmdsd">fmdsd</a></code>, <code><a href="#topic+fdiscd.misclass">fdiscd.misclass</a></code> and <code><a href="#topic+fdiscd.predict">fdiscd.predict</a></code> when their argument <code>windowh</code> is set to <code>NULL</code>. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

    
<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>
<p>Wand, M. P., Jones, M. C. (1995). Kernel Smoothing. Boca Raton, FL: Chapman and Hall.    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Sample size :
    n &lt;- 20
    # Number of variables :
    p &lt;- 3
    bandwidth.parameter(p, n)
</code></pre>

<hr>
<h2 id='castles'>
Alsacian castles by year of building
</h2><span id='topic+castles'></span>

<h3>Description</h3>

<p>The data were collected by J.M. Rudrauf on Alsacian castles whose building year is known (even approximatively).
On each castle, he measured 4 structural parameters on a sample of building stones.
</p>
<p>These data are about the same castles as in <code><a href="#topic+castles.dated">castles.dated</a></code> data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(castles)</code></pre>


<h3>Format</h3>

<p><code>castles</code> is a list of 46 data frames. Each of these data frames matches with one year (between 1136 and 1510) and contains measures on one or several castles which have been built since that year.
</p>
<p>Each data frame has 5 to 101 rows (stones) and 5 columns: <code>height</code>, <code>width</code>, <code>edging</code>, <code>boss</code> (numeric) and <code>castle</code> (factor).
</p>


<h3>Source</h3>

<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution a l'etude de l'architecture medievale: les caracteristiques des pierres a bossage des chateaux forts alsaciens. Centre de Recherches Archeologiques Medievales de Saverne, 5, 5-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles)
foldert(castles)
</code></pre>

<hr>
<h2 id='castles.dated'>
Dated Alsacian castles
</h2><span id='topic+castles.dated'></span>

<h3>Description</h3>

<p>The data were collected by J.M. Rudrauf on Alsacian castles whose building period is
known (even approximately).
On each castle, he measured 4 structural parameters on a sample of building stones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(castles.dated)</code></pre>


<h3>Format</h3>

<p><code>castles.dated</code> is a list of two data frames:
</p>

<ul>
<li><p><code>castles.dated$stones</code>: this first data frame has 1262 cases (rows) and 5 variables (columns) that are named
<code>height, width, edging, boss</code> (numeric) and <code>castle</code> (factor).
</p>
</li>
<li><p><code>castles.dated$periods</code>: this second data frame has 68 cases and 2 variables named <code>castle</code> and <code>period</code>; the column <code>castle</code> corresponds to the levels of the factor <code>castle</code> of the first data frame; the column <code>period</code> is a factor with 6 levels indicating the approximative building period. Thus this factor defines 6 classes of castles.
</p>
</li></ul>



<h3>Source</h3>

<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution a l'etude de l'architecture medievale: les caracteristiques des pierres a bossage des chateaux forts alsaciens. Centre de Recherches Archeologiques Medievales de Saverne, 5, 5-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
summary(castles.dated$stones)
summary(castles.dated$periods)
</code></pre>

<hr>
<h2 id='castles.nondated'>
Non dated Alsacian castles
</h2><span id='topic+castles.nondated'></span>

<h3>Description</h3>

<p>The data were collected by J.M. Rudrauf on Alsacian castles whose building period is unknown.
On each castle, he measured 4 structural parameters on a sample of building stones. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(castles.nondated)</code></pre>


<h3>Format</h3>

<p><code>castles.nondated</code> is a list of two data frames:
</p>

<ul>
<li><p><code>castles.nondated$stones</code>: this first data frame has 1280 cases (rows) and 5 variables (columns) that are named
<code>height, width, edging, boss</code> (numeric) and <code>castle</code> (factor).
</p>
</li>
<li><p><code>castles.nondated$periods</code>: this second data frame has 67 cases and 2 variables named <code>castle</code> and <code>period</code>; the column <code>castle</code> corresponds to the levels of the factor <code>castle</code> of the first data frame; the column <code>period</code> is a factor indicating NA as the building period is unknown.
</p>
</li></ul>

<p>Notice that the data frames corresponding to the castles whose building period is known are those in <code><a href="#topic+castles.dated">castles.dated</a></code>.
</p>


<h3>Source</h3>

<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution a l'etude de l'architecture medievale: les caracteristiques des pierres a bossage des chateaux forts alsaciens. Centre de Recherches Archeologiques Medievales de Saverne, 5, 5-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.nondated)
summary(castles.nondated$stones)
summary(castles.nondated$periods)
</code></pre>

<hr>
<h2 id='cor.folder'>
Correlation matrices of a folder of data sets
</h2><span id='topic+cor.folder'></span>

<h3>Description</h3>

<p>Computes the correlation matrices of the elements of an object of class <code>folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.folder(x, use = "everything", method = "pearson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor.folder_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="cor.folder_+3A_use">use</code></td>
<td>

<p>an optional character string giving a method for computing covariances in the presence of missing values. This must be (an abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot; (see <code><a href="stats.html#topic+var">var</a></code>).
</p>
</td></tr>
<tr><td><code id="cor.folder_+3A_method">method</code></td>
<td>

<p>a character string indicating which correlation coefficient (or covariance) is to be computed. One of &quot;pearson&quot; (default), &quot;kendall&quot;, or &quot;spearman&quot;: can be abbreviated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses <code><a href="stats.html#topic+cor">cor</a></code> to compute the variance matrix of the numeric columns of each element of the folder. If some columns of the data frames are not numeric, there is a warning, and the variances are computed on the numeric columns only.
</p>


<h3>Value</h3>

<p>A list whose elements are the correlation matrices of the elements of the folder.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code> to create an object is of class <code>folder</code>.
<code><a href="#topic+mean.folder">mean.folder</a></code>, <code><a href="#topic+var.folder">var.folder</a></code>, <code><a href="#topic+skewness.folder">skewness.folder</a></code>, <code><a href="#topic+kurtosis.folder">kurtosis.folder</a></code> for other statistics for <code>folder</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: iris (Fisher)               
data(iris)
iris.fold &lt;- as.folder(iris, "Species")
iris.cor &lt;- cor.folder(iris.fold)
print(iris.cor)

# Second example: roses
data(roses)
roses.fold &lt;- as.folder(roses, "rose")
roses.cor &lt;- cor.folder(roses.fold)
print(roses.cor)
</code></pre>

<hr>
<h2 id='cut.data.frame'>
Change numeric variables into factors
</h2><span id='topic+cut.data.frame'></span>

<h3>Description</h3>

<p>This function changes numerical columns of a data frame <code>x</code> into factors. For each of these columns, its range is divided into intervals and the values of this column is recoded according to which interval they fall.
</p>
<p>For that, <code><a href="base.html#topic+cut">cut</a></code> is applied to each column of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
cut(x, breaks, labels = NULL, include.lowest = FALSE, right = TRUE, dig.lab = 3L,
    ordered_result = FALSE, cutcol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.data.frame_+3A_x">x</code></td>
<td>

<p>data frame (can also be a tibble).
</p>
</td></tr>       
<tr><td><code id="cut.data.frame_+3A_breaks">breaks</code></td>
<td>

<p>list or numeric.
</p>

<ul>
<li><p> If breaks is a list, its length is equal to the number of columns in the data frame. It can be:
</p>

<ul>
<li><p> a list of numeric vectors.
The <code class="reqn">j^{th}</code> element corresponds to the column <code>x[, j]</code>, and is a vector of two or more unique cut points
</p>
</li>
<li><p> or a list of single numbers (each greater or equal to 2).
<code>breaks[[j]]</code> element gives the number of intervals into which th <code class="reqn">j^{th}</code> variable of the folder is to be cut.
The elements <code>breaks[[j]]</code> corresponding to non-numeric columns must be NULL; if not, there is a warning.
</p>
</li></ul>

</li>
<li><p> If breaks is a numeric vector, it gives the number of intervals into which every column <code>x[, j]</code> is to be cut (see <code><a href="base.html#topic+cut">cut</a></code>).
</p>
</li></ul>

</td></tr>
<tr><td><code id="cut.data.frame_+3A_labels">labels</code></td>
<td>

<p>list of character vectors. If given, its length is equal to the number of columns of x.
<code>labels[[j]]</code> gives the labels for the intervals of the <code class="reqn">j^{th}</code> columns of the data frame.
By default, the <code>labels</code> are constructed using &quot;(a,b]&quot; interval notation.
If <code>labels = FALSE</code>, simple integer codes are returned instead of a factor.
</p>
<p>See <code><a href="base.html#topic+cut">cut</a></code>.
</p>
</td></tr>
<tr><td><code id="cut.data.frame_+3A_include.lowest">include.lowest</code></td>
<td>

<p>logical, indicating if, for each column <code>x[, j]</code>, an <code>x[i, j]</code> equal to the lowest (or highest, for <code>right = FALSE</code>) 'breaks' value should be included (see <code><a href="base.html#topic+cut">cut</a></code>).
</p>
</td></tr>
<tr><td><code id="cut.data.frame_+3A_right">right</code></td>
<td>

<p>logical, indicating if the intervals should be closed on the right (and open on the left) or vice versa (see <code><a href="base.html#topic+cut">cut</a></code>).
</p>
</td></tr>
<tr><td><code id="cut.data.frame_+3A_dig.lab">dig.lab</code></td>
<td>

<p>integer or integer vector, which is used when labels are not given.
It determines the number of digits used in formatting the break numbers.
</p>

<ul>
<li><p> If it is a single value, it gives the number of digits for all variables of the folder (see <code><a href="base.html#topic+cut">cut</a></code>).
</p>
</li>
<li><p> If it is a list of integers, its length is equal to the number of variables, and the <code class="reqn">j^{th}</code> element gives the number of digits for the <code class="reqn">j^{th}</code> variable of the folder.
</p>
</li></ul>

</td></tr>
<tr><td><code id="cut.data.frame_+3A_ordered_result">ordered_result</code></td>
<td>

<p>logical: should the results be ordered factors? (see <code><a href="base.html#topic+cut">cut</a></code>)
</p>
</td></tr>
<tr><td><code id="cut.data.frame_+3A_cutcol">cutcol</code></td>
<td>

<p>numeric vector: indices of the columns to be converted into factors.
These columns must all be numeric. Otherwise, there is a warning.
</p>
</td></tr>
<tr><td><code id="cut.data.frame_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the same column and row names as <code>x</code>.
</p>
<p>If <code>cutcol</code> is given, each numeric column <code>x[, j]</code> whose number is contained in <code>cutcol</code> is replaced by a factor.
The other columns are unmodified.
</p>
<p>If any column <code>x[, j]</code> whose number is in <code>cutcol</code> is not numeric, it is unmodified.
</p>
<p>If <code>cutcol</code> is omitted, every numerical columns are replaced by factors.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("roses")
x &lt;- roses[roses$rose %in% c("A", "B"), c("Sha", "Sym", "Den", "rose")]

cut(x, breaks = 3)
cut(x, breaks = 5)
cut(x, breaks = c(0, 4, 6, 10))
cut(x, breaks = list(c(0, 6, 8, 10), c(0, 5, 7, 10), c(0, 6, 7, 10)))
cut(x, breaks = list(c(0, 6, 8, 10), c(0, 5, 7, 10)), cutcol = 1:2)
</code></pre>

<hr>
<h2 id='cut.folder'>
In a folder: change numeric variables into factors
</h2><span id='topic+cut.folder'></span>

<h3>Description</h3>

<p>This function applies to a <a href="#topic+folder">folder</a>. For each elements (data frames) of this folder, it changes its numerical columns into factors, using <code><a href="#topic+cut.data.frame">cut.data.frame</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'folder'
cut(x, breaks, labels = NULL, include.lowest = FALSE, right = TRUE, dig.lab = 3L,
    ordered_result = FALSE, cutcol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.folder_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+folder">folder</a></code>.
</p>
</td></tr>       
<tr><td><code id="cut.folder_+3A_breaks">breaks</code></td>
<td>

<p>list or numeric, defining the intervals into which the variables of each element of the folder is to be cut.
See <code><a href="#topic+cut.folder">cut.folder</a></code>.
</p>
</td></tr>
<tr><td><code id="cut.folder_+3A_labels">labels</code></td>
<td>

<p>list of character vectors. If not omitted, it gives the labels for the intervals of each column of the elements of <code>x</code>.
See <code><a href="#topic+cut.folder">cut.folder</a></code>.
</p>
</td></tr>
<tr><td><code id="cut.folder_+3A_include.lowest">include.lowest</code></td>
<td>

<p>logical, indicating if a value equal to the lowest (or highest, for <code>right = FALSE</code>) 'breaks' value should be included (see <code><a href="#topic+cut.folder">cut.folder</a></code>).
</p>
</td></tr>
<tr><td><code id="cut.folder_+3A_right">right</code></td>
<td>

<p>logical, indicating if the intervals should be closed on the right (and open on the left) or vice versa (see <code><a href="#topic+cut.folder">cut.folder</a></code>).
</p>
</td></tr>
<tr><td><code id="cut.folder_+3A_dig.lab">dig.lab</code></td>
<td>

<p>integer or integer vector, which is used when labels are not given.
It determines the number of digits used in formatting the break numbers.
See <code><a href="#topic+cut.folder">cut.folder</a></code>.
</p>
</td></tr>
<tr><td><code id="cut.folder_+3A_ordered_result">ordered_result</code></td>
<td>

<p>logical: should the results be ordered factors? (see <code><a href="#topic+cut.folder">cut.folder</a></code>)
</p>
</td></tr>
<tr><td><code id="cut.folder_+3A_cutcol">cutcol</code></td>
<td>

<p>numeric vector: indices of the columns of the elements of <code>x</code> to be converted into factors.
These columns must all be numeric. Otherwise, there is a warning.
See <code><a href="#topic+cut.folder">cut.folder</a></code>.
</p>
</td></tr>
<tr><td><code id="cut.folder_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>folder</code> with the same length and names as <code>x</code>.
Its elements (data frames) have the same column and row names as the elements of <code>x</code>.
</p>
<p>For more details, see <code><a href="#topic+cut.data.frame">cut.data.frame</a></code>
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("roses")

x &lt;- as.folder(roses[, c("Sha", "Den", "Sym", "rose")], groups = "rose")
summary(x)

x3 &lt;- cut(x, breaks = 3)
summary(x3)

x7 &lt;- cut(x, breaks = 7)
summary(x7)
</code></pre>

<hr>
<h2 id='ddchisqsym'>
Distance between probability distributions of discrete variables given samples   
</h2><span id='topic+ddchisqsym'></span>

<h3>Description</h3>

<p>Symmetrized chi-squared distance between two multivariate (<code class="reqn">q &gt; 1</code>) or univariate (<code class="reqn">q = 1</code>) discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddchisqsym(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddchisqsym_+3A_x1">x1</code>, <code id="ddchisqsym_+3A_x2">x2</code></td>
<td>

<p>vectors or data frames of <code class="reqn">q</code> columns (can also be a tibble).
</p>
<p>If they are data frames and have not the same column names, there is a warning.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_1</code> and <code class="reqn">p_2</code> denote the estimated probability distributions of the discrete samples <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. The symmetrized chi-squared distance between the discrete probability distributions of the samples are computed using the <code><a href="#topic+ddchisqsympar">ddchisqsympar</a></code> function.
</p>


<h3>Value</h3>

<p>The distance between the two probability distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddchisqsympar">ddchisqsympar</a></code>: chi-squared distance between two discrete distributions, given the probabilities on their common support.
</p>
<p>Other distances: <code><a href="#topic+ddhellinger">ddhellinger</a></code>, <code><a href="#topic+ddjeffreys">ddjeffreys</a></code>, <code><a href="#topic+ddjensen">ddjensen</a></code>, <code><a href="#topic+ddlp">ddlp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- c("A", "A", "B", "B")
x2 &lt;- c("A", "A", "A", "B", "B")
ddchisqsym(x1, x2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
ddchisqsym(x1, x2)
</code></pre>

<hr>
<h2 id='ddchisqsympar'>
Distance between discrete probability distributions given the probabilities on their common support
</h2><span id='topic+ddchisqsympar'></span>

<h3>Description</h3>

<p>Symmetrized chi-squared distance between two discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets) , given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddchisqsympar(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddchisqsympar_+3A_p1">p1</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The first probability distribution on the support.
</p>
</td></tr>
<tr><td><code id="ddchisqsympar_+3A_p2">p2</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The second probability distribution on the support.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chi-squared distance between two discrete distributions <code class="reqn">p_1</code> and <code class="reqn">p_2</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">\sum_x{(p_1(x) - p_2(x))^2}/p_2(x)</code>
</p>

<p>Then the symmetrized chi-squared distance is given by the formula:
</p>
<p style="text-align: center;"><code class="reqn">||p_1 - p_2|| = \sum_x{(p_1(x) - p_2(x))^2}/(p_1(x) + p_2(x))</code>
</p>



<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddchisqsym">ddchisqsym</a></code>: chi-squared distance between two estimated discrete distributions, given samples.
</p>
<p>Other distances: <code><a href="#topic+ddhellingerpar">ddhellingerpar</a></code>, <code><a href="#topic+ddjeffreyspar">ddjeffreyspar</a></code>, <code><a href="#topic+ddjensenpar">ddjensenpar</a></code>, <code><a href="#topic+ddlppar">ddlppar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
p1 &lt;- array(c(1/2, 1/2), dimnames = list(c("a", "b"))) 
p2 &lt;- array(c(1/4, 3/4), dimnames = list(c("a", "b"))) 
ddchisqsympar(p1, p2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
p1 &lt;- table(x1)/nrow(x1)                 
p2 &lt;- table(x2)/nrow(x2)
ddchisqsympar(p1, p2)
</code></pre>

<hr>
<h2 id='ddhellinger'>
Distance between probability distributions of discrete variables given samples   
</h2><span id='topic+ddhellinger'></span>

<h3>Description</h3>

<p>Hellinger (or Matusita) distance between two multivariate (<code class="reqn">q &gt; 1</code>) or univariate (<code class="reqn">q = 1</code>) discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddhellinger(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddhellinger_+3A_x1">x1</code>, <code id="ddhellinger_+3A_x2">x2</code></td>
<td>

<p>data frames of <code class="reqn">q</code> columns or vectors (can also be tibbles).
</p>
<p>If they are data frames and have not the same column names, there is a warning.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_1</code> and <code class="reqn">p_2</code> denote the estimated probability distributions of the discrete samples <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. The Matusita distance between the discrete probability distributions of the samples are computed using the <code><a href="#topic+ddhellingerpar">ddhellingerpar</a></code> function.
</p>


<h3>Value</h3>

<p>The distance between the two probability distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddhellingerpar">ddhellingerpar</a></code>: Hellinger metric (Matusita distance)  between two discrete distributions, given the on their common support probabilities.
</p>
<p>Other distances: <code><a href="#topic+ddchisqsym">ddchisqsym</a></code>, <code><a href="#topic+ddjeffreys">ddjeffreys</a></code>, <code><a href="#topic+ddjensen">ddjensen</a></code>, <code><a href="#topic+ddlp">ddlp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- c("A", "A", "B", "B")
x2 &lt;- c("A", "A", "A", "B", "B")
ddhellinger(x1, x2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
ddhellinger(x1, x2)
</code></pre>

<hr>
<h2 id='ddhellingerpar'>
Distance between discrete probability distributions given the probabilities on their common support
</h2><span id='topic+ddhellingerpar'></span>

<h3>Description</h3>

<p>Hellinger (or Matusita) distance between two discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets) , given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddhellingerpar(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddhellingerpar_+3A_p1">p1</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The first probability distribution on the support.
</p>
</td></tr>
<tr><td><code id="ddhellingerpar_+3A_p2">p2</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The second probability distribution on the support.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hellinger distance between two discrete distributions <code class="reqn">p_1</code> and <code class="reqn">p_2</code> is given by:
<code class="reqn">\sqrt{ \sum_x{(\sqrt{p_1(x)} - \sqrt{p_2(x)})^2}} </code>
</p>
<p>Notice that some authors divide this expression by <code class="reqn">\sqrt{2}</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddhellinger">ddhellinger</a></code>: Hellinger distance between two estimated discrete distributions, given samples.
</p>
<p>Other distances: <code><a href="#topic+ddchisqsympar">ddchisqsympar</a></code>, <code><a href="#topic+ddjeffreyspar">ddjeffreyspar</a></code>, <code><a href="#topic+ddjensenpar">ddjensenpar</a></code>, <code><a href="#topic+ddlppar">ddlppar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
p1 &lt;- array(c(1/2, 1/2), dimnames = list(c("a", "b"))) 
p2 &lt;- array(c(1/4, 3/4), dimnames = list(c("a", "b"))) 
ddhellingerpar(p1, p2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
p1 &lt;- table(x1)/nrow(x1)                 
p2 &lt;- table(x2)/nrow(x2)
ddhellingerpar(p1, p2)
</code></pre>

<hr>
<h2 id='ddjeffreys'>
Divergence between probability distributions of discrete variables given samples   
</h2><span id='topic+ddjeffreys'></span>

<h3>Description</h3>

<p>jeffreys's divergence (symmetrized Kullback-Leibler divergence) between two multivariate (<code class="reqn">q &gt; 1</code>) or univariate (<code class="reqn">q = 1</code>) discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddjeffreys(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddjeffreys_+3A_x1">x1</code>, <code id="ddjeffreys_+3A_x2">x2</code></td>
<td>

<p>vectors or data frames of <code class="reqn">q</code> columns (can also be a tibble).
</p>
<p>If they are data frames and have not the same column names, there is a warning.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_1</code> and <code class="reqn">p_2</code> denote the estimated probability distributions of the discrete samples <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. The jeffreys's divergence between the discrete probability distributions of the samples are computed using the <code><a href="#topic+ddjeffreyspar">ddjeffreyspar</a></code> function.
</p>


<h3>Value</h3>

<p>The divergence between the two probability distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddjeffreyspar">ddjeffreyspar</a></code>: Jeffrey's distances  between two discrete distributions, given the probabilities on their common support.
</p>
<p>Other distances: <code><a href="#topic+ddchisqsym">ddchisqsym</a></code>, <code><a href="#topic+ddhellinger">ddhellinger</a></code>, <code><a href="#topic+ddjensen">ddjensen</a></code>, <code><a href="#topic+ddlp">ddlp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- c("A", "A", "B", "B")
x2 &lt;- c("A", "A", "A", "B", "B")
ddjeffreys(x1, x2)

# Example 2 (Its value can be infinity -Inf-)
x1 &lt;- c("A", "A", "B", "C")
x2 &lt;- c("A", "A", "A", "B", "B")
ddjeffreys(x1, x2)

# Example 3
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
ddjeffreys(x1, x2)
</code></pre>

<hr>
<h2 id='ddjeffreyspar'>
Distance between discrete probability distributions given the probabilities on their common support
</h2><span id='topic+ddjeffreyspar'></span>

<h3>Description</h3>

<p>Jeffreys divergence (symmetrized Kullback-Leibler divergence) between two discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets) , given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddjeffreyspar(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddjeffreyspar_+3A_p1">p1</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The first probability distribution on the support.
</p>
</td></tr>
<tr><td><code id="ddjeffreyspar_+3A_p2">p2</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The second probability distribution on the support.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Jeffreys divergence <code class="reqn">||p_1 - p_2||</code> between two discrete distributions <code class="reqn">p_1</code> and <code class="reqn">p_2</code> is given by the formula:
</p>
<p style="text-align: center;"><code class="reqn">||p_1 - p_2|| = \sum_x{(p_1(x) - p_2(x)) log(p_1(x)/p_2(x))}</code>
</p>



<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddjeffreys">ddjeffreys</a></code>: Jeffreys distance between two estimated discrete distributions, given samples.
</p>
<p>Other distances: <code><a href="#topic+ddchisqsympar">ddchisqsympar</a></code>, <code><a href="#topic+ddhellingerpar">ddhellingerpar</a></code>, <code><a href="#topic+ddjensenpar">ddjensenpar</a></code>, <code><a href="#topic+ddlppar">ddlppar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
p1 &lt;- array(c(1/2, 1/2), dimnames = list(c("a", "b"))) 
p2 &lt;- array(c(1/4, 3/4), dimnames = list(c("a", "b"))) 
ddjeffreyspar(p1, p2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
p1 &lt;- table(x1)/nrow(x1)                 
p2 &lt;- table(x2)/nrow(x2)
ddjeffreyspar(p1, p2)
</code></pre>

<hr>
<h2 id='ddjensen'>
Divergence between probability distributions of discrete variables given samples   
</h2><span id='topic+ddjensen'></span>

<h3>Description</h3>

<p>Jensen-Shannon divergence between two multivariate (<code class="reqn">q &gt; 1</code>) or univariate (<code class="reqn">q = 1</code>) discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddjensen(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddjensen_+3A_x1">x1</code>, <code id="ddjensen_+3A_x2">x2</code></td>
<td>

<p>vectors or data frames of <code class="reqn">q</code> columns (can also be tibbles).
</p>
<p>If they are data frames and have not the same column names, there is a warning.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_1</code> and <code class="reqn">p_2</code> denote the estimated probability distributions of the discrete samples <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. The Jensen-Shannon divergence between the discrete probability distributions of the samples are computed using the <code><a href="#topic+ddjensenpar">ddjensenpar</a></code> function.
</p>


<h3>Value</h3>

<p>The distance between the two probability distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddjensenpar">ddjensenpar</a></code>: Jensen-Shannon distance between two discrete distributions, given the probabilities on their common support.
</p>
<p>Other distances: <code><a href="#topic+ddchisqsym">ddchisqsym</a></code>, <code><a href="#topic+ddhellinger">ddhellinger</a></code>, <code><a href="#topic+ddjeffreys">ddjeffreys</a></code>, <code><a href="#topic+ddlp">ddlp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- c("A", "A", "B", "B")
x2 &lt;- c("A", "A", "A", "B", "B")
ddjensen(x1, x2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
ddjensen(x1, x2)
</code></pre>

<hr>
<h2 id='ddjensenpar'>
Divergence between discrete probability distributions given the probabilities on their common support
</h2><span id='topic+ddjensenpar'></span>

<h3>Description</h3>

<p>Jensen-Shannon divergence between two discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets), given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddjensenpar(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddjensenpar_+3A_p1">p1</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The first probability distribution on the support.
</p>
</td></tr>
<tr><td><code id="ddjensenpar_+3A_p2">p2</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The second probability distribution on the support.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jensen-Shannon divergence <code class="reqn">||p_1 - p_2||</code> between two discrete distributions <code class="reqn">p_1</code> and <code class="reqn">p_2</code> is given by the formula:
</p>
<p style="text-align: center;"><code class="reqn">||p_1 - p_2|| = \sum_x{(p_1(x) log(2 p_1(x) / (p_1(x)+p_2(x)))) + (p_2(x) log(2 p_2(x) / (p_1(x)+p_2(x))))}</code>
</p>



<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddjensen">ddjensen</a></code>: Jensen-Shannon distance between two estimated discrete distributions, given samples.
</p>
<p>Other distances: <code><a href="#topic+ddchisqsympar">ddchisqsympar</a></code>, <code><a href="#topic+ddhellingerpar">ddhellingerpar</a></code>, <code><a href="#topic+ddjeffreyspar">ddjeffreyspar</a></code>, <code><a href="#topic+ddlppar">ddlppar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
p1 &lt;- array(c(1/2, 1/2), dimnames = list(c("a", "b"))) 
p2 &lt;- array(c(1/4, 3/4), dimnames = list(c("a", "b"))) 
ddjensenpar(p1, p2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
p1 &lt;- table(x1)/nrow(x1)                 
p2 &lt;- table(x2)/nrow(x2)
ddjensenpar(p1, p2)
</code></pre>

<hr>
<h2 id='ddlp'>
Distance between probability distributions of discrete variables given samples   
</h2><span id='topic+ddlp'></span>

<h3>Description</h3>

<p><code class="reqn">L^p</code> distance between two multivariate (<code class="reqn">q &gt; 1</code>) or univariate (<code class="reqn">q = 1</code>) discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddlp(x1, x2, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddlp_+3A_x1">x1</code>, <code id="ddlp_+3A_x2">x2</code></td>
<td>

<p>vectors or data frames of <code class="reqn">q</code> columns (can also be tibbles).
</p>
<p>If they are data frames and have not the same column names, there is a warning.
</p>
</td></tr>
<tr><td><code id="ddlp_+3A_p">p</code></td>
<td>

<p>integer. Parameter of the distance.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">p_1</code> and <code class="reqn">p_2</code> denote the estimated probability distributions of the discrete samples <code class="reqn">x_1</code> and <code class="reqn">x_2</code>. The <code class="reqn">L^p</code> distance between the discrete probability distributions of the samples are computed using the <code><a href="#topic+ddlppar">ddlppar</a></code> function.
</p>


<h3>Value</h3>

<p>The distance between the two discrete probability distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddlppar">ddlppar</a></code>: <code class="reqn">L^p</code> distance between two discrete distributions, given the probabilities on their common support.
</p>
<p>Other distances: <code><a href="#topic+ddchisqsym">ddchisqsym</a></code>, <code><a href="#topic+ddhellinger">ddhellinger</a></code>, <code><a href="#topic+ddjeffreys">ddjeffreys</a></code>, <code><a href="#topic+ddjensen">ddjensen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- c("A", "A", "B", "B")
x2 &lt;- c("A", "A", "A", "B", "B")
ddlp(x1, x2)
ddlp(x1, x2, p = 2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
ddlp(x1, x2)
</code></pre>

<hr>
<h2 id='ddlppar'>
Distance between discrete probability distributions given the probabilities on their common support
</h2><span id='topic+ddlppar'></span>

<h3>Description</h3>

<p><code class="reqn">L^p</code> distance between two discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets) , given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddlppar(p1, p2, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddlppar_+3A_p1">p1</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The first probability distribution on the support.
</p>
</td></tr>
<tr><td><code id="ddlppar_+3A_p2">p2</code></td>
<td>

<p>array (or table) the dimension of which is <code class="reqn">q</code>. The second probability distribution on the support.
</p>
</td></tr>
<tr><td><code id="ddlppar_+3A_p">p</code></td>
<td>

<p>integer. Parameter of the distance.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">L^p</code> distance <code class="reqn">||p_1 - p_2||</code> between two discrete distributions <code class="reqn">p_1</code> and <code class="reqn">p_2</code> is given by the formula:
</p>
<p style="text-align: center;"><code class="reqn">||p_1 - p_2||^p = \sum_x{|p_1(x)-p_2(x)|^p}</code>
</p>

<p>If <code class="reqn">p=1</code>, it is the variational distance.
</p>
<p>If <code class="reqn">p=2</code>, it is the Patrick-Fisher distance.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddlp">ddlp</a></code>: <code class="reqn">L^p</code> distance between two estimated discrete distributions, given samples.
</p>
<p>Other distances: <code><a href="#topic+ddchisqsympar">ddchisqsympar</a></code>, <code><a href="#topic+ddhellingerpar">ddhellingerpar</a></code>, <code><a href="#topic+ddjeffreyspar">ddjeffreyspar</a></code>, <code><a href="#topic+ddjensenpar">ddjensenpar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
p1 &lt;- array(c(1/2, 1/2), dimnames = list(c("a", "b"))) 
p2 &lt;- array(c(1/4, 3/4), dimnames = list(c("a", "b"))) 
ddlppar(p1, p2)
ddlppar(p1, p2, p=2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
p1 &lt;- table(x1)/nrow(x1)                 
p2 &lt;- table(x2)/nrow(x2)
ddlppar(p1, p2)
</code></pre>

<hr>
<h2 id='departments'>French departments and regions
</h2><span id='topic+departments'></span>

<h3>Description</h3>

<p>Departments and regions of metropolitan France.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(departments)</code></pre>


<h3>Format</h3>

<p><code>departments</code> is a data frame with 96 rows and 4 columns (factors):
</p>

<ul>
<li><p><code>coded: </code> departments: numbers
</p>
</li>
<li><p><code>named: </code> departments: names
</p>
</li>
<li><p><code>coder: </code> regions: ISO code
</p>
</li>
<li><p><code>namer: </code> region: names
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>Source</h3>

  
<p>INSEE. <a href="https://www.insee.fr/fr/information/3363419">Code officiel g\'eographique au 1er janvier 2018</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(departments)
print(departments)
</code></pre>

<hr>
<h2 id='discdd.misclass'>
Misclassification ratio in functional discriminant analysis of discrete probability distributions.
</h2><span id='topic+discdd.misclass'></span>

<h3>Description</h3>

<p>Computes the one-leave-out misclassification ratio of the rule assigning <code class="reqn">T</code> groups of individuals, one group after another, to the class of groups (among <code class="reqn">K</code> classes of groups) which achieves the minimum of the distances or divergences between the probability distribution associated to the group to assign and the <code class="reqn">K</code> probability distributions associated to the <code class="reqn">K</code> classes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discdd.misclass(xf, class.var, distance =  c("l1", "l2", "chisqsym", "hellinger",
           "jeffreys", "jensen", "lp"), crit = 1, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discdd.misclass_+3A_xf">xf</code></td>
<td>

<p>object of class <code><a href="#topic+folderh">folderh</a></code> with two data frames or list of arrays (or tables).
</p>

<ul>
<li><p> If it is a <code>folderh</code>:
</p>

<ul>
<li><p> The first data.frame has at least two columns. One column contains the names of the <code class="reqn">T</code> groups (all the names must be different). An other column is a factor with <code class="reqn">K</code> levels partitionning the T groups into K classes.
</p>
</li>
<li><p> The second one has <code class="reqn">(q+1)</code> columns. The first <code class="reqn">q</code> columns are factors (otherwise, they are coerced into factors). The last column is a factor with <code class="reqn">T</code> levels defining <code class="reqn">T</code> groups. Each group, say <code class="reqn">t</code>, consists of <code class="reqn">n_t</code> individuals.
</p>
</li></ul>

</li>
<li><p> If it is a list of arrays or tables, the <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) is the table of the joint distribution (absolute or relative frequencies) of the <code class="reqn">t^{th}</code> group. These arrays have the same shape:
</p>
<p>Each array (or table) <code>xf[[i]]</code> has:
</p>

<ul>
<li><p> the same dimension(s). If <code class="reqn">q = 1</code> (univariate), <code>dim(xf[[i]])</code> is an integer. If <code class="reqn">q &gt; 1</code> (multivariate), <code>dim(xf[[i]])</code> is an integer vector of length <code>q</code>.
</p>
</li>
<li><p> the same dimension names <code>dimnames(xf[[i]])</code> (is non <code>NULL</code>). These dimnames are the names of the variables.
</p>
</li></ul>

</li></ul>

</td></tr>       
<tr><td><code id="discdd.misclass_+3A_class.var">class.var</code></td>
<td>

<p>string (if <code>xf</code> is an object of class <code>"folderh"</code>) or data.frame with two columns (if <code>xf</code> is a list of arrays).
</p>

<ul>
<li><p> If <code>xf</code> is of class <code>"folder"</code>, <code>class.var</code> is the name of the class variable.
</p>
</li>
<li><p> If <code>xf</code> is a list of arrays or a list of tables, <code>class.var</code> is a data.frame with at least two columns named <code>"group"</code> and <code>"class"</code>.
The <code>"group"</code> column contains the names of the <code class="reqn">T</code> groups (all the names must be different). The <code>"class"</code> column is a factor with <code class="reqn">K</code> levels partitioning the <code class="reqn">T</code> groups into <code class="reqn">K</code> classes.
</p>
</li></ul>

</td></tr>
<tr><td><code id="discdd.misclass_+3A_distance">distance</code></td>
<td>

<p>The distance or dissimilarity used to compute the distance matrix between the densities.
It can be:
</p>

<ul>
<li> <p><code>"l1"</code> (default) the <code class="reqn">L^p</code> distance with <code class="reqn">p = 1</code>
</p>
</li>
<li> <p><code>"l2"</code> the <code class="reqn">L^p</code> distance with <code class="reqn">p = 2</code>
</p>
</li>
<li> <p><code>"chisqsym"</code> the symmetric Chi-squared distance
</p>
</li>
<li> <p><code>"hellinger"</code> the Hellinger metric (Matusita distance)
</p>
</li>
<li> <p><code>"jeffreys"</code> Jeffreys distance (symmetrised Kullback-Leibler divergence)
</p>
</li>
<li> <p><code>"jensen"</code> the Jensen-Shannon distance
</p>
</li>
<li> <p><code>"lp"</code> the <code class="reqn">L^p</code> distance with <code class="reqn">p</code> given by the argument <code>p</code> of the function.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="discdd.misclass_+3A_crit">crit</code></td>
<td>

<p>1 or 2. In order to select the densities associated to the classes. See Details.
</p>
</td></tr>
<tr><td><code id="discdd.misclass_+3A_p">p</code></td>
<td>

<p>integer. Optional. When <code>distance = "lp"</code> (<code class="reqn">L^p</code> distance with <code class="reqn">p&gt;2</code>), <code>p</code> is the parameter of the distance.
</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>xf</code> is an object of class <code>"folderh"</code> containing the data:
</p>
<p>The <code class="reqn">T</code> probability distributions <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> groups of individuals are estimated by frequency distributions within each group.
</p>
<p>To the class <code class="reqn">k</code> consisting of <code class="reqn">T_k</code> groups is associated the probability distribution <code class="reqn">g_k</code>,
knowing that when using the one-leave-out method, we do not include the group to assign in its class <code class="reqn">k</code>.
The <code>crit</code> argument selects the estimation method of the <code class="reqn">g_k</code>'s.
</p>

<ul>
<li><p><code>crit=1</code>
The probability distribution <code class="reqn">g_k</code> is estimated using the whole data of this class, that is the rows of <code>x</code> corresponding to the <code class="reqn">T_k</code> groups of the class <code class="reqn">k</code>.
</p>
<p>The estimation of the <code class="reqn">g_k</code>'s uses the same method as the estimation of the <code class="reqn">f_t</code>'s.
</p>
</li>
<li><p><code>crit=2</code>
The <code class="reqn">T_k</code> probability distributions <code class="reqn">f_t</code> are estimated using the corresponding data from <code>xf</code>. Then they are averaged to obtain an estimation of the density <code class="reqn">g_k</code>, that is <code class="reqn">g_k = \frac{1}{T_k} \, \sum{f_t}</code>.
</p>
</li></ul>

</li>
<li><p> If <code>xf</code> is a list of arrays (or list of tables):
</p>
<p>The <code class="reqn">t^{th}</code> array is the joint frequency distribution of the <code class="reqn">t^{th}</code> group. The frequencies can be absolute or relative.
</p>
<p>To the class <code class="reqn">k</code> consisting of <code class="reqn">T_k</code> groups is associated the probability distribution <code class="reqn">g_k</code>,
knowing that when using the one-leave-out method, we do not include the group to assign in its class <code class="reqn">k</code>.
The <code>crit</code> argument selects the estimation method of the <code class="reqn">g_k</code>'s.
</p>

<ul>
<li><p><code>crit=1</code>
<code class="reqn">g_k = \frac{1}{\sum n_t} \sum n_t f_t</code>,
where <code class="reqn">n_t</code> is the total of <code>xf[[t]]</code>.
</p>
<p>Notice that when <code>xf[[t]]</code> contains relative frequencies, its total is 1.
That is equivalent to <code>crit=2</code>.
</p>
</li>
<li><p><code>crit=2</code>
<code class="reqn">g_k = \frac{1}{T_k} \, \sum f_t</code>.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>discdd.misclass</code>, that is a list including:
</p>
<table>
<tr><td><code>classification</code></td>
<td>
<p>data frame with 4 columns:
</p>

<ul>
<li><p> factor giving the group name. The column name is the same as that of the column (<code class="reqn">q+1</code>) of <code>x</code>,
</p>
</li>
<li><p> the prior class of the group if it is available, or NA if not,
</p>
</li>
<li> <p><code>alloc</code>: the class allocation computed by the discriminant analysis method,
</p>
</li>
<li> <p><code>misclassed</code>: boolean. <code>TRUE</code> if the group is misclassed, <code>FALSE</code> if it is well-classed, <code>NA</code> if the prior class of the group is unknown.
</p>
</li></ul>

</td></tr>
<tr><td><code>confusion.mat</code></td>
<td>
<p>confusion matrix,</p>
</td></tr>
<tr><td><code>misalloc.per.class</code></td>
<td>
<p>the misclassification ratio per class,</p>
</td></tr>
<tr><td><code>misclassed</code></td>
<td>
<p>the misclassification ratio,</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>matrix with <code class="reqn">T</code> rows and <code class="reqn">K</code> columns, of the distances (<code class="reqn">d_{tk}</code>): <code class="reqn">d_{tk}</code> is the distance between the group <code class="reqn">t</code> and the class <code class="reqn">k</code>,</p>
</td></tr>
<tr><td><code>proximities</code></td>
<td>
<p>matrix of the proximity indices (in percents) between the groups and the classes. The proximity between the group <code class="reqn">t</code> and the class <code class="reqn">k</code> is: <code class="reqn">(1/d_{tk})/\sum_{l=1}^{l=K}(1/d_{tl})</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution à l'étude de l'architecture médiévale: les caractéristiques des pierres à bossage des châteaux forts alsaciens, Centre de Recherches Archéologiques médiévales de Saverne, 5, 5-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 with a folderh obtained by converting numeric variables
data("castles.dated")
stones &lt;- castles.dated$stones
periods &lt;- castles.dated$periods
stones$height &lt;- cut(stones$height, breaks = c(19, 27, 40, 71), include.lowest = TRUE)
stones$width &lt;- cut(stones$width, breaks = c(24, 45, 62, 144), include.lowest = TRUE)
stones$edging &lt;- cut(stones$edging, breaks = c(0, 3, 4, 8), include.lowest = TRUE)
stones$boss &lt;- cut(stones$boss, breaks = c(0, 6, 9, 20), include.lowest = TRUE )

castlefh &lt;- folderh(periods, "castle", stones)

# Default: dist="l1", crit=1
discdd.misclass(castlefh, "period")

# Hellinger distance, crit=2
discdd.misclass(castlefh, "period", distance = "hellinger", crit = 2)


# Example 2 with a list of 96 arrays
data("dspgd2015")
data("departments")
classes &lt;- departments[, c("coded", "namer")]
names(classes) &lt;- c("group", "class")

# Default: dist="l1", crit=1
discdd.misclass(dspgd2015, classes)

# Hellinger distance, crit=2
discdd.misclass(dspgd2015, classes, distance = "hellinger", crit = 2)
</code></pre>

<hr>
<h2 id='discdd.predict'>
Predicting the class of a group of individuals with discriminant analysis of probability distributions.
</h2><span id='topic+discdd.predict'></span>

<h3>Description</h3>

<p>Assigns several groups of individuals, one group after another, to the class of groups (among <code class="reqn">K</code> classes of groups) which achieves the minimum of the distances or divergences between the probability distribution associated to the group to assign and the <code class="reqn">K</code> probability distributions associated to the <code class="reqn">K</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discdd.predict(xf, class.var, distance =  c("l1", "l2", "chisqsym", "hellinger",
           "jeffreys", "jensen", "lp"), crit = 1, misclass.ratio = FALSE, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discdd.predict_+3A_xf">xf</code></td>
<td>

<p>object of class <code><a href="#topic+folderh">folderh</a></code> with two data frames or list of arrays (or tables).
</p>

<ul>
<li><p> If it is a <code>folderh</code>:
</p>

<ul>
<li><p> The first data.frame has at least two columns. One column contains the names of the <code class="reqn">T</code> groups (all the names must be different). An other column is a factor with <code class="reqn">K</code> levels partitionning the T groups into K classes.
</p>
</li>
<li><p> The second one has <code class="reqn">(q+1)</code> columns. The first <code class="reqn">q</code> columns are factors (otherwise, they are coerced into factors). The last column is a factor with <code class="reqn">T</code> levels defining <code class="reqn">T</code> groups. Each group, say <code class="reqn">t</code>, consists of <code class="reqn">n_t</code> individuals.
</p>
</li></ul>

</li>
<li><p> If it is a list of arrays or tables, the <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) is the table of the joint distribution (absolute or relative frequencies) of the <code class="reqn">t^{th}</code> group. These arrays have the same shape:
</p>
<p>Each array (or table) <code>xf[[i]]</code> has:
</p>

<ul>
<li><p> the same dimension(s). If <code class="reqn">q = 1</code> (univariate), <code>dim(xf[[i]])</code> is an integer. If <code class="reqn">q &gt; 1</code> (multivariate), <code>dim(xf[[i]])</code> is an integer vector of length <code>q</code>.
</p>
</li>
<li><p> the same dimension names <code>dimnames(xf[[i]])</code> (is non <code>NULL</code>). These dimnames are the names of the variables.
</p>
</li></ul>

</li></ul>

</td></tr>       
<tr><td><code id="discdd.predict_+3A_class.var">class.var</code></td>
<td>

<p>string (if <code>xf</code> is an object of class <code>"folderh"</code>) or data.frame with two columns (if <code>xf</code> is a list of arrays).
</p>

<ul>
<li><p> If <code>xf</code> is of class <code>"folder"</code>, <code>class.var</code> is the name of the class variable.
</p>
</li>
<li><p> If <code>xf</code> is a list of arrays or a list of tables, <code>class.var</code> is a data.frame with at least two columns named <code>"group"</code> and <code>"class"</code>.
The <code>"group"</code> column contains the names of the <code class="reqn">T</code> groups (all the names must be different). The <code>"class"</code> column is a factor with <code class="reqn">K</code> levels partitioning the <code class="reqn">T</code> groups into <code class="reqn">K</code> classes.
</p>
</li></ul>

</td></tr>
<tr><td><code id="discdd.predict_+3A_distance">distance</code></td>
<td>

<p>The distance or dissimilarity used to compute the distance matrix between the densities.
It can be:
</p>

<ul>
<li> <p><code>"l1"</code> (default) the <code class="reqn">L^p</code> distance with <code class="reqn">p = 1</code>
</p>
</li>
<li> <p><code>"l2"</code> the <code class="reqn">L^p</code> distance with <code class="reqn">p = 2</code>
</p>
</li>
<li> <p><code>"chisqsym"</code> the symmetric Chi-squared distance
</p>
</li>
<li> <p><code>"hellinger"</code> the Hellinger metric (Matusita distance)
</p>
</li>
<li> <p><code>"jeffreys"</code> Jeffreys distance (symmetrised Kullback-Leibler divergence)
</p>
</li>
<li> <p><code>"jensen"</code> the Jensen-Shannon distance
</p>
</li>
<li> <p><code>"lp"</code> the <code class="reqn">L^p</code> distance with <code class="reqn">p</code> given by the argument <code>p</code> of the function.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="discdd.predict_+3A_crit">crit</code></td>
<td>

<p>1 or 2. In order to select the densities associated to the classes. See Details.
</p>
</td></tr>
<tr><td><code id="discdd.predict_+3A_misclass.ratio">misclass.ratio</code></td>
<td>

<p>logical (default <code>FALSE</code>). If <code>TRUE</code>, the confusion matrix and misclassification ratio are computed on the groups whose prior class is known. In order to compute the misclassification ratio by the one-leave-out method, use the <code><a href="#topic+discdd.misclass">discdd.misclass</a></code> function.</p>
</td></tr>
<tr><td><code id="discdd.predict_+3A_p">p</code></td>
<td>

<p>integer. Optional. When <code>distance = "lp"</code> (<code class="reqn">L^p</code> distance with <code class="reqn">p&gt;2</code>), <code>p</code> is the parameter of the distance.
</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>xf</code> is an object of class <code>"folderh"</code> containing the data:
</p>
<p>The <code class="reqn">T</code> probability distributions <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> groups of individuals are estimated by frequency distributions within each group.
</p>
<p>To the class <code class="reqn">k</code> consisting of <code class="reqn">T_k</code> groups is associated the probability distribution <code class="reqn">g_k</code>.
The <code>crit</code> argument selects the estimation method of the <code class="reqn">g_k</code>'s.
</p>

<ul>
<li><p><code>crit=1</code>
The probability distribution <code class="reqn">g_k</code> is estimated using the whole data of this class, that is the rows of <code>x</code> corresponding to the <code class="reqn">T_k</code> groups of the class <code class="reqn">k</code>.
</p>
<p>The estimation of the <code class="reqn">g_k</code>'s uses the same method as the estimation of the <code class="reqn">f_t</code>'s.
</p>
</li>
<li><p><code>crit=2</code>
The <code class="reqn">T_k</code> probability distributions <code class="reqn">f_t</code> are estimated using the corresponding data from <code>xf</code>. Then they are averaged to obtain an estimation of the density <code class="reqn">g_k</code>, that is <code class="reqn">g_k = \frac{1}{T_k} \, \sum{f_t}</code>.
</p>
</li></ul>

</li>
<li><p> If <code>xf</code> is a list of arrays (or list of tables):
</p>
<p>The <code class="reqn">t^{th}</code> array is the joint frequency distribution of the <code class="reqn">t^{th}</code> group. The frequencies can be absolute or relative.
</p>
<p>To the class <code class="reqn">k</code> consisting of <code class="reqn">T_k</code> groups is associated the probability distribution <code class="reqn">g_k</code>.
The <code>crit</code> argument selects the estimation method of the <code class="reqn">g_k</code>'s.
</p>

<ul>
<li><p><code>crit=1</code>
<code class="reqn">g_k = \frac{1}{\sum n_t} \sum n_t f_t</code>,
where <code class="reqn">n_t</code> is the total of <code>xf[[t]]</code>.
</p>
<p>Notice that when <code>xf[[t]]</code> contains relative frequencies, its total is 1.
That is equivalent to <code>crit=2</code>.
</p>
</li>
<li><p><code>crit=2</code>
<code class="reqn">g_k = \frac{1}{T_k} \, \sum f_t</code>.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>discdd.predict</code>, that is a list including:
</p>
<table>
<tr><td><code>prediction</code></td>
<td>
<p>data frame with 3 columns:
</p>

<ul>
<li><p> factor giving the group name. The column name is the same as that of the column (<code class="reqn">q+1</code>) of <code>x</code>,
</p>
</li>
<li> <p><code>class.known</code>: the prior class of the group if it is available, or NA if not,  
</p>
</li>
<li> <p><code>class.predict</code>: the class allocation predicted by the discriminant analysis method. If <code>misclass.ratio = TRUE</code>, the class allocations are computed for all groups. Otherwise (default), they are computed only for the groups whose class is unknown.
</p>
</li></ul>

</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>matrix with <code class="reqn">T</code> rows and <code class="reqn">K</code> columns, of the distances (<code class="reqn">d_{tk}</code>): <code class="reqn">d_{tk}</code> is the distance between the group <code class="reqn">t</code> and the class <code class="reqn">k</code>, computed with the measure given by argument,</p>
</td></tr>
<tr><td><code>proximities</code></td>
<td>
<p>matrix of the proximities (in percents). The proximity of a group <code class="reqn">t</code> to the class <code class="reqn">k</code> is computed as so: <code class="reqn">(1/d_{tk})/\sum_{l=1}^{l=K}(1/d_{tl})</code>.</p>
</td></tr>
<tr><td><code>confusion.mat</code></td>
<td>
<p>the confusion matrix (if <code>misclass.ratio = TRUE</code>)</p>
</td></tr>
<tr><td><code>misclassed</code></td>
<td>
<p>the misclassification ratio (if <code>misclass.ratio = TRUE</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution à l'étude de l'architecture médiévale: les caractéristiques des pierres à bossage des châteaux forts alsaciens, Centre de Recherches Archéologiques médiévales de Saverne, 5, 5-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
data(castles.nondated)
stones &lt;- rbind(castles.dated$stones, castles.nondated$stones)
periods &lt;- rbind(castles.dated$periods, castles.nondated$periods)
stones$height &lt;- cut(stones$height, breaks = c(19, 27, 40, 71), include.lowest = TRUE)
stones$width &lt;- cut(stones$width, breaks = c(24, 45, 62, 144), include.lowest = TRUE)
stones$edging &lt;- cut(stones$edging, breaks = c(0, 3, 4, 8), include.lowest = TRUE)
stones$boss &lt;- cut(stones$boss, breaks = c(0, 6, 9, 20), include.lowest = TRUE )

castlesfh &lt;- folderh(periods, "castle", stones)

# Default: dist="l1", crit=1
discdd.predict(castlesfh, "period")

# With the calculation of the confusion matrix and misclassification ratio
discdd.predict(castlesfh, "period", misclass.ratio = TRUE)

# Hellinger distance
discdd.predict(castlesfh, "period", distance = "hellinger")

# crit=2
discdd.predict(castlesfh, "period", crit = 2)
</code></pre>

<hr>
<h2 id='distl2d'>
<code class="reqn">L^2</code> distance between probability densities
</h2><span id='topic+distl2d'></span>

<h3>Description</h3>

<p><code class="reqn">L^2</code> distance between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (dimension: <code class="reqn">p = 1</code>) probability densities, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distl2d(x1, x2, method = "gaussiand", check = FALSE, varw1 = NULL, varw2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distl2d_+3A_x1">x1</code>, <code id="distl2d_+3A_x2">x2</code></td>
<td>

<p>the samples from the probability densities (see <code><a href="#topic+l2d">l2d</a></code>).
</p>
</td></tr>
<tr><td><code id="distl2d_+3A_method">method</code></td>
<td>

<p>string.  It can be:
</p>

<ul>
<li> <p><code>"gaussiand"</code> if the densities are considered to be Gaussian.
</p>
</li>
<li> <p><code>"kern"</code> if they are estimated using the Gaussian kernel method.
</p>
</li></ul>

</td></tr>
<tr><td><code id="distl2d_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices (if <code>method = "gaussiand"</code>) or smoothing bandwidth matrices (if <code>method = "kern"</code>) are not degenerate, before computing the inner product. 
</p>
<p>Notice that if <code class="reqn">p = 1</code>, it checks if the variances or smoothing parameters are not zero.
</p>
</td></tr>
<tr><td><code id="distl2d_+3A_varw1">varw1</code>, <code id="distl2d_+3A_varw2">varw2</code></td>
<td>

<p>the bandwidths when the densities are estimated by the kernel method (see <code><a href="#topic+l2d">l2d</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>distl2d</code> computes the distance between <code class="reqn">f_1</code> and <code class="reqn">f_2</code> from the formula
</p>
<p style="text-align: center;"><code class="reqn">||f_1 - f_2||^2 = &lt;f_1, f_1&gt; + &lt;f_2, f_2&gt; - 2 &lt;f_1, f_2&gt;</code>
</p>

<p>For some information about the method used to compute the <code class="reqn">L^2</code> inner product or about the arguments, see <code><a href="#topic+l2d">l2d</a></code>.
</p>


<h3>Value</h3>

<p>The <code class="reqn">L^2</code> distance between the two densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one smoothing bandwidth matrix is degenerate, the result returned can not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matdistl2d">matdistl2d</a></code> in order to compute pairwise distances between several densities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
m1 &lt;- c(0,0)
v1 &lt;- matrix(c(1,0,0,1),ncol = 2) 
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(4,1,1,9),ncol = 2)
x1 &lt;- mvrnorm(n = 3,mu = m1,Sigma = v1)
x2 &lt;- mvrnorm(n = 5, mu = m2, Sigma = v2)
distl2d(x1, x2, method = "gaussiand")
distl2d(x1, x2, method = "kern")
distl2d(x1, x2, method = "kern", varw1 = v1, varw2 = v2)
</code></pre>

<hr>
<h2 id='distl2dnorm'>
<code class="reqn">L^2</code> distance between <code class="reqn">L^2</code>-normed probability densities
</h2><span id='topic+distl2dnorm'></span>

<h3>Description</h3>

<p><code class="reqn">L^2</code> distance between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (dimension: <code class="reqn">p = 1</code>) <code class="reqn">L^2</code>-normed probability densities, estimated from samples, where a <code class="reqn">L^2</code>-normed probability density is the original probability density function divided by its <code class="reqn">L^2</code>-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distl2dnorm(x1, x2, method = "gaussiand", check = FALSE, varw1 = NULL, varw2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distl2dnorm_+3A_x1">x1</code>, <code id="distl2dnorm_+3A_x2">x2</code></td>
<td>

<p>the samples from the probability densities (see <code><a href="#topic+l2d">l2d</a></code>.
</p>
</td></tr>
<tr><td><code id="distl2dnorm_+3A_method">method</code></td>
<td>

<p>string.  It can be:
</p>

<ul>
<li> <p><code>"gaussiand"</code> if the densities are considered to be Gaussian.
</p>
</li>
<li> <p><code>"kern"</code> if they are estimated using the Gaussian kernel method.
</p>
</li></ul>

</td></tr>
<tr><td><code id="distl2dnorm_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices (if <code>method = "gaussiand"</code>) or smoothing bandwidth matrices (if <code>method = "kern"</code>) are not degenerate, before computing the inner product. 
</p>
<p>Notice that if <code class="reqn">p = 1</code>, it checks if the variances or smoothing parameters are not zero.
</p>
</td></tr>
<tr><td><code id="distl2dnorm_+3A_varw1">varw1</code>, <code id="distl2dnorm_+3A_varw2">varw2</code></td>
<td>

<p>the bandwidths when the densities are estimated by the kernel method (see <code><a href="#topic+l2d">l2d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given  densities <code class="reqn">f_1</code> and <code class="reqn">f_2</code>, the function <code>distl2dnormpar</code> computes the distance between the <code class="reqn">L^2</code>-normed densities <code class="reqn">f_1 / ||f_1||</code> and <code class="reqn">f_2 / ||f_2||</code>:
</p>
<p style="text-align: center;"><code class="reqn">2 - 2 &lt;f_1, f_2&gt; / (||f_1|| ||f_2||)</code>
</p>

<p>For some information about the method used to compute the <code class="reqn">L^2</code> inner product or about the arguments, see <code><a href="#topic+l2d">l2d</a></code>.
</p>


<h3>Value</h3>

<p>The <code class="reqn">L^2</code> distance between the two <code class="reqn">L^2</code>-normed densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one smoothing bandwidth matrix is degenerate, the result returned can not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distl2d">distl2d</a></code> for the distance between two probability densities.
</p>
<p><code><a href="#topic+matdistl2dnorm">matdistl2dnorm</a></code> in order to compute pairwise distances between several <code class="reqn">L^2</code>-normed densities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
m1 &lt;- c(0,0)
v1 &lt;- matrix(c(1,0,0,1),ncol = 2) 
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(4,1,1,9),ncol = 2)
x1 &lt;- mvrnorm(n = 3,mu = m1,Sigma = v1)
x2 &lt;- mvrnorm(n = 5, mu = m2, Sigma = v2)
distl2dnorm(x1, x2, method = "gaussiand")
distl2dnorm(x1, x2, method = "kern")
distl2dnorm(x1, x2, method = "kern", varw1 = v1, varw2 = v2)
</code></pre>

<hr>
<h2 id='distl2dnormpar'>
<code class="reqn">L^2</code> distance between <code class="reqn">L^2</code>-normed Gaussian densities given their parameters
</h2><span id='topic+distl2dnormpar'></span>

<h3>Description</h3>

<p><code class="reqn">L^2</code> distance between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (dimension: <code class="reqn">p = 1</code>) <code class="reqn">L^2</code>-normed Gaussian densities, given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate) where a <code class="reqn">L^2</code>-normed probability density is the original probability density function divided by its <code class="reqn">L^2</code>-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distl2dnormpar(mean1, var1, mean2, var2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distl2dnormpar_+3A_mean1">mean1</code>, <code id="distl2dnormpar_+3A_mean2">mean2</code></td>
<td>

<p>means of the probability densities.
</p>
</td></tr>
<tr><td><code id="distl2dnormpar_+3A_var1">var1</code>, <code id="distl2dnormpar_+3A_var2">var2</code></td>
<td>

<p>variances (<code class="reqn">p</code> = 1) or covariance matrices (<code class="reqn">p</code> &gt; 1) of the probability densities.
</p>
</td></tr>
<tr><td><code id="distl2dnormpar_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate, before computing the inner product.
</p>
<p>If the variables are univariate, it checks if the variances are not zero.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given  densities <code class="reqn">f_1</code> and <code class="reqn">f_2</code>, the function <code>distl2dnormpar</code> computes the distance between the <code class="reqn">L^2</code>-normed densities <code class="reqn">f_1 / ||f_1||</code> and <code class="reqn">f_2 / ||f_2||</code>:
</p>
<p style="text-align: center;"><code class="reqn">2 - 2 &lt;f_1, f_2&gt; / (||f_1|| ||f_2||)</code>
</p>
<p>.
</p>
<p>For some information about the method used to compute the <code class="reqn">L^2</code> inner product or about the arguments, see <code><a href="#topic+l2dpar">l2dpar</a></code>; the norm <code class="reqn">||f||</code> of the multivariate Gaussian density <code class="reqn">f</code> is equal to <code class="reqn">(4\pi)^{-p/4} det(var)^{-1/4}</code>.
</p>


<h3>Value</h3>

<p>The <code class="reqn">L^2</code> distance between the two <code class="reqn">L^2</code>-normed Gaussian densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one variance matrix is degenerated (or one variance is zero if the densities are univariate), the result returned must not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distl2dpar">distl2dpar</a></code> for the distance between two probability densities.
</p>
<p><code><a href="#topic+matdistl2d">matdistl2d</a></code> in order to compute pairwise distances between several densities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u1 &lt;- c(1,1,1);
v1 &lt;- matrix(c(4,0,0,0,16,0,0,0,25),ncol = 3);
u2 &lt;- c(0,1,0);
v2 &lt;- matrix(c(1,0,0,0,1,0,0,0,1),ncol = 3);
distl2dnormpar(u1,v1,u2,v2)
</code></pre>

<hr>
<h2 id='distl2dpar'>
<code class="reqn">L^2</code> distance between Gaussian densities given their parameters
</h2><span id='topic+distl2dpar'></span>

<h3>Description</h3>

<p><code class="reqn">L^2</code> distance between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (dimension: <code class="reqn">p = 1</code>) Gaussian densities, given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distl2dpar(mean1, var1, mean2, var2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distl2dpar_+3A_mean1">mean1</code>, <code id="distl2dpar_+3A_mean2">mean2</code></td>
<td>

<p>means of the probability densities.
</p>
</td></tr>
<tr><td><code id="distl2dpar_+3A_var1">var1</code>, <code id="distl2dpar_+3A_var2">var2</code></td>
<td>

<p>variances (<code class="reqn">p</code> = 1) or covariance matrices (<code class="reqn">p</code> &gt; 1) of the probability densities.
</p>
</td></tr>
<tr><td><code id="distl2dpar_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate, before computing the inner product.
</p>
<p>If the variables are univariate, it checks if the variances are not zero.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>distl2dpar</code> computes the distance between two densities, say <code class="reqn">f_1</code> and <code class="reqn">f_2</code>, from the formula:
</p>
<p style="text-align: center;"><code class="reqn">||f_1 - f_2||^2 = &lt;f_1, f_1&gt; + &lt;f_2, f_2&gt; - 2 &lt;f_1, f_2&gt;</code>
</p>
<p>.
</p>
<p>For some information about the method used to compute the <code class="reqn">L^2</code> inner product or about the arguments, see <code><a href="#topic+l2dpar">l2dpar</a></code>.
</p>


<h3>Value</h3>

<p>The <code class="reqn">L^2</code> distance between the two densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one variance matrix is degenerated (or one variance is zero if the densities are univariate), the result returned must not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matdistl2d">matdistl2d</a></code> in order to compute pairwise distances between several densities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u1 &lt;- c(1,1,1);
v1 &lt;- matrix(c(4,0,0,0,16,0,0,0,25),ncol = 3);
u2 &lt;- c(0,1,0);
v2 &lt;- matrix(c(1,0,0,0,1,0,0,0,1),ncol = 3);
distl2dpar(u1,v1,u2,v2)
</code></pre>

<hr>
<h2 id='dspg'>Diploma x Socio professional group
</h2><span id='topic+dspg'></span>

<h3>Description</h3>

<p>Contingency tables of the counts of Diploma x Socio professional group of France
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dspg)</code></pre>


<h3>Format</h3>

<p><code>dspg</code> is a list of 7 arrays (each one corresponding to a year: 1968, 1975, 1982, 1990, 1999, 2010, 2015) of 4 rows (each one corresponding to a level of diploma) and 6 columns (each one corresponding to a socio professional group). 
</p>

<ul>
<li><p><code>csp: </code> Socio professional group
</p>
</li>
<li><p><code>diplome: </code> Diploma
</p>
</li>
<li><p><code>agri: </code> farmer (agriculteur)
</p>
</li>
<li><p><code>arti: </code> craftsperson (artisan)
</p>
</li>
<li><p><code>cadr: </code> senior manager (cadre sup\'erieur)
</p>
</li>
<li><p><code>pint: </code> middle manager (profession interm\'ediaire)
</p>
</li>
<li><p><code>empl: </code> employee (employ\'e)
</p>
</li>
<li><p><code>ouvr: </code> worker (ouvrier)
</p>
</li>
<li><p><code>bepc: </code> brevet
</p>
</li>
<li><p><code>cap: </code> NVQ (cap)
</p>
</li>
<li><p><code>bac: </code> baccalaureate
</p>
</li>
<li><p><code>sup: </code> higher education (sup\'erieur)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>Source</h3>

<p>INSEE. <a href="https://www.insee.fr/fr/statistiques/1893185">
Population active de 25 à 54 ans ayant un emploi et chômeurs par catégorie socioprofessionnelle et diplôme par commune et département (1968 à 2015)</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dspg)
names(dspg)
print(dspg[[1]])
</code></pre>

<hr>
<h2 id='dspgd2015'>Diploma x Socio professional group by departement in 2015
</h2><span id='topic+dspgd2015'></span>

<h3>Description</h3>

<p>Contingency tables of the counts of Diploma x Socio professional group by metroplitan France departement in year 2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dspgd2015)
</code></pre>


<h3>Format</h3>

<p><code>dspgd2015</code> is a list of 96 arrays (each one corresponding to a department, designated by its official geographical code) of 4 rows (each one corresponding to a level of diploma) and 6 columns (each one corresponding to a socio professional group). 
</p>

<ul>
<li><p><code>csp: </code> Socio professional group
</p>
</li>
<li><p><code>diplome: </code> Diploma
</p>
</li>
<li><p><code>agri: </code> farmer (agriculteur)
</p>
</li>
<li><p><code>arti: </code> craftsperson (artisan)
</p>
</li>
<li><p><code>cadr: </code> senior manager (cadre sup\'erieur)
</p>
</li>
<li><p><code>pint: </code> middle manager (profession interm\'ediaire)
</p>
</li>
<li><p><code>empl: </code> employee (employ\'e)
</p>
</li>
<li><p><code>ouvr: </code> worker (ouvrier)
</p>
</li>
<li><p><code>bepc: </code> brevet
</p>
</li>
<li><p><code>cap: </code> NVQ (cap)
</p>
</li>
<li><p><code>bac: </code> baccalaureate
</p>
</li>
<li><p><code>sup: </code> higher education (sup\'erieur)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>Source</h3>

<p>INSEE. <a href="https://www.insee.fr/fr/statistiques/1893185">
Population active de 25 à 54 ans ayant un emploi et chômeurs par catégorie socioprofessionnelle et diplôme par commune et département (1968 à 2015)</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dspgd2015)
names(dspgd2015)
print(dspgd2015[[1]])
</code></pre>

<hr>
<h2 id='dstatis.inter'>
Dual STATIS method (interstructure stage)
</h2><span id='topic+dstatis.inter'></span><span id='topic+dstatis'></span>

<h3>Description</h3>

<p>Performs the first stage (interstructure) of the dual STATIS method in order to describe a data folder, consisting of <code class="reqn">T</code> groups of individuals on which are observed <code class="reqn">p</code> variables. It returns an object of class <code>dstatis</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dstatis.inter(xf, normed = TRUE, centered = TRUE, data.scaled = FALSE, nb.factors = 3,
      nb.values = 10, sub.title = "", plot.eigen = TRUE, plot.score = FALSE,
      nscore = 1:3, group.name = "group", filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dstatis.inter_+3A_xf">xf</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code>. Its elements are data frames with <code class="reqn">p</code> numeric columns.
If there are non numeric columns, there is an error.
The <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) matches with the <code class="reqn">t^{th}</code> group.
</p>
</td></tr>       
<tr><td><code id="dstatis.inter_+3A_normed">normed</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the scalar products are normed.
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_centered">centered</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the scalar products are centered.
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_data.scaled">data.scaled</code></td>
<td>

<p>logical. If <code>TRUE</code>, the data of each group are centered and scaled. The analysis is then performed on the correlation matrices. If <code>FALSE</code> (default), the analysis is performed on the covariance matrices.
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_nb.factors">nb.factors</code></td>
<td>

<p>numeric. Number of returned principal scores (default <code>nb.factors = 3</code>).
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_nb.values">nb.values</code></td>
<td>

<p>numerical. Number of returned eigenvalues (default <code>nb.values = 10</code>).
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_sub.title">sub.title</code></td>
<td>

<p>string. If provided, the subtitle for the graphs.
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_plot.eigen">plot.eigen</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the barplot of the eigenvalues is plotted.
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_plot.score">plot.score</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the graphs of principal scores are plotted. A new graphic device is opened for each pair of principal scores defined by <code>nscore</code> argument.
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_nscore">nscore</code></td>
<td>

<p>numeric vector. If <code>plot.score = TRUE</code>, the numbers of the principal scores which are plotted. By default it is equal to <code>nscore = 1:3</code>. Its components cannot be greater than <code>nb.factors</code>. 
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_group.name">group.name</code></td>
<td>

<p>string. Name of the grouping variable. Default: <code>groupname  = "group"</code>.
</p>
</td></tr>
<tr><td><code id="dstatis.inter_+3A_filename">filename</code></td>
<td>

<p>string. Name of the file in which the results are saved. By default (<code>filename  = NULL</code>) the results are not saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The covariance matrices (if <code>data.scale</code> is <code>FALSE</code>) or correlation matrices (if <code>TRUE</code>) per group are computed. The matrix <code class="reqn">W</code> of the scalar products between these covariance matrices is then computed.
</p>
<p>To perform the STATIS method, see the function <a href="multigroup.html#topic+DSTATIS">DSTATIS</a> of the <code>multigroup</code> package.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>dstatis</code>, that is a list including:
</p>
<table>
<tr><td><code>inertia</code></td>
<td>
<p>data frame of the eigenvalues and percentages of inertia.</p>
</td></tr>
<tr><td><code>contributions</code></td>
<td>
<p>data frame of the contributions to the first <code>nb.factors</code> principal components.</p>
</td></tr>
<tr><td><code>qualities</code></td>
<td>
<p>data frame of the qualities on the first <code>nb.factors</code> principal factors.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>data frame of the first <code>nb.factors</code> scores of the spectral decomposition of <code class="reqn">W</code>.</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>
<p>vector of the <code class="reqn">L^2</code> norms of the densities.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>list of the means.</p>
</td></tr>
<tr><td><code>variances</code></td>
<td>
<p>list of the covariance matrices.</p>
</td></tr>
<tr><td><code>correlations</code></td>
<td>
<p>list of the correlation matrices.</p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p>list of the skewness coefficients.</p>
</td></tr>
<tr><td><code>kurtosis</code></td>
<td>
<p>list of the kurtosis coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Lavit, C., Escoufier, Y., Sabatier, R., Traissac, P. (1994). The ACT (STATIS method). Computational Statistics &amp; Data Analysis, 18 (1994), 97-119.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.dstatis">print.dstatis</a>, <a href="#topic+plot.dstatis">plot.dstatis</a>, <a href="#topic+interpret.dstatis">interpret.dstatis</a>.
</p>
<p><a href="multigroup.html#topic+DSTATIS">DSTATIS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
rosesf &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])

# Dual STATIS on the covariance matrices
result1 &lt;- dstatis.inter(rosesf, data.scaled = FALSE, group.name = "rose")
print(result1)
plot(result1)

# Dual STATIS on the correlation matrices
result2 &lt;- dstatis.inter(rosesf, data.scaled = FALSE, group.name = "rose")
print(result2)
plot(result2)
</code></pre>

<hr>
<h2 id='fdiscd.misclass'>
Misclassification ratio in functional discriminant analysis of probability densities.
</h2><span id='topic+fdiscd.misclass'></span>

<h3>Description</h3>

<p>Computes the one-leave-out misclassification ratio of the rule assigning <code class="reqn">T</code> groups of individuals, one group after another, to the class of groups (among <code class="reqn">K</code> classes of groups) which achieves the minimum of the distances or divergences between the density function associated to the group to assign and the <code class="reqn">K</code> density functions associated to the <code class="reqn">K</code> classes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdiscd.misclass(xf, class.var, gaussiand = TRUE,
           distance =  c("jeffreys", "hellinger", "wasserstein", "l2", "l2norm"),
           crit = 1, windowh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdiscd.misclass_+3A_xf">xf</code></td>
<td>

<p>object of class <code><a href="#topic+folderh">folderh</a></code> with two data frames:
</p>

<ul>
<li><p> The first one has at least two columns. One column contains the names of the <code class="reqn">T</code> groups (all the names must be different). An other column is a factor with <code class="reqn">K</code> levels partitionning the T groups into K classes.
</p>
</li>
<li><p> The second one has <code class="reqn">(p+1)</code> columns. The first <code class="reqn">p</code> columns are numeric (otherwise, there is an error). The last column is a factor with <code class="reqn">T</code> levels defining <code class="reqn">T</code> groups. Each group, say <code class="reqn">t</code>, consists of <code class="reqn">n_t</code> individuals.
</p>
</li></ul>

</td></tr>       
<tr><td><code id="fdiscd.misclass_+3A_class.var">class.var</code></td>
<td>

<p>string. The name of the class variable.
</p>
</td></tr>
<tr><td><code id="fdiscd.misclass_+3A_distance">distance</code></td>
<td>

<p>The distance or dissimilarity used to compute the distance matrix between the densities.
It can be:
</p>

<ul>
<li> <p><code>"jeffreys"</code> (default) the Jeffreys measure (symmetrised Kullback-Leibler divergence),
</p>
</li>
<li> <p><code>"hellinger"</code> the Hellinger (Matusita) distance,
</p>
</li>
<li> <p><code>"wasserstein"</code> the Wasserstein distance,
</p>
</li>
<li> <p><code>"l2"</code> the <code class="reqn">L^2</code> distance,
</p>
</li>
<li> <p><code>"l2norm"</code> (only available when crit = 1) the densities are normed and the <code class="reqn">L^2</code> distance between these normed densities is used;
</p>
</li></ul>

<p>If <code>gaussiand = FALSE</code>, the densities are estimated by the Gaussian kernel method and the distance is <code>"l2"</code> or <code>"l2norm"</code>.
</p>
</td></tr>
<tr><td><code id="fdiscd.misclass_+3A_crit">crit</code></td>
<td>

<p>1, 2 or 3. In order to select the densities associated to the classes. See Details.
</p>
<p>If <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code>, <code>crit</code> is necessarily <code>1</code> (see Details).
</p>
</td></tr>
<tr><td><code id="fdiscd.misclass_+3A_gaussiand">gaussiand</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the probability densities are supposed Gaussian. If <code>FALSE</code>, densities are estimated using the Gaussian kernel method.
</p>
<p>If <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code>, <code>gaussiand</code> is necessarily <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="fdiscd.misclass_+3A_windowh">windowh</code></td>
<td>

<p>strictly positive numeric value. If <code>windowh = NULL</code> (default), the bandwidths are computed using the <code><a href="#topic+bandwidth.parameter">bandwidth.parameter</a></code> function.
</p>
<p>Omitted when <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code> (see Details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">T</code> probability densities <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> groups of individuals are either parametrically estimated (<code>gaussiand = TRUE</code>) or estimated using the Gaussian kernel method (<code>gaussiand = FALSE</code>). In the latter case, the <code>windowh</code> argument provides the list of the bandwidths to be used. Notice that in the multivariate case (<code class="reqn">p</code>&gt;1), the bandwidths are positive-definite matrices.
</p>
<p>The argument <code>windowh</code> is a numerical value, the matrix bandwidth is of the form <code class="reqn">h S</code>, where <code class="reqn">S</code> is either the square root of the covariance matrix (<code class="reqn">p</code>&gt;1) or the standard deviation of the estimated density.  
</p>
<p>If <code>windowh = NULL</code> (default), <code class="reqn">h</code> in the above formula is computed using the <code><a href="#topic+bandwidth.parameter">bandwidth.parameter</a></code> function.
</p>

<p>To the class <code class="reqn">k</code> consisting of <code class="reqn">T_k</code> groups is associated the density denoted <code class="reqn">g_k</code>. The <code>crit</code> argument selects the estimation method of the <code class="reqn">K</code> densities <code class="reqn">g_k</code>.
</p>

<ol>
<li>
<p>The density <code class="reqn">g_k</code> is estimated using the whole data of this class, that is the rows of <code>x</code> corresponding to the <code class="reqn">T_k</code> groups of the class <code class="reqn">k</code>.
</p>
<p>The estimation of the densities <code class="reqn">g_k</code> uses the same method as the estimation of the <code class="reqn">f_t</code>.
</p>
</li>
<li> 
<p>The <code class="reqn">T_k</code> densities <code class="reqn">f_t</code> are estimated using the corresponding data from <code>x</code>. Then they are averaged to obtain an estimation of the density <code class="reqn">g_k</code>, that is <code class="reqn">g_k = \frac{1}{T_k} \, \sum{f_t}</code>.
</p>
</li>
<li> 
<p>Each previous density <code class="reqn">f_t</code> is weighted by <code class="reqn">n_t</code> (the number of rows of <code class="reqn">x</code> corresponding to <code class="reqn">f_t</code>). Then they are averaged, that is <code class="reqn">g_k = \frac{1}{\sum n_t} \sum n_t f_t</code>.
</p>
</li></ol>

<p>The last two methods are only available for the <code class="reqn">L^2</code>-distance. If the divergences between densities are computed using the Hellinger or Wasserstein distance or Jeffreys measure, only the first of these methods is available.
</p>
<p>The distance or dissimilarity between the estimated densities is either the <code class="reqn">L^2</code> distance, the Hellinger distance, Jeffreys measure (symmetrised Kullback-Leibler divergence) or the Wasserstein distance.
</p>

<ul>
<li><p> If it is the <code>L^2</code> distance (<code>distance="l2"</code> or <code>distance="l2norm"</code>), the densities can be either parametrically estimated or estimated using the Gaussian kernel.
</p>
</li>
<li><p> If it is the Hellinger distance (<code>distance="hellinger"</code>), Jeffreys measure (<code>distance="jeffreys"</code>) or the Wasserstein distance (<code>distance="wasserstein"</code>), the densities are considered Gaussian and necessarily parametrically estimated.
</p>
</li></ul>



<h3>Value</h3>

 
<p>Returns an object of class <code>fdiscd.misclass</code>, that is a list including:
</p>
<table>
<tr><td><code>classification</code></td>
<td>
<p>data frame with 4 columns:
</p>

<ul>
<li><p> factor giving the group name. The column name is the same as that of the column (<code class="reqn">p+1</code>) of <code>x</code>,
</p>
</li>
<li><p> the prior class of the group if it is available, or NA if not,
</p>
</li>
<li> <p><code>alloc</code>: the class allocation computed by the discriminant analysis method,
</p>
</li>
<li> <p><code>misclassed</code>: boolean. <code>TRUE</code> if the group is misclassed, <code>FALSE</code> if it is well-classed, <code>NA</code> if the prior class of the group is unknown.
</p>
</li></ul>

</td></tr>
<tr><td><code>confusion.mat</code></td>
<td>
<p>confusion matrix,</p>
</td></tr>
<tr><td><code>misalloc.per.class</code></td>
<td>
<p>the misclassification ratio per class,</p>
</td></tr>
<tr><td><code>misclassed</code></td>
<td>
<p>the misclassification ratio,</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>matrix with <code class="reqn">T</code> rows and <code class="reqn">K</code> columns, of the distances (<code class="reqn">d_{tk}</code>): <code class="reqn">d_{tk}</code> is the distance between the group <code class="reqn">t</code> and the class <code class="reqn">k</code>, computed with the measure given by argument <code>distance</code> (<code class="reqn">L^2</code>-distance, Hellinger distance or Jeffreys measure),</p>
</td></tr>
<tr><td><code>proximities</code></td>
<td>
<p>matrix of the proximity indices (in percents) between the groups and the classes. The proximity of the group <code class="reqn">t</code> to the class <code class="reqn">k</code> is computed as so: <code class="reqn">(1/d_{tk})/\sum_{l=1}^{l=K}(1/d_{tl})</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R. (2004). Discriminant analysis with independently repeated multivariate measurements: an <code class="reqn">L^2</code> approach. Computational Statistics &amp; Data Analysis, 47, 823-843.
</p>
<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution à l'étude de l'architecture médiévale: les caractéristiques des pierres à bossage des châteaux forts alsaciens. Centre de Recherches Archéologiques Médiévales de Saverne, 5, 5-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
castles.stones &lt;- castles.dated$stones
castles.periods &lt;- castles.dated$periods
castlesfh &lt;- folderh(castles.periods, "castle", castles.stones)
result &lt;- fdiscd.misclass(castlesfh, "period")
print(result)
</code></pre>

<hr>
<h2 id='fdiscd.predict'>
Predicting the class of a group of individuals with discriminant analysis of probability densities.
</h2><span id='topic+fdiscd.predict'></span>

<h3>Description</h3>

<p>Assigns several groups of individuals, one group after another, to the class of groups (among <code class="reqn">K</code> classes of groups) which achieves the minimum of the distances or divergences between the density function associated to the group to assign and the <code class="reqn">K</code> density functions associated to the <code class="reqn">K</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdiscd.predict(xf, class.var, gaussiand = TRUE,
           distance =  c("jeffreys", "hellinger", "wasserstein", "l2", "l2norm"),
           crit = 1, windowh = NULL, misclass.ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdiscd.predict_+3A_xf">xf</code></td>
<td>

<p>object of class <code><a href="#topic+folderh">folderh</a></code> with two data frames:
</p>

<ul>
<li><p> The first one has at least two columns. One column contains the names of the <code class="reqn">T</code> groups (all the names must be different). An other column is a factor with <code class="reqn">K</code> levels partitionning the T groups into K classes..
</p>
</li>
<li><p> The second one has <code class="reqn">(p+1)</code> columns. The first <code class="reqn">p</code> columns are numeric (otherwise, there is an error). The last column is a factor with <code class="reqn">T</code> levels defining <code class="reqn">T</code> groups. Each group, say <code class="reqn">t</code>, consists of <code class="reqn">n_t</code> individuals.
</p>
</li></ul>

<p>Notice that for the versions earlier than 2.0, fdiscd.predict applied to two data frames.
</p>
</td></tr>       
<tr><td><code id="fdiscd.predict_+3A_class.var">class.var</code></td>
<td>

<p>string. The name of the class variable.
</p>
</td></tr>
<tr><td><code id="fdiscd.predict_+3A_distance">distance</code></td>
<td>

<p>The distance or divergence used to compute the distance matrix between the densities.
It can be:
</p>

<ul>
<li> <p><code>"jeffreys"</code> (default) Jeffreys measure (symmetrised Kullback-Leibler divergence),
</p>
</li>
<li> <p><code>"hellinger"</code> the Hellinger (Matusita) distance,
</p>
</li>
<li> <p><code>"wasserstein"</code> the Wasserstein distance,
</p>
</li>
<li> <p><code>"l2"</code> the <code class="reqn">L^2</code> distance,
</p>
</li>
<li> <p><code>"l2norm"</code> the densities are normed and the <code class="reqn">L^2</code> distance between these normed densities is used;
</p>
</li></ul>

<p>If <code>gaussiand = FALSE</code>, the densities are estimated by the Gaussian kernel method and the distance is <code>"l2"</code> or <code>"l2norm"</code>.
</p>
</td></tr>
<tr><td><code id="fdiscd.predict_+3A_crit">crit</code></td>
<td>

<p>1, 2 or 3. In order to select the densities associated to the classes. See Details.
</p>
<p>If <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code>, <code>crit</code> is necessarily <code>1</code> (see Details).
</p>
</td></tr>
<tr><td><code id="fdiscd.predict_+3A_gaussiand">gaussiand</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the probability densities are supposed Gaussian. If <code>FALSE</code>, densities are estimated using the Gaussian kernel method.
</p>
<p>If <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code>, <code>gaussiand</code> is necessarily <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="fdiscd.predict_+3A_windowh">windowh</code></td>
<td>

<p>strictly positive number. If <code>windowh = NULL</code> (default), the bandwidths are computed using the <code><a href="#topic+bandwidth.parameter">bandwidth.parameter</a></code> function.
</p>
<p>Omitted when <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code> (see Details).
</p>
</td></tr>
<tr><td><code id="fdiscd.predict_+3A_misclass.ratio">misclass.ratio</code></td>
<td>

<p>logical (default <code>FALSE</code>). If <code>TRUE</code>, the confusion matrix and misclassification ratio are computed on the groups whose prior class is known. In order to compute the misclassification ratio by the one-leave-out method, use the <code><a href="#topic+fdiscd.misclass">fdiscd.misclass</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To the group <code class="reqn">t</code> is associated the density denoted <code class="reqn">f_t</code>. To the class <code class="reqn">k</code> consisting of <code class="reqn">T_k</code> groups is associated the density denoted <code class="reqn">g_k</code>. The <code>crit</code> argument selects the estimation method of the <code class="reqn">K</code> densities <code class="reqn">g_k</code>.
</p>

<ol>
<li>
<p>The density <code class="reqn">g_k</code> is estimated using the whole data of this class, that is the rows of <code>x</code> corresponding to the <code class="reqn">T_k</code> groups of the class <code class="reqn">k</code>. 
</p>
</li>
<li> 
<p>The <code class="reqn">T_k</code> densities <code class="reqn">f_t</code> are estimated using the corresponding data from <code>x</code>. Then they are averaged to obtain an estimation of the density <code class="reqn">g_k</code>, that is <code class="reqn">g_k = (1/T_k)\sum{f_t}</code>.
</p>
</li>
<li> 
<p>Each previous density <code class="reqn">f_t</code> is weighted by <code class="reqn">n_t</code> (the number of rows of <code class="reqn">x</code> corresponding to <code class="reqn">f_t</code>). Then they are averaged, that is <code class="reqn">g_k = (1/\sum n_t) \sum n_t f_t</code>.
</p>
</li></ol>

<p>The last two methods are available only for the <code class="reqn">L^2</code>-distance. If the divergences between densities are computed using the Hellinger or Wasserstein distance or Jeffreys measure, only the first of these methods is available.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>fdiscd.predict</code>, that is a list including:
</p>
<table>
<tr><td><code>prediction</code></td>
<td>
<p>data frame with 3 columns:
</p>

<ul>
<li><p> factor giving the group name. The column name is the same as that of the column (<code class="reqn">p+1</code>) of <code>x</code>,
</p>
</li>
<li> <p><code>class.known</code>: the prior class of the group if it is available, or NA if not,  
</p>
</li>
<li> <p><code>class.predict</code>: the class allocation predicted by the discriminant analysis method. If <code>misclass.ratio = TRUE</code>, the class allocations are computed for all groups. Otherwise (default), they are computed only for the groups whose class is unknown.
</p>
</li></ul>

</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>matrix with <code class="reqn">T</code> rows and <code class="reqn">K</code> columns, of the distances (<code class="reqn">d_{tk}</code>): <code class="reqn">d_{tk}</code> is the distance between the group <code class="reqn">t</code> and the class <code class="reqn">k</code>, computed with the measure given by argument <code>distance</code> (<code class="reqn">L^2</code>-distance, Hellinger distance or jeffreys measure),</p>
</td></tr>
<tr><td><code>proximities</code></td>
<td>
<p>matrix of the proximities (in percents). The proximity of a group <code class="reqn">t</code> to the class <code class="reqn">k</code> is computed as so: <code class="reqn">(1/d_{tk})/\sum_{l=1}^{l=K}(1/d_{tl})</code>.</p>
</td></tr>
<tr><td><code>confusion.mat</code></td>
<td>
<p>the confusion matrix (if <code>misclass.ratio = TRUE</code>)</p>
</td></tr>
<tr><td><code>misclassed</code></td>
<td>
<p>the misclassification ratio (if <code>misclass.ratio = TRUE</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R. (2004). Discriminant analysis with independently repeated multivariate measurements: an <code class="reqn">L^2</code> approach. Computational Statistics &amp; Data Analysis, 47, 823-843.
</p>
<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution à l'étude de l'architecture médiévale: les caractéristiques des pierres à bossage des châteaux forts alsaciens. Centre de Recherches Archéologiques Médiévales de Saverne, 5, 5-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
data(castles.nondated)
castles.stones &lt;- rbind(castles.dated$stones, castles.nondated$stones)
castles.periods &lt;- rbind(castles.dated$periods, castles.nondated$periods)
castlesfh &lt;- folderh(castles.periods, "castle", castles.stones)

# With the L^2-distance

# - crit=1
resultl2.1 &lt;- fdiscd.predict(castlesfh, "period", distance="l2", crit=1)
print(resultl2.1)

# - crit=2
## Not run: 
resultl2.2 &lt;- fdiscd.predict(castlesfh, "period", distance="l2", crit=2)
print(resultl2.2)

## End(Not run)

# - crit=3
resultl2.3 &lt;- fdiscd.predict(castlesfh, "period", distance="l2", crit=3)
print(resultl2.3)

# With the Hellinger distance
resulthelling &lt;- fdiscd.predict(castlesfh, "period", distance="hellinger")
print(resulthelling)

# With jeffreys measure
resultjeff &lt;- fdiscd.predict(castlesfh, "period", distance="jeffreys")
print(resultjeff)
</code></pre>

<hr>
<h2 id='fhclustd'>
Hierarchic cluster analysis of probability densities
</h2><span id='topic+fhclustd'></span>

<h3>Description</h3>

<p>Performs functional hierarchic cluster analysis of probability densities. It returns an object of class <code><a href="#topic+fhclustd">fhclustd</a></code>. It applies <code><a href="stats.html#topic+hclust">hclust</a></code> to the distance matrix between the <code class="reqn">T</code> densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fhclustd(xf, group.name  = "group", gaussiand = TRUE, distance = c("jeffreys",
             "hellinger", "wasserstein", "l2", "l2norm"), windowh=NULL,
             data.centered = FALSE, data.scaled = FALSE, common.variance = FALSE,
             sub.title = "", filename = NULL, method.hclust = "complete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fhclustd_+3A_xf">xf</code></td>
<td>

<p>object of class <code>"<a href="#topic+folder">folder</a>"</code> or data.frame.
</p>

<ul>
<li><p> If it is an object of class <code>"folder"</code>, its elements are data frames with <code class="reqn">p</code> numeric columns.
If there are non numeric columns, there is an error.
The <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) matches with the <code class="reqn">t^{th}</code> group.             
</p>
</li>
<li><p> If it is a data frame, the column with name given by the <code>group.name</code> argument is a factor giving the groups.
The other columns are all numeric; otherwise, there is an error.
</p>
</li></ul>

</td></tr>       
<tr><td><code id="fhclustd_+3A_group.name">group.name</code></td>
<td>

<p>string.
</p>

<ul>
<li><p> If <code>xf</code> is an object of class <code>"<a href="#topic+folder">folder</a>"</code>, it is the name of the grouping variable in the returned results. The default is <code>groupname  = "group"</code>.
</p>
</li>
<li><p> If <code>xf</code> is a data frame, it is the name of the column of <code>xf</code> containing the groups.
</p>
</li></ul>

</td></tr>
<tr><td><code id="fhclustd_+3A_gaussiand">gaussiand</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the probability densities are supposed Gaussian. If <code>FALSE</code>, densities are estimated using the Gaussian kernel method.
</p>
<p>If <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code>, <code>gaussiand</code> is necessarily <code>TRUE</code> (see Details).
</p>
</td></tr>
<tr><td><code id="fhclustd_+3A_distance">distance</code></td>
<td>

<p>The distance or divergence used to compute the distance matrix between the densities.
It can be:
</p>

<ul>
<li> <p><code>"jeffreys"</code> (default) Jeffreys measure (symmetrised Kullback-Leibler divergence),
</p>
</li>
<li> <p><code>"hellinger"</code> the Hellinger (Matusita) distance,
</p>
</li>
<li> <p><code>"wasserstein"</code> the Wasserstein distance,
</p>
</li>
<li> <p><code>"l2"</code> the <code class="reqn">L^2</code> distance,
</p>
</li>
<li> <p><code>"l2norm"</code> the densities are normed and the <code class="reqn">L^2</code> distance between these normed densities is used;
</p>
</li></ul>

<p>If <code>gaussiand = FALSE</code>, the densities are estimated by the Gaussian kernel method and the distance can be
<code>"l2"</code> (default) or <code>"l2norm"</code>.
</p>
</td></tr>
<tr><td><code id="fhclustd_+3A_windowh">windowh</code></td>
<td>

<p>either a list of <code class="reqn">T</code> bandwidths (one per density associated to a group), or a strictly positive number. If <code>windowh = NULL</code> (default), the bandwidths are automatically computed. See Details.
</p>
<p>Omitted when <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code> (see Details).
</p>
</td></tr>
<tr><td><code id="fhclustd_+3A_data.centered">data.centered</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), the data of each group are centered.
</p>
</td></tr>
<tr><td><code id="fhclustd_+3A_data.scaled">data.scaled</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), the data of each group are centered (even if <code>data.centered = FALSE</code>) and scaled.
</p>
</td></tr>
<tr><td><code id="fhclustd_+3A_common.variance">common.variance</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), a common covariance matrix (or correlation matrix if <code>data.scaled = TRUE</code>), computed on the whole data, is used. If <code>FALSE</code> (default), a covariance (or correlation) matrix per group is used.
</p>
</td></tr>
<tr><td><code id="fhclustd_+3A_sub.title">sub.title</code></td>
<td>

<p>string. If provided, the subtitle for the graphs.
</p>
</td></tr>
<tr><td><code id="fhclustd_+3A_filename">filename</code></td>
<td>

<p>string. Name of the file in which the results are saved. By default (<code>filename  = NULL</code>) the results are not saved.
</p>
</td></tr>
<tr><td><code id="fhclustd_+3A_method.hclust">method.hclust</code></td>
<td>

<p>the agglomeration method to be used for the clustering. See the <code>method</code> argument of the <code><a href="stats.html#topic+hclust">hclust</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>In order to compute the distances/dissimilarities between the groups, the <code class="reqn">T</code> probability densities <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> groups of individuals are either parametrically estimated (<code>gaussiand = TRUE</code>) or estimated using the Gaussian kernel method (<code>gaussiand = FALSE</code>). In the latter case, the <code>windowh</code> argument provides the list of the bandwidths to be used. Notice that in the multivariate case (<code class="reqn">p</code>&gt;1), the bandwidths are positive-definite matrices.
The distances between the <code class="reqn">T</code> groups of individuals are given by the <code class="reqn">L^2</code>-distances between the <code class="reqn">T</code> probability densities <code class="reqn">f_t</code> corresponding to these groups. The <code><a href="stats.html#topic+hclust">hclust</a></code> function is then applied to the distance matrix to perform the hierarchical clustering on the <code class="reqn">T</code> groups.
</p>
<p>If <code>windowh</code> is a numerical value, the matrix bandwidth is of the form <code class="reqn">h S</code>, where <code class="reqn">S</code> is either the square root of the covariance matrix (<code class="reqn">p</code>&gt;1) or the standard deviation of the estimated density.  
</p>
<p>If <code>windowh = NULL</code> (default), <code class="reqn">h</code> in the above formula is computed using the <code><a href="#topic+bandwidth.parameter">bandwidth.parameter</a></code> function.
</p>
<p>The distance or dissimilarity between the estimated densities is either the <code class="reqn">L^2</code> distance, the Hellinger distance, Jeffreys measure (symmetrised Kullback-Leibler divergence) or the Wasserstein distance.
</p>

<ul>
<li><p> If it is the <code>L^2</code> distance (<code>distance="l2"</code> or <code>distance="l2norm"</code>), the densities can be either parametrically estimated or estimated using the Gaussian kernel.
</p>
</li>
<li><p> If it is the Hellinger distance (<code>distance="hellinger"</code>), Jeffreys measure (<code>distance="jeffreys"</code>) or the Wasserstein distance (<code>distance="wasserstein"</code>), the densities are considered Gaussian and necessarily parametrically estimated.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>fhclustd</code>, that is a list including:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>matrix of the <code class="reqn">L^2</code>-distances between the estimated densities.</p>
</td></tr>
<tr><td><code>clust</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+fdiscd.predict">fdiscd.predict</a>, <a href="#topic+fdiscd.misclass">fdiscd.misclass</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
stones &lt;- castles.dated$stones
periods &lt;- castles.dated$periods

periods123 &lt;- periods[periods$period %in% 1:3, "castle"]
stones123 &lt;- stones[stones$castle %in% periods123, ]
stones123$castle &lt;- as.factor(as.character(stones123$castle))
yf &lt;- as.folder(stones123)


# Jeffreys measure (default):

resultjef &lt;- fhclustd(yf)
print(resultjef)
print(resultjef, dist.print = TRUE)
plot(resultjef)
plot(resultjef, hang = -1)

# Use cutree (stats package) to get the partition
cutree(resultjef$clust, k = 1:4)
cutree(resultjef$clust, k = 5)
cutree(resultjef$clust, h = 0.041)


# Applied to a data frame (Jeffreys measure):

fhclustd(stones123, group.name = "castle")

# Use cutree (stats package) to get the partition
cutree(resultjef$clust, k = 1:4)
cutree(resultjef$clust, k = 5)
cutree(resultjef$clust, h = 0.041)


# Hellinger distance:

resulthel &lt;- fhclustd(yf, distance = "hellinger")
print(resulthel)
print(resulthel, dist.print = TRUE)
plot(resulthel)
plot(resulthel, hang = -1)

# Use cutree (stats package) to get the partition
cutree(resulthel$clust, k = 1:4)
cutree(resulthel$clust, k = 5)
cutree(resulthel$clust, h = 0.041)


## Not run: 
# L2-distance:

xf &lt;- as.folder(stones)
result &lt;- fhclustd(xf, distance = "l2")
print(result)
print(result, dist.print = TRUE)
plot(result)
plot(result, hang = -1)

# Use cutree (stats package) to get the partition
cutree(result$clust, k = 1:5)
cutree(result$clust, k = 5)
cutree(result$clust, h = 0.18)

## End(Not run)

periods123 &lt;- periods[periods$period %in% 1:3, "castle"]
stones123 &lt;- stones[stones$castle %in% periods123, ]
stones123$castle &lt;- as.factor(as.character(stones123$castle))
yf &lt;- as.folder(stones123)
result123 &lt;- fhclustd(yf, distance = "l2")
print(result123)
print(result123, dist.print = TRUE)
plot(result123)
plot(result123, hang = -1)

# Use cutree (stats package) to get the partition
cutree(result123$clust, k = 1:4)
cutree(result123$clust, k = 5)
cutree(result123$clust, h = 0.041)
</code></pre>

<hr>
<h2 id='floribundity'>
Rose flowering
</h2><span id='topic+floribundity'></span>

<h3>Description</h3>

<p>These data are collected on eight rosebushes from four varieties, during summer 2010 in Angers, France. They give measures of the flowering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("floribundity")</code></pre>


<h3>Format</h3>

<p><code>floribundity</code> is a list of 16 data frames, each corresponding to an observation date. Each one of these data frames has 3 or 4 columns:
</p>

<ul>
<li><p><code>rose</code>: the number of the rosebush, that is an identifier.
</p>
</li>
<li><p><code>variety</code>: factor. The variety of the rosebush.
</p>
</li>
<li><p><code>area</code> (when available): numeric. The ratio of flowering area to the whole plant area, measured on the photograph of the rosebush.
</p>
</li>
<li><p><code>nflowers</code> (when available): integer. The number of flowers on the rosebush.
</p>
</li></ul>

<p>The row names of these data frames are the rose identifiers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(floribundity)
foldt &lt;- foldert(floribundity, times = as.Date(names(floribundity)), rows.select = "union")
summary(foldt)
</code></pre>

<hr>
<h2 id='fmdsd'>
Multidimensional scaling of probability densities
</h2><span id='topic+fmdsd'></span>

<h3>Description</h3>

<p>Applies the multidimensional scaling (MDS) method to probability densities in order to describe a data folder, consisting of <code class="reqn">T</code> groups of individuals on which are observed <code class="reqn">p</code> variables. It returns an object of class <code>fmdsd</code>. It applies <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> to the distance matrix between the <code class="reqn">T</code> densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmdsd(xf, group.name = "group", gaussiand = TRUE, distance = c("jeffreys", "hellinger",
    "wasserstein", "l2", "l2norm"), windowh=NULL, data.centered = FALSE,
    data.scaled = FALSE, common.variance = FALSE, add = TRUE, nb.factors = 3,
    nb.values = 10, sub.title = "", plot.eigen = TRUE, plot.score = FALSE, nscore = 1:3,
    filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmdsd_+3A_xf">xf</code></td>
<td>

<p>object of class <code>"<a href="#topic+folder">folder</a>"</code> or data.frame.
</p>

<ul>
<li><p> If it is an object of class <code>"folder"</code>, its elements are data frames with <code class="reqn">p</code> numeric columns.
If there are non numeric columns, there is an error.
The <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) matches with the <code class="reqn">t^{th}</code> group.             
</p>
</li>
<li><p> If it is a data frame, the column with name given by the <code>group.name</code> argument is a factor giving the groups.
The other columns are all numeric; otherwise, there is an error.
</p>
</li></ul>

</td></tr>
<tr><td><code id="fmdsd_+3A_group.name">group.name</code></td>
<td>

<p>string.
</p>

<ul>
<li><p> If <code>xf</code> is an object of class <code>"<a href="#topic+folder">folder</a>"</code>, it is the name of the grouping variable in the returned results. The default is <code>groupname  = "group"</code>.
</p>
</li>
<li><p> If <code>xf</code> is a data frame, it is the name of the column of <code>xf</code> containing the groups.
</p>
</li></ul>

</td></tr>
<tr><td><code id="fmdsd_+3A_gaussiand">gaussiand</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the probability densities are supposed Gaussian. If <code>FALSE</code>, densities are estimated using the Gaussian kernel method.
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_distance">distance</code></td>
<td>

<p>The distance or divergence used to compute the distance matrix between the densities.
</p>
<p>If <code>gaussiand = TRUE</code>, the densities are parametrically estimated and the distance can be:
</p>

<ul>
<li> <p><code>"jeffreys"</code> (default) Jeffreys measure (symmetrised Kullback-Leibler divergence),
</p>
</li>
<li> <p><code>"hellinger"</code> the Hellinger (Matusita) distance,
</p>
</li>
<li> <p><code>"wasserstein"</code> the Wasserstein distance,
</p>
</li>
<li> <p><code>"l2"</code> the <code class="reqn">L^2</code> distance,
</p>
</li>
<li> <p><code>"l2norm"</code> the densities are normed and the <code class="reqn">L^2</code> distance between these normed densities is used;
</p>
</li></ul>

<p>If <code>gaussiand = FALSE</code>, the densities are estimated by the Gaussian kernel method and the distance can be
<code>"l2"</code> (default) or <code>"l2norm"</code>.
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_windowh">windowh</code></td>
<td>

<p>either a list of <code class="reqn">T</code> bandwidths (one per density associated to a group), or a strictly positive number. If <code>windowh = NULL</code> (default), the bandwidths are automatically computed. See Details.
</p>
<p>Omitted when <code>distance</code> is <code>"hellinger"</code>, <code>"jeffreys"</code> or <code>"wasserstein"</code> (see Details).
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_data.centered">data.centered</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), the data of each group are centered.
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_data.scaled">data.scaled</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), the data of each group are centered (even if <code>data.centered = FALSE</code>) and scaled.
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_common.variance">common.variance</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), a common covariance matrix (or correlation matrix if <code>data.scaled = TRUE</code>), computed on the whole data, is used. If <code>FALSE</code> (default), a covariance (or correlation) matrix per group is used.
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_add">add</code></td>
<td>

<p>logical indicating if an additive constant should be computed and added to the non diagonal dissimilarities such that the modified dissimilarities are Euclidean (default <code>TRUE</code>; see <code>add</code> argument of <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>).
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_nb.factors">nb.factors</code></td>
<td>

<p>numeric. Number of returned principal coordinates (default <code>nb.factors = 3</code>).
</p>
<p>Warning: The <code><a href="#topic+plot.fmdsd">plot.fmdsd</a></code> and <code><a href="#topic+interpret.fmdsd">interpret.fmdsd</a></code> functions cannot take into account more than <code>nb.factors</code>  principal factors.
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_nb.values">nb.values</code></td>
<td>

<p>numeric. Number of returned eigenvalues (default <code>nb.values = 10</code>).
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_sub.title">sub.title</code></td>
<td>

<p>string. Subtitle for the graphs (default <code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_plot.eigen">plot.eigen</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the barplot of the eigenvalues is plotted.
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_plot.score">plot.score</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the graphs of new coordinates are plotted. A new graphic device is opened for each pair of coordinates defined by <code>nscore</code> argument.
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_nscore">nscore</code></td>
<td>

<p>numeric vector. If <code>plot.score = TRUE</code>, the numbers of the principal coordinates which are plotted. By default it is equal to <code>nscore = 1:3</code>. Its components cannot be greater than <code>nb.factors</code>. 
</p>
</td></tr>
<tr><td><code id="fmdsd_+3A_filename">filename</code></td>
<td>

<p>string. Name of the file in which the results are saved. By default (<code>filename  = NULL</code>) they are not saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to compute the distances/dissimilarities between the groups, the <code class="reqn">T</code> probability densities <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> groups of individuals are either parametrically estimated (<code>gaussiand = TRUE</code>) or estimated using the Gaussian kernel method (<code>gaussiand = FALSE</code>). In the latter case, the <code>windowh</code> argument provides the list of the bandwidths to be used. Notice that in the multivariate case (<code class="reqn">p</code>&gt;1), the bandwidths are positive-definite matrices.
</p>
<p>If <code>windowh</code> is a numerical value, the matrix bandwidth is of the form <code class="reqn">h S</code>, where <code class="reqn">S</code> is either the square root of the covariance matrix (<code class="reqn">p</code>&gt;1) or the standard deviation of the estimated density.  
</p>
<p>If <code>windowh = NULL</code> (default), <code class="reqn">h</code> in the above formula is computed using the <code><a href="#topic+bandwidth.parameter">bandwidth.parameter</a></code> function.
</p>
<p>The distance or dissimilarity between the estimated densities is either the <code class="reqn">L^2</code> distance, the Hellinger distance, Jeffreys measure (symmetrised Kullback-Leibler divergence) or the Wasserstein distance.
</p>

<ul>
<li><p> If it is the <code>L^2</code> distance (<code>distance="l2"</code> or <code>distance="l2norm"</code>), the densities can be either parametrically estimated or estimated using the Gaussian kernel.
</p>
</li>
<li><p> If it is the Hellinger distance (<code>distance="hellinger"</code>), Jeffreys measure (<code>distance="jeffreys"</code>) or the Wasserstein distance (<code>distance="wasserstein"</code>), the densities are considered Gaussian and necessarily parametrically estimated.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>fmdsd</code>, i.e. a list including:
</p>
<table>
<tr><td><code>inertia</code></td>
<td>
<p>data frame of the eigenvalues and percentages of inertia.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>data frame of the <code>nb.factors</code> first principal coordinates.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>list of the means.</p>
</td></tr>
<tr><td><code>variances</code></td>
<td>
<p>list of the covariance matrices.</p>
</td></tr>
<tr><td><code>correlations</code></td>
<td>
<p>list of the correlation matrices.</p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p>list of the skewness coefficients.</p>
</td></tr>
<tr><td><code>kurtosis</code></td>
<td>
<p>list of the kurtosis coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>
<p>Delicado, P. (2011). Dimensionality reduction when data are density functions. Computational Statistics &amp; Data Analysis, 55, 401-420.
</p>
<p>Yousfi, S., Boumaza, R., Aissani, D., Adjabi, S. (2014). Optimal bandwith matrices in functional principal component analysis of density function. Journal of Statistical Computation and Simulation, 85 (11), 2315-2330.
</p>
<p>Cox, T.F., Cox, M.A.A. (2001). Multimensional Scaling, second ed. Chapman &amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="#topic+fpcad">fpcad</a>
<a href="#topic+print.fmdsd">print.fmdsd</a>, <a href="#topic+plot.fmdsd">plot.fmdsd</a>, <a href="#topic+interpret.fmdsd">interpret.fmdsd</a>, <a href="#topic+bandwidth.parameter">bandwidth.parameter</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
rosesf &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])

# MDS on Gaussian densities (on sensory data)

# using jeffreys measure (default):
resultjeff &lt;- fmdsd(rosesf, distance = "jeffreys")
print(resultjeff)
plot(resultjeff)

## Not run: 
# Applied to a data frame:
resultjeffdf &lt;- fmdsd(roses[,c("Sha","Den","Sym","rose")],
                      distance = "jeffreys", group.name = "rose")
print(resultjeffdf)
plot(resultjeffdf)

## End(Not run)

# using the Hellinger distance:
resulthellin &lt;- fmdsd(rosesf, distance = "hellinger")
print(resulthellin)
plot(resulthellin)

# using the Wasserstein distance:
resultwass &lt;- fmdsd(rosesf, distance = "wasserstein")
print(resultwass)
plot(resultwass)

# Gaussian case, using the L2-distance:
resultl2 &lt;- fmdsd(rosesf, distance = "l2")
print(resultl2)
plot(resultl2)

# Gaussian case, using the L2-distance between normed densities:
resultl2norm &lt;- fmdsd(rosesf, distance = "l2norm")
print(resultl2norm)
plot(resultl2norm)

## Not run: 
# Non Gaussian case, using the L2-distance,
# the densities are estimated using the Gaussian kernel method:
result &lt;- fmdsd(rosesf, distance = "l2", gaussiand = FALSE, group.name = "rose")
print(result)       
plot(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='folder'>
Folder of data sets
</h2><span id='topic+folder'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"folder"</code> (called folder below), that is a list of data frames with the same column names. Thus, these data sets are on the same variables. They can be on the same individuals or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folder(x1, x2 = NULL, ..., cols.select = "intersect", rows.select = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="folder_+3A_x1">x1</code></td>
<td>

<p>data frame (can also be a tibble) or list of data frames.
</p>

<ul>
<li><p> If <code>x1</code> is a data frame, <code>x2</code> must be provided.
</p>
</li>
<li><p> If <code>x1</code> is a list of data frames, its elements are the datasets of the folder. In this case, there is no <code>x2</code> argument.
</p>
</li></ul>

</td></tr>
<tr><td><code id="folder_+3A_x2">x2</code></td>
<td>

<p>data frame. Must be provided if <code>x1</code> is a data frame.
</p>
</td></tr>
<tr><td><code id="folder_+3A_...">...</code></td>
<td>

<p>optional. One or several data frames. When <code>x1</code> and <code>x2</code> are data frames, these are the other data frames.
</p>
</td></tr>
<tr><td><code id="folder_+3A_cols.select">cols.select</code></td>
<td>

<p>string. Gives the method used to choose the column names of the data frames of the folder. This argument can be:
</p>

<dl>
<dt><code>"intersect"</code></dt><dd><p>(default) the column names of the data frames in the folder are the intersection of the column names of all the data frames given as arguments.</p>
</dd>
<dt><code>"union"</code></dt><dd><p>the column names of the data frames in the folder are the union of the column names of all the data frames given as arguments. When necessary, the rows of the returned data frames are completed by NA.</p>
</dd>
</dl>
<p>If <code>cols.select</code> is a character vector, it gives the column names selected in the data frames given as arguments. The corresponding columns constitute the columns of the elements of the returned folder. Notice that when a column name is not present in all data frames (given as arguments), the data are completed by NA.

</p>
</td></tr>
<tr><td><code id="folder_+3A_rows.select">rows.select</code></td>
<td>

<p>string. Gives the method used to choose the row names of the data frames of the folder. This argument can be:
</p>

<dl>
<dt><code>""</code></dt><dd><p>(default) the data frames of the folder have the same rows as those which were passed as arguments.
</p>
</dd>
<dt><code>"intersect"</code></dt><dd><p>the row names of the data frames in the folder are the intersection of the row names of all the data frames given as arguments.</p>
</dd>
<dt><code>"union"</code></dt><dd><p>the row names of the data frames in the folder are the union of the row names of all the data frames given as arguments. When necessary, the columns of the data frames returned are completed by <code>NA</code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>folder</code> has a logical attributes <code>attr(,"same.rows")</code>.
</p>
<p>The data frames in the returned folder all have the same column names. That means that the same variables are observed in every data sets.
</p>
<p>If the <code>rows.select</code> argument is <code>"union"</code> or <code>"intersect"</code>, the elements of the returned folder have the same rows. That means that the same individuals are present in every data sets. This allows to consider the evolution of each individual among time.
</p>
<p>If <code>rows.select</code> is <code>""</code>, every rows of this folder are different, and the row names are made unique by adding the name of the data frame to the row names. In this case, The individuals of the data sets are assumed to be all different. Or, at least, the user does not mind if they are the same or not.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"folder"</code>, that is a list of data frames.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.folder">is.folder</a></code> to test if an object is of class <code>folder</code>.
<code><a href="#topic+folderh">folderh</a></code> to build a folder of several data frames with a hierarchic relation between each pair of consecutive data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example              
x1 &lt;- data.frame(x = rnorm(10), y = 1:10)
x2 &lt;- data.frame(x = rnorm(10), z = runif(10, 1, 10))
f1 &lt;- folder(x1, x2)
print(f1)

f2 &lt;- folder(x1, x2, cols.select = "union")
print(f2)

#Second example
data(iris)
iris.set &lt;- iris[iris$Species == "setosa", 1:4]
iris.ver &lt;- iris[iris$Species == "versicolor", 1:4]
iris.vir &lt;- iris[iris$Species == "virginica", 1:4]
irisf1 &lt;- folder(iris.set, iris.ver, iris.vir)
print(irisf1)

listofdf &lt;- list(df1 = iris.set,df2 = iris.ver,df3 = iris.vir)
irisf2 &lt;- folder(listofdf,x2 = NULL)
print(irisf2)
</code></pre>

<hr>
<h2 id='folderh'>
Hierarchic folder of n data frames related in pairs by (n-1) keys
</h2><span id='topic+folderh'></span>

<h3>Description</h3>

<p>Creates an object of class <code>folderh</code>, that is a list of <code class="reqn">n&gt;1</code> data frames whose rows are related by (n-1) keys, each key defining a relation &quot;1 to N&quot; between the two adjacent data frames passed as arguments of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folderh(df1, key1, df2, ..., na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="folderh_+3A_df1">df1</code></td>
<td>

<p>data frame (can also be a tibble) with at least two columns. It contains a factor (whose name is given by <code>key1</code> argument) whose levels are taken exactly once.
</p>
</td></tr>
<tr><td><code id="folderh_+3A_key1">key1</code></td>
<td>

<p>character string. The name of the factor of the data frames <code>df1</code> and <code>df2</code> which contains the key of the relations &quot;1 to N&quot; between the two datasets.
</p>
</td></tr>
<tr><td><code id="folderh_+3A_df2">df2</code></td>
<td>

<p>data frame (or tibble) with at least two columns. It contains a factor column (named by <code>keys</code> argument) with the same levels as <code>df1[, key1]</code> (see Details).
</p>
</td></tr>
<tr><td><code id="folderh_+3A_...">...</code></td>
<td>

<p>optional. One or several supplementary character strings and data frames, ordered as follows: <code>key2, df3, ...</code>.
The argument <code>key2</code> indicates the key defining the relation &quot;1 to N&quot; between the data frames <code>df2</code> and <code>df3</code>, and so on.
</p>
</td></tr>
<tr><td><code id="folderh_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. If <code>TRUE</code>, the rows of each data frame for which the key is <code>NA</code> are removed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object of class <code>folderh</code> is a list of <code class="reqn">n \ge 2</code> data frames.
</p>

<ul>
<li><p> If no optional arguments are given via <code>...</code>, that is <code class="reqn">n = 2</code>, the two data frames of the list
have a column named by the attribute <code>attr(, "keys")</code> (argument <code>key1</code>), which is a factor with the same levels.
Each one of these levels occur exactly once in the first data frame of the list.
</p>
</li>
<li><p> If some supplementary data frames and supplementary strings <code>key2, df3</code>, ... are given as optional arguments, <code class="reqn">n</code> is the number of data frames given as arguments.
Then, the attribute <code>attr(, "keys")</code> is a vector of <code class="reqn">n-1</code> character strings.
For <code class="reqn">i = 1, \ldots, N-1</code>, its <code class="reqn">i</code>-th element is the name of a column of the <code class="reqn">i</code>-th and <code class="reqn">(i+1)</code>-th data frames of the folderh, which are factors with the same levels.
Each one of these levels occur exactly once in the <code class="reqn">i</code>-th data frame.
</p>
</li></ul>

<p>If there are more than two data frames, <code>folderh</code> computes a folderh with the two last data frames, and then uses the function <code><a href="#topic+appendtofolderh">appendtofolderh</a></code> to append each one of the other data frames to the folderh.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>folderh</code>. Its elements are the data frames passed as arguments, and the attribute <code>attr(, "keys")</code> contains the character arguments.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.folderh">is.folderh</a></code> to test if an object is of class <code>folderh</code>.
<code><a href="#topic+folder">folder</a></code> for a folder of data frames with no hierarchic relation between them.
<code><a href="#topic+as.folder.folderh">as.folder.folderh</a></code> (or <code><a href="#topic+as.data.frame.folderh">as.data.frame.folderh</a></code>) to build an object of class <code>folder</code> (or a data frame) from an object of class <code>folderh</code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: rose flowers
data(roseflowers)
df1 &lt;- roseflowers$variety
df2 &lt;- roseflowers$flower
fh1 &lt;- folderh(df1, "rose", df2)
print(fh1)

# Second example
data(roseleaves)
roses &lt;- roseleaves$rose
stems &lt;- roseleaves$stem
leaves &lt;- roseleaves$leaf
leaflets &lt;- roseleaves$leaflet
fh2 &lt;- folderh(roses, "rose", stems, "stem", leaves, "leaf", leaflets)
print(fh2)
</code></pre>

<hr>
<h2 id='foldermtg'>
foldermtg
</h2><span id='topic+foldermtg'></span>

<h3>Description</h3>

<p>An object of S3 class &quot;foldermtg&quot; is built and returned by the function <code><a href="#topic+read.mtg">read.mtg</a></code>.
</p>


<h3>Value</h3>

<p>An object of this S3 class is a list of at least 5 data frames (see the Value section in <code><a href="#topic+read.mtg">read.mtg</a></code>):
<code>classes</code>, <code>description</code>, <code>features</code>, <code>topology</code>, <code>coordinates</code>...
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>
<code><a href="#topic+print.foldermtg">print.foldermtg</a></code>
<code><a href="#topic+mtgorder">mtgorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtgfile1 &lt;- system.file("extdata/plant1.mtg", package = "dad")
x1 &lt;- read.mtg(mtgfile1)
print(x1)

mtgfile2 &lt;- system.file("extdata/plant2.mtg", package = "dad")
x2 &lt;- read.mtg(mtgfile2)
print(x2)
</code></pre>

<hr>
<h2 id='foldert'>
Folder of data sets among time
</h2><span id='topic+foldert'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"foldert"</code> (called foldert below), that is a list of data frames, each of them corresponding to a time of observation. These data sets are on the same variables. They can be on the same individuals or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldert(x1, x2 = NULL, ..., times = NULL, cols.select = "intersect", rows.select = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foldert_+3A_x1">x1</code></td>
<td>

<p>data frame (can also be a tibble) or list of data frames.
</p>

<ul>
<li><p> If <code>x1</code> is a data frame, <code>x2</code> must be provided.
</p>
</li>
<li><p> If <code>x1</code> is a list of data frames, its elements are the datasets of the folder. In this case, there is no <code>x2</code> argument.
</p>
</li></ul>

</td></tr>
<tr><td><code id="foldert_+3A_x2">x2</code></td>
<td>

<p>data frame. Must be provided if <code>x1</code> is a data frame. Omitted if x1 is a list of data frames.
</p>
</td></tr>
<tr><td><code id="foldert_+3A_...">...</code></td>
<td>

<p>optional. One or several data frames when <code>x1</code> is a data frame. These supplementary data frames are added to the list of data frames constituting the returned foldert.
</p>
</td></tr>
<tr><td><code id="foldert_+3A_times">times</code></td>
<td>

<p>Vector of the &ldquo;times&rdquo; of observations. It can be either numeric, or an ordered factor or an object of class <code>"Date"</code>, <code>"POSIXlt"</code> or <code>"POSIXct"</code>. If omitted, it is <code>1:N</code> where <code>N</code> is the number of data frame arguments (if <code>x1</code> is a data frame) or the length of <code>x1</code> (if it is a list).
</p>
<p>So there is an order relationship between these times.
</p>
</td></tr>
<tr><td><code id="foldert_+3A_cols.select">cols.select</code></td>
<td>

<p>string or character vector. Gives the method used to choose the column names of the data frames of the foldert. This argument can be:
</p>

<dl>
<dt><code>"intersect"</code></dt><dd><p>(default) the column names of the data frames in the foldert are the intersection of the column names of all the data frames given as arguments.</p>
</dd>
<dt><code>"union"</code></dt><dd><p>the column names of the data frames in the foldert are the union of the column names of all the data frames given as arguments. When necessary, the rows of the returned data frames are completed by NA.</p>
</dd>
</dl>

<p>If <code>cols.select</code> is a character vector, it gives the column names selected in the data frames given as arguments. The corresponding columns constitute the columns of the elements of the returned foldert. Notice that when a column name is not present in all data frames (given as arguments), the data are completed by NA.
</p>
</td></tr>
<tr><td><code id="foldert_+3A_rows.select">rows.select</code></td>
<td>

<p>string. Gives the method used to choose the row names of the data frames of the foldert. This argument can be:
</p>

<dl>
<dt><code>""</code></dt><dd><p>(default) the data frames of the foldert have the same rows as those which were passed as arguments.
</p>
</dd>
<dt><code>"intersect"</code></dt><dd><p>the row names of the data frames in the foldert are the intersection of the row names of all the data frames given as arguments.</p>
</dd>
<dt><code>"union"</code></dt><dd><p>the row names of the data frames in the foldert are the union of the row names of all the data frames given as arguments. When necessary, the columns of the data frames returned are completed by <code>NA</code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"foldert"</code> has an attribute <code>attr(,"times")</code> (the <code>times</code> argument, when provided) and a logical attributes 
<code>attr(,"same.rows")</code>.
</p>
<p>The data frames in the returned foldert all have the same column names. That means that the same variables are observed in every data sets.
</p>
<p>If the <code>rows.select</code> argument is <code>"union"</code> or <code>"intersect"</code>, the elements of the returned foldert have the same rows. That means that the same individuals are present in every data sets. This allows to consider the evolution of each individual among time.
</p>
<p>If <code>rows.select</code> is <code>""</code>, every rows of this foldert are different, and the row names are made unique by adding the name of the data frame to the row names. In this case, The individuals of the data sets are assumed to be all different. Or, at least, the user does not mind if they are the same or not.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"foldert"</code>, that is a list of data frames. The elements of this list are ordered according to time.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.foldert">is.foldert</a></code> to test if an object is of class <code>foldert</code>.
<code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>: build an object of class <code>foldert</code> from a data frame.
<code><a href="#topic+as.foldert.array">as.foldert.array</a></code>: build an object of class <code>foldert</code> from a <code class="reqn">3d</code>-array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(xyz = rep(c("A", "B", "C"), each = 2),
                xy = letters[1:6],
                x1 = rnorm(6),
                x2 = rnorm(6, 2, 1),
                row.names = paste0("i", 1:6),
                stringsAsFactors = TRUE)
y &lt;- data.frame(xyz = c("A", "A", "B", "C"),
                xy = c("a", "b", "a", "c"),
                y1 = rnorm(4, 4, 2),
                row.names = c(paste0("i", c(1, 2, 4, 6))),
                stringsAsFactors = TRUE)
z &lt;- data.frame(xyz = c("A", "B", "C"),
                z1 = rnorm(3),
                row.names = c("i1", "i2", "i5"),
                stringsAsFactors = TRUE)

# Columns selected by the user
ftc. &lt;- foldert(x, y, z, cols.select = c("xyz", "x1", "y1", "z1"))
print(ftc.)

# cols.select = "union": all the variables (columns) of each data frame are kept
ftcun &lt;- foldert(x, y, z, cols.select = "union")
print(ftcun)

# cols.select = "intersect": only variables common to all data frames
ftcint &lt;- foldert(x, y, z, cols.select = "intersect")
print(ftcint)

# rows.select = "": the rows of the data frames are unchanged
# and the rownames are made unique
ftr. &lt;- foldert(x, y, z, rows.select = "")
print(ftr.)

# rows.select = "union": all the individuals (rows) of each data frame are kept
ftrun &lt;- foldert(x, y, z, rows.select = "union")
print(ftrun)

# rows.select = "intersect": only individuals common to all data frames
ftrint &lt;- foldert(x, y, z, rows.select = "intersect")
print(ftrint)

# Define the times (times argument)
ftimes &lt;- foldert(x, y, z, times = as.Date(c("2018-03-01", "2018-04-01", "2018-05-01")))
print(ftimes)
</code></pre>

<hr>
<h2 id='fpcad'>
Functional PCA of probability densities
</h2><span id='topic+fpcad'></span>

<h3>Description</h3>

<p>Performs functional principal component analysis of probability densities in order to describe a data folder, consisting of <code class="reqn">T</code> groups of individuals on which are observed <code class="reqn">p</code> variables. It returns an object of class <code>fpcad</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpcad(xf, group.name = "group", gaussiand = TRUE, windowh = NULL, normed = TRUE,
    centered = TRUE, data.centered = FALSE, data.scaled = FALSE,
    common.variance = FALSE, nb.factors = 3, nb.values = 10, sub.title = "",
    plot.eigen = TRUE, plot.score = FALSE, nscore = 1:3,
    filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpcad_+3A_xf">xf</code></td>
<td>

<p>object of class <code>"<a href="#topic+folder">folder</a>"</code> or data.frame.
</p>

<ul>
<li><p> If it is an object of class <code>"folder"</code>, its elements are data frames with <code class="reqn">p</code> numeric columns.
If there are non numeric columns, there is an error.
The <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) matches with the <code class="reqn">t^{th}</code> group.             
</p>
</li>
<li><p> If it is a data frame, the column with name given by the <code>group.name</code> argument is a factor giving the groups.
The other columns are all numeric; otherwise, there is an error.
</p>
</li></ul>

</td></tr>       
<tr><td><code id="fpcad_+3A_group.name">group.name</code></td>
<td>

<p>string.
</p>

<ul>
<li><p> If <code>xf</code> is an object of class <code>"<a href="#topic+folder">folder</a>"</code>, name of the grouping variable in the returned results. The default is <code>groupname  = "group"</code>.
</p>
</li>
<li><p> If <code>xf</code> is a data frame, <code>group.name</code> is the name of the column of <code>xf</code> containing the groups.
</p>
</li></ul>

</td></tr>
<tr><td><code id="fpcad_+3A_gaussiand">gaussiand</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the probability densities are supposed Gaussian. If <code>FALSE</code>, densities are estimated using the Gaussian kernel method.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_windowh">windowh</code></td>
<td>

<p>either a list of <code class="reqn">T</code> bandwidths (one per density associated to a group), or a strictly positive number. If <code>windowh = NULL</code> (default), the bandwidths are automatically computed. See Details.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_normed">normed</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the densities are normed before computing the distances.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_centered">centered</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the densities are centered.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_data.centered">data.centered</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), the data of each group are centered.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_data.scaled">data.scaled</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), the data of each group are centered (even if <code>data.centered = FALSE</code>) and scaled.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_common.variance">common.variance</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), a common covariance matrix (or correlation matrix if <code>data.scaled = TRUE</code>), computed on the whole data, is used. If <code>FALSE</code> (default), a covariance (or correlation) matrix per group is used.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_nb.factors">nb.factors</code></td>
<td>

<p>numeric. Number of returned principal scores (default <code>nb.factors = 3</code>).
</p>
<p>Warning: The <code><a href="#topic+plot.fpcad">plot.fpcad</a></code> and <code><a href="#topic+interpret.fpcad">interpret.fpcad</a></code> functions cannot take into account more than <code>nb.factors</code>  principal factors.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_nb.values">nb.values</code></td>
<td>

<p>numerical. Number of returned eigenvalues (default <code>nb.values = 10</code>).
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_sub.title">sub.title</code></td>
<td>

<p>string. If provided, the subtitle for the graphs.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_plot.eigen">plot.eigen</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the barplot of the eigenvalues is plotted.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_plot.score">plot.score</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the graphs of principal scores are plotted. A new graphic device is opened for each pair of principal scores defined by <code>nscore</code> argument.
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_nscore">nscore</code></td>
<td>

<p>numeric vector. If <code>plot.score = TRUE</code>, the numbers of the principal scores which are plotted. By default it is equal to <code>nscore = 1:3</code>. Its components cannot be greater than <code>nb.factors</code>. 
</p>
</td></tr>
<tr><td><code id="fpcad_+3A_filename">filename</code></td>
<td>

<p>string. Name of the file in which the results are saved. By default (<code>filename  = NULL</code>) the results are not saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The <code class="reqn">T</code> probability densities <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> groups of individuals are either parametrically estimated (<code>gaussiand = TRUE</code>) or estimated using the Gaussian kernel method (<code>gaussiand = FALSE</code>). In the latter case, the <code>windowh</code> argument provides the list of the bandwidths to use. Notice that in the multivariate case (<code class="reqn">p</code>&gt;1) the bandwidths are positive-definite matrices.
</p>
<p>If <code>windowh</code> is a numerical value, the matrix bandwidth is of the form <code class="reqn">h S</code>, where <code class="reqn">S</code> is either the square root of the covariance matrix (<code class="reqn">p</code>&gt;1) or the standard deviation of the estimated density.  
</p>
<p>If <code>windowh = NULL</code> (default), <code class="reqn">h</code> in the above formula is computed using the <code><a href="#topic+bandwidth.parameter">bandwidth.parameter</a></code> function.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>fpcad</code>, that is a list including:
</p>
<table>
<tr><td><code>inertia</code></td>
<td>
<p>data frame of the eigenvalues and percentages of inertia.</p>
</td></tr>
<tr><td><code>contributions</code></td>
<td>
<p>data frame of the contributions to the first <code>nb.factors</code> principal components.</p>
</td></tr>
<tr><td><code>qualities</code></td>
<td>
<p>data frame of the qualities on the first <code>nb.factors</code> principal factors.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>data frame of the first <code>nb.factors</code> principal scores.</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>
<p>vector of the <code class="reqn">L^2</code> norms of the densities.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>list of the means.</p>
</td></tr>
<tr><td><code>variances</code></td>
<td>
<p>list of the covariance matrices.</p>
</td></tr>
<tr><td><code>correlations</code></td>
<td>
<p>list of the correlation matrices.</p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p>list of the skewness coefficients.</p>
</td></tr>
<tr><td><code>kurtosis</code></td>
<td>
<p>list of the kurtosis coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R. (1998). Analyse en composantes principales de distributions gaussiennes multidimensionnelles. Revue de Statistique Appliqu?e, XLVI (2), 5-20.
</p>
<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>
<p>Delicado, P. (2011). Dimensionality reduction when data are density functions. Computational Statistics &amp; Data Analysis, 55, 401-420.
</p>
<p>Yousfi, S., Boumaza, R., Aissani, D., Adjabi, S. (2014). Optimal bandwith matrices in functional principal component analysis of density functions. Journal of Statistical Computation and Simulation, 85 (11), 2315-2330.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.fpcad">print.fpcad</a>, <a href="#topic+plot.fpcad">plot.fpcad</a>, <a href="#topic+interpret.fpcad">interpret.fpcad</a>, <a href="#topic+bandwidth.parameter">bandwidth.parameter</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
# Case of a normed non-centred PCA of Gaussian densities (on 3 architectural 
# characteristics of roses: shape (Sha), foliage density (Den) and symmetry (Sym))
rosesf &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])
result3 &lt;- fpcad(rosesf, group.name = "rose")
print(result3)
plot(result3)

# Applied to a data frame:
result3df &lt;- fpcad(roses[,c("Sha","Den","Sym","rose")], group.name = "rose")
print(result3df)
plot(result3df)

# Flower colors of the roses
scores &lt;- result3$scores
scores &lt;- data.frame(scores, color = scores$rose, stringsAsFactors = TRUE)
colours &lt;- scores$rose
colours &lt;- factor(c(A = "yellow", B = "yellow", C = "pink", D = "yellow", E = "red",
                  F = "yellow", G = "pink", H = "pink", I = "yellow", J = "yellow"))
levels(scores$color) &lt;- c(A = "yellow", B = "yellow", C = "pink", D = "yellow", E = "red",
                         F = "yellow", G = "pink", H = "pink", I = "yellow", J = "yellow")
# Scores according to the first two principal components, per color
plot(result3, nscore = 1:2, color = colours)
</code></pre>

<hr>
<h2 id='fpcat'>
Functional PCA of probability densities among time
</h2><span id='topic+fpcat'></span>

<h3>Description</h3>

<p>Performs functional principal component analysis of probability densities in order to describe a data &ldquo;foldert&rdquo;, consisting of individuals on which are observed <code class="reqn">p</code> variables on <code class="reqn">T</code> times. It returns an object of class <code>fpcat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpcat(xf, group.name="time", method = 1, ind = 1, nvar = NULL, gaussiand = TRUE,
    windowh = NULL, normed=TRUE, centered=TRUE, data.centered = FALSE,
    data.scaled = FALSE, common.variance = FALSE, nb.factors = 3, nb.values = 10,
    sub.title = "", plot.eigen = TRUE, plot.score = FALSE, nscore = 1:3,
    filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpcat_+3A_xf">xf</code></td>
<td>

<p>object of class <code>"<a href="#topic+foldert">foldert</a>"</code> or data.frame.
</p>

<ul>
<li><p> An object of class <code>"foldert"</code> is a list of data frames with the same column names, each of them corresponding to a time of observation. Its elements are data frames with <code class="reqn">p</code> numeric columns.
If there are non numeric columns, there is an error.
The <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) matches with the <code class="reqn">t^{th}</code> time of observation.             
</p>
</li>
<li><p> If it is a data frame:
</p>

<ul>
<li><p> If <code>method=1</code>: the column with name given by the <code>group.name</code> argument is a factor giving the groups.
The other columns are all numeric; otherwise, there is an error.
</p>
</li>
<li><p> If <code>method=2</code>: the column named after the <code>ind</code> argument contains the identifiers of the measured objects, and the observations are organized as follows:
</p>
<p>Given <code>timecol</code> the number of the column named by the <code>group.name</code> argument,
</p>
<p>the observations corresponding to the 1st time are on columns <code>timecol : (timecol + nvar - 1)</code>
</p>
<p>the observations corresponding to the 2nd time are on columns <code>(timecol + nvar) : (timecol + 2 * nvar - 1)</code>
</p>
<p>and so on.
</p>
</li></ul>

</li></ul>

</td></tr>
<tr><td><code id="fpcat_+3A_group.name">group.name</code></td>
<td>

<p>string or numeric.
</p>

<ul>
<li><p> If <code>xf</code> is an object of class <code>"<a href="#topic+foldert">foldert</a>"</code>, string.
Name of the grouping variable, that is the observation times.
The default is <code>groupname  = "time"</code>.
</p>
</li>
<li><p> If <code>xf</code> is a data frame, string or numeric,
as the <code>ind</code> argument of <code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>.
</p>

<ul>
<li><p>If <code>method = 1</code>, <code>timecol</code> is the name or the number of the column of x containing the times of observation, or the number of this column. <code>x[, timecol]</code> must be of class <code>"numeric"</code>, <code>"ordered"</code>, <code>"Date"</code>, <code>"POSIXlt"</code> or <code>"POSIXct"</code>, otherwise, there is an error.

</p>
</li>
<li><p>If <code>method=2</code>, <code>timecol</code> is the name or the number of the first column corresponding to the first observation. If there are duplicated column names and several columns are named by <code>timecol</code>, the first one is considered.

</p>
</li></ul>

</li></ul>

</td></tr>
<tr><td><code id="fpcat_+3A_method">method</code></td>
<td>

<p>if <code>xf</code> is a data frame, 1 or 2. Omitted if <code>xf</code> is an object of class <code>"foldert"</code>.
</p>
<p>If <code>xf</code> is a data frame, <code>method</code> indicates the layout of this data frame and, therefore, the method used to extract the data and build the foldert.
</p>

<ul>
<li><p>If <code>method = 1</code>, there is a column containing the identifiers of the measured objects and a column containing the times. The other columns contain the observations.
</p>
</li>
<li><p>If <code>method = 2</code>, there is a column containing the identifiers of the measured objects, and the observations are organized as follows:
</p>

<ul>
<li><p>the observations corresponding to the 1st time are on columns <code>timecol : (timecol + nvar - 1)</code>
</p>
</li>
<li><p>the observations corresponding to the 2nd time are on columns <code>(timecol + nvar) : (timecol + 2 * nvar - 1)</code>
</p>
</li>
<li><p>and so on.
</p>
</li></ul>


</li></ul>

</td></tr>
<tr><td><code id="fpcat_+3A_ind">ind</code></td>
<td>

<p>if <code>xf</code> is a data frame, string or numeric. Omitted if <code>xf</code> is an object of class <code>"foldert"</code>.
</p>
<p>The name of the column of x containing the indentifiers of the measured objects, or the number of this column.
See the <code>ind</code> argument of <code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_nvar">nvar</code></td>
<td>

<p>if <code>xf</code> is a data frame and <code>mathod=2</code>, string or numeric. Omitted if <code>xf</code> is an object of class <code>"foldert"</code> or if <code>method=1</code>.
</p>
<p>The number of variable measured at each observation time.
See the <code>ind</code> argument of <code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>.
</p>
</td></tr>
</table>
<p>All other arguments are the same as for <code><a href="#topic+fpcad">fpcad</a></code>.
</p>
<table>
<tr><td><code id="fpcat_+3A_gaussiand">gaussiand</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the probability densities are supposed Gaussian. If <code>FALSE</code>, densities are estimated using the Gaussian kernel method (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_windowh">windowh</code></td>
<td>

<p>either a list of <code class="reqn">T</code> bandwidths (one per density associated to a group), or a strictly positive number. If <code>windowh = NULL</code> (default), the bandwidths are automatically computed (as <code><a href="#topic+fpcad">fpcad</a></code>). See Details.
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_normed">normed</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the densities are normed before computing the distances (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_centered">centered</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the densities are centered (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_data.centered">data.centered</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), the data of each group are centered (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_data.scaled">data.scaled</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), the data of each group are centered (even if <code>data.centered = FALSE</code>) and scaled (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_common.variance">common.variance</code></td>
<td>

<p>logical. If <code>TRUE</code> (default is <code>FALSE</code>), a common covariance matrix (or correlation matrix if <code>data.scaled = TRUE</code>), computed on the whole data, is used. If <code>FALSE</code> (default), a covariance (or correlation) matrix per group is used (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_nb.factors">nb.factors</code></td>
<td>

<p>numeric. Number of returned principal scores (default <code>nb.factors = 3</code>) (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
<p>Warning: The <code><a href="#topic+plot.fpcad">plot.fpcad</a></code> and <code><a href="#topic+interpret.fpcad">interpret.fpcad</a></code> functions cannot take into account more than <code>nb.factors</code>  principal factors (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_nb.values">nb.values</code></td>
<td>

<p>numerical. Number of returned eigenvalues (default <code>nb.values = 10</code>) (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_sub.title">sub.title</code></td>
<td>

<p>string. Subtitle for the graphs (default <code>NULL</code>) (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_plot.eigen">plot.eigen</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the barplot of the eigenvalues is plotted (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_plot.score">plot.score</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the graphs of principal scores are plotted. A new graphic device is opened for each pair of principal scores defined by <code>nscore</code> argument (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_nscore">nscore</code></td>
<td>

<p>numeric vector. If <code>plot.score = TRUE</code>, the numbers of the principal scores which are plotted. By default it is equal to <code>nscore = 1:3</code>. Its components cannot be greater than <code>nb.factors</code> (as <code><a href="#topic+fpcad">fpcad</a></code>). 
</p>
</td></tr>
<tr><td><code id="fpcat_+3A_filename">filename</code></td>
<td>

<p>string. Name of the file in which the results are saved. By default (<code>filename  = NULL</code>) the results are not saved (as <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The <code class="reqn">T</code> probability densities <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> times of observation are either parametrically estimated or estimated using the Gaussian kernel method (see <code><a href="#topic+fpcad">fpcad</a></code> for the use of the arguments indicating the method used to estimate these densities).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>fpcat</code>, that is a list including:
</p>
<table>
<tr><td><code>times</code></td>
<td>
<p>vector of the times of observation.</p>
</td></tr>
<tr><td><code>inertia</code></td>
<td>
<p>data frame of the eigenvalues and percentages of inertia.</p>
</td></tr>
<tr><td><code>contributions</code></td>
<td>
<p>data frame of the contributions to the first <code>nb.factors</code> principal components.</p>
</td></tr>
<tr><td><code>qualities</code></td>
<td>
<p>data frame of the qualities on the first <code>nb.factors</code> principal factors.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>data frame of the first <code>nb.factors</code> principal scores.</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>
<p>vector of the <code class="reqn">L^2</code> norms of the densities.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>list of the means.</p>
</td></tr>
<tr><td><code>variances</code></td>
<td>
<p>list of the covariance matrices.</p>
</td></tr>
<tr><td><code>correlations</code></td>
<td>
<p>list of the correlation matrices.</p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p>list of the skewness coefficients.</p>
</td></tr>
<tr><td><code>kurtosis</code></td>
<td>
<p>list of the kurtosis coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R. (1998). Analyse en composantes principales de distributions gaussiennes multidimensionnelles. Revue de Statistique Appliqu?e, XLVI (2), 5-20.
</p>
<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>
<p>Delicado, P. (2011). Dimensionality reduction when data are density functions. Computational Statistics &amp; Data Analysis, 55, 401-420.
</p>
<p>Yousfi, S., Boumaza, R., Aissani, D., Adjabi, S. (2014). Optimal bandwith matrices in functional principal component analysis of density functions. Journal of Statistical Computation and Simulation, 85 (11), 2315-2330.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.fpcat">print.fpcat</a>, <a href="#topic+plot.fpcat">plot.fpcat</a>, 
<a href="#topic+bandwidth.parameter">bandwidth.parameter</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times &lt;- as.Date(c("2017-03-01", "2017-04-01", "2017-05-01", "2017-06-01"))
x1 &lt;- data.frame(z1=rnorm(6,1,5), z2=rnorm(6,3,3))
x2 &lt;- data.frame(z1=rnorm(6,4,6), z2=rnorm(6,5,2))
x3 &lt;- data.frame(z1=rnorm(6,7,2), z2=rnorm(6,8,4))
x4 &lt;- data.frame(z1=rnorm(6,9,3), z2=rnorm(6,10,2))
ft &lt;- foldert(x1, x2, x3, x4, times = times, rows.select="intersect")
print(ft)
result &lt;- fpcat(ft)
print(result)
plot(result)
</code></pre>

<hr>
<h2 id='getcol.folder'>
Select columns in all elements of a folder
</h2><span id='topic+getcol.folder'></span>

<h3>Description</h3>

<p>Select columns in all data frames of a folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcol.folder(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getcol.folder_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="getcol.folder_+3A_name">name</code></td>
<td>

<p>character vector. The names of the columns to be selected in each data frame of the folder.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A folder with the same number of elements as <code>object</code>. Its <code class="reqn">k^{th}</code> element is a data frame, and its columns are the columns of <code>object[[k]]</code> given by <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>: object of class <code>folder</code>.
</p>
<p><code><a href="#topic+rmcol.folder">rmcol.folder</a></code>: remove columns in all elements of a folder.
</p>
<p><code><a href="#topic+getrow.folder">getrow.folder</a></code>: select rows in all elements of a folder.
</p>
<p><code><a href="#topic+rmrow.folder">rmrow.folder</a></code>: remove rows in all elements of a folder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

iris.fold &lt;- as.folder(iris, "Species")
getcol.folder(iris.fold, "Sepal.Length")
getcol.folder(iris.fold, c("Petal.Length", "Petal.Width"))
</code></pre>

<hr>
<h2 id='getcol.foldert'>
Select columns in all elements of a foldert
</h2><span id='topic+getcol.foldert'></span>

<h3>Description</h3>

<p>Select columns in all data frames of a foldert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcol.foldert(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getcol.foldert_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+foldert">foldert</a></code> that is a list of data frames with the same column names, each of them corresponding to a time of observation.
</p>
</td></tr>
<tr><td><code id="getcol.foldert_+3A_name">name</code></td>
<td>

<p>character vector. The names of the columns to be selected in each data frame of the foldert.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A foldert with the same number of elements as <code>object</code>. Its <code class="reqn">k^{th}</code> element is a data frame, and its columns are the columns of <code>object[[k]]</code> given by <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: object of class <code>foldert</code>.
</p>
<p><code><a href="#topic+rmcol.foldert">rmcol.foldert</a></code>: remove columns in all elements of a foldert.
</p>
<p><code><a href="#topic+getrow.foldert">getrow.foldert</a></code>: select rows in all elements of a foldert.
</p>
<p><code><a href="#topic+rmrow.foldert">rmrow.foldert</a></code>: remove rows in all elements of a foldert.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(floribundity)

ft0 &lt;- foldert(floribundity, cols.select = "union")
getcol.foldert(ft0, c("rose", "variety"))
</code></pre>

<hr>
<h2 id='getrow.folder'>
Select rows in all elements of a folder
</h2><span id='topic+getrow.folder'></span>

<h3>Description</h3>

<p>Select rows in all data frames of a folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getrow.folder(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getrow.folder_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="getrow.folder_+3A_name">name</code></td>
<td>

<p>character vector. The names of the rows to be selected in each data frame of the folder.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A folder with the same number of elements as <code>object</code>. Its <code class="reqn">k^{th}</code> element is a data frame, and its rows are the rows of <code>object[[k]]</code> given by <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>: object of class <code>folder</code>.
</p>
<p><code><a href="#topic+rmrow.folder">rmrow.folder</a></code>: remove rows in all elements of a folder.
</p>
<p><code><a href="#topic+getcol.folder">getcol.folder</a></code>: select rows in all elements of a folder.
</p>
<p><code><a href="#topic+rmcol.folder">rmcol.folder</a></code>: remove rows in all elements of a folder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

iris.fold &lt;- as.folder(iris, "Species")
getrow.folder(iris.fold, c(1:5, 51:55, 101:105))
</code></pre>

<hr>
<h2 id='getrow.foldert'>
Select rows in all elements of a foldert
</h2><span id='topic+getrow.foldert'></span>

<h3>Description</h3>

<p>Select rows in all data frames of a foldert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getrow.foldert(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getrow.foldert_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+foldert">foldert</a></code> that is a list of data frames with the same column names, each of them corresponding to a time of observation.
</p>
</td></tr>
<tr><td><code id="getrow.foldert_+3A_name">name</code></td>
<td>

<p>character vector. The names of the rows to be selected in each data frame of the foldert.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A foldert with the same number of elements as <code>object</code>. Its <code class="reqn">k^{th}</code> element is a data frame, and its rows are the rows of <code>object[[k]]</code> given by <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: object of class <code>foldert</code>.
</p>
<p><code><a href="#topic+rmrow.foldert">rmrow.foldert</a></code>: remove rows in all elements of a foldert.
</p>
<p><code><a href="#topic+getcol.foldert">getcol.foldert</a></code>: select columns in all elements of a foldert.
</p>
<p><code><a href="#topic+rmcol.foldert">rmcol.foldert</a></code>: remove columns in all elements of a foldert.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(floribundity)

ft0 &lt;- foldert(floribundity, cols.select = "union", rows.select = "union")
getrow.foldert(ft0, c("16", "51"))
</code></pre>

<hr>
<h2 id='hclustdd'>
Hierarchic cluster analysis of discrete probability distributions
</h2><span id='topic+hclustdd'></span>

<h3>Description</h3>

<p>Performs functional hierarchic cluster analysis of discrete probability distributions. It returns an object of class <code><a href="#topic+hclustdd">hclustdd</a></code>. It applies <code><a href="stats.html#topic+hclust">hclust</a></code> to the distance matrix between the <code class="reqn">T</code> distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclustdd(xf, group.name = "group", distance = c("l1", "l2", "chisqsym", "hellinger",
             "jeffreys", "jensen", "lp"), 
             sub.title = "", filename = NULL,
             method.hclust = "complete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hclustdd_+3A_xf">xf</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code>, or list of arrays (or tables).
</p>

<ul>
<li><p> If it is a folder, its elements are data frames with <code class="reqn">q</code> columns (considered as factors).
The <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) matches with the <code class="reqn">t^{th}</code> group.
</p>
</li>
<li><p> If it is a data frame, the columns with name given by the <code>group.name</code> argument is a factor giving the groups.
The other columns are all considered as factors.
</p>
</li>
<li><p> If it is a list of arrays (or tables), the <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) is the table of the joint frequency distribution of <code class="reqn">q</code> variables within the <code class="reqn">t^{th}</code> group. The frequency distribution is expressed with relative or absolute frequencies.
These arrays have the same shape.
</p>
<p>Each array (or table) <code>xf[[i]]</code> has:
</p>

<ul>
<li><p> the same dimension(s). If <code class="reqn">q = 1</code> (univariate), <code>dim(xf[[i]])</code> is an integer. If <code class="reqn">q &gt; 1</code> (multivariate), <code>dim(xf[[i]])</code> is an integer vector of length <code>q</code>.
</p>
</li>
<li><p> the same dimension names <code>dimnames(xf[[i]])</code> (is non <code>NULL</code>). These dimnames are the names of the variables.
</p>
</li></ul>

<p>The elements of the arrays are non-negative numbers (if they are not, there is an error).
</p>
</li></ul>

</td></tr>       
<tr><td><code id="hclustdd_+3A_group.name">group.name</code></td>
<td>

<p>string. Name of the grouping variable. Default: <code>group.name  = "group"</code>.
</p>
</td></tr>
<tr><td><code id="hclustdd_+3A_distance">distance</code></td>
<td>

<p>The distance or divergence used to compute the distance matrix between the discrete distributions (see Details).
It can be:
</p>

<ul>
<li> <p><code>"l1"</code> (default) the <code class="reqn">L^p</code> distance with <code class="reqn">p = 1</code>
</p>
</li>
<li> <p><code>"l2"</code> the <code class="reqn">L^p</code> distance with <code class="reqn">p = 2</code>
</p>
</li>
<li> <p><code>"chisqsym"</code> the symmetric Chi-squared distance
</p>
</li>
<li> <p><code>"hellinger"</code> the Hellinger metric (Matusita distance)
</p>
</li>
<li> <p><code>"jeffreys"</code> Jeffreys distance (symmetrised Kullback-Leibler divergence)
</p>
</li>
<li> <p><code>"jensen"</code> the Jensen-Shannon distance
</p>
</li>
<li> <p><code>"lp"</code> the <code class="reqn">L^p</code> distance with <code class="reqn">p</code> given by the argument <code>p</code> of the function.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="hclustdd_+3A_sub.title">sub.title</code></td>
<td>

<p>string. If provided, the subtitle for the graphs.
</p>
</td></tr>
<tr><td><code id="hclustdd_+3A_filename">filename</code></td>
<td>

<p>string. Name of the file in which the results are saved. By default (<code>filename  = NULL</code>) the results are not saved.
</p>
</td></tr>
<tr><td><code id="hclustdd_+3A_method.hclust">method.hclust</code></td>
<td>

<p>the agglomeration method to be used for the clustering. See the <code>method</code> argument of the <code><a href="stats.html#topic+hclust">hclust</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>In order to compute the distances/dissimilarities between the groups, the <code class="reqn">T</code> probability distributions <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> groups of individuals are estimated from observations.
Then the distances/dissimilarities between the estimated distributions are computed, using the distance or divergence defined by the <code>distance</code> argument:
</p>
<p>If the distance is <code>"l1"</code>, <code>"l2"</code> or <code>"lp"</code>, the distances are computed by the function <code><a href="#topic+matddlppar">matddlppar</a></code>.
Otherwise, it can be computed by <code><a href="#topic+matddchisqsympar">matddchisqsympar</a></code> (<code>"chisqsym"</code>), <code><a href="#topic+matddhellingerpar">matddhellingerpar</a></code> (<code>"hellinger"</code>), <code><a href="#topic+matddjeffreyspar">matddjeffreyspar</a></code> (<code>"jeffreys"</code>) or <code><a href="#topic+matddjensenpar">matddjensenpar</a></code> (<code>"jensen"</code>).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>hclustdd</code>, that is a list including:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>matrix of the <code class="reqn">L^2</code>-distances between the estimated densities.</p>
</td></tr>
<tr><td><code>clust</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+hclustdd">hclustdd</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 with a folder (10 groups) of 3 factors 
# obtained by converting numeric variables 
data(roses)
xr = roses[,c("Sha", "Den", "Sym", "rose")]
xr = cut(xr, breaks = list(c(0, 5, 7, 10), c(0, 4, 6, 10), c(0, 6, 8, 10)))
xf = as.folder(xr, groups = "rose")
af = hclustdd(xf)
print(af)
print(af, dist.print = TRUE)
plot(af)
plot(af, hang = -1)

# Example 2 with a data frame obtained by converting numeric variables
ar = hclustdd(xr, group.name = "rose")
print(ar)
print(ar, dist.print = TRUE)
plot(ar)
plot(ar, hang = -1)

# Example 3 with a list of 7 arrays
data(dspg)
xl = dspg
hclustdd(xl)
</code></pre>

<hr>
<h2 id='hellinger'>
Hellinger distance between Gaussian densities
</h2><span id='topic+hellinger'></span>

<h3>Description</h3>

<p>Hellinger distance between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hellinger(x1, x2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hellinger_+3A_x1">x1</code></td>
<td>

<p>a matrix or data frame of <code class="reqn">n_1</code> rows (observations) and <code class="reqn">p</code> columns (variables) (can also be a tibble) or a vector of length <code class="reqn">n_1</code>.
</p>
</td></tr>
<tr><td><code id="hellinger_+3A_x2">x2</code></td>
<td>

<p>matrix or data frame (or tibble) of <code class="reqn">n_2</code> rows and <code class="reqn">p</code> columns or vector of length <code class="reqn">n_2</code>.
</p>
</td></tr>
<tr><td><code id="hellinger_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate (multivariate case) or if the variances are not zero (univariate case).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hellinger distance between the two Gaussian densities is computed by using the <code><a href="#topic+hellingerpar">hellingerpar</a></code> function and the density parameters estimated from samples.
</p>


<h3>Value</h3>

<p>Returns the <code class="reqn">Hellinger</code> distance between the two probability densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one smoothing bandwidth matrix is degenerate, the result returned can not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>McLachlan, G.J. (1992). Discriminant analysis and statistical pattern recognition. John Wiley &amp; Sons, New York .
</p>


<h3>See Also</h3>

<p><a href="#topic+hellingerpar">hellingerpar</a>: Hellinger distance between Gaussian densities, given their parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
m1 &lt;- c(0,0)
v1 &lt;- matrix(c(1,0,0,1),ncol = 2) 
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(4,1,1,9),ncol = 2)
x1 &lt;- mvrnorm(n = 3,mu = m1,Sigma = v1)
x2 &lt;- mvrnorm(n = 5, mu = m2, Sigma = v2)
hellinger(x1, x2)
</code></pre>

<hr>
<h2 id='hellingerpar'>
Hellinger distance between Gaussian densities given their parameters
</h2><span id='topic+hellingerpar'></span>

<h3>Description</h3>

<p>Hellinger distance between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate) (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hellingerpar(mean1, var1, mean2, var2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hellingerpar_+3A_mean1">mean1</code></td>
<td>

<p><code class="reqn">p</code>-length numeric vector: the mean of the first Gaussian density.
</p>
</td></tr>
<tr><td><code id="hellingerpar_+3A_var1">var1</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric numeric matrix (<code class="reqn">p</code> &gt; 1) or numeric (<code class="reqn">p</code> = 1): the covariance matrix (<code class="reqn">p</code> &gt; 1) or the variance (<code class="reqn">p</code> = 1) of the first Gaussian density.
</p>
</td></tr>
<tr><td><code id="hellingerpar_+3A_mean2">mean2</code></td>
<td>

<p><code class="reqn">p</code>-length numeric vector: the mean of the second Gaussian density.
</p>
</td></tr>
<tr><td><code id="hellingerpar_+3A_var2">var2</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric numeric matrix (<code class="reqn">p</code> &gt; 1) or numeric (<code class="reqn">p</code> = 1): the covariance matrix (<code class="reqn">p</code> &gt; 1) or the variance (<code class="reqn">p</code> = 1) of the second Gaussian density.
</p>
</td></tr>
<tr><td><code id="hellingerpar_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate (multivariate case) or if the variances are not zero (univariate case).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean vectors (<code class="reqn">m1</code> and <code class="reqn">m2</code>) and variance matrices (<code class="reqn">v1</code> and <code class="reqn">v2</code>) given as arguments (<code>mean1</code>, <code>mean2</code>, <code>var1</code> and <code>var2</code>) are used to compute the Hellinger distance between the two Gaussian densities, equal to: 
</p>
<p style="text-align: center;"><code class="reqn">( 2 (1 -  2^{p/2} det(v1 v2)^{1/4} det(v1 + v2)^{-1/2}  exp((-1/4) t(m1-m2) (v1+v2)^{-1} (m1-m2)) ))^{1/2}</code>
</p>

<p>If <code class="reqn">p = 1</code> the means and variances are numbers, the formula is the same ignoring the following operators: t (transpose of a matrix or vector) and det (determinant of a square matrix).
</p>


<h3>Value</h3>

<p>The Hellinger distance between two Gaussian densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one covariance matrix is degenerated (multivariate case) or one variance is zero (univariate case), the result returned must not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>McLachlan, G.J. (1992). Discriminant analysis and statistical pattern recognition. John Wiley &amp; Sons, New York .
</p>


<h3>See Also</h3>

<p><a href="#topic+hellinger">hellinger</a>: Hellinger distance between Gaussian densities estimated from samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- c(1,1)
v1 &lt;- matrix(c(4,1,1,9),ncol = 2)
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(1,0,0,1),ncol = 2)
hellingerpar(m1,v1,m2,v2)
</code></pre>

<hr>
<h2 id='interpret'>
Scores of <code>fmdsd</code>, <code>dstatis</code>, <code>fpcad</code>, or <code>fpcat</code> vs. moments, or scores of <code>mdsdd</code> vs. marginal distributions or association measures
</h2><span id='topic+interpret'></span>

<h3>Description</h3>

<p>This generic function provides a tool for the interpretation of the results of <code>fmdsd</code>, <code>dstatis</code>, <code>fpcad</code>, <code>fpcat</code> or <code>mdsdd</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpret(x, nscore = 1:3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpret_+3A_x">x</code></td>
<td>

<p>object of class <code>fmdsd</code>, <code>dstatis</code>, <code>fpcad</code>, <code>fpcat</code> or <code>mdsdd</code>.
</p>

<ul>
<li> <p><code>fmdsd</code>: see <code><a href="#topic+interpret.fmdsd">interpret.fmdsd</a></code>
</p>
</li>
<li> <p><code>dstatis</code>: see <code><a href="#topic+interpret.dstatis">interpret.dstatis</a></code>
</p>
</li>
<li> <p><code>fpcad</code>: see <code><a href="#topic+interpret.fpcad">interpret.fpcad</a></code>
</p>
</li>
<li> <p><code>fpcat</code>: see <code><a href="#topic+interpret.fpcat">interpret.fpcat</a></code>
</p>
</li>
<li> <p><code>mdsdd</code>: see <code><a href="#topic+interpret.mdsdd">interpret.mdsdd</a></code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="interpret_+3A_nscore">nscore</code></td>
<td>

<p>numeric vector. Selects the columns of the data frame <code>x$scores</code> to be interpreted.
</p>
<p>Warning: Its components cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+fpcad">fpcad</a></code> or <code><a href="#topic+fpcat">fpcat</a></code> function.
</p>
</td></tr>
<tr><td><code id="interpret_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to the methods, such as <code>moment</code> (for <code><a href="#topic+interpret.fmdsd">interpret.fmdsd</a></code>, <code><a href="#topic+interpret.dstatis">interpret.dstatis</a></code>,
<code><a href="#topic+interpret.fpcad">interpret.fpcad</a></code> and <code><a href="#topic+interpret.fpcat">interpret.fpcat</a></code>), or <code>mma</code> (for <code><a href="#topic+interpret.mdsdd">interpret.mdsdd</a></code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr><td><code>pearson</code></td>
<td>
<p>matrix of Pearson correlations between selected scores and moments, probabilities or associations.</p>
</td></tr>
<tr><td><code>spearman</code></td>
<td>
<p>matrix of Spearman correlations between selected scores and moments, probabilities or associations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+interpret.fmdsd">interpret.fmdsd</a>; <a href="#topic+interpret.dstatis">interpret.dstatis</a>; <a href="#topic+interpret.fpcad">interpret.fpcad</a>; <a href="#topic+interpret.fpcat">interpret.fpcat</a>; <a href="#topic+interpret.mdsdd">interpret.mdsdd</a>.
</p>

<hr>
<h2 id='interpret.dstatis'>
Scores of the <code>dstatis</code> function vs. moments of the densities
</h2><span id='topic+interpret.dstatis'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"dstatis"</code>, plots the principal scores vs. the moments of the densities (means, standard deviations, variances, correlations, skewness and kurtosis coefficients), and computes the correlations between these scores and moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dstatis'
interpret(x, nscore = 1, moment=c("mean", "sd", "var", "cov", "cor",
    "skewness", "kurtosis"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpret.dstatis_+3A_x">x</code></td>
<td>

<p>object of class <code>"dstatis"</code> (returned by the <code><a href="#topic+dstatis.inter">dstatis.inter</a></code> function).
</p>
</td></tr>
<tr><td><code id="interpret.dstatis_+3A_nscore">nscore</code></td>
<td>

<p>numeric. Selects the column of the data frame <code>x$scores</code> consisting of a score vector.
</p>
<p>Note that since dad-4, <code>nscore</code> can only be a single value (in earlier versions, it could be a vector of length &gt; 1).
</p>
<p>Warning: <code>nscore</code> cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+dstatis.inter">dstatis.inter</a></code> function.
</p>
</td></tr>
<tr><td><code id="interpret.dstatis_+3A_moment">moment</code></td>
<td>

<p>characters string. Selects the moments to cross with scores:
</p>

<ul>
<li> <p><code>"mean"</code> (means)
</p>
</li>
<li> <p><code>"sd"</code> (standard deviations)
</p>
</li>
<li> <p><code>"cov"</code> (covariances)
</p>
</li>
<li> <p><code>"cor"</code> (correlation coefficients)
</p>
</li>
<li> <p><code>"skewness"</code> (skewness coefficients)
</p>
</li>
<li> <p><code>"kurtosis"</code> (kurtosis coefficients)
</p>
</li></ul>

</td></tr>
<tr><td><code id="interpret.dstatis_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graphics device can contain up to 9 graphs.
If there are too many (more than 36) graphs for each score, one can display the graphs in a multipage PDF file.
</p>
<p>The number of principal scores to be interpreted cannot be greater than <code>nb.factors</code> of the data frame <code>x$scores</code> returned by the function <a href="#topic+dstatis.inter">dstatis.inter</a>.
</p>


<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr><td><code>pearson</code></td>
<td>
<p>matrix of Pearson correlations between selected scores and moments.</p>
</td></tr>
<tr><td><code>spearman</code></td>
<td>
<p>matrix of Spearman correlations between selected scores and moments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Lavit, C., Escoufier, Y., Sabatier, R., Traissac, P. (1994). The ACT (STATIS method). Computational Statistics &amp; Data Analysis, 18 (1994), 97-119.
</p>


<h3>See Also</h3>

<p><a href="#topic+dstatis.inter">dstatis.inter</a>; <a href="#topic+plot.dstatis">plot.dstatis</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
rosesf &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])

# Dual STATIS on the covariance matrices
## Not run: 
result &lt;- dstatis.inter(rosesf, group.name = "rose")
interpret(result)
interpret(result, moment = "var")
interpret(result, moment = "cor")
interpret(result, nscore = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='interpret.fmdsd'>
Scores of the <code>fmdsd</code> function vs. moments of the densities
</h2><span id='topic+interpret.fmdsd'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fmdsd"</code>, plots the scores vs. the moments of the densities (means, standard deviations, variances, correlations, skewness and kurtosis coefficients), and computes the correlations between these scores and moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmdsd'
interpret(x, nscore = 1, moment=c("mean", "sd", "var", "cov", "cor",
    "skewness", "kurtosis"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpret.fmdsd_+3A_x">x</code></td>
<td>

<p>object of class <code>"fmdsd"</code> (returned by the <code><a href="#topic+fmdsd">fmdsd</a></code> function).
</p>
</td></tr>
<tr><td><code id="interpret.fmdsd_+3A_nscore">nscore</code></td>
<td>

<p>numeric. Selects the column of the data frame <code>x$scores</code> consisting of a score vector.
</p>
<p>Note that since dad-4, <code>nscore</code> can only be a single value (in earlier versions, it could be a vector of length &gt; 1).
</p>
<p>Warning: <code>nscore</code> cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+fmdsd">fmdsd</a></code> function.
</p>
</td></tr>
<tr><td><code id="interpret.fmdsd_+3A_moment">moment</code></td>
<td>

<p>character string. Selects the moments to cross with scores:
</p>

<ul>
<li> <p><code>"mean"</code> (means, which is the default value)
</p>
</li>
<li> <p><code>"sd"</code> (standard deviations)
</p>
</li>
<li> <p><code>"cov"</code> (covariances)
</p>
</li>
<li> <p><code>"cor"</code> (correlation coefficients)
</p>
</li>
<li> <p><code>"skewness"</code> (skewness coefficients)
</p>
</li>
<li> <p><code>"kurtosis"</code> (kurtosis coefficients)
</p>
</li></ul>

</td></tr>
<tr><td><code id="interpret.fmdsd_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graphics device can contain up to 9 graphs.
If there are too many (more than 36) graphs for each score, one can display the graphs in a multipage PDF file.
</p>
<p>The number of principal scores to be interpreted cannot be greater than <code>nb.factors</code> of the data frame <code>x$scores</code> returned by the function <code><a href="#topic+fmdsd">fmdsd</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr><td><code>pearson</code></td>
<td>
<p>matrix of Pearson correlations between selected scores and moments.</p>
</td></tr>
<tr><td><code>spearman</code></td>
<td>
<p>matrix of Spearman correlations between selected scores and moments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>
<p>Delicado, P. (2011). Dimensionality reduction when data are density functions. Computational Statistics &amp; Data Analysis, 55, 401-420.
</p>


<h3>See Also</h3>

<p><a href="#topic+fmdsd">fmdsd</a>; <a href="#topic+plot.fmdsd">plot.fmdsd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
x &lt;- roses[,c("Sha","Den","Sym","rose")]
rosesfold &lt;- as.folder(x)
result1 &lt;- fmdsd(rosesfold)
interpret(result1)
## Not run: 
interpret(result1, moment = "var")

## End(Not run)
interpret(result1, nscore = 2)
</code></pre>

<hr>
<h2 id='interpret.fpcad'>
Scores of the <code>fpcad</code> function vs. moments of the densities
</h2><span id='topic+interpret.fpcad'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fpcad"</code>, plots the principal scores vs. the moments of the densities (means, standard deviations, variances, correlations, skewness and kurtosis coefficients), and computes the correlations between these scores and moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpcad'
interpret(x, nscore = 1, moment=c("mean", "sd", "var", "cov", "cor",
    "skewness", "kurtosis"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpret.fpcad_+3A_x">x</code></td>
<td>

<p>object of class <code>"fpcad"</code> (returned by the <code><a href="#topic+fpcad">fpcad</a></code> function).
</p>
</td></tr>
<tr><td><code id="interpret.fpcad_+3A_nscore">nscore</code></td>
<td>

<p>numeric. Selects the column of the data frame <code>x$scores</code> consisting of a score vector.
</p>
<p>Note that since dad-4, <code>nscore</code> can only be a single value (in earlier versions, it could be a vector of length &gt; 1).
</p>
<p>Warning: <code>nscore</code> cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+fpcad">fpcad</a></code> function.
</p>
</td></tr>
<tr><td><code id="interpret.fpcad_+3A_moment">moment</code></td>
<td>

<p>characters string. Selects the moments to cross with scores:
</p>

<ul>
<li> <p><code>"mean"</code> (means)
</p>
</li>
<li> <p><code>"sd"</code> (standard deviations)
</p>
</li>
<li> <p><code>"cov"</code> (covariances)
</p>
</li>
<li> <p><code>"cor"</code> (correlation coefficients)
</p>
</li>
<li> <p><code>"skewness"</code> (skewness coefficients)
</p>
</li>
<li> <p><code>"kurtosis"</code> (kurtosis coefficients)
</p>
</li></ul>

</td></tr>
<tr><td><code id="interpret.fpcad_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graphics device can contain up to 9 graphs.
If there are too many (more than 36) graphs for each score, one can display the graphs in a multipage PDF file.
</p>
<p>The number of principal scores to be interpreted cannot be greater than <code>nb.factors</code> of the data frame <code>x$scores</code> returned by the function <a href="#topic+fpcad">fpcad</a>.
</p>


<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr><td><code>pearson</code></td>
<td>
<p>matrix of Pearson correlations between selected scores and moments.</p>
</td></tr>
<tr><td><code>spearman</code></td>
<td>
<p>matrix of Spearman correlations between selected scores and moments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+fpcad">fpcad</a>; <a href="#topic+plot.fpcad">plot.fpcad</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
rosefold &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])
result1 &lt;- fpcad(rosefold)
interpret(result1)
## Not run: 
interpret(result1, moment = "var")

## End(Not run)
interpret(result1, moment = "cor")
interpret(result1, nscore = 2)
</code></pre>

<hr>
<h2 id='interpret.fpcat'>
Scores of the <code>"fpcat"</code> function vs. moments of the densities
</h2><span id='topic+interpret.fpcat'></span>

<h3>Description</h3>

<p>This function applies to an object of class <code>"fpcat"</code> and does the same as for an object of class <code>"fpcad"</code>: it plots the principal scores vs. the moments of the densities (means, standard deviations, variances, correlations, skewness and kurtosis coefficients), and computes the correlations between these scores and moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpcat'
interpret(x, nscore = 1, moment=c("mean", "sd", "var", "cov", "cor",
    "skewness", "kurtosis"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpret.fpcat_+3A_x">x</code></td>
<td>

<p>object of class <code>"fpcat"</code> (returned by the <code><a href="#topic+fpcat">fpcat</a></code> function).
</p>
</td></tr>
<tr><td><code id="interpret.fpcat_+3A_nscore">nscore</code></td>
<td>

<p>numeric. Selects the column of the data frame <code>x$scores</code> consisting of a score vector.
</p>
<p>Note that since dad-4, <code>nscore</code> can only be a single value (in earlier versions, it could be a vector of length &gt; 1).
</p>
<p>Warning: <code>nscore</code> cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+fpcat">fpcat</a></code> function.
</p>
</td></tr>
<tr><td><code id="interpret.fpcat_+3A_moment">moment</code></td>
<td>

<p>characters string. Selects the moments to cross with scores:
</p>

<ul>
<li> <p><code>"mean"</code> (means)
</p>
</li>
<li> <p><code>"sd"</code> (standard deviations)
</p>
</li>
<li> <p><code>"cov"</code> (covariances)
</p>
</li>
<li> <p><code>"cor"</code> (correlation coefficients)
</p>
</li>
<li> <p><code>"skewness"</code> (skewness coefficients)
</p>
</li>
<li> <p><code>"kurtosis"</code> (kurtosis coefficients)
</p>
</li></ul>

</td></tr>
<tr><td><code id="interpret.fpcat_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graphics device can contain up to 9 graphs.
If there are too many (more than 36) graphs for each score, one can display the graphs in a multipage PDF file.
</p>
<p>The number of principal scores to be interpreted cannot be greater than <code>nb.factors</code> of the data frame <code>x$scores</code> returned by the function <a href="#topic+fpcat">fpcat</a>.
</p>


<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr><td><code>pearson</code></td>
<td>
<p>matrix of Pearson correlations between selected scores and moments.</p>
</td></tr>
<tr><td><code>spearman</code></td>
<td>
<p>matrix of Spearman correlations between selected scores and moments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+fpcat">fpcat</a>; <a href="#topic+plot.fpcat">plot.fpcat</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Alsacian castles with their building year
data(castles)
castyear &lt;- foldert(lapply(castles, "[", 1:4))
fpcayear &lt;- fpcat(castyear, group.name = "year")
interpret(fpcayear)
## Not run: 
interpret(fpcayear, moment="var")

## End(Not run)
</code></pre>

<hr>
<h2 id='interpret.mdsdd'>
Scores of the <code>mdsdd</code> function vs. marginal probability distributions or association measures
</h2><span id='topic+interpret.mdsdd'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"mdsdd"</code>, plots the scores vs. the marginal probability distributions or pairwise association measures of the discrete variables, and computes the correlations between these scores and probabilities or association measures (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdsdd'
interpret(x, nscore = 1, mma = c("marg1", "marg2", "assoc"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpret.mdsdd_+3A_x">x</code></td>
<td>

<p>object of class <code>"mdsdd"</code> (returned by the <code><a href="#topic+mdsdd">mdsdd</a></code> function).
</p>
</td></tr>
<tr><td><code id="interpret.mdsdd_+3A_nscore">nscore</code></td>
<td>

<p>numeric. Selects the column of the data frame <code>x$scores</code> consisting of a score vector.
</p>
<p>Note that since dad-4, <code>nscore</code> can only be a single value (in earlier versions, it could be a vector of length &gt; 1).
</p>
<p>Warning: <code>nscore</code> cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+mdsdd">mdsdd</a></code> function.
</p>
</td></tr>
<tr><td><code id="interpret.mdsdd_+3A_mma">mma</code></td>
<td>

<p>character. Indicates which measures will be considered:
</p>

<ul>
<li><p>&quot;marg1&quot;: the probability distribution of each variable.
</p>
</li>
<li><p>&quot;marg2&quot;: the joint probability distribution of each pair of variables.
</p>
</li>
<li><p>&quot;assoc&quot;: the pairwise association measures of the variables.
</p>
</li></ul>

</td></tr>
<tr><td><code id="interpret.mdsdd_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graphics device can contain up to 9 graphs.
If there are too many (more than 36) graphs for each score, one can display the graphs in a multipage PDF file.
</p>
<p>The number of principal scores to be interpreted cannot be greater than <code>nb.factors</code> of the data frame <code>x$scores</code> returned by the function <code><a href="#topic+mdsdd">mdsdd</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr><td><code>pearson</code></td>
<td>
<p>matrix of Pearson correlations between selected scores and probabilities or association measures.</p>
</td></tr>
<tr><td><code>spearman</code></td>
<td>
<p>matrix of Spearman correlations between selected scores and probabilities or association measures.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+mdsdd">mdsdd</a>; <a href="#topic+plot.mdsdd">plot.mdsdd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># INSEE (France): Diploma x Socio professional group, seven years.
data(dspg)
xlista = dspg
a &lt;- mdsdd(xlista)
interpret(a)

# Example 3 with a list of 96 arrays (departments)
## Not run: 
data(dspgd2015)
xd = dspgd2015
res = mdsdd(xd, group.name = "coded")
interpret(res)
plot(res, fontsize.points = 0.7)

# Each department is represented by its name
data(departments)
coor = merge(res$scores, departments, by = "coded")
dev.new()
plot(coor$PC.1, coor$PC.2, type ="n")
text(coor$PC.1, coor$PC.2, coor$named, cex = 0.5)

# Each department is represented by its region
dev.new()
plot(coor$PC.1, coor$PC.2, type ="n")
text(coor$PC.1, coor$PC.2, coor$coder, cex = 0.7)

## End(Not run)
</code></pre>

<hr>
<h2 id='is.discdd.misclass'>
Class <code>discdd.misclass</code>
</h2><span id='topic+is.discdd.misclass'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>discdd.misclass</code> (see Details 
of the function <a href="#topic+discdd.misclass">discdd.misclass</a>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.discdd.misclass(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.discdd.misclass_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>discdd.misclass</code>, and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+discdd.misclass">discdd.misclass</a>.
</p>

<hr>
<h2 id='is.discdd.predict'>
Class <code>discdd.predict</code>
</h2><span id='topic+is.discdd.predict'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>discdd.predict</code> (see Details 
of the function <a href="#topic+discdd.predict">discdd.predict</a>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.discdd.predict(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.discdd.predict_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>discdd.predict</code>, and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+discdd.predict">discdd.predict</a>.
</p>

<hr>
<h2 id='is.dstatis'>
Class <code>dstatis</code>
</h2><span id='topic+is.dstatis'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>dstatis</code> (see Details 
of the function <a href="#topic+dstatis.inter">dstatis.inter</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dstatis(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dstatis_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>dstatis</code>, and <code>FALSE</code> otherwise. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+dstatis.inter">dstatis.inter</a>.
</p>

<hr>
<h2 id='is.fdiscd.misclass'>
Class <code>fdiscd.misclass</code>
</h2><span id='topic+is.fdiscd.misclass'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>fdiscd.misclass</code> (see Details 
of the function <a href="#topic+fdiscd.misclass">fdiscd.misclass</a>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fdiscd.misclass(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fdiscd.misclass_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>fdiscd.misclass</code>, and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+fdiscd.misclass">fdiscd.misclass</a>.
</p>

<hr>
<h2 id='is.fdiscd.predict'>
Class <code>fdiscd.predict</code>
</h2><span id='topic+is.fdiscd.predict'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>fdiscd.predict</code> (see Details 
of the function <a href="#topic+fdiscd.predict">fdiscd.predict</a>)..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fdiscd.predict(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fdiscd.predict_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>fdiscd.predict</code>, and <code>FALSE</code> otherwise. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+fdiscd.predict">fdiscd.predict</a>.
</p>

<hr>
<h2 id='is.fhclustd'>
Class <code>fhclustd</code>
</h2><span id='topic+is.fhclustd'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>fhclustd</code> (see Details 
of the function <a href="#topic+fhclustd">fhclustd</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fhclustd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fhclustd_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>fhclustd</code>, and <code>FALSE</code> otherwise. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+fhclustd">fhclustd</a>.
</p>

<hr>
<h2 id='is.fmdsd'>
Class <code>fmdsd</code>
</h2><span id='topic+is.fmdsd'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>fmdsd</code> (see Details 
of the function <a href="#topic+fmdsd">fmdsd</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fmdsd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fmdsd_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>fmdsd</code>, and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+fmdsd">fmdsd</a>.
</p>

<hr>
<h2 id='is.folder'>
Class <code>folder</code>
</h2><span id='topic+is.folder'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>folder</code> (see <code><a href="#topic+folder">folder</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.folder(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.folder_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>folder</code>, and <code>FALSE</code> otherwise. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code> to create an object of class <code>folder</code>.
</p>

<hr>
<h2 id='is.folderh'>
Class <code>folderh</code>
</h2><span id='topic+is.folderh'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>folderh</code> (see <code><a href="#topic+folderh">folderh</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.folderh(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.folderh_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>folderh</code>, and <code>FALSE</code> otherwise. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folderh">folderh</a></code> to create an object of class <code>folderh</code>.
</p>

<hr>
<h2 id='is.foldermtg'>
Class <code>foldermtg</code>
</h2><span id='topic+is.foldermtg'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>foldermtg</code> (see <code><a href="#topic+read.mtg">read.mtg</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.foldermtg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.foldermtg_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>foldermtg</code>, and <code>FALSE</code> otherwise. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code> to read a MTG file and create an object of class <code>foldermtg</code>.
</p>

<hr>
<h2 id='is.foldert'>
Class <code>foldert</code>
</h2><span id='topic+is.foldert'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>foldert</code> (see <code><a href="#topic+foldert">foldert</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.foldert(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.foldert_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>foldert</code>, and <code>FALSE</code> otherwise. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code> to create an object of class <code>foldert</code>.
</p>

<hr>
<h2 id='is.fpcad'>
Class <code>fpcad</code>
</h2><span id='topic+is.fpcad'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>fpcad</code> (see Details 
of the function <a href="#topic+fpcad">fpcad</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fpcad(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fpcad_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>fpcad</code>, and <code>FALSE</code> otherwise. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+fpcad">fpcad</a>.
</p>

<hr>
<h2 id='is.mdsdd'>
Class <code>mdsdd</code>
</h2><span id='topic+is.mdsdd'></span>

<h3>Description</h3>

<p>Tests if its argument is an object of class <code>mdsdd</code> (see Details 
of the function <a href="#topic+mdsdd">mdsdd</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mdsdd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mdsdd_+3A_x">x</code></td>
<td>

<p>object to be tested.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if its argument is of class <code>mdsdd</code>, and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+mdsdd">mdsdd</a>.
</p>

<hr>
<h2 id='jeffreys'>
Jeffreys measure between Gaussian densities
</h2><span id='topic+jeffreys'></span>

<h3>Description</h3>

<p>Jeffreys measure (or symmetrised Kullback-Leibler divergence) between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities given samples (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jeffreys(x1, x2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jeffreys_+3A_x1">x1</code></td>
<td>

<p>a matrix or data frame of <code class="reqn">n_1</code> rows (observations) and <code class="reqn">p</code> columns (variables) (can also be a tibble) or a vector of length <code class="reqn">n_1</code>.
</p>
</td></tr>
<tr><td><code id="jeffreys_+3A_x2">x2</code></td>
<td>

<p>matrix or data frame (or tibble) of <code class="reqn">n_2</code> rows and <code class="reqn">p</code> columns or vector of length <code class="reqn">n_2</code>.
</p>
</td></tr>
<tr><td><code id="jeffreys_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate (multivariate case) or if the variances are not zero (univariate case).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jeffreys measure between the two Gaussian densities is computed by using the <code><a href="#topic+jeffreyspar">jeffreyspar</a></code> function and the density parameters estimated from samples.
</p>


<h3>Value</h3>

<p>Returns the Jeffrey's measure between the two probability densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one smoothing bandwidth matrix is degenerate, the result returned must not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Thabane, L., Safiul Haq, M. (1999). On Bayesian selection of the best population using the Kullback-Leibler divergence measure. Statistica     Neerlandica, 53(3): 342-360.
</p>


<h3>See Also</h3>

<p><a href="#topic+jeffreyspar">jeffreyspar</a>: Jeffreys measure between Gaussian densities, given their parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
m1 &lt;- c(0,0)
v1 &lt;- matrix(c(1,0,0,1),ncol = 2) 
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(4,1,1,9),ncol = 2)
x1 &lt;- mvrnorm(n = 3,mu = m1,Sigma = v1)
x2 &lt;- mvrnorm(n = 5, mu = m2, Sigma = v2)
jeffreys(x1, x2)
</code></pre>

<hr>
<h2 id='jeffreyspar'>
Jeffreys measure between Gaussian densities given their parameters
</h2><span id='topic+jeffreyspar'></span>

<h3>Description</h3>

<p>Jeffreys measure (or symmetrised Kullback-Leibler divergence) between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given their parameters (mean vectors and covariance matrices if they are multivariate, means and variances if univariate) (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jeffreyspar(mean1, var1, mean2, var2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jeffreyspar_+3A_mean1">mean1</code></td>
<td>

<p><code class="reqn">p</code>-length numeric vector: the mean of the first Gaussian density.
</p>
</td></tr>
<tr><td><code id="jeffreyspar_+3A_var1">var1</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric numeric matrix (<code class="reqn">p</code> &gt; 1) or numeric (<code class="reqn">p</code> = 1): the covariance matrix (<code class="reqn">p</code> &gt; 1) or the variance (<code class="reqn">p</code> = 1) of the first Gaussian density.
</p>
</td></tr>
<tr><td><code id="jeffreyspar_+3A_mean2">mean2</code></td>
<td>

<p><code class="reqn">p</code>-length numeric vector: the mean of the second Gaussian density.
</p>
</td></tr>
<tr><td><code id="jeffreyspar_+3A_var2">var2</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric numeric matrix (<code class="reqn">p</code> &gt; 1) or numeric (<code class="reqn">p</code> = 1): the covariance matrix (<code class="reqn">p</code> &gt; 1) or the variance (<code class="reqn">p</code> = 1) of the second Gaussian density.
</p>
</td></tr>
<tr><td><code id="jeffreyspar_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate (multivariate case) or if the variances are not zero (univariate case).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">m1</code> and <code class="reqn">m2</code> the mean vectors, <code class="reqn">v1</code> and <code class="reqn">v2</code> the covariance matrices, Jeffreys measure of the two Gaussian densities is equal to:
</p>
<p style="text-align: center;"><code class="reqn">(1/2) t(m1 - m2) (v1^{-1} + v2^{-1}) (m1 - m2) - (1/2) tr( (v1 - v2) (v1^{-1} - v2^{-1}) )</code>
</p>
<p>.
</p>
<p>If <code class="reqn">p = 1</code> the means and variances are numbers, the formula is the same ignoring the following operators: t (transpose of a matrix or vector) and tr (trace of a square matrix).
</p>


<h3>Value</h3>

<p>Jeffreys measure between two Gaussian densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one covariance matrix is degenerated (multivariate case) or one variance is zero (univariate case), the result returned must not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>McLachlan, G.J. (1992). Discriminant analysis and statistical pattern recognition. John Wiley &amp; Sons, New York .
</p>
<p>Thabane, L., Safiul Haq, M. (1999). On Bayesian selection of the best population using the Kullback-Leibler divergence measure. Statistica     Neerlandica, 53(3): 342-360.
</p>


<h3>See Also</h3>

<p><a href="#topic+jeffreys">jeffreys</a>: Jeffreys measure of two parametrically estimated Gaussian densities, given samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- c(1,1)
v1 &lt;- matrix(c(4,1,1,9),ncol = 2)
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(1,0,0,1),ncol = 2)
jeffreyspar(m1,v1,m2,v2)
</code></pre>

<hr>
<h2 id='kurtosis.folder'>
Kurtosis coefficients of a folder of data sets
</h2><span id='topic+kurtosis.folder'></span>

<h3>Description</h3>

<p>Computes the kurtosis coefficient by column of the elements of an object of class <code>folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kurtosis.folder(x, na.rm = FALSE, type = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kurtosis.folder_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+folder">folder</a></code>.
</p>
</td></tr>
<tr><td><code id="kurtosis.folder_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. Should missing values be omitted from the calculations? (see <code><a href="e1071.html#topic+kurtosis">kurtosis</a></code>)
</p>
</td></tr>
<tr><td><code id="kurtosis.folder_+3A_type">type</code></td>
<td>

<p>an integer between 1 and 3 (see <code><a href="e1071.html#topic+kurtosis">kurtosis</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses <code><a href="e1071.html#topic+kurtosis">kurtosis</a></code> to compute the mean by numeric column of each element of the folder. If some columns of the data frames are not numeric, there is a warning, and the means are computed on the numeric columns only.
</p>


<h3>Value</h3>

<p>A list whose elements are the kurtosis coefficients by column of the elements of the folder.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code> to create an object is of class <code>folder</code>.
<code><a href="#topic+mean.folder">mean.folder</a></code>, <code><a href="#topic+var.folder">var.folder</a></code>, <code><a href="#topic+cor.folder">cor.folder</a></code>, <code><a href="#topic+skewness.folder">skewness.folder</a></code> for other statistics for <code>folder</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: iris (Fisher)               
data(iris)
iris.fold &lt;- as.folder(iris, "Species")
iris.kurtosis &lt;- kurtosis.folder(iris.fold)
print(iris.kurtosis)

# Second example: roses
data(roses)
roses.fold &lt;- as.folder(roses, "rose")
roses.kurtosis &lt;- kurtosis.folder(roses.fold)
print(roses.kurtosis)
</code></pre>

<hr>
<h2 id='l2d'>
<code class="reqn">L^2</code> inner product of probability densities
</h2><span id='topic+l2d'></span>

<h3>Description</h3>

<p><code class="reqn">L^2</code> inner product of two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) probability densities, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l2d(x1, x2, method = "gaussiand", check = FALSE, varw1 = NULL, varw2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l2d_+3A_x1">x1</code></td>
<td>

<p>a matrix or data frame of <code class="reqn">n_1</code> rows (observations) and <code class="reqn">p</code> columns (variables) (can also be a tibble) or a vector of length <code class="reqn">n_1</code>.
</p>
</td></tr>
<tr><td><code id="l2d_+3A_x2">x2</code></td>
<td>

<p>matrix or data frame (or tibble) of <code class="reqn">n_2</code> rows and <code class="reqn">p</code> columns or vector of length <code class="reqn">n_2</code>.
</p>
</td></tr>
<tr><td><code id="l2d_+3A_method">method</code></td>
<td>

<p>string.  It can be:
</p>

<ul>
<li> <p><code>"gaussiand"</code> if the densities are considered to be Gaussian.
</p>
</li>
<li> <p><code>"kern"</code> if they are estimated using the Gaussian kernel method.
</p>
</li></ul>

</td></tr>
<tr><td><code id="l2d_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices (if <code>method = "gaussiand"</code>) or smoothing bandwidth matrices (if <code>method = "kern"</code>) are not degenerate, before computing the inner product. 
</p>
<p>Notice that if <code class="reqn">p = 1</code>, it checks if the variances or smoothing parameters are not zero.
</p>
</td></tr>
<tr><td><code id="l2d_+3A_varw1">varw1</code>, <code id="l2d_+3A_varw2">varw2</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric matrices: the smoothing bandwidths for the estimation of the probability densities. If they are omitted, the smoothing bandwidths are computed using the normal reference rule matrix bandwidth (see details).
</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>method = "gaussiand"</code>, the mean vectors and the variance matrices (<code class="reqn">v1</code> and <code class="reqn">v2</code>) of the two samples are computed, and they are used to compute the inner product using the <code><a href="#topic+l2dpar">l2dpar</a></code> function.
</p>
</li>
<li><p> If <code>method = "kern"</code>, the densities of both samples are estimated using the Gaussian kernel method.
These estimations are then used to compute the inner product.
if <code>varw1</code> and <code>varw2</code> arguments are omitted, the smoothing bandwidths are computed using the normal reference rule matrix bandwidth:
</p>
<p style="text-align: center;"><code class="reqn">h_1 v_1^{1/2}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">h_1 = (4 / ( n_1 (p+2) ) )^{1 / (p+4)}</code>
</p>

<p>for the first density.  Idem for the second density after making the necessary changes.
</p>
</li></ul>



<h3>Value</h3>

<p>The <code class="reqn">L^2</code> inner product of the two probability densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one smoothing bandwidth matrix is degenerate, the result returned can not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>
<p>Wand, M., Jones, M. (1995). Kernel smoothing. Chapman and Hall/CRC, London.
</p>
<p>Yousfi, S., Boumaza R., Aissani, D., Adjabi, S. (2014). Optimal bandwith matrices in functional principal component analysis of density functions. Journal of Statistical Computational and Simulation, 85 (11), 2315-2330.
</p>


<h3>See Also</h3>

<p><a href="#topic+l2dpar">l2dpar</a> for Gaussian densities whose parameters are given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
m1 &lt;- c(0,0)
v1 &lt;- matrix(c(1,0,0,1),ncol = 2) 
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(4,1,1,9),ncol = 2)
x1 &lt;- mvrnorm(n = 3,mu = m1,Sigma = v1)
x2 &lt;- mvrnorm(n = 5, mu = m2, Sigma = v2)
l2d(x1, x2, method = "gaussiand")
l2d(x1, x2, method = "kern")
l2d(x1, x2, method = "kern", varw1 = v1, varw2 = v2)
</code></pre>

<hr>
<h2 id='l2dpar'>
<code class="reqn">L^2</code> inner product of Gaussian densities given their parameters
</h2><span id='topic+l2dpar'></span>

<h3>Description</h3>

<p><code class="reqn">L^2</code> inner product of multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l2dpar(mean1, var1, mean2, var2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l2dpar_+3A_mean1">mean1</code></td>
<td>

<p><code class="reqn">p</code>-length numeric vector: the mean of the first Gaussian density.
</p>
</td></tr>
<tr><td><code id="l2dpar_+3A_var1">var1</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric numeric matrix (<code class="reqn">p</code> &gt; 1) or numeric (<code class="reqn">p</code> = 1): the covariance matrix (<code class="reqn">p</code> &gt; 1) or the variance (<code class="reqn">p</code> = 1) of the first Gaussian density.
</p>
</td></tr>
<tr><td><code id="l2dpar_+3A_mean2">mean2</code></td>
<td>

<p><code class="reqn">p</code>-length numeric vector: the mean of the second Gaussian density.
</p>
</td></tr>
<tr><td><code id="l2dpar_+3A_var2">var2</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric numeric matrix (<code class="reqn">p</code> &gt; 1) or numeric (<code class="reqn">p</code> = 1): the covariance matrix (<code class="reqn">p</code> &gt; 1) or the variance (<code class="reqn">p</code> = 1) of the second Gaussian density.
</p>
</td></tr>
<tr><td><code id="l2dpar_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate (multivariate case) or if the variances are not zero (univariate case).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the inner product of two Gaussian densities, equal to: 
</p>
<p style="text-align: center;"><code class="reqn">(2\pi)^{-p/2} det(var1 + var2)^{-1/2} exp(-(1/2) t(mean1 - mean2) (var1 + var2)^{-1} (mean1 - mean2))</code>
</p>

<p>If <code class="reqn">p = 1</code> the means and variances are numbers, the formula is the same ignoring the following operators: t (transpose of a matrix or vector) and det (determinant of a square matrix).
</p>


<h3>Value</h3>

<p>The <code class="reqn">L^2</code> inner product between two Gaussian densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one covariance matrix is degenerated (multivariate case) or one variance is zero (univariate case), the result returned must not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>M. Wand and M. Jones (1995). Kernel Smoothing. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><a href="#topic+l2d">l2d</a> for parametrically estimated Gaussian densities or nonparametrically estimated densities, given samples;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- c(1,1)
v1 &lt;- matrix(c(4,1,1,9),ncol = 2)
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(1,0,0,1),ncol = 2)
l2dpar(m1,v1,m2,v2)
</code></pre>

<hr>
<h2 id='matddchisqsym'>
Matrix of distances between discrete probability densities given samples
</h2><span id='topic+matddchisqsym'></span>

<h3>Description</h3>

<p>Computes the matrix of the symmetric Chi-squared distances between several multivariate or univariate discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddchisqsym(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddchisqsym_+3A_x">x</code></td>
<td>

<p>object of class <code>"folder"</code> containing the data. Its elements are data frames (one data frame per distribution) whose columns are factors.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of data frames (or distributions), consisting of the pairwise symmetric chi-squared distances between the distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddchisqsym">ddchisqsym</a></code>.
</p>
<p><code><a href="#topic+matddchisqsympar">matddchisqsympar</a></code> for discrete probability densities, given the probabilities on the same support.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- data.frame(x = factor(c("A", "A", "B", "B")))
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")))
xf &lt;- folder(x1, x2, x3)
matddchisqsym(xf)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")),
                 y = factor(c("a", "b", "a", "b", "a", "b")))
xf &lt;- folder(x1, x2, x3)
matddchisqsym(xf)
</code></pre>

<hr>
<h2 id='matddchisqsympar'>
Matrix of distances between discrete probability densities given the probabilities on their common support
</h2><span id='topic+matddchisqsympar'></span>

<h3>Description</h3>

<p>Computes the matrix of the symmetric Chi-squared distances between several multivariate or univariate discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets), given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddchisqsympar(freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddchisqsympar_+3A_freq">freq</code></td>
<td>

<p>list of arrays. Their <code>dim</code> attribute is a vector with length <code class="reqn">q</code>, its elements containing the numbers of levels of the <code class="reqn">sets</code>. Each array contains the probabilities of the discrete distribution on the same support.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of distributions, consisting of the pairwise symmetric chi-squared distances between these distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddchisqsympar">ddchisqsympar</a></code>.
</p>
<p><code><a href="#topic+matddchisqsym">matddchisqsym</a></code> for discrete probability densities which are estimated from the data.
</p>

<hr>
<h2 id='matddhellinger'>
Matrix of distances between discrete probability densities given samples
</h2><span id='topic+matddhellinger'></span>

<h3>Description</h3>

<p>Computes the matrix of the Hellinger (or Matusita) distances between several multivariate or univariate discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddhellinger(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddhellinger_+3A_x">x</code></td>
<td>

<p>object of class <code>"folder"</code> containing the data. Its elements are data frames (one data frame per distribution) whose columns are factors.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of data frames (or distributions), consisting of the pairwise Hellinger distances between the distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddhellinger">ddhellinger</a></code>.
</p>
<p><code><a href="#topic+matddhellingerpar">matddhellingerpar</a></code> for discrete probability densities, given the probabilities on the same support.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- data.frame(x = factor(c("A", "A", "B", "B")))
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")))
xf &lt;- folder(x1, x2, x3)
matddhellinger(xf)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")),
                 y = factor(c("a", "b", "a", "b", "a", "b")))
xf &lt;- folder(x1, x2, x3)
matddhellinger(xf)
</code></pre>

<hr>
<h2 id='matddhellingerpar'>
Matrix of distances between discrete probability densities given the probabilities on their common support
</h2><span id='topic+matddhellingerpar'></span>

<h3>Description</h3>

<p>Computes the matrix of the Hellinger (or Matusita) distances between several multivariate or univariate discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets), given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddhellingerpar(freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddhellingerpar_+3A_freq">freq</code></td>
<td>

<p>list of arrays. Their <code>dim</code> attribute is a vector with length <code class="reqn">q</code>, its elements containing the numbers of levels of the <code class="reqn">sets</code>. Each array contains the probabilities of the discrete distribution on the same support.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of distributions, consisting of the pairwise Hellinger distances between these distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddhellingerpar">ddhellingerpar</a></code>.
</p>
<p><code><a href="#topic+matddhellinger">matddhellinger</a></code> for discrete probability densities which are estimated from the data.
</p>

<hr>
<h2 id='matddjeffreys'>
Matrix of distances between discrete probability densities given samples
</h2><span id='topic+matddjeffreys'></span>

<h3>Description</h3>

<p>Computes the matrix of Jeffreys divergences between several multivariate or univariate discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddjeffreys(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddjeffreys_+3A_x">x</code></td>
<td>

<p>object of class <code>"folder"</code> containing the data. Its elements are data frames (one data frame per distribution) whose columns are factors.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of data frames (or distributions), consisting of the pairwise Jeffreys divergences between the distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Dezaz E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddjeffreys">ddjeffreys</a></code>.
</p>
<p><code><a href="#topic+matddjeffreyspar">matddjeffreyspar</a></code> for discrete probability densities, given the probabilities on the same support.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- data.frame(x = factor(c("A", "A", "B", "B")))
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")))
xf &lt;- folder(x1, x2, x3)
matddhellinger(xf)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")),
                 y = factor(c("a", "b", "a", "b", "a", "b")))
xf &lt;- folder(x1, x2, x3)
matddhellinger(xf)
</code></pre>

<hr>
<h2 id='matddjeffreyspar'>
Matrix of divergences between discrete probability densities given the probabilities on their common support
</h2><span id='topic+matddjeffreyspar'></span>

<h3>Description</h3>

<p>Computes the matrix of Jeffreys divergences between several multivariate or univariate discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets), given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddjeffreyspar(freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddjeffreyspar_+3A_freq">freq</code></td>
<td>

<p>list of arrays. Their <code>dim</code> attribute is a vector with length <code class="reqn">q</code>, its elements containing the numbers of levels of the <code class="reqn">sets</code>. Each array contains the probabilities of the discrete distribution on the same support.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of distributions, consisting of the pairwise Jeffreys divergences between these distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddjeffreyspar">ddjeffreyspar</a></code>.
</p>
<p><code><a href="#topic+matddjeffreys">matddjeffreys</a></code> for discrete probability densities which are estimated from the data.
</p>

<hr>
<h2 id='matddjensen'>
Matrix of divergences between discrete probability densities given samples
</h2><span id='topic+matddjensen'></span>

<h3>Description</h3>

<p>Computes the matrix of the Jensen-Shannon divergences between several multivariate or univariate discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddjensen(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddjensen_+3A_x">x</code></td>
<td>

<p>object of class <code>"folder"</code> containing the data. Its elements are data frames (one data frame per distribution) whose columns are factors.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of data frames (or distributions), consisting of the pairwise Jensen-Shannon divergences between the distributions.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddjensen">ddjensen</a></code>.
</p>
<p><code><a href="#topic+matddjensenpar">matddjensenpar</a></code> for discrete probability densities, given the probabilities on the same support.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- data.frame(x = factor(c("A", "A", "B", "B")))
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")))
xf &lt;- folder(x1, x2, x3)
matddhellinger(xf)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")),
                 y = factor(c("a", "b", "a", "b", "a", "b")))
xf &lt;- folder(x1, x2, x3)
matddhellinger(xf)
</code></pre>

<hr>
<h2 id='matddjensenpar'>
Matrix of divergences between discrete probability densities given the probabilities on their common support
</h2><span id='topic+matddjensenpar'></span>

<h3>Description</h3>

<p>Computes the matrix of the Jensen-Shannon divergences between several multivariate or univariate discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets), given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddjensenpar(freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddjensenpar_+3A_freq">freq</code></td>
<td>

<p>list of arrays. Their <code>dim</code> attribute is a vector with length <code class="reqn">q</code>, its elements containing the numbers of levels of the <code class="reqn">sets</code>. Each array contains the probabilities of the discrete distribution on the same support.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise Jensen-Shannon divergences between the discrete probability densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddjensenpar">ddjensenpar</a></code>.
</p>
<p><code><a href="#topic+matddjensen">matddjensen</a></code> for discrete probability densities which are estimated from the data.
</p>

<hr>
<h2 id='matddlp'>
Matrix of distances between discrete probability distributions given samples
</h2><span id='topic+matddlp'></span>

<h3>Description</h3>

<p>Computes the matrix of the <code class="reqn">L^p</code> distances between several multivariate or univariate discrete probability distributions, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddlp(x, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddlp_+3A_x">x</code></td>
<td>

<p>object of class <code>"folder"</code> containing the data. Its elements are data frames (one data frame per distribution) whose columns are factors.
</p>
</td></tr>
<tr><td><code id="matddlp_+3A_p">p</code></td>
<td>

<p>integer. Parameter of the distance.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of data frames (or distributions), consisting of the pairwise <code class="reqn">L^p</code> distances between the distributions. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddlp">ddlp</a></code>.
</p>
<p><code><a href="#topic+matddlppar">matddlppar</a></code> for discrete probability distributions, given the probabilities on the same support.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
x1 &lt;- data.frame(x = factor(c("A", "A", "B", "B")))
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")))
xf &lt;- folder(x1, x2, x3)
matddlp(xf)
matddlp(xf, p = 2)

# Example 2
x1 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B", "B")),
                 y = factor(c("a", "a", "a", "b", "b", "b")))                 
x2 &lt;- data.frame(x = factor(c("A", "A", "A", "B", "B")),
                 y = factor(c("a", "a", "b", "a", "b")))
x3 &lt;- data.frame(x = factor(c("A", "A", "B", "B", "B", "B")),
                 y = factor(c("a", "b", "a", "b", "a", "b")))
xf &lt;- folder(x1, x2, x3)
matddlp(xf, p = 1)
</code></pre>

<hr>
<h2 id='matddlppar'>
Matrix of distances between discrete probability densities given the probabilities on their common support
</h2><span id='topic+matddlppar'></span>

<h3>Description</h3>

<p>Computes the matrix of the <code class="reqn">L^p</code> distances between several multivariate or univariate discrete probability distributions on the same support (which can be a Cartesian product of <code class="reqn">q</code> sets), given the probabilities of the states (which are <code class="reqn">q</code>-tuples) of the support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matddlppar(freq, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matddlppar_+3A_freq">freq</code></td>
<td>

<p>list of arrays. Their <code>dim</code> attribute is a vector with length <code class="reqn">q</code>, its elements containing the numbers of levels of the <code class="reqn">sets</code>. Each array contains the probabilities of the discrete distribution on the same support.
</p>
</td></tr>
<tr><td><code id="matddlppar_+3A_p">p</code></td>
<td>

<p>integer. Parameter of the distance.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of distributions, consisting of the pairwise <code class="reqn">L^p</code> distances between these distributions. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Deza, M.M. and Deza E. (2013). Encyclopedia of distances. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddlppar">ddlppar</a></code>.
</p>
<p><code><a href="#topic+matddlp">matddlp</a></code> for discrete probability distributions which are estimated from samples.
</p>

<hr>
<h2 id='matdistl2d'>
Matrix of <code class="reqn">L^2</code> distances between probability densities
</h2><span id='topic+matdistl2d'></span>

<h3>Description</h3>

<p>Computes the matrix of the <code class="reqn">L^2</code> distances between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) probability densities, estimated from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matdistl2d(x, method = "gaussiand", varwL = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matdistl2d_+3A_x">x</code></td>
<td>

<p>object of class &quot;folder&quot; containing the data. Its elements have only numeric variables (observations of the probability densities).
If there are non numeric variables, there is an error.
</p>
</td></tr>
<tr><td><code id="matdistl2d_+3A_method">method</code></td>
<td>

<p>string.  It can be:
</p>

<ul>
<li> <p><code>"gaussiand"</code> if the densities are considered to be Gaussian.
</p>
</li>
<li> <p><code>"kern"</code> if they are estimated using the Gaussian kernel method.
</p>
</li></ul>

</td></tr>
<tr><td><code id="matdistl2d_+3A_varwl">varwL</code></td>
<td>

<p>list of matrices. The smoothing bandwidths for the estimation of each probability density. If they are omitted, the smoothing bandwidths are computed using the normal reference rule matrix bandwidth (see details of the <code><a href="#topic+l2d">l2d</a></code> function).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise distances between the probability densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distl2d">distl2d</a></code>.
</p>
<p><code><a href="#topic+matdistl2dpar">matdistl2dpar</a></code> when the probability densities are Gaussian, given the parameters (means and variances).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")], groups = "rose")
    summary(X)
    mean.X &lt;- mean(X)
    var.X &lt;- var.folder(X)
    
    # Parametrically estimated Gaussian densities:
    matdistl2d(X)
    
    ## Not run: 
    # Estimated densities using the Gaussian kernel method ()normal reference rule bandwidth):
    matdistl2d(X, method = "kern")   

    # Estimated densities using the Gaussian kernel method (bandwidth provided):
    matdistl2d(X, method = "kern", varwL = var.X)
    
## End(Not run)

    # Univariate :
    X1 &lt;- as.folder(roses[,c("Sha","rose")], groups = "rose")
    summary(X1)
    mean.X1 &lt;- mean(X1)
    var.X1 &lt;- var.folder(X1)
    
    # Parametrically estimated Gaussian densities:
    matdistl2d(X1)
    
    # Estimated densities using the Gaussian kernel method (normal reference rule bandwidth):
    matdistl2d(X1, method = "kern")
    
    # Estimated densities using the Gaussian kernel method (normal reference rule bandwidth):
    matdistl2d(X1, method = "kern", varwL = var.X1)
</code></pre>

<hr>
<h2 id='matdistl2dnorm'>
Matrix of <code class="reqn">L^2</code> distances between <code class="reqn">L^2</code>-normed probability densities
</h2><span id='topic+matdistl2dnorm'></span>

<h3>Description</h3>

<p>Computes the matrix of the <code class="reqn">L^2</code> distances between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) <code class="reqn">L^2</code>-normed probability densities, estimated from samples, where a <code class="reqn">L^2</code>-normed probability density is the original probability density function divided by its <code class="reqn">L^2</code>-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matdistl2dnorm(x, method = "gaussiand", varwL = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matdistl2dnorm_+3A_x">x</code></td>
<td>

<p>object of class &quot;folder&quot; containing the data. Its elements have only numeric variables (observations of the probability densities).
If there are non numeric variables, there is an error.
</p>
</td></tr>
<tr><td><code id="matdistl2dnorm_+3A_method">method</code></td>
<td>

<p>string.  It can be:
</p>

<ul>
<li> <p><code>"gaussiand"</code> if the densities are considered to be Gaussian.
</p>
</li>
<li> <p><code>"kern"</code> if they are estimated using the Gaussian kernel method.
</p>
</li></ul>

</td></tr>
<tr><td><code id="matdistl2dnorm_+3A_varwl">varwL</code></td>
<td>

<p>list of matrices. The smoothing bandwidths for the estimation of each probability density. If they are omitted, the smoothing bandwidths are computed using the normal reference rule matrix bandwidth (see details of the <code><a href="#topic+l2d">l2d</a></code> function).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise distances between the <code class="reqn">L^2</code>-normed probability densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distl2dnorm">distl2dnorm</a></code>.
</p>
<p><code><a href="#topic+matdistl2d">matdistl2d</a></code> for the distance matrix between probability densities.
</p>
<p><code><a href="#topic+matdistl2dnormpar">matdistl2dnormpar</a></code> when the probability densities are Gaussian, given the parameters (means and variances).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")], groups = "rose")
    summary(X)
    mean.X &lt;- mean(X)
    var.X &lt;- var.folder(X)
    
    # Parametrically estimated Gaussian densities:
    matdistl2dnorm(X)
    
    ## Not run: 
    # Estimated densities using the Gaussian kernel method ()normal reference rule bandwidth):
    matdistl2dnorm(X, method = "kern")   

    # Estimated densities using the Gaussian kernel method (bandwidth provided):
    matdistl2dnorm(X, method = "kern", varwL = var.X)
    
## End(Not run)

    # Univariate :
    X1 &lt;- as.folder(roses[,c("Sha","rose")], groups = "rose")
    summary(X1)
    mean.X1 &lt;- mean(X1)
    var.X1 &lt;- var.folder(X1)
    
    # Parametrically estimated Gaussian densities:
    matdistl2dnorm(X1)
    
    # Estimated densities using the Gaussian kernel method (normal reference rule bandwidth):
    matdistl2dnorm(X1, method = "kern")
    
    # Estimated densities using the Gaussian kernel method (normal reference rule bandwidth):
    matdistl2dnorm(X1, method = "kern", varwL = var.X1)
</code></pre>

<hr>
<h2 id='matdistl2dnormpar'>
Matrix of <code class="reqn">L^2</code> distances between <code class="reqn">L^2</code>-normed Gaussian densities given their parameters
</h2><span id='topic+matdistl2dnormpar'></span>

<h3>Description</h3>

<p>Computes the matrix of the <code class="reqn">L^2</code> distances between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) <code class="reqn">L^2</code>-normed Gaussian densities, given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate), where a <code class="reqn">L^2</code>-normed Gaussian density is the original probability density function divided by its <code class="reqn">L^2</code>-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matdistl2dnormpar(meanL, varL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matdistl2dnormpar_+3A_meanl">meanL</code></td>
<td>

<p>list of the means (<code class="reqn">p = 1</code>) or vector means (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
<tr><td><code id="matdistl2dnormpar_+3A_varl">varL</code></td>
<td>

<p>list of the variances (<code class="reqn">p = 1</code>) or covariance matrices (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise distances between the <code class="reqn">L^2</code>-normed probability densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distl2dnormpar">distl2dnormpar</a></code>.
</p>
<p><code><a href="#topic+matdistl2dpar">matdistl2dpar</a></code> for the distance matrix between Gaussian densities, given their parameters.
</p>
<p><code><a href="#topic+matdistl2dnorm">matdistl2dnorm</a></code> for the distance matrix between normed probability densities which are estimated from the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- roses[,c("Sha","Den","Sym","rose")]
    summary(X)
    mean.X &lt;- as.list(by(X[, 1:3], X$rose, colMeans))
    var.X &lt;- as.list(by(X[, 1:3], X$rose, var))
    
    # Gaussian densities, given parameters
    matdistl2dnormpar(mean.X, var.X)

    # Univariate :
    X1 &lt;- roses[,c("Sha","rose")]
    summary(X1)
    mean.X1 &lt;- by(X1$Sha, X1$rose, mean)
    var.X1 &lt;- by(X1$Sha, X1$rose, var)
    
    # Gaussian densities, given parameters
    matdistl2dnormpar(mean.X1, var.X1)
</code></pre>

<hr>
<h2 id='matdistl2dpar'>
Matrix of <code class="reqn">L^2</code> distances between Gaussian densities given their parameters
</h2><span id='topic+matdistl2dpar'></span>

<h3>Description</h3>

<p>Computes the matrix of the <code class="reqn">L^2</code> distances between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matdistl2dpar(meanL, varL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matdistl2dpar_+3A_meanl">meanL</code></td>
<td>

<p>list of the means (<code class="reqn">p = 1</code>) or vector means (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
<tr><td><code id="matdistl2dpar_+3A_varl">varL</code></td>
<td>

<p>list of the variances (<code class="reqn">p = 1</code>) or covariance matrices (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise distances between the probability densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distl2dpar">distl2dpar</a></code>.
</p>
<p><code><a href="#topic+matdistl2d">matdistl2d</a></code> for the distance matrix between probability densities which are estimated from the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- roses[,c("Sha","Den","Sym","rose")]
    summary(X)
    mean.X &lt;- as.list(by(X[, 1:3], X$rose, colMeans))
    var.X &lt;- as.list(by(X[, 1:3], X$rose, var))
    
    # Gaussian densities, given parameters
    matdistl2dpar(mean.X, var.X)

    # Univariate :
    X1 &lt;- roses[,c("Sha","rose")]
    summary(X1)
    mean.X1 &lt;- by(X1$Sha, X1$rose, mean)
    var.X1 &lt;- by(X1$Sha, X1$rose, var)
    
    # Gaussian densities, given parameters
    matdistl2dpar(mean.X1, var.X1)
</code></pre>

<hr>
<h2 id='mathellinger'>
Matrix of Hellinger distances between Gaussian densities
</h2><span id='topic+mathellinger'></span>

<h3>Description</h3>

<p>Computes the matrix of the Hellinger distances between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities  given samples and using <code><a href="#topic+hellinger">hellinger</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mathellinger(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mathellinger_+3A_x">x</code></td>
<td>

<p>object of class &quot;folder&quot; containing the data. Its elements have only numeric variables (observations of the probability densities).
If there are non numeric variables, there is an error.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise Hellinger distances between the probability densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hellinger">hellinger</a></code>.
</p>
<p><code><a href="#topic+mathellingerpar">mathellingerpar</a></code> when the probability densities are Gaussian, given the parameters (means and variances).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")], groups = "rose")
    summary(X)
    mathellinger(X)
    
    # Univariate :
    X1 &lt;- as.folder(roses[,c("Sha","rose")], groups = "rose")
    summary(X1)
    mathellinger(X1)
</code></pre>

<hr>
<h2 id='mathellingerpar'>
Matrix of Hellinger distances between Gaussian densities given their parameters
</h2><span id='topic+mathellingerpar'></span>

<h3>Description</h3>

<p>Computes the matrix of the Hellinger distances between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given their means and variances, using <code><a href="#topic+hellingerpar">hellingerpar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mathellingerpar(meanL, varL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mathellingerpar_+3A_meanl">meanL</code></td>
<td>

<p>list of the means (<code class="reqn">p = 1</code>) or vector means (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
<tr><td><code id="mathellingerpar_+3A_varl">varL</code></td>
<td>

<p>list of the variances (<code class="reqn">p = 1</code>) or covariance matrices (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise distances between the Gaussian densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hellingerpar">hellingerpar</a></code>.
</p>
<p><code><a href="#topic+mathellinger">mathellinger</a></code> for the distance matrix between probability densities which are estimated from the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- roses[,c("Sha","Den","Sym","rose")]
    summary(X)
    mean.X &lt;- as.list(by(X[, 1:3], X$rose, colMeans))
    var.X &lt;- as.list(by(X[, 1:3], X$rose, var))
    mathellingerpar(mean.X, var.X)

    # Univariate :
    X1 &lt;- roses[,c("Sha","rose")]
    summary(X1)
    mean.X1 &lt;- by(X1$Sha, X1$rose, mean)
    var.X1 &lt;- by(X1$Sha, X1$rose, var)
    mathellingerpar(mean.X1, var.X1)
</code></pre>

<hr>
<h2 id='matipl2d'>
Matrix of <code class="reqn">L^2</code> inner products of probability densities
</h2><span id='topic+matipl2d'></span>

<h3>Description</h3>

<p>Computes the matrix of the <code class="reqn">L^2</code> inner products between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) probability densities, estimated from samples, using <code><a href="#topic+l2d">l2d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matipl2d(x, method = "gaussiand", varwL = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matipl2d_+3A_x">x</code></td>
<td>

<p>object of class &quot;folder&quot; containing the data. Its elements have only numeric variables (observations of the probability densities).
If there are non numeric variables, there is an error.
</p>
</td></tr>
<tr><td><code id="matipl2d_+3A_method">method</code></td>
<td>

<p>string.  It can be:
</p>

<ul>
<li> <p><code>"gaussiand"</code> if the densities are considered to be Gaussian.
</p>
</li>
<li> <p><code>"kern"</code> if they are estimated using the Gaussian kernel method.
</p>
</li></ul>

</td></tr>
<tr><td><code id="matipl2d_+3A_varwl">varwL</code></td>
<td>

<p>list of matrices. The smoothing bandwidths for the estimation of each probability density. If they are omitted, the smoothing bandwidths are computed using the normal reference rule matrix bandwidth (see details of the <code><a href="#topic+l2d">l2d</a></code> function).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise inner products between the probability densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+l2d">l2d</a></code>.
</p>
<p><code><a href="#topic+matipl2dpar">matipl2dpar</a></code> when the probability densities are Gaussian, given the parameters (means and variances).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")], groups = "rose")
    summary(X)
    mean.X &lt;- mean(X)
    var.X &lt;- var.folder(X)
    
    # Parametrically estimated Gaussian densities:
    matipl2d(X)
    
    # Estimated densities using the Gaussian kernel method (normal reference rule bandwidth):
    matipl2d(X, method  = "kern")
    
    # Estimated densities using the Gaussian kernel method (bandwidth provided):
    matipl2d(X, method  = "kern", varwL = var.X)
    
    # Univariate :
    X1 &lt;- as.folder(roses[,c("Sha","rose")], groups = "rose")
    summary(X1)
    mean.X1 &lt;- mean(X1)
    var.X1 &lt;- var.folder(X1)
    
    # Parametrically estimated Gaussian densities:
    matipl2d(X1)
    
    # Estimated densities using the Gaussian kernel method (normal reference rule bandwidth):
    matipl2d(X1, method = "kern")
    
    # Estimated densities using the Gaussian kernel method (bandwidth provided):
    matipl2d(X1, method = "kern", varwL = var.X1)
</code></pre>

<hr>
<h2 id='matipl2dpar'>
Matrix of <code class="reqn">L^2</code> inner products of Gaussian densities
</h2><span id='topic+matipl2dpar'></span>

<h3>Description</h3>

<p>Computes the matrix of the <code class="reqn">L^2</code> inner products between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matipl2dpar(meanL, varL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matipl2dpar_+3A_meanl">meanL</code></td>
<td>

<p>list of the means (<code class="reqn">p = 1</code>) or vector means (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
<tr><td><code id="matipl2dpar_+3A_varl">varL</code></td>
<td>

<p>list of the variances (<code class="reqn">p = 1</code>) or covariance matrices (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise inner products between the Gaussian densities.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+l2dpar">l2dpar</a></code>.
</p>
<p><code><a href="#topic+matipl2d">matipl2d</a></code> for the distance matrix between probability densities which are estimated from the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- roses[,c("Sha","Den","Sym","rose")]
    summary(X)
    mean.X &lt;- as.list(by(X[, 1:3], X$rose, colMeans))
    var.X &lt;- as.list(by(X[, 1:3], X$rose, var))
    
    # Gaussian densities, given parameters
    matipl2dpar(mean.X, var.X)

    # Univariate :
    X1 &lt;- roses[,c("Sha","rose")]
    summary(X1)
    mean.X1 &lt;- by(X1$Sha, X1$rose, mean)
    var.X1 &lt;- by(X1$Sha, X1$rose, var)
    
    # Gaussian densities, given parameters
    matipl2dpar(mean.X1, var.X1)
</code></pre>

<hr>
<h2 id='matjeffreys'>
Matrix of the Jeffreys measures (symmetrised Kullback-Leibler divergences) between Gaussian densities
</h2><span id='topic+matjeffreys'></span>

<h3>Description</h3>

<p>Computes the matrix of Jeffreys measures between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matjeffreys(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matjeffreys_+3A_x">x</code></td>
<td>

<p>object of class &quot;folder&quot; containing the data. Its elements have only numeric variables (observations of the probability densities).
If there are non numeric variables, there is an error.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of pairwise Jeffreys measures between the Gaussian densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matjeffreyspar">matjeffreyspar</a></code> if the parameters of the Gaussian densities are known.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")], groups = "rose")
    summary(X)
    matjeffreys(X)
    
    # Univariate :
    X1 &lt;- as.folder(roses[,c("Sha","rose")], groups = "rose")
    summary(X1)
    matjeffreys(X1)
</code></pre>

<hr>
<h2 id='matjeffreyspar'>
Matrix of Jeffreys measures (symmetrised Kullback-Leibler divergences) between Gaussian densities
</h2><span id='topic+matjeffreyspar'></span>

<h3>Description</h3>

<p>Computes the matrix of Jeffreys measures between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate), using <code><a href="#topic+jeffreyspar">jeffreyspar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matjeffreyspar(meanL, varL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matjeffreyspar_+3A_meanl">meanL</code></td>
<td>

<p>list of the means (<code class="reqn">p = 1</code>) or vector means (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
<tr><td><code id="matjeffreyspar_+3A_varl">varL</code></td>
<td>

<p>list of the variances (<code class="reqn">p = 1</code>) or covariance matrices (<code class="reqn">p &gt; 1</code>) of the probability densities.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of pairwise Jeffreys measures between the Gaussian densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jeffreyspar">jeffreyspar</a></code>.
</p>
<p><code><a href="#topic+matjeffreys">matjeffreys</a></code> for the matrix of Jeffreys divergences between probability densities which are estimated from the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- roses[,c("Sha","Den","Sym","rose")]
    summary(X)
    mean.X &lt;- as.list(by(X[, 1:3], X$rose, colMeans))
    var.X &lt;- as.list(by(X[, 1:3], X$rose, var))
    matjeffreyspar(mean.X, var.X)

    # Univariate :
    X1 &lt;- roses[,c("Sha","rose")]
    summary(X1)
    mean.X1 &lt;- by(X1$Sha, X1$rose, mean)
    var.X1 &lt;- by(X1$Sha, X1$rose, var)
    matjeffreyspar(mean.X1, var.X1)
</code></pre>

<hr>
<h2 id='matwasserstein'>
Matrix of 2-Wassterstein distance between Gaussian densities
</h2><span id='topic+matwasserstein'></span>

<h3>Description</h3>

<p>Computes the matrix of the 2-Wassterstein distances between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matwasserstein(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matwasserstein_+3A_x">x</code></td>
<td>

<p>object of class &quot;folder&quot; containing the data. Its elements have only numeric variables (observations of the probability densities).
If there are non numeric variables, there is an error.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise 2-Wassterstein distance between the Gaussian densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matwassersteinpar">matwassersteinpar</a></code> if the parameters of the Gaussian densities are known.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")], groups = "rose")
    summary(X)
    matwasserstein(X)
    
    # Univariate :
    X1 &lt;- as.folder(roses[,c("Sha","rose")], groups = "rose")
    summary(X1)
    matwasserstein(X1)
</code></pre>

<hr>
<h2 id='matwassersteinpar'>
Matrix of 2-Wasserstein distances between Gaussian densities
</h2><span id='topic+matwassersteinpar'></span>

<h3>Description</h3>

<p>Computes the matrix of the 2-Wasserstein distances between several multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities, given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate), using <code><a href="#topic+wassersteinpar">wassersteinpar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matwassersteinpar(meanL, varL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matwassersteinpar_+3A_meanl">meanL</code></td>
<td>

<p>list of the means (<code class="reqn">p = 1</code>) or vector means (<code class="reqn">p &gt; 1</code>) of the Gaussian densities.
</p>
</td></tr>
<tr><td><code id="matwassersteinpar_+3A_varl">varL</code></td>
<td>

<p>list of the variances (<code class="reqn">p = 1</code>) or covariance matrices (<code class="reqn">p &gt; 1</code>) of the probability densities.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positive symmetric matrix whose order is equal to the number of densities, consisting of the pairwise 2-Wasserstein distances between the Gaussian densities. 
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wasserstein">wasserstein</a></code>.
</p>
<p><code><a href="#topic+matwasserstein">matwasserstein</a></code> for the matrix of 2-Wasserstein distances between probability densities which are estimated from the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(roses)
    
    # Multivariate:
    X &lt;- roses[,c("Sha","Den","Sym","rose")]
    summary(X)
    mean.X &lt;- as.list(by(X[, 1:3], X$rose, colMeans))
    var.X &lt;- as.list(by(X[, 1:3], X$rose, var))
    matwassersteinpar(mean.X, var.X)

    # Univariate :
    X1 &lt;- roses[,c("Sha","rose")]
    summary(X1)
    mean.X1 &lt;- by(X1$Sha, X1$rose, mean)
    var.X1 &lt;- by(X1$Sha, X1$rose, var)
    matwassersteinpar(mean.X1, var.X1)
</code></pre>

<hr>
<h2 id='mdsdd'>
Multidimensional scaling of discrete probability distributions
</h2><span id='topic+mdsdd'></span>

<h3>Description</h3>

<p>Applies the multidimensional scaling (MDS) method to discrete probability distributions in order to describe <code class="reqn">T</code> groups of individuals on which are observed <code class="reqn">q</code> categorical variables. It returns an object of class 
<code>mdsdd</code>. It applies <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> to the distance matrix between the <code class="reqn">T</code> distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdsdd(xf, group.name = "group", distance = c("l1", "l2", "chisqsym", "hellinger",
    "jeffreys", "jensen", "lp"), nb.factors = 3, nb.values = 10, association = c("cramer",
    "tschuprow", "pearson", "phi"), sub.title = "", plot.eigen = TRUE,
    plot.score = FALSE, nscore = 1:3, filename = NULL, add = TRUE, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdsdd_+3A_xf">xf</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code>, list of arrays (or tables) or data frame.
</p>

<ul>
<li><p> If it is a folder, its elements are data frames with <code class="reqn">q</code> columns (considered as factors).
The <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) matches with the <code class="reqn">t^{th}</code> group.
</p>
</li>
<li><p> If it is a data frame, the columns with name given by the <code>group.name</code> argument is a factor giving the groups.
The other columns are all considered as factors.
</p>
</li>
<li><p> If it is a list of arrays (or tables), the <code class="reqn">t^{th}</code> element (<code class="reqn">t = 1, \ldots, T</code>) is the table of the joint frequency distribution of <code class="reqn">q</code> variables within the <code class="reqn">t^{th}</code> group. The frequency distribution is expressed with relative or absolute frequencies.
These arrays have the same shape.
</p>
<p>Each array (or table) <code>xf[[i]]</code> has:
</p>

<ul>
<li><p> the same dimension(s). If <code class="reqn">q = 1</code> (univariate), <code>dim(xf[[i]])</code> is an integer. If <code class="reqn">q &gt; 1</code> (multivariate), <code>dim(xf[[i]])</code> is an integer vector of length <code>q</code>.
</p>
</li>
<li><p> the same dimension names <code>dimnames(xf[[i]])</code> (is non <code>NULL</code>). These dimnames are the names of the variables.
</p>
</li></ul>

<p>The elements of the arrays are non-negative numbers (if they are not, there is an error).
</p>
</li></ul>

</td></tr>
<tr><td><code id="mdsdd_+3A_group.name">group.name</code></td>
<td>

<p>string. Name of the grouping variable. Default: <code>groupname  = "group"</code>.
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_distance">distance</code></td>
<td>

<p>The distance or divergence used to compute the distance matrix between the discrete distributions (see Details).
It can be:
</p>

<ul>
<li> <p><code>"l1"</code> (default) the <code class="reqn">L^p</code> distance with <code class="reqn">p = 1</code>
</p>
</li>
<li> <p><code>"l2"</code> the <code class="reqn">L^p</code> distance with <code class="reqn">p = 2</code>
</p>
</li>
<li> <p><code>"chisqsym"</code> the symmetric Chi-squared distance
</p>
</li>
<li> <p><code>"hellinger"</code> the Hellinger metric (Matusita distance)
</p>
</li>
<li> <p><code>"jeffreys"</code> Jeffreys distance (symmetrised Kullback-Leibler divergence)
</p>
</li>
<li> <p><code>"jensen"</code> the Jensen-Shannon distance
</p>
</li>
<li> <p><code>"lp"</code> the <code class="reqn">L^p</code> distance with <code class="reqn">p</code> given by the argument <code>p</code> of the function.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="mdsdd_+3A_nb.factors">nb.factors</code></td>
<td>

<p>numeric. Number of returned principal coordinates (default <code>nb.factors = 3</code>). This number must be less than <code class="reqn">T - 1</code>.
</p>
<p>Warning: The <code><a href="#topic+plot.mdsdd">plot.mdsdd</a></code> and <code><a href="#topic+interpret.mdsdd">interpret.mdsdd</a></code> functions cannot take into account more than <code>nb.factors</code>  principal factors.
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_nb.values">nb.values</code></td>
<td>

<p>numeric. Number of returned eigenvalues (default <code>nb.values = 10</code>).
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_association">association</code></td>
<td>

<p>The association measure between two discrete distributions to be used (see Details).
It can be:
</p>

<ul>
<li> <p><code>"cramer"</code> (default) Cramer's V (see <code><a href="#topic+cramer.folder">cramer.folder</a></code>).
</p>
</li>
<li> <p><code>"tschuprow"</code> Tschuprow's T (<code><a href="#topic+tschuprow.folder">tschuprow.folder</a></code>).
</p>
</li>
<li> <p><code>"pearson"</code> Pearson's contingency coefficient (<code><a href="#topic+pearson.folder">pearson.folder</a></code>).
</p>
</li>
<li> <p><code>"phi"</code> phi (<code><a href="#topic+phi.folder">phi.folder</a></code>).
</p>
</li></ul>

</td></tr>
<tr><td><code id="mdsdd_+3A_sub.title">sub.title</code></td>
<td>

<p>string. Subtitle for the graphs (default <code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_plot.eigen">plot.eigen</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the barplot of the eigenvalues is plotted.
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_plot.score">plot.score</code></td>
<td>

<p>logical.  If <code>TRUE</code>, the graphs of new coordinates are plotted. A new graphic device is opened for each pair of coordinates defined by <code>nscore</code> argument.
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_nscore">nscore</code></td>
<td>

<p>numeric vector. If <code>plot.score = TRUE</code>, the numbers of the principal coordinates which are plotted. By default, <code>nscore = 1:3</code>. Its components cannot be greater than <code>nb.factors</code>. 
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_filename">filename</code></td>
<td>

<p>string. Name of the file in which the results are saved. By default (<code>filename  = NULL</code>) they are not saved.
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_add">add</code></td>
<td>

<p>logical indicating if an additive constant should be computed and added to the non diagonal dissimilarities such that the modified dissimilarities are Euclidean (default <code>TRUE</code>; see <code>add</code> argument of <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>).
</p>
</td></tr>
<tr><td><code id="mdsdd_+3A_p">p</code></td>
<td>

<p>integer. Optional. When <code>distance = "lp"</code> (<code class="reqn">L^p</code> distance with <code class="reqn">p&gt;2</code>), <code>p</code> is the parameter of the distance.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a folder is given as argument, the <code class="reqn">T</code> discrete probability distributions <code class="reqn">f_t</code> corresponding to the <code class="reqn">T</code> groups of individuals are estimated from observations.
Then the distances/dissimilarities between the estimated distributions are computed, using the distance or divergence defined by the <code>distance</code> argument:
</p>
<p>If the distance is <code>"l1"</code>, <code>"l2"</code> or <code>"lp"</code>, the distances are computed by the function <code><a href="#topic+matddlppar">matddlppar</a></code>.
Otherwise, it can be computed by <code><a href="#topic+matddchisqsympar">matddchisqsympar</a></code> (<code>"chisqsym"</code>), <code><a href="#topic+matddhellingerpar">matddhellingerpar</a></code> (<code>"hellinger"</code>), <code><a href="#topic+matddjeffreyspar">matddjeffreyspar</a></code> (<code>"jeffreys"</code>) or <code><a href="#topic+matddjensenpar">matddjensenpar</a></code> (<code>"jensen"</code>).
</p>
<p>The association measures are computed accordingly to the value of the parameter <code>association</code>The computation uses the corresponding function of the package <code>DescTools</code> (see <code><a href="DescTools.html#topic+Assocs">Assocs</a></code>). Notice that an association measure between a constant variable with and other variable is set to zero. The association measure between each variable with itself is not computed and the diagonal of the returned association matrices is set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>mdsdd</code>, that is a list including:
</p>
<table>
<tr><td><code>inertia</code></td>
<td>
<p>data frame of the eigenvalues and the percentages of their sum.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>data frame of the coordinates along the <code>nb.factors</code> first principal coordinates.</p>
</td></tr>
<tr><td><code>jointp</code></td>
<td>
<p>list of arrays. The joint probability distribution for each group.</p>
</td></tr>
<tr><td><code>margins</code></td>
<td>
<p>list of two data frames giving respectively:
</p>

<ul>
<li><p>The probability distribution of each variable for each group. Each column of the data frame corresponds to one level of one categorical variable and contains the probabilities of this level in each group.
</p>
</li>
<li><p>The joint probability distribution of each pair of variables for each group. Each column of the data frame corresponds to one pair of levels of two categorical variables (one level per variable) and contains the probabilities of this pair of levels in each group.
</p>
</li></ul>

</td></tr>
<tr><td><code>associations</code></td>
<td>
<p>list of <code class="reqn">T</code> matrices. Each matrix corresponds to a group and gives the pairwise association measures between the <code class="reqn">q</code> categorical variables.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza, Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Cox, T.F., Cox, M.A.A. (2001). Multidimensional Scaling, second ed. Chapman &amp; Hall/CRC.
</p>
<p>Saporta, G. (2006). Probabilit\'es, Analyse des donn\'ees et Statistique. Editions Technip, Paris.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.mdsdd">print.mdsdd</a>, <a href="#topic+plot.mdsdd">plot.mdsdd</a>, <a href="#topic+interpret.mdsdd">interpret.mdsdd</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 with a folder (10 groups) of 3 factors 
# obtained by converting numeric variables
data(roses)
xr = roses[,c("Sha", "Den", "Sym", "rose")]
xf = as.folder(xr, groups = "rose")
xf = cut(xf, breaks = list(c(0, 5, 7, 10), c(0, 4, 6, 10), c(0, 6, 8, 10)), cutcol = 1:3)
af = mdsdd(xf)
print(af)
print(af$jointp)
print(af$margins[[1]]) # equivalent to print(af$margins$margin1) 
print(af$margins[[2]])
print(af$associations)

# Example 2 with a data frame obtained by converting numeric variables
data(roses)
xr = roses[,c("Sha", "Den", "Sym", "rose")]
xr = cut(xr, breaks = list(c(0, 5, 7, 10), c(0, 4, 6, 10), c(0, 6, 8, 10)), cutcol = 1:3)
ar = mdsdd(xr, group.name = "rose")
print(ar)
print(ar$jointp)
print(ar$margins[[1]]) # equivalent to print(ar$margins$margin1) 
print(ar$margins[[2]])
print(ar$associations)

# Example 3 with a list of 7 arrays
data(dspg)
xl = dspg
mdsdd(xl)
</code></pre>

<hr>
<h2 id='mean.folder'>
Means of a folder of data sets
</h2><span id='topic+mean.folder'></span>

<h3>Description</h3>

<p>Computes the means by column of the elements of an object of class <code>folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'folder'
mean(x, ..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.folder_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="mean.folder_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
<tr><td><code id="mean.folder_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. Should missing values (including NaN) be omitted from the calculations? (see <code><a href="base.html#topic+mean">mean</a></code> or <code><a href="base.html#topic+colMeans">colMeans</a></code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses <code><a href="base.html#topic+colMeans">colMeans</a></code> to compute the mean by numeric column of each element of the folder. If some columns of the data frames are not numeric, there is a warning, and the means are computed on the numeric columns only.
</p>


<h3>Value</h3>

<p>A list whose elements are the mean by column of the elements of the folder.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code> to create an object of class <code>folder</code>.
<code><a href="#topic+var.folder">var.folder</a></code>, <code><a href="#topic+cor.folder">cor.folder</a></code>, <code><a href="#topic+skewness.folder">skewness.folder</a></code>, <code><a href="#topic+kurtosis.folder">kurtosis.folder</a></code> for other statistics for <code>folder</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: iris (Fisher)               
data(iris)
iris.fold &lt;- as.folder(iris, "Species")
iris.means &lt;- mean(iris.fold)
print(iris.means)

# Second example: roses
data(roses)
roses.fold &lt;- as.folder(roses, "rose")
roses.means &lt;- mean(roses.fold)
print(roses.means)
</code></pre>

<hr>
<h2 id='mtgcomponents'>
Components of upper scale of a vertex
</h2><span id='topic+mtgcomponents'></span>

<h3>Description</h3>

<p>For a vertex in an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>, computes its decomposition into vertices of an upper scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtgcomponents(x, vertex, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtgcomponents_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>.
</p>
</td></tr>
<tr><td><code id="mtgcomponents_+3A_vertex">vertex</code></td>
<td>

<p>character. The identifier of a vertex. These identifiers are the rownames of the data frame <code>x$topology</code>.
</p>
</td></tr>
<tr><td><code id="mtgcomponents_+3A_scale">scale</code></td>
<td>

<p>integer. The scale of the components of <code>vertex</code> which will be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>vertex</code> is a vertex of scale <code>i</code>, then <code>scale</code> (the scale of the returned components of <code>vertex</code>) must be higher than <code>i</code>. For example, if <code>vertex</code> is a vertex of scale 2, then <code>scale &gt; 2</code>, for instance <code>scale = 3</code>. The returned components are then vertices of scale 3 which have a decomposition relationship with <code>vertex</code>.
</p>


<h3>Value</h3>

<p>A character vector, containing the idendifiers of the components of <code>vertex</code>.
</p>
<p>If there is no component, then the returned vector is empty.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>: reads a MTG file and builds an object of class <code>foldermtg</code>.
</p>
<p><code><a href="#topic+mtgorder">mtgorder</a></code>, <code><a href="#topic+mtgrank">mtgrank</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtgfile &lt;- system.file("extdata/plant1.mtg", package = "dad")
xmtg &lt;- read.mtg(mtgfile)

# Vertex of class "P" (plant, of scale 1), components of class 2 (axes: "A")
mtgcomponents(xmtg, vertex = "v01", scale = 2)

# Vertex of class "P" (plant, of scale 1), components of class 3 ("O", "M" and "I")
mtgcomponents(xmtg, vertex = "v01", scale = 3)

# Vertex of class "A" (stem, of scale 2), components of class 3 ("O", "M" and "I")
mtgcomponents(xmtg, vertex = "v12", scale = 3)
</code></pre>

<hr>
<h2 id='mtgorder'>
Branching order of vertices
</h2><span id='topic+mtgorder'></span>

<h3>Description</h3>

<p>Computes the branching order of vertices contained in an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>. The order of a vertex is the number of the column of <code><a href="#topic+topology">topology</a></code>, which contains this vertex. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtgorder(x, classes = "all", display = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtgorder_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>.
</p>
</td></tr>
<tr><td><code id="mtgorder_+3A_classes">classes</code></td>
<td>

<p>character vector. The classes of entities for which the branching order is computed. If omitted, the branching orders are computed for all entities.
</p>
</td></tr>
<tr><td><code id="mtgorder_+3A_display">display</code></td>
<td>

<p>logical. If <code>TRUE</code>, the data frames of <code>x</code> corresponding to <code>classes</code> are displayed. Default: <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>x</code> after appending the branching orders of the vertices of the classes given in the argument <code>classes</code>. The branching orders 
are appended to the data frames containing the vertices (one data frame per class) and the values of their corresponding features.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>, that is a list of data frames.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>: reads a MTG file and builds an object of class <code>foldermtg</code>.
</p>
<p><code><a href="#topic+mtgorder">mtgorder</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtgfile &lt;- system.file("extdata/plant1.mtg", package = "dad")
xmtg &lt;- read.mtg(mtgfile)

# The branching orders
ymtg &lt;- mtgorder(xmtg)
print(ymtg)

# Add the branching orders to the 'foldermtg'
zmtg &lt;- mtgorder(xmtg, display = TRUE)
print(zmtg)
</code></pre>

<hr>
<h2 id='mtgplant1'>
Class <code>foldermtg</code>
</h2><span id='topic+mtgplant1'></span>

<h3>Description</h3>

<p>These data produced by the SAGAH team (Sciences Agronomiques Appliquées à l'Horticulture, now Research Institute on Horticulture and Seeds), provide the topological structure of a rosebush.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mtgplant1")</code></pre>


<h3>Format</h3>

<p>This object of class <code><a href="#topic+foldermtg">foldermtg</a></code> is a list of 10 data frames:
</p>

<ul>
<li><p><code>mtgplant1$classes</code>: data frame with 6 rows and 5 columns named
<code>SYMBOL</code> (factor: the classes of the vertices), <code>SCALE</code> (integer: the scale at which they appear), <code>DECOMPOSITION</code> (factor), <code>INDEXATION</code> (factor) and <code>DEFINITION</code> (factor).
</p>
<p>The vertex classes are:
</p>

<ul>
<li> <p><code>P</code>: the whole plant (scale 1)
</p>
</li>
<li> <p><code>A</code>: the axes (scale 2)
</p>
</li>
<li> <p><code>O</code>, <code>M</code>, <code>I</code>: the ..., metamers (phytomers) and inflorescences (scale 3)
</p>
</li></ul>


</li>
<li><p><code>mtgplant1$description</code>: data frame with 8 rows and 4 columns (factors) named <code>LEFT</code>, <code>RIGHT</code>, <code>RELTYPE</code> and <code>MAX</code>.
</p>
</li>
<li><p><code>mtgplant1$features</code>: data frame with 13 rows and 2 columns (factors) named <code>NAME</code> and <code>TYPE</code>.
</p>
</li>
<li><p><code>mtgplant1$topology</code>: data frame with 88 rows and 4 columns:
</p>

<ul>
<li> <p><code>order1</code>, <code>order2</code> and <code>order3</code> (factors): the codes of the vertices, as they are found in the MTG table of the MTG file. The column on which a code appears gives the branching order of the corresponding vertex.
</p>
</li>
<li> <p><code>vertex</code> (character): the same codes of vertices, on a single column.
</p>
</li></ul>


</li>
<li><p><code>mtgplant1$coordinates</code>: data frame with 86 rows and 6 columns (numeric) named <code>XX</code>, <code>YY</code> and <code>22</code>: cartesian coordinates of the vertices, and <code>AA</code>, <code>BB</code> and <code>CC</code>: an other coordinates system.
</p>
</li>
<li><p><code>mtgplant1$P</code>, <code>mtgplant1$A</code>, <code>mtgplant1$M</code>, <code>mtgplant1$I</code>: data frames of the features on the vertices (all numeric).
</p>
</li></ul>



<h3>Details</h3>

<p>This object of class <code>foldermtg</code> can be built by reading the data in a MTG file (see examples).
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>: to read an MTG file and build an object of class MTG.
</p>
<p><code><a href="#topic+mtgplant2">mtgplant2</a></code>: an other example of such data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtgplant1)
print(mtgplant1)

# To read these data from a MTG file:
mtgfile1 &lt;- system.file("extdata/plant1.mtg", package = "dad")
mtgplant1 &lt;- read.mtg(mtgfile1)
print(mtgplant1)
</code></pre>

<hr>
<h2 id='mtgplant2'>
Class <code>foldermtg</code>
</h2><span id='topic+mtgplant2'></span>

<h3>Description</h3>

<p>These data provides the topology of a bushy plant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mtgplant2")</code></pre>


<h3>Format</h3>

<p>This object of class <code><a href="#topic+foldermtg">foldermtg</a></code> is a list of 9 data frames:
</p>

<ul>
<li><p><code>mtgplant2$classes</code>: data frame with 6 rows and 5 columns named
<code>SYMBOL</code> (factor: the classes of the vertices), <code>SCALE</code> (integer: the scale at which they appear), <code>DECOMPOSITION</code> (factor), <code>INDEXATION</code> (factor) and <code>DEFINITION</code> (factor).
</p>
<p>The vertex classes are:
</p>

<ul>
<li> <p><code>P</code>: the whole plant (scale 1)
</p>
</li>
<li> <p><code>A</code>: the axes (scale 2)
</p>
</li>
<li> <p><code>F</code>, <code>I</code>: the flower and internodes (scale 3)
</p>
</li></ul>


</li>
<li><p><code>mtgplant2$description</code>: data frame with 4 rows and 4 columns (factors) named <code>LEFT</code>, <code>RIGHT</code>, <code>RELTYPE</code> and <code>MAX</code>.
</p>
</li>
<li><p><code>mtgplant2$features</code>: data frame with 9 rows and 2 columns (factors) named <code>NAME</code> and <code>TYPE</code>.
</p>
</li>
<li><p><code>mtgplant2$topology</code>: data frame with 14 rows and 3 columns:
</p>

<ul>
<li> <p><code>order1</code> and <code>order2</code> (factors): the codes of the vertices, as they are found in the MTG table of the MTG file. The column on which a code appears gives the branching order of the corresponding vertex.
</p>
</li>
<li> <p><code>vertex</code> (character): the same codes of vertices, on a single column.
</p>
</li></ul>


</li>
<li><p><code>mtgplant2$coordinates</code>: data frame with 0 rows and 0 columns (there are no spatial coordinates in these MTG data).
</p>
</li>
<li><p><code>mtgplant2$P</code>, <code>mtgplant2$A</code>, <code>mtgplant2$F</code> and <code>mtgplant2$I</code>: data frames of the features on the vertices (all numeric).
</p>
</li></ul>



<h3>Details</h3>

<p>This object of class <code>foldermtg</code> can be built by reading the data in a MTG file (see examples).
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>: to read an MTG file and build an object of class MTG.
</p>
<p><code><a href="#topic+mtgplant1">mtgplant1</a></code>: an other example of such data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtgplant2)
print(mtgplant2)

# To read these data from a MTG file:
mtgfile2 &lt;- system.file("extdata/plant2.mtg", package = "dad")
mtgplant2 &lt;- read.mtg(mtgfile2)
print(mtgplant2)
</code></pre>

<hr>
<h2 id='mtgrank'>
Ranks of vertices in a decomposition
</h2><span id='topic+mtgrank'></span>

<h3>Description</h3>

<p>Computes the rank of the vertices contained in an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>. The vertex sequences resulting from a decomposition of other vertices, the rank of the vertices making up the sequences are computed from the beginning of the sequence or from its end. These ranks can be absolute or relative.  
</p>
<p>For example: ranks of the phytomeres and inflorescences in each stem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtgrank(x, classe, parent.class = NULL, sibling.classes = NULL,
  relative = FALSE, from = c("origin", "end"), rank.name = "Rank",
  display = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtgrank_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>.
</p>
</td></tr>
<tr><td><code id="mtgrank_+3A_classe">classe</code></td>
<td>

<p>character. The class of the vertices for which the ranks are computed.
</p>
</td></tr>
<tr><td><code id="mtgrank_+3A_parent.class">parent.class</code></td>
<td>

<p>character. The class of the parent entities of those for which the ranks are computed. If omitted, the entities of scale <code>maxscal - 1</code>, where <code>maxscal</code> is the highest scale in <code>x</code> data.
</p>
</td></tr>
<tr><td><code id="mtgrank_+3A_sibling.classes">sibling.classes</code></td>
<td>

<p>character vector. The classes of vertices appearing at the same scale as <code>classe</code>, which are used in the computing of the ranks.
</p>
<p>If omitted, only the vertices of class <code>classe</code> are used to compute the ranks.
</p>
</td></tr>
<tr><td><code id="mtgrank_+3A_relative">relative</code></td>
<td>

<p>logical. If <code>TRUE</code>, the relative ranks are computed, i.e. ranks from 0 to 1. Default: <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mtgrank_+3A_from">from</code></td>
<td>

<p>character. It can be <code>"origin"</code> (default) or <code>"end"</code>.
</p>
<p>If <code>from = "origin"</code>, the ranks are computed from the origin to the end, i.e. from 1 to its maximum (from 0 to 1 if <code>relative = TRUE</code>). If <code>from = "end"</code>, they are computed from the end to the origin, i.e. from the maximum to 1 (from 1 to 0 if <code>relative = TRUE</code>).
</p>
</td></tr>
<tr><td><code id="mtgrank_+3A_rank.name">rank.name</code></td>
<td>

<p>character. Name of the rank column that is appended to <code>x[[classe]]</code>. The default is <code>"Rank"</code>.
</p>
</td></tr>
<tr><td><code id="mtgrank_+3A_display">display</code></td>
<td>

<p>logical. If <code>TRUE</code>, the data frames of <code>x</code> corresponding to <code>classes</code> are displayed. Default: <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the branching orders of the entities given by <code>classe</code>, <code>parent.class</code> and, if relevant, <code>sibling.classes</code> are not contained in <code>x</code>, <code>mtgrank()</code> uses <code><a href="#topic+mtgorder">mtgorder</a></code> to compute them. The ranks are appended to the data frames containing the vertices (one data frame per class) and the values of their corresponding features.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>, that is a list of data frames.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>: reads a MTG file and builds an object of class <code>foldermtg</code>.
</p>
<p><code><a href="#topic+mtgorder">mtgorder</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtgfile &lt;- system.file("extdata/plant1.mtg", package = "dad")
xmtg &lt;- read.mtg(mtgfile)

ymtg &lt;- mtgrank(xmtg, "M")
print(ymtg)

mtgrank(xmtg, "M", display = TRUE)

mtgrank(xmtg, "M", parent.class = "A", display = TRUE)
mtgrank(xmtg, "M", parent.class = "A", sibling.classes = c("O", "I"), display = TRUE)
mtgrank(xmtg, "M", relative = TRUE, display = TRUE)
mtgrank(xmtg, "M", from = "origin", display = TRUE)
mtgrank(xmtg, "M", from = "end", display = TRUE)
</code></pre>

<hr>
<h2 id='plot.dstatis'>
Plotting scores of STATIS method (interstructure) analysis
</h2><span id='topic+plot.dstatis'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"dstatis"</code> (see details of the  
<code><a href="#topic+dstatis.inter">dstatis.inter</a></code> function). Plots the scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dstatis'
plot(x, nscore = c(1, 2), sub.title = NULL, color = NULL, fontsize.points = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dstatis_+3A_x">x</code></td>
<td>

<p>object of class <code>"dstatis"</code> (returned by <code><a href="#topic+dstatis.inter">dstatis.inter</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.dstatis_+3A_nscore">nscore</code></td>
<td>

<p>a length 2 numeric vector. The numbers of the score vectors to be plotted.
</p>
<p>Warning: Its components cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+dstatis.inter">dstatis.inter</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.dstatis_+3A_sub.title">sub.title</code></td>
<td>

<p>string. Subtitle to be added to each graph.
</p>
</td></tr>
<tr><td><code id="plot.dstatis_+3A_color">color</code></td>
<td>

<p>When provided, the colour of the symbols of each group. Can be a vector with length equal to the number of groups.
</p>
</td></tr>
<tr><td><code id="plot.dstatis_+3A_fontsize.points">fontsize.points</code></td>
<td>

<p>Numeric. Expansion of the characters (or symbols) of the groups on the graph. This works as a multiple of <code>par("cex")</code> (see <code><a href="graphics.html#topic+points">points</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.dstatis_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>plot</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the principal scores returned by the <code><a href="#topic+dstatis.inter">dstatis.inter</a></code> function. 
A new graphics window is opened for each pair of principal axes defined by the <code>nscore</code> argument.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Lavit, C., Escoufier, Y., Sabatier, R., Traissac, P. (1994). The ACT (STATIS method). Computational Statistics &amp; Data Analysis, 18 (1994), 97-119.
</p>


<h3>See Also</h3>

<p><a href="#topic+dstatis.inter">dstatis.inter</a>; <a href="#topic+print.dstatis">print.dstatis</a>; <a href="#topic+interpret.dstatis">interpret.dstatis</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
rosesf &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])

# Dual STATIS on the covariance matrices
result &lt;- dstatis.inter(rosesf, data.scaled = FALSE, group.name = "rose")
plot(result)
</code></pre>

<hr>
<h2 id='plot.fhclustd'>
Plotting a hierarchical clustering
</h2><span id='topic+plot.fhclustd'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>fhclustd</code> (see details of the  
<code><a href="#topic+fhclustd">fhclustd</a></code> function). Plots the dendogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fhclustd'
plot(x, labels = NULL, hang = 0.1, check = TRUE, axes = TRUE,
                        frame.plot = FALSE, ann = TRUE,
                        main = "HCA of probability density functions",
                        sub = NULL, xlab = NULL, ylab = "Height", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fhclustd_+3A_x">x</code></td>
<td>

<p>object of class <code>fhclustd</code> (returned by <code><a href="#topic+fhclustd">fhclustd</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.fhclustd_+3A_labels">labels</code>, <code id="plot.fhclustd_+3A_hang">hang</code>, <code id="plot.fhclustd_+3A_check">check</code>, <code id="plot.fhclustd_+3A_axes">axes</code>, <code id="plot.fhclustd_+3A_frame.plot">frame.plot</code>, <code id="plot.fhclustd_+3A_ann">ann</code>, <code id="plot.fhclustd_+3A_main">main</code>, <code id="plot.fhclustd_+3A_sub">sub</code>, <code id="plot.fhclustd_+3A_xlab">xlab</code>, <code id="plot.fhclustd_+3A_ylab">ylab</code></td>
<td>

<p>Arguments concerning the graphical representation of the dendogram. See <code><a href="stats.html#topic+plot.hclust">plot.hclust</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.fhclustd_+3A_...">...</code></td>
<td>

<p>Further graphical arguments.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+fhclustd">fhclustd</a>; <a href="#topic+print.fhclustd">print.fhclustd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
xf &lt;- as.folder(castles.dated$stones)
## Not run: 
result &lt;- fhclustd(xf)
plot(result)
plot(result, hang = -1)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fmdsd'>
Plotting scores of multidimensional scaling of density functions
</h2><span id='topic+plot.fmdsd'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fmdsd"</code> (see the details section of the  
<code><a href="#topic+fmdsd">fmdsd</a></code> function). Plots the scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmdsd'
plot(x, nscore = c(1, 2), main="MDS of probability density functions",
    sub.title = NULL, color = NULL, fontsize.points = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fmdsd_+3A_x">x</code></td>
<td>

<p>object of class <code>"fmdsd"</code>.
</p>
</td></tr>
<tr><td><code id="plot.fmdsd_+3A_nscore">nscore</code></td>
<td>

<p>a length 2 numeric vector. The numbers of the score vectors to be plotted.
</p>
<p>Warning: Its components cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+fmdsd">fmdsd</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.fmdsd_+3A_main">main</code></td>
<td>

<p>this argument to title has an useful default here.
</p>
</td></tr>
<tr><td><code id="plot.fmdsd_+3A_sub.title">sub.title</code></td>
<td>

<p>string. Subtitle to be added to each graph.
</p>
</td></tr>
<tr><td><code id="plot.fmdsd_+3A_color">color</code></td>
<td>

<p>When provided, the colour of the symbols of each group. Can be a vector with length equal to the number of groups.
</p>
</td></tr>
<tr><td><code id="plot.fmdsd_+3A_fontsize.points">fontsize.points</code></td>
<td>

<p>Numeric. Expansion of the characters (or symbols) of the groups on the graph. This works as a multiple of <code>par("cex")</code> (see <code><a href="graphics.html#topic+points">points</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.fmdsd_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>plot</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the principal scores returned by the function <code><a href="#topic+fmdsd">fmdsd</a></code>. 
A new graphics window is opened for each pair of principal score vectors defined by the
<code>nscore</code> argument.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+fmdsd">fmdsd</a>; <a href="#topic+print.fmdsd">print.fmdsd</a>; <a href="#topic+interpret.fmdsd">interpret.fmdsd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
x &lt;- roses[,c("Sha","Den","Sym","rose")]
rosesfold &lt;- as.folder(x)
result &lt;- fmdsd(rosesfold)
plot(result)
</code></pre>

<hr>
<h2 id='plot.foldert'>
Plotting data of a foldert
</h2><span id='topic+plot.foldert'></span>

<h3>Description</h3>

<p>Applies to an object of class <code><a href="#topic+foldert">foldert</a></code> (called foldert below) that is a list.
Plots the longitudinal evolution of a numeric variable for every individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foldert'
plot(x, which, na.inter = TRUE, type = "l", ylim = NULL, ylab = which,
                       main = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.foldert_+3A_x">x</code></td>
<td>

<p>object of class <code><a href="#topic+foldert">foldert</a></code> that is a list of data frames with the same column names, each of them corresponding to a time of observation.
</p>
</td></tr>
<tr><td><code id="plot.foldert_+3A_which">which</code></td>
<td>

<p>character. Name of a column of the data frames of <code>x</code>.
It gives the name of the variable to be plotted.
</p>
<p>For each element <code>x[[k]]</code> of <code>x</code>, <code>x[[k]]</code> must be numeric.
Otherwise, there is an error
</p>
</td></tr>
<tr><td><code id="plot.foldert_+3A_na.inter">na.inter</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), for each individual, the missing values are deleted before plotting its evolution.
If <code>FALSE</code>, the line corresponding to each individual is interrupted if there is a missing value, as for <code><a href="graphics.html#topic+matplot">matplot</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.foldert_+3A_type">type</code></td>
<td>

<p>character string (length 1 vector) or vector of 1-character strings (default <code>"l"</code>) indicating the type of plot for each of the individuals followed among time, that is for each line of the data frames in the foldert.
For further information about this argument, see <code><a href="graphics.html#topic+matplot">matplot</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.foldert_+3A_ylim">ylim</code></td>
<td>

<p>ranges of y axis. <code>xlim</code> is as in <code><a href="graphics.html#topic+matplot">matplot</a></code>.
See details.
</p>
</td></tr>
<tr><td><code id="plot.foldert_+3A_ylab">ylab</code></td>
<td>

<p>a label for the <code>y</code> axis. Default: the name of the plotted variable (<code>which</code> argument).
</p>
</td></tr>
<tr><td><code id="plot.foldert_+3A_main">main</code></td>
<td>

<p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.foldert_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>plot</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, <code>plot.foldert</code> builds a matrix <code>mdata</code> containing the data of the variable given by <code>which</code> argument.
The element <code>mdata[ind, t]</code> of this matrix is the value of the variable <code>which</code> for the individual <code>ind</code>: <code>x[[t]][ind, which]</code>.
</p>
<p>If the <code>ylim</code> argument is omitted, the range of <code>y</code> axis is given by <code>range(mdata, na.rm = TRUE)*c(0, 1.2)</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: object of class <code>foldert</code>.
<code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>: build an object of class <code>foldert</code> from a data frame.
<code><a href="#topic+as.foldert.array">as.foldert.array</a></code>: build an object of class <code>foldert</code> from a <code class="reqn">3d</code>-array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(floribundity)
ftflor &lt;- foldert(floribundity, cols.select = "union", rows.select = "union")
plot(ftflor, which = "nflowers", ylab = "Number of flowers per plant",
     main = "Floribundity of rosebushes, 2010, Angers (France)")
</code></pre>

<hr>
<h2 id='plot.fpcad'>
Plotting scores of principal component analysis of density functions
</h2><span id='topic+plot.fpcad'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fpcad"</code> (see details of the  
<code><a href="#topic+fpcad">fpcad</a></code> function). Plots the scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpcad'
plot(x, nscore = c(1, 2), main = "PCA of probability density functions",
    sub.title = NULL, color = NULL, fontsize.points = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fpcad_+3A_x">x</code></td>
<td>

<p>object of class <code>"fpcad"</code> (returned by <code><a href="#topic+fpcad">fpcad</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.fpcad_+3A_nscore">nscore</code></td>
<td>

<p>a length 2 numeric vector. The numbers of the score vectors to be plotted.
</p>
<p>Warning: Its components cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+fpcad">fpcad</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.fpcad_+3A_main">main</code></td>
<td>

<p>this argument to title has an useful default here.
</p>
</td></tr>
<tr><td><code id="plot.fpcad_+3A_sub.title">sub.title</code></td>
<td>

<p>string. Subtitle to be added to each graph.
</p>
</td></tr>
<tr><td><code id="plot.fpcad_+3A_color">color</code></td>
<td>

<p>When provided, the colour of the symbols of each group. Can be a vector with length equal to the number of groups.
</p>
</td></tr>
<tr><td><code id="plot.fpcad_+3A_fontsize.points">fontsize.points</code></td>
<td>

<p>Numeric. Expansion of the characters (or symbols) of the groups on the graph. This works as a multiple of <code>par("cex")</code> (see <code><a href="graphics.html#topic+points">points</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.fpcad_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>plot</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the principal scores returned by the <code><a href="#topic+fpcad">fpcad</a></code> function. 
A new graphics window is opened for each pair of principal axes defined by the <code>nscore</code> argument.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+fpcad">fpcad</a>; <a href="#topic+print.fpcad">print.fpcad</a>; <a href="#topic+interpret.fpcad">interpret.fpcad</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
rosefold &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])
result &lt;- fpcad(rosefold)
plot(result)
</code></pre>

<hr>
<h2 id='plot.fpcat'>
Plotting scores of principal component analysis of density functions among time
</h2><span id='topic+plot.fpcat'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fpcat"</code> (see details of the  
<code><a href="#topic+fpcat">fpcat</a></code> function). Plots the scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpcat'
plot(x, nscore=c(1, 2), main = "PCA of probability density functions",
    sub.title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fpcat_+3A_x">x</code></td>
<td>

<p>object of class <code>"fpcat"</code> (returned by <code><a href="#topic+fpcat">fpcat</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.fpcat_+3A_nscore">nscore</code></td>
<td>

<p>numeric or length 2 numeric vector. If it is a length 2 numeric vector (default), it contains the numbers of the score vectors to be plotted. If it is a single value, it is the number of the score which is plotted among time.
</p>
<p>Warning: The components of <code>nscore</code> cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+fpcat">fpcat</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.fpcat_+3A_main">main</code></td>
<td>

<p>this argument to title has an useful default here.
</p>
</td></tr>
<tr><td><code id="plot.fpcat_+3A_sub.title">sub.title</code></td>
<td>

<p>string. Subtitle to be added to each graph.
</p>
</td></tr>
<tr><td><code id="plot.fpcat_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>plot</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots:
</p>

<ul>
<li><p>if <code>nscore</code> is a length 2 vector (default): the principal scores returned by the <code><a href="#topic+fpcat">fpcat</a></code> function with arrows from the point corresponding to each time to the next one.
</p>
</li>
<li><p>if <code>nscore</code> is a single value, the principal scores among time with arrows from each time to the next one.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+fpcat">fpcat</a>; <a href="#topic+print.fpcat">print.fpcat</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times &lt;- as.Date(c("2017-03-01", "2017-04-01", "2017-05-01", "2017-06-01"))
x1 &lt;- data.frame(z1=rnorm(6,1,5), z2=rnorm(6,3,3))
x2 &lt;- data.frame(z1=rnorm(6,4,6), z2=rnorm(6,5,2))
x3 &lt;- data.frame(z1=rnorm(6,7,2), z2=rnorm(6,8,4))
x4 &lt;- data.frame(z1=rnorm(6,9,3), z2=rnorm(6,10,2))
ft &lt;- foldert(x1, x2, x3, x4, times = times, rows.select="intersect")
print(ft)
result &lt;- fpcat(ft)
plot(result)
plot(result,  nscore = c(1, 2))
plot(result,  nscore = 1)
plot(result)
</code></pre>

<hr>
<h2 id='plot.hclustdd'>
Plotting a hierarchical clustering of discrete distributions
</h2><span id='topic+plot.hclustdd'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>hclustdd</code> (see details of the  
<code><a href="#topic+hclustdd">hclustdd</a></code> function). Plots the dendogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hclustdd'
plot(x, labels = NULL, hang = 0.1, check = TRUE, axes = TRUE,
                        frame.plot = FALSE, ann = TRUE,
                        main = "HCA of probability density functions",
                        sub = NULL, xlab = NULL, ylab = "Height", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hclustdd_+3A_x">x</code></td>
<td>

<p>object of class <code>hclustdd</code> (returned by <code><a href="#topic+hclustdd">hclustdd</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.hclustdd_+3A_labels">labels</code>, <code id="plot.hclustdd_+3A_hang">hang</code>, <code id="plot.hclustdd_+3A_check">check</code>, <code id="plot.hclustdd_+3A_axes">axes</code>, <code id="plot.hclustdd_+3A_frame.plot">frame.plot</code>, <code id="plot.hclustdd_+3A_ann">ann</code>, <code id="plot.hclustdd_+3A_main">main</code>, <code id="plot.hclustdd_+3A_sub">sub</code>, <code id="plot.hclustdd_+3A_xlab">xlab</code>, <code id="plot.hclustdd_+3A_ylab">ylab</code></td>
<td>

<p>Arguments concerning the graphical representation of the dendogram. See <code><a href="stats.html#topic+plot.hclust">plot.hclust</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.hclustdd_+3A_...">...</code></td>
<td>

<p>Further graphical arguments.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+hclustdd">hclustdd</a>; <a href="#topic+print.hclustdd">print.hclustdd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dspg)
xl = dspg
result &lt;- hclustdd(xl)
plot(result)
plot(result, hang = -1)
</code></pre>

<hr>
<h2 id='plot.mdsdd'>
Plotting scores of multidimensional scaling analysis of discrete distributions
</h2><span id='topic+plot.mdsdd'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"mdsdd"</code> (see the details section of the  
<code><a href="#topic+mdsdd">mdsdd</a></code> function). Plots the scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdsdd'
plot(x, nscore = c(1, 2), main="MDS of probability density functions",
    sub.title = NULL, color = NULL, fontsize.points = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mdsdd_+3A_x">x</code></td>
<td>

<p>object of class <code>"mdsdd"</code>.
</p>
</td></tr>
<tr><td><code id="plot.mdsdd_+3A_nscore">nscore</code></td>
<td>

<p>a length 2 numeric vector. The numbers of the score vectors to be plotted.
</p>
<p>Warning: Its components cannot be greater than the <code>nb.factors</code> argument in the call of the <code><a href="#topic+fmdsd">fmdsd</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.mdsdd_+3A_main">main</code></td>
<td>

<p>this argument to title has an useful default here.
</p>
</td></tr>
<tr><td><code id="plot.mdsdd_+3A_sub.title">sub.title</code></td>
<td>

<p>string. Subtitle to be added to each graph.
</p>
</td></tr>
<tr><td><code id="plot.mdsdd_+3A_color">color</code></td>
<td>

<p>When provided, the colour of the symbols of each group. Can be a vector with length equal to the number of groups.
</p>
</td></tr>
<tr><td><code id="plot.mdsdd_+3A_fontsize.points">fontsize.points</code></td>
<td>

<p>Numeric. Expansion of the characters (or symbols) of the groups on the graph. This works as a multiple of <code>par("cex")</code> (see <code><a href="graphics.html#topic+points">points</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.mdsdd_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>plot</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the principal scores returned by the function <code><a href="#topic+mdsdd">mdsdd</a></code>. 
A new graphics window is opened for each pair of principal score vectors defined by the
<code>nscore</code> argument.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+mdsdd">mdsdd</a>; <a href="#topic+print.mdsdd">print.mdsdd</a>; <a href="#topic+interpret.mdsdd">interpret.mdsdd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># INSEE (France): Diploma x Socio professional group, seven years.
data(dspg)
xlista = dspg
a &lt;- mdsdd(xlista)
plot(a) 
</code></pre>

<hr>
<h2 id='plotframes'>
Plotting of two sets of variables
</h2><span id='topic+plotframes'></span>

<h3>Description</h3>

<p>Plots a set of numeric variables vs. another set and prints the pairwise correlations. It uses the function <code>xyplot</code> of <code>lattice</code> package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotframes(x, y, xlab = NULL, ylab = NULL, font.size = 12, layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotframes_+3A_x">x</code></td>
<td>

<p>data frame (can also be a tibble). Variables on x coordinates.
</p>
</td></tr>
<tr><td><code id="plotframes_+3A_y">y</code></td>
<td>

<p>data frame (or tibble). Variables on y coordinates.
</p>
</td></tr>
<tr><td><code id="plotframes_+3A_xlab">xlab</code></td>
<td>

<p>a label for the x axis, by default the column names of <code>y</code>.
</p>
</td></tr>
<tr><td><code id="plotframes_+3A_ylab">ylab</code></td>
<td>

<p>a label for the y axis (by default there is no label).
</p>
</td></tr>
<tr><td><code id="plotframes_+3A_font.size">font.size</code></td>
<td>

<p>integer. Size of the characters in the strips.
</p>
</td></tr>
<tr><td><code id="plotframes_+3A_layout">layout</code></td>
<td>

<p>numeric vector of length 2 or 3 giving the number of columns, rows, and optionally pages of the lattice. If omitted, the graphs will be displayed on 3 lines and 3 columns, with a number of pages set to the required number.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
mx &lt;- c(0,0)
vx &lt;- matrix(c(1,0,0,1),ncol = 2) 
my &lt;- c(0,1)
vy &lt;- matrix(c(4,1,1,9),ncol = 2)
x &lt;- as.data.frame(mvrnorm(n = 10, mu = mx, Sigma = vx))
y &lt;- as.data.frame(mvrnorm(n = 10, mu = my, Sigma = vy))
colnames(x) &lt;- c("x1", "x2")
colnames(y) &lt;- c("y1", "y2")
plotframes(x, y)
</code></pre>

<hr>
<h2 id='print.discdd.misclass'>
Printing results of discriminant analysis of discrete probability distributions
</h2><span id='topic+print.discdd.misclass'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"discdd.misclass"</code>. Prints the numerical results of <code><a href="#topic+discdd.misclass">discdd.misclass</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'discdd.misclass'
print(x, dist.print=FALSE, prox.print=FALSE, digits=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.discdd.misclass_+3A_x">x</code></td>
<td>

<p>object of class <code>"discdd.misclass"</code>, returned by <code><a href="#topic+discdd.misclass">discdd.misclass</a></code>.
</p>
</td></tr>
<tr><td><code id="print.discdd.misclass_+3A_dist.print">dist.print</code></td>
<td>

<p>logical. Its default value is <code>FALSE</code>. If <code>TRUE</code>, prints the matrix of distances between, on one side, the groups (densities) and, on the other side, the classes (of groups or densities).
</p>
</td></tr>
<tr><td><code id="print.discdd.misclass_+3A_prox.print">prox.print</code></td>
<td>

<p>logical. Its default value is <code>FALSE</code>. If <code>TRUE</code>, prints the matrix of proximity indices (in percent) )between, on one side, the groups (densities) and, on the other side, the classes (of groups or densities).
</p>
</td></tr>
<tr><td><code id="print.discdd.misclass_+3A_digits">digits</code></td>
<td>

<p>numeric. Number of significant digits for the display of numerical results.
</p>
</td></tr>
<tr><td><code id="print.discdd.misclass_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed the whole misallocation ratio, the confusion matrix (allocations versus origins) with the misallocation ratios per class, and the data frame whose rows are the groups, and whose columns are the origin classes and allocation classes, and a logical variable indicating misclassification. 
</p>
<p>If <code>dist.print = TRUE</code> or <code>prox.print = TRUE</code>, the distances or proximity indices (in percent) between groups and classes, are displayed.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+discdd.misclass">discdd.misclass</a>; <a href="base.html#topic+print">print</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("castles.dated")
stones &lt;- castles.dated$stones
periods &lt;- castles.dated$periods
stones$height &lt;- cut(stones$height, breaks = c(19, 27, 40, 71), include.lowest = TRUE)
stones$width &lt;- cut(stones$width, breaks = c(24, 45, 62, 144), include.lowest = TRUE)
stones$edging &lt;- cut(stones$edging, breaks = c(0, 3, 4, 8), include.lowest = TRUE)
stones$boss &lt;- cut(stones$boss, breaks = c(0, 6, 9, 20), include.lowest = TRUE )

castlefh &lt;- folderh(periods, "castle", stones)

res &lt;- discdd.misclass(castlefh, "period")

print(res)
</code></pre>

<hr>
<h2 id='print.discdd.predict'>
Printing results of discriminant analysis of discrete probability distributions
</h2><span id='topic+print.discdd.predict'></span>

<h3>Description</h3>

<p><code>print</code> function, applied to an object of class <code>"discdd.predict"</code>, prints numerical results of <a href="#topic+discdd.predict">discdd.predict</a> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'discdd.predict'
print(x, dist.print=TRUE, prox.print=FALSE, digits=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.discdd.predict_+3A_x">x</code></td>
<td>

<p>object of class <code>"discdd.predict"</code>, returned by <a href="#topic+discdd.predict">discdd.predict</a>.
</p>
</td></tr>
<tr><td><code id="print.discdd.predict_+3A_dist.print">dist.print</code></td>
<td>

<p>logical. If <code>TRUE</code> (the default), prints the matrix of distances between, on one side, the groups (densities) and, on the other side, the classes (of groups or densities).
</p>
</td></tr>
<tr><td><code id="print.discdd.predict_+3A_prox.print">prox.print</code></td>
<td>

<p>logical. Its default value is <code>FALSE</code>. If <code>TRUE</code>, prints the matrix of proximity indices between, on one side, the groups (densities) and, on the other side, the classes (of groups or densities).
</p>
</td></tr>
<tr><td><code id="print.discdd.predict_+3A_digits">digits</code></td>
<td>

<p>numerical. Number of significant digits for the display of numerical results.
</p>
</td></tr>
<tr><td><code id="print.discdd.predict_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed:
</p>

<ul>
<li><p> if available (if <code>misclass.ratio</code> argument of <code><a href="#topic+discdd.predict">discdd.predict</a></code> was <code>TRUE</code>), the whole misallocation ratio, the confusion matrix (allocations versus origins) and the misallocation ratio per class are printed.
</p>
</li>
<li><p> the data frame the rows of which are the groups, and the columns of which are of the origin (<code>NA</code> if not available) and allocation classes. 
</p>
</li></ul>

<p>If <code>dist.print = TRUE</code> or <code>prox.print = TRUE</code>, the distances or proximity indices between groups and classes, are displayed.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+discdd.predict">discdd.predict</a>; <a href="base.html#topic+print">print</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
data(castles.nondated)
stones &lt;- rbind(castles.dated$stones, castles.nondated$stones)
periods &lt;- rbind(castles.dated$periods, castles.nondated$periods)
stones$height &lt;- cut(stones$height, breaks = c(19, 27, 40, 71), include.lowest = TRUE)
stones$width &lt;- cut(stones$width, breaks = c(24, 45, 62, 144), include.lowest = TRUE)
stones$edging &lt;- cut(stones$edging, breaks = c(0, 3, 4, 8), include.lowest = TRUE)
stones$boss &lt;- cut(stones$boss, breaks = c(0, 6, 9, 20), include.lowest = TRUE )

castlesfh &lt;- folderh(periods, "castle", stones)

result &lt;- discdd.predict(castlesfh, "period")
print(result)
print(result, prox.print=TRUE)
</code></pre>

<hr>
<h2 id='print.dstatis'>
Printing results of STATIS method (interstructure) analysis
</h2><span id='topic+print.dstatis'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"dstatis"</code>. Prints the numeric results returned by the <code><a href="#topic+dstatis.inter">dstatis.inter</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dstatis'
print(x, mean.print = FALSE, var.print = FALSE,
  cor.print = FALSE, skewness.print = FALSE, kurtosis.print = FALSE,
  digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dstatis_+3A_x">x</code></td>
<td>

<p>object of class <code>"dstatis"</code>, returned by the <code><a href="#topic+dstatis.inter">dstatis.inter</a></code> function.
</p>
</td></tr>
<tr><td><code id="print.dstatis_+3A_mean.print">mean.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the means and standard deviations of the variables and the norm of the density.
</p>
</td></tr>
<tr><td><code id="print.dstatis_+3A_var.print">var.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the variances and covariances of the variables.
</p>
</td></tr>
<tr><td><code id="print.dstatis_+3A_cor.print">cor.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the correlations between the variables.
</p>
</td></tr>
<tr><td><code id="print.dstatis_+3A_skewness.print">skewness.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the skewness coefficients of the variables.
</p>
</td></tr>
<tr><td><code id="print.dstatis_+3A_kurtosis.print">kurtosis.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the kurtosis coefficients of the variables.
</p>
</td></tr>
<tr><td><code id="print.dstatis_+3A_digits">digits</code></td>
<td>

<p>numeric. Number of significant digits for the display of numeric results.
</p>
</td></tr>
<tr><td><code id="print.dstatis_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed the inertia explained by the <code>nb.values</code> (see <code><a href="#topic+dstatis.inter">dstatis.inter</a></code>) first principal components, the contributions, the qualities of representation of the densities along the <code>nb.factors</code> (see <code><a href="#topic+dstatis.inter">dstatis.inter</a></code>) first principal components, and the principal scores.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Lavit, C., Escoufier, Y., Sabatier, R., Traissac, P. (1994). The ACT (STATIS method). Computational Statistics &amp; Data Analysis, 18 (1994), 97-119.
</p>


<h3>See Also</h3>

<p><a href="#topic+dstatis.inter">dstatis.inter</a>; <a href="#topic+plot.dstatis">plot.dstatis</a>; <a href="#topic+interpret.dstatis">interpret.dstatis</a>; <a href="#topic+print.dstatis">print.dstatis</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
rosesf &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])

# Dual STATIS on the covariance matrices
result &lt;- dstatis.inter(rosesf, data.scaled = FALSE, group.name = "rose")
print(result)
</code></pre>

<hr>
<h2 id='print.fdiscd.misclass'>
Printing results of discriminant analysis of probability density functions
</h2><span id='topic+print.fdiscd.misclass'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fdiscd.misclass"</code>. Prints the numerical results of <code><a href="#topic+fdiscd.misclass">fdiscd.misclass</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fdiscd.misclass'
print(x, dist.print=FALSE, prox.print=FALSE, digits=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fdiscd.misclass_+3A_x">x</code></td>
<td>

<p>object of class <code>"fdiscd.misclass"</code>, returned by <code><a href="#topic+fdiscd.misclass">fdiscd.misclass</a></code>.
</p>
</td></tr>
<tr><td><code id="print.fdiscd.misclass_+3A_dist.print">dist.print</code></td>
<td>

<p>logical. Its default value is <code>FALSE</code>. If <code>TRUE</code>, prints the matrix of distances between, on one side, the groups (densities) and, on the other side, the classes (of groups or densities).
</p>
</td></tr>
<tr><td><code id="print.fdiscd.misclass_+3A_prox.print">prox.print</code></td>
<td>

<p>logical. Its default value is <code>FALSE</code>. If <code>TRUE</code>, prints the matrix of proximity indices (in percent) )between, on one side, the groups (densities) and, on the other side, the classes (of groups or densities).
</p>
</td></tr>
<tr><td><code id="print.fdiscd.misclass_+3A_digits">digits</code></td>
<td>

<p>numeric. Number of significant digits for the display of numerical results.
</p>
</td></tr>
<tr><td><code id="print.fdiscd.misclass_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed the whole misallocation ratio, the confusion matrix (allocations versus origins) with the misallocation ratios per class, and the data frame whose rows are the groups, and whose columns are the origin classes and allocation classes, and a logical variable indicating misclassification. 
</p>
<p>If <code>dist.print = TRUE</code> or <code>prox.print = TRUE</code>, the distances or proximity indices (in percent) between groups and classes, are displayed.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R. (2004). Discriminant analysis with independently repeated multivariate measurements: an <code class="reqn">L^2</code> approach. Computational Statistics &amp; Data Analysis, 47, 823-843.
</p>
<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution à l'étude de l'architecture médiévale: les caractéristiques des pierres à bossage des châteaux forts alsaciens, Centre de Recherches Archéologiques Médiévales de Saverne, 5, 5-38.
</p>


<h3>See Also</h3>

<p><a href="#topic+fdiscd.misclass">fdiscd.misclass</a>; <a href="base.html#topic+print">print</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
castlesfh &lt;- folderh(castles.dated$periods, "castle", castles.dated$stones)
result &lt;- fdiscd.misclass(castlesfh, "period")
print(result)
print(result, dist.print=TRUE)
print(result, prox.print=TRUE)
</code></pre>

<hr>
<h2 id='print.fdiscd.predict'>
Printing results of discriminant analysis of probability density functions
</h2><span id='topic+print.fdiscd.predict'></span>

<h3>Description</h3>

<p><code>print</code> function, applied to an object of class <code>"fdiscd.predict"</code>, prints numerical results of <a href="#topic+fdiscd.predict">fdiscd.predict</a> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fdiscd.predict'
print(x, dist.print=TRUE, prox.print=FALSE, digits=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fdiscd.predict_+3A_x">x</code></td>
<td>

<p>object of class <code>"fdiscd.predict"</code>, returned by <a href="#topic+fdiscd.predict">fdiscd.predict</a>.
</p>
</td></tr>
<tr><td><code id="print.fdiscd.predict_+3A_dist.print">dist.print</code></td>
<td>

<p>logical. If <code>TRUE</code> (the default), prints the matrix of distances between, on one side, the groups (densities) and, on the other side, the classes (of groups or densities).
</p>
</td></tr>
<tr><td><code id="print.fdiscd.predict_+3A_prox.print">prox.print</code></td>
<td>

<p>logical. Its default value is <code>FALSE</code>. If <code>TRUE</code>, prints the matrix of proximity indices between, on one side, the groups (densities) and, on the other side, the classes (of groups or densities).
</p>
</td></tr>
<tr><td><code id="print.fdiscd.predict_+3A_digits">digits</code></td>
<td>

<p>numerical. Number of significant digits for the display of numerical results.
</p>
</td></tr>
<tr><td><code id="print.fdiscd.predict_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed:
</p>

<ul>
<li><p> if available (if <code>misclass.ratio</code> argument of <code><a href="#topic+fdiscd.predict">fdiscd.predict</a></code> was <code>TRUE</code>), the whole misallocation ratio, the confusion matrix (allocations versus origins) and the misallocation ratio per class are printed.
</p>
</li>
<li><p> the data frame the rows of which are the groups, and the columns of which are of the origin (<code>NA</code> if not available) and allocation classes. 
</p>
</li></ul>

<p>If <code>dist.print = TRUE</code> or <code>prox.print = TRUE</code>, the distances or proximity indices between groups and classes, are displayed.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R. (2004). Discriminant analysis with independently repeated multivariate measurements: an <code class="reqn">L^2</code> approach. Computational Statistics &amp; Data Analysis, 47, 823-843.
</p>
<p>Rudrauf, J.M., Boumaza, R. (2001). Contribution à l'étude de l'architecture médiévale: les caractéristiques des pierres à bossage des châteaux forts alsaciens, Centre de Recherches Archéologiques médiévales de Saverne, 5, 5-38.
</p>


<h3>See Also</h3>

<p><a href="#topic+fdiscd.predict">fdiscd.predict</a>; <a href="base.html#topic+print">print</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
data(castles.nondated)
castles.stones &lt;- rbind(castles.dated$stones, castles.nondated$stones)
castles.periods &lt;- rbind(castles.dated$periods, castles.nondated$periods)
castlesfh &lt;- folderh(castles.periods, "castle", castles.stones)
result &lt;- fdiscd.predict(castlesfh, "period")
print(result)
print(result, prox.print=TRUE)
</code></pre>

<hr>
<h2 id='print.fhclustd'>
Printing results of a hierarchical clustering of probability density functions
</h2><span id='topic+print.fhclustd'></span>

<h3>Description</h3>

<p><code>print</code> function, applied to an object of class <code>"fhclustd"</code>, prints numerical results of <a href="#topic+fhclustd">fhclustd</a> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fhclustd'
print(x, dist.print=FALSE, digits=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fhclustd_+3A_x">x</code></td>
<td>

<p>object of class <code>"fhclustd"</code>, returned by <a href="#topic+fhclustd">fhclustd</a>.
</p>
</td></tr>
<tr><td><code id="print.fhclustd_+3A_dist.print">dist.print</code></td>
<td>

<p>logical. If <code>TRUE</code> (default: <code>FALSE</code>), prints the matrix of distances between the groups (densities).
</p>
</td></tr>
<tr><td><code id="print.fhclustd_+3A_digits">digits</code></td>
<td>

<p>numerical. Number of significant digits for the display of numerical results.
</p>
</td></tr>
<tr><td><code id="print.fhclustd_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>dist.print = TRUE</code>, the distances between groups are displayed.
</p>
<p>By default, the result of the clustering is printed. The display is the same as that of the <code><a href="stats.html#topic+print.hclust">print.hclust</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+fhclustd">fhclustd</a>; <a href="base.html#topic+print">print</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(castles.dated)
xf &lt;- as.folder(castles.dated$stones)
## Not run: 
result &lt;- fhclustd(xf)
print(result)
print(result, dist.print = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.fmdsd'>
Printing results of a multidimensional scaling analysis of probability densities
</h2><span id='topic+print.fmdsd'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fmdsd"</code>. Prints the numeric results returned by the <code><a href="#topic+fmdsd">fmdsd</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmdsd'
print(x, mean.print = FALSE, var.print = FALSE,
  cor.print = FALSE, skewness.print = FALSE, kurtosis.print = FALSE,
  digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fmdsd_+3A_x">x</code></td>
<td>

<p>object of class <code>"fmdsd"</code>, returned by the <code><a href="#topic+fmdsd">fmdsd</a></code> function.
</p>
</td></tr>
<tr><td><code id="print.fmdsd_+3A_mean.print">mean.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the means and standard deviations of the variables and the norm of the density.
</p>
</td></tr>
<tr><td><code id="print.fmdsd_+3A_var.print">var.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the variances and covariances of the variables.
</p>
</td></tr>
<tr><td><code id="print.fmdsd_+3A_cor.print">cor.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the correlations between the variables.
</p>
</td></tr>
<tr><td><code id="print.fmdsd_+3A_skewness.print">skewness.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the skewness coefficients of the variables.
</p>
</td></tr>
<tr><td><code id="print.fmdsd_+3A_kurtosis.print">kurtosis.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the kurtosis coefficients of the variables.
</p>
</td></tr>
<tr><td><code id="print.fmdsd_+3A_digits">digits</code></td>
<td>

<p>numeric. Number of significant digits for the display of numeric results.
</p>
</td></tr>
<tr><td><code id="print.fmdsd_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed the inertia explained by the <code>nb.values</code> (see <code><a href="#topic+fmdsd">fmdsd</a></code>) first coordinates and the <code>nb.factors</code> (see <code><a href="#topic+fmdsd">fmdsd</a></code>) coordinates of the densities.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+fmdsd">fmdsd</a>; <a href="#topic+plot.fmdsd">plot.fmdsd</a>; <a href="#topic+interpret.fmdsd">interpret.fmdsd</a>; <a href="base.html#topic+print">print</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
x &lt;- roses[,c("Sha","Den","Sym","rose")]
rosesfold &lt;- as.folder(x)
result &lt;- fmdsd(rosesfold)
print(result)
print(result, mean.print = TRUE)
</code></pre>

<hr>
<h2 id='print.foldermtg'>
Printing an object of class <code>foldermtg</code>
</h2><span id='topic+print.foldermtg'></span>

<h3>Description</h3>

<p><code>print</code> function, applied to an object of class <code>"foldermtg"</code>, prints an MTG (Multiscale Tree Graph) folder, as returned by <code><a href="#topic+foldermtg">foldermtg</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foldermtg'
print(x, classes = TRUE, description = FALSE, features = TRUE,
  topology = FALSE, coordinates = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.foldermtg_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>.
</p>
</td></tr>
<tr><td><code id="print.foldermtg_+3A_classes">classes</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), prints the data frame describing the classes (<code>CLASSES:</code> table in the MTG file).
</p>
</td></tr>
<tr><td><code id="print.foldermtg_+3A_description">description</code></td>
<td>

<p>logical. If <code>TRUE</code> (default: <code>FALSE</code>), prints the description data frame (<code>DESCRIPTION:</code> table in the MTG file).
</p>
</td></tr>
<tr><td><code id="print.foldermtg_+3A_features">features</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), prints the data frame of the features and their types (<code>FEATURES:</code> table in the MTG file).
</p>
</td></tr>
<tr><td><code id="print.foldermtg_+3A_topology">topology</code></td>
<td>

<p>logical. If <code>TRUE</code> (default: <code>FALSE</code>), prints the data frame of the plant topology.
</p>
</td></tr>
<tr><td><code id="print.foldermtg_+3A_coordinates">coordinates</code></td>
<td>

<p>logical. If <code>TRUE</code> (default: <code>FALSE</code>), prints the spatial coordinates of the entities of the plant.
</p>
</td></tr>
<tr><td><code id="print.foldermtg_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>classes</code>, <code>description</code> or <code>features</code> are <code>TRUE</code>, the corresponding data frames are displayed.
</p>
<p>If <code>topology = TRUE</code>, the plant structure is displayed; and if  <code>coordinates = TRUE</code>, the spatial coordinates are displayed.
</p>
<p>By default, the data frames containing the features on the vertices per class are printed.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>: reads a MTG file and creates an object of class <code>"foldermtg"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtgfile1 &lt;- system.file("extdata/plant1.mtg", package = "dad")
xmtg1 &lt;- read.mtg(mtgfile1)
print(xmtg1)
print(xmtg1, topology = TRUE)
print(xmtg1, coordinates = TRUE)

mtgfile2 &lt;- system.file("extdata/plant2.mtg", package = "dad")
xmtg2 &lt;- read.mtg(mtgfile2)
print(xmtg2)
print(xmtg2, topology = TRUE)
print(xmtg2, coordinates = TRUE)
</code></pre>

<hr>
<h2 id='print.foldert'>
Printing an object of class <code>foldert</code>
</h2><span id='topic+print.foldert'></span>

<h3>Description</h3>

<p><code>print</code> function, applied to an object of class <code>"foldert"</code>, prints a foldert, as returned by <code><a href="#topic+foldert">foldert</a></code> or <code><a href="#topic+as.foldert">as.foldert</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foldert'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.foldert_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+foldert">foldert</a></code>.
</p>
</td></tr>
<tr><td><code id="print.foldert_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The foldert is printed. In any data frame <code>x[[t]]</code> of this foldert, if a row is entirely <code>NA</code> (which means that the corresponding individual was not observed at time <code>t</code>), this row are not printed.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: object of class <code>foldert</code>.
<code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>: build an object of class <code>foldert</code> from a data frame.
<code><a href="#topic+as.foldert.array">as.foldert.array</a></code>: build an object of class <code>foldert</code> from a <code class="reqn">3d</code>-array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(floribundity)

ft &lt;- foldert(floribundity, cols.select = "union", rows.select = "union")
print(ft)
</code></pre>

<hr>
<h2 id='print.fpcad'>
Printing results of a functional PCA of probability densities
</h2><span id='topic+print.fpcad'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fpcad"</code>. Prints the numeric results returned by the <code><a href="#topic+fpcad">fpcad</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpcad'
print(x, mean.print = FALSE, var.print = FALSE,
  cor.print = FALSE, skewness.print = FALSE, kurtosis.print = FALSE,
  digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fpcad_+3A_x">x</code></td>
<td>

<p>object of class <code>"fpcad"</code>, returned by the <code><a href="#topic+fpcad">fpcad</a></code> function.
</p>
</td></tr>
<tr><td><code id="print.fpcad_+3A_mean.print">mean.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the means and standard deviations of the variables and the norm of the density.
</p>
</td></tr>
<tr><td><code id="print.fpcad_+3A_var.print">var.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the variances and covariances of the variables.
</p>
</td></tr>
<tr><td><code id="print.fpcad_+3A_cor.print">cor.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the correlations between the variables.
</p>
</td></tr>
<tr><td><code id="print.fpcad_+3A_skewness.print">skewness.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the skewness coefficients of the variables.
</p>
</td></tr>
<tr><td><code id="print.fpcad_+3A_kurtosis.print">kurtosis.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the kurtosis coefficients of the variables.
</p>
</td></tr>
<tr><td><code id="print.fpcad_+3A_digits">digits</code></td>
<td>

<p>numeric. Number of significant digits for the display of numeric results.
</p>
</td></tr>
<tr><td><code id="print.fpcad_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed the inertia explained by the <code>nb.values</code> (see <code><a href="#topic+fpcad">fpcad</a></code>) first principal components, the contributions, the qualities of representation of the densities along the <code>nb.factors</code> (see <code><a href="#topic+fpcad">fpcad</a></code>) first principal components, and the principal scores.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+fpcad">fpcad</a>; <a href="#topic+plot.fpcad">plot.fpcad</a>; <a href="#topic+interpret.fpcad">interpret.fpcad</a>; <a href="base.html#topic+print">print</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
rosefold &lt;- as.folder(roses[,c("Sha","Den","Sym","rose")])
result &lt;- fpcad(rosefold)
print(result)
print(result, mean.print = TRUE)
</code></pre>

<hr>
<h2 id='print.fpcat'>
Printing results of a functional PCA of probability densities among time
</h2><span id='topic+print.fpcat'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"fpcat"</code>. Prints the numeric results returned by the <code><a href="#topic+fpcat">fpcat</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpcat'
print(x, mean.print = FALSE, var.print = FALSE,
  cor.print = FALSE, skewness.print = FALSE, kurtosis.print = FALSE,
  digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fpcat_+3A_x">x</code></td>
<td>

<p>object of class <code>"fpcat"</code>, returned by the <code><a href="#topic+fpcat">fpcat</a></code> function.
</p>
</td></tr>
<tr><td><code id="print.fpcat_+3A_mean.print">mean.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each observation time the means and standard deviations of the variables and the norm of the density.
</p>
</td></tr>
<tr><td><code id="print.fpcat_+3A_var.print">var.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each observation time the variances and covariances of the variables.
</p>
</td></tr>
<tr><td><code id="print.fpcat_+3A_cor.print">cor.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each observation time the correlations between the variables.
</p>
</td></tr>
<tr><td><code id="print.fpcat_+3A_skewness.print">skewness.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each observation time the skewness coefficients of the variables.
</p>
</td></tr>
<tr><td><code id="print.fpcat_+3A_kurtosis.print">kurtosis.print</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each observation time the kurtosis coefficients of the variables.
</p>
</td></tr>
<tr><td><code id="print.fpcat_+3A_digits">digits</code></td>
<td>

<p>numeric. Number of significant digits for the display of numeric results.
</p>
</td></tr>
<tr><td><code id="print.fpcat_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed the vector of observation times (numeric, ordered factor or object of class <code>"Date"</code>), the inertia explained by the <code>nb.values</code> (see <code><a href="#topic+fpcat">fpcat</a></code>) first principal components, the contributions, the qualities of representation of the densities along the <code>nb.factors</code> (see <code><a href="#topic+fpcat">fpcat</a></code>) first principal components, and the principal scores.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Boumaza, R., Yousfi, S., Demotes-Mainard, S. (2015). Interpreting the principal component analysis of multivariate density functions. Communications in Statistics - Theory and Methods, 44 (16), 3321-3339.
</p>


<h3>See Also</h3>

<p><a href="#topic+fpcat">fpcat</a>; <a href="#topic+plot.fpcat">plot.fpcat</a>; <a href="base.html#topic+print">print</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times &lt;- as.Date(c("2017-03-01", "2017-04-01", "2017-05-01", "2017-06-01"))
x1 &lt;- data.frame(z1=rnorm(6,1,5), z2=rnorm(6,3,3))
x2 &lt;- data.frame(z1=rnorm(6,4,6), z2=rnorm(6,5,2))
x3 &lt;- data.frame(z1=rnorm(6,7,2), z2=rnorm(6,8,4))
x4 &lt;- data.frame(z1=rnorm(6,9,3), z2=rnorm(6,10,2))
ft &lt;- foldert(x1, x2, x3, x4, times = times, rows.select="intersect")
print(ft)
result &lt;- fpcat(ft)

print(result)
print(result, mean.print = TRUE, var.print = TRUE)
</code></pre>

<hr>
<h2 id='print.hclustdd'>
Printing results of a hierarchical clustering of discrete distributions
</h2><span id='topic+print.hclustdd'></span>

<h3>Description</h3>

<p><code>print</code> function, applied to an object of class <code>"hclustdd"</code>, prints numerical results of <a href="#topic+hclustdd">hclustdd</a> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hclustdd'
print(x, dist.print=FALSE, digits=2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hclustdd_+3A_x">x</code></td>
<td>

<p>object of class <code>"hclustdd"</code>, returned by <code><a href="#topic+hclustdd">hclustdd</a></code>.
</p>
</td></tr>
<tr><td><code id="print.hclustdd_+3A_dist.print">dist.print</code></td>
<td>

<p>logical. If <code>TRUE</code> (default: <code>FALSE</code>), prints the matrix of distances between the groups (densities).
</p>
</td></tr>
<tr><td><code id="print.hclustdd_+3A_digits">digits</code></td>
<td>

<p>numerical. Number of significant digits for the display of numerical results.
</p>
</td></tr>
<tr><td><code id="print.hclustdd_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>dist.print = TRUE</code>, the distances between groups are displayed.
</p>
<p>By default, the result of the clustering is printed. The display is the same as that of the <code><a href="stats.html#topic+print.hclust">print.hclust</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+hclustdd">hclustdd</a>; <a href="#topic+plot.hclustdd">plot.hclustdd</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dspg)
xl = dspg
result &lt;- hclustdd(xl)
print(result)
print(result, dist.print = TRUE)
</code></pre>

<hr>
<h2 id='print.mdsdd'>
Printing results of a multidimensional scaling analysis of discrete distributions
</h2><span id='topic+print.mdsdd'></span>

<h3>Description</h3>

<p>Applies to an object of class <code>"mdsdd"</code>. Prints the numeric results returned by the <code><a href="#topic+mdsdd">mdsdd</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdsdd'
print(x, joint = FALSE, margin1 = FALSE, margin2 = FALSE,
        association = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mdsdd_+3A_x">x</code></td>
<td>

<p>object of class <code>"mdsdd"</code>, returned by the <code><a href="#topic+mdsdd">mdsdd</a></code> function.
</p>
</td></tr>
<tr><td><code id="print.mdsdd_+3A_joint">joint</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the table of estimated joint distribution.
</p>
</td></tr>
<tr><td><code id="print.mdsdd_+3A_margin1">margin1</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the data frame of estimated marginal distributions.
</p>
</td></tr>
<tr><td><code id="print.mdsdd_+3A_margin2">margin2</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the data frame of the estimated marginal distributions per combination of two variables.
</p>
</td></tr>
<tr><td><code id="print.mdsdd_+3A_association">association</code></td>
<td>

<p>logical. If <code>TRUE</code>, prints for each group the matrix of the pairwise association measures of the variables.
</p>
</td></tr>
<tr><td><code id="print.mdsdd_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, are printed the inertia explained by the <code>nb.values</code> (see <code><a href="#topic+mdsdd">mdsdd</a></code>) first coordinates and the <code>nb.factors</code> (see <code><a href="#topic+mdsdd">mdsdd</a></code>) coordinates of the densities.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><a href="#topic+mdsdd">mdsdd</a>; <a href="#topic+plot.mdsdd">plot.mdsdd</a>; <a href="#topic+interpret.mdsdd">interpret.mdsdd</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># INSEE (France): Diploma x Socio professional group, seven years.
data(dspg)
xlista = dspg
a &lt;- mdsdd(xlista)
print(a, joint = TRUE, margin1 = TRUE, margin2 = TRUE) 
</code></pre>

<hr>
<h2 id='read.mtg'>
Read a MTG (Multiscale Tree Graph) file
</h2><span id='topic+read.mtg'></span><span id='topic+topology'></span>

<h3>Description</h3>

<p>Reads an MTG (Multiscale Tree Graph) file and returns an object of class <code>foldermtg</code>, that is a list of data frames (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.mtg(file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.mtg_+3A_file">file</code></td>
<td>

<p>character. Path of the MTG file.
</p>
</td></tr>
<tr><td><code id="read.mtg_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>print</code> methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recalling that a MTG file is a text file that can be opened with a spreadsheet (Excel, LibreOffice-Calc...).
Its 4 tables are:
</p>

<ul>
<li> <p><b>CLASSES:</b> In this table the first column, named <code>SYMBOL</code>, contains the symbolic character denoting each botanical entity (or vertex class, plant component...) used in the MTG (for example, P for plant, A for axis...). The second column, named <code>SCALE</code>, represents the scale at which each entity appears in the MTG (for example 1 for P, 2 for axis...).
</p>
</li>
<li> <p><b>DESCRIPTION:</b> This table displays the relations between the vertices: <code>+</code> (branching relationship) or <code>&lt;</code> (successor relationship).
</p>
</li>
<li> <p><b>FEATURES:</b> This table contains the features that can be attached to the vertices and their types: <code>INT</code> (integer), <code>REAL</code> (real numbers), <code>STRING</code> (character)...
</p>
</li>
<li> <p><b>MTG:</b> This table describes the plant topology, that is the vertices (one vertex per row) and their relations, the spatial coordinates of each vertex and the values taken by each vertex on the above listed features.
</p>
<p>Each vertex is labelled by its class, designating its botanical entity, and its index, designating its position among its immediate neighbours having the same scale. Each vertex label is preceded by <code>+</code> or <code>&lt;</code>, seen above, or by the symbol <code>/</code> (decomposition relationship) that means that the corresponding vertex is the first vertex of the decomposition of the vertex which precedes <code>/</code>.
</p>
<p>Notice that the column number of a vertex matches with its branching order. The vertices of scale <code>k</code> resulting from the decomposition of a vertex of scale <code>k-1</code>, named parent vertex, have the same order as that of the parent vertex. 
</p>
</li></ul>

<p>See the example below.
</p>


<h3>Value</h3>

<p><code>read.mtg</code> returns an object, say <code>x</code>, of class <code>fodermtg</code>, that is a list of at least 6 data frames:
</p>
<table>
<tr><td><code>classes</code></td>
<td>
<p>the table <code>CLASSES:</code> in the MTG file.</p>
</td></tr>
<tr><td><code>description</code></td>
<td>
<p>the table <code>DESCRIPTION:</code> in the MTG file.</p>
</td></tr>
<tr><td><code>features</code></td>
<td>
<p>the table <code>FEATURES:</code> in the MTG file.</p>
</td></tr>
<tr><td><code>topology</code></td>
<td>
<p>data frame containing the first columns of the <code>"MTG:"</code> table of the MTG file. If the maximum branching order of the elements of the MTG is <code class="reqn">p</code>, then <code>x$topology</code> has <code class="reqn">p</code> columns.
</p>
<p>If the <code>i</code>-th vertex appears on the <code>j</code>-th column, it means that its branching order is <code>j</code>, that is it belongs to a vertex of the <code>j</code>-th order.</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>
<p>data frame of the spatial coordinates of the entities. It has six columns: <code>XX</code>, <code>YY</code>, <code>ZZ</code> (cartesian coordinates), <code>AA</code>, <code>BB</code>, <code>CC</code> (angle coordinates). If there are no coordinates in the MTG file, this data frame has 0 row.</p>
</td></tr>
</table>
<p>The sixth and following elements are <code>nclass</code> data frames, <code>nclass</code> being the number of classes in the MTG file. Each data frame matches with a vertex class, such as <code>"P"</code> (plant), <code>"A"</code> (axes), <code>"M"</code> (metamers or phytomers), and contains the features on the corresponing vertices.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.foldermtg">print.foldermtg</a></code>
</p>
<p><code><a href="#topic+mtgorder">mtgorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtgfile1 &lt;- system.file("extdata/plant1.mtg", package = "dad")
x1 &lt;- read.mtg(mtgfile1)
print(x1)

mtgfile2 &lt;- system.file("extdata/plant2.mtg", package = "dad")
x2 &lt;- read.mtg(mtgfile2)
print(x2)
</code></pre>

<hr>
<h2 id='rmcol.folder'>
Remove columns in all elements of a folder
</h2><span id='topic+rmcol.folder'></span>

<h3>Description</h3>

<p>Remove some columns in all data frames of a folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmcol.folder(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmcol.folder_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="rmcol.folder_+3A_name">name</code></td>
<td>

<p>character vector. The names of the columns to be removed in each data frame of the folder.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A folder with the same number of elements as <code>object</code>. Its <code class="reqn">k^{th}</code> element is a data frame, and its columns are the columns of <code>object[[k]]</code>, except those given by <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>: object of class <code>folder</code>.
</p>
<p><code><a href="#topic+getcol.folder">getcol.folder</a></code>: select columns in all elements of a folder.
</p>
<p><code><a href="#topic+getrow.folder">getrow.folder</a></code>: select rows in all elements of a folder.
</p>
<p><code><a href="#topic+rmrow.folder">rmrow.folder</a></code>: remove rows in all elements of a folder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

iris.fold &lt;- as.folder(iris, "Species")
rmcol.folder(iris.fold, c("Petal.Length", "Petal.Width"))
</code></pre>

<hr>
<h2 id='rmcol.foldert'>
Remove cols in all elements of a foldert
</h2><span id='topic+rmcol.foldert'></span>

<h3>Description</h3>

<p>Remove some columns in all data frames of a foldert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmcol.foldert(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmcol.foldert_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+foldert">foldert</a></code> that is a list of data frames with the same column names, each of them corresponding to a time of observation.
</p>
</td></tr>
<tr><td><code id="rmcol.foldert_+3A_name">name</code></td>
<td>

<p>character vector. The names of the columns to be removed in each data frame of the foldert.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A foldert with the same number of elements as <code>object</code>. Its <code class="reqn">k^{th}</code> element is a data frame, and its columns are the columns of <code>object[[k]]</code>, except those given by <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: object of class <code>foldert</code>.
</p>
<p><code><a href="#topic+getcol.foldert">getcol.foldert</a></code>: select columns in all elements of a foldert.
</p>
<p><code><a href="#topic+getrow.foldert">getrow.foldert</a></code>: get rows in all elements of a foldert.
</p>
<p><code><a href="#topic+rmrow.foldert">rmrow.foldert</a></code>: remove rows in all elements of a foldert.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(floribundity)

ft0 &lt;- foldert(floribundity, cols.select = "union", rows.select = "union")
ft0
rmcol.foldert(ft0, c("area"))
</code></pre>

<hr>
<h2 id='rmrow.folder'>
Remove rows in all elements of a folder
</h2><span id='topic+rmrow.folder'></span>

<h3>Description</h3>

<p>Remove some rows in all data frames of a folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmrow.folder(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmrow.folder_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="rmrow.folder_+3A_name">name</code></td>
<td>

<p>character vector. The names of the rows to be removed in each data frame of the folder.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A folder with the same number of elements as <code>object</code>. Its <code class="reqn">k^{th}</code> element is a data frame, and its rows are the rows of <code>object[[k]]</code>, except those given by <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>: object of class <code>folder</code>.
</p>
<p><code><a href="#topic+getrow.folder">getrow.folder</a></code>: select rows in all elements of a folder.
</p>
<p><code><a href="#topic+getcol.folder">getcol.folder</a></code>: select columns in all elements of a folder.
</p>
<p><code><a href="#topic+rmcol.folder">rmcol.folder</a></code>: remove columns in all elements of a folder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

iris.fold &lt;- as.folder(iris, "Species")
rmrow.folder(iris.fold, as.character(seq(1, 150, by = 2)))
</code></pre>

<hr>
<h2 id='rmrow.foldert'>
Remove rows in all elements of a foldert
</h2><span id='topic+rmrow.foldert'></span>

<h3>Description</h3>

<p>Remove some rows in all data frames of a foldert.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmrow.foldert(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmrow.foldert_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+foldert">foldert</a></code> that is a list of data frames with the same column names, each of them corresponding to a time of observation.
</p>
</td></tr>
<tr><td><code id="rmrow.foldert_+3A_name">name</code></td>
<td>

<p>character vector. The names of the rows to be removed in each data frame of the foldert.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A foldert with the same number of elements as <code>object</code>. Its <code class="reqn">k^{th}</code> element is a data frame, and its rows are the rows of <code>object[[k]]</code>, except those given by <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: object of class <code>foldert</code>.
</p>
<p><code><a href="#topic+getrow.foldert">getrow.foldert</a></code>: select rows in all elements of a foldert.
</p>
<p><code><a href="#topic+getcol.foldert">getcol.foldert</a></code>: select columns in all elements of a foldert.
</p>
<p><code><a href="#topic+rmcol.foldert">rmcol.foldert</a></code>: remove columns in all elements of a foldert.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(floribundity)

ft0 &lt;- foldert(floribundity, cols.select = "union", rows.select = "union")
ft0
rmrow.foldert(ft0, c("rose", c("16", "51")))
</code></pre>

<hr>
<h2 id='roseflowers'>
Rose flowers
</h2><span id='topic+roseflowers'></span>

<h3>Description</h3>

<p>The data are extracted from measures on roses from an agronomic experiment in a greenhouse and outdoors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(roseflowers)</code></pre>


<h3>Format</h3>

<p><code>roseflowers</code> is a list of two data frames:
</p>

<ul>
<li><p><code>roseflowers$variety</code>: this first data frame has 5 rows and 3 columns (factors) named
<code>place</code>, <code>rose</code> and <code>variety</code>.
</p>
</li>
<li><p><code>roseflowers$flower</code>: this second data frame has 11 cases and 5 columns named <code>numflower</code> (the order number of the flower), <code>rose</code>, <code>diameter</code> and <code>height</code> (the diameter and height of the flower), and <code>nleaves</code> (the number of the leaves of the axis).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(roseflowers)
summary(roseflowers$variety)
summary(roseflowers$flower)
</code></pre>

<hr>
<h2 id='roseleaves'>
Rose leaves
</h2><span id='topic+roseleaves'></span>

<h3>Description</h3>

<p>The data are extracted from measures on roses from an agronomic experiment in a greenhouse and outdoors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("roseleaves")</code></pre>


<h3>Format</h3>

<p><code>roseleaves</code> is a list of four data frames:
</p>

<ul>
<li><p><code>roseflowers$rose</code>: data frame with 7 rows and 3 columns (factors) named
<code>rose</code>, <code>place</code> and <code>variety</code>.
</p>
</li>
<li><p><code>roseflowers$stem</code>: data frame with 12 rows and 5 columns named <code>rose</code>, <code>stem</code>, <code>date</code>, <code>order</code> (the ramification order of the stem) and <code>nleaves</code> (the number of leaves of the stem).
</p>
</li>
<li><p><code>roseflowers$leaf</code>: data frame with 35 rows and 5 columns named <code>stem</code>, <code>leaf</code>, <code>rank</code> (the rank of the leaf on the stem), <code>nleaflets</code> and <code>lrachis</code> (the number of leaflets of the leaf and the length of its rachis).
</p>
</li>
<li><p><code>roseflowers$leaflet</code>: data frame with 221 rows and 4 columns named <code>leaf</code>, <code>leaflet</code>, <code>lleaflet</code> and <code>wleaflet</code> (the length and width of the leaflet).
</p>
</li></ul>

<p>Each row (rose) in <code>roseleaves$rose</code> pertains to several rows (stems) in <code>roseleaves$stem</code>.
</p>
<p>Each row (stem) in <code>roseleaves$rose</code> pertains to several rows (leaves) in <code>roseleaves$leaf</code>.
</p>
<p>Each row (leaf) in <code>roseleaves$rose</code> pertains to several rows (leaflets) in <code>roseleaves$leaflet</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roseleaves)
summary(roseleaves$rose)
summary(roseleaves$stem)
summary(roseleaves$leaf)
summary(roseleaves$leaflet)
</code></pre>

<hr>
<h2 id='rosephytomer'>
Rose leaf and internode dynamics
</h2><span id='topic+rosephytomer'></span>

<h3>Description</h3>

<p>These data are extracted from measures on rosebushes during a study on leaf and internode expansion dynamics.
For four rosebushes, on each metamer, the length of the terminal leaflet and the length of the internode were measured on several days, from the 24 april 2010 to the 19 july 2010.
</p>
<p>The metamers which have no leaflets are omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("rosephytomer")</code></pre>


<h3>Format</h3>

<p>A data frame with 643 rows (4 plants, 7, 8 or 9 metamers per plant, 37 days of observation) and 6 columns:
</p>

<dl>
<dt><code>date</code></dt><dd><p>a POSIXct</p>
</dd>
<dt><code>nplant</code></dt><dd><p>a factor with levels <code>113</code> <code>114</code> <code>118</code> <code>121</code>. Numbers of the plants.</p>
</dd>
<dt><code>rank</code></dt><dd><p>numeric. Rank of the metamer on the stem.</p>
</dd>
<dt><code>lleaflet</code>, <code>linternode</code></dt><dd><p>numeric. Length of the terminal leaflet, length of the internode.</p>
</dd>
<dt><code>phytomer</code></dt><dd><p>factor. Identifiers of the metamers.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Demotes-Mainard, S., Bertheloot, J., Boumaza, R., Huché-Thélier, L., Guéritaine, G., Guérin, V. and Andrieu, B. (2013). Rose bush leaf and internode expansion dynamics: analysis and development of a model capturing interplant variability. Frontiers in Plant Science 4: 418. Doi: 10.3389/fpls.2013.00418
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rosephytomer)
as.foldert(rosephytomer, method = 1, ind = "phytomer", timecol = "date", same.rows = TRUE)
</code></pre>

<hr>
<h2 id='roses'>Roses data     
</h2><span id='topic+roses'></span>

<h3>Description</h3>

<p>Sensory data characterising the visual aspect of 10 rosebushes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(roses)</code></pre>


<h3>Format</h3>

<p><code>roses</code> is a data frame of sensory data with 420 rows (10 products, 14 assessors, 3 sessions) and 17 columns. The first 16 columns are numeric and correspond to 16 visual characteristics of rosebushes. The last column is a factor giving the name of the corresponding rosebush.
</p>

<ul>
<li><p><code>Sha: </code> top sided shape
</p>
</li>
<li><p><code>Den: </code> foliage thickness
</p>
</li>
<li><p><code>Sym: </code> plant symmetry
</p>
</li>
<li><p><code>Vgr: </code> stem vigour
</p>
</li>
<li><p><code>Qrm: </code> quantity of stems
</p>
</li>
<li><p><code>Htr: </code> branching level
</p>
</li>
<li><p><code>Qfl: </code> quantity of flowers
</p>
</li>
<li><p><code>Efl: </code> staggering of flowering
</p>
</li>
<li><p><code>Mvfl: </code> flower enhancement
</p>
</li>
<li><p><code>Difl: </code> flower size
</p>
</li>
<li><p><code>Qfr: </code> quantity of faded flowers/fruits
</p>
</li>
<li><p><code>Qbt: </code> quantity of floral buds
</p>
</li>
<li><p><code>Defl: </code> density of flower petals
</p>
</li>
<li><p><code>Vcfl: </code> intensity of flower colour
</p>
</li>
<li><p><code>Tfe: </code> leaf size
</p>
</li>
<li><p><code>Vfe: </code> darkness of leaf colour
</p>
</li>
<li><p><code>rose: </code> factor with 10 levels: <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, 
<code>E</code>, <code>F</code>, <code>G</code>, <code>H</code>, <code>I</code> and <code>J</code>
</p>
</li></ul>



<h3>Source</h3>

<p>Boumaza, R., Huché-Thélier, L., Demotes-Mainard, S., Le Coz, E., Leduc, N., Pelleschi-Travier, S., 
Qannari, E.M., Sakr, S., Santagostini, P., Symoneaux, R., Guérin, V. (2010). Sensory profile 
and preference analysis in ornamental horticulture: The case of rosebush. Food Quality and Preference,
21, 987-997. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(roses)
summary(roses)
</code></pre>

<hr>
<h2 id='skewness.folder'>
Skewness coefficients of a folder of data sets
</h2><span id='topic+skewness.folder'></span>

<h3>Description</h3>

<p>Computes the skewness coefficient by column of the elements of an object of class <code>folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness.folder(x, na.rm = FALSE, type = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewness.folder_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="skewness.folder_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. Should missing values be omitted from the calculations? (see <code><a href="e1071.html#topic+skewness">skewness</a></code>)
</p>
</td></tr>
<tr><td><code id="skewness.folder_+3A_type">type</code></td>
<td>

<p>an integer between 1 and 3 (see <code><a href="e1071.html#topic+skewness">skewness</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses <code><a href="e1071.html#topic+skewness">skewness</a></code> to compute the mean by numeric column of each element of the folder. If some columns of the data frames are not numeric, there is a warning, and the means are computed on the numeric columns only.
</p>


<h3>Value</h3>

<p>A list whose elements are the skewness coefficients by column of the elements of the folder.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code> to create an object is of class <code>folder</code>.
<code><a href="#topic+mean.folder">mean.folder</a></code>, <code><a href="#topic+var.folder">var.folder</a></code>, <code><a href="#topic+cor.folder">cor.folder</a></code>, <code><a href="#topic+kurtosis.folder">kurtosis.folder</a></code> for other statistics for <code>folder</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: iris (Fisher)               
data(iris)
iris.fold &lt;- as.folder(iris, "Species")
iris.skewness &lt;- skewness.folder(iris.fold)
print(iris.skewness)

# Second example: roses
data(roses)
roses.fold &lt;- as.folder(roses, "rose")
roses.skewness &lt;- skewness.folder(roses.fold)
print(roses.skewness)
</code></pre>

<hr>
<h2 id='sqrtmatrix'>
Square root of a symmetric, positive semi-definite matrix
</h2><span id='topic+sqrtmatrix'></span>

<h3>Description</h3>

<p>Calculation of the square root of a positive semi-definite matrix (see Details for the definition of such a matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrtmatrix(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrtmatrix_+3A_mat">mat</code></td>
<td>

<p>numeric matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix <code>mat</code> must be symmetric and positive semi-definite. Otherwise, there is an error.
</p>
<p>The square root of the matrix <code>mat</code> is the positive semi-definite matrix <code>M</code> such as <code>t(M) %*% M = mat</code>.
Do not confuse with <code>sqrt(mat)</code>, which returns the square root of the elements of <code>mat</code>.
</p>
<p>The computation is based on the diagonalisation of <code>mat</code>. The eigenvalues smaller than 10^-16 are identified as null values.
</p>


<h3>Value</h3>

<p>Matrix: the square root of the matrix <code>mat</code>.                                   
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    M2 &lt;- matrix(c(5, 4, 4, 5), nrow = 2)
    M &lt;- sqrtmatrix(M2)
    M
</code></pre>

<hr>
<h2 id='summary.folder'>
Summarize a folder
</h2><span id='topic+summary.folder'></span>

<h3>Description</h3>

<p>Summarize an object of class <code>folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'folder'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.folder_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="summary.folder_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, each element of it contains the summary of the corresponding element of <code>object</code>.
This list has an attribute <code>attr(, "same.rows")</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code>: object of class <code>folder</code>.
<code><a href="#topic+as.folder.data.frame">as.folder.data.frame</a></code>: build an object of class <code>folder</code> from a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

iris.fold &lt;- as.folder(iris, "Species")
summary(iris.fold)
</code></pre>

<hr>
<h2 id='summary.folderh'>
Summarize a folderh
</h2><span id='topic+summary.folderh'></span>

<h3>Description</h3>

<p>Summarize an object of class <code>folderh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'folderh'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.folderh_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+folderh">folderh</a></code> that is a list of data frames.
</p>
</td></tr>
<tr><td><code id="summary.folderh_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, each element of it containing the summary of the corresponding element of <code>object</code>.
This list has an attribute <code>attr(, "keys")</code> (see <code><a href="#topic+folderh">folderh</a></code>).
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folderh">folderh</a></code>: object of class <code>folderh</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First example
mtgfile &lt;- system.file("extdata/plant1.mtg", package = "dad")
x &lt;- read.mtg(mtgfile)
fh1 &lt;- as.folderh(x, classes = c("P", "A", "M"))
summary(fh1)

# Second example
data(roseleaves)
roses &lt;- roseleaves$rose
stems &lt;- roseleaves$stem
leaves &lt;- roseleaves$leaf
leaflets &lt;- roseleaves$leaflet
fh2 &lt;- folderh(roses, "rose", stems, "stem", leaves, "leaf", leaflets)
summary(fh2)
</code></pre>

<hr>
<h2 id='summary.foldermtg'>
Summary of an object of class <code>foldermtg</code>
</h2><span id='topic+summary.foldermtg'></span>

<h3>Description</h3>

<p>Summary method for S3 class <code>foldermtg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foldermtg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.foldermtg_+3A_object">object</code></td>
<td>

<p>an object of class <code><a href="#topic+foldermtg">foldermtg</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.foldermtg_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>summary</code> methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summary of the data frames containing the vertices of each class and the values of the features on these vertices.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Pradal, C., Godin, C. and Cokelaer, T. (2023). <a href="https://mtg.readthedocs.io/en/latest/user/index.html">MTG user guide</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.mtg">read.mtg</a></code>: reads a MTG file and creates an object of class <code>"foldermtg"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtgfile1 &lt;- system.file("extdata/plant1.mtg", package = "dad")
x1 &lt;- read.mtg(mtgfile1)
summary(x1)

mtgfile2 &lt;- system.file("extdata/plant2.mtg", package = "dad")
x2 &lt;- read.mtg(mtgfile2)
summary(x2)
</code></pre>

<hr>
<h2 id='summary.foldert'>
Summarize a foldert
</h2><span id='topic+summary.foldert'></span>

<h3>Description</h3>

<p>Summarize an object of class <code>foldert</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foldert'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.foldert_+3A_object">object</code></td>
<td>

<p>object of class <code><a href="#topic+foldert">foldert</a></code> that is a list of data frames organised according to time.
</p>
</td></tr>
<tr><td><code id="summary.foldert_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, each element of it contains the summary of the corresponding element of <code>object</code>.
This list has two attributes <code>attr(, "times")</code> and <code>attr(, "same.rows")</code>.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foldert">foldert</a></code>: object of class <code>foldert</code>.
<code><a href="#topic+as.foldert.data.frame">as.foldert.data.frame</a></code>: build an object of class <code>foldert</code> from a data frame.
<code><a href="#topic+as.foldert.array">as.foldert.array</a></code>: build an object of class <code>foldert</code> from a <code class="reqn">3d</code>-array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1st example
data(floribundity)
ftflor &lt;- foldert(floribundity, cols.select = "union", rows.select = "union")
summary(ftflor)
</code></pre>

<hr>
<h2 id='var.folder'>
Variance matrices of a folder of data sets
</h2><span id='topic+var.folder'></span>

<h3>Description</h3>

<p>Computes the variance matrices of the elements of an object of class <code>folder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.folder(x, na.rm = FALSE, use = "everything")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.folder_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="#topic+folder">folder</a></code> that is a list of data frames with the same column names.
</p>
</td></tr>
<tr><td><code id="var.folder_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. Should missing values be removed? (see <code><a href="stats.html#topic+var">var</a></code>)
</p>
</td></tr>
<tr><td><code id="var.folder_+3A_use">use</code></td>
<td>

<p>an optional character string giving a method for computing covariances in the presence of missing values. This must be (an abbreviation of) one of the strings &quot;everything&quot;, &quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;na.or.complete&quot;, or &quot;pairwise.complete.obs&quot; (see <code><a href="stats.html#topic+var">var</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses <code><a href="stats.html#topic+var">var</a></code> to compute the variance matrix of the numeric columns of each element of the folder. If some columns of the data frames are not numeric, there is a warning, and the variances are computed on the numeric columns only.
</p>


<h3>Value</h3>

<p>A list whose elements are the variance matrices of the elements of the folder.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+folder">folder</a></code> to create an object is of class <code>folder</code>.
<code><a href="#topic+mean.folder">mean.folder</a></code>, <code><a href="#topic+cor.folder">cor.folder</a></code>, <code><a href="#topic+skewness.folder">skewness.folder</a></code>, <code><a href="#topic+kurtosis.folder">kurtosis.folder</a></code> for other statistics for <code>folder</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First example: iris (Fisher)               
data(iris)
iris.fold &lt;- as.folder(iris, "Species")
iris.vars &lt;- var.folder(iris.fold)
print(iris.vars)

# Second example: roses
data(roses)
roses.fold &lt;- as.folder(roses, "rose")
roses.vars &lt;- var.folder(roses.fold)
print(roses.vars)
</code></pre>

<hr>
<h2 id='varietyleaves'>
Rose variety leaves
</h2><span id='topic+varietyleaves'></span>

<h3>Description</h3>

<p>The data are extracted from measures on roses from an agronomic experiment in a greenhouse and outdoors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("varietyleaves")</code></pre>


<h3>Format</h3>

<p><code>varietyleaves</code> is an object of class <code>"folderh"</code>, that is a list of two data frames:
</p>

<ul>
<li><p><code>varietyleaves$variety</code>: data frame with 31 rows and 2 columns (factors) named
<code>rose</code> and <code>variety</code>.
</p>
</li>
<li><p><code>varietyleaves$leaves</code>: data frame with 581 rows and 5 columns named <code>rose</code>, <code>nleaflet</code> (number of leaflets), <code>lrachis</code> (length of the rachis), <code>lleaflet</code> (length of the principal leaflet) and <code>wleaflet</code> (width of the principal leaflet).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(varietyleaves)
summary(varietyleaves)
</code></pre>

<hr>
<h2 id='wasserstein'>
2-Wasserstein distance between Gaussian densities
</h2><span id='topic+wasserstein'></span>

<h3>Description</h3>

<p>The 2-Wasserstein distance between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein(x1, x2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_+3A_x1">x1</code></td>
<td>

<p>a matrix or data frame of <code class="reqn">n_1</code> rows (observations) and <code class="reqn">p</code> columns (variables) (can also be a tibble) or a vector of length <code class="reqn">n_1</code>.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_x2">x2</code></td>
<td>

<p>matrix or data frame (or tibble) of <code class="reqn">n_2</code> rows and <code class="reqn">p</code> columns or vector of length <code class="reqn">n_2</code>.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate (multivariate case) or if the variances are not zero (univariate case).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wasserstein distance between the two Gaussian densities is computed by using the <code><a href="#topic+wassersteinpar">wassersteinpar</a></code> function and the density parameters estimated from samples.
</p>


<h3>Value</h3>

<p>Returns the 2-<code class="reqn">Wasserstein</code> distance between the two probability densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one smoothing bandwidth matrix is degenerate, the result returned can not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Peterson, A., Mueller, H.G. (2016). Functional Data Analysis for Density Functions by Transformation to a Hilbert Space. The annals of Statistics, 44 (1), 183-218. DOI: 10.1214/15-AOS1363
</p>
<p>Dowson, D.C., Ladau, B.V. (1982). The Fréchet Distance between Multivariate Normal Distributions. Journal of Multivariate Analysis, 12, 450-455.
</p>


<h3>See Also</h3>

<p><a href="#topic+wassersteinpar">wassersteinpar</a>: 2-Wasserstein distance between Gaussian densities, given their parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
m1 &lt;- c(0,0)
v1 &lt;- matrix(c(1,0,0,1),ncol = 2) 
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(4,1,1,9),ncol = 2)
x1 &lt;- mvrnorm(n = 3,mu = m1,Sigma = v1)
x2 &lt;- mvrnorm(n = 5, mu = m2, Sigma = v2)
wasserstein(x1, x2)
</code></pre>

<hr>
<h2 id='wassersteinpar'>
2-Wasserstein distance between Gaussian densities given their parameters
</h2><span id='topic+wassersteinpar'></span>

<h3>Description</h3>

<p>The 2-Wasserstein distance between two multivariate (<code class="reqn">p &gt; 1</code>) or univariate (<code class="reqn">p = 1</code>) Gaussian densities given their parameters (mean vectors and covariance matrices if the densities are multivariate, or means and variances if univariate) (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wassersteinpar(mean1, var1, mean2, var2, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wassersteinpar_+3A_mean1">mean1</code></td>
<td>

<p><code class="reqn">p</code>-length numeric vector: the mean of the first Gaussian density.
</p>
</td></tr>
<tr><td><code id="wassersteinpar_+3A_var1">var1</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric numeric matrix (<code class="reqn">p</code> &gt; 1) or numeric (<code class="reqn">p</code> = 1): the covariance matrix (<code class="reqn">p</code> &gt; 1) or the variance (<code class="reqn">p</code> = 1) of the first Gaussian density.
</p>
</td></tr>
<tr><td><code id="wassersteinpar_+3A_mean2">mean2</code></td>
<td>

<p><code class="reqn">p</code>-length numeric vector: the mean of the second Gaussian density.
</p>
</td></tr>
<tr><td><code id="wassersteinpar_+3A_var2">var2</code></td>
<td>

<p><code class="reqn">p</code> x <code class="reqn">p</code> symmetric numeric matrix (<code class="reqn">p</code> &gt; 1) or numeric (<code class="reqn">p</code> = 1): the covariance matrix (<code class="reqn">p</code> &gt; 1) or the variance (<code class="reqn">p</code> = 1) of the second Gaussian density.
</p>
</td></tr>
<tr><td><code id="wassersteinpar_+3A_check">check</code></td>
<td>

<p>logical. When <code>TRUE</code> (the default is <code>FALSE</code>) the function checks if the covariance matrices are not degenerate (multivariate case) or if the variances are not zero (univariate case).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean vectors (<code class="reqn">m1</code> and <code class="reqn">m2</code>) and variance matrices (<code class="reqn">v1</code> and <code class="reqn">v2</code>) given as arguments (<code>mean1</code>, <code>mean2</code>, <code>var1</code> and <code>var2</code>) are used to compute the 2-Wasserstein distance between the two Gaussian densities, equal to: 
</p>
<p style="text-align: center;"><code class="reqn">(||m1-m2||_2^2 + trace((v1+v2) - 2*(v2^{1/2} v1 v2^{1/2})^{1/2}))^{1/2}</code>
</p>

<p>If <code class="reqn">p = 1</code>:
</p>
<p style="text-align: center;"><code class="reqn">((m1-m2)^2 + v1 + v2 - 2*(v1*v2)^{1/2})^{1/2}</code>
</p>



<h3>Value</h3>

<p>The 2-Wasserstein distance between two Gaussian densities.
</p>
<p>Be careful! If <code>check = FALSE</code> and one covariance matrix is degenerated (multivariate case) or one variance is zero (univariate case), the result returned must not be considered.
</p>


<h3>Author(s)</h3>

<p>Rachid Boumaza,  Pierre Santagostini, Smail Yousfi, Gilles Hunault, Sabine Demotes-Mainard
</p>


<h3>References</h3>

<p>Peterson, A., Mueller, H.G (2016). Functional Data Analysis for Density Functions by Transformation to a Hilbert Space. The annals of Statistics, 44 (1), 183-218. DOI: 10.1214/15-AOS1363
</p>
<p>Dowson, D.C., Ladau, B.V. (1982). The Fréchet Distance between Multivariate Normal Distributions. Journal of Multivariate Analysis, 12, 450-455.
</p>


<h3>See Also</h3>

<p><a href="#topic+wasserstein">wasserstein</a>: 2-Wasserstein distance between Gaussian densities estimated from samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- c(1,1)
v1 &lt;- matrix(c(4,1,1,9),ncol = 2)
m2 &lt;- c(0,1)
v2 &lt;- matrix(c(1,0,0,1),ncol = 2)
wassersteinpar(m1,v1,m2,v2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
