<!DOCTYPE html><html lang="en"><head><title>Help for package spTimer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spTimer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spTimer-package'>
<p>Spatio-Temporal Bayesian Modelling using R</p></a></li>
<li><a href='#confint.spT'><p>Credible intervals for model parameters.</p></a></li>
<li><a href='#fitted.spT'><p>Extract model fitted values.</p></a></li>
<li><a href='#NYdata'><p>Observations of ozone concentration levels, maximum temperature and wind speed.</p></a></li>
<li><a href='#plot.spT'><p>Plots for spTimer output.</p></a></li>
<li><a href='#predict.spT'><p>Spatial and temporal predictions for the spatio-temporal models.</p></a></li>
<li><a href='#spT.decay'><p>Choice for sampling spatial decay parameter <code class="reqn">\phi</code>.</p></a></li>
<li><a href='#spT.geodist'><p>Geodetic/geodesic Distance</p></a></li>
<li><a href='#spT.Gibbs'><p>MCMC sampling for the spatio-temporal models.</p></a></li>
<li><a href='#spT.grid.coords'><p>Grid Coordinates</p></a></li>
<li><a href='#spT.initials'><p>Initial values for the spatio-temporal models.</p></a></li>
<li><a href='#spT.pCOVER'><p>Nominal Coverage</p></a></li>
<li><a href='#spT.priors'><p>Priors for the spatio-temporal models.</p></a></li>
<li><a href='#spT.segment.plot'><p>Utility plot for prediction/forecast</p></a></li>
<li><a href='#spT.subset'><p>Select a subset of Spatial data.</p></a></li>
<li><a href='#spT.time'><p>Timer series information.</p></a></li>
<li><a href='#spT.validation'><p>Validation Commands</p></a></li>
<li><a href='#spT.validation2'><p>Validation Commands</p></a></li>
<li><a href='#spTimer-internal'><p>Service functions and some undocumented functions for the spTimer library</p></a></li>
<li><a href='#summary.spT'><p>Summary statistics of the parameters.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatio-Temporal Bayesian Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>3.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-05</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.4.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits, spatially predicts and temporally forecasts large amounts of space-time data using  [1] Bayesian Gaussian Process (GP) Models, [2] Bayesian Auto-Regressive (AR) Models, and [3] Bayesian Gaussian Predictive Processes (GPP) based AR Models for spatio-temporal big-n problems. Bakar and Sahu (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v063.i15">doi:10.18637/jss.v063.i15</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, sp, spacetime, extraDistr, grDevices, graphics, stats,
utils</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-08 08:33:08 UTC; kbak4671</td>
</tr>
<tr>
<td>Author:</td>
<td>K. Shuvo Bakar <a href="https://orcid.org/0000-0003-3215-4496"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sujit K. Sahu <a href="https://orcid.org/0000-0003-2315-3598"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>K. Shuvo Bakar &lt;shuvo.bakar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-08 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spTimer-package'>
Spatio-Temporal Bayesian Modelling using R
</h2><span id='topic+spTimer-package'></span><span id='topic+spTimer'></span>

<h3>Description</h3>

<p>This package uses different hierarchical Bayesian spatio-temporal modelling strategies, namely: <br />
(1) Gaussian processes (GP) models, <br />
(2) Autoregressive (AR) models, <br />
(3) Gaussian predictive processes (GPP) based autoregressive models for big-n problem.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> spTimer</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The back-end code of this package is built under c language.<br />
Main functions used: <br />
<code>&gt; <a href="#topic+spT.Gibbs">spT.Gibbs</a></code> <br />
<code>&gt; <a href="#topic+predict.spT">predict.spT</a></code> <br />
Some other important functions: <br />
<code>&gt; <a href="#topic+spT.priors">spT.priors</a></code> <br />
<code>&gt; <a href="#topic+spT.initials">spT.initials</a></code> <br />
<code>&gt; <a href="#topic+spT.decay">spT.decay</a></code> <br />
<code>&gt; <a href="#topic+spT.time">spT.time</a></code> <br />
Data descriptions: <br />
<code>&gt; <a href="#topic+NYdata">NYdata</a></code> <br />
</p>


<h3>Author(s)</h3>

<p>K.S. Bakar &amp; S.K. Sahu <br />
Maintainer: K.S. Bakar &lt;shuvo.bakar@gmail.com&gt;
</p>


<h3>References</h3>

<p>1. Bakar, K. S., &amp; Sahu, S. K. (2015). sptimer: Spatio-temporal bayesian modelling using r. Journal of Statistical Software, 63(15), 1-32. <br />
2. Sahu, S.K. &amp; Bakar, K.S. (2012). Hierarchical Bayesian Autoregressive Models for Large Space Time Data with Applications to Ozone Concentration Modelling. Applied Stochastic Models in Business and Industry, 28, 395-415.<br />
3. Sahu, S.K., Gelfand, A.E., &amp; Holland, D.M. (2007). High-Resolution Space-Time Ozone Modelling for Assessing Trends. Journal of the American Statistical Association, 102, 1221-1234.<br />
4. Bakar, K.S. (2012). Bayesian Analysis of Daily Maximum Ozone Levels. PhD Thesis, University of Southampton, Southampton, United Kingdom.
</p>


<h3>See Also</h3>

<p>Packages 'spacetime', 'forecast'; 'spBayes'; 'maps'; 'MBA'; 'coda'; website: <code>http://www.r-project.org/</code>.
</p>

<hr>
<h2 id='confint.spT'>Credible intervals for model parameters.</h2><span id='topic+confint.spT'></span>

<h3>Description</h3>

<p>This function is used to obtain credible intervals for model parameters from the MCMC samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spT'
confint(object, parm, level = 0.95, ...)

## 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.spT_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;spT&quot;.</p>
</td></tr>
<tr><td><code id="confint.spT_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given credible intervals, a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.spT_+3A_level">level</code></td>
<td>
<p>The required credible interval.</p>
</td></tr>
<tr><td><code id="confint.spT_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##

confint(out) # where out is the output from spT class

##

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted.spT'>Extract model fitted values.</h2><span id='topic+fitted.spT'></span>

<h3>Description</h3>

<p>Extract average fitted values and corresponding standard deviations from model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spT'
fitted(object, ...)

## 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.spT_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;spT&quot;.</p>
</td></tr>
<tr><td><code id="fitted.spT_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Mean</code></td>
<td>
<p>Fitted mean values obtained from the MCMC samples.</p>
</td></tr>
<tr><td><code>SD</code></td>
<td>
<p>Corresponding standard deviations.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##

fitted(out) # where out is the output from spT class

##

## End(Not run)
</code></pre>

<hr>
<h2 id='NYdata'>Observations of ozone concentration levels, maximum temperature and wind speed.</h2><span id='topic+NYdata'></span><span id='topic+NYgrid'></span>

<h3>Description</h3>

<p>This data set contains values of daily 
8-hour maximum average ozone concentrations (parts per billion (ppb)),
maximum  temperature (in degree Celsius),
wind speed (knots), and 
relative humidity, 
obtained from 28 monitoring sites of New York, USA.
</p>
<p>NYgrid: This dataset contains total 6200 rows for 62 days of observations for 10x10 = 100 grid points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NYdata</code></pre>


<h3>Format</h3>

<p>Columns for NYdata: each contains 1798 observations. 
</p>

<ul>
<li><p>   1st col = Site index (s.index), 
</p>
</li>
<li><p>   2nd col = Longitude,
</p>
</li>
<li><p>   3rd col = Latitude,  
</p>
</li>
<li><p>	4th col = Year,
</p>
</li>
<li><p>	5th col = Month,
</p>
</li>
<li><p>	6th col = Day, 
</p>
</li>
<li><p>	7th col = Ozone (o8hrmax), 
</p>
</li>
<li><p>	8th col = Maximum temperature (cMAXTMP), 
</p>
</li>
<li><p>	9th col = Wind speed (WDSP).
</p>
</li>
<li><p>	10th col = Relative humidity (RH).
</p>
</li></ul>



<h3>Source</h3>

<p>US EPA</p>


<h3>See Also</h3>

<p><code><a href="#topic+NYgrid">NYgrid</a>, <a href="#topic+spT.Gibbs">spT.Gibbs</a>, <a href="#topic+spT.subset">spT.subset</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
  library("spTimer")
# NY data
  data(NYdata)
  head(NYdata)
# plots in NY map
  NYsite&lt;-unique(cbind(NYdata[,1:3]))
  head(NYsite)
# map
  #library(maps)
  #map(database="state",regions="new york")
  #points(NYsite[,2:3],pch=19)

  # Grid data
  data(NYgrid)
  head(NYgrid)
  grid.coords&lt;-unique(cbind(NYgrid[,8:9]))
  #library(maps)
  plot(grid.coords,pch=19,col=1)
  #map(database="state",regions="new york",add=TRUE)

##
</code></pre>

<hr>
<h2 id='plot.spT'>Plots for spTimer output.</h2><span id='topic+plot.spT'></span>

<h3>Description</h3>

<p>This function is used to obtain MCMC summary, residual and fitted surface plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spT'
plot(x, residuals=FALSE, coefficient=NULL, ...)

## 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.spT_+3A_x">x</code></td>
<td>
<p>Object of class inheriting from &quot;spT&quot;.</p>
</td></tr>
<tr><td><code id="plot.spT_+3A_residuals">residuals</code></td>
<td>
<p>If TRUE then plot residual vs. fitted and normal qqplot of the residuals. If FALSE then plot MCMC samples of the parameters using coda package. Defaults value is FALSE.</p>
</td></tr>
<tr><td><code id="plot.spT_+3A_coefficient">coefficient</code></td>
<td>
<p>Only applicable for package &quot;spTDyn&quot; (see details: https://cran.r-project.org/web/packages/spTDyn/index.html).</p>
</td></tr>
<tr><td><code id="plot.spT_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##

plot(out) # where out is the output from spT class
plot(out, residuals=TRUE) # where out is the output from spT class

##

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.spT'>Spatial and temporal predictions for the spatio-temporal models.</h2><span id='topic+predict.spT'></span>

<h3>Description</h3>

<p>This function is used to obtain spatial predictions in the unknown locations and also to get the temporal forecasts using MCMC samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spT'
predict(object, newdata, newcoords, foreStep=NULL, type="spatial", 
        nBurn, tol.dist, predAR=NULL, Summary=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.spT_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;spT&quot;.</p>
</td></tr>
<tr><td><code id="predict.spT_+3A_newdata">newdata</code></td>
<td>
<p>The data set providing the covariate values for spatial prediction or temporal forecasts. This data should have the same space-time structure as the original data frame.</p>
</td></tr>
<tr><td><code id="predict.spT_+3A_newcoords">newcoords</code></td>
<td>
<p>The coordinates for the prediction or forecast sites. The locations are in similar format to <code>coords</code>, see <code><a href="#topic+spT.Gibbs">spT.Gibbs</a></code>.</p>
</td></tr>
<tr><td><code id="predict.spT_+3A_forestep">foreStep</code></td>
<td>
<p>Number of K-step (time points) ahead forecast, K=1,2, ...; Only applicable if type=&quot;temporal&quot;.</p>
</td></tr>
<tr><td><code id="predict.spT_+3A_type">type</code></td>
<td>
<p>If the value is &quot;spatial&quot; then only spatial prediction will be performed at the <code>newcoords</code> which must be different from the fitted sites provided by <code>coords</code>.  When the &quot;temporal&quot; option is specified then forecasting will be performed  and in this case the <code>newcoords</code> may also contain elements of the fitted sites in which case only temporal forecasting beyond the last fitted time point will be performed. </p>
</td></tr> 
<tr><td><code id="predict.spT_+3A_nburn">nBurn</code></td>
<td>
<p>Number of burn-in. Initial MCMC samples to discard before making inference.</p>
</td></tr>
<tr><td><code id="predict.spT_+3A_tol.dist">tol.dist</code></td>
<td>
<p>Minimum tolerance distance limit between fitted and predicted locations.</p>
</td></tr>
<tr><td><code id="predict.spT_+3A_predar">predAR</code></td>
<td>
<p>The prediction output, if forecasts are in the prediction locations. Only applicable if type=&quot;forecast&quot; and data fitted with the &quot;AR&quot; model.</p>
</td></tr>
<tr><td><code id="predict.spT_+3A_summary">Summary</code></td>
<td>
<p>To obtain summary statistics for the posterior predicted MCMC samples. Default is TRUE.</p>
</td></tr>
<tr><td><code id="predict.spT_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pred.samples or fore.samples</code></td>
<td>
<p>Prediction or forecast MCMC samples.</p>
</td></tr>
<tr><td><code>pred.coords or fore.coords</code></td>
<td>
<p>prediction or forecast coordinates.</p>
</td></tr>
<tr><td><code>Mean</code></td>
<td>
<p>Average of the MCMC predictions</p>
</td></tr>
<tr><td><code>Median</code></td>
<td>
<p>Median of the MCMC predictions</p>
</td></tr>
<tr><td><code>SD</code></td>
<td>
<p>Standard deviation of the MCMC predictions</p>
</td></tr>
<tr><td><code>Low</code></td>
<td>
<p>Lower limit for the 95 percent CI of the MCMC predictions</p>
</td></tr>
<tr><td><code>Up</code></td>
<td>
<p>Upper limit for the 95 percent CI of the MCMC predictions</p>
</td></tr>
<tr><td><code>computation.time</code></td>
<td>
<p>The computation time.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model method used for prediction.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>&quot;spatial&quot; or &quot;temporal&quot;.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Other values &quot;obsData&quot;, &quot;fittedData&quot; and &quot;residuals&quot; are provided only for temporal prediction. This is to analyse the <code>spTimer</code> forecast output using package <code>forecast</code> through function <code><a href="#topic+as.forecast.object">as.forecast.object</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bakar, K. S. and Sahu, S. K. (2014) spTimer: Spatio-Temporal Bayesian Modelling Using R. Technical Report, University of Southampton, UK. To appear in the Journal of Statistical Software. <br />
Sahu, S. K. and Bakar, K. S. (2012) A comparison of Bayesian Models for Daily Ozone Concentration Levels Statistical Methodology , 9, 144-157. <br />
Sahu, S. K. and Bakar, K. S. (2012) Hierarchical Bayesian auto-regressive models for large space time data with applications to ozone concentration modelling. Applied Stochastic Models in Business and Industry, 28, 395-415. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a>, <a href="#topic+as.forecast.object">as.forecast.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##

###########################
## The GP models:
###########################

##
## Spatial prediction/interpolation
##

# Read data
data(NYdata)
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))

# MCMC via Gibbs using default choices
set.seed(11)
post.gp &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
        data=DataFit, model="GP", coords=~Longitude+Latitude, 
        scale.transform="SQRT")
print(post.gp)

# Define prediction coordinates
pred.coords&lt;-as.matrix(unique(cbind(DataValPred[,2:3])))

# Spatial prediction using spT.Gibbs output
set.seed(11)
pred.gp &lt;- predict(post.gp, newdata=DataValPred, newcoords=pred.coords)
print(pred.gp)
names(pred.gp)

# validation criteria
spT.validation(DataValPred$o8hrmax,c(pred.gp$Mean))  

##
## Temporal  prediction/forecast 
## 1. In the unobserved locations
##

# Read data
DataValFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValFore&lt;-subset(DataValFore, with(DataValFore, (Day %in% c(30, 31) &amp; Month == 8)))

# define forecast coordinates
fore.coords&lt;-as.matrix(unique(cbind(DataValFore[,2:3])))

# Two-step ahead forecast, i.e., in day 61 and 62 
# in the unobserved locations using output from spT.Gibbs
set.seed(11)
fore.gp &lt;- predict(post.gp, newdata=DataValFore, newcoords=fore.coords, 
           type="temporal", foreStep=2)
print(fore.gp)
names(fore.gp)

# Forecast validations 
spT.validation(DataValFore$o8hrmax,c(fore.gp$Mean)) 

# Use of "forecast" class
#library(forecast)
#tmp&lt;-as.forecast.object(fore.gp, site=1) # default for site 1
#plot(tmp)
#summary(tmp)

##
## Temporal  prediction/forecast 
## 2. In the observed/fitted locations
##

# Read data
DataFitFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
			reverse=TRUE) 
DataFitFore&lt;-subset(DataFitFore, with(DataFitFore, (Day %in% c(30, 31) &amp; Month == 8)))

# Define forecast coordinates
fore.coords&lt;-as.matrix(unique(cbind(DataFitFore[,2:3])))

# Two-step ahead forecast, i.e., in day 61 and 62, 
# in the fitted locations using output from spT.Gibbs
set.seed(11)
fore.gp &lt;- predict(post.gp, newdata=DataFitFore, newcoords=fore.coords, 
           type="temporal", foreStep=2)
print(fore.gp)
names(fore.gp)

# Forecast validations 
spT.validation(DataFitFore$o8hrmax,c(fore.gp$Mean)) # 

# Use of "forecast" class
#library(forecast)
#tmp&lt;-as.forecast.object(fore.gp, site=5) # for site 5
#plot(tmp)

###########################
## The AR models:
###########################

##
## Spatial prediction/interpolation
##

# Read data
data(NYdata)
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))

# MCMC via Gibbs using default choices
set.seed(11)
post.ar &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
         data=DataFit, model="AR", coords=~Longitude+Latitude, 
         scale.transform="SQRT")
print(post.ar)

# Define prediction coordinates
pred.coords&lt;-as.matrix(unique(cbind(DataValPred[,2:3])))

# Spatial prediction using spT.Gibbs output
set.seed(11)
pred.ar &lt;- predict(post.ar, newdata=DataValPred, newcoords=pred.coords)
print(pred.ar)
names(pred.ar)

# validation criteria
spT.validation(DataValPred$o8hrmax,c(pred.ar$Mean))  

##
## Temporal  prediction/forecast 
## 1. In the unobserved locations
##

# Read data
DataValFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValFore&lt;-subset(DataValFore, with(DataValFore, (Day %in% c(30, 31) &amp; Month == 8)))

# define forecast coordinates
fore.coords&lt;-as.matrix(unique(cbind(DataValFore[,2:3])))

# Two-step ahead forecast, i.e., in day 61 and 62 
# in the unobserved locations using output from spT.Gibbs
set.seed(11)
fore.ar &lt;- predict(post.ar, newdata=DataValFore, newcoords=fore.coords, 
           type="temporal", foreStep=2, predAR=pred.ar)
print(fore.ar)
names(fore.ar)

# Forecast validations 
spT.validation(DataValFore$o8hrmax,c(fore.ar$Mean)) 

# Use of "forecast" class
#tmp&lt;-as.forecast.object(fore.ar, site=1) # default for site 1
#plot(tmp)


##
## Temporal  prediction/forecast 
## 2. In the observed/fitted locations
##

# Read data
DataFitFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
			reverse=TRUE) 
DataFitFore&lt;-subset(DataFitFore, with(DataFitFore, (Day %in% c(30, 31) &amp; Month == 8)))

# Define forecast coordinates
fore.coords&lt;-as.matrix(unique(cbind(DataFitFore[,2:3])))

# Two-step ahead forecast, i.e., in day 61 and 62, 
# in the fitted locations using output from spT.Gibbs
set.seed(11)
fore.ar &lt;- predict(post.ar, newdata=DataFitFore, newcoords=fore.coords, 
           type="temporal", foreStep=2)
print(fore.ar)
names(fore.ar)

# Forecast validations 
spT.validation(DataFitFore$o8hrmax,c(fore.ar$Mean)) # 

# Use of "forecast" class
#tmp&lt;-as.forecast.object(fore.ar, site=1) # default for site 1
#plot(tmp)

#################################
## The GPP approximation models:
#################################

##
## Spatial prediction/interpolation
##

# Read data
data(NYdata)
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))

# Define knots
knots&lt;-spT.grid.coords(Longitude=c(max(coords[,1]),
              min(coords[,1])),Latitude=c(max(coords[,2]),
              min(coords[,2])), by=c(4,4))

# MCMC via Gibbs using default choices
set.seed(11)
post.gpp &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
         data=DataFit, model="GPP", coords=~Longitude+Latitude, 
         knots.coords=knots, scale.transform="SQRT")
print(post.gpp)

# Define prediction coordinates
pred.coords&lt;-as.matrix(unique(cbind(DataValPred[,2:3])))

# Spatial prediction using spT.Gibbs output
set.seed(11)
pred.gpp &lt;- predict(post.gpp, newdata=DataValPred, newcoords=pred.coords)
print(pred.gpp)
names(pred.gpp)

# validation criteria
spT.validation(DataValPred$o8hrmax,c(pred.gpp$Mean))  

##
## Temporal  prediction/forecast 
## 1. In the unobserved locations
##

# Read data
DataValFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValFore&lt;-subset(DataValFore, with(DataValFore, (Day %in% c(30, 31) &amp; Month == 8)))

# define forecast coordinates
fore.coords&lt;-as.matrix(unique(cbind(DataValFore[,2:3])))

# Two-step ahead forecast, i.e., in day 61 and 62 
# in the unobserved locations using output from spT.Gibbs
set.seed(11)
fore.gpp &lt;- predict(post.gpp, newdata=DataValFore, newcoords=fore.coords, 
           type="temporal", foreStep=2)
print(fore.gpp)
names(fore.gpp)

# Forecast validations 
spT.validation(DataValFore$o8hrmax,c(fore.gpp$Mean)) 

# Use of "forecast" class
#tmp&lt;-as.forecast.object(fore.gpp, site=1) # default for site 1
#plot(tmp)

##
## Temporal  prediction/forecast 
## 2. In the observed/fitted locations
##

# Read data
DataFitFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
			reverse=TRUE) 
DataFitFore&lt;-subset(DataFitFore, with(DataFitFore, (Day %in% c(30, 31) &amp; Month == 8)))

# Define forecast coordinates
fore.coords&lt;-as.matrix(unique(cbind(DataFitFore[,2:3])))

# Two-step ahead forecast, i.e., in day 61 and 62, 
# in the fitted locations using output from spT.Gibbs
set.seed(11)
fore.gpp &lt;- predict(post.gpp, newdata=DataFitFore, newcoords=fore.coords, 
           type="temporal", foreStep=2)
print(fore.gpp)
names(fore.gpp)

# Forecast validations 
spT.validation(DataFitFore$o8hrmax,c(fore.gpp$Mean)) # 

# Use of "forecast" class
#tmp&lt;-as.forecast.object(fore.gpp, site=1) # default for site 1
#plot(tmp)

##

######################################################
## The Truncated/Censored GP models:
######################################################

##
## Model fitting
##

data(NYdata)

# Truncation at 30 (say)
NYdata$o8hrmax[NYdata$o8hrmax&lt;=30] &lt;- 30

# Read data 
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValFore&lt;-subset(DataValFore, with(DataValFore, (Day %in% c(30, 31) &amp; Month == 8)))
DataFitFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
			reverse=TRUE) 
DataFitFore&lt;-subset(DataFitFore, with(DataFitFore, (Day %in% c(30, 31) &amp; Month == 8)))

#
nItr &lt;- 5000 # number of MCMC samples for each model
nBurn &lt;- 1000 # number of burn-in from the MCMC samples
# Truncation at 30 
# fit truncated GP model 
out &lt;- spT.Gibbs(formula=o8hrmax~cMAXTMP+WDSP+RH,data=DataFit,
  model="truncatedGP",coords=~Longitude+Latitude,
  distance.method="geodetic:km",nItr=nItr,nBurn=nBurn,report=5,
  truncation.para = list(at = 30,lambda = 4),
  fitted.values="ORIGINAL")
#  
summary(out)
head(fitted(out))
plot(out,density=FALSE)
#
head(cbind(DataFit$o8hrmax,fitted(out)[,1]))
plot(DataFit$o8hrmax,fitted(out)[,1])
spT.validation(DataFit$o8hrmax,fitted(out)[,1])

##
## prediction (spatial)
##

pred &lt;- predict(out,newdata=DataValPred, newcoords=~Longitude+Latitude, tol=0.05)
names(pred)
plot(DataValPred$o8hrmax,c(pred$Mean)) 
spT.validation(DataValPred$o8hrmax,c(pred$Mean)) 
#pred$prob.below.threshold

##
## forecast (temporal)
##

# unobserved locations
fore &lt;- predict(out,newdata=DataValFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataValFore$o8hrmax,c(fore$Mean)) 
plot(DataValFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold

# observed locations 
fore &lt;- predict(out,newdata=DataFitFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataFitFore$o8hrmax,c(fore$Mean)) 
plot(DataFitFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold


######################################################
## The Truncated/Censored GPP models:
######################################################

##
## Model fitting
##

data(NYdata)

# Define the coordinates
coords&lt;-as.matrix(unique(cbind(NYdata[,2:3])))
# Define knots
knots&lt;-spT.grid.coords(Longitude=c(max(coords[,1]),
              min(coords[,1])),Latitude=c(max(coords[,2]),
              min(coords[,2])), by=c(4,4))

# Truncation at 30 (say)
NYdata$o8hrmax[NYdata$o8hrmax&lt;=30] &lt;- 30

# Read data 
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValFore&lt;-subset(DataValFore, with(DataValFore, (Day %in% c(30, 31) &amp; Month == 8)))
DataFitFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
			reverse=TRUE) 
DataFitFore&lt;-subset(DataFitFore, with(DataFitFore, (Day %in% c(30, 31) &amp; Month == 8)))

#
nItr &lt;- 5000 # number of MCMC samples for each model
nBurn &lt;- 1000 # number of burn-in from the MCMC samples
# Truncation at 30 
# fit truncated GPP model 
out &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
         data=DataFit, model="truncatedGPP",coords=~Longitude+Latitude,
         knots.coords=knots, distance.method="geodetic:km",
         nItr=nItr,nBurn=nBurn,report=5,fitted="ORIGINAL",
         truncation.para = list(at = 30,lambda = 4))
#  
summary(out)
head(fitted(out))
plot(out,density=FALSE)
#
head(cbind(DataFit$o8hrmax,fitted(out)[,1]))
plot(DataFit$o8hrmax,fitted(out)[,1])
spT.validation(DataFit$o8hrmax,fitted(out)[,1])

##
## prediction (spatial)
##

pred &lt;- predict(out,newdata=DataValPred, newcoords=~Longitude+Latitude, tol=0.05)
names(pred)
plot(DataValPred$o8hrmax,c(pred$Mean)) 
spT.validation(DataValPred$o8hrmax,c(pred$Mean)) 
#pred$prob.below.threshold

##
## forecast (temporal)
##

# unobserved locations
fore &lt;- predict(out,newdata=DataValFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataValFore$o8hrmax,c(fore$Mean)) 
plot(DataValFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold

# observed locations 
fore &lt;- predict(out,newdata=DataFitFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataFitFore$o8hrmax,c(fore$Mean)) 
plot(DataFitFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold


######################################################
######################################################
##

</code></pre>

<hr>
<h2 id='spT.decay'>Choice for sampling spatial decay parameter <code class="reqn">\phi</code>.</h2><span id='topic+spT.decay'></span>

<h3>Description</h3>

<p>This function initialises the sampling method for the spatial decay parameter <code class="reqn">\phi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.decay(distribution=Gamm(a=2,b=1), tuning=NULL, npoints=NULL, value=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.decay_+3A_distribution">distribution</code></td>
<td>
<p>Prior distribution for <code class="reqn">\phi</code>. Currently available methods are, Gamm(a,b) and Unif(low,up). One can also used &quot;FIXED&quot; value for <code class="reqn">\phi</code> parameter.</p>
</td></tr>
<tr><td><code id="spT.decay_+3A_tuning">tuning</code></td>
<td>
<p>If the Gamma prior distribution is used then we need to define the tuning parameter for sampling <code class="reqn">\phi</code>. The <code>tuning</code> is the standard deviation for the normal proposal distribution of the random-walk Metropolis algorithm used to sample <code class="reqn">\phi</code> on the log-scale.  </p>
</td></tr>
<tr><td><code id="spT.decay_+3A_npoints">npoints</code></td>
<td>
<p>If Unif distribution is used then need to define the number of segments for the range of limits by npoints. Default value is 5.</p>
</td></tr>
<tr><td><code id="spT.decay_+3A_value">value</code></td>
<td>
<p>If distribution=&quot;FIXED&quot; type is used then need to define the value for <code class="reqn">\phi</code>. The default value is 3/dmax where dmax is the maximum distance between the fitting sites provided by <code>coords</code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 

# input for random-walk Metropolis within Gibbs 
# sampling for phi parameter
spatial.decay&lt;-spT.decay(distribution=Gamm(2,1), tuning=0.08)

# input for discrete sampling of phi parameter 
# with uniform prior distribution
spatial.decay&lt;-spT.decay(distribution=Unif(0.01,0.02),npoints=5)

# input for spatial decay if FIXED is used
spatial.decay&lt;-spT.decay(distribution="FIXED", value=0.01)

##
</code></pre>

<hr>
<h2 id='spT.geodist'>Geodetic/geodesic Distance</h2><span id='topic+spT.geodist'></span><span id='topic+spT.geo.dist'></span><span id='topic+spT.geo_dist'></span>

<h3>Description</h3>

<p>This geodetic distance provides the distance between the locations in Kilometers (k.m.) and Miles, using spherical law of Cosines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.geodist(Lon, Lat, KM = TRUE)

spT.geo.dist(point1, point2)
spT.geo_dist(points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.geodist_+3A_lon">Lon</code></td>
<td>
<p>The longitude position.</p>
</td></tr>
<tr><td><code id="spT.geodist_+3A_lat">Lat</code></td>
<td>
<p>The latitude position.</p>
</td></tr>
<tr><td><code id="spT.geodist_+3A_km">KM</code></td>
<td>
<p>A logical value, if 'TRUE' then output is in &lsquo;kilometers&rsquo;, otherwise in &lsquo;miles&rsquo;.</p>
</td></tr>
<tr><td><code id="spT.geodist_+3A_point1">point1</code></td>
<td>
<p>In the form of (longitude, latitude) position.</p>
</td></tr>
<tr><td><code id="spT.geodist_+3A_point2">point2</code></td>
<td>
<p>In the form of (longitude, latitude) position.</p>
</td></tr>
<tr><td><code id="spT.geodist_+3A_points">points</code></td>
<td>
<p>In the form of points 1:(longitude, latitude) 2:(longitude, latitude) positions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spT.geodist</code> is used to get geodetic distance in both miles and kilometers.
<code>spT.geo.dist</code> is only used to get geodetic distance in kilometers with a different format.
<code>spT.geo_dist</code> is only used to get geodetic distance in kilometers with a different format.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NYdata">NYdata</a></code>, <code><a href="#topic+spT.grid.coords">spT.grid.coords</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

# Load 28 ozone monitoring locations of New York.
data(NYdata)	
head(NYdata)
NYsite&lt;-unique(NYdata[,1:3])	

# Find the geodetic distance in km
spT.geodist(Lon=NYsite$Longitude, Lat=NYsite$Latitude, KM=TRUE)
   
# Find the geodetic distance in miles
spT.geodist(Lon=NYsite$Longitude, Lat=NYsite$Latitude, KM=FALSE)

##

# using spT.geo.dist
point1&lt;-c(-73.757,42.681)
point2&lt;-c(-73.881,40.866)
spT.geo.dist(point1,point2)

# using spT.geo_dist
points&lt;-c(point1,point2)
spT.geo_dist(points)

##
</code></pre>

<hr>
<h2 id='spT.Gibbs'>MCMC sampling for the spatio-temporal models.</h2><span id='topic+spT.Gibbs'></span>

<h3>Description</h3>

<p>This function is used to draw MCMC samples using the Gibbs sampler. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.Gibbs(formula, data = parent.frame(), model = "GP", time.data = NULL, 
	coords, knots.coords, newcoords = NULL, newdata = NULL, priors = NULL, 
	initials = NULL, nItr = 5000, nBurn = 1000, report = 1, tol.dist = 0.05, 
	distance.method = "geodetic:km", cov.fnc = "exponential", 
	scale.transform = "NONE", spatial.decay = spT.decay(distribution = "FIXED"), 
	truncation.para = list(at = 0,lambda = 2), annual.aggrn = "NONE",
	fitted.values="TRANSFORMED")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.Gibbs_+3A_formula">formula</code></td>
<td>
<p>The symnbolic description of the model equation of the regression part of the space-time model.</p>
</td></tr> 
<tr><td><code id="spT.Gibbs_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the model. If omitted, the variables are taken from environment(formula), typically the environment from which spT.Gibbs is called. The data should be ordered first by the time and then by the sites specified by the <code>coords</code> below. One can also supply coordinates through this argument, where coordinate names should be &quot;Latitude&quot; and &quot;Longitude&quot;.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_model">model</code></td>
<td>
<p>The spatio-temporal models to be fitted, current choices are: &quot;GP&quot;, &quot;truncatedGP&quot;, &quot;AR&quot;, &quot;GPP&quot;, and &quot;truncatedGPP&quot;, with the first one as the default.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_time.data">time.data</code></td>
<td>
<p>Defining the segments of the time-series set up using the function <code><a href="#topic+spT.time">spT.time</a></code>.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_coords">coords</code></td>
<td>
<p>The n by 2 matrix or data frame defining the locations (e.g., longitude/easting, latitude/northing) of the fitting sites, where n is the number of fitting sites. One can also supply coordinates through a formula argument such as ~Longitude+Latitude.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_knots.coords">knots.coords</code></td>
<td>
<p>The locations of the knots in similar format to coords above, only required if <code>model="GPP"</code>.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_newcoords">newcoords</code></td>
<td>
<p>The locations of the prediction sites in similar format to coords above, only required if fit and predictions are to be performed simultaneously. If omitted, no predictions will be performed.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_newdata">newdata</code></td>
<td>
<p>The covariate values at the prediction sites specified by <code>newcoords</code>. This should have same space-time structure as the original data frame.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_priors">priors</code></td>
<td>
<p>The prior distributions for the parameters. Default distributions are specified if these are not provided. If priors=NULL a flat prior distribution will be used with large variance. See details in <code><a href="#topic+spT.priors">spT.priors</a></code>.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_initials">initials</code></td>
<td>
<p>The preferred initial values for the parameters. If omitted, default values are provided automatically. Further  details are provided in  <code><a href="#topic+spT.initials">spT.initials</a></code>.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_nitr">nItr</code></td>
<td>
<p>Number of MCMC iterations. Default value is 5000.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_nburn">nBurn</code></td>
<td>
<p>Number of burn-in samples. This number of samples will be discarded before making any inference. Default value is 1000.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_report">report</code></td>
<td>
<p>Number of reports to display while running the Gibbs sampler. Defaults to number of iterations. </p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_distance.method">distance.method</code></td>
<td>
<p>The preferred method to calculate the distance between any two locations. The available options are &quot;geodetic:km&quot;, &quot;geodetic:mile&quot;, &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, and &quot;canberra&quot;. See details in <code><a href="stats.html#topic+dist">dist</a></code>. The default is &quot;geodetic:km&quot;.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_tol.dist">tol.dist</code></td>
<td>
<p>Minimum separation distance between any two locations out of those  specified by coords, knots.coords and pred.coords. The default is 0.005. The programme will exit if the minimum distance is less than the non-zero specified value. This will ensure non-singularity of the covariance matrices.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_cov.fnc">cov.fnc</code></td>
<td>
<p>Covariance function for the spatial effects. The available options  are &quot;exponential&quot;, &quot;gaussian&quot;, &quot;spherical&quot; and &quot;matern&quot;. If &quot;matern&quot; is used then by default the smooth parameter (<code class="reqn">\nu</code>) is estimated from (0,1) uniform distribution using discrete samples.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_scale.transform">scale.transform</code></td>
<td>
<p>The transformation method for the response variable. Currently implemented options are: &quot;NONE&quot;, &quot;SQRT&quot;, and &quot;LOG&quot; with  &quot;NONE&quot; as the deault.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_spatial.decay">spatial.decay</code></td>
<td>
<p>Provides the prior distribution for the spatial decay parameter <code class="reqn">\phi</code>. Currently implemented options  are  &quot;FIXED&quot;, &quot;Unif&quot;, or &quot;Gamm&quot;.  Further details for each of these are specified by <code><a href="#topic+spT.decay">spT.decay</a></code>.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_truncation.para">truncation.para</code></td>
<td>
<p>Provides truncation parameter <code class="reqn">\lambda</code> and truncation point &quot;at&quot; using list.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_annual.aggrn">annual.aggrn</code></td>
<td>
<p>This provides the options for calculating annual summary statistics by aggregating different time segments (e.g., annual mean). Currently implemented options are: &quot;NONE&quot;, &quot;ave&quot; and &quot;an4th&quot;, where &quot;ave&quot; = annual average, &quot;an4th&quot;= annual 4th highest. Only applicable if <code><a href="#topic+spT.time">spT.time</a></code> inputs more than one segment and when fit and predict are done simultaneously.</p>
</td></tr>
<tr><td><code id="spT.Gibbs_+3A_fitted.values">fitted.values</code></td>
<td>
<p>This option provides calculating fitted values and corresponding sd in the original scale. Currently implemented options are: &quot;ORIGINAL&quot; and &quot;TRANSFORMED&quot;. Only applicable if <code>scale.transform</code> inputs &quot;SQRT&quot; or &quot;LOG&quot;. Note that the PMCC (model validation criteria) values will be changed accordingly.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>accept</code></td>
<td>
<p>The acceptance rate for the <code class="reqn">\phi</code> parameter if the &quot;MH&quot; method of sampling is chosen.</p>
</td></tr>
<tr><td><code>phip</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code>nup</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\nu</code>. Only available if &quot;matern&quot; covariance function is used.</p>
</td></tr>
<tr><td><code>sig2eps</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\sigma^2_\epsilon</code>.</p>
</td></tr>
<tr><td><code>sig2etap</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\sigma^2_\eta</code>.</p>
</td></tr>
<tr><td><code>betap</code></td>
<td>
<p>MCMC samples for the parameter <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>rhop</code></td>
<td>
<p>MCMC samples for <code class="reqn">\rho</code> for the AR or GPP model.</p>
</td></tr>
<tr><td><code>op</code></td>
<td>
<p>MCMC samples for the true observations.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>MCMC summary (mean and sd) for the fitted values.</p>
</td></tr>
<tr><td><code>tol.dist</code></td>
<td>
<p>Minimum tolerance distance limit between the locations.</p>
</td></tr>
<tr><td><code>distance.method</code></td>
<td>
<p>Name of the distance calculation method.</p>
</td></tr>
<tr><td><code>cov.fnc</code></td>
<td>
<p>Name of the covariance function used in model fitting.</p>
</td></tr>
<tr><td><code>scale.transform</code></td>
<td>
<p>Name of the scale.transformation method.</p>
</td></tr>
<tr><td><code>sampling.sp.decay</code></td>
<td>
<p>The method of sampling for the spatial decay parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code>covariate.names</code></td>
<td>
<p>Name of the covariates used in the model.</p>
</td></tr>
<tr><td><code>Distance.matrix</code></td>
<td>
<p>The distance matrix.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>The coordinate values.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Total number of sites.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Total number of segments in time, e.g., years.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>Total points of time, e.g., days within each year.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Total number of model coefficients, i.e., <code class="reqn">\beta</code>'s including the intercept.</p>
</td></tr>
<tr><td><code>initials</code></td>
<td>
<p>The initial values used in the model.</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>The prior distributions used in the model.</p>
</td></tr>
<tr><td><code>PMCC</code></td>
<td>
<p>The predictive model choice criteria obtained by minimising the expected value of a loss function, see Gelfand and Ghosh (1998). Results for both goodness of fit and penalty are given.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of samples for the MCMC chain, without burn-in.</p>
</td></tr>
<tr><td><code>nBurn</code></td>
<td>
<p>The number of burn-in period for the MCMC chain.</p>
</td></tr>
<tr><td><code>computation.time</code></td>
<td>
<p>The computation time required for the fitted model.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The spatio-temporal model used for analyse the data.</p>
</td></tr>
<tr><td><code>Text Output</code></td>
<td>
<p>This option is only applicable when fit and predictions are done simultaneously.<br />
</p>
<p>For GP models:<br />
OutGP_Values_Parameter.txt: (nItr x parameters matrix) has the MCMC samples for the parameters, ordered as: beta's, sig2eps, sig2eta, and phi. <br />
OutGP_Stats_FittedValue.txt: (N x 2) matrix of fitted summary, with 1st column as mean and 2nd column as standard deviations, where N=nrT. <br />
OutGP_Stats_PredValue.txt: ((predsites*r*T) x 2) matrix of prediction summary, with 1st column as mean and 2nd column as standard deviations. <br />
OutGP_Values_Prediction.txt: (nItr x (predsites*r*T)) matrix of MCMC predicted values in the predicted sites. <br />
If <code>annual.aggregation="ave"</code> then we get text output as: <br />
OutGP_Annual_Average_Prediction.txt: (nItr x (predsites*r)) matrix. <br />
If <code>annual.aggregation="an4th"</code> then we get text output as: <br />
OutGP_Annual_4th_Highest_Prediction.txt: (nItr x (predsites*r)) matrix. <br />
</p>
<p>For AR models: <br />
OutAR_Values_Parameter.txt: (nItr x parameters matrix) has the MCMC samples for the parameters, ordered as: beta's, rho, sig2eps, sig2eta, mu_l's, sig2l's and phi. <br />
OutAR_Stats_TrueValue.txt: (N x 2) matrix of true summary values, with 1st column as mean and 2nd column as standard deviations. <br />
OutAR_Stats_FittedValue.txt: (N x 2) matrix of fitted summary, with 1st column as mean and 2nd column as standard deviations. <br />
OutAR_Stats_PredValue.txt: ((predsites*r*T) x 2) matrix of prediction summary, with 1st column as mean and 2nd column as standard deviations. <br />
OutAR_Values_Prediction.txt: (nItr x (predsites*r*T)) matrix of MCMC predicted values in the predicted sites. <br />
If <code>annual.aggregation="ave"</code> then we get text output as: <br />
OutAR_Annual_Average_Prediction.txt: (nItr x (predsites*r)) matrix. <br />
If <code>annual.aggregation="an4th"</code> then we get text output as: <br />
OutAR_Annual_4th_Highest_Prediction.txt: (nItr x (predsites*r)) matrix. <br />
</p>
<p>For models using GPP approximations: <br />
OutGPP_Values_Parameter.txt: (nItr x parameters matrix) has the MCMC samples for the parameters, ordered as: beta's, rho, sig2eps, sig2eta, and phi. <br />
OutGPP_Stats_FittedValue.txt: (N x 2) matrix of fitted summary, with 1st column as mean and 2nd column as standard deviations. <br />
OutGPP_Stats_PredValue.txt: ((predsites*r*T) x 2) matrix of prediction summary, with 1st column as mean and 2nd column as standard deviations. <br />
OutGPP_Values_Prediction.txt: (nItr x (predsites*r*T)) matrix of MCMC predicted values in the predicted sites. <br />
If <code>annual.aggregation="ave"</code> then we get text output as: <br />
OutGPP_Annual_Average_Prediction.txt: (nItr x (predsites*r)) matrix. <br />
If <code>annual.aggregation="an4th"</code> then we get text output as: <br />
OutGPP_Annual_4th_Highest_Prediction.txt: (nItr x (predsites*r)) matrix. <br />
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bakar, K. S. and Sahu, S. K. (2015) spTimer: Spatio-Temporal Bayesian Modelling Using R. Journal of Statistical Software, 63(15). 1&ndash;32. 
</p>
<p>Sahu, S. K. and Bakar, K. S. (2012a) A comparison of Bayesian Models for Daily Ozone Concentration Levels Statistical Methodology, 9, 144-157.
</p>
<p>Sahu, S. K. and Bakar, K. S. (2012b) Hierarchical Bayesian auto-regressive models for large space time data with applications to ozone concentration modelling. Applied Stochastic Models in Business and Industry, 28, 395-415. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spT.priors">spT.priors</a>, <a href="#topic+spT.initials">spT.initials</a>, <a href="#topic+spT.geodist">spT.geodist</a>, <a href="stats.html#topic+dist">dist</a>, <a href="#topic+summary.spT">summary.spT</a>, <a href="#topic+plot.spT">plot.spT</a>, <a href="#topic+predict.spT">predict.spT</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##

###########################
## Attach library spTimer
###########################

library(spTimer)

###########################
## The GP models:
###########################

##
## Model fitting
##

# Read data 
data(NYdata)

# MCMC via Gibbs using default choices
set.seed(11)
post.gp &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
        data=NYdata, model="GP", coords=~Longitude+Latitude, 
        scale.transform="SQRT")
print(post.gp)

# MCMC via Gibbs not using default choices
# Read data 
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))

# define the time-series 
time.data&lt;-spT.time(t.series=60,segment=1)

# hyper-parameters for the prior distributions
priors&lt;-spT.priors(model="GP",inv.var.prior=Gamm(2,1),
        beta.prior=Norm(0,10^4))

# initial values for the model parameters
initials&lt;-spT.initials(model="GP", sig2eps=0.01, 
            sig2eta=0.5, beta=NULL, phi=0.001)

# input for spatial decay, any one approach from below
#spatial.decay&lt;-spT.decay(distribution="FIXED", value=0.01)
spatial.decay&lt;-spT.decay(distribution=Gamm(2,1), tuning=0.08)
#spatial.decay&lt;-spT.decay(distribution=Unif(0.01,0.02),npoints=5)

# Iterations for the MCMC algorithms
nItr&lt;-5000

# MCMC via Gibbs
set.seed(11)
post.gp &lt;- spT.Gibbs(formula=o8hrmax ~ cMAXTMP+WDSP+RH, 
         data=DataFit, model="GP", time.data=time.data, 
         coords=~Longitude+Latitude, priors=priors, initials=initials, 
         nItr=nItr, nBurn=0, report=nItr, 
         tol.dist=2, distance.method="geodetic:km", 
         cov.fnc="exponential", scale.transform="SQRT", 
         spatial.decay=spatial.decay)
print(post.gp)

# Summary and plots
summary(post.gp)
summary(post.gp,pack="coda")
plot(post.gp)
plot(post.gp,residuals=TRUE)

coef(post.gp)
confint(post.gp)
terms(post.gp)
formula(post.gp)
model.frame(post.gp)
model.matrix(post.gp)

# Model selection criteria
post.gp$PMCC 


######################################
## The GP model for sp class data
######################################

# Creating sp class data
library(sp)
data(meuse)
summary(meuse)
coordinates(meuse) &lt;- ~x+y
class(meuse)
out&lt;-spT.Gibbs(formula=zinc~sqrt(dist),data=meuse,
               model="GP", scale.transform="LOG")
summary(out)

# Create a dataset with spacetime class
library(spTimer)
site&lt;-unique(NYdata[,c("Longitude","Latitude")])
library(spacetime)
row.names(site)&lt;-paste("point",1:nrow(site),sep="")
site &lt;- SpatialPoints(site)
ymd&lt;-as.POSIXct(seq(as.Date("2006-07-01"),as.Date("2006-08-31"),by=1))
# introduce class STFDF
newNYdata&lt;-STFDF(sp=site, time=ymd, data=NYdata) # full lattice
class(newNYdata)
out &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
      data=newNYdata, model="GP", scale.transform="SQRT")
summary(out)


###########################
## The AR models:
###########################

##
## Model fitting
##

# Read data 
data(NYdata)

# Define the coordinates
coords&lt;-as.matrix(unique(cbind(NYdata[,2:3])))

# MCMC via Gibbs using default choices
set.seed(11)
post.ar &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
         data=NYdata, model="AR", coords=coords, 
         scale.transform="SQRT")
print(post.ar)

# MCMC via Gibbs not using default choices
# define the time-series 
time.data&lt;-spT.time(t.series=62,segment=1)

# hyper-parameters for the prior distributions
priors&lt;-spT.priors(model="AR",inv.var.prior=Gamm(2,1),
        beta.prior=Norm(0,10^4))

# initial values for the model parameters
initials&lt;-spT.initials(model="AR", sig2eps=0.01, 
            sig2eta=0.5, beta=NULL, phi=0.001)

# Input for spatial decay
#spatial.decay&lt;-spT.decay(distribution="FIXED", value=0.01)
spatial.decay&lt;-spT.decay(distribution=Gamm(2,1), tuning=0.08)
#spatial.decay&lt;-spT.decay(distribution=Unif(0.01,0.02),npoints=5)

# Iterations for the MCMC algorithms
nItr&lt;-5000

# MCMC via Gibbs
set.seed(11)
post.ar &lt;- spT.Gibbs(formula=o8hrmax~cMAXTMP+WDSP+RH, 
         data=NYdata, model="AR", time.data=time.data, 
         coords=coords, priors=priors, initials=initials, 
         nItr=nItr, nBurn=0, report=nItr, 
         tol.dist=2, distance.method="geodetic:km", 
         cov.fnc="exponential", scale.transform="SQRT", 
         spatial.decay=spatial.decay)
print(post.ar)

# Summary and plots
summary(post.ar)
plot(post.ar)

# Model selection criteria
post.ar$PMCC 

#################################
## The GPP approximation models:
#################################

##
## Model fitting
##

# Read data 
data(NYdata); 

# Define the coordinates
coords&lt;-as.matrix(unique(cbind(NYdata[,2:3])))
# Define knots
knots&lt;-spT.grid.coords(Longitude=c(max(coords[,1]),
              min(coords[,1])),Latitude=c(max(coords[,2]),
              min(coords[,2])), by=c(4,4))

# MCMC via Gibbs using default choices
set.seed(11)
post.gpp &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
         data=NYdata, model="GPP", coords=coords, 
         knots.coords=knots, scale.transform="SQRT")
print(post.gpp)

# MCMC via Gibbs not using default choices
# define the time-series 
time.data&lt;-spT.time(t.series=62,segment=1)

# hyper-parameters for the prior distributions
priors&lt;-spT.priors(model="GPP",inv.var.prior=Gamm(2,1),
        beta.prior=Norm(0,10^4))

# initial values for the model parameters
initials&lt;-spT.initials(model="GPP", sig2eps=0.01, 
            sig2eta=0.5, beta=NULL, phi=0.001)

# input for spatial decay
#spatial.decay&lt;-spT.decay(distribution="FIXED", value=0.001)
spatial.decay&lt;-spT.decay(distribution=Gamm(2,1), tuning=0.05)
#spatial.decay&lt;-spT.decay(distribution=Unif(0.001,0.009),npoints=10)

# Iterations for the MCMC algorithms
nItr&lt;-5000 

# MCMC via Gibbs
set.seed(11)
post.gpp &lt;- spT.Gibbs(formula=o8hrmax~cMAXTMP+WDSP+RH, 
         data=NYdata, model="GPP", time.data=time.data, 
         coords=coords, knots.coords=knots,
         priors=priors, initials=initials, 
         nItr=nItr, nBurn=0, report=nItr, 
         tol.dist=2, distance.method="geodetic:km", 
         cov.fnc="exponential", scale.transform="SQRT", 
         spatial.decay=spatial.decay)
print(post.gpp)

# Summary and plots
summary(post.gpp)
plot(post.gpp)

# Model selection criteria
post.gpp$PMCC 


######################################################
## The Truncated/Censored GP models:
######################################################

##
## Model fitting
##

data(NYdata)

# Truncation at 30 (say)
NYdata$o8hrmax[NYdata$o8hrmax&lt;=30] &lt;- 30

# Read data 
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValFore&lt;-subset(DataValFore, with(DataValFore, (Day %in% c(30, 31) &amp; Month == 8)))
DataFitFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
			reverse=TRUE) 
DataFitFore&lt;-subset(DataFitFore, with(DataFitFore, (Day %in% c(30, 31) &amp; Month == 8)))

#
nItr &lt;- 5000 # number of MCMC samples for each model
nBurn &lt;- 1000 # number of burn-in from the MCMC samples
# Truncation at 30 
# fit truncated GP model 
out &lt;- spT.Gibbs(formula=o8hrmax~cMAXTMP+WDSP+RH,data=DataFit,
  model="truncatedGP",coords=~Longitude+Latitude,
  distance.method="geodetic:km",nItr=nItr,nBurn=nBurn,report=5,
  truncation.para = list(at = 30,lambda = 2),
  fitted.values="ORIGINAL")
#  
summary(out)
head(fitted(out))
plot(out,density=FALSE)
#
head(cbind(DataFit$o8hrmax,fitted(out)[,1]))
plot(DataFit$o8hrmax,fitted(out)[,1])
spT.validation(DataFit$o8hrmax,fitted(out)[,1])

##
## prediction (spatial)
##

pred &lt;- predict(out,newdata=DataValPred, newcoords=~Longitude+Latitude, tol=0.05)
names(pred)
plot(DataValPred$o8hrmax,c(pred$Mean)) 
spT.validation(DataValPred$o8hrmax,c(pred$Mean)) 
#pred$prob.below.threshold

##
## forecast (temporal)
##

# unobserved locations
fore &lt;- predict(out,newdata=DataValFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataValFore$o8hrmax,c(fore$Mean)) 
plot(DataValFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold

# observed locations 
fore &lt;- predict(out,newdata=DataFitFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataFitFore$o8hrmax,c(fore$Mean)) 
plot(DataFitFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold


######################################################
## The Truncated/Censored AR models:
######################################################

##
## Model fitting
##

data(NYdata)

# Truncation at 30 (say)
NYdata$o8hrmax[NYdata$o8hrmax&lt;=30] &lt;- 30

# Read data 
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValFore&lt;-subset(DataValFore, with(DataValFore, (Day %in% c(30, 31) &amp; Month == 8)))
DataFitFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
			reverse=TRUE) 
DataFitFore&lt;-subset(DataFitFore, with(DataFitFore, (Day %in% c(30, 31) &amp; Month == 8)))

#
nItr &lt;- 5000 # number of MCMC samples for each model
nBurn &lt;- 1000 # number of burn-in from the MCMC samples
# Truncation at 30 
# fit truncated AR model 
out &lt;- spT.Gibbs(formula=o8hrmax~cMAXTMP+WDSP+RH,data=DataFit,
  model="truncatedAR",coords=~Longitude+Latitude,
  distance.method="geodetic:km",nItr=nItr,nBurn=nBurn,report=5,
  truncation.para = list(at = 30,lambda = 2),
  fitted.values="ORIGINAL")
#  
summary(out)
head(fitted(out))
plot(out,density=FALSE)
#
head(cbind(DataFit$o8hrmax,fitted(out)[,1]))
plot(DataFit$o8hrmax,fitted(out)[,1])
spT.validation(DataFit$o8hrmax,fitted(out)[,1])

##
## prediction (spatial)
##

pred &lt;- predict(out,newdata=DataValPred, newcoords=~Longitude+Latitude, tol=0.05)
names(pred)
plot(DataValPred$o8hrmax,c(pred$Mean)) 
spT.validation(DataValPred$o8hrmax,c(pred$Mean)) 
#pred$prob.below.threshold

##
## forecast (temporal)
##

# unobserved locations
fore &lt;- predict(out,newdata=DataValFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataValFore$o8hrmax,c(fore$Mean)) 
plot(DataValFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold

# observed locations 
fore &lt;- predict(out,newdata=DataFitFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataFitFore$o8hrmax,c(fore$Mean)) 
plot(DataFitFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold


######################################################
## The Truncated/Censored GPP models:
######################################################

##
## Model fitting
##

data(NYdata)

# Define the coordinates
coords&lt;-as.matrix(unique(cbind(NYdata[,2:3])))
# Define knots
knots&lt;-spT.grid.coords(Longitude=c(max(coords[,1]),
              min(coords[,1])),Latitude=c(max(coords[,2]),
              min(coords[,2])), by=c(4,4))

# Truncation at 30 (say)
NYdata$o8hrmax[NYdata$o8hrmax&lt;=30] &lt;- 30

# Read data 
s&lt;-c(8,11,12,14,18,21,24,28)
DataFit&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s, reverse=TRUE) 
DataFit&lt;-subset(DataFit, with(DataFit, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValPred&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=s) 
DataValPred&lt;-subset(DataValPred, with(DataValPred, !(Day %in% c(30, 31) &amp; Month == 8)))
DataValFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28)) 
DataValFore&lt;-subset(DataValFore, with(DataValFore, (Day %in% c(30, 31) &amp; Month == 8)))
DataFitFore&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(8,11,12,14,18,21,24,28),
			reverse=TRUE) 
DataFitFore&lt;-subset(DataFitFore, with(DataFitFore, (Day %in% c(30, 31) &amp; Month == 8)))

#
nItr &lt;- 5000 # number of MCMC samples for each model
nBurn &lt;- 1000 # number of burn-in from the MCMC samples
# Truncation at 30 
# fit truncated GPP model 
out &lt;- spT.Gibbs(formula=o8hrmax ~cMAXTMP+WDSP+RH,   
         data=DataFit, model="truncatedGPP",coords=~Longitude+Latitude,
         knots.coords=knots, distance.method="geodetic:km",
         nItr=nItr,nBurn=nBurn,report=5,fitted="ORIGINAL",
         truncation.para = list(at = 30,lambda = 2))
#  
summary(out)
head(fitted(out))
plot(out,density=FALSE)
#
head(cbind(DataFit$o8hrmax,fitted(out)[,1]))
plot(DataFit$o8hrmax,fitted(out)[,1])
spT.validation(DataFit$o8hrmax,fitted(out)[,1])

##
## prediction (spatial)
##

pred &lt;- predict(out,newdata=DataValPred, newcoords=~Longitude+Latitude, tol=0.05)
names(pred)
plot(DataValPred$o8hrmax,c(pred$Mean)) 
spT.validation(DataValPred$o8hrmax,c(pred$Mean)) 
#pred$prob.below.threshold

##
## forecast (temporal)
##

# unobserved locations
fore &lt;- predict(out,newdata=DataValFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataValFore$o8hrmax,c(fore$Mean)) 
plot(DataValFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold

# observed locations 
fore &lt;- predict(out,newdata=DataFitFore, newcoords=~Longitude+Latitude,
   type="temporal", foreStep=2, tol=0.05)
spT.validation(DataFitFore$o8hrmax,c(fore$Mean)) 
plot(DataFitFore$o8hrmax,c(fore$Mean)) 
#fore$prob.below.threshold


######################################################
######################################################
##

</code></pre>

<hr>
<h2 id='spT.grid.coords'>Grid Coordinates</h2><span id='topic+spT.grid.coords'></span>

<h3>Description</h3>

<p>This function is used to obtain Longitude/x and Latitude/y coordinates in a grid set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.grid.coords(Longitude = c(max, min),
   Latitude = c(max, min), by = c(NA,NA))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.grid.coords_+3A_longitude">Longitude</code></td>
<td>
<p> The maximum and minimum longitude position.</p>
</td></tr>
<tr><td><code id="spT.grid.coords_+3A_latitude">Latitude</code></td>
<td>
<p> The maximum and minimum latitude position.</p>
</td></tr>
<tr><td><code id="spT.grid.coords_+3A_by">by</code></td>
<td>
<p>The number of x and y points in each axis.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.geodist">spT.geodist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

# Load 29 ozone monitoring locations in New York.

data(NYdata)	
coords &lt;- as.matrix(NYdata[,c(2,3)])

# Find the knots coordinates

knots.coords &lt;- spT.grid.coords(Longitude=c(max(coords[,1]),
          min(coords[,1])), Latitude=c(max(coords[,2]),
          min(coords[,2])),by=c(4,4))      
knots.coords

##
</code></pre>

<hr>
<h2 id='spT.initials'>Initial values for the spatio-temporal models.</h2><span id='topic+spT.initials'></span>

<h3>Description</h3>

<p>This command is useful to assign the initial values of the hyper-parameters of the prior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.initials(model, sig2eps=0.01, sig2eta=NULL, rho=NULL, beta=NULL, phi=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.initials_+3A_model">model</code></td>
<td>
<p>The spatio-temporal models, current options are: &quot;GP&quot;, &quot;AR&quot;, and &quot;GPP&quot;.</p>
</td></tr>
<tr><td><code id="spT.initials_+3A_sig2eps">sig2eps</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\sigma</code>^2_<code class="reqn">\epsilon</code>.</p>
</td></tr>
<tr><td><code id="spT.initials_+3A_sig2eta">sig2eta</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\sigma</code>^2_<code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code id="spT.initials_+3A_rho">rho</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\rho</code>.</p>
</td></tr>
<tr><td><code id="spT.initials_+3A_beta">beta</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="spT.initials_+3A_phi">phi</code></td>
<td>
<p>Initial value for the parameter <code class="reqn">\phi</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Initial values are automatically given if the user does not provide these. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a>, <a href="#topic+predict.spT">predict.spT</a>, <a href="#topic+spT.priors">spT.priors</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 

initials&lt;-spT.initials(model="GPP", sig2eps=0.01, 
        sig2eta=0.5, beta=NULL, phi=0.001)
initials

##
</code></pre>

<hr>
<h2 id='spT.pCOVER'>Nominal Coverage</h2><span id='topic+spT.pCOVER'></span>

<h3>Description</h3>

<p>This function is used to obtain nominal coverage.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.pCOVER(z=NULL,zup=NULL,zlow=NULL,zsample=NULL,level=95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.pCOVER_+3A_z">z</code></td>
<td>
<p>The original values (matrix or vector).</p>
</td></tr>
<tr><td><code id="spT.pCOVER_+3A_zup">zup</code></td>
<td>
<p>The predicted values for upper interval (matrix or vector).</p>
</td></tr>
<tr><td><code id="spT.pCOVER_+3A_zlow">zlow</code></td>
<td>
<p>The predicted values for lower interval (matrix or vector).</p>
</td></tr>
<tr><td><code id="spT.pCOVER_+3A_zsample">zsample</code></td>
<td>
<p>Predicted MCMC samples.</p>
</td></tr>
<tr><td><code id="spT.pCOVER_+3A_level">level</code></td>
<td>
<p>Level of coverages.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.validation">spT.validation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

# Create `x': the true values.
# Create `yup': the upper interval.
# Create `ylow': the lower interval.

x &lt;- rnorm(1000,5,0.1)
yup &lt;- rnorm(1000,7,2)
ylow &lt;- rnorm(1000,3,2)
	
# The pCOVER is:

spT.pCOVER(z=x, zup=yup, zlow=ylow)

# create predicted MCMC samples

y &lt;- matrix(rnorm(1000*5000,5,1),1000,5000)

# The pCOVER is:

spT.pCOVER(z=x, zsample=y)
spT.pCOVER(z=x, zsample=y, level=50)

##  
</code></pre>

<hr>
<h2 id='spT.priors'>Priors for the spatio-temporal models.</h2><span id='topic+spT.priors'></span>

<h3>Description</h3>

<p>This command is useful to assign the hyper-parameters of the prior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.priors(model="GP", inv.var.prior=Gamm(a=2,b=1),
  beta.prior=Norm(0,10^10), rho.prior=Norm(0,10^10))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.priors_+3A_model">model</code></td>
<td>
<p>The spatio-temporal models, current input: &quot;GP&quot;, &quot;AR&quot;, and &quot;GPP&quot;.</p>
</td></tr>
<tr><td><code id="spT.priors_+3A_inv.var.prior">inv.var.prior</code></td>
<td>
<p>The hyper-parameter for the Gamma prior distribution (with mean = a/b) of the precision (inverse variance) model parameters (e.g., 1/<code class="reqn">\sigma</code>2_<code class="reqn">\epsilon</code>, 1/<code class="reqn">\sigma</code>2_<code class="reqn">\eta</code>).</p>
</td></tr>
<tr><td><code id="spT.priors_+3A_beta.prior">beta.prior</code></td>
<td>
<p>The hyper-parameter for the Normal prior distribution of the <code class="reqn">\beta</code> model parameters.</p>
</td></tr>
<tr><td><code id="spT.priors_+3A_rho.prior">rho.prior</code></td>
<td>
<p>The hyper-parameter for the Normal prior distribution of the <code class="reqn">\rho</code> model parameter.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If no prior information are given (assigned as NULL), then it use flat prior values of the corresponding distributions. <br />
<code>Gamm</code> and <code>Norm</code> refers to Gamma and Normal distributions respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a>, <a href="#topic+predict.spT">predict.spT</a>, <a href="#topic+spT.initials">spT.initials</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 

priors&lt;-spT.priors(model="GPP",inv.var.prior=Gamm(2,1),
      beta.prior=Norm(0,10^4))
priors

##
</code></pre>

<hr>
<h2 id='spT.segment.plot'>Utility plot for prediction/forecast</h2><span id='topic+spT.segment.plot'></span>

<h3>Description</h3>

<p>This function is used to obtain scatter plots with 95 percent CI for predictions/forecasts. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.segment.plot(obs, est, up, low, limit = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.segment.plot_+3A_obs">obs</code></td>
<td>
<p>Observed values.</p>
</td></tr>
<tr><td><code id="spT.segment.plot_+3A_est">est</code></td>
<td>
<p>Estimated values.</p>
</td></tr>
<tr><td><code id="spT.segment.plot_+3A_up">up</code></td>
<td>
<p>Upper limit of the estimated values.</p>
</td></tr>
<tr><td><code id="spT.segment.plot_+3A_low">low</code></td>
<td>
<p>Lower limit of the estimated values.</p>
</td></tr>
<tr><td><code id="spT.segment.plot_+3A_limit">limit</code></td>
<td>
<p>x-axis and y-axis limits.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.spT">summary.spT</a>, <a href="#topic+plot.spT">plot.spT</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

obs&lt;-rnorm(10,15,1)
est&lt;-rnorm(10,15,1.5)
up&lt;-rnorm(10,25,0.5)
low&lt;-rnorm(10,5,0.5)
spT.segment.plot(obs,est,up,low,limit=c(0,30)) 

##
</code></pre>

<hr>
<h2 id='spT.subset'>Select a subset of Spatial data.</h2><span id='topic+spT.subset'></span>

<h3>Description</h3>

<p>This command selects a subset of the dataset using the site numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.subset(data, var.name, s = NULL, reverse = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.subset_+3A_data">data</code></td>
<td>
<p>The dataset.</p>
</td></tr>
<tr><td><code id="spT.subset_+3A_var.name">var.name</code></td>
<td>
<p>The name of the variable for which data will be sub-setted, e.g., &quot;s.index&quot;.</p>
</td></tr>
<tr><td><code id="spT.subset_+3A_s">s</code></td>
<td>
<p>The site numbers to be selected/deselected based on the argument <code>reverse</code>, e.g., c(2,8,12).</p>
</td></tr>
<tr><td><code id="spT.subset_+3A_reverse">reverse</code></td>
<td>
<p>Logical value: if TRUE then <code>num.rs</code> will be discarded from the data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+NYdata">NYdata</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

# Load ozone concentration data for New York.
data(NYdata)	
NYdata	
# Choose sites 2, 8, and 12.
subdata&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(2,8,12))
# Do not choose purposively defined sites numbered as 2, 8, and 12.
subdata&lt;-spT.subset(data=NYdata, var.name=c("s.index"), s=c(2,8,12), reverse=TRUE)
   
##
</code></pre>

<hr>
<h2 id='spT.time'>Timer series information.</h2><span id='topic+spT.time'></span>

<h3>Description</h3>

<p>This function defines the time series in the spatio-temporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.time(t.series, segments=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.time_+3A_t.series">t.series</code></td>
<td>
<p>Number of times within each segment in each series. It could be either a scalar or a vector. It should be a scalar if the segments are of equal length and should be a vector of length <code>segments</code> whose entries give the length of the segments.</p>
</td></tr>  
<tr><td><code id="spT.time_+3A_segments">segments</code></td>
<td>
<p>Number of segments in each time series. This should  be a scalar. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 

# Equal length time-series in each of 3 years
time.data&lt;-spT.time(t.series=365,segments=3)

# Un-equal length time-series in 5 years
time.data&lt;-spT.time(t.series=c(366, 365, 365, 365, 366),segments=5)

##
</code></pre>

<hr>
<h2 id='spT.validation'>Validation Commands</h2><span id='topic+spT.validation'></span>

<h3>Description</h3>

<p>The following function is used to validate the predicted observations with the actual values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.validation(z, zhat, names=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.validation_+3A_z">z</code></td>
<td>
<p>The original values (matrix or vector).</p>
</td></tr>
<tr><td><code id="spT.validation_+3A_zhat">zhat</code></td>
<td>
<p>The predicted values (matrix or vector).</p>
</td></tr>
<tr><td><code id="spT.validation_+3A_names">names</code></td>
<td>
<p>Logical, if TRUE then print the names of the validation statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>MSE</code></td>
<td>
<p>Mean Squared Error.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Root Mean Squared Error.</p>
</td></tr>
<tr><td><code>MAE</code></td>
<td>
<p>Mean Absolute Error.</p>
</td></tr>
<tr><td><code>MAPE</code></td>
<td>
<p>Mean Absolute Percentage Error.</p>
</td></tr>
<tr><td><code>BIAS</code></td>
<td>
<p>Bias.</p>
</td></tr>
<tr><td><code>rBIAS</code></td>
<td>
<p>Relative Bias.</p>
</td></tr>
<tr><td><code>rMSEP</code></td>
<td>
<p>Relative Mean Separation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.pCOVER">spT.pCOVER</a>,<a href="#topic+spT.validation2">spT.validation2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

# Create `x', which is the true values.
# Create `y', which is the predicted values.

x &lt;- rnorm(10,5,0.1)
y &lt;- rnorm(10,5,1)
spT.validation(x, y)

##
</code></pre>

<hr>
<h2 id='spT.validation2'>Validation Commands</h2><span id='topic+spT.validation2'></span>

<h3>Description</h3>

<p>The following function is used to validate the predicted observations with the actual values based on some threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spT.validation2(z,zhat,cutoff,names=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spT.validation2_+3A_z">z</code></td>
<td>
<p>The original values (matrix or vector).</p>
</td></tr>
<tr><td><code id="spT.validation2_+3A_zhat">zhat</code></td>
<td>
<p>The predicted values (matrix or vector).</p>
</td></tr>
<tr><td><code id="spT.validation2_+3A_cutoff">cutoff</code></td>
<td>
<p>The threshold value or cut-off point.</p>
</td></tr>
<tr><td><code id="spT.validation2_+3A_names">names</code></td>
<td>
<p>Logical, if TRUE then print the names of the validation statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>TPR</code></td>
<td>
<p>True Positive Rate, Sensitivity, Hit rate, Recall</p>
</td></tr>
<tr><td><code>FPR</code></td>
<td>
<p>False Positive Rate, False alarm</p>
</td></tr>
<tr><td><code>FNR</code></td>
<td>
<p>False Negative Rate, Miss rate</p>
</td></tr>
<tr><td><code>TNR</code></td>
<td>
<p>True Negative Rate, Specificity</p>
</td></tr>
<tr><td><code>Prevalence</code></td>
<td>
<p>Prevalence</p>
</td></tr>
<tr><td><code>Accuracy</code></td>
<td>
<p>Accuracy</p>
</td></tr>
<tr><td><code>Precision</code></td>
<td>
<p>Precision, Positive Predictive Value</p>
</td></tr>
<tr><td><code>FOR</code></td>
<td>
<p>False Ommission Rate</p>
</td></tr>
<tr><td><code>LRp</code></td>
<td>
<p>Positive Likelihood Ratio</p>
</td></tr>
<tr><td><code>LRn</code></td>
<td>
<p>Negative Likelihood Ratio</p>
</td></tr>
<tr><td><code>FDR</code></td>
<td>
<p>False Discovery Rate</p>
</td></tr>
<tr><td><code>NPV</code></td>
<td>
<p>Negative Predictive Value</p>
</td></tr>
<tr><td><code>DOR</code></td>
<td>
<p>Diagnostic Odds Ratio</p>
</td></tr>
<tr><td><code>F1score</code></td>
<td>
<p>F1 score</p>
</td></tr> 
<tr><td><code>Heidke.Skill</code></td>
<td>
<p>Heidke Skill</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.pCOVER">spT.pCOVER</a>,<a href="#topic+spT.validation">spT.validation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

# Create `x', which is the true values.
# Create `y', which is the predicted values.

x &lt;- rnorm(100,0,0.1)
y &lt;- rnorm(100,0,1)
spT.validation2(x, y, cutoff=0,names=TRUE)

##
</code></pre>

<hr>
<h2 id='spTimer-internal'>Service functions and some undocumented functions for the spTimer library</h2><span id='topic+.First.lib'></span><span id='topic+.onLoad'></span><span id='topic+.onAttach'></span><span id='topic+as.forecast.object'></span><span id='topic+stat.sum'></span><span id='topic+Formula.matrix'></span><span id='topic+Formula.coords'></span><span id='topic+Gamm'></span><span id='topic+Norm'></span><span id='topic+Unif'></span><span id='topic+PMCC'></span><span id='topic+fnc.time'></span><span id='topic+initials.checking.ar'></span><span id='topic+initials.checking.gp'></span><span id='topic+initials.checking.gpp'></span><span id='topic+print.spT'></span><span id='topic+print.spTpred'></span><span id='topic+print.spTprd'></span><span id='topic+print.spTfore'></span><span id='topic+priors.checking.ar'></span><span id='topic+priors.checking.gp'></span><span id='topic+priors.checking.gpp'></span><span id='topic+spAR.Gibbs'></span><span id='topic+spAR.MCMC.Pred'></span><span id='topic+spAR.forecast'></span><span id='topic+spAR.prediction'></span><span id='topic+spGP.Gibbs'></span><span id='topic+spGP.MCMC.Pred'></span><span id='topic+spGP.forecast'></span><span id='topic+spGP.prediction'></span><span id='topic+spGPP.Gibbs'></span><span id='topic+spGPP.MCMC.Pred'></span><span id='topic+spGPP.forecast'></span><span id='topic+spGPP.prediction'></span><span id='topic+spT.fit.pred'></span><span id='topic+spT.forecast'></span><span id='topic+spT.prediction'></span><span id='topic+spT.Summary.Stat'></span><span id='topic+spT.MCMC.plot'></span><span id='topic+spT.MCMC.stat'></span><span id='topic+as.mcmc.spT'></span><span id='topic+MCMC.plot.obj'></span><span id='topic+coef.spT'></span><span id='topic+model.frame.spT'></span><span id='topic+residuals.spT'></span><span id='topic+formula.spT'></span><span id='topic+terms.spT'></span><span id='topic+model.matrix.spT'></span><span id='topic+sp.dimname.fnc'></span><span id='topic+tp.dimname.fnc'></span><span id='topic+tp'></span><span id='topic+sp'></span><span id='topic+spT.ObsGridLoc'></span><span id='topic+spT.ObsGridData'></span><span id='topic+spT.gridTodata'></span><span id='topic+sptruncGP.Gibbs'></span><span id='topic+sptruncGPP.Gibbs'></span><span id='topic+truncated.fnc'></span><span id='topic+prob.below.threshold'></span><span id='topic+reverse.truncated.fnc'></span>

<h3>Description</h3>

<p>Internal spTimer functions</p>

<hr>
<h2 id='summary.spT'>Summary statistics of the parameters.</h2><span id='topic+summary.spT'></span>

<h3>Description</h3>

<p>This function is used to obtain MCMC summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spT'
summary(object, digits=4, package="spTimer", coefficient=NULL, ...)

## 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.spT_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from &quot;spT&quot;.</p>
</td></tr>
<tr><td><code id="summary.spT_+3A_digits">digits</code></td>
<td>
<p>Rounds the specified number of decimal places (default 4).</p>
</td></tr>
<tr><td><code id="summary.spT_+3A_package">package</code></td>
<td>
<p>If &quot;coda&quot; then summary statistics are given using coda package. Defaults value is &quot;spTimer&quot;. One can also use &quot;spTDyn&quot; for obtaining spatially varying and temporal dynamic models (see details: https://cran.r-project.org/web/packages/spTDyn/index.html)</p>
</td></tr>
<tr><td><code id="summary.spT_+3A_coefficient">coefficient</code></td>
<td>
<p>Only applicable for package &quot;spTDyn&quot;.</p>
</td></tr>
<tr><td><code id="summary.spT_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sig2eps</code></td>
<td>
<p>Summary statistics for <code class="reqn">\sigma_\epsilon^2</code>.</p>
</td></tr> 
<tr><td><code>sig2eta</code></td>
<td>
<p>Summary statistics for <code class="reqn">\sigma_\eta^2</code>.</p>
</td></tr> 
<tr><td><code>phi</code></td>
<td>
<p>Summary statistics for spatial decay parameter <code class="reqn">\phi</code>, if estimated using <code>spT.decay</code>.</p>
</td></tr> 
<tr><td><code>...</code></td>
<td>
<p>Summary statistics for other parameters used in the models.</p>
</td></tr> 
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spT.Gibbs">spT.Gibbs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##

summary(out) # where out is the output from spT class
summary(out, digit=2) # where out is the output from spT class
summary(out, pack="coda") # where out is the output from spT class

##

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
