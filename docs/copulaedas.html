<!DOCTYPE html><html><head><title>Help for package copulaedas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {copulaedas}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CEDA-class'><p>Class for Copula EDAs</p></a></li>
<li><a href='#EDA-class'><p>Base Class for EDAs</p></a></li>
<li><a href='#edaCriticalPopSize'><p>Critical Population Size</p></a></li>
<li><a href='#edaIndepRuns'><p>Independent Runs</p></a></li>
<li><a href='#edaOptimize'><p>Local Optimization Methods</p></a></li>
<li><a href='#edaReplace'><p>Replacement Methods</p></a></li>
<li><a href='#edaReport'><p>Reporting Methods</p></a></li>
<li><a href='#EDAResult-class'><p>Class for the Results of a Run of an EDA</p></a></li>
<li><a href='#EDAResults-class'><p>Class for the Results of a Sequence of Runs of an EDA</p></a></li>
<li><a href='#edaRun'><p>Main Loop of an EDA</p></a></li>
<li><a href='#edaSeed'><p>Seeding Methods</p></a></li>
<li><a href='#edaSelect'><p>Selection Methods</p></a></li>
<li><a href='#edaTerminate'><p>Termination Methods</p></a></li>
<li><a href='#margins'><p>Marginal Distributions</p></a></li>
<li><a href='#problems'><p>Benchmark Problems</p></a></li>
<li><a href='#VEDA-class'><p>Class for Vine EDAs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of Distribution Algorithms Based on Copulas</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a platform where EDAs (estimation of
    distribution algorithms) based on copulas can be implemented and
    studied. The package offers complete implementations of various
    EDAs based on copulas and vines, a group of well-known
    optimization problems, and utility functions to study the
    performance of the algorithms. Newly developed EDAs can be easily
    integrated into the package by extending an S4 class with generic
    functions for their main components.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yasserglez/copulaedas">https://github.com/yasserglez/copulaedas</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>copula, vines, mvtnorm, truncnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cec2005benchmark, cec2013</td>
</tr>
<tr>
<td>Collate:</td>
<td>EDA.R edaSeed.R edaSelect.R edaOptimize.R edaReport.R
edaReplace.R edaTerminate.R edaRun.R margins.R problems.R
edaIndepRuns.R edaCriticalPopSize.R CEDA.R VEDA.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-29 05:19:56 UTC; yasserglez</td>
</tr>
<tr>
<td>Author:</td>
<td>Yasser Gonzalez-Fernandez [aut, cre],
  Marta Soto [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yasser Gonzalez-Fernandez &lt;ygonzalezfernandez@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-29 05:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='CEDA-class'>Class for Copula EDAs</h2><span id='topic+CEDA'></span><span id='topic+CEDA-class'></span><span id='topic+edaLearnCEDA'></span><span id='topic+edaSampleCEDA'></span><span id='topic+edaLearn+2CCEDA-method'></span><span id='topic+edaSample+2CCEDA-method'></span>

<h3>Description</h3>

<p>Extends the <code><a href="#topic+EDA-class">EDA</a></code> class to implement EDAs based on
multivariate copulas. Objects are created by calling the <code>CEDA</code>
function.
</p>


<h3>Details</h3>

<p>Copula EDAs (CEDA) are a class of EDAs that model the search distributions
using a multivariate copula. These algorithms estimate separately the
univariate marginal distributions and the dependence structure from the
selected population. The dependence structure is represented through a
multivariate copula. The following instances of CEDA are implemented.
</p>

<ul>
<li><p>If the dependence structure is modeled using a product copula,
the resulting algorithm corresponds to the Univariate Marginal
Distribution Algorithm (UMDA) for the continuous domain
(Larrañaga et al. 1999, 2000).
</p>
</li>
<li><p>If the dependence structure is modeled using a normal copula, the
resulting algorithm corresponds to the Gaussian Copula Estimation of
Distribution Algorithm (GCEDA) (Soto et al. 2007; Arderí 2007).
If non-normal marginal distributions are used, the correlation
matrix is calculated using the inversion of Kendall's tau for each pair
of variables (Demarta and McNeil 2005). The correction proposed in
(Rousseeuw and Molenberghs 1993) is applied if the resulting correlation
matrix is not positive-definite. If normal marginal distributions are
used, the correlation matrix is estimated directly from the
selected population using the <code><a href="stats.html#topic+cor">cor</a></code> function.
</p>
</li></ul>

<p>The following parameters are recognized by the functions that implement the
<code><a href="#topic+edaLearn">edaLearn</a></code> and <code><a href="#topic+edaSample">edaSample</a></code> methods for the
<code><a href="#topic+CEDA-class">CEDA</a></code> class.
</p>

<dl>
<dt><code>copula</code></dt><dd><p>Multivariate copula. Supported values are:
<code>"indep"</code> (independence or product copula) and <code>"normal"</code>
(normal copula). Default value: <code>"normal"</code>.</p>
</dd>
<dt><code>margin</code></dt><dd><p>Marginal distributions. If this argument is <code>"xxx"</code>,
the algorithm will search for three functions named <code>fxxx</code>.
<code>pxxx</code> and <code>qxxx</code> to fit each marginal distribution
and evaluate the cumulative distribution function and its inverse,
respectively. Default value: <code>"norm"</code>.</p>
</dd>
<dt><code>popSize</code></dt><dd><p>Population size. Default value: <code>100</code>.</p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>See the documentation of the slot in the
<code><a href="#topic+EDA-class">EDA</a></code> class.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>See the documentation of the slot in the
<code><a href="#topic+EDA-class">EDA</a></code> class.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>edaLearn</dt><dd><p><code>signature(eda = "CEDA")</code>: The <code>edaLearnCEDA</code>
function.</p>
</dd>
<dt>edaSample</dt><dd><p><code>signature(eda = "CEDA")</code>: The <code>edaSampleCEDA</code>
function.</p>
</dd>
</dl>



<h3>References</h3>

<p>Arderí RJ (2007). Algoritmo con estimación de distribuciones con cópula gaussiana.
Bachelor's thesis, University of Havana, Cuba.
</p>
<p>Demarta S, McNeil AJ (2005). The t Copula and Related Copulas.
<em>International Statistical Review</em>, <b>73</b>(1), 111&ndash;129.
</p>
<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>
<p>Larrañaga P, Etxeberria R, Lozano JA, Peña JM (1999). Optimization by Learning
and Simulation of Bayesian and Gaussian Networks. Technical Report
EHU-KZAA-IK-4/99, University of the Basque Country.
</p>
<p>Larrañaga P, Etxeberria R, Lozano JA, Peña JM (2000). Optimization in
Continuous Domains by Learning and Simulation of Gaussian Networks.
In <em>Proceedings of the Workshop in Optimization by Building and Using
Probabilistic Models in the Genetic and Evolutionary Computation
Conference (GECCO 2000)</em>, pp. 201&ndash;204.
</p>
<p>Rousseeuw P, Molenberghs G (1993). Transformation of Nonpositive Semidefinite
Correlation Matrices. <em>Communications in Statistics: Theory and Methods</em>,
<b>22</b>, 965&ndash;984.
</p>
<p>Soto M, Ochoa A, Arderí RJ (2007). Gaussian Copula Estimation of Distribution
Algorithm. Technical Report ICIMAF 2007-406, Institute of Cybernetics,
Mathematics and Physics, Cuba. ISSN 0138-8916.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setMethod("edaTerminate", "EDA", edaTerminateEval)
setMethod("edaReport", "EDA", edaReportSimple)

UMDA &lt;- CEDA(copula = "indep", margin = "norm",
    popSize = 200, fEval = 0, fEvalTol = 1e-03)
UMDA@name &lt;- "Univariate Marginal Distribution Algorithm"

GCEDA &lt;- CEDA(copula = "normal", margin = "norm",
    popSize = 200, fEval = 0, fEvalTol = 1e-03)
GCEDA@name &lt;- "Gaussian Copula Estimation of Distribution Algorithm"

resultsUMDA &lt;- edaRun(UMDA, fSphere, rep(-600, 5), rep(600, 5))
resultsGCEDA &lt;- edaRun(GCEDA, fSphere, rep(-600, 5), rep(600, 5))

show(resultsUMDA)
show(resultsGCEDA)
</code></pre>

<hr>
<h2 id='EDA-class'>Base Class for EDAs</h2><span id='topic+EDA-class'></span><span id='topic+edaSeed+2CEDA-method'></span><span id='topic+edaSelect+2CEDA-method'></span><span id='topic+edaOptimize+2CEDA-method'></span><span id='topic+edaReplace+2CEDA-method'></span><span id='topic+edaReport+2CEDA-method'></span><span id='topic+edaTerminate+2CEDA-method'></span><span id='topic+show+2CEDA-method'></span>

<h3>Description</h3>

<p>Base class of all the classes that implement EDAs in the package.
This is a virtual class, no object may be created from it.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Object of class <code>character</code>.
Name of the EDA.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>Object of class <code>list</code>.
Parameters of the EDA.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>edaSeed</dt><dd><p><code>signature(eda = "EDA")</code>: Seeding method.
Default: <code><a href="#topic+edaSeedUniform">edaSeedUniform</a></code>.</p>
</dd>
<dt>edaSelect</dt><dd><p><code>signature(eda = "EDA")</code>: Selection method.
Default: <code><a href="#topic+edaSelectTruncation">edaSelectTruncation</a></code>.</p>
</dd>
<dt>edaOptimize</dt><dd><p><code>signature(eda = "EDA")</code>: Local optimization method.
Default: <code><a href="#topic+edaOptimizeDisabled">edaOptimizeDisabled</a></code>.</p>
</dd>
<dt>edaReplace</dt><dd><p><code>signature(eda = "EDA")</code>: Replacement method.
Default: <code><a href="#topic+edaReplaceComplete">edaReplaceComplete</a></code>.</p>
</dd>
<dt>edaReport</dt><dd><p><code>signature(eda = "EDA")</code>: Reporting method.
Default: <code><a href="#topic+edaReportDisabled">edaReportDisabled</a></code>.</p>
</dd>
<dt>edaTerminate</dt><dd><p><code>signature(eda = "EDA")</code>: Termination method.
Default: <code><a href="#topic+edaTerminateMaxGen">edaTerminateMaxGen</a></code>.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "EDA")</code>: Print a textual
representation of the EDA.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CEDA-class">CEDA</a></code>,
<code><a href="#topic+VEDA-class">VEDA</a></code>,
<code><a href="#topic+edaRun">edaRun</a></code>.
</p>

<hr>
<h2 id='edaCriticalPopSize'>Critical Population Size</h2><span id='topic+edaCriticalPopSize'></span>

<h3>Description</h3>

<p>Determine the critical population size using a bisection method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaCriticalPopSize(eda, f, lower, upper, fEval, fEvalTol,
    totalRuns = 30, successRuns = totalRuns, lowerPop = 2,
    upperPop = NA, stopPercent = 10, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaCriticalPopSize_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_f">f</code></td>
<td>
<p>Objective function.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_lower">lower</code></td>
<td>
<p>Lower bounds of the variables of the objective function.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_upper">upper</code></td>
<td>
<p>Upper bounds of the variables of the objective function.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_feval">fEval</code></td>
<td>
<p>Optimum value of the objective function.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_fevaltol">fEvalTol</code></td>
<td>
<p>A run is considered successful if the difference between
<code>fEval</code> and the best found solution is less than <code>fEvalTol</code>.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_totalruns">totalRuns</code></td>
<td>
<p>Total number of runs.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_successruns">successRuns</code></td>
<td>
<p>Required number of successfully runs.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_lowerpop">lowerPop</code></td>
<td>
<p>Lower bound of the initial interval for the population.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_upperpop">upperPop</code></td>
<td>
<p>Upper bound of the initial interval for the population.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_stoppercent">stopPercent</code></td>
<td>
<p>Stop percent.</p>
</td></tr>
<tr><td><code id="edaCriticalPopSize_+3A_verbose">verbose</code></td>
<td>
<p>Print progress information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines the minimum population size required by the EDA to
reach the value <code>fEval</code> of the objective function in <code>successRuns</code>
runs out of a total of <code>totalRuns</code> independent runs (critical
population size).
</p>
<p>The population size is determined using a bisection method starting with the
interval delimited by <code>lowerPop</code> and <code>upperPop</code>. The bisection
procedure stops when the estimated population size is less than
<code>stopPercent</code> percent away from the critical population size. If either
<code>lowerPop</code> or <code>upperPop</code> is not specified, the algorithm will
determine an initial interval based on the value of the <code>popSize</code>
parameter and then continue using the bisection method.
</p>
<p>See (Pelikan 2005) for a pseudocode of a similar algorithm.
</p>


<h3>Value</h3>

<p>Either <code>NULL</code> if the critical population size was not determined or
an <code><a href="#topic+EDAResults-class">EDAResults</a></code> instance with the results of the runs
of the EDA using the critical population size.
</p>


<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>
<p>Pelikan M (2005). <em>Hierarchical Bayesian Optimization Algorithm.
Toward a New Generation of Evolutionary Algorithms</em>. Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EDA-class">EDA</a></code>,
<code><a href="#topic+edaRun">edaRun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setMethod("edaReport", "EDA", edaReportDisabled)
setMethod("edaTerminate", "EDA",
    edaTerminateCombined(edaTerminateEval,
        edaTerminateMaxEvals))

UMDA &lt;- CEDA(copula = "indep", margin = "norm",
    fEval = 0, fEvalTol = 1e-03, maxEvals = 10000)
UMDA@name &lt;- "Univariate Marginal Distribution Algorithm"

results &lt;- edaCriticalPopSize(UMDA, fSphere, rep(-600, 10),
    rep(600, 10), 0, 1e-03, totalRuns = 30, successRuns = 30,
    lowerPop = 50, upperPop = 100, verbose = TRUE)

show(results)
summary(results)
</code></pre>

<hr>
<h2 id='edaIndepRuns'>Independent Runs</h2><span id='topic+edaIndepRuns'></span>

<h3>Description</h3>

<p>Execute independent runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaIndepRuns(eda, f, lower, upper, runs, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaIndepRuns_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaIndepRuns_+3A_f">f</code></td>
<td>
<p>Objective function.</p>
</td></tr>
<tr><td><code id="edaIndepRuns_+3A_lower">lower</code></td>
<td>
<p>Lower bounds of the variables of the objective function.</p>
</td></tr>
<tr><td><code id="edaIndepRuns_+3A_upper">upper</code></td>
<td>
<p>Upper bounds of the variables of the objective function.</p>
</td></tr>
<tr><td><code id="edaIndepRuns_+3A_runs">runs</code></td>
<td>
<p>Number of runs.</p>
</td></tr>
<tr><td><code id="edaIndepRuns_+3A_verbose">verbose</code></td>
<td>
<p>Print information after each run and a final summary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+EDAResults-class">EDAResults</a></code> instance.
</p>


<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EDA-class">EDA</a></code>,
<code><a href="#topic+edaRun">edaRun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setMethod("edaReport", "EDA", edaReportSimple)
setMethod("edaTerminate", "EDA",
    edaTerminateCombined(edaTerminateMaxGen,
        edaTerminateEval))

DVEDA &lt;- VEDA(vine = "DVine", copulas = c("normal"),
    indepTestSigLevel = 0.01, margin = "norm", popSize = 200,
    maxGens = 50, fEval = 0, fEvalTol = 1e-03)
DVEDA@name &lt;- "D-vine Estimation of Distribution Algorithm"

results &lt;- edaIndepRuns(DVEDA, fSphere, rep(-600, 5), rep(600, 5), 5)

show(results)
summary(results)
</code></pre>

<hr>
<h2 id='edaOptimize'>Local Optimization Methods</h2><span id='topic+edaOptimize'></span><span id='topic+edaOptimizeDisabled'></span>

<h3>Description</h3>

<p>Methods for the <code>edaOptimize</code> generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaOptimizeDisabled(eda, gen, pop, popEval, f, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaOptimize_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaOptimize_+3A_gen">gen</code></td>
<td>
<p>Generation.</p>
</td></tr>
<tr><td><code id="edaOptimize_+3A_pop">pop</code></td>
<td>
<p>Matrix with one row for each solution in the population.</p>
</td></tr>
<tr><td><code id="edaOptimize_+3A_popeval">popEval</code></td>
<td>
<p>Vector with the evaluation of each solution in <code>pop</code>.</p>
</td></tr>
<tr><td><code id="edaOptimize_+3A_f">f</code></td>
<td>
<p>Objective function.</p>
</td></tr>
<tr><td><code id="edaOptimize_+3A_lower">lower</code></td>
<td>
<p>Lower bounds of the variables of the objective function.</p>
</td></tr>
<tr><td><code id="edaOptimize_+3A_upper">upper</code></td>
<td>
<p>Upper bounds of the variables of the objective function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local optimization methods improve the solutions sampled by the search
distribution. These methods can also be used to implement repairing
strategies for constrained problems in which the simulated solutions may be
unfeasible and some strategy to repair these solutions is available.
</p>
<p>The following local optimization methods are implemented.
</p>

<dl>
<dt><code>edaOptimizeDisabled</code></dt><dd><p>Disable local optimization. This is
the default method of the <code>edaOptimize</code> generic function.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>list</code> with the following components.
</p>
<table>
<tr><td><code>pop</code></td>
<td>
<p>Matrix with one row for each solution in the optimized population.</p>
</td></tr>
<tr><td><code>popEval</code></td>
<td>
<p>Vector with the evaluation of each solution in <code>pop</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>

<hr>
<h2 id='edaReplace'>Replacement Methods</h2><span id='topic+edaReplace'></span><span id='topic+edaReplaceComplete'></span><span id='topic+edaReplaceRTR'></span>

<h3>Description</h3>

<p>Methods for the <code>edaReplace</code> generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaReplaceComplete(eda, gen, pop, popEval, sampledPop, sampledEval)
edaReplaceRTR(eda, gen, pop, popEval, sampledPop, sampledEval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaReplace_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaReplace_+3A_gen">gen</code></td>
<td>
<p>Generation.</p>
</td></tr>
<tr><td><code id="edaReplace_+3A_pop">pop</code></td>
<td>
<p>Matrix with one row for each solution in the population.</p>
</td></tr>
<tr><td><code id="edaReplace_+3A_popeval">popEval</code></td>
<td>
<p>Vector with the evaluation of each solution in <code>pop</code>.</p>
</td></tr>
<tr><td><code id="edaReplace_+3A_sampledpop">sampledPop</code></td>
<td>
<p>Matrix with one row for each solution sampled in the
current generation.</p>
</td></tr>
<tr><td><code id="edaReplace_+3A_sampledeval">sampledEval</code></td>
<td>
<p>Vector with the evaluation of the candidate solutions
in <code>sampledPop</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replacement methods combine the candidate solutions sampled in the current
generation with the candidate solutions from the population of the previous
generation. The following replacement methods are implemented.
</p>

<dl>
<dt><code>edaReplaceComplete</code></dt><dd><p>The population sampled in the current
generation completely replaces the population of the previous generation.
This is the default method of the <code>edaReplace</code> generic function.</p>
</dd>
<dt><code>edaReplaceRTR</code></dt><dd><p>Restricted Tournament Replacement is a niching
method that can be used to promote the preservation of alternative candidate
solutions. See (Pelikan 2005) for a pseudocode of the algorithm implemented
here. The parameter <code>windowSize</code> specifies the window size (default
value: <code>min(ncol(pop), nrow(pop) / 2)</code>).</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>list</code> with the following components.
</p>
<table>
<tr><td><code>pop</code></td>
<td>
<p>Matrix with one row for each solution in the new population.</p>
</td></tr>
<tr><td><code>popEval</code></td>
<td>
<p>Vector with the evaluation of each solution in <code>pop</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>

<hr>
<h2 id='edaReport'>Reporting Methods</h2><span id='topic+edaReport'></span><span id='topic+edaReportDisabled'></span><span id='topic+edaReportSimple'></span><span id='topic+edaReportDumpPop'></span><span id='topic+edaReportDumpSelectedPop'></span><span id='topic+edaReportCombined'></span>

<h3>Description</h3>

<p>Methods for the <code>edaReport</code> generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaReportDisabled(eda, gen, fEvals, model, pop, popEval)
edaReportSimple(eda, gen, fEvals, model, pop, popEval)
edaReportDumpPop(eda, gen, fEvals, model, pop, popEval)
edaReportDumpSelectedPop(eda, gen, fEvals, model, pop, popEval)
edaReportCombined(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaReport_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaReport_+3A_gen">gen</code></td>
<td>
<p>Generation.</p>
</td></tr>
<tr><td><code id="edaReport_+3A_fevals">fEvals</code></td>
<td>
<p>Evaluations of the objective function.</p>
</td></tr>
<tr><td><code id="edaReport_+3A_model">model</code></td>
<td>
<p>Model learned in the current generation.</p>
</td></tr>
<tr><td><code id="edaReport_+3A_pop">pop</code></td>
<td>
<p>Matrix with one row for each solution in the population.</p>
</td></tr>
<tr><td><code id="edaReport_+3A_popeval">popEval</code></td>
<td>
<p>Vector with the evaluation of each solution in <code>pop</code>.</p>
</td></tr>
<tr><td><code id="edaReport_+3A_...">...</code></td>
<td>
<p>Functions that implement reporting methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reporting methods provide progress information during the execution of the
EDA. The following reporting methods are implemented.
</p>

<dl>
<dt><code>edaReportDisabled</code></dt><dd><p>Disable reporting progress. This is the
default method of the <code>edaReport</code> generic function.</p>
</dd>
<dt><code>edaReportSimple</code></dt><dd><p>Print one line at each generation with the
number of generations, and the minimum, mean and standard deviation of
the evaluation of the candidate solutions in the population.</p>
</dd>
<dt><code>edaReportDumpPop</code></dt><dd><p>Save the population at each generation
in a different plain-text file in the current working directory.
The names of the files are <code>pop_1.txt</code>, <code>pop_2.txt</code>,
and so on.</p>
</dd>
<dt><code>edaReportDumpSelectedPop</code></dt><dd><p>Save the selected population at
each generation in a different plain-text file in the current working
directory. The names of the files are <code>sel_1.txt</code>, <code>sel_2.txt</code>,
and so on.</p>
</dd>
<dt><code>edaReportCombined</code></dt><dd><p>Execute all the reporting methods specified
in <code>...</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>

<hr>
<h2 id='EDAResult-class'>Class for the Results of a Run of an EDA</h2><span id='topic+EDAResult-class'></span><span id='topic+show+2CEDAResult-method'></span>

<h3>Description</h3>

<p>Results of a run of an EDA. Objects are created by calling the
<code><a href="#topic+edaRun">edaRun</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>eda</code>:</dt><dd><p>Object of class <code>EDA</code>.</p>
</dd>
<dt><code>f</code>:</dt><dd><p>Object of class <code>function</code>. Objective function.</p>
</dd>
<dt><code>lower</code>:</dt><dd><p>Object of class <code>numeric</code>. Lower bounds of
the variables of the objective function.</p>
</dd>
<dt><code>upper</code>:</dt><dd><p>Object of class <code>numeric</code>. Upper bounds of
the variables of the objective function.</p>
</dd>
<dt><code>numGens</code>:</dt><dd><p>Object of class <code>numeric</code>. Number of
generations.</p>
</dd>
<dt><code>fEvals</code>:</dt><dd><p>Object of class <code>numeric</code>. Number of
evaluations of the objective function.</p>
</dd>
<dt><code>bestEval</code>:</dt><dd><p>Object of class <code>numeric</code>. Best evaluation
of the objective function.</p>
</dd>
<dt><code>bestSol</code>:</dt><dd><p>Object of class <code>numeric</code>. Best solution.</p>
</dd>
<dt><code>cpuTime</code>:</dt><dd><p>Object of class <code>numeric</code>. Run time of the
algorithm in seconds.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "EDAResult")</code>: Prints the results.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EDA-class">EDA</a></code>,
<code><a href="#topic+edaRun">edaRun</a></code>.
</p>

<hr>
<h2 id='EDAResults-class'>Class for the Results of a Sequence of Runs of an EDA</h2><span id='topic+EDAResults-class'></span><span id='topic+show+2CEDAResults-method'></span><span id='topic+summary+2CEDAResults-method'></span>

<h3>Description</h3>

<p>Results of a sequence of independent runs of an EDA. This class is just a
wrapper for a <code>list</code> object containing <code><a href="#topic+EDAResult-class">EDAResult</a></code>
instances. Objects are created by calling the <code><a href="#topic+edaIndepRuns">edaIndepRuns</a></code>
function.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "EDAResults")</code>: Prints a table with
the results.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "EDAResults")</code>: Prints a summary
of the results.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EDA-class">EDA</a></code>,
<code><a href="#topic+edaIndepRuns">edaIndepRuns</a></code>.
</p>

<hr>
<h2 id='edaRun'>Main Loop of an EDA</h2><span id='topic+edaRun'></span><span id='topic+edaLearn'></span><span id='topic+edaSample'></span>

<h3>Description</h3>

<p>Main loop of an EDA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaRun(eda, f, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaRun_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaRun_+3A_f">f</code></td>
<td>
<p>Objective function.</p>
</td></tr>
<tr><td><code id="edaRun_+3A_lower">lower</code></td>
<td>
<p>Lower bounds of the variables of the objective function.</p>
</td></tr>
<tr><td><code id="edaRun_+3A_upper">upper</code></td>
<td>
<p>Upper bounds of the variables of the objective function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>EDAs are implemented using S4 classes with generic functions for its main
parts: seeding (<code><a href="#topic+edaSeed">edaSeed</a></code>), selection (<code><a href="#topic+edaSelect">edaSelect</a></code>),
learning (<code>edaLearn</code>), sampling (<code>edaSample</code>), replacement
(<code><a href="#topic+edaReplace">edaReplace</a></code>), local optimization (<code><a href="#topic+edaOptimize">edaOptimize</a></code>),
termination (<code><a href="#topic+edaTerminate">edaTerminate</a></code>), and reporting
(<code><a href="#topic+edaReport">edaReport</a></code>). The following pseudocode illustrates the interactions
between all the generic functions. It is a simplified version of the
implementation of the <code><a href="#topic+edaRun">edaRun</a></code> function.
</p>
<pre>
gen &lt;- 0
fEvals &lt;- 0
terminate &lt;- FALSE

while (!terminate) {
  gen &lt;- gen + 1

  if (gen == 1) {
    model &lt;- NULL
    pop &lt;- edaSeed(lower, upper)
    # Set popEval to the evaluation of each solution in pop.
    # Update fEvals.
    r &lt;- edaOptimize(gen, pop, popEval, f, lower, upper)
    pop &lt;- r$pop; popEval &lt;- r$popEval
  } else {
    s &lt;- edaSelect(gen, pop, popEval)
    selectedPop &lt;- pop[s, ]; selectedEval &lt;- popEval[s]
    model &lt;- edaLearn(gen, model, selectedPop, selectedEval,
                      lower, upper)
    sampledPop &lt;- edaSample(gen, model, lower, upper)
    # Set sampledEval to the evaluation of each solution
    # in sampledPop. Update fEvals.
    r &lt;- edaOptimize(gen, sampledPop, sampledEval, f, lower, upper)
    sampledPop &lt;- r$pop; sampledEval &lt;- r$popEval
    r &lt;- edaReplace(gen, pop, popEval, sampledPop, sampledEval)
    pop &lt;- r$pop; popEval &lt;- r$popEval
  }

  edaReport(gen, fEvals, model, pop, popEval)
  terminate &lt;- edaTerminate(gen, fEvals, pop, popEval)
}
</pre>


<h3>Value</h3>

<p>An <code><a href="#topic+EDAResult-class">EDAResult</a></code> instance.
</p>


<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EDA-class">EDA</a></code>,
<code><a href="#topic+EDAResult-class">EDAResult</a></code>,
<code><a href="#topic+edaIndepRuns">edaIndepRuns</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setMethod("edaReport", "EDA", edaReportSimple)
setMethod("edaTerminate", "EDA",
    edaTerminateCombined(edaTerminateMaxGen,
        edaTerminateEval))

DVEDA &lt;- VEDA(vine = "DVine", copulas = c("normal"),
    indepTestSigLevel = 0.01, margin = "norm",
    popSize = 200, maxGens = 50, fEval = 0,
    fEvalTol = 1e-03)
DVEDA@name &lt;- "D-vine Estimation of Distribution Algorithm"

result &lt;- edaRun(DVEDA, fSphere, rep(-600, 5), rep(600, 5))

show(result)
</code></pre>

<hr>
<h2 id='edaSeed'>Seeding Methods</h2><span id='topic+edaSeed'></span><span id='topic+edaSeedUniform'></span>

<h3>Description</h3>

<p>Methods for the <code>edaSeed</code> generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaSeedUniform(eda, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaSeed_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaSeed_+3A_lower">lower</code></td>
<td>
<p>Lower bounds of the variables of the objective function.</p>
</td></tr>
<tr><td><code id="edaSeed_+3A_upper">upper</code></td>
<td>
<p>Upper bounds of the variables of the objective function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Seeding methods create the initial population. The length of the <code>lower</code>
and <code>upper</code> vectors determine the number of variables of the objective
function. The following seeding methods are implemented.
</p>

<dl>
<dt><code>edaSeedUniform</code></dt><dd><p>Sample each variable from a continuous uniform
distribution in the interval determined by <code>lower</code> and <code>upper</code>.
The parameter <code>popSize</code> sets the number of solutions in the population
(default value: <code>100</code>). This is the default method of the
<code>edaSeed</code> generic function.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A matrix with one column for each variable of the objective function and one
row for each solution in the population.
</p>


<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>

<hr>
<h2 id='edaSelect'>Selection Methods</h2><span id='topic+edaSelect'></span><span id='topic+edaSelectTruncation'></span><span id='topic+edaSelectTournament'></span>

<h3>Description</h3>

<p>Methods for the <code>edaSelect</code> generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaSelectTruncation(eda, gen, pop, popEval)
edaSelectTournament(eda, gen, pop, popEval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaSelect_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaSelect_+3A_gen">gen</code></td>
<td>
<p>Generation.</p>
</td></tr>
<tr><td><code id="edaSelect_+3A_pop">pop</code></td>
<td>
<p>Matrix with one row for each solution in the population.</p>
</td></tr>
<tr><td><code id="edaSelect_+3A_popeval">popEval</code></td>
<td>
<p>Vector with the evaluation of each solution in <code>pop</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection methods determine the solutions to be modeled by the search
distribution (selected population). These solutions are usually the most
promising solutions of the population. The following selection methods are
implemented.
</p>

<dl>
<dt><code>edaSelectTruncation</code></dt><dd><p>In truncation selection, the
<code>100 * truncFactor</code> percent of the solutions with the best evaluation
in the population are selected. The parameter <code>truncFactor</code> specifies
the truncation factor (default value: <code>0.3</code>). This is the default
method of the <code>edaSelect</code> generic function.</p>
</dd>
<dt><code>edaSelectTournament</code></dt><dd><p>In tournament selection, a group of
solutions are randomly picked from the population and the best one is
selected. This process is repeated as many times as needed to complete
the selected population. The parameter <code>tournamentSize</code> specifies
the number of solutions randomly picked from the population (default
value: <code>2</code>), <code>selectionSize</code> specifies the size of the selected
population (default value: <code>nrow(pop)</code>), and <code>replacement</code>
specifies whether to sample with replacement or not (default value:
<code>TRUE</code>).</p>
</dd>
</dl>



<h3>Value</h3>

<p>An <code>integer</code> vector with the indexes of the solutions selected
from <code>pop</code>.
</p>


<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>
<p>Pelikan M (2005). <em>Hierarchical Bayesian Optimization Algorithm.
Toward a New Generation of Evolutionary Algorithms</em>. Springer-Verlag.
</p>

<hr>
<h2 id='edaTerminate'>Termination Methods</h2><span id='topic+edaTerminate'></span><span id='topic+edaTerminateMaxGen'></span><span id='topic+edaTerminateMaxEvals'></span><span id='topic+edaTerminateEval'></span><span id='topic+edaTerminateEvalStdDev'></span><span id='topic+edaTerminateCombined'></span>

<h3>Description</h3>

<p>Methods for the <code>edaTerminate</code> generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaTerminateMaxGen(eda, gen, fEvals, pop, popEval)
edaTerminateMaxEvals(eda, gen, fEvals, pop, popEval)
edaTerminateEval(eda, gen, fEvals, pop, popEval)
edaTerminateEvalStdDev(eda, gen, fEvals, pop, popEval)
edaTerminateCombined(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaTerminate_+3A_eda">eda</code></td>
<td>
<p><code><a href="#topic+EDA-class">EDA</a></code> instance.</p>
</td></tr>
<tr><td><code id="edaTerminate_+3A_gen">gen</code></td>
<td>
<p>Generation.</p>
</td></tr>
<tr><td><code id="edaTerminate_+3A_fevals">fEvals</code></td>
<td>
<p>Evaluations of the objective function.</p>
</td></tr>
<tr><td><code id="edaTerminate_+3A_pop">pop</code></td>
<td>
<p>Matrix with one row for each solution in the population.</p>
</td></tr>
<tr><td><code id="edaTerminate_+3A_popeval">popEval</code></td>
<td>
<p>Vector with the evaluation of each solution in <code>pop</code>.</p>
</td></tr>
<tr><td><code id="edaTerminate_+3A_...">...</code></td>
<td>
<p>Functions that implement termination methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Termination methods decide when to stop the main loop of the EDA.
The following termination methods are implemented.
</p>

<dl>
<dt><code>edaTerminateMaxGen</code></dt><dd><p>Stop when a maximum number of generations
has been reached. The parameter <code>maxGen</code> specifies the number of
generations (default value: <code>100</code>). This is the default
method of the <code>edaTerminate</code> generic function.</p>
</dd>
<dt><code>edaTerminateMaxEvals</code></dt><dd><p>Stop when a maximum number of evaluations
of the objective function has been reached. The parameter <code>maxEvals</code>
specifies the number of evaluations (default value: <code>1000</code>.)</p>
</dd>
<dt><code>edaTerminateEval</code></dt><dd><p>Stop when a given value of the objective
function has been reached. The parameters <code>fEval</code> (default value:
<code>0</code>) and <code>fEvalTol</code> (default value: <code>1e-06</code>) set the value
of the objective function and the tolerance, respectively.</p>
</dd>
<dt><code>edaTerminateEvalStdDev</code></dt><dd><p>Stop when the standard deviation of
the evaluation of the solutions in the population is less than the value
given by the parameter <code>fEvalStdDev</code> (default value: <code>1e-02</code>)</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>edaTerminateCombined</code></dt><dd><p>Evaluate all the termination criteria
specified in <code>...</code> and stop if (at least) one of them returns
<code>TRUE</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>logical</code> value that indicates if the algorithm should stop.
</p>


<h3>References</h3>

<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>

<hr>
<h2 id='margins'>Marginal Distributions</h2><span id='topic+fnorm'></span><span id='topic+ftruncnorm'></span><span id='topic+fkernel'></span><span id='topic+pkernel'></span><span id='topic+qkernel'></span><span id='topic+ftrunckernel'></span><span id='topic+ptrunckernel'></span><span id='topic+qtrunckernel'></span>

<h3>Description</h3>

<p>Functions that implement marginal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnorm(x, lower, upper)

ftruncnorm(x, lower, upper)

fkernel(x, lower, upper)
pkernel(q, X, h)
qkernel(p, X, h)

ftrunckernel(x, lower, upper)
ptrunckernel(q, a, b, X, h)
qtrunckernel(p, a, b, X, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margins_+3A_x">x</code>, <code id="margins_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="margins_+3A_lower">lower</code>, <code id="margins_+3A_a">a</code></td>
<td>
<p>Lower bound of the variable.</p>
</td></tr>
<tr><td><code id="margins_+3A_upper">upper</code>, <code id="margins_+3A_b">b</code></td>
<td>
<p>Upper bound of the variable.</p>
</td></tr>
<tr><td><code id="margins_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
<tr><td><code id="margins_+3A_x">X</code></td>
<td>
<p>Observations of the variable.</p>
</td></tr>
<tr><td><code id="margins_+3A_h">h</code></td>
<td>
<p>Bandwidth of the kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>fnorm</code>, <code><a href="stats.html#topic+pnorm">pnorm</a></code>, and <code><a href="stats.html#topic+qnorm">qnorm</a></code>
implement the normal marginal distributions for EDAs with the <code>margin</code>
parameter set to <code>"norm"</code>. The <code>fnorm</code> function fits the parameters,
it returns a <code>list</code> object with the mean (<code>mean</code> component) and
the standard deviation (<code>sd</code> component). These components determine the
values of the corresponding arguments of the <code><a href="stats.html#topic+pnorm">pnorm</a></code> and
<code><a href="stats.html#topic+qnorm">qnorm</a></code> functions.
</p>
<p>The functions <code>ftruncnorm</code>, <code><a href="truncnorm.html#topic+ptruncnorm">ptruncnorm</a></code>, and
<code><a href="truncnorm.html#topic+qtruncnorm">qtruncnorm</a></code> implement the normal marginal distributions for
EDAs with the <code>margin</code> parameter set to <code>"truncnorm"</code>. The
<code>ftruncnorm</code> function fits the parameters, it returns a <code>list</code>
object with the lower and upper bounds (<code>a</code> and <code>b</code> components,
respectively), the mean (<code>mean</code> component) and the standard deviation
(<code>sd</code> component). These components determine the values of the
corresponding arguments of the <code><a href="truncnorm.html#topic+ptruncnorm">ptruncnorm</a></code> and
<code><a href="truncnorm.html#topic+qtruncnorm">qtruncnorm</a></code> functions.
</p>
<p>The functions <code>fkernel</code>, <code>pkernel</code>, and <code>qkernel</code>
implement the kernel-smoothed empirical marginal distributions for EDAs
with the <code>margin</code> parameter set to <code>"kernel"</code>. The <code>fkernel</code>
function fits the marginal distribution, it returns a <code>list</code> object with
the observations of the variable (<code>X</code> component) and the bandwidth of a
Gaussian kernel density estimator (<code>h</code> component). The bandwidth is
calculated using Silverman's rule of thumb (see <code><a href="stats.html#topic+bw.nrd0">bw.nrd0</a></code>).
The components of the <code>list</code> object returned by <code>fkernel</code> are used
as aditional arguments in the <code>pkernel</code> and <code>qkernel</code> functions.
The <code>pkernel</code> function calculates the empirical cumulative distribution
function. The expression of the empirical cumulative distribution function
includes the modification used in the copula context to avoid problems
in the boundary of the <code class="reqn">[0,1]</code> interval. The <code>qkernel</code> function uses
the Gaussian kernel density estimator fitted by <code>fkernel</code> to evaluate the
inverse of the cumulative distribution function, following the procedure
suggested in (Azzalini 1981).
</p>
<p>The functions <code>ftrunckernel</code>, <code>ptrunckernel</code>, and <code>qtrunckernel</code>
implement the truncated kernel-smoothed empirical marginal distributions for
EDAs with the <code>margin</code> parameter set to <code>"trunckernel"</code>. The
distribution is computed from the corresponding kernel-smoothed empirical
marginal distributions without truncation by following the procedure
illustrated in (Nadarajah and Kotz 2006).
</p>


<h3>References</h3>

<p>Azzalini, A (1981) A Note on the Estimation of a Distribution Function and
Quantiles by a Kernel Method, <em>Biometrika</em>, <b>68</b>, 326-328.
</p>
<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>
<p>Nadarajah S, Kotz S (2006) <span class="rlang"><b>R</b></span> Programs for Computing Truncated Distributions,
<em>Journal of Statistical Software</em>, <b>16</b>, Code Snippet 2.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pnorm">pnorm</a></code>,
<code><a href="stats.html#topic+qnorm">qnorm</a></code>,
<code><a href="truncnorm.html#topic+ptruncnorm">ptruncnorm</a></code>,
<code><a href="truncnorm.html#topic+qtruncnorm">qtruncnorm</a></code>.
</p>

<hr>
<h2 id='problems'>Benchmark Problems</h2><span id='topic+fAckley'></span><span id='topic+fGriewank'></span><span id='topic+fRastrigin'></span><span id='topic+fRosenbrock'></span><span id='topic+fSphere'></span><span id='topic+fSummationCancellation'></span>

<h3>Description</h3>

<p>Implementation of a group of well-known benchmark problems typically used
to evaluate the performance of EDAs and other numerical optimization
algorithms for unconstrained global optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fAckley(x)
fGriewank(x)
fRosenbrock(x)
fRastrigin(x)
fSphere(x)
fSummationCancellation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="problems_+3A_x">x</code></td>
<td>
<p>A vector to be evaluated in the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of the functions for a vector
<code class="reqn">\boldsymbol{x}=(x_{1},\ldots,x_{n})</code> is given below.
</p>
<p style="text-align: center;"><code class="reqn">\texttt{fAckley}(\boldsymbol{x})=-20\exp\left(-0.2\sqrt{\frac{1}{n}\sum_{i=1}^{n}x^{2}}\right)-\exp\left(\frac{1}{n}\sum_{i=1}^{n}\cos\left(2\pi x_{i}\right)\right)+20+\exp\left(1\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">\texttt{fGriewank}(\boldsymbol{x})=1+\sum_{i=1}^{n}\frac{x_{i}^{2}}{4000}-\prod_{i=1}^{n}\cos\left(\frac{x_{i}}{\sqrt{i}}\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">\texttt{fRastrigin}(\boldsymbol{x})=\sum_{i=1}^{n}\left(x_i^2 - 10 \cos\left(2 \pi x_i\right) + 10\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">\texttt{fRosenbrock}(\boldsymbol{x})=\sum_{i=1}^{n-1}\left(100\left(x_{i+1}-x_{i}^{2}\right)^{2}+\left(1-x_{i}\right)^{2}\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">\texttt{fSphere}(\boldsymbol{x})=\sum_{i=1}^{n}x_{i}^{2}</code>
</p>

<p style="text-align: center;"><code class="reqn">\texttt{fSummationCancellation}(\boldsymbol{x})=\frac{-1}{10^{-5}+\sum_{i=1}^{n}|y_{i}|},\, y_{1}=x_{1},\, y_{i}=y_{i-1}+x_{i}</code>
</p>

<p>Ackley, Griewank, Rastrigin, Rosenbrock, and Sphere are minimization
problems. Summation Cancellation is originally a maximization problem but it
is expressed here as a minimization problem. Ackley, Griewank, Rastrigin and
Sphere have their global optimum at <code class="reqn">\boldsymbol{x}=(0,\ldots,0)</code>
with evaluation 0. Rosenbrock has its global optimum at
<code class="reqn">\boldsymbol{x}=(1,\ldots,1)</code> with evaluation 0. Summation Cancellation
has its global optimum at <code class="reqn">\boldsymbol{x}=(0,\ldots,0)</code> with evaluation
<code class="reqn">-10^{5}</code>. See (Bengoetxea et al. 2002; Bosman and Thierens 2006;
Chen and Lim 2008) for a description of the functions.
</p>


<h3>Value</h3>

<p>The value of the function for the vector <code>x</code>.
</p>


<h3>References</h3>

<p>Bengoetxea E, Miquélez T, Lozano JA, Larrañaga P (2002). Experimental Results
in Function Optimization with EDAs in Continuous Domain. In P Larrañaga,
JA Lozano (eds.), <em>Estimation of Distribution Algorithms. A New Tool
for Evolutionary Computation</em>, pp. 181&ndash;194. Kluwer Academic Publisher
</p>
<p>Bosman PAN, Thierens D (2006). Numerical Optimization with Real-Valued
Estimation of Distribution Algorithms. In M Pelikan, K Sastry, E Cantú-Paz
(eds.), <em>Scalable Optimization via Probabilistic Modeling. From Algorithms
to Applications</em>, pp. 91&ndash;120. Springer-Verlag.
</p>
<p>Chen Yp, Lim MH (eds.) (2008). Linkage in Evolutionary Computation.
Springer-Verlag. ISBN 978-3-540-85067-0.
</p>
<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.equal(fAckley(rep(0, 10)), 0)
all.equal(fGriewank(rep(0, 10)), 0)
all.equal(fRastrigin(rep(0, 10)), 0)
all.equal(fRosenbrock(rep(1, 10)), 0)
all.equal(fSphere(rep(0, 10)), 0)
all.equal(fSummationCancellation(rep(0, 10)), -1e+05)
</code></pre>

<hr>
<h2 id='VEDA-class'>Class for Vine EDAs</h2><span id='topic+VEDA'></span><span id='topic+VEDA-class'></span><span id='topic+edaLearnVEDA'></span><span id='topic+edaSampleVEDA'></span><span id='topic+edaLearn+2CVEDA-method'></span><span id='topic+edaSample+2CVEDA-method'></span>

<h3>Description</h3>

<p>Extends the <code><a href="#topic+EDA-class">EDA</a></code> class to implement EDAs based on vines.
Objects are created by calling the <code>VEDA</code> function.
</p>


<h3>Details</h3>

<p>Vine EDAs (VEDAs) are a class of EDAs (Soto and Gonzalez-Fernandez 2010;
Gonzalez-Fernandez 2011) that model the search distributions using vines.
Vines are graphical models that represent high-dimensional distributions by
decomposing the multivariate density into conditional bivariate copulas,
unconditional bivariate copulas, and one-dimensional densities
(Joe 1996; Bedford and Cooke 2001; Aas et al. 2009; Kurowicka and Cooke 2006).
In particular, VEDAs are based on the simplified pair-copula construction
(Hobaek Haff et al. 2010). Similarly to Copula EDAs, these algorithms estimate
separately the univariate marginal distributions and the dependence structure
from the selected population. Instead of representing the dependence structure
using a single multivariate copula, VEDAs can model a rich variety of
dependencies by combining bivariate copulas that belong to different families.
The following instances of VEDA are implemented.
</p>

<ul>
<li><p>C-vine EDA (CVEDA), that models the search distributions using C-vines
(Soto and Gonzalez-Fernandez 2010; Gonzalez-Fernandez 2011).
</p>
</li>
<li><p>D-vine EDA (DVEDA), that models the search distributions using D-vines
(Soto and Gonzalez-Fernandez 2010; Gonzalez-Fernandez 2011).
</p>
</li></ul>

<p>Greedy heuristics based on the empirical Kendall's tau between each variable
in the selected population are used to determine the structure of the C-vines
and D-vines in CVEDA and DVEDA, respectively (Brechmann 2010).
</p>
<p>The selection of each bivariate copula in both decompositions starts with
an independence test (Genest and Rémillard 2004; Genest et al. 2007).
The independence copula is selected if there is not enough evidence against
the null hypothesis of independence at a given significance level. In the
other case, the parameters of a group of candidate copulas are estimated
and the one that minimizes a distance to the empirical copula is selected.
A Cramér-von Mises statistic is used as the measure of distance
(Genest and Rémillard 2008).
</p>
<p>The parameters of all the candidate copulas but the t copula are estimated
using the inversion of Kendall's tau. In the case of the t copula,
the correlation coefficient is computed using the inversion of Kendall's tau
and the degrees of freedom are estimated by maximum likelihood with the
correlation parameter fixed (Demarta and McNeil 2005).
</p>
<p>To simplify the construction of the vines the truncation strategy presented in
(Brechmann 2010) is applied. If a vine is truncated at a given tree, all the
copulas in the subsequent trees are assumed to be product copulas. By default,
a model selection procedure based on AIC (Akaike Information Criterion) is
applied to detect the required number of trees, but it is also possible to
base the selection on BIC (Bayesian Information Criterion) or completely
disable the truncation strategy. Also, a maximum number of dependence trees
of the vine can be set, which may be helpful when dealing with high-dimensional
problems.
</p>
<p>The following parameters are recognized by the functions that implement
the <code><a href="#topic+edaLearn">edaLearn</a></code> and <code><a href="#topic+edaSample">edaSample</a></code> methods for the
<code><a href="#topic+VEDA-class">VEDA</a></code> class.
</p>

<dl>
<dt><code>vine</code></dt><dd><p>Vine type. Supported values are: <code>"CVine"</code>
(Canonical vine) and <code>"DVine"</code> (D-vine). Default value:
<code>"DVine"</code>.</p>
</dd>
<dt><code>trees</code></dt><dd><p>Maximum number of dependence trees of the vine.
The default is to estimate a full vine.</p>
</dd>
<dt><code>truncMethod</code></dt><dd><p>Method used to automatically truncate the vine if
enough dependence is captured in the first trees. Supported values
are: <code>"AIC"</code>, <code>"BIC"</code> and <code>""</code> (no truncation). Default
value: <code>"AIC"</code>.</p>
</dd>
<dt><code>copulas</code></dt><dd><p>A <code>character</code> vector specifying the candidate
copulas. Supported values are: <code>"normal"</code> (normal copula),
<code>"t"</code> (t copula), <code>"clayton"</code> (Clayton copula),
<code>"frank"</code> (Frank copula), and <code>"gumbel"</code> (Gumbel copula).
Default value: <code>c("normal")</code>.</p>
</dd>
<dt><code>indepTestSigLevel</code></dt><dd><p>Significance level of the independence
test. Default value: <code>0.01</code>.</p>
</dd>
<dt><code>margin</code></dt><dd><p>Marginal distributions. If this argument is <code>"xxx"</code>,
the algorithm will search for three functions named <code>fxxx</code>.
<code>pxxx</code> and <code>qxxx</code> to fit each marginal distribution
and evaluate the cumulative distribution function and its inverse,
respectively. Default value: <code>"norm"</code>.</p>
</dd>
<dt><code>popSize</code></dt><dd><p>Population size. Default value: <code>100</code>.</p>
</dd>
</dl>



<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>See the documentation of the slot in the
<code><a href="#topic+EDA-class">EDA</a></code> class.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>See the documentation of the slot in the
<code><a href="#topic+EDA-class">EDA</a></code> class.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>edaLearn</dt><dd><p><code>signature(eda = "CEDA")</code>: The <code>edaLearnCEDA</code>
function.</p>
</dd>
<dt>edaSample</dt><dd><p><code>signature(eda = "CEDA")</code>: The <code>edaSampleCEDA</code>
function.</p>
</dd>
</dl>



<h3>References</h3>

<p>Aas K, Czado C, Frigessi A, Bakken H (2009). Pair-Copula Constructions of
Multiple Dependence. <em>Insurance: Mathematics and Economics</em>,
<b>44</b>(2), 182&ndash;198.
</p>
<p>Bedford T, Cooke RM (2001). Probability Density Decomposition for Conditionally
Dependent Random Variables Modeled by Vines. <em>Annals of Mathematics and
Artificial Intelligence</em>, <b>32</b>(1), 245&ndash;268.
</p>
<p>Brechmann EC (2010). Truncated and Simplified Regular Vines and Their
Applications. Diploma thesis, University of Technology, Munich, Germany.
</p>
<p>Demarta S, McNeil AJ (2005). The t Copula and Related Copulas.
<em>International Statistical Review</em>, <b>73</b>(1), 111&ndash;129.
</p>
<p>Genest C, Rémillard B (2004). Tests of Independence or Randomness Based
on the Empirical Copula Process. <em>Test</em>, <b>13</b>(2), 335&ndash;369.
</p>
<p>Genest C, Quessy JF, Rémillard B (2007). Asymptotic Local Efficiency of
Cramér-von mises Tests for Multivariate Independence. <em>The Annals
of Statistics</em>, <b>35</b>, 166&ndash;191.
</p>
<p>Genest C, Rémillard B (2008). Validity of the Parametric Bootstrap for
Goodness-of-Fit Testing in Semiparametric Models. <em>Annales de
l'Institut Henri Poincaré: Probabilités et Statistiques</em>, <b>44</b>,
1096&ndash;1127.
</p>
<p>Gonzalez-Fernandez Y (2011). Algoritmos con estimación de distribuciones
basados en cópulas y vines. Bachelor's thesis, University of Havana, Cuba.
</p>
<p>Gonzalez-Fernandez Y, Soto M (2014). <span class="pkg">copulaedas</span>: An <span class="rlang"><b>R</b></span>
Package for Estimation of Distribution Algorithms Based on Copulas.
<em>Journal of Statistical Software</em>, <b>58</b>(9), 1-34.
<a href="http://www.jstatsoft.org/v58/i09/">http://www.jstatsoft.org/v58/i09/</a>.
</p>
<p>Hobaek Haff I, Aas K, Frigessi A (2010). On the Simplified Pair-Copula
Construction &mdash; Simply Useful or Too Simplistic? Journal of Multivarite
Analysis, <b>101</b>, 1145&ndash;1152.
</p>
<p>Joe H (1996). Families of <code class="reqn">m</code>-variate Distributions with Given Margins
and <code class="reqn">m(m-1)/2</code> Bivariate Dependence Parameters. In L Röschendorf,
B Schweizer, MD Taylor (eds.), <em>Distributions with fixed marginals
and related topics</em>, pp. 120&ndash;141.
</p>
<p>Soto M, Gonzalez-Fernandez Y (2010). Vine Estimation of Distribution Algorithms.
Technical Report ICIMAF 2010-561, Institute of Cybernetics, Mathematics and
Physics, Cuba. ISSN 0138-8916.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setMethod("edaTerminate", "EDA", edaTerminateEval)
setMethod("edaReport", "EDA", edaReportSimple)

CVEDA &lt;- VEDA(vine = "CVine",
    copulas = c("normal", "clayton", "frank", "gumbel"),
    indepTestSigLevel = 0.01, margin = "norm",
    popSize = 200, fEval = 0, fEvalTol = 1e-03)
CVEDA@name &lt;- "C-vine Estimation of Distribution Algorithm"

DVEDA &lt;- VEDA(vine = "DVine",
    copulas = c("normal", "clayton", "frank", "gumbel"),
    indepTestSigLevel = 0.01, margin = "norm",
    popSize = 200, fEval = 0, fEvalTol = 1e-03)
DVEDA@name &lt;- "D-vine Estimation of Distribution Algorithm"

resultsCVEDA &lt;- edaRun(CVEDA, fSphere, rep(-600, 5), rep(600, 5))
resultsDVEDA &lt;- edaRun(DVEDA, fSphere, rep(-600, 5), rep(600, 5))

show(resultsCVEDA)
show(resultsDVEDA)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
