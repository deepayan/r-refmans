<!DOCTYPE html><html lang="en"><head><title>Help for package bootSVD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bootSVD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#As2Vs'><p>Convert low dimensional bootstrap components to high dimensional bootstrap components</p></a></li>
<li><a href='#bootPCA'><p>Quickly calculates bootstrap PCA results (wrapper for bootSVD)</p></a></li>
<li><a href='#bootSVD'><p>Calculates bootstrap distribution of PCA (i.e. SVD) results</p></a></li>
<li><a href='#bootSVD_LD'><p>Calculate bootstrap distribution of <code class="reqn">n</code>-dimensional PCs</p></a></li>
<li><a href='#EEG_leadingV'><p>Leading 5 Principal Components (PCs) from EEG dataset</p></a></li>
<li><a href='#EEG_mu'><p>Functional mean from EEG dataset</p></a></li>
<li><a href='#EEG_score_var'><p>Empirical variance of the first 5 score variables from EEG dataset</p></a></li>
<li><a href='#fastSVD'><p>Fast SVD of a wide or tall matrix</p></a></li>
<li><a href='#ffmatrixmult'><p>Matrix multiplication with &quot;ff_matrix&quot; or &quot;matrix&quot; inputs</p></a></li>
<li><a href='#genBootIndeces'><p>Generate a random set of bootstrap resampling indeces</p></a></li>
<li><a href='#genQ'><p>Generate random orthonormal matrix</p></a></li>
<li><a href='#getMomentsAndMomentCI'><p>Calculate bootstrap moments and moment-based confidence intervals for the PCs.</p></a></li>
<li><a href='#os'><p>Quickly print an R object's size</p></a></li>
<li><a href='#qrSVD'><p>Wrapper for <code>svd</code>, which uses random preconditioning to restart when svd fails to converge</p></a></li>
<li><a href='#reindexMatricesByK'><p>Used for calculation of low dimensional standard errors &amp; percentiles, by re-indexing the <code class="reqn">A^b</code> by PC index (<code class="reqn">k</code>) rather than bootstrap index (<code class="reqn">b</code>).</p></a></li>
<li><a href='#reindexVectorsByK'><p>Used to study of the bootstrap distribution of the k^th singular values, by re-indexing the list of <code class="reqn">d^b</code> vectors to be organized by PC index (<code class="reqn">k</code>) rather than bootstrap index (<code class="reqn">b</code>).</p></a></li>
<li><a href='#simEEG'><p>Simulation functional EEG data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fast, Exact Bootstrap Principal Component Analysis for High
Dimensional Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements fast, exact bootstrap Principal Component Analysis and
    Singular Value Decompositions for high dimensional data, as described in
    &lt;<a href="https://doi.org/10.1080%2F01621459.2015.1062383">doi:10.1080/01621459.2015.1062383</a>&gt; (see also &lt;<a href="https://doi.org/10.48550/arXiv.1405.0922">doi:10.48550/arXiv.1405.0922</a>&gt; ). For data matrices that are too large to operate
    on in memory, users can input objects with class 'ff' (see the 'ff'
    package), where the actual data is stored on disk. In response, this
    package will implement a block matrix algebra procedure for calculating the
    principal components (PCs) and bootstrap PCs. Depending on options set by
    the user, the 'parallel' package can be used to parallelize the calculation of
    the bootstrap PCs.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron Fisher &lt;afishe27@alumni.jh.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron Fisher &lt;afishe27@alumni.jh.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://arxiv.org/abs/1405.0922">http://arxiv.org/abs/1405.0922</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ff, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-01 22:28:49 UTC; aaronfisher</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-02 10:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='As2Vs'>Convert low dimensional bootstrap components to high dimensional bootstrap components</h2><span id='topic+As2Vs'></span>

<h3>Description</h3>

<p>Let <code class="reqn">B</code> be the number of bootstrap samples, indexed by <code class="reqn">b=1,2,...B</code>.
<code>As2Vs</code> is a simple function converts the list of principal component (PC) matrices for the bootstrap scores to a list of principal component matrices on the original high dimensional space. Both of these lists, the input and the output of <code>As2Vs</code>, are indexed by <code class="reqn">b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>As2Vs(AsByB, V, pattern = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="As2Vs_+3A_asbyb">AsByB</code></td>
<td>
<p>a list of the PCs matrices for each bootstrap sample, indexed by <code class="reqn">b</code>. Each element of this list should be a (<code class="reqn">n</code> by <code class="reqn">K</code>) matrix, where <code class="reqn">K</code> is the number of PCs of interest, and <code class="reqn">n</code> is the sample size.</p>
</td></tr>
<tr><td><code id="As2Vs_+3A_v">V</code></td>
<td>
<p>a tall (<code class="reqn">p</code> by <code class="reqn">n</code>) matrix containing the PCs of the original sample, where <code class="reqn">n</code> is sample size, and <code class="reqn">p</code> is sample dimension.</p>
</td></tr>
<tr><td><code id="As2Vs_+3A_pattern">pattern</code></td>
<td>
<p>if <code>V</code> is a class <code>ff</code> object, the returned value will also be a class <code>ff</code> object. <code>pattern</code> is passed to <code>ff</code> in creation of the output.</p>
</td></tr>
<tr><td><code id="As2Vs_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>B</code>-length list of (<code>p</code> by <code>K</code>) PC matrices on the original sample coordinate space (denoted here as <code class="reqn">V^b</code>). This is achieved by the matrix multiplication <code class="reqn">V^b=VA^b</code>. Note that here, <code class="reqn">V^b</code> denotes the <code class="reqn">b^{th}</code> bootstrap PC matrix, not <code class="reqn">V</code> raised to the power <code class="reqn">b</code>. This notation is the same as the notation used in (Fisher et al., 2014).
</p>


<h3>References</h3>

<p>Aaron Fisher, Brian Caffo, and Vadim Zipunnikov. <em>Fast, Exact Bootstrap Principal Component Analysis for p&gt;1 million</em>. 2014. http://arxiv.org/abs/1405.0922
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#use small n, small B, for a quick illustration
set.seed(0)
Y&lt;-simEEG(n=100, centered=TRUE, wide=TRUE) 
svdY&lt;-fastSVD(Y)
DUt&lt;- tcrossprod(diag(svdY$d),svdY$u)
bInds&lt;-genBootIndeces(B=50,n=dim(DUt)[2])
bootSVD_LD_output&lt;-bootSVD_LD(DUt=DUt,bInds=bInds,K=3,verbose=interactive())

Vs&lt;-As2Vs(As=bootSVD_LD_output$As,V=svdY$v)
# Yields the high dimensional bootstrap PCs (left singular 
# vectors of the bootstrap sample Y), 
# indexed by b = 1,2...B, where B is the number of bootstrap samples
</code></pre>

<hr>
<h2 id='bootPCA'>Quickly calculates bootstrap PCA results (wrapper for bootSVD)</h2><span id='topic+bootPCA'></span>

<h3>Description</h3>

<p>All arguments are passed to <code><a href="#topic+bootSVD">bootSVD</a></code>. This function should be used in exactly the same way as <code><a href="#topic+bootSVD">bootSVD</a></code>. The only difference is that PCA typically involves re-centering each bootstrap sample, whereas calculations involving the SVD might not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootPCA(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootPCA_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+bootSVD">bootSVD</a></code>, with centerSamples set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bootSVD(...)</code>
</p>

<hr>
<h2 id='bootSVD'>Calculates bootstrap distribution of PCA (i.e. SVD) results</h2><span id='topic+bootSVD'></span>

<h3>Description</h3>

<p>Applies fast bootstrap PCA, using the method from (Fisher et al., 2014). Dimension of the sample is denoted by <code class="reqn">p</code>, and sample size is denoted by <code class="reqn">n</code>, with <code class="reqn">p&gt;n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootSVD(Y = NULL, K, V = NULL, d = NULL, U = NULL, B = 50,
  output = "HD_moments", verbose = getOption("verbose"), bInds = NULL,
  percentiles = c(0.025, 0.975), centerSamples = TRUE, pattern_V = "V_",
  pattern_Vb = "Vb_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootSVD_+3A_y">Y</code></td>
<td>
<p>initial data sample, which can be either a matrix or a <code>ff</code> matrix. <code>Y</code> can be either tall (<code class="reqn">p</code> by <code class="reqn">n</code>) or wide (<code class="reqn">n</code> by <code class="reqn">p</code>). If <code>Y</code> is entered and <code>V</code>, <code>d</code> and <code>U</code> (see definitions below) are not entered, then <code>bootSVD</code> will also compute the SVD of <code>Y</code>. In this case where the SVD is computed, <code>bootSVD</code> will assume that the larger dimension of <code>Y</code> is <code class="reqn">p</code>, and the smaller dimension of code Y is <code class="reqn">n</code> (i.e. <code>bootSVD</code> assumes that (<code class="reqn">p&gt;n</code>). This assumption can be overriden by manually entering <code>V</code>, <code>U</code> and <code>d</code>.<br />
For cases where the entire data matrix can be easily stored in memory (e.g. <code class="reqn">p&lt;50000</code>), it is generally appropriate to enter <code>Y</code> as a standard matrix. When <code>Y</code> is large enough that matrix algebra on <code>Y</code> is too demanding for memory though, <code>Y</code> should be entered as a <code>ff</code> object, where the actual data is stored on disk. If <code>Y</code> has class <code>ff</code>, and <code>V</code>, <code>d</code> or <code>U</code> is not entered, then block matrix algebra will be used to calculate the PCs and bootstrap PCs. The results of these calculations will be returned as <code>ff</code> objects as well.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_k">K</code></td>
<td>
<p>number of PCs to calculate the bootstrap distribution for.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_v">V</code></td>
<td>
<p>(optional) the (<code class="reqn">p</code> by <code class="reqn">n</code>) full matrix of <code class="reqn">p</code>-dimensional PCs for the sample data matrix. If <code>Y</code> is wide, these are the right singular vectors of <code>Y</code> (i.e. <code class="reqn">Y=UDV'</code>). If <code>Y</code> is tall, these are the left singular vectors of <code>Y</code> (i.e. <code class="reqn">Y=VDU'</code>). In general it is assumed that <code class="reqn">p&gt;n</code>, however, this can be overridden by setting <code>V</code> and <code>U</code> appropriately.<br />
Like <code>Y</code>, the argument <code>V</code> can be either a standard matrix or a <code>ff</code> matrix. If <code>V</code> is a <code>ff</code> object, the bootstrap PCs, if requested, will be returned as <code>ff</code> objects as well.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_d">d</code></td>
<td>
<p>(optional) <code class="reqn">n</code>-length vector of the singular values of <code>Y</code>. For example, if <code>Y</code> is tall, then we have <code class="reqn">Y=VDU'</code> with <code>D=diag(d)</code>.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_u">U</code></td>
<td>
<p>(optional) the (<code class="reqn">n</code> by <code class="reqn">n</code>) full set of <code class="reqn">n</code>-dimensional singular vectors of <code>Y</code>. If <code>Y</code> is wide, these are the left singular vectors of <code>Y</code> (i.e. <code class="reqn">Y=UDV'</code>). If <code>Y</code> is tall, these are the right singular vectors of <code>Y</code> (i.e. <code class="reqn">Y=VDU'</code>).</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples to compute.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_output">output</code></td>
<td>
<p>a vector telling which descriptions of the bootstrap distribution should be calculated. Can include any of the following: 'initial_SVD', 'HD_moments', 'full_HD_PC_dist', and 'HD_percentiles'. See below for explanations of these outputs.<br />
For especially high dimensional cases, caution should be used if requesting 'full_HD_PC_dist' due to potential storage limitations.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, the function will print progress during calculation procedure.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_binds">bInds</code></td>
<td>
<p>a (<code class="reqn">B</code> by <code class="reqn">n</code>) matrix of bootstrap indeces, where <code>B</code> is the number of bootstrap samples, and <code>n</code> is the sample size. The purpose of setting a specific bootstrap sampling index is to allow the results to be more precisely compared against standard bootstrap PCA calculations. If entered, the <code>bInds</code> argument will override the <code>B</code> argument.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_percentiles">percentiles</code></td>
<td>
<p>a vector containing percentiles to be used to calculate element-wise percentiles across the bootstrap distribution (both across the distribution of  <code class="reqn">p</code>-dimensional components and the distribution of <code class="reqn">n</code>-dimensional components). For example, <code>percentiles=c(.025,.975)</code> will return the 2.5 and 97.5 percentiles, which can be used as <code class="reqn">95</code> percent bootstrap percentile CIs. Alternatively, a longer vector of percentiles can be entered.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_centersamples">centerSamples</code></td>
<td>
<p>whether each bootstrap sample should be centered before calculating the SVD.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_pattern_v">pattern_V</code></td>
<td>
<p>if <code>Y</code> is a class <code>ff</code> object, then the returned PCs of <code>Y</code> will also be a class <code>ff</code> object. <code>pattern_V</code> is passed to <code>ff</code> in creation of the <code>initial_SVD</code> output. Specifically, <code>pattern_V</code> is a filename prefix used for storing the high dimensional PCs of the original sample.</p>
</td></tr>
<tr><td><code id="bootSVD_+3A_pattern_vb">pattern_Vb</code></td>
<td>
<p>if <code>Y</code> or <code>V</code> is a class <code>ff</code> object, then the returned bootstrap PCs will also be class <code>ff</code> objects. <code>pattern_Vb</code> is passed to <code>ff</code> in creation of the <code>full_HD_PC_dist</code> output. Specifically, <code>pattern_Vb</code> is a filename prefix used for storing the high dimensional bootstrap PCs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users might also consider changing the global options <code>ffbatchbytes</code>, from the <code>ff</code> package, and <code>mc.cores</code>, from the <code>parallel</code> package. When <code>ff</code> objects are entered as arguments for <code>bootSVD</code>, the required matrix algebra is done using block matrix alebra. The <code>ffbatchbytes</code> option determines the size of the largest block matrix that will be held in memory at any one time. The <code>mc.cores</code> option (set to 1 by default) determines the level of parallelization to use when calculating the high dimensional distribution of the bootstrap PCs (see <code><a href="parallel.html#topic+mclapply">mclapply</a></code>).
</p>


<h3>Value</h3>

<p><code>bootSVD</code> returns a list that can include any of the following elements, depending on what is specified in the <code>output</code> argument:
</p>

<dl>
<dt>initial_SVD</dt><dd><p>The singular value decomposition of the centered, original data matrix. <code>initial_SVD</code> is a list containing <code>V</code>, the matrix of <code class="reqn">p</code>-dimensional principal components, <code>d</code>, the vector of singular values of <code>Y</code>, and <code>U</code>, the matrix of <code class="reqn">n</code>-dimensional singular vectors of <code>Y</code>.</p>
</dd>
<dt>HD_moments</dt><dd><p>A list containing the bootstrap expected value (<code>EPCs</code>), element-wise bootstrap variance (<code>varPCs</code>), and element-wise bootstrap standard deviation (<code>sdPCs</code>) for each of the <code class="reqn">p</code>-dimensional PCs. Each of these three elements of <code>HD_moments</code> is also a list, which contains <code class="reqn">K</code> vectors, one for each PC. <code>HD_moments</code> also contains <code>momentCI</code>, a <code class="reqn">K</code>-length list of (<code class="reqn">p</code> by 2) matrices containing element-wise moment based confidence intervals for the PCs.</p>
</dd>
<dt>full_HD_PC_dist</dt><dd><p>A <code class="reqn">B</code>-length list of matrices (or <code>ff</code> matrices), with the <code class="reqn">b^{th}</code> list element equal to the (<code class="reqn">p</code> by <code class="reqn">K</code>) matrix of high dimensional PCs for the <code class="reqn">b^{th}</code> bootstrap sample. <br />
For especially high dimensional cases when the output is returned as <code>ff</code> matrices, caution should be used if requesting 'full_HD_PC_dist' due to potential storage limitations. <br />
To reindex these PCs by <code class="reqn">k</code> (the PC index) as opposed to <code class="reqn">b</code> (the bootstrap index), see <code><a href="#topic+reindexMatricesByK">reindexMatricesByK</a></code>. Again though, caution shoulded be used when reindexing PCs stored as <code>ff</code> objects, as this will double the number of files stored.</p>
</dd>
<dt>HD_percentiles</dt><dd><p>A list of <code class="reqn">K</code> matrices, each of dimension (<code class="reqn">p</code> by <code class="reqn">q</code>), where <code class="reqn">q</code> is the number of percentiles requested (i.e. <code class="reqn">q</code> = <code>length(percentiles)</code>). The <code class="reqn">k^{th}</code> matrix in <code>HD_percentiles</code> contains element-wise percentiles for the <code class="reqn">k^{th}</code>, <code class="reqn">p</code>-dimensional PC.</p>
</dd>
</dl>

<p>In addition, the following results are always included in the output, regardless of what is specified in the <code>output</code> argument:
</p>
<table role = "presentation">
<tr><td><code>full_LD_PC_dist</code></td>
<td>
<p>A <code class="reqn">B</code>-length list of matrices, with the <code class="reqn">b^{th}</code> list element equal to the (<code class="reqn">p</code> by <code class="reqn">K</code>) matrix of PCs of the scores in the <code class="reqn">b^{th}</code> bootstrap sample. To reindex these vectors by <code class="reqn">k</code> (the PC index), see <code><a href="#topic+reindexMatricesByK">reindexMatricesByK</a></code>.</p>
</td></tr>
<tr><td><code>d_dist</code></td>
<td>
<p>A <code>B</code>-length list of vectors, with the <code class="reqn">b^{th}</code> element of <code>d_dist</code> containing the <code class="reqn">n</code>-length vector of singular values from the <code class="reqn">b^{th}</code> bootstrap sample. To reindex these values by <code class="reqn">k</code> (the PC index), see <code><a href="#topic+reindexVectorsByK">reindexVectorsByK</a></code>.</p>
</td></tr>
<tr><td><code>U_dist</code></td>
<td>
<p>A <code>B</code>-length list of (<code class="reqn">n</code> by <code class="reqn">K</code>) matrices, with the columns of the <code class="reqn">b^{th}</code> matrix containing the <code class="reqn">n</code>-length singular vectors from the <code class="reqn">b^{th}</code> bootstrap sample. To reindex these vectors by <code class="reqn">k</code> (the PC index), see <code><a href="#topic+reindexMatricesByK">reindexMatricesByK</a></code>.</p>
</td></tr>
<tr><td><code>LD_moments</code></td>
<td>
<p>A list that is comparable to <code>HD_moments</code>, but that instead describes the variability of the <code class="reqn">n</code>-dimensional principal components of the resampled score matrices. <code>LD_moments</code> contains the bootstrap expected value (<code>EPCs</code>), element-wise bootstrap variances (<code>varPCs</code>), and element-wise bootstrap standard deviations (<code>sdPCs</code>) for each of the <code class="reqn">n</code>-dimensional PCs. Each of these three elements of <code>LD_moments</code> is also a list, which contains <code class="reqn">K</code> vectors, one for each PC. <code>LD_moments</code> also contains <code>momentCI</code>, a list of <code class="reqn">K</code> (<code class="reqn">n</code> by 2) matrices containing element-wise, moment-based confidence intervals for the PCs.</p>
</td></tr>
<tr><td><code>LD_percentiles</code></td>
<td>
<p>A list of <code class="reqn">K</code> matrices, each of dimension (<code class="reqn">p</code> by <code class="reqn">q</code>), where <code class="reqn">q</code> is the number of percentiles requested (i.e. <code class="reqn">q</code> = <code>length(percentiles)</code>). The <code class="reqn">k^{th}</code> matrix in <code>LD_percentiles</code> contains element-wise percentiles for the <code class="reqn">k^{th}</code> <code class="reqn">n</code>-dimensional PC.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Aaron Fisher, Brian Caffo, and Vadim Zipunnikov. <em>Fast, Exact Bootstrap Principal Component Analysis for p&gt;1 million</em>. 2014. http://arxiv.org/abs/1405.0922
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#use small n, small B, for a quick illustration
set.seed(0)
Y&lt;-simEEG(n=100, centered=TRUE, wide=TRUE) 
b&lt;-bootSVD(Y, B=50, K=2, output= 
 	c('initial_SVD', 'HD_moments', 'full_HD_PC_dist',
 	'HD_percentiles'), verbose=interactive())
b

#explore results
matplot(b$initial_SVD$V[,1:4],type='l',main='Fitted PCs',lty=1)
legend('bottomright',paste0('PC',1:4),col=1:4,lty=1,lwd=2)

######################
# look specifically at 2nd PC
k&lt;-2

######
#looking at HD variability

#plot several draws from bootstrap distribution
VsByK&lt;-reindexMatricesByK(b$full_HD_PC_dist)
matplot(t(VsByK[[k]][1:20,]),type='l',lty=1,
		main=paste0('20 Draws from bootstrap\ndistribution of HD PC ',k))

#plot pointwise CIs
matplot(b$HD_moments$momentCI[[k]],type='l',col='blue',lty=1,
		main=paste0('CIs For HD PC ',k))
matlines(b$HD_percentiles[[k]],type='l',col='darkgreen',lty=1)
lines(b$initial_SVD$V[,k])
legend('topright',c('Fitted PC','Moment CIs','Percentile CIs'),
		lty=1,col=c('black','blue','darkgreen'))
abline(h=0,lty=2,col='darkgrey')

######
# looking at LD variability

# plot several draws from bootstrap distribution
AsByK&lt;-reindexMatricesByK(b$full_LD_PC_dist)
matplot(t(AsByK[[k]][1:50,]),type='l',lty=1,
		main=paste0('50 Draws from bootstrap\ndistribution of LD PC ',k),
	xlim=c(1,10),xlab='PC index (truncated)')

# plot pointwise CIs
matplot(b$LD_moments$momentCI[[k]],type='o',col='blue',
		lty=1,main=paste0('CIs For LD PC ',k),xlim=c(1,10),
		xlab='PC index (truncated)',pch=1)
matlines(b$LD_percentiles[[k]],type='o',pch=1,col='darkgreen',lty=1)
abline(h=0,lty=2,col='darkgrey')
legend('topright',c('Moment CIs','Percentile CIs'),lty=1,
		pch=1,col=c('blue','darkgreen'))
#Note: variability is mostly due to rotations with the third and fourth PC.

# Bootstrap eigenvalue distribution
dsByK&lt;-reindexVectorsByK(b$d_dist)
boxplot(dsByK[[k]]^2,main=paste0('Covariance Matrix Eigenvalue ',k),
		ylab='Bootstrap Distribution',
		ylim=range(c(dsByK[[k]]^2,b$initial_SVD$d[k]^2)))
points(b$initial_SVD$d[k]^2,pch=18,col='red')
legend('bottomright','Sample Value',pch=18,col='red')


##################
#Example with ff input
library(ff)
Yff&lt;-as.ff(Y, pattern='Y_')
# If desired, change options in 'ff' package to
# adjust the size of matrix blocks held in RAM.
# For example:
# options('ffbatchbytes'=100000)
ff_dir&lt;-tempdir()
pattern_V &lt;- paste0(ff_dir,'/V_')
pattern_Vb &lt;- paste0(ff_dir,'/Vb_')
bff &lt;- bootSVD(Yff, B=50, K=2, output=c('initial_SVD', 'HD_moments',
 	'full_HD_PC_dist', 'HD_percentiles'), pattern_V= pattern_V,
 	pattern_Vb=pattern_Vb, verbose=interactive())


# Note that elements of full_HD_PC_dist and initial_SVD
# have class 'ff'
str(lapply(bff,function(x) class(x[[1]])))
#Show some results of bootstrap draws
plot(bff$full_HD_PC_dist[[1]][,k],type='l')
#Reindexing by K will create a new set of ff files.
VsByKff&lt;-reindexMatricesByK(bff$full_HD_PC_dist,
 	pattern=paste0(ff_dir,'/Vk_'))
physical(bff$full_HD_PC_dist[[1]])$filename
physical(VsByKff[[1]])$filename
matplot(t(VsByKff[[k]][1:10,]),type='l',lty=1,
main=paste0('Bootstrap Distribution of PC',k))


# Saving and moving results:
saveRDS(bff,file=paste0(ff_dir,'/bff.rds'))
close(bff$initial_SVD$V)
physical(bff$initial_SVD$V)$filename
# If the 'ff' files on disk are moved or renamed,
# this filename attribute can be changed:
old_ff_path &lt;- physical(bff$initial_SVD$V)$filename
new_ff_path &lt;- paste0(tempdir(),'/new_V_file.ff')
file.rename(from= old_ff_path, to= new_ff_path)
physical(bff$initial_SVD$V)$filename &lt;- new_ff_path
matplot(bff$initial_SVD$V[,1:4],type='l',lty=1)

</code></pre>

<hr>
<h2 id='bootSVD_LD'>Calculate bootstrap distribution of <code class="reqn">n</code>-dimensional PCs</h2><span id='topic+bootSVD_LD'></span>

<h3>Description</h3>

<p><code>bootSVD_LD</code> Calculates the bootstrap distribution of the principal components (PCs) of a low dimensional matrix. If the score matrix is inputted, the output of <code>bootSVD_LD</code> can be used to to calculate bootstrap standard errors, confidence regions, or the full bootstrap distribution of the high dimensional components. Most users may want to instead consider using <code><a href="#topic+bootSVD">bootSVD</a></code>, which also calculates descriptions of the high dimensional components. Note that <code><a href="#topic+bootSVD">bootSVD</a></code> calls <code>bootSVD_LD</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootSVD_LD(UD, DUt = t(UD), bInds = genBootIndeces(B = 1000, n =
  dim(DUt)[2]), K, warning_type = "silent", verbose = getOption("verbose"),
  centerSamples = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootSVD_LD_+3A_ud">UD</code></td>
<td>
<p>(optional) a (<code class="reqn">n</code> by <code class="reqn">n</code>) matrix of scores, were rows denote individuals, and columns denote measurements in the PC space.</p>
</td></tr>
<tr><td><code id="bootSVD_LD_+3A_dut">DUt</code></td>
<td>
<p>the transpose of <code>UD</code>. If both <code>UD</code> and <code>UDt</code> are entered and <code>t(UD)!=DUt</code>, the <code>DUt</code> argument will override the <code>UD</code> argument.</p>
</td></tr>
<tr><td><code id="bootSVD_LD_+3A_binds">bInds</code></td>
<td>
<p>a (<code class="reqn">B</code> by <code class="reqn">n</code>) matrix of bootstrap indeces, where <code>B</code> is the number of bootstrap samples, and <code>n</code> is the sample size. Each row should be an indexing vector that can be used to generate a new bootstrap sample (i.e. <code>sample(n,replace=TRUE)</code>). The matrix of bootstrap indeces is taken as input, rather than being calculated within <code>bootSVD_LD</code>, so that this method can be more easily compared against traditional bootstrap SVD methods on the exact same bootstrap samples. The <code>bInds</code> matrix can be calculated using the helper function <code><a href="#topic+genBootIndeces">genBootIndeces</a></code>).</p>
</td></tr>
<tr><td><code id="bootSVD_LD_+3A_k">K</code></td>
<td>
<p>the number of PCs to be estimated.</p>
</td></tr>
<tr><td><code id="bootSVD_LD_+3A_warning_type">warning_type</code></td>
<td>
<p>passed to <code><a href="#topic+qrSVD">qrSVD</a></code>, when taking the SVD of the low dimensional bootstrap score matrices.</p>
</td></tr>
<tr><td><code id="bootSVD_LD_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, a progress bar will appear.</p>
</td></tr>
<tr><td><code id="bootSVD_LD_+3A_centersamples">centerSamples</code></td>
<td>
<p>whether each bootstrap sample should be centered before calculating the SVD.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For each bootstrap matrix <code class="reqn">(DU')^b</code>, let <code class="reqn">svd(DU')=:A^b D^b U^b</code>, where <code class="reqn">A^b</code> and <code class="reqn">U^b</code> are (<code class="reqn">n</code> by <code class="reqn">n</code>) orthonormal matrices, and <code class="reqn">D^b</code> is a (<code class="reqn">n</code> by <code class="reqn">n</code>) diagonal matrix <code class="reqn">K</code>. Here we calculate only the first <code>K</code> columns of <code class="reqn">A^b</code>, but all <code>n</code> columns of <code class="reqn">U^b</code>. The results are stored as a list containing
</p>
<table role = "presentation">
<tr><td><code>As</code></td>
<td>
<p>a <code>B</code>-length list of the (<code>n</code> by <code>K</code>) matrices containing the first <code>K</code> PCs from each bootstrap sample. This list is indexed by <code>b</code>, with the <code class="reqn">b^{th}</code> element containing the results from the <code class="reqn">b^{th}</code> bootstrap sample.</p>
</td></tr>
<tr><td><code>ds</code></td>
<td>
<p>a <code>B</code>-length list of vectors, indexed by the bootstrap index <code>b</code>, with each vector containing the singular values of the corresponding bootstrap sample.</p>
</td></tr>
<tr><td><code>Us</code></td>
<td>
<p>a <code>B</code>-length list, indexed by the bootstrap index <code>b</code>, of the (<code class="reqn">n</code> by <code class="reqn">n</code>) matrices <code class="reqn">U^b</code>.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>The computation time required for the procedure, taken using <code><a href="base.html#topic+system.time">system.time</a></code>.</p>
</td></tr>
</table>
<p>If the score matrix is inputted to <code>bootSVD_LD</code>, the results can be transformed to get the PCs on the original space by multiplying each matrix <code class="reqn">A^b</code> by the PCs of the original sample, <code class="reqn">V</code> (see <code><a href="#topic+As2Vs">As2Vs</a></code>). The bootstrap scores of the original sample are equal to <code class="reqn">U^b D^b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#use small n, small B, for a quick illustration
set.seed(0)
Y&lt;-simEEG(n=100, centered=TRUE, wide=TRUE) 
svdY&lt;-fastSVD(Y)
DUt&lt;- tcrossprod(diag(svdY$d),svdY$u)
bInds&lt;-genBootIndeces(B=50,n=dim(DUt)[2])
bootSVD_LD_output&lt;-bootSVD_LD(DUt=DUt,bInds=bInds,K=3,verbose=interactive())
</code></pre>

<hr>
<h2 id='EEG_leadingV'>Leading 5 Principal Components (PCs) from EEG dataset</h2><span id='topic+EEG_leadingV'></span>

<h3>Description</h3>

<p>This package is based on (Fisher et al., 2014), which uses as an example a subset of the electroencephalogram (EEG) measurements from the Sleep Heart Health Study (SHHS) (Quan et al. 1997). Since we cannot publish the EEG recordings from SHHS participants in this package, we instead include the summary statistics of the PCs from our subsample of the processed SHHS EEG data. These summary statistics were generated from measurements of smoothed Normalized Delta Power. This data is used by the <code><a href="#topic+simEEG">simEEG</a></code> to simulate data examples to demonstrate our functions.
</p>


<h3>Details</h3>

<p>Specifically, <code>EEG_leadingV</code> is a matrix whose columns contain the leading 5 principal components of the EEG dataset.
</p>


<h3>References</h3>

<p>Aaron Fisher, Brian Caffo, and Vadim Zipunnikov. <em>Fast, Exact Bootstrap Principal Component Analysis for p&gt;1 million</em>. 2014. http://arxiv.org/abs/1405.0922
</p>
<p>Stuart F Quan, Barbara V Howard, Conrad Iber, James P Kiley, F Javier Nieto, George T O'Connor, David M Rapoport, Susan Redline, John Robbins, JM Samet, et al.<em> The sleep heart health study: design, rationale, and methods</em>. Sleep, 20(12):1077-1085, 1997. 1.1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EEG_mu">EEG_mu</a></code>, <code><a href="#topic+EEG_score_var">EEG_score_var</a></code>
</p>

<hr>
<h2 id='EEG_mu'>Functional mean from EEG dataset</h2><span id='topic+EEG_mu'></span>

<h3>Description</h3>

<p>This package is based on (Fisher et al., 2014), which uses as an example a subset of the electroencephalogram (EEG) measurements from the Sleep Heart Health Study (SHHS) (Quan et al. 1997). Since we cannot publish the EEG recordings from SHHS participants in this package, we instead include the summary statistics of the PCs from our subsample of the processed SHHS EEG data. These summary statistics were generated from measurements of smoothed Normalized Delta Power. This data is used by the <code><a href="#topic+simEEG">simEEG</a></code> to simulate data examples to demonstrate our functions.
</p>


<h3>Details</h3>

<p>Specifically, <code>EEG_mu</code> is a vector containing the mean normalized delta power function across all subjects, for the first 7.5 hours of sleep.
</p>


<h3>References</h3>

<p>Aaron Fisher, Brian Caffo, and Vadim Zipunnikov. <em>Fast, Exact Bootstrap Principal Component Analysis for p&gt;1 million</em>. 2014. http://arxiv.org/abs/1405.0922
</p>
<p>Stuart F Quan, Barbara V Howard, Conrad Iber, James P Kiley, F Javier Nieto, George T O'Connor, David M Rapoport, Susan Redline, John Robbins, JM Samet, et al.<em> The sleep heart health study: design, rationale, and methods</em>. Sleep, 20(12):1077-1085, 1997. 1.1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EEG_leadingV">EEG_leadingV</a></code>, <code><a href="#topic+EEG_score_var">EEG_score_var</a></code>
</p>

<hr>
<h2 id='EEG_score_var'>Empirical variance of the first 5 score variables from EEG dataset</h2><span id='topic+EEG_score_var'></span>

<h3>Description</h3>

<p>This package is based on (Fisher et al., 2014), which uses as an example a subset of the electroencephalogram (EEG) measurements from the Sleep Heart Health Study (SHHS) (Quan et al. 1997). Since we cannot publish the EEG recordings from SHHS participants in this package, we instead include the summary statistics of the PCs from our subsample of the processed SHHS EEG data. These summary statistics were generated from measurements of smoothed Normalized Delta Power. This data is used by the <code><a href="#topic+simEEG">simEEG</a></code> to simulate data examples to demonstrate our functions.
</p>


<h3>Details</h3>

<p>Specifically, <code>EEG_score_var</code> is a vector containing the variances of the first 5 empirical score variables. Here, we refer to the score variables refer to the <code class="reqn">n</code>-dimensional, uncorrelated variables, whose coordinate vectors are the principal components <code><a href="#topic+EEG_leadingV">EEG_leadingV</a></code>.
</p>


<h3>References</h3>

<p>Aaron Fisher, Brian Caffo, and Vadim Zipunnikov. <em>Fast, Exact Bootstrap Principal Component Analysis for p&gt;1 million</em>. 2014. http://arxiv.org/abs/1405.0922
</p>
<p>Stuart F Quan, Barbara V Howard, Conrad Iber, James P Kiley, F Javier Nieto, George T O'Connor, David M Rapoport, Susan Redline, John Robbins, JM Samet, et al.<em> The sleep heart health study: design, rationale, and methods</em>. Sleep, 20(12):1077-1085, 1997. 1.1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EEG_mu">EEG_mu</a></code>, <code><a href="#topic+EEG_leadingV">EEG_leadingV</a></code>
</p>

<hr>
<h2 id='fastSVD'>Fast SVD of a wide or tall matrix</h2><span id='topic+fastSVD'></span>

<h3>Description</h3>

<p><code>fastSVD</code> uses the inherent low dimensionality of a wide, or tall, matrix to quickly calculate its SVD. For a matrix <code class="reqn">A</code>, this function solves <code class="reqn">svd(A)=UDV'</code>. 
This function can be applied to either standard matrices, or, when the data is too large to be stored in memeory, to matrices with class <code>ff</code>. <code>ff</code> objects have a representation in memory, but store their contents on disk. In these cases, <code>fastSVD</code> will implement block matrix algebra to compute the SVD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastSVD(A, nv = min(dim(A)), warning_type = "silent", center_A = FALSE,
  pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastSVD_+3A_a">A</code></td>
<td>
<p>matrix of dimension (<code class="reqn">n</code> by <code class="reqn">m</code>). This can be either of class <code>matrix</code> or <code>ff</code>.</p>
</td></tr>
<tr><td><code id="fastSVD_+3A_nv">nv</code></td>
<td>
<p>number of high dimensional singular vectors to obtain. If <code class="reqn">n&gt;m</code>, this is the number of <code class="reqn">n</code>-dimensional left singular vectors to be computed. If <code class="reqn">n&lt;m</code>, this is the number of <code class="reqn">m</code>-dimensional right singular vectors to be computed.</p>
</td></tr>
<tr><td><code id="fastSVD_+3A_warning_type">warning_type</code></td>
<td>
<p>passed to <code><a href="#topic+qrSVD">qrSVD</a></code>, which calculates either <code>svd(tcrossprod(A))</code> or <code>svd(crossprod(A))</code>, whichever is of lower dimension.</p>
</td></tr>
<tr><td><code id="fastSVD_+3A_center_a">center_A</code></td>
<td>
<p>Whether the matrix <code>A</code> should be centered before taking it's SVD. Centering is done along whichever dimension of <code>A</code> is larger. For example, if <code>A</code> is tall, then setting <code>center_A=TRUE</code> will return the SVD of <code>A</code> after centering the rows of <code>A</code>. This centering is implemented as a low dimensional matrix operation that does not require creating a copy of the original matrix <code>A</code>.</p>
</td></tr>
<tr><td><code id="fastSVD_+3A_pattern">pattern</code></td>
<td>
<p>passed to <code>ff</code>. When <code>A</code> has class <code>ff</code>, the returned high dimensional singular vectors will also have class <code>ff</code>. The argument <code>pattern</code> is passed to <code>ff</code> when creating the files on disk for the high dimensional singular vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users might also consider changing the global option <code>ffbatchbytes</code>, from the <code>ff</code> package. When a <code>ff</code> object is entered, the <code>ffbatchbytes</code> option determines the maximum block size in the block matrix algebra used to calculate the SVD.
</p>


<h3>Value</h3>

<p>Let <code class="reqn">r</code> be the rank of the matrix <code>A</code>. <code>fastSVD</code> solves <code class="reqn">svd(A)=UDV'</code>, where <code class="reqn">U</code> is an (<code class="reqn">n</code> by <code class="reqn">r</code>) orthonormal matrix, <code class="reqn">D</code> is an (<code class="reqn">r</code> by <code class="reqn">r</code>) diagonal matrix; and <code class="reqn">V</code> is a (<code class="reqn">m</code> by <code class="reqn">r</code>) orthonormal matrix. When <code>A</code> is entered as an <code>ff</code> object, the high dimensional singular vectors of <code>A</code> will be returned as an <code>ff</code> object as well. For matrices where one dimension is substantially large than the other, calculation times are considerably faster than the standard <code>svd</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Y&lt;-simEEG(n=100,centered=TRUE,wide=TRUE)
svdY&lt;-fastSVD(Y)
svdY
matplot(svdY$v[,1:5],type='l',lty=1) #sample PCs for a wide matrix are the right singular vectors

#Note: For a tall, demeaned matrix Y, with columns corresponding 
#to subjects and rows to measurements, 
#the PCs are the high dimensional left singular vectors.

#Example with 'ff'
dev.off()
library(ff)
Yff&lt;-as.ff(Y)
svdYff&lt;-fastSVD(Yff)
svdYff
matplot(svdYff$v[,1:5],type='l',lty=1) 
</code></pre>

<hr>
<h2 id='ffmatrixmult'>Matrix multiplication with &quot;ff_matrix&quot; or &quot;matrix&quot; inputs</h2><span id='topic+ffmatrixmult'></span>

<h3>Description</h3>

<p>A function for <code>crossprod(x,y)</code>, for <code>tcrossprod(x,y)</code>, or for regular matrix multiplication, that is compatible with <code>ff</code> matrices. Multiplication is done without creating new matrices for the transposes of <code>x</code> or <code>y</code>. Note, the crossproduct function can't be applied directly to objects with class <code>ff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffmatrixmult(x, y = NULL, xt = FALSE, yt = FALSE, ram.output = FALSE,
  override.big.error = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ffmatrixmult_+3A_x">x</code></td>
<td>
<p>a matrix or ff_matrix</p>
</td></tr>
<tr><td><code id="ffmatrixmult_+3A_y">y</code></td>
<td>
<p>a matrix or ff_matrix. If NULL, this is set equal to x, although a second copy of the matrix x is not actually stored.</p>
</td></tr>
<tr><td><code id="ffmatrixmult_+3A_xt">xt</code></td>
<td>
<p>should the x matrix be transposed before multiplying</p>
</td></tr>
<tr><td><code id="ffmatrixmult_+3A_yt">yt</code></td>
<td>
<p>should the y matrix be transposed before multiplying (e.g. <code>xt=TRUE</code>, <code>yt=FALSE</code> leads to <code>crossprod(x,y)</code>).</p>
</td></tr>
<tr><td><code id="ffmatrixmult_+3A_ram.output">ram.output</code></td>
<td>
<p>force output to be a normal matrix, as opposed to an object with class <code>ff</code>.</p>
</td></tr>
<tr><td><code id="ffmatrixmult_+3A_override.big.error">override.big.error</code></td>
<td>
<p>If the dimension of the final output matrix is especially large, <code>ffmatrixmult</code> will abort, giving an error. This is meant to avoid the accidental creation of very large matrices. Set override.big.error=TRUE to bypass this error.</p>
</td></tr>
<tr><td><code id="ffmatrixmult_+3A_...">...</code></td>
<td>
<p>passed to <code>ff</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A standard matrix, or a matrix with class <code>ff</code> if one of the input matrices has class <code>ff</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 library(ff)
	#Tall data
	y_tall&lt;-matrix(rnorm(5000),500,10) #y tall
	x_tall&lt;-matrix(rnorm(5000),500,10)
	y_wide&lt;-t(y_tall)
	x_wide&lt;-t(x_tall)
	y_tall_ff&lt;-as.ff(y_tall) #y tall and ff
	x_tall_ff&lt;-as.ff(x_tall) 
	y_wide_ff&lt;-as.ff(y_wide) #y tall and ff
	x_wide_ff&lt;-as.ff(x_wide) 

 #Set options to ensure that block matrix algebra is actually done,
 #and the entire algebra isn't just one in one step.
 #Compare ffmatrixmult against output from standard methods
 options('ffbytesize'=100)

 #small final matrices
	#x'x
	range(  crossprod(x_tall) - ffmatrixmult(x_tall_ff, xt=TRUE)  )
	range(  tcrossprod(x_wide) - ffmatrixmult(x_wide_ff, yt=TRUE)  )
	range(  crossprod(x_tall,y_tall) - ffmatrixmult(x_tall_ff,y_tall_ff, xt=TRUE)  )
	range(  tcrossprod(x_wide,y_wide) - ffmatrixmult(x_wide_ff,y_wide_ff, yt=TRUE)  )
	range(  (x_wide%*%y_tall) - ffmatrixmult(x_wide_ff,y_tall_ff)  )

	#ff + small data
	s_tall &lt;- matrix(rnorm(80),10,8) 
	s_wide &lt;- matrix(rnorm(80),8,10) 

	#tall output
	range(  crossprod(x_wide, s_tall) - ffmatrixmult(x_wide_ff, s_tall,xt=TRUE)[]  )
	range(  tcrossprod(x_tall, s_wide) - ffmatrixmult(x_tall_ff, s_wide,yt=TRUE)[]  )
	range( x_tall%*%s_tall - ffmatrixmult(x_tall_ff, s_tall)[])

	#Wide output
	range(  crossprod(s_tall, y_wide) - ffmatrixmult( s_tall, y_wide_ff,xt=TRUE)[]  )
	range(  tcrossprod(s_wide, y_tall) - ffmatrixmult( s_wide,y_tall_ff,yt=TRUE)[]  )
	range( s_wide%*%y_wide - ffmatrixmult(s_wide,y_wide_ff)[])

 #Reset options for more practical use
 options('ffbytesize'=16777216)


## End(Not run)
</code></pre>

<hr>
<h2 id='genBootIndeces'>Generate a random set of bootstrap resampling indeces</h2><span id='topic+genBootIndeces'></span>

<h3>Description</h3>

<p>Let <code class="reqn">n</code> be the original sample size, <code class="reqn">p</code> be the number of measurements per subject, and <code class="reqn">B</code> be the number of bootstrap samples. <code>genBootIndeces</code> generates a (<code class="reqn">B</code> by <code class="reqn">n</code>) matrix containing <code class="reqn">B</code> indexing vectors that can be used to create <code class="reqn">B</code> bootstrap samples, each of size <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genBootIndeces(B, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genBootIndeces_+3A_b">B</code></td>
<td>
<p>number of desired bootstrap samples</p>
</td></tr>
<tr><td><code id="genBootIndeces_+3A_n">n</code></td>
<td>
<p>size of original sample from which we'll be resampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code class="reqn">B</code> by <code class="reqn">n</code>) matrix of bootstrap indeces. Let <code>bInds</code> denote the output of <code>getBootIndeces</code>, and <code>Y</code> denote the original (<code class="reqn">p</code> by <code class="reqn">n</code>) sample. Then <code>Y[,bInds[b,]]</code> is the <code class="reqn">b^{th}</code> bootstrap sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bInds&lt;-genBootIndeces(B=50,n=200)
</code></pre>

<hr>
<h2 id='genQ'>Generate random orthonormal matrix</h2><span id='topic+genQ'></span>

<h3>Description</h3>

<p><code>genQ</code> generates a square matrix of random normal noise, and then takes the QR decomposition to return Q, a random orthogonal square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genQ(n, lim_attempts = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genQ_+3A_n">n</code></td>
<td>
<p>the dimension of the desired random orthonormal matrix</p>
</td></tr>
<tr><td><code id="genQ_+3A_lim_attempts">lim_attempts</code></td>
<td>
<p>the random matrix of normal noise must be full rank to generate the appropriate QR decomposition. <code>lim_attempts</code> gives the maximum number of attempts for generating a full rank matrix of normal noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a random orthonormal (<code class="reqn">n</code> by <code class="reqn">n</code>) matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-genQ(3)
round(crossprod(A),digits=10)
</code></pre>

<hr>
<h2 id='getMomentsAndMomentCI'>Calculate bootstrap moments and moment-based confidence intervals for the PCs.</h2><span id='topic+getMomentsAndMomentCI'></span>

<h3>Description</h3>

<p>Let <code class="reqn">K</code> be the number of PCs of interest, let <code class="reqn">B</code> be the number of bootstrap samples, and let <code class="reqn">p</code> be the number of measurements per subject, also known as the dimension of the sample. In general, we use <code class="reqn">k</code> to refer to the principal component (PC) index, where <code class="reqn">k=1,2,...K</code>, and use <code class="reqn">b</code> to refer to the bootstrap index, where <code class="reqn">b=1,2,...B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMomentsAndMomentCI(AsByK, V, K = length(AsByK), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMomentsAndMomentCI_+3A_asbyk">AsByK</code></td>
<td>
<p>a list of the bootstrap PC matrices. This list should be indexed by <code class="reqn">k</code>, with the <code class="reqn">k^{th}</code> element of the lsit containing a <code class="reqn">b</code> by <code class="reqn">p</code> matrix of results for the <code class="reqn">k^{th}</code> PC, across bootstrap samples.</p>
</td></tr>
<tr><td><code id="getMomentsAndMomentCI_+3A_v">V</code></td>
<td>
<p>a (<code class="reqn">p</code> by <code class="reqn">n</code>) matrix containing the coordinate vectors for the matrices within the <code>AsByK</code> list, where <code class="reqn">n</code> is sample size and <code class="reqn">p</code> is sample dimension. Generally for bootstrap PCA, <code>AsByK</code> should contain the PCs for the bootstrap scores, and <code>V</code> should be the matrix of PCs from the original sample. The argument <code>V</code> may also be a <code>ff</code> object.</p>
</td></tr>
<tr><td><code id="getMomentsAndMomentCI_+3A_k">K</code></td>
<td>
<p>the number of leading PCs for which moments and confidence intervals should be obtained.</p>
</td></tr>
<tr><td><code id="getMomentsAndMomentCI_+3A_verbose">verbose</code></td>
<td>
<p>setting to <code>TRUE</code> will cause the function to print its progress in calculating the bootstrap variance for each PC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table role = "presentation">
<tr><td><code>EVs</code></td>
<td>
<p>a list containing element-wise bootstrap means for each of the <code>K</code> fitted PCs, indexed by <code>k</code>.</p>
</td></tr>
<tr><td><code>varVs</code></td>
<td>
<p>a list containing element-wise bootstrap variances for each of the <code>K</code> fitted PCs, indexed by <code>k</code>.</p>
</td></tr>
<tr><td><code>sdVs</code></td>
<td>
<p>a list containing element-wise bootstrap standard errors for each of the <code>K</code> fitted PCs, indexed by <code>k</code>.</p>
</td></tr>
<tr><td><code>momentCI</code></td>
<td>
<p>a list of (<code class="reqn">p</code> by <code class="reqn">2</code>) matrices, indexed by <code>k</code>, where <code>momentCI[[k]][j,]</code> is the pointwise moment-based CI for the <code class="reqn">j^{th}</code> element of the <code class="reqn">k^{th}</code> PC.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#use small n, small B, for a quick illustration
set.seed(0)
Y&lt;-simEEG(n=100, centered=TRUE, wide=TRUE) 
svdY&lt;-fastSVD(Y)
V&lt;-svdY$v #right singular vectors of the wide matrix Y
DUt&lt;- tcrossprod(diag(svdY$d),svdY$u)
bInds&lt;-genBootIndeces(B=50,n=dim(DUt)[2])
bootSVD_LD_output&lt;-bootSVD_LD(DUt=DUt,bInds=bInds,K=3,verbose=interactive())

AsByB&lt;-bootSVD_LD_output$As
AsByK&lt;-reindexMatricesByK(AsByB)
moments&lt;-getMomentsAndMomentCI(AsByK,V,verbose=interactive())
plot(V[,1],type='l',ylim=c(-.1,.1),main='Original PC1, with CI in blue')
matlines(moments$momentCI[[1]],col='blue',lty=1)

#Can also use this function to get moments for low dimensional
#vectors A^b[,k], by setting V to the identity matrix.
moments_A&lt;- getMomentsAndMomentCI(As=AsByK,V=diag(ncol(AsByK[[1]])))
</code></pre>

<hr>
<h2 id='os'>Quickly print an R object's size</h2><span id='topic+os'></span>

<h3>Description</h3>

<p>Quickly print an R object's size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>os(x, units = "Mb")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="os_+3A_x">x</code></td>
<td>
<p>an object of interest</p>
</td></tr>
<tr><td><code id="os_+3A_units">units</code></td>
<td>
<p>measure to print size in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print(object.size(x),units=units)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y&lt;-simEEG(n=50)
os(Y)
</code></pre>

<hr>
<h2 id='qrSVD'>Wrapper for <code><a href="base.html#topic+svd">svd</a></code>, which uses random preconditioning to restart when svd fails to converge</h2><span id='topic+qrSVD'></span>

<h3>Description</h3>

<p>In order to generate the SVD of the matrix <code>x</code>, <code><a href="#topic+qrSVD">qrSVD</a></code>  calls <code><a href="#topic+genQ">genQ</a></code> to generate a random orthonormal matrix, and uses this random matrix to precondition <code>x</code>. The svd of the preconditioned matrix is calculated, and adjusted to account for the preconditioning process in order to find <code>svd(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qrSVD(x, lim_attempts = 50, warning_type = "silent",
  warning_file = "qrSVD_warnings.txt", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qrSVD_+3A_x">x</code></td>
<td>
<p>a matrix to calculate the svd for</p>
</td></tr>
<tr><td><code id="qrSVD_+3A_lim_attempts">lim_attempts</code></td>
<td>
<p>the number of tries to randomly precondition x. We generally find that one preconditioning attempt is sufficient.</p>
</td></tr>
<tr><td><code id="qrSVD_+3A_warning_type">warning_type</code></td>
<td>
<p>controls whether the user should be told if an orthogonal preconditioning matrix is required, or if <code><a href="base.html#topic+svd">svd</a></code> gives warnings. 'silent' ignores these warnings, 'print' prints the warning to the console, and 'file' saves the warnings in a text file.</p>
</td></tr>
<tr><td><code id="qrSVD_+3A_warning_file">warning_file</code></td>
<td>
<p>gives the location of a file to print warnings to, if <code>warning_type</code> is set to 'file'.</p>
</td></tr>
<tr><td><code id="qrSVD_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="base.html#topic+svd">svd</a></code>, such as <code>nv</code> and <code>nu</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solves <code class="reqn">svd(x)=UDV'</code>, where <code class="reqn">U</code> is an matrix containing the left singular vectors of <code class="reqn">x</code>, <code class="reqn">D</code> is a diagonal matrix containing the singular values of <code class="reqn">x</code>; and <code class="reqn">V</code> is a matrix containing the right singular vectors of <code class="reqn">x</code> (output follows the same notation convention as the <code><a href="base.html#topic+svd">svd</a></code> function).
</p>
<p><code>qrSVD</code> will attempt the standard <code><a href="base.html#topic+svd">svd</a></code> function before preconditioning the matrix <code class="reqn">x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastSVD">fastSVD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-matrix(rnorm(3*5),nrow=3,ncol=5)
svdx &lt;- qrSVD(x)
svdx
</code></pre>

<hr>
<h2 id='reindexMatricesByK'>Used for calculation of low dimensional standard errors &amp; percentiles, by re-indexing the <code class="reqn">A^b</code> by PC index (<code class="reqn">k</code>) rather than bootstrap index (<code class="reqn">b</code>).</h2><span id='topic+reindexMatricesByK'></span>

<h3>Description</h3>

<p>This function is used as a precursor step for calculate bootstrap standard errors, or percentiles. For very high dimensional data, we recommend that the this function be applied to the low dimensional components <code class="reqn">A^b</code>, but the function can also be used to reorder a list of high dimensional bootstrap PCs. It can equivalently be used to reorder a list of scores. In general, we recommend that as many operations as possible be applied to the low dimensional components, as opposed to their high dimensional counterparts.  This function is called by <code><a href="#topic+getMomentsAndMomentCI">getMomentsAndMomentCI</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindexMatricesByK(matricesByB, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reindexMatricesByK_+3A_matricesbyb">matricesByB</code></td>
<td>
<p>a <code>B</code>-length list of (<code>r</code> by <code>K</code>) matrices from each bootstrap sample. If the list elements have class <code>ff</code>, the returned matrices will also have class <code>ff</code>.</p>
</td></tr>
<tr><td><code id="reindexMatricesByK_+3A_pattern">pattern</code></td>
<td>
<p>(optional) passed to <code>ff</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>K</code>-length list of (<code class="reqn">B</code> by <code class="reqn">r</code>) matrices. If elements of <code>matricesByB</code> have class <code>ff</code>, then the returned, reordered matrices will also have class <code>ff</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#use small n, small B, for a quick illustration
set.seed(0)
Y&lt;-simEEG(n=100, centered=TRUE, wide=TRUE) 
svdY&lt;-fastSVD(Y)
V&lt;- svdY$v #original sample PCs
DUt&lt;- tcrossprod(diag(svdY$d),svdY$u)
bInds&lt;-genBootIndeces(B=50,n=dim(DUt)[2])
bootSVD_LD_output&lt;-bootSVD_LD(DUt=DUt,bInds=bInds,K=3,verbose=interactive())

########
# to get 'low dimensional PC' moments and lower percentiles
AsByB&lt;-bootSVD_LD_output$As
AsByK&lt;-reindexMatricesByK(AsByB)

meanA1&lt;-	apply(AsByK[[1]],2,mean)
seA1&lt;-	apply(AsByK[[1]],2,sd)
pA1&lt;-	apply(AsByK[[1]],2,function(x) quantile(x,.05))
#can also use lapply to get a list (indexed by k=1,...K) of 
#the means, standard errors, or percentiles for each PC. 
#See example below, for high dimensional bootstrap PCs.

#Alternatively, moments can be calculated with
seA1_v2&lt;- getMomentsAndMomentCI(As=AsByK,
		V=diag(dim(AsByK[[1]])[2]))$sdPCs[[1]]
all(seA1_v2==seA1)

#Additional examples of exploring the low dimensional bootstrap 
#PC distribution are given in the documentation for 
#the 'bootSVD' function.
#########

#########
#High dimensional percentiles for each PC
VsByB&lt;-As2Vs(As=AsByB,V=V)
VsByK&lt;-reindexMatricesByK(VsByB)
percentileCI_Vs&lt;-lapply(VsByK,function(mat_k){
	apply(mat_k,2,function(x) quantile(x,c(.025,.975)))
})
k=2 # the 2nd PC is a little more interesting here.
matplot(t(percentileCI_Vs[[k]]),type='l',lty=1,col='blue')
lines(V[,k])
########

# Note: This function can also be used to reorganize the
#   high dimensional PCs. For 'ff' matrices, this will
#   create a new set of files on disk. 
</code></pre>

<hr>
<h2 id='reindexVectorsByK'>Used to study of the bootstrap distribution of the k^th singular values, by re-indexing the list of <code class="reqn">d^b</code> vectors to be organized by PC index (<code class="reqn">k</code>) rather than bootstrap index (<code class="reqn">b</code>).</h2><span id='topic+reindexVectorsByK'></span>

<h3>Description</h3>

<p>Used to study of the bootstrap distribution of the k^th singular values, by re-indexing the list of <code class="reqn">d^b</code> vectors to be organized by PC index (<code class="reqn">k</code>) rather than bootstrap index (<code class="reqn">b</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindexVectorsByK(vectorsByB)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reindexVectorsByK_+3A_vectorsbyb">vectorsByB</code></td>
<td>
<p>a <code>B</code>-length list, containing vectors with the <code>n</code> values from each bootstrap sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>K</code>-length list of (<code class="reqn">B</code> by <code class="reqn">n</code>) matrices, where each matrices' rows refers to the values from a different bootstrap sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#use small n, small B, for a quick illustration
set.seed(0)
Y&lt;-simEEG(n=100, centered=TRUE, wide=TRUE) 
svdY&lt;-fastSVD(Y)
DUt&lt;- tcrossprod(diag(svdY$d),svdY$u)
bInds&lt;-genBootIndeces(B=50,n=dim(DUt)[2])
bootSVD_LD_output&lt;-bootSVD_LD(DUt=DUt,bInds=bInds,K=3,verbose=interactive())

dsByK&lt;-reindexVectorsByK(bootSVD_LD_output$ds)

boxplot(dsByK[[1]],main='Bootstrap distribution of 1st singular value')
</code></pre>

<hr>
<h2 id='simEEG'>Simulation functional EEG data</h2><span id='topic+simEEG'></span>

<h3>Description</h3>

<p>Our data from (Fisher et al. 2014) consists of EEG measurements from the Sleep Heart Health Study (SHHS) (Quan et al. 1997). Since we cannot publish the EEG recordings from the individuals in the SHHS, we instead include the summary statistics of the PCs from our subsample of the processed SHHS EEG data. This data is used by the <code>simEEG</code> to simulate functional data that is approximately similar to the data used in our work. The resulting simulated vectors are always of length 900, and are generated from 5 basis vectors (see <code><a href="#topic+EEG_leadingV">EEG_leadingV</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simEEG(n = 100, centered = TRUE, propVarNoise = 0.45, wide = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simEEG_+3A_n">n</code></td>
<td>
<p>the desired sample size</p>
</td></tr>
<tr><td><code id="simEEG_+3A_centered">centered</code></td>
<td>
<p>if TRUE, the sample will be centered to have mean zero for each dimension. If FALSE, measurements will be simulated from a population where the mean is equal to that observed in the sample used in (Fisher et al. 2014) (see <code><a href="#topic+EEG_mu">EEG_mu</a></code>).</p>
</td></tr>
<tr><td><code id="simEEG_+3A_propvarnoise">propVarNoise</code></td>
<td>
<p>the approximate proportion of total sample variance attributable to random noise.</p>
</td></tr>
<tr><td><code id="simEEG_+3A_wide">wide</code></td>
<td>
<p>if TRUE, the resulting data is outputted as a <code>n</code> by 900 matrix, with each row corresponding to a different subject. If FALSE, the resulting data is outputted as a 900 by <code>n</code> matrix, with each column corresponding to a different subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing <code>n</code> simulated measurement vectors of Normalized Delta Power, for the first 7.5 hours of sleep. These vectors are generated according to the equation:
</p>
<p><code class="reqn">y = \sum_{j=1}^{5} B_j * s_j + e</code>
</p>
<p>Where <code class="reqn">y</code> is the simulated measurement for a subject, <code class="reqn">B_j</code> is the <code class="reqn">j^{th}</code> basis vector, <code class="reqn">s_j</code> is a random normal variable with mean zero, and e is a vector of random normal noise. The specific values for <code class="reqn">B_j</code> and <code class="reqn">var(s_j)</code> are determined from the EEG data sample studied in (Fisher et al., 2014), and are respectively equal to the <code class="reqn">j^{th}</code> empirical principal component vector (see <code><a href="#topic+EEG_leadingV">EEG_leadingV</a></code>), and the empirical variance of the <code class="reqn">j^{th}</code> score variable (see <code><a href="#topic+EEG_score_var">EEG_score_var</a></code>).
</p>


<h3>References</h3>

<p>Aaron Fisher, Brian Caffo, and Vadim Zipunnikov. <em>Fast, Exact Bootstrap Principal Component Analysis for p&gt;1 million</em>. 2014. http://arxiv.org/abs/1405.0922
</p>
<p>Stuart F Quan, Barbara V Howard, Conrad Iber, James P Kiley, F Javier Nieto, George T O'Connor, David M Rapoport, Susan Redline, John Robbins, JM Samet, et al.<em> The sleep heart health study: design, rationale, and methods</em>. Sleep, 20(12):1077-1085, 1997. 1.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)

#Low noise example, for an illustration of smoother functions
Y&lt;-simEEG(n=20,centered=FALSE,propVarNoise=.02,wide=FALSE)
matplot(Y,type='l',lty=1)

#Higher noise example, for PCA
Y&lt;-simEEG(n=100,centered=TRUE,propVarNoise=.5,wide=TRUE)
svdY&lt;-fastSVD(Y)
V&lt;-svdY$v #since Y is wide, the PCs are the right singular vectors (svd(Y)$v). 
d&lt;-svdY$d
head(cumsum(d^2)/sum(d^2),5) #first 5 PCs explain about half the variation

# Compare fitted PCs to true, generating basis vectors
# Since PCs have arbitrary sign, we match the sign of 
# the fitted sample PCs to the population PCs first
V_sign_adj&lt;- array(NA,dim=dim(V))
for(i in 1:5){
	V_sign_adj[,i]&lt;-V[,i] * sign(crossprod(V[,i],EEG_leadingV[,i]))
}
par(mfrow=c(1,2))
matplot(V_sign_adj[,1:5],type='l',lty=1,
		main='PCs from simulated data,\n sign adjusted')
matplot(EEG_leadingV,type='l',lty=1,main='Population PCs')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
