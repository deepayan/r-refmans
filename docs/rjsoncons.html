<!DOCTYPE html><html><head><title>Help for package rjsoncons</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rjsoncons}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_r'><p>Parse JSON or NDJSON to R</p></a></li>
<li><a href='#j_data_type'><p>Detect JSON and NDJSON data and path types</p></a></li>
<li><a href='#j_flatten'><p>Flatten and find keys or values in JSON or NDJSON documents</p></a></li>
<li><a href='#j_patch_apply'><p>Patch or compute the difference between two JSON documents</p></a></li>
<li><a href='#j_query'><p>Query and pivot JSON and NDJSON documents</p></a></li>
<li><a href='#j_schema_is_valid'><p>Validate JSON documents against JSON Schema</p></a></li>
<li><a href='#jsonpath'><p>JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON</p>
documents; use <code>j_query()</code> instead</a></li>
<li><a href='#version'><p>Version of jsoncons C++ library</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Query, Pivot, Patch, and Validate 'JSON' and 'NDJSON'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to query (filter or transform), pivot (convert
    from array-of-objects to object-of-arrays, for easy import as 'R'
    data frame), search, patch (edit), and validate (against 'JSON Schema')
    'JSON' and 'NDJSON' strings, files, or URLs. Query and
    pivot support 'JSONpointer', 'JSONpath' or 'JMESpath'
    expressions. The implementation uses the 'jsoncons'
    <a href="https://danielaparker.github.io/jsoncons/">https://danielaparker.github.io/jsoncons/</a> header-only library;
    the library is easily linked to other packages for direct access
    to 'C++' functionality not implemented here.</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>jsonlite, tinytest, BiocStyle, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11, cli</td>
</tr>
<tr>
<td>License:</td>
<td><a href="http://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mtmorgan/rjsoncons/issues">https://github.com/mtmorgan/rjsoncons/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mtmorgan.github.io/rjsoncons/">https://mtmorgan.github.io/rjsoncons/</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-01 18:23:42 UTC; ma38727</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Morgan <a href="https://orcid.org/0000-0002-5874-8148"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Marcel Ramos <a href="https://orcid.org/0000-0002-3242-0582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel Parker [aut, cph] (jsoncons C++ library maintainer)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Morgan &lt;mtmorgan.xyz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-07 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_r'>Parse JSON or NDJSON to R</h2><span id='topic+as_r'></span>

<h3>Description</h3>

<p><code>as_r()</code> transforms JSON or NDJSON to an <em>R</em> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_r(
  data,
  object_names = "asis",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_r_+3A_data">data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or the
name of a file or URL containing JSON or NDJSON, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td></tr>
<tr><td><code id="as_r_+3A_object_names">object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td></tr>
<tr><td><code id="as_r_+3A_...">...</code></td>
<td>
<p>passed to <code>jsonlite::toJSON</code> when <code>data</code> is an <em>R</em> object.</p>
</td></tr>
<tr><td><code id="as_r_+3A_n_records">n_records</code></td>
<td>
<p>numeric(1) maximum number of NDJSON records parsed.</p>
</td></tr>
<tr><td><code id="as_r_+3A_verbose">verbose</code></td>
<td>
<p>logical(1) report progress when parsing large NDJSON
files.</p>
</td></tr>
<tr><td><code id="as_r_+3A_data_type">data_type</code></td>
<td>
<p>character(1) type of <code>data</code>; one of <code>"json"</code>,
<code>"ndjson"</code>, or a value returned by <code>j_data_type()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>as = "R"</code> argument to <code>j_query()</code>, <code>j_pivot()</code>, and the
<code>as_r()</code> function transform JSON or NDJSON to an <em>R</em> object. JSON
and NDJSON can be a character vector, file, or url, or an <em>R</em>
object (which is first translated to a JSON string). Main rules are:
</p>

<ul>
<li><p> JSON arrays of a single type (boolean, integer, double, string)
are transformed to <em>R</em> vectors of the same length and
corresponding type. A JSON scalar and a JSON vector of length 1
are represented in the same way in <em>R</em>.
</p>
</li>
<li><p> If a JSON 64-bit integer array contains a value larger than <em>R</em>'s
32-bit integer representation, the array is transformed to an <em>R</em>
numeric vector. NOTE that this results in loss of precision for
64-bit integer values greater than <code>2^53</code>.
</p>
</li>
<li><p> JSON arrays mixing integer and double values are transformed to
<em>R</em> numeric vectors.
</p>
</li>
<li><p> JSON objects are transformed to <em>R</em> named lists.
</p>
</li></ul>

<p>The vignette reiterates this information and provides additional
details.
</p>


<h3>Value</h3>

<p><code>as_r()</code> returns an <em>R</em> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## as_r()
as_r('[1, 2, 3]')       # JSON integer array -&gt; R integer vector
as_r('[1, 2.0, 3]')     # JSON intger and double array -&gt; R numeric vector
as_r('[1, 2.0, "3"]')   # JSON mixed array -&gt; R list
as_r('[1, 2147483648]') # JSON integer &gt; R integer max -&gt; R numeric vector

json &lt;- '{"b": 1, "a": ["c", "d"], "e": true, "f": [true], "g": {}}'
as_r(json) |&gt; str()     # parsing complex objects
identical(              # JSON scalar and length 1 array identical in R
    as_r('{"a": 1}'), as_r('{"a": [1]}')
)

</code></pre>

<hr>
<h2 id='j_data_type'>Detect JSON and NDJSON data and path types</h2><span id='topic+j_data_type'></span><span id='topic+j_path_type'></span>

<h3>Description</h3>

<p><code>j_data_type()</code> uses simple rules to determine whether
'data' is JSON, NDJSON, file, url, or R.
</p>
<p><code>j_path_type()</code> uses simple rules to identify
whether <code>path</code> is a JSONpointer, JSONpath, or JMESpath
expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_data_type(data)

j_path_type(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_data_type_+3A_data">data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or the
name of a file or URL containing JSON or NDJSON, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td></tr>
<tr><td><code id="j_data_type_+3A_path">path</code></td>
<td>
<p>character(1) JSONpointer, JSONpath or JMESpath query
string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>j_data_type()</code> without any arguments reports possible return
values: <code>"json"</code>, <code>"ndjson"</code>, <code>"file"</code>, <code>"url"</code>, <code>"R"</code>.  When
provided an argument, <code>j_data_type()</code> infers (but does not
validate) the type of <code>data</code> based on the following rules:
</p>

<ul>
<li><p> For a scalar (length 1) character <code>data</code>, either <code>"url"</code>
(matching regular expression <code>"^https?://"</code>, <code>"file"</code>
(<code>file.exists(data)</code> returns <code>TRUE</code>), or <code>"json"</code>. When <code>"file"</code>
or <code>"url"</code> is inferred, the return value is a length 2 vector,
with the first element the inferred type of data (<code>"json"</code> or
<code>"ndjson"</code>) obtained from the first 2 lines of the file.
</p>
</li>
<li><p> For character data with <code>length(data) &gt; 1</code>, <code>"ndjson"</code> if all
elements start a square bracket or curly brace, consistently
(i.e., agreeing with the start of the first record), otherwise
<code>"json"</code>.
</p>
</li>
<li> <p><code>"R"</code> for all non-character data.
</p>
</li></ul>

<p><code>j_path_type()</code> without any argument reports possible values:
<code>"JSONpointer"</code>, <code>"JSONpath"</code>, or <code>"JMESpath"</code>. When provided an
argument, <code>j_path_type()</code> infers the type of <code>path</code> using a simple
but incomplete classification:
</p>

<ul>
<li> <p><code>"JSONpointer"</code> is inferred if the the path is <code>""</code> or starts with <code>"/"</code>.
</p>
</li>
<li> <p><code>"JSONpath"</code> expressions start with <code>"$"</code>.
</p>
</li>
<li> <p><code>"JMESpath"</code> expressions satisfy neither the <code>JSONpointer</code> nor
<code>JSONpath</code> criteria.
</p>
</li></ul>

<p>Because of these rules, the valid JSONpointer path <code>"@"</code> is
interpreted as JMESpath; use <code>jsonpointer()</code> if JSONpointer
behavior is required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>j_data_type()                            # available types
j_data_type("")                          # json
j_data_type('{"a": 1}')                  # json
j_data_type(c('[{"a": 1}', '{"a": 2}]')) # json
j_data_type(c('{"a": 1}', '{"a": 2}'))   # ndjson
j_data_type(list(a = 1, b = 2))          # R
fl &lt;- system.file(package = "rjsoncons", "extdata", "example.json")
j_data_type(fl)                          # c('json', 'file')
j_data_type(readLines(fl))               # json

j_path_type()                            # available types
j_path_type("")                          # JSONpointer
j_path_type("/locations/0/name")         # JSONpointer
j_path_type("$.locations[0].name")       # JSONpath
j_path_type("locations[0].name")         # JMESpath

</code></pre>

<hr>
<h2 id='j_flatten'>Flatten and find keys or values in JSON or NDJSON documents</h2><span id='topic+j_flatten'></span><span id='topic+j_find_values'></span><span id='topic+j_find_values_grep'></span><span id='topic+j_find_keys'></span><span id='topic+j_find_keys_grep'></span><span id='topic+flatten_NDJSON'></span>

<h3>Description</h3>

<p><code>j_flatten()</code> transforms a JSON document into a list
where names are JSONpointer 'paths' and elements are the
corresponding 'values' from the JSON document.
</p>
<p><code>j_find_values()</code> finds paths to exactly matching
values.
</p>
<p><code>j_find_values_grep()</code> finds paths to values matching
a regular expression.
</p>
<p><code>j_find_keys()</code> finds paths to exactly matching keys.
</p>
<p><code>j_find_keys_grep()</code> finds paths to keys matching a
regular expression.
</p>
<p>For NDJSON documents, the result is either a character
vector (for <code>as = "string"</code>) or list of <em>R</em> objects, one
element for each NDJSON record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_flatten(
  data,
  object_names = "asis",
  as = "string",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)

j_find_values(
  data,
  values,
  object_names = "asis",
  as = "R",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)

j_find_values_grep(
  data,
  pattern,
  object_names = "asis",
  as = "R",
  ...,
  grep_args = list(),
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)

j_find_keys(
  data,
  keys,
  object_names = "asis",
  as = "R",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)

j_find_keys_grep(
  data,
  pattern,
  object_names = "asis",
  as = "R",
  ...,
  grep_args = list(),
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_flatten_+3A_data">data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or the
name of a file or URL containing JSON or NDJSON, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_object_names">object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_as">as</code></td>
<td>
<p>character(1) describing the return type.  For
<code>j_flatten()</code>, either &quot;string&quot; or &quot;R&quot;. For other functions on
this page, one of &quot;R&quot;, &quot;data.frame&quot;, or &quot;tibble&quot;.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_...">...</code></td>
<td>
<p>passed to <code>jsonlite::toJSON</code> when <code>data</code> is an <em>R</em> object.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_n_records">n_records</code></td>
<td>
<p>numeric(1) maximum number of NDJSON records parsed.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_verbose">verbose</code></td>
<td>
<p>logical(1) report progress when parsing large NDJSON
files.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_data_type">data_type</code></td>
<td>
<p>character(1) type of <code>data</code>; one of <code>"json"</code>,
<code>"ndjson"</code>, or a value returned by <code>j_data_type()</code>.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_path_type">path_type</code></td>
<td>
<p>character(1) type of 'path' to be returned; one of
'&quot;JSONpointer&quot;', '&quot;JSONpath&quot;'; '&quot;JMESpath&quot;' is not supported.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_values">values</code></td>
<td>
<p>vector of one or more values to be matched exactly to
values in the JSON document.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_pattern">pattern</code></td>
<td>
<p>character(1) regular expression to match values or
paths.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_grep_args">grep_args</code></td>
<td>
<p>list() additional arguments passed to <code>grepl()</code>
when searching on values or paths.</p>
</td></tr>
<tr><td><code id="j_flatten_+3A_keys">keys</code></td>
<td>
<p>character() vector of one or more keys to be matched
exactly to path elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions documented on this page expand <code>data</code> into all
path / value pairs. This is not suitable for very large JSON
documents.
</p>
<p>For <code>j_find_keys()</code>, the <code>key</code> must exactly match one or
more consecutive keys in the JSONpointer path returned by
<code>j_flatten()</code>.
</p>
<p>For <code>j_find_keys_grep()</code>, the <code>key</code> can define a pattern
that spans across JSONpointer or JSONpath elements.
</p>


<h3>Value</h3>

<p><code>j_flatten(as = "string")</code> (default) returns a JSON string
representation of the flattened document, i.e., an object with keys
the JSONpointer paths and values the value at the corresponding
path in the original document.
</p>
<p><code>j_flatten(as = "R")</code> returns a named list, where <code>names()</code> are the
JSONpointer paths to each element in the JSON document and list
elements are the corresponding values.
</p>
<p><code>j_find_values()</code> and <code>j_find_values_grep()</code> return a list
with names as JSONpointer paths and list elements the matching
values, or a <code>data.frame</code> or <code>tibble</code> with columns <code>path</code> and
<code>value</code>. Values are coerced to a common type when <code>as</code> is
<code>data.frame</code> or <code>tibble</code>.
</p>
<p><code>j_find_keys()</code> and <code>j_find_keys_grep()</code> returns a list,
data.frame, or tibble similar to <code>j_find_values()</code> and
<code>j_find_values_grep()</code>.
</p>
<p>For NDJSON documents, the result is a vector paralleling
the NDJSON document, with <code>j_flatten()</code> applied to each element
of the NDJSON document.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>json &lt;- '{
    "discards": {
        "1000": "Record does not exist",
        "1004": "Queue limit exceeded",
        "1010": "Discarding timed-out partial msg"
    },
    "warnings": {
        "0": "Phone number missing country code",
        "1": "State code missing",
        "2": "Zip code missing"
    }
}'

## JSONpointer
j_flatten(json) |&gt;
    cat("\n")

## JSONpath
j_flatten(json, as = "R", path_type = "JSONpath") |&gt;
    str()

j_find_values(json, "Zip code missing", as = "tibble")
j_find_values(
    json,
    c("Queue limit exceeded", "Zip code missing"),
    as = "tibble"
)

j_find_values_grep(json, "missing", as = "tibble")

## JSONpath
j_find_values_grep(json, "missing", as = "tibble", path_type = "JSONpath")

j_find_keys(json, "discards", as = "tibble")
j_find_keys(json, "1", as = "tibble")
j_find_keys(json, c("discards", "warnings"), as = "tibble")

## JSONpath
j_find_keys(json, "discards", as = "tibble", path_type = "JSONpath")

j_find_keys_grep(json, "discard", as = "tibble")
j_find_keys_grep(json, "1", as = "tibble")
j_find_keys_grep(json, "car.*/101", as = "tibble")

## JSONpath
j_find_keys_grep(json, "car.*\\['101", as = "tibble", path_type = "JSONpath")

## NDJSON

ndjson_file &lt;-
    system.file(package = "rjsoncons", "extdata", "example.ndjson")
j_flatten(ndjson_file) |&gt;
    noquote()
j_find_values_grep(ndjson_file, "e") |&gt;
    str()
</code></pre>

<hr>
<h2 id='j_patch_apply'>Patch or compute the difference between two JSON documents</h2><span id='topic+j_patch_apply'></span><span id='topic+j_patch_from'></span><span id='topic+j_patch_op'></span><span id='topic+j_patch_op.default'></span><span id='topic+j_patch_op.j_patch_op'></span><span id='topic+c.j_patch_op'></span><span id='topic+print.j_patch_op'></span>

<h3>Description</h3>

<p><code>j_patch_apply()</code> uses JSON Patch
<a href="https://jsonpatch.com">https://jsonpatch.com</a> to transform JSON 'data' according the
rules in JSON 'patch'.
</p>
<p><code>j_patch_from()</code> computes a JSON patch describing the
difference between two JSON documents.
</p>
<p><code>j_patch_op()</code> translates <em>R</em> arguments to the JSON
representation of a patch, validating and 'unboxing' arguments
as necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_patch_apply(data, patch, as = "string", ...)

j_patch_from(data_x, data_y, as = "string", ...)

j_patch_op(op, path, ...)

## Default S3 method:
j_patch_op(op, path, ..., from = NULL, value = NULL)

## S3 method for class 'j_patch_op'
j_patch_op(op, ...)

## S3 method for class 'j_patch_op'
c(..., recursive = FALSE)

## S3 method for class 'j_patch_op'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_patch_apply_+3A_data">data</code></td>
<td>
<p>JSON character vector, file, URL, or an <em>R</em> object to
be converted to JSON using <code>jsonline::fromJSON(data, ...)</code>.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_patch">patch</code></td>
<td>
<p>JSON 'patch' as character vector, file, URL, <em>R</em>
object, or the result of <code>j_patch_op()</code>.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_as">as</code></td>
<td>
<p>character(1) return type; <code>"string"</code> returns a JSON
string, <code>"R"</code> returns an <em>R</em> object using the rules in
<code>as_r()</code>.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_...">...</code></td>
<td>
<p>For <code>j_patch_apply()</code> and <code>j_patch_diff()</code>, arguments passed to
<code>jsonlite::toJSON</code> when <code>data</code>, <code>patch</code>, <code>data_x</code>, and / or
<code>data_y</code> is an <em>R</em> object.  It is appropriate to add the
<code>jsonlite::toJSON()</code> argument <code>auto_unbox = TRUE</code> when <code>patch</code> is
an <em>R</em> object and any 'value' fields are JSON scalars; for more
complicated scenarios 'value' fields should be marked with
<code>jsonlite::unbox()</code> before being passed to <code style="white-space: pre;">&#8288;j_patch_*()&#8288;</code>.
</p>
<p>For <code>j_patch_op()</code> the <code>...</code> are additional arguments to the patch
operation, e.g., <code style="white-space: pre;">&#8288;path = ', &#8288;</code>value = '.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_data_x">data_x</code></td>
<td>
<p>As for <code>data</code>.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_data_y">data_y</code></td>
<td>
<p>As for <code>data</code>.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_op">op</code></td>
<td>
<p>A patch operation (<code>"add"</code>, <code>"remove"</code>, <code>"replace"</code>,
<code>"copy"</code>, <code>"move"</code>, <code>"test"</code>), or when 'piping' an object
created by <code>j_patch_op()</code>.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_path">path</code></td>
<td>
<p>A character(1) JSONPointer path to the location being patched.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_from">from</code></td>
<td>
<p>A character(1) JSONPointer path to the location an
object will be copied or moved from.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_value">value</code></td>
<td>
<p>An <em>R</em> object to be translated into JSON and used during
add, replace, or test.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_recursive">recursive</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="j_patch_apply_+3A_x">x</code></td>
<td>
<p>An object produced by <code>j_patch_op()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>j_patch_apply()</code>, 'patch' is a JSON array of objects. Each
object describes how the patch is to be applied. Simple examples
are available at <a href="https://jsonpatch.com">https://jsonpatch.com</a>, with verbs 'add',
'remove', 'replace', 'copy' and 'test'. The 'path' element of each
operation is a JSON pointer; remember that JSON arrays are 0-based.
</p>

<ul>
<li> <p><code>add</code> &ndash; add elements to an existing document.
</p>
<div class="sourceCode"><pre>{"op": "add", "path": "/biscuits/1", "value": {"name": "Ginger Nut"}}
</pre></div>
</li>
<li> <p><code>remove</code> &ndash; remove elements from a document.
</p>
<div class="sourceCode"><pre>{"op": "remove", "path": "/biscuits/0"}
</pre></div>
</li>
<li> <p><code>replace</code> &ndash; replace one element with another
</p>
<div class="sourceCode"><pre>{
    "op": "replace", "path": "/biscuits/0/name",
    "value": "Chocolate Digestive"
}
</pre></div>
</li>
<li> <p><code>copy</code> &ndash; copy a path to another location.
</p>
<div class="sourceCode"><pre>{"op": "copy", "path": "/best_biscuit", "from": "/biscuits/0"}
</pre></div>
</li>
<li> <p><code>move</code> &ndash; move a path to another location.
</p>
<div class="sourceCode"><pre>{"op": "move", "path": "/cookies", "from": "/biscuits"}
</pre></div>
</li>
<li> <p><code>test</code> &ndash; test for the existence of a path; if the path does not
exist, do not apply any of the patch.
</p>
<div class="sourceCode"><pre>{"op": "test", "path": "/best_biscuit/name", "value": "Choco Leibniz"}
</pre></div>
</li></ul>

<p>The examples below illustrate a patch with one (a JSON array with a
single object) or several (a JSON array with several arguments)
operations. <code>j_patch_apply()</code> fits naturally into a pipeline
composed with <code style="white-space: pre;">&#8288;|&gt;&#8288;</code> to transform JSON between representations.
</p>
<p>The <code>j_patch_op()</code> function takes care to ensure that <code>op</code>, <code>path</code>,
and <code>from</code> arguments are 'unboxed' (represented as JSON scalars
rather than arrays). The user must ensure that <code>value</code> is
represented correctly by applying <code>jsonlite::unbox()</code> to individual
elements or adding <code>auto_unbox = TRUE</code> to <code>...</code>. Examples
illustrate these different scenarios.
</p>


<h3>Value</h3>

<p><code>j_patch_apply()</code> returns a JSON string or <em>R</em> object
representing 'data' patched according to 'patch'.
</p>
<p><code>j_patch_from()</code> returns a JSON string or <em>R</em> object
representing the difference between 'data_x' and 'data_y'.
</p>
<p><code>j_patch_op()</code> returns a character vector subclass that can
be used in <code>j_patch_apply()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_file &lt;-
    system.file(package = "rjsoncons", "extdata", "patch_data.json")

## add a biscuit
patch &lt;- '[
    {"op": "add", "path": "/biscuits/1", "value": {"name": "Ginger Nut"}}
]'
j_patch_apply(data_file, patch, as = "R") |&gt; str()

## add a biscuit and choose a favorite
patch &lt;- '[
    {"op": "add", "path": "/biscuits/1", "value": {"name": "Ginger Nut"}},
    {"op": "copy", "path": "/best_biscuit", "from": "/biscuits/2"}
]'
biscuits &lt;- j_patch_apply(data_file, patch)
as_r(biscuits) |&gt; str()

j_patch_from(biscuits, data_file, as = "R") |&gt; str()

if (requireNamespace("jsonlite", quietly = TRUE)) {
## helper for constructing patch operations from R objects
j_patch_op(
    "add", path = "/biscuits/1", value = list(name = "Ginger Nut"),
    ## 'Ginger Nut' is a JSON scalar, so auto-unbox the 'value' argument
    auto_unbox = TRUE
)
j_patch_op("remove", "/biscuits/0")
j_patch_op(
    "replace", "/biscuits/0/name",
    ## also possible to unbox arguments explicitly
    value = jsonlite::unbox("Chocolate Digestive")
)
j_patch_op("copy", "/best_biscuit", from = "/biscuits/0")
j_patch_op("move", "/cookies", from = "/biscuits")
j_patch_op(
    "test", "/best_biscuit/name", value = "Choco Leibniz",
    auto_unbox = TRUE
)

## several operations
value &lt;- list(name = jsonlite::unbox("Ginger Nut"))
ops &lt;- c(
    j_patch_op("add", "/biscuits/1", value = value),
    j_patch_op("copy", path = "/best_biscuit", from = "/biscuits/0")
)
ops

ops &lt;-
    j_patch_op("add", "/biscuits/1", value = value) |&gt;
    j_patch_op("copy", path = "/best_biscuit", from = "/biscuits/0")
ops
}
</code></pre>

<hr>
<h2 id='j_query'>Query and pivot JSON and NDJSON documents</h2><span id='topic+j_query'></span><span id='topic+j_pivot'></span>

<h3>Description</h3>

<p><code>j_query()</code> executes a query against a JSON or NDJSON
document, automatically inferring the type of <code>data</code> and
<code>path</code>.
</p>
<p><code>j_pivot()</code> transforms a JSON array-of-objects to an
object-of-arrays; this can be useful when forming a
column-based tibble from row-oriented JSON / NDJSON.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_query(
  data,
  path = "",
  object_names = "asis",
  as = "string",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = j_path_type(path)
)

j_pivot(
  data,
  path = "",
  object_names = "asis",
  as = "string",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = j_path_type(path)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_query_+3A_data">data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or the
name of a file or URL containing JSON or NDJSON, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td></tr>
<tr><td><code id="j_query_+3A_path">path</code></td>
<td>
<p>character(1) JSONpointer, JSONpath or JMESpath query
string.</p>
</td></tr>
<tr><td><code id="j_query_+3A_object_names">object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td></tr>
<tr><td><code id="j_query_+3A_as">as</code></td>
<td>
<p>character(1) return type. For <code>j_query()</code>, <code>"string"</code>
returns JSON / NDJSON strings; <code>"R"</code> parses JSON / NDJSON to R
using rules in <code>as_r()</code>. For <code>j_pivot()</code> (JSON only), use <code>as = "data.frame"</code> or <code>as = "tibble"</code> to coerce the result to a
data.frame or tibble.</p>
</td></tr>
<tr><td><code id="j_query_+3A_...">...</code></td>
<td>
<p>passed to <code>jsonlite::toJSON</code> when <code>data</code> is an <em>R</em> object.</p>
</td></tr>
<tr><td><code id="j_query_+3A_n_records">n_records</code></td>
<td>
<p>numeric(1) maximum number of NDJSON records parsed.</p>
</td></tr>
<tr><td><code id="j_query_+3A_verbose">verbose</code></td>
<td>
<p>logical(1) report progress when parsing large NDJSON
files.</p>
</td></tr>
<tr><td><code id="j_query_+3A_data_type">data_type</code></td>
<td>
<p>character(1) type of <code>data</code>; one of <code>"json"</code>,
<code>"ndjson"</code>, or a value returned by <code>j_data_type()</code>.</p>
</td></tr>
<tr><td><code id="j_query_+3A_path_type">path_type</code></td>
<td>
<p>character(1) type of <code>path</code>; one of
<code>"JSONpointer"</code>, <code>"JSONpath"</code>, <code>"JMESpath"</code>. Inferred from
<code>path</code> using <code>j_path_type()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>j_pivot()</code> transforms an 'array-of-objects' (typical when the JSON
is a row-oriented representation of a table) to an
'object-of-arrays'. A simple example transforms an array of two
objects each with three fields <code>'[{"a": 1, "b": 2, "c": 3}, {"a": 4, "b": 5, "c": 6}]'</code> to an object with three fields, each a vector
of length 2 <code>'{"a": [1, 4], "b": [2, 5], "c": [3, 6]}'</code>. The
object-of-arrays representation corresponds closely to an <em>R</em>
data.frame or tibble, as illustrated in the examples.
</p>
<p><code>j_pivot()</code> with JMESpath paths are especially useful for
transforming NDJSON to a <code>data.frame</code> or <code>tibble</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>json &lt;- '{
  "locations": [
    {"name": "Seattle", "state": "WA"},
    {"name": "New York", "state": "NY"},
    {"name": "Bellevue", "state": "WA"},
    {"name": "Olympia", "state": "WA"}
  ]
}'

j_query(json, "/locations/0/name")             # JSONpointer
j_query(json, "$.locations[*].name", as = "R") # JSONpath
j_query(json, "locations[].state", as = "R")   # JMESpath

## a few NDJSON records from &lt;https://www.gharchive.org/&gt;
ndjson_file &lt;-
    system.file(package = "rjsoncons", "extdata", "2023-02-08-0.json")
j_query(ndjson_file, "{id: id, type: type}")

j_pivot(json, "$.locations[?@.state=='WA']", as = "string")
j_pivot(json, "locations[?@.state=='WA']", as = "R")
j_pivot(json, "locations[?@.state=='WA']", as = "data.frame")
j_pivot(json, "locations[?@.state=='WA']", as = "tibble")

## use 'path' to pivot ndjson one record at at time
j_pivot(ndjson_file, "{id: id, type: type}", as = "data.frame")

## 'org' is a nested element; extract it
j_pivot(ndjson_file, "org", as = "data.frame")

## use j_pivot() to filter 'PushEvent' for organizations
path &lt;- "[{id: id, type: type, org: org}]
             [?@.type == 'PushEvent' &amp;&amp; @.org != null] |
                 [0]"
j_pivot(ndjson_file, path, as = "data.frame")

## try also
##
##     j_pivot(ndjson_file, path, as = "tibble") |&gt;
##         tidyr::unnest_wider("org", names_sep = ".")
</code></pre>

<hr>
<h2 id='j_schema_is_valid'>Validate JSON documents against JSON Schema</h2><span id='topic+j_schema_is_valid'></span><span id='topic+j_schema_validate'></span>

<h3>Description</h3>

<p><code>j_schema_is_vaild()</code> uses JSON Schema
<a href="https://json-schema.org/">https://json-schema.org/</a> to validate JSON 'data' according to
'schema'.
</p>
<p><code>j_schema_validate()</code> returns a JSON or <em>R</em> object,
data.frame, or tibble, describing how <code>data</code> does not conform
to <code>schema</code>. See the &quot;Using 'jsoncons' in R&quot; vignette for help
interpreting validation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_schema_is_valid(
  data,
  schema,
  ...,
  data_type = j_data_type(data),
  schema_type = j_data_type(schema)
)

j_schema_validate(
  data,
  schema,
  as = "string",
  ...,
  data_type = j_data_type(data),
  schema_type = j_data_type(schema)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_schema_is_valid_+3A_data">data</code></td>
<td>
<p>JSON character vector, file, or URL defining document
to be validated. NDJSON data and schema are not supported.</p>
</td></tr>
<tr><td><code id="j_schema_is_valid_+3A_schema">schema</code></td>
<td>
<p>JSON character vector, file, or URL defining the
schema against which <code>data</code> will be validated.</p>
</td></tr>
<tr><td><code id="j_schema_is_valid_+3A_...">...</code></td>
<td>
<p>passed to <code>jsonlite::toJSON</code> when <code>data</code> is not
character-valued.</p>
</td></tr>
<tr><td><code id="j_schema_is_valid_+3A_data_type">data_type</code></td>
<td>
<p>character(1) type of <code>data</code>; one of <code>"json"</code> or a
value returned by <code>j_data_type()</code>; schema validation does not
support <code>"ndjson"</code> data.</p>
</td></tr>
<tr><td><code id="j_schema_is_valid_+3A_schema_type">schema_type</code></td>
<td>
<p>character(1) type of <code>schema</code>; see <code>data_type</code>.</p>
</td></tr>
<tr><td><code id="j_schema_is_valid_+3A_as">as</code></td>
<td>
<p>for <code>j_schema_validate()</code>, one of <code>"string"</code>, <code>"R"</code>,
<code>"data.frame"</code>, <code>"tibble"</code>, or <code>"details"</code>, to determine the
representation of the return value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Allowable `data_type=` and `schema_type` -- excludes 'ndjson'
j_data_type() |&gt;
    Filter(\(type) !"ndjson" %in% type, x = _) |&gt;
    str()
## compare JSON patch to specification. 'op' key should have value
## 'add'; 'paths' key should be key 'path'
## schema &lt;- "https://json.schemastore.org/json-patch.json"
schema &lt;- system.file(package = "rjsoncons", "extdata", "json-patch.json")
op &lt;- '[{
    "op": "adds", "paths": "/biscuits/1",
    "value": { "name": "Ginger Nut" }
}]'
j_schema_is_valid(op, schema)

j_schema_validate(op, schema, as = "details")

</code></pre>

<hr>
<h2 id='jsonpath'>JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON
documents; use <code>j_query()</code> instead</h2><span id='topic+jsonpath'></span><span id='topic+jmespath'></span><span id='topic+jsonpointer'></span>

<h3>Description</h3>

<p><code>jsonpath()</code> executes a query against a JSON string or
vector NDJSON entries using the 'JSONpath' specification.
</p>
<p><code>jmespath()</code> executes a query against a JSON string
using the 'JMESpath' specification.
</p>
<p><code>jsonpointer()</code> extracts an element from a JSON string
using the 'JSON pointer' specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsonpath(data, path, object_names = "asis", as = "string", ...)

jmespath(data, path, object_names = "asis", as = "string", ...)

jsonpointer(data, path, object_names = "asis", as = "string", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jsonpath_+3A_data">data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or the
name of a file or URL containing JSON or NDJSON, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td></tr>
<tr><td><code id="jsonpath_+3A_path">path</code></td>
<td>
<p>character(1) JSONpointer, JSONpath or JMESpath query
string.</p>
</td></tr>
<tr><td><code id="jsonpath_+3A_object_names">object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td></tr>
<tr><td><code id="jsonpath_+3A_as">as</code></td>
<td>
<p>character(1) return type. <code>"string"</code> returns a single
JSON string; <code>"R"</code> returns an <em>R</em> object following the rules
outlined for <code>as_r()</code>.</p>
</td></tr>
<tr><td><code id="jsonpath_+3A_...">...</code></td>
<td>
<p>arguments for parsing NDJSON, or passed to <code>jsonlite::toJSON</code> when
<code>data</code> is not character-valued. For NDJSON,
</p>

<ul>
<li><p> Use <code>n_records = 2</code> to parse just the first two records of the
NDJSON document.
</p>
</li>
<li><p> Use <code>verbose = TRUE</code> to obtain a progress bar when reading from a
connection (file or URL). Requires the cli package.
</p>
</li></ul>

<p>As an example for use with <code>jsonlite::toJSON()</code>
</p>

<ul>
<li><p> use <code>auto_unbox = TRUE</code> to automatically 'unbox' vectors of
length 1 to JSON scalar values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>jsonpath()</code>, <code>jmespath()</code> and <code>jsonpointer()</code> return a
character(1) JSON string (<code>as = "string"</code>, default) or <em>R</em>
object (<code>as = "R"</code>) representing the result of the query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>json &lt;- '{
  "locations": [
    {"name": "Seattle", "state": "WA"},
    {"name": "New York", "state": "NY"},
    {"name": "Bellevue", "state": "WA"},
    {"name": "Olympia", "state": "WA"}
  ]
 }'

## return a JSON string
jsonpath(json, "$..name") |&gt;
    cat("\n")

## return an R object
jsonpath(json, "$..name", as = "R")

## create a list with state and name as scalar vectors
lst &lt;- as_r(json)

if (requireNamespace("jsonlite", quietly = TRUE)) {
## objects other than scalar character vectors are automatically
## coerced to JSON; use `auto_unbox = TRUE` to represent R scalar
## vectors in the object as JSON scalar vectors
jsonpath(lst, "$..name", auto_unbox = TRUE) |&gt;
    cat("\n")

## use I("Seattle") to coerce to a JSON object ["Seattle"]
jsonpath(I("Seattle"), "$[0]")      |&gt; cat("\n")
}

## a scalar character vector like "Seattle" is not valid JSON...
try(jsonpath("Seattle", "$"))
## ...but a double-quoted string is
jsonpath('"Seattle"', "$")

## different ordering of object names -- 'asis' (default) or 'sort'
json_obj &lt;- '{"b": "1", "a": "2"}'
jsonpath(json_obj, "$")           |&gt; cat("\n")
jsonpath(json_obj, "$.*")         |&gt; cat("\n")
jsonpath(json_obj, "$", "sort")   |&gt; cat("\n")
jsonpath(json_obj, "$.*", "sort") |&gt; cat("\n")

path &lt;- "locations[?state == 'WA'].name | sort(@)"
jmespath(json, path) |&gt;
    cat("\n")

if (requireNamespace("jsonlite", quietly = TRUE)) {
## original filter always fails, e.g., '["WA"] != 'WA'
jmespath(lst, path)  # empty result set, '[]'

## filter with unboxed state, and return unboxed name
jmespath(lst, "locations[?state[0] == 'WA'].name[0] | sort(@)") |&gt;
    cat("\n")

## automatically unbox scalar values when creating the JSON string
jmespath(lst, path, auto_unbox = TRUE) |&gt;
    cat("\n")
}

## jsonpointer 0-based arrays
jsonpointer(json, "/locations/0/name")

## document root "", sort selected element keys
jsonpointer('{"b": 0, "a": 1}', "", "sort", as = "R") |&gt;
    str()

## 'Key not found' -- path '/' searches for a 0-length key
try(jsonpointer('{"b": 0, "a": 1}', "/"))

</code></pre>

<hr>
<h2 id='version'>Version of jsoncons C++ library</h2><span id='topic+version'></span>

<h3>Description</h3>

<p><code>version()</code> reports the version of the C++ jsoncons
library in use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version()
</code></pre>


<h3>Value</h3>

<p><code>version()</code> returns a character(1) major.minor.patch
version string, possibly with git hash for between-release
version.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>version()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
