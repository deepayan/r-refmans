<!DOCTYPE html><html><head><title>Help for package rjsoncons</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rjsoncons}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_r'><p>Parse JSON to R</p></a></li>
<li><a href='#j_data_type'><p>Detect JSON / NDJSON data and path types</p></a></li>
<li><a href='#j_query'><p>Query and pivot for JSON / NDJSON documents</p></a></li>
<li><a href='#jsonpath'><p>JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON documents</p></a></li>
<li><a href='#version'><p>Version of jsoncons C++ library</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>'C++' Header-Only 'jsoncons' Library for 'JSON' Queries</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'jsoncons'
    <a href="https://danielaparker.github.io/jsoncons/">https://danielaparker.github.io/jsoncons/</a> 'C++' header-only
    library constructs representations from a 'JSON' character vector,
    and provides extensions for flexible queries and other operations
    on 'JSON' objects. This package provides 'R' functions to query
    (filter or transform) and pivot (convert from array-of-objects to
    object-of-arrays, for easy import into 'R') 'JSON' or 'NDJSON'
    strings or files using 'JSONpointer', 'JSONpath' or 'JMESpath'
    expression. The 'jsoncons' library is also be easily linked to
    other packages for direct access to 'C++' functionality.</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>jsonlite, tibble, cli, tinytest, BiocStyle, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>License:</td>
<td><a href="http://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mtmorgan/rjsoncons/issues">https://github.com/mtmorgan/rjsoncons/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mtmorgan.github.io/rjsoncons/">https://mtmorgan.github.io/rjsoncons/</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-26 22:14:07 UTC; ma38727</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Morgan <a href="https://orcid.org/0000-0002-5874-8148"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Marcel Ramos <a href="https://orcid.org/0000-0002-3242-0582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel Parker [aut, cph] (jsoncons C++ library maintainer)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Morgan &lt;mtmorgan.xyz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-26 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_r'>Parse JSON to R</h2><span id='topic+as_r'></span>

<h3>Description</h3>

<p><code>as_r()</code> transforms a JSON string to an <em>R</em> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_r(data, object_names = "asis", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_r_+3A_data">data</code></td>
<td>
<p>a character(1) JSON string or (unusually) an <code>R</code> object.</p>
</td></tr>
<tr><td><code id="as_r_+3A_object_names">object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td></tr>
<tr><td><code id="as_r_+3A_...">...</code></td>
<td>
<p>passed to <code>jsonlite::toJSON()</code> in the unusual
circumstance that <code>data</code> is an <code>R</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>as = "R"</code> argument to <code>j_query()</code>, <code>j_pivot()</code>, etc., and the
<code>as_r()</code> function transform a JSON string representation to an <em>R</em>
object. Main rules are:
</p>

<ul>
<li><p> JSON arrays of a single type (boolean, integer, double, string)
are transformed to <em>R</em> vectors of the same length and
corresponding type. A JSON scalar and a JSON vector of length 1
are represented in the same way in <em>R</em>.
</p>
</li>
<li><p> If a JSON 64-bit integer array contains a value larger than <em>R</em>'s
32-bit integer representation, the array is transformed to an <em>R</em>
numeric vector. NOTE that this results in loss of precision for
64-bit integer values greater than <code>2^53</code>.
</p>
</li>
<li><p> JSON arrays mixing integer and double values are transformed to
<em>R</em> numeric vectors.
</p>
</li>
<li><p> JSON objects are transformed to <em>R</em> named lists.
</p>
</li></ul>

<p>The vignette reiterates this information and provides additional
details.
</p>


<h3>Value</h3>

<p><code>as_r()</code> returns an <em>R</em> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## as_r()
as_r('[1, 2, 3]')       # JSON integer array -&gt; R integer vector
as_r('[1, 2.0, 3]')     # JSON intger and double array -&gt; R numeric vector
as_r('[1, 2.0, "3"]')   # JSON mixed array -&gt; R list
as_r('[1, 2147483648]') # JSON integer &gt; R integer max -&gt; R numeric vector

json &lt;- '{"b": 1, "a": ["c", "d"], "e": true, "f": [true], "g": {}}'
as_r(json) |&gt; str()     # parsing complex objects
identical(              # JSON scalar and length 1 array identical in R
    as_r('{"a": 1}'), as_r('{"a": [1]}')
)

</code></pre>

<hr>
<h2 id='j_data_type'>Detect JSON / NDJSON data and path types</h2><span id='topic+j_data_type'></span><span id='topic+j_path_type'></span>

<h3>Description</h3>

<p><code>j_data_type()</code> uses simple rules to determine whether
'data' is JSON, NDJSON, file, url, or R.
</p>
<p><code>j_path_type()</code> uses simple rules to identify
whether <code>path</code> is a JSONpointer, JSONpath, or JMESpath
expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_data_type(data)

j_path_type(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_data_type_+3A_data">data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td></tr>
<tr><td><code id="j_data_type_+3A_path">path</code></td>
<td>
<p>character(1) JSONpointer, JSONpath or JMESpath query
string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>j_data_type()</code> without any arguments reports possible return
values: <code>"json"</code>, <code>"ndjson"</code>, <code>"file"</code>, <code>"url"</code>, <code>"R"</code>.  When
provided an argument, <code>j_data_type()</code> infers (but does not
validate) the type of <code>data</code> based on the following rules:
</p>

<ul>
<li><p> For a scalar (length 1) character <code>data</code>, either <code>"url"</code>
(matching regular expression <code>"^https?://"</code>, <code>"file"</code>
(<code>file.exists(data)</code> returns <code>TRUE</code>), or <code>"json"</code>. When <code>"file"</code>
or <code>"url"</code> is inferred, the return value is a length 2 vector,
with the first element the inferred type of data (<code>"json"</code> or
<code>"ndjson"</code>) obtained from the first 2 lines of the file.
</p>
</li>
<li><p> For character data with <code>length(data) &gt; 1</code>, <code>"ndjson"</code> if all
elements start a square bracket or curly brace, consistently
(i.e., agreeing with the start of the first record), otherwise
<code>"json"</code>.
</p>
</li>
<li> <p><code>"R"</code> for all non-character data.
</p>
</li></ul>

<p><code>j_path_type()</code> without any argument reports possible values:
<code>"JSONpointer"</code>, <code>"JSONpath"</code>, or <code>"JMESpath"</code>. When provided an
argument, <code>j_path_type()</code> infers the type of <code>path</code> using a simple
but incomplete classification:
</p>

<ul>
<li> <p><code>"JSONpointer"</code> is inferred if the the path is <code>""</code> or starts with <code>"/"</code>.
</p>
</li>
<li> <p><code>"JSONpath"</code> expressions start with <code>"$"</code>.
</p>
</li>
<li> <p><code>"JMESpath"</code> expressions satisfy neither the <code>JSONpointer</code> nor
<code>JSONpath</code> criteria.
</p>
</li></ul>

<p>Because of these rules, the valid JSONpointer path <code>"@"</code> is
interpreted as JMESpath; use <code>jsonpointer()</code> if JSONpointer
behavior is required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>j_data_type()                            # available types
j_data_type("")                          # json
j_data_type('{"a": 1}')                  # json
j_data_type(c('[{"a": 1}', '{"a": 2}]')) # json
j_data_type(c('{"a": 1}', '{"a": 2}'))   # ndjson
j_data_type(list(a = 1, b = 2))          # R
fl &lt;- system.file(package = "rjsoncons", "extdata", "example.json")
j_data_type(fl)                          # c('json', 'file')
j_data_type(readLines(fl))               # json

j_path_type()                            # available types
j_path_type("")                          # JSONpointer
j_path_type("/locations/0/name")         # JSONpointer
j_path_type("$.locations[0].name")       # JSONpath
j_path_type("locations[0].name")         # JMESpath

</code></pre>

<hr>
<h2 id='j_query'>Query and pivot for JSON / NDJSON documents</h2><span id='topic+j_query'></span><span id='topic+j_pivot'></span>

<h3>Description</h3>

<p><code>j_query()</code> executes a query against a JSON or NDJSON
document, automatically inferring the type of <code>data</code> and
<code>path</code>.
</p>
<p><code>j_pivot()</code> transforms a JSON array-of-objects to an
object-of-arrays; this can be useful when forming a
column-based tibble from row-oriented JSON.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_query(
  data,
  path = "",
  object_names = "asis",
  as = "string",
  ...,
  data_type = j_data_type(data),
  path_type = j_path_type(path)
)

j_pivot(
  data,
  path = "",
  object_names = "asis",
  as = "string",
  ...,
  data_type = j_data_type(data),
  path_type = j_path_type(path)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_query_+3A_data">data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td></tr>
<tr><td><code id="j_query_+3A_path">path</code></td>
<td>
<p>character(1) JSONpointer, JSONpath or JMESpath query
string.</p>
</td></tr>
<tr><td><code id="j_query_+3A_object_names">object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td></tr>
<tr><td><code id="j_query_+3A_as">as</code></td>
<td>
<p>character(1) return type. For <code>j_query()</code>, <code>"string"</code>
returns JSON / NDJSON strings; <code>"R"</code> parses JSON / NDJSON to R
using rules in <code>as_r()</code>. For <code>j_pivot()</code> (JSON only), use <code>as = "data.frame"</code> or <code>as = "tibble"</code> to coerce the result to a
data.frame or tibble.</p>
</td></tr>
<tr><td><code id="j_query_+3A_...">...</code></td>
<td>
<p>arguments for parsing NDJSON, or passed to <code>jsonlite::toJSON</code> when
<code>data</code> is not character-valued. For NDJSON,
</p>

<ul>
<li><p> Use <code>n_records = 2</code> to parse just the first two records of the
NDJSON document.
</p>
</li>
<li><p> Use <code>verbose = TRUE</code> to obtain a progress bar when reading from a
connection (file or URL). Requires the cli package.
</p>
</li></ul>

<p>As an example for use with <code>jsonlite::toJSON()</code>
</p>

<ul>
<li><p> use <code>auto_unbox = TRUE</code> to automatically 'unbox' vectors of
length 1 to JSON scalar values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="j_query_+3A_data_type">data_type</code></td>
<td>
<p>character(1) type of <code>data</code>; one of <code>"json"</code>,
<code>"ndjson"</code>. Inferred from <code>data</code> using <code>j_data_type()</code>.</p>
</td></tr>
<tr><td><code id="j_query_+3A_path_type">path_type</code></td>
<td>
<p>character(1) type of <code>path</code>; one of
<code>"JSONpointer"</code>, <code>"JSONpath"</code>, <code>"JMESpath"</code>. Inferred from
<code>path</code> using <code>j_path_type()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>j_pivot()</code> transforms an 'array-of-objects' (typical when the JSON
is a row-oriented representation of a table) to an
'object-of-arrays'. A simple example transforms an array of two
objects each with three fields <code>'[{"a": 1, "b": 2, "c": 3}, {"a": 4, "b": 5, "c": 6}]'</code> to an object with three fields, each a vector
of length 2 <code>'{"a": [1, 4], "b": [2, 5], "c": [3, 6]}'</code>. The
object-of-arrays representation corresponds closely to an <em>R</em>
data.frame or tibble, as illustrated in the examples.
</p>
<p><code>j_pivot()</code> with JMESpath paths are especially useful for
transforming NDJSON to a <code>data.frame</code> or <code>tibble</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>json &lt;- '{
  "locations": [
    {"name": "Seattle", "state": "WA"},
    {"name": "New York", "state": "NY"},
    {"name": "Bellevue", "state": "WA"},
    {"name": "Olympia", "state": "WA"}
  ]
}'

j_query(json, "/locations/0/name")             # JSONpointer
j_query(json, "$.locations[*].name", as = "R") # JSONpath
j_query(json, "locations[].state", as = "R")   # JMESpath

## a few NDJSON records from &lt;https://www.gharchive.org/&gt;
ndjson_file &lt;-
    system.file(package = "rjsoncons", "extdata", "2023-02-08-0.json")
j_query(ndjson_file, "{id: id, type: type}")

j_pivot(json, "$.locations[?@.state=='WA']", as = "string")
j_pivot(json, "locations[?@.state=='WA']", as = "R")
j_pivot(json, "locations[?@.state=='WA']", as = "data.frame")
j_pivot(json, "locations[?@.state=='WA']", as = "tibble")

## use 'path' to pivot ndjson one record at at time
j_pivot(ndjson_file, "{id: id, type: type}", as = "data.frame")

## 'org' is a nested element; extract it
j_pivot(ndjson_file, "org", as = "data.frame")

## use j_pivot() to filter 'PushEvent' for organizations
path &lt;- "[{id: id, type: type, org: org}]
             [?@.type == 'PushEvent' &amp;&amp; @.org != null]"
j_pivot(ndjson_file, path, as = "data.frame")

## try also
##
##     j_pivot(ndjson_file, path, as = "tibble") |&gt;
##         tidyr::unnest_wider("org", names_sep = ".")
</code></pre>

<hr>
<h2 id='jsonpath'>JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON documents</h2><span id='topic+jsonpath'></span><span id='topic+jmespath'></span><span id='topic+jsonpointer'></span>

<h3>Description</h3>

<p><code>jsonpath()</code> executes a query against a JSON string or
vector NDJSON entries using the 'JSONpath' specification.
</p>
<p><code>jmespath()</code> executes a query against a JSON string
using the 'JMESpath' specification.
</p>
<p><code>jsonpointer()</code> extracts an element from a JSON string
using the 'JSON pointer' specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsonpath(data, path, object_names = "asis", as = "string", ...)

jmespath(data, path, object_names = "asis", as = "string", ...)

jsonpointer(data, path, object_names = "asis", as = "string", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jsonpath_+3A_data">data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td></tr>
<tr><td><code id="jsonpath_+3A_path">path</code></td>
<td>
<p>character(1) JSONpointer, JSONpath or JMESpath query
string.</p>
</td></tr>
<tr><td><code id="jsonpath_+3A_object_names">object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td></tr>
<tr><td><code id="jsonpath_+3A_as">as</code></td>
<td>
<p>character(1) return type. <code>"string"</code> returns a single
JSON string; <code>"R"</code> returns an <em>R</em> object following the rules
outlined for <code>as_r()</code>.</p>
</td></tr>
<tr><td><code id="jsonpath_+3A_...">...</code></td>
<td>
<p>arguments for parsing NDJSON, or passed to <code>jsonlite::toJSON</code> when
<code>data</code> is not character-valued. For NDJSON,
</p>

<ul>
<li><p> Use <code>n_records = 2</code> to parse just the first two records of the
NDJSON document.
</p>
</li>
<li><p> Use <code>verbose = TRUE</code> to obtain a progress bar when reading from a
connection (file or URL). Requires the cli package.
</p>
</li></ul>

<p>As an example for use with <code>jsonlite::toJSON()</code>
</p>

<ul>
<li><p> use <code>auto_unbox = TRUE</code> to automatically 'unbox' vectors of
length 1 to JSON scalar values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>jsonpath()</code>, <code>jmespath()</code> and <code>jsonpointer()</code> return a
character(1) JSON string (<code>as = "string"</code>, default) or <em>R</em>
object (<code>as = "R"</code>) representing the result of the query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>json &lt;- '{
  "locations": [
    {"name": "Seattle", "state": "WA"},
    {"name": "New York", "state": "NY"},
    {"name": "Bellevue", "state": "WA"},
    {"name": "Olympia", "state": "WA"}
  ]
 }'

## return a JSON string
jsonpath(json, "$..name") |&gt;
    cat("\n")

## return an R object
jsonpath(json, "$..name", as = "R")

## create a list with state and name as scalar vectors
lst &lt;- jsonlite::fromJSON(json, simplifyVector = FALSE)

## objects other than scalar character vectors are automatically
## coerced to JSON; use `auto_unbox = TRUE` to represent R scalar
## vectors in the object as JSON scalar vectors
jsonpath(lst, "$..name", auto_unbox = TRUE) |&gt;
    cat("\n")

## a scalar character vector like "Seattle" is not valid JSON...
try(jsonpath("Seattle", "$"))
## ...but a double-quoted string is
jsonpath('"Seattle"', "$")

## use I("Seattle") to coerce to a JSON object ["Seattle"]
jsonpath(I("Seattle"), "$[0]")      |&gt; cat("\n")

## different ordering of object names -- 'asis' (default) or 'sort'
json_obj &lt;- '{"b": "1", "a": "2"}'
jsonpath(json_obj, "$")           |&gt; cat("\n")
jsonpath(json_obj, "$.*")         |&gt; cat("\n")
jsonpath(json_obj, "$", "sort")   |&gt; cat("\n")
jsonpath(json_obj, "$.*", "sort") |&gt; cat("\n")

path &lt;- "locations[?state == 'WA'].name | sort(@)"
jmespath(json, path) |&gt;
    cat("\n")

## original filter always fails, e.g., '["WA"] != 'WA'
jmespath(lst, path)  # empty result set, '[]'

## filter with unboxed state, and return unboxed name
jmespath(lst, "locations[?state[0] == 'WA'].name[0] | sort(@)") |&gt;
    cat("\n")

## automatically unbox scalar values when creating the JSON string
jmespath(lst, path, auto_unbox = TRUE) |&gt;
    cat("\n")

## jsonpointer 0-based arrays
jsonpointer(json, "/locations/0/name")

## document root "", sort selected element keys
jsonpointer('{"b": 0, "a": 1}', "", "sort", as = "R") |&gt;
    str()

## 'Key not found' -- path '/' searches for a 0-length key
try(jsonpointer('{"b": 0, "a": 1}', "/"))

</code></pre>

<hr>
<h2 id='version'>Version of jsoncons C++ library</h2><span id='topic+version'></span>

<h3>Description</h3>

<p><code>version()</code> reports the version of the C++ jsoncons
library in use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version()
</code></pre>


<h3>Value</h3>

<p><code>version()</code> returns a character(1) major.minor.patch
version string .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>version()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
