<!DOCTYPE html><html lang="en"><head><title>Help for package magic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {magic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#magic-package'>
<p>Create and Investigate Magic Squares</p></a></li>
<li><a href='#adiag'><p>Binds arrays corner-to-corner</p></a></li>
<li><a href='#allsubhypercubes'><p>Subhypercubes of magic hypercubes</p></a></li>
<li><a href='#allsums'><p>Row, column, and two diagonal sums of arrays</p></a></li>
<li><a href='#apad'><p>Pad arrays</p></a></li>
<li><a href='#apl'><p>Replacements for APL functions take and drop</p></a></li>
<li><a href='#aplus'><p>Generalized array addition</p></a></li>
<li><a href='#arev'><p>Reverses some dimensions; a generalization of rev</p></a></li>
<li><a href='#arot'><p>Rotates an array about two specified dimensions</p></a></li>
<li><a href='#arow'><p>Generalized row and col</p></a></li>
<li><a href='#as.standard'><p>Standard form for magic squares</p></a></li>
<li><a href='#cilleruelo'>
<p>A class of multiplicative magic squares due to Cilleruelo and Luca</p></a></li>
<li><a href='#circulant'><p>Circulant matrices of any order</p></a></li>
<li><a href='#cube2'><p>A pantriagonal magic cube</p></a></li>
<li><a href='#diag.off'><p>Extracts broken diagonals</p></a></li>
<li><a href='#do.index'><p>Apply a function to array element indices</p></a></li>
<li><a href='#eq'><p>Comparison of two magic squares</p></a></li>
<li><a href='#fnsd'><p>First non-singleton dimension</p></a></li>
<li><a href='#force.integer'><p>Integerize array elements</p></a></li>
<li><a href='#Frankenstein'><p>A perfect magic cube due to Frankenstein</p></a></li>
<li><a href='#hadamard'><p>Hadamard matrices</p></a></li>
<li><a href='#hendricks'><p>A perfect magic cube due to Hendricks</p></a></li>
<li><a href='#hudson'><p>Pandiagonal magic squares due to Hudson</p></a></li>
<li><a href='#is.magic'><p>Various tests for the magicness of a square</p></a></li>
<li><a href='#is.magichypercube'><p>magic hypercubes</p></a></li>
<li><a href='#is.ok'><p>does a vector have the sum required to be a row or column of a</p>
magic square?</a></li>
<li><a href='#is.square.palindromic'><p>Is a square matrix square palindromic?</p></a></li>
<li><a href='#latin'><p>Random latin squares</p></a></li>
<li><a href='#lozenge'><p>Conway's lozenge algorithm for magic squares</p></a></li>
<li><a href='#magic'><p>Creates magic squares</p></a></li>
<li><a href='#magic.2np1'><p>Magic squares of odd order</p></a></li>
<li><a href='#magic.4n'><p>Magic squares of order 4n</p></a></li>
<li><a href='#magic.4np2'><p>Magic squares of order 4n+2</p></a></li>
<li><a href='#magic.8'><p>Regular magic squares of order 8</p></a></li>
<li><a href='#magic.constant'><p>Magic constant of a magic square or hypercube</p></a></li>
<li><a href='#magic.prime'><p>Magic squares prime order</p></a></li>
<li><a href='#magic.product'><p>Product of two magic squares</p></a></li>
<li><a href='#magiccube.2np1'><p>Magic cubes of order 2n+1</p></a></li>
<li><a href='#magiccubes'><p>Magic cubes of order 3</p></a></li>
<li><a href='#magichypercube.4n'><p>Magic hypercubes of order 4n</p></a></li>
<li><a href='#magicplot'><p>Joins consecutive numbers of a magic square.</p></a></li>
<li><a href='#minmax'><p>are all elements of a vector identical?</p></a></li>
<li><a href='#notmagic.2n'><p>An unmagic square</p></a></li>
<li><a href='#nqueens'><p>N queens problem</p></a></li>
<li><a href='#Ollerenshaw'><p>A most perfect square due to Ollerenshaw</p></a></li>
<li><a href='#panmagic.4'><p>Panmagic squares of order 4</p></a></li>
<li><a href='#panmagic.6npm1'><p>Panmagic squares of order 4n, 6n+1 and 6n-1</p></a></li>
<li><a href='#panmagic.8'><p>Panmagic squares of order 8</p></a></li>
<li><a href='#perfectcube5'><p>A perfect magic cube of order 5</p></a></li>
<li><a href='#perfectcube6'><p>A perfect cube of order 6</p></a></li>
<li><a href='#process'><p>Force index arrays into range</p></a></li>
<li><a href='#recurse'><p>Recursively apply a permutation</p></a></li>
<li><a href='#sam'><p>Sparse antimagic squares</p></a></li>
<li><a href='#shift'><p>Shift origin of arrays and vectors</p></a></li>
<li><a href='#strachey'><p>Strachey's algorithm for magic squares</p></a></li>
<li><a href='#subsums'><p>Sums of submatrices</p></a></li>
<li><a href='#transf'><p>Frenicle's equivalent magic squares</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.6-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Create and Investigate Magic Squares</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), abind</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions for the manipulation and
 analysis of arbitrarily dimensioned arrays.  The original motivation
 for the package was the development of efficient, vectorized
 algorithms for the creation and investigation of magic squares and
 high-dimensional magic hypercubes.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/magic">https://github.com/RobinHankin/magic</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/magic/issues">https://github.com/RobinHankin/magic/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-14 19:20:55 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-16 03:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='magic-package'>
Create and Investigate Magic Squares
</h2><span id='topic+magic-package'></span>

<h3>Description</h3>

<p>A collection of functions for the manipulation and
 analysis of arbitrarily dimensioned arrays.  The original motivation
 for the package was the development of efficient, vectorized
 algorithms for the creation and investigation of magic squares and
 high-dimensional magic hypercubes.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> magic</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.6-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Create and Investigate Magic Squares</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10), abind</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> A collection of functions for the manipulation and
 analysis of arbitrarily dimensioned arrays.  The original motivation
 for the package was the development of efficient, vectorized
 algorithms for the creation and investigation of magic squares and
 high-dimensional magic hypercubes.</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/magic</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/magic/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Frankenstein            A perfect magic cube due to Frankenstein
Ollerenshaw             A most perfect square due to Ollerenshaw
adiag                   Binds arrays corner-to-corner
allsubhypercubes        Subhypercubes of magic hypercubes
allsums                 Row, column, and two diagonal sums of arrays
apad                    Pad arrays
apl                     Replacements for APL functions take and drop
aplus                   Generalized array addition
arev                    Reverses some dimensions; a generalization of
                        rev
arot                    Rotates an array about two specified dimensions
arow                    Generalized row and col
as.standard             Standard form for magic squares
cilleruelo              A class of multiplicative magic squares due to
                        Cilleruelo and Luca
circulant               Circulant matrices of any order
cube2                   A pantriagonal magic cube
diag.off                Extracts broken diagonals
do.index                Apply a function to array element indices
eq                      Comparison of two magic squares
fnsd                    First non-singleton dimension
force.integer           Integerize array elements
hadamard                Hadamard matrices
hendricks               A perfect magic cube due to Hendricks
hudson                  Pandiagonal magic squares due to Hudson
is.magic                Various tests for the magicness of a square
is.magichypercube       magic hypercubes
is.ok                   does a vector have the sum required to be a row
                        or column of a magic square?
is.square.palindromic   Is a square matrix square palindromic?
latin                   Random latin squares
lozenge                 Conway's lozenge algorithm for magic squares
magic                   Creates magic squares
magic-package           Create and Investigate Magic Squares
magic.2np1              Magic squares of odd order
magic.4n                Magic squares of order 4n
magic.4np2              Magic squares of order 4n+2
magic.8                 Regular magic squares of order 8
magic.constant          Magic constant of a magic square or hypercube
magic.prime             Magic squares prime order
magic.product           Product of two magic squares
magiccube.2np1          Magic cubes of order 2n+1
magiccubes              Magic cubes of order 3
magichypercube.4n       Magic hypercubes of order 4n
magicplot               Joins consecutive numbers of a magic square.
minmax                  are all elements of a vector identical?
notmagic.2n             An unmagic square
nqueens                 N queens problem
panmagic.4              Panmagic squares of order 4
panmagic.6npm1          Panmagic squares of order 4n, 6n+1 and 6n-1
panmagic.8              Panmagic squares of order 8
perfectcube5            A perfect magic cube of order 5
perfectcube6            A perfect cube of order 6
process                 Force index arrays into range
recurse                 Recursively apply a permutation
sam                     Sparse antimagic squares
shift                   Shift origin of arrays and vectors
strachey                Strachey's algorithm for magic squares
subsums                 Sums of submatrices
transf                  Frenicle's equivalent magic squares
</pre>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p>   R. K. S. Hankin 2005.  &ldquo;Recreational mathematics with R:
introducing the <span class="pkg">magic</span> package&rdquo;.  R news, 5(1)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
magic(6)

magicplot(magic(8))

magichypercube.4n(1)

is.alicehypercube(magichypercube.4n(1,d=5),4,give.answers=TRUE)

</code></pre>

<hr>
<h2 id='adiag'>Binds arrays corner-to-corner</h2><span id='topic+adiag'></span>

<h3>Description</h3>

<p>Array generalization of <code>blockdiag()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adiag(... , pad=as.integer(0), do.dimnames=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adiag_+3A_...">...</code></td>
<td>
<p>Arrays to be binded together</p>
</td></tr>
<tr><td><code id="adiag_+3A_pad">pad</code></td>
<td>
<p>Value to pad array with; note default keeps integer status
of arrays</p>
</td></tr>
<tr><td><code id="adiag_+3A_do.dimnames">do.dimnames</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return
dimnames if possible.  Set to <code>FALSE</code> if performance is an
issue</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Binds any number of arrays together, corner-to-corner.  Because the
function is associative provided <code>pad</code> is of length 1, this page
discusses the two array case.
</p>
<p>Suppose <code>x &lt;- adiag(a,b)</code> and <code>dim(a)=c(a_1,...,a_d)</code>,
<code>dim(b)=c(b_1,...,b_d)</code>.  Then we have
<code>all(dim(x)==dim(a)+dim(b))</code>; and <code>x[1:a_1,...,1:a_d]==a</code> and
<code>x[(a_1+1):(a_1+b_1),...,(a_d+1):(a_d+b_d)]==b</code>.
</p>
<p>Dimnames are preserved, if both arrays have non-null dimnames, and
<code>do.dimnames</code> is <code>TRUE</code>.
</p>
<p>Argument <code>pad</code> is usually a length-one vector, but any vector is
acceptable; standard recycling is used.  Be aware that the output array
(of dimension <code>dim(a)+dim(b)</code>) is filled with (copies of)
<code>pad</code> <em>before</em> <code>a</code> and <code>b</code> are copied.  This can be
confusing.
</p>


<h3>Value</h3>

<p>Returns an array of dimensions <code>dim(a)+dim(b)</code> as described above.
</p>


<h3>Note</h3>

<p>In <code>adiag(a,b)</code>, if <code>a</code> is a length-one vector, it is coerced
to an array of dimensions <code>rep(1,length(dim(b)))</code>; likewise
<code>b</code>.  If both <code>a</code> and <code>b</code> are length-one vectors, return
<code>diag(c(a,b))</code>.
</p>
<p>If <code>a</code> and <code>b</code> are arrays, function <code>adiag()</code> requires
<code>length(dim(a))==length(dim(b))</code> (the function does not guess which
dimensions have been dropped; see examples section).  In particular,
note that vectors are not coerced except if of length one.
</p>
<p><code>adiag()</code> is used when padding magic hypercubes in the context
of evaluating subarray sums.
</p>


<h3>Author(s)</h3>

<p>Peter Wolf with some additions by Robin Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+subsums">subsums</a></code>, <code><a href="#topic+apad">apad</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> a &lt;- array( 1,c(2,2))
 b &lt;- array(-1,c(2,2))
 adiag(a,b)

 ## dropped dimensions can count:

 b2 &lt;- b1 &lt;- b
 dim(a) &lt;- c(2,1,2)
 dim(b1) &lt;- c(2,2,1)
 dim(b2) &lt;- c(1,2,2)

 dim(adiag(a,b1))
 dim(adiag(a,b2))

## dimnames are preserved if not null:

a &lt;- matrix(1,2,2,dimnames=list(col=c("red","blue"),size=c("big","small"))) 
b &lt;- 8
dim(b) &lt;- c(1,1)
dimnames(b) &lt;- list(col=c("green"),size=c("tiny"))
adiag(a,b)   #dimnames preserved
adiag(a,8)   #dimnames lost because second argument has none.

## non scalar values for pad can be confusing:
q &lt;- matrix(0,3,3)
adiag(q,q,pad=1:4)

## following example should make the pattern clear:
adiag(q,q,pad=1:36)


# Now, a use for arrays with dimensions of zero extent:
z &lt;- array(dim=c(0,3))
colnames(z) &lt;- c("foo","bar","baz")

adiag(a,z)        # Observe how this has
                  # added no (ie zero) rows to "a" but
                  # three extra columns filled with the pad value

adiag(a,t(z))
adiag(z,t(z))     # just the pad value

</code></pre>

<hr>
<h2 id='allsubhypercubes'>Subhypercubes of magic hypercubes</h2><span id='topic+allsubhypercubes'></span>

<h3>Description</h3>

<p>Extracts all subhypercubes from an n-dimensional hypercube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allsubhypercubes(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allsubhypercubes_+3A_a">a</code></td>
<td>
<p>The magic hypercube whose subhypercubes are computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, each element of which is a subhypercube of <code>a</code>.
Note that major diagonals are also returned (as n-by-1 arrays).
</p>
<p>The names of the list are the extracted subhypercubes.  Consider
<code>a &lt;- magichypercube.4n(1,d=4)</code> (so n=4) and if <code>jj &lt;-
  allsubhypercubes(a)</code>, consider <code>jj[9]</code>.  The name of
<code>jj[9]</code> is <code>"n-i+1,i,i,"</code>; its value is a square matrix.  The
columns of <code>jj[9]</code> may be recovered by <code>a[n-i+1,i,i,]</code>
with <code class="reqn">i=1\ldots n</code> (<strong>NB</strong>: that is,
jj[[9]] == <code>cbind(a[n-1+1,1,1,],
  a[n-2+1,2,2,], a[n-3+1,3,3,], a[n-4+1,4,4,])</code> where <code>n=4</code>).
</p>
<p>The list does not include the whole array.
</p>


<h3>Note</h3>

<p>This function is a dog's dinner.  It's complicated, convoluted,
and needs an absurd use of the <code>eval(parse(text=...))</code>
construction.  Basically it sucks big time.
</p>
<p>BUT... I cannot for the life of me see a better way that gives the
same results, without loops, on hypercubes of arbitrary dimension.
</p>
<p>On my 256MB Linuxbox, <code>allsubhypercubes()</code> cannot cope with
<code>d</code> as high as 5, for <code>n=4</code>.  Heigh ho.
</p>
<p>The term &ldquo;subhypercube&rdquo; does not include diagonally oriented
entities at <code>is.magichypercube</code>.  But it does here.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.perfect">is.perfect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- magichypercube.4n(1,d=4)
  allsubhypercubes(a)
</code></pre>

<hr>
<h2 id='allsums'>Row, column, and two diagonal sums of arrays</h2><span id='topic+allsums'></span>

<h3>Description</h3>

<p>Returns all rowsums, all columnsums, and all (broken) diagonal sums of
a putative magic square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allsums(m,func=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allsums_+3A_m">m</code></td>
<td>
<p>The square to be tested</p>
</td></tr>
<tr><td><code id="allsums_+3A_func">func</code></td>
<td>
<p>Function, with default <code>NULL</code> interpreted
as<code>sum()</code>, to be applied to the square rowwise, columnwise, and
diagonalwise</p>
</td></tr>
<tr><td><code id="allsums_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>func()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of four elements.  In the following, &ldquo;sums&rdquo;
means &ldquo;the result of applying func()&rdquo;.
</p>
<table role = "presentation">
<tr><td><code>rowsums</code></td>
<td>
<p>All <code class="reqn">n</code> row sums</p>
</td></tr>
<tr><td><code>colsums</code></td>
<td>
<p>All <code class="reqn">n</code> column sums</p>
</td></tr>
<tr><td><code>majors</code></td>
<td>
<p>All <code class="reqn">n</code> broken major diagonals (northwest-southeast).
First element is the long (unbroken) major diagonal, tested by
<code>is.magic()</code></p>
</td></tr>
<tr><td><code>minors</code></td>
<td>
<p>All <code class="reqn">n</code> broken minor diagonals (northeast-southwest).
First element is the long (unbroken) minor diagonal.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>func()</code> returns a vector, then the <code>allsums()</code> returns a
list whose columns are the result of applying <code>func()</code>.  See third
and fourth examples below.
</p>
<p>Used by <code>is.magic()</code> et seq.
</p>
<p>The major and minor diagonals would benefit from being recoded in C.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.magic">is.magic</a></code>,<code><a href="#topic+is.semimagic">is.semimagic</a></code>,<code><a href="#topic+is.panmagic">is.panmagic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>allsums(magic(7))
allsums(magic(7),func=max)

allsums(magic(7),func=range)
allsums(magic(7),func=function(x){x[1:2]})


allsums(magic(7),sort)
  # beware! compare apply(magic(7),1,sort) and apply(magic(7),2,sort)

</code></pre>

<hr>
<h2 id='apad'>Pad arrays</h2><span id='topic+apad'></span>

<h3>Description</h3>

<p>Generalized padding for arrays of arbitrary dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apad(a, l, e = NULL, method = "ext", post = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apad_+3A_a">a</code></td>
<td>
<p>Array to be padded</p>
</td></tr>
<tr><td><code id="apad_+3A_l">l</code></td>
<td>
<p>Amount of padding to add.  If a vector of length greater than
one, it is interpreted as
the extra extent of <code>a</code> along each of its dimensions (standard
recycling is used).  If of length one, interpret as the dimension to be
padded, in which case the amount is given by argument <code>l</code>.</p>
</td></tr>
<tr><td><code id="apad_+3A_e">e</code></td>
<td>
<p>If <code>l</code> is of length one, the  amount of padding to add to
dimension <code>l</code></p>
</td></tr>
<tr><td><code id="apad_+3A_method">method</code></td>
<td>
<p>String specifying the values of the padded elements.  See
details section.</p>
</td></tr>
<tr><td><code id="apad_+3A_post">post</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to append to
<code>a</code> and <code>FALSE</code> meaning to prepend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>method</code> specifies the values of the padded elements.
It can be either &ldquo;<code>ext</code>&rdquo;,
&ldquo;<code>mirror</code>&rdquo;, or &ldquo;<code>rep</code>&rdquo;.
</p>
<p>Specifying <code>ext</code> (the default) uses a padding value given by
the &ldquo;nearest&rdquo; element of <code>a</code>, as measured by the
Manhattan metric.
</p>
<p>Specifying <code>mirror</code> fills the array with alternate mirror
images of <code>a</code>; while <code>rep</code>  fills it with unreflected copies
of <code>a</code>.
</p>


<h3>Note</h3>

<p>Function <code>apad()</code> does not work with arrays with dimensions of
zero extent: what to pad it with?  To pad with a particular value, use
<code>adiag()</code>.
</p>
<p>The function works as expected with vectors, which are treated as
one-dimensional arrays.  See examples section.
</p>
<p>Function <code>apad()</code> is distinct from <code>adiag()</code>, which takes
two arrays and binds them together.  Both functions create an array of
the same dimensionality as their array arguments but with possibly
larger extents.  However, the functions differ in the values of the
new array elements. Function <code>adiag()</code> uses a second array;
function <code>apad()</code> takes the values from its primary array argument. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+adiag">adiag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
apad(1:10,4,method="mirror")


a &lt;- matrix(1:30,5,6)

apad(a,c(4,4))
apad(a,c(4,4),post=FALSE)

apad(a,1,5)

apad(a,c(5,6),method="mirror")
apad(a,c(5,6),method="mirror",post=FALSE)
</code></pre>

<hr>
<h2 id='apl'>Replacements for APL functions take and drop</h2><span id='topic+apl'></span><span id='topic+take'></span><span id='topic+apldrop'></span><span id='topic+apltake'></span><span id='topic+apldrop+3C-'></span><span id='topic+apltake+3C-'></span>

<h3>Description</h3>

<p>Replacements for APL functions take and drop
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apldrop(a, b, give.indices=FALSE)
apldrop(a, b) &lt;- value
apltake(a, b, give.indices=FALSE)
apltake(a, b) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apl_+3A_a">a</code></td>
<td>
<p>Array</p>
</td></tr>
<tr><td><code id="apl_+3A_b">b</code></td>
<td>
<p>Vector of number of indices to take/drop.  Length of <code>b</code>
should not exceed <code>length(dim(a))</code>; if it does, an error is
returned</p>
</td></tr> 
<tr><td><code id="apl_+3A_give.indices">give.indices</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
return the appropriate subset of array <code>a</code>, and <code>TRUE</code>
meaning to return the list of the selected elements in each of the
dimensions.  Setting to <code>TRUE</code> is not really intended for the
end-user, but is used in the code of <code>apltake&lt;-()</code> and
<code>apldrop&lt;-()</code></p>
</td></tr> 
<tr><td><code id="apl_+3A_value">value</code></td>
<td>
<p>elements to replace</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>apltake(a,b)</code> returns an array of the same dimensionality as
<code>a</code>.  Along dimension <code>i</code>, if <code>b[i]&gt;0</code>, the first
<code>b[i]</code> elements are retained; if <code>b[i]&lt;0</code>, the last
<code>b[i]</code> elements are retained.
</p>
<p><code>apldrop(a,b)</code> returns an array of the same dimensionality as 
<code>a</code>.  Along dimension <code>i</code>, if <code>b[i]&gt;0</code>, the first
<code>b[i]</code> elements are dropped if <code>b[i]&lt;0</code>, the last
<code>b[i]</code> elements are dropped.
</p>
<p>These functions do not drop singleton dimensions.  Use <code>drop()</code>
if this is desired.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- magichypercube.4n(m=1)
apltake(a,c(2,3,2))
apldrop(a,c(1,1,2))

b &lt;- matrix(1:30,5,6)
apldrop(b,c(1,-2)) &lt;- -1

b &lt;- matrix(1:110,10,11)
apltake(b,2) &lt;- -1
apldrop(b,c(5,-7)) &lt;- -2
b

</code></pre>

<hr>
<h2 id='aplus'>Generalized array addition</h2><span id='topic+aplus'></span>

<h3>Description</h3>

<p>Given two arrays <code>a</code> and <code>b</code> with
<code>length(dim(a))==length(dim(b))</code>, return a matrix with
dimensions <code>pmax(dim(a),dim(b))</code> where &ldquo;overlap&rdquo;
elements are <code>a+b</code>, and the other elements are either 0, a, or
b according to location.  See details section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aplus(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aplus_+3A_...">...</code></td>
<td>
<p>numeric or complex arrays</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes any number of arguments (the binary operation is
associative).
</p>
<p>The operation of <code>aplus()</code> is understandable by examining the
following <strong>pseudo</strong>code:
</p>

<ul>
<li> <p><code>outa &lt;- array(0,pmax(a,b))</code>
</p>
</li>
<li> <p><code>outb &lt;- array(0,pmax(a,b))</code>
</p>
</li>
<li> <p><code>outa[1:dim(a)] &lt;- a</code>
</p>
</li>
<li> <p><code>outb[1:dim(a)] &lt;- b</code>
</p>
</li>
<li> <p><code>return(outa+outb)</code>
</p>
</li></ul>

<p>See how <code>outa</code> and <code>outb</code> are the correct size and the
appropriate elements of each are populated with <code>a</code> and <code>b</code>
respectively.  Then the sum is returned.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+apad">apad</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
aplus(rbind(1:9),cbind(1:9))

a &lt;- matrix(1:8,2,4)
b &lt;- matrix(1:10,5,2)
aplus(a*100,b,b)



</code></pre>

<hr>
<h2 id='arev'>Reverses some dimensions; a generalization of rev</h2><span id='topic+arev'></span>

<h3>Description</h3>

<p>A multidimensional generalization of <code>rev()</code>: given an array
<code>a</code>, and a Boolean vector <code>swap</code>, return an array of the
same shape as <code>a</code> but with dimensions corresponding to <code>TRUE</code>
elements of <code>swap</code> reversed.  If <code>swap</code> is not Boolean, it is
interpreted as the dimensions along which to swap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arev(a, swap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arev_+3A_a">a</code></td>
<td>
<p>Array to be reversed</p>
</td></tr>
<tr><td><code id="arev_+3A_swap">swap</code></td>
<td>
<p>Vector of Boolean variables.  If <code>swap[i]</code> is
<code>TRUE</code>, then dimension <code>i</code> of array <code>a</code> is reversed.
If <code>swap</code> is of length one, recycle to <code>length(dim(a))</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>swap</code> is not Boolean, it is equivalent to <code>1:n %in%
  swap</code> (where <code>n</code> is the number of dimensions).  Thus multiple
entries are ignored, as are entries greater than <code>n</code>.
</p>
<p>If <code>a</code> is a vector, <code>rev(a)</code> is returned.
</p>
<p>Function <code>arev()</code> handles zero-extent dimensions as expected.
</p>
<p>Function <code>arev()</code> does not treat singleton dimensions specially,
and is thus different from Octave's <code>flipdim()</code>, which (if
supplied with no second argument) flips the first nonsingleton
dimension.  To reproduce this, use <code>arev(a,fnsd(a))</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ashift">ashift</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(1:42,6,7)
arev(a)  #Note swap defaults to TRUE

b &lt;- magichypercube.4n(1,d=4)
arev(b,c(TRUE,FALSE,TRUE,FALSE))
</code></pre>

<hr>
<h2 id='arot'>Rotates an array about two specified dimensions</h2><span id='topic+arot'></span>

<h3>Description</h3>

<p>Rotates an array about two specified dimensions by any number of 90
degree turns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arot(a, rights = 1,pair=1:2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arot_+3A_a">a</code></td>
<td>
<p>The array to be rotated</p>
</td></tr>
<tr><td><code id="arot_+3A_rights">rights</code></td>
<td>
<p>Integer; number of right angles to turn</p>
</td></tr>
<tr><td><code id="arot_+3A_pair">pair</code></td>
<td>
<p>A two-element vector containing the dimensions to rotate
with default meaning to rotate about the first two dimensions</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code>arot()</code> is not exactly equivalent to octave's
<code>rotdim()</code>; in <code>arot()</code> the order of the elements of
<code>pair</code> matters because the rotation is clockwise when viewed
in the <code>(pair[1],pair[2])</code> direction.  Compare octave's
<code>rotdim()</code> in which <code>pair</code> is replaced with
<code>sort(pair)</code>.
</p>
<p>Note also that the rotation is about the first two dimensions
specified by <code>pair</code> but if <code>pair</code> has more than two elements
then these dimensions are also permuted.
</p>
<p>Also note that function <code>arot()</code> does not treat singleton
dimensions specially.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+arev">arev</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(1:16,rep(2,4))
arot(a)
</code></pre>

<hr>
<h2 id='arow'>Generalized row and col</h2><span id='topic+arow'></span>

<h3>Description</h3>

<p>Given an array, returns an array of the same size whose elements
are sequentially numbered along the <code class="reqn">i^{\rm th}</code> dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arow(a, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arow_+3A_a">a</code></td>
<td>
<p>array to be converted</p>
</td></tr>
<tr><td><code id="arow_+3A_i">i</code></td>
<td>
<p>Number of the dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix with the same dimensions as <code>a</code>, with element 
<code class="reqn">\left(n_1,n_2,\ldots n_d\right)</code>
being <code class="reqn">n_i</code>.
</p>


<h3>Note</h3>

<p>This function is equivalent to, but faster than,
<code>function(a,i){do.index(a,function(x){x[i]})}</code>.  However, it is
much more complicated.
</p>
<p>The function is nominally the same as <code>slice.index()</code> but I have
not checked all the edge cases.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(0,c(3,3,2,2))
arow(a,2)
(arow(a,1)+arow(a,2)+arow(a,3)+arow(a,4))%%2

</code></pre>

<hr>
<h2 id='as.standard'>Standard form for magic squares</h2><span id='topic+as.standard'></span><span id='topic+is.standard'></span><span id='topic+is.standard.toroidal'></span>

<h3>Description</h3>

<p>Transforms a magic square or magic hypercube into
Frenicle's standard form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.standard(a, toroidal = FALSE, one_minus=FALSE)
is.standard(a, toroidal = FALSE, one_minus=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.standard_+3A_a">a</code></td>
<td>
<p>Magic square or hypercube (array) to be tested or
transformed</p>
</td></tr>
<tr><td><code id="as.standard_+3A_toroidal">toroidal</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to use
Frenicle's method, and <code>TRUE</code> meaning to use additional
transformations appropriate to toroidal connectivity</p>
</td></tr>
<tr><td><code id="as.standard_+3A_one_minus">one_minus</code></td>
<td>
<p>Boolean, with  <code>TRUE</code> meaning to use the
transformation <code class="reqn">x\longrightarrow n^2+1-x</code> if
appropriate, 
and default <code>FALSE</code> meaning not to use this</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a square, <code>as.standard()</code> transforms a magic square into
Frenicle's standard form.  The four numbers at each of
the four corners are determined.  First, the square is rotated so the
smallest of the four is at the upper left.  Then, element <code>[1,2]</code>
is compared with element<code>[2,1]</code> and, if it is larger, the transpose
is taken.
</p>
<p>Thus all eight rotated and transposed versions of a magic square have
the same standard form.
</p>
<p>The square returned by <code>magic()</code> is in standard form.
</p>
<p>For hypercubes, the algorithm is generalized.  First, the hypercube is
reflected so that <code>a[1,1,...,1,1]</code> is the smallest of the <code class="reqn">2^d</code>
corner elements (eg <code>a[1,n,1,...,1,1]</code>).
</p>
<p>Next, <code>aperm()</code> is called so that
</p>
<p><code>a[1,1,...,1,2] &lt; a[1,1,...,2,1] &lt; ... &lt; a[2,1,...,1,1]</code>.
</p>
<p>Note that the inequalities are strict as hypercubes are assumed to be
normal.  As of version 1.3-1, <code>as.standard()</code> will accept arrays of
any dimension (ie arrays <code>a</code> with <code>minmax(dim(a))==FALSE</code> will
be handled sensibly).
</p>
<p>An array with any dimension of extent zero is in standard form by
definition; dimensions of length one are dropped.
</p>
<p>If argument <code>toroidal</code> is <code>TRUE</code>, then the array <code>a</code> is
translated using <code>ashift()</code> so that <code>a[1,1,...,1] == min(a)</code>.
Such translations preserve the properties of semimagicness and
pandiagonalness (but not magicness or associativity).
</p>
<p>It is easier (for me at least) to visualise this by considering
two-dimensional arrays, tiling the plane with copies of <code>a</code>.
</p>
<p>Next, the array is shifted so that <code>a[2,1,1,...,1] &lt;
  a[dim(a)[1],1,1,...,1]</code> and <code>a[1,2,1,..,1] &lt;
  a[1,dim(a)[2],1,...,1]</code> and so on.
</p>
<p>Then <code>aperm()</code> is called as per the non-toroidal case above.
</p>
<p><code>is.standard()</code> returns <code>TRUE</code> if the magic square or
hypercube is in standard form.  <code>is.standard()</code> and
<code>as.standard()</code> check for neither magicness nor normality (use
<code><a href="#topic+is.magic">is.magic</a></code> and <code><a href="#topic+is.normal">is.normal</a></code> for this).
</p>


<h3>Note</h3>

<p>There does not appear to be a way to make the third letter of
&ldquo;Frenicle&rdquo; have an acute accent, as it should do.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic">magic</a></code>, <code><a href="#topic+eq">eq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>is.standard(magic.2np1(4))
as.standard(magic.4n(3))

as.standard(magichypercube.4n(1,5))

##non-square arrays:
as.standard(magic(7)[1:3,])


## Toroidal transforms preserve pandiagonalness:
is.pandiagonal(as.standard(hudson(11)))


## but not magicness:
is.magic(as.standard(magic(10),TRUE))


</code></pre>

<hr>
<h2 id='cilleruelo'>
A class of multiplicative magic squares due to Cilleruelo and Luca
</h2><span id='topic+cilleruelo'></span>

<h3>Description</h3>

<p>Cilleruelo and Luca give a class of multiplicative magic squares whose
behaviour is interesting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cilleruelo(n, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cilleruelo_+3A_n">n</code>, <code id="cilleruelo_+3A_m">m</code></td>
<td>
<p>Arguments: usually integers</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">
    \left(
    \begin{array}{cccc}
    (n+2)(m+0) &amp; (n+3)(m+3) &amp; (n+1)(m+2) &amp; (n+0)(m+1)\\
    (n+1)(m+1) &amp; (n+0)(m+2) &amp; (n+2)(m+3) &amp; (n+3)(m+0)\\
    (n+0)(m+3) &amp; (n+1)(m+0) &amp; (n+3)(m+1) &amp; (n+2)(m+2)\\
    (n+3)(m+2) &amp; (n+2)(m+1) &amp; (n+0)(m+0) &amp; (n+1)(m+3)
    \end{array}
    \right)
  </code>
</p>



<h3>Value</h3>

<p>Returns a <code class="reqn">4\times 4</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Javier Cilleruelo and Florian Luca 2010, &ldquo;On multiplicative
magic squares&rdquo;, <em>The Electronic Journal of Combinatorics</em> vol 17,
number 8
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.magic(cilleruelo(5,6))
is.magic(cilleruelo(5,6),func=prod)


f &lt;- function(n){
  jj &lt;-
    sapply(
           seq(from=5,len=n),
           function(i){cilleruelo(i,i-4)}
           )
  xM &lt;- apply(jj,2,max)
  xm &lt;- apply(jj,2,min)

  cbind(xM-xm , 5^(5/12)*xm^0.5 , 6*xm^0.5)
}
  
matplot(f(200),type='l',log='xy',xlab='n',ylab='')
legend(x="topleft",legend=c("xM-xm","5^(5/12).xm^(1/2)","6xm^(1/2)"),
       lty=1:3,col=1:3)



</code></pre>

<hr>
<h2 id='circulant'>Circulant matrices of any order</h2><span id='topic+circulant'></span><span id='topic+is.circulant'></span>

<h3>Description</h3>

<p>Creates and tests for circulant matrices of any order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circulant(vec,doseq=TRUE)
is.circulant(m,dir=rep(1,length(dim(m))))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circulant_+3A_vec">vec</code>, <code id="circulant_+3A_doseq">doseq</code></td>
<td>
<p>In <code>circulant()</code>, vector of elements of the first
row.  If <code>vec</code> is of length one, and <code>doseq</code> is
<code>TRUE</code>, then interpret <code>vec</code> as the order of the matrix
and return a circulant with first row <code>seq_len(vec)</code></p>
</td></tr>
<tr><td><code id="circulant_+3A_m">m</code></td>
<td>
<p>In <code>is.circulant()</code>, matrix to be tested for
circulantism</p>
</td></tr>
<tr><td><code id="circulant_+3A_dir">dir</code></td>
<td>
<p>In <code>is.circulant()</code>, the direction of the diagonal.
In a matrix, the default value (<code>c(1,1)</code>) traces the major
diagonals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A matrix <code class="reqn">a</code> is <dfn>circulant</dfn> if all major diagonals, including
broken diagonals, are uniform; ie if
<code class="reqn">a_{ij}=a_{kl}</code> when <code class="reqn">i-j=k-l</code> (modulo
<code class="reqn">n</code>).  The standard values to use give <code>1:n</code> for the top row.
</p>
<p>In function <code>is.circulant()</code>, for arbitrary dimensional arrays,
the default value for <code>dir</code> checks that
<code>a[v]==a[v+rep(1,d)]==...==a[v+rep((n-1),d)]</code> for all <code>v</code>
(that is, following lines parallel to the major diagonal); indices are
passed through <code>process()</code>.
</p>
<p>For general <code>dir</code>, function <code>is.circulant()</code> checks that
<code>a[v]==a[v+dir]==a[v+2*dir]==...==a[v+(n-1)*d]</code> for all
<code>v</code>.
</p>
<p>A <dfn>Toeplitz</dfn> matrix is one in which <code>a[i,j]=a[i',j']</code>
whenever <code>|i-j|=|i'-j'|</code>.  See function <code>toeplitz()</code> of the
<code>stats</code> package for details.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Arthur T. Benjamin and K. Yasuda.  <em>Magic
&ldquo;Squares&rdquo; Indeed!</em>, American Mathematical Monthly, vol
106(2), pp152-156, Feb 1999</p>


<h3>Examples</h3>

<pre><code class='language-R'>circulant(5)
circulant(2^(0:4))
is.circulant(circulant(5))

 a &lt;- outer(1:3,1:3,"+")%%3
 is.circulant(a)
 is.circulant(a,c(1,2))

 is.circulant(array(c(1:4,4:1),rep(2,3)))

 is.circulant(magic(5)%%5,c(1,-2))

</code></pre>

<hr>
<h2 id='cube2'>A pantriagonal magic cube</h2><span id='topic+cube2'></span>

<h3>Description</h3>

<p>A pantriagonal magic cube of order 4 originally due to Hendricks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cube2)</code></pre>


<h3>Details</h3>

<p>Meaning of &ldquo;pantriagonal&rdquo; currently unclear
</p>


<h3>Source</h3>

<p>Hendricks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cube2)
is.magichypercube(cube2)
is.perfect(cube2)
</code></pre>

<hr>
<h2 id='diag.off'>Extracts broken diagonals</h2><span id='topic+diag.off'></span>

<h3>Description</h3>

<p>Returns broken diagonals of a magic square
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag.off(a, offset = 0, nw.se = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diag.off_+3A_a">a</code></td>
<td>
<p>Square matrix</p>
</td></tr>
<tr><td><code id="diag.off_+3A_offset">offset</code></td>
<td>
<p>vertical offset</p>
</td></tr> 
<tr><td><code id="diag.off_+3A_nw.se">nw.se</code></td>
<td>
<p>Boolean variable with <code>TRUE</code> meaning trace diagonals
along the northwest-southeast direction (point <code>[1,n]</code>
to <code>[n,1]</code>).</p>
</td></tr>  </table>


<h3>Details</h3>

<p>Useful when testing for panmagic squares.  The first element is always
the unbroken one (ie <code>[1,1]</code> to <code>[n,n]</code> if <code>nw.se</code> is
<code>TRUE</code> and <code>[1,n]</code> to <code>[n,1]</code> if <code>nw.se</code> is
<code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.panmagic">is.panmagic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>diag.off(magic(10),nw.se=FALSE,offset=0)
diag.off(magic(10),nw.se=FALSE,offset=1)
</code></pre>

<hr>
<h2 id='do.index'>Apply a function to array element indices</h2><span id='topic+do.index'></span>

<h3>Description</h3>

<p>Given a function <code>f()</code> that takes a vector of indices, and an
array of arbitrary dimensions, apply <code>f()</code> to the elements of <code>a</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.index(a, f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do.index_+3A_a">a</code></td>
<td>
<p>Array</p>
</td></tr>
<tr><td><code id="do.index_+3A_f">f</code></td>
<td>
<p>Function that takes a vector argument of the same length as
<code>dim(a)</code></p>
</td></tr>
<tr><td><code id="do.index_+3A_...">...</code></td>
<td>
<p>Further arguments supplied to <code>f()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of the same dimensions as <code>a</code>
</p>


<h3>Note</h3>

<p>Tamas Papp suggests the one-liner
</p>
<p><code>
    function(a, f, ...){array(apply(as.matrix(expand.grid(lapply(dim(a),seq_len),KEEP.OUT.ATTRS=FALSE)),1,f,...),dim(a))}
  </code>
</p>
<p>which is functionally identical to <code>do.index()</code>; but
it is no faster than the version implemented in the package, and (IMO)
is harder to read.
</p>
<p>Further note that function <code>arow()</code> is much much faster than
<code>do.index()</code>; it is often possible to rephrase a call to
<code>do.index()</code> as a call to <code>arow()</code>; do this where possible
unless the additional code opacity outweighs the speed savings.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin, with improvements by  Gabor Grothendieck and
Martin Maechler, via the R help list</p>


<h3>See Also</h3>

<p><code><a href="#topic+arow">arow</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(0,c(2,3,4))
b &lt;- array(rpois(60,1),c(3,4,5))

f1 &lt;- function(x){sum(x)}
f2 &lt;- function(x){sum((x-1)^2)}
f3 &lt;- function(x){b[t(x)]}
f4 &lt;- function(x){sum(x)%%2}
f5 &lt;- function(x,u){x[u]}

do.index(a,f1)    # should match   arow(a,1)+arow(a,2)+arow(a,3)
do.index(a,f2)
do.index(a,f3)    # same as  apltake(b,dim(a))
do.index(a,f4)    # Male/female toilets at NOC
do.index(a,f5,2)  # same as  arow(a,2)
</code></pre>

<hr>
<h2 id='eq'>Comparison of two magic squares</h2><span id='topic+eq'></span><span id='topic+ne'></span><span id='topic+gt'></span><span id='topic+lt'></span><span id='topic+ge'></span><span id='topic+le'></span><span id='topic++25eq+25'></span><span id='topic++25ne+25'></span><span id='topic++25gt+25'></span><span id='topic++25lt+25'></span><span id='topic++25ge+25'></span><span id='topic++25le+25'></span>

<h3>Description</h3>

<p>Compares two magic squares according to Frenicle's method.
Mnemonic is the old Fortran &ldquo;.GT.&rdquo;  (for &ldquo;Greater Than&rdquo;)
comparison et seq.
</p>
<p>To compare magic square <code>a</code> with magic square <code>b</code>, their
elements are compared in rowwise order: <code>a[1,1]</code> is compared with
<code>b[1,1]</code>, then <code>a[1,2]</code> with <code>b[1,2]</code>, up to
<code>a[n,n]</code>.  Consider the first element that is different, say
<code>[i,j]</code>.  Then <code>a&lt;b</code> if <code>a[i,j]&lt;b[i,j]</code>.
</p>
<p>The generalization to hypercubes is straightforward: comparisons are
carried out natural order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eq(m1, m2)
ne(m1, m2)
gt(m1, m2)
lt(m1, m2)
ge(m1, m2)
le(m1, m2)
m1 %eq% m2
m1 %ne% m2
m1 %gt% m2
m1 %lt% m2
m1 %ge% m2
m1 %le% m2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eq_+3A_m1">m1</code></td>
<td>
<p>First magic square</p>
</td></tr>
<tr><td><code id="eq_+3A_m2">m2</code></td>
<td>
<p>Second magic square</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Rather clumsy function definition due to the degenerate case of 
testing two identical matrices (<code>min(NULL)</code> is undefined).
</p>
<p>The two arguments are assumed to be matrices of the same size.  If
not, an error is given.  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.standard">as.standard</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>magic(4) %eq% magic.4n(1)
eq(magic(4) , magic.4n(1))
</code></pre>

<hr>
<h2 id='fnsd'>First non-singleton dimension</h2><span id='topic+fnsd'></span>

<h3>Description</h3>

<p>Given an array, returns the first non-singleton dimension.  Useful for
emulating some of Matlab / Octave's multidimensional functions.
</p>
<p>If <code>n</code> is supplied, return the first <code>n</code> nonsingleton dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnsd(a,n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fnsd_+3A_a">a</code></td>
<td>
<p>An array</p>
</td></tr>
<tr><td><code id="fnsd_+3A_n">n</code></td>
<td>
<p>Integer.  Return the first <code>n</code> nonsingleton dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an integer vector with elements in the range <code>1</code> to
<code>length(dim(a))</code>.
</p>


<h3>Note</h3>

<p>Treats zero-extent dimensions as singletons.
</p>
<p>Case <code>n=0</code> now treated sensibly (returns a zero-length vector).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+arev">arev</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(1:24,c(1,1,1,1,2,1,3,4))
fnsd(a)
fnsd(a,2)
</code></pre>

<hr>
<h2 id='force.integer'>Integerize array elements</h2><span id='topic+force.integer'></span>

<h3>Description</h3>

<p>Returns an elementwise <code>as.integer</code>-ed array.  All magic squares
should have integer elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force.integer(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="force.integer_+3A_x">x</code></td>
<td>
<p>Array to be converted</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code>force.integer()</code> differs from <code>as.integer()</code> as
the latter returns an integer vector, and the former returns an array
whose elements are  integer versions of <code>x</code>; see examples section
below. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(rep(1,4),2,2)
force.integer(a)
as.integer(a)
</code></pre>

<hr>
<h2 id='Frankenstein'>A perfect magic cube due to Frankenstein</h2><span id='topic+Frankenstein'></span>

<h3>Description</h3>

<p>A perfect magic cube due to Frankenstein
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Frankenstein)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(Frankenstein)
is.perfect(Frankenstein)
</code></pre>

<hr>
<h2 id='hadamard'>Hadamard matrices</h2><span id='topic+hadamard'></span><span id='topic+is.hadamard'></span><span id='topic+sylvester'></span>

<h3>Description</h3>

<p>Various functionality for Hadamard matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sylvester(k)
is.hadamard(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hadamard_+3A_k">k</code></td>
<td>
<p>Function <code>sylvester()</code> gives the <code>k</code>-th Sylvester
matrix</p>
</td></tr> 
<tr><td><code id="hadamard_+3A_m">m</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>Hadamard matrix</dfn> is a square matrix whose entries are either +1
or -1 and whose rows are mutually orthogonal.  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>&ldquo;Hadamard matrix.&rdquo; <em>Wikipedia, The Free Encyclopedia.</em> 19 Jan 2009, 18:21 UTC. 20 Jan 2009 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.hadamard(sylvester(4))
image(sylvester(5))

</code></pre>

<hr>
<h2 id='hendricks'>A perfect magic cube due to Hendricks</h2><span id='topic+hendricks'></span>

<h3>Description</h3>

<p>A perfect <code class="reqn">8\times 8\times 8</code> magic cube due to Hendricks</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hendricks)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(hendricks)
is.perfect(hendricks)
</code></pre>

<hr>
<h2 id='hudson'>Pandiagonal magic squares due to Hudson</h2><span id='topic+hudson'></span>

<h3>Description</h3>

<p>Returns a regular pandiagonal magic square of order
<code class="reqn">6m\pm 1</code> using a method developed by Hudson.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hudson(n = NULL, a = NULL, b = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hudson_+3A_n">n</code></td>
<td>
<p>Order of the square, <code class="reqn">n=6m\pm 1</code>.  If
<code>NULL</code>, use the length of <code>a</code></p>
</td></tr>
<tr><td><code id="hudson_+3A_a">a</code></td>
<td>
<p>The first line of Hudson's <code class="reqn">A</code> matrix.  If
<code>NULL</code>, use Hudson's value of <code>c(n-1,0:(n-2))</code></p>
</td></tr>
<tr><td><code id="hudson_+3A_b">b</code></td>
<td>
<p>The first line of Hudson's <code class="reqn">B</code> matrix.  If
<code>NULL</code>, use Hudson's value of <code>c(2:(n-1),n,1)</code>.
Using default values for <code>a</code> and <code>b</code> gives an associative square
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns one member of a set of regular magic squares of order
<code class="reqn">n=6m\pm 1</code>.  The set is of size <code class="reqn">(n!)^2</code>.
</p>
<p>Note that <code>n</code> is not checked for being in the form <code class="reqn">6n\pm
    1</code>.  If it is not the correct form, the square is magic
but not necessarily normal.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>C. B. Hudson, <em>On pandiagonal squares of order 6t +/- 1</em>,
Mathematics Magazine, March 1972, pp94-96</p>


<h3>See Also</h3>

<p><code><a href="#topic+recurse">recurse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>hudson(n=11)
magicplot(hudson(n=11))
is.associative(hudson(n=13))
hudson(a=(2*1:13)%%13 ,  b=(8*1:13)%%13)
all(replicate(10,is.magic(hudson(a=sample(13),b=sample(13)))))
</code></pre>

<hr>
<h2 id='is.magic'>Various tests for the magicness of a square</h2><span id='topic+is.magic'></span><span id='topic+is.panmagic'></span><span id='topic+is.pandiagonal'></span><span id='topic+is.semimagic'></span><span id='topic+is.semimagic.default'></span><span id='topic+is.associative'></span><span id='topic+is.regular'></span><span id='topic+is.ultramagic'></span><span id='topic+is.normal'></span><span id='topic+is.sparse'></span><span id='topic+is.mostperfect'></span><span id='topic+is.2x2.correct'></span><span id='topic+is.bree.correct'></span><span id='topic+is.latin'></span><span id='topic+is.antimagic'></span><span id='topic+is.totally.antimagic'></span><span id='topic+is.heterosquare'></span><span id='topic+is.totally.heterosquare'></span><span id='topic+is.sam'></span><span id='topic+is.stam'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if the square is magic, semimagic, panmagic, associative,
normal.  If argument <code>give.answers</code> is <code>TRUE</code>, also returns
additional information about the sums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.magic(m, give.answers = FALSE, func=sum, boolean=FALSE) 
is.panmagic(m, give.answers = FALSE, func=sum, boolean=FALSE) 
is.pandiagonal(m, give.answers = FALSE, func=sum, boolean=FALSE) 
is.semimagic(m, give.answers = FALSE, func=sum, boolean=FALSE) 
is.semimagic.default(m)
is.associative(m)
is.normal(m)
is.sparse(m)
is.mostperfect(m,give.answers=FALSE)
is.2x2.correct(m,give.answers=FALSE)
is.bree.correct(m,give.answers=FALSE)
is.latin(m,give.answers=FALSE)
is.antimagic(m, give.answers = FALSE, func=sum) 
is.totally.antimagic(m, give.answers = FALSE, func=sum)
is.heterosquare(m, func=sum) 
is.totally.heterosquare(m, func=sum)
is.sam(m)
is.stam(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.magic_+3A_m">m</code></td>
<td>
<p>The square to be tested</p>
</td></tr>
<tr><td><code id="is.magic_+3A_give.answers">give.answers</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning return additional
information about the sums (see details)</p>
</td></tr>
<tr><td><code id="is.magic_+3A_func">func</code></td>
<td>
<p>A function that is evaluated for each row, column, and
unbroken diagonal</p>
</td></tr>
<tr><td><code id="is.magic_+3A_boolean">boolean</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning that the square is
deemed magic, semimagic, etc, if all applications of <code>func</code>
evaluate to <code>TRUE</code>.  If <code>boolean</code> is <code>FALSE</code>, square
<code>m</code> is magic etc if all applications of <code>func</code> are
identical</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> A <dfn>semimagic square</dfn> is one all of whose row sums equal
all its columnwise sums (ie the magic constant).
</p>
</li>
<li><p> A <dfn>magic square</dfn> is a semimagic square with the sum of
both unbroken diagonals equal to the magic constant.
</p>
</li>
<li><p> A <dfn>panmagic square</dfn> is a magic square all of whose broken
diagonals sum to the magic constant.  Ollerenshaw calls this a
&ldquo;pandiagonal&rdquo; square.
</p>
</li>
<li><p> A <dfn>most-perfect</dfn> square has all 2-by-2 arrays anywhere
within the square summing to <code class="reqn">2S</code> where <code class="reqn">S=n^2+1</code>; and all
pairs of integers <code class="reqn">n/2</code> distant along the same major (NW-SE)
diagonal sum to <code class="reqn">S</code> (note that the <code class="reqn">S</code> used here differs
from Ollerenshaw's because her squares are numbered starting at
zero).  The first condition is tested by <code>is.2x2.correct()</code> and
the second by <code>is.bree.correct()</code>.
</p>
<p>All most-perfect squares are panmagic.
</p>
</li>
<li><p> A <dfn>normal square</dfn> is one that contains <code class="reqn">n^2</code>
consecutive integers (typically starting at 0 or 1).
</p>
</li>
<li><p> A <dfn>sparse</dfn> matrix is one whose nonzero entries are
consecutive integers, starting at 1.
</p>
</li>
<li><p> An <dfn>associative square</dfn> (also <dfn>regular square</dfn>) is a magic square in which
<code class="reqn">a_{i,j}+a_{n+1-i,n+1-j}=n^2+1</code>.
Note that an associative semimagic square is magic; see also
<code>is.square.palindromic()</code>.  The definition extends to magic
hypercubes: a hypercube <code>a</code> is associative if <code>a+arev(a)</code>
is constant.
</p>
</li>
<li><p> An <dfn>ultramagic square</dfn> is pandiagonal and associative.
</p>
</li>
<li><p> A <dfn>latin square</dfn> of size <code class="reqn">n\times n</code> is one in
which each column and each row comprises the integers 1 to n (not
necessarily in that order).  Function <code>is.latin()</code> is a wrapper
for <code>is.latinhypercube()</code> because there is no natural way to
present the extra information given when <code>give.answers</code> is
<code>TRUE</code> in a manner consistent with the other functions
documented here.
</p>
</li>
<li><p> An <dfn>antimagic square</dfn> is one whose row sums and column
sums are consecutive integers; a <dfn>totally antimagic square</dfn> is
one whose row sums, column sums, and two unbroken diagonals are
consecutive integers.  Observe that an antimagic square is not
necessarily totally antimagic, and vice-versa.
</p>
</li>
<li><p> A <dfn>heterosquare</dfn> has all rowsums and column sums
distinct; a <dfn>totally heterosquare</dfn> [NB nonstandard terminology]
has all rowsums, columnsums, and two long diagonals distinct.
</p>
</li>
<li><p> A square is <dfn>sam</dfn> (or <dfn>SAM</dfn>) if it is sparse and
antimagic; it is  <dfn>stam</dfn> (or <dfn>STAM</dfn>) if it is sparse and
totally antimagic.  See documentation at <code>SAM</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns <code>TRUE</code> if the square is semimagic, etc. and <code>FALSE</code>
if not.
</p>
<p>If <code>give.answers</code> is taken as an argument and is <code>TRUE</code>,
return a list of at least five elements.  The first element of the
list is the answer: it is <code>TRUE</code> if the square is (semimagic,
magic, panmagic) and <code>FALSE</code> otherwise.  Elements 2-5 give the
result of a call to <code>allsums()</code>, viz: rowwise and columnwise
sums; and broken major (ie NW-SE) and minor (ie NE-SW) diagonal sums.
</p>
<p>Function <code>is.bree.correct()</code> also returns the sums of
elements distant <code class="reqn">n/2</code> along a major diagonal
(<code>diag.sums</code>); and function <code>is.2x2.correct()</code> returns the
sum of each <code class="reqn">2\times 2</code> submatrix (<code>tbt.sums</code>); for
other size windows use <code>subsums()</code> directly.
Function <code>is.mostperfect()</code> returns both of these.
</p>
<p>Function <code>is.semimagic.default()</code> returns <code>TRUE</code> if the
argument is semimagic [with respect to <code>sum()</code>] using a faster
method than <code>is.semimagic()</code>.
</p>


<h3>Note</h3>

<p>Functions that take a <code>func</code> argument apply that function to each
row, column, and diagonal as necessary.  If <code>func</code> takes its
default value of <code>sum()</code>, the sum will be returned; if
<code>prod()</code>, the product will be returned, and so on.  There are
many choices for this argument that produce interesting tests;
consider <code>func=max</code>, for example.  With this, a &ldquo;magic&rdquo;
square is one whose row, sum and (unbroken) diagonals have identical
maxima.  Thus <code>diag(5)</code> is magic with respect to <code>max()</code>,
but <code>diag(6)</code> isn't.
</p>
<p>Argument <code>boolean</code> is designed for use with non-default values
for the <code>func</code> argument; for example, a latin square is semimagic
with respect to <code>func=function(x){all(diff(sort(x))==1)}</code>.
</p>
<p>Function <code>is.magic()</code> is vectorized; if a list is supplied, the
defaults are assumed.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://mathworld.wolfram.com/MagicSquare.html">https://mathworld.wolfram.com/MagicSquare.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+minmax">minmax</a></code>,<code><a href="#topic+is.perfect">is.perfect</a></code>,<code><a href="#topic+is.semimagichypercube">is.semimagichypercube</a></code>,<code><a href="#topic+sam">sam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>is.magic(magic(4))

is.magic(diag(7),func=max)  # TRUE
is.magic(diag(8),func=max)  # FALSE

stopifnot(is.magic(magic(3:8)))

is.panmagic(panmagic.4())
is.panmagic(panmagic.8())

data(Ollerenshaw)
is.mostperfect(Ollerenshaw)

proper.magic &lt;- function(m){is.magic(m) &amp; is.normal(m)}
proper.magic(magic(20))
</code></pre>

<hr>
<h2 id='is.magichypercube'>magic hypercubes</h2><span id='topic+is.semimagichypercube'></span><span id='topic+is.magichypercube'></span><span id='topic+is.nasik'></span><span id='topic+is.alicehypercube'></span><span id='topic+is.perfect'></span><span id='topic+is.diagonally.correct'></span><span id='topic+is.latinhypercube'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if a hypercube is semimagic, magic, perfect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.semimagichypercube(a, give.answers=FALSE, func=sum, boolean=FALSE, ...)
is.diagonally.correct(a, give.answers = FALSE, func=sum, boolean=FALSE, ...) 
is.magichypercube(a, give.answers = FALSE, func=sum, boolean=FALSE, ...) 
is.perfect(a, give.answers = FALSE, func=sum, boolean=FALSE)
is.latinhypercube(a, give.answers=FALSE)
is.alicehypercube(a,ndim,give.answers=FALSE, func=sum, boolean=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.magichypercube_+3A_a">a</code></td>
<td>
<p>The hypercube (array) to be tested</p>
</td></tr>
<tr><td><code id="is.magichypercube_+3A_give.answers">give.answers</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to also return
the sums</p>
</td></tr>
<tr><td><code id="is.magichypercube_+3A_func">func</code></td>
<td>
<p>Function to be applied across each dimension</p>
</td></tr>
<tr><td><code id="is.magichypercube_+3A_ndim">ndim</code></td>
<td>
<p>In <code>is.alicehypercube()</code>, dimensionality of
subhypercube to take sums over.  See the details section</p>
</td></tr>
<tr><td><code id="is.magichypercube_+3A_boolean">boolean</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning that the hypercube is
deemed magic, semimagic, etc, if all applications of <code>func</code>
evaluate to <code>TRUE</code>.  If <code>boolean</code> is <code>FALSE</code>, the
hypercube is magic etc if all applications of <code>func</code> are
identical</p>
</td></tr>
<tr><td><code id="is.magichypercube_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>func()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>(Although apparently non-standard, here a hypercube is defined to have
dimension <code class="reqn">d</code> and order <code class="reqn">n</code>&mdash;and thus has <code class="reqn">n^d</code>
elements).
</p>

<ul>
<li><p> A <dfn>semimagic hypercube</dfn> has all &ldquo;rook's move&rdquo; sums
equal to the magic constant (that is, each <code class="reqn">\sum
    a[i_1,i_2,\ldots,i_{r-1},,i_{r+1}, \ldots,i_d]</code> with <code class="reqn">1\leq r\leq d</code> is equal to the magic constant for all values of the
<code class="reqn">i</code>'s).  In <code>is.semimagichypercube()</code>, if
<code>give.answers</code> is <code>TRUE</code>, the sums returned are in the
form of an array of dimension <code>c(rep(n,d-1),d)</code>.  The first
<code>d-1</code> dimensions are the coordinates of the projection of the
summed elements onto the surface hypercube.  The last dimension
indicates the dimension along which the sum was taken over.
</p>
<p>Optional argument <code>func</code>, defaulting to <code>sum()</code>, indicates
the function to be taken over each of the <code>d</code> dimensions.
Currently requires <code>func</code> to return a scalar.
</p>
</li>
<li><p> A <dfn>Latin hypercube</dfn> is one in which each line of elements
whose coordinates differ in only one dimension comprises the numbers
<code class="reqn">1</code> to <code class="reqn">n</code> (or <code class="reqn">0</code> to <code class="reqn">n-1</code>), not necessarily in
that order.  Each integer thus appears <code class="reqn">n^{d-1}</code> times.
</p>
</li>
<li><p> A <dfn>magic hypercube</dfn> is a semimagic hypercube with the
additional requirement that all <code class="reqn">2^{d-1}</code> long (ie
extreme point-to-extreme point) diagonals sum correctly.  Correct
diagonal summation is tested by <code>is.diagonally.correct()</code>; by
specifying a function other than <code>sum()</code>, criteria other than
the diagonals returning the correct sum may be tested.
</p>
</li>
<li><p> An <dfn>Alice hypercube</dfn> is a different generalization of a
semimagic square to higher dimensions.  It is named for A. M. Hankin
(&ldquo;Alice&rdquo;), who originally suggested it.
</p>
<p>A semimagic hypercube has all one-dimensional subhypercubes (ie
lines) summing correctly.  An Alice hypercube is one in which all
<code>ndim</code>-dimensional subhypercubes have the same sum, where
<code>ndim</code> is a fixed integer argument.  Thus, if <code>a</code> is a
hypercube of size <code class="reqn">n^d</code>, <code>is.alicehypercube(a,ndim)</code>
returns <code>TRUE</code> if all <code>n^{d-ndim}</code> subhypercubes have the
same sum.
</p>
<p>For example, if <code>a</code> is four-dimensional with dimension
<code class="reqn">5\times 5\times 5\times 5</code> then
<code>is.alicehypercube(a,1)</code> is <code>TRUE</code> if and only if <code>a</code>
is a semimagic hypercube: all <code class="reqn">{4\choose 1}5^3=500</code>
one-dimensional subhypercubes have the same sum.  Then
<code>is.alicehypercube(a,2)</code> is <code>TRUE</code> if all 2-dimensional
subhypercubes (ie all <code class="reqn">{4\choose 2}\times 5^2=150</code> of
the <code class="reqn">5\times 5</code> squares, for example <code>a[,2,4,]</code> and
<code>a[1,1,,]</code>) have the same sum.  Then
<code>is.alicehypercube(a,3)</code> means that all 3d subhypercubes (ie
all <code class="reqn">{4\choose 3}\times 5^1=20</code> of the <code class="reqn">5\times
    5\times 5</code> cubes, for example <code>a[,,1,]</code> and
<code>a[4,,,]</code>) have the same sum.  For any hypercube <code>a</code>,
<code>is.alicehypercube(a,dim(a))</code> returns <code>TRUE</code>.
</p>
<p>A semimagic hypercube is an Alice hypercube for any value of
<code>ndim</code>.
</p>
</li>
<li><p> A <dfn>perfect magic hypercube</dfn> (use <code>is.perfect()</code>) is
a magic hypercube with all nonbroken diagonals summing correctly.
This is a seriously restrictive requirement for high dimensional
hypercubes.  As yet, this function does not take a
<code>give.answers</code> argument.
</p>
</li>
<li><p> A <dfn>pandiagonal magic hypercube</dfn>, also <dfn>Nasik
hypercube</dfn> (or sometimes just a <dfn>perfect hypercube</dfn>) is a
semimagic hypercube with all diagonals, including broken diagonals,
summing correctly.  This is not implemented.  </p>
</li></ul>

<p>The terminology in this area is pretty confusing.  
</p>
<p>In <code>is.magichypercube()</code>, if argument <code>give.answers=TRUE</code>
then a list is returned.  The first element of this list is Boolean
with <code>TRUE</code> if the array is a magic hypercube.  The second
element and third elements are answers
from<code>is.semimagichypercube()</code> and <code>is.diagonally.correct()</code>
respectively.
</p>
<p>In <code>is.diagonally.correct()</code>, if argument
<code>give.answers=TRUE</code>, the function also returns an array of
dimension <code>c(q,rep(2,d))</code> (that is, <code class="reqn">q\times 2^d</code>
elements), where <code class="reqn">q</code> is the length of <code>func()</code> applied to a
long diagonal of <code>a</code> (if <code class="reqn">q=1</code>, the first dimension is
dropped).  If <code class="reqn">q=1</code>, then in dimension <code>d</code> having index 1
means <code>func()</code> is applied to elements of <code>a</code> with the
<code class="reqn">d^{\rm th}</code> dimension running over <code>1:n</code>; index 2
means to run over <code>n:1</code>.  If <code class="reqn">q&gt;1</code>, the index of the first
dimension gives the index of <code>func()</code>, and subsequent dimensions
have indices of 1 or 2 as above and are interpreted in the same way.
</p>
<p>An example of a function for which these two are not identical is
given below.
</p>
<p>If <code>func=f</code> where <code>f</code> is a function returning a vector of
length <code>i</code>, <code>is.diagonally.correct()</code> returns an array
<code>out</code> of dimension <code>c(i,rep(2,d))</code>, with
<code>out[,i_1,i_2,...,i_d]</code> being <code>f(x)</code> where <code>x</code> is the
appropriate long diagonal.  Thus the <code class="reqn">2^d</code> equalities
<code>out[,i_1,i_2,...,i_d]==out[,3-i_1,3-i_2,...,3-i_d]</code> hold if and
only if <code>identical(f(x),f(rev(x)))</code> is <code>TRUE</code> for each long
diagonal (a condition met, for example, by <code>sum()</code> but not by the
identity function or <code>function(x){x[1]}</code>).
</p>


<h3>Note</h3>

<p>On this page, &ldquo;subhypercube&rdquo; is restricted to
rectangularly-oriented subarrays; see the note at <code>subhypercubes</code>.
</p>
<p>Not all subhypercubes of a magic hypercube are necessarily magic! (for
example, consider a 5-dimensional magic hypercube <code>a</code>.  The square
<code>b</code> defined by <code>a[1,1,1,,]</code> might not be magic: the diagonals
of <code>b</code> are not covered by the definition of a magic hypercube).
Some subhypercubes of a magic hypercube are not even semimagic: see
below for an example.
</p>
<p>Even in three dimensions, being perfect is pretty bad.  Consider a
<code class="reqn">5\times5\times 5</code> (ie three dimensional), cube.  Say
<code>a=magiccube.2np1(2)</code>.  Then the square defined by
<code>sapply(1:n,function(i){a[,i,6-i]}, simplify=TRUE)</code>, which is a
subhypercube of <code>a</code>, is not even semimagic: the rowsums are
incorrect (the colsums must sum correctly because <code>a</code> is magic).
Note that the diagonals of this square are two of the &ldquo;extreme
point-to-point&rdquo; diagonals of <code>a</code>.
</p>
<p>A <dfn>pandiagonal magic hypercube</dfn> (or sometimes just a <dfn>perfect
hypercube</dfn>) is semimagic and in addition the sums of all diagonals,
including broken diagonals, are correct.  This is one seriously bad-ass
requirement.  I reckon that is a total of <code class="reqn">\frac{1}{2}\left(
3^d-1\right)\cdot n^{d-1}</code> correct summations.  This
is not coded up yet; I can't see how to do it in anything like a
vectorized manner.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>R. K. S. Hankin 2005.  &ldquo;Recreational mathematics with R:
introducing the <span class="pkg">magic</span> package&rdquo;.  R news, 5(1)
</p>
</li>
<li>
<p>Richards 1980. &ldquo;Generalized magic cubes&rdquo;.
<em>Mathematics Magazine</em>, volume 53, number 2, (March).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+is.magic">is.magic</a></code>, <code><a href="#topic+allsubhypercubes">allsubhypercubes</a></code>, <code><a href="#topic+hendricks">hendricks</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(abind)
is.semimagichypercube(magiccube.2np1(1))
is.semimagichypercube(magichypercube.4n(1,d=4))

is.perfect(magichypercube.4n(1,d=4))

# Now try an array with minmax(dim(a))==FALSE:
a &lt;- abind(magiccube.2np1(1),magiccube.2np1(1),along=2)
is.semimagichypercube(a,g=TRUE)$rook.sums

# is.semimagichypercube() takes further arguments:
mymax &lt;- function(x,UP){max(c(x,UP))}
not_mag  &lt;- array(1:81,rep(3,4))
is.semimagichypercube(not_mag,func=mymax,UP=80)  # FALSE
is.semimagichypercube(not_mag,func=mymax,UP=81)  # TRUE


a2 &lt;- magichypercube.4n(m=1,d=4)
is.diagonally.correct(a2)
is.diagonally.correct(a2,g=TRUE)$diag.sums

## To extract corner elements (note func(1:n) != func(n:1)):
is.diagonally.correct(a2,func=function(x){x[1]},g=TRUE)$diag.sums 


#Now for a subhypercube of a magic hypercube that is not semimagic:
is.magic(allsubhypercubes(magiccube.2np1(1))[[10]])

data(hendricks)
is.perfect(hendricks)


#note that Hendricks's magic cube also has many broken diagonals summing
#correctly:

a &lt;- allsubhypercubes(hendricks)
ld &lt;- function(a){length(dim(a))}

jj &lt;- unlist(lapply(a,ld))
f &lt;- function(i){is.perfect(a[[which(jj==2)[i]]])}
all(sapply(1:sum(jj==2),f))

#but this is NOT enough to ensure that it is pandiagonal (but I
#think hendricks is pandiagonal).


is.alicehypercube(magichypercube.4n(1,d=5),4,give.answers=TRUE)

</code></pre>

<hr>
<h2 id='is.ok'>does a vector have the sum required to be a row or column of a
magic square?</h2><span id='topic+is.ok'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if and only if <code>sum(vec)==magic.constant(n,d=d))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ok(vec, n=length(vec), d=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.ok_+3A_vec">vec</code></td>
<td>
<p>Vector to be tested</p>
</td></tr>
<tr><td><code id="is.ok_+3A_n">n</code></td>
<td>
<p>Order of square or hypercube.  Default assumes order is equal
to length of <code>vec</code></p>
</td></tr>
<tr><td><code id="is.ok_+3A_d">d</code></td>
<td>
<p>Dimension of square or hypercube.  Default of 2 corresponds to a square</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'> is.ok(magic(5)[1,])

</code></pre>

<hr>
<h2 id='is.square.palindromic'>Is a square matrix square palindromic?</h2><span id='topic+is.square.palindromic'></span><span id='topic+is.centrosymmetric'></span><span id='topic+is.persymmetric'></span>

<h3>Description</h3>

<p>Implementation of various properties presented in a paper by Arthur
T. Benjamin and K. Yasuda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.square.palindromic(m, base=10, give.answers=FALSE)
is.centrosymmetric(m)
is.persymmetric(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.square.palindromic_+3A_m">m</code></td>
<td>
<p>The square to be tested</p>
</td></tr>
<tr><td><code id="is.square.palindromic_+3A_base">base</code></td>
<td>
<p>Base of number expansion, defaulting to 10; not relevant
for the &ldquo;sufficient&rdquo; part of the test</p>
</td></tr>
<tr><td><code id="is.square.palindromic_+3A_give.answers">give.answers</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return
additional information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following tests apply to a general square matrix <code>m</code> of size
<code class="reqn">n\times n</code>.
</p>

<ul>
<li><p> A <dfn>centrosymmetric</dfn> square is one in which
<code>a[i,j]=a[n+1-i,n+1-j]</code>; use <code>is.centrosymmetric()</code> to test
for this (compare an <em>associative</em> square).  Note that this
definition extends naturally to hypercubes: a hypercube <code>a</code> is
centrosymmetric if <code>all(a==arev(a))</code>.
</p>
</li>
<li><p> A <dfn>persymmetric square</dfn> is one in which
<code>a[i,j]=a[n+1-j,n+1-i]</code>; use <code>is.persymmetric()</code> to test for
this.
</p>
</li>
<li><p> A matrix is <dfn>square palindromic</dfn> if it satisfies the rather
complicated conditions set out by Benjamin and Yasuda (see refs).
</p>
</li></ul>



<h3>Value</h3>

<p>These functions return a list of Boolean variables whose value depends
on whether or not <code>m</code> has the property in question.
</p>
<p>If argument <code>give.answers</code> takes the default value of
<code>FALSE</code>, a Boolean value is returned that shows whether the
sufficient conditions are met.
</p>
<p>If argument <code>give.answers</code> is <code>TRUE</code>, a detailed list is
given that shows the status of each individual test, both for the
necessary and sufficient conditions.  The value of the second element
(named <code>necessary</code>) is the status of their Theorem 1 on page 154.
</p>
<p>Note that the necessary conditions do not depend on the base <code>b</code>
(technically, neither do the sufficient conditions, for being a square
palindrome requires the sums to match for <em>every</em> base <code>b</code>.
In this implementation, &ldquo;sufficient&rdquo; is defined only with
respect to a particular base).
</p>


<h3>Note</h3>

<p>Every associative square is square palindromic, according to Benjamin
and Yasuda.
</p>
<p>Function <code>is.square.palindromic()</code> does not yet take a
<code>give.answers</code> argument as does, say, <code>is.magic()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Arthur T. Benjamin and K. Yasuda.  <em>Magic
&ldquo;Squares&rdquo; Indeed!</em>, American Mathematical Monthly, vol
106(2), pp152-156, Feb 1999</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.square.palindromic(magic(3))
is.persymmetric(matrix(c(1,0,0,1),2,2))

#now try a circulant:
a &lt;- matrix(0,5,5)
is.square.palindromic(circulant(10))  #should be TRUE
</code></pre>

<hr>
<h2 id='latin'>Random latin squares</h2><span id='topic+latin'></span><span id='topic+incidence'></span><span id='topic+is.incidence'></span><span id='topic+is.incidence.improper'></span><span id='topic+unincidence'></span><span id='topic+inc_to_inc'></span><span id='topic+another_latin'></span><span id='topic+another_incidence'></span><span id='topic+rlatin'></span>

<h3>Description</h3>

<p>Various functionality for generating random latin squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence(a)
is.incidence(a, include.improper)
is.incidence.improper(a)
unincidence(a)
inc_to_inc(a)
another_latin(a)
another_incidence(i)
rlatin(n,size=NULL,start=NULL,burnin=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latin_+3A_a">a</code></td>
<td>
<p>A latin square</p>
</td></tr>
<tr><td><code id="latin_+3A_i">i</code></td>
<td>
<p>An incidence array</p>
</td></tr>
<tr><td><code id="latin_+3A_n">n</code>, <code id="latin_+3A_include.improper">include.improper</code>, <code id="latin_+3A_size">size</code>, <code id="latin_+3A_start">start</code>, <code id="latin_+3A_burnin">burnin</code></td>
<td>
<p>Various control arguments;
see details section</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Function <code>incidence()</code> takes an integer array
(specifically, a latin square) and returns the incidence array as
per Jacobson and Matthew 1996
</p>
</li>
<li><p> Function <code>is.incidence()</code> tests for an array being an
incidence array; if argument <code>include.improper</code> is <code>TRUE</code>,
admit an improper array
</p>
</li>
<li><p> Function <code>is.incidence.improper()</code> tests for an array
being an improper array
</p>
</li>
<li><p> Function <code>unincidence()</code> converts an incidence array to a
latin square
</p>
</li>
<li><p> Function <code>another_latin()</code> takes a latin square and
returns a different latin square
</p>
</li>
<li><p> Function <code>another_incidence()</code> takes an incidence array
and returns a different incidence array
</p>
</li>
<li><p> Function <code>rlatin()</code> generates a (Markov) sequence of
random latin squres, arranged in a 3D array.  Argument <code>n</code>
specifies how many to generate; argument <code>size</code> gives the size
of latin squares generated; argument <code>start</code> gives the start
latin square (it must be latin and is checked with
<code>is.latin()</code>); argument <code>burnin</code> gives the burn-in value
(number of Markov steps to discard).
</p>
<p>Default value of <code>NULL</code> for argument <code>size</code> means to take
the size of argument <code>start</code>; default value of <code>NULL</code> for
argument <code>start</code> means to use <code>circulant(size)</code>
</p>
<p>As a special case, if argument <code>size</code> and <code>start</code> both
take the default value of <code>NULL</code>, then argument <code>n</code> is
interpreted as the size of a single random latin square to be
returned; the other arguments take their default values.  This
ensures that &ldquo;<code>rlatin(n)</code>&rdquo; returns a single random
<code class="reqn">n\times n</code> latin square.
</p>
</li></ul>

<p>From Jacobson and Matthew 1996, an <code class="reqn">n\times n</code> latin square
LS is equivalent to an <code class="reqn">n\times n\times n</code> array A with
entries 0 or 1; the dimensions of A are identified with the rows,
columns and symbols of LS; a 1 appears in cell <code class="reqn">(r,c,s)</code> of A iffi
the symbol <code class="reqn">s</code> appears in row <code class="reqn">r</code>, column <code class="reqn">s</code> of LS.
Jacobson and Matthew call this an <dfn>incidence cube</dfn>.
</p>
<p>The notation is readily generalized to latin hypercubes and
<code>incidence()</code> is dimensionally vectorized.
</p>
<p>An <dfn>improper</dfn> incidence cube is an incidence cube that includes a
single <code class="reqn">-1</code> entry; all other entries must be 0 or 1; and all line
sums must equal 1.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. T. Jacobson and P. Matthews 1996. &ldquo;Generating
uniformly distributed random latin squares&rdquo;.  <em>Journal of
Combinatorial Designs</em>, volume 4, No. 6, pp405&ndash;437
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.magic">is.magic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rlatin(5)
rlatin(n=2, size=4, burnin=10)

# An example that allows one to optimize an objective function
# [here f()] over latin squares:
gr &lt;- function(x){ another_latin(matrix(x,7,7)) }
set.seed(0)
index &lt;- sample(49,20)
f &lt;- function(x){ sum(x[index])}
jj &lt;- optim(par=as.vector(latin(7)), fn=f, gr=gr, method="SANN", control=list(maxit=10))
best_latin &lt;- matrix(jj$par,7,7)
print(best_latin)
print(f(best_latin))

#compare starting value:
f(circulant(7))


</code></pre>

<hr>
<h2 id='lozenge'>Conway's lozenge algorithm for magic squares</h2><span id='topic+lozenge'></span>

<h3>Description</h3>

<p>Uses John Conway's lozenge algorithm to produce magic squares of
odd order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lozenge(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lozenge_+3A_m">m</code></td>
<td>
<p>magic square returned is of order <code>n=2m+1</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic.4np2">magic.4np2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lozenge(4)
all(sapply(1:10,function(n){is.magic(lozenge(n))}))
</code></pre>

<hr>
<h2 id='magic'>Creates magic squares</h2><span id='topic+magic'></span>

<h3>Description</h3>

<p>Creates normal magic squares of any order <code class="reqn">&gt;2</code>.  Uses
the appropriate method depending on n modulo 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magic_+3A_n">n</code></td>
<td>
<p>Order of magic square.  If a vector, return a list whose
<code class="reqn">i</code>-th element is a magic square of order <code>n[i]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls either <code>magic.2np1()</code>, <code>magic.4n()</code>,
or <code>magic.4np2()</code> depending on the value of <code>n</code>.  Returns a
magic square in standard format (compare the <code>magic.2np1()</code> et seq,
which return the square as generated by the direct algorithm).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>William H. Benson and Oswald Jacoby.  <em>New recreations with
magic squares</em>. Dover 1976.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic.2np1">magic.2np1</a></code>, <code><a href="#topic+magic.prime">magic.prime</a></code>,
<code><a href="#topic+magic.4np2">magic.4np2</a></code>,
<code><a href="#topic+magic.4n">magic.4n</a></code>,<code><a href="#topic+lozenge">lozenge</a></code>,
<code><a href="#topic+as.standard">as.standard</a></code>, <code><a href="#topic+force.integer">force.integer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>magic(6)
all(is.magic(magic(3:10)))

## The first eigenvalue of a magic square is equal to the magic constant:
eigen(magic(10),FALSE,TRUE)$values[1] - magic.constant(10)

## The sum of the eigenvalues of a magic square after the first is zero:
sum(eigen(magic(10),FALSE,TRUE)$values[2:10])



</code></pre>

<hr>
<h2 id='magic.2np1'>Magic squares of odd order</h2><span id='topic+magic.2np1'></span>

<h3>Description</h3>

<p>Function to create magic squares of odd order 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic.2np1(m, ord.vec = c(-1, 1), break.vec = c(1, 0), start.point=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magic.2np1_+3A_m">m</code></td>
<td>
<p>creates a magic square of order <code class="reqn">n=2m+1</code></p>
</td></tr>
<tr><td><code id="magic.2np1_+3A_ord.vec">ord.vec</code></td>
<td>
<p>ordinary vector.  Default value of <code>c(-1,1) </code>
corresponds to the usual northeast direction</p>
</td></tr>
<tr><td><code id="magic.2np1_+3A_break.vec">break.vec</code></td>
<td>
<p>break vector.  Default of <code>c(1,0)</code> corresponds to the
usual south direction</p>
</td></tr>
<tr><td><code id="magic.2np1_+3A_start.point">start.point</code></td>
<td>
<p>Starting position for the method (ie coordinates of
unity).  Default value of NULL corresponds to row 1, column <code>m</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Written up in loads of places.  The method (at least with
the default ordinary and break vectors) seems to have been known since
at least the Renaissance.
</p>
<p>Benson and Jacoby, and the Mathematica website, discuss the problem
with nondefault ordinary and break vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic">magic</a></code>, <code><a href="#topic+magic.prime">magic.prime</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>magic.2np1(1)
f &lt;- function(n){is.magic(magic.2np1(n))}
all(sapply(1:20,f))

is.panmagic(magic.2np1(5,ord.vec=c(2,1),break.vec=c(1,3)))
</code></pre>

<hr>
<h2 id='magic.4n'>Magic squares of order 4n</h2><span id='topic+magic.4n'></span>

<h3>Description</h3>

<p>Produces an associative magic square of order <code class="reqn">4n</code> using the
delta-x method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic.4n(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magic.4n_+3A_m">m</code></td>
<td>
<p>Order <code class="reqn">n</code> of the square is given by <code class="reqn">n=4m</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic">magic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>magic.4n(4)
is.magic(magic.4n(5))
</code></pre>

<hr>
<h2 id='magic.4np2'>Magic squares of order 4n+2</h2><span id='topic+magic.4np2'></span>

<h3>Description</h3>

<p>Produces a magic square of order <code class="reqn">4n+2</code> using
Conway's &ldquo;LUX&rdquo; method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic.4np2(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magic.4np2_+3A_m">m</code></td>
<td>
<p>returns a magic square of order <code class="reqn">n=4m+2</code>
for <code class="reqn">m\geq 1</code>, using Conway's
&ldquo;LUX&rdquo; construction</p>
</td></tr>
</table>


<h3>Note</h3>

<p>I am not entirely happy with the method used: it's too complicated</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://mathworld.wolfram.com/MagicSquare.html">https://mathworld.wolfram.com/MagicSquare.html</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+magic">magic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>magic.4np2(1)
is.magic(magic.4np2(3))
</code></pre>

<hr>
<h2 id='magic.8'>Regular magic squares of order 8</h2><span id='topic+magic.8'></span>

<h3>Description</h3>

<p>Returns all 90 regular magic squares of order 8
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic.8(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magic.8_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array of dimensions <code>c(8,8,90)</code> of which each slice is
an 8-by-8 magic square.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.grogono.com/magic/index.php">https://www.grogono.com/magic/index.php</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
h &lt;- magic.8()
h[,,1]

stopifnot(apply(h,3,is.magic))
</code></pre>

<hr>
<h2 id='magic.constant'>Magic constant of a magic square or hypercube</h2><span id='topic+magic.constant'></span>

<h3>Description</h3>

<p>Returns the magic constant: that is, the common sum for all rows,
columns and (broken) diagonals of a magic square or hypercube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic.constant(n,d=2,start=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magic.constant_+3A_n">n</code></td>
<td>
<p>Order of the square or hypercube</p>
</td></tr>
<tr><td><code id="magic.constant_+3A_d">d</code></td>
<td>
<p>Dimension of hypercube, defaulting to <code>d=2</code> (a square)</p>
</td></tr>
<tr><td><code id="magic.constant_+3A_start">start</code></td>
<td>
<p>Start value.  Common values are 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>n</code> is an integer, interpret this as the order of the square
or hypercube; return <code class="reqn">n({\rm start}+n^d-1)/2</code>.
</p>
<p>If <code>n</code> is a square or hypercube, return the magic constant for
a normal array (starting at 1) of the same dimensions as <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic">magic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>magic.constant(4)
</code></pre>

<hr>
<h2 id='magic.prime'>Magic squares prime order</h2><span id='topic+magic.prime'></span>

<h3>Description</h3>

<p>Produces magic squares of prime order using the standard method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic.prime(n,i=2,j=3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magic.prime_+3A_n">n</code></td>
<td>
<p>The order of the square</p>
</td></tr>
<tr><td><code id="magic.prime_+3A_i">i</code></td>
<td>
<p>row number of increment</p>
</td></tr>
<tr><td><code id="magic.prime_+3A_j">j</code></td>
<td>
<p>column number of increment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Claimed to work for order any prime <code class="reqn">p</code> with <code class="reqn">(p,ij)=1</code>, but
I've tried it (with the defaults for <code>i</code> and <code>j</code>) for many
composite integers of the form <code class="reqn">6n+1</code> and <code class="reqn">6n-1</code> and
found no exceptions; indeed, they all seem to be panmagic.  It is not
clear to me when the process works and when it doesn't.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>magic.prime(7)
f &lt;- function(n){is.magic(magic.prime(n))}
all(sapply(6*1:30+1,f))
all(sapply(6*1:30-1,f))

is.magic(magic.prime(9,i=2,j=4),give.answers=TRUE)
magic.prime(7,i=2,j=4)
</code></pre>

<hr>
<h2 id='magic.product'>Product of two magic squares</h2><span id='topic+magic.product'></span><span id='topic+magic.product.fast'></span>

<h3>Description</h3>

<p>Gives a magic square that is a product of two magic squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic.product(a, b, mat=NULL)
magic.product.fast(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magic.product_+3A_a">a</code></td>
<td>
<p>First magic square; if <code>a</code> is an integer, use <code>magic(a)</code>.</p>
</td></tr>
<tr><td><code id="magic.product_+3A_b">b</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="magic.product_+3A_mat">mat</code></td>
<td>
<p>Matrix, of same size as <code>a</code>, of integers treated as
modulo 8.  Default value of <code>NULL</code> equivalent to passing
<code>a*0</code>.  Each number from 0-7 corresponds to one of the 8
squares which have the same Frenicle's standard form, as generated
by <code>transf()</code>.  Then
subsquares of the product square (ie tiles of the same size as
<code>b</code>) are rotated and transposed appropriately according to
their corresponding entry in <code>mat</code>.  This is a lot easier to
see than to describe (see examples section).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>magic.product.fast()</code> does not take a <code>mat</code>
argument, and is equivalent to <code>magic.product()</code> with <code>mat</code>
taking the default value of <code>NULL</code>.  The improvement in speed is
doubtful unless <code>order(a)</code><code class="reqn">\gg</code><code>order(b)</code>, in which
case there appears to be a substantial saving.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>William H. Benson and Oswald Jacoby. New recreations with magic
squares, Dover 1976 (and that paper in JRM)</p>


<h3>Examples</h3>

<pre><code class='language-R'>magic.product(magic(3),magic(4))
magic.product(3,4)

mat &lt;- matrix(0,3,3)
a &lt;- magic.product(3,4,mat=mat)
mat[1,1] &lt;- 1
b &lt;- magic.product(3,4,mat=mat)

a==b
</code></pre>

<hr>
<h2 id='magiccube.2np1'>Magic cubes of order 2n+1</h2><span id='topic+magiccube.2np1'></span>

<h3>Description</h3>

<p>Creates odd-order magic cubes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magiccube.2np1(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magiccube.2np1_+3A_m">m</code></td>
<td>
<p>n=2m+1</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>website</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic">magic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#try with m=3, n=2*3+1=7:

m &lt;-7                     
n &lt;- 2*m+1


apply(magiccube.2np1(m),c(1,2),sum)
apply(magiccube.2np1(m),c(1,3),sum)
apply(magiccube.2np1(m),c(2,3),sum)

#major diagonal checks out:
sum(magiccube.2np1(m)[matrix(1:n,n,3)])

#now other diagonals:
b &lt;- c(-1,1)
f &lt;- function(dir,v){if(dir&gt;0){return(v)}else{return(rev(v))}}
g &lt;- function(jj){sum(magiccube.2np1(m)[sapply(jj,f,v=1:n)])}
apply(expand.grid(b,b,b),1,g)  #each diagonal twice, once per direction.
</code></pre>

<hr>
<h2 id='magiccubes'>Magic cubes of order 3</h2><span id='topic+magiccubes'></span>

<h3>Description</h3>

<p>A list of four elements listing each fundamentally different magic cube
of order 3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(magiccubes)</code></pre>


<h3>Source</h3>

<p>Originally discovered by Hendricks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(magiccubes)
magiccubes$a1
sapply(magiccubes,is.magichypercube)
</code></pre>

<hr>
<h2 id='magichypercube.4n'>Magic hypercubes of order 4n</h2><span id='topic+magichypercube.4n'></span>

<h3>Description</h3>

<p>Returns magic hypercubes of order 4n and any dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magichypercube.4n(m, d = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magichypercube.4n_+3A_m">m</code></td>
<td>
<p>Magic hypercube produced of order <code class="reqn">n=4m</code></p>
</td></tr>
<tr><td><code id="magichypercube.4n_+3A_d">d</code></td>
<td>
<p>Dimensionality of cube</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a rather kludgy (but vectorized) method.  I am not 100% sure that
the method does in fact produce magic squares for all orders and dimensions.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>magichypercube.4n(1,d=4)
magichypercube.4n(2,d=3)
</code></pre>

<hr>
<h2 id='magicplot'>Joins consecutive numbers of a magic square.</h2><span id='topic+magicplot'></span>

<h3>Description</h3>

<p>A nice way to graphically represent normal magic squares.  Lines are
plotted to join successive numbers from 1 to <code class="reqn">n^2</code>.
Many magic squares have attractive such plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magicplot(m, number = TRUE, do.circuit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="magicplot_+3A_m">m</code></td>
<td>
<p>Magic square to be plotted.</p>
</td></tr>
<tr><td><code id="magicplot_+3A_number">number</code></td>
<td>
<p>Boolean variable with <code>TRUE</code> meaning to include the
numbers on the plot</p>
</td></tr>
<tr><td><code id="magicplot_+3A_do.circuit">do.circuit</code></td>
<td>
<p>Boolean variable with <code>TRUE</code> meaning to include the
line joining <code class="reqn">n^2</code> to 1</p>
</td></tr>
<tr><td><code id="magicplot_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code>plot()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>magicplot(magic.4n(2))
</code></pre>

<hr>
<h2 id='minmax'>are all elements of a vector identical?</h2><span id='topic+minmax'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if and only if all elements of a vector are identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minmax(x, tol=1e-6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minmax_+3A_x">x</code></td>
<td>
<p>Vector to be tested</p>
</td></tr>
<tr><td><code id="minmax_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is an integer, exact equality is required.  If real or
complex, a relative tolerance of <code>tol</code> is required.  Note that
functions such as <code>is.magic()</code> and <code>is.semimagichypercube()</code>
use the default value for <code>tol</code>.  To change this, 
define a new Boolean function that tests the sum to the required
tolerance, and set <code>boolean</code> to <code>TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p>is.magic()</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Ollerenshaw)
minmax(subsums(Ollerenshaw,2))  #should be TRUE, as per is.2x2.correct()
</code></pre>

<hr>
<h2 id='notmagic.2n'>An unmagic square</h2><span id='topic+notmagic.2n'></span>

<h3>Description</h3>

<p>Returns a square of order <code class="reqn">n=2m</code> that has been claimed to
be magic, but isn't.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notmagic.2n(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="notmagic.2n_+3A_m">m</code></td>
<td>
<p>Order of square is <code class="reqn">n=2m</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>This took me a whole evening to code up.  And I was quite pleased
with the final vectorized form: it matches Andrews's (8 by 8) example
square exactly.  What a crock</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>&ldquo;Magic Squares and Cubes&rdquo;, Andrews, (book)</p>


<h3>Examples</h3>

<pre><code class='language-R'>  notmagic.2n(4)
  is.magic(notmagic.2n(4))
  is.semimagic(notmagic.2n(4))

</code></pre>

<hr>
<h2 id='nqueens'>N queens problem</h2><span id='topic+nqueens'></span><span id='topic+bernhardsson'></span><span id='topic+bernhardssonA'></span><span id='topic+bernhardssonB'></span>

<h3>Description</h3>

<p>Solves the N queens problem for any n-by-n board. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernhardsson(n)
bernhardssonA(n)
bernhardssonB(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nqueens_+3A_n">n</code></td>
<td>
<p>Size of the chessboard</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a direct transcript of Bo Bernhardsson's method.
</p>
<p>All solutions (up to reflection and translation) for the 8-by-8 case
given in the examples.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>Bo Bernhardsson 1991.  &ldquo;Explicit solutions to the
n-queens problem for all <code class="reqn">n</code>&rdquo;.  <em>SIGART Bull.</em>, 2(2):7
</p>
</li>
<li><p> Weisstein, Eric W. &ldquo;Queens Problem&rdquo; From
<em>MathWorld&ndash;A Wolfram Web Resource</em>
<a href="https://mathworld.wolfram.com/QueensProblem.html">https://mathworld.wolfram.com/QueensProblem.html</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>bernhardsson(7)

a &lt;-
  matrix(
         c(3,6,2,7,1,4,8,5,
           2,6,8,3,1,4,7,5,
           6,3,7,2,4,8,1,5,
           3,6,8,2,4,1,7,5,
           4,8,1,3,6,2,7,5,
           7,2,6,3,1,4,8,5,
           2,6,1,7,4,8,3,5,
           1,6,8,3,7,4,2,5,
           1,5,8,6,3,7,2,4,
           2,4,6,8,3,1,7,5,
           6,3,1,8,4,2,7,5,
           4,6,8,2,7,1,3,5)
         ,8,12)

out &lt;- array(0L,c(8,8,12))
for(i in 1:12){
  out[cbind(seq_len(8),a[,i],i)] &lt;- 1L
}


</code></pre>

<hr>
<h2 id='Ollerenshaw'>A most perfect square due to Ollerenshaw</h2><span id='topic+Ollerenshaw'></span>

<h3>Description</h3>

<p>A 12-by-12 most perfect square due to Ollerenshaw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Ollerenshaw)</code></pre>


<h3>Source</h3>

<p>&ldquo;Most perfect pandiagonal magic squares&rdquo;, K. Ollerenshaw and D. Bree,
1998, Institute of Mathematics and its applications
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Ollerenshaw)
is.mostperfect(Ollerenshaw)
</code></pre>

<hr>
<h2 id='panmagic.4'>Panmagic squares of order 4</h2><span id='topic+panmagic.4'></span>

<h3>Description</h3>

<p>Creates all fundamentally different panmagic squares of order 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panmagic.4(vals = 2^(0:3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panmagic.4_+3A_vals">vals</code></td>
<td>
<p>a length four vector giving the values which are combined
in each of the <code class="reqn">2^4</code> possible ways.  Thus
<code>vals=2^sample(0:3)</code> always gives a normal square
(0-15 in binary).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.grogono.com/magic/index.php">https://www.grogono.com/magic/index.php</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+panmagic.6npm1">panmagic.6npm1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>panmagic.4()
panmagic.4(2^c(1,3,2,0))
panmagic.4(10^(0:3))
</code></pre>

<hr>
<h2 id='panmagic.6npm1'>Panmagic squares of order 4n, 6n+1 and 6n-1</h2><span id='topic+panmagic.4n'></span><span id='topic+panmagic.6npm1'></span><span id='topic+panmagic.6np1'></span><span id='topic+panmagic.6nm1'></span>

<h3>Description</h3>

<p>Produce a panmagic square of order <code class="reqn">4n</code> or <code class="reqn">6n\pm 1</code> using a
classical method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panmagic.6npm1(n)
panmagic.6np1(m)
panmagic.6nm1(m)
panmagic.4n(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panmagic.6npm1_+3A_m">m</code></td>
<td>
<p>Function <code>panmagic.6np1(m)</code> returns a panmagic square of
order <code class="reqn">n=6m+1</code> for <code class="reqn">m\geq 1</code>, and function
<code>panmagic.6nm1(m)</code> returns a panmagic square of order
<code class="reqn">n=6m-1</code> for <code class="reqn">m\geq 1</code>, using a classical method.
</p>
<p>Function <code>panmagic.4n(m)</code> returns a magic square of order
<code class="reqn">n=4m</code></p>
</td></tr> <tr><td><code id="panmagic.6npm1_+3A_n">n</code></td>
<td>
<p>Function <code>panmagic.6npm1(n)</code> returns a
panmagic square of order <code class="reqn">n</code> where <code class="reqn">n=6m\pm 1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>panmagic.6npm1(n)</code> will return a square if <code>n</code> is
not of the form <code class="reqn">6m\pm 1</code>, but it is not necessarily
magic.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>&ldquo;Pandiagonal magic square.&rdquo; <em>Wikipedia, The Free
Encyclopedia.</em> Wikimedia Foundation, Inc. 13 February 2013 </p>


<h3>See Also</h3>

<p><code><a href="#topic+magic">magic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>panmagic.6np1(1)
panmagic.6npm1(13)

all(sapply(panmagic.6np1(1:3),is.panmagic))

</code></pre>

<hr>
<h2 id='panmagic.8'>Panmagic squares of order 8</h2><span id='topic+panmagic.8'></span>

<h3>Description</h3>

<p>Produces each of a wide class of order 8 panmagic squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panmagic.8(chosen = 1:6, vals = 2^(0:5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panmagic.8_+3A_chosen">chosen</code></td>
<td>
<p>Which of the magic carpets are used in combination</p>
</td></tr>
<tr><td><code id="panmagic.8_+3A_vals">vals</code></td>
<td>
<p>The values combined to produce the magic square.  Choosing
<code>0:5</code> gives a normal magic square.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Not all choices for <code>chosen</code> give normal magic squares.  There
seems to be no clear pattern.  See website in references for details.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.grogono.com/magic/index.php">https://www.grogono.com/magic/index.php</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+panmagic.4">panmagic.4</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>is.panmagic(panmagic.8(chosen=2:7))
is.normal(panmagic.8(chosen=2:7))
is.normal(panmagic.8(chosen=c(1,2,3,6,7,8)))

#to see the twelve basis magic carpets, set argument 'chosen' to each
#integer from 1 to 12 in turn, with vals=1:

panmagic.8(chosen=1,vals=1)-1
image(panmagic.8(chosen=12,vals=1))

</code></pre>

<hr>
<h2 id='perfectcube5'>A perfect magic cube of order 5</h2><span id='topic+perfectcube5'></span>

<h3>Description</h3>

<p>A perfect cube of order 5, due to Trump and Boyer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(perfectcube5)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(perfectcube5)
is.perfect(perfectcube5)
</code></pre>

<hr>
<h2 id='perfectcube6'>A perfect cube of order 6</h2><span id='topic+perfectcube6'></span>

<h3>Description</h3>

<p>A perfect cube of order 6 originally due to Trump
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(perfectcube6)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(perfectcube6)
is.perfect(perfectcube6)
is.magichypercube(perfectcube6[2:5,2:5,2:5])
</code></pre>

<hr>
<h2 id='process'>Force index arrays into range</h2><span id='topic+process'></span>

<h3>Description</h3>

<p>Forces an (integer) array to have entries in the range 1-n, by (i)
taking the entries modulo n, then (ii) setting zero elements to n.
Useful for modifying index arrays into a form suitable for use with
magic squares.</p>


<h3>Usage</h3>

<pre><code class='language-R'>process(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_+3A_x">x</code></td>
<td>
<p>Index array to be processed</p>
</td></tr>
<tr><td><code id="process_+3A_n">n</code></td>
<td>
<p>Modulo of arithmetic to be used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'># extract the broken diagonal of magic.2np1(4) that passes
# through element [1,5]:

a &lt;- magic.2np1(4)
index &lt;- t(c(1,5)+rbind(1:9,1:9))
a[process(index,9)]
</code></pre>

<hr>
<h2 id='recurse'>Recursively apply a permutation</h2><span id='topic+recurse'></span>

<h3>Description</h3>

<p>Recursively apply a permutation to a vector an arbitrary number of
times.  Negative times mean apply the inverse permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recurse(perm, i, start = seq_along(perm))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recurse_+3A_perm">perm</code></td>
<td>
<p>Permutation (integers 1 to <code>length(start)</code> in some order)</p>
</td></tr>
<tr><td><code id="recurse_+3A_start">start</code></td>
<td>
<p>Start vector to be permuted</p>
</td></tr>
<tr><td><code id="recurse_+3A_i">i</code></td>
<td>
<p>Number of times to apply the permutation.  <code>i=0</code> gives
<code>start</code> by definition and negative values use the inverse
permutation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+hudson">hudson</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 15
noquote(recurse(start=letters[1:n],perm=shift(1:n),i=0))
noquote(recurse(start=letters[1:n],perm=shift(1:n),i=1))
noquote(recurse(start=letters[1:n],perm=shift(1:n),i=2))

noquote(recurse(start=letters[1:n],perm=sample(n),i=1))
noquote(recurse(start=letters[1:n],perm=sample(n),i=2))

</code></pre>

<hr>
<h2 id='sam'>Sparse antimagic squares</h2><span id='topic+sam'></span>

<h3>Description</h3>

<p>Produces an antimagic square of order <code class="reqn">m</code> using
Gray and MacDougall's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sam(m, u, A=NULL, B=A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sam_+3A_m">m</code></td>
<td>
<p>Order of the magic square (not &ldquo;<code>n</code>&rdquo;: the
terminology follows Gray and MacDougall)</p>
</td></tr>
<tr><td><code id="sam_+3A_u">u</code></td>
<td>
<p>See details section</p>
</td></tr>
<tr><td><code id="sam_+3A_a">A</code>, <code id="sam_+3A_b">B</code></td>
<td>
<p>Start latin squares, with default <code>NULL</code> meaning to
use <code>circulant(m)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Gray's terminology, <code>sam(m,n)</code> produces a
<code class="reqn">SAM(2m,2u+1,0)</code>.
</p>
<p>The method is not vectorized.
</p>
<p>To test for these properties, use functions such as
<code>is.antimagic()</code>, documented under <code>is.magic.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>I. D. Gray and J. A. MacDougall 2006.  &ldquo;Sparse anti-magic squares
and vertex-magic labelings of bipartite graphs&rdquo;, <em>Discrete
Mathematics</em>, volume 306, pp2878-2892
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic">magic</a></code>,<code><a href="#topic+is.magic">is.magic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>sam(6,2)

jj &lt;- matrix(c(
     5, 2, 3, 4, 1,
     3, 5, 4, 1, 2,
     2, 3, 1, 5, 4,
     4, 1, 2, 3, 5, 
     1, 4, 5, 2, 3),5,5)

is.sam(sam(5,2,B=jj))

</code></pre>

<hr>
<h2 id='shift'>Shift origin of arrays and vectors</h2><span id='topic+shift'></span><span id='topic+ashift'></span>

<h3>Description</h3>

<p>Shift origin of arrays and vectors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(x, i=1)
ashift(a, v=rep(1,length(dim(a))))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>Vector to be shifted</p>
</td></tr>
<tr><td><code id="shift_+3A_i">i</code></td>
<td>
<p>Number of places elements to be shifted, with default value
of 1 meaning to put the last element first, followed by the first
element, then the second, etc</p>
</td></tr>
<tr><td><code id="shift_+3A_a">a</code></td>
<td>
<p>Array to be shifted</p>
</td></tr>
<tr><td><code id="shift_+3A_v">v</code></td>
<td>
<p>Vector of numbers to be shifted in each dimension, with
default value corresponding to <code>shift()</code>ing each dimension by 1
unit.  If the length of <code>v</code> is less than <code>length(dim(a))</code>,
it is padded with zeros (thus a scalar value of <code>i</code> indicates
that the first dimension is to be shifted by <code>i</code> units)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>shift(x,n)</code> returns <code class="reqn">P^n(x)</code> where <code class="reqn">P</code> is the
permutation <code class="reqn">(n,1,2,\ldots,n-1)</code>.
</p>
<p>Function <code>ashift</code> is the array generalization of this: the
<code class="reqn">n^{\rm th}</code> dimension is shifted by <code>v[n]</code>.  In other
words,
<code>ashift(a,v)=a[shift(1:(dim(a)[1]),v[1]),...,shift(1:(dim(a)[n]),v[n])]</code>. 
It is named by analogy with <code>abind()</code> and <code>aperm()</code>.
</p>
<p>This function is here because a shifted semimagic square or hypercube
is semimagic and a shifted pandiagonal square or hypercube is
pandiagonal (note that a shifted magic square is not necessarily
magic, and a shifted perfect hypercube is not necessarily perfect).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>shift(1:10,3)
m &lt;- matrix(1:100,10,10)
ashift(m,c(1,1))
ashift(m,c(0,1))    #note columns shifted by 1, rows unchanged.
ashift(m,dim(m))    #m unchanged (Mnemonic).
</code></pre>

<hr>
<h2 id='strachey'>Strachey's algorithm for magic squares</h2><span id='topic+strachey'></span>

<h3>Description</h3>

<p>Uses Strachey's algorithm to produce magic squares of
singly-even order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strachey(m, square=magic.2np1(m))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strachey_+3A_m">m</code></td>
<td>
<p>magic square produced of order <code>n=2m+1</code></p>
</td></tr>
<tr><td><code id="strachey_+3A_square">square</code></td>
<td>
<p>magic square of order <code>2m+1</code> needed for Strachey's
method.  Default value gives the standard construction, but
the  method will work with any odd order magic square</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strachey's method essentially places four identical magic squares
of order <code class="reqn">2m+1</code> together to form one of <code class="reqn">n=4m+2</code>.  Then
<code class="reqn">0,n^2/4,n^2/2,3n^2/4</code> is added to each
square; and finally, certain squares are swapped from the top
subsquare to the bottom subsquare.
</p>
<p>See the final example for an illustration of how this works,
using a zero matrix as the submatrix.  Observe how some 75s are
swapped with some 0s, and some 50s with some 25s.  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+magic.4np2">magic.4np2</a></code>,<code><a href="#topic+lozenge">lozenge</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> strachey(3)
 strachey(2,square=magic(5))

 strachey(2,square=magic(5)) %eq%  strachey(2,square=t(magic(5)))
 #should be FALSE

 #Show which numbers have been swapped:
 strachey(2,square=matrix(0,5,5))

 #It's still magic, but not normal:
  is.magic(strachey(2,square=matrix(0,5,5)))
</code></pre>

<hr>
<h2 id='subsums'>Sums of submatrices</h2><span id='topic+subsums'></span>

<h3>Description</h3>

<p>Returns the sums of submatrices of an array; multidimensional moving
window averaging</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsums(a,p,func="sum",wrap=TRUE, pad=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsums_+3A_a">a</code></td>
<td>
<p>Array to be analysed</p>
</td></tr>
<tr><td><code id="subsums_+3A_p">p</code></td>
<td>
<p>Argument specifying the subarrays to be summed.  If a vector
of length greater than one,
it is assumed to be of length <code>d=length(dim(a))</code>, and is
interpreted to be the dimensions of the subarrays, with
the size of the window's <code class="reqn">n{^{\rm th}}</code> dimension being
<code>a[n]</code>.  If the length of <code>p</code> is one, recycling is used.
</p>
<p>If not a vector, is assumed to be a matrix with <code>d</code> columns, each
row representing the coordinates of the elements to be summed.  See
examples.  
</p>
</td></tr>
<tr><td><code id="subsums_+3A_func">func</code></td>
<td>
<p>Function to be applied over the elements of the moving
window.  Default value of <code>sum</code> gives the sum as used in
<code>is.2x2.correct()</code>;  other choices might be <code>mean</code>,
<code>prod</code>, or <code>max</code>.  
</p>
<p>If <code>sum=""</code>, return the array of dimension
<code>c(dim(a),prod(p))</code> where each hyperplane is a shifted version
of <code>a</code>.</p>
</td></tr>
<tr><td><code id="subsums_+3A_wrap">wrap</code></td>
<td>
<p>Boolean, with default value of <code>TRUE</code> meaning to view
array <code>a</code> as a n-dimensional torus.  Thus, if
<code>x=subsums(a,p,wrap=TRUE)</code>, and if <code>dim(a)=c(a_1,...,a_d)</code>
then <code>x[a_1,...,a_d]</code> is the sum of all corner elements of
<code>a</code>.
</p>
<p>If <code>FALSE</code>, do not wrap <code>a</code> and return an array of
dimension <code>dim(a)+p-1</code>.</p>
</td></tr>
<tr><td><code id="subsums_+3A_pad">pad</code></td>
<td>
<p>If <code>wrap</code> is <code>TRUE</code>, <code>pad</code> is
the value used   to pad the array with.  Use a &ldquo;neutral&rdquo; value here;
for example, if <code>func=sum</code>, then use 0; if <code>max</code>, use
<code class="reqn">-\infty</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The offset is specified so that <code>allsums(a,v)[1,1,...,1]=
    sum(a[1:v[1],1:v[2],...,1:v[n]])</code>, where <code>n=length(dim(a))</code>.
</p>
<p>Function <code>subsums()</code> is used in <code>is.2x2.correct()</code> and
<code>is.diagonally.correct()</code>. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Ollerenshaw)
  subsums(Ollerenshaw,c(2,2))
  subsums(Ollerenshaw[,1:10],c(2,2))
  subsums(Ollerenshaw, matrix(c(0,6),2,2)) # effectively, is.bree.correct()

  # multidimensional example.  
  a &lt;- array(1,c(3,4,2))
  subsums(a,2)             # note that p=2 is equivalent to p=c(2,2,2);
                           # all elements should be identical

  subsums(a,2,wrap=FALSE)  #note "middle" elements &gt; "outer" elements


  #Example of nondefault function:
  x &lt;- matrix(1:42,6,7)
  subsums(x,2,func="max",pad=Inf,wrap=TRUE)  
  subsums(x,2,func="max",pad=Inf,wrap=FALSE)
</code></pre>

<hr>
<h2 id='transf'>Frenicle's equivalent magic squares</h2><span id='topic+transf'></span>

<h3>Description</h3>

<p>For a given magic square, returns one of the eight squares 
whose Frenicle's standard form is the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transf(a, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transf_+3A_a">a</code></td>
<td>
<p>Magic square</p>
</td></tr>
<tr><td><code id="transf_+3A_i">i</code></td>
<td>
<p>Integer, considered modulo 8.  Specifying 0-7 gives a
different magic square</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.standard">is.standard</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- magic(3)
identical(transf(a,0),a)

transf(a,1)
transf(a,2)

transf(a,1) %eq% transf(a,7)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
