<!DOCTYPE html><html lang="en"><head><title>Help for package SNFtool</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SNFtool}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#affinityMatrix'>
<p>Affinity matrix calculation</p></a></li>
<li><a href='#calNMI'>
<p>Mutual Information calculation</p></a></li>
<li><a href='#chiDist2'>
<p>Pairwise Chi-squared distances</p></a></li>
<li><a href='#concordanceNetworkNMI'>
<p>Concordance Network NMI calculation</p></a></li>
<li><a href='#Data1'>
<p>Data1</p></a></li>
<li><a href='#Data2'>
<p>Data2</p></a></li>
<li><a href='#dataL'>
<p>dataL</p></a></li>
<li><a href='#displayClusters'>
<p>Plot given similarity matrix by clusters</p></a></li>
<li><a href='#displayClustersWithHeatmap'>
<p>Display the similarity matrix by clusters with some sample information</p></a></li>
<li><a href='#dist2'>
<p>Pairwise squared Euclidean distances</p></a></li>
<li><a href='#estimateNumberOfClustersGivenGraph'>
<p>Estimate Number Of Clusters Given Graph</p></a></li>
<li><a href='#getColorsForGroups'>
<p>Obtaining a vector of colors from a numeric vector of group</p></a></li>
<li><a href='#groupPredict'>
<p>Group Predict</p></a></li>
<li><a href='#heatmapPlus'>
<p>Display heatmap for clusters</p></a></li>
<li><a href='#label'>
<p>Labels for dataL dataset</p></a></li>
<li><a href='#plotAlluvial'>
<p>Plot Alluvial</p></a></li>
<li><a href='#rankFeaturesByNMI'>
<p>Rank Features by NMI</p></a></li>
<li><a href='#SNF'>
<p>Similarity Network Fusion</p></a></li>
<li><a href='#SNFtool-internal'><p>Internal SNFtool Functions</p></a></li>
<li><a href='#spectralClustering'>
<p>Spectral Clustering</p></a></li>
<li><a href='#standardNormalization'>
<p>Standard Normalization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Similarity Network Fusion</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-06-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Bo Wang, Aziz Mezlini, Feyyaz Demir, Marc Fiume, Zhuowen Tu, Michael Brudno, Benjamin Haibe-Kains, Anna Goldenberg</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Brew &lt;goldenberglab@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>ExPosition, alluvial</td>
</tr>
<tr>
<td>Description:</td>
<td>Similarity Network Fusion takes multiple views of a network and fuses them together to construct an overall status matrix. The input to our algorithm can be feature vectors, pairwise distances, or pairwise similarities. The learned status matrix can then be used for retrieval, clustering, and classification.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-11 08:40:15 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-10 21:44:03 UTC; benbrew88</td>
</tr>
</table>
<hr>
<h2 id='affinityMatrix'>
Affinity matrix calculation
</h2><span id='topic+affinityMatrix'></span>

<h3>Description</h3>

<p>Computes affinity matrix from a generic distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affinityMatrix(diff, K = 20, sigma = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="affinityMatrix_+3A_diff">diff</code></td>
<td>

<p>Distance matrix
</p>
</td></tr>
<tr><td><code id="affinityMatrix_+3A_k">K</code></td>
<td>

<p>Number of nearest neighbors
</p>
</td></tr>
<tr><td><code id="affinityMatrix_+3A_sigma">sigma</code></td>
<td>

<p>Variance for local model
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an affinity matrix that represents the neighborhood graph of the data points.
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>References</h3>

<p>B Wang, A Mezlini, F Demir, M Fiume, T Zu, M Brudno, B Haibe-Kains, A Goldenberg (2014) Similarity Network Fusion: a fast and effective method to aggregate multiple data types on a genome wide scale. Nature Methods. Online. Jan 26, 2014  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First, set all the parameters:
K = 20; ##number of neighbors, must be greater than 1. usually (10~30)
alpha = 0.5; ##hyperparameter, usually (0.3~0.8)
T = 20; ###Number of Iterations, usually (10~50)

## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Calculate distance matrices(here we calculate Euclidean Distance, 
## you can use other distance, e.g. correlation)
Dist1 = (dist2(as.matrix(Data1),as.matrix(Data1)))^(1/2)
Dist2 = (dist2(as.matrix(Data2),as.matrix(Data2)))^(1/2)

## Next, construct similarity graphs
W1 = affinityMatrix(Dist1, K, alpha)
W2 = affinityMatrix(Dist2, K, alpha)

</code></pre>

<hr>
<h2 id='calNMI'>
Mutual Information calculation
</h2><span id='topic+calNMI'></span>

<h3>Description</h3>

<p>Calculate the mutual information between vectors x and y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calNMI(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calNMI_+3A_x">x</code></td>
<td>

<p>a vector
</p>
</td></tr>
<tr><td><code id="calNMI_+3A_y">y</code></td>
<td>

<p>a vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mutual information between vectors x and y.
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>References</h3>

<p>B Wang, A Mezlini, F Demir, M Fiume, T Zu, M Brudno, B Haibe-Kains, A Goldenberg (2014) Similarity Network Fusion: a fast and effective method to aggregate multiple data types on a genome wide scale. Nature Methods. Online. Jan 26, 2014  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# How to use SNF with multiple views

# Load views into list "dataL"
data(dataL)
data(label)

# Set the other parameters
K = 20 # number of neighbours
alpha = 0.5 # hyperparameter in affinityMatrix
T = 20 # number of iterations of SNF

# Normalize the features in each of the views if necessary
# dataL = lapply(dataL, standardNormalization)

# Calculate the distances for each view
distL = lapply(dataL, function(x) (dist2(x, x))^(1/2))

# Construct the similarity graphs
affinityL = lapply(distL, function(x) affinityMatrix(x, K, alpha))

# Example of how to use SNF to perform subtyping
# Construct the fused network
W = SNF(affinityL, K, T)
# Perform clustering on the fused network.
clustering = spectralClustering(W,3);
# Use NMI to measure the goodness of the obtained labels.
NMI = calNMI(clustering,label);

</code></pre>

<hr>
<h2 id='chiDist2'>
Pairwise Chi-squared distances
</h2><span id='topic+chiDist2'></span>

<h3>Description</h3>

<p>Wrapper function chi2Dist imported from 'ExPosition' package.
Computes the Chi-squared distances between all pairs of data point given
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiDist2(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chiDist2_+3A_a">A</code></td>
<td>

<p>A data matrix where each row is a different data point
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an N x N matrix where N is the number of rows in X. element (i,j) is the squared Chi-squared distance between ith data point in X and jth data point in X.
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Calculate distance matrices(here we calculate Euclidean Distance, 
## you can use other distance, e.g. correlation)
Dist1 = chiDist2(as.matrix(Data1))
Dist2 = chiDist2(as.matrix(Data2))

</code></pre>

<hr>
<h2 id='concordanceNetworkNMI'>
Concordance Network NMI calculation
</h2><span id='topic+concordanceNetworkNMI'></span>

<h3>Description</h3>

<p>Given a list of affinity matrices, Wall, the number of clusters, return a matrix containing the NMIs between cluster assignments made with spectral clustering on all matrices provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concordanceNetworkNMI(Wall, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concordanceNetworkNMI_+3A_wall">Wall</code></td>
<td>

<p>List of matrices. Each element of the list is a square, symmetric matrix that shows affinities of the data points from a certain view.
</p>
</td></tr>
<tr><td><code id="concordanceNetworkNMI_+3A_c">C</code></td>
<td>

<p>Number of clusters
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an affinity matrix that represents the neighborhood graph of the data points.
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# How to use SNF with multiple views

# Load views into list "dataL"
data(dataL)
data(label)

# Set the other parameters
K = 20 # number of neighbours
alpha = 0.5 # hyperparameter in affinityMatrix
T = 20 # number of iterations of SNF
# Normalize the features in each of the views.
#dataL = lapply(dataL, standardNormalization)

# Calculate the distances for each view
distL = lapply(dataL, function(x) (dist2(x, x)^(1/2)))

# Construct the similarity graphs
affinityL = lapply(distL, function(x) affinityMatrix(x, K, alpha))

# an example of how to use concordanceNetworkNMI
Concordance_matrix = concordanceNetworkNMI(affinityL, 3);

## The output, Concordance_matrix,
## shows the concordance between the fused network and each individual network. 

</code></pre>

<hr>
<h2 id='Data1'>
Data1
</h2><span id='topic+Data1'></span>

<h3>Description</h3>

<p>Data1 dataset used to demonstrate the use of SNFtool. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Data1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 2 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>V2</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(Data1)
</code></pre>

<hr>
<h2 id='Data2'>
Data2
</h2><span id='topic+Data2'></span>

<h3>Description</h3>

<p>Data2 dataset used to demonstrate the use of SNFtool. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Data2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 2 variables.
</p>

<dl>
<dt><code>V3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>V4</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(Data2)
</code></pre>

<hr>
<h2 id='dataL'>
dataL
</h2><span id='topic+dataL'></span>

<h3>Description</h3>

<p>Dataset used to provide an example of predicting the new labels with label propagation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataL)
</code></pre>


<h3>Format</h3>

<p>The format is:
List of 2
$ : num [1:600, 1:76] 0.0659 0.0491 0.0342 0.0623 0.062 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:600] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; ...
.. ..$ : NULL
$ : int [1:600, 1:240] 0 0 0 0 0 0 0 0 0 0 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:600] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; ...
.. ..$ : NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataL)
</code></pre>

<hr>
<h2 id='displayClusters'>
Plot given similarity matrix by clusters
</h2><span id='topic+displayClusters'></span>

<h3>Description</h3>

<p>Visualize the clusters in given similarity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayClusters(W, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="displayClusters_+3A_w">W</code></td>
<td>

<p>Similarity matrix
</p>
</td></tr>
<tr><td><code id="displayClusters_+3A_group">group</code></td>
<td>

<p>A vector containing the labels for each sample in W. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots given similarity matrix with patients ordered to form clusters.
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First, set all the parameters:
K = 20;			# number of neighbors, usually (10~30)
alpha = 0.5;  	# hyperparameter, usually (0.3~0.8)
T = 10; 		# Number of Iterations, usually (10~20)

## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Here, the simulation data (SNFdata) has two data types. They are complementary to each other. 
## And two data types have the same number of points. 
## The first half data belongs to the first cluster; the rest belongs to the second cluster.
truelabel = c(matrix(1,100,1),matrix(2,100,1)); ## the ground truth of the simulated data

## Calculate distance matrices
## (here we calculate Euclidean Distance, you can use other distance, e.g,correlation)

## If the data are all continuous values, we recommend the users to perform 
## standard normalization before using SNF, 
## though it is optional depending on the data the users want to use.  
# Data1 = standardNormalization(Data1);
# Data2 = standardNormalization(Data2);


## Calculate the pair-wise distance; 
## If the data is continuous, we recommend to use the function "dist2" as follows 
Dist1 = (dist2(as.matrix(Data1),as.matrix(Data1)))^(1/2)
Dist2 = (dist2(as.matrix(Data2),as.matrix(Data2)))^(1/2)

## next, construct similarity graphs
W1 = affinityMatrix(Dist1, K, alpha)
W2 = affinityMatrix(Dist2, K, alpha)

## These similarity graphs have complementary information about clusters.
displayClusters(W1, truelabel);
displayClusters(W2, truelabel);

</code></pre>

<hr>
<h2 id='displayClustersWithHeatmap'>
Display the similarity matrix by clusters with some sample information
</h2><span id='topic+displayClustersWithHeatmap'></span>

<h3>Description</h3>

<p>Visualize the clusters present in the given similarity matrix as well as some sample information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayClustersWithHeatmap(W, group, ColSideColors=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="displayClustersWithHeatmap_+3A_w">W</code></td>
<td>

<p>Similarity matrix
</p>
</td></tr>
<tr><td><code id="displayClustersWithHeatmap_+3A_group">group</code></td>
<td>

<p>A numeric vector containing the groups information for each sample in W such as the result of the spectralClustering function. The order should correspond to the sample order in W.
</p>
</td></tr>
<tr><td><code id="displayClustersWithHeatmap_+3A_colsidecolors">ColSideColors</code></td>
<td>

<p>(optional) character vector of length ncol(x) containing the color names for a horizontal side bar that may be used to annotate the columns of x, used by the heatmap function, OR a character matrix with number of rows matching number of rows in x.  Each column is plotted as a row similar to heatmap()'s ColSideColors by the heatmap.plus function.
</p>
</td></tr>
<tr><td><code id="displayClustersWithHeatmap_+3A_...">...</code></td>
<td>

<p>other paramater that can be pass on to the heatmap (if ColSideColor is a NULL or a vector) or  heatmap.plus function (if ColSideColors is matrix)  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the heatmap or heatmap.plus function to display the similarity matrix
For representation purpose, the similarity matrix diagonal is set to the median value of W, the matrix is normalised and W = W + t(W) is applied
In this presentation no clustering method is ran the samples are ordered in function of their group label present in the group arguments.
</p>


<h3>Value</h3>

<p>Plots the similarity matrix using the heatmap function. Samples are ordered by the clusters provided by the argument groups with sample information displayed with a color bar if the ColSideColors argument is informed.
</p>


<h3>Author(s)</h3>

<p>Florence Cavalli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First, set all the parameters:
K = 20;    # number of neighbors, usually (10~30)
alpha = 0.5;    # hyperparameter, usually (0.3~0.8)
T = 20;   # Number of Iterations, usually (10~20)

## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Here, the simulation data (SNFdata) has two data types. They are complementary to each other. 
## And two data types have the same number of points. 
## The first half data belongs to the first cluster; the rest belongs to the second cluster.
truelabel = c(matrix(1,100,1),matrix(2,100,1)); ## the ground truth of the simulated data

## Calculate distance matrices
## (here we calculate Euclidean Distance, you can use other distance, e.g,correlation)

## If the data are all continuous values, we recommend the users to perform 
## standard normalization before using SNF, 
## though it is optional depending on the data the users want to use.  
# Data1 = standardNormalization(Data1);
# Data2 = standardNormalization(Data2);

## Calculate the pair-wise distance; 
## If the data is continuous, we recommend to use the function "dist2" as follows 
Dist1 = (dist2(as.matrix(Data1),as.matrix(Data1)))^(1/2)
Dist2 = (dist2(as.matrix(Data2),as.matrix(Data2)))^(1/2)

## next, construct similarity graphs
W1 = affinityMatrix(Dist1, K, alpha)
W2 = affinityMatrix(Dist2, K, alpha)

## next, we fuse all the graphs
## then the overall matrix can be computed by similarity network fusion(SNF):
W = SNF(list(W1,W2), K, T)

## With this unified graph W of size n x n, 
## you can do either spectral clustering or Kernel NMF. 
## If you need help with further clustering, please let us know. 

## You can display clusters in the data by the following function
## where C is the number of clusters.
C = 2   							# number of clusters
group = spectralClustering(W,C); 	# the final subtypes information

## Get a matrix containing the group information 
## for the samples such as the SpectralClustering result and the True label
M_label=cbind(group,truelabel)
colnames(M_label)=c("spectralClustering","TrueLabel")

## ****
## Comments
## rownames(M_label)=names(spectralClustering) To add if the spectralClustering function 
## pass the sample ID as names.
## or rownames(M_label)=rownames(W) Having W with rownames and colmanes 
## with smaple ID would help as well.
## ***

## Use the getColorsForGroups function to assign a color to each group
## NB is more than 8 groups, you will have to input a vector 
## of colors into the getColorsForGroups function
M_label_colors=t(apply(M_label,1,getColorsForGroups))
## or choose you own colors for each label, for example:
M_label_colors=cbind("spectralClustering"=getColorsForGroups(M_label[,"spectralClustering"],
colors=c("blue","green")),"TrueLabel"=getColorsForGroups(M_label[,"TrueLabel"],
colors=c("orange","cyan")))

## Visualize the clusters present in the given similarity matrix 
## as well as some sample information
## In this presentation no clustering method is ran the samples 
## are ordered in function of their group label present in the group arguments
displayClustersWithHeatmap(W, group, M_label_colors[,"spectralClustering"]) 
displayClustersWithHeatmap(W, group, M_label_colors)
</code></pre>

<hr>
<h2 id='dist2'>
Pairwise squared Euclidean distances
</h2><span id='topic+dist2'></span>

<h3>Description</h3>

<p>Computes the squared Euclidean distances between all pairs of data point given
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2(X, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist2_+3A_x">X</code></td>
<td>

<p>A data matrix where each row is a different data point
</p>
</td></tr>
<tr><td><code id="dist2_+3A_c">C</code></td>
<td>

<p>A data matrix where each row is a different data point. If this matrix is the same as X, pairwise distances for all data points are computed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an N x M matrix where N is the number of rows in X and M is the number of rows in M. element (n,m) is the squared Euclidean distance between nth data point in X and mth data point in C
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Calculate distance matrices(here we calculate Euclidean Distance, 
## you can use other distance, e.g. correlation)
Dist1 = dist2(as.matrix(Data1), as.matrix(Data1))
Dist2 = dist2(as.matrix(Data2), as.matrix(Data2))

</code></pre>

<hr>
<h2 id='estimateNumberOfClustersGivenGraph'>
Estimate Number Of Clusters Given Graph
</h2><span id='topic+estimateNumberOfClustersGivenGraph'></span>

<h3>Description</h3>

<p>This function estimates the number of clusters given the two huristics given in the supplementary materials of our nature method paper W is the similarity graph NUMC is a vector which contains the possible choices of number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateNumberOfClustersGivenGraph(W, NUMC=2:5) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateNumberOfClustersGivenGraph_+3A_w">W</code></td>
<td>

<p>List of matrices. Each element of the list is a square, symmetric matrix that shows affinities of the data points from a certain view.
</p>
</td></tr>
<tr><td><code id="estimateNumberOfClustersGivenGraph_+3A_numc">NUMC</code></td>
<td>

<p>A vector which contains the possible choices of number of clusters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>K1 is the estimated best number of clusters according to eigen-gaps
K12 is the estimated SECOND best number of clusters according to eigen-gaps    
K2 is the estimated number of clusters according to rotation cost
K22 is the estimated SECOND number of clusters according to rotation cost
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>References</h3>

<p>B Wang, A Mezlini, F Demir, M Fiume, T Zu, M Brudno, B Haibe-Kains, A Goldenberg (2014) Similarity Network Fusion: a fast and effective method to aggregate multiple data types on a genome wide scale. Nature Methods. Online. Jan 26, 2014  
</p>
<p>Concise description can be found here: 
http://compbio.cs.toronto.edu/SNF/SNF/Software.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First, set all the parameters:
K = 20;  	# number of neighbors, usually (10~30)
alpha = 0.5;  	# hyperparameter, usually (0.3~0.8)
T = 20; 	# Number of Iterations, usually (10~20)

## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Here, the simulation data (SNFdata) has two data types. They are complementary to each other. 
## And two data types have the same number of points. 
## The first half data belongs to the first cluster; the rest belongs to the second cluster.
truelabel = c(matrix(1,100,1),matrix(2,100,1)); ## the ground truth of the simulated data

## Calculate distance matrices
## (here we calculate Euclidean Distance, you can use other distance, e.g,correlation)

## If the data are all continuous values, we recommend the users to perform 
## standard normalization before using SNF, 
## though it is optional depending on the data the users want to use.  
# Data1 = standardNormalization(Data1);
# Data2 = standardNormalization(Data2);



## Calculate the pair-wise distance; 
## If the data is continuous, we recommend to use the function "dist2" as follows 
Dist1 = (dist2(as.matrix(Data1),as.matrix(Data1)))^(1/2)
Dist2 = (dist2(as.matrix(Data2),as.matrix(Data2)))^(1/2)

## next, construct similarity graphs
W1 = affinityMatrix(Dist1, K, alpha)
W2 = affinityMatrix(Dist2, K, alpha)

## These similarity graphs have complementary information about clusters.
displayClusters(W1,truelabel);
displayClusters(W2,truelabel);

## next, we fuse all the graphs
## then the overall matrix can be computed by similarity network fusion(SNF):
W = SNF(list(W1,W2), K, T)

## With this unified graph W of size n x n, 
## you can do either spectral clustering or Kernel NMF. 
## If you need help with further clustering, please let us know. 

## You can display clusters in the data by the following function
## where C is the number of clusters.
C = 2 								# number of clusters
group = spectralClustering(W,C); 	# the final subtypes information
displayClusters(W, group)

## You can get cluster labels for each data point by spectral clustering
labels = spectralClustering(W, C)

plot(Data1, col=labels, main='Data type 1')
plot(Data2, col=labels, main='Data type 2')

## Here we provide two ways to estimate the number of clusters. Note that,
## these two methods cannot guarantee the accuracy of esstimated number of
## clusters, but just to offer two insights about the datasets.

estimationResult = estimateNumberOfClustersGivenGraph(W, 2:5);
</code></pre>

<hr>
<h2 id='getColorsForGroups'>
Obtaining a vector of colors from a numeric vector of group
</h2><span id='topic+getColorsForGroups'></span>

<h3>Description</h3>

<p>Convert a numeric vector containing group information to a vector of colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColorsForGroups(group, colors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getColorsForGroups_+3A_group">group</code></td>
<td>

<p>A numeric vector containing the groups information such as the result of the spectralClustering function.
</p>
</td></tr>
<tr><td><code id="getColorsForGroups_+3A_colors">colors</code></td>
<td>

<p>a vector of colors to be used for the different groups. If the number of group is &gt; 8, the user will have to use the colors argument and give a vector of colors with length at least equal to the number of groups.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially used to construct a vector or a matrix with colors used as for the ColSideColors argument in the displayClustersWithHeatmap function. See the displayClustersWithHeatmap()'s example.
</p>


<h3>Value</h3>

<p>A character vector of colors, corresponding to the given vector of group, keeping the same order.
</p>


<h3>Author(s)</h3>

<p>Florence Cavalli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
gp=c(rep(1,10),rep(2,4),rep(1,3),rep(3,6))
## Using the default colors
gp_colors=getColorsForGroups(gp)
gp_colors
## Specifying the colors
gp_colors=getColorsForGroups(gp,colors=c("cyan","purple","orange"))
gp_colors

## Example 2: Part of SNF
## First, set all the parameters:
K = 20;    # number of neighbors, usually (10~30)
alpha = 0.5;    # hyperparameter, usually (0.3~0.8)
T = 20;   # Number of Iterations, usually (10~20)

## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Here, the simulation data (SNFdata) has two data types. They are complementary to each other. 
## And two data types have the same number of points. 
## The first half data belongs to the first cluster; the rest belongs to the second cluster.
truelabel = c(matrix(1,100,1),matrix(2,100,1)); ## the ground truth of the simulated data

## Calculate distance matrices
## (here we calculate Euclidean Distance, you can use other distance, e.g,correlation)

## If the data are all continuous values, we recommend the users to perform 
## standard normalization before using SNF, 
## though it is optional depending on the data the users want to use.  
# Data1 = standardNormalization(Data1);
# Data2 = standardNormalization(Data2);

## Calculate the pair-wise distance; 
## If the data is continuous, we recommend to use the function "dist2" as follows 
Dist1 = dist2(as.matrix(Data1),as.matrix(Data1));
Dist2 = dist2(as.matrix(Data2),as.matrix(Data2));

## next, construct similarity graphs
W1 = affinityMatrix(Dist1, K, alpha)
W2 = affinityMatrix(Dist2, K, alpha)

## next, we fuse all the graphs
## then the overall matrix can be computed by similarity network fusion(SNF):
W = SNF(list(W1,W2), K, T)

## With this unified graph W of size n x n, 
## you can do either spectral clustering or Kernel NMF. 
## If you need help with further clustering, please let us know. 

## You can display clusters in the data by the following function
## where C is the number of clusters.
C = 2     						# number of clusters
group = spectralClustering(W,C); 	# the final subtypes information

## Get a matrix containing the group information 
## for the samples such as the SpectralClustering result and the True label
M_label=cbind(group,truelabel)
colnames(M_label)=c("spectralClustering","TrueLabel")

## ****
## Comments
## rownames(M_label)=names(spectralClustering) To add if the spectralClustering function 
## pass the sample ID as names.
## or rownames(M_label)=rownames(W) Having W with rownames and colmanes 
## with smaple ID would help as well.
## ***

## Use the getColorsForGroups function to assign a color to each group
## NB is more than 8 groups, you will have to input a vector 
## of colors into the getColorsForGroups function
M_label_colors=t(apply(M_label,1,getColorsForGroups))
## or choose you own colors for each label, for example:
M_label_colors=cbind("spectralClustering"=getColorsForGroups(M_label[,"spectralClustering"],
colors=c("blue","green")),"TrueLabel"=getColorsForGroups(M_label[,"TrueLabel"],
colors=c("orange","cyan")))

## Visualize the clusters present in the given similarity matrix 
## as well as some sample information
## In this presentation no clustering method is ran the samples 
## are ordered in function of their group label present in the group arguments
displayClustersWithHeatmap(W, group, M_label_colors[,"spectralClustering"]) 
displayClustersWithHeatmap(W, group, M_label_colors)
</code></pre>

<hr>
<h2 id='groupPredict'>
Group Predict
</h2><span id='topic+groupPredict'></span>

<h3>Description</h3>

<p>This function is used to predict the subtype of new patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupPredict(train, test, groups, K=20, alpha=0.5, t=20, method=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupPredict_+3A_train">train</code></td>
<td>

<p>Training data. Has the same number of view and columns as test data. 
</p>
</td></tr>
<tr><td><code id="groupPredict_+3A_test">test</code></td>
<td>

<p>Test data. Has the same number of view and columns as training data. 
</p>
</td></tr>
<tr><td><code id="groupPredict_+3A_groups">groups</code></td>
<td>

<p>The label for the training data.
</p>
</td></tr>
<tr><td><code id="groupPredict_+3A_k">K</code></td>
<td>

<p>Number of neighbors.
</p>
</td></tr>
<tr><td><code id="groupPredict_+3A_alpha">alpha</code></td>
<td>

<p>Hyperparameter used in constructing similarity network.
</p>
</td></tr>
<tr><td><code id="groupPredict_+3A_t">t</code></td>
<td>

<p>Number of iterations.
</p>
</td></tr>
<tr><td><code id="groupPredict_+3A_method">method</code></td>
<td>

<p>A indicator of which method to use to predict the label. method = 0 means to use local and global consistency; method = 1 means to use label propagation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the prediction of which group the test data belongs to. 
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Provide an example of predicting the new labels with label propagation

# Load views into list "dataL" and the cluster assignment into vector "label"
data(dataL)
data(label)

# Create the training and test data
n = floor(0.8*length(label)) # number of training cases
trainSample = sample.int(length(label), n)
train = lapply(dataL, function(x) x[trainSample, ]) # Use the first 150 samples for training
test = lapply(dataL, function(x) x[-trainSample, ]) # Test the rest of the data set
groups = label[trainSample]

# Set the other
K = 20
alpha = 0.5
t = 20
method = TRUE

# Apply the prediction function to the data
newLabel = groupPredict(train,test,groups,K,alpha,t,method)

# Compare the prediction accuracy
accuracy = sum(label[-trainSample] == newLabel[-c(1:n)])/(length(label) - n)

</code></pre>

<hr>
<h2 id='heatmapPlus'>
Display heatmap for clusters 
</h2><span id='topic+heatmapPlus'></span>

<h3>Description</h3>

<p>Visualize clusters with heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapPlus(x, 
Rowv = NULL, 
Colv = if (symm) "Rowv" else NULL, 
distfun = dist, 
hclustfun = hclust, 
reorderfun = function(d, w) reorder(d, w), 
add.expr, 
symm = FALSE, 
revC = identical(Colv, "Rowv"), 
scale = c("row", "column", "none"), 
na.rm = TRUE, 
margins = c(5, 5), 
ColSideColors, 
RowSideColors, 
cexRow = 0.2 + 1/log10(nr), 
cexCol = 0.2 + 1/log10(nc), 
labRow = NULL, 
labCol = NULL, 
main = NULL, 
xlab = NULL, 
ylab = NULL, 
keep.dendro = FALSE, 
verbose = getOption("verbose"), ...)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmapPlus_+3A_x">x</code></td>
<td>

<p>numeric matrix of the values to be plotted.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_rowv">Rowv</code></td>
<td>

<p>determines if and how the row dendrogram should be computed and reordered. Either a dendrogram or a vector of values used to reorder the row dendrogram or NA to suppress any row dendrogram (and reordering) or by default, NULL.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_colv">Colv</code></td>
<td>

<p>determines if and how the column dendrogram should be reordered. Has the same options as the Rowv argument above and additionally when x is a square matrix, Colv = &quot;Rowv&quot; means that columns should be treated identically to the rows.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_distfun">distfun</code></td>
<td>

<p>function used to compute the distance (dissimilarity) between both rows and columns. Defaults to dist.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_hclustfun">hclustfun</code></td>
<td>

<p>function used to compute the hierarchical clustering when Rowv or Colv are not dendrograms. Defaults to hclust.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_reorderfun">reorderfun</code></td>
<td>

<p>function(d,w) of dendrogram and weights for reordering the row and column dendrograms. The default uses reorder.dendrogram.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_add.expr">add.expr</code></td>
<td>

<p>expression that will be evaluated after the call to image. Can be used to add components to the plot.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_symm">symm</code></td>
<td>

<p>logical indicating if x should be treated symmetrically; can only be true when x is a square matrix.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_revc">revC</code></td>
<td>

<p>logical indicating if the column order should be reversed for plotting, such that e.g., for the symmetric case, the symmetry axis is as usual.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_scale">scale</code></td>
<td>

<p>character indicating if the values should be centered and scaled in either the row direction or the column direction, or none. The default is &quot;row&quot; if symm false, and &quot;none&quot; otherwise. 
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_na.rm">na.rm</code></td>
<td>

<p>logical indicating whether NA's should be removed.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_margins">margins</code></td>
<td>

<p>numeric vector of length 2 containing the margins (see par(mar= *)) for column and row names, respectively.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_colsidecolors">ColSideColors</code></td>
<td>

<p>(optional) character matrix with number of rows matching number of rows in x. Each column is plotted as a row similar to heatmap()'s ColSideColors. colnames() will be used for labels if present.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_rowsidecolors">RowSideColors</code></td>
<td>

<p>(optional)character matrix with number of rows matching number of columns in x. Each column is plotted as a row similar to heatmap()'s RowSideColors. colnames() will be used for labels if present.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_cexrow">cexRow</code></td>
<td>

<p>positive numbers, used as cex.axis in for the row axis labeling. The defaults currently only use number of rows.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_cexcol">cexCol</code></td>
<td>

<p>positive numbers, used as cex.axis in for the column axis labeling. The defaults currently only use number of columns.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_labrow">labRow</code></td>
<td>

<p>character vectors with row labels to use; these default to rownames(x).
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_labcol">labCol</code></td>
<td>

<p>character vectors with column labels to use; these default to colnames(x). 
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_main">main</code></td>
<td>

<p>y-axis titles; defaults to none.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_xlab">xlab</code></td>
<td>

<p>x-axis titles; defaults to none.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_ylab">ylab</code></td>
<td>

<p>main titles; defaults to none.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_keep.dendro">keep.dendro</code></td>
<td>

<p>logical indicating if the dendrogram(s) should be kept as part of the result (when Rowv and/or Colv are not NA).
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_verbose">verbose</code></td>
<td>

<p>logical indicating if information should be printed.
</p>
</td></tr>
<tr><td><code id="heatmapPlus_+3A_...">...</code></td>
<td>

<p>additional arguments passed on to image, e.g., col specifying the colors
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, a list with components
</p>
<p>rowInd
row index permutation vector as returned by order.dendrogram.
</p>
<p>colInd
column index permutation vector.
</p>
<p>Rowv
the row dendrogram; only if input Rowv was not NA and keep.dendro is true.
</p>
<p>Colv
the column dendrogram; only if input Colv was not NA and keep.dendro is true.
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  z = matrix(rnorm(30),nrow=5,ncol=6);
  rlab = matrix(as.character(c(1:5,2:6,3:7,4:8)),nrow=5,ncol=4);
  clab = matrix(as.character(c(1:6,6:1)),nrow=6,ncol=2);
  colnames(rlab) = LETTERS[1:dim(rlab)[2]];
  colnames(clab) = 1:dim(clab)[2];
  heatmapPlus(z,ColSideColors=clab,RowSideColors=rlab);
</code></pre>

<hr>
<h2 id='label'>
Labels for dataL dataset
</h2><span id='topic+label'></span>

<h3>Description</h3>

<p>The ground truth for dataL dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(label)
</code></pre>


<h3>Format</h3>

<p>The format is:
int [1:600] 1 1 1 1 1 1 1 1 1 1 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(label)
</code></pre>

<hr>
<h2 id='plotAlluvial'>
Plot Alluvial 
</h2><span id='topic+plotAlluvial'></span>

<h3>Description</h3>

<p>This function plots an alluvial (Parallel coordinate plot) of sample clusterings for a specified number of clusters. Samples can be coloured by providing a vector of colours, allowing for the visualization of sample properties over a range of clustering number choices.
</p>
<p>*This is a wrapper function calling the <a href="https://CRAN.R-project.org/package=alluvial">Alluvial Package</a> (Bojanowski M. &amp; Edwards R)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAlluvial(W, clust.range, color.vect)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotAlluvial_+3A_w">W</code></td>
<td>

<p>Affinity matrix of dimension n.samples by n.samples
</p>
</td></tr>
<tr><td><code id="plotAlluvial_+3A_clust.range">clust.range</code></td>
<td>

<p>Integer vector specifying the number of clusters for each clustering
</p>
</td></tr>
<tr><td><code id="plotAlluvial_+3A_color.vect">color.vect</code></td>
<td>

<p>A vector of color's of length n.samples to colour the samples
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots an alluvial plot for range of clustering choices. 
</p>


<h3>Author(s)</h3>

<p>Daniel Cole
</p>


<h3>See Also</h3>

<p>More information on <a href="https://CRAN.R-project.org/package=alluvial">Alluvial Package</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>K &lt;- 20
alpha &lt;- 0.5
iter &lt;- 20

data(Data1)
data(Data2)

dist1 &lt;- (dist2(as.matrix(Data1), as.matrix(Data1)))^(1/2)
dist2 &lt;- (dist2(as.matrix(Data2), as.matrix(Data2)))^(1/2)

W1 &lt;- affinityMatrix(dist1, K, alpha)
W2 &lt;- affinityMatrix(dist2, K, alpha)

W &lt;- SNF(list(W1, W2), K, iter)

#Plots the alluvial with no colouring
plotAlluvial(W, 2:5)

#Change the colour of all samples a single colour
plotAlluvial(W, 2:5, col="red")

colour.breaks &lt;- 30
#This will assign each sample to one of colour.breaks colour bins between green and red.
colFunc &lt;- colorRampPalette(c("green", "red"))
colours &lt;- colFunc(colour.breaks)[as.numeric(cut(Data1[,1],breaks=colour.breaks))]
plotAlluvial(W, 2:5, col=colours)
</code></pre>

<hr>
<h2 id='rankFeaturesByNMI'>
Rank Features by NMI
</h2><span id='topic+rankFeaturesByNMI'></span>

<h3>Description</h3>

<p>Ranks each features by NMI based on their clustering assingments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankFeaturesByNMI(data, W) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankFeaturesByNMI_+3A_data">data</code></td>
<td>

<p>List containing all the data types.
</p>
</td></tr>
<tr><td><code id="rankFeaturesByNMI_+3A_w">W</code></td>
<td>

<p>Target Matrix for which the NMI is calculated against.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the NMI and rank based on NMI for each feature. 
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First, set all the parameters:
K = 20;		# number of neighbors, usually (10~30)
alpha = 0.5;  	# hyperparameter, usually (0.3~0.8)
T = 20; 	# Number of Iterations, usually (10~20)

## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Here, the simulation data (SNFdata) has two data types. They are complementary to each other. 
## And two data types have the same number of points. 
## The first half data belongs to the first cluster; the rest belongs to the second cluster.
truelabel = c(matrix(1,100,1),matrix(2,100,1)); ## the ground truth of the simulated data

## Calculate distance matrices
## (here we calculate Euclidean Distance, you can use other distance, e.g,correlation)

## If the data are all continuous values, we recommend the users to perform 
## standard normalization before using SNF, 
## though it is optional depending on the data the users want to use.  
# Data1 = standardNormalization(Data1);
# Data2 = standardNormalization(Data2);



## Calculate the pair-wise distance; 
## If the data is continuous, we recommend to use the function "dist2" as follows 
Dist1 = (dist2(as.matrix(Data1),as.matrix(Data1)))^(1/2)
Dist2 = (dist2(as.matrix(Data2),as.matrix(Data2)))^(1/2)

## next, construct similarity graphs
W1 = affinityMatrix(Dist1, K, alpha)
W2 = affinityMatrix(Dist2, K, alpha)

## next, we fuse all the graphs
## then the overall matrix can be computed by similarity network fusion(SNF):
W = SNF(list(W1,W2), K, T)

NMI_scores &lt;- rankFeaturesByNMI(list(Data1, Data2), W)

</code></pre>

<hr>
<h2 id='SNF'>
Similarity Network Fusion
</h2><span id='topic+SNF'></span>

<h3>Description</h3>

<p>Similarity Network Fusion takes multiple views of a network and fuses them together to construct an overall status matrix. The input to our algorithm can be feature vectors, pairwise distances, or pairwise similarities. The learned status matrix can then be used for retrieval, clustering, and classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SNF(Wall, K, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SNF_+3A_wall">Wall</code></td>
<td>

<p>List of matrices. Each element of the list is a square, symmetric matrix that shows affinities of the data points from a certain view.
</p>
</td></tr>
<tr><td><code id="SNF_+3A_k">K</code></td>
<td>

<p>Number of neighbors in K-nearest neighbors part of the algorithm.
</p>
</td></tr>
<tr><td><code id="SNF_+3A_t">t</code></td>
<td>

<p>Number of iterations for the diffusion process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>W is the overall status matrix derived
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>References</h3>

<p>B Wang, A Mezlini, F Demir, M Fiume, T Zu, M Brudno, B Haibe-Kains, A Goldenberg (2014) Similarity Network Fusion: a fast and effective method to aggregate multiple data types on a genome wide scale. Nature Methods. Online. Jan 26, 2014  
</p>
<p>Concise description can be found here: 
http://compbio.cs.toronto.edu/SNF/SNF/Software.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First, set all the parameters:
K = 20;		# number of neighbors, usually (10~30)
alpha = 0.5;  	# hyperparameter, usually (0.3~0.8)
T = 20; 	# Number of Iterations, usually (10~20)

## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Here, the simulation data (SNFdata) has two data types. They are complementary to each other. 
## And two data types have the same number of points. 
## The first half data belongs to the first cluster; the rest belongs to the second cluster.
truelabel = c(matrix(1,100,1),matrix(2,100,1)); ## the ground truth of the simulated data

## Calculate distance matrices
## (here we calculate Euclidean Distance, you can use other distance, e.g,correlation)

## If the data are all continuous values, we recommend the users to perform 
## standard normalization before using SNF, 
## though it is optional depending on the data the users want to use.  
# Data1 = standardNormalization(Data1);
# Data2 = standardNormalization(Data2);



## Calculate the pair-wise distance; 
## If the data is continuous, we recommend to use the function "dist2" as follows 
Dist1 = (dist2(as.matrix(Data1),as.matrix(Data1)))^(1/2)
Dist2 = (dist2(as.matrix(Data2),as.matrix(Data2)))^(1/2)

## next, construct similarity graphs
W1 = affinityMatrix(Dist1, K, alpha)
W2 = affinityMatrix(Dist2, K, alpha)

## These similarity graphs have complementary information about clusters.
displayClusters(W1,truelabel);
displayClusters(W2,truelabel);

## next, we fuse all the graphs
## then the overall matrix can be computed by similarity network fusion(SNF):
W = SNF(list(W1,W2), K, T)

## With this unified graph W of size n x n, 
## you can do either spectral clustering or Kernel NMF. 
## If you need help with further clustering, please let us know. 

## You can display clusters in the data by the following function
## where C is the number of clusters.
C = 2 								# number of clusters
group = spectralClustering(W,C); 	# the final subtypes information
displayClusters(W, group)

## You can get cluster labels for each data point by spectral clustering
labels = spectralClustering(W, C)

plot(Data1, col=labels, main='Data type 1')
plot(Data2, col=labels, main='Data type 2')
</code></pre>

<hr>
<h2 id='SNFtool-internal'>Internal SNFtool Functions</h2><span id='topic+.csPrediction'></span><span id='topic+.discretisation'></span><span id='topic+.discretisationEigenVectorData'></span><span id='topic+.dominateset'></span><span id='topic+.mutualInformation'></span><span id='topic+.entropy'></span>

<h3>Description</h3>

 
<p>Internal SNFtool functions 
</p>


<h3>Details</h3>

 
<p>These are not to be called by the user. 
</p>

<hr>
<h2 id='spectralClustering'>
Spectral Clustering
</h2><span id='topic+spectralClustering'></span>

<h3>Description</h3>

<p>Perform the famous spectral clustering algorithms. There are three variants. The default one is the third type. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralClustering(affinity, K, type = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectralClustering_+3A_affinity">affinity</code></td>
<td>

<p>Similarity matrix
</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_k">K</code></td>
<td>

<p>Number of clusters
</p>
</td></tr>
<tr><td><code id="spectralClustering_+3A_type">type</code></td>
<td>

<p>The variants of spectral clustering to use.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consisting of cluster labels of each sample.
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First, set all the parameters:
K = 20;##number of neighbors, usually (10~30)
alpha = 0.5; ##hyperparameter, usually (0.3~0.8)
T = 20; ###Number of Iterations, usually (10~50)

## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

## Calculate distance matrices (here we calculate Euclidean Distance, 
## you can use other distance, e.g. correlation)
Dist1 = (dist2(as.matrix(Data1),as.matrix(Data1)))^(1/2)
Dist2 = (dist2(as.matrix(Data2),as.matrix(Data2)))^(1/2)

## Next, construct similarity graphs
W1 = affinityMatrix(Dist1, K, alpha)
W2 = affinityMatrix(Dist2, K, alpha)

# Next, we fuse all the graphs
# then the overall matrix can be computed by
W = SNF(list(W1,W2), K, T)

## With this unified graph W of size n x n, 
## you can do either spectral clustering or Kernel NMF. 
## If you need help with further clustering, please let us know. 

## You can display clusters in the data by the following function
## where C is the number of clusters.
C = 2

## You can get cluster labels for each data point by spectral clustering
labels = spectralClustering(W, C)
</code></pre>

<hr>
<h2 id='standardNormalization'>
Standard Normalization
</h2><span id='topic+standardNormalization'></span>

<h3>Description</h3>

<p>Normalize each column of the input data to have mean 0 and standard deviation 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardNormalization(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardNormalization_+3A_x">x</code></td>
<td>

<p>The unnormalized data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data normalized. 
</p>


<h3>Author(s)</h3>

<p>Dr. Anna Goldenberg, Bo Wang, Aziz Mezlini, Feyyaz Demir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data1 is of size n x d_1, 
## where n is the number of patients, d_1 is the number of genes, 
## Data2 is of size n x d_2, 
## where n is the number of patients, d_2 is the number of methylation
data(Data1)
data(Data2)

Data1 = standardNormalization(Data1);
Data2 = standardNormalization(Data2);
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
