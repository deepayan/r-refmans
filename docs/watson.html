<!DOCTYPE html><html><head><title>Help for package watson</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {watson}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#diam_clus'><p>Diametrical clustering</p></a></li>
<li><a href='#rmwat'><p>Random Sampling from a Mixture of Watson Distributions</p></a></li>
<li><a href='#watson'><p>Fit Mixtures of Watson Distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting and Simulating Mixtures of Watson Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lukas Sablica &lt;lsablica@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for fitting and simulating mixtures of Watson distributions. 
             The random sampling scheme of the package offers two sampling 
             algorithms that are based of the results of Sablica, Hornik and Leydold (2022)
             <a href="https://research.wu.ac.at/en/publications/random-sampling-from-the-watson-distribution">https://research.wu.ac.at/en/publications/random-sampling-from-the-watson-distribution</a>.
             What is more, the package offers a smart tool to combine these two methods,
             and based on the selected parameters, it approximates the relative sampling
             speed for both methods and picks the faster one. In addition, the package
             offers a fitting function for the mixtures of Watson distribution, that
             uses the expectation-maximization (EM) algorithm. Special features are
             the possibility to use multiple variants of the E-step and M-step,
             sparse matrices for the data representation and state of the art methods
             for numerical evaluation of needed special functions using the results of
             Sablica and Hornik (2022) <a href="https://www.ams.org/journals/mcom/2022-91-334/S0025-5718-2021-03690-X/">https://www.ams.org/journals/mcom/2022-91-334/S0025-5718-2021-03690-X/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18), Tinflex (&ge; 1.8)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, Tinflex</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-01 09:07:18 UTC; sablica</td>
</tr>
<tr>
<td>Author:</td>
<td>Lukas Sablica <a href="https://orcid.org/0000-0001-9166-4563"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Josef Leydold <a href="https://orcid.org/0000-0002-9076-4893"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Gerard Jungman [ctb, cph] (Author and copyright holder of included GNU
    GSL code),
  Brian Gough [ctb, cph] (Author and copyright holder of included GNU GSL
    code)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-01 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='diam_clus'>Diametrical clustering</h2><span id='topic+diam_clus'></span>

<h3>Description</h3>

<p><code>diam_clus</code> clusters axial data on sphere using  the algorithm proposed in Dhillon et al. (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diam_clus(x, k, niter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diam_clus_+3A_x">x</code></td>
<td>
<p>a numeric data matrix, with rows corresponding to observations. Can be a dense matrix,
or any of the supported sparse matrices from <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> package by <code><a href="Rcpp.html#topic+Rcpp">Rcpp</a></code>.</p>
</td></tr>
<tr><td><code id="diam_clus_+3A_k">k</code></td>
<td>
<p>an integer giving the number of mixture components.</p>
</td></tr>
<tr><td><code id="diam_clus_+3A_niter">niter</code></td>
<td>
<p>integer indicating the number of iterations of the diametrical clustering algorithm, default: 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the concentration directions with an attribute &quot;id&quot; defining the classified categories.
</p>


<h3>References</h3>

<p>Inderjit S Dhillon, Edward M Marcotte, and Usman Roshan. Diametrical clustering 
for identifying anti-correlated gene clusters. Bioinformatics, 19(13):1612-1619, 2003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a sample 
a &lt;- rmwat(n = 200, weights = c(0.5,0.5), kappa = c(20, 20),
                        mu = matrix(c(1,1,-1,1),nrow = 2))
## Fit basic model
q &lt;- diam_clus(a, 2)
</code></pre>

<hr>
<h2 id='rmwat'>Random Sampling from a Mixture of Watson Distributions</h2><span id='topic+rmwat'></span>

<h3>Description</h3>

<p><code>rmwat</code> generates a random sample from a mixture of multivariate Watson distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmwat(n, weights, kappa, mu, method = "acg", b = -10, rho = 1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmwat_+3A_n">n</code></td>
<td>
<p>an integer giving the number of samples to draw.</p>
</td></tr>
<tr><td><code id="rmwat_+3A_weights">weights</code></td>
<td>
<p>a numeric vector with non-negative elements giving the mixture probabilities.</p>
</td></tr>
<tr><td><code id="rmwat_+3A_kappa">kappa</code></td>
<td>
<p>a numeric vector giving the kappa parameters of the mixture components.</p>
</td></tr>
<tr><td><code id="rmwat_+3A_mu">mu</code></td>
<td>
<p>a numeric matrix with columns giving the mu parameters of the mixture components.</p>
</td></tr>
<tr><td><code id="rmwat_+3A_method">method</code></td>
<td>
<p>a string indicating whether ACG sampler (<code>method = "acg"</code>), Tinflex sampler (<code>method = "tinflex"</code>) or automatic selection (<code>method = "auto"</code>) of the sampler should be used, default: &quot;acg&quot;.</p>
</td></tr>
<tr><td><code id="rmwat_+3A_b">b</code></td>
<td>
<p>a positive numeric hyper-parameter used in the sampling. If not a positive value is given, optimal choice of b is used, default: -10.</p>
</td></tr>
<tr><td><code id="rmwat_+3A_rho">rho</code></td>
<td>
<p>performance parameter: requested upper bound for ratio of area below hat to area below squeeze (numeric). See <code><a href="Tinflex.html#topic+Tinflex.setup">Tinflex.setup</a></code>, default: 1.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates samples from finite mixtures of Watson distributions,
using methods from Sablica, Hornik and Leydold (2022) <a href="https://research.wu.ac.at/en/publications/random-sampling-from-the-watson-distribution">https://research.wu.ac.at/en/publications/random-sampling-from-the-watson-distribution</a>.
</p>


<h3>Value</h3>

<p>A matrix with rows equal to the generated values.
</p>


<h3>References</h3>

<p>Sablica, Hornik and Leydold (2022). Random Sampling from the Watson Distribution <a href="https://research.wu.ac.at/en/publications/random-sampling-from-the-watson-distribution">https://research.wu.ac.at/en/publications/random-sampling-from-the-watson-distribution</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate from Watson distribution
sample1 &lt;- rmwat(n = 20, weights = 1, kappa = 20, mu = matrix(c(1,1,1),nrow = 3))

## simulate from a mixture of Watson distributions
sample2 &lt;- rmwat(n = 20, weights = c(0.5,0.5), kappa = c(-200,-200),
                            mu = matrix(c(1,1,1,-1,1,1),nrow = 3))
</code></pre>

<hr>
<h2 id='watson'>Fit Mixtures of Watson Distributions</h2><span id='topic+watson'></span>

<h3>Description</h3>

<p><code>watson</code> fits a finite mixture of multivariate Watson distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watson(x, k, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watson_+3A_x">x</code></td>
<td>
<p>a numeric data matrix, with rows corresponding to observations. Can be a dense matrix,
or any of the supported sparse matrices from  <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> package by <code><a href="Rcpp.html#topic+Rcpp">Rcpp</a></code>.</p>
</td></tr>
<tr><td><code id="watson_+3A_k">k</code></td>
<td>
<p>an integer giving the number of mixture components.</p>
</td></tr>
<tr><td><code id="watson_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See Details.</p>
</td></tr>
<tr><td><code id="watson_+3A_...">...</code></td>
<td>
<p>a list of control parameters (overriding those specified in control).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>watson returns an object of class &quot;watfit&quot; representing the fitted mixture of Watson
distributions model. Available methods for such objects include <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="base.html#topic+print">print</a></code> and <code><a href="stats.html#topic+predict">predict</a></code>.
<code><a href="stats.html#topic+predict">predict</a></code> has an extra type argument with possible values <code>"class_ids"</code> (default) and <code>"memberships"</code>
for indicating hard or soft prediction, respectively.
</p>
<p>The mixture of Watson distributions is fitted using EM variants as specified by control
option E (specifying the E-step employed), with possible values &quot;softmax&quot; (default), &quot;hardmax&quot; or
&quot;stochmax&quot;. For &quot;stochmax&quot;, class assignments are drawn from the posteriors for each observation in the E-step as
outlined as SEM in Celeux and Govaert (1992). The stopping criterion for this algorithm is by default
changed to not check for convergence (logical control option converge), but to return the parameters with
the maximum likelihood encountered.
</p>
<p>In the M-step, the parameters of the respective component distributions
are estimated via maximum likelihood, which is accomplished by solving the equation
</p>
<p style="text-align: center;"><code class="reqn">g(\alpha,\beta, \kappa)=r,</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">0&lt;\alpha&lt;\beta,  \  0\leq r\leq 1</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">g(\alpha, \beta, \kappa) =  (\alpha/\beta)M(\alpha+1, \beta+1,  \kappa)/M(\alpha, \beta,  \kappa),</code>
</p>
<p> with M being the Kummer's function.
Via control argument M, one can specify how to (approximately) solve these equations.
The possible methods are:
</p>
<p>&quot;Sra_2007&quot;
uses the approximation of Sra (2007).
</p>
<p>&quot;BBG&quot;
uses the approximation of Bijral et al. (2007), without the correction term.
</p>
<p>&quot;BBG_c&quot;
uses the approximation of Bijral et al. (2007), with the correction term.
</p>
<p>&quot;Sra_Karp_2013&quot;
uses the bounds derived in Sra and Karp (2013), with the decision rule .
</p>
<p>&quot;bisection&quot;
uses a bisection to solve the problem using evaluation proposed in Writeup1 (2018).
</p>
<p>&quot;newton&quot;
uses a bracketet type of Neton algorithm to solve the problem using evaluation proposed in Writeup1 (2018). (Default.)
</p>
<p>&quot;lognewton&quot;
uses a bracketet type of Neton algorithm to solve the problem <code class="reqn">log(g((\alpha, \beta, \kappa)) = log(r)</code>
using evaluation proposed in Writeup1 (2018).
</p>
<p>Additional control parameters are as follows.
</p>
<p>maxiter
an integer giving the maximal number of EM iterations to be performed, default: 100.
</p>
<p>reltol
the minimum relative improvement of the objective function per iteration. If improvement is less, the EM
algorithm will stop under the assumption that no further significant improvement can be made, defaults
to sqrt(.Machine$double.eps).
</p>
<p>ids
either a vector of class memberships or TRUE which implies that the class memberships are obtained from
the attribute named &quot;id&quot; of the input data; these class memberships are used for initializing the EM
algorithm and the algorithm is stopped after the first iteration.
</p>
<p>init_iter
a numeric vector setting the number of diametrical clustering iterations to do, before the EM starts, default: 0.
</p>
<p>start
a specification of the starting values to be employed. Can be a list of matrices giving the memberships
of objects to components. This information is combined with the <code>init_iter</code> parameter and together form
the initialization procedure. If nothing is given, the starting values are drwan randomly.
</p>
<p>If several starting values are specified, the EM algorithm is performed individually to each starting
value, and the best solution found is returned.
</p>
<p>nruns
an integer giving the number of EM runs to be performed. Default: 1. Only used if start is not given.
</p>
<p>minweight
a numeric indicating the minimum prior probability. Components falling below this threshold are removed
during the iteration. If is greater than 1, the value is taken as the minimal number of observations in a component, default: 0 if
E = &quot;softmax&quot; and 2 if other type of E-method is used .
</p>
<p>converge
a logical, if TRUE the EM algorithm is stopped if the reltol criterion is met and the current parameter
estimate is returned. If FALSE the EM algorithm is run for maxiter iterations and the parametrizations
with the maximum likelihood encountered during the EM algorithm is returned. Default: TRUE, changed to
FALSE if E=&quot;stochmax&quot;.
</p>
<p>N
an integer indicating number of iteration used when the Kummer function is approximate, default: 30.
</p>
<p>verbose
a logical indicating whether to provide some output on algorithmic progress, default: FALSE.
</p>


<h3>Value</h3>

<p>An object of class &quot;watfit&quot; representing the fitted mixture, which is a list containing the fitted
weights, concentrations parameters (kappa), concentrations directions (mu) and further metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a sample with two orthogonal circles (negative kappas)
a &lt;- rmwat(n = 200, weights = c(0.5,0.5), kappa = c(-200,-200),
                        mu = matrix(c(1,1,1,-1,1,1),nrow = 3))
## Fit basic model
q &lt;- watson(a, 2)
## Fit the models, giving the true categories
q &lt;- watson(a, 2, ids=TRUE)
## Fit a model with hard-assignment, and 50 runs
q &lt;- watson(a, 2, E = "hard", nruns = 50)
## Print details
q
## Extract coefficients
coef(q)
## Calculate likelihood for new data
a2 &lt;- rmwat(n = 20, weights = c(0.5,0.5), kappa = c(-200,-200),
                        mu = matrix(c(1,1,1,-1,1,1),nrow = 3))
logLik(q, a2)
## Compare the fitted classes to the true ones:
table(True = attr(a, "id"), Fitted = predict(q))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
