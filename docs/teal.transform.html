<!DOCTYPE html><html><head><title>Help for package teal.transform</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {teal.transform}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#teal.transform-package'><p><code>teal.transform</code>: Functions for extracting and merging data in the <code>teal</code> framework</p></a></li>
<li><a href='#add_no_selected_choices'><p>Add empty choice to choices selected</p></a></li>
<li><a href='#all_choices'><p>Bare constructor for <code>all_choices</code> object</p></a></li>
<li><a href='#are_needed_keys_provided'><p>Checks whether the provided slices have the corresponding join keys</p></a></li>
<li><a href='#call_check_parse_varname'><p>Checks <code>varname</code> argument and convert to call</p></a></li>
<li><a href='#call_condition_choice'><p>Choices condition call</p></a></li>
<li><a href='#call_condition_logical'><p><code>logical</code> variable condition call</p></a></li>
<li><a href='#call_condition_range'><p><code>numeric</code> range condition call</p></a></li>
<li><a href='#call_condition_range_date'><p><code>Date</code> range condition call</p></a></li>
<li><a href='#call_condition_range_posixct'><p><code>POSIXct</code> range condition call</p></a></li>
<li><a href='#call_extract_array'><p>Get call to subset and select array</p></a></li>
<li><a href='#call_extract_list'><p>Compose extract call with <code>$</code> operator</p></a></li>
<li><a href='#call_extract_matrix'><p>Get call to subset and select matrix</p></a></li>
<li><a href='#call_with_colon'><p>Create a call using a function in a given namespace</p></a></li>
<li><a href='#calls_combine_by'><p>Combine calls by operator</p></a></li>
<li><a href='#check_data_extract_spec'><p>Check data extract specification</p></a></li>
<li><a href='#check_data_extract_spec_react'><p>Function to check data_extract_specs</p></a></li>
<li><a href='#check_data_merge_selectors'><p>Validate data_extracts in merge_datasets</p></a></li>
<li><a href='#check_merge_function'><p>Check if the merge function is valid</p></a></li>
<li><a href='#check_no_multiple_selection'><p>Checks that the <code>extract_input</code> specification does not allow multiple</p>
selection</a></li>
<li><a href='#check_selector'><p>Check selector</p></a></li>
<li><a href='#check_selector_dataname'><p>Check selector <code>dataname</code> element</p></a></li>
<li><a href='#check_selector_filters'><p>Check selector filters element</p></a></li>
<li><a href='#check_selector_internal_id'><p>Check selector internal_id element</p></a></li>
<li><a href='#check_selector_keys'><p>Check selector keys element</p></a></li>
<li><a href='#check_selector_reshape'><p>Check selector reshape element</p></a></li>
<li><a href='#check_selector_select'><p>Check selector select element</p></a></li>
<li><a href='#choices_labeled'><p>Set &quot;<code style="white-space: pre;">&#8288;&lt;choice&gt;:&lt;label&gt;&#8288;</code>&quot; type of names</p></a></li>
<li><a href='#choices_selected'><p>Choices selected</p></a></li>
<li><a href='#compose_and_enable_validators'><p>Function to compose <code>validators</code> from <code>data_extract_multiple_srv</code></p></a></li>
<li><a href='#cond_data_extract_single_ui'><p>Creates a panel that displays (with filter and column selection)</p>
conditionally on <code>input[ns("dataset")] == dataname</code></a></li>
<li><a href='#convert_teal_data'><p>Ensures datasets is a list of reactive expression</p></a></li>
<li><a href='#data_extract_filter_srv'><p>Handles events emitted from the UI generated by <code>data_extract_filter_ui</code></p></a></li>
<li><a href='#data_extract_filter_ui'><p>Returns a <code>shiny.tag</code> object with the UI for a <code>filter_spec</code> object</p></a></li>
<li><a href='#data_extract_multiple_srv'><p>Creates a named list of <code>data_extract_srv</code> output</p></a></li>
<li><a href='#data_extract_read_srv'><p>Returns a reactive list with values read from the inputs of <code>data_extract_spec</code></p></a></li>
<li><a href='#data_extract_select_ui'><p>Returns a <code>shiny.tag.list</code> object with the UI for a <code>select_spec</code> object</p></a></li>
<li><a href='#data_extract_single_srv'><p>The server function for a single <code>data_extract_spec</code> object</p></a></li>
<li><a href='#data_extract_single_ui'><p>Returns a <code>shiny.tag</code> with the UI elements for a <code>data_extract_spec</code></p></a></li>
<li><a href='#data_extract_spec'><p>Data extract input for <code>teal</code> modules</p></a></li>
<li><a href='#data_extract_srv'><p>Extraction of the selector(s) details</p></a></li>
<li><a href='#data_extract_ui'><p><code>teal</code> data extraction module user-interface</p></a></li>
<li><a href='#datanames_input'><p>Help text with available datasets input</p></a></li>
<li><a href='#extract_choices_labels'><p>Extract labels from choices basing on attributes and names</p></a></li>
<li><a href='#filter_spec'><p>Data extract filter specification</p></a></li>
<li><a href='#filter_spec_internal'><p>Data extract dynamic filter specification</p></a></li>
<li><a href='#format_data_extract'><p>Formatting data extracts</p></a></li>
<li><a href='#get_anl_relabel_call'><p>Gets the relabel call</p></a></li>
<li><a href='#get_dataset_prefixed_col_names'><p>Returns non-key column names from data</p></a></li>
<li><a href='#get_dplyr_call'><p>Parses filter, select, rename and reshape call</p></a></li>
<li><a href='#get_dplyr_call_data'><p>Aggregates data extract selectors</p></a></li>
<li><a href='#get_dropped_filters'><p>Names of filtered-out filters dropped from selection</p></a></li>
<li><a href='#get_extract_datanames'><p>Gets names of the datasets from a list of <code>data_extract_spec</code> objects</p></a></li>
<li><a href='#get_filter_call'><p>Build a <code>dplyr</code> filter call</p></a></li>
<li><a href='#get_initial_filter_values'><p>Returns the initial values for the <code>vals</code> widget of a <code>filter_spec</code> object</p></a></li>
<li><a href='#get_merge_call'><p>Get merge call from a list of selectors</p></a></li>
<li><a href='#get_merge_key_grid'><p>Gets merge key pair list from keys list</p></a></li>
<li><a href='#get_merge_key_i'><p>Gets keys needed for join call of two selectors</p></a></li>
<li><a href='#get_merge_key_pair'><p>Gets keys vector from keys list</p></a></li>
<li><a href='#get_pivot_longer_col'><p>Get pivot longer  columns</p></a></li>
<li><a href='#get_relabel_call'><p>Create relabel call from named character</p></a></li>
<li><a href='#get_relabel_cols'><p>Get columns to relabel</p></a></li>
<li><a href='#get_rename_call'><p>Returns <code>dplyr</code> rename call</p></a></li>
<li><a href='#get_reshape_call'><p>Returns <code>dplyr</code> reshape call</p></a></li>
<li><a href='#get_reshape_unite_col'><p>Get unite columns</p></a></li>
<li><a href='#get_reshape_unite_vals'><p>Get unite columns values</p></a></li>
<li><a href='#get_select_call'><p>Parse <code>dplyr</code> select call</p></a></li>
<li><a href='#id_for_dataset'><p>Generate id for dataset</p></a></li>
<li><a href='#include_css_files'><p>Include <code>CSS</code> files from <code style="white-space: pre;">&#8288;/inst/css/&#8288;</code> package directory to application header</p></a></li>
<li><a href='#is_single_dataset'><p>Verify uniform dataset source across data extract specification</p></a></li>
<li><a href='#list_extract_spec'><p>Make sure that the extract specification is in list format</p></a></li>
<li><a href='#merge_datasets'><p>Merge the datasets on the keys</p></a></li>
<li><a href='#merge_expression_module'><p>Merge expression module</p></a></li>
<li><a href='#merge_expression_srv'><p>Data merge module server</p></a></li>
<li><a href='#merge_selectors'><p>Merge selectors when <code>dataname</code>, <code>reshape</code>, <code>filters</code> and <code>keys</code> entries are identical</p></a></li>
<li><a href='#no_selected_as_NULL'><p>Check select choices for no choice made</p></a></li>
<li><a href='#parse_merge_key_i'><p>Parses merge keys</p></a></li>
<li><a href='#Queue'><p>R6 Class - A First-In-First-Out Abstract Data Type</p></a></li>
<li><a href='#rADAE'><p>Random adverse events</p></a></li>
<li><a href='#rADLB'><p>Random lab analysis</p></a></li>
<li><a href='#rADRS'><p>Random response</p></a></li>
<li><a href='#rADSL'><p>Random patient listing</p></a></li>
<li><a href='#rADTTE'><p>Random time to event analysis dataset</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#resolve'><p>Resolve delayed inputs by evaluating the code within the provided datasets</p></a></li>
<li><a href='#resolve_delayed'><p>Resolve delayed inputs by evaluating the code within the provided datasets</p></a></li>
<li><a href='#resolve_delayed_expr'><p>Resolve expression after delayed data are loaded</p></a></li>
<li><a href='#select_spec'><p>Column selection input specification</p></a></li>
<li><a href='#split_by_sep'><p>Split by separator (matched exactly)</p></a></li>
<li><a href='#validate_keys_sufficient'><p>Validates whether the provided keys are sufficient to merge the datasets slices</p></a></li>
<li><a href='#value_choices'><p>Value labeling and filtering based on variable relationship</p></a></li>
<li><a href='#variable_choices'><p>Variable label extraction and custom selection from data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functions for Extracting and Merging Data in the 'teal'
Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-16</td>
</tr>
<tr>
<td>Description:</td>
<td>A standardized user interface for column selection, that
    facilitates dataset merging in 'teal' framework.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://insightsengineering.github.io/teal.transform/">https://insightsengineering.github.io/teal.transform/</a>,
<a href="https://github.com/insightsengineering/teal.transform/">https://github.com/insightsengineering/teal.transform/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/insightsengineering/teal.transform/issues">https://github.com/insightsengineering/teal.transform/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.1.0), dplyr (&ge; 1.1.0), lifecycle (&ge; 0.2.0),
logger (&ge; 0.2.0), methods, rlang (&ge; 1.0.0), shiny (&ge; 1.6.0),
shinyjs, shinyvalidate, stats, teal.data (&ge; 0.5.0),
teal.logger (&ge; 0.1.1), teal.widgets (&ge; 0.4.0), tidyr (&ge;
0.8.3), tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.42), rmarkdown (&ge; 2.19), teal.code (&ge; 0.5.0),
testthat (&ge; 3.1.5)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Config/Needs/verdepcheck:</td>
<td>mllg/checkmate, tidyverse/dplyr,
r-lib/lifecycle, daroczig/logger, r-lib/rlang,
rstudio/rmarkdown, rstudio/shiny, daattali/shinyjs,
rstudio/shinyvalidate, insightsengineering/teal.data,
insightsengineering/teal.logger,
insightsengineering/teal.widgets, tidyverse/tidyr,
r-lib/tidyselect, yihui/knitr, insightsengineering/teal.code,
r-lib/testthat</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>insightsengineering/nesttemplate</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-16 17:57:01 UTC; unardid</td>
</tr>
<tr>
<td>Author:</td>
<td>Dawid Kaledkowski [aut, cre],
  Pawel Rucki [aut],
  Mahmoud Hallal [aut],
  Nikolas Burkoff [aut],
  Maciej Nasinski [aut],
  Konrad Pagacz [aut],
  Junlue Zhao [aut],
  F. Hoffmann-La Roche AG [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dawid Kaledkowski &lt;dawid.kaledkowski@roche.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-17 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='teal.transform-package'><code>teal.transform</code>: Functions for extracting and merging data in the <code>teal</code> framework</h2><span id='topic+teal.transform'></span><span id='topic+teal.transform-package'></span>

<h3>Description</h3>

<p>A standardized user interface for column selection, that facilitates dataset merging in 'teal' framework.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dawid Kaledkowski <a href="mailto:dawid.kaledkowski@roche.com">dawid.kaledkowski@roche.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Pawel Rucki <a href="mailto:pawel.rucki@roche.com">pawel.rucki@roche.com</a>
</p>
</li>
<li><p> Mahmoud Hallal <a href="mailto:mahmoud.hallal@roche.com">mahmoud.hallal@roche.com</a>
</p>
</li>
<li><p> Nikolas Burkoff
</p>
</li>
<li><p> Maciej Nasinski
</p>
</li>
<li><p> Konrad Pagacz
</p>
</li>
<li><p> Junlue Zhao
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> F. Hoffmann-La Roche AG [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://insightsengineering.github.io/teal.transform/">https://insightsengineering.github.io/teal.transform/</a>
</p>
</li>
<li> <p><a href="https://github.com/insightsengineering/teal.transform/">https://github.com/insightsengineering/teal.transform/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/insightsengineering/teal.transform/issues">https://github.com/insightsengineering/teal.transform/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_no_selected_choices'>Add empty choice to choices selected</h2><span id='topic+add_no_selected_choices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_no_selected_choices(x, multiple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_no_selected_choices_+3A_x">x</code></td>
<td>
<p>(<code>choices_selected</code>) object.</p>
</td></tr>
<tr><td><code id="add_no_selected_choices_+3A_multiple">multiple</code></td>
<td>
<p>(<code>logical(1)</code>) whether multiple selections are allowed or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>choices_selected</code> object with an empty option added to the choices.
</p>

<hr>
<h2 id='all_choices'>Bare constructor for <code>all_choices</code> object</h2><span id='topic+all_choices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>An S3 structure representing the selection of all possible choices in a
<code>filter_spec</code>, <code>select_spec</code> or <code>choices_selected</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_choices()
</code></pre>


<h3>Value</h3>

<p><code>all_choices</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Both structures are semantically identical
filter_spec(
  vars = c("selected_variable"),
  choices = c("value1", "value2"),
  selected = c("value1", "value2")
)

filter_spec(
  vars = c("selected_variable"),
  choices = c("value1", "value2"),
  selected = all_choices()
)

choices_selected(choices = letters, selected = letters)
choices_selected(choices = letters, selected = all_choices())
</code></pre>

<hr>
<h2 id='are_needed_keys_provided'>Checks whether the provided slices have the corresponding join keys</h2><span id='topic+are_needed_keys_provided'></span>

<h3>Description</h3>

<p>Checks whether the provided slices have the corresponding join keys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_needed_keys_provided(join_keys, merged_selector_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_needed_keys_provided_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>) the provided join keys.</p>
</td></tr>
<tr><td><code id="are_needed_keys_provided_+3A_merged_selector_list">merged_selector_list</code></td>
<td>
<p>(<code>list</code>) the specification of datasets' slices to merge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all pairs of the slices have the corresponding keys and
<code>FALSE</code> otherwise.
</p>


<h3>Note</h3>

<p><code>merged_selector_list</code> contains a list of descriptions of data frame slices;
each coming from a single dataset. This function checks whether all pairs
of the datasets have the join keys needed to merge the slices.
</p>

<hr>
<h2 id='call_check_parse_varname'>Checks <code>varname</code> argument and convert to call</h2><span id='topic+call_check_parse_varname'></span>

<h3>Description</h3>

<p>Checks <code>varname</code> type and parse if it's a <code>character</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_check_parse_varname(varname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_check_parse_varname_+3A_varname">varname</code></td>
<td>
<p>(<code>name</code> or <code>call</code> or <code>character(1)</code>)
name of the variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the parsed <code>varname</code>.
</p>

<hr>
<h2 id='call_condition_choice'>Choices condition call</h2><span id='topic+call_condition_choice'></span>

<h3>Description</h3>

<p>Compose choices condition call from inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_condition_choice(varname, choices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_condition_choice_+3A_varname">varname</code></td>
<td>
<p>(<code>name</code> or <code>call</code> or <code>character(1)</code>)
name of the variable.</p>
</td></tr>
<tr><td><code id="call_condition_choice_+3A_choices">choices</code></td>
<td>
<p>(<code>vector</code>)
<code>varname</code> values to match using the <code>==</code> (single value) or <code>%in%</code> (vector)
condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>choices</code> can be vector of any type but for some output might be converted:
</p>

<ul>
<li> <p><code>factor</code> call is composed on choices converted to <code>character</code>;
</p>
</li>
<li> <p><code>Date</code> call is composed on choices converted to <code>character</code> using
<code>format(choices)</code>;
</p>
</li>
<li> <p><code>POSIXct</code>, <code>POSIXlt</code> call is composed on choices converted to <code>character</code> using
<code>format(choices)</code>.
</p>
</li></ul>

<p>One has to be careful here as formatted date-time variable might loose
some precision (see <code>format</code> argument in <code><a href="base.html#topic+format.POSIXlt">format.POSIXlt()</a></code> and output call
could be insufficient for exact comparison. In this case one should specify
<code style="white-space: pre;">&#8288;varname = trunc(&lt;varname&gt;)&#8288;</code> and possibly convert <code>choices</code> to <code>character</code>).
</p>


<h3>Value</h3>

<p><code>call</code>.
</p>

<hr>
<h2 id='call_condition_logical'><code>logical</code> variable condition call</h2><span id='topic+call_condition_logical'></span>

<h3>Description</h3>

<p>Compose <code>logical</code> variable condition call from inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_condition_logical(varname, choice)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_condition_logical_+3A_varname">varname</code></td>
<td>
<p>(<code>name</code> or <code>character(1)</code>)
name of the variable</p>
</td></tr>
<tr><td><code id="call_condition_logical_+3A_choice">choice</code></td>
<td>
<p>(<code>logical(1)</code>)
chosen value</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>call</code>.
</p>

<hr>
<h2 id='call_condition_range'><code>numeric</code> range condition call</h2><span id='topic+call_condition_range'></span>

<h3>Description</h3>

<p>Compose <code>numeric</code> range condition call from inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_condition_range(varname, range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_condition_range_+3A_varname">varname</code></td>
<td>
<p>(<code>name</code> or <code>character(1)</code>)
name of the variable.</p>
</td></tr>
<tr><td><code id="call_condition_range_+3A_range">range</code></td>
<td>
<p>(<code>numeric(2)</code>)
range of the variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>call</code>.
</p>

<hr>
<h2 id='call_condition_range_date'><code>Date</code> range condition call</h2><span id='topic+call_condition_range_date'></span>

<h3>Description</h3>

<p>Compose <code>Date</code> range condition call from inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_condition_range_date(varname, range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_condition_range_date_+3A_varname">varname</code></td>
<td>
<p>(<code>name</code> or <code>character(1)</code>) name of the variable.</p>
</td></tr>
<tr><td><code id="call_condition_range_date_+3A_range">range</code></td>
<td>
<p>(<code>Date</code>) range of the variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>call</code>.
</p>

<hr>
<h2 id='call_condition_range_posixct'><code>POSIXct</code> range condition call</h2><span id='topic+call_condition_range_posixct'></span>

<h3>Description</h3>

<p>Compose <code>POSIXct</code> range condition call from inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_condition_range_posixct(varname, range, timezone = Sys.timezone())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_condition_range_posixct_+3A_varname">varname</code></td>
<td>
<p>(<code>name</code> or <code>character(1)</code>) name of the variable.</p>
</td></tr>
<tr><td><code id="call_condition_range_posixct_+3A_range">range</code></td>
<td>
<p>(<code>POSIXct</code>) range of the variable.
Be aware that output uses truncated range format <code>"%Y-%m-%d %H:%M:%S"</code>,
which means that some precision might be lost.</p>
</td></tr>
<tr><td><code id="call_condition_range_posixct_+3A_timezone">timezone</code></td>
<td>
<p>(<code>character(1)</code>) specifies the time zone to be used for the conversion.
By default <code>Sys.timezone()</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>call</code>.
</p>

<hr>
<h2 id='call_extract_array'>Get call to subset and select array</h2><span id='topic+call_extract_array'></span>

<h3>Description</h3>

<p>Get call to subset and select array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_extract_array(dataname = ".", row = NULL, column = NULL, aisle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_extract_array_+3A_dataname">dataname</code></td>
<td>
<p>(<code>character(1)</code> or <code>name</code>).</p>
</td></tr>
<tr><td><code id="call_extract_array_+3A_row">row</code></td>
<td>
<p>(optional <code>name</code> or <code>call</code> or <code>logical</code> or <code>integer</code> or <code>character</code>)
name of the <code>row</code> or condition.</p>
</td></tr>
<tr><td><code id="call_extract_array_+3A_column">column</code></td>
<td>
<p>(optional <code>name</code> or <code>call</code> or <code>logical</code>, <code>integer</code> or <code>character</code>)
name of the <code>column</code> or condition.</p>
</td></tr>
<tr><td><code id="call_extract_array_+3A_aisle">aisle</code></td>
<td>
<p>(optional <code>name</code> or <code>call</code> or <code>logical</code> or <code>integer</code> or <code>character</code>)
name of the <code>row</code> or condition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+Extract">Extract()</a></code> <code>call</code> for 3-dimensional array in <code>x[i, j, k]</code> notation.
</p>

<hr>
<h2 id='call_extract_list'>Compose extract call with <code>$</code> operator</h2><span id='topic+call_extract_list'></span>

<h3>Description</h3>

<p>Compose extract call with <code>$</code> operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_extract_list(dataname, varname, dollar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_extract_list_+3A_dataname">dataname</code></td>
<td>
<p>(<code>character(1)</code> or <code>name</code>) name of the object.</p>
</td></tr>
<tr><td><code id="call_extract_list_+3A_varname">varname</code></td>
<td>
<p>(<code>character(1)</code> or <code>name</code>) name of the slot in data.</p>
</td></tr>
<tr><td><code id="call_extract_list_+3A_dollar">dollar</code></td>
<td>
<p>(<code>logical(1)</code>) whether returned call should use <code>$</code> or <code>[[</code> operator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+Extract">Extract()</a></code> <code>call</code> in <code>$</code> or <code>[[</code> notation (depending on parameters).
</p>

<hr>
<h2 id='call_extract_matrix'>Get call to subset and select matrix</h2><span id='topic+call_extract_matrix'></span>

<h3>Description</h3>

<p>Get call to subset and select matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_extract_matrix(dataname = ".", row = NULL, column = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_extract_matrix_+3A_dataname">dataname</code></td>
<td>
<p>(<code>character(1)</code> or <code>name</code>).</p>
</td></tr>
<tr><td><code id="call_extract_matrix_+3A_row">row</code></td>
<td>
<p>(optional <code>name</code> or <code>call</code> or <code>logical</code> or <code>integer</code> or <code>character</code>)
name of the <code>row</code> or condition.</p>
</td></tr>
<tr><td><code id="call_extract_matrix_+3A_column">column</code></td>
<td>
<p>(optional <code>name</code> or <code>call</code> or <code>logical</code> or <code>integer</code> or <code>character</code>)
name of the <code>column</code> or condition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+Extract">Extract()</a></code> <code>call</code> for matrix in <code>x[i, j]</code> notation.
</p>

<hr>
<h2 id='call_with_colon'>Create a call using a function in a given namespace</h2><span id='topic+call_with_colon'></span>

<h3>Description</h3>

<p>The dot arguments in <code>...</code> need to be quoted because they will be evaluated otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_with_colon(name, ..., unlist_args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_with_colon_+3A_name">name</code></td>
<td>
<p><code>character</code> function name, possibly using namespace colon <code>::</code>, also
works with <code>:::</code> (sometimes needed, but strongly discouraged).</p>
</td></tr>
<tr><td><code id="call_with_colon_+3A_...">...</code></td>
<td>
<p>arguments to pass to function with name <code>name</code>.</p>
</td></tr>
<tr><td><code id="call_with_colon_+3A_unlist_args">unlist_args</code></td>
<td>
<p><code>list</code> extra arguments passed in a single list,
avoids the use of <code>do.call</code> with this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>call</code>.
</p>

<hr>
<h2 id='calls_combine_by'>Combine calls by operator</h2><span id='topic+calls_combine_by'></span>

<h3>Description</h3>

<p>Combine list of calls by specific operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calls_combine_by(operator, calls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calls_combine_by_+3A_operator">operator</code></td>
<td>
<p>(<code>character(1)</code> or <code>name</code>) name / symbol of the operator.</p>
</td></tr>
<tr><td><code id="calls_combine_by_+3A_calls">calls</code></td>
<td>
<p>(<code>list</code> of calls) list containing calls to be combined by <code>operator</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined <code>call</code>.
</p>

<hr>
<h2 id='check_data_extract_spec'>Check data extract specification</h2><span id='topic+check_data_extract_spec'></span>

<h3>Description</h3>

<p>Check data extract specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_extract_spec(data_extract_spec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_extract_spec_+3A_data_extract_spec">data_extract_spec</code></td>
<td>
<p>(<code>list</code>) of <code>data_extract_spec</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns the <code>data_extract_spec</code>
parameter, invisibly and unchanged.
</p>

<hr>
<h2 id='check_data_extract_spec_react'>Function to check data_extract_specs</h2><span id='topic+check_data_extract_spec_react'></span>

<h3>Description</h3>

<p>Checks if <code>dataname</code> argument exists as a dataset.
Checks if selected or filter columns exist within the datasets. Throws a <code>shiny</code>
validation error if the above requirements are not met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_extract_spec_react(datasets, data_extract)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_extract_spec_react_+3A_datasets">datasets</code></td>
<td>
<p>(<code>FilteredData</code>) the object created using the <code>teal</code> API.</p>
</td></tr>
<tr><td><code id="check_data_extract_spec_react_+3A_data_extract">data_extract</code></td>
<td>
<p>(<code>list</code>) the output of the <code>data_extract</code> module.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>.
</p>

<hr>
<h2 id='check_data_merge_selectors'>Validate data_extracts in merge_datasets</h2><span id='topic+check_data_merge_selectors'></span>

<h3>Description</h3>

<p>Validate selected inputs from data_extract before passing to data_merge to avoid
<code>dplyr</code> errors or unexpected results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_merge_selectors(selector_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_merge_selectors_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if check is successful and <code>shiny</code> validate error otherwise.
</p>

<hr>
<h2 id='check_merge_function'>Check if the merge function is valid</h2><span id='topic+check_merge_function'></span>

<h3>Description</h3>

<p>Check if the merge function is valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_merge_function(merge_function)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_merge_function_+3A_merge_function">merge_function</code></td>
<td>
<p>(<code>character</code>) merge function name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns <code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='check_no_multiple_selection'>Checks that the <code>extract_input</code> specification does not allow multiple
selection</h2><span id='topic+check_no_multiple_selection'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_no_multiple_selection(extract_input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_no_multiple_selection_+3A_extract_input">extract_input</code></td>
<td>
<p>(<code>list</code> or <code>NULL</code>) a list of <code>data_extract_spec</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stops if condition not met.
</p>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns <code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='check_selector'>Check selector</h2><span id='topic+check_selector'></span>

<h3>Description</h3>

<p>Check selector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_selector(selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_selector_+3A_selector">selector</code></td>
<td>
<p>(<code>list</code>) of selector elements generated by <code>data_extract_srv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns the <code>selector</code>
parameter, invisibly and unchanged.
</p>

<hr>
<h2 id='check_selector_dataname'>Check selector <code>dataname</code> element</h2><span id='topic+check_selector_dataname'></span>

<h3>Description</h3>

<p>Check selector <code>dataname</code> element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_selector_dataname(dataname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_selector_dataname_+3A_dataname">dataname</code></td>
<td>
<p>(<code>character(1)</code>) selector element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns the <code>dataname</code>
parameter, invisibly and unchanged.
</p>

<hr>
<h2 id='check_selector_filters'>Check selector filters element</h2><span id='topic+check_selector_filters'></span>

<h3>Description</h3>

<p>Check selector filters element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_selector_filters(filters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_selector_filters_+3A_filters">filters</code></td>
<td>
<p>(<code>list</code>) selector element generated by <code>data_extract_srv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when the check fails, otherwise it returns <code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='check_selector_internal_id'>Check selector internal_id element</h2><span id='topic+check_selector_internal_id'></span>

<h3>Description</h3>

<p>Check selector internal_id element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_selector_internal_id(internal_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_selector_internal_id_+3A_internal_id">internal_id</code></td>
<td>
<p>(<code>character(1)</code>) selector element generated by <code>data_extract_srv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns the <code>internal_id</code>
parameter, invisibly and unchanged.
</p>

<hr>
<h2 id='check_selector_keys'>Check selector keys element</h2><span id='topic+check_selector_keys'></span>

<h3>Description</h3>

<p>Check selector keys element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_selector_keys(keys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_selector_keys_+3A_keys">keys</code></td>
<td>
<p>(<code>character</code>) selector element generated by <code>data_extract_srv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns the <code>keys</code>
parameter, invisibly and unchanged.
</p>

<hr>
<h2 id='check_selector_reshape'>Check selector reshape element</h2><span id='topic+check_selector_reshape'></span>

<h3>Description</h3>

<p>Check selector reshape element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_selector_reshape(reshape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_selector_reshape_+3A_reshape">reshape</code></td>
<td>
<p>(<code>logical(1)</code>) selector element generated by <code>data_extract_srv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns the <code>reshape</code>
parameter, invisibly and unchanged.
</p>

<hr>
<h2 id='check_selector_select'>Check selector select element</h2><span id='topic+check_selector_select'></span>

<h3>Description</h3>

<p>Check selector select element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_selector_select(select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_selector_select_+3A_select">select</code></td>
<td>
<p>(<code>character</code>) selector element generated by <code>data_extract_srv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raises an error when check fails, otherwise, it returns the <code>select</code>
parameter, invisibly and unchanged.
</p>

<hr>
<h2 id='choices_labeled'>Set &quot;<code style="white-space: pre;">&#8288;&lt;choice&gt;:&lt;label&gt;&#8288;</code>&quot; type of names</h2><span id='topic+choices_labeled'></span><span id='topic+print.choices_labeled'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>This is often useful for <code><a href="#topic+choices_selected">choices_selected()</a></code> as it marks up the drop-down boxes
for <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choices_labeled(choices, labels, subset = NULL, types = NULL)

## S3 method for class 'choices_labeled'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choices_labeled_+3A_choices">choices</code></td>
<td>
<p>(<code>character</code> or <code>factor</code> or <code>numeric</code> or <code>logical</code>) vector.</p>
</td></tr>
<tr><td><code id="choices_labeled_+3A_labels">labels</code></td>
<td>
<p>(<code>character</code>) vector containing labels to be applied to <code>choices</code>.
If <code>NA</code> then &quot;Label Missing&quot; will be used.</p>
</td></tr>
<tr><td><code id="choices_labeled_+3A_subset">subset</code></td>
<td>
<p>(<code>character</code> or <code>factor</code> or <code>numeric</code> or <code>logical</code>) vector that
is a subset of <code>choices</code>.
This is useful if only a few variables need to be named.
If this argument is used, the returned vector will match its order.</p>
</td></tr>
<tr><td><code id="choices_labeled_+3A_types">types</code></td>
<td>
<p>(<code>character</code>) vector containing the types of the columns to be used for applying the appropriate
icons to the <a href="#topic+choices_selected">choices_selected</a> drop down box (e.g. &quot;numeric&quot;).</p>
</td></tr>
<tr><td><code id="choices_labeled_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="choices_labeled_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code>choices</code> or <code>labels</code> are factors, they are coerced to character.
Duplicated elements from <code>choices</code> get removed.
</p>


<h3>Value</h3>

<p>Named <code>character</code> vector.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(choices_labeled)</code>: Print choices_labeled object
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(teal.data)

ADSL &lt;- teal.transform::rADSL
ADTTE &lt;- teal.transform::rADTTE

choices1 &lt;- choices_labeled(names(ADSL), col_labels(ADSL, fill = FALSE))
choices2 &lt;- choices_labeled(ADTTE$PARAMCD, ADTTE$PARAM)

# if only a subset of variables are needed, use subset argument
choices3 &lt;- choices_labeled(
  names(ADSL),
  col_labels(ADSL, fill = FALSE),
  subset = c("ARMCD", "ARM")
)

ui &lt;- fluidPage(
  selectInput("c1",
    label = "Choices from ADSL",
    choices = choices1,
    selected = choices1[1]
  ),
  selectInput("c2",
    label = "Choices from ADTTE",
    choices = choices2,
    selected = choices2[1]
  ),
  selectInput("c3",
    label = "Arm choices from ADSL",
    choices = choices3,
    selected = choices3[1]
  )
)
server &lt;- function(input, output) {}

if (interactive()) {
  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='choices_selected'>Choices selected</h2><span id='topic+choices_selected'></span><span id='topic+is.choices_selected'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Construct a single list containing available choices, the default selected value, and
additional settings such as to order the choices with the selected elements appearing first
or whether to block the user from making selections.
</p>
<p>Can be used in UI input elements such as <code><a href="teal.widgets.html#topic+optionalSelectInput">teal.widgets::optionalSelectInput()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choices_selected(
  choices,
  selected = if (inherits(choices, "delayed_data")) NULL else choices[1],
  keep_order = FALSE,
  fixed = FALSE
)

is.choices_selected(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choices_selected_+3A_choices">choices</code></td>
<td>
<p>(<code>character</code>) vector of possible choices or <code>delayed_data</code> object.
</p>
<p>See <code><a href="#topic+variable_choices">variable_choices()</a></code> and <code><a href="#topic+value_choices">value_choices()</a></code>.</p>
</td></tr>
<tr><td><code id="choices_selected_+3A_selected">selected</code></td>
<td>
<p>(<code>character</code>) vector of preselected options, (<code>all_choices</code>) object
or (<code>delayed_data</code>) object.
</p>
<p>If <code>delayed_data</code> object then <code>choices</code> must also be <code>delayed_data</code> object.
If not supplied it will default to the first element of <code>choices</code> if
<code>choices</code> is a vector, or <code>NULL</code> if <code>choices</code> is a <code>delayed_data</code> object.</p>
</td></tr>
<tr><td><code id="choices_selected_+3A_keep_order">keep_order</code></td>
<td>
<p>(<code>logical</code>) In case of <code>FALSE</code> the selected variables will
be on top of the drop-down field.</p>
</td></tr>
<tr><td><code id="choices_selected_+3A_fixed">fixed</code></td>
<td>
<p>(optional <code>logical</code>) Whether to block user to select choices.</p>
</td></tr>
<tr><td><code id="choices_selected_+3A_x">x</code></td>
<td>
<p>(<code>choices_selected</code>) object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that the order of selected will always follow the order of choices. The <code>keep_order</code>
argument is set to false which will run the following code inside:
</p>
<div class="sourceCode"><pre>choices &lt;- c(selected, setdiff(choices, selected))
</pre></div>
<p>In case you want to keep your specific order of choices, set <code>keep_order</code> to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p><code>choices_selected</code> returns list of <code>choices_selected</code>, encapsulating the specified
<code>choices</code>, <code>selected</code>, <code>keep_order</code> and <code>fixed</code>.
</p>
<p><code>is.choices_selected</code> returns <code>TRUE</code> if <code>x</code> inherits from a <code>choices_selected</code> object, <code>FALSE</code> otherwise.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is.choices_selected()</code>: Check if an object is a choices_selected class
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(teal.widgets)

# all_choices example - semantically the same objects
choices_selected(choices = letters, selected = all_choices())
choices_selected(choices = letters, selected = letters)

choices_selected(
  choices = setNames(LETTERS[1:5], paste("Letter", LETTERS[1:5])),
  selected = "C"
)

ADSL &lt;- teal.transform::rADSL
choices_selected(variable_choices(ADSL), "SEX")

# How to select nothing
# use an empty character
choices_selected(
  choices = c("", "A", "B", "C"),
  selected = ""
)

# How to allow the user to select nothing
# use an empty character
choices_selected(
  choices = c("A", "", "B", "C"),
  selected = "A"
)


# How to make Nothing the Xth choice
# just use keep_order
choices_selected(
  choices = c("A", "", "B", "C"),
  selected = "A",
  keep_order = TRUE
)


# How to give labels to selections
# by adding names - choices will be replaced by "name" in UI, not in code
choices_selected(
  choices = c("name for A" = "A", "Name for nothing" = "", "name for b" = "B", "name for C" = "C"),
  selected = "A"
)

# by using choices_labeled
# labels will be shown behind the choice
choices_selected(
  choices = choices_labeled(
    c("A", "", "B", "C"),
    c("name for A", "nothing", "name for B", "name for C")
  ),
  selected = "A"
)

# Passing a `delayed_data` object to `selected`
choices_selected(
  choices = variable_choices("ADSL"),
  selected = variable_choices("ADSL", subset = c("STUDYID"))
)

# functional form (subsetting for factor variables only) of choices_selected
# with delayed data loading
choices_selected(variable_choices("ADSL", subset = function(data) {
  idx &lt;- vapply(data, is.factor, logical(1))
  names(data)[idx]
}))

cs &lt;- choices_selected(
  choices = c("A", "B", "C"),
  selected = "A"
)

ui &lt;- fluidPage(
  optionalSelectInput(
    inputId = "id",
    choices = cs$choices,
    selected = cs$selected
  )
)

server &lt;- function(input, output, session) {}
if (interactive()) {
  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='compose_and_enable_validators'>Function to compose <code>validators</code> from <code>data_extract_multiple_srv</code></h2><span id='topic+compose_and_enable_validators'></span>

<h3>Description</h3>

<p>This function takes the output from <code>data_extract_multiple_srv</code> and
collates the <code>shinyvalidate::InputValidator</code>s returned into a single
<code>validator</code> and enables this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose_and_enable_validators(iv, selector_list, validator_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_and_enable_validators_+3A_iv">iv</code></td>
<td>
<p>(<code>shinyvalidate::InputValidator</code>) A <code>validator</code>.</p>
</td></tr>
<tr><td><code id="compose_and_enable_validators_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code> named list of <code>reactives</code>).
Typically this is the output from <code>data_extract_multiple_srv</code>.
The <code>validators</code> in this list (specifically <code style="white-space: pre;">&#8288;selector_list()[[validator_names]]()iv&#8288;</code>)
will be added into <code>iv</code>.</p>
</td></tr>
<tr><td><code id="compose_and_enable_validators_+3A_validator_names">validator_names</code></td>
<td>
<p>(<code>character</code> or <code>NULL</code>). If <code>character</code> then only <code>validators</code>
in the elements of <code>selector_list()</code> whose name is in this list will be added. If <code>NULL</code>
all <code>validators</code> will be added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>shinyvalidate::InputValidator</code>) enabled <code>iv</code> with appropriate <code>validators</code> added into it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(shinyvalidate)
library(shinyjs)
library(teal.widgets)

iris_extract &lt;- data_extract_spec(
  dataname = "iris",
  select = select_spec(
    label = "Select variable:",
    choices = variable_choices(iris, colnames(iris)),
    selected = "Sepal.Length",
    multiple = TRUE,
    fixed = FALSE
  )
)

data_list &lt;- list(iris = reactive(iris))

ui &lt;- fluidPage(
  useShinyjs(),
  standard_layout(
    output = verbatimTextOutput("out1"),
    encoding = tagList(
      data_extract_ui(
        id = "x_var",
        label = "Please select an X column",
        data_extract_spec = iris_extract
      ),
      data_extract_ui(
        id = "y_var",
        label = "Please select a Y column",
        data_extract_spec = iris_extract
      ),
      data_extract_ui(
        id = "col_var",
        label = "Please select a color column",
        data_extract_spec = iris_extract
      )
    )
  )
)

server &lt;- function(input, output, session) {
  exactly_2_validation &lt;- function() {
    ~ if (length(.) != 2) "Exactly 2 'Y' column variables must be chosen"
  }

  selector_list &lt;- data_extract_multiple_srv(
    list(x_var = iris_extract, y_var = iris_extract, col_var = iris_extract),
    datasets = data_list,
    select_validation_rule = list(
      x_var = sv_required("Please select an X column"),
      y_var = compose_rules(
        sv_required("Exactly 2 'Y' column variables must be chosen"),
        exactly_2_validation()
      )
    )
  )
  iv_r &lt;- reactive({
    iv &lt;- InputValidator$new()
    compose_and_enable_validators(
      iv,
      selector_list,
      # if validator_names = NULL then all validators are used
      # to turn on only "x_var" then set this argument to "x_var"
      validator_names = NULL
    )
  })

  output$out1 &lt;- renderPrint({
    if (iv_r()$is_valid()) {
      ans &lt;- lapply(selector_list(), function(x) {
        cat(format_data_extract(x()), "\n\n")
      })
    } else {
      "Check that you have made a valid selection"
    }
  })
}

if (interactive()) {
  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='cond_data_extract_single_ui'>Creates a panel that displays (with filter and column selection)
conditionally on <code>input[ns("dataset")] == dataname</code></h2><span id='topic+cond_data_extract_single_ui'></span>

<h3>Description</h3>

<p>Creates a panel that displays (with filter and column selection)
conditionally on <code>input[ns("dataset")] == dataname</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_data_extract_single_ui(ns, single_data_extract_spec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_data_extract_single_ui_+3A_ns">ns</code></td>
<td>
<p>(<code>function</code>) the shiny namespace function.</p>
</td></tr>
<tr><td><code id="cond_data_extract_single_ui_+3A_single_data_extract_spec">single_data_extract_spec</code></td>
<td>
<p>(<code>data_extract_spec</code>) the specification
for extraction of data during the application initialization.
</p>
<p>Generated by <code><a href="#topic+data_extract_spec">data_extract_spec()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>shiny.tag</code> with the HTML code for the panel.
</p>

<hr>
<h2 id='convert_teal_data'>Ensures datasets is a list of reactive expression</h2><span id='topic+convert_teal_data'></span>

<h3>Description</h3>

<p>Ensures datasets is a list of reactive expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_teal_data(datasets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_teal_data_+3A_datasets">datasets</code></td>
<td>
<p>(<code>reactive</code> or <code>teal_data</code> or <code>list</code>) of <code>data.frame</code>
wrapped or not in a reactive expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of <code>reactive</code> expressions that contains all the individual <code>datasets</code>.
</p>

<hr>
<h2 id='data_extract_filter_srv'>Handles events emitted from the UI generated by <code>data_extract_filter_ui</code></h2><span id='topic+data_extract_filter_srv'></span>

<h3>Description</h3>

<p>Handles events emitted from the UI generated by <code>data_extract_filter_ui</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_filter_srv(id, datasets, filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_filter_srv_+3A_id">id</code></td>
<td>
<p>(<code>character</code>) id string.</p>
</td></tr>
<tr><td><code id="data_extract_filter_srv_+3A_datasets">datasets</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named list&#8288;</code>) a list of reactive <code>data.frame</code> type objects.</p>
</td></tr>
<tr><td><code id="data_extract_filter_srv_+3A_filter">filter</code></td>
<td>
<p>(<code>filter_spec</code>) the filter generated by a call to <code><a href="#topic+filter_spec">filter_spec()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly.
</p>


<h3>Note</h3>

<p>This shiny module server updates the values of the <code>vals</code>
<code><a href="teal.widgets.html#topic+optionalSelectInput">teal.widgets::optionalSelectInput()</a></code> widget.
It's responsible for setting the initial values and the subsequent updates to
the <code>vals</code> widget based on the input of the <code>col</code> widget.
</p>

<hr>
<h2 id='data_extract_filter_ui'>Returns a <code>shiny.tag</code> object with the UI for a <code>filter_spec</code> object</h2><span id='topic+data_extract_filter_ui'></span>

<h3>Description</h3>

<p>Returns a <code>shiny.tag</code> object with the UI for a <code>filter_spec</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_filter_ui(filter, id = "filter")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_filter_ui_+3A_filter">filter</code></td>
<td>
<p>(<code>filter_spec</code>) the object generated with <code><a href="#topic+filter_spec">filter_spec()</a></code>.</p>
</td></tr>
<tr><td><code id="data_extract_filter_ui_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>) the shiny <code>inputId</code> for the generated <code>shiny.tag</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates two <code>optionSelectInput</code> elements (one for column and one for values) based
on a definition of a <code><a href="#topic+filter_spec">filter_spec()</a></code> object.
</p>


<h3>Value</h3>

<p><code>shiny.tag</code> defining the <code>filter_spec</code>'s UI element.
</p>

<hr>
<h2 id='data_extract_multiple_srv'>Creates a named list of <code>data_extract_srv</code> output</h2><span id='topic+data_extract_multiple_srv'></span><span id='topic+data_extract_multiple_srv.reactive'></span><span id='topic+data_extract_multiple_srv.FilteredData'></span><span id='topic+data_extract_multiple_srv.list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>data_extract_multiple_srv</code> loops over the list of <code>data_extract</code> given and
runs <code>data_extract_srv</code> for each one returning a list of reactive objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_multiple_srv(data_extract, datasets, ...)

## S3 method for class 'reactive'
data_extract_multiple_srv(data_extract, datasets, ...)

## S3 method for class 'FilteredData'
data_extract_multiple_srv(data_extract, datasets, ...)

## S3 method for class 'list'
data_extract_multiple_srv(
  data_extract,
  datasets,
  join_keys = NULL,
  select_validation_rule = NULL,
  filter_validation_rule = NULL,
  dataset_validation_rule = if (is.null(select_validation_rule) &amp;&amp;
    is.null(filter_validation_rule)) {
     NULL
 } else {
    
    shinyvalidate::sv_required("Please select a dataset")
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_multiple_srv_+3A_data_extract">data_extract</code></td>
<td>
<p>(named <code>list</code> of <code>data_extract_spec</code> objects) the list <code>data_extract_spec</code> objects.
The names of the elements in the list need to correspond to the <code>ids</code> passed to <code>data_extract_ui</code>.
</p>
<p>See example for details.</p>
</td></tr>
<tr><td><code id="data_extract_multiple_srv_+3A_datasets">datasets</code></td>
<td>
<p>(<code>FilteredData</code> or <code>list</code> of <code>reactive</code> or non-<code>reactive</code> <code>data.frame</code>)
object containing data either in the form of <code>FilteredData</code> or as a list of <code>data.frame</code>.
When passing a list of non-reactive <code>data.frame</code> objects, they are converted to reactive <code>data.frame</code>s internally.
When passing a list of reactive or non-reactive <code>data.frame</code> objects, the argument <code>join_keys</code> is required also.</p>
</td></tr>
<tr><td><code id="data_extract_multiple_srv_+3A_...">...</code></td>
<td>
<p>An additional argument <code>join_keys</code> is required when <code>datasets</code> is a list of <code>data.frame</code>.
It shall contain the keys per dataset in <code>datasets</code>.</p>
</td></tr>
<tr><td><code id="data_extract_multiple_srv_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code> or <code>NULL</code>) of join keys per dataset in <code>datasets</code>.</p>
</td></tr>
<tr><td><code id="data_extract_multiple_srv_+3A_select_validation_rule">select_validation_rule</code></td>
<td>
<p>(<code>NULL</code> or <code>function</code> or <code style="white-space: pre;">&#8288;named list&#8288;</code> of <code>function</code>)
Should there be any <code>shinyvalidate</code> input validation of the select parts of the <code>data_extract_ui</code>.
If all <code>data_extract</code> require the same validation function then this can be used directly
(i.e. <code>select_validation_rule = shinyvalidate::sv_required()</code>).
</p>
<p>For more fine-grained control use a list:
</p>
<p><code>select_validation_rule = list(extract_1 = sv_required(), extract2 = ~ if (length(.) &gt; 2) "Error")</code>
</p>
<p>If <code>NULL</code> then no validation will be added.
</p>
<p>See example for more details.</p>
</td></tr>
<tr><td><code id="data_extract_multiple_srv_+3A_filter_validation_rule">filter_validation_rule</code></td>
<td>
<p>(<code>NULL</code> or <code>function</code> or <code style="white-space: pre;">&#8288;named list&#8288;</code> of <code>function</code>) Same as
<code>select_validation_rule</code> but for the filter (values) part of the <code>data_extract_ui</code>.</p>
</td></tr>
<tr><td><code id="data_extract_multiple_srv_+3A_dataset_validation_rule">dataset_validation_rule</code></td>
<td>
<p>(<code>NULL</code> or <code>function</code> or <code style="white-space: pre;">&#8288;named list&#8288;</code> of <code>function</code>) Same as
<code>select_validation_rule</code> but for the choose dataset part of the <code>data_extract_ui</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>reactive named <code>list</code> containing outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
Output list names are the same as <code>data_extract</code> input argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(shinyvalidate)
library(shinyjs)
library(teal.widgets)

iris_select &lt;- data_extract_spec(
  dataname = "iris",
  select = select_spec(
    label = "Select variable:",
    choices = variable_choices(iris, colnames(iris)),
    selected = "Sepal.Length",
    multiple = TRUE,
    fixed = FALSE
  )
)

iris_filter &lt;- data_extract_spec(
  dataname = "iris",
  filter = filter_spec(
    vars = "Species",
    choices = c("setosa", "versicolor", "virginica"),
    selected = "setosa",
    multiple = TRUE
  )
)

data_list &lt;- list(iris = reactive(iris))

ui &lt;- fluidPage(
  useShinyjs(),
  standard_layout(
    output = verbatimTextOutput("out1"),
    encoding = tagList(
      data_extract_ui(
        id = "x_var",
        label = "Please select an X column",
        data_extract_spec = iris_select
      ),
      data_extract_ui(
        id = "species_var",
        label = "Please select 2 Species",
        data_extract_spec = iris_filter
      )
    )
  )
)

server &lt;- function(input, output, session) {
  exactly_2_validation &lt;- function(msg) {
    ~ if (length(.) != 2) msg
  }


  selector_list &lt;- data_extract_multiple_srv(
    list(x_var = iris_select, species_var = iris_filter),
    datasets = data_list,
    select_validation_rule = list(
      x_var = sv_required("Please select an X column")
    ),
    filter_validation_rule = list(
      species_var = compose_rules(
        sv_required("Exactly 2 Species must be chosen"),
        exactly_2_validation("Exactly 2 Species must be chosen")
      )
    )
  )
  iv_r &lt;- reactive({
    iv &lt;- InputValidator$new()
    compose_and_enable_validators(
      iv,
      selector_list,
      validator_names = NULL
    )
  })

  output$out1 &lt;- renderPrint({
    if (iv_r()$is_valid()) {
      ans &lt;- lapply(selector_list(), function(x) {
        cat(format_data_extract(x()), "\n\n")
      })
    } else {
      "Please fix errors in your selection"
    }
  })
}

if (interactive()) {
  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='data_extract_read_srv'>Returns a reactive list with values read from the inputs of <code>data_extract_spec</code></h2><span id='topic+data_extract_read_srv'></span>

<h3>Description</h3>

<p>Returns a reactive list with values read from the inputs of <code>data_extract_spec</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_read_srv(
  id,
  datasets,
  single_data_extract_spec,
  iv,
  select_validation_rule = NULL,
  filter_validation_rule = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_read_srv_+3A_id">id</code></td>
<td>
<p>(<code>character</code>) id string.</p>
</td></tr>
<tr><td><code id="data_extract_read_srv_+3A_datasets">datasets</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named list&#8288;</code>) a list of reactive <code>data.frame</code> type objects.</p>
</td></tr>
<tr><td><code id="data_extract_read_srv_+3A_single_data_extract_spec">single_data_extract_spec</code></td>
<td>
<p>(<code>data_extract_spec</code>) the
<code><a href="#topic+data_extract_spec">data_extract_spec()</a></code> object to handle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reads the UI inputs of a single <code>data_extract_spec</code> object in a running
<code>teal</code> application.
Returns a reactive list of reactive values read from the input.
</p>
<p>The returned list has keys corresponding to the UI inputs:
<code>select</code>, <code>filters</code>, <code>always_selected</code>, <code>reshape</code>.
</p>


<h3>Value</h3>

<p><code>shiny::reactive</code> the reactive list with reactive values read from the UI.
</p>

<hr>
<h2 id='data_extract_select_ui'>Returns a <code>shiny.tag.list</code> object with the UI for a <code>select_spec</code> object</h2><span id='topic+data_extract_select_ui'></span>

<h3>Description</h3>

<p>Returns a <code>shiny.tag.list</code> object with the UI for a <code>select_spec</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_select_ui(select, id = "select")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_select_ui_+3A_select">select</code></td>
<td>
<p>(<code>select_spec</code>) A definition of a select spec element.
Setting <code><a href="#topic+select_spec">select_spec()</a></code> with <code>ordered = TRUE</code> makes this selector responsive
to the variable selection order.</p>
</td></tr>
<tr><td><code id="data_extract_select_ui_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>) The shiny <code>inputId</code> of the element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>shiny.tag.list</code> with the UI.
</p>

<hr>
<h2 id='data_extract_single_srv'>The server function for a single <code>data_extract_spec</code> object</h2><span id='topic+data_extract_single_srv'></span>

<h3>Description</h3>

<p>The server function for a single <code>data_extract_spec</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_single_srv(id, datasets, single_data_extract_spec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_single_srv_+3A_id">id</code></td>
<td>
<p>(<code>character</code>) id string.</p>
</td></tr>
<tr><td><code id="data_extract_single_srv_+3A_datasets">datasets</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named list&#8288;</code>) a list of reactive <code>data.frame</code> type objects.</p>
</td></tr>
<tr><td><code id="data_extract_single_srv_+3A_single_data_extract_spec">single_data_extract_spec</code></td>
<td>
<p>(<code>data_extract_spec</code>) the
<code><a href="#topic+data_extract_spec">data_extract_spec()</a></code> object to handle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Shiny server function for handling a single <a href="#topic+data_extract_spec">data_extract_spec</a> object.
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>

<hr>
<h2 id='data_extract_single_ui'>Returns a <code>shiny.tag</code> with the UI elements for a <code>data_extract_spec</code></h2><span id='topic+data_extract_single_ui'></span>

<h3>Description</h3>

<p>Returns a <code>shiny.tag</code> with the UI elements for a <code>data_extract_spec</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_single_ui(id = NULL, single_data_extract_spec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_single_ui_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>) the id of the module.</p>
</td></tr>
<tr><td><code id="data_extract_single_ui_+3A_single_data_extract_spec">single_data_extract_spec</code></td>
<td>
<p>(<code>data_extract_spec</code>) the
<code><a href="#topic+data_extract_spec">data_extract_spec()</a></code> object to handle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a <code>shiny.tag</code> element defining the UI elements corresponding to a
single <code>data_extract_spec</code> object.
</p>


<h3>Value</h3>

<p><code>shiny.tag</code> the HTML element defining the UI.
</p>

<hr>
<h2 id='data_extract_spec'>Data extract input for <code>teal</code> modules</h2><span id='topic+data_extract_spec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>The Data extract input can be used to filter and select columns from a data set.
This function enables such an input in <code>teal</code>.
Please use the constructor function <a href="#topic+data_extract_spec">data_extract_spec</a> to set it up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_spec(dataname, select = NULL, filter = NULL, reshape = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_spec_+3A_dataname">dataname</code></td>
<td>
<p>(<code>character</code>)
The name of the dataset to be extracted.</p>
</td></tr>
<tr><td><code id="data_extract_spec_+3A_select">select</code></td>
<td>
<p>(<code>NULL</code> or <code>select_spec</code>-S3 class or <code>delayed_select_spec</code>)
Columns to be selected from the input dataset mentioned in <code>dataname</code>.
The setup can be created using <a href="#topic+select_spec">select_spec</a> function.</p>
</td></tr>
<tr><td><code id="data_extract_spec_+3A_filter">filter</code></td>
<td>
<p>(<code>NULL</code> or <code>filter_spec</code> or its respective delayed version)
Setup of the filtering of key columns inside the dataset.
This setup can be created using the <a href="#topic+filter_spec">filter_spec</a> function.
Please note that if both select and filter are set to <code>NULL</code>, then the result
will be a filter spec UI with all variables as possible choices and a select
spec with multiple set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="data_extract_spec_+3A_reshape">reshape</code></td>
<td>
<p>(<code>logical</code>)
whether reshape long to wide.
Note that it will be used only in case of long dataset with multiple
keys selected in filter part.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data_extract_spec</code> object.
</p>


<h3>Module Development</h3>

<p><code>teal.transform</code> uses this object to construct a UI element in a module.
</p>


<h3>Note</h3>

<p>No checks based on columns can be done because the data is only referred to by name.
</p>


<h3>References</h3>

<p><a href="#topic+select_spec">select_spec</a> <a href="#topic+filter_spec">filter_spec</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adtte_filters &lt;- filter_spec(
  vars = c("PARAMCD", "CNSR"),
  sep = "-",
  choices = c("OS-1" = "OS-1", "OS-0" = "OS-0", "PFS-1" = "PFS-1"),
  selected = "OS-1",
  multiple = FALSE,
  label = "Choose endpoint and Censor"
)

data_extract_spec(
  dataname = "ADTTE",
  filter = adtte_filters,
  select = select_spec(
    choices = c("AVAL", "BMRKR1", "AGE"),
    selected = c("AVAL", "BMRKR1"),
    multiple = TRUE,
    fixed = FALSE,
    label = "Column"
  )
)

data_extract_spec(
  dataname = "ADSL",
  filter = NULL,
  select = select_spec(
    choices = c("AGE", "SEX", "USUBJID"),
    selected = c("SEX"),
    multiple = FALSE,
    fixed = FALSE
  )
)
data_extract_spec(
  dataname = "ADSL",
  filter = filter_spec(
    vars = variable_choices("ADSL", subset = c("AGE"))
  )
)

dynamic_filter &lt;- filter_spec(
  vars = choices_selected(variable_choices("ADSL"), "COUNTRY"),
  multiple = TRUE
)
data_extract_spec(
  dataname = "ADSL",
  filter = dynamic_filter
)

</code></pre>

<hr>
<h2 id='data_extract_srv'>Extraction of the selector(s) details</h2><span id='topic+data_extract_srv'></span><span id='topic+data_extract_srv.FilteredData'></span><span id='topic+data_extract_srv.list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Extracting details of the selection(s) in <a href="#topic+data_extract_ui">data_extract_ui</a> elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_srv(id, datasets, data_extract_spec, ...)

## S3 method for class 'FilteredData'
data_extract_srv(id, datasets, data_extract_spec, ...)

## S3 method for class 'list'
data_extract_srv(
  id,
  datasets,
  data_extract_spec,
  join_keys = NULL,
  select_validation_rule = NULL,
  filter_validation_rule = NULL,
  dataset_validation_rule = if (is.null(select_validation_rule) &amp;&amp;
    is.null(filter_validation_rule)) {
     NULL
 } else {
    
    shinyvalidate::sv_required("Please select a dataset")
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_srv_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the module's
UI function.</p>
</td></tr>
<tr><td><code id="data_extract_srv_+3A_datasets">datasets</code></td>
<td>
<p>(<code>FilteredData</code> or <code>list</code> of <code>reactive</code> or non-<code>reactive</code> <code>data.frame</code>)
object containing data either in the form of <code>FilteredData</code> or as a list of <code>data.frame</code>.
When passing a list of non-reactive <code>data.frame</code> objects, they are converted to reactive <code>data.frame</code>s internally.
When passing a list of reactive or non-reactive <code>data.frame</code> objects, the argument <code>join_keys</code> is required also.</p>
</td></tr>
<tr><td><code id="data_extract_srv_+3A_data_extract_spec">data_extract_spec</code></td>
<td>
<p>(<code>data_extract_spec</code> or a list of <code>data_extract_spec</code>)
A list of data filter and select information constructed by <a href="#topic+data_extract_spec">data_extract_spec</a>.</p>
</td></tr>
<tr><td><code id="data_extract_srv_+3A_...">...</code></td>
<td>
<p>An additional argument <code>join_keys</code> is required when <code>datasets</code> is a list of <code>data.frame</code>.
It shall contain the keys per dataset in <code>datasets</code>.</p>
</td></tr>
<tr><td><code id="data_extract_srv_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code> or <code>NULL</code>) of keys per dataset in <code>datasets</code>.</p>
</td></tr>
<tr><td><code id="data_extract_srv_+3A_select_validation_rule">select_validation_rule</code></td>
<td>
<p>(<code>NULL</code> or <code>function</code>)
Should there be any <code>shinyvalidate</code> input validation of the select parts of the <code>data_extract_ui</code>.
</p>
<p>You can use a validation function directly (i.e. <code>select_validation_rule = shinyvalidate::sv_required()</code>)
or for more fine-grained control use a function:
</p>
<p><code>select_validation_rule = ~ if (length(.) &gt; 2) "Error"</code>.
</p>
<p>If <code>NULL</code> then no validation will be added. See example for more details.</p>
</td></tr>
<tr><td><code id="data_extract_srv_+3A_filter_validation_rule">filter_validation_rule</code></td>
<td>
<p>(<code>NULL</code> or <code>function</code>) Same as
<code>select_validation_rule</code> but for the filter (values) part of the <code>data_extract_ui</code>.</p>
</td></tr>
<tr><td><code id="data_extract_srv_+3A_dataset_validation_rule">dataset_validation_rule</code></td>
<td>
<p>(<code>NULL</code> or <code>function</code>) Same as
<code>select_validation_rule</code> but for the choose dataset part of the <code>data_extract_ui</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reactive <code>list</code> containing following fields:
</p>

<ul>
<li> <p><code>filters</code>: A list with the information on the filters that are applied to the data set.
</p>
</li>
<li> <p><code>select</code>: The variables that are selected from the dataset.
</p>
</li>
<li> <p><code>always_selected</code>: The column names from the data set that should always be selected.
</p>
</li>
<li> <p><code>reshape</code>: Whether reshape long to wide should be applied or not.
</p>
</li>
<li> <p><code>dataname</code>: The name of the data set.
</p>
</li>
<li> <p><code>internal_id</code>: The <code>id</code> of the corresponding shiny input element.
</p>
</li>
<li> <p><code>keys</code>: The names of the columns that can be used to merge the data set.
</p>
</li>
<li> <p><code>iv</code>: A <code>shinyvalidate::InputValidator</code> containing <code>validator</code> for this <code>data_extract</code>.
</p>
</li></ul>



<h3>References</h3>

<p><a href="#topic+data_extract_srv">data_extract_srv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(shinyvalidate)
library(teal.data)
library(teal.widgets)

# Sample ADSL dataset
ADSL &lt;- data.frame(
  STUDYID = "A",
  USUBJID = LETTERS[1:10],
  SEX = rep(c("F", "M"), 5),
  AGE = rpois(10, 30),
  BMRKR1 = rlnorm(10)
)

# Specification for data extraction
adsl_extract &lt;- data_extract_spec(
  dataname = "ADSL",
  filter = filter_spec(vars = "SEX", choices = c("F", "M"), selected = "F"),
  select = select_spec(
    label = "Select variable:",
    choices = variable_choices(ADSL, c("AGE", "BMRKR1")),
    selected = "AGE",
    multiple = TRUE,
    fixed = FALSE
  )
)

# Using reactive list of data.frames
data_list &lt;- list(ADSL = reactive(ADSL))

join_keys &lt;- join_keys(join_key("ADSL", "ADSL", c("STUDYID", "USUBJID")))

# App: data extraction with validation
ui &lt;- fluidPage(
  standard_layout(
    output = verbatimTextOutput("out1"),
    encoding = tagList(
      data_extract_ui(
        id = "adsl_var",
        label = "ADSL selection",
        data_extract_spec = adsl_extract
      )
    )
  )
)
server &lt;- function(input, output, session) {
  adsl_reactive_input &lt;- data_extract_srv(
    id = "adsl_var",
    datasets = data_list,
    data_extract_spec = adsl_extract,
    join_keys = join_keys,
    select_validation_rule = sv_required("Please select a variable.")
  )

  iv_r &lt;- reactive({
    iv &lt;- InputValidator$new()
    iv$add_validator(adsl_reactive_input()$iv)
    iv$enable()
    iv
  })

  output$out1 &lt;- renderPrint({
    if (iv_r()$is_valid()) {
      cat(format_data_extract(adsl_reactive_input()))
    } else {
      "Please fix errors in your selection"
    }
  })
}

if (interactive()) {
  shinyApp(ui, server)
}

# App: simplified data extraction
ui &lt;- fluidPage(
  standard_layout(
    output = verbatimTextOutput("out1"),
    encoding = tagList(
      data_extract_ui(
        id = "adsl_var",
        label = "ADSL selection",
        data_extract_spec = adsl_extract
      )
    )
  )
)

server &lt;- function(input, output, session) {
  adsl_reactive_input &lt;- data_extract_srv(
    id = "adsl_var",
    datasets = data_list,
    data_extract_spec = adsl_extract
  )

  output$out1 &lt;- renderPrint(adsl_reactive_input())
}

if (interactive()) {
  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='data_extract_ui'><code>teal</code> data extraction module user-interface</h2><span id='topic+data_extract_ui'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract_ui(id, label, data_extract_spec, is_single_dataset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_ui_+3A_id">id</code></td>
<td>
<p>(<code>character</code>) shiny input unique identifier.</p>
</td></tr>
<tr><td><code id="data_extract_ui_+3A_label">label</code></td>
<td>
<p>(<code>character</code>) Label above the data extract input.</p>
</td></tr>
<tr><td><code id="data_extract_ui_+3A_data_extract_spec">data_extract_spec</code></td>
<td>
<p>(<code>list</code> of <code>data_extract_spec</code>)
This is the outcome of listing <code><a href="#topic+data_extract_spec">data_extract_spec()</a></code> constructor calls.</p>
</td></tr>
<tr><td><code id="data_extract_ui_+3A_is_single_dataset">is_single_dataset</code></td>
<td>
<p>(<code>logical</code>) <code>FALSE</code> to display the dataset widget.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three inputs that will be rendered
</p>

<ol>
<li><p> Dataset select Optional. If more than one <a href="#topic+data_extract_spec">data_extract_spec</a> is handed over
to the function, a shiny <a href="shiny.html#topic+selectInput">shiny::selectInput</a> will be rendered. Else just the name
of the dataset is given.
</p>
</li>
<li><p> Filter Panel Optional. If the <a href="#topic+data_extract_spec">data_extract_spec</a> contains a
filter element a shiny <a href="shiny.html#topic+selectInput">shiny::selectInput</a> will be rendered with the options to
filter the dataset.
</p>
</li>
<li><p> Select panel A shiny <a href="shiny.html#topic+selectInput">shiny::selectInput</a> to select columns from the dataset to
go into the analysis.
</p>
</li></ol>

<p>The output can be analyzed using <code>data_extract_srv(...)</code>.
</p>
<p>This functionality should be used in the encoding panel of your <code>teal</code> app.
It will allow app-developers to specify a <code><a href="#topic+data_extract_spec">data_extract_spec()</a></code> object.
This object should be used to <code>teal</code> module variables being filtered data
from CDISC datasets.
</p>
<p>You can use this function in the same way as any
<a href="https://shiny.rstudio.com/articles/modules.html"><code style="white-space: pre;">&#8288;shiny module&#8288;</code></a> UI.
The corresponding server module can be found in <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
</p>


<h3>Value</h3>

<p>Shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput</a></code><code>s</code> that allow to define how to extract data from
a specific dataset. The input elements will be returned inside a <a href="shiny.html#topic+reexports">shiny::div</a> container.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(teal.widgets)

adtte_filters &lt;- filter_spec(
  vars = c("PARAMCD", "CNSR"),
  sep = "-",
  choices = c("OS-1" = "OS-1", "OS-0" = "OS-0", "PFS-1" = "PFS-1"),
  selected = "OS-1",
  multiple = FALSE,
  label = "Choose endpoint and Censor"
)

response_spec &lt;- data_extract_spec(
  dataname = "ADTTE",
  filter = adtte_filters,
  select = select_spec(
    choices = c("AVAL", "BMRKR1", "AGE"),
    selected = c("AVAL", "BMRKR1"),
    multiple = TRUE,
    fixed = FALSE,
    label = "Column"
  )
)
# Call to use inside your teal module UI function
standard_layout(
  output = tableOutput("table"),
  encoding = div(
    data_extract_ui(
      id = "regressor",
      label = "Regressor Variable",
      data_extract_spec = response_spec
    )
  )
)

</code></pre>

<hr>
<h2 id='datanames_input'>Help text with available datasets input</h2><span id='topic+datanames_input'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Creates <code><a href="shiny.html#topic+helpText">shiny::helpText()</a></code> with the names of available datasets for the
current module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datanames_input(data_extracts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datanames_input_+3A_data_extracts">data_extracts</code></td>
<td>
<p>(<code>list</code>) of data extracts for single variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>shiny.tag</code> defining help-text element that can be added to a UI element.
</p>

<hr>
<h2 id='extract_choices_labels'>Extract labels from choices basing on attributes and names</h2><span id='topic+extract_choices_labels'></span>

<h3>Description</h3>

<p>Extract labels from choices basing on attributes and names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_choices_labels(choices, values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_choices_labels_+3A_choices">choices</code></td>
<td>
<p>(<code>list</code> or <code>vector</code>) select choices.</p>
</td></tr>
<tr><td><code id="extract_choices_labels_+3A_values">values</code></td>
<td>
<p>(optional <code>list</code> or <code>vector</code>) with subset of <code>choices</code> for which
labels should be extracted, <code>NULL</code> for all choices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector with labels.
</p>

<hr>
<h2 id='filter_spec'>Data extract filter specification</h2><span id='topic+filter_spec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>It consists in choices and additionally the variable names for the choices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_spec(
  vars,
  choices = NULL,
  selected = if (inherits(choices, "delayed_data")) NULL else choices[1],
  multiple = length(selected) &gt; 1 || inherits(selected, "all_choices"),
  label = "Filter by",
  sep = attr(choices, "sep"),
  drop_keys = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_spec_+3A_vars">vars</code></td>
<td>
<p>(<code>character</code> or <code>delayed_data</code>) object.
Character vector giving the columns to be filtered. These should be
key variables of the data set to be filtered.
<code>delayed_data</code> objects can be created via <code><a href="#topic+variable_choices">variable_choices()</a></code>, <code><a href="#topic+value_choices">value_choices()</a></code>,
or <code><a href="#topic+choices_selected">choices_selected()</a></code>.</p>
</td></tr>
<tr><td><code id="filter_spec_+3A_choices">choices</code></td>
<td>
<p>(<code>character</code> or <code>numeric</code> or <code>logical</code> or (<code>delayed_data</code>) object.
Named character vector to define the choices of a shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>.
These choices will be used to filter the dataset.
</p>
<p>These shall be filter values of the <code>vars</code> input separated by the separator(<code>sep</code>). Please
watch out that the filter values have to follow the order of the <code>vars</code> input. In the following
example we will show how to filter two columns:
</p>
<p><code>vars = c("PARAMCD","AVISIT")</code> and <code>choices = c("CRP - BASELINE", "ALT - BASELINE")</code>
will lead to a filtering of
<code>(PARAMCD == "CRP" &amp; AVISIT == "BASELINE") | (PARAMCD == "ALT" &amp; AVISIT == "BASELINE")</code>.
</p>
<p>The <code>sep</code> input has to be <code>" - "</code> in this case.
</p>
<p><code>delayed_data</code> objects can be created via <code><a href="#topic+variable_choices">variable_choices()</a></code> or <code><a href="#topic+value_choices">value_choices()</a></code>.</p>
</td></tr>
<tr><td><code id="filter_spec_+3A_selected">selected</code></td>
<td>
<p>(<code>character</code> or <code>numeric</code> or <code>logical</code> or (<code>delayed_data</code> or <code>all_choices</code>) object.
Named character vector to define the selected values of a shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>
(default values).
This value will be displayed inside the shiny app upon start.
The <code>all_choices</code> object indicates selecting all possible choices.</p>
</td></tr>
<tr><td><code id="filter_spec_+3A_multiple">multiple</code></td>
<td>
<p>(<code>logical</code>) Whether multiple values shall be allowed in the
shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>.</p>
</td></tr>
<tr><td><code id="filter_spec_+3A_label">label</code></td>
<td>
<p>(optional <code>character</code>). Define a label on top of this specific
shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>. The default value is <code>"Filter by"</code>.</p>
</td></tr>
<tr><td><code id="filter_spec_+3A_sep">sep</code></td>
<td>
<p>(<code>character</code>) A separator string to split the <code>choices</code> or
<code>selected</code> inputs into the values of the different columns.</p>
</td></tr>
<tr><td><code id="filter_spec_+3A_drop_keys">drop_keys</code></td>
<td>
<p>(optional <code>logical</code>) whether to drop filter column from the
dataset keys, <code>TRUE</code> on default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>filter_spec</code> is used inside <code>teal</code> apps to allow filtering datasets
for their key variables. Imagine having an adverse events table. It has
the columns <code>PARAMCD</code> and <code>CNSR</code>. <code>PARAMCD</code> contains the levels
<code>"OS"</code>, <code>"PFS"</code>, <code>"EFS"</code>. <code>CNSR</code> contains the levels <code>"0"</code> and <code>"1"</code>.
The first example should show how a <code>filter_spec</code> setup will influence
the drop-down menu the app user will see.
</p>


<h3>Value</h3>

<p><code>filter_spec</code>-S3-class object or <code>delayed_filter_spec</code>-S3-class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for Adverse Events table
filter_spec(
  vars = c("PARAMCD", "CNSR"),
  sep = "-",
  choices = c("OS-1" = "OS-1", "OS-0" = "OS-0", "PFS-1" = "PFS-1"),
  selected = "OS-1",
  multiple = FALSE,
  label = "Choose endpoint and Censor"
)

# filtering a single variable
filter_spec(
  vars = c("PARAMCD"),
  sep = "-",
  choices = c("OS", "PFS", "EFS"),
  selected = "OS",
  multiple = FALSE,
  label = "Choose endpoint"
)

# filtering a single variable by multiple levels of the variable
filter_spec(
  vars = c("PARAMCD"),
  sep = "-",
  choices = c("OS", "PFS", "EFS"),
  selected = c("OS", "PFS"),
  multiple = TRUE,
  label = "Choose endpoint"
)

# delayed version
filter_spec(
  vars = variable_choices("ADSL", "SEX"),
  sep = "-",
  choices = value_choices("ADSL", "SEX", "SEX"),
  selected = "F",
  multiple = FALSE,
  label = "Choose endpoint and Censor"
)
# using `choices_selected()`
filter_spec(
  vars = choices_selected(variable_choices("ADSL", subset = c("SEX", "AGE")), "SEX", fixed = FALSE),
  multiple = TRUE
)

filter_spec(
  vars = choices_selected(variable_choices("ADSL"), "SEX", fixed = TRUE),
  multiple = TRUE
)

# choose all choices
adsl_filter &lt;- filter_spec(
  vars = choices_selected(variable_choices("ADSL"), "SEX", fixed = FALSE),
  choices = value_choices("ADSL", "SEX"),
  selected = all_choices()
)
</code></pre>

<hr>
<h2 id='filter_spec_internal'>Data extract dynamic filter specification</h2><span id='topic+filter_spec_internal'></span><span id='topic+filter_spec_internal.delayed_data'></span><span id='topic+filter_spec_internal.default'></span>

<h3>Description</h3>

<p>Builds a configuration for the <code>data_extract_ui</code> module. This function covers
the configuration of filtering datasets (so called <code>filter_spec</code>), which then
is used to build the UI element in the <code>teal</code> app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_spec_internal(
  vars_choices,
  vars_selected = NULL,
  vars_label = NULL,
  vars_fixed = FALSE,
  vars_multiple = TRUE,
  choices = NULL,
  selected = NULL,
  label = NULL,
  fixed = FALSE,
  multiple = TRUE,
  sep = attr(vars_choices, "sep"),
  drop_keys = FALSE,
  dataname = NULL,
  initialized = FALSE
)

## S3 method for class 'delayed_data'
filter_spec_internal(
  vars_choices,
  vars_selected = NULL,
  vars_label = NULL,
  vars_fixed = FALSE,
  vars_multiple = TRUE,
  choices = NULL,
  selected = NULL,
  label = NULL,
  fixed = FALSE,
  multiple = TRUE,
  sep = attr(vars_choices, "sep"),
  drop_keys = FALSE,
  dataname = NULL,
  initialized = FALSE
)

## Default S3 method:
filter_spec_internal(
  vars_choices,
  vars_selected = NULL,
  vars_label = NULL,
  vars_fixed = FALSE,
  vars_multiple = TRUE,
  choices = NULL,
  selected = NULL,
  label = NULL,
  fixed = FALSE,
  multiple = TRUE,
  sep = attr(vars_choices, "sep"),
  drop_keys = FALSE,
  dataname = NULL,
  initialized = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_spec_internal_+3A_vars_choices">vars_choices</code></td>
<td>
<p>(<code>character</code> or <code>delayed_data</code>)
the vector of dataset column names available to build dynamic filter
<code>delayed_data</code> objects can be created via <code><a href="#topic+variable_choices">variable_choices()</a></code>.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_vars_selected">vars_selected</code></td>
<td>
<p>(<code>NULL</code> or named <code>character</code>)
the selected column name out from <code>choices</code>.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_vars_label">vars_label</code></td>
<td>
<p>(<code>character</code>)
the title printed on the UI element generated on the basis of this <code>filter_spec</code>.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_vars_fixed">vars_fixed</code></td>
<td>
<p>(<code>logical</code>)
if true allow to change the selected variables in the UI element; otherwise, do not allow.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_vars_multiple">vars_multiple</code></td>
<td>
<p>(<code>logical</code>)
if true allow to select multiple variables in the UI elements; otherwise, do not allow.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_choices">choices</code></td>
<td>
<p>(<code>character</code> or <code>numeric</code> or <code>logical</code> or (<code>delayed_data</code>) object.
Named character vector to define the choices of a shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>.
These choices will be used to filter the dataset.
</p>
<p>These shall be filter values of the <code>vars</code> input separated by the separator(<code>sep</code>). Please
watch out that the filter values have to follow the order of the <code>vars</code> input. In the following
example we will show how to filter two columns:
</p>
<p><code>vars = c("PARAMCD","AVISIT")</code> and <code>choices = c("CRP - BASELINE", "ALT - BASELINE")</code>
will lead to a filtering of
<code>(PARAMCD == "CRP" &amp; AVISIT == "BASELINE") | (PARAMCD == "ALT" &amp; AVISIT == "BASELINE")</code>.
</p>
<p>The <code>sep</code> input has to be <code>" - "</code> in this case.
</p>
<p><code>delayed_data</code> objects can be created via <code><a href="#topic+variable_choices">variable_choices()</a></code> or <code><a href="#topic+value_choices">value_choices()</a></code>.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_selected">selected</code></td>
<td>
<p>(<code>character</code> or <code>numeric</code> or <code>logical</code> or (<code>delayed_data</code> or <code>all_choices</code>) object.
Named character vector to define the selected values of a shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>
(default values).
This value will be displayed inside the shiny app upon start.
The <code>all_choices</code> object indicates selecting all possible choices.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_label">label</code></td>
<td>
<p>(optional <code>character</code>). Define a label on top of this specific
shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>. The default value is <code>"Filter by"</code>.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_fixed">fixed</code></td>
<td>
<p>(<code>logical</code>)
if true allow to change the initially selected values of the variables; otherwise, do not allow.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_multiple">multiple</code></td>
<td>
<p>(<code>logical</code>) Whether multiple values shall be allowed in the
shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_sep">sep</code></td>
<td>
<p>(<code>character</code>) A separator string to split the <code>choices</code> or
<code>selected</code> inputs into the values of the different columns.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_drop_keys">drop_keys</code></td>
<td>
<p>(optional <code>logical</code>) whether to drop filter column from the
dataset keys, <code>TRUE</code> on default.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_dataname">dataname</code></td>
<td>
<p>(<code>character</code>)
the name of the dataset this filter covers. Set during the initialization of the <code>teal</code> application.</p>
</td></tr>
<tr><td><code id="filter_spec_internal_+3A_initialized">initialized</code></td>
<td>
<p>(<code>logical</code>)
indicates whether this filter was already initialized in the application.
TRUE if this filter was already consumed by the server function; FALSE otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>filter_spec</code> or <code>delayed_filter_spec</code> S3-class object.
</p>


<h3>See Also</h3>

<p>filter_spec
</p>

<hr>
<h2 id='format_data_extract'>Formatting data extracts</h2><span id='topic+format_data_extract'></span>

<h3>Description</h3>

<p>Returns a human-readable string representation of an extracted <code>data_extract_spec</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_data_extract(data_extract)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_data_extract_+3A_data_extract">data_extract</code></td>
<td>
<p><code>list</code> the list output of <code>data_extract_srv</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function formats the output of <code><a href="#topic+data_extract_srv">data_extract_srv</a></code>.
See the example for more information.
</p>


<h3>Value</h3>

<p><code>character(1)</code> representation of the <code>data_extract</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
simple_des &lt;- data_extract_spec(
  dataname = "iris",
  filter = filter_spec(vars = "Petal.Length", choices = c("1.4", "1.5")),
  select = select_spec(choices = c("Petal.Length", "Species"))
)

ui &lt;- fluidPage(
  data_extract_ui(
    id = "extract",
    label = "data extract ui",
    data_extract_spec = simple_des,
    is_single_dataset = TRUE
  ),
  verbatimTextOutput("formatted_extract")
)
server &lt;- function(input, output, session) {
  extracted_input &lt;- data_extract_srv(
    id = "extract",
    datasets = list(iris = iris),
    data_extract_spec = simple_des
  )
  output$formatted_extract &lt;- renderPrint({
    cat(format_data_extract(extracted_input()))
  })
}

if (interactive()) {
  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='get_anl_relabel_call'>Gets the relabel call</h2><span id='topic+get_anl_relabel_call'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_anl_relabel_call(columns_source, datasets, anl_name = "ANL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_anl_relabel_call_+3A_columns_source">columns_source</code></td>
<td>
<p>(named <code>list</code>)
where names are column names, values are labels + additional attribute <code>dataname</code></p>
</td></tr>
<tr><td><code id="get_anl_relabel_call_+3A_datasets">datasets</code></td>
<td>
<p>(named <code>list</code> of <code>reactive</code> or non-<code>reactive</code> <code>data.frame</code>)
object containing data as a list of <code>data.frame</code>.
When passing a list of non-reactive <code>data.frame</code> objects, they are
converted to reactive <code>data.frame</code> objects internally.</p>
</td></tr>
<tr><td><code id="get_anl_relabel_call_+3A_anl_name">anl_name</code></td>
<td>
<p>(<code>character(1)</code>)
Name of the analysis dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>call</code>) to relabel <code>dataset</code> and assign to <code>anl_name</code>.
</p>

<hr>
<h2 id='get_dataset_prefixed_col_names'>Returns non-key column names from data</h2><span id='topic+get_dataset_prefixed_col_names'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dataset_prefixed_col_names(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dataset_prefixed_col_names_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>) Data with attribute <code>filter_and_columns</code>. This can only be
created by <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>, which returns a shiny <code><a href="shiny.html#topic+reactive">shiny::reactive()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>character</code> vector with the non-key columns of the <code>data</code>.
</p>


<h3>References</h3>

<p><code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>
</p>

<hr>
<h2 id='get_dplyr_call'>Parses filter, select, rename and reshape call</h2><span id='topic+get_dplyr_call'></span>

<h3>Description</h3>

<p>Parses filter, select, rename and reshape call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dplyr_call(
  selector_list,
  idx = 1L,
  join_keys = teal.data::join_keys(),
  dplyr_call_data = get_dplyr_call_data(selector_list, join_keys = join_keys),
  datasets = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dplyr_call_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="get_dplyr_call_+3A_idx">idx</code></td>
<td>
<p>optional (<code>integer</code>) current selector index in all selectors list.</p>
</td></tr>
<tr><td><code id="get_dplyr_call_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>) nested list of keys used for joining.</p>
</td></tr>
<tr><td><code id="get_dplyr_call_+3A_dplyr_call_data">dplyr_call_data</code></td>
<td>
<p>(<code>list</code>) simplified selectors with aggregated set of filters,
selections, reshapes etc. All necessary data for merging.</p>
</td></tr>
<tr><td><code id="get_dplyr_call_+3A_data">data</code></td>
<td>
<p>(<code>NULL</code> or named <code>list</code>) of datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>call</code>) filter, select, rename and reshape call.
</p>

<hr>
<h2 id='get_dplyr_call_data'>Aggregates data extract selectors</h2><span id='topic+get_dplyr_call_data'></span>

<h3>Description</h3>

<p>Simplifies <code>selector_list</code> into aggregated list with one element per
same selector - same dataset, same filter configuration and same reshape status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dplyr_call_data(selector_list, join_keys = teal.data::join_keys())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dplyr_call_data_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="get_dplyr_call_data_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>) nested list of keys used for joining.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code>) simplified selectors with aggregated set of filters,
selections, reshapes etc. All necessary data for merging.
</p>

<hr>
<h2 id='get_dropped_filters'>Names of filtered-out filters dropped from selection</h2><span id='topic+get_dropped_filters'></span>

<h3>Description</h3>

<p>Names of filtered-out filters dropped from selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dropped_filters(selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dropped_filters_+3A_selector">selector</code></td>
<td>
<p>one element of selector_list obtained by <code>get_dplyr_call_data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Names of filtered-out filters dropped from automatic selection
(key vars are automatically included in select).
Dropped filter is filter which became not unique for all observations.
This means that if variable is filtered to just one level,
it's not a key anymore.
</p>
<p>Other variables used in filter should also be dropped from automatic
selection, unless they have been selected.
</p>


<h3>Value</h3>

<p>Vector of <code>character</code> names of the filters which should be dropped from select call.
</p>

<hr>
<h2 id='get_extract_datanames'>Gets names of the datasets from a list of <code>data_extract_spec</code> objects</h2><span id='topic+get_extract_datanames'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Fetches <code>dataname</code> slot per <code>data_extract_spec</code> from a list of
<code>data_extract_spec</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_extract_datanames(data_extracts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_extract_datanames_+3A_data_extracts">data_extracts</code></td>
<td>
<p>(<code>data_extract_spec(1)</code>) object or a list (of lists)
of <code>data_extract_spec</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector with the unique <code>dataname</code> set.
</p>

<hr>
<h2 id='get_filter_call'>Build a <code>dplyr</code> filter call</h2><span id='topic+get_filter_call'></span>

<h3>Description</h3>

<p>Build a <code>dplyr</code> filter call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_filter_call(filter, dataname = NULL, datasets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_filter_call_+3A_filter">filter</code></td>
<td>
<p>(<code>list</code>) Either list of lists or list with <code>select</code> and <code>selected</code> items.</p>
</td></tr>
<tr><td><code id="get_filter_call_+3A_dataname">dataname</code></td>
<td>
<p>(<code>NULL</code> or <code>character</code>) name of dataset.</p>
</td></tr>
<tr><td><code id="get_filter_call_+3A_datasets">datasets</code></td>
<td>
<p>(<code>NULL</code> or named <code>list</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dplyr</code> filter <code>call</code>.
</p>

<hr>
<h2 id='get_initial_filter_values'>Returns the initial values for the <code>vals</code> widget of a <code>filter_spec</code> object</h2><span id='topic+get_initial_filter_values'></span>

<h3>Description</h3>

<p>Returns the initial values for the <code>vals</code> widget of a <code>filter_spec</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_initial_filter_values(filter, datasets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_initial_filter_values_+3A_filter">filter</code></td>
<td>
<p>(<code>filter_spec</code>) the filter generated by a call to <code><a href="#topic+filter_spec">filter_spec()</a></code>.</p>
</td></tr>
<tr><td><code id="get_initial_filter_values_+3A_datasets">datasets</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;named list&#8288;</code>) a list of reactive <code>data.frame</code> type objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named <code>list</code> with two slots <code>choices</code> and <code>selected</code>.
</p>

<hr>
<h2 id='get_merge_call'>Get merge call from a list of selectors</h2><span id='topic+get_merge_call'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Creates list of calls depending on selector(s) and type of the merge.
The merge order is the same as in selectors passed to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_merge_call(
  selector_list,
  join_keys = teal.data::join_keys(),
  dplyr_call_data = get_dplyr_call_data(selector_list, join_keys = join_keys),
  merge_function = "dplyr::full_join",
  anl_name = "ANL"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_merge_call_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="get_merge_call_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>) nested list of keys used for joining.</p>
</td></tr>
<tr><td><code id="get_merge_call_+3A_dplyr_call_data">dplyr_call_data</code></td>
<td>
<p>(<code>list</code>) simplified selectors with aggregated set of filters.</p>
</td></tr>
<tr><td><code id="get_merge_call_+3A_merge_function">merge_function</code></td>
<td>
<p>(<code>character(1)</code> or <code>reactive</code>)
A character string of a function that accepts the arguments
<code>x</code>, <code>y</code> and <code>by</code> to perform the merging of datasets.</p>
</td></tr>
<tr><td><code id="get_merge_call_+3A_anl_name">anl_name</code></td>
<td>
<p>(<code>character(1)</code>)
Name of the analysis dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with merge <code>call</code> elements.
</p>

<hr>
<h2 id='get_merge_key_grid'>Gets merge key pair list from keys list</h2><span id='topic+get_merge_key_grid'></span>

<h3>Description</h3>

<p>Gets merge key pair list from keys list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_merge_key_grid(selector_list, join_keys = teal.data::join_keys())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_merge_key_grid_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="get_merge_key_grid_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>) nested list of keys used for joining.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of merge key pairs between all datasets.
</p>

<hr>
<h2 id='get_merge_key_i'>Gets keys needed for join call of two selectors</h2><span id='topic+get_merge_key_i'></span>

<h3>Description</h3>

<p>Gets keys needed for join call of two selectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_merge_key_i(
  selector_list,
  idx,
  dplyr_call_data = get_dplyr_call_data(selector_list)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_merge_key_i_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="get_merge_key_i_+3A_idx">idx</code></td>
<td>
<p>(optional <code>integer</code>) current selector index in all selectors list.</p>
</td></tr>
<tr><td><code id="get_merge_key_i_+3A_dplyr_call_data">dplyr_call_data</code></td>
<td>
<p>(<code>list</code>) simplified selectors with aggregated set of filters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> list of keys.
</p>

<hr>
<h2 id='get_merge_key_pair'>Gets keys vector from keys list</h2><span id='topic+get_merge_key_pair'></span>

<h3>Description</h3>

<p>Gets keys vector from keys list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_merge_key_pair(selector_from, selector_to, key_from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_merge_key_pair_+3A_selector_from">selector_from</code></td>
<td>
<p>(<code>list</code>) of <code>data_extract_srv</code> objects.</p>
</td></tr>
<tr><td><code id="get_merge_key_pair_+3A_selector_to">selector_to</code></td>
<td>
<p>(<code>list</code>) of <code>data_extract_srv</code> objects.</p>
</td></tr>
<tr><td><code id="get_merge_key_pair_+3A_key_from">key_from</code></td>
<td>
<p>(<code>character</code>) keys used in the first selector while joining.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function covers up to now 4 cases:
</p>

<ul>
<li><p> Dataset without parent: Primary keys are returned;
</p>
</li>
<li><p> Dataset source = dataset target:
The primary keys subtracted of all key columns that get purely filtered.
This means just one value would be left after filtering inside this column
Then it can be taken out;
</p>
</li>
<li><p> Target <code>dataname</code> is parent foreign keys;
</p>
</li>
<li><p> Any other case foreign keys;
</p>
</li></ul>



<h3>Value</h3>

<p><code>character</code> vector of selector keys.
</p>

<hr>
<h2 id='get_pivot_longer_col'>Get pivot longer  columns</h2><span id='topic+get_pivot_longer_col'></span>

<h3>Description</h3>

<p>Get values names which are spread into columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pivot_longer_col(selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pivot_longer_col_+3A_selector">selector</code></td>
<td>
<p>one element of selector_list obtained by <code>get_dplyr_call_data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of all the selected columns that are not a <code>keys</code> element.
</p>

<hr>
<h2 id='get_relabel_call'>Create relabel call from named character</h2><span id='topic+get_relabel_call'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Function creates relabel call from named character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_relabel_call(labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_relabel_call_+3A_labels">labels</code></td>
<td>
<p>(named <code>character</code>)
where name is name is function argument name and value is a function argument value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>call</code> object with relabel step.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_relabel_call(
  labels = c(
    x = as.name("ANL"),
    AGE = "Age",
    AVAL = "Continuous variable"
  )
)

get_relabel_call(
  labels = c(
    AGE = "Age",
    AVAL = "Continuous variable"
  )
)
</code></pre>

<hr>
<h2 id='get_relabel_cols'>Get columns to relabel</h2><span id='topic+get_relabel_cols'></span>

<h3>Description</h3>

<p>Get columns to relabel excluding these which has been reshaped (pivot_wider).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_relabel_cols(columns_source, dplyr_call_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_relabel_cols_+3A_columns_source">columns_source</code></td>
<td>
<p>(<code>list</code>)</p>
</td></tr>
<tr><td><code id="get_relabel_cols_+3A_dplyr_call_data">dplyr_call_data</code></td>
<td>
<p>(<code>list</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>columns_source</code> list without columns that have been reshaped.
</p>

<hr>
<h2 id='get_rename_call'>Returns <code>dplyr</code> rename call</h2><span id='topic+get_rename_call'></span>

<h3>Description</h3>

<p>Rename is used only if there are duplicated columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rename_call(
  selector_list = list(),
  idx = 1L,
  join_keys = teal.data::join_keys(),
  dplyr_call_data = get_dplyr_call_data(selector_list, join_keys = join_keys)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rename_call_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="get_rename_call_+3A_idx">idx</code></td>
<td>
<p>optional (<code>integer</code>) current selector index in all selectors list.</p>
</td></tr>
<tr><td><code id="get_rename_call_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>) nested list of keys used for joining.</p>
</td></tr>
<tr><td><code id="get_rename_call_+3A_dplyr_call_data">dplyr_call_data</code></td>
<td>
<p>(<code>list</code>) simplified selectors with aggregated set of filters,
selections, reshapes etc. All necessary data for merging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>call</code>) <code>dplyr</code> rename call.
</p>

<hr>
<h2 id='get_reshape_call'>Returns <code>dplyr</code> reshape call</h2><span id='topic+get_reshape_call'></span>

<h3>Description</h3>

<p>Returns <code>dplyr</code> reshape call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reshape_call(
  selector_list = list(),
  idx = 1L,
  join_keys = teal.data::join_keys(),
  dplyr_call_data = get_dplyr_call_data(selector_list, join_keys = join_keys)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_reshape_call_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="get_reshape_call_+3A_idx">idx</code></td>
<td>
<p>optional (<code>integer</code>) current selector index in all selectors list.</p>
</td></tr>
<tr><td><code id="get_reshape_call_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>) nested list of keys used for joining.</p>
</td></tr>
<tr><td><code id="get_reshape_call_+3A_dplyr_call_data">dplyr_call_data</code></td>
<td>
<p>(<code>list</code>) simplified selectors with aggregated set of filters,
selections, reshapes etc. All necessary data for merging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of multiple <code>dplyr</code> calls that reshape data.
</p>

<hr>
<h2 id='get_reshape_unite_col'>Get unite columns</h2><span id='topic+get_reshape_unite_col'></span>

<h3>Description</h3>

<p>Get key names which spreads values into columns. Reshape is done only
on keys which are in <code>filter_spec</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reshape_unite_col(selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_reshape_unite_col_+3A_selector">selector</code></td>
<td>
<p>one element of selector_list obtained by <code>get_dplyr_call_data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of all the selector's keys that are defined in the filters.
</p>

<hr>
<h2 id='get_reshape_unite_vals'>Get unite columns values</h2><span id='topic+get_reshape_unite_vals'></span>

<h3>Description</h3>

<p>Get key values (levels) of the unite columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reshape_unite_vals(selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_reshape_unite_vals_+3A_selector">selector</code></td>
<td>
<p>one element of selector_list obtained by <code>get_dplyr_call_data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of keys of the unite columns.
</p>

<hr>
<h2 id='get_select_call'>Parse <code>dplyr</code> select call</h2><span id='topic+get_select_call'></span>

<h3>Description</h3>

<p>Parse <code>dplyr</code> select call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_select_call(select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_select_call_+3A_select">select</code></td>
<td>
<p>(<code>character</code>) vector of selected column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dplyr</code> select <code>call</code>.
</p>

<hr>
<h2 id='id_for_dataset'>Generate id for dataset</h2><span id='topic+id_for_dataset'></span>

<h3>Description</h3>

<p>Generate id for dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_for_dataset(dataname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_for_dataset_+3A_dataname">dataname</code></td>
<td>
<p>(<code>character(1)</code>) the name of the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character(1)</code>.
</p>

<hr>
<h2 id='include_css_files'>Include <code>CSS</code> files from <code style="white-space: pre;">&#8288;/inst/css/&#8288;</code> package directory to application header</h2><span id='topic+include_css_files'></span>

<h3>Description</h3>

<p><code>system.file</code> should not be used to access files in other packages, it does
not work with <code>devtools</code>.
As a result, this method is individually redefined as required in each package.
Therefore, this function is not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>include_css_files(pattern = "*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="include_css_files_+3A_pattern">pattern</code></td>
<td>
<p>(<code>character</code>) pattern of files to be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HTML code that includes <code>CSS</code> files.
</p>

<hr>
<h2 id='is_single_dataset'>Verify uniform dataset source across data extract specification</h2><span id='topic+is_single_dataset'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Checks if the input <code>data_extract_spec</code> objects all come from the same dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_single_dataset(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_single_dataset_+3A_...">...</code></td>
<td>
<p>either <code>data_extract_spec</code> objects or lists of <code>data_extract_spec</code>
objects that do not contain <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all <code>data_extract_spec</code> objects come from the same dataset,
<code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='list_extract_spec'>Make sure that the extract specification is in list format</h2><span id='topic+list_extract_spec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_extract_spec(x, allow_null = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_extract_spec_+3A_x">x</code></td>
<td>
<p>(<code>data_extract_spec</code> or <code>list</code>) of <code>data_extract_spec</code> elements.</p>
</td></tr>
<tr><td><code id="list_extract_spec_+3A_allow_null">allow_null</code></td>
<td>
<p>(<code>logical</code>) whether x can be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> as a list if it is not already.
</p>

<hr>
<h2 id='merge_datasets'>Merge the datasets on the keys</h2><span id='topic+merge_datasets'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Combines/merges multiple datasets with specified keys attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_datasets(
  selector_list,
  datasets,
  join_keys,
  merge_function = "dplyr::full_join",
  anl_name = "ANL"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_datasets_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="merge_datasets_+3A_datasets">datasets</code></td>
<td>
<p>(named <code>list</code> of <code>reactive</code> or non-<code>reactive</code> <code>data.frame</code>)
object containing data as a list of <code>data.frame</code>.
When passing a list of non-reactive <code>data.frame</code> objects, they are
converted to reactive <code>data.frame</code> objects internally.</p>
</td></tr>
<tr><td><code id="merge_datasets_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>)
of variables used as join keys for each of the datasets in <code>datasets</code>.
This will be used to extract the <code>keys</code> of every dataset.</p>
</td></tr>
<tr><td><code id="merge_datasets_+3A_merge_function">merge_function</code></td>
<td>
<p>(<code>character(1)</code> or <code>reactive</code>)
A character string of a function that accepts the arguments
<code>x</code>, <code>y</code> and <code>by</code> to perform the merging of datasets.</p>
</td></tr>
<tr><td><code id="merge_datasets_+3A_anl_name">anl_name</code></td>
<td>
<p>(<code>character(1)</code>)
Name of the analysis dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally this function uses calls to allow reproducibility.
</p>
<p>This function is often used inside a <code>teal</code> module server function with the
<code>selectors</code> being the output of <code>data_extract_srv</code> or <code>data_extract_multiple_srv</code>.
</p>
<div class="sourceCode"><pre># inside teal module server function

response &lt;- data_extract_srv(
  id = "reponse",
  data_extract_spec = response_spec,
  datasets = datasets
)
regressor &lt;- data_extract_srv(
  id = "regressor",
  data_extract_spec = regressor_spec,
  datasets = datasets
)
merged_data &lt;- merge_datasets(list(regressor(), response()))
</pre></div>


<h3>Value</h3>

<p><code>merged_dataset</code> list containing:
</p>

<ul>
<li> <p><code>expr</code> (<code>list</code> of <code>call</code>) code needed to replicate merged dataset;
</p>
</li>
<li> <p><code>columns_source</code> (<code>list</code>) of column names selected for particular selector;
Each list element contains named character vector where:
</p>

<ul>
<li><p> Values are the names of the columns in the <code>ANL</code>. In case if the same column name is selected in more than one
selector it gets prefixed by the id of the selector. For example if two <code>data_extract</code> have id <code>x</code>, <code>y</code>, then
their duplicated selected variable (for example <code>AGE</code>) is prefixed to be <code>x.AGE</code> and <code>y.AGE</code>;
</p>
</li>
<li><p> Names of the vector denote names of the variables in the input dataset;
</p>
</li>
<li> <p><code>attr(,"dataname")</code> to indicate which dataset variable is merged from;
</p>
</li>
<li> <p><code>attr(, "always selected")</code> to denote the names of the variables which need to be always selected;
</p>
</li></ul>

</li>
<li> <p><code>keys</code> (<code>list</code>) the keys of the merged dataset;
</p>
</li>
<li> <p><code>filter_info</code> (<code>list</code>) The information given by the user. This information
defines the filters that are applied on the data. Additionally it defines
the variables that are selected from the data sets.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(teal.data)

X &lt;- data.frame(A = c(1, 1:3), B = 2:5, D = 1:4, E = letters[1:4], G = letters[6:9])
Y &lt;- data.frame(A = c(1, 1, 2), B = 2:4, C = c(4, 4:5), E = letters[4:6], G = letters[1:3])
join_keys &lt;- join_keys(join_key("X", "Y", c("A", "B")))

selector_list &lt;- list(
  list(
    dataname = "X",
    filters = NULL,
    select = "E",
    keys = c("A", "B"),
    reshape = FALSE,
    internal_id = "x"
  ),
  list(
    dataname = "Y",
    filters = NULL,
    select = "G",
    keys = c("A", "C"),
    reshape = FALSE,
    internal_id = "y"
  )
)

data_list &lt;- list(X = reactive(X), Y = reactive(Y))

merged_datasets &lt;- isolate(
  merge_datasets(
    selector_list = selector_list,
    datasets = data_list,
    join_keys = join_keys
  )
)

paste(merged_datasets$expr)
</code></pre>

<hr>
<h2 id='merge_expression_module'>Merge expression module</h2><span id='topic+merge_expression_module'></span><span id='topic+merge_expression_module.reactive'></span><span id='topic+merge_expression_module.list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Convenient wrapper to combine <code>data_extract_multiple_srv()</code> and
<code>merge_expression_srv()</code> when no additional processing is required.
Compare the example below with that found in <code><a href="#topic+merge_expression_srv">merge_expression_srv()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_expression_module(
  datasets,
  join_keys = NULL,
  data_extract,
  merge_function = "dplyr::full_join",
  anl_name = "ANL",
  id = "merge_id"
)

## S3 method for class 'reactive'
merge_expression_module(
  datasets,
  join_keys = NULL,
  data_extract,
  merge_function = "dplyr::full_join",
  anl_name = "ANL",
  id = "merge_id"
)

## S3 method for class 'list'
merge_expression_module(
  datasets,
  join_keys = NULL,
  data_extract,
  merge_function = "dplyr::full_join",
  anl_name = "ANL",
  id = "merge_id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_expression_module_+3A_datasets">datasets</code></td>
<td>
<p>(named <code>list</code> of <code>reactive</code> or non-<code>reactive</code> <code>data.frame</code>)
object containing data as a list of <code>data.frame</code>.
When passing a list of non-reactive <code>data.frame</code> objects, they are
converted to reactive <code>data.frame</code> objects internally.</p>
</td></tr>
<tr><td><code id="merge_expression_module_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>)
of variables used as join keys for each of the datasets in <code>datasets</code>.
This will be used to extract the <code>keys</code> of every dataset.</p>
</td></tr>
<tr><td><code id="merge_expression_module_+3A_data_extract">data_extract</code></td>
<td>
<p>(named <code>list</code> of <code>data_extract_spec</code>).</p>
</td></tr>
<tr><td><code id="merge_expression_module_+3A_merge_function">merge_function</code></td>
<td>
<p>(<code>character(1)</code>)
A character string of a function that accepts the arguments <code>x</code>, <code>y</code> and
<code>by</code> to perform the merging of datasets.</p>
</td></tr>
<tr><td><code id="merge_expression_module_+3A_anl_name">anl_name</code></td>
<td>
<p>(<code>character(1)</code>)
Name of the analysis dataset.</p>
</td></tr>
<tr><td><code id="merge_expression_module_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the module's
UI function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reactive expression with output from <code><a href="#topic+merge_expression_srv">merge_expression_srv()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_expression_srv">merge_expression_srv()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(teal.data)
library(teal.widgets)

ADSL &lt;- data.frame(
  STUDYID = "A",
  USUBJID = LETTERS[1:10],
  SEX = rep(c("F", "M"), 5),
  AGE = rpois(10, 30),
  BMRKR1 = rlnorm(10)
)
ADLB &lt;- expand.grid(
  STUDYID = "A",
  USUBJID = LETTERS[1:10],
  PARAMCD = c("ALT", "CRP", "IGA"),
  AVISIT = c("SCREENING", "BASELINE", "WEEK 1 DAY 8", "WEEK 2 DAY 15")
)
ADLB$AVAL &lt;- rlnorm(120)
ADLB$CHG &lt;- rnorm(120)

data_list &lt;- list(
  ADSL = reactive(ADSL),
  ADLB = reactive(ADLB)
)

join_keys &lt;- join_keys(
  join_key("ADSL", "ADSL", c("STUDYID", "USUBJID")),
  join_key("ADSL", "ADLB", c("STUDYID", "USUBJID")),
  join_key("ADLB", "ADLB", c("STUDYID", "USUBJID", "PARAMCD", "AVISIT"))
)

adsl_extract &lt;- data_extract_spec(
  dataname = "ADSL",
  select = select_spec(
    label = "Select variable:",
    choices = c("AGE", "BMRKR1"),
    selected = "AGE",
    multiple = TRUE,
    fixed = FALSE
  )
)
adlb_extract &lt;- data_extract_spec(
  dataname = "ADLB",
  filter = filter_spec(vars = "PARAMCD", choices = c("ALT", "CRP", "IGA"), selected = "ALT"),
  select = select_spec(
    label = "Select variable:",
    choices = c("AVAL", "CHG"),
    selected = "AVAL",
    multiple = TRUE,
    fixed = FALSE
  )
)

ui &lt;- fluidPage(
  standard_layout(
    output = div(
      verbatimTextOutput("expr"),
      dataTableOutput("data")
    ),
    encoding = tagList(
      data_extract_ui("adsl_var", label = "ADSL selection", adsl_extract),
      data_extract_ui("adlb_var", label = "ADLB selection", adlb_extract)
    )
  )
)

server &lt;- function(input, output, session) {
  data_q &lt;- qenv()

  data_q &lt;- eval_code(
    data_q,
    "ADSL &lt;- data.frame(
        STUDYID = 'A',
        USUBJID = LETTERS[1:10],
        SEX = rep(c('F', 'M'), 5),
        AGE = rpois(10, 30),
        BMRKR1 = rlnorm(10)
      )"
  )

  data_q &lt;- eval_code(
    data_q,
    "ADLB &lt;- expand.grid(
        STUDYID = 'A',
        USUBJID = LETTERS[1:10],
        PARAMCD = c('ALT', 'CRP', 'IGA'),
        AVISIT = c('SCREENING', 'BASELINE', 'WEEK 1 DAY 8', 'WEEK 2 DAY 15'),
        AVAL = rlnorm(120),
        CHG = rlnorm(120)
       )"
  )

  merged_data &lt;- merge_expression_module(
    data_extract = list(adsl_var = adsl_extract, adlb_var = adlb_extract),
    datasets = data_list,
    join_keys = join_keys,
    merge_function = "dplyr::left_join"
  )

  code_merge &lt;- reactive({
    for (exp in merged_data()$expr) data_q &lt;- eval_code(data_q, exp)
    data_q
  })

  output$expr &lt;- renderText(paste(merged_data()$expr, collapse = "\n"))
  output$data &lt;- renderDataTable(code_merge()[["ANL"]])
}

if (interactive()) {
  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='merge_expression_srv'>Data merge module server</h2><span id='topic+merge_expression_srv'></span><span id='topic+merge_expression_srv.reactive'></span><span id='topic+merge_expression_srv.list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_expression_srv(
  id = "merge_id",
  selector_list,
  datasets,
  join_keys,
  merge_function = "dplyr::full_join",
  anl_name = "ANL"
)

## S3 method for class 'reactive'
merge_expression_srv(
  id = "merge_id",
  selector_list,
  datasets,
  join_keys,
  merge_function = "dplyr::full_join",
  anl_name = "ANL"
)

## S3 method for class 'list'
merge_expression_srv(
  id = "merge_id",
  selector_list,
  datasets,
  join_keys,
  merge_function = "dplyr::full_join",
  anl_name = "ANL"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_expression_srv_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the module's
UI function.</p>
</td></tr>
<tr><td><code id="merge_expression_srv_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="merge_expression_srv_+3A_datasets">datasets</code></td>
<td>
<p>(named <code>list</code> of <code>reactive</code> or non-<code>reactive</code> <code>data.frame</code>)
object containing data as a list of <code>data.frame</code>.
When passing a list of non-reactive <code>data.frame</code> objects, they are
converted to reactive <code>data.frame</code> objects internally.</p>
</td></tr>
<tr><td><code id="merge_expression_srv_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>)
of variables used as join keys for each of the datasets in <code>datasets</code>.
This will be used to extract the <code>keys</code> of every dataset.</p>
</td></tr>
<tr><td><code id="merge_expression_srv_+3A_merge_function">merge_function</code></td>
<td>
<p>(<code>character(1)</code> or <code>reactive</code>)
A character string of a function that accepts the arguments
<code>x</code>, <code>y</code> and <code>by</code> to perform the merging of datasets.</p>
</td></tr>
<tr><td><code id="merge_expression_srv_+3A_anl_name">anl_name</code></td>
<td>
<p>(<code>character(1)</code>)
Name of the analysis dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When additional processing of the <code>data_extract</code> list input is required,
<code>merge_expression_srv()</code> can be combined with <code>data_extract_multiple_srv()</code>
or <code>data_extract_srv()</code> to influence the <code>selector_list</code> input.
Compare the example below with that found in <code><a href="#topic+merge_expression_module">merge_expression_module()</a></code>.
</p>


<h3>Value</h3>

<p>Reactive expression with output from <code><a href="#topic+merge_expression_srv">merge_expression_srv()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_expression_module">merge_expression_module()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
library(teal.data)
library(teal.widgets)

ADSL &lt;- data.frame(
  STUDYID = "A",
  USUBJID = LETTERS[1:10],
  SEX = rep(c("F", "M"), 5),
  AGE = rpois(10, 30),
  BMRKR1 = rlnorm(10)
)

ADLB &lt;- expand.grid(
  STUDYID = "A",
  USUBJID = LETTERS[1:10],
  PARAMCD = c("ALT", "CRP", "IGA"),
  AVISIT = c("SCREENING", "BASELINE", "WEEK 1 DAY 8", "WEEK 2 DAY 15")
)
ADLB$AVAL &lt;- rlnorm(120)
ADLB$CHG &lt;- rlnorm(120)

data_list &lt;- list(
  ADSL = reactive(ADSL),
  ADLB = reactive(ADLB)
)

join_keys &lt;- join_keys(
  join_key("ADSL", "ADSL", c("STUDYID", "USUBJID")),
  join_key("ADSL", "ADLB", c("STUDYID", "USUBJID")),
  join_key("ADLB", "ADLB", c("STUDYID", "USUBJID", "PARAMCD", "AVISIT"))
)

adsl_extract &lt;- data_extract_spec(
  dataname = "ADSL",
  select = select_spec(
    label = "Select variable:",
    choices = c("AGE", "BMRKR1"),
    selected = "AGE",
    multiple = TRUE,
    fixed = FALSE
  )
)
adlb_extract &lt;- data_extract_spec(
  dataname = "ADLB",
  filter = filter_spec(vars = "PARAMCD", choices = c("ALT", "CRP", "IGA"), selected = "ALT"),
  select = select_spec(
    label = "Select variable:",
    choices = c("AVAL", "CHG"),
    selected = "AVAL",
    multiple = TRUE,
    fixed = FALSE
  )
)

ui &lt;- fluidPage(
  standard_layout(
    output = div(
      verbatimTextOutput("expr"),
      dataTableOutput("data")
    ),
    encoding = tagList(
      data_extract_ui("adsl_var", label = "ADSL selection", adsl_extract),
      data_extract_ui("adlb_var", label = "ADLB selection", adlb_extract)
    )
  )
)

server &lt;- function(input, output, session) {
  data_q &lt;- qenv()

  data_q &lt;- eval_code(
    data_q,
    "ADSL &lt;- data.frame(
        STUDYID = 'A',
        USUBJID = LETTERS[1:10],
        SEX = rep(c('F', 'M'), 5),
        AGE = rpois(10, 30),
        BMRKR1 = rlnorm(10)
      )"
  )

  data_q &lt;- eval_code(
    data_q,
    "ADLB &lt;- expand.grid(
        STUDYID = 'A',
        USUBJID = LETTERS[1:10],
        PARAMCD = c('ALT', 'CRP', 'IGA'),
        AVISIT = c('SCREENING', 'BASELINE', 'WEEK 1 DAY 8', 'WEEK 2 DAY 15'),
        AVAL = rlnorm(120),
        CHG = rlnorm(120)
      )"
  )

  selector_list &lt;- data_extract_multiple_srv(
    list(adsl_var = adsl_extract, adlb_var = adlb_extract),
    datasets = data_list
  )
  merged_data &lt;- merge_expression_srv(
    selector_list = selector_list,
    datasets = data_list,
    join_keys = join_keys,
    merge_function = "dplyr::left_join"
  )

  code_merge &lt;- reactive({
    for (exp in merged_data()$expr) data_q &lt;- eval_code(data_q, exp)
    data_q
  })

  output$expr &lt;- renderText(paste(merged_data()$expr, collapse = "\n"))
  output$data &lt;- renderDataTable(code_merge()[["ANL"]])
}

if (interactive()) {
  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='merge_selectors'>Merge selectors when <code>dataname</code>, <code>reshape</code>, <code>filters</code> and <code>keys</code> entries are identical</h2><span id='topic+merge_selectors'></span>

<h3>Description</h3>

<p>Merge selectors when <code>dataname</code>, <code>reshape</code>, <code>filters</code> and <code>keys</code> entries are identical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_selectors(selector_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_selectors_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of merged selectors or original parameter if the conditions to merge are
not applicable.
</p>

<hr>
<h2 id='no_selected_as_NULL'>Check select choices for no choice made</h2><span id='topic+no_selected_as_NULL'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>no_selected_as_NULL(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="no_selected_as_NULL_+3A_x">x</code></td>
<td>
<p>(<code>character</code>) Word that shall be checked for <code>NULL</code>, empty, &quot;&ndash;no-selection&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The word or <code>NULL</code>.
</p>

<hr>
<h2 id='parse_merge_key_i'>Parses merge keys</h2><span id='topic+parse_merge_key_i'></span>

<h3>Description</h3>

<p>Parses merge keys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_merge_key_i(
  selector_list,
  idx,
  dplyr_call_data = get_dplyr_call_data(selector_list),
  merge_key = get_merge_key_i(selector_list, idx, dplyr_call_data)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_merge_key_i_+3A_selector_list">selector_list</code></td>
<td>
<p>(<code>reactive</code>)
output from <code><a href="#topic+data_extract_multiple_srv">data_extract_multiple_srv()</a></code> or a reactive named list of
outputs from <code><a href="#topic+data_extract_srv">data_extract_srv()</a></code>.
When using a reactive named list, the names must be identical to the shiny
ids of the respective
<code><a href="#topic+data_extract_ui">data_extract_ui()</a></code>.</p>
</td></tr>
<tr><td><code id="parse_merge_key_i_+3A_idx">idx</code></td>
<td>
<p>optional (<code>integer</code>) current selector index in all selectors list.</p>
</td></tr>
<tr><td><code id="parse_merge_key_i_+3A_dplyr_call_data">dplyr_call_data</code></td>
<td>
<p>(<code>list</code>) simplified selectors with aggregated set of filters.</p>
</td></tr>
<tr><td><code id="parse_merge_key_i_+3A_merge_key">merge_key</code></td>
<td>
<p>keys obtained from <code>get_merge_key_i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>call</code> with merge keys.
</p>

<hr>
<h2 id='Queue'>R6 Class - A First-In-First-Out Abstract Data Type</h2><span id='topic+Queue'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Abstract data type that stores and returns any number of elements.
</p>


<h3>Details</h3>

<p>A <code>Queue</code> object stores all elements in a single vector,
thus all data types can be stored, but silent coercion may occur.
</p>
<p>Elements are returned in the same order that they were added.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Queue-push"><code>Queue$push()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-get"><code>Queue$get()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-pop"><code>Queue$pop()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-remove"><code>Queue$remove()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-empty"><code>Queue$empty()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-size"><code>Queue$size()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-print"><code>Queue$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Queue-clone"><code>Queue$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Queue-push"></a>



<h4>Method <code>push()</code></h4>

<p>Adds element(s) to <code>Queue</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$push(new_elements)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_elements</code></dt><dd><p>vector of elements to add.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>, invisibly.
</p>


<hr>
<a id="method-Queue-get"></a>



<h4>Method <code>get()</code></h4>

<p>Returns all contents of the <code>Queue</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$get()</pre></div>



<h5>Returns</h5>

<p>Single vector containing all <code>Queue</code> contents.
</p>


<hr>
<a id="method-Queue-pop"></a>



<h4>Method <code>pop()</code></h4>

<p>Returns the first (oldest) element of the <code>Queue</code> and removes it.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$pop()</pre></div>



<h5>Returns</h5>

<p>vector of length 1 containing the first element of <code>Queue</code>
or <code>NULL</code> if <code>Queue</code> is empty.
</p>


<hr>
<a id="method-Queue-remove"></a>



<h4>Method <code>remove()</code></h4>

<p>Removes the oldest occurrence of specified element(s) from <code>Queue</code>.
Relies on implicit type conversions of R identify elements to remove.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$remove(elements)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>elements</code></dt><dd><p>vector of elements to remove from <code>Queue</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>, invisibly.
</p>


<hr>
<a id="method-Queue-empty"></a>



<h4>Method <code>empty()</code></h4>

<p>Removes all elements from <code>Queue</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$empty()</pre></div>



<h5>Returns</h5>

<p><code>self</code>, invisibly.
</p>


<hr>
<a id="method-Queue-size"></a>



<h4>Method <code>size()</code></h4>

<p>Returns the number of elements in <code>Queue</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$size()</pre></div>



<h5>Returns</h5>

<p><code>integer(1)</code>.
</p>


<hr>
<a id="method-Queue-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints this <code>Queue</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional arguments to this method, ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>, invisibly.
</p>


<hr>
<a id="method-Queue-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Queue$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='rADAE'>Random adverse events</h2><span id='topic+rADAE'></span>

<h3>Description</h3>

<p>Random adverse events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rADAE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 1934 rows and 92 columns.
</p>


<h3>Source</h3>

<p>internal
</p>

<hr>
<h2 id='rADLB'>Random lab analysis</h2><span id='topic+rADLB'></span>

<h3>Description</h3>

<p>Random lab analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rADLB
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 8400 rows and 102 columns.
</p>


<h3>Source</h3>

<p>internal
</p>

<hr>
<h2 id='rADRS'>Random response</h2><span id='topic+rADRS'></span>

<h3>Description</h3>

<p>Random response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rADRS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 3200 rows and 65 columns.
</p>


<h3>Source</h3>

<p>internal
</p>

<hr>
<h2 id='rADSL'>Random patient listing</h2><span id='topic+rADSL'></span>

<h3>Description</h3>

<p>Random patient listing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rADSL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 400 rows and 55 columns.
</p>


<h3>Source</h3>

<p>internal
</p>

<hr>
<h2 id='rADTTE'>Random time to event analysis dataset</h2><span id='topic+rADTTE'></span>

<h3>Description</h3>

<p>Random time to event analysis dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rADTTE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 2000 rows and 67 columns.
</p>


<h3>Source</h3>

<p>internal
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='resolve'>Resolve delayed inputs by evaluating the code within the provided datasets</h2><span id='topic+resolve'></span><span id='topic+resolve.delayed_variable_choices'></span><span id='topic+resolve.delayed_value_choices'></span><span id='topic+resolve.delayed_choices_selected'></span><span id='topic+resolve.delayed_select_spec'></span><span id='topic+resolve.delayed_filter_spec'></span><span id='topic+resolve.delayed_data_extract_spec'></span><span id='topic+resolve.list'></span><span id='topic+resolve.default'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve(x, datasets, keys = NULL)

## S3 method for class 'delayed_variable_choices'
resolve(x, datasets, keys)

## S3 method for class 'delayed_value_choices'
resolve(x, datasets, keys)

## S3 method for class 'delayed_choices_selected'
resolve(x, datasets, keys)

## S3 method for class 'delayed_select_spec'
resolve(x, datasets, keys)

## S3 method for class 'delayed_filter_spec'
resolve(x, datasets, keys)

## S3 method for class 'delayed_data_extract_spec'
resolve(x, datasets, keys)

## S3 method for class 'list'
resolve(x, datasets, keys)

## Default S3 method:
resolve(x, datasets, keys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_+3A_x">x</code></td>
<td>
<p>(<code>delayed_data</code>) object to resolve.</p>
</td></tr>
<tr><td><code id="resolve_+3A_datasets">datasets</code></td>
<td>
<p>(named <code>list</code> of <code>data.frame</code>) to use in evaluation.</p>
</td></tr>
<tr><td><code id="resolve_+3A_keys">keys</code></td>
<td>
<p>(named <code>list</code> of <code>character</code>) to be used as the keys for each dataset.
The names of this list must be exactly the same as for datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Resolved object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>resolve(delayed_variable_choices)</code>: Call <code><a href="#topic+variable_choices">variable_choices()</a></code> on the delayed <code>variable_choices</code> object.
</p>
</li>
<li> <p><code>resolve(delayed_value_choices)</code>: Call <code><a href="#topic+value_choices">value_choices()</a></code> on the delayed <code>value_choices</code> object.
</p>
</li>
<li> <p><code>resolve(delayed_choices_selected)</code>: Call <code><a href="#topic+select_spec">select_spec()</a></code> on the delayed <code>choices_selected</code> object.
</p>
</li>
<li> <p><code>resolve(delayed_select_spec)</code>: Call <code><a href="#topic+select_spec">select_spec()</a></code> on the delayed specification.
</p>
</li>
<li> <p><code>resolve(delayed_filter_spec)</code>: Call <code><a href="#topic+filter_spec">filter_spec()</a></code> on the delayed specification.
</p>
</li>
<li> <p><code>resolve(delayed_data_extract_spec)</code>: Call <code><a href="#topic+data_extract_spec">data_extract_spec()</a></code> on the delayed specification.
</p>
</li>
<li> <p><code>resolve(list)</code>: Iterates over elements of the list and recursively calls
<code>resolve</code>.
</p>
</li>
<li> <p><code>resolve(default)</code>: Default method that does nothing and returns <code>x</code> itself.
</p>
</li></ul>


<h3>Note</h3>

<p>This is an internal function that is used by <code><a href="#topic+resolve_delayed">resolve_delayed()</a></code>.
All the methods are used internally only.
</p>

<hr>
<h2 id='resolve_delayed'>Resolve delayed inputs by evaluating the code within the provided datasets</h2><span id='topic+resolve_delayed'></span><span id='topic+resolve_delayed.FilteredData'></span><span id='topic+resolve_delayed.list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_delayed(x, datasets, keys)

## S3 method for class 'FilteredData'
resolve_delayed(
  x,
  datasets,
  keys = sapply(datasets$datanames(), datasets$get_keys, simplify = FALSE)
)

## S3 method for class 'list'
resolve_delayed(x, datasets, keys = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_delayed_+3A_x">x</code></td>
<td>
<p>(<code>delayed_data</code>, <code>list</code>) to resolve.</p>
</td></tr>
<tr><td><code id="resolve_delayed_+3A_datasets">datasets</code></td>
<td>
<p>(<code>FilteredData</code> or named <code>list</code>) to use as a reference to resolve <code>x</code>.</p>
</td></tr>
<tr><td><code id="resolve_delayed_+3A_keys">keys</code></td>
<td>
<p>(named <code>list</code>) with primary keys for each dataset from <code>datasets</code>. <code>names(keys)</code>
should match <code>names(datasets)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Resolved object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>resolve_delayed(FilteredData)</code>: Default values for <code>keys</code> parameters is extracted from <code>datasets</code>.
</p>
</li>
<li> <p><code>resolve_delayed(list)</code>: Generic method when <code>datasets</code> argument is a named list.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(shiny)
ADSL &lt;- teal.transform::rADSL
isolate({
  data_list &lt;- list(ADSL = reactive(ADSL))

  # value_choices example
  v1 &lt;- value_choices("ADSL", "SEX", "SEX")
  v1
  resolve_delayed(v1, data_list)

  # variable_choices example
  v2 &lt;- variable_choices("ADSL", c("BMRKR1", "BMRKR2"))
  v2
  resolve_delayed(v2, data_list)

  # data_extract_spec example
  adsl_filter &lt;- filter_spec(
    vars = variable_choices("ADSL", "SEX"),
    sep = "-",
    choices = value_choices("ADSL", "SEX", "SEX"),
    selected = "F",
    multiple = FALSE,
    label = "Choose endpoint and Censor"
  )

  adsl_select &lt;- select_spec(
    label = "Select variable:",
    choices = variable_choices("ADSL", c("BMRKR1", "BMRKR2")),
    selected = "BMRKR1",
    multiple = FALSE,
    fixed = FALSE
  )

  adsl_de &lt;- data_extract_spec(
    dataname = "ADSL",
    select = adsl_select,
    filter = adsl_filter
  )

  resolve_delayed(adsl_filter, datasets = data_list)
  resolve_delayed(adsl_select, datasets = data_list)
  resolve_delayed(adsl_de, datasets = data_list)

  # nested list (arm_ref_comp)
  arm_ref_comp &lt;- list(
    ARMCD = list(
      ref = variable_choices("ADSL"),
      comp = variable_choices("ADSL")
    )
  )

  resolve_delayed(arm_ref_comp, datasets = data_list)
})
</code></pre>

<hr>
<h2 id='resolve_delayed_expr'>Resolve expression after delayed data are loaded</h2><span id='topic+resolve_delayed_expr'></span>

<h3>Description</h3>

<p>Resolve expression after delayed data are loaded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_delayed_expr(x, ds, is_value_choices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_delayed_expr_+3A_x">x</code></td>
<td>
<p>(<code>function</code>) Function that is applied on dataset.
It must take only a single argument &quot;data&quot; and return character vector with columns / values.</p>
</td></tr>
<tr><td><code id="resolve_delayed_expr_+3A_ds">ds</code></td>
<td>
<p>(<code>data.frame</code>) Dataset.</p>
</td></tr>
<tr><td><code id="resolve_delayed_expr_+3A_is_value_choices">is_value_choices</code></td>
<td>
<p>(<code>logical</code>) Determines which check of the returned value will be applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector - result of calling function <code>x</code> on dataset <code>ds</code>.
</p>

<hr>
<h2 id='select_spec'>Column selection input specification</h2><span id='topic+select_spec'></span><span id='topic+select_spec.delayed_data'></span><span id='topic+select_spec.default'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p><code>select_spec</code> is used inside <code>teal</code> to create a <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>
that will select columns from a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_spec(
  choices,
  selected = if (inherits(choices, "delayed_data")) NULL else choices[1],
  multiple = length(selected) &gt; 1 || inherits(selected, "all_choices"),
  fixed = FALSE,
  always_selected = NULL,
  ordered = FALSE,
  label = "Select"
)

select_spec.delayed_data(
  choices,
  selected = NULL,
  multiple = length(selected) &gt; 1,
  fixed = FALSE,
  always_selected = NULL,
  ordered = FALSE,
  label = NULL
)

select_spec.default(
  choices,
  selected = choices[1],
  multiple = length(selected) &gt; 1,
  fixed = FALSE,
  always_selected = NULL,
  ordered = FALSE,
  label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_spec_+3A_choices">choices</code></td>
<td>
<p>(<code>character</code> or <code>delayed_data</code>) object.
Named character vector to define the choices of a shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>.
These have to be columns in the dataset defined in the <code><a href="#topic+data_extract_spec">data_extract_spec()</a></code>
where this is called.
<code>delayed_data</code> objects can be created via <code><a href="#topic+variable_choices">variable_choices()</a></code> or <code><a href="#topic+value_choices">value_choices()</a></code>.</p>
</td></tr>
<tr><td><code id="select_spec_+3A_selected">selected</code></td>
<td>
<p>(optional <code>character</code> or <code>NULL</code> or <code>all_choices</code> or <code>delayed_data</code>).
Named character vector to define the selected values of a shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>.
Passing an <code>all_choices()</code> object indicates selecting all possible choices.
Defaults to the first value of <code>choices</code> or <code>NULL</code> for delayed data loading.</p>
</td></tr>
<tr><td><code id="select_spec_+3A_multiple">multiple</code></td>
<td>
<p>(<code>logical</code>) Whether multiple values shall be allowed in the
shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>.</p>
</td></tr>
<tr><td><code id="select_spec_+3A_fixed">fixed</code></td>
<td>
<p>(optional <code>logical</code>). <code><a href="#topic+data_extract_spec">data_extract_spec()</a></code> specific feature to
hide the choices selected in case they are not needed. Setting fixed to <code>TRUE</code>
will not allow the user to select columns. It will then lead to a selection of
columns in the dataset that is defined by the developer of the app.</p>
</td></tr>
<tr><td><code id="select_spec_+3A_always_selected">always_selected</code></td>
<td>
<p>(<code>character</code>) Additional column names from the data set that should
always be selected</p>
</td></tr>
<tr><td><code id="select_spec_+3A_ordered">ordered</code></td>
<td>
<p>(<code>logical(1)</code>) Flags whether selection order should be tracked.</p>
</td></tr>
<tr><td><code id="select_spec_+3A_label">label</code></td>
<td>
<p>(optional <code>character</code>). Define a label on top of this specific
shiny <code><a href="shiny.html#topic+selectInput">shiny::selectInput()</a></code>. The default value is <code>"Select"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>select_spec</code>-S3 class object or <code>delayed_select_spec</code>-S3-class object.
It contains all input values.
</p>
<p>If <code>select_spec</code>, then the function double checks the <code>choices</code> and <code>selected</code> inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Selection with just one column allowed
select_spec(
  choices = c("AVAL", "BMRKR1", "AGE"),
  selected = c("AVAL"),
  multiple = FALSE,
  fixed = FALSE,
  label = "Column"
)

# Selection with just multiple columns allowed
select_spec(
  choices = c("AVAL", "BMRKR1", "AGE"),
  selected = c("AVAL", "BMRKR1"),
  multiple = TRUE,
  fixed = FALSE,
  label = "Columns"
)

# Selection without user access
select_spec(
  choices = c("AVAL", "BMRKR1"),
  selected = c("AVAL", "BMRKR1"),
  multiple = TRUE,
  fixed = TRUE,
  label = "Columns"
)

# Delayed version
select_spec(
  label = "Select variable:",
  choices = variable_choices("ADSL", c("BMRKR1", "BMRKR2")),
  selected = "BMRKR1",
  multiple = FALSE,
  fixed = FALSE
)

# all_choices passed to selected
select_spec(
  label = "Select variable:",
  choices = variable_choices("ADSL", c("BMRKR1", "BMRKR2")),
  selected = all_choices()
)

# Both below objects are semantically the same
select_spec(choices = variable_choices("ADSL"), selected = variable_choices("ADSL"))
select_spec(choices = variable_choices("ADSL"), selected = all_choices())
</code></pre>

<hr>
<h2 id='split_by_sep'>Split by separator (matched exactly)</h2><span id='topic+split_by_sep'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by_sep(x, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_by_sep_+3A_x">x</code></td>
<td>
<p>(<code>character</code>) Character vector, each element of which is to be split.
Other inputs, including a factor return themselves.</p>
</td></tr>
<tr><td><code id="split_by_sep_+3A_sep">sep</code></td>
<td>
<p>(<code>character</code>) separator to use for splitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of character vectors split by <code>sep</code>. Self if <code>x</code> is not a <code>character</code>.
</p>

<hr>
<h2 id='validate_keys_sufficient'>Validates whether the provided keys are sufficient to merge the datasets slices</h2><span id='topic+validate_keys_sufficient'></span>

<h3>Description</h3>

<p>Validates whether the provided keys are sufficient to merge the datasets slices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_keys_sufficient(join_keys, merged_selector_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_keys_sufficient_+3A_join_keys">join_keys</code></td>
<td>
<p>(<code>join_keys</code>) the provided join keys.</p>
</td></tr>
<tr><td><code id="validate_keys_sufficient_+3A_merged_selector_list">merged_selector_list</code></td>
<td>
<p>(<code>list</code>) the specification of datasets' slices to merge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the provided keys meet the requirement and <code>shiny</code>
validate error otherwise.
</p>


<h3>Note</h3>

<p>The keys are not sufficient if the datasets slices described in
<code>merged_selector_list</code> come from datasets, which don't have the
appropriate join keys in <code>join_keys</code>.
</p>

<hr>
<h2 id='value_choices'>Value labeling and filtering based on variable relationship</h2><span id='topic+value_choices'></span><span id='topic+value_choices.character'></span><span id='topic+value_choices.data.frame'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Wrapper on <a href="#topic+choices_labeled">choices_labeled</a> to label variable values basing on other variable values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_choices(data, var_choices, var_label = NULL, subset = NULL, sep = " - ")

## S3 method for class 'character'
value_choices(data, var_choices, var_label = NULL, subset = NULL, sep = " - ")

## S3 method for class 'data.frame'
value_choices(data, var_choices, var_label = NULL, subset = NULL, sep = " - ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value_choices_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>, <code>character</code>)
If <code>data.frame</code>, then data to extract labels from.
If <code>character</code>, then name of the dataset to extract data from once available.</p>
</td></tr>
<tr><td><code id="value_choices_+3A_var_choices">var_choices</code></td>
<td>
<p>(<code>character</code> or <code>NULL</code>) vector with choices column names.</p>
</td></tr>
<tr><td><code id="value_choices_+3A_var_label">var_label</code></td>
<td>
<p>(<code>character</code>) vector with labels column names.</p>
</td></tr>
<tr><td><code id="value_choices_+3A_subset">subset</code></td>
<td>
<p>(<code>character</code> or <code>function</code>)
If <code>character</code>, vector with values to subset.
If <code>function</code>, then this function is used to determine the possible columns (e.g. all factor columns).
In this case, the function must take only single argument &quot;data&quot; and return a character vector.
</p>
<p>See examples for more details.</p>
</td></tr>
<tr><td><code id="value_choices_+3A_sep">sep</code></td>
<td>
<p>(<code>character</code>) separator used in case of multiple column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named character vector or <code>delayed_data</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ADRS &lt;- teal.transform::rADRS
value_choices(ADRS, "PARAMCD", "PARAM", subset = c("BESRSPI", "INVET"))
value_choices(ADRS, c("PARAMCD", "ARMCD"), c("PARAM", "ARM"))
value_choices(ADRS, c("PARAMCD", "ARMCD"), c("PARAM", "ARM"),
  subset = c("BESRSPI - ARM A", "INVET - ARM A", "OVRINV - ARM A")
)
value_choices(ADRS, c("PARAMCD", "ARMCD"), c("PARAM", "ARM"), sep = " --- ")

# delayed version
value_choices("ADRS", c("PARAMCD", "ARMCD"), c("PARAM", "ARM"))

# functional subset
value_choices(ADRS, "PARAMCD", "PARAM", subset = function(data) {
  levels(data$PARAMCD)[1:2]
})
</code></pre>

<hr>
<h2 id='variable_choices'>Variable label extraction and custom selection from data</h2><span id='topic+variable_choices'></span><span id='topic+variable_choices.character'></span><span id='topic+variable_choices.data.frame'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Wrapper on <a href="#topic+choices_labeled">choices_labeled</a> to label variables basing on existing labels in data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_choices(data, subset = NULL, fill = FALSE, key = NULL)

## S3 method for class 'character'
variable_choices(data, subset = NULL, fill = FALSE, key = NULL)

## S3 method for class 'data.frame'
variable_choices(data, subset = NULL, fill = TRUE, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_choices_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code> or <code>character</code>)
If <code>data.frame</code>, then data to extract labels from.
If <code>character</code>, then name of the dataset to extract data from once available.</p>
</td></tr>
<tr><td><code id="variable_choices_+3A_subset">subset</code></td>
<td>
<p>(<code>character</code> or <code>function</code>)
If <code>character</code>, then a vector of column names.
If <code>function</code>, then this function is used to determine the possible columns (e.g. all factor columns).
In this case, the function must take only single argument &quot;data&quot; and return a character vector.
</p>
<p>See examples for more details.</p>
</td></tr>
<tr><td><code id="variable_choices_+3A_fill">fill</code></td>
<td>
<p>(<code>logical(1)</code>) if <code>TRUE</code>, the function will return variable names
for columns with non-existent labels; otherwise will return <code>NA</code> for them.</p>
</td></tr>
<tr><td><code id="variable_choices_+3A_key">key</code></td>
<td>
<p>(<code>character</code>) vector with names of the variables, which are part of the primary key
of the <code>data</code> argument.
</p>
<p>This is an optional argument, which allows to identify variables associated
with the primary key and display the appropriate icon for them in the
<code><a href="teal.widgets.html#topic+optionalSelectInput">teal.widgets::optionalSelectInput()</a></code> widget.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named <code>character</code> vector with additional attributes or <code>delayed_data</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(teal.data)

ADRS &lt;- teal.transform::rADRS
variable_choices(ADRS)
variable_choices(ADRS, subset = c("PARAM", "PARAMCD"))
variable_choices(ADRS, subset = c("", "PARAM", "PARAMCD"))
variable_choices(
  ADRS,
  subset = c("", "PARAM", "PARAMCD"),
  key = default_cdisc_join_keys["ADRS", "ADRS"]
)

# delayed version
variable_choices("ADRS", subset = c("USUBJID", "STUDYID"))

# functional subset (with delayed data) - return only factor variables
variable_choices("ADRS", subset = function(data) {
  idx &lt;- vapply(data, is.factor, logical(1))
  names(data)[idx]
})
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
