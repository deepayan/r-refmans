<!DOCTYPE html><html><head><title>Help for package recipes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {recipes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#recipes'><p>recipes: A package for computing and preprocessing design matrices.</p></a></li>
<li><a href='#.get_data_types'><p>Get types for use in recipes</p></a></li>
<li><a href='#add_step'><p>Add a New Operation to the Current Recipe</p></a></li>
<li><a href='#bake'><p>Apply a trained preprocessing recipe</p></a></li>
<li><a href='#case_weights'><p>Using case weights with recipes</p></a></li>
<li><a href='#case-weight-helpers'><p>Helpers for steps with case weights</p></a></li>
<li><a href='#check_class'><p>Check variable class</p></a></li>
<li><a href='#check_cols'><p>Check if all columns are present</p></a></li>
<li><a href='#check_missing'><p>Check for missing values</p></a></li>
<li><a href='#check_name'><p>check that newly created variable names don't overlap</p></a></li>
<li><a href='#check_new_data'><p>Check for required column at bake-time</p></a></li>
<li><a href='#check_new_values'><p>Check for new values</p></a></li>
<li><a href='#check_range'><p>Check range consistency</p></a></li>
<li><a href='#check_type'><p>Quantitatively check on variables</p></a></li>
<li><a href='#detect_step'><p>Detect if a particular step or check is used in a recipe</p></a></li>
<li><a href='#developer_functions'><p>Developer functions for creating recipes steps</p></a></li>
<li><a href='#discretize'><p>Discretize Numeric Variables</p></a></li>
<li><a href='#fixed'><p>Helper Functions for Profile Data Sets</p></a></li>
<li><a href='#format_ch_vec'><p>Helpers for printing step functions</p></a></li>
<li><a href='#formula.recipe'><p>Create a formula from a prepared recipe</p></a></li>
<li><a href='#fully_trained'><p>Check to see if a recipe is trained/prepared</p></a></li>
<li><a href='#get_keep_original_cols'><p>Get the <code>keep_original_cols</code> value of a recipe step</p></a></li>
<li><a href='#has_role'><p>Role Selection</p></a></li>
<li><a href='#juice'><p>Extract transformed training set</p></a></li>
<li><a href='#names0'><p>Naming Tools</p></a></li>
<li><a href='#prep'><p>Estimate a preprocessing recipe</p></a></li>
<li><a href='#prepper'><p>Wrapper function for preparing recipes within resampling</p></a></li>
<li><a href='#print.recipe'><p>Print a Recipe</p></a></li>
<li><a href='#rand_id'><p>Make a random identification field for steps</p></a></li>
<li><a href='#recipe'><p>Create a recipe for preprocessing data</p></a></li>
<li><a href='#recipes_eval_select'><p>Evaluate a selection with tidyselect semantics specific to recipes</p></a></li>
<li><a href='#recipes_extension_check'><p>Checks that steps have all S3 methods</p></a></li>
<li><a href='#recipes_pkg_check'><p>Update packages</p></a></li>
<li><a href='#recipes_remove_cols'><p>Removes columns if options apply</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove_original_cols'><p>Removes original columns if options apply</p></a></li>
<li><a href='#required_pkgs.step_classdist_shrunken'><p>S3 methods for tracking which additional packages are needed for steps.</p></a></li>
<li><a href='#roles'><p>Manually alter roles</p></a></li>
<li><a href='#selections'><p>Methods for selecting variables in step functions</p></a></li>
<li><a href='#step'><p><code>step</code> sets the class of the <code>step</code> and <code>check</code> is for checks.</p></a></li>
<li><a href='#step_arrange'><p>Sort rows using dplyr</p></a></li>
<li><a href='#step_bin2factor'><p>Create a factors from A dummy variable</p></a></li>
<li><a href='#step_BoxCox'><p>Box-Cox transformation for non-negative data</p></a></li>
<li><a href='#step_bs'><p>B-spline basis functions</p></a></li>
<li><a href='#step_center'><p>Centering numeric data</p></a></li>
<li><a href='#step_classdist'><p>Distances to class centroids</p></a></li>
<li><a href='#step_classdist_shrunken'><p>Compute shrunken centroid distances for classification models</p></a></li>
<li><a href='#step_corr'><p>High correlation filter</p></a></li>
<li><a href='#step_count'><p>Create counts of patterns using regular expressions</p></a></li>
<li><a href='#step_cut'><p>Cut a numeric variable into a factor</p></a></li>
<li><a href='#step_date'><p>Date feature generator</p></a></li>
<li><a href='#step_depth'><p>Data depths</p></a></li>
<li><a href='#step_discretize'><p>Discretize Numeric Variables</p></a></li>
<li><a href='#step_dummy'><p>Create traditional dummy variables</p></a></li>
<li><a href='#step_dummy_extract'><p>Extract patterns from nominal data</p></a></li>
<li><a href='#step_dummy_multi_choice'><p>Handle levels in multiple predictors together</p></a></li>
<li><a href='#step_factor2string'><p>Convert factors to strings</p></a></li>
<li><a href='#step_filter'><p>Filter rows using dplyr</p></a></li>
<li><a href='#step_filter_missing'><p>Missing value column filter</p></a></li>
<li><a href='#step_geodist'><p>Distance between two locations</p></a></li>
<li><a href='#step_harmonic'><p>Add sin and cos terms for harmonic analysis</p></a></li>
<li><a href='#step_holiday'><p>Holiday feature generator</p></a></li>
<li><a href='#step_hyperbolic'><p>Hyperbolic transformations</p></a></li>
<li><a href='#step_ica'><p>ICA signal extraction</p></a></li>
<li><a href='#step_impute_bag'><p>Impute via bagged trees</p></a></li>
<li><a href='#step_impute_knn'><p>Impute via k-nearest neighbors</p></a></li>
<li><a href='#step_impute_linear'><p>Impute numeric variables via a linear model</p></a></li>
<li><a href='#step_impute_lower'><p>Impute numeric data below the threshold of measurement</p></a></li>
<li><a href='#step_impute_mean'><p>Impute numeric data using the mean</p></a></li>
<li><a href='#step_impute_median'><p>Impute numeric data using the median</p></a></li>
<li><a href='#step_impute_mode'><p>Impute nominal data using the most common value</p></a></li>
<li><a href='#step_impute_roll'><p>Impute numeric data using a rolling window statistic</p></a></li>
<li><a href='#step_indicate_na'><p>Create missing data column indicators</p></a></li>
<li><a href='#step_integer'><p>Convert values to predefined integers</p></a></li>
<li><a href='#step_interact'><p>Create interaction variables</p></a></li>
<li><a href='#step_intercept'><p>Add intercept (or constant) column</p></a></li>
<li><a href='#step_inverse'><p>Inverse transformation</p></a></li>
<li><a href='#step_invlogit'><p>Inverse logit transformation</p></a></li>
<li><a href='#step_isomap'><p>Isomap embedding</p></a></li>
<li><a href='#step_kpca'><p>Kernel PCA signal extraction</p></a></li>
<li><a href='#step_kpca_poly'><p>Polynomial kernel PCA signal extraction</p></a></li>
<li><a href='#step_kpca_rbf'><p>Radial basis function kernel PCA signal extraction</p></a></li>
<li><a href='#step_lag'><p>Create a lagged predictor</p></a></li>
<li><a href='#step_lincomb'><p>Linear combination filter</p></a></li>
<li><a href='#step_log'><p>Logarithmic transformation</p></a></li>
<li><a href='#step_logit'><p>Logit transformation</p></a></li>
<li><a href='#step_mutate'><p>Add new variables using dplyr</p></a></li>
<li><a href='#step_mutate_at'><p>Mutate multiple columns using dplyr</p></a></li>
<li><a href='#step_naomit'><p>Remove observations with missing values</p></a></li>
<li><a href='#step_nnmf'><p>Non-negative matrix factorization signal extraction</p></a></li>
<li><a href='#step_nnmf_sparse'><p>Non-negative matrix factorization signal extraction with lasso penalization</p></a></li>
<li><a href='#step_normalize'><p>Center and scale numeric data</p></a></li>
<li><a href='#step_novel'><p>Simple value assignments for novel factor levels</p></a></li>
<li><a href='#step_ns'><p>Natural spline basis functions</p></a></li>
<li><a href='#step_num2factor'><p>Convert numbers to factors</p></a></li>
<li><a href='#step_nzv'><p>Near-zero variance filter</p></a></li>
<li><a href='#step_ordinalscore'><p>Convert ordinal factors to numeric scores</p></a></li>
<li><a href='#step_other'><p>Collapse infrequent categorical levels</p></a></li>
<li><a href='#step_pca'><p>PCA signal extraction</p></a></li>
<li><a href='#step_percentile'><p>Percentile transformation</p></a></li>
<li><a href='#step_pls'><p>Partial least squares feature extraction</p></a></li>
<li><a href='#step_poly'><p>Orthogonal polynomial basis functions</p></a></li>
<li><a href='#step_poly_bernstein'><p>Generalized bernstein polynomial basis</p></a></li>
<li><a href='#step_profile'><p>Create a profiling version of a data set</p></a></li>
<li><a href='#step_range'><p>Scaling numeric data to a specific range</p></a></li>
<li><a href='#step_ratio'><p>Ratio variable creation</p></a></li>
<li><a href='#step_regex'><p>Detect a regular expression</p></a></li>
<li><a href='#step_relevel'><p>Relevel factors to a desired level</p></a></li>
<li><a href='#step_relu'><p>Apply (smoothed) rectified linear transformation</p></a></li>
<li><a href='#step_rename'><p>Rename variables by name using dplyr</p></a></li>
<li><a href='#step_rename_at'><p>Rename multiple columns using dplyr</p></a></li>
<li><a href='#step_rm'><p>General variable filter</p></a></li>
<li><a href='#step_sample'><p>Sample rows using dplyr</p></a></li>
<li><a href='#step_scale'><p>Scaling mumeric data</p></a></li>
<li><a href='#step_select'><p>Select variables using dplyr</p></a></li>
<li><a href='#step_shuffle'><p>Shuffle variables</p></a></li>
<li><a href='#step_slice'><p>Filter rows by position using dplyr</p></a></li>
<li><a href='#step_spatialsign'><p>Spatial sign preprocessing</p></a></li>
<li><a href='#step_spline_b'><p>Basis splines</p></a></li>
<li><a href='#step_spline_convex'><p>Convex splines</p></a></li>
<li><a href='#step_spline_monotone'><p>Monotone splines</p></a></li>
<li><a href='#step_spline_natural'><p>Natural splines</p></a></li>
<li><a href='#step_spline_nonnegative'><p>Non-negative splines</p></a></li>
<li><a href='#step_sqrt'><p>Square root transformation</p></a></li>
<li><a href='#step_string2factor'><p>Convert strings to factors</p></a></li>
<li><a href='#step_time'><p>Time feature generator</p></a></li>
<li><a href='#step_unknown'><p>Assign missing categories to &quot;unknown&quot;</p></a></li>
<li><a href='#step_unorder'><p>Convert ordered factors to unordered factors</p></a></li>
<li><a href='#step_window'><p>Moving window functions</p></a></li>
<li><a href='#step_YeoJohnson'><p>Yeo-Johnson transformation</p></a></li>
<li><a href='#step_zv'><p>Zero variance filter</p></a></li>
<li><a href='#summary.recipe'><p>Summarize a recipe</p></a></li>
<li><a href='#terms_select'><p>Select terms in a step function.</p></a></li>
<li><a href='#tidy.step_BoxCox'><p>Tidy the result of a recipe</p></a></li>
<li><a href='#update_role_requirements'><p>Update role specific requirements</p></a></li>
<li><a href='#update.step'><p>Update a recipe step</p></a></li>
<li><a href='#yj_transform'><p>Internal Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Preprocessing and Feature Engineering Steps for Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.10</td>
</tr>
<tr>
<td>Description:</td>
<td>A recipe prepares your data for modeling. We provide an
    extensible framework for pipeable sequences of feature engineering
    steps provides preprocessing tools to be applied to data. Statistical
    parameters for the steps can be estimated from an initial data set and
    then applied to other data sets. The resulting processed output can
    then be used as inputs for statistical or machine learning models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tidymodels/recipes">https://github.com/tidymodels/recipes</a>,
<a href="https://recipes.tidymodels.org/">https://recipes.tidymodels.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/recipes/issues">https://github.com/tidymodels/recipes/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>dplyr (&ge; 1.1.0), R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, clock (&ge; 0.6.1), ellipsis, generics (&ge; 0.1.2), glue,
gower, hardhat (&ge; 1.3.0), ipred (&ge; 0.9-12), lifecycle (&ge;
1.0.3), lubridate (&ge; 1.8.0), magrittr, Matrix, purrr (&ge;
1.0.0), rlang (&ge; 1.1.0), stats, tibble, tidyr (&ge; 1.0.0),
tidyselect (&ge; 1.2.0), timeDate, utils, vctrs (&ge; 0.5.0), withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ddalpha, dials (&ge; 1.2.0), ggplot2, igraph, kernlab,
knitr, modeldata (&ge; 0.1.1), parsnip (&ge; 1.2.0), RANN,
RcppRoll, rmarkdown, rpart, rsample, RSpectra, splines2,
testthat (&ge; 3.0.0), workflows, xml2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 17:15:26 UTC; max</td>
</tr>
<tr>
<td>Author:</td>
<td>Max Kuhn [aut, cre],
  Hadley Wickham [aut],
  Emil Hvitfeldt [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Max Kuhn &lt;max@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='recipes'>recipes: A package for computing and preprocessing design matrices.</h2><span id='topic+recipes'></span><span id='topic+recipes-package'></span>

<h3>Description</h3>

<p>The <code>recipes</code> package can be used to create design matrices for modeling
and to conduct preprocessing of variables. It is meant to be a more
extensive framework that R's formula method. Some differences between
simple formula methods and recipes are that
</p>

<ol>
<li><p> Variables can have arbitrary roles in the analysis beyond predictors
and outcomes.
</p>
</li>
<li><p> A recipe consists of one or more steps that define actions on the
variables.
</p>
</li>
<li><p> Recipes can be defined sequentially using pipes as well as being
modifiable and extensible.
</p>
</li></ol>



<h3>Basic Functions</h3>

<p>The three main functions are <code><a href="#topic+recipe">recipe()</a></code>, <code><a href="#topic+prep">prep()</a></code>,
and <code><a href="#topic+bake">bake()</a></code>.
</p>
<p><code><a href="#topic+recipe">recipe()</a></code> defines the operations on the data and the associated
roles. Once the preprocessing steps are defined, any parameters are
estimated using <code><a href="#topic+prep">prep()</a></code>. Once the data are ready for
transformation, the <code><a href="#topic+bake">bake()</a></code> function applies the operations.
</p>


<h3>Step Functions</h3>

<p>These functions are used to add new actions to the recipe and have the
naming convention <code>"step_action"</code>. For example,
<code><a href="#topic+step_center">step_center()</a></code> centers the data to have a zero mean and
<code><a href="#topic+step_dummy">step_dummy()</a></code> is used to create dummy variables.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Max Kuhn <a href="mailto:max@posit.co">max@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
</li>
<li><p> Emil Hvitfeldt <a href="mailto:emil.hvitfeldt@posit.co">emil.hvitfeldt@posit.co</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tidymodels/recipes">https://github.com/tidymodels/recipes</a>
</p>
</li>
<li> <p><a href="https://recipes.tidymodels.org/">https://recipes.tidymodels.org/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/recipes/issues">https://github.com/tidymodels/recipes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.get_data_types'>Get types for use in recipes</h2><span id='topic+.get_data_types'></span><span id='topic+.get_data_types.default'></span><span id='topic+.get_data_types.character'></span><span id='topic+.get_data_types.ordered'></span><span id='topic+.get_data_types.factor'></span><span id='topic+.get_data_types.integer'></span><span id='topic+.get_data_types.numeric'></span><span id='topic+.get_data_types.double'></span><span id='topic+.get_data_types.Surv'></span><span id='topic+.get_data_types.logical'></span><span id='topic+.get_data_types.Date'></span><span id='topic+.get_data_types.POSIXct'></span><span id='topic+.get_data_types.list'></span><span id='topic+.get_data_types.textrecipes_tokenlist'></span><span id='topic+.get_data_types.hardhat_case_weights'></span>

<h3>Description</h3>

<p>The <code>.get_data_types()</code> generic is used internally to supply types to
columns used in recipes. These functions underlie the work that the user sees
in <a href="#topic+selections">selections</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_data_types(x)

## Default S3 method:
.get_data_types(x)

## S3 method for class 'character'
.get_data_types(x)

## S3 method for class 'ordered'
.get_data_types(x)

## S3 method for class 'factor'
.get_data_types(x)

## S3 method for class 'integer'
.get_data_types(x)

## S3 method for class 'numeric'
.get_data_types(x)

## S3 method for class 'double'
.get_data_types(x)

## S3 method for class 'Surv'
.get_data_types(x)

## S3 method for class 'logical'
.get_data_types(x)

## S3 method for class 'Date'
.get_data_types(x)

## S3 method for class 'POSIXct'
.get_data_types(x)

## S3 method for class 'list'
.get_data_types(x)

## S3 method for class 'textrecipes_tokenlist'
.get_data_types(x)

## S3 method for class 'hardhat_case_weights'
.get_data_types(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_data_types_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function acts as an extended recipes-specific version of <code><a href="base.html#topic+class">class()</a></code>. By
ignoring differences in similar types (&quot;double&quot; and &quot;numeric&quot;) and allowing
each element to have multiple types (&quot;factor&quot; returns &quot;factor&quot;, &quot;unordered&quot;,
and &quot;nominal&quot;, and &quot;character&quot; returns &quot;string&quot;, &quot;unordered&quot;, and
&quot;nominal&quot;) we are able to create more natural selectors such as
<code><a href="#topic+all_nominal">all_nominal()</a></code>, <code><a href="#topic+all_string">all_string()</a></code> and <code><a href="#topic+all_integer">all_integer()</a></code>.
</p>
<p>The following list shows the data types for different classes, as defined
by recipes. If an object has a class not supported by <code>.get_data_types()</code>,
it will get data type &quot;other&quot;.
</p>

<ul>
<li><p> character: string, unordered, and nominal
</p>
</li>
<li><p> ordered: ordered, and nominal
</p>
</li>
<li><p> factor: factor, unordered, and nominal
</p>
</li>
<li><p> integer: integer, and numeric
</p>
</li>
<li><p> numeric: double, and numeric
</p>
</li>
<li><p> double: double, and numeric
</p>
</li>
<li><p> Surv: surv
</p>
</li>
<li><p> logical: logical
</p>
</li>
<li><p> Date: date
</p>
</li>
<li><p> POSIXct: datetime
</p>
</li>
<li><p> list: list
</p>
</li>
<li><p> textrecipes_tokenlist: tokenlist
</p>
</li>
<li><p> hardhat_case_weights: case_weights
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Sacramento, package = "modeldata")
lapply(Sacramento, .get_data_types)

</code></pre>

<hr>
<h2 id='add_step'>Add a New Operation to the Current Recipe</h2><span id='topic+add_step'></span><span id='topic+add_check'></span>

<h3>Description</h3>

<p><code>add_step</code> adds a step to the last location in the recipe.
<code>add_check</code> does the same for checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_step(rec, object)

add_check(rec, object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_step_+3A_rec">rec</code></td>
<td>
<p>A <code><a href="#topic+recipe">recipe()</a></code>.</p>
</td></tr>
<tr><td><code id="add_step_+3A_object">object</code></td>
<td>
<p>A step or check object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A updated <code><a href="#topic+recipe">recipe()</a></code> with the new operation in the last slot.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='bake'>Apply a trained preprocessing recipe</h2><span id='topic+bake'></span><span id='topic+bake.recipe'></span>

<h3>Description</h3>

<p>For a recipe with at least one preprocessing operation that has been trained by
<code><a href="#topic+prep">prep()</a></code>, apply the computations to new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bake(object, ...)

## S3 method for class 'recipe'
bake(object, new_data, ..., composition = "tibble")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bake_+3A_object">object</code></td>
<td>
<p>A trained object such as a <code><a href="#topic+recipe">recipe()</a></code> with at least
one preprocessing operation.</p>
</td></tr>
<tr><td><code id="bake_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which variables will be
returned by the function. See <code><a href="#topic+selections">selections()</a></code> for more details.
If no selectors are given, the default is to use
<code><a href="dplyr.html#topic+everything">everything()</a></code>.</p>
</td></tr>
<tr><td><code id="bake_+3A_new_data">new_data</code></td>
<td>
<p>A data frame or tibble for whom the preprocessing will be
applied. If <code>NULL</code> is given to <code>new_data</code>, the pre-processed <em>training
data</em> will be returned (assuming that <code>prep(retain = TRUE)</code> was used).</p>
</td></tr>
<tr><td><code id="bake_+3A_composition">composition</code></td>
<td>
<p>Either &quot;tibble&quot;, &quot;matrix&quot;, &quot;data.frame&quot;, or
&quot;dgCMatrix&quot; for the format of the processed data set. Note that
all computations during the baking process are done in a
non-sparse format. Also, note that this argument should be
called <strong>after</strong> any selectors and the selectors should only
resolve to numeric columns (otherwise an error is thrown).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+bake">bake()</a></code> takes a trained recipe and applies its operations to a
data set to create a design matrix. If you are using a recipe as a
preprocessor for modeling, we <strong>highly recommend</strong> that you use a <code>workflow()</code>
instead of manually applying a recipe (see the example in <code><a href="#topic+recipe">recipe()</a></code>).
</p>
<p>If the data set is not too large, time can be saved by using the
<code>retain = TRUE</code> option of <code><a href="#topic+prep">prep()</a></code>. This stores the processed version of the
training set. With this option set, <code>bake(object, new_data = NULL)</code>
will return it for free.
</p>
<p>Also, any steps with <code>skip = TRUE</code> will not be applied to the
data when <code><a href="#topic+bake">bake()</a></code> is invoked with a data set in <code>new_data</code>.
<code>bake(object, new_data = NULL)</code> will always have all of the steps applied.
</p>


<h3>Value</h3>

<p>A tibble, matrix, or sparse matrix that may have different
columns than the original columns in <code>new_data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recipe">recipe()</a></code>, <code><a href="#topic+prep">prep()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")

ames &lt;- mutate(ames, Sale_Price = log10(Sale_Price))

ames_rec &lt;-
  recipe(Sale_Price ~ ., data = ames[-(1:6), ]) %&gt;%
  step_other(Neighborhood, threshold = 0.05) %&gt;%
  step_dummy(all_nominal()) %&gt;%
  step_interact(~ starts_with("Central_Air"):Year_Built) %&gt;%
  step_ns(Longitude, Latitude, deg_free = 2) %&gt;%
  step_zv(all_predictors()) %&gt;%
  prep()

# return the training set (already embedded in ames_rec)
bake(ames_rec, new_data = NULL)

# apply processing to other data:
bake(ames_rec, new_data = head(ames))

# only return selected variables:
bake(ames_rec, new_data = head(ames), all_numeric_predictors())
bake(ames_rec, new_data = head(ames), starts_with(c("Longitude", "Latitude")))

</code></pre>

<hr>
<h2 id='case_weights'>Using case weights with recipes</h2><span id='topic+case_weights'></span>

<h3>Description</h3>

<p>Case weights are positive numeric values that may influence how much each
data point has during the preprocessing. There are a variety of situations
where case weights can be used.
</p>


<h3>Details</h3>

<p>tidymodels packages differentiate <em>how</em> different types of case weights
should be used during the entire data analysis process, including
preprocessing data, model fitting, performance calculations, etc.
</p>
<p>The tidymodels packages require users to convert their numeric vectors to a
vector class that reflects how these should be used. For example, there are
some situations where the weights should not affect operations such as
centering and scaling or other preprocessing operations.
</p>
<p>The types of weights allowed in tidymodels are:
</p>

<ul>
<li><p> Frequency weights via <code><a href="hardhat.html#topic+frequency_weights">hardhat::frequency_weights()</a></code>
</p>
</li>
<li><p> Importance weights via <code><a href="hardhat.html#topic+importance_weights">hardhat::importance_weights()</a></code>
</p>
</li></ul>

<p>More types can be added by request.
</p>
<p>For recipes, we distinguish between supervised and unsupervised steps.
Supervised steps use the outcome in the calculations, this type of steps
will use frequency and importance weights. Unsupervised steps don't use the
outcome and will only use frequency weights.
</p>
<p>There are 3 main principles about how case weights are used within recipes.
First, the data set that is passed to the <code>recipe()</code> function should already
have a case weights column in it. This column can be created beforehand using
<code><a href="hardhat.html#topic+frequency_weights">hardhat::frequency_weights()</a></code> or <code><a href="hardhat.html#topic+importance_weights">hardhat::importance_weights()</a></code>. Second,
There can only be 1 case weights column in a recipe at any given time. Third,
You can not modify the case weights column with most of the steps or using
the <code>update_role()</code> and <code>add_role()</code> functions.
</p>
<p>These principles ensure that you experience minimal surprises when using case
weights, as the steps automatically apply case weighted operations when
supported. The printing method will additionally show which steps where
weighted and which steps ignored the weights because they were of an
incompatible type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frequency_weights">frequency_weights()</a></code>, <code><a href="#topic+importance_weights">importance_weights()</a></code>
</p>

<hr>
<h2 id='case-weight-helpers'>Helpers for steps with case weights</h2><span id='topic+case-weight-helpers'></span><span id='topic+get_case_weights'></span><span id='topic+averages'></span><span id='topic+medians'></span><span id='topic+variances'></span><span id='topic+correlations'></span><span id='topic+covariances'></span><span id='topic+pca_wts'></span><span id='topic+are_weights_used'></span>

<h3>Description</h3>

<p>These functions can be used to do basic calculations with or without case
weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_case_weights(info, .data, call = rlang::caller_env())

averages(x, wts = NULL, na_rm = TRUE)

medians(x, wts = NULL)

variances(x, wts = NULL, na_rm = TRUE)

correlations(x, wts = NULL, use = "everything", method = "pearson")

covariances(x, wts = NULL, use = "everything", method = "pearson")

pca_wts(x, wts = NULL)

are_weights_used(wts, unsupervised = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case-weight-helpers_+3A_info">info</code></td>
<td>
<p>A data frame from the <code>info</code> argument within steps</p>
</td></tr>
<tr><td><code id="case-weight-helpers_+3A_.data">.data</code></td>
<td>
<p>The training data</p>
</td></tr>
<tr><td><code id="case-weight-helpers_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="case-weight-helpers_+3A_x">x</code></td>
<td>
<p>A numeric vector or a data frame</p>
</td></tr>
<tr><td><code id="case-weight-helpers_+3A_wts">wts</code></td>
<td>
<p>A vector of case weights</p>
</td></tr>
<tr><td><code id="case-weight-helpers_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical value indicating whether <code>NA</code>
values should be removed during computations.</p>
</td></tr>
<tr><td><code id="case-weight-helpers_+3A_use">use</code></td>
<td>
<p>Used by <code><a href="#topic+correlations">correlations()</a></code> or <code><a href="#topic+covariances">covariances()</a></code> to pass argument to
<code><a href="stats.html#topic+cor">cor()</a></code> or <code><a href="stats.html#topic+cov">cov()</a></code></p>
</td></tr>
<tr><td><code id="case-weight-helpers_+3A_method">method</code></td>
<td>
<p>Used by <code><a href="#topic+correlations">correlations()</a></code> or <code><a href="#topic+covariances">covariances()</a></code> to pass argument to
<code><a href="stats.html#topic+cor">cor()</a></code> or <code><a href="stats.html#topic+cov">cov()</a></code></p>
</td></tr>
<tr><td><code id="case-weight-helpers_+3A_unsupervised">unsupervised</code></td>
<td>
<p>Can the step handle unsupervised weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+get_case_weights">get_case_weights()</a></code> is designed for developers of recipe steps, to return
a column with the role of &quot;case weight&quot; as a vector.
</p>
<p>For the other functions, rows with missing case weights are removed from
calculations.
</p>
<p>For <code>averages()</code> and <code>variances()</code>, missing values in the data (<em>not</em> the
case weights) only affect the calculations for those rows. For
<code>correlations()</code>, the correlation matrix computation first removes rows
with any missing values (equal to the &quot;complete.obs&quot; strategy in
<code><a href="stats.html#topic+cor">stats::cor()</a></code>).
</p>
<p><code>are_weights_used()</code> is designed for developers of recipe steps and is used
inside print method to determine how printing should be done.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='check_class'>Check variable class</h2><span id='topic+check_class'></span>

<h3>Description</h3>

<p><code>check_class</code> creates a <em>specification</em> of a recipe
check that will check if a variable is of a designated class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_class(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  class_nm = NULL,
  allow_additional = FALSE,
  skip = FALSE,
  class_list = NULL,
  id = rand_id("class")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_class_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The check will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="check_class_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this check. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="check_class_+3A_role">role</code></td>
<td>
<p>Not used by this check since no new variables are
created.</p>
</td></tr>
<tr><td><code id="check_class_+3A_trained">trained</code></td>
<td>
<p>A logical for whether the selectors in <code>...</code>
have been resolved by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="check_class_+3A_class_nm">class_nm</code></td>
<td>
<p>A character vector that will be used in <code>inherits</code> to
check the class. If <code>NULL</code> the classes will be learned in <code>prep</code>.
Can contain more than one class.</p>
</td></tr>
<tr><td><code id="check_class_+3A_allow_additional">allow_additional</code></td>
<td>
<p>If <code>TRUE</code> a variable is allowed to
have additional classes to the one(s) that are checked.</p>
</td></tr>
<tr><td><code id="check_class_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the check be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="check_class_+3A_class_list">class_list</code></td>
<td>
<p>A named list of column classes. This is
<code>NULL</code> until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="check_class_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this check to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can check the classes of the variables
in two ways. When the <code>class</code> argument is provided
it will check if all the variables specified are of the
given class. If this argument is <code>NULL</code>, the check will
learn the classes of each of the specified variables in <code>prep</code>.
Both ways will break <code>bake</code> if the variables are not of
the requested class. If a variable has multiple
classes in <code>prep</code>, all the classes are checked. Please note
that in <code>prep</code> the argument <code>strings_as_factors</code> defaults to
<code>TRUE</code>. If the train set contains character variables
the check will be break <code>bake</code> when <code>strings_as_factors</code> is
<code>TRUE</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new check added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this check, a tibble with columns
<code>terms</code> (the selectors or variables selected) and <code>value</code> (the type)
is returned.
</p>


<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other checks: 
<code><a href="#topic+check_cols">check_cols</a>()</code>,
<code><a href="#topic+check_missing">check_missing</a>()</code>,
<code><a href="#topic+check_new_values">check_new_values</a>()</code>,
<code><a href="#topic+check_range">check_range</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
data(Sacramento, package = "modeldata")

# Learn the classes on the train set
train &lt;- Sacramento[1:500, ]
test &lt;- Sacramento[501:nrow(Sacramento), ]
recipe(train, sqft ~ .) %&gt;%
  check_class(everything()) %&gt;%
  prep(train, strings_as_factors = FALSE) %&gt;%
  bake(test)

# Manual specification
recipe(train, sqft ~ .) %&gt;%
  check_class(sqft, class_nm = "integer") %&gt;%
  check_class(city, zip, type, class_nm = "factor") %&gt;%
  check_class(latitude, longitude, class_nm = "numeric") %&gt;%
  prep(train, strings_as_factors = FALSE) %&gt;%
  bake(test)

# By default only the classes that are specified
#   are allowed.
x_df &lt;- tibble(time = c(Sys.time() - 60, Sys.time()))
x_df$time %&gt;% class()
## Not run: 
recipe(x_df) %&gt;%
  check_class(time, class_nm = "POSIXt") %&gt;%
  prep(x_df) %&gt;%
  bake_(x_df)

## End(Not run)

# Use allow_additional = TRUE if you are fine with it
recipe(x_df) %&gt;%
  check_class(time, class_nm = "POSIXt", allow_additional = TRUE) %&gt;%
  prep(x_df) %&gt;%
  bake(x_df)

</code></pre>

<hr>
<h2 id='check_cols'>Check if all columns are present</h2><span id='topic+check_cols'></span>

<h3>Description</h3>

<p><code>check_cols</code> creates a <em>specification</em> of a recipe
step that will check if all the columns of the training frame are
present in the new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cols(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = rand_id("cols")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cols_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The check will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="check_cols_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this check. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="check_cols_+3A_role">role</code></td>
<td>
<p>Not used by this check since no new variables are
created.</p>
</td></tr>
<tr><td><code id="check_cols_+3A_trained">trained</code></td>
<td>
<p>A logical for whether the selectors in <code>...</code>
have been resolved by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="check_cols_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the check be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="check_cols_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this check to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This check will break the <code>bake</code> function if any of the specified
columns is not present in the data. If the check passes, nothing is changed
to the data.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new check added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this check, a tibble with columns
<code>terms</code> (the selectors or variables selected) and <code>value</code> (the type)
is returned.
</p>


<h3>See Also</h3>

<p>Other checks: 
<code><a href="#topic+check_class">check_class</a>()</code>,
<code><a href="#topic+check_missing">check_missing</a>()</code>,
<code><a href="#topic+check_new_values">check_new_values</a>()</code>,
<code><a href="#topic+check_range">check_range</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_rec &lt;- recipe(HHV ~ ., data = biomass) %&gt;%
  step_rm(sample, dataset) %&gt;%
  check_cols(contains("gen")) %&gt;%
  step_center(all_numeric_predictors())
## Not run: 
bake(biomass_rec, biomass[, c("carbon", "HHV")])

## End(Not run)

</code></pre>

<hr>
<h2 id='check_missing'>Check for missing values</h2><span id='topic+check_missing'></span>

<h3>Description</h3>

<p><code>check_missing</code> creates a <em>specification</em> of a recipe
operation that will check if variables contain missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_missing(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("missing")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_missing_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The check will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="check_missing_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this check. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="check_missing_+3A_role">role</code></td>
<td>
<p>Not used by this check since no new variables are
created.</p>
</td></tr>
<tr><td><code id="check_missing_+3A_trained">trained</code></td>
<td>
<p>A logical for whether the selectors in <code>...</code>
have been resolved by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="check_missing_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="check_missing_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the check be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="check_missing_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this check to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This check will break the <code>bake</code> function if any of the checked
columns does contain <code>NA</code> values. If the check passes, nothing is changed
to the data.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new check added to the
sequence of any existing operations.
</p>


<h3>tidy() results</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this check, a tibble with column
<code>terms</code> (the selectors or variables selected) is returned.
</p>


<h3>See Also</h3>

<p>Other checks: 
<code><a href="#topic+check_class">check_class</a>()</code>,
<code><a href="#topic+check_cols">check_cols</a>()</code>,
<code><a href="#topic+check_new_values">check_new_values</a>()</code>,
<code><a href="#topic+check_range">check_range</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(credit_data, package = "modeldata")
is.na(credit_data) %&gt;% colSums()

# If the test passes, `new_data` is returned unaltered
recipe(credit_data) %&gt;%
  check_missing(Age, Expenses) %&gt;%
  prep() %&gt;%
  bake(credit_data)

# If your training set doesn't pass, prep() will stop with an error
## Not run: 
recipe(credit_data) %&gt;%
  check_missing(Income) %&gt;%
  prep()

## End(Not run)

# If `new_data` contain missing values, the check will stop `bake()`

train_data &lt;- credit_data %&gt;% dplyr::filter(Income &gt; 150)
test_data &lt;- credit_data %&gt;% dplyr::filter(Income &lt;= 150 | is.na(Income))

rp &lt;- recipe(train_data) %&gt;%
  check_missing(Income) %&gt;%
  prep()

bake(rp, train_data)
## Not run: 
bake(rp, test_data)

## End(Not run)

</code></pre>

<hr>
<h2 id='check_name'>check that newly created variable names don't overlap</h2><span id='topic+check_name'></span>

<h3>Description</h3>

<p><code>check_name</code> is to be used in the bake function to ensure that
newly created variable names don't overlap with existing names.
Throws an error if check fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_name(
  res,
  new_data,
  object,
  newname = NULL,
  names = FALSE,
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_name_+3A_res">res</code></td>
<td>
<p>A data frame or tibble of the newly created variables.</p>
</td></tr>
<tr><td><code id="check_name_+3A_new_data">new_data</code></td>
<td>
<p>A data frame or tibble passed to the bake function.</p>
</td></tr>
<tr><td><code id="check_name_+3A_object">object</code></td>
<td>
<p>A trained object passed to the bake function.</p>
</td></tr>
<tr><td><code id="check_name_+3A_newname">newname</code></td>
<td>
<p>A string of variable names if prefix isn't specified
in the trained object.</p>
</td></tr>
<tr><td><code id="check_name_+3A_names">names</code></td>
<td>
<p>A logical determining if the names should be set using
the names function (TRUE) or colnames function (FALSE).</p>
</td></tr>
<tr><td><code id="check_name_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running function, e.g.
<code>caller_env()</code>. The function will be mentioned in error messages as the
source of the error. See the call argument of <code><a href="rlang.html#topic+abort">rlang::abort()</a></code> for more
information.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='check_new_data'>Check for required column at bake-time</h2><span id='topic+check_new_data'></span>

<h3>Description</h3>

<p>When baking a step, create an information error message when a column that
is used by the step is not present in <code>new_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_new_data(req, object, new_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_new_data_+3A_req">req</code></td>
<td>
<p>A character vector of required columns.</p>
</td></tr>
<tr><td><code id="check_new_data_+3A_object">object</code></td>
<td>
<p>A step object.</p>
</td></tr>
<tr><td><code id="check_new_data_+3A_new_data">new_data</code></td>
<td>
<p>A tibble of data being baked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible NULL. Side effects are the focus of the function.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='check_new_values'>Check for new values</h2><span id='topic+check_new_values'></span>

<h3>Description</h3>

<p><code>check_new_values</code> creates a <em>specification</em> of a recipe
operation that will check if variables contain new values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_new_values(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  ignore_NA = TRUE,
  values = NULL,
  skip = FALSE,
  id = rand_id("new_values")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_new_values_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The check will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="check_new_values_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this check. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="check_new_values_+3A_role">role</code></td>
<td>
<p>Not used by this check since no new variables are
created.</p>
</td></tr>
<tr><td><code id="check_new_values_+3A_trained">trained</code></td>
<td>
<p>A logical for whether the selectors in <code>...</code>
have been resolved by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="check_new_values_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="check_new_values_+3A_ignore_na">ignore_NA</code></td>
<td>
<p>A logical that indicates if we should consider missing
values as value or not. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="check_new_values_+3A_values">values</code></td>
<td>
<p>A named list with the allowed values.
This is <code>NULL</code> until computed by prep.recipe().</p>
</td></tr>
<tr><td><code id="check_new_values_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the check be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="check_new_values_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this check to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This check will break the <code>bake</code> function if any of the checked
columns does contain values it did not contain when <code>prep</code> was called
on the recipe. If the check passes, nothing is changed to the data.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new check added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this check, a tibble with columns
<code>terms</code> (the selectors or variables selected) is returned.
</p>


<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other checks: 
<code><a href="#topic+check_class">check_class</a>()</code>,
<code><a href="#topic+check_cols">check_cols</a>()</code>,
<code><a href="#topic+check_missing">check_missing</a>()</code>,
<code><a href="#topic+check_range">check_range</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(credit_data, package = "modeldata")

# If the test passes, `new_data` is returned unaltered
recipe(credit_data) %&gt;%
  check_new_values(Home) %&gt;%
  prep() %&gt;%
  bake(new_data = credit_data)

# If `new_data` contains values not in `x` at the [prep()] function,
# the [bake()] function will break.
## Not run: 
recipe(credit_data %&gt;% dplyr::filter(Home != "rent")) %&gt;%
  check_new_values(Home) %&gt;%
  prep() %&gt;%
  bake(new_data = credit_data)

## End(Not run)

# By default missing values are ignored, so this passes.
recipe(credit_data %&gt;% dplyr::filter(!is.na(Home))) %&gt;%
  check_new_values(Home) %&gt;%
  prep() %&gt;%
  bake(credit_data)

# Use `ignore_NA = FALSE` if you consider missing values  as a value,
# that should not occur when not observed in the train set.
## Not run: 
recipe(credit_data %&gt;% dplyr::filter(!is.na(Home))) %&gt;%
  check_new_values(Home, ignore_NA = FALSE) %&gt;%
  prep() %&gt;%
  bake(credit_data)

## End(Not run)

</code></pre>

<hr>
<h2 id='check_range'>Check range consistency</h2><span id='topic+check_range'></span>

<h3>Description</h3>

<p><code>check_range</code> creates a <em>specification</em> of a recipe
check that will check if the range of a numeric
variable changed in the new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_range(
  recipe,
  ...,
  role = NA,
  skip = FALSE,
  trained = FALSE,
  slack_prop = 0.05,
  warn = FALSE,
  lower = NULL,
  upper = NULL,
  id = rand_id("range_check_")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_range_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The check will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="check_range_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this check. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="check_range_+3A_role">role</code></td>
<td>
<p>Not used by this check since no new variables are
created.</p>
</td></tr>
<tr><td><code id="check_range_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the check be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="check_range_+3A_trained">trained</code></td>
<td>
<p>A logical for whether the selectors in <code>...</code>
have been resolved by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="check_range_+3A_slack_prop">slack_prop</code></td>
<td>
<p>The allowed slack as a proportion of the range
of the variable in the train set.</p>
</td></tr>
<tr><td><code id="check_range_+3A_warn">warn</code></td>
<td>
<p>If <code>TRUE</code> the check will throw a warning instead
of an error when failing.</p>
</td></tr>
<tr><td><code id="check_range_+3A_lower">lower</code></td>
<td>
<p>A named numeric vector of minimum values in the train set.
This is <code>NULL</code> until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="check_range_+3A_upper">upper</code></td>
<td>
<p>A named numeric vector of maximum values in the train set.
This is <code>NULL</code> until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="check_range_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this check to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The amount of slack that is allowed is determined by the
<code>slack_prop</code>. This is a numeric of length one or two. If
of length one, the same proportion will be used at both ends
of the train set range. If of length two, its first value
is used to compute the allowed slack at the lower end,
the second to compute the allowed slack at the upper end.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new check added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this check, a tibble with columns
<code>terms</code> (the selectors or variables selected) and <code>value</code> (the means)
is returned.
</p>


<h3>See Also</h3>

<p>Other checks: 
<code><a href="#topic+check_class">check_class</a>()</code>,
<code><a href="#topic+check_cols">check_cols</a>()</code>,
<code><a href="#topic+check_missing">check_missing</a>()</code>,
<code><a href="#topic+check_new_values">check_new_values</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>slack_df &lt;- data_frame(x = 0:100)
slack_new_data &lt;- data_frame(x = -10:110)

# this will fail the check both ends
## Not run: 
recipe(slack_df) %&gt;%
  check_range(x) %&gt;%
  prep() %&gt;%
  bake(slack_new_data)

## End(Not run)

# this will fail the check only at the upper end
## Not run: 
recipe(slack_df) %&gt;%
  check_range(x, slack_prop = c(0.1, 0.05)) %&gt;%
  prep() %&gt;%
  bake(slack_new_data)

## End(Not run)

# give a warning instead of an error
## Not run: 
recipe(slack_df) %&gt;%
  check_range(x, warn = TRUE) %&gt;%
  prep() %&gt;%
  bake(slack_new_data)

## End(Not run)
</code></pre>

<hr>
<h2 id='check_type'>Quantitatively check on variables</h2><span id='topic+check_type'></span>

<h3>Description</h3>

<p>This internal function is to be used in the prep function to ensure that
the type of the variables matches the expectation. Throws an error if
check fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_type(dat, quant = TRUE, types = NULL, call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_type_+3A_dat">dat</code></td>
<td>
<p>A data frame or tibble of the training data.</p>
</td></tr>
<tr><td><code id="check_type_+3A_quant">quant</code></td>
<td>
<p>A logical indicating whether the data is expected to be numeric
(TRUE) or a factor/character (FALSE). Is ignored if <code>types</code> is specified.</p>
</td></tr>
<tr><td><code id="check_type_+3A_types">types</code></td>
<td>
<p>Character vector of allowed types. Following the same types as
<code><a href="#topic+has_role">has_role()</a></code>. See details for more.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>types</code> is a more fine-tuned way to use this. function compared to using
<code>quant</code>. <code>types</code> should specify all allowed types as designated by
<a href="#topic+.get_data_types">.get_data_types</a>. Suppose you want to allow doubles, integers, characters,
factors and ordered factors, then you should specify
<code>types = c("double", "integer", "string", "factor", "ordered")</code> to get a
clear error message.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='detect_step'>Detect if a particular step or check is used in a recipe</h2><span id='topic+detect_step'></span>

<h3>Description</h3>

<p>Detect if a particular step or check is used in a recipe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_step(recipe, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_step_+3A_recipe">recipe</code></td>
<td>
<p>A recipe to check.</p>
</td></tr>
<tr><td><code id="detect_step_+3A_name">name</code></td>
<td>
<p>Character name of a step or check, omitted the prefix. That is,
to check if <code>step_intercept</code> is present, use <code>name = intercept</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating if recipes contains given step.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rec &lt;- recipe(Species ~ ., data = iris) %&gt;%
  step_intercept()

detect_step(rec, "intercept")
</code></pre>

<hr>
<h2 id='developer_functions'>Developer functions for creating recipes steps</h2><span id='topic+developer_functions'></span>

<h3>Description</h3>

<p>This page provides a comprehensive list of the exported functions for
creating recipes steps and guidance on how to use them.
</p>


<h3>Creating steps</h3>

<p><code><a href="#topic+add_step">add_step()</a></code> and <code><a href="#topic+add_check">add_check()</a></code> are required when creating a new step. The
output of <code><a href="#topic+add_step">add_step()</a></code> should be the return value of all steps and should
have the following format:
</p>
<div class="sourceCode r"><pre>step_example &lt;- function(recipe,
                         ...,
                         role = NA,
                         trained = FALSE,
                         skip = FALSE,
                         id = rand_id("example")) {
  add_step(
    recipe,
    step_example_new(
      terms = enquos(...),
      role = role,
      trained = trained,
      skip = skip,
      id = id
    )
  )
}
</pre></div>
<p><code><a href="#topic+rand_id">rand_id()</a></code> should be used in the arguments of <code>step_example()</code> to specify
the argument, as we see in the above example.
</p>
<p><code><a href="#topic+recipes_pkg_check">recipes_pkg_check()</a></code> should be used in <code>step_example()</code> functions together
with <code><a href="#topic+required_pkgs">required_pkgs()</a></code> to alert users that certain other packages are
required. The standard way of using this function is the following format:
</p>
<div class="sourceCode r"><pre>recipes_pkg_check(required_pkgs.step_example())
</pre></div>
<p><code><a href="#topic+step">step()</a></code> and <code><a href="#topic+check">check()</a></code> are used within the <code style="white-space: pre;">&#8288;step_*_new()&#8288;</code> function that you
use in your new step. It will be used in the following way:
</p>
<div class="sourceCode r"><pre>step_example_new &lt;- function(terms, role, trained, skip, id) {
  step(
    subclass = "example",
    terms = terms,
    role = role,
    trained = trained,
    skip = skip,
    id = id
  )
}
</pre></div>
<p><code><a href="#topic+recipes_eval_select">recipes_eval_select()</a></code> is used within <code style="white-space: pre;">&#8288;prep.step_*()&#8288;</code> functions, and are
used to turn the <code>terms</code> object into a character vector of the selected
variables.
</p>
<p>It will most likely be used like so:
</p>
<div class="sourceCode r"><pre>col_names &lt;- recipes_eval_select(x$terms, training, info)
</pre></div>
<p><code><a href="#topic+check_type">check_type()</a></code> can be used within <code style="white-space: pre;">&#8288;prep.step_*()&#8288;</code> functions to check that the
variables passed in are the right types. We recommend that you use the
<code>types</code> argument as it offers higher flexibility and it matches the types
defined by <code><a href="#topic+.get_data_types">.get_data_types()</a></code>. When using <code>types</code> we find it better to be
explicit, e.g. writing <code>types = c("double", "integer")</code> instead of <code>types = "numeric"</code>, as it produces cleaner error messages.
</p>
<p>It should be used like so:
</p>
<div class="sourceCode r"><pre>check_type(training[, col_names], types = c("double", "integer"))
</pre></div>
<p><code><a href="#topic+check_new_data">check_new_data()</a></code> should be used within <code style="white-space: pre;">&#8288;bake.step_*()&#8288;</code>. This function is
used to make check that the required columns are present in the data. It
should be one of the first lines inside the function.
</p>
<p>It should be used like so:
</p>
<div class="sourceCode r"><pre>check_new_data(names(object$columns), object, new_data)
</pre></div>
<p><code><a href="#topic+check_name">check_name()</a></code> should be used in <code style="white-space: pre;">&#8288;bake.step_*()&#8288;</code> functions for steps that add
new columns to the data set. The function throws an error if the column names
already exist in the data set. It should be called before adding the new
columns to the data set.
</p>
<p><code><a href="#topic+get_keep_original_cols">get_keep_original_cols()</a></code> and <code><a href="#topic+remove_original_cols">remove_original_cols()</a></code> are used within steps
with the <code>keep_original_cols</code> argument. <code><a href="#topic+get_keep_original_cols">get_keep_original_cols()</a></code> is used in
<code style="white-space: pre;">&#8288;prep.step_*()&#8288;</code> functions for steps that were created before the
<code>keep_original_cols</code> argument was added, and acts as a way to throw a warning
that the user should regenerate the recipe. <code><a href="#topic+remove_original_cols">remove_original_cols()</a></code> should
be used in <code style="white-space: pre;">&#8288;bake.step_*()&#8288;</code> functions to remove the original columns. It is
worth noting that <code><a href="#topic+remove_original_cols">remove_original_cols()</a></code> can remove multiple columns at
once and when possible should be put outside <code>for</code> loops.
</p>
<div class="sourceCode r"><pre>new_data &lt;- remove_original_cols(new_data, object, names_of_original_cols)
</pre></div>
<p><code><a href="#topic+recipes_remove_cols">recipes_remove_cols()</a></code> should be used in <code style="white-space: pre;">&#8288;prep.step_*()&#8288;</code> functions, and is
used to remove columns from the data set, either by using the
<code>object$removals</code> field or by using the <code>col_names</code> argument.
</p>
<p><code><a href="#topic+get_case_weights">get_case_weights()</a></code> and <code><a href="#topic+are_weights_used">are_weights_used()</a></code> are functions that help you
extract case weights and help determine if they are used or not within the
step. They will typically be used within the <code style="white-space: pre;">&#8288;prep.step_*()&#8288;</code> functions if the
step in question supports case weights.
</p>
<p><code><a href="#topic+print_step">print_step()</a></code> is used inside <code style="white-space: pre;">&#8288;print.step_*()&#8288;</code> functions. This function is
replacing the internally deprecated <code><a href="#topic+printer">printer()</a></code> function.
</p>
<p><code><a href="#topic+sel2char">sel2char()</a></code> is mostly used within <code style="white-space: pre;">&#8288;tidy.step_*()&#8288;</code> functions to turn
selections into character vectors.
</p>
<p><code><a href="#topic+names0">names0()</a></code> creates a series of <code>num</code> names with a common prefix. The names
are numbered with leading zeros (e.g. <code>prefix01</code>-<code>prefix10</code> instead of
<code>prefix1</code>-<code>prefix10</code>). This is useful for many types of steps that produce
new columns.
</p>


<h3>Interacting with recipe objects</h3>

<p><code><a href="#topic+detect_step">detect_step()</a></code> returns a logical indicator to determine if a given step or
check is included in a recipe.
</p>
<p><code><a href="#topic+fully_trained">fully_trained()</a></code> returns a logical indicator if the recipe is fully trained.
The function <code><a href="#topic+is_trained">is_trained()</a></code> can be used to check in any individual steps are
trained or not.
</p>
<p><code><a href="#topic+.get_data_types">.get_data_types()</a></code> is an S3 method that is used for <a href="#topic+selections">selections</a>. This method
can be extended to work with column types not supported by recipes.
</p>
<p><code><a href="#topic+recipes_extension_check">recipes_extension_check()</a></code> is recommended to be used by package authors to
make sure that all steps have <code style="white-space: pre;">&#8288;prep.step_*()&#8288;</code>, <code style="white-space: pre;">&#8288;bake.step_*()&#8288;</code>,
<code style="white-space: pre;">&#8288;print.step_*()&#8288;</code>, <code style="white-space: pre;">&#8288;tidy.step_*()&#8288;</code>, and <code style="white-space: pre;">&#8288;required_pkgs.step_*()&#8288;</code> methods. It
should be used as a test, preferably like this:
</p>
<div class="sourceCode r"><pre>test_that("recipes_extension_check", {
  expect_snapshot(
    recipes::recipes_extension_check(
      pkg = "pkgname"
    )
  )
})
</pre></div>

<hr>
<h2 id='discretize'>Discretize Numeric Variables</h2><span id='topic+discretize'></span><span id='topic+discretize.default'></span><span id='topic+discretize.numeric'></span><span id='topic+predict.discretize'></span>

<h3>Description</h3>

<p><code>discretize()</code> converts a numeric vector into a factor with
bins having approximately the same number of data points (based
on a training set).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize(x, ...)

## Default S3 method:
discretize(x, ...)

## S3 method for class 'numeric'
discretize(
  x,
  cuts = 4,
  labels = NULL,
  prefix = "bin",
  keep_na = TRUE,
  infs = TRUE,
  min_unique = 10,
  ...
)

## S3 method for class 'discretize'
predict(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="discretize_+3A_...">...</code></td>
<td>
<p>Options to pass to
<code><a href="stats.html#topic+quantile">stats::quantile()</a></code> that should not include <code>x</code>
or <code>probs</code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_cuts">cuts</code></td>
<td>
<p>An integer defining how many cuts to make of the
data.</p>
</td></tr>
<tr><td><code id="discretize_+3A_labels">labels</code></td>
<td>
<p>A character vector defining the factor levels
that will be in the new factor (from smallest to largest). This
should have length <code>cuts+1</code> and should not include a level
for missing (see <code>keep_na</code> below).</p>
</td></tr>
<tr><td><code id="discretize_+3A_prefix">prefix</code></td>
<td>
<p>A single parameter value to be used as a prefix
for the factor levels (e.g. <code>bin1</code>, <code>bin2</code>, ...). If
the string is not a valid R name, it is coerced to one.
If <code>prefix = NULL</code> then the factor levels will be labelled
according to the output of <code>cut()</code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_keep_na">keep_na</code></td>
<td>
<p>A logical for whether a factor level should be
created to identify missing values in <code>x</code>. If <code>keep_na</code> is
set to <code>TRUE</code> then <code>na.rm = TRUE</code> is used when calling
<code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_infs">infs</code></td>
<td>
<p>A logical indicating whether the smallest and
largest cut point should be infinite.</p>
</td></tr>
<tr><td><code id="discretize_+3A_min_unique">min_unique</code></td>
<td>
<p>An integer defining a sample size line of
dignity for the binning. If (the number of unique
values)<code style="white-space: pre;">&#8288;/(cuts+1)&#8288;</code> is less than <code>min_unique</code>, no
discretization takes place.</p>
</td></tr>
<tr><td><code id="discretize_+3A_object">object</code></td>
<td>
<p>An object of class <code>discretize</code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_new_data">new_data</code></td>
<td>
<p>A new numeric object to be binned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>discretize</code> estimates the cut points from
<code>x</code> using percentiles. For example, if <code>cuts = 3</code>, the
function estimates the quartiles of <code>x</code> and uses these as
the cut points. If <code>cuts = 2</code>, the bins are defined as
being above or below the median of <code>x</code>.
</p>
<p>The <code>predict</code> method can then be used to turn numeric
vectors into factor vectors.
</p>
<p>If <code>keep_na = TRUE</code>, a suffix of &quot;_missing&quot; is used as a
factor level (see the examples below).
</p>
<p>If <code>infs = FALSE</code> and a new value is greater than the
largest value of <code>x</code>, a missing value will result.
</p>


<h3>Value</h3>

<p><code>discretize</code> returns an object of class
<code>discretize</code> and <code>predict.discretize</code> returns a factor
vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

median(biomass_tr$carbon)
discretize(biomass_tr$carbon, cuts = 2)
discretize(biomass_tr$carbon, cuts = 2, infs = FALSE)
discretize(biomass_tr$carbon, cuts = 2, infs = FALSE, keep_na = FALSE)
discretize(biomass_tr$carbon, cuts = 2, prefix = "maybe a bad idea to bin")

carbon_binned &lt;- discretize(biomass_tr$carbon)
table(predict(carbon_binned, biomass_tr$carbon))

carbon_no_infs &lt;- discretize(biomass_tr$carbon, infs = FALSE)
predict(carbon_no_infs, c(50, 100))

</code></pre>

<hr>
<h2 id='fixed'>Helper Functions for Profile Data Sets</h2><span id='topic+fixed'></span><span id='topic+fixed.default'></span><span id='topic+fixed.numeric'></span><span id='topic+fixed.factor'></span><span id='topic+fixed.character'></span><span id='topic+fixed.Date'></span><span id='topic+fixed.POSIXct'></span><span id='topic+prof'></span><span id='topic+prof.numeric'></span><span id='topic+prof.factor'></span><span id='topic+prof.character'></span><span id='topic+prof.Date'></span><span id='topic+prof.POSIXct'></span>

<h3>Description</h3>

<p>Helper Functions for Profile Data Sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed(x, pct, index, ...)

## Default S3 method:
fixed(x, pct, index, ...)

## S3 method for class 'numeric'
fixed(x, pct, index, ...)

## S3 method for class 'factor'
fixed(x, pct, index, ...)

## S3 method for class 'character'
fixed(x, pct, index, ...)

## S3 method for class 'Date'
fixed(x, pct, index, ...)

## S3 method for class 'POSIXct'
fixed(x, pct, index, ...)

prof(x, grid, ...)

## S3 method for class 'numeric'
prof(x, grid, ...)

## S3 method for class 'factor'
prof(x, grid, ...)

## S3 method for class 'character'
prof(x, grid, ...)

## S3 method for class 'Date'
prof(x, grid, ...)

## S3 method for class 'POSIXct'
prof(x, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="fixed_+3A_pct">pct</code>, <code id="fixed_+3A_index">index</code>, <code id="fixed_+3A_...">...</code>, <code id="fixed_+3A_grid">grid</code></td>
<td>
<p>Options pass from <code><a href="#topic+step_profile">step_profile()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='format_ch_vec'>Helpers for printing step functions</h2><span id='topic+format_ch_vec'></span><span id='topic+format_selectors'></span>

<h3>Description</h3>

<p>Helpers for printing step functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_ch_vec(x, sep = ", ", width = options()$width - 9)

format_selectors(x, width = options()$width - 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_ch_vec_+3A_x">x</code></td>
<td>
<p>A vector of objects.</p>
</td></tr>
<tr><td><code id="format_ch_vec_+3A_sep">sep</code></td>
<td>
<p>A character string for separating values.</p>
</td></tr>
<tr><td><code id="format_ch_vec_+3A_width">width</code></td>
<td>
<p>An integer for when to split the output over lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string
</p>

<hr>
<h2 id='formula.recipe'>Create a formula from a prepared recipe</h2><span id='topic+formula.recipe'></span>

<h3>Description</h3>

<p>In case a model formula is required, the formula method can
be used on a recipe to show what predictors and outcome(s)
could be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recipe'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.recipe_+3A_x">x</code></td>
<td>
<p>A recipe object that has been prepared.</p>
</td></tr>
<tr><td><code id="formula.recipe_+3A_...">...</code></td>
<td>
<p>Note currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
formula(recipe(Species + Sepal.Length ~ ., data = iris) %&gt;% prep())

iris_rec &lt;- recipe(Species ~ ., data = iris) %&gt;%
  step_center(all_numeric()) %&gt;%
  prep()
formula(iris_rec)
</code></pre>

<hr>
<h2 id='fully_trained'>Check to see if a recipe is trained/prepared</h2><span id='topic+fully_trained'></span>

<h3>Description</h3>

<p>Check to see if a recipe is trained/prepared
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fully_trained(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fully_trained_+3A_x">x</code></td>
<td>
<p>A recipe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical which is true if all of the recipe steps have been run
through <code>prep</code>. If no steps have been added to the recipe, <code>TRUE</code> is
returned only if the recipe has been prepped.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rec &lt;- recipe(Species ~ ., data = iris) %&gt;%
  step_center(all_numeric())

rec %&gt;% fully_trained()


rec %&gt;%
  prep(training = iris) %&gt;%
  fully_trained()
</code></pre>

<hr>
<h2 id='get_keep_original_cols'>Get the <code>keep_original_cols</code> value of a recipe step</h2><span id='topic+get_keep_original_cols'></span>

<h3>Description</h3>

<p>Get the <code>keep_original_cols</code> value of a recipe step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_keep_original_cols(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_keep_original_cols_+3A_object">object</code></td>
<td>
<p>A recipe step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical to keep the original variables in the output
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='has_role'>Role Selection</h2><span id='topic+has_role'></span><span id='topic+has_type'></span><span id='topic+all_outcomes'></span><span id='topic+all_predictors'></span><span id='topic+all_date'></span><span id='topic+all_date_predictors'></span><span id='topic+all_datetime'></span><span id='topic+all_datetime_predictors'></span><span id='topic+all_double'></span><span id='topic+all_double_predictors'></span><span id='topic+all_factor'></span><span id='topic+all_factor_predictors'></span><span id='topic+all_integer'></span><span id='topic+all_integer_predictors'></span><span id='topic+all_logical'></span><span id='topic+all_logical_predictors'></span><span id='topic+all_nominal'></span><span id='topic+all_nominal_predictors'></span><span id='topic+all_numeric'></span><span id='topic+all_numeric_predictors'></span><span id='topic+all_ordered'></span><span id='topic+all_ordered_predictors'></span><span id='topic+all_string'></span><span id='topic+all_string_predictors'></span><span id='topic+all_unordered'></span><span id='topic+all_unordered_predictors'></span><span id='topic+current_info'></span>

<h3>Description</h3>

<p><code>has_role()</code>, <code>all_predictors()</code>, and <code>all_outcomes()</code> can be used to
select variables in a formula that have certain roles.
</p>
<p><strong>In most cases</strong>, the right approach for users will be use to use the
predictor-specific selectors such as <code>all_numeric_predictors()</code> and
<code>all_nominal_predictors()</code>. In general you should be careful about using
<code>-all_outcomes()</code> if a <code style="white-space: pre;">&#8288;*_predictors()&#8288;</code> selector would do what you want.
</p>
<p>Similarly, <code>has_type()</code>, <code>all_numeric()</code>, <code>all_integer()</code>, <code>all_double()</code>,
<code>all_nominal()</code>, <code>all_ordered()</code>, <code>all_unordered()</code>, <code>all_factor()</code>,
<code>all_string()</code>, <code>all_date()</code> and <code>all_datetime()</code> are used to select columns
based on their data type.
</p>
<p><code>all_factor()</code> captures ordered and unordered factors, <code>all_string()</code>
captures characters, <code>all_unordered()</code> captures unordered factors and
characters, <code>all_ordered()</code> captures ordered factors, <code>all_nominal()</code>
captures characters, unordered and ordered factors.
</p>
<p><code>all_integer()</code> captures integers, <code>all_double()</code> captures doubles,
<code>all_numeric()</code> captures all kinds of numeric.
</p>
<p><code>all_date()</code> captures <code><a href="base.html#topic+Date">Date()</a></code> variables, <code>all_datetime()</code> captures
<code><a href="base.html#topic+POSIXct">POSIXct()</a></code> variables.
</p>
<p>See <a href="#topic+selections">selections</a> for more details.
</p>
<p><code>current_info()</code> is an internal function.
</p>
<p>All of these functions have have limited utility outside of column selection
in step functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_role(match = "predictor")

has_type(match = "numeric")

all_outcomes()

all_predictors()

all_date()

all_date_predictors()

all_datetime()

all_datetime_predictors()

all_double()

all_double_predictors()

all_factor()

all_factor_predictors()

all_integer()

all_integer_predictors()

all_logical()

all_logical_predictors()

all_nominal()

all_nominal_predictors()

all_numeric()

all_numeric_predictors()

all_ordered()

all_ordered_predictors()

all_string()

all_string_predictors()

all_unordered()

all_unordered_predictors()

current_info()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_role_+3A_match">match</code></td>
<td>
<p>A single character string for the query. Exact
matching is used (i.e. regular expressions won't work).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Selector functions return an integer vector.
</p>
<p><code>current_info()</code> returns an environment with objects <code>vars</code> and <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

rec &lt;- recipe(biomass) %&gt;%
  update_role(
    carbon, hydrogen, oxygen, nitrogen, sulfur,
    new_role = "predictor"
  ) %&gt;%
  update_role(HHV, new_role = "outcome") %&gt;%
  update_role(sample, new_role = "id variable") %&gt;%
  update_role(dataset, new_role = "splitting indicator")

recipe_info &lt;- summary(rec)
recipe_info

# Centering on all predictors except carbon
rec %&gt;%
  step_center(all_predictors(), -carbon) %&gt;%
  prep(training = biomass) %&gt;%
  bake(new_data = NULL)

</code></pre>

<hr>
<h2 id='juice'>Extract transformed training set</h2><span id='topic+juice'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>As of <code>recipes</code> version 0.1.14, <strong><code>juice()</code> is superseded</strong> in favor of
<code>bake(object, new_data = NULL)</code>.
</p>
<p>As steps are estimated by <code>prep</code>, these operations are applied to the
training set. Rather than running <code><a href="#topic+bake">bake()</a></code> to duplicate this processing, this
function will return variables from the processed training set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juice(object, ..., composition = "tibble")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="juice_+3A_object">object</code></td>
<td>
<p>A <code>recipe</code> object that has been prepared with the option
<code>retain = TRUE</code>.</p>
</td></tr>
<tr><td><code id="juice_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which variables will be
returned by the function. See <code><a href="#topic+selections">selections()</a></code> for more details.
If no selectors are given, the default is to use
<code><a href="dplyr.html#topic+everything">everything()</a></code>.</p>
</td></tr>
<tr><td><code id="juice_+3A_composition">composition</code></td>
<td>
<p>Either &quot;tibble&quot;, &quot;matrix&quot;, &quot;data.frame&quot;, or
&quot;dgCMatrix&quot; for the format of the processed data set. Note that
all computations during the baking process are done in a
non-sparse format. Also, note that this argument should be
called <strong>after</strong> any selectors and the selectors should only
resolve to numeric columns (otherwise an error is thrown).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>juice()</code> will return the results of a recipe where <em>all steps</em> have been
applied to the data, irrespective of the value of the step's <code>skip</code> argument.
</p>
<p><code>juice()</code> can only be used if a recipe was prepped with <code>retain = TRUE</code>. This
is equivalent to <code>bake(object, new_data = NULL)</code> which is the preferred way
to extract the transformation of the training data set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recipe">recipe()</a></code> <code><a href="#topic+prep">prep()</a></code> <code><a href="#topic+bake">bake()</a></code>
</p>

<hr>
<h2 id='names0'>Naming Tools</h2><span id='topic+names0'></span><span id='topic+dummy_names'></span><span id='topic+dummy_extract_names'></span>

<h3>Description</h3>

<p><code>names0</code> creates a series of <code>num</code> names with a common prefix.
The names are numbered with leading zeros (e.g.
<code>prefix01</code>-<code>prefix10</code> instead of <code>prefix1</code>-<code>prefix10</code>).
<code>dummy_names</code> can be used for renaming unordered and ordered
dummy variables (in <code><a href="#topic+step_dummy">step_dummy()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>names0(num, prefix = "x")

dummy_names(var, lvl, ordinal = FALSE, sep = "_")

dummy_extract_names(var, lvl, ordinal = FALSE, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names0_+3A_num">num</code></td>
<td>
<p>A single integer for how many elements are created.</p>
</td></tr>
<tr><td><code id="names0_+3A_prefix">prefix</code></td>
<td>
<p>A character string that will start each name.</p>
</td></tr>
<tr><td><code id="names0_+3A_var">var</code></td>
<td>
<p>A single string for the original factor name.</p>
</td></tr>
<tr><td><code id="names0_+3A_lvl">lvl</code></td>
<td>
<p>A character vectors of the factor levels (in order).
When used with <code><a href="#topic+step_dummy">step_dummy()</a></code>, <code>lvl</code> would be the suffixes
that result <em>after</em> <code>model.matrix</code> is called (see the
example below).</p>
</td></tr>
<tr><td><code id="names0_+3A_ordinal">ordinal</code></td>
<td>
<p>A logical; was the original factor ordered?</p>
</td></tr>
<tr><td><code id="names0_+3A_sep">sep</code></td>
<td>
<p>A single character value for the separator between the names and
levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>dummy_names()</code>, factor levels that are not valid
variable names (e.g. &quot;some text  with spaces&quot;) will be changed to valid
names by <code><a href="base.html#topic+make.names">base::make.names()</a></code>; see example below. This function will also
change the names of ordinal dummy variables. Instead of values such as
&quot;<code>.L</code>&quot;, &quot;<code>.Q</code>&quot;, or &quot;<code style="white-space: pre;">&#8288;^4&#8288;</code>&quot;, ordinal dummy variables are given simple integer
suffixes such as &quot;<code style="white-space: pre;">&#8288;_1&#8288;</code>&quot;, &quot;<code style="white-space: pre;">&#8288;_2&#8288;</code>&quot;, etc.
</p>


<h3>Value</h3>

<p><code>names0</code> returns a character string of length <code>num</code> and
<code>dummy_names</code> generates a character vector the same length as
<code>lvl</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names0(9, "a")
names0(10, "a")

example &lt;- data.frame(
  x = ordered(letters[1:5]),
  y = factor(LETTERS[1:5]),
  z = factor(paste(LETTERS[1:5], 1:5))
)

dummy_names("y", levels(example$y)[-1])
dummy_names("z", levels(example$z)[-1])

after_mm &lt;- colnames(model.matrix(~x, data = example))[-1]
after_mm
levels(example$x)

dummy_names("x", substring(after_mm, 2), ordinal = TRUE)
</code></pre>

<hr>
<h2 id='prep'>Estimate a preprocessing recipe</h2><span id='topic+prep'></span><span id='topic+prep.recipe'></span>

<h3>Description</h3>

<p>For a recipe with at least one preprocessing operation, estimate the required
parameters from a training set that can be later applied to other data
sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep(x, ...)

## S3 method for class 'recipe'
prep(
  x,
  training = NULL,
  fresh = FALSE,
  verbose = FALSE,
  retain = TRUE,
  log_changes = FALSE,
  strings_as_factors = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="prep_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (not currently
used).</p>
</td></tr>
<tr><td><code id="prep_+3A_training">training</code></td>
<td>
<p>A data frame or tibble that will be used to estimate
parameters for preprocessing.</p>
</td></tr>
<tr><td><code id="prep_+3A_fresh">fresh</code></td>
<td>
<p>A logical indicating whether already trained operation should be
re-trained. If <code>TRUE</code>, you should pass in a data set to the argument
<code>training</code>.</p>
</td></tr>
<tr><td><code id="prep_+3A_verbose">verbose</code></td>
<td>
<p>A logical that controls whether progress is reported as operations
are executed.</p>
</td></tr>
<tr><td><code id="prep_+3A_retain">retain</code></td>
<td>
<p>A logical: should the <em>preprocessed</em> training set be saved
into the <code>template</code> slot of the recipe after training? This is a good
idea if you want to add more steps later but want to avoid re-training
the existing steps. Also, it is advisable to use <code>retain = TRUE</code>
if any steps use the option <code>skip = FALSE</code>. <strong>Note</strong> that this can make
the final recipe size large. When <code>verbose = TRUE</code>, a message is written
with the approximate object size in memory but may be an underestimate
since it does not take environments into account.</p>
</td></tr>
<tr><td><code id="prep_+3A_log_changes">log_changes</code></td>
<td>
<p>A logical for printing a summary for each step regarding
which (if any) columns were added or removed during training.</p>
</td></tr>
<tr><td><code id="prep_+3A_strings_as_factors">strings_as_factors</code></td>
<td>
<p>A logical: should character columns be converted to
factors? This affects the preprocessed training set (when
<code>retain = TRUE</code>) as well as the results of <code>bake.recipe</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a data set, this function estimates the required quantities and
statistics needed by any operations. <code><a href="#topic+prep">prep()</a></code> returns an updated recipe
with the estimates. If you are using a recipe as a preprocessor for modeling,
we <strong>highly recommend</strong> that you use a <code>workflow()</code> instead of manually
estimating a recipe (see the example in <code><a href="#topic+recipe">recipe()</a></code>).
</p>
<p>Note that missing data is handled in the steps; there is no global
<code>na.rm</code> option at the recipe level or in <code><a href="#topic+prep">prep()</a></code>.
</p>
<p>Also, if a recipe has been trained using <code><a href="#topic+prep">prep()</a></code> and then steps
are added, <code><a href="#topic+prep">prep()</a></code> will only update the new operations. If
<code>fresh = TRUE</code>, all of the operations will be (re)estimated.
</p>
<p>As the steps are executed, the <code>training</code> set is updated. For example,
if the first step is to center the data and the second is to scale the
data, the step for scaling is given the centered data.
</p>


<h3>Value</h3>

<p>A recipe whose step objects have been updated with the required
quantities (e.g. parameter estimates, model objects, etc). Also, the
<code>term_info</code> object is likely to be modified as the operations are
executed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")

library(dplyr)

ames &lt;- mutate(ames, Sale_Price = log10(Sale_Price))

ames_rec &lt;-
  recipe(
    Sale_Price ~ Longitude + Latitude + Neighborhood + Year_Built + Central_Air,
    data = ames
  ) %&gt;%
  step_other(Neighborhood, threshold = 0.05) %&gt;%
  step_dummy(all_nominal()) %&gt;%
  step_interact(~ starts_with("Central_Air"):Year_Built) %&gt;%
  step_ns(Longitude, Latitude, deg_free = 5)

prep(ames_rec, verbose = TRUE)

prep(ames_rec, log_changes = TRUE)

</code></pre>

<hr>
<h2 id='prepper'>Wrapper function for preparing recipes within resampling</h2><span id='topic+prepper'></span>

<h3>Description</h3>

<p>When working with the <span class="pkg">rsample</span> package, a simple recipe
must be <em>prepared</em> using the <code>prep</code>
function first. When using recipes with <span class="pkg">rsample</span> it
is helpful to have a function that can prepare a recipe
across a series of <code>split</code> objects that are produced
in this package. <code>prepper</code> is a wrapper function
around <code>prep</code> that can be used to do
this. See the vignette on &quot;Recipes and rsample&quot; for an
example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepper(split_obj, recipe, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepper_+3A_split_obj">split_obj</code></td>
<td>
<p>An <code>rplit</code> object</p>
</td></tr>
<tr><td><code id="prepper_+3A_recipe">recipe</code></td>
<td>
<p>An untrained <code>recipe</code> object.</p>
</td></tr>
<tr><td><code id="prepper_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>prep</code> such as <code>verbose</code> or <code>retain</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prepper()</code> sets the underlying <code>prep()</code> argument <code>fresh</code> to <code>TRUE</code>.
</p>

<hr>
<h2 id='print.recipe'>Print a Recipe</h2><span id='topic+print.recipe'></span>

<h3>Description</h3>

<p>Print a Recipe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recipe'
print(x, form_width = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.recipe_+3A_x">x</code></td>
<td>
<p>A <code>recipe</code> object</p>
</td></tr>
<tr><td><code id="print.recipe_+3A_form_width">form_width</code></td>
<td>
<p>The number of characters used to print the variables or
terms in a formula</p>
</td></tr>
<tr><td><code id="print.recipe_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (not currently
used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original object (invisibly)
</p>

<hr>
<h2 id='rand_id'>Make a random identification field for steps</h2><span id='topic+rand_id'></span>

<h3>Description</h3>

<p>Make a random identification field for steps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_id(prefix = "step", len = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_id_+3A_prefix">prefix</code></td>
<td>
<p>A single character string</p>
</td></tr>
<tr><td><code id="rand_id_+3A_len">len</code></td>
<td>
<p>An integer for the number of random characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the prefix and random letters separated by
and underscore.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='recipe'>Create a recipe for preprocessing data</h2><span id='topic+recipe'></span><span id='topic+recipe.default'></span><span id='topic+recipe.formula'></span><span id='topic+recipe.data.frame'></span><span id='topic+recipe.matrix'></span>

<h3>Description</h3>

<p>A recipe is a description of the steps to be applied to a data set in
order to prepare it for data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recipe(x, ...)

## Default S3 method:
recipe(x, ...)

## S3 method for class 'data.frame'
recipe(x, formula = NULL, ..., vars = NULL, roles = NULL)

## S3 method for class 'formula'
recipe(formula, data, ...)

## S3 method for class 'matrix'
recipe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recipe_+3A_x">x</code>, <code id="recipe_+3A_data">data</code></td>
<td>
<p>A data frame or tibble of the <em>template</em> data set
(see below).</p>
</td></tr>
<tr><td><code id="recipe_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently
used).</p>
</td></tr>
<tr><td><code id="recipe_+3A_formula">formula</code></td>
<td>
<p>A model formula. No in-line functions should be used here
(e.g. <code>log(x)</code>, <code>x:y</code>, etc.) and minus signs are not allowed. These types of
transformations should be enacted using <code>step</code> functions in this package.
Dots are allowed as are simple multivariate outcome terms (i.e. no need for
<code>cbind</code>; see Examples). A model formula may not be the best choice for
high-dimensional data with many columns, because of problems with memory.</p>
</td></tr>
<tr><td><code id="recipe_+3A_vars">vars</code></td>
<td>
<p>A character string of column names corresponding to variables
that will be used in any context (see below)</p>
</td></tr>
<tr><td><code id="recipe_+3A_roles">roles</code></td>
<td>
<p>A character string (the same length of <code>vars</code>) that
describes a single role that the variable will take. This value could be
anything but common roles are <code>"outcome"</code>, <code>"predictor"</code>,
<code>"case_weight"</code>, or <code>"ID"</code></p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Defining recipes</h4>

<p>Variables in recipes can have any type of <em>role</em>, including outcome,
predictor, observation ID, case weights, stratification variables, etc.
</p>
<p><code>recipe</code> objects can be created in several ways. If an analysis only
contains outcomes and predictors, the simplest way to create one is to
use a formula (e.g.<code>y ~ x1 + x2</code>) that does not contain inline
functions such as <code>log(x3)</code> (see the first example below).
</p>
<p>Alternatively, a <code>recipe</code> object can be created by first specifying
which variables in a data set should be used and then sequentially
defining their roles (see the last example). This alternative is an
excellent choice when the number of variables is very high, as the
formula method is memory-inefficient with many variables.
</p>
<p>There are two different types of operations that can be sequentially
added to a recipe.
</p>

<ul>
<li> <p><strong>Steps</strong> can include operations like scaling a variable, creating
dummy variables or interactions, and so on. More computationally
complex actions such as dimension reduction or imputation can also be
specified.
</p>
</li>
<li> <p><strong>Checks</strong> are operations that conduct specific tests of the data.
When the test is satisfied, the data are returned without issue or
modification. Otherwise, an error is thrown.
</p>
</li></ul>

<p>If you have defined a recipe and want to see which steps are included,
use the <code><a href="#topic+tidy.recipe">tidy()</a></code> method on the recipe object.
</p>
<p>Note that the data passed to <code><a href="#topic+recipe">recipe()</a></code> need not be the
complete data that will be used to train the steps (by
<code><a href="#topic+prep">prep()</a></code>). The recipe only needs to know the names and types
of data that will be used. For large data sets, <code><a href="utils.html#topic+head">head()</a></code> could
be used to pass a smaller data set to save time and memory.
</p>



<h4>Using recipes</h4>

<p>Once a recipe is defined, it needs to be <em>estimated</em> before being
applied to data. Most recipe steps have specific quantities that must be
calculated or estimated. For example,
<code><a href="#topic+step_normalize">step_normalize()</a></code> needs to compute the training
sets mean for the selected columns, while
<code><a href="#topic+step_dummy">step_dummy()</a></code> needs to determine the factor levels of
selected columns in order to make the appropriate indicator columns.
</p>
<p>The two most common application of recipes are modeling and stand-alone
preprocessing. How the recipe is estimated depends on how it is being
used.
</p>


<h5>Modeling</h5>

<p>The best way to use use a recipe for modeling is via the <code>workflows</code>
package. This bundles a model and preprocessor (e.g.a recipe) together
and gives the user a fluent way to train the model/recipe and make
predictions.
</p>
<div class="sourceCode r"><pre>library(dplyr)
library(workflows)
library(recipes)
library(parsnip)

data(biomass, package = "modeldata")

# split data
biomass_tr &lt;- biomass %&gt;% filter(dataset == "Training")
biomass_te &lt;- biomass %&gt;% filter(dataset == "Testing")

# With only predictors and outcomes, use a formula:
rec &lt;- recipe(HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
              data = biomass_tr)

# Now add preprocessing steps to the recipe:
sp_signed &lt;- 
  rec %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_spatialsign(all_numeric_predictors())
sp_signed
</pre></div>
<div class="sourceCode"><pre>## 

## -- Recipe ------------------------------------------------------------

## 

## -- Inputs

## Number of variables by role

## outcome:   1
## predictor: 5

## 

## -- Operations

## * Centering and scaling for: all_numeric_predictors()

## * Spatial sign on: all_numeric_predictors()
</pre></div>
<p>We can create a <code>parsnip</code> model, and then build a workflow with the
model and recipe:
</p>
<div class="sourceCode r"><pre>linear_mod &lt;- linear_reg()

linear_sp_sign_wflow &lt;- 
  workflow() %&gt;% 
  add_model(linear_mod) %&gt;% 
  add_recipe(sp_signed)

linear_sp_sign_wflow
</pre></div>
<div class="sourceCode"><pre>## == Workflow ==========================================================
## Preprocessor: Recipe
## Model: linear_reg()
## 
## -- Preprocessor ------------------------------------------------------
## 2 Recipe Steps
## 
## * step_normalize()
## * step_spatialsign()
## 
## -- Model -------------------------------------------------------------
## Linear Regression Model Specification (regression)
## 
## Computational engine: lm
</pre></div>
<p>To estimate the preprocessing steps and then fit the linear model, a
single call to <code><a href="parsnip.html#topic+fit">fit()</a></code> is used:
</p>
<div class="sourceCode r"><pre>linear_sp_sign_fit &lt;- fit(linear_sp_sign_wflow, data = biomass_tr)
</pre></div>
<p>When predicting, there is no need to do anything other than call
<code><a href="parsnip.html#topic+predict.model_fit">predict()</a></code>. This preprocesses the new
data in the same manner as the training set, then gives the data to the
linear model prediction code:
</p>
<div class="sourceCode r"><pre>predict(linear_sp_sign_fit, new_data = head(biomass_te))
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 6 x 1
##   .pred
##   &lt;dbl&gt;
## 1  18.1
## 2  17.9
## 3  17.2
## 4  18.8
## 5  19.6
## 6  14.6
</pre></div>



<h5>Stand-alone use of recipes</h5>

<p>When using a recipe to generate data for a visualization or to
troubleshoot any problems with the recipe, there are functions that can
be used to estimate the recipe and apply it to new data manually.
</p>
<p>Once a recipe has been defined, the <code><a href="#topic+prep">prep()</a></code> function can be
used to estimate quantities required for the operations using a data set
(a.k.a. the training data). <code><a href="#topic+prep">prep()</a></code> returns a recipe.
</p>
<p>As an example of using PCA (perhaps to produce a plot):
</p>
<div class="sourceCode r"><pre># Define the recipe
pca_rec &lt;- 
  rec %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_pca(all_numeric_predictors())
</pre></div>
<p>Now to estimate the normalization statistics and the PCA loadings:
</p>
<div class="sourceCode r"><pre>pca_rec &lt;- prep(pca_rec, training = biomass_tr)
pca_rec
</pre></div>
<div class="sourceCode"><pre>## 

## -- Recipe ------------------------------------------------------------

## 

## -- Inputs

## Number of variables by role

## outcome:   1
## predictor: 5

## 

## -- Training information

## Training data contained 456 data points and no incomplete rows.

## 

## -- Operations

## * Centering and scaling for: carbon and hydrogen, ... | Trained

## * PCA extraction with: carbon, hydrogen, oxygen, ... | Trained
</pre></div>
<p>Note that the estimated recipe shows the actual column names captured by
the selectors.
</p>
<p>You can <code><a href="#topic+tidy.recipe">tidy.recipe()</a></code> a recipe, either when it is
prepped or unprepped, to learn more about its components.
</p>
<div class="sourceCode r"><pre>tidy(pca_rec)
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 2 x 6
##   number operation type      trained skip  id             
##    &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;lgl&gt;   &lt;lgl&gt; &lt;chr&gt;          
## 1      1 step      normalize TRUE    FALSE normalize_AeYA4
## 2      2 step      pca       TRUE    FALSE pca_Zn1yz
</pre></div>
<p>You can also <code><a href="#topic+tidy.recipe">tidy()</a></code> recipe <em>steps</em> with a <code>number</code>
or <code>id</code> argument.
</p>
<p>To apply the prepped recipe to a data set, the <code><a href="#topic+bake">bake()</a></code>
function is used in the same manner that
<code><a href="parsnip.html#topic+predict.model_fit">predict()</a></code> would be for models. This
applies the estimated steps to any data set.
</p>
<div class="sourceCode r"><pre>bake(pca_rec, head(biomass_te))
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 6 x 6
##     HHV    PC1    PC2     PC3     PC4     PC5
##   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1  18.3 0.730  -0.412 -0.495   0.333   0.253 
## 2  17.6 0.617   1.41   0.118  -0.466   0.815 
## 3  17.2 0.761   1.10  -0.0550 -0.397   0.747 
## 4  18.9 0.0400  0.950  0.158   0.405  -0.143 
## 5  20.5 0.792  -0.732  0.204   0.465  -0.148 
## 6  18.5 0.433  -0.127 -0.354  -0.0168 -0.0888
</pre></div>
<p>In general, the workflow interface to recipes is recommended for most
applications.
</p>




<h3>Value</h3>

<p>An object of class <code>recipe</code> with sub-objects:
</p>
<table>
<tr><td><code>var_info</code></td>
<td>
<p>A tibble containing information about the original data
set columns</p>
</td></tr>
<tr><td><code>term_info</code></td>
<td>
<p>A tibble that contains the current set of terms in the
data set. This initially defaults to the same data contained in
<code>var_info</code>.</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>A list of <code>step</code>  or <code>check</code> objects that define the sequence of
preprocessing operations that will be applied to data. The default value is
<code>NULL</code></p>
</td></tr>
<tr><td><code>template</code></td>
<td>
<p>A tibble of the data. This is initialized to be the same
as the data given in the <code>data</code> argument but can be different after
the recipe is trained.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# formula example with single outcome:
data(biomass, package = "modeldata")

# split data
biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

# With only predictors and outcomes, use a formula
rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

# Now add preprocessing steps to the recipe
sp_signed &lt;- rec %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_spatialsign(all_numeric_predictors())
sp_signed

# ---------------------------------------------------------------------------
# formula multivariate example:
# no need for `cbind(carbon, hydrogen)` for left-hand side

multi_y &lt;- recipe(carbon + hydrogen ~ oxygen + nitrogen + sulfur,
  data = biomass_tr
)
multi_y &lt;- multi_y %&gt;%
  step_center(all_numeric_predictors()) %&gt;%
  step_scale(all_numeric_predictors())

# ---------------------------------------------------------------------------
# example using `update_role` instead of formula:
# best choice for high-dimensional data

rec &lt;- recipe(biomass_tr) %&gt;%
  update_role(carbon, hydrogen, oxygen, nitrogen, sulfur,
    new_role = "predictor"
  ) %&gt;%
  update_role(HHV, new_role = "outcome") %&gt;%
  update_role(sample, new_role = "id variable") %&gt;%
  update_role(dataset, new_role = "splitting indicator")
rec

</code></pre>

<hr>
<h2 id='recipes_eval_select'>Evaluate a selection with tidyselect semantics specific to recipes</h2><span id='topic+recipes_eval_select'></span>

<h3>Description</h3>

<p><code>recipes_eval_select()</code> is a recipes specific variant of
<code><a href="tidyselect.html#topic+eval_select">tidyselect::eval_select()</a></code> enhanced with the ability to recognize recipes
selectors, such as <code><a href="#topic+all_numeric_predictors">all_numeric_predictors()</a></code>. See <a href="#topic+selections">selections</a>
for more information about the unique recipes selectors.
</p>
<p>This is a developer tool that is only useful for creating new recipes steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recipes_eval_select(
  quos,
  data,
  info,
  ...,
  allow_rename = FALSE,
  check_case_weights = TRUE,
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recipes_eval_select_+3A_quos">quos</code></td>
<td>
<p>A list of quosures describing the selection. This is generally
the <code>...</code> argument of your step function, captured with <code><a href="rlang.html#topic+enquo">rlang::enquos()</a></code>
and stored in the step object as the <code>terms</code> element.</p>
</td></tr>
<tr><td><code id="recipes_eval_select_+3A_data">data</code></td>
<td>
<p>A data frame to use as the context to evaluate the selection in.
This is generally the <code>training</code> data passed to the <code><a href="#topic+prep">prep()</a></code> method
of your step.</p>
</td></tr>
<tr><td><code id="recipes_eval_select_+3A_info">info</code></td>
<td>
<p>A data frame of term information describing each column's type
and role for use with the recipes selectors. This is generally the <code>info</code>
data passed to the <code><a href="#topic+prep">prep()</a></code> method of your step.</p>
</td></tr>
<tr><td><code id="recipes_eval_select_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="recipes_eval_select_+3A_allow_rename">allow_rename</code></td>
<td>
<p>Should the renaming syntax <code>c(foo = bar)</code> be allowed?
This is rarely required, and is currently only used by <code><a href="#topic+step_select">step_select()</a></code>.
It is unlikely that your step will need renaming capabilities.</p>
</td></tr>
<tr><td><code id="recipes_eval_select_+3A_check_case_weights">check_case_weights</code></td>
<td>
<p>Should selecting case weights throw an error?
Defaults to <code>TRUE</code>. This is rarely changed and only needed in <code><a href="#topic+juice">juice()</a></code>,
<code><a href="#topic+bake.recipe">bake.recipe()</a></code>, <code><a href="#topic+update_role">update_role()</a></code>, and <code><a href="#topic+add_role">add_role()</a></code>.</p>
</td></tr>
<tr><td><code id="recipes_eval_select_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running function, e.g.
<code>caller_env()</code>. The function will be mentioned in error messages as the
source of the error. See the call argument of <code><a href="rlang.html#topic+abort">rlang::abort()</a></code> for more
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector containing the evaluated selection. The names are
always the same as the values, except when <code>allow_rename = TRUE</code>, in which
case the names reflect the new names chosen by the user.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(rlang)
data(scat, package = "modeldata")

rec &lt;- recipe(Species ~ ., data = scat)

info &lt;- summary(rec)
info

quos &lt;- quos(all_numeric_predictors(), where(is.factor))

recipes_eval_select(quos, scat, info)

</code></pre>

<hr>
<h2 id='recipes_extension_check'>Checks that steps have all S3 methods</h2><span id='topic+recipes_extension_check'></span>

<h3>Description</h3>

<p>This is a developer tool intended to help making sure all methods for each
step have been created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recipes_extension_check(
  pkg,
  exclude_steps = character(),
  exclude_methods = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recipes_extension_check_+3A_pkg">pkg</code></td>
<td>
<p>Character, name of package containing steps to check</p>
</td></tr>
<tr><td><code id="recipes_extension_check_+3A_exclude_steps">exclude_steps</code></td>
<td>
<p>Character, name of steps to exclude. This is mostly
used to remove false positives.</p>
</td></tr>
<tr><td><code id="recipes_extension_check_+3A_exclude_methods">exclude_methods</code></td>
<td>
<p>Character, which methods to exclude testing for. Can
take the values &quot;prep&quot;, &quot;bake&quot;, &quot;print&quot;, &quot;tidy&quot;, and &quot;required_pkgs&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended that the following test in placed in packages that add
recipes steps to help keep everything up to date.
</p>
<div class="sourceCode r"><pre>test_that("recipes_extension_check", {
  expect_snapshot(
    recipes::recipes_extension_check(
      pkg = "pkgname"
    )
  )
})
</pre></div>


<h3>Value</h3>

<p>cli output
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recipes_extension_check(
  pkg = "recipes"
)

recipes_extension_check(
  pkg = "recipes",
  exclude_steps = "step_testthat_helper",
  exclude_methods = c("required_pkgs")
)
</code></pre>

<hr>
<h2 id='recipes_pkg_check'>Update packages</h2><span id='topic+recipes_pkg_check'></span>

<h3>Description</h3>

<p>This will check to see if all required packages are installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recipes_pkg_check(pkg = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recipes_pkg_check_+3A_pkg">pkg</code></td>
<td>
<p>A character string for the package being checked</p>
</td></tr>
<tr><td><code id="recipes_pkg_check_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to <code><a href="utils.html#topic+install.packages">utils::install.packages()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned but a message is printed to the
console about which packages (if any) should be installed along
with code to do so.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
recipes_pkg_check("recipes")

## End(Not run)
</code></pre>

<hr>
<h2 id='recipes_remove_cols'>Removes columns if options apply</h2><span id='topic+recipes_remove_cols'></span>

<h3>Description</h3>

<p>This helper function removes columns based on character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recipes_remove_cols(new_data, object, col_names = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recipes_remove_cols_+3A_new_data">new_data</code></td>
<td>
<p>A tibble.</p>
</td></tr>
<tr><td><code id="recipes_remove_cols_+3A_object">object</code></td>
<td>
<p>A step object.</p>
</td></tr>
<tr><td><code id="recipes_remove_cols_+3A_col_names">col_names</code></td>
<td>
<p>A character vector, denoting columns to remove. Will
overwrite <code>object$removals</code> if set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>new_data</code> with column names removed if specified by <code>col_names</code> or
<code>object$removals</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+required_pkgs'></span><span id='topic+tunable'></span><span id='topic+tune_args'></span><span id='topic+extract_parameter_set_dials'></span><span id='topic+extract_parameter_dials'></span><span id='topic+importance_weights'></span><span id='topic+frequency_weights'></span><span id='topic++25+3E+25'></span><span id='topic+update'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+required_pkgs">required_pkgs</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code>, <code><a href="generics.html#topic+tunable">tunable</a></code>, <code><a href="generics.html#topic+tune_args">tune_args</a></code></p>
</dd>
<dt>hardhat</dt><dd><p><code><a href="hardhat.html#topic+hardhat-extract">extract_parameter_dials</a></code>, <code><a href="hardhat.html#topic+hardhat-extract">extract_parameter_set_dials</a></code>, <code><a href="hardhat.html#topic+frequency_weights">frequency_weights</a></code>, <code><a href="hardhat.html#topic+importance_weights">importance_weights</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>stats</dt><dd><p><code><a href="stats.html#topic+update">update</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove_original_cols'>Removes original columns if options apply</h2><span id='topic+remove_original_cols'></span>

<h3>Description</h3>

<p>This helper function should be used whenever the argument
<code>keep_original_cols</code> is used in a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_original_cols(new_data, object, col_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_original_cols_+3A_new_data">new_data</code></td>
<td>
<p>A tibble.</p>
</td></tr>
<tr><td><code id="remove_original_cols_+3A_object">object</code></td>
<td>
<p>A step object.</p>
</td></tr>
<tr><td><code id="remove_original_cols_+3A_col_names">col_names</code></td>
<td>
<p>A character vector, denoting columns to remove.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new_data with <code>col_names</code> removed if
<code>get_keep_original_cols(object) == TRUE</code> or <code>object$preserve == TRUE</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='required_pkgs.step_classdist_shrunken'>S3 methods for tracking which additional packages are needed for steps.</h2><span id='topic+required_pkgs.step_classdist_shrunken'></span><span id='topic+required_pkgs.step_depth'></span><span id='topic+required_pkgs.step_ica'></span><span id='topic+required_pkgs.step_isomap'></span><span id='topic+required_pkgs.step_kpca'></span><span id='topic+required_pkgs.step_kpca_poly'></span><span id='topic+required_pkgs.step_kpca_rbf'></span><span id='topic+required_pkgs.step_nnmf'></span><span id='topic+required_pkgs.step_nnmf_sparse'></span><span id='topic+required_pkgs.step_pls'></span><span id='topic+required_pkgs.step_poly_bernstein'></span><span id='topic+required_pkgs.recipe'></span><span id='topic+required_pkgs.step'></span><span id='topic+required_pkgs.check'></span><span id='topic+required_pkgs.step_spline_b'></span><span id='topic+required_pkgs.step_spline_convex'></span><span id='topic+required_pkgs.step_spline_monotone'></span><span id='topic+required_pkgs.step_spline_natural'></span><span id='topic+required_pkgs.step_spline_nonnegative'></span><span id='topic+required_pkgs.step_window'></span>

<h3>Description</h3>

<p>S3 methods for tracking which additional packages are needed for steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step_classdist_shrunken'
required_pkgs(x, ...)

## S3 method for class 'step_depth'
required_pkgs(x, ...)

## S3 method for class 'step_ica'
required_pkgs(x, ...)

## S3 method for class 'step_isomap'
required_pkgs(x, ...)

## S3 method for class 'step_kpca'
required_pkgs(x, ...)

## S3 method for class 'step_kpca_poly'
required_pkgs(x, ...)

## S3 method for class 'step_kpca_rbf'
required_pkgs(x, ...)

## S3 method for class 'step_nnmf'
required_pkgs(x, ...)

## S3 method for class 'step_nnmf_sparse'
required_pkgs(x, ...)

## S3 method for class 'step_pls'
required_pkgs(x, ...)

## S3 method for class 'step_poly_bernstein'
required_pkgs(x, ...)

## S3 method for class 'recipe'
required_pkgs(x, infra = TRUE, ...)

## S3 method for class 'step'
required_pkgs(x, ...)

## S3 method for class 'check'
required_pkgs(x, ...)

## S3 method for class 'step_spline_b'
required_pkgs(x, ...)

## S3 method for class 'step_spline_convex'
required_pkgs(x, ...)

## S3 method for class 'step_spline_monotone'
required_pkgs(x, ...)

## S3 method for class 'step_spline_natural'
required_pkgs(x, ...)

## S3 method for class 'step_spline_nonnegative'
required_pkgs(x, ...)

## S3 method for class 'step_window'
required_pkgs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="required_pkgs.step_classdist_shrunken_+3A_x">x</code></td>
<td>
<p>A recipe or recipe step</p>
</td></tr>
<tr><td><code id="required_pkgs.step_classdist_shrunken_+3A_infra">infra</code></td>
<td>
<p>Should recipes itself be included in the result?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='roles'>Manually alter roles</h2><span id='topic+roles'></span><span id='topic+add_role'></span><span id='topic+update_role'></span><span id='topic+remove_role'></span>

<h3>Description</h3>

<p><code>update_role()</code> alters an existing role in the recipe or assigns an initial
role to variables that do not yet have a declared role.
</p>
<p><code>add_role()</code> adds an <em>additional</em> role to variables that already have a role
in the recipe. It does not overwrite old roles, as a single variable can have
multiple roles.
</p>
<p><code>remove_role()</code> eliminates a single existing role in the recipe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_role(recipe, ..., new_role = "predictor", new_type = NULL)

update_role(recipe, ..., new_role = "predictor", old_role = NULL)

remove_role(recipe, ..., old_role)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roles_+3A_recipe">recipe</code></td>
<td>
<p>An existing <code><a href="#topic+recipe">recipe()</a></code>.</p>
</td></tr>
<tr><td><code id="roles_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which variables are being
assigned a role. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="roles_+3A_new_role">new_role</code></td>
<td>
<p>A character string for a single role.</p>
</td></tr>
<tr><td><code id="roles_+3A_new_type">new_type</code></td>
<td>
<p>A character string for specific type that the variable should
be identified as. If left as <code>NULL</code>, the type is automatically identified
as the <em>first</em> type you see for that variable in <code>summary(recipe)</code>.</p>
</td></tr>
<tr><td><code id="roles_+3A_old_role">old_role</code></td>
<td>
<p>A character string for the specific role to update for the
variables selected by <code>...</code>. <code>update_role()</code> accepts a <code>NULL</code> as long as
the variables have only a single role.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>update_role()</code>, <code>add_role()</code> and <code>remove_role()</code> will be applied on a recipe
before any of the steps or checks, regardless of where they are located in
position. This means that roles can only be changed with these three
functions for columns that are already present in the original data supplied
to <code>recipe()</code>. See the <code>role</code> argument in some step functions to update
roles for columns created by steps.
</p>
<p>Variables can have any arbitrary role (see the examples) but there are two
special standard roles, <code>"predictor"</code> and <code>"outcome"</code>. These two roles are
typically required when fitting a model.
</p>
<p><code>update_role()</code> should be used when a variable doesn't currently have a role
in the recipe, or to replace an <code>old_role</code> with a <code>new_role</code>. <code>add_role()</code>
only adds additional roles to variables that already have roles and will
throw an error when the current role is missing (i.e. <code>NA</code>).
</p>
<p>When using <code>add_role()</code>, if a variable is selected that already has the
<code>new_role</code>, a warning is emitted and that variable is skipped so no duplicate
roles are added.
</p>
<p>Adding or updating roles is a useful way to group certain variables that
don't fall in the standard <code>"predictor"</code> bucket. You can perform a step on
all of the variables that have a custom role with the selector <code><a href="#topic+has_role">has_role()</a></code>.
</p>


<h4>Effects of non-standard roles</h4>

<p>Recipes can label and retain column(s) of your data set that should not be treated as outcomes or predictors. A unique identifier column or some other ancillary data could be used to troubleshoot issues during model development but may not be either an outcome or predictor.
</p>
<p>For example, the <code>modeldata::biomass</code> dataset has a column named <code>sample</code> with information about the specific sample type. We can change that role:
</p>
<div class="sourceCode r"><pre>library(recipes)

data(biomass, package = "modeldata")
biomass_train &lt;- biomass[1:100,]
biomass_test &lt;- biomass[101:200,]

rec &lt;- recipe(HHV ~ ., data = biomass_train) %&gt;%
  update_role(sample, new_role = "id variable") %&gt;%
  step_center(carbon)

rec &lt;- prep(rec, biomass_train)
</pre></div>
<p>This means that <code>sample</code> is no longer treated as a <code>"predictor"</code> (the default role for columns on the right-hand side of the formula supplied to <code>recipe()</code>) and won't be used in model fitting or analysis, but will still be retained in the data set.
</p>
<p>If you really aren't using <code>sample</code> in your recipe, we recommend that you instead remove <code>sample</code> from your dataset before passing it to <code>recipe()</code>. The reason for this is because recipes assumes that all non-standard roles are required at <code>bake()</code> time (or <code>predict()</code> time, if you are using a workflow). Since you didn't use <code>sample</code> in any steps of the recipe, you might think that you don't need to pass it to <code>bake()</code>, but this isn't true because recipes doesn't know that you didn't use it:
</p>
<div class="sourceCode r"><pre>biomass_test$sample &lt;- NULL

bake(rec, biomass_test)
#&gt; Error in `bake()`:
#&gt; x The following required columns are missing from `new_data`: `sample`.
#&gt; i These columns have one of the following roles, which are required at `bake()`
#&gt;   time: `id variable`.
#&gt; i If these roles are not required at `bake()` time, use
#&gt;   `update_role_requirements(role = "your_role", bake = FALSE)`.
</pre></div>
<p>As we mentioned before, the best way to avoid this issue is to not even use a role, just remove the <code>sample</code> column from <code>biomass</code> before calling <code>recipe()</code>. In general, predictors and non-standard roles that are supplied to <code>recipe()</code> should be present at both <code>prep()</code> and <code>bake()</code> time.
</p>
<p>If you can't remove <code>sample</code> for some reason, then the second best way to get around this issue is to tell recipes that the <code>"id variable"</code> role isn't required at <code>bake()</code> time. You can do that by using <code>update_role_requirements()</code>:
</p>
<div class="sourceCode r"><pre>rec &lt;- recipe(HHV ~ ., data = biomass_train) %&gt;%
  update_role(sample, new_role = "id variable") %&gt;%
  update_role_requirements("id variable", bake = FALSE) %&gt;%
  step_center(carbon)

rec &lt;- prep(rec, biomass_train)

# No errors!
biomass_test_baked &lt;- bake(rec, biomass_test)
</pre></div>
<p>It should be very rare that you need this feature.
</p>



<h3>Value</h3>

<p>An updated recipe object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
data(biomass, package = "modeldata")

# Using the formula method, roles are created for any outcomes and predictors:
recipe(HHV ~ ., data = biomass) %&gt;%
  summary()

# However `sample` and `dataset` aren't predictors. Since they already have
# roles, `update_role()` can be used to make changes, to any arbitrary role:
recipe(HHV ~ ., data = biomass) %&gt;%
  update_role(sample, new_role = "id variable") %&gt;%
  update_role(dataset, new_role = "splitting variable") %&gt;%
  summary()

# `update_role()` cannot set a role to NA, use `remove_role()` for that
## Not run: 
recipe(HHV ~ ., data = biomass) %&gt;%
  update_role(sample, new_role = NA_character_)

## End(Not run)

# ------------------------------------------------------------------------------

# Variables can have more than one role. `add_role()` can be used
# if the column already has at least one role:
recipe(HHV ~ ., data = biomass) %&gt;%
  add_role(carbon, sulfur, new_role = "something") %&gt;%
  summary()

# `update_role()` has an argument called `old_role` that is required to
# unambiguously update a role when the column currently has multiple roles.
recipe(HHV ~ ., data = biomass) %&gt;%
  add_role(carbon, new_role = "something") %&gt;%
  update_role(carbon, new_role = "something else", old_role = "something") %&gt;%
  summary()

# `carbon` has two roles at the end, so the last `update_roles()` fails since
# `old_role` was not given.
## Not run: 
recipe(HHV ~ ., data = biomass) %&gt;%
  add_role(carbon, sulfur, new_role = "something") %&gt;%
  update_role(carbon, new_role = "something else")

## End(Not run)

# ------------------------------------------------------------------------------

# To remove a role, `remove_role()` can be used to remove a single role.
recipe(HHV ~ ., data = biomass) %&gt;%
  add_role(carbon, new_role = "something") %&gt;%
  remove_role(carbon, old_role = "something") %&gt;%
  summary()

# To remove all roles, call `remove_role()` multiple times to reset to `NA`
recipe(HHV ~ ., data = biomass) %&gt;%
  add_role(carbon, new_role = "something") %&gt;%
  remove_role(carbon, old_role = "something") %&gt;%
  remove_role(carbon, old_role = "predictor") %&gt;%
  summary()

# ------------------------------------------------------------------------------

# If the formula method is not used, all columns have a missing role:
recipe(biomass) %&gt;%
  summary()

</code></pre>

<hr>
<h2 id='selections'>Methods for selecting variables in step functions</h2><span id='topic+selections'></span><span id='topic+selection'></span>

<h3>Description</h3>

<p>Tips for selecting columns in step functions.
</p>


<h3>Details</h3>

<p>When selecting variables or model terms in <code>step</code>
functions, <code>dplyr</code>-like tools are used. The <em>selector</em> functions
can choose variables based on their name, current role, data
type, or any combination of these. The selectors are passed as
any other argument to the step. If the variables are explicitly
named in the step function, this might look like:
</p>
<pre>
  recipe( ~ ., data = USArrests) %&gt;%
    step_pca(Murder, Assault, UrbanPop, Rape, num_comp = 3)
</pre>
<p>The first four arguments indicate which variables should be
used in the PCA while the last argument is a specific argument
to <code><a href="#topic+step_pca">step_pca()</a></code> about the number of components.
</p>
<p>Note that:
</p>

<ol>
<li><p> These arguments are not evaluated until the <code>prep</code>
function for the step is executed.
</p>
</li>
<li><p> The <code>dplyr</code>-like syntax allows for negative signs to
exclude variables (e.g. <code>-Murder</code>) and the set of selectors will
processed in order.
</p>
</li>
<li><p> A leading exclusion in these arguments (e.g. <code>-Murder</code>)
has the effect of adding <em>all</em> variables to the list except the
excluded variable(s), ignoring role information.
</p>
</li></ol>

<p>Select helpers from the <code>tidyselect</code> package can also be used:
<code><a href="tidyselect.html#topic+starts_with">tidyselect::starts_with()</a></code>, <code><a href="tidyselect.html#topic+starts_with">tidyselect::ends_with()</a></code>,
<code><a href="tidyselect.html#topic+starts_with">tidyselect::contains()</a></code>, <code><a href="tidyselect.html#topic+starts_with">tidyselect::matches()</a></code>,
<code><a href="tidyselect.html#topic+starts_with">tidyselect::num_range()</a></code>, <code><a href="tidyselect.html#topic+everything">tidyselect::everything()</a></code>,
<code><a href="tidyselect.html#topic+one_of">tidyselect::one_of()</a></code>, <code><a href="tidyselect.html#topic+all_of">tidyselect::all_of()</a></code>, and
<code><a href="tidyselect.html#topic+all_of">tidyselect::any_of()</a></code>
</p>
<p>For example:
</p>
<pre>
  recipe(Species ~ ., data = iris) %&gt;%
    step_center(starts_with("Sepal"), -contains("Width"))
</pre>
<p>would only select <code>Sepal.Length</code>
</p>
<p>Columns of the design matrix that may not exist when the step
is coded can also be selected. For example, when using
<code>step_pca()</code>, the number of columns created by feature extraction
may not be known when subsequent steps are defined. In this
case, using <code>matches("^PC")</code> will select all of the columns
whose names start with &quot;PC&quot; <em>once those columns are created</em>.
</p>
<p>There are sets of recipes-specific functions that can be used to select
variables based on their role or type: <code><a href="#topic+has_role">has_role()</a></code> and
<code><a href="#topic+has_type">has_type()</a></code>. For convenience, there are also functions that are
more specific. The functions <code><a href="#topic+all_numeric">all_numeric()</a></code> and <code><a href="#topic+all_nominal">all_nominal()</a></code> select
based on type, with nominal variables including both character and factor;
the functions <code><a href="#topic+all_predictors">all_predictors()</a></code> and <code><a href="#topic+all_outcomes">all_outcomes()</a></code> select based on role.
The functions <code><a href="#topic+all_numeric_predictors">all_numeric_predictors()</a></code> and <code><a href="#topic+all_nominal_predictors">all_nominal_predictors()</a></code>
select intersections of role and type. Any can be used in conjunction with
the previous functions described for selecting variables using their names.
</p>
<p>A selection like this:
</p>
<pre>
  data(biomass)
  recipe(HHV ~ ., data = biomass) %&gt;%
    step_center(all_numeric(), -all_outcomes())
</pre>
<p>is equivalent to:
</p>
<pre>
  data(biomass)
  recipe(HHV ~ ., data = biomass) %&gt;%
    step_center(all_numeric_predictors())
</pre>
<p>Both result in all the numeric predictors: carbon, hydrogen,
oxygen, nitrogen, and sulfur.
</p>
<p>If a role for a variable has not been defined, it will never be
selected using role-specific selectors.
</p>


<h4>Interactions</h4>

<p>Selectors can be used in <code><a href="#topic+step_interact">step_interact()</a></code> in similar ways but
must be embedded in a model formula (as opposed to a sequence
of selectors). For example, the interaction specification
could be <code>~ starts_with("Species"):Sepal.Width</code>. This can be
useful if <code>Species</code> was converted to dummy variables
previously using <code><a href="#topic+step_dummy">step_dummy()</a></code>. The implementation of
<code>step_interact()</code> is special, and is more restricted than
the other step functions. Only the selector functions from
recipes and tidyselect are allowed. User defined selector functions
will not be recognized. Additionally, the tidyselect domain specific
language is not recognized here, meaning that <code>&amp;</code>, <code>|</code>, <code>!</code>, and <code>-</code>
will not work.
</p>



<h4>Tips for saving recipes and filtering columns</h4>

<p>When creating variable selections:
</p>

<ul>
<li><p> If you are using column filtering steps, such as <code>step_corr()</code>, try to
avoid hardcoding specific variable names in downstream steps in case
those columns are removed by the filter. Instead, use
<code><a href="dplyr.html#topic+reexports">dplyr::any_of()</a></code> and
<code><a href="dplyr.html#topic+reexports">dplyr::all_of()</a></code>.
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+reexports">dplyr::any_of()</a></code> will be tolerant if a column
has been removed.
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+reexports">dplyr::all_of()</a></code> will fail unless all of the
columns are present in the data.
</p>
</li></ul>

</li>
<li><p> For both of these functions, if you are going to save the recipe as a
binary object to use in another R session, try to avoid referring to a
vector in your workspace.
</p>

<ul>
<li><p> Preferred: <code>any_of(!!var_names)</code>
</p>
</li>
<li><p> Avoid: <code>any_of(var_names)</code>
</p>
</li></ul>

</li></ul>

<p>Some examples:
</p>
<div class="sourceCode r"><pre>some_vars &lt;- names(mtcars)[4:6]

# No filter steps, OK for not saving the recipe
rec_1 &lt;-
  recipe(mpg ~ ., data = mtcars) %&gt;% 
  step_log(all_of(some_vars)) %&gt;% 
  prep()

# No filter steps, saving the recipe
rec_2 &lt;-
  recipe(mpg ~ ., data = mtcars) %&gt;% 
  step_log(!!!some_vars) %&gt;% 
  prep()

# This fails since `wt` is not in the data
recipe(mpg ~ ., data = mtcars)  %&gt;% 
  step_rm(wt) %&gt;% 
  step_log(!!!some_vars) %&gt;% 
  prep()
</pre></div>
<div class="sourceCode"><pre>## Error in `step_log()`:
## Caused by error in `prep()` at recipes/R/recipe.R:473:8:
## ! Can't subset columns that don't exist.
## x Column `wt` doesn't exist.
</pre></div>
<div class="sourceCode r"><pre># Best for filters (using any_of()) and when
# saving the recipe
rec_4 &lt;- 
  recipe(mpg ~ ., data = mtcars) %&gt;% 
  step_rm(wt) %&gt;% 
  step_log(any_of(!!some_vars)) %&gt;% 
  # equal to step_log(any_of(c("hp", "drat", "wt")))
  prep()
</pre></div>


<hr>
<h2 id='step'><code>step</code> sets the class of the <code>step</code> and <code>check</code> is for checks.</h2><span id='topic+step'></span><span id='topic+check'></span>

<h3>Description</h3>

<p><code>step</code> sets the class of the <code>step</code> and <code>check</code> is for checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step(subclass, ..., .prefix = "step_")

check(subclass, ..., .prefix = "check_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_+3A_subclass">subclass</code></td>
<td>
<p>A character string for the resulting class. For example,
if <code>subclass = "blah"</code> the step object that is returned has class
<code>step_blah</code> or <code>check_blah</code> depending on the context.</p>
</td></tr>
<tr><td><code id="step_+3A_...">...</code></td>
<td>
<p>All arguments to the operator that should be returned.</p>
</td></tr>
<tr><td><code id="step_+3A_.prefix">.prefix</code></td>
<td>
<p>Prefix to the subclass created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated step or check with the new class.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>

<hr>
<h2 id='step_arrange'>Sort rows using dplyr</h2><span id='topic+step_arrange'></span>

<h3>Description</h3>

<p><code>step_arrange()</code> creates a <em>specification</em> of a recipe step that will sort
rows using <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_arrange(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  inputs = NULL,
  skip = FALSE,
  id = rand_id("arrange")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_arrange_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_arrange_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted variable names.
Use 'desc()&ldquo; to sort a variable in descending order. See
<code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_arrange_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_arrange_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_arrange_+3A_inputs">inputs</code></td>
<td>
<p>Quosure of values given by <code>...</code>.</p>
</td></tr>
<tr><td><code id="step_arrange_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_arrange_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an object in the user's global environment is
referenced in the expression defining the new variable(s),
it is a good idea to use quasiquotation (e.g. <code style="white-space: pre;">&#8288;!!!&#8288;</code>)
to embed the value of the object in the expression (to
be portable between sessions). See the examples.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other row operation steps: 
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>,
<code><a href="#topic+step_lag">step_lag</a>()</code>,
<code><a href="#topic+step_naomit">step_naomit</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_shuffle">step_shuffle</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>
<p>Other dplyr steps: 
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_rename_at">step_rename_at</a>()</code>,
<code><a href="#topic+step_rename">step_rename</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rec &lt;- recipe(~., data = iris) %&gt;%
  step_arrange(desc(Sepal.Length), 1 / Petal.Length)

prepped &lt;- prep(rec, training = iris %&gt;% slice(1:75))
tidy(prepped, number = 1)

library(dplyr)

dplyr_train &lt;-
  iris %&gt;%
  as_tibble() %&gt;%
  slice(1:75) %&gt;%
  dplyr::arrange(desc(Sepal.Length), 1 / Petal.Length)

rec_train &lt;- bake(prepped, new_data = NULL)
all.equal(dplyr_train, rec_train)

dplyr_test &lt;-
  iris %&gt;%
  as_tibble() %&gt;%
  slice(76:150) %&gt;%
  dplyr::arrange(desc(Sepal.Length), 1 / Petal.Length)
rec_test &lt;- bake(prepped, iris %&gt;% slice(76:150))
all.equal(dplyr_test, rec_test)

# When you have variables/expressions, you can create a
# list of symbols with `rlang::syms()`` and splice them in
# the call with `!!!`. See https://tidyeval.tidyverse.org

sort_vars &lt;- c("Sepal.Length", "Petal.Length")

qq_rec &lt;-
  recipe(~., data = iris) %&gt;%
  # Embed the `values` object in the call using !!!
  step_arrange(!!!syms(sort_vars)) %&gt;%
  prep(training = iris)

tidy(qq_rec, number = 1)
</code></pre>

<hr>
<h2 id='step_bin2factor'>Create a factors from A dummy variable</h2><span id='topic+step_bin2factor'></span>

<h3>Description</h3>

<p><code>step_bin2factor()</code> creates a <em>specification</em> of a recipe step that will
create a two-level factor from a single dummy variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_bin2factor(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  levels = c("yes", "no"),
  ref_first = TRUE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("bin2factor")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_bin2factor_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_bin2factor_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_bin2factor_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_bin2factor_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_bin2factor_+3A_levels">levels</code></td>
<td>
<p>A length 2 character string that indicates the
factor levels for the 1's (in the first position) and the zeros
(second)</p>
</td></tr>
<tr><td><code id="step_bin2factor_+3A_ref_first">ref_first</code></td>
<td>
<p>Logical. Should the first level, which replaces
1's, be the factor reference level?</p>
</td></tr>
<tr><td><code id="step_bin2factor_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_bin2factor_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_bin2factor_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operation may be useful for situations where a
binary piece of information may need to be represented as
categorical instead of numeric. For example, naive Bayes models
would do better to have factor predictors so that the binomial
distribution is modeled instead of a Gaussian probability
density of numeric binary data. Note that the numeric data is
only verified to be numeric (and does not count levels).
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(covers, package = "modeldata")

rec &lt;- recipe(~description, covers) %&gt;%
  step_regex(description, pattern = "(rock|stony)", result = "rocks") %&gt;%
  step_regex(description, pattern = "(rock|stony)", result = "more_rocks") %&gt;%
  step_bin2factor(rocks)

tidy(rec, number = 3)

rec &lt;- prep(rec, training = covers)
results &lt;- bake(rec, new_data = covers)

table(results$rocks, results$more_rocks)

tidy(rec, number = 3)

</code></pre>

<hr>
<h2 id='step_BoxCox'>Box-Cox transformation for non-negative data</h2><span id='topic+step_BoxCox'></span>

<h3>Description</h3>

<p><code>step_BoxCox()</code> creates a <em>specification</em> of a recipe step that will transform
data using a Box-Cox transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_BoxCox(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  lambdas = NULL,
  limits = c(-5, 5),
  num_unique = 5,
  skip = FALSE,
  id = rand_id("BoxCox")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_BoxCox_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_BoxCox_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_BoxCox_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_BoxCox_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_BoxCox_+3A_lambdas">lambdas</code></td>
<td>
<p>A numeric vector of transformation values. This
is <code>NULL</code> until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_BoxCox_+3A_limits">limits</code></td>
<td>
<p>A length 2 numeric vector defining the range to
compute the transformation parameter lambda.</p>
</td></tr>
<tr><td><code id="step_BoxCox_+3A_num_unique">num_unique</code></td>
<td>
<p>An integer to specify minimum required unique
values to evaluate for a transformation.</p>
</td></tr>
<tr><td><code id="step_BoxCox_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_BoxCox_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Box-Cox transformation, which requires a strictly
positive variable, can be used to rescale a variable to be more
similar to a normal distribution. In this package, the partial
log-likelihood function is directly optimized within a
reasonable set of transformation values (which can be changed by
the user).
</p>
<p>This transformation is typically done on the outcome variable
using the residuals for a statistical model (such as ordinary
least squares). Here, a simple null model (intercept only) is
used to apply the transformation to the <em>predictor</em>
variables individually. This can have the effect of making the
variable distributions more symmetric.
</p>
<p>If the transformation parameters are estimated to be very
closed to the bounds, or if the optimization fails, a value of
<code>NA</code> is used and no transformation is applied.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the lambda estimate</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Sakia, R. M. (1992). The Box-Cox transformation technique:
A review. <em>The Statistician</em>, 169-178..
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rec &lt;- recipe(~., data = as.data.frame(state.x77))

bc_trans &lt;- step_BoxCox(rec, all_numeric())

bc_estimates &lt;- prep(bc_trans, training = as.data.frame(state.x77))

bc_data &lt;- bake(bc_estimates, as.data.frame(state.x77))

plot(density(state.x77[, "Illiteracy"]), main = "before")
plot(density(bc_data$Illiteracy), main = "after")

tidy(bc_trans, number = 1)
tidy(bc_estimates, number = 1)
</code></pre>

<hr>
<h2 id='step_bs'>B-spline basis functions</h2><span id='topic+step_bs'></span>

<h3>Description</h3>

<p><code>step_bs()</code> creates a <em>specification</em> of a recipe step that will create new
columns that are basis expansions of variables using B-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_bs(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  deg_free = NULL,
  degree = 3,
  objects = NULL,
  options = list(),
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("bs")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_bs_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_deg_free">deg_free</code></td>
<td>
<p>The degrees of freedom for the spline. As the
degrees of freedom for a spline increase, more flexible and
complex curves can be generated. When a single degree of freedom is used,
the result is a rescaled version of the original data.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_degree">degree</code></td>
<td>
<p>Degree of polynomial spline (integer).</p>
</td></tr>
<tr><td><code id="step_bs_+3A_objects">objects</code></td>
<td>
<p>A list of <code><a href="splines.html#topic+bs">splines::bs()</a></code> objects
created once the step has been trained.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="splines.html#topic+bs">splines::bs()</a></code>
which should not include <code>x</code>, <code>degree</code>, or <code>df</code>.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_bs_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_bs</code> can create new features from a single variable
that enable fitting routines to model this variable in a
nonlinear manner. The extent of the possible nonlinearity is
determined by the <code>df</code>, <code>degree</code>, or <code>knot</code> arguments of
<code><a href="splines.html#topic+bs">splines::bs()</a></code>. The original variables are removed
from the data and new columns are added. The naming convention
for the new variables is <code>varname_bs_1</code> and so on.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>deg_free</code>: Spline Degrees of Freedom (type: integer, default: NULL)
</p>
</li>
<li> <p><code>degree</code>: Polynomial Degree (type: integer, default: 3)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

with_splines &lt;- rec %&gt;%
  step_bs(carbon, hydrogen)
with_splines &lt;- prep(with_splines, training = biomass_tr)

expanded &lt;- bake(with_splines, biomass_te)
expanded

</code></pre>

<hr>
<h2 id='step_center'>Centering numeric data</h2><span id='topic+step_center'></span>

<h3>Description</h3>

<p><code>step_center()</code> creates a <em>specification</em> of a recipe step that will
normalize numeric data to have a mean of zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_center(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  means = NULL,
  na_rm = TRUE,
  skip = FALSE,
  id = rand_id("center")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_center_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_center_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_center_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_center_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_center_+3A_means">means</code></td>
<td>
<p>A named numeric vector of means. This is
<code>NULL</code> until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_center_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical value indicating whether <code>NA</code>
values should be removed during computations.</p>
</td></tr>
<tr><td><code id="step_center_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_center_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centering data means that the average of a variable is
subtracted from the data. <code>step_center</code> estimates the
variable means from the data used in the <code>training</code>
argument of <code>prep.recipe</code>. <code>bake.recipe</code> then applies
the centering to new data sets using these means.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code>, and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the means</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other normalization steps: 
<code><a href="#topic+step_normalize">step_normalize</a>()</code>,
<code><a href="#topic+step_range">step_range</a>()</code>,
<code><a href="#topic+step_scale">step_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

center_trans &lt;- rec %&gt;%
  step_center(carbon, contains("gen"), -hydrogen)

center_obj &lt;- prep(center_trans, training = biomass_tr)

transformed_te &lt;- bake(center_obj, biomass_te)

biomass_te[1:10, names(transformed_te)]
transformed_te

tidy(center_trans, number = 1)
tidy(center_obj, number = 1)

</code></pre>

<hr>
<h2 id='step_classdist'>Distances to class centroids</h2><span id='topic+step_classdist'></span>

<h3>Description</h3>

<p><code>step_classdist()</code> creates a <em>specification</em> of a recipe step that will
convert numeric data into Mahalanobis distance measurements to the data
centroid. This is done for each value of a categorical class variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_classdist(
  recipe,
  ...,
  class,
  role = "predictor",
  trained = FALSE,
  mean_func = mean,
  cov_func = cov,
  pool = FALSE,
  log = TRUE,
  objects = NULL,
  prefix = "classdist_",
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("classdist")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_classdist_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_class">class</code></td>
<td>
<p>A single character string that specifies a single
categorical variable to be used as the class.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_mean_func">mean_func</code></td>
<td>
<p>A function to compute the center of the
distribution.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_cov_func">cov_func</code></td>
<td>
<p>A function that computes the covariance matrix</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_pool">pool</code></td>
<td>
<p>A logical: should the covariance matrix be computed
by pooling the data for all of the classes?</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_log">log</code></td>
<td>
<p>A logical: should the distances be transformed by
the natural log function?</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_objects">objects</code></td>
<td>
<p>Statistics are stored here once this step has
been trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_classdist_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_classdist</code> will create a new column for every unique value of
the <code>class</code> variable. The resulting variables will not replace the original
values and, by default, have the prefix <code>classdist_</code>. The naming format can
be changed using the <code>prefix</code> argument.
</p>
<p>Class-specific centroids are the multivariate averages of each predictor
using the data from each class in the training set. When pre-processing a
new data point, this step computes the distance from the new point to each
of the class centroids. These distance features can be very effective at
capturing linear class boundaries. For this reason, they can be useful to
add to an existing predictor set used within a nonlinear model. If the true
boundary is actually linear, the model will have an easier time learning the
training data patterns.
</p>
<p>Note that, by default, the default covariance function requires
that each class should have at least as many rows as variables
listed in the <code>terms</code> argument. If <code>pool = TRUE</code>,
there must be at least as many data points are variables
overall.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code>, <code>class</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, location of centroid</p>
</dd>
<dt>class</dt><dd><p>character, name of the class</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an supervised operation that can utilize case weights.
As a result, case weights are used with frequency weights as well as
importance weights. For more information,, see the documentation in
<a href="#topic+case_weights">case_weights</a> and the examples on <code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(penguins, package = "modeldata")
penguins &lt;- penguins[complete.cases(penguins), ]
penguins$island &lt;- NULL
penguins$sex &lt;- NULL

# in case of missing data...
mean2 &lt;- function(x) mean(x, na.rm = TRUE)

# define naming convention
rec &lt;- recipe(species ~ ., data = penguins) %&gt;%
  step_classdist(all_numeric_predictors(),
    class = "species",
    pool = FALSE, mean_func = mean2, prefix = "centroid_"
  )

# default naming
rec &lt;- recipe(species ~ ., data = penguins) %&gt;%
  step_classdist(all_numeric_predictors(),
    class = "species",
    pool = FALSE, mean_func = mean2
  )

rec_dists &lt;- prep(rec, training = penguins)

dists_to_species &lt;- bake(rec_dists, new_data = penguins, everything())
## on log scale:
dist_cols &lt;- grep("classdist", names(dists_to_species), value = TRUE)
dists_to_species[, c("species", dist_cols)]

tidy(rec, number = 1)
tidy(rec_dists, number = 1)

</code></pre>

<hr>
<h2 id='step_classdist_shrunken'>Compute shrunken centroid distances for classification models</h2><span id='topic+step_classdist_shrunken'></span>

<h3>Description</h3>

<p><code>step_classdist_shrunken</code> creates a <em>specification</em> of a recipe
step  that will convert numeric data into Euclidean distance
to the regularized class centroid. This is done for each value of a
categorical class variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_classdist_shrunken(
  recipe,
  ...,
  class = NULL,
  role = NA,
  trained = FALSE,
  threshold = 1/2,
  sd_offset = 1/2,
  log = TRUE,
  prefix = "classdist_",
  keep_original_cols = TRUE,
  objects = NULL,
  skip = FALSE,
  id = rand_id("classdist_shrunken")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_classdist_shrunken_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_class">class</code></td>
<td>
<p>A single character string that specifies a single
categorical variable to be used as the class.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_threshold">threshold</code></td>
<td>
<p>A regularization parameter between zero and one. Zero means
that no regularization is used and one means that centroids should be
shrunk to the global centroid.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_sd_offset">sd_offset</code></td>
<td>
<p>A value between zero and one for the quantile that should
be used to stabilize the pooled standard deviation.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_log">log</code></td>
<td>
<p>A logical: should the distances be transformed by
the natural log function?</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_objects">objects</code></td>
<td>
<p>Statistics are stored here once this step has
been trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_classdist_shrunken_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Class-specific centroids are the multivariate averages of each predictor
using the data from each class in the training set. When pre-processing a
new data point, this step computes the distance from the new point to each
of the class centroids. These distance features can be very effective at
capturing linear class boundaries. For this reason, they can be useful to
add to an existing predictor set used within a nonlinear model. If the true
boundary is actually linear, the model will have an easier time learning the
training data patterns.
</p>
<p>Shrunken centroids use a form of regularization where the class-specific
centroids are contracted to the overall class-independent centroid. If a
predictor is uninformative, shrinking it may move it entirely to the overall
centroid. This has the effect of removing that predictor's effect on the new
distance features. However, it may not move all of the class-specific
features to the center in many cases. This means that some features will
only affect the classification of specific classes.
</p>
<p>The <code>threshold</code> parameter can be used to optimized how much regularization
should be used.
</p>
<p><code>step_classdist_shrunken</code> will create a new column for every unique value of
the <code>class</code> variable. The resulting variables will not replace the original
values and, by default, have the prefix <code>classdist_</code>. The naming format can
be changed using the <code>prefix</code> argument.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code>, <code>class</code>, <code>type</code>, <code>threshold</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the centroid</p>
</dd>
<dt>class</dt><dd><p>character, name of class variable</p>
</dd>
<dt>type</dt><dd><p>character, has values <code>"global"</code>, <code>"by_class"</code>, and <code>"shrunken"</code></p>
</dd>
<dt>threshold</dt><dd><p>numeric, value of threshold</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>

<p>The first two types of centroids are in the original units while the last
has been standardized.
</p>


<h3>Case weights</h3>

<p>This step performs an supervised operation that can utilize case weights.
As a result, case weights are used with frequency weights as well as
importance weights. For more information,, see the documentation in
<a href="#topic+case_weights">case_weights</a> and the examples on <code>tidymodels.org</code>.
</p>


<h3>References</h3>

<p>Tibshirani, R., Hastie, T., Narasimhan, B., &amp; Chu, G. (2002). Diagnosis of
multiple cancer types by shrunken centroids of gene expression. <em>Proceedings
of the National Academy of Sciences</em>, 99(10), 6567-6572.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(penguins, package = "modeldata")
penguins &lt;- penguins[complete.cases(penguins), ]
penguins$island &lt;- NULL
penguins$sex &lt;- NULL

# define naming convention
rec &lt;- recipe(species ~ ., data = penguins) %&gt;%
  step_classdist_shrunken(all_numeric_predictors(),
    class = "species",
    threshold = 1 / 4, prefix = "centroid_"
  )

# default naming
rec &lt;- recipe(species ~ ., data = penguins) %&gt;%
  step_classdist_shrunken(all_numeric_predictors(),
    class = "species",
    threshold = 3 / 4
  )

rec_dists &lt;- prep(rec, training = penguins)

dists_to_species &lt;- bake(rec_dists, new_data = penguins, everything())
## on log scale:
dist_cols &lt;- grep("classdist", names(dists_to_species), value = TRUE)
dists_to_species[, c("species", dist_cols)]

tidy(rec, number = 1)
tidy(rec_dists, number = 1)

</code></pre>

<hr>
<h2 id='step_corr'>High correlation filter</h2><span id='topic+step_corr'></span>

<h3>Description</h3>

<p><code>step_corr()</code> creates a <em>specification</em> of a recipe step that will
potentially remove variables that have large absolute correlations with other
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_corr(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  threshold = 0.9,
  use = "pairwise.complete.obs",
  method = "pearson",
  removals = NULL,
  skip = FALSE,
  id = rand_id("corr")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_corr_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_threshold">threshold</code></td>
<td>
<p>A value for the threshold of absolute
correlation values. The step will try to remove the minimum
number of columns so that all the resulting absolute
correlations are less than this value.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_use">use</code></td>
<td>
<p>A character string for the <code>use</code> argument to
the <code><a href="stats.html#topic+cor">stats::cor()</a></code> function.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_method">method</code></td>
<td>
<p>A character string for the <code>method</code> argument
to the <code><a href="stats.html#topic+cor">stats::cor()</a></code> function.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_removals">removals</code></td>
<td>
<p>A character string that contains the names of
columns that should be removed. These values are not determined
until <code><a href="#topic+prep">prep()</a></code> is called.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_corr_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step can potentially remove columns from the data set. This may
cause issues for subsequent steps in your recipe if the missing columns are
specifically referenced by name. To avoid this, see the advice in the
<em>Tips for saving recipes and filtering columns</em> section of <a href="#topic+selections">selections</a>.
</p>
<p>This step attempts to remove variables to keep the
largest absolute correlation between the variables less than
<code>threshold</code>.
</p>
<p>When a column has a single unique value, that column will be
excluded from the correlation analysis. Also, if the data set
has sporadic missing values (and an inappropriate value of <code>use</code>
is chosen), some columns will also be excluded from the filter.
</p>
<p>The arguments <code>use</code> and <code>method</code> don't take effect if case weights
are used in the recipe.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected to be removed</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>threshold</code>: Threshold (type: double, default: 0.9)
</p>
</li></ul>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>Author(s)</h3>

<p>Original R code for filtering algorithm by Dong Li,
modified by Max Kuhn. Contributions by Reynald Lescarbeau (for
original in <code>caret</code> package). Max Kuhn for the <code>step</code>
function.
</p>


<h3>See Also</h3>

<p>Other variable filter steps: 
<code><a href="#topic+step_filter_missing">step_filter_missing</a>()</code>,
<code><a href="#topic+step_lincomb">step_lincomb</a>()</code>,
<code><a href="#topic+step_nzv">step_nzv</a>()</code>,
<code><a href="#topic+step_rm">step_rm</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_zv">step_zv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

set.seed(3535)
biomass$duplicate &lt;- biomass$carbon + rnorm(nrow(biomass))

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur + duplicate,
  data = biomass_tr
)

corr_filter &lt;- rec %&gt;%
  step_corr(all_numeric_predictors(), threshold = .5)

filter_obj &lt;- prep(corr_filter, training = biomass_tr)

filtered_te &lt;- bake(filter_obj, biomass_te)
round(abs(cor(biomass_tr[, c(3:7, 9)])), 2)
round(abs(cor(filtered_te)), 2)

tidy(corr_filter, number = 1)
tidy(filter_obj, number = 1)

</code></pre>

<hr>
<h2 id='step_count'>Create counts of patterns using regular expressions</h2><span id='topic+step_count'></span>

<h3>Description</h3>

<p><code>step_count()</code> creates a <em>specification</em> of a recipe step that will create a
variable that counts instances of a regular expression pattern in text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_count(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  pattern = ".",
  normalize = FALSE,
  options = list(),
  result = make.names(pattern),
  input = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("count")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_count_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_count_+3A_...">...</code></td>
<td>
<p>A single selector function to choose which variable
will be searched for the regex pattern. The selector should
resolve to a single variable. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_count_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_count_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_count_+3A_pattern">pattern</code></td>
<td>
<p>A character string containing a regular
expression (or character string for <code>fixed = TRUE</code>) to be
matched in the given character vector. Coerced by
<code>as.character</code> to a character string if possible.</p>
</td></tr>
<tr><td><code id="step_count_+3A_normalize">normalize</code></td>
<td>
<p>A logical; should the integer counts be
divided by the total number of characters in the string?.</p>
</td></tr>
<tr><td><code id="step_count_+3A_options">options</code></td>
<td>
<p>A list of options to <code><a href="base.html#topic+gregexpr">gregexpr()</a></code> that
should not include <code>x</code> or <code>pattern</code>.</p>
</td></tr>
<tr><td><code id="step_count_+3A_result">result</code></td>
<td>
<p>A single character value for the name of the new
variable. It should be a valid column name.</p>
</td></tr>
<tr><td><code id="step_count_+3A_input">input</code></td>
<td>
<p>A single character value for the name of the
variable being searched. This is <code>NULL</code> until computed by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_count_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_count_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_count_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>result</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>result</dt><dd><p>character, the new column names</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(covers, package = "modeldata")

rec &lt;- recipe(~description, covers) %&gt;%
  step_count(description, pattern = "(rock|stony)", result = "rocks") %&gt;%
  step_count(description, pattern = "famil", normalize = TRUE)

rec2 &lt;- prep(rec, training = covers)
rec2

count_values &lt;- bake(rec2, new_data = covers)
count_values

tidy(rec, number = 1)
tidy(rec2, number = 1)

</code></pre>

<hr>
<h2 id='step_cut'>Cut a numeric variable into a factor</h2><span id='topic+step_cut'></span>

<h3>Description</h3>

<p><code>step_cut()</code> creates a <em>specification</em> of a recipe step that cuts a numeric
variable into a factor based on provided boundary values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_cut(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  breaks,
  include_outside_range = FALSE,
  skip = FALSE,
  id = rand_id("cut")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_cut_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_cut_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_cut_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_cut_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_cut_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector with at least one cut point.</p>
</td></tr>
<tr><td><code id="step_cut_+3A_include_outside_range">include_outside_range</code></td>
<td>
<p>Logical, indicating if values outside the
range in the train set should be included in the lowest or highest bucket.
Defaults to <code>FALSE</code>, values outside the original range will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="step_cut_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_cut_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the <code>base::cut()</code> function there is no need to specify the
min and the max values in the breaks. All values before the lowest break
point will end up in the first bucket, all values after the last break
points will end up in the last.
</p>
<p><code>step_cut()</code> will call <code>base::cut()</code> in the baking step with
<code>include.lowest</code> set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the location of the cuts</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other discretization steps: 
<code><a href="#topic+step_discretize">step_discretize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = 1:10, y = 5:14)
rec &lt;- recipe(df)

# The min and max of the variable are used as boundaries
# if they exceed the breaks
rec %&gt;%
  step_cut(x, breaks = 5) %&gt;%
  prep() %&gt;%
  bake(df)

# You can use the same breaks on multiple variables
# then for each variable the boundaries are set separately
rec %&gt;%
  step_cut(x, y, breaks = c(6, 9)) %&gt;%
  prep() %&gt;%
  bake(df)

# You can keep the original variables using `step_mutate` or
# `step_mutate_at`, for transforming multiple variables at once
rec %&gt;%
  step_mutate(x_orig = x) %&gt;%
  step_cut(x, breaks = 5) %&gt;%
  prep() %&gt;%
  bake(df)

# It is up to you if you want values outside the
# range learned at prep to be included
new_df &lt;- data.frame(x = 1:11, y = 5:15)
rec %&gt;%
  step_cut(x, breaks = 5, include_outside_range = TRUE) %&gt;%
  prep() %&gt;%
  bake(new_df)

rec %&gt;%
  step_cut(x, breaks = 5, include_outside_range = FALSE) %&gt;%
  prep() %&gt;%
  bake(new_df)
</code></pre>

<hr>
<h2 id='step_date'>Date feature generator</h2><span id='topic+step_date'></span>

<h3>Description</h3>

<p><code>step_date()</code> creates a <em>specification</em> of a recipe step that will convert
date data into one or more factor or numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_date(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  features = c("dow", "month", "year"),
  abbr = TRUE,
  label = TRUE,
  ordinal = FALSE,
  locale = clock::clock_locale()$labels,
  columns = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("date")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_date_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_date_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. The selected variables should have class <code>Date</code> or
<code>POSIXct</code>. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_date_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_date_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_date_+3A_features">features</code></td>
<td>
<p>A character string that includes at least one
of the following values: <code>month</code>, <code>dow</code> (day of week),
<code>doy</code> (day of year), <code>week</code>, <code>month</code>,
<code>decimal</code> (decimal date, e.g. 2002.197), <code>quarter</code>,
<code>semester</code>, <code>year</code>.</p>
</td></tr>
<tr><td><code id="step_date_+3A_abbr">abbr</code></td>
<td>
<p>A logical. Only available for features <code>month</code>
or <code>dow</code>. <code>FALSE</code> will display the day of the week as
an ordered factor of character strings, such as &quot;Sunday&quot;.
<code>TRUE</code> will display an abbreviated version of the label,
such as &quot;Sun&quot;. <code>abbr</code> is disregarded if <code>label = FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_date_+3A_label">label</code></td>
<td>
<p>A logical. Only available for features
<code>month</code> or <code>dow</code>. <code>TRUE</code> will display the day of
the week as an ordered factor of character strings, such as
&quot;Sunday.&quot; <code>FALSE</code> will display the day of the week as a
number.</p>
</td></tr>
<tr><td><code id="step_date_+3A_ordinal">ordinal</code></td>
<td>
<p>A logical: should factors be ordered? Only
available for features <code>month</code> or <code>dow</code>.</p>
</td></tr>
<tr><td><code id="step_date_+3A_locale">locale</code></td>
<td>
<p>Locale to be used for <code>month</code> and <code>dow</code>, see <a href="base.html#topic+locales">locales</a>.
On Linux systems you can use <code>system("locale -a")</code> to list all the
installed locales. Can be a locales string, or a <code><a href="clock.html#topic+clock_labels">clock::clock_labels()</a></code>
object. Defaults to <code>clock::clock_locale()$labels</code>.</p>
</td></tr>
<tr><td><code id="step_date_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_date_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="step_date_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_date_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike some other steps, <code>step_date</code> does <em>not</em>
remove the original date variables by default. Set <code>keep_original_cols</code>
to <code>FALSE</code> to remove them.
</p>
<p>See <code><a href="#topic+step_time">step_time()</a></code> if you want to calculate features that are smaller than
days.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble with columns
<code>terms</code> (the selectors or variables selected), <code>value</code> (the feature
names), and <code>ordinal</code> (a logical) is returned.
</p>
<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code>, <code>ordinal</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>character, the feature names</p>
</dd>
<dt>ordinal</dt><dd><p>logical, are factors ordered</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

examples &lt;- data.frame(
  Dan = ymd("2002-03-04") + days(1:10),
  Stefan = ymd("2006-01-13") + days(1:10)
)
date_rec &lt;- recipe(~ Dan + Stefan, examples) %&gt;%
  step_date(all_predictors())

tidy(date_rec, number = 1)

date_rec &lt;- prep(date_rec, training = examples)

date_values &lt;- bake(date_rec, new_data = examples)
date_values

tidy(date_rec, number = 1)
</code></pre>

<hr>
<h2 id='step_depth'>Data depths</h2><span id='topic+step_depth'></span>

<h3>Description</h3>

<p><code>step_depth()</code> creates a <em>specification</em> of a recipe step that will convert
numeric data into a measurement of <em>data depth</em>. This is done for each value of
a categorical class variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_depth(
  recipe,
  ...,
  class,
  role = "predictor",
  trained = FALSE,
  metric = "halfspace",
  options = list(),
  data = NULL,
  prefix = "depth_",
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("depth")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_depth_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_class">class</code></td>
<td>
<p>A single character string that specifies a single
categorical variable to be used as the class.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_metric">metric</code></td>
<td>
<p>A character string specifying the depth metric.
Possible values are &quot;potential&quot;, &quot;halfspace&quot;, &quot;Mahalanobis&quot;,
&quot;simplicialVolume&quot;, &quot;spatial&quot;, and &quot;zonoid&quot;.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_options">options</code></td>
<td>
<p>A list of options to pass to the underlying
depth functions. See <code><a href="ddalpha.html#topic+depth.halfspace">ddalpha::depth.halfspace()</a></code>,
<code><a href="ddalpha.html#topic+depth.Mahalanobis">ddalpha::depth.Mahalanobis()</a></code>,
<code><a href="ddalpha.html#topic+depth.potential">ddalpha::depth.potential()</a></code>,
<code><a href="ddalpha.html#topic+depth.projection">ddalpha::depth.projection()</a></code>,
<code><a href="ddalpha.html#topic+depth.simplicial">ddalpha::depth.simplicial()</a></code>,
<code><a href="ddalpha.html#topic+depth.simplicialVolume">ddalpha::depth.simplicialVolume()</a></code>,
<code><a href="ddalpha.html#topic+depth.spatial">ddalpha::depth.spatial()</a></code>,
<code><a href="ddalpha.html#topic+depth.zonoid">ddalpha::depth.zonoid()</a></code>.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_data">data</code></td>
<td>
<p>The training data are stored here once after
<code><a href="#topic+prep">prep()</a></code> is executed.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_depth_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data depth metrics attempt to measure how close data a
data point is to the center of its distribution. There are a
number of methods for calculating depth but a simple example is
the inverse of the distance of a data point to the centroid of
the distribution. Generally, small values indicate that a data
point not close to the centroid. <code>step_depth</code> can compute a
class-specific depth for a new data point based on the proximity
of the new value to the training set distribution.
</p>
<p>This step requires the <span class="pkg">ddalpha</span> package. If not installed, the
step will stop with a note about installing the package.
</p>
<p>Note that the entire training set is saved to compute future
depth values. The saved data have been trained (i.e. prepared)
and baked (i.e. processed) up to the point before the location
that <code>step_depth</code> occupies in the recipe. Also, the data
requirements for the different step methods may vary. For
example, using <code>metric = "Mahalanobis"</code> requires that each
class should have at least as many rows as variables listed in
the <code>terms</code> argument.
</p>
<p>The function will create a new column for every unique value of
the <code>class</code> variable. The resulting variables will not
replace the original values and by default have the prefix <code>depth_</code>. The
naming format can be changed using the <code>prefix</code> argument.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>class</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>class</dt><dd><p>character, name of class variable</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# halfspace depth is the default
rec &lt;- recipe(Species ~ ., data = iris) %&gt;%
  step_depth(all_numeric_predictors(), class = "Species")

# use zonoid metric instead
# also, define naming convention for new columns
rec &lt;- recipe(Species ~ ., data = iris) %&gt;%
  step_depth(all_numeric_predictors(),
    class = "Species",
    metric = "zonoid", prefix = "zonoid_"
  )

rec_dists &lt;- prep(rec, training = iris)

dists_to_species &lt;- bake(rec_dists, new_data = iris)
dists_to_species

tidy(rec, number = 1)
tidy(rec_dists, number = 1)

</code></pre>

<hr>
<h2 id='step_discretize'>Discretize Numeric Variables</h2><span id='topic+step_discretize'></span>

<h3>Description</h3>

<p><code>step_discretize()</code> creates a <em>specification</em> of a recipe step that will
convert numeric data into a factor with bins having approximately the same
number of data points (based on a training set).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_discretize(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  num_breaks = 4,
  min_unique = 10,
  objects = NULL,
  options = list(prefix = "bin"),
  skip = FALSE,
  id = rand_id("discretize")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_discretize_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_num_breaks">num_breaks</code></td>
<td>
<p>An integer defining how many cuts to make of the
data.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_min_unique">min_unique</code></td>
<td>
<p>An integer defining a sample size line of
dignity for the binning. If (the number of unique
values)<code style="white-space: pre;">&#8288;/(cuts+1)&#8288;</code> is less than <code>min_unique</code>, no
discretization takes place.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_objects">objects</code></td>
<td>
<p>The <code><a href="#topic+discretize">discretize()</a></code> objects are stored
here once the recipe has be trained by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_options">options</code></td>
<td>
<p>A list of options to <code><a href="#topic+discretize">discretize()</a></code>. A
default is set for the argument <code>x</code>. Note that using
the options <code>prefix</code> and <code>labels</code> when more than one
variable is being transformed might be problematic as all
variables inherit those values.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_discretize_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the breaks</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>min_unique</code>: Unique Value Threshold (type: integer, default: 10)
</p>
</li>
<li> <p><code>num_breaks</code>: Number of Cut Points (type: integer, default: 4)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other discretization steps: 
<code><a href="#topic+step_cut">step_cut</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
) %&gt;%
  step_discretize(carbon, hydrogen)

rec &lt;- prep(rec, biomass_tr)
binned_te &lt;- bake(rec, biomass_te)
table(binned_te$carbon)

tidy(rec, 1)

</code></pre>

<hr>
<h2 id='step_dummy'>Create traditional dummy variables</h2><span id='topic+step_dummy'></span>

<h3>Description</h3>

<p><code>step_dummy()</code> creates a <em>specification</em> of a recipe step that will convert
nominal data (e.g. factors) into one or more numeric binary model terms
corresponding to the levels of the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_dummy(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  one_hot = FALSE,
  preserve = deprecated(),
  naming = dummy_names,
  levels = NULL,
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("dummy")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_dummy_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables for this step.
See <code><a href="#topic+selections">selections()</a></code> for more details. The selected variables <em>must</em> be
factors.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_one_hot">one_hot</code></td>
<td>
<p>A logical. For C levels, should C dummy variables be created
rather than C-1?</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_preserve">preserve</code></td>
<td>
<p>This argument has been deprecated. Please use
<code>keep_original_cols</code> instead.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_naming">naming</code></td>
<td>
<p>A function that defines the naming convention for new dummy
columns. See Details below.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_levels">levels</code></td>
<td>
<p>A list that contains the information needed to create dummy
variables for each variable contained in <code>terms</code>. This is <code>NULL</code> until the
step is trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_dummy_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_dummy()</code> will create a set of binary dummy variables from a factor
variable. For example, if an unordered factor column in the data set has
levels of &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, the dummy variable bake will create two
additional columns of 0/1 data for two of those three values (and remove the
original column). For ordered factors, polynomial contrasts are used to
encode the numeric values.
</p>
<p>By default, the excluded dummy variable (i.e. the reference cell) will
correspond to the first level of the unordered factor being converted.
<code>step_relevel()</code> can be used to create a new reference level by setting the
<code>ref_level</code> argument.
</p>
<p>This recipe step allows for flexible naming of the resulting
variables. For an unordered factor named <code>x</code>, with levels <code>"a"</code>
and <code>"b"</code>, the default naming convention would be to create a
new variable called <code>x_b</code>. The naming format can be changed using
the <code>naming</code> argument; the function <code><a href="#topic+dummy_names">dummy_names()</a></code> is the
default.
</p>
<p>To change the type of contrast being used, change the global contrast option
via <code>options</code>.
</p>
<p>When the factor being converted has a missing value, all of the corresponding
dummy variables are also missing. See <code><a href="#topic+step_unknown">step_unknown()</a></code> for a solution.
</p>
<p>When data to be processed contains novel levels (i.e., not contained in the
training set), a missing value is assigned to the results. See <code><a href="#topic+step_other">step_other()</a></code>
for an alternative.
</p>
<p>If no columns are selected (perhaps due to an earlier <code>step_zv()</code>), <code><a href="#topic+bake">bake()</a></code>
will return the data as-is (e.g. with no dummy variables).
</p>
<p>Note that, by default, the new dummy variable column names obey the naming
rules for columns. If there are levels such as &quot;0&quot;, <code><a href="#topic+dummy_names">dummy_names()</a></code> will put
a leading &quot;X&quot; in front of the level (since it uses <code><a href="base.html#topic+make.names">make.names()</a></code>). This can
be changed by passing in a different function to the <code>naming</code> argument for
this step.
</p>
<p>Also, there are a number of contrast methods that return fractional values.
The columns returned by this step are doubles (not integers).
</p>
<p>The <a href="https://recipes.tidymodels.org/articles/Dummies.html">package vignette for dummy variables</a>
and interactions has more information.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>columns</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>columns</dt><dd><p>character, names of resulting columns</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dummy_names">dummy_names()</a></code>
</p>
<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

# Original data: city has 37 levels
length(unique(Sacramento$city))
unique(Sacramento$city) %&gt;% sort()

rec &lt;- recipe(~ city + sqft + price, data = Sacramento)

# Default dummy coding: 36 dummy variables
dummies &lt;- rec %&gt;%
  step_dummy(city) %&gt;%
  prep(training = Sacramento)

dummy_data &lt;- bake(dummies, new_data = NULL)

dummy_data %&gt;%
  select(starts_with("city")) %&gt;%
  names() # level "anything" is the reference level

# Obtain the full set of 37 dummy variables using `one_hot` option
dummies_one_hot &lt;- rec %&gt;%
  step_dummy(city, one_hot = TRUE) %&gt;%
  prep(training = Sacramento)

dummy_data_one_hot &lt;- bake(dummies_one_hot, new_data = NULL)

dummy_data_one_hot %&gt;%
  select(starts_with("city")) %&gt;%
  names() # no reference level


tidy(dummies, number = 1)
tidy(dummies_one_hot, number = 1)

</code></pre>

<hr>
<h2 id='step_dummy_extract'>Extract patterns from nominal data</h2><span id='topic+step_dummy_extract'></span>

<h3>Description</h3>

<p><code>step_dummy_extract()</code> creates a <em>specification</em> of a recipe step that will
convert nominal data (e.g. characters or factors) into one or more integer
model terms for the extracted levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_dummy_extract(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  sep = NULL,
  pattern = NULL,
  threshold = 0,
  other = "other",
  naming = dummy_extract_names,
  levels = NULL,
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("dummy_extract")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_dummy_extract_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_sep">sep</code></td>
<td>
<p>Character vector containing a regular expression to use
for splitting. <code><a href="base.html#topic+strsplit">strsplit()</a></code> is used to perform the split. <code>sep</code> takes
priority if <code>pattern</code> is also specified.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_pattern">pattern</code></td>
<td>
<p>Character vector containing a regular expression used
for extraction. <code><a href="base.html#topic+gregexpr">gregexpr()</a></code> and <code><a href="base.html#topic+regmatches">regmatches()</a></code> are used to perform
pattern extraction using <code>perl = TRUE</code>.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value between 0 and 1, or an integer greater or
equal to one.  If less than one, then factor levels with a rate of
occurrence in the training set below <code>threshold</code> will be pooled to <code>other</code>.
If greater or equal to one, then this value is treated as a frequency
and factor levels that occur less than <code>threshold</code> times will be pooled
to <code>other</code>.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_other">other</code></td>
<td>
<p>A single character value for the &quot;other&quot; category.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_naming">naming</code></td>
<td>
<p>A function that defines the naming convention for new dummy
columns. See Details below.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_levels">levels</code></td>
<td>
<p>A list that contains the information needed to create dummy
variables for each variable contained in <code>terms</code>. This is <code>NULL</code> until the
step is trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_dummy_extract_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_dummy_extract()</code> will create a set of integer dummy
variables from a character variable by extracting individual strings
by either splitting or extracting then counting those to create
count variables.
</p>
<p>Note that <code>threshold</code> works in a very specific way for this step.
While it is possible for one label to be present multiple times in
the same row, it will only be counted once when calculating the
occurrences and frequencies.
</p>
<p>This recipe step allows for flexible naming of the resulting
variables. For an unordered factor named <code>x</code>, with levels <code>"a"</code>
and <code>"b"</code>, the default naming convention would be to create a
new variable called <code>x_b</code>. The naming format can be changed using
the <code>naming</code> argument; the function <code><a href="#topic+dummy_names">dummy_names()</a></code> is the
default.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>columns</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>columns</dt><dd><p>character, names of resulting columns</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>

<p>The return value is ordered according to the frequency of <code>columns</code> entries in the training data set.
</p>


<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dummy_extract_names">dummy_extract_names()</a></code>
</p>
<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tate_text, package = "modeldata")

dummies &lt;- recipe(~ artist + medium, data = tate_text) %&gt;%
  step_dummy_extract(artist, medium, sep = ", ") %&gt;%
  prep()

dummy_data &lt;- bake(dummies, new_data = NULL)

dummy_data %&gt;%
  select(starts_with("medium")) %&gt;%
  names() %&gt;%
  head()

# More detailed splitting
dummies_specific &lt;- recipe(~medium, data = tate_text) %&gt;%
  step_dummy_extract(medium, sep = "(, )|( and )|( on )") %&gt;%
  prep()

dummy_data_specific &lt;- bake(dummies_specific, new_data = NULL)

dummy_data_specific %&gt;%
  select(starts_with("medium")) %&gt;%
  names() %&gt;%
  head()

tidy(dummies, number = 1)
tidy(dummies_specific, number = 1)

# pattern argument can be useful to extract harder patterns
color_examples &lt;- tibble(
  colors = c(
    "['red', 'blue']",
    "['red', 'blue', 'white']",
    "['blue', 'blue', 'blue']"
  )
)

dummies_color &lt;- recipe(~colors, data = color_examples) %&gt;%
  step_dummy_extract(colors, pattern = "(?&lt;=')[^',]+(?=')") %&gt;%
  prep()

dommies_data_color &lt;- dummies_color %&gt;%
  bake(new_data = NULL)

dommies_data_color

</code></pre>

<hr>
<h2 id='step_dummy_multi_choice'>Handle levels in multiple predictors together</h2><span id='topic+step_dummy_multi_choice'></span>

<h3>Description</h3>

<p><code>step_dummy_multi_choice()</code> creates a <em>specification</em> of a recipe step that
will convert multiple nominal data (e.g. characters or factors) into one or
more numeric binary model terms for the levels of the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_dummy_multi_choice(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  threshold = 0,
  levels = NULL,
  input = NULL,
  other = "other",
  naming = dummy_names,
  prefix = NULL,
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("dummy_multi_choice")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_dummy_multi_choice_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables for this step.
See <code><a href="#topic+selections">selections()</a></code> for more details. The selected variables <em>must</em> be
factors.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value between 0 and 1, or an integer greater or
equal to one.  If less than one, then factor levels with a rate of
occurrence in the training set below <code>threshold</code> will be pooled to <code>other</code>.
If greater or equal to one, then this value is treated as a frequency
and factor levels that occur less than <code>threshold</code> times will be pooled
to <code>other</code>.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_levels">levels</code></td>
<td>
<p>A list that contains the information needed to create dummy
variables for each variable contained in <code>terms</code>. This is <code>NULL</code> until the
step is trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_input">input</code></td>
<td>
<p>A character vector containing the names of the columns used.
This is <code>NULL</code> until the step is trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_other">other</code></td>
<td>
<p>A single character value for the &quot;other&quot; category.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_naming">naming</code></td>
<td>
<p>A function that defines the naming convention for new dummy
columns. See Details below.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_dummy_multi_choice_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The overall proportion (or total counts) of the categories are
computed. The &quot;other&quot; category is used in place of any categorical levels
whose individual proportion (or frequency) in the training set is less than
<code>threshold</code>.
</p>
<p>This recipe step allows for flexible naming of the resulting
variables. For an unordered factor named <code>x</code>, with levels <code>"a"</code>
and <code>"b"</code>, the default naming convention would be to create a
new variable called <code>x_b</code>. The naming format can be changed using
the <code>naming</code> argument; the function <code><a href="#topic+dummy_names">dummy_names()</a></code> is the
default.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>threshold</code>: Threshold (type: double, default: 0)
</p>
</li></ul>



<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>columns</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>columns</dt><dd><p>character, names of resulting columns</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
languages &lt;- tribble(
  ~lang_1,    ~lang_2,   ~lang_3,
  "English",  "Italian", NA,
  "Spanish",  NA,        "French",
  "Armenian", "English", "French",
  NA,         NA,        NA
)

dummy_multi_choice_rec &lt;- recipe(~., data = languages) %&gt;%
  step_dummy_multi_choice(starts_with("lang")) %&gt;%
  prep()

bake(dummy_multi_choice_rec, new_data = NULL)
tidy(dummy_multi_choice_rec, number = 1)

dummy_multi_choice_rec2 &lt;- recipe(~., data = languages) %&gt;%
  step_dummy_multi_choice(starts_with("lang"),
    prefix = "lang",
    threshold = 0.2
  ) %&gt;%
  prep()

bake(dummy_multi_choice_rec2, new_data = NULL)
tidy(dummy_multi_choice_rec2, number = 1)
</code></pre>

<hr>
<h2 id='step_factor2string'>Convert factors to strings</h2><span id='topic+step_factor2string'></span>

<h3>Description</h3>

<p><code>step_factor2string()</code> creates a <em>specification</em> of a recipe step that will
convert one or more factor vectors to strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_factor2string(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = FALSE,
  skip = FALSE,
  id = rand_id("factor2string")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_factor2string_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_factor2string_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_factor2string_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_factor2string_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_factor2string_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_factor2string_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_factor2string_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+prep">prep()</a></code> has an option <code>strings_as_factors</code> that defaults to <code>TRUE</code>. If this
step is used with the default option, the strings produced by this step will
not be converted to factors.
</p>
<p>Remember that categorical data that will be directly passed to a model should
be encoded as factors. This step is helpful for ancillary columns (such as
identifiers) that will not be computed on in the model.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

rec &lt;- recipe(~ city + zip, data = Sacramento)

make_string &lt;- rec %&gt;%
  step_factor2string(city)

make_string &lt;- prep(make_string,
  training = Sacramento,
  strings_as_factors = FALSE
)

make_string

# note that `city` is a string in recipe output
bake(make_string, new_data = NULL) %&gt;% head()

# ...but remains a factor in the original data
Sacramento %&gt;% head()

</code></pre>

<hr>
<h2 id='step_filter'>Filter rows using dplyr</h2><span id='topic+step_filter'></span>

<h3>Description</h3>

<p><code>step_filter()</code> creates a <em>specification</em> of a recipe step that will remove
rows using <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_filter(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  inputs = NULL,
  skip = TRUE,
  id = rand_id("filter")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_filter_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_filter_+3A_...">...</code></td>
<td>
<p>Logical predicates defined in terms of the variables
in the data. Multiple conditions are combined with <code>&amp;</code>. Only
rows where the condition evaluates to <code>TRUE</code> are kept. See
<code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_filter_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_filter_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_filter_+3A_inputs">inputs</code></td>
<td>
<p>Quosure of values given by <code>...</code>.</p>
</td></tr>
<tr><td><code id="step_filter_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_filter_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an object in the user's global environment is
referenced in the expression defining the new variable(s),
it is a good idea to use quasiquotation (e.g. <code style="white-space: pre;">&#8288;!!&#8288;</code>) to embed
the value of the object in the expression (to be portable
between sessions). See the examples.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Row Filtering</h3>

<p>This step can entirely remove observations (rows of data), which can have
unintended and/or problematic consequences when applying the step to new
data later via <code><a href="#topic+bake">bake()</a></code>. Consider whether <code>skip = TRUE</code> or
<code>skip = FALSE</code> is more appropriate in any given use case. In most instances
that affect the rows of the data being predicted, this step probably should
not be applied at all; instead, execute operations like this outside and
before starting a preprocessing <code><a href="#topic+recipe">recipe()</a></code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>

<p>The expressions in <code>terms</code> are text representations and are not parsable.
</p>


<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other row operation steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>,
<code><a href="#topic+step_lag">step_lag</a>()</code>,
<code><a href="#topic+step_naomit">step_naomit</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_shuffle">step_shuffle</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>
<p>Other dplyr steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_rename_at">step_rename_at</a>()</code>,
<code><a href="#topic+step_rename">step_rename</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rec &lt;- recipe(~., data = iris) %&gt;%
  step_filter(Sepal.Length &gt; 4.5, Species == "setosa")

prepped &lt;- prep(rec, training = iris %&gt;% slice(1:75))

library(dplyr)

dplyr_train &lt;-
  iris %&gt;%
  as_tibble() %&gt;%
  slice(1:75) %&gt;%
  dplyr::filter(Sepal.Length &gt; 4.5, Species == "setosa")

rec_train &lt;- bake(prepped, new_data = NULL)
all.equal(dplyr_train, rec_train)

dplyr_test &lt;-
  iris %&gt;%
  as_tibble() %&gt;%
  slice(76:150) %&gt;%
  dplyr::filter(Sepal.Length &gt; 4.5, Species != "setosa")
rec_test &lt;- bake(prepped, iris %&gt;% slice(76:150))
all.equal(dplyr_test, rec_test)

values &lt;- c("versicolor", "virginica")

qq_rec &lt;-
  recipe(~., data = iris) %&gt;%
  # Embed the `values` object in the call using !!
  step_filter(Sepal.Length &gt; 4.5, Species %in% !!values)

tidy(qq_rec, number = 1)
</code></pre>

<hr>
<h2 id='step_filter_missing'>Missing value column filter</h2><span id='topic+step_filter_missing'></span>

<h3>Description</h3>

<p><code>step_filter_missing()</code> creates a <em>specification</em> of a recipe step that will
potentially remove variables that have too many missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_filter_missing(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  threshold = 0.1,
  removals = NULL,
  skip = FALSE,
  id = rand_id("filter_missing")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_filter_missing_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_filter_missing_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_filter_missing_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_filter_missing_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_filter_missing_+3A_threshold">threshold</code></td>
<td>
<p>A value for the threshold of missing values in column. The
step will remove the columns where the proportion of missing values
exceeds the threshold.</p>
</td></tr>
<tr><td><code id="step_filter_missing_+3A_removals">removals</code></td>
<td>
<p>A character string that contains the names of
columns that should be removed. These values are not determined
until <code><a href="#topic+prep">prep()</a></code> is called.</p>
</td></tr>
<tr><td><code id="step_filter_missing_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_filter_missing_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step can potentially remove columns from the data set. This may
cause issues for subsequent steps in your recipe if the missing columns are
specifically referenced by name. To avoid this, see the advice in the
<em>Tips for saving recipes and filtering columns</em> section of <a href="#topic+selections">selections</a>.
</p>
<p>This step will remove variables if the proportion of missing
values exceeds the <code>threshold</code>.
</p>
<p>All variables with missing values will be removed for <code>threshold = 0</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>threshold</code>: Threshold (type: double, default: 0.1)
</p>
</li></ul>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other variable filter steps: 
<code><a href="#topic+step_corr">step_corr</a>()</code>,
<code><a href="#topic+step_lincomb">step_lincomb</a>()</code>,
<code><a href="#topic+step_nzv">step_nzv</a>()</code>,
<code><a href="#topic+step_rm">step_rm</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_zv">step_zv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(credit_data, package = "modeldata")

rec &lt;- recipe(Status ~ ., data = credit_data) %&gt;%
  step_filter_missing(all_predictors(), threshold = 0)

filter_obj &lt;- prep(rec)

filtered_te &lt;- bake(filter_obj, new_data = NULL)

tidy(rec, number = 1)
tidy(filter_obj, number = 1)

</code></pre>

<hr>
<h2 id='step_geodist'>Distance between two locations</h2><span id='topic+step_geodist'></span>

<h3>Description</h3>

<p><code>step_geodist()</code> creates a <em>specification</em> of a recipe step that will
calculate the distance between points on a map to a reference location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_geodist(
  recipe,
  lat = NULL,
  lon = NULL,
  role = "predictor",
  trained = FALSE,
  ref_lat = NULL,
  ref_lon = NULL,
  is_lat_lon = TRUE,
  log = FALSE,
  name = "geo_dist",
  columns = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("geodist")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_geodist_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_lon">lon</code>, <code id="step_geodist_+3A_lat">lat</code></td>
<td>
<p>Selector functions to choose which variables are
used by the step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_ref_lon">ref_lon</code>, <code id="step_geodist_+3A_ref_lat">ref_lat</code></td>
<td>
<p>Single numeric values for the location
of the reference point.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_is_lat_lon">is_lat_lon</code></td>
<td>
<p>A logical: Are coordinates in latitude and longitude? If
<code>TRUE</code> the Haversine formula is used and the returned result is meters. If
<code>FALSE</code> the Pythagorean formula is used. Default is <code>TRUE</code> and for recipes
created from previous versions of recipes, a value of <code>FALSE</code> is used.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_log">log</code></td>
<td>
<p>A logical: should the distance be transformed by
the natural log function?</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_name">name</code></td>
<td>
<p>A single character value to use for the new
predictor column. If a column exists with this name, an error is
issued.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_geodist_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_geodist</code> uses the Pythagorean theorem to calculate Euclidean
distances if <code>is_lat_lon</code> is FALSE. If <code>is_lat_lon</code> is TRUE, the Haversine
formula is used to calculate the great-circle distance in meters.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>latitude</code>, <code>longitude</code>, <code>ref_latitude</code>, <code>ref_longitude</code>,
<code>is_lat_lon</code>, <code>name</code> , and <code>id</code>:
</p>

<dl>
<dt>latitude</dt><dd><p>character, name of latitude variable</p>
</dd>
<dt>longitude</dt><dd><p>character, name of longitude variable</p>
</dd>
<dt>ref_latitude</dt><dd><p>numeric, location of latitude reference point</p>
</dd>
<dt>ref_longitude</dt><dd><p>numeric, location of longitude reference point</p>
</dd>
<dt>is_lat_lon</dt><dd><p>character, the summary function name</p>
</dd>
<dt>name</dt><dd><p>character, name of resulting variable</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Haversine_formula
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Smithsonian, package = "modeldata")

# How close are the museums to Union Station?
near_station &lt;- recipe(~., data = Smithsonian) %&gt;%
  update_role(name, new_role = "location") %&gt;%
  step_geodist(
    lat = latitude, lon = longitude, log = FALSE,
    ref_lat = 38.8986312, ref_lon = -77.0062457,
    is_lat_lon = TRUE
  ) %&gt;%
  prep(training = Smithsonian)

bake(near_station, new_data = NULL) %&gt;%
  arrange(geo_dist)

tidy(near_station, number = 1)

</code></pre>

<hr>
<h2 id='step_harmonic'>Add sin and cos terms for harmonic analysis</h2><span id='topic+step_harmonic'></span>

<h3>Description</h3>

<p><code>step_harmonic()</code> creates a <em>specification</em> of a recipe step that will add
<code>sin()</code> and <code>cos()</code> terms for harmonic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_harmonic(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  frequency = NA_real_,
  cycle_size = NA_real_,
  starting_val = NA_real_,
  keep_original_cols = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("harmonic")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_harmonic_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details. This will
typically be a single variable.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_frequency">frequency</code></td>
<td>
<p>A numeric vector with at least one value.
The value(s) must be greater than zero and finite.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_cycle_size">cycle_size</code></td>
<td>
<p>A numeric vector with at least one value that indicates
the size of a single cycle. <code>cycle_size</code> should have the same units as the
input variable(s).</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_starting_val">starting_val</code></td>
<td>
<p>either <code>NA</code>, numeric, Date or POSIXt value(s) that indicates
the reference point for the sin and cos curves for each input variable.
If the value is a <code>Date</code> or <code>POISXt</code> the value is converted to numeric
using <code>as.numeric</code>. This parameter may be specified to increase control
over the signal phase.  If <code>starting_val</code> is not specified the default
is 0.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_harmonic_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step seeks to describe periodic components of observational
data using a combination of sin and cos waves. To do this, each wave of a
specified frequency is modeled using one sin and one cos term. The two
terms for each frequency can then be used to estimate the amplitude and
phase shift of a periodic signal in observational data. The equation
relating cos waves of known frequency but unknown phase and amplitude to a
sum of sin and cos terms is below:
</p>
<p style="text-align: center;"><code class="reqn">A_j cos(\sigma_j t_i - \Phi_j) = C_j cos(\sigma_j t_i) + S_j sin(\sigma_j t_i)</code>
</p>

<p>Solving the equation yields <code class="reqn">C_j</code> and <code class="reqn">S_j</code>. the
amplitude can then be obtained with:
</p>
<p style="text-align: center;"><code class="reqn">A_j = \sqrt{C^2_j + S^2_j}</code>
</p>

<p>And the phase can be obtained with:
</p>
<p style="text-align: center;"><code class="reqn">\Phi_j = \arctan{(S_j / C_j)}</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">\sigma_j = 2 \pi (frequency / cycle\_size))</code>
</p>
</li>
<li> <p><code class="reqn">A_j</code> is the amplitude of the <code class="reqn">j^{th}</code> frequency
</p>
</li>
<li> <p><code class="reqn">\Phi_j</code> is the phase of the <code class="reqn">j^{th}</code> frequency
</p>
</li>
<li> <p><code class="reqn">C_j</code> is the coefficient of the cos term for the <code class="reqn">j^{th}</code> frequency
</p>
</li>
<li> <p><code class="reqn">S_j</code> is the coefficient of the sin term for the <code class="reqn">j^{th}</code> frequency
</p>
</li></ul>

<p>The periodic component is specified by <code>frequency</code> and <code>cycle_size</code>
parameters. The cycle size relates the specified frequency to the
input column(s) units. There are multiple ways to specify a wave of given
frequency, for example, a <code>POSIXct</code> input column given a <code>frequency</code> of
24 and a <code>cycle_size</code> equal to 86400 is equivalent to a <code>frequency</code> of
1.0 with <code>cycle_size</code> equal to 3600.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>frequency</code>: Harmonic Frequency (type: double, default: NA)
</p>
</li></ul>



<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>starting_val</code>, <code>cycle_size</code>, <code>frequency</code>, <code>key</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>starting_val</dt><dd><p>numeric, the starting value</p>
</dd>
<dt>cycle_size</dt><dd><p>numeric, the cycle size</p>
</dd>
<dt>frequency</dt><dd><p>numeric, the frequency</p>
</dd>
<dt>key</dt><dd><p>character, key describing the calculation</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Doran, H. E., &amp; Quilkey, J. J. (1972).
Harmonic analysis of seasonal data: some important properties.
American Journal of Agricultural Economics, 54, volume 4, part 1, 646-651.
</p>
<p>Foreman, M. G. G., &amp; Henry, R. F. (1989).
The harmonic analysis of tidal model time series.
Advances in water resources, 12(3), 109-120.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2, quietly = TRUE)
library(dplyr)

data(sunspot.year)
sunspots &lt;-
  tibble(
    year = 1700:1988,
    n_sunspot = sunspot.year,
    type = "measured"
  ) %&gt;%
  slice(1:75)

# sunspots period is around 11 years, sample spacing is one year
dat &lt;- recipe(n_sunspot ~ year, data = sunspots) %&gt;%
  step_harmonic(year, frequency = 1 / 11, cycle_size = 1) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL)

fit &lt;- lm(n_sunspot ~ year_sin_1 + year_cos_1, data = dat)

preds &lt;- tibble(
  year = sunspots$year,
  n_sunspot = fit$fitted.values,
  type = "predicted"
)

bind_rows(sunspots, preds) %&gt;%
  ggplot(aes(x = year, y = n_sunspot, color = type)) +
  geom_line()


# ------------------------------------------------------------------------------
# POSIXct example

date_time &lt;-
  as.POSIXct(
    paste0(rep(1959:1997, each = 12), "-", rep(1:12, length(1959:1997)), "-01"),
    tz = "UTC"
  )

carbon_dioxide &lt;- tibble(
  date_time = date_time,
  co2 = as.numeric(co2),
  type = "measured"
)

# yearly co2 fluctuations
dat &lt;-
  recipe(co2 ~ date_time,
    data = carbon_dioxide
  ) %&gt;%
  step_mutate(date_time_num = as.numeric(date_time)) %&gt;%
  step_ns(date_time_num, deg_free = 3) %&gt;%
  step_harmonic(date_time, frequency = 1, cycle_size = 86400 * 365.24) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL)

fit &lt;- lm(co2 ~ date_time_num_ns_1 + date_time_num_ns_2 +
  date_time_num_ns_3 + date_time_sin_1 +
  date_time_cos_1, data = dat)

preds &lt;- tibble(
  date_time = date_time,
  co2 = fit$fitted.values,
  type = "predicted"
)

bind_rows(carbon_dioxide, preds) %&gt;%
  ggplot(aes(x = date_time, y = co2, color = type)) +
  geom_line()

</code></pre>

<hr>
<h2 id='step_holiday'>Holiday feature generator</h2><span id='topic+step_holiday'></span>

<h3>Description</h3>

<p><code>step_holiday()</code> creates a <em>specification</em> of a recipe step that will convert
date data into one or more binary indicator variables for common holidays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_holiday(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  holidays = c("LaborDay", "NewYearsDay", "ChristmasDay"),
  columns = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("holiday")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_holiday_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_holiday_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. The selected variables should have class <code>Date</code> or
<code>POSIXct</code>. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_holiday_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_holiday_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_holiday_+3A_holidays">holidays</code></td>
<td>
<p>A character string that includes at least one
holiday supported by the <code>timeDate</code> package. See
<code><a href="timeDate.html#topic+holiday-Listing">timeDate::listHolidays()</a></code> for a complete list.</p>
</td></tr>
<tr><td><code id="step_holiday_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_holiday_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="step_holiday_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_holiday_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike some other steps, <code>step_holiday</code> does <em>not</em>
remove the original date variables by default. Set <code>keep_original_cols</code>
to <code>FALSE</code> to remove them.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>holiday</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>holiday</dt><dd><p>character, name of holidays</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="timeDate.html#topic+holiday-Listing">timeDate::listHolidays()</a></code>
</p>
<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

examples &lt;- data.frame(someday = ymd("2000-12-20") + days(0:40))
holiday_rec &lt;- recipe(~someday, examples) %&gt;%
  step_holiday(all_predictors())

holiday_rec &lt;- prep(holiday_rec, training = examples)
holiday_values &lt;- bake(holiday_rec, new_data = examples)
holiday_values
</code></pre>

<hr>
<h2 id='step_hyperbolic'>Hyperbolic transformations</h2><span id='topic+step_hyperbolic'></span>

<h3>Description</h3>

<p><code>step_hyperbolic()</code> creates a <em>specification</em> of a recipe step that will
transform data using a hyperbolic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_hyperbolic(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  func = c("sinh", "cosh", "tanh"),
  inverse = TRUE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("hyperbolic")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_hyperbolic_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_hyperbolic_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_hyperbolic_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_hyperbolic_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_hyperbolic_+3A_func">func</code></td>
<td>
<p>A character value for the function. Valid values
are &quot;sinh&quot;, &quot;cosh&quot;, or &quot;tanh&quot;.</p>
</td></tr>
<tr><td><code id="step_hyperbolic_+3A_inverse">inverse</code></td>
<td>
<p>A logical: should the inverse function be used?</p>
</td></tr>
<tr><td><code id="step_hyperbolic_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_hyperbolic_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_hyperbolic_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>inverse</code>, <code>func</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>inverse</dt><dd><p>logical, is the inverse function be used</p>
</dd>
<dt>func</dt><dd><p>character, name of function. <code>"sinh"</code>, <code>"cosh"</code>, or <code>"tanh"</code></p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(313)
examples &lt;- matrix(rnorm(40), ncol = 2)
examples &lt;- as.data.frame(examples)

rec &lt;- recipe(~ V1 + V2, data = examples)

cos_trans &lt;- rec %&gt;%
  step_hyperbolic(
    all_numeric_predictors(),
    func = "cosh", inverse = FALSE
  )

cos_obj &lt;- prep(cos_trans, training = examples)

transformed_te &lt;- bake(cos_obj, examples)
plot(examples$V1, transformed_te$V1)

tidy(cos_trans, number = 1)
tidy(cos_obj, number = 1)
</code></pre>

<hr>
<h2 id='step_ica'>ICA signal extraction</h2><span id='topic+step_ica'></span>

<h3>Description</h3>

<p><code>step_ica()</code> creates a <em>specification</em> of a recipe step that will convert
numeric data into one or more independent components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ica(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_comp = 5,
  options = list(method = "C"),
  seed = sample.int(10000, 5),
  res = NULL,
  columns = NULL,
  prefix = "IC",
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("ica")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ica_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_num_comp">num_comp</code></td>
<td>
<p>The number of components to retain as new predictors.
If <code>num_comp</code> is greater than the number of columns or the number of
possible components, a smaller value will be used. If <code>num_comp = 0</code>
is set then no transformation is done and selected variables will
stay unchanged, regardless of the value of <code>keep_original_cols</code>.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_options">options</code></td>
<td>
<p>A list of options to
<code><a href="fastICA.html#topic+fastICA">fastICA::fastICA()</a></code>. No defaults are set here.
<strong>Note</strong> that the arguments <code>X</code> and <code>n.comp</code> should
not be passed here.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_seed">seed</code></td>
<td>
<p>A single integer to set the random number stream prior to
running ICA.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_res">res</code></td>
<td>
<p>The <code><a href="fastICA.html#topic+fastICA">fastICA::fastICA()</a></code> object is stored
here once this preprocessing step has be trained by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_ica_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Independent component analysis (ICA) is a
transformation of a group of variables that produces a new set
of artificial features or components. ICA assumes that the
variables are mixtures of a set of distinct, non-Gaussian
signals and attempts to transform the data to isolate these
signals. Like PCA, the components are statistically independent
from one another. This means that they can be used to combat
large inter-variables correlations in a data set. Also like PCA,
it is advisable to center and scale the variables prior to
running ICA.
</p>
<p>This package produces components using the &quot;FastICA&quot;
methodology (see reference below). This step requires the
<span class="pkg">dimRed</span> and <span class="pkg">fastICA</span> packages. If not installed, the
step will stop with a note about installing these packages.
</p>
<p>The argument <code>num_comp</code> controls the number of components that will be retained
(the original variables that are used to derive the components are removed from
the data). The new components will have names that begin with <code>prefix</code> and a
sequence of numbers. The variable names are padded with zeros. For example, if
<code>num_comp &lt; 10</code>, their names will be <code>IC1</code> - <code>IC9</code>. If <code>num_comp = 101</code>,
the names would be <code>IC1</code> - <code>IC101</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>component</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>component</dt><dd><p>character, name of component</p>
</dd>
<dt>value</dt><dd><p>numeric, the loading</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>num_comp</code>: # Components (type: integer, default: 5)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Hyvarinen, A., and Oja, E. (2000). Independent
component analysis: algorithms and applications. <em>Neural
Networks</em>, 13(4-5), 411-430.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# from fastICA::fastICA
set.seed(131)
S &lt;- matrix(runif(400), 200, 2)
A &lt;- matrix(c(1, 1, -1, 3), 2, 2, byrow = TRUE)
X &lt;- as.data.frame(S %*% A)

tr &lt;- X[1:100, ]
te &lt;- X[101:200, ]

rec &lt;- recipe(~., data = tr)

ica_trans &lt;- step_center(rec, V1, V2)
ica_trans &lt;- step_scale(ica_trans, V1, V2)
ica_trans &lt;- step_ica(ica_trans, V1, V2, num_comp = 2)

ica_estimates &lt;- prep(ica_trans, training = tr)
ica_data &lt;- bake(ica_estimates, te)

plot(te$V1, te$V2)
plot(ica_data$IC1, ica_data$IC2)

tidy(ica_trans, number = 3)
tidy(ica_estimates, number = 3)

</code></pre>

<hr>
<h2 id='step_impute_bag'>Impute via bagged trees</h2><span id='topic+step_impute_bag'></span><span id='topic+step_bagimpute'></span><span id='topic+imp_vars'></span>

<h3>Description</h3>

<p><code>step_impute_bag()</code> creates a <em>specification</em> of a recipe step that will
create bagged tree models to impute missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_impute_bag(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  impute_with = imp_vars(all_predictors()),
  trees = 25,
  models = NULL,
  options = list(keepX = FALSE),
  seed_val = sample.int(10^4, 1),
  skip = FALSE,
  id = rand_id("impute_bag")
)

step_bagimpute(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  impute_with = imp_vars(all_predictors()),
  trees = 25,
  models = NULL,
  options = list(keepX = FALSE),
  seed_val = sample.int(10^4, 1),
  skip = FALSE,
  id = rand_id("impute_bag")
)

imp_vars(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_impute_bag_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables to be imputed.
When used with <code>imp_vars</code>, these dots indicate which variables are used to
predict the missing data in each variable. See <code><a href="#topic+selections">selections()</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_impute_with">impute_with</code></td>
<td>
<p>A call to <code>imp_vars</code> to specify which variables are used
to impute the variables that can include specific variable names separated
by commas or different selectors (see <code><a href="#topic+selections">selections()</a></code>). If a column is
included in both lists to be imputed and to be an imputation predictor, it
will be removed from the latter and not used to impute itself.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_trees">trees</code></td>
<td>
<p>An integer for the number of bagged trees to use in each model.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_models">models</code></td>
<td>
<p>The <code><a href="ipred.html#topic+bagging">ipred::ipredbagg()</a></code> objects are stored here once this
bagged trees have be trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_options">options</code></td>
<td>
<p>A list of options to <code><a href="ipred.html#topic+bagging">ipred::ipredbagg()</a></code>. Defaults are set
for the arguments <code>nbagg</code> and <code>keepX</code> but others can be passed in. <strong>Note</strong>
that the arguments <code>X</code> and <code>y</code> should not be passed here.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_seed_val">seed_val</code></td>
<td>
<p>An integer used to create reproducible models. The same seed
is used across all imputation models.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_impute_bag_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable requiring imputation, a bagged tree is created
where the outcome is the variable of interest and the predictors are any
other variables listed in the <code>impute_with</code> formula. One advantage to the
bagged tree is that is can accept predictors that have missing values
themselves. This imputation method can be used when the variable of interest
(and predictors) are numeric or categorical. Imputed categorical variables
will remain categorical. Also, integers will be imputed to integer too.
</p>
<p>Note that if a variable that is to be imputed is also in <code>impute_with</code>,
this variable will be ignored.
</p>
<p>It is possible that missing values will still occur after imputation if a
large majority (or all) of the imputing variables are also missing.
</p>
<p>As of <code>recipes</code> 0.1.16, this function name changed from <code>step_bagimpute()</code>
to <code>step_impute_bag()</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble with columns
<code>terms</code> (the selectors or variables selected) and <code>model</code>
(the bagged tree object) is returned.
</p>
<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>model</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>model</dt><dd><p>list, the bagged tree object</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>trees</code>: # Trees (type: integer, default: 25)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Kuhn, M. and Johnson, K. (2013). <em>Applied Predictive Modeling</em>.
Springer Verlag.
</p>


<h3>See Also</h3>

<p>Other imputation steps: 
<code><a href="#topic+step_impute_knn">step_impute_knn</a>()</code>,
<code><a href="#topic+step_impute_linear">step_impute_linear</a>()</code>,
<code><a href="#topic+step_impute_lower">step_impute_lower</a>()</code>,
<code><a href="#topic+step_impute_mean">step_impute_mean</a>()</code>,
<code><a href="#topic+step_impute_median">step_impute_median</a>()</code>,
<code><a href="#topic+step_impute_mode">step_impute_mode</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("credit_data", package = "modeldata")

## missing data per column
vapply(credit_data, function(x) mean(is.na(x)), c(num = 0))

set.seed(342)
in_training &lt;- sample(1:nrow(credit_data), 2000)

credit_tr &lt;- credit_data[in_training, ]
credit_te &lt;- credit_data[-in_training, ]
missing_examples &lt;- c(14, 394, 565)

rec &lt;- recipe(Price ~ ., data = credit_tr)
## Not run: 
impute_rec &lt;- rec %&gt;%
  step_impute_bag(Status, Home, Marital, Job, Income, Assets, Debt)

imp_models &lt;- prep(impute_rec, training = credit_tr)

imputed_te &lt;- bake(imp_models, new_data = credit_te, everything())

credit_te[missing_examples, ]
imputed_te[missing_examples, names(credit_te)]

tidy(impute_rec, number = 1)
tidy(imp_models, number = 1)

## Specifying which variables to imputate with

impute_rec &lt;- rec %&gt;%
  step_impute_bag(Status, Home, Marital, Job, Income, Assets, Debt,
    impute_with = imp_vars(Time, Age, Expenses),
    # for quick execution, nbagg lowered
    options = list(nbagg = 5, keepX = FALSE)
  )

imp_models &lt;- prep(impute_rec, training = credit_tr)

imputed_te &lt;- bake(imp_models, new_data = credit_te, everything())

credit_te[missing_examples, ]
imputed_te[missing_examples, names(credit_te)]

tidy(impute_rec, number = 1)
tidy(imp_models, number = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='step_impute_knn'>Impute via k-nearest neighbors</h2><span id='topic+step_impute_knn'></span><span id='topic+step_knnimpute'></span>

<h3>Description</h3>

<p><code>step_impute_knn()</code> creates a <em>specification</em> of a recipe step that will
impute missing data using nearest neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_impute_knn(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  neighbors = 5,
  impute_with = imp_vars(all_predictors()),
  options = list(nthread = 1, eps = 1e-08),
  ref_data = NULL,
  columns = NULL,
  skip = FALSE,
  id = rand_id("impute_knn")
)

step_knnimpute(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  neighbors = 5,
  impute_with = imp_vars(all_predictors()),
  options = list(nthread = 1, eps = 1e-08),
  ref_data = NULL,
  columns = NULL,
  skip = FALSE,
  id = rand_id("impute_knn")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_impute_knn_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables to be imputed.
When used with <code>imp_vars</code>, these dots indicate which variables are used to
predict the missing data in each variable. See <code><a href="#topic+selections">selections()</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_neighbors">neighbors</code></td>
<td>
<p>The number of neighbors.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_impute_with">impute_with</code></td>
<td>
<p>A call to <code>imp_vars</code> to specify which variables are used
to impute the variables that can include specific variable names separated
by commas or different selectors (see <code><a href="#topic+selections">selections()</a></code>). If a column is
included in both lists to be imputed and to be an imputation predictor, it
will be removed from the latter and not used to impute itself.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_options">options</code></td>
<td>
<p>A named list of options to pass to <code><a href="gower.html#topic+gower_topn">gower::gower_topn()</a></code>.
Available options are currently <code>nthread</code> and <code>eps</code>.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_ref_data">ref_data</code></td>
<td>
<p>A tibble of data that will reflect the data preprocessing
done up to the point of this imputation step. This is <code>NULL</code> until the step
is trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_impute_knn_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The step uses the training set to impute any other data sets. The
only distance function available is Gower's distance which can be used for
mixtures of nominal and numeric data.
</p>
<p>Once the nearest neighbors are determined, the mode is used to predictor
nominal variables and the mean is used for numeric data. Note that, if the
underlying data are integer, the mean will be converted to an integer too.
</p>
<p>Note that if a variable that is to be imputed is also in <code>impute_with</code>,
this variable will be ignored.
</p>
<p>It is possible that missing values will still occur after imputation if a
large majority (or all) of the imputing variables are also missing.
</p>
<p>As of <code>recipes</code> 0.1.16, this function name changed from <code>step_knnimpute()</code>
to <code>step_impute_knn()</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>predictors</code>, <code>neighbors</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>predictors</dt><dd><p>character, selected predictors used to impute</p>
</dd>
<dt>neighbors</dt><dd><p>integer, number of neighbors</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>neighbors</code>: # Nearest Neighbors (type: integer, default: 5)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Gower, C. (1971) &quot;A general coefficient of similarity and some
of its properties,&quot; Biometrics, 857-871.
</p>


<h3>See Also</h3>

<p>Other imputation steps: 
<code><a href="#topic+step_impute_bag">step_impute_bag</a>()</code>,
<code><a href="#topic+step_impute_linear">step_impute_linear</a>()</code>,
<code><a href="#topic+step_impute_lower">step_impute_lower</a>()</code>,
<code><a href="#topic+step_impute_mean">step_impute_mean</a>()</code>,
<code><a href="#topic+step_impute_median">step_impute_median</a>()</code>,
<code><a href="#topic+step_impute_mode">step_impute_mode</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]
biomass_te_whole &lt;- biomass_te

# induce some missing data at random
set.seed(9039)
carb_missing &lt;- sample(1:nrow(biomass_te), 3)
nitro_missing &lt;- sample(1:nrow(biomass_te), 3)

biomass_te$carbon[carb_missing] &lt;- NA
biomass_te$nitrogen[nitro_missing] &lt;- NA

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

ratio_recipe &lt;- rec %&gt;%
  step_impute_knn(all_predictors(), neighbors = 3)
ratio_recipe2 &lt;- prep(ratio_recipe, training = biomass_tr)
imputed &lt;- bake(ratio_recipe2, biomass_te)

# how well did it work?
summary(biomass_te_whole$carbon)
cbind(
  before = biomass_te_whole$carbon[carb_missing],
  after = imputed$carbon[carb_missing]
)

summary(biomass_te_whole$nitrogen)
cbind(
  before = biomass_te_whole$nitrogen[nitro_missing],
  after = imputed$nitrogen[nitro_missing]
)

tidy(ratio_recipe, number = 1)
tidy(ratio_recipe2, number = 1)

</code></pre>

<hr>
<h2 id='step_impute_linear'>Impute numeric variables via a linear model</h2><span id='topic+step_impute_linear'></span>

<h3>Description</h3>

<p><code>step_impute_linear()</code> creates a <em>specification</em> of a recipe step that will
create linear regression models to impute missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_impute_linear(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  impute_with = imp_vars(all_predictors()),
  models = NULL,
  skip = FALSE,
  id = rand_id("impute_linear")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_impute_linear_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_impute_linear_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables to be imputed;
these variables <strong>must</strong> be of type <code>numeric</code>. When used with <code>imp_vars</code>,
these dots indicate which variables are used to predict the missing data
in each variable. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_impute_linear_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_impute_linear_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_impute_linear_+3A_impute_with">impute_with</code></td>
<td>
<p>A call to <code>imp_vars</code> to specify which variables are used
to impute the variables that can include specific variable names separated
by commas or different selectors (see <code><a href="#topic+selections">selections()</a></code>). If a column is
included in both lists to be imputed and to be an imputation predictor, it
will be removed from the latter and not used to impute itself.</p>
</td></tr>
<tr><td><code id="step_impute_linear_+3A_models">models</code></td>
<td>
<p>The <code><a href="stats.html#topic+lm">lm()</a></code> objects are stored here once the linear models
have been trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_impute_linear_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_impute_linear_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable requiring imputation, a linear model is fit
where the outcome is the variable of interest and the predictors are any
other variables listed in the <code>impute_with</code> formula. Note that if a variable
that is to be imputed is also in <code>impute_with</code>, this variable will be ignored.
</p>
<p>The variable(s) to be imputed must be of type <code>numeric</code>. The imputed values
will keep the same type as their original data (i.e, model predictions are
coerced to integer as needed).
</p>
<p>Since this is a linear regression, the imputation model only uses complete
cases for the training set predictors.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>model</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>model</dt><dd><p>list, list of fitted <code>lm()</code> models</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>References</h3>

<p>Kuhn, M. and Johnson, K. (2013).
<em>Feature Engineering and Selection</em>
<a href="https://bookdown.org/max/FES/handling-missing-data.html">https://bookdown.org/max/FES/handling-missing-data.html</a>
</p>


<h3>See Also</h3>

<p>Other imputation steps: 
<code><a href="#topic+step_impute_bag">step_impute_bag</a>()</code>,
<code><a href="#topic+step_impute_knn">step_impute_knn</a>()</code>,
<code><a href="#topic+step_impute_lower">step_impute_lower</a>()</code>,
<code><a href="#topic+step_impute_mean">step_impute_mean</a>()</code>,
<code><a href="#topic+step_impute_median">step_impute_median</a>()</code>,
<code><a href="#topic+step_impute_mode">step_impute_mode</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")
set.seed(393)
ames_missing &lt;- ames
ames_missing$Longitude[sample(1:nrow(ames), 200)] &lt;- NA

imputed_ames &lt;-
  recipe(Sale_Price ~ ., data = ames_missing) %&gt;%
  step_impute_linear(
    Longitude,
    impute_with = imp_vars(Latitude, Neighborhood, MS_Zoning, Alley)
  ) %&gt;%
  prep(ames_missing)

imputed &lt;-
  bake(imputed_ames, new_data = ames_missing) %&gt;%
  dplyr::rename(imputed = Longitude) %&gt;%
  bind_cols(ames %&gt;% dplyr::select(original = Longitude)) %&gt;%
  bind_cols(ames_missing %&gt;% dplyr::select(Longitude)) %&gt;%
  dplyr::filter(is.na(Longitude))

library(ggplot2)
ggplot(imputed, aes(x = original, y = imputed)) +
  geom_abline(col = "green") +
  geom_point(alpha = .3) +
  coord_equal() +
  labs(title = "Imputed Values")

</code></pre>

<hr>
<h2 id='step_impute_lower'>Impute numeric data below the threshold of measurement</h2><span id='topic+step_impute_lower'></span><span id='topic+step_lowerimpute'></span>

<h3>Description</h3>

<p><code>step_impute_lower()</code> creates a <em>specification</em> of a recipe step designed for
cases where the non-negative numeric data cannot be measured below a known
value. In these cases, one method for imputing the data is to substitute the
truncated value by a random uniform number between zero and the truncation
point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_impute_lower(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  threshold = NULL,
  skip = FALSE,
  id = rand_id("impute_lower")
)

step_lowerimpute(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  threshold = NULL,
  skip = FALSE,
  id = rand_id("impute_lower")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_impute_lower_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_impute_lower_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_impute_lower_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_impute_lower_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_impute_lower_+3A_threshold">threshold</code></td>
<td>
<p>A named numeric vector of lower bounds. This is
<code>NULL</code> until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_impute_lower_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_impute_lower_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_impute_lower</code> estimates the variable minimums
from the data used in the <code>training</code> argument of <code>prep.recipe</code>.
<code>bake.recipe</code> then simulates a value for any data at the minimum
with a random uniform value between zero and the minimum.
</p>
<p>As of <code>recipes</code> 0.1.16, this function name changed from <code>step_lowerimpute()</code>
to <code>step_impute_lower()</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the estimated value</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other imputation steps: 
<code><a href="#topic+step_impute_bag">step_impute_bag</a>()</code>,
<code><a href="#topic+step_impute_knn">step_impute_knn</a>()</code>,
<code><a href="#topic+step_impute_linear">step_impute_linear</a>()</code>,
<code><a href="#topic+step_impute_mean">step_impute_mean</a>()</code>,
<code><a href="#topic+step_impute_median">step_impute_median</a>()</code>,
<code><a href="#topic+step_impute_mode">step_impute_mode</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
data(biomass, package = "modeldata")

## Truncate some values to emulate what a lower limit of
## the measurement system might look like

biomass$carbon &lt;- ifelse(biomass$carbon &gt; 40, biomass$carbon, 40)
biomass$hydrogen &lt;- ifelse(biomass$hydrogen &gt; 5, biomass$carbon, 5)

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

impute_rec &lt;- rec %&gt;%
  step_impute_lower(carbon, hydrogen)

tidy(impute_rec, number = 1)

impute_rec &lt;- prep(impute_rec, training = biomass_tr)

tidy(impute_rec, number = 1)

transformed_te &lt;- bake(impute_rec, biomass_te)

plot(transformed_te$carbon, biomass_te$carbon,
  ylab = "pre-imputation", xlab = "imputed"
)

</code></pre>

<hr>
<h2 id='step_impute_mean'>Impute numeric data using the mean</h2><span id='topic+step_impute_mean'></span><span id='topic+step_meanimpute'></span>

<h3>Description</h3>

<p><code>step_impute_mean()</code> creates a <em>specification</em> of a recipe step that will
substitute missing values of numeric variables by the training set mean of
those variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_impute_mean(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  means = NULL,
  trim = 0,
  skip = FALSE,
  id = rand_id("impute_mean")
)

step_meanimpute(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  means = NULL,
  trim = 0,
  skip = FALSE,
  id = rand_id("impute_mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_impute_mean_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_impute_mean_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_impute_mean_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_impute_mean_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_impute_mean_+3A_means">means</code></td>
<td>
<p>A named numeric vector of means. This is <code>NULL</code> until computed
by <code><a href="#topic+prep">prep()</a></code>. Note that, if the original data are integers, the mean
will be converted to an integer to maintain the same data type.</p>
</td></tr>
<tr><td><code id="step_impute_mean_+3A_trim">trim</code></td>
<td>
<p>The fraction (0 to 0.5) of observations to be trimmed from each
end of the variables before the mean is computed. Values of trim outside
that range are taken as the nearest endpoint.</p>
</td></tr>
<tr><td><code id="step_impute_mean_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_impute_mean_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_impute_mean</code> estimates the variable means from the data used
in the <code>training</code> argument of <code>prep.recipe</code>. <code>bake.recipe</code> then applies the
new values to new data sets using these averages.
</p>
<p>As of <code>recipes</code> 0.1.16, this function name changed from <code>step_meanimpute()</code>
to <code>step_impute_mean()</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the mean value</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>trim</code>: Amount of Trimming (type: double, default: 0)
</p>
</li></ul>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other imputation steps: 
<code><a href="#topic+step_impute_bag">step_impute_bag</a>()</code>,
<code><a href="#topic+step_impute_knn">step_impute_knn</a>()</code>,
<code><a href="#topic+step_impute_linear">step_impute_linear</a>()</code>,
<code><a href="#topic+step_impute_lower">step_impute_lower</a>()</code>,
<code><a href="#topic+step_impute_median">step_impute_median</a>()</code>,
<code><a href="#topic+step_impute_mode">step_impute_mode</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("credit_data", package = "modeldata")

## missing data per column
vapply(credit_data, function(x) mean(is.na(x)), c(num = 0))

set.seed(342)
in_training &lt;- sample(1:nrow(credit_data), 2000)

credit_tr &lt;- credit_data[in_training, ]
credit_te &lt;- credit_data[-in_training, ]
missing_examples &lt;- c(14, 394, 565)

rec &lt;- recipe(Price ~ ., data = credit_tr)

impute_rec &lt;- rec %&gt;%
  step_impute_mean(Income, Assets, Debt)

imp_models &lt;- prep(impute_rec, training = credit_tr)

imputed_te &lt;- bake(imp_models, new_data = credit_te, everything())

credit_te[missing_examples, ]
imputed_te[missing_examples, names(credit_te)]

tidy(impute_rec, number = 1)
tidy(imp_models, number = 1)

</code></pre>

<hr>
<h2 id='step_impute_median'>Impute numeric data using the median</h2><span id='topic+step_impute_median'></span><span id='topic+step_medianimpute'></span>

<h3>Description</h3>

<p><code>step_impute_median()</code> creates a <em>specification</em> of a recipe step that will
substitute missing values of numeric variables by the training set median of
those variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_impute_median(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  medians = NULL,
  skip = FALSE,
  id = rand_id("impute_median")
)

step_medianimpute(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  medians = NULL,
  skip = FALSE,
  id = rand_id("impute_median")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_impute_median_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_impute_median_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_impute_median_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_impute_median_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_impute_median_+3A_medians">medians</code></td>
<td>
<p>A named numeric vector of medians. This is <code>NULL</code> until
computed by <code><a href="#topic+prep">prep()</a></code>. Note that, if the original data are integers,
the median will be converted to an integer to maintain the same data type.</p>
</td></tr>
<tr><td><code id="step_impute_median_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_impute_median_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_impute_median</code> estimates the variable medians from the data
used in the <code>training</code> argument of <code>prep.recipe</code>. <code>bake.recipe</code> then applies
the new values to new data sets using these medians.
</p>
<p>As of <code>recipes</code> 0.1.16, this function name changed from
<code>step_medianimpute()</code> to <code>step_impute_median()</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the median value</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other imputation steps: 
<code><a href="#topic+step_impute_bag">step_impute_bag</a>()</code>,
<code><a href="#topic+step_impute_knn">step_impute_knn</a>()</code>,
<code><a href="#topic+step_impute_linear">step_impute_linear</a>()</code>,
<code><a href="#topic+step_impute_lower">step_impute_lower</a>()</code>,
<code><a href="#topic+step_impute_mean">step_impute_mean</a>()</code>,
<code><a href="#topic+step_impute_mode">step_impute_mode</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("credit_data", package = "modeldata")

## missing data per column
vapply(credit_data, function(x) mean(is.na(x)), c(num = 0))

set.seed(342)
in_training &lt;- sample(1:nrow(credit_data), 2000)

credit_tr &lt;- credit_data[in_training, ]
credit_te &lt;- credit_data[-in_training, ]
missing_examples &lt;- c(14, 394, 565)

rec &lt;- recipe(Price ~ ., data = credit_tr)

impute_rec &lt;- rec %&gt;%
  step_impute_median(Income, Assets, Debt)

imp_models &lt;- prep(impute_rec, training = credit_tr)

imputed_te &lt;- bake(imp_models, new_data = credit_te, everything())

credit_te[missing_examples, ]
imputed_te[missing_examples, names(credit_te)]

tidy(impute_rec, number = 1)
tidy(imp_models, number = 1)

</code></pre>

<hr>
<h2 id='step_impute_mode'>Impute nominal data using the most common value</h2><span id='topic+step_impute_mode'></span><span id='topic+step_modeimpute'></span>

<h3>Description</h3>

<p><code>step_impute_mode()</code> creates a <em>specification</em> of a recipe step that will
substitute missing values of nominal variables by the training set mode of
those variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_impute_mode(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  modes = NULL,
  ptype = NULL,
  skip = FALSE,
  id = rand_id("impute_mode")
)

step_modeimpute(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  modes = NULL,
  ptype = NULL,
  skip = FALSE,
  id = rand_id("impute_mode")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_impute_mode_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_impute_mode_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_impute_mode_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_impute_mode_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_impute_mode_+3A_modes">modes</code></td>
<td>
<p>A named character vector of modes. This is
<code>NULL</code> until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_impute_mode_+3A_ptype">ptype</code></td>
<td>
<p>A data frame prototype to cast new data sets to. This is
commonly a 0-row slice of the training set.</p>
</td></tr>
<tr><td><code id="step_impute_mode_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_impute_mode_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_impute_mode</code> estimates the variable modes
from the data used in the <code>training</code> argument of
<code>prep.recipe</code>. <code>bake.recipe</code> then applies the new
values to new data sets using these values. If the training set
data has more than one mode, one is selected at random.
</p>
<p>As of <code>recipes</code> 0.1.16, this function name changed from <code>step_modeimpute()</code>
to <code>step_impute_mode()</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>character, the mode value</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other imputation steps: 
<code><a href="#topic+step_impute_bag">step_impute_bag</a>()</code>,
<code><a href="#topic+step_impute_knn">step_impute_knn</a>()</code>,
<code><a href="#topic+step_impute_linear">step_impute_linear</a>()</code>,
<code><a href="#topic+step_impute_lower">step_impute_lower</a>()</code>,
<code><a href="#topic+step_impute_mean">step_impute_mean</a>()</code>,
<code><a href="#topic+step_impute_median">step_impute_median</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("credit_data", package = "modeldata")

## missing data per column
vapply(credit_data, function(x) mean(is.na(x)), c(num = 0))

set.seed(342)
in_training &lt;- sample(1:nrow(credit_data), 2000)

credit_tr &lt;- credit_data[in_training, ]
credit_te &lt;- credit_data[-in_training, ]
missing_examples &lt;- c(14, 394, 565)

rec &lt;- recipe(Price ~ ., data = credit_tr)

impute_rec &lt;- rec %&gt;%
  step_impute_mode(Status, Home, Marital)

imp_models &lt;- prep(impute_rec, training = credit_tr)

imputed_te &lt;- bake(imp_models, new_data = credit_te, everything())

table(credit_te$Home, imputed_te$Home, useNA = "always")

tidy(impute_rec, number = 1)
tidy(imp_models, number = 1)

</code></pre>

<hr>
<h2 id='step_impute_roll'>Impute numeric data using a rolling window statistic</h2><span id='topic+step_impute_roll'></span><span id='topic+step_rollimpute'></span>

<h3>Description</h3>

<p><code>step_impute_roll()</code> creates a <em>specification</em> of a recipe step that will
substitute missing values of numeric variables by the measure of location
(e.g. median) within a moving window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_impute_roll(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  statistic = median,
  window = 5,
  skip = FALSE,
  id = rand_id("impute_roll")
)

step_rollimpute(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  statistic = median,
  window = 5,
  skip = FALSE,
  id = rand_id("impute_roll")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_impute_roll_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_impute_roll_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables to be imputed;
these columns must be non-integer numerics (i.e., double precision).
See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_impute_roll_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_impute_roll_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_impute_roll_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_impute_roll_+3A_statistic">statistic</code></td>
<td>
<p>A function with a single argument for the data to compute
the imputed value. Only complete values will be passed to the function and
it should return a double precision value.</p>
</td></tr>
<tr><td><code id="step_impute_roll_+3A_window">window</code></td>
<td>
<p>The size of the window around a point to be imputed. Should be
an odd integer greater than one. See Details below for a discussion of
points at the ends of the series.</p>
</td></tr>
<tr><td><code id="step_impute_roll_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_impute_roll_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On the tails, the window is shifted towards the ends.
For example, for a 5-point window, the windows for the first
four points are <code>1:5</code>, <code>1:5</code>, <code>1:5</code>, and then <code>2:6</code>.
</p>
<p>When missing data are in the window, they are not passed to the
function. If all of the data in the window are missing, a
missing value is returned.
</p>
<p>The statistics are calculated on the training set values
<em>before</em> imputation. This means that if previous data within the
window are missing, their imputed values are not included in the
window data used for imputation. In other words, each imputation
does not know anything about previous imputations in the series
prior to the current point.
</p>
<p>As of <code>recipes</code> 0.1.16, this function name changed from <code>step_rollimpute()</code>
to <code>step_impute_roll()</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>window</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>window</dt><dd><p>integer, window size</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>statistic</code>: Rolling Summary Statistic (type: character, default: median)
</p>
</li>
<li> <p><code>window</code>: Window Size (type: integer, default: 5)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other imputation steps: 
<code><a href="#topic+step_impute_bag">step_impute_bag</a>()</code>,
<code><a href="#topic+step_impute_knn">step_impute_knn</a>()</code>,
<code><a href="#topic+step_impute_linear">step_impute_linear</a>()</code>,
<code><a href="#topic+step_impute_lower">step_impute_lower</a>()</code>,
<code><a href="#topic+step_impute_mean">step_impute_mean</a>()</code>,
<code><a href="#topic+step_impute_median">step_impute_median</a>()</code>,
<code><a href="#topic+step_impute_mode">step_impute_mode</a>()</code>
</p>
<p>Other row operation steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_lag">step_lag</a>()</code>,
<code><a href="#topic+step_naomit">step_naomit</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_shuffle">step_shuffle</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

set.seed(145)
example_data &lt;-
  data.frame(
    day = ymd("2012-06-07") + days(1:12),
    x1 = round(runif(12), 2),
    x2 = round(runif(12), 2),
    x3 = round(runif(12), 2)
  )
example_data$x1[c(1, 5, 6)] &lt;- NA
example_data$x2[c(1:4, 10)] &lt;- NA

library(recipes)
seven_pt &lt;- recipe(~., data = example_data) %&gt;%
  update_role(day, new_role = "time_index") %&gt;%
  step_impute_roll(all_numeric_predictors(), window = 7) %&gt;%
  prep(training = example_data)

# The training set:
bake(seven_pt, new_data = NULL)
</code></pre>

<hr>
<h2 id='step_indicate_na'>Create missing data column indicators</h2><span id='topic+step_indicate_na'></span>

<h3>Description</h3>

<p><code>step_indicate_na()</code> creates a <em>specification</em> of a recipe step that will
create and append additional binary columns to the data set to indicate which
observations are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_indicate_na(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  columns = NULL,
  prefix = "na_ind",
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("indicate_na")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_indicate_na_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_indicate_na_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_indicate_na_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_indicate_na_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_indicate_na_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_indicate_na_+3A_prefix">prefix</code></td>
<td>
<p>A character string that will be the prefix to the
resulting new variables. Defaults to &quot;na_ind&quot;.</p>
</td></tr>
<tr><td><code id="step_indicate_na_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_indicate_na_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_indicate_na_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("credit_data", package = "modeldata")

## missing data per column
purrr::map_dbl(credit_data, function(x) mean(is.na(x)))

set.seed(342)
in_training &lt;- sample(1:nrow(credit_data), 2000)

credit_tr &lt;- credit_data[in_training, ]
credit_te &lt;- credit_data[-in_training, ]

rec &lt;- recipe(Price ~ ., data = credit_tr)

impute_rec &lt;- rec %&gt;%
  step_indicate_na(Income, Assets, Debt)

imp_models &lt;- prep(impute_rec, training = credit_tr)

imputed_te &lt;- bake(imp_models, new_data = credit_te, everything())

</code></pre>

<hr>
<h2 id='step_integer'>Convert values to predefined integers</h2><span id='topic+step_integer'></span>

<h3>Description</h3>

<p><code>step_integer()</code> creates a <em>specification</em> of a recipe step that will convert
new data into a set of integers based on the original data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_integer(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  strict = TRUE,
  zero_based = FALSE,
  key = NULL,
  skip = FALSE,
  id = rand_id("integer")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_integer_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_integer_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_integer_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_integer_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_integer_+3A_strict">strict</code></td>
<td>
<p>A logical for whether the values should be returned as
integers (as opposed to double).</p>
</td></tr>
<tr><td><code id="step_integer_+3A_zero_based">zero_based</code></td>
<td>
<p>A logical for whether the integers should start at zero and
new values be appended as the largest integer.</p>
</td></tr>
<tr><td><code id="step_integer_+3A_key">key</code></td>
<td>
<p>A list that contains the information needed to
create integer variables for each variable contained in
<code>terms</code>. This is <code>NULL</code> until the step is trained by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_integer_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_integer_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_integer</code> will determine the unique values of
each variable from the training set (excluding missing values),
order them, and then assign integers to each value. When baked,
each data point is translated to its corresponding integer or a
value of zero for yet unseen data (although see the <code>zero_based</code>
argument above). Missing values propagate.
</p>
<p>Factor inputs are ordered by their levels. All others are
ordered by <code>sort</code>.
</p>
<p>Despite the name, the new values are returned as numeric unless
<code>strict = TRUE</code>, which will coerce the results to integers.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>list, a <em>list column</em> with the conversion key</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

sacr_tr &lt;- Sacramento[1:100, ]
sacr_tr$sqft[1] &lt;- NA

sacr_te &lt;- Sacramento[101:105, ]
sacr_te$sqft[1] &lt;- NA
sacr_te$city[1] &lt;- "whoville"
sacr_te$city[2] &lt;- NA

rec &lt;- recipe(type ~ ., data = sacr_tr) %&gt;%
  step_integer(all_predictors()) %&gt;%
  prep(training = sacr_tr)

bake(rec, sacr_te, all_predictors())
tidy(rec, number = 1)

</code></pre>

<hr>
<h2 id='step_interact'>Create interaction variables</h2><span id='topic+step_interact'></span>

<h3>Description</h3>

<p><code>step_interact()</code> creates a <em>specification</em> of a recipe step that will create
new columns that are interaction terms between two or more variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_interact(
  recipe,
  terms,
  role = "predictor",
  trained = FALSE,
  objects = NULL,
  sep = "_x_",
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("interact")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_interact_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_interact_+3A_terms">terms</code></td>
<td>
<p>A traditional R formula that contains interaction
terms. This can include <code>.</code> and selectors. See <code><a href="#topic+selections">selections()</a></code>
for more details, and consider using <code><a href="tidyselect.html#topic+starts_with">tidyselect::starts_with()</a></code> when
dummy variables have been created.</p>
</td></tr>
<tr><td><code id="step_interact_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_interact_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_interact_+3A_objects">objects</code></td>
<td>
<p>A list of <code>terms</code> objects for each
individual interaction.</p>
</td></tr>
<tr><td><code id="step_interact_+3A_sep">sep</code></td>
<td>
<p>A character value used to delineate variables in an
interaction (e.g. <code>var1_x_var2</code> instead of the more
traditional <code>var1:var2</code>).</p>
</td></tr>
<tr><td><code id="step_interact_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_interact_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_interact_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_interact</code> can create interactions between
variables. It is primarily intended for <strong>numeric data</strong>;
categorical variables should probably be converted to dummy
variables using <code><a href="#topic+step_dummy">step_dummy()</a></code> prior to being used for
interactions.
</p>
<p>Unlike other step functions, the <code>terms</code> argument should
be a traditional R model formula but should contain no inline
functions (e.g. <code>log</code>). For example, for predictors
<code>A</code>, <code>B</code>, and <code>C</code>, a formula such as
<code>~A:B:C</code> can be used to make a three way interaction
between the variables. If the formula contains terms other than
interactions (e.g. <code>(A+B+C)^3</code>) only the interaction terms
are retained for the design matrix.
</p>
<p>The separator between the variables defaults to &quot;<code style="white-space: pre;">&#8288;_x_&#8288;</code>&quot; so
that the three way interaction shown previously would generate a
column named <code>A_x_B_x_C</code>. This can be changed using the
<code>sep</code> argument.
</p>
<p>When dummy variables are created and are used in interactions,
selectors can help specify the interactions succinctly. For
example, suppose a factor column <code>X</code> gets converted to dummy
variables <code>x_2</code>, <code>x_3</code>, ..., <code>x_6</code> using <code><a href="#topic+step_dummy">step_dummy()</a></code>. If
you wanted an interaction with numeric column <code>z</code>, you could
create a set of specific interaction effects (e.g.
<code>x_2:z + x_3:z</code> and so on) or you could use
<code>starts_with("x_"):z</code>. When <code><a href="#topic+prep">prep()</a></code> evaluates this step,
<code>starts_with("x_")</code> resolves to <code>(x_2 + x_3 + x_4 + x_5 + x_6)</code>
so that the formula is now <code>(x_2 + x_3 + x_4 + x_5 + x_6):z</code> and
all two-way interactions are created.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(penguins, package = "modeldata")
penguins &lt;- penguins %&gt;% na.omit()

rec &lt;- recipe(flipper_length_mm ~ ., data = penguins)

int_mod_1 &lt;- rec %&gt;%
  step_interact(terms = ~ bill_depth_mm:bill_length_mm)

# specify all dummy variables succinctly with `starts_with()`
int_mod_2 &lt;- rec %&gt;%
  step_dummy(sex, species, island) %&gt;%
  step_interact(terms = ~ body_mass_g:starts_with("species"))

int_mod_1 &lt;- prep(int_mod_1, training = penguins)
int_mod_2 &lt;- prep(int_mod_2, training = penguins)

dat_1 &lt;- bake(int_mod_1, penguins)
dat_2 &lt;- bake(int_mod_2, penguins)

names(dat_1)
names(dat_2)

tidy(int_mod_1, number = 1)
tidy(int_mod_2, number = 2)

</code></pre>

<hr>
<h2 id='step_intercept'>Add intercept (or constant) column</h2><span id='topic+step_intercept'></span>

<h3>Description</h3>

<p><code>step_intercept()</code> creates a <em>specification</em> of a recipe step that will add
an intercept or constant term in the first column of a data matrix.
<code>step_intercept()</code> defaults to <em>predictor</em> role so that it is by default
only called in the bake step. Be careful to avoid unintentional transformations
when calling steps with <code>all_predictors()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_intercept(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  name = "intercept",
  value = 1L,
  skip = FALSE,
  id = rand_id("intercept")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_intercept_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_intercept_+3A_...">...</code></td>
<td>
<p>Argument ignored; included for consistency with other step
specification functions.</p>
</td></tr>
<tr><td><code id="step_intercept_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_intercept_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for preprocessing
have been estimated. Again included only for consistency.</p>
</td></tr>
<tr><td><code id="step_intercept_+3A_name">name</code></td>
<td>
<p>Character name for newly added column</p>
</td></tr>
<tr><td><code id="step_intercept_+3A_value">value</code></td>
<td>
<p>A numeric constant to fill the intercept column. Defaults to
<code>1L</code>.</p>
</td></tr>
<tr><td><code id="step_intercept_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_intercept_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)
rec_trans &lt;- recipe(HHV ~ ., data = biomass_tr[, -(1:2)]) %&gt;%
  step_intercept(value = 2) %&gt;%
  step_scale(carbon)

rec_obj &lt;- prep(rec_trans, training = biomass_tr)

with_intercept &lt;- bake(rec_obj, biomass_te)
with_intercept

</code></pre>

<hr>
<h2 id='step_inverse'>Inverse transformation</h2><span id='topic+step_inverse'></span>

<h3>Description</h3>

<p><code>step_inverse()</code> creates a <em>specification</em> of a recipe step that will inverse
transform the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_inverse(
  recipe,
  ...,
  role = NA,
  offset = 0,
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("inverse")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_inverse_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_inverse_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_inverse_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_inverse_+3A_offset">offset</code></td>
<td>
<p>An optional value to add to the data prior to
logging (to avoid <code>1/0</code>).</p>
</td></tr>
<tr><td><code id="step_inverse_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_inverse_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_inverse_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_inverse_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(313)
examples &lt;- matrix(runif(40), ncol = 2)
examples &lt;- data.frame(examples)

rec &lt;- recipe(~ X1 + X2, data = examples)

inverse_trans &lt;- rec %&gt;%
  step_inverse(all_numeric_predictors())

inverse_obj &lt;- prep(inverse_trans, training = examples)

transformed_te &lt;- bake(inverse_obj, examples)
plot(examples$X1, transformed_te$X1)

tidy(inverse_trans, number = 1)
tidy(inverse_obj, number = 1)
</code></pre>

<hr>
<h2 id='step_invlogit'>Inverse logit transformation</h2><span id='topic+step_invlogit'></span>

<h3>Description</h3>

<p><code>step_invlogit()</code> creates a <em>specification</em> of a recipe step that will
transform the data from real values to be between zero and one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_invlogit(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("invlogit")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_invlogit_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_invlogit_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_invlogit_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_invlogit_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_invlogit_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_invlogit_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_invlogit_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse logit transformation takes values on the
real line and translates them to be between zero and one using
the function <code>f(x) = 1/(1+exp(-x))</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

ilogit_trans &lt;- rec %&gt;%
  step_center(carbon, hydrogen) %&gt;%
  step_scale(carbon, hydrogen) %&gt;%
  step_invlogit(carbon, hydrogen)

ilogit_obj &lt;- prep(ilogit_trans, training = biomass_tr)

transformed_te &lt;- bake(ilogit_obj, biomass_te)
plot(biomass_te$carbon, transformed_te$carbon)

</code></pre>

<hr>
<h2 id='step_isomap'>Isomap embedding</h2><span id='topic+step_isomap'></span>

<h3>Description</h3>

<p><code>step_isomap()</code> creates a <em>specification</em> of a recipe step that uses
multidimensional scaling to convert numeric data into one or more new
dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_isomap(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_terms = 5,
  neighbors = 50,
  options = list(.mute = c("message", "output")),
  res = NULL,
  columns = NULL,
  prefix = "Isomap",
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("isomap")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_isomap_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_num_terms">num_terms</code></td>
<td>
<p>The number of isomap dimensions to retain as new
predictors. If <code>num_terms</code> is greater than the number of columns
or the number of possible dimensions, a smaller value will be
used.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_neighbors">neighbors</code></td>
<td>
<p>The number of neighbors.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_options">options</code></td>
<td>
<p>A list of options to <code><a href="dimRed.html#topic+Isomap-class">dimRed::Isomap()</a></code>.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_res">res</code></td>
<td>
<p>The <code><a href="dimRed.html#topic+Isomap-class">dimRed::Isomap()</a></code> object is stored
here once this preprocessing step has be trained by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_isomap_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Isomap is a form of multidimensional scaling (MDS).
MDS methods try to find a reduced set of dimensions such that
the geometric distances between the original data points are
preserved. This version of MDS uses nearest neighbors in the
data as a method for increasing the fidelity of the new
dimensions to the original data values.
</p>
<p>This step requires the <span class="pkg">dimRed</span>, <span class="pkg">RSpectra</span>,
<span class="pkg">igraph</span>, and <span class="pkg">RANN</span> packages. If not installed, the
step will stop with a note about installing these packages.
</p>
<p>It is advisable to center and scale the variables prior to
running Isomap (<code>step_center</code> and <code>step_scale</code> can be
used for this purpose).
</p>
<p>The argument <code>num_terms</code> controls the number of components that
will be retained (the original variables that are used to derive
the components are removed from the data). The new components
will have names that begin with <code>prefix</code> and a sequence of
numbers. The variable names are padded with zeros. For example,
if <code>num_terms &lt; 10</code>, their names will be <code>Isomap1</code> -
<code>Isomap9</code>. If <code>num_terms = 101</code>, the names would be
<code>Isomap001</code> - <code>Isomap101</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>  , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>num_terms</code>: # Model Terms (type: integer, default: 5)
</p>
</li>
<li> <p><code>neighbors</code>: # Nearest Neighbors (type: integer, default: 50)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>De Silva, V., and Tenenbaum, J. B. (2003). Global
versus local methods in nonlinear dimensionality reduction.
<em>Advances in Neural Information Processing Systems</em>.
721-728.
</p>
<p><span class="pkg">dimRed</span>, a framework for dimensionality reduction,
https://github.com/gdkrmr
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

im_trans &lt;- rec %&gt;%
  step_YeoJohnson(all_numeric_predictors()) %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_isomap(all_numeric_predictors(), neighbors = 100, num_terms = 2)

im_estimates &lt;- prep(im_trans, training = biomass_tr)

im_te &lt;- bake(im_estimates, biomass_te)

rng &lt;- extendrange(c(im_te$Isomap1, im_te$Isomap2))
plot(im_te$Isomap1, im_te$Isomap2,
  xlim = rng, ylim = rng
)

tidy(im_trans, number = 3)
tidy(im_estimates, number = 3)

</code></pre>

<hr>
<h2 id='step_kpca'>Kernel PCA signal extraction</h2><span id='topic+step_kpca'></span>

<h3>Description</h3>

<p><code>step_kpca()</code> creates a <em>specification</em> of a recipe step that will convert
numeric data into one or more principal components using a kernel basis
expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_kpca(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_comp = 5,
  res = NULL,
  columns = NULL,
  options = list(kernel = "rbfdot", kpar = list(sigma = 0.2)),
  prefix = "kPC",
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("kpca")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_kpca_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_num_comp">num_comp</code></td>
<td>
<p>The number of components to retain as new predictors.
If <code>num_comp</code> is greater than the number of columns or the number of
possible components, a smaller value will be used. If <code>num_comp = 0</code>
is set then no transformation is done and selected variables will
stay unchanged, regardless of the value of <code>keep_original_cols</code>.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_res">res</code></td>
<td>
<p>An S4 <code><a href="kernlab.html#topic+kpca">kernlab::kpca()</a></code> object is stored here once this
preprocessing step has be trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_options">options</code></td>
<td>
<p>A list of options to <code><a href="kernlab.html#topic+kpca">kernlab::kpca()</a></code>. Defaults are set for
the arguments <code>kernel</code> and <code>kpar</code> but others can be passed in.
<strong>Note</strong> that the arguments <code>x</code> and <code>features</code> should not be passed here
(or at all).</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_kpca_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When performing kPCA with <code>step_kpca()</code>, you must choose the kernel
function (and any important kernel parameters). This step uses the
<span class="pkg">kernlab</span> package; the reference below discusses the types of kernels
available and their parameter(s). These specifications can be made in the
<code>kernel</code> and <code>kpar</code> slots of the <code>options</code> argument to <code>step_kpca()</code>.
Consider using <code><a href="#topic+step_kpca_rbf">step_kpca_rbf()</a></code> for a radial basis function kernel or
<code><a href="#topic+step_kpca_poly">step_kpca_poly()</a></code> for a polynomial kernel.
</p>
<p>Kernel principal component analysis (kPCA) is an extension of a PCA analysis
that conducts the calculations in a broader dimensionality defined by a
kernel function. For example, if a quadratic kernel function were used,
each variable would be represented by its original values as well as its
square. This nonlinear mapping is used during the PCA analysis and can
potentially help find better representations of the original data.
</p>
<p>This step requires the <span class="pkg">kernlab</span> package.
If not installed, the step will stop with a prompt about installing
the package.
</p>
<p>As with ordinary PCA, it is important to center and scale the variables
prior to computing PCA components (<code><a href="#topic+step_normalize">step_normalize()</a></code> can be used for
this purpose).
</p>
<p>The argument <code>num_comp</code> controls the number of components that will be retained
(the original variables that are used to derive the components are removed from
the data). The new components will have names that begin with <code>prefix</code> and a
sequence of numbers. The variable names are padded with zeros. For example, if
<code>num_comp &lt; 10</code>, their names will be <code>kPC1</code> - <code>kPC9</code>. If <code>num_comp = 101</code>,
the names would be <code>kPC1</code> - <code>kPC101</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>tidy() results</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble with column
<code>terms</code> (the selectors or variables selected) is returned.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Scholkopf, B., Smola, A., and Muller, K. (1997).
Kernel principal component analysis. <em>Lecture Notes in
Computer Science</em>, 1327, 583-588.
</p>
<p>Karatzoglou, K., Smola, A., Hornik, K., and Zeileis, A. (2004).
kernlab - An S4 package for kernel methods in R. <em>Journal
of Statistical Software</em>, 11(1), 1-20.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

kpca_trans &lt;- rec %&gt;%
  step_YeoJohnson(all_numeric_predictors()) %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_kpca(all_numeric_predictors())

kpca_estimates &lt;- prep(kpca_trans, training = biomass_tr)

kpca_te &lt;- bake(kpca_estimates, biomass_te)

ggplot(kpca_te, aes(x = kPC1, y = kPC2)) +
  geom_point() +
  coord_equal()

tidy(kpca_trans, number = 3)
tidy(kpca_estimates, number = 3)

</code></pre>

<hr>
<h2 id='step_kpca_poly'>Polynomial kernel PCA signal extraction</h2><span id='topic+step_kpca_poly'></span>

<h3>Description</h3>

<p><code>step_kpca_poly()</code> creates a <em>specification</em> of a recipe step that will
convert numeric data into one or more principal components using a polynomial
kernel basis expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_kpca_poly(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_comp = 5,
  res = NULL,
  columns = NULL,
  degree = 2,
  scale_factor = 1,
  offset = 1,
  prefix = "kPC",
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("kpca_poly")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_kpca_poly_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_num_comp">num_comp</code></td>
<td>
<p>The number of components to retain as new predictors.
If <code>num_comp</code> is greater than the number of columns or the number of
possible components, a smaller value will be used. If <code>num_comp = 0</code>
is set then no transformation is done and selected variables will
stay unchanged, regardless of the value of <code>keep_original_cols</code>.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_res">res</code></td>
<td>
<p>An S4 <code><a href="kernlab.html#topic+kpca">kernlab::kpca()</a></code> object is stored
here once this preprocessing step has be trained by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_degree">degree</code>, <code id="step_kpca_poly_+3A_scale_factor">scale_factor</code>, <code id="step_kpca_poly_+3A_offset">offset</code></td>
<td>
<p>Numeric values for the polynomial kernel function.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_kpca_poly_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel principal component analysis (kPCA) is an extension of a PCA analysis
that conducts the calculations in a broader dimensionality defined by a
kernel function. For example, if a quadratic kernel function were used,
each variable would be represented by its original values as well as its
square. This nonlinear mapping is used during the PCA analysis and can
potentially help find better representations of the original data.
</p>
<p>This step requires the <span class="pkg">kernlab</span> package.
If not installed, the step will stop with a prompt about installing
the package.
</p>
<p>As with ordinary PCA, it is important to center and scale the variables
prior to computing PCA components (<code><a href="#topic+step_normalize">step_normalize()</a></code> can be used for
this purpose).
</p>
<p>The argument <code>num_comp</code> controls the number of components that will be retained
(the original variables that are used to derive the components are removed from
the data). The new components will have names that begin with <code>prefix</code> and a
sequence of numbers. The variable names are padded with zeros. For example, if
<code>num_comp &lt; 10</code>, their names will be <code>kPC1</code> - <code>kPC9</code>. If <code>num_comp = 101</code>,
the names would be <code>kPC1</code> - <code>kPC101</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>tidy() results</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble with column
<code>terms</code> (the selectors or variables selected) is returned.
</p>


<h3>Tuning Parameters</h3>

<p>This step has 4 tuning parameters:
</p>

<ul>
<li> <p><code>num_comp</code>: # Components (type: integer, default: 5)
</p>
</li>
<li> <p><code>degree</code>: Polynomial Degree (type: double, default: 2)
</p>
</li>
<li> <p><code>scale_factor</code>: Scale Factor (type: double, default: 1)
</p>
</li>
<li> <p><code>offset</code>: Offset (type: double, default: 1)
</p>
</li></ul>



<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Scholkopf, B., Smola, A., and Muller, K. (1997).
Kernel principal component analysis. <em>Lecture Notes in
Computer Science</em>, 1327, 583-588.
</p>
<p>Karatzoglou, K., Smola, A., Hornik, K., and Zeileis, A. (2004).
kernlab - An S4 package for kernel methods in R. <em>Journal
of Statistical Software</em>, 11(1), 1-20.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

kpca_trans &lt;- rec %&gt;%
  step_YeoJohnson(all_numeric_predictors()) %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_kpca_poly(all_numeric_predictors())

kpca_estimates &lt;- prep(kpca_trans, training = biomass_tr)

kpca_te &lt;- bake(kpca_estimates, biomass_te)

ggplot(kpca_te, aes(x = kPC1, y = kPC2)) +
  geom_point() +
  coord_equal()

tidy(kpca_trans, number = 3)
tidy(kpca_estimates, number = 3)

</code></pre>

<hr>
<h2 id='step_kpca_rbf'>Radial basis function kernel PCA signal extraction</h2><span id='topic+step_kpca_rbf'></span>

<h3>Description</h3>

<p><code>step_kpca_rbf()</code> creates a <em>specification</em> of a recipe step that will
convert numeric data into one or more principal components using a radial
basis function kernel basis expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_kpca_rbf(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_comp = 5,
  res = NULL,
  columns = NULL,
  sigma = 0.2,
  prefix = "kPC",
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("kpca_rbf")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_kpca_rbf_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_num_comp">num_comp</code></td>
<td>
<p>The number of components to retain as new predictors.
If <code>num_comp</code> is greater than the number of columns or the number of
possible components, a smaller value will be used. If <code>num_comp = 0</code>
is set then no transformation is done and selected variables will
stay unchanged, regardless of the value of <code>keep_original_cols</code>.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_res">res</code></td>
<td>
<p>An S4 <code><a href="kernlab.html#topic+kpca">kernlab::kpca()</a></code> object is stored
here once this preprocessing step has be trained by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_sigma">sigma</code></td>
<td>
<p>A numeric value for the radial basis function parameter.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_kpca_rbf_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel principal component analysis (kPCA) is an extension of a PCA analysis
that conducts the calculations in a broader dimensionality defined by a
kernel function. For example, if a quadratic kernel function were used,
each variable would be represented by its original values as well as its
square. This nonlinear mapping is used during the PCA analysis and can
potentially help find better representations of the original data.
</p>
<p>This step requires the <span class="pkg">kernlab</span> package.
If not installed, the step will stop with a prompt about installing
the package.
</p>
<p>As with ordinary PCA, it is important to center and scale the variables
prior to computing PCA components (<code><a href="#topic+step_normalize">step_normalize()</a></code> can be used for
this purpose).
</p>
<p>The argument <code>num_comp</code> controls the number of components that will be retained
(the original variables that are used to derive the components are removed from
the data). The new components will have names that begin with <code>prefix</code> and a
sequence of numbers. The variable names are padded with zeros. For example, if
<code>num_comp &lt; 10</code>, their names will be <code>kPC1</code> - <code>kPC9</code>. If <code>num_comp = 101</code>,
the names would be <code>kPC1</code> - <code>kPC101</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>tidy() results</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble with column
<code>terms</code> (the selectors or variables selected) is returned.
</p>


<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>num_comp</code>: # Components (type: integer, default: 5)
</p>
</li>
<li> <p><code>sigma</code>: Radial Basis Function sigma (type: double, default: 0.2)
</p>
</li></ul>



<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Scholkopf, B., Smola, A., and Muller, K. (1997).
Kernel principal component analysis. <em>Lecture Notes in
Computer Science</em>, 1327, 583-588.
</p>
<p>Karatzoglou, K., Smola, A., Hornik, K., and Zeileis, A. (2004).
kernlab - An S4 package for kernel methods in R. <em>Journal
of Statistical Software</em>, 11(1), 1-20.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

kpca_trans &lt;- rec %&gt;%
  step_YeoJohnson(all_numeric_predictors()) %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_kpca_rbf(all_numeric_predictors())

kpca_estimates &lt;- prep(kpca_trans, training = biomass_tr)

kpca_te &lt;- bake(kpca_estimates, biomass_te)

ggplot(kpca_te, aes(x = kPC1, y = kPC2)) +
  geom_point() +
  coord_equal()

tidy(kpca_trans, number = 3)
tidy(kpca_estimates, number = 3)

</code></pre>

<hr>
<h2 id='step_lag'>Create a lagged predictor</h2><span id='topic+step_lag'></span>

<h3>Description</h3>

<p><code>step_lag()</code> creates a <em>specification</em> of a recipe step that will add new
columns of lagged data. Lagged data will by default include NA values where
the lag was induced. These can be removed with <code><a href="#topic+step_naomit">step_naomit()</a></code>, or you may
specify an alternative filler value with the <code>default</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_lag(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  lag = 1,
  prefix = "lag_",
  default = NA,
  columns = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("lag")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_lag_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_lag">lag</code></td>
<td>
<p>A vector of positive integers. Each specified column will be
lagged for each value in the vector.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_prefix">prefix</code></td>
<td>
<p>A prefix for generated column names, default to &quot;lag_&quot;.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_default">default</code></td>
<td>
<p>Passed to <code>dplyr::lag</code>, determines what fills empty rows
left by lagging (defaults to NA).</p>
</td></tr>
<tr><td><code id="step_lag_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_lag_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The step assumes that the data are already <em>in the proper sequential
order</em> for lagging.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other row operation steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>,
<code><a href="#topic+step_naomit">step_naomit</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_shuffle">step_shuffle</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
start &lt;- as.Date("1999/01/01")
end &lt;- as.Date("1999/01/10")

df &lt;- data.frame(
  x = runif(n),
  index = 1:n,
  day = seq(start, end, by = "day")
)

recipe(~., data = df) %&gt;%
  step_lag(index, day, lag = 2:3) %&gt;%
  prep(df) %&gt;%
  bake(df)
</code></pre>

<hr>
<h2 id='step_lincomb'>Linear combination filter</h2><span id='topic+step_lincomb'></span>

<h3>Description</h3>

<p><code>step_lincomb()</code> creates a <em>specification</em> of a recipe step that will
potentially remove numeric variables that have exact linear combinations
between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_lincomb(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  max_steps = 5,
  removals = NULL,
  skip = FALSE,
  id = rand_id("lincomb")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_lincomb_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_lincomb_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_lincomb_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_lincomb_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_lincomb_+3A_max_steps">max_steps</code></td>
<td>
<p>The number of times to apply the algorithm.</p>
</td></tr>
<tr><td><code id="step_lincomb_+3A_removals">removals</code></td>
<td>
<p>A character string that contains the names of
columns that should be removed. These values are not determined
until <code><a href="#topic+prep">prep()</a></code> is called.</p>
</td></tr>
<tr><td><code id="step_lincomb_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_lincomb_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step can potentially remove columns from the data set. This may
cause issues for subsequent steps in your recipe if the missing columns are
specifically referenced by name. To avoid this, see the advice in the
<em>Tips for saving recipes and filtering columns</em> section of <a href="#topic+selections">selections</a>.
</p>
<p>This step finds exact linear combinations between two
or more variables and recommends which column(s) should be
removed to resolve the issue. This algorithm may need to be
applied multiple times (as defined by <code>max_steps</code>).
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>Author(s)</h3>

<p>Max Kuhn, Kirk Mettler, and Jed Wing
</p>


<h3>See Also</h3>

<p>Other variable filter steps: 
<code><a href="#topic+step_corr">step_corr</a>()</code>,
<code><a href="#topic+step_filter_missing">step_filter_missing</a>()</code>,
<code><a href="#topic+step_nzv">step_nzv</a>()</code>,
<code><a href="#topic+step_rm">step_rm</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_zv">step_zv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass$new_1 &lt;- with(
  biomass,
  .1 * carbon - .2 * hydrogen + .6 * sulfur
)
biomass$new_2 &lt;- with(
  biomass,
  .5 * carbon - .2 * oxygen + .6 * nitrogen
)

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(HHV ~ carbon + hydrogen + oxygen + nitrogen +
  sulfur + new_1 + new_2,
data = biomass_tr
)

lincomb_filter &lt;- rec %&gt;%
  step_lincomb(all_numeric_predictors())

lincomb_filter_trained &lt;- prep(lincomb_filter, training = biomass_tr)
lincomb_filter_trained

tidy(lincomb_filter, number = 1)
tidy(lincomb_filter_trained, number = 1)

</code></pre>

<hr>
<h2 id='step_log'>Logarithmic transformation</h2><span id='topic+step_log'></span>

<h3>Description</h3>

<p><code>step_log()</code> creates a <em>specification</em> of a recipe step that will log
transform data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_log(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  base = exp(1),
  offset = 0,
  columns = NULL,
  skip = FALSE,
  signed = FALSE,
  id = rand_id("log")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_log_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_log_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_log_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_log_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_log_+3A_base">base</code></td>
<td>
<p>A numeric value for the base.</p>
</td></tr>
<tr><td><code id="step_log_+3A_offset">offset</code></td>
<td>
<p>An optional value to add to the data prior to
logging (to avoid <code>log(0)</code>).</p>
</td></tr>
<tr><td><code id="step_log_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_log_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_log_+3A_signed">signed</code></td>
<td>
<p>A logical indicating whether to take the signed log.
This is sign(x) * log(abs(x)) when abs(x) =&gt; 1 or 0 if abs(x) &lt; 1.
If <code>TRUE</code> the <code>offset</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="step_log_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>base</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>base</dt><dd><p>numeric, value for the base</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(313)
examples &lt;- matrix(exp(rnorm(40)), ncol = 2)
examples &lt;- as.data.frame(examples)

rec &lt;- recipe(~ V1 + V2, data = examples)

log_trans &lt;- rec %&gt;%
  step_log(all_numeric_predictors())

log_obj &lt;- prep(log_trans, training = examples)

transformed_te &lt;- bake(log_obj, examples)
plot(examples$V1, transformed_te$V1)

tidy(log_trans, number = 1)
tidy(log_obj, number = 1)

# using the signed argument with negative values

examples2 &lt;- matrix(rnorm(40, sd = 5), ncol = 2)
examples2 &lt;- as.data.frame(examples2)

recipe(~ V1 + V2, data = examples2) %&gt;%
  step_log(all_numeric_predictors()) %&gt;%
  prep(training = examples2) %&gt;%
  bake(examples2)

recipe(~ V1 + V2, data = examples2) %&gt;%
  step_log(all_numeric_predictors(), signed = TRUE) %&gt;%
  prep(training = examples2) %&gt;%
  bake(examples2)
</code></pre>

<hr>
<h2 id='step_logit'>Logit transformation</h2><span id='topic+step_logit'></span>

<h3>Description</h3>

<p><code>step_logit()</code> creates a <em>specification</em> of a recipe step that will logit
transform the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_logit(
  recipe,
  ...,
  offset = 0,
  role = NA,
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("logit")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_logit_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_logit_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_logit_+3A_offset">offset</code></td>
<td>
<p>A numeric value to modify values of the columns that are either
one or zero. They are modified to be <code>x - offset</code> or <code>offset</code>, respectively.</p>
</td></tr>
<tr><td><code id="step_logit_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_logit_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_logit_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_logit_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_logit_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logit transformation takes values between
zero and one and translates them to be on the real line using
the function <code>f(p) = log(p/(1-p))</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(313)
examples &lt;- matrix(runif(40), ncol = 2)
examples &lt;- data.frame(examples)

rec &lt;- recipe(~ X1 + X2, data = examples)

logit_trans &lt;- rec %&gt;%
  step_logit(all_numeric_predictors())

logit_obj &lt;- prep(logit_trans, training = examples)

transformed_te &lt;- bake(logit_obj, examples)
plot(examples$X1, transformed_te$X1)

tidy(logit_trans, number = 1)
tidy(logit_obj, number = 1)
</code></pre>

<hr>
<h2 id='step_mutate'>Add new variables using dplyr</h2><span id='topic+step_mutate'></span>

<h3>Description</h3>

<p><code>step_mutate()</code> creates a <em>specification</em> of a recipe step that will add
variables using <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_mutate(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  inputs = NULL,
  skip = FALSE,
  id = rand_id("mutate")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_mutate_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_mutate_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions. See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>.</p>
</td></tr>
<tr><td><code id="step_mutate_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_mutate_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_mutate_+3A_inputs">inputs</code></td>
<td>
<p>Quosure(s) of <code>...</code>.</p>
</td></tr>
<tr><td><code id="step_mutate_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_mutate_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using this flexible step, use extra care to avoid data leakage in your
preprocessing. Consider, for example, the transformation <code>x = w &gt; mean(w)</code>.
When applied to new data or testing data, this transformation would use the
mean of <code>w</code> from the <em>new</em> data, not the mean of <code>w</code> from the training data.
</p>
<p>When an object in the user's global environment is
referenced in the expression defining the new variable(s),
it is a good idea to use quasiquotation (e.g. <code style="white-space: pre;">&#8288;!!&#8288;</code>) to embed
the value of the object in the expression (to be portable
between sessions). See the examples.
</p>
<p>If a preceding step removes a column that is selected by name in
<code>step_mutate()</code>, the recipe will error when being estimated with <code><a href="#topic+prep">prep()</a></code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>character, expression passed to <code>mutate()</code></p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>
<p>Other dplyr steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_rename_at">step_rename_at</a>()</code>,
<code><a href="#topic+step_rename">step_rename</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rec &lt;-
  recipe(~., data = iris) %&gt;%
  step_mutate(
    dbl_width = Sepal.Width * 2,
    half_length = Sepal.Length / 2
  )

prepped &lt;- prep(rec, training = iris %&gt;% slice(1:75))

library(dplyr)

dplyr_train &lt;-
  iris %&gt;%
  as_tibble() %&gt;%
  slice(1:75) %&gt;%
  mutate(
    dbl_width = Sepal.Width * 2,
    half_length = Sepal.Length / 2
  )

rec_train &lt;- bake(prepped, new_data = NULL)
all.equal(dplyr_train, rec_train)

dplyr_test &lt;-
  iris %&gt;%
  as_tibble() %&gt;%
  slice(76:150) %&gt;%
  mutate(
    dbl_width = Sepal.Width * 2,
    half_length = Sepal.Length / 2
  )
rec_test &lt;- bake(prepped, iris %&gt;% slice(76:150))
all.equal(dplyr_test, rec_test)

# Embedding objects:
const &lt;- 1.414

qq_rec &lt;-
  recipe(~., data = iris) %&gt;%
  step_mutate(
    bad_approach = Sepal.Width * const,
    best_approach = Sepal.Width * !!const
  ) %&gt;%
  prep(training = iris)

bake(qq_rec, new_data = NULL, contains("appro")) %&gt;% slice(1:4)

# The difference:
tidy(qq_rec, number = 1)
</code></pre>

<hr>
<h2 id='step_mutate_at'>Mutate multiple columns using dplyr</h2><span id='topic+step_mutate_at'></span>

<h3>Description</h3>

<p><code>step_mutate_at()</code> creates a <em>specification</em> of a recipe step that will
modify the selected variables using a common function via
<code><a href="dplyr.html#topic+mutate_all">dplyr::mutate_at()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_mutate_at(
  recipe,
  ...,
  fn,
  role = "predictor",
  trained = FALSE,
  inputs = NULL,
  skip = FALSE,
  id = rand_id("mutate_at")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_mutate_at_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_mutate_at_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_mutate_at_+3A_fn">fn</code></td>
<td>
<p>A function fun, a quosure style lambda '~ fun(.)&ldquo; or a list of
either form. (see <code><a href="dplyr.html#topic+mutate_all">dplyr::mutate_at()</a></code>). <strong>Note that this argument must be
named</strong>.</p>
</td></tr>
<tr><td><code id="step_mutate_at_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_mutate_at_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_mutate_at_+3A_inputs">inputs</code></td>
<td>
<p>A vector of column names populated by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_mutate_at_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_mutate_at_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using this flexible step, use extra care to avoid data leakage in your
preprocessing. Consider, for example, the transformation <code>x = w &gt; mean(w)</code>.
When applied to new data or testing data, this transformation would use the
mean of <code>w</code> from the <em>new</em> data, not the mean of <code>w</code> from the training data.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>
<p>Other dplyr steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_rename_at">step_rename_at</a>()</code>,
<code><a href="#topic+step_rename">step_rename</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
recipe(~., data = iris) %&gt;%
  step_mutate_at(contains("Length"), fn = ~ 1 / .) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  slice(1:10)

recipe(~., data = iris) %&gt;%
  # leads to more columns being created.
  step_mutate_at(contains("Length"), fn = list(log = log, sqrt = sqrt)) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  slice(1:10)
</code></pre>

<hr>
<h2 id='step_naomit'>Remove observations with missing values</h2><span id='topic+step_naomit'></span>

<h3>Description</h3>

<p><code>step_naomit()</code> creates a <em>specification</em> of a recipe step that will remove
observations (rows of data) if they contain <code>NA</code> or <code>NaN</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_naomit(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  skip = TRUE,
  id = rand_id("naomit")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_naomit_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_naomit_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_naomit_+3A_role">role</code></td>
<td>
<p>Unused, include for consistency with other steps.</p>
</td></tr>
<tr><td><code id="step_naomit_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for preprocessing
have been estimated. Again included for consistency.</p>
</td></tr>
<tr><td><code id="step_naomit_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_naomit_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_naomit_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Row Filtering</h3>

<p>This step can entirely remove observations (rows of data), which can have
unintended and/or problematic consequences when applying the step to new
data later via <code><a href="#topic+bake">bake()</a></code>. Consider whether <code>skip = TRUE</code> or
<code>skip = FALSE</code> is more appropriate in any given use case. In most instances
that affect the rows of the data being predicted, this step probably should
not be applied at all; instead, execute operations like this outside and
before starting a preprocessing <code><a href="#topic+recipe">recipe()</a></code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other row operation steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>,
<code><a href="#topic+step_lag">step_lag</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_shuffle">step_shuffle</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
recipe(Ozone ~ ., data = airquality) %&gt;%
  step_naomit(Solar.R) %&gt;%
  prep(airquality, verbose = FALSE) %&gt;%
  bake(new_data = NULL)
</code></pre>

<hr>
<h2 id='step_nnmf'>Non-negative matrix factorization signal extraction</h2><span id='topic+step_nnmf'></span>

<h3>Description</h3>

<p><code>step_nnmf()</code> creates a <em>specification</em> of a recipe step that will convert
numeric data into one or more non-negative components.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Please use <code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse()</a></code> instead of this step function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_nnmf(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_comp = 2,
  num_run = 30,
  options = list(),
  res = NULL,
  columns = NULL,
  prefix = "NNMF",
  seed = sample.int(10^5, 1),
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("nnmf")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_nnmf_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_num_comp">num_comp</code></td>
<td>
<p>The number of components to retain as new predictors.
If <code>num_comp</code> is greater than the number of columns or the number of
possible components, a smaller value will be used. If <code>num_comp = 0</code>
is set then no transformation is done and selected variables will
stay unchanged, regardless of the value of <code>keep_original_cols</code>.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_num_run">num_run</code></td>
<td>
<p>A positive integer for the number of computations runs used
to obtain a consensus projection.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_options">options</code></td>
<td>
<p>A list of options to <code>nmf()</code> in the NMF package by way of the
<code>NNMF()</code> function in the <code>dimRed</code> package. <strong>Note</strong> that the arguments
<code>data</code> and <code>ndim</code> should not be passed here, and that NMF's parallel
processing is turned off in favor of resample-level parallelization.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_res">res</code></td>
<td>
<p>The <code>NNMF()</code> object is stored
here once this preprocessing step has been trained by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_prefix">prefix</code></td>
<td>
<p>A character string that will be the prefix to the
resulting new variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used to set the seed in isolation
when computing the factorization.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_nnmf_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-negative matrix factorization computes latent components that
have non-negative values and take into account that the original data
have non-negative values.
</p>
<p>The argument <code>num_comp</code> controls the number of components that will be retained
(the original variables that are used to derive the components are removed from
the data). The new components will have names that begin with <code>prefix</code> and a
sequence of numbers. The variable names are padded with zeros. For example, if
<code>num_comp &lt; 10</code>, their names will be <code>NNMF1</code> - <code>NNMF9</code>. If <code>num_comp = 101</code>,
the names would be <code>NNMF1</code> - <code>NNMF101</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code>, <code>component</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, value of loading</p>
</dd>
<dt>component</dt><dd><p>character, name of component</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>num_comp</code>: # Components (type: integer, default: 2)
</p>
</li>
<li> <p><code>num_run</code>: Number of Computation Runs (type: integer, default: 30)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

# rec &lt;- recipe(HHV ~ ., data = biomass) %&gt;%
#   update_role(sample, new_role = "id var") %&gt;%
#   update_role(dataset, new_role = "split variable") %&gt;%
#   step_nnmf(all_numeric_predictors(), num_comp = 2, seed = 473, num_run = 2) %&gt;%
#   prep(training = biomass)
#
# bake(rec, new_data = NULL)
#
# library(ggplot2)
# bake(rec, new_data = NULL) %&gt;%
#  ggplot(aes(x = NNMF2, y = NNMF1, col = HHV)) + geom_point()

</code></pre>

<hr>
<h2 id='step_nnmf_sparse'>Non-negative matrix factorization signal extraction with lasso penalization</h2><span id='topic+step_nnmf_sparse'></span>

<h3>Description</h3>

<p><code>step_nnmf_sparse()</code> creates a <em>specification</em> of a recipe step that will
convert numeric data into one or more non-negative components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_nnmf_sparse(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_comp = 2,
  penalty = 0.001,
  options = list(),
  res = NULL,
  prefix = "NNMF",
  seed = sample.int(10^5, 1),
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("nnmf_sparse")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_nnmf_sparse_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_num_comp">num_comp</code></td>
<td>
<p>The number of components to retain as new predictors.
If <code>num_comp</code> is greater than the number of columns or the number of
possible components, a smaller value will be used. If <code>num_comp = 0</code>
is set then no transformation is done and selected variables will
stay unchanged, regardless of the value of <code>keep_original_cols</code>.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_penalty">penalty</code></td>
<td>
<p>A non-negative number used as a penalization factor for the
loadings. Values are usually between zero and one.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_options">options</code></td>
<td>
<p>A list of options to <code>nmf()</code> in the RcppML package. That
package has a separate function <code>setRcppMLthreads()</code> that controls the
amount of internal parallelization. <strong>Note</strong> that the argument <code>A</code>, <code>k</code>,
<code>L1</code>, and <code>seed</code> should not be passed here.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_res">res</code></td>
<td>
<p>A matrix of loadings is stored here, along with the names of the
original predictors, once this preprocessing step has been trained by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used to set the seed in isolation when
computing the factorization.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_nnmf_sparse_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-negative matrix factorization computes latent components that
have non-negative values and take into account that the original data have
non-negative values.
</p>
<p>The argument <code>num_comp</code> controls the number of components that will be retained
(the original variables that are used to derive the components are removed from
the data). The new components will have names that begin with <code>prefix</code> and a
sequence of numbers. The variable names are padded with zeros. For example, if
<code>num_comp &lt; 10</code>, their names will be <code>NNMF1</code> - <code>NNMF9</code>. If <code>num_comp = 101</code>,
the names would be <code>NNMF1</code> - <code>NNMF101</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code>, <code>component</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, value of loading</p>
</dd>
<dt>component</dt><dd><p>character, name of component</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>num_comp</code>: # Components (type: integer, default: 2)
</p>
</li>
<li> <p><code>penalty</code>: Amount of Regularization (type: double, default: 0.001)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (rlang::is_installed(c("modeldata", "RcppML", "ggplot2"))) {
library(Matrix)
data(biomass, package = "modeldata")

rec &lt;- recipe(HHV ~ ., data = biomass) %&gt;%
  update_role(sample, new_role = "id var") %&gt;%
  update_role(dataset, new_role = "split variable") %&gt;%
  step_nnmf_sparse(
    all_numeric_predictors(),
    num_comp = 2,
    seed = 473,
    penalty = 0.01
  ) %&gt;%
  prep(training = biomass)

bake(rec, new_data = NULL)

library(ggplot2)
bake(rec, new_data = NULL) %&gt;%
  ggplot(aes(x = NNMF2, y = NNMF1, col = HHV)) +
  geom_point()
}

</code></pre>

<hr>
<h2 id='step_normalize'>Center and scale numeric data</h2><span id='topic+step_normalize'></span>

<h3>Description</h3>

<p><code>step_normalize()</code> creates a <em>specification</em> of a recipe step that will
normalize numeric data to have a standard deviation of one and a mean of
zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_normalize(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  means = NULL,
  sds = NULL,
  na_rm = TRUE,
  skip = FALSE,
  id = rand_id("normalize")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_normalize_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_normalize_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_normalize_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_normalize_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_normalize_+3A_means">means</code></td>
<td>
<p>A named numeric vector of means. This is <code>NULL</code> until computed
by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_normalize_+3A_sds">sds</code></td>
<td>
<p>A named numeric vector of standard deviations This is <code>NULL</code> until
computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_normalize_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical value indicating whether <code>NA</code> values should be removed
when computing the standard deviation and mean.</p>
</td></tr>
<tr><td><code id="step_normalize_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_normalize_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centering data means that the average of a variable is subtracted
from the data. Scaling data means that the standard deviation of a variable
is divided out of the data. <code>step_normalize</code> estimates the variable standard
deviations and means from the data used in the <code>training</code> argument of
<code>prep.recipe</code>. <code><a href="#topic+bake.recipe">bake.recipe</a></code> then applies the scaling to new data sets using
these estimates.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>statistic</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>statistic</dt><dd><p>character, name of statistic (<code>"mean"</code> or <code>"sd"</code>)</p>
</dd>
<dt>value</dt><dd><p>numeric, value of the <code>statistic</code></p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other normalization steps: 
<code><a href="#topic+step_center">step_center</a>()</code>,
<code><a href="#topic+step_range">step_range</a>()</code>,
<code><a href="#topic+step_scale">step_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

norm_trans &lt;- rec %&gt;%
  step_normalize(carbon, hydrogen)

norm_obj &lt;- prep(norm_trans, training = biomass_tr)

transformed_te &lt;- bake(norm_obj, biomass_te)

biomass_te[1:10, names(transformed_te)]
transformed_te
tidy(norm_trans, number = 1)
tidy(norm_obj, number = 1)

# To keep the original variables in the output, use `step_mutate_at`:
norm_keep_orig &lt;- rec %&gt;%
  step_mutate_at(all_numeric_predictors(), fn = list(orig = ~.)) %&gt;%
  step_normalize(-contains("orig"), -all_outcomes())

keep_orig_obj &lt;- prep(norm_keep_orig, training = biomass_tr)
keep_orig_te &lt;- bake(keep_orig_obj, biomass_te)
keep_orig_te

</code></pre>

<hr>
<h2 id='step_novel'>Simple value assignments for novel factor levels</h2><span id='topic+step_novel'></span>

<h3>Description</h3>

<p><code>step_novel()</code> creates a <em>specification</em> of a recipe step that will assign a
previously unseen factor level to <code>"new"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_novel(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  new_level = "new",
  objects = NULL,
  skip = FALSE,
  id = rand_id("novel")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_novel_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_novel_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_novel_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_novel_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_novel_+3A_new_level">new_level</code></td>
<td>
<p>A single character value that will be assigned
to new factor levels.</p>
</td></tr>
<tr><td><code id="step_novel_+3A_objects">objects</code></td>
<td>
<p>A list of objects that contain the information
on factor levels that will be determined by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_novel_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_novel_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selected variables are adjusted to have a new
level (given by <code>new_level</code>) that is placed in the last
position. During preparation there will be no data points
associated with this new level since all of the data have been
seen.
</p>
<p>Note that if the original columns are character, they will be
converted to factors by this step.
</p>
<p>Missing values will remain missing.
</p>
<p>If <code>new_level</code> is already in the data given to <code>prep</code>, an error
is thrown.
</p>
<p>When fitting a model that can deal with new factor levels, consider using
<code><a href="workflows.html#topic+add_recipe">workflows::add_recipe()</a></code> with <code>allow_novel_levels = TRUE</code> set in
<code><a href="hardhat.html#topic+default_recipe_blueprint">hardhat::default_recipe_blueprint()</a></code>. This will allow your model to handle
new levels at prediction time, instead of throwing warnings or errors.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>character, the factor levels that are used for the new value</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dummy_names">dummy_names()</a></code>
</p>
<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

sacr_tr &lt;- Sacramento[1:800, ]
sacr_te &lt;- Sacramento[801:806, ]
sacr_te$city[3] &lt;- "beeptown"
sacr_te$city[4] &lt;- "boopville"

rec &lt;- recipe(~ city + zip, data = sacr_tr)

rec &lt;- rec %&gt;%
  step_novel(city, zip)
rec &lt;- prep(rec, training = sacr_tr)

processed &lt;- bake(rec, sacr_te)
tibble(old = sacr_te$city, new = processed$city)

tidy(rec, number = 1)

</code></pre>

<hr>
<h2 id='step_ns'>Natural spline basis functions</h2><span id='topic+step_ns'></span>

<h3>Description</h3>

<p><code>step_ns()</code> creates a <em>specification</em> of a recipe step that will create new
columns that are basis expansions of variables using natural splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ns(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  objects = NULL,
  deg_free = 2,
  options = list(),
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("ns")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ns_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_objects">objects</code></td>
<td>
<p>A list of <code><a href="splines.html#topic+ns">splines::ns()</a></code> objects
created once the step has been trained.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_deg_free">deg_free</code></td>
<td>
<p>The degrees of freedom for the natural spline. As the
degrees of freedom for a natural spline increase, more flexible and
complex curves can be generated. When a single degree of freedom is used,
the result is a rescaled version of the original data.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="splines.html#topic+ns">splines::ns()</a></code>
which should not include <code>x</code> or <code>df</code>.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_ns_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_ns</code> can create new features from a single variable
that enable fitting routines to model this variable in a
nonlinear manner. The extent of the possible nonlinearity is
determined by the <code>df</code> or <code>knot</code> arguments of
<code><a href="splines.html#topic+ns">splines::ns()</a></code>. The original variables are removed
from the data and new columns are added. The naming convention
for the new variables is <code>varname_ns_1</code> and so on.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>deg_free</code>: Spline Degrees of Freedom (type: integer, default: 2)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

with_splines &lt;- rec %&gt;%
  step_ns(carbon, hydrogen)
with_splines &lt;- prep(with_splines, training = biomass_tr)

expanded &lt;- bake(with_splines, biomass_te)
expanded

</code></pre>

<hr>
<h2 id='step_num2factor'>Convert numbers to factors</h2><span id='topic+step_num2factor'></span>

<h3>Description</h3>

<p><code>step_num2factor()</code> will convert one or more numeric vectors to factors
(ordered or unordered). This can be useful when categories are encoded as
integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_num2factor(
  recipe,
  ...,
  role = NA,
  transform = function(x) x,
  trained = FALSE,
  levels,
  ordered = FALSE,
  skip = FALSE,
  id = rand_id("num2factor")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_num2factor_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_num2factor_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_num2factor_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_num2factor_+3A_transform">transform</code></td>
<td>
<p>A function taking a single argument <code>x</code> that can be used
to modify the numeric values prior to determining the levels (perhaps using
<code><a href="base.html#topic+integer">base::as.integer()</a></code>). The output of a function should be an integer that
corresponds to the value of <code>levels</code> that should be assigned. If not an
integer, the value will be converted to an integer during <code><a href="#topic+bake">bake()</a></code>.</p>
</td></tr>
<tr><td><code id="step_num2factor_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_num2factor_+3A_levels">levels</code></td>
<td>
<p>A character vector of values that will be used as the levels.
These are the numeric data converted to character and ordered. This is
modified once <code><a href="#topic+prep">prep()</a></code> is executed.</p>
</td></tr>
<tr><td><code id="step_num2factor_+3A_ordered">ordered</code></td>
<td>
<p>A single logical value; should the factor(s) be ordered?</p>
</td></tr>
<tr><td><code id="step_num2factor_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_num2factor_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>ordered</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>ordered</dt><dd><p>logical, were the factor(s) ordered</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
data(attrition, package = "modeldata")

attrition %&gt;%
  group_by(StockOptionLevel) %&gt;%
  count()

amnt &lt;- c("nothin", "meh", "some", "copious")

rec &lt;-
  recipe(Attrition ~ StockOptionLevel, data = attrition) %&gt;%
  step_num2factor(
    StockOptionLevel,
    transform = function(x) x + 1,
    levels = amnt
  )

encoded &lt;- rec %&gt;%
  prep() %&gt;%
  bake(new_data = NULL)

table(encoded$StockOptionLevel, attrition$StockOptionLevel)


# an example for binning

binner &lt;- function(x) {
  x &lt;- cut(x, breaks = 1000 * c(0, 5, 10, 20), include.lowest = TRUE)
  # now return the group number
  as.numeric(x)
}

inc &lt;- c("low", "med", "high")

rec &lt;-
  recipe(Attrition ~ MonthlyIncome, data = attrition) %&gt;%
  step_num2factor(
    MonthlyIncome,
    transform = binner,
    levels = inc,
    ordered = TRUE
  ) %&gt;%
  prep()

encoded &lt;- bake(rec, new_data = NULL)

table(encoded$MonthlyIncome, binner(attrition$MonthlyIncome))

# What happens when a value is out of range?
ceo &lt;- attrition %&gt;%
  slice(1) %&gt;%
  mutate(MonthlyIncome = 10^10)

bake(rec, ceo)

</code></pre>

<hr>
<h2 id='step_nzv'>Near-zero variance filter</h2><span id='topic+step_nzv'></span>

<h3>Description</h3>

<p><code>step_nzv()</code> creates a <em>specification</em> of a recipe step that will potentially
remove variables that are highly sparse and unbalanced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_nzv(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  freq_cut = 95/5,
  unique_cut = 10,
  options = list(freq_cut = 95/5, unique_cut = 10),
  removals = NULL,
  skip = FALSE,
  id = rand_id("nzv")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_nzv_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_nzv_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_nzv_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_nzv_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_nzv_+3A_freq_cut">freq_cut</code>, <code id="step_nzv_+3A_unique_cut">unique_cut</code></td>
<td>
<p>Numeric parameters for the filtering process. See
the Details section below.</p>
</td></tr>
<tr><td><code id="step_nzv_+3A_options">options</code></td>
<td>
<p>A list of options for the filter (see Details
below).</p>
</td></tr>
<tr><td><code id="step_nzv_+3A_removals">removals</code></td>
<td>
<p>A character string that contains the names of
columns that should be removed. These values are not determined
until <code><a href="#topic+prep">prep()</a></code> is called.</p>
</td></tr>
<tr><td><code id="step_nzv_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_nzv_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step can potentially remove columns from the data set. This may
cause issues for subsequent steps in your recipe if the missing columns are
specifically referenced by name. To avoid this, see the advice in the
<em>Tips for saving recipes and filtering columns</em> section of <a href="#topic+selections">selections</a>.
</p>
<p>This step diagnoses predictors that have one unique
value (i.e. are zero variance predictors) or predictors that have
both of the following characteristics:
</p>

<ol>
<li><p> they have very few unique values relative to the number
of samples and
</p>
</li>
<li><p> the ratio of the frequency of the most common value to
the frequency of the second most common value is large.
</p>
</li></ol>

<p>For example, an example of near-zero variance predictor is one
that, for 1000 samples, has two distinct values and 999 of them
are a single value.
</p>
<p>To be flagged, first, the frequency of the most prevalent value
over the second most frequent value (called the &quot;frequency
ratio&quot;) must be above <code>freq_cut</code>. Secondly, the &quot;percent of
unique values,&quot; the number of unique values divided by the total
number of samples (times 100), must also be below
<code>unique_cut</code>.
</p>
<p>In the above example, the frequency ratio is 999 and the unique
value percent is 0.2%.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>freq_cut</code>: Frequency Distribution Ratio (type: double, default: 95/5)
</p>
</li>
<li> <p><code>unique_cut</code>: % Unique Values (type: double, default: 10)
</p>
</li></ul>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other variable filter steps: 
<code><a href="#topic+step_corr">step_corr</a>()</code>,
<code><a href="#topic+step_filter_missing">step_filter_missing</a>()</code>,
<code><a href="#topic+step_lincomb">step_lincomb</a>()</code>,
<code><a href="#topic+step_rm">step_rm</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_zv">step_zv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass$sparse &lt;- c(1, rep(0, nrow(biomass) - 1))

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(HHV ~ carbon + hydrogen + oxygen +
  nitrogen + sulfur + sparse,
data = biomass_tr
)

nzv_filter &lt;- rec %&gt;%
  step_nzv(all_predictors())

filter_obj &lt;- prep(nzv_filter, training = biomass_tr)

filtered_te &lt;- bake(filter_obj, biomass_te)
any(names(filtered_te) == "sparse")

tidy(nzv_filter, number = 1)
tidy(filter_obj, number = 1)

</code></pre>

<hr>
<h2 id='step_ordinalscore'>Convert ordinal factors to numeric scores</h2><span id='topic+step_ordinalscore'></span>

<h3>Description</h3>

<p><code>step_ordinalscore()</code> creates a <em>specification</em> of a recipe step that will
convert ordinal factor variables into numeric scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ordinalscore(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  convert = as.numeric,
  skip = FALSE,
  id = rand_id("ordinalscore")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ordinalscore_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_ordinalscore_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_ordinalscore_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_ordinalscore_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_ordinalscore_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_ordinalscore_+3A_convert">convert</code></td>
<td>
<p>A function that takes an ordinal factor vector
as an input and outputs a single numeric variable.</p>
</td></tr>
<tr><td><code id="step_ordinalscore_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_ordinalscore_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dummy variables from ordered factors with <code>C</code>
levels will create polynomial basis functions with <code>C-1</code>
terms. As an alternative, this step can be used to translate the
ordered levels into a single numeric vector of values that
represent (subjective) scores. By default, the translation uses
a linear scale (1, 2, 3, ... <code>C</code>) but custom score
functions can also be used (see the example below).
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fail_lvls &lt;- c("meh", "annoying", "really_bad")

ord_data &lt;-
  data.frame(
    item = c("paperclip", "twitter", "airbag"),
    fail_severity = factor(fail_lvls,
      levels = fail_lvls,
      ordered = TRUE
    )
  )

model.matrix(~fail_severity, data = ord_data)

linear_values &lt;- recipe(~ item + fail_severity, data = ord_data) %&gt;%
  step_dummy(item) %&gt;%
  step_ordinalscore(fail_severity)

linear_values &lt;- prep(linear_values, training = ord_data)

bake(linear_values, new_data = NULL, everything())

custom &lt;- function(x) {
  new_values &lt;- c(1, 3, 7)
  new_values[as.numeric(x)]
}

nonlin_scores &lt;- recipe(~ item + fail_severity, data = ord_data) %&gt;%
  step_dummy(item) %&gt;%
  step_ordinalscore(fail_severity, convert = custom)

tidy(nonlin_scores, number = 2)

nonlin_scores &lt;- prep(nonlin_scores, training = ord_data)

bake(nonlin_scores, new_data = NULL, everything())

tidy(nonlin_scores, number = 2)
</code></pre>

<hr>
<h2 id='step_other'>Collapse infrequent categorical levels</h2><span id='topic+step_other'></span>

<h3>Description</h3>

<p><code>step_other()</code> creates a <em>specification</em> of a recipe step that will
potentially pool infrequently occurring values into an <code>"other"</code> category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_other(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  threshold = 0.05,
  other = "other",
  objects = NULL,
  skip = FALSE,
  id = rand_id("other")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_other_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_other_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_other_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_other_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_other_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value between 0 and 1, or an integer greater or
equal to one.  If less than one, then factor levels with a rate of
occurrence in the training set below <code>threshold</code> will be pooled to <code>other</code>.
If greater or equal to one, then this value is treated as a frequency
and factor levels that occur less than <code>threshold</code> times will be pooled
to <code>other</code>.</p>
</td></tr>
<tr><td><code id="step_other_+3A_other">other</code></td>
<td>
<p>A single character value for the &quot;other&quot; category.</p>
</td></tr>
<tr><td><code id="step_other_+3A_objects">objects</code></td>
<td>
<p>A list of objects that contain the information
to pool infrequent levels that is determined by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_other_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_other_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The overall proportion (or total counts) of the categories are
computed. The &quot;other&quot; category is used in place of any categorical levels
whose individual proportion (or frequency) in the training set is less than
<code>threshold</code>.
</p>
<p>If no pooling is done the data are unmodified (although character data may
be changed to factors based on the value of <code>strings_as_factors</code> in
<code><a href="#topic+prep">prep()</a></code>). Otherwise, a factor is always returned with
different factor levels.
</p>
<p>If <code>threshold</code> is less than the largest category proportion, all levels
except for the most frequent are collapsed to the <code>other</code> level.
</p>
<p>If the retained categories include the value of <code>other</code>, an error is
thrown. If <code>other</code> is in the list of discarded levels, no error
occurs.
</p>
<p>If no pooling is done, novel factor levels are converted to missing. If
pooling is needed, they will be placed into the other category.
</p>
<p>When data to be processed contains novel levels (i.e., not
contained in the training set), the other category is assigned.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>retained</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>retained</dt><dd><p>character, factor levels not pulled into <code>"other"</code></p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>threshold</code>: Threshold (type: double, default: 0.05)
</p>
</li></ul>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dummy_names">dummy_names()</a></code>
</p>
<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

set.seed(19)
in_train &lt;- sample(1:nrow(Sacramento), size = 800)

sacr_tr &lt;- Sacramento[in_train, ]
sacr_te &lt;- Sacramento[-in_train, ]

rec &lt;- recipe(~ city + zip, data = sacr_tr)


rec &lt;- rec %&gt;%
  step_other(city, zip, threshold = .1, other = "other values")
rec &lt;- prep(rec, training = sacr_tr)

collapsed &lt;- bake(rec, sacr_te)
table(sacr_te$city, collapsed$city, useNA = "always")

tidy(rec, number = 1)

# novel levels are also "othered"
tahiti &lt;- Sacramento[1, ]
tahiti$zip &lt;- "a magical place"
bake(rec, tahiti)

# threshold as a frequency
rec &lt;- recipe(~ city + zip, data = sacr_tr)

rec &lt;- rec %&gt;%
  step_other(city, zip, threshold = 2000, other = "other values")
rec &lt;- prep(rec, training = sacr_tr)

tidy(rec, number = 1)
# compare it to
# sacr_tr %&gt;% count(city, sort = TRUE) %&gt;% top_n(4)
# sacr_tr %&gt;% count(zip, sort = TRUE) %&gt;% top_n(3)

</code></pre>

<hr>
<h2 id='step_pca'>PCA signal extraction</h2><span id='topic+step_pca'></span>

<h3>Description</h3>

<p><code>step_pca()</code> creates a <em>specification</em> of a recipe step that will convert
numeric variables into one or more principal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_pca(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_comp = 5,
  threshold = NA,
  options = list(),
  res = NULL,
  columns = NULL,
  prefix = "PC",
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("pca")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_pca_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_num_comp">num_comp</code></td>
<td>
<p>The number of components to retain as new predictors.
If <code>num_comp</code> is greater than the number of columns or the number of
possible components, a smaller value will be used. If <code>num_comp = 0</code>
is set then no transformation is done and selected variables will
stay unchanged, regardless of the value of <code>keep_original_cols</code>.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_threshold">threshold</code></td>
<td>
<p>A fraction of the total variance that should be covered by
the components. For example, <code>threshold = .75</code> means that <code>step_pca</code> should
generate enough components to capture 75 percent of the variability in the
variables. Note: using this argument will override and reset any value given
to <code>num_comp</code>.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_options">options</code></td>
<td>
<p>A list of options to the default method for
<code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>. Argument defaults are set to <code>retx = FALSE</code>, <code>center = FALSE</code>, <code>scale. = FALSE</code>, and <code>tol = NULL</code>. <strong>Note</strong> that the argument <code>x</code>
should not be passed here (or at all).</p>
</td></tr>
<tr><td><code id="step_pca_+3A_res">res</code></td>
<td>
<p>The <code><a href="stats.html#topic+prcomp">stats::prcomp.default()</a></code> object is stored here once this
preprocessing step has be trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_pca_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Principal component analysis (PCA) is a transformation of a
group of variables that produces a new set of artificial
features or components. These components are designed to capture
the maximum amount of information (i.e. variance) in the
original variables. Also, the components are statistically
independent from one another. This means that they can be used
to combat large inter-variables correlations in a data set.
</p>
<p>It is advisable to standardize the variables prior to running
PCA. Here, each variable will be centered and scaled prior to
the PCA calculation. This can be changed using the
<code>options</code> argument or by using <code><a href="#topic+step_center">step_center()</a></code>
and <code><a href="#topic+step_scale">step_scale()</a></code>.
</p>
<p>The argument <code>num_comp</code> controls the number of components that will be retained
(the original variables that are used to derive the components are removed from
the data). The new components will have names that begin with <code>prefix</code> and a
sequence of numbers. The variable names are padded with zeros. For example, if
<code>num_comp &lt; 10</code>, their names will be <code>PC1</code> - <code>PC9</code>. If <code>num_comp = 101</code>,
the names would be <code>PC1</code> - <code>PC101</code>.
</p>
<p>Alternatively, <code>threshold</code> can be used to determine the
number of components that are required to capture a specified
fraction of the total variance in the variables.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step two things can happen depending
the <code>type</code> argument. If <code>type = "coef"</code> a tibble returned with 4 columns
<code>terms</code>, <code>value</code>, <code>component</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, variable loading</p>
</dd>
<dt>component</dt><dd><p>character, principle component</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>

<p>If <code>type = "variance"</code> a tibble returned with 4 columns <code>terms</code>, <code>value</code>,
<code>component</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, type of variance</p>
</dd>
<dt>value</dt><dd><p>numeric, value of the variance</p>
</dd>
<dt>component</dt><dd><p>integer, principle component</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>num_comp</code>: # Components (type: integer, default: 5)
</p>
</li>
<li> <p><code>threshold</code>: Threshold (type: double, default: NA)
</p>
</li></ul>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>References</h3>

<p>Jolliffe, I. T. (2010). <em>Principal Component
Analysis</em>. Springer.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rec &lt;- recipe(~., data = USArrests)
pca_trans &lt;- rec %&gt;%
  step_normalize(all_numeric()) %&gt;%
  step_pca(all_numeric(), num_comp = 3)
pca_estimates &lt;- prep(pca_trans, training = USArrests)
pca_data &lt;- bake(pca_estimates, USArrests)

rng &lt;- extendrange(c(pca_data$PC1, pca_data$PC2))
plot(pca_data$PC1, pca_data$PC2,
  xlim = rng, ylim = rng
)

with_thresh &lt;- rec %&gt;%
  step_normalize(all_numeric()) %&gt;%
  step_pca(all_numeric(), threshold = .99)
with_thresh &lt;- prep(with_thresh, training = USArrests)
bake(with_thresh, USArrests)

tidy(pca_trans, number = 2)
tidy(pca_estimates, number = 2)
tidy(pca_estimates, number = 2, type = "variance")
</code></pre>

<hr>
<h2 id='step_percentile'>Percentile transformation</h2><span id='topic+step_percentile'></span>

<h3>Description</h3>

<p><code>step_percentile()</code> creates a <em>specification</em> of a recipe step that replaces
the value of a variable with its percentile from the training set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_percentile(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  ref_dist = NULL,
  options = list(probs = (0:100)/100),
  outside = "none",
  skip = FALSE,
  id = rand_id("percentile")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_percentile_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_percentile_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_percentile_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_percentile_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_percentile_+3A_ref_dist">ref_dist</code></td>
<td>
<p>The computed percentiles is stored here once this
preprocessing step has be trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_percentile_+3A_options">options</code></td>
<td>
<p>A named list of options to pass to <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.
See Details for more information.</p>
</td></tr>
<tr><td><code id="step_percentile_+3A_outside">outside</code></td>
<td>
<p>A character, describing how interpolation is to take place
outside the interval <code style="white-space: pre;">&#8288;[min(x), max(x)]&#8288;</code>. <code>none</code> means nothing will happen
and values outside the range will be <code>NA</code>. <code>lower</code> means that new values
less than <code>min(x)</code> will be given the value <code>0</code>. <code>upper</code> means that new
values larger than <code>max(x)</code> will be given the value <code>1</code>. <code>both</code> will handle
both cases. Defaults to <code>none</code>.</p>
</td></tr>
<tr><td><code id="step_percentile_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_percentile_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code>, <code>percentile</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the value at the percentile</p>
</dd>
<dt>percentile</dt><dd><p>numeric, the percentile as a percentage</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
) %&gt;%
  step_percentile(carbon)

prepped_rec &lt;- prep(rec)

prepped_rec %&gt;%
  bake(biomass_te)

tidy(rec, 1)
tidy(prepped_rec, 1)

</code></pre>

<hr>
<h2 id='step_pls'>Partial least squares feature extraction</h2><span id='topic+step_pls'></span>

<h3>Description</h3>

<p><code>step_pls()</code> creates a <em>specification</em> of a recipe step that will convert
numeric data into one or more new dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_pls(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  num_comp = 2,
  predictor_prop = 1,
  outcome = NULL,
  options = list(scale = TRUE),
  preserve = deprecated(),
  res = NULL,
  columns = NULL,
  prefix = "PLS",
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("pls")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_pls_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_num_comp">num_comp</code></td>
<td>
<p>The number of components to retain as new predictors.
If <code>num_comp</code> is greater than the number of columns or the number of
possible components, a smaller value will be used. If <code>num_comp = 0</code>
is set then no transformation is done and selected variables will
stay unchanged, regardless of the value of <code>keep_original_cols</code>.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_predictor_prop">predictor_prop</code></td>
<td>
<p>The maximum number of original predictors that can have
non-zero coefficients for each PLS component (via regularization).</p>
</td></tr>
<tr><td><code id="step_pls_+3A_outcome">outcome</code></td>
<td>
<p>When a single outcome is available, character string or call
to <code><a href="dplyr.html#topic+vars">dplyr::vars()</a></code> can be used to specify a single outcome variable.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_options">options</code></td>
<td>
<p>A list of options to <code>mixOmics::pls()</code>, <code>mixOmics::spls()</code>,
<code>mixOmics::plsda()</code>, or <code>mixOmics::splsda()</code> (depending on the data and
arguments).</p>
</td></tr>
<tr><td><code id="step_pls_+3A_preserve">preserve</code></td>
<td>
<p>Use <code>keep_original_cols</code> instead to specify whether the
original predictor data should be retained along with the new features.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_res">res</code></td>
<td>
<p>A list of results are stored here once this preprocessing step has
been trained by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_prefix">prefix</code></td>
<td>
<p>A character string for the prefix of the resulting new
variables. See notes below.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_pls_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PLS is a supervised version of principal component analysis that requires the
outcome data to compute the new features.
</p>
<p>This step requires the Bioconductor <span class="pkg">mixOmics</span> package. If not installed,
the step will stop with a note about installing the package. Install
<span class="pkg">mixOmics</span> using the pak package:
</p>
<div class="sourceCode r"><pre># install.packages("pak")
pak::pak("mixOmics")
</pre></div>
<p>The argument <code>num_comp</code> controls the number of components that will be retained
(the original variables that are used to derive the components are removed from
the data). The new components will have names that begin with <code>prefix</code> and a
sequence of numbers. The variable names are padded with zeros. For example, if
<code>num_comp &lt; 10</code>, their names will be <code>PLS1</code> - <code>PLS9</code>. If <code>num_comp = 101</code>,
the names would be <code>PLS1</code> - <code>PLS101</code>.
</p>
<p>Sparsity can be encouraged using the <code>predictor_prop</code> parameter. This affects
each PLS component, and indicates the maximum proportion of predictors with
non-zero coefficients in each component. <code>step_pls()</code> converts this
proportion to determine the <code>keepX</code> parameter in <code>mixOmics::spls()</code> and
<code>mixOmics::splsda()</code>. See the references in <code>mixOmics::spls()</code> for details.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code>, <code>component</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, coefficients defined as <code class="reqn">W(P'W)^{-1}</code></p>
</dd>
<dt>size</dt><dd><p>character, name of component</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>num_comp</code>: # Components (type: integer, default: 2)
</p>
</li>
<li> <p><code>predictor_prop</code>: Proportion of Predictors (type: double, default: 1)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Partial_least_squares_regression">https://en.wikipedia.org/wiki/Partial_least_squares_regression</a>
</p>
<p>Rohart F, Gautier B, Singh A, L Cao K-A (2017) <em>mixOmics: An R package for
'omics feature selection and multiple data integration</em>. PLoS Comput Biol
13(11): e1005752. <a href="https://doi.org/10.1371/journal.pcbi.1005752">doi:10.1371/journal.pcbi.1005752</a>
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# requires the Bioconductor mixOmics package
data(biomass, package = "modeldata")

biom_tr &lt;-
  biomass %&gt;%
  dplyr::filter(dataset == "Training") %&gt;%
  dplyr::select(-dataset, -sample)
biom_te &lt;-
  biomass %&gt;%
  dplyr::filter(dataset == "Testing") %&gt;%
  dplyr::select(-dataset, -sample, -HHV)

dense_pls &lt;-
  recipe(HHV ~ ., data = biom_tr) %&gt;%
  step_pls(all_numeric_predictors(), outcome = "HHV", num_comp = 3)

sparse_pls &lt;-
  recipe(HHV ~ ., data = biom_tr) %&gt;%
  step_pls(all_numeric_predictors(), outcome = "HHV", num_comp = 3,
           predictor_prop = 4 / 5)

## -----------------------------------------------------------------------------
## PLS discriminant analysis

data(cells, package = "modeldata")

cell_tr &lt;-
  cells %&gt;%
  dplyr::filter(case == "Train") %&gt;%
  dplyr::select(-case)
cell_te &lt;-
  cells %&gt;%
  dplyr::filter(case == "Test") %&gt;%
  dplyr::select(-case, -class)

dense_plsda &lt;-
  recipe(class ~ ., data = cell_tr) %&gt;%
  step_pls(all_numeric_predictors(), outcome = "class", num_comp = 5)

sparse_plsda &lt;-
  recipe(class ~ ., data = cell_tr) %&gt;%
  step_pls(all_numeric_predictors(), outcome = "class", num_comp = 5,
           predictor_prop = 1 / 4)

</code></pre>

<hr>
<h2 id='step_poly'>Orthogonal polynomial basis functions</h2><span id='topic+step_poly'></span>

<h3>Description</h3>

<p><code>step_poly()</code> creates a <em>specification</em> of a recipe step that will create new
columns that are basis expansions of variables using orthogonal polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_poly(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  objects = NULL,
  degree = 2,
  options = list(),
  keep_original_cols = FALSE,
  skip = FALSE,
  id = rand_id("poly")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_poly_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_poly_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_poly_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_poly_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_poly_+3A_objects">objects</code></td>
<td>
<p>A list of <code><a href="stats.html#topic+poly">stats::poly()</a></code> objects created once the step has
been trained.</p>
</td></tr>
<tr><td><code id="step_poly_+3A_degree">degree</code></td>
<td>
<p>The polynomial degree (an integer).</p>
</td></tr>
<tr><td><code id="step_poly_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="stats.html#topic+poly">stats::poly()</a></code> which should not include
<code>x</code>, <code>degree</code>, or <code>simple</code>. Note that the option <code>raw = TRUE</code> will produce
the regular polynomial values (not orthogonalized).</p>
</td></tr>
<tr><td><code id="step_poly_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_poly_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_poly_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step_poly()</code> can create new features from a single variable that enable
fitting routines to model this variable in a nonlinear manner. The extent of
the possible nonlinearity is determined by the <code>degree</code> argument of
<code><a href="stats.html#topic+poly">stats::poly()</a></code>. The original variables are removed from the data by default,
but can be retained by setting <code>keep_original_cols = TRUE</code> and new columns
are added. The naming convention for the new variables is <code>varname_poly_1</code>
and so on.
</p>
<p>The orthogonal polynomial expansion is used by default because it yields
variables that are uncorrelated and doesn't produce large values which would
otherwise be a problem for large values of <code>degree</code>. Orthogonal polynomial
expansion pick up the same signal as their uncorrelated counterpart.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>degree</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>degree</dt><dd><p>integer, the polynomial degree</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>degree</code>: Polynomial Degree (type: integer, default: 2)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

quadratic &lt;- rec %&gt;%
  step_poly(carbon, hydrogen)
quadratic &lt;- prep(quadratic, training = biomass_tr)

expanded &lt;- bake(quadratic, biomass_te)
expanded

tidy(quadratic, number = 1)

</code></pre>

<hr>
<h2 id='step_poly_bernstein'>Generalized bernstein polynomial basis</h2><span id='topic+step_poly_bernstein'></span>

<h3>Description</h3>

<p><code>step_poly_bernstein()</code> creates a <em>specification</em> of a recipe step that
creates Bernstein polynomial features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_poly_bernstein(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  degree = 10,
  complete_set = FALSE,
  options = NULL,
  keep_original_cols = FALSE,
  results = NULL,
  skip = FALSE,
  id = rand_id("poly_bernstein")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_poly_bernstein_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_degree">degree</code></td>
<td>
<p>The degrees of the polynomial. As the degrees for a polynomial
increase, more flexible and complex curves can be generated.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_complete_set">complete_set</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output. This maps to
the <code>intercept</code> argument of the corresponding function from the
<span class="pkg">splines2</span> package and has the same default value.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="splines2.html#topic+bernsteinPoly">splines2::bernsteinPoly()</a></code>
which should not include <code>x</code> or <code>degree</code>.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_results">results</code></td>
<td>
<p>A list of objects created once the step has been trained.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_poly_bernstein_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Polynomial transformations take a numeric column and create multiple features
that, when used in a model, can estimate nonlinear trends between the column
and some outcome. The degrees of freedom determines how many new features
are added to the data.
</p>
<p>If the spline expansion fails for a selected column, the step will
remove that column's results (but will retain the original data). Use the
<code>tidy()</code> method to determine which columns were used.
</p>


<h3>Value</h3>

<p>An object with classes <code>"step_poly_bernstein"</code> and <code>"step"</code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>degree</code>: Polynomial Degree (type: integer, default: 10)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="splines2.html#topic+bernsteinPoly">splines2::bernsteinPoly()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyr)
library(dplyr)

library(ggplot2)
data(ames, package = "modeldata")

spline_rec &lt;- recipe(Sale_Price ~ Longitude, data = ames) %&gt;%
  step_poly_bernstein(Longitude, degree = 6, keep_original_cols = TRUE) %&gt;%
  prep()

tidy(spline_rec, number = 1)

# Show where each feature is active
spline_rec %&gt;%
  bake(new_data =  NULL,-Sale_Price) %&gt;%
  pivot_longer(c(starts_with("Longitude_")), names_to = "feature", values_to = "value") %&gt;%
  mutate(feature = gsub("Longitude_", "feature ", feature)) %&gt;%
  filter(value &gt; 0) %&gt;%
  ggplot(aes(x = Longitude, y = value)) +
  geom_line() +
  facet_wrap(~ feature)

</code></pre>

<hr>
<h2 id='step_profile'>Create a profiling version of a data set</h2><span id='topic+step_profile'></span>

<h3>Description</h3>

<p><code>step_profile()</code> creates a <em>specification</em> of a recipe step that will fix the
levels of all variables but one and will create a sequence of values for the
remaining variable. This step can be helpful when creating partial regression
plots for additive models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_profile(
  recipe,
  ...,
  profile = NULL,
  pct = 0.5,
  index = 1,
  grid = list(pctl = TRUE, len = 100),
  columns = NULL,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = rand_id("profile")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_profile_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_profile">profile</code></td>
<td>
<p>A call to <code><a href="dplyr.html#topic+vars">dplyr::vars()</a></code>) to specify which
variable will be profiled (see <code><a href="#topic+selections">selections()</a></code>). If a column is
included in both lists to be fixed and to be profiled, an error
is thrown.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_pct">pct</code></td>
<td>
<p>A value between 0 and 1 that is the percentile to
fix continuous variables. This is applied to all continuous
variables captured by the selectors. For date variables, either
the minimum, median, or maximum used based on their distance to
<code>pct</code>.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_index">index</code></td>
<td>
<p>The level that qualitative variables will be
fixed. If the variables are character (not factors), this will
be the index of the sorted unique values. This is applied to all
qualitative variables captured by the selectors.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_grid">grid</code></td>
<td>
<p>A named list with elements <code>pctl</code> (a logical) and
<code>len</code> (an integer). If <code>pctl = TRUE</code>, then <code>len</code> denotes how
many percentiles to use to create the profiling grid. This
creates a grid between 0 and 1 and the profile is determined by
the percentiles of the data. For example, if <code>pctl = TRUE</code> and
<code>len = 3</code>, the profile would contain the minimum, median, and
maximum values. If <code>pctl = FALSE</code>, it defines how many grid
points between the minimum and maximum values should be created.
This parameter is ignored for qualitative variables (since all
of their possible levels are profiled). In the case of date
variables, <code>pctl = FALSE</code> will always be used since there is no
quantile method for dates.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_profile_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step is atypical in that, when baked, the
<code>new_data</code> argument is ignored; the resulting data set is
based on the fixed and profiled variable's information.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>type</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>type</dt><dd><p>character, <code>"fixed"</code> or <code>"profiled"</code></p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

# Setup a grid across beds but keep the other values fixed
recipe(~ city + price + beds, data = Sacramento) %&gt;%
  step_profile(-beds, profile = vars(beds)) %&gt;%
  prep(training = Sacramento) %&gt;%
  bake(new_data = NULL)

##########

# An *additive* model; not for use when there are interactions or
# other functional relationships between predictors

lin_mod &lt;- lm(mpg ~ poly(disp, 2) + cyl + hp, data = mtcars)

# Show the difference in the two grid creation methods

disp_pctl &lt;- recipe(~ disp + cyl + hp, data = mtcars) %&gt;%
  step_profile(-disp, profile = vars(disp)) %&gt;%
  prep(training = mtcars)

disp_grid &lt;- recipe(~ disp + cyl + hp, data = mtcars) %&gt;%
  step_profile(
    -disp,
    profile = vars(disp),
    grid = list(pctl = FALSE, len = 100)
  ) %&gt;%
  prep(training = mtcars)

grid_data &lt;- bake(disp_grid, new_data = NULL)
grid_data &lt;- grid_data %&gt;%
  mutate(
    pred = predict(lin_mod, grid_data),
    method = "grid"
  )

pctl_data &lt;- bake(disp_pctl, new_data = NULL)
pctl_data &lt;- pctl_data %&gt;%
  mutate(
    pred = predict(lin_mod, pctl_data),
    method = "percentile"
  )

plot_data &lt;- bind_rows(grid_data, pctl_data)

library(ggplot2)

ggplot(plot_data, aes(x = disp, y = pred)) +
  geom_point(alpha = .5, cex = 1) +
  facet_wrap(~method)

</code></pre>

<hr>
<h2 id='step_range'>Scaling numeric data to a specific range</h2><span id='topic+step_range'></span>

<h3>Description</h3>

<p><code>step_range()</code> creates a <em>specification</em> of a recipe step that will normalize
numeric data to be within a pre-defined range of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_range(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  min = 0,
  max = 1,
  clipping = TRUE,
  ranges = NULL,
  skip = FALSE,
  id = rand_id("range")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_range_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_range_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_range_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_range_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_range_+3A_min">min</code></td>
<td>
<p>A single numeric value for the smallest value in the
range.</p>
</td></tr>
<tr><td><code id="step_range_+3A_max">max</code></td>
<td>
<p>A single numeric value for the largest value in the
range.</p>
</td></tr>
<tr><td><code id="step_range_+3A_clipping">clipping</code></td>
<td>
<p>A single logical value for determining whether
application of transformation onto new data should be forced
to be inside <code>min</code> and <code>max</code>. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="step_range_+3A_ranges">ranges</code></td>
<td>
<p>A character vector of variables that will be
normalized. Note that this is ignored until the values are
determined by <code><a href="#topic+prep">prep()</a></code>. Setting this value will
be ineffective.</p>
</td></tr>
<tr><td><code id="step_range_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_range_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a new data point is outside of the ranges seen in
the training set, the new values are truncated at <code>min</code> or
<code>max</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>min</code>, <code>max</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>min</dt><dd><p>numeric, lower range</p>
</dd>
<dt>max</dt><dd><p>numeric, upper range</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other normalization steps: 
<code><a href="#topic+step_center">step_center</a>()</code>,
<code><a href="#topic+step_normalize">step_normalize</a>()</code>,
<code><a href="#topic+step_scale">step_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

ranged_trans &lt;- rec %&gt;%
  step_range(carbon, hydrogen)

ranged_obj &lt;- prep(ranged_trans, training = biomass_tr)

transformed_te &lt;- bake(ranged_obj, biomass_te)

biomass_te[1:10, names(transformed_te)]
transformed_te

tidy(ranged_trans, number = 1)
tidy(ranged_obj, number = 1)

</code></pre>

<hr>
<h2 id='step_ratio'>Ratio variable creation</h2><span id='topic+step_ratio'></span><span id='topic+denom_vars'></span>

<h3>Description</h3>

<p><code>step_ratio()</code> creates a <em>specification</em> of a recipe step that will create
one or more ratios from selected numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ratio(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  denom = denom_vars(),
  naming = function(numer, denom) {
     make.names(paste(numer, denom, sep = "_o_"))
 },
  columns = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("ratio")
)

denom_vars(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ratio_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variables will be used in the <em>numerator</em> of the ratio.
When used with <code>denom_vars</code>, the dots indicate which
variables are used in the <em>denominator</em>. See
<code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_denom">denom</code></td>
<td>
<p>A call to <code>denom_vars</code> to specify which
variables are used in the denominator that can include specific
variable names separated by commas or different selectors (see
<code><a href="#topic+selections">selections()</a></code>). If a column is included in both lists
to be numerator and denominator, it will be removed from the
listing.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_naming">naming</code></td>
<td>
<p>A function that defines the naming convention for
new ratio columns.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_ratio_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble with columns
<code>terms</code> (the selectors or variables selected) and <code>denom</code> is returned.
</p>
<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>denom</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>denom</dt><dd><p>character, name of denominator selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_spatialsign">step_spatialsign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
data(biomass, package = "modeldata")

biomass$total &lt;- apply(biomass[, 3:7], 1, sum)
biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(HHV ~ carbon + hydrogen + oxygen + nitrogen +
  sulfur + total,
data = biomass_tr
)

ratio_recipe &lt;- rec %&gt;%
  # all predictors over total
  step_ratio(all_numeric_predictors(), denom = denom_vars(total),
             keep_original_cols = FALSE)

ratio_recipe &lt;- prep(ratio_recipe, training = biomass_tr)

ratio_data &lt;- bake(ratio_recipe, biomass_te)
ratio_data

</code></pre>

<hr>
<h2 id='step_regex'>Detect a regular expression</h2><span id='topic+step_regex'></span>

<h3>Description</h3>

<p><code>step_regex()</code> creates a <em>specification</em> of a recipe step that will create a
new dummy variable based on a regular expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_regex(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  pattern = ".",
  options = list(),
  result = make.names(pattern),
  input = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("regex")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_regex_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_...">...</code></td>
<td>
<p>A single selector function to choose which variable
will be searched for the regex pattern. The selector should resolve
to a single variable. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_pattern">pattern</code></td>
<td>
<p>A character string containing a regular
expression (or character string for <code>fixed = TRUE</code>) to be
matched in the given character vector. Coerced by
<code>as.character</code> to a character string if possible.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_options">options</code></td>
<td>
<p>A list of options to <code><a href="base.html#topic+grepl">grepl()</a></code> that
should not include <code>x</code> or <code>pattern</code>.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_result">result</code></td>
<td>
<p>A single character value for the name of the new
variable. It should be a valid column name.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_input">input</code></td>
<td>
<p>A single character value for the name of the
variable being searched. This is <code>NULL</code> until computed by
<code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_regex_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>result</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>result</dt><dd><p>character, new column name</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(covers, package = "modeldata")

rec &lt;- recipe(~description, covers) %&gt;%
  step_regex(description, pattern = "(rock|stony)", result = "rocks") %&gt;%
  step_regex(description, pattern = "ratake families")

rec2 &lt;- prep(rec, training = covers)
rec2

with_dummies &lt;- bake(rec2, new_data = covers)
with_dummies
tidy(rec, number = 1)
tidy(rec2, number = 1)

</code></pre>

<hr>
<h2 id='step_relevel'>Relevel factors to a desired level</h2><span id='topic+step_relevel'></span>

<h3>Description</h3>

<p><code>step_relevel()</code> creates a <em>specification</em> of a recipe step that will reorder
the provided factor columns so that the level specified by <code>ref_level</code> is
first. This is useful for <code><a href="stats.html#topic+contr.treatment">contr.treatment()</a></code> contrasts which take the first
level as the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_relevel(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  ref_level,
  objects = NULL,
  skip = FALSE,
  id = rand_id("relevel")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_relevel_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_relevel_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_relevel_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_relevel_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_relevel_+3A_ref_level">ref_level</code></td>
<td>
<p>A single character value that will be used to
relevel the factor column(s) (if the level is present).</p>
</td></tr>
<tr><td><code id="step_relevel_+3A_objects">objects</code></td>
<td>
<p>A list of objects that contain the information
on factor levels that will be determined by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_relevel_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_relevel_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selected variables are releveled to a level
(given by <code>ref_level</code>), placing the <code>ref_level</code> in the first
position.
</p>
<p>Note that if the original columns are character, they will be
converted to factors by this step.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>character, the value of <code>ref_level</code></p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")
rec &lt;- recipe(~ city + zip, data = Sacramento) %&gt;%
  step_unknown(city, new_level = "UNKNOWN") %&gt;%
  step_relevel(city, ref_level = "UNKNOWN") %&gt;%
  prep()

data &lt;- bake(rec, Sacramento)
levels(data$city)

</code></pre>

<hr>
<h2 id='step_relu'>Apply (smoothed) rectified linear transformation</h2><span id='topic+step_relu'></span>

<h3>Description</h3>

<p><code>step_relu()</code> creates a <em>specification</em> of a recipe step that will add the
rectified linear or softplus transformations of a variable to the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_relu(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  shift = 0,
  reverse = FALSE,
  smooth = FALSE,
  prefix = "right_relu_",
  columns = NULL,
  skip = FALSE,
  id = rand_id("relu")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_relu_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_shift">shift</code></td>
<td>
<p>A numeric value dictating a translation to apply to the data.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_reverse">reverse</code></td>
<td>
<p>A logical to indicate if the left hinge should be used as
opposed to the right hinge.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_smooth">smooth</code></td>
<td>
<p>A logical indicating if the softplus function, a smooth
approximation to the rectified linear transformation, should be used.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_prefix">prefix</code></td>
<td>
<p>A prefix for generated column names, defaults to &quot;right_relu_&quot;
for right hinge transformation and &quot;left_relu_&quot; for reversed/left hinge
transformations.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_relu_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rectified linear transformation is calculated as
</p>
<p style="text-align: center;"><code class="reqn">max(0, x - c)</code>
</p>
<p> and is also known as the ReLu or right hinge function.
If <code>reverse</code> is true, then the transformation is reflected about the
y-axis, like so: </p>
<p style="text-align: center;"><code class="reqn">max(0, c - x)</code>
</p>
<p> Setting the <code>smooth</code> option
to true will instead calculate a smooth approximation to ReLu
according to </p>
<p style="text-align: center;"><code class="reqn">ln(1 + e^(x - c)</code>
</p>
<p> The <code>reverse</code> argument may
also be applied to this transformation.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Connection to MARS:</h3>

<p>The rectified linear transformation is used in Multivariate Adaptive
Regression Splines as a basis function to fit piecewise linear functions to
data in a strategy similar to that employed in tree based models. The
transformation is a popular choice as an activation function in many
neural networks, which could then be seen as a stacked generalization of
MARS when making use of ReLu activations. The hinge function also appears
in the loss function of Support Vector Machines, where it penalizes
residuals only if they are within a certain margin of the decision boundary.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>shift</code>, <code>reverse</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>shift</dt><dd><p>numeric, location of hinge</p>
</dd>
<dt>reverse</dt><dd><p>logical, whether left hinge is used</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

transformed_te &lt;- rec %&gt;%
  step_relu(carbon, shift = 40) %&gt;%
  prep(biomass_tr) %&gt;%
  bake(biomass_te)

transformed_te

</code></pre>

<hr>
<h2 id='step_rename'>Rename variables by name using dplyr</h2><span id='topic+step_rename'></span>

<h3>Description</h3>

<p><code>step_rename()</code> creates a <em>specification</em> of a recipe step that will add
variables using <code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_rename(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  inputs = NULL,
  skip = FALSE,
  id = rand_id("rename")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_rename_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_rename_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas. See
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> where the convention is <strong><code>new_name = old_name</code></strong>.</p>
</td></tr>
<tr><td><code id="step_rename_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_rename_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_rename_+3A_inputs">inputs</code></td>
<td>
<p>Quosure(s) of <code>...</code>.</p>
</td></tr>
<tr><td><code id="step_rename_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_rename_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an object in the user's global environment is referenced in
the expression defining the new variable(s), it is a good idea to use
quasiquotation (e.g. <code style="white-space: pre;">&#8288;!!&#8288;</code>) to embed the value of the object in the
expression (to be portable between sessions).
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>character, <code>rename</code> expression</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dplyr steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_rename_at">step_rename_at</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recipe(~., data = iris) %&gt;%
  step_rename(Sepal_Width = Sepal.Width) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  slice(1:5)

vars &lt;- c(var1 = "cyl", var2 = "am")
car_rec &lt;-
  recipe(~., data = mtcars) %&gt;%
  step_rename(!!!vars)

car_rec %&gt;%
  prep() %&gt;%
  bake(new_data = NULL)

car_rec %&gt;%
  tidy(number = 1)
</code></pre>

<hr>
<h2 id='step_rename_at'>Rename multiple columns using dplyr</h2><span id='topic+step_rename_at'></span>

<h3>Description</h3>

<p><code>step_rename_at()</code> creates a <em>specification</em> of a recipe step that will
rename the selected variables using a common function via
<code><a href="dplyr.html#topic+select_all">dplyr::rename_at()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_rename_at(
  recipe,
  ...,
  fn,
  role = "predictor",
  trained = FALSE,
  inputs = NULL,
  skip = FALSE,
  id = rand_id("rename_at")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_rename_at_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_rename_at_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_rename_at_+3A_fn">fn</code></td>
<td>
<p>A function <code>fun</code>, a quosure style lambda '~ fun(.)&ldquo; or a list of
either form (but containing only a single function, see <code><a href="dplyr.html#topic+select_all">dplyr::rename_at()</a></code>).
<strong>Note that this argument must be named</strong>.</p>
</td></tr>
<tr><td><code id="step_rename_at_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_rename_at_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_rename_at_+3A_inputs">inputs</code></td>
<td>
<p>A vector of column names populated by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_rename_at_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_rename_at_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dplyr steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_rename">step_rename</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
recipe(~., data = iris) %&gt;%
  step_rename_at(everything(), fn = ~ gsub(".", "_", ., fixed = TRUE)) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  slice(1:10)
</code></pre>

<hr>
<h2 id='step_rm'>General variable filter</h2><span id='topic+step_rm'></span>

<h3>Description</h3>

<p><code>step_rm()</code> creates a <em>specification</em> of a recipe step that will remove
selected variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_rm(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  removals = NULL,
  skip = FALSE,
  id = rand_id("rm")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_rm_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_rm_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_rm_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_rm_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_rm_+3A_removals">removals</code></td>
<td>
<p>A character string that contains the names of
columns that should be removed. These values are not determined
until <code><a href="#topic+prep">prep()</a></code> is called.</p>
</td></tr>
<tr><td><code id="step_rm_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_rm_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step can potentially remove columns from the data set. This may
cause issues for subsequent steps in your recipe if the missing columns are
specifically referenced by name. To avoid this, see the advice in the
<em>Tips for saving recipes and filtering columns</em> section of <a href="#topic+selections">selections</a>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other variable filter steps: 
<code><a href="#topic+step_corr">step_corr</a>()</code>,
<code><a href="#topic+step_filter_missing">step_filter_missing</a>()</code>,
<code><a href="#topic+step_lincomb">step_lincomb</a>()</code>,
<code><a href="#topic+step_nzv">step_nzv</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_zv">step_zv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

library(dplyr)
smaller_set &lt;- rec %&gt;%
  step_rm(contains("gen"))

smaller_set &lt;- prep(smaller_set, training = biomass_tr)

filtered_te &lt;- bake(smaller_set, biomass_te)
filtered_te

tidy(smaller_set, number = 1)

</code></pre>

<hr>
<h2 id='step_sample'>Sample rows using dplyr</h2><span id='topic+step_sample'></span>

<h3>Description</h3>

<p><code>step_sample()</code> creates a <em>specification</em> of a recipe step that will sample
rows using <code><a href="dplyr.html#topic+sample_n">dplyr::sample_n()</a></code> or <code><a href="dplyr.html#topic+sample_n">dplyr::sample_frac()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_sample(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  size = NULL,
  replace = FALSE,
  skip = TRUE,
  id = rand_id("sample")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_sample_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_sample_+3A_...">...</code></td>
<td>
<p>Argument ignored; included for consistency with other step
specification functions.</p>
</td></tr>
<tr><td><code id="step_sample_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_sample_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_sample_+3A_size">size</code></td>
<td>
<p>An integer or fraction. If the value is within (0, 1),
<code><a href="dplyr.html#topic+sample_n">dplyr::sample_frac()</a></code> is applied to the data. If an integer
value of 1 or greater is used, <code><a href="dplyr.html#topic+sample_n">dplyr::sample_n()</a></code> is applied.
The default of <code>NULL</code> uses <code><a href="dplyr.html#topic+sample_n">dplyr::sample_n()</a></code> with the size
of the training set (or smaller for smaller <code>new_data</code>).</p>
</td></tr>
<tr><td><code id="step_sample_+3A_replace">replace</code></td>
<td>
<p>Sample with or without replacement?</p>
</td></tr>
<tr><td><code id="step_sample_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_sample_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Row Filtering</h3>

<p>This step can entirely remove observations (rows of data), which can have
unintended and/or problematic consequences when applying the step to new
data later via <code><a href="#topic+bake">bake()</a></code>. Consider whether <code>skip = TRUE</code> or
<code>skip = FALSE</code> is more appropriate in any given use case. In most instances
that affect the rows of the data being predicted, this step probably should
not be applied at all; instead, execute operations like this outside and
before starting a preprocessing <code><a href="#topic+recipe">recipe()</a></code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>size</code>, <code>replace</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>size</dt><dd><p>numeric, amount of sampling</p>
</dd>
<dt>replace</dt><dd><p>logical, whether sampling is done with replacement</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other row operation steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>,
<code><a href="#topic+step_lag">step_lag</a>()</code>,
<code><a href="#topic+step_naomit">step_naomit</a>()</code>,
<code><a href="#topic+step_shuffle">step_shuffle</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>
<p>Other dplyr steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_rename_at">step_rename_at</a>()</code>,
<code><a href="#topic+step_rename">step_rename</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Uses `sample_n`
recipe(~., data = mtcars) %&gt;%
  step_sample(size = 1) %&gt;%
  prep(training = mtcars) %&gt;%
  bake(new_data = NULL) %&gt;%
  nrow()

# Uses `sample_frac`
recipe(~., data = mtcars) %&gt;%
  step_sample(size = 0.9999) %&gt;%
  prep(training = mtcars) %&gt;%
  bake(new_data = NULL) %&gt;%
  nrow()

# Uses `sample_n` and returns _at maximum_ 20 samples.
smaller_cars &lt;-
  recipe(~., data = mtcars) %&gt;%
  step_sample() %&gt;%
  prep(training = mtcars %&gt;% slice(1:20))

bake(smaller_cars, new_data = NULL) %&gt;% nrow()
bake(smaller_cars, new_data = mtcars %&gt;% slice(21:32)) %&gt;% nrow()
</code></pre>

<hr>
<h2 id='step_scale'>Scaling mumeric data</h2><span id='topic+step_scale'></span>

<h3>Description</h3>

<p><code>step_scale()</code> creates a <em>specification</em> of a recipe step that will normalize
numeric data to have a standard deviation of one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_scale(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  sds = NULL,
  factor = 1,
  na_rm = TRUE,
  skip = FALSE,
  id = rand_id("scale")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_scale_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_scale_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_scale_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_scale_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_scale_+3A_sds">sds</code></td>
<td>
<p>A named numeric vector of standard deviations. This is <code>NULL</code>
until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_scale_+3A_factor">factor</code></td>
<td>
<p>A numeric value of either 1 or 2 that scales the
numeric inputs by one or two standard deviations. By dividing
by two standard deviations, the coefficients attached to
continuous predictors can be interpreted the same way as with
binary inputs. Defaults to <code>1</code>. More in reference below.</p>
</td></tr>
<tr><td><code id="step_scale_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical value indicating whether <code>NA</code>
values should be removed when computing the standard deviation.</p>
</td></tr>
<tr><td><code id="step_scale_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_scale_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scaling data means that the standard deviation of a
variable is divided out of the data. <code>step_scale</code> estimates
the variable standard deviations from the data used in the
<code>training</code> argument of <code>prep.recipe</code>.
<code>bake.recipe</code> then applies the scaling to new data sets
using these standard deviations.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the standard deviations</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, case weights are only used with frequency weights. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>References</h3>

<p>Gelman, A. (2007) &quot;Scaling regression inputs by
dividing by two standard deviations.&quot; Unpublished. Source:
<a href="http://www.stat.columbia.edu/~gelman/research/unpublished/standardizing.pdf">http://www.stat.columbia.edu/~gelman/research/unpublished/standardizing.pdf</a>.
</p>


<h3>See Also</h3>

<p>Other normalization steps: 
<code><a href="#topic+step_center">step_center</a>()</code>,
<code><a href="#topic+step_normalize">step_normalize</a>()</code>,
<code><a href="#topic+step_range">step_range</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

scaled_trans &lt;- rec %&gt;%
  step_scale(carbon, hydrogen)

scaled_obj &lt;- prep(scaled_trans, training = biomass_tr)

transformed_te &lt;- bake(scaled_obj, biomass_te)

biomass_te[1:10, names(transformed_te)]
transformed_te
tidy(scaled_trans, number = 1)
tidy(scaled_obj, number = 1)

</code></pre>

<hr>
<h2 id='step_select'>Select variables using dplyr</h2><span id='topic+step_select'></span>

<h3>Description</h3>

<p><code>step_select()</code> creates a <em>specification</em> of a recipe step that will select
variables using <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_select(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  skip = FALSE,
  id = rand_id("select")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_select_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_select_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_select_+3A_role">role</code></td>
<td>
<p>For model terms selected by this step, what analysis
role should they be assigned?</p>
</td></tr>
<tr><td><code id="step_select_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_select_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_select_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an object in the user's global environment is
referenced in the expression defining the new variable(s),
it is a good idea to use quasiquotation (e.g. <code style="white-space: pre;">&#8288;!!&#8288;</code>) to embed
the value of the object in the expression (to be portable
between sessions). See the examples.
</p>
<p>This step can potentially remove columns from the data set. This may
cause issues for subsequent steps in your recipe if the missing columns are
specifically referenced by name. To avoid this, see the advice in the
<em>Tips for saving recipes and filtering columns</em> section of <a href="#topic+selections">selections</a>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other variable filter steps: 
<code><a href="#topic+step_corr">step_corr</a>()</code>,
<code><a href="#topic+step_filter_missing">step_filter_missing</a>()</code>,
<code><a href="#topic+step_lincomb">step_lincomb</a>()</code>,
<code><a href="#topic+step_nzv">step_nzv</a>()</code>,
<code><a href="#topic+step_rm">step_rm</a>()</code>,
<code><a href="#topic+step_zv">step_zv</a>()</code>
</p>
<p>Other dplyr steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_rename_at">step_rename_at</a>()</code>,
<code><a href="#topic+step_rename">step_rename</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

iris_tbl &lt;- as_tibble(iris)
iris_train &lt;- slice(iris_tbl, 1:75)
iris_test &lt;- slice(iris_tbl, 76:150)

dplyr_train &lt;- select(iris_train, Species, starts_with("Sepal"))
dplyr_test &lt;- select(iris_test, Species, starts_with("Sepal"))

rec &lt;- recipe(~., data = iris_train) %&gt;%
  step_select(Species, starts_with("Sepal")) %&gt;%
  prep(training = iris_train)

rec_train &lt;- bake(rec, new_data = NULL)
all.equal(dplyr_train, rec_train)

rec_test &lt;- bake(rec, iris_test)
all.equal(dplyr_test, rec_test)

# Local variables
sepal_vars &lt;- c("Sepal.Width", "Sepal.Length")

qq_rec &lt;-
  recipe(~., data = iris_train) %&gt;%
  # fine for interactive usage
  step_select(Species, all_of(sepal_vars)) %&gt;%
  # best approach for saving a recipe to disk
  step_select(Species, all_of(!!sepal_vars))

# Note that `sepal_vars` is inlined in the second approach
qq_rec
</code></pre>

<hr>
<h2 id='step_shuffle'>Shuffle variables</h2><span id='topic+step_shuffle'></span>

<h3>Description</h3>

<p><code>step_shuffle()</code> creates a <em>specification</em> of a recipe step that will
randomly change the order of rows for selected variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_shuffle(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("shuffle")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_shuffle_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_shuffle_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_shuffle_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_shuffle_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_shuffle_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_shuffle_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_shuffle_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other row operation steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>,
<code><a href="#topic+step_lag">step_lag</a>()</code>,
<code><a href="#topic+step_naomit">step_naomit</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_slice">step_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>integers &lt;- data.frame(A = 1:12, B = 13:24, C = 25:36)

library(dplyr)
rec &lt;- recipe(~ A + B + C, data = integers) %&gt;%
  step_shuffle(A, B)

rand_set &lt;- prep(rec, training = integers)

set.seed(5377)
bake(rand_set, integers)

tidy(rec, number = 1)
tidy(rand_set, number = 1)
</code></pre>

<hr>
<h2 id='step_slice'>Filter rows by position using dplyr</h2><span id='topic+step_slice'></span>

<h3>Description</h3>

<p><code>step_slice()</code> creates a <em>specification</em> of a recipe step that will filter
rows using <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_slice(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  inputs = NULL,
  skip = TRUE,
  id = rand_id("slice")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_slice_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_slice_+3A_...">...</code></td>
<td>
<p>Integer row values. See
<code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_slice_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_slice_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_slice_+3A_inputs">inputs</code></td>
<td>
<p>Quosure of values given by <code>...</code>.</p>
</td></tr>
<tr><td><code id="step_slice_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_slice_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an object in the user's global environment is
referenced in the expression defining the new variable(s),
it is a good idea to use quasiquotation (e.g. <code style="white-space: pre;">&#8288;!!&#8288;</code>)
to embed the value of the object in the expression (to
be portable between sessions). See the examples.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Row Filtering</h3>

<p>This step can entirely remove observations (rows of data), which can have
unintended and/or problematic consequences when applying the step to new
data later via <code><a href="#topic+bake">bake()</a></code>. Consider whether <code>skip = TRUE</code> or
<code>skip = FALSE</code> is more appropriate in any given use case. In most instances
that affect the rows of the data being predicted, this step probably should
not be applied at all; instead, execute operations like this outside and
before starting a preprocessing <code><a href="#topic+recipe">recipe()</a></code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, containing the filtering indices</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other row operation steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_impute_roll">step_impute_roll</a>()</code>,
<code><a href="#topic+step_lag">step_lag</a>()</code>,
<code><a href="#topic+step_naomit">step_naomit</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_shuffle">step_shuffle</a>()</code>
</p>
<p>Other dplyr steps: 
<code><a href="#topic+step_arrange">step_arrange</a>()</code>,
<code><a href="#topic+step_filter">step_filter</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_rename_at">step_rename_at</a>()</code>,
<code><a href="#topic+step_rename">step_rename</a>()</code>,
<code><a href="#topic+step_sample">step_sample</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rec &lt;- recipe(~., data = iris) %&gt;%
  step_slice(1:3)

prepped &lt;- prep(rec, training = iris %&gt;% slice(1:75))
tidy(prepped, number = 1)

library(dplyr)

dplyr_train &lt;-
  iris %&gt;%
  as_tibble() %&gt;%
  slice(1:75) %&gt;%
  slice(1:3)

rec_train &lt;- bake(prepped, new_data = NULL)
all.equal(dplyr_train, rec_train)

dplyr_test &lt;-
  iris %&gt;%
  as_tibble() %&gt;%
  slice(76:150)

rec_test &lt;- bake(prepped, iris %&gt;% slice(76:150))
all.equal(dplyr_test, rec_test)

# Embedding the integer expression (or vector) into the
# recipe:

keep_rows &lt;- 1:6

qq_rec &lt;-
  recipe(~., data = iris) %&gt;%
  # Embed `keep_rows` in the call using !!!
  step_slice(!!!keep_rows) %&gt;%
  prep(training = iris)

tidy(qq_rec, number = 1)
</code></pre>

<hr>
<h2 id='step_spatialsign'>Spatial sign preprocessing</h2><span id='topic+step_spatialsign'></span>

<h3>Description</h3>

<p><code>step_spatialsign()</code> is a <em>specification</em> of a recipe step that will convert
numeric data into a projection on to a unit sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_spatialsign(
  recipe,
  ...,
  role = "predictor",
  na_rm = TRUE,
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("spatialsign")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_spatialsign_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_spatialsign_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_spatialsign_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_spatialsign_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical: should missing data be removed from the
norm computation?</p>
</td></tr>
<tr><td><code id="step_spatialsign_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_spatialsign_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_spatialsign_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_spatialsign_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial sign transformation projects the variables
onto a unit sphere and is related to global contrast
normalization. The spatial sign of a vector <code>w</code> is
<code>w/norm(w)</code>.
</p>
<p>The variables should be centered and scaled prior to the
computations.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
As a result, only frequency weights are allowed. For more
information, see the documentation in <a href="#topic+case_weights">case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>
<p>Unlike most, this step requires the case weights to be available when new
samples are processed (e.g., when <code>bake()</code> is used or <code>predict()</code> with a
workflow). To tell recipes that the case weights are required at bake time,
use
<code>recipe %&gt;% update_role_requirements(role = "case_weights", bake = TRUE)</code>.
See <code><a href="#topic+update_role_requirements">update_role_requirements()</a></code> for more information.
</p>


<h3>References</h3>

<p>Serneels, S., De Nolf, E., and Van Espen, P.
(2006). Spatial sign preprocessing: a simple way to impart
moderate robustness to multivariate estimators. <em>Journal of
Chemical Information and Modeling</em>, 46(3), 1402-1409.
</p>


<h3>See Also</h3>

<p>Other multivariate transformation steps: 
<code><a href="#topic+step_classdist_shrunken">step_classdist_shrunken</a>()</code>,
<code><a href="#topic+step_classdist">step_classdist</a>()</code>,
<code><a href="#topic+step_depth">step_depth</a>()</code>,
<code><a href="#topic+step_geodist">step_geodist</a>()</code>,
<code><a href="#topic+step_ica">step_ica</a>()</code>,
<code><a href="#topic+step_isomap">step_isomap</a>()</code>,
<code><a href="#topic+step_kpca_poly">step_kpca_poly</a>()</code>,
<code><a href="#topic+step_kpca_rbf">step_kpca_rbf</a>()</code>,
<code><a href="#topic+step_kpca">step_kpca</a>()</code>,
<code><a href="#topic+step_mutate_at">step_mutate_at</a>()</code>,
<code><a href="#topic+step_nnmf_sparse">step_nnmf_sparse</a>()</code>,
<code><a href="#topic+step_nnmf">step_nnmf</a>()</code>,
<code><a href="#topic+step_pca">step_pca</a>()</code>,
<code><a href="#topic+step_pls">step_pls</a>()</code>,
<code><a href="#topic+step_ratio">step_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

ss_trans &lt;- rec %&gt;%
  step_center(carbon, hydrogen) %&gt;%
  step_scale(carbon, hydrogen) %&gt;%
  step_spatialsign(carbon, hydrogen)

ss_obj &lt;- prep(ss_trans, training = biomass_tr)

transformed_te &lt;- bake(ss_obj, biomass_te)

plot(biomass_te$carbon, biomass_te$hydrogen)

plot(transformed_te$carbon, transformed_te$hydrogen)

tidy(ss_trans, number = 3)
tidy(ss_obj, number = 3)

</code></pre>

<hr>
<h2 id='step_spline_b'>Basis splines</h2><span id='topic+step_spline_b'></span>

<h3>Description</h3>

<p><code>step_spline_b()</code> creates a <em>specification</em> of a recipe step that creates
b-spline features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_spline_b(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  deg_free = 10,
  degree = 3,
  complete_set = FALSE,
  options = NULL,
  keep_original_cols = FALSE,
  results = NULL,
  skip = FALSE,
  id = rand_id("spline_b")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_spline_b_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_deg_free">deg_free</code></td>
<td>
<p>The degrees of freedom for the b-spline. As the
degrees of freedom for a b-spline increase, more flexible and
complex curves can be generated.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_degree">degree</code></td>
<td>
<p>A non-negative integer specifying the degree of the piece-wise
polynomial. The default value is 3 for cubic splines. Zero degree is allowed
for piece-wise constant basis functions.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_complete_set">complete_set</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output. This maps to
the <code>intercept</code> argument of the corresponding function from the
<span class="pkg">splines2</span> package and has the same default value.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="splines2.html#topic+bSpline">splines2::bSpline()</a></code>
which should not include <code>x</code>, <code>df</code>, <code>degree</code>, or <code>intercept</code>.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_results">results</code></td>
<td>
<p>A list of objects created once the step has been trained.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_spline_b_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spline transformations take a numeric column and create multiple features
that, when used in a model, can estimate nonlinear trends between the column
and some outcome. The degrees of freedom determines how many new features
are added to the data.
</p>
<p>Setting <code>periodic = TRUE</code> in the list passed to <code>options</code>, a periodic version
of the spline is used.
</p>
<p>If the spline expansion fails for a selected column, the step will
remove that column's results (but will retain the original data). Use the
<code>tidy()</code> method to determine which columns were used.
</p>


<h3>Value</h3>

<p>An object with classes <code>"step_spline_b"</code> and <code>"step"</code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>deg_free</code>: Spline Degrees of Freedom (type: integer, default: 10)
</p>
</li>
<li> <p><code>degree</code>: Polynomial Degree (type: integer, default: 3)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="splines2.html#topic+bSpline">splines2::bSpline()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyr)
library(dplyr)

library(ggplot2)
data(ames, package = "modeldata")

spline_rec &lt;- recipe(Sale_Price ~ Longitude, data = ames) %&gt;%
  step_spline_b(Longitude, deg_free = 6, keep_original_cols = TRUE) %&gt;%
  prep()

tidy(spline_rec, number = 1)

# Show where each feature is active
spline_rec %&gt;%
  bake(new_data =  NULL,-Sale_Price) %&gt;%
  pivot_longer(c(starts_with("Longitude_")), names_to = "feature", values_to = "value") %&gt;%
  mutate(feature = gsub("Longitude_", "feature ", feature)) %&gt;%
  filter(value &gt; 0) %&gt;%
  ggplot(aes(x = Longitude, y = value)) +
  geom_line() +
  facet_wrap(~ feature)

</code></pre>

<hr>
<h2 id='step_spline_convex'>Convex splines</h2><span id='topic+step_spline_convex'></span>

<h3>Description</h3>

<p><code>step_spline_convex()</code> creates a <em>specification</em> of a recipe step that
creates convex spline features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_spline_convex(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  deg_free = 10,
  degree = 3,
  complete_set = TRUE,
  options = NULL,
  keep_original_cols = FALSE,
  results = NULL,
  skip = FALSE,
  id = rand_id("spline_convex")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_spline_convex_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_deg_free">deg_free</code></td>
<td>
<p>The degrees of freedom for the b-spline. As the
degrees of freedom for a b-spline increase, more flexible and
complex curves can be generated.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_degree">degree</code></td>
<td>
<p>The degree of C-spline defined to be the degree of the
associated M-spline instead of actual polynomial degree. For example,
C-spline basis of degree 2 is defined as the scaled double integral of
associated M-spline basis of degree 2.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_complete_set">complete_set</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output. This maps to
the <code>intercept</code> argument of the corresponding function from the
<span class="pkg">splines2</span> package and has the same default value.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="splines2.html#topic+cSpline">splines2::cSpline()</a></code>
which should not include <code>x</code>, <code>df</code>, <code>degree</code>, or <code>intercept</code>.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_results">results</code></td>
<td>
<p>A list of objects created once the step has been trained.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_spline_convex_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spline transformations take a numeric column and create multiple features
that, when used in a model, can estimate nonlinear trends between the column
and some outcome. The degrees of freedom determines how many new features
are added to the data.
</p>
<p>These particular spline functions have forms that are guaranteed to be
convex.
</p>
<p>If the spline expansion fails for a selected column, the step will
remove that column's results (but will retain the original data). Use the
<code>tidy()</code> method to determine which columns were used.
</p>


<h3>Value</h3>

<p>An object with classes <code>"step_spline_convex"</code> and <code>"step"</code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>deg_free</code>: Spline Degrees of Freedom (type: integer, default: 10)
</p>
</li>
<li> <p><code>degree</code>: Polynomial Degree (type: integer, default: 3)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="splines2.html#topic+cSpline">splines2::cSpline()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyr)
library(dplyr)

library(ggplot2)
data(ames, package = "modeldata")

spline_rec &lt;- recipe(Sale_Price ~ Longitude, data = ames) %&gt;%
  step_spline_convex(Longitude, deg_free = 6, keep_original_cols = TRUE) %&gt;%
  prep()

tidy(spline_rec, number = 1)

# Show where each feature is active
spline_rec %&gt;%
  bake(new_data =  NULL,-Sale_Price) %&gt;%
  pivot_longer(c(starts_with("Longitude_")), names_to = "feature", values_to = "value") %&gt;%
  mutate(feature = gsub("Longitude_", "feature ", feature)) %&gt;%
  filter(value &gt; 0) %&gt;%
  ggplot(aes(x = Longitude, y = value)) +
  geom_line() +
  facet_wrap(~ feature)

</code></pre>

<hr>
<h2 id='step_spline_monotone'>Monotone splines</h2><span id='topic+step_spline_monotone'></span>

<h3>Description</h3>

<p><code>step_spline_monotone()</code> creates a <em>specification</em> of a recipe step that
creates monotone spline features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_spline_monotone(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  deg_free = 10,
  degree = 3,
  complete_set = TRUE,
  options = NULL,
  keep_original_cols = FALSE,
  results = NULL,
  skip = FALSE,
  id = rand_id("spline_monotone")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_spline_monotone_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_deg_free">deg_free</code></td>
<td>
<p>The degrees of freedom for the b-spline. As the
degrees of freedom for a b-spline increase, more flexible and
complex curves can be generated.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_degree">degree</code></td>
<td>
<p>The degree of I-spline defined to be the degree of the
associated M-spline instead of actual polynomial degree. For example,
I-spline basis of degree 2 is defined as the integral of associated M-spline
basis of degree 2.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_complete_set">complete_set</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output. This maps to
the <code>intercept</code> argument of the corresponding function from the
<span class="pkg">splines2</span> package and has the same default value.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="splines2.html#topic+iSpline">splines2::iSpline()</a></code>
which should not include <code>x</code>, <code>df</code>, <code>degree</code>, <code>periodic</code>, or <code>intercept</code>.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_results">results</code></td>
<td>
<p>A list of objects created once the step has been trained.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_spline_monotone_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spline transformations take a numeric column and create multiple features
that, when used in a model, can estimate nonlinear trends between the column
and some outcome. The degrees of freedom determines how many new features
are added to the data.
</p>
<p>These splines are integrated forms of M-splines and are non-negative and
monotonic. This means that, when used with a fitting function that produces
non-negative regression coefficients, the resulting fit is monotonic.
</p>
<p>If the spline expansion fails for a selected column, the step will
remove that column's results (but will retain the original data). Use the
<code>tidy()</code> method to determine which columns were used.
</p>


<h3>Value</h3>

<p>An object with classes <code>"step_spline_monotone"</code> and <code>"step"</code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>deg_free</code>: Spline Degrees of Freedom (type: integer, default: 10)
</p>
</li>
<li> <p><code>degree</code>: Polynomial Degree (type: integer, default: 3)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="splines2.html#topic+iSpline">splines2::iSpline()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyr)
library(dplyr)

library(ggplot2)
data(ames, package = "modeldata")

spline_rec &lt;- recipe(Sale_Price ~ Longitude, data = ames) %&gt;%
  step_spline_monotone(Longitude, deg_free = 6, keep_original_cols = TRUE) %&gt;%
  prep()

tidy(spline_rec, number = 1)

# Show where each feature is active
spline_rec %&gt;%
  bake(new_data =  NULL,-Sale_Price) %&gt;%
  pivot_longer(c(starts_with("Longitude_")), names_to = "feature", values_to = "value") %&gt;%
  mutate(feature = gsub("Longitude_", "feature ", feature)) %&gt;%
  filter(value &gt; 0) %&gt;%
  ggplot(aes(x = Longitude, y = value)) +
  geom_line() +
  facet_wrap(~ feature)

</code></pre>

<hr>
<h2 id='step_spline_natural'>Natural splines</h2><span id='topic+step_spline_natural'></span>

<h3>Description</h3>

<p><code>step_spline_natural()</code> creates a <em>specification</em> of a recipe step that
creates natural spline features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_spline_natural(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  deg_free = 10,
  complete_set = FALSE,
  options = NULL,
  keep_original_cols = FALSE,
  results = NULL,
  skip = FALSE,
  id = rand_id("spline_natural")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_spline_natural_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_deg_free">deg_free</code></td>
<td>
<p>The degrees of freedom for the natural spline. As the
degrees of freedom for a natural spline increase, more flexible and
complex curves can be generated. This step requires at least two degrees of
freedom.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_complete_set">complete_set</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output. This maps to
the <code>intercept</code> argument of the corresponding function from the
<span class="pkg">splines2</span> package and has the same default value.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="splines2.html#topic+naturalSpline">splines2::naturalSpline()</a></code>
which should not include <code>x</code>, <code>df</code>, or <code>intercept</code>.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_results">results</code></td>
<td>
<p>A list of objects created once the step has been trained.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_spline_natural_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spline transformations take a numeric column and create multiple features
that, when used in a model, can estimate nonlinear trends between the column
and some outcome. The degrees of freedom determines how many new features
are added to the data.
</p>
<p>This spline is a piece-wise cubic polynomial function.
</p>
<p>If the spline expansion fails for a selected column, the step will
remove that column's results (but will retain the original data). Use the
<code>tidy()</code> method to determine which columns were used.
</p>


<h3>Value</h3>

<p>An object with classes <code>"step_spline_natural"</code> and <code>"step"</code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>deg_free</code>: Spline Degrees of Freedom (type: integer, default: 10)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="splines2.html#topic+naturalSpline">splines2::naturalSpline()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyr)
library(dplyr)

library(ggplot2)
data(ames, package = "modeldata")

spline_rec &lt;- recipe(Sale_Price ~ Longitude, data = ames) %&gt;%
  step_spline_natural(Longitude, deg_free = 6, keep_original_cols = TRUE) %&gt;%
  prep()

tidy(spline_rec, number = 1)

# Show where each feature is active
spline_rec %&gt;%
  bake(new_data =  NULL,-Sale_Price) %&gt;%
  pivot_longer(c(starts_with("Longitude_")), names_to = "feature", values_to = "value") %&gt;%
  mutate(feature = gsub("Longitude_", "feature ", feature)) %&gt;%
  filter(value &gt; 0) %&gt;%
  ggplot(aes(x = Longitude, y = value)) +
  geom_line() +
  facet_wrap(~ feature)

</code></pre>

<hr>
<h2 id='step_spline_nonnegative'>Non-negative splines</h2><span id='topic+step_spline_nonnegative'></span>

<h3>Description</h3>

<p><code>step_spline_nonnegative()</code> creates a <em>specification</em> of a recipe step that
creates non-negative spline features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_spline_nonnegative(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  deg_free = 10,
  degree = 3,
  complete_set = FALSE,
  options = NULL,
  keep_original_cols = FALSE,
  results = NULL,
  skip = FALSE,
  id = rand_id("spline_nonnegative")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_spline_nonnegative_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_deg_free">deg_free</code></td>
<td>
<p>The degrees of freedom for the b-spline. As the
degrees of freedom for a b-spline increase, more flexible and
complex curves can be generated.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_degree">degree</code></td>
<td>
<p>A nonnegative integer specifying the degree of the piecewise
polynomial. The default value is 3 for cubic splines. Zero degree is allowed
for piecewise constant basis functions.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_complete_set">complete_set</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output. This maps to
the <code>intercept</code> argument of the corresponding function from the
<span class="pkg">splines2</span> package and has the same default value.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_options">options</code></td>
<td>
<p>A list of options for <code><a href="splines2.html#topic+mSpline">splines2::mSpline()</a></code>
which should not include <code>x</code>, <code>df</code>, <code>degree</code>, <code>periodic</code>, or <code>intercept</code>.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_results">results</code></td>
<td>
<p>A list of objects created once the step has been trained.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_spline_nonnegative_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spline transformations take a numeric column and create multiple features
that, when used in a model, can estimate nonlinear trends between the column
and some outcome. The degrees of freedom determines how many new features
are added to the data.
</p>
<p>This function generates M-splines (Curry, and Schoenberg 1988) which are
non-negative and have interesting statistical properties (such as integrating
to one). A zero-degree M-spline generates box/step functions while a first
degree basis function is triangular.
</p>
<p>Setting <code>periodic = TRUE</code> in the list passed to <code>options</code>, a periodic version
of the spline is used.
</p>
<p>If the spline expansion fails for a selected column, the step will
remove that column's results (but will retain the original data). Use the
<code>tidy()</code> method to determine which columns were used.
</p>


<h3>Value</h3>

<p>An object with classes <code>"step_spline_nonnegative"</code> and <code>"step"</code>.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>deg_free</code>: Spline Degrees of Freedom (type: integer, default: 10)
</p>
</li>
<li> <p><code>degree</code>: Polynomial Degree (type: integer, default: 3)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Curry, H.B., Schoenberg, I.J. (1988). On Polya Frequency Functions IV: The
Fundamental Spline Functions and their Limits. In: de Boor, C. (eds) I. J.
Schoenberg Selected Papers. Contemporary Mathematicians. Birkhuser, Boston,
MA
</p>
<p>Ramsay, J. O. &quot;Monotone Regression Splines in Action.&quot; Statistical Science,
vol. 3, no. 4, 1988, pp. 42541
</p>


<h3>See Also</h3>

<p><code><a href="splines2.html#topic+mSpline">splines2::mSpline()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyr)
library(dplyr)

library(ggplot2)
data(ames, package = "modeldata")

spline_rec &lt;- recipe(Sale_Price ~ Longitude, data = ames) %&gt;%
  step_spline_nonnegative(Longitude, deg_free = 6, keep_original_cols = TRUE) %&gt;%
  prep()

tidy(spline_rec, number = 1)

# Show where each feature is active
spline_rec %&gt;%
  bake(new_data =  NULL,-Sale_Price) %&gt;%
  pivot_longer(c(starts_with("Longitude_")), names_to = "feature", values_to = "value") %&gt;%
  mutate(feature = gsub("Longitude_", "feature ", feature)) %&gt;%
  filter(value &gt; 0) %&gt;%
  ggplot(aes(x = Longitude, y = value)) +
  geom_line() +
  facet_wrap(~ feature)

</code></pre>

<hr>
<h2 id='step_sqrt'>Square root transformation</h2><span id='topic+step_sqrt'></span>

<h3>Description</h3>

<p><code>step_sqrt()</code> creates a <em>specification</em> of a recipe step that will apply
square root transform to the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_sqrt(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("sqrt")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_sqrt_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_sqrt_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_sqrt_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_sqrt_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_sqrt_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_sqrt_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_sqrt_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_YeoJohnson">step_YeoJohnson</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(313)
examples &lt;- matrix(rnorm(40)^2, ncol = 2)
examples &lt;- as.data.frame(examples)

rec &lt;- recipe(~ V1 + V2, data = examples)

sqrt_trans &lt;- rec %&gt;%
  step_sqrt(all_numeric_predictors())

sqrt_obj &lt;- prep(sqrt_trans, training = examples)

transformed_te &lt;- bake(sqrt_obj, examples)
plot(examples$V1, transformed_te$V1)

tidy(sqrt_trans, number = 1)
tidy(sqrt_obj, number = 1)
</code></pre>

<hr>
<h2 id='step_string2factor'>Convert strings to factors</h2><span id='topic+step_string2factor'></span>

<h3>Description</h3>

<p><code>step_string2factor()</code> will convert one or more character vectors to factors
(ordered or unordered).
</p>
<p><em>Use this step only in special cases</em> (see Details) and instead convert
strings to factors before using any tidymodels functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_string2factor(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  levels = NULL,
  ordered = FALSE,
  skip = FALSE,
  id = rand_id("string2factor")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_string2factor_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_string2factor_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_string2factor_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_string2factor_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_string2factor_+3A_levels">levels</code></td>
<td>
<p>An options specification of the levels to be used
for the new factor. If left <code>NULL</code>, the sorted unique
values present when <code>bake</code> is called will be used.</p>
</td></tr>
<tr><td><code id="step_string2factor_+3A_ordered">ordered</code></td>
<td>
<p>A single logical value; should the factor(s) be
ordered?</p>
</td></tr>
<tr><td><code id="step_string2factor_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_string2factor_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>When should you use this step?</h4>

<p>In most cases, if you are planning to use <code>step_string2factor()</code>
without setting <code>levels</code>, you will be better off converting
those character variables to factor variables <strong>before using a recipe</strong>.
</p>
<p>This can be done using <span class="pkg">dplyr</span> with the following code
</p>
<div class="sourceCode r"><pre>df &lt;- mutate(df, across(where(is.character), as.factor))
</pre></div>
<p>During resampling, the complete set of values might
not be in the character data. Converting them to factors with
<code>step_string2factor()</code>  then will misconfigure the levels.
</p>
<p>If the <code>levels</code> argument to <code>step_string2factor()</code>is used, it will
convert all variables affected by this step to have the same
levels. Because of this, you will need to know the full set of level
when you define the recipe.
</p>
<p>Also, note that <code><a href="#topic+prep">prep()</a></code> has an option <code>strings_as_factors</code> that
defaults to <code>TRUE</code>. This should be changed so that raw character
data will be applied to <code>step_string2factor()</code>. However, this step
can also take existing factors (but will leave them as-is).
</p>



<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>ordered</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>ordered</dt><dd><p>logical, are factors ordered</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

# convert factor to string to demonstrate
Sacramento$city &lt;- as.character(Sacramento$city)

rec &lt;- recipe(~ city + zip, data = Sacramento)

make_factor &lt;- rec %&gt;%
  step_string2factor(city)

make_factor &lt;- prep(make_factor,
  training = Sacramento
)

make_factor

# note that `city` is a factor in recipe output
bake(make_factor, new_data = NULL) %&gt;% head()

# ...but remains a string in the data
Sacramento %&gt;% head()

</code></pre>

<hr>
<h2 id='step_time'>Time feature generator</h2><span id='topic+step_time'></span>

<h3>Description</h3>

<p><code>step_time()</code> creates a <em>specification</em> of a recipe step that will convert
date-time data into one or more factor or numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_time(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  features = c("hour", "minute", "second"),
  columns = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("time")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_time_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_time_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. The selected variables should have class
<code>POSIXct</code> or <code>POSIXlt</code>. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_time_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be used as <em>predictors</em> in a model.</p>
</td></tr>
<tr><td><code id="step_time_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_time_+3A_features">features</code></td>
<td>
<p>A character string that includes at least one
of the following values: <code>am</code> (is is AM), <code>hour</code>, <code>hour12</code>, <code>minute</code>,
<code>second</code>, <code>decimal_day</code>.</p>
</td></tr>
<tr><td><code id="step_time_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_time_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="step_time_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_time_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike some other steps, <code>step_time()</code> does <em>not</em>
remove the original time variables by default. Set <code>keep_original_cols</code>
to <code>FALSE</code> to remove them.
</p>
<p><code>decimal_day</code> return time of day as a decimal number between 0 and 24. for
example <code>"07:15:00"</code> would be transformed to <code>7.25</code>  and <code>"03:59:59"</code> would
be transformed to <code>3.999722</code>. The formula for these calculations are
<code>hour(x) + (second(x) + minute(x) * 60) / 3600</code>.
</p>
<p>See <code><a href="#topic+step_date">step_date()</a></code> if you want to calculate features that are larger than
hours.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>character, the feature names</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

examples &lt;- data.frame(
  times = ymd_hms("2022-05-06 23:51:07") +
  hours(1:5) + minutes(1:5) + seconds(1:5)
)
time_rec &lt;- recipe(~ times, examples) %&gt;%
  step_time(all_predictors())

tidy(time_rec, number = 1)

time_rec &lt;- prep(time_rec, training = examples)

time_values &lt;- bake(time_rec, new_data = examples)
time_values

tidy(time_rec, number = 1)
</code></pre>

<hr>
<h2 id='step_unknown'>Assign missing categories to &quot;unknown&quot;</h2><span id='topic+step_unknown'></span>

<h3>Description</h3>

<p><code>step_unknown()</code> creates a <em>specification</em> of a recipe step that will assign
a missing value in a factor level to <code>"unknown"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_unknown(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  new_level = "unknown",
  objects = NULL,
  skip = FALSE,
  id = rand_id("unknown")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_unknown_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_unknown_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_unknown_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_unknown_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_unknown_+3A_new_level">new_level</code></td>
<td>
<p>A single character value that will be assigned
to new factor levels.</p>
</td></tr>
<tr><td><code id="step_unknown_+3A_objects">objects</code></td>
<td>
<p>A list of objects that contain the information
on factor levels that will be determined by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_unknown_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_unknown_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selected variables are adjusted to have a new
level (given by <code>new_level</code>) that is placed in the last
position.
</p>
<p>Note that if the original columns are character, they will be
converted to factors by this step.
</p>
<p>If <code>new_level</code> is already in the data given to <code>prep</code>, an error
is thrown.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>statistic</dt><dd><p>character, the factor levels for the new values</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dummy_names">dummy_names()</a></code>
</p>
<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unorder">step_unorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

rec &lt;-
  recipe(~ city + zip, data = Sacramento) %&gt;%
  step_unknown(city, new_level = "unknown city") %&gt;%
  step_unknown(zip, new_level = "unknown zip") %&gt;%
  prep()

table(bake(rec, new_data = NULL) %&gt;% pull(city),
  Sacramento %&gt;% pull(city),
  useNA = "always"
) %&gt;%
  as.data.frame() %&gt;%
  dplyr::filter(Freq &gt; 0)

tidy(rec, number = 1)

</code></pre>

<hr>
<h2 id='step_unorder'>Convert ordered factors to unordered factors</h2><span id='topic+step_unorder'></span>

<h3>Description</h3>

<p><code>step_unorder()</code> creates a <em>specification</em> of a recipe step that will turn
ordered factor variables into unordered factor variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_unorder(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("unorder")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_unorder_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_unorder_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_unorder_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_unorder_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_unorder_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_unorder_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_unorder_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factors level order is preserved during the transformation.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other dummy variable and encoding steps: 
<code><a href="#topic+step_bin2factor">step_bin2factor</a>()</code>,
<code><a href="#topic+step_count">step_count</a>()</code>,
<code><a href="#topic+step_date">step_date</a>()</code>,
<code><a href="#topic+step_dummy_extract">step_dummy_extract</a>()</code>,
<code><a href="#topic+step_dummy_multi_choice">step_dummy_multi_choice</a>()</code>,
<code><a href="#topic+step_dummy">step_dummy</a>()</code>,
<code><a href="#topic+step_factor2string">step_factor2string</a>()</code>,
<code><a href="#topic+step_holiday">step_holiday</a>()</code>,
<code><a href="#topic+step_indicate_na">step_indicate_na</a>()</code>,
<code><a href="#topic+step_integer">step_integer</a>()</code>,
<code><a href="#topic+step_novel">step_novel</a>()</code>,
<code><a href="#topic+step_num2factor">step_num2factor</a>()</code>,
<code><a href="#topic+step_ordinalscore">step_ordinalscore</a>()</code>,
<code><a href="#topic+step_other">step_other</a>()</code>,
<code><a href="#topic+step_regex">step_regex</a>()</code>,
<code><a href="#topic+step_relevel">step_relevel</a>()</code>,
<code><a href="#topic+step_string2factor">step_string2factor</a>()</code>,
<code><a href="#topic+step_time">step_time</a>()</code>,
<code><a href="#topic+step_unknown">step_unknown</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lmh &lt;- c("Low", "Med", "High")

examples &lt;- data.frame(
  X1 = factor(rep(letters[1:4], each = 3)),
  X2 = ordered(rep(lmh, each = 4),
    levels = lmh
  )
)

rec &lt;- recipe(~ X1 + X2, data = examples)

factor_trans &lt;- rec %&gt;%
  step_unorder(all_nominal_predictors())

factor_obj &lt;- prep(factor_trans, training = examples)

transformed_te &lt;- bake(factor_obj, examples)
table(transformed_te$X2, examples$X2)

tidy(factor_trans, number = 1)
tidy(factor_obj, number = 1)
</code></pre>

<hr>
<h2 id='step_window'>Moving window functions</h2><span id='topic+step_window'></span>

<h3>Description</h3>

<p><code>step_window()</code> creates a <em>specification</em> of a recipe step that will create
new columns that are the results of functions that compute statistics across
moving windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_window(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  size = 3,
  na_rm = TRUE,
  statistic = "mean",
  columns = NULL,
  names = NULL,
  keep_original_cols = TRUE,
  skip = FALSE,
  id = rand_id("window")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_window_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_window_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_window_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis
role should they be assigned? If <code>names</code> is left to be
<code>NULL</code>, the rolling statistics replace the original columns
and the roles are left unchanged. If <code>names</code> is set, those
new columns will have a role of <code>NULL</code> unless this argument
has a value.</p>
</td></tr>
<tr><td><code id="step_window_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_window_+3A_size">size</code></td>
<td>
<p>An odd integer <code style="white-space: pre;">&#8288;&gt;= 3&#8288;</code> for the window size.</p>
</td></tr>
<tr><td><code id="step_window_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical for whether missing values should be
removed from the calculations within each window.</p>
</td></tr>
<tr><td><code id="step_window_+3A_statistic">statistic</code></td>
<td>
<p>A character string for the type of statistic
that should be calculated for each moving window. Possible
values are: <code>'max'</code>, <code>'mean'</code>, <code>'median'</code>,
<code>'min'</code>, <code>'prod'</code>, <code>'sd'</code>, <code>'sum'</code>,
<code>'var'</code></p>
</td></tr>
<tr><td><code id="step_window_+3A_columns">columns</code></td>
<td>
<p>A character string of the selected variable names. This field
is a placeholder and will be populated once <code><a href="#topic+prep">prep()</a></code> is used.</p>
</td></tr>
<tr><td><code id="step_window_+3A_names">names</code></td>
<td>
<p>An optional character string that is the same
length of the number of terms selected by <code>terms</code>. If you
are not sure what columns will be selected, use the
<code>summary</code> function (see the example below). These will be
the names of the new columns created by the step.</p>
</td></tr>
<tr><td><code id="step_window_+3A_keep_original_cols">keep_original_cols</code></td>
<td>
<p>A logical to keep the original variables in the
output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="step_window_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_window_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculations use a somewhat atypical method for
handling the beginning and end parts of the rolling statistics.
The process starts with the center justified window calculations
and the beginning and ending parts of the rolling values are
determined using the first and last rolling values,
respectively. For example, if a column <code>x</code> with 12 values is
smoothed with a 5-point moving median, the first three smoothed
values are estimated by <code>median(x[1:5])</code> and the fourth
uses <code>median(x[2:6])</code>.
</p>
<p><code>keep_original_cols</code> also applies to this step if <code>names</code> is specified.
</p>
<p>step will stop with a note about installing the package.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>statistic</code>, <code>size</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>statistic</dt><dd><p>character, the summary function name</p>
</dd>
<dt>size</dt><dd><p>integer, window size</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>statistic</code>: Rolling Summary Statistic (type: character, default: mean)
</p>
</li>
<li> <p><code>size</code>: Window Size (type: integer, default: 3)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(dplyr)
library(rlang)
library(ggplot2, quietly = TRUE)

set.seed(5522)
sim_dat &lt;- data.frame(x1 = (20:100) / 10)
n &lt;- nrow(sim_dat)
sim_dat$y1 &lt;- sin(sim_dat$x1) + rnorm(n, sd = 0.1)
sim_dat$y2 &lt;- cos(sim_dat$x1) + rnorm(n, sd = 0.1)
sim_dat$x2 &lt;- runif(n)
sim_dat$x3 &lt;- rnorm(n)

rec &lt;- recipe(y1 + y2 ~ x1 + x2 + x3, data = sim_dat) %&gt;%
  step_window(starts_with("y"),
    size = 7, statistic = "median",
    names = paste0("med_7pt_", 1:2),
    role = "outcome"
  ) %&gt;%
  step_window(starts_with("y"),
    names = paste0("mean_3pt_", 1:2),
    role = "outcome"
  )
rec &lt;- prep(rec, training = sim_dat)

smoothed_dat &lt;- bake(rec, sim_dat, everything())

ggplot(data = sim_dat, aes(x = x1, y = y1)) +
  geom_point() +
  geom_line(data = smoothed_dat, aes(y = med_7pt_1)) +
  geom_line(data = smoothed_dat, aes(y = mean_3pt_1), col = "red") +
  theme_bw()

tidy(rec, number = 1)
tidy(rec, number = 2)

# If you want to replace the selected variables with the rolling statistic
# don't set `names`
sim_dat$original &lt;- sim_dat$y1
rec &lt;- recipe(y1 + y2 + original ~ x1 + x2 + x3, data = sim_dat) %&gt;%
  step_window(starts_with("y"))
rec &lt;- prep(rec, training = sim_dat)
smoothed_dat &lt;- bake(rec, sim_dat, everything())
ggplot(smoothed_dat, aes(x = original, y = y1)) +
  geom_point() +
  theme_bw()

</code></pre>

<hr>
<h2 id='step_YeoJohnson'>Yeo-Johnson transformation</h2><span id='topic+step_YeoJohnson'></span>

<h3>Description</h3>

<p><code>step_YeoJohnson()</code> creates a <em>specification</em> of a recipe step that will
transform data using a Yeo-Johnson transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_YeoJohnson(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  lambdas = NULL,
  limits = c(-5, 5),
  num_unique = 5,
  na_rm = TRUE,
  skip = FALSE,
  id = rand_id("YeoJohnson")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_YeoJohnson_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_lambdas">lambdas</code></td>
<td>
<p>A numeric vector of transformation values. This
is <code>NULL</code> until computed by <code><a href="#topic+prep">prep()</a></code>.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_limits">limits</code></td>
<td>
<p>A length 2 numeric vector defining the range to
compute the transformation parameter lambda.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_num_unique">num_unique</code></td>
<td>
<p>An integer where data that have less possible
values will not be evaluated for a transformation.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical value indicating whether <code>NA</code>
values should be removed during computations.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_YeoJohnson_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Yeo-Johnson transformation is very similar to the
Box-Cox but does not require the input variables to be strictly
positive. In the package, the partial log-likelihood function is
directly optimized within a reasonable set of transformation
values (which can be changed by the user).
</p>
<p>This transformation is typically done on the outcome variable
using the residuals for a statistical model (such as ordinary
least squares). Here, a simple null model (intercept only) is
used to apply the transformation to the <em>predictor</em>
variables individually. This can have the effect of making the
variable distributions more symmetric.
</p>
<p>If the transformation parameters are estimated to be very
closed to the bounds, or if the optimization fails, a value of
<code>NA</code> is used and no transformation is applied.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code>, <code>value</code> , and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>value</dt><dd><p>numeric, the lambda estimate</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Yeo, I. K., and Johnson, R. A. (2000). A new family of power
transformations to improve normality or symmetry. <em>Biometrika</em>.
</p>


<h3>See Also</h3>

<p>Other individual transformation steps: 
<code><a href="#topic+step_BoxCox">step_BoxCox</a>()</code>,
<code><a href="#topic+step_bs">step_bs</a>()</code>,
<code><a href="#topic+step_harmonic">step_harmonic</a>()</code>,
<code><a href="#topic+step_hyperbolic">step_hyperbolic</a>()</code>,
<code><a href="#topic+step_inverse">step_inverse</a>()</code>,
<code><a href="#topic+step_invlogit">step_invlogit</a>()</code>,
<code><a href="#topic+step_logit">step_logit</a>()</code>,
<code><a href="#topic+step_log">step_log</a>()</code>,
<code><a href="#topic+step_mutate">step_mutate</a>()</code>,
<code><a href="#topic+step_ns">step_ns</a>()</code>,
<code><a href="#topic+step_percentile">step_percentile</a>()</code>,
<code><a href="#topic+step_poly">step_poly</a>()</code>,
<code><a href="#topic+step_relu">step_relu</a>()</code>,
<code><a href="#topic+step_sqrt">step_sqrt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
)

yj_transform &lt;- step_YeoJohnson(rec, all_numeric())

yj_estimates &lt;- prep(yj_transform, training = biomass_tr)

yj_te &lt;- bake(yj_estimates, biomass_te)

plot(density(biomass_te$sulfur), main = "before")
plot(density(yj_te$sulfur), main = "after")

tidy(yj_transform, number = 1)
tidy(yj_estimates, number = 1)

</code></pre>

<hr>
<h2 id='step_zv'>Zero variance filter</h2><span id='topic+step_zv'></span>

<h3>Description</h3>

<p><code>step_zv()</code> creates a <em>specification</em> of a recipe step that will remove
variables that contain only a single value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_zv(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  group = NULL,
  removals = NULL,
  skip = FALSE,
  id = rand_id("zv")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_zv_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_zv_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose variables
for this step. See <code><a href="#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_zv_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_zv_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_zv_+3A_group">group</code></td>
<td>
<p>An optional character string or call to <code><a href="dplyr.html#topic+vars">dplyr::vars()</a></code>
that can be used to specify a group(s) within which to identify
variables that contain only a single value. If the grouping variables
are contained in terms selector, they will not be considered for
removal.</p>
</td></tr>
<tr><td><code id="step_zv_+3A_removals">removals</code></td>
<td>
<p>A character string that contains the names of
columns that should be removed. These values are not determined
until <code><a href="#topic+prep">prep()</a></code> is called.</p>
</td></tr>
<tr><td><code id="step_zv_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_zv_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step can potentially remove columns from the data set. This may
cause issues for subsequent steps in your recipe if the missing columns are
specifically referenced by name. To avoid this, see the advice in the
<em>Tips for saving recipes and filtering columns</em> section of <a href="#topic+selections">selections</a>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step added to the
sequence of any existing operations.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="#topic+tidy.recipe">tidy()</a></code> this step, a tibble is returned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, names of the columns that will be removed</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>See Also</h3>

<p>Other variable filter steps: 
<code><a href="#topic+step_corr">step_corr</a>()</code>,
<code><a href="#topic+step_filter_missing">step_filter_missing</a>()</code>,
<code><a href="#topic+step_lincomb">step_lincomb</a>()</code>,
<code><a href="#topic+step_nzv">step_nzv</a>()</code>,
<code><a href="#topic+step_rm">step_rm</a>()</code>,
<code><a href="#topic+step_select">step_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass$one_value &lt;- 1

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

rec &lt;- recipe(HHV ~ carbon + hydrogen + oxygen +
  nitrogen + sulfur + one_value,
data = biomass_tr
)

zv_filter &lt;- rec %&gt;%
  step_zv(all_predictors())

filter_obj &lt;- prep(zv_filter, training = biomass_tr)

filtered_te &lt;- bake(filter_obj, biomass_te)
any(names(filtered_te) == "one_value")

tidy(zv_filter, number = 1)
tidy(filter_obj, number = 1)

</code></pre>

<hr>
<h2 id='summary.recipe'>Summarize a recipe</h2><span id='topic+summary.recipe'></span>

<h3>Description</h3>

<p>This function prints the current set of variables/features and some of their
characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recipe'
summary(object, original = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.recipe_+3A_object">object</code></td>
<td>
<p>A <code>recipe</code> object</p>
</td></tr>
<tr><td><code id="summary.recipe_+3A_original">original</code></td>
<td>
<p>A logical: show the current set of variables or the original
set when the recipe was defined.</p>
</td></tr>
<tr><td><code id="summary.recipe_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (not currently
used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, until the recipe has been trained,
the current and original variables are the same.
</p>
<p>It is possible for variables to have multiple roles by adding them with
<code><a href="#topic+add_role">add_role()</a></code>. If a variable has multiple roles, it will have more than one
row in the summary tibble.
</p>


<h3>Value</h3>

<p>A tibble with columns <code>variable</code>, <code>type</code>, <code>role</code>,
and <code>source</code>. When <code>original = TRUE</code>, an additional column is included
named <code>required_to_bake</code> (based on the results of
<code><a href="#topic+update_role_requirements">update_role_requirements()</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recipe">recipe()</a></code> <code><a href="#topic+prep">prep()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rec &lt;- recipe(~., data = USArrests)
summary(rec)
rec &lt;- step_pca(rec, all_numeric(), num_comp = 3)
summary(rec) # still the same since not yet trained
rec &lt;- prep(rec, training = USArrests)
summary(rec)
</code></pre>

<hr>
<h2 id='terms_select'>Select terms in a step function.</h2><span id='topic+terms_select'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>terms_select()</code> has been deprecated in favor of <code><a href="#topic+recipes_eval_select">recipes_eval_select()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terms_select(terms, info, empty_fun = function(x) x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms_select_+3A_terms">terms</code></td>
<td>
<p>A list of formulas whose right-hand side contains
quoted expressions. See <code><a href="rlang.html#topic+defusing-advanced">rlang::quos()</a></code> for examples.</p>
</td></tr>
<tr><td><code id="terms_select_+3A_info">info</code></td>
<td>
<p>A tibble with columns <code>variable</code>, <code>type</code>, <code>role</code>,
and <code>source</code> that represent the current state of the data. The
function <code><a href="#topic+summary.recipe">summary.recipe()</a></code> can be used to get this information
from a recipe.</p>
</td></tr>
<tr><td><code id="terms_select_+3A_empty_fun">empty_fun</code></td>
<td>
<p>A function to execute when no terms are selected by the
step. The default function throws an error with a message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of column names or an error of there
are no selectors or if no variables are selected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recipe">recipe()</a></code> <code><a href="#topic+summary.recipe">summary.recipe()</a></code>
<code><a href="#topic+prep">prep()</a></code>
</p>

<hr>
<h2 id='tidy.step_BoxCox'>Tidy the result of a recipe</h2><span id='topic+tidy.step_BoxCox'></span><span id='topic+tidy.step_YeoJohnson'></span><span id='topic+tidy.step_arrange'></span><span id='topic+tidy.step_bin2factor'></span><span id='topic+tidy.step_bs'></span><span id='topic+tidy.step_center'></span><span id='topic+tidy.check_class'></span><span id='topic+tidy.step_classdist'></span><span id='topic+tidy.step_classdist_shrunken'></span><span id='topic+tidy.check_cols'></span><span id='topic+tidy.step_corr'></span><span id='topic+tidy.step_count'></span><span id='topic+tidy.step_cut'></span><span id='topic+tidy.step_date'></span><span id='topic+tidy.step_depth'></span><span id='topic+tidy.step_discretize'></span><span id='topic+tidy.step_dummy'></span><span id='topic+tidy.step_dummy_extract'></span><span id='topic+tidy.step_dummy_multi_choice'></span><span id='topic+tidy.step_factor2string'></span><span id='topic+tidy.step_filter'></span><span id='topic+tidy.step_filter_missing'></span><span id='topic+tidy.step_geodist'></span><span id='topic+tidy.step_harmonic'></span><span id='topic+tidy.step_holiday'></span><span id='topic+tidy.step_hyperbolic'></span><span id='topic+tidy.step_ica'></span><span id='topic+tidy.step_impute_bag'></span><span id='topic+tidy.step_impute_knn'></span><span id='topic+tidy.step_impute_linear'></span><span id='topic+tidy.step_impute_lower'></span><span id='topic+tidy.step_impute_mean'></span><span id='topic+tidy.step_impute_median'></span><span id='topic+tidy.step_impute_mode'></span><span id='topic+tidy.step_impute_roll'></span><span id='topic+tidy.step_indicate_na'></span><span id='topic+tidy.step_integer'></span><span id='topic+tidy.step_interact'></span><span id='topic+tidy.step_intercept'></span><span id='topic+tidy.step_inverse'></span><span id='topic+tidy.step_invlogit'></span><span id='topic+tidy.step_isomap'></span><span id='topic+tidy.step_kpca'></span><span id='topic+tidy.step_kpca_poly'></span><span id='topic+tidy.step_kpca_rbf'></span><span id='topic+tidy.step_lag'></span><span id='topic+tidy.step_lincomb'></span><span id='topic+tidy.step_log'></span><span id='topic+tidy.step_logit'></span><span id='topic+tidy.check_missing'></span><span id='topic+tidy.step_mutate'></span><span id='topic+tidy.step_mutate_at'></span><span id='topic+tidy.step_naomit'></span><span id='topic+tidy.check_new_values'></span><span id='topic+tidy.step_nnmf'></span><span id='topic+tidy.step_nnmf_sparse'></span><span id='topic+tidy.step_normalize'></span><span id='topic+tidy.step_novel'></span><span id='topic+tidy.step_ns'></span><span id='topic+tidy.step_num2factor'></span><span id='topic+tidy.step_nzv'></span><span id='topic+tidy.step_ordinalscore'></span><span id='topic+tidy.step_other'></span><span id='topic+tidy.step_pca'></span><span id='topic+tidy.step_percentile'></span><span id='topic+tidy.step_pls'></span><span id='topic+tidy.step_poly'></span><span id='topic+tidy.step_poly_bernstein'></span><span id='topic+tidy.step_profile'></span><span id='topic+tidy.step_range'></span><span id='topic+tidy.check_range'></span><span id='topic+tidy.step_ratio'></span><span id='topic+tidy.step_regex'></span><span id='topic+tidy.step_relevel'></span><span id='topic+tidy.step_relu'></span><span id='topic+tidy.step_rename'></span><span id='topic+tidy.step_rename_at'></span><span id='topic+tidy.step_rm'></span><span id='topic+tidy.step_sample'></span><span id='topic+tidy.step_scale'></span><span id='topic+tidy.step_select'></span><span id='topic+tidy.step_shuffle'></span><span id='topic+tidy.step_slice'></span><span id='topic+tidy.step_spatialsign'></span><span id='topic+tidy.step_spline_b'></span><span id='topic+tidy.step_spline_convex'></span><span id='topic+tidy.step_spline_monotone'></span><span id='topic+tidy.step_spline_natural'></span><span id='topic+tidy.step_spline_nonnegative'></span><span id='topic+tidy.step_sqrt'></span><span id='topic+tidy.step_string2factor'></span><span id='topic+tidy.recipe'></span><span id='topic+tidy.step'></span><span id='topic+tidy.check'></span><span id='topic+tidy.step_time'></span><span id='topic+tidy.step_unknown'></span><span id='topic+tidy.step_unorder'></span><span id='topic+tidy.step_window'></span><span id='topic+tidy.step_zv'></span>

<h3>Description</h3>

<p><code>tidy</code> will return a data frame that contains information
regarding a recipe or operation within the recipe (when a <code>tidy</code>
method for the operation exists).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step_BoxCox'
tidy(x, ...)

## S3 method for class 'step_YeoJohnson'
tidy(x, ...)

## S3 method for class 'step_arrange'
tidy(x, ...)

## S3 method for class 'step_bin2factor'
tidy(x, ...)

## S3 method for class 'step_bs'
tidy(x, ...)

## S3 method for class 'step_center'
tidy(x, ...)

## S3 method for class 'check_class'
tidy(x, ...)

## S3 method for class 'step_classdist'
tidy(x, ...)

## S3 method for class 'step_classdist_shrunken'
tidy(x, ...)

## S3 method for class 'check_cols'
tidy(x, ...)

## S3 method for class 'step_corr'
tidy(x, ...)

## S3 method for class 'step_count'
tidy(x, ...)

## S3 method for class 'step_cut'
tidy(x, ...)

## S3 method for class 'step_date'
tidy(x, ...)

## S3 method for class 'step_depth'
tidy(x, ...)

## S3 method for class 'step_discretize'
tidy(x, ...)

## S3 method for class 'step_dummy'
tidy(x, ...)

## S3 method for class 'step_dummy_extract'
tidy(x, ...)

## S3 method for class 'step_dummy_multi_choice'
tidy(x, ...)

## S3 method for class 'step_factor2string'
tidy(x, ...)

## S3 method for class 'step_filter'
tidy(x, ...)

## S3 method for class 'step_filter_missing'
tidy(x, ...)

## S3 method for class 'step_geodist'
tidy(x, ...)

## S3 method for class 'step_harmonic'
tidy(x, ...)

## S3 method for class 'step_holiday'
tidy(x, ...)

## S3 method for class 'step_hyperbolic'
tidy(x, ...)

## S3 method for class 'step_ica'
tidy(x, ...)

## S3 method for class 'step_impute_bag'
tidy(x, ...)

## S3 method for class 'step_impute_knn'
tidy(x, ...)

## S3 method for class 'step_impute_linear'
tidy(x, ...)

## S3 method for class 'step_impute_lower'
tidy(x, ...)

## S3 method for class 'step_impute_mean'
tidy(x, ...)

## S3 method for class 'step_impute_median'
tidy(x, ...)

## S3 method for class 'step_impute_mode'
tidy(x, ...)

## S3 method for class 'step_impute_roll'
tidy(x, ...)

## S3 method for class 'step_indicate_na'
tidy(x, ...)

## S3 method for class 'step_integer'
tidy(x, ...)

## S3 method for class 'step_interact'
tidy(x, ...)

## S3 method for class 'step_intercept'
tidy(x, ...)

## S3 method for class 'step_inverse'
tidy(x, ...)

## S3 method for class 'step_invlogit'
tidy(x, ...)

## S3 method for class 'step_isomap'
tidy(x, ...)

## S3 method for class 'step_kpca'
tidy(x, ...)

## S3 method for class 'step_kpca_poly'
tidy(x, ...)

## S3 method for class 'step_kpca_rbf'
tidy(x, ...)

## S3 method for class 'step_lag'
tidy(x, ...)

## S3 method for class 'step_lincomb'
tidy(x, ...)

## S3 method for class 'step_log'
tidy(x, ...)

## S3 method for class 'step_logit'
tidy(x, ...)

## S3 method for class 'check_missing'
tidy(x, ...)

## S3 method for class 'step_mutate'
tidy(x, ...)

## S3 method for class 'step_mutate_at'
tidy(x, ...)

## S3 method for class 'step_naomit'
tidy(x, ...)

## S3 method for class 'check_new_values'
tidy(x, ...)

## S3 method for class 'step_nnmf'
tidy(x, ...)

## S3 method for class 'step_nnmf_sparse'
tidy(x, ...)

## S3 method for class 'step_normalize'
tidy(x, ...)

## S3 method for class 'step_novel'
tidy(x, ...)

## S3 method for class 'step_ns'
tidy(x, ...)

## S3 method for class 'step_num2factor'
tidy(x, ...)

## S3 method for class 'step_nzv'
tidy(x, ...)

## S3 method for class 'step_ordinalscore'
tidy(x, ...)

## S3 method for class 'step_other'
tidy(x, ...)

## S3 method for class 'step_pca'
tidy(x, type = "coef", ...)

## S3 method for class 'step_percentile'
tidy(x, ...)

## S3 method for class 'step_pls'
tidy(x, ...)

## S3 method for class 'step_poly'
tidy(x, ...)

## S3 method for class 'step_poly_bernstein'
tidy(x, ...)

## S3 method for class 'step_profile'
tidy(x, ...)

## S3 method for class 'step_range'
tidy(x, ...)

## S3 method for class 'check_range'
tidy(x, ...)

## S3 method for class 'step_ratio'
tidy(x, ...)

## S3 method for class 'step_regex'
tidy(x, ...)

## S3 method for class 'step_relevel'
tidy(x, ...)

## S3 method for class 'step_relu'
tidy(x, ...)

## S3 method for class 'step_rename'
tidy(x, ...)

## S3 method for class 'step_rename_at'
tidy(x, ...)

## S3 method for class 'step_rm'
tidy(x, ...)

## S3 method for class 'step_sample'
tidy(x, ...)

## S3 method for class 'step_scale'
tidy(x, ...)

## S3 method for class 'step_select'
tidy(x, ...)

## S3 method for class 'step_shuffle'
tidy(x, ...)

## S3 method for class 'step_slice'
tidy(x, ...)

## S3 method for class 'step_spatialsign'
tidy(x, ...)

## S3 method for class 'step_spline_b'
tidy(x, ...)

## S3 method for class 'step_spline_convex'
tidy(x, ...)

## S3 method for class 'step_spline_monotone'
tidy(x, ...)

## S3 method for class 'step_spline_natural'
tidy(x, ...)

## S3 method for class 'step_spline_nonnegative'
tidy(x, ...)

## S3 method for class 'step_sqrt'
tidy(x, ...)

## S3 method for class 'step_string2factor'
tidy(x, ...)

## S3 method for class 'recipe'
tidy(x, number = NA, id = NA, ...)

## S3 method for class 'step'
tidy(x, ...)

## S3 method for class 'check'
tidy(x, ...)

## S3 method for class 'step_time'
tidy(x, ...)

## S3 method for class 'step_unknown'
tidy(x, ...)

## S3 method for class 'step_unorder'
tidy(x, ...)

## S3 method for class 'step_window'
tidy(x, ...)

## S3 method for class 'step_zv'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.step_BoxCox_+3A_x">x</code></td>
<td>
<p>A <code>recipe</code> object, step, or check (trained or otherwise).</p>
</td></tr>
<tr><td><code id="tidy.step_BoxCox_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="tidy.step_BoxCox_+3A_type">type</code></td>
<td>
<p>For <code>step_pca</code>, either <code>"coef"</code> (for the variable loadings per
component) or <code>"variance"</code> (how much variance does each component
account for).</p>
</td></tr>
<tr><td><code id="tidy.step_BoxCox_+3A_number">number</code></td>
<td>
<p>An integer or <code>NA</code>. If missing, and <code>id</code> is not provided,
the return value is a list of the operations in the recipe.
If a number is given, a <code>tidy</code> method is executed for that operation
in the recipe (if it exists). <code>number</code> must not be provided if
<code>id</code> is.</p>
</td></tr>
<tr><td><code id="tidy.step_BoxCox_+3A_id">id</code></td>
<td>
<p>A character string or <code>NA</code>. If missing and <code>number</code> is not provided,
the return value is a list of the operations in the recipe.
If a character string is given, a <code>tidy</code> method is executed for that
operation in the recipe (if it exists). <code>id</code> must not be provided
if <code>number</code> is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns that vary depending on what
<code>tidy</code> method is executed. When <code>number</code>, and <code>id</code> are <code>NA</code>, a
tibble with columns <code>number</code> (the operation iteration),
<code>operation</code> (either &quot;step&quot; or &quot;check&quot;),
<code>type</code> (the method, e.g. &quot;nzv&quot;, &quot;center&quot;), a logical
column called <code>trained</code> for whether the operation has been
estimated using <code>prep</code>, a logical for <code>skip</code>, and a character column <code>id</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sacramento, package = "modeldata")

Sacramento_rec &lt;- recipe(~., data = Sacramento) %&gt;%
  step_other(all_nominal(), threshold = 0.05, other = "another") %&gt;%
  step_center(all_numeric()) %&gt;%
  step_dummy(all_nominal()) %&gt;%
  check_cols(ends_with("ude"), sqft, price)

tidy(Sacramento_rec)

tidy(Sacramento_rec, number = 2)
tidy(Sacramento_rec, number = 3)

Sacramento_rec_trained &lt;- prep(Sacramento_rec, training = Sacramento)

tidy(Sacramento_rec_trained)
tidy(Sacramento_rec_trained, number = 3)
tidy(Sacramento_rec_trained, number = 4)

</code></pre>

<hr>
<h2 id='update_role_requirements'>Update role specific requirements</h2><span id='topic+update_role_requirements'></span>

<h3>Description</h3>

<p><code>update_role_requirements()</code> allows you to fine tune requirements of the
various roles you might come across in recipes (see <code><a href="#topic+update_role">update_role()</a></code> for
general information about roles). Role requirements can only be altered for
roles that exist in the <em>original</em> data supplied to <code><a href="#topic+recipe">recipe()</a></code>, they are not
applied to columns computed by steps.
</p>
<p>Like <code>update_role()</code>, <code>update_role_requirements()</code> is applied to the recipe
<em>immediately</em>, unlike the <code style="white-space: pre;">&#8288;step_*()&#8288;</code> functions which do most of their work
at <code><a href="#topic+prep">prep()</a></code> time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_role_requirements(recipe, role, ..., bake = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_role_requirements_+3A_recipe">recipe</code></td>
<td>
<p>A recipe.</p>
</td></tr>
<tr><td><code id="update_role_requirements_+3A_role">role</code></td>
<td>
<p>A string representing the role that you'd like to modify the
requirements of. This must be a role that already exists in the recipe.</p>
</td></tr>
<tr><td><code id="update_role_requirements_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="update_role_requirements_+3A_bake">bake</code></td>
<td>
<p>At <code>bake()</code> time, should a check be done to ensure that all
columns of this role that were supplied to <code>recipe()</code> also be present
in the <code>new_data</code> supplied to <code>bake()</code>?
</p>
<p>Must be a single <code>TRUE</code> or <code>FALSE</code>. The default, <code>NULL</code>, won't modify
this requirement.
</p>
<p>The following represents the default bake time requirements of specific
types of roles:
</p>

<ul>
<li> <p><code>"outcome"</code>: Not required at bake time. Can't be changed.
</p>
</li>
<li> <p><code>"predictor"</code>: Required at bake time. Can't be changed.
</p>
</li>
<li> <p><code>"case_weights"</code>: Not required at bake time by default.
</p>
</li>
<li> <p><code>NA</code>: Required at bake time by default.
</p>
</li>
<li><p> Custom roles: Required at bake time by default.
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(y = c(1, 2, 3), x = c(4, 5, 6), var = c("a", "b", "c"))

# Let's assume that you have a `var` column that isn't used in the recipe.
# We typically recommend that you remove this column before passing the
# `data` to `recipe()`, but for now let's pass it through and assign it an
# `"id"` role.
rec &lt;- recipe(y ~ ., df) %&gt;%
  update_role(var, new_role = "id") %&gt;%
  step_center(x)

prepped &lt;- prep(rec, df)

# Now assume you have some "new data" and you are ready to `bake()` it
# to prepare it for prediction purposes. Here, you might not have `var`
# available as a column because it isn't important to your model.
new_data &lt;- df[c("y", "x")]

# By default `var` is required at `bake()` time because we don't know if
# you actually use it in the recipe or not
try(bake(prepped, new_data))

# You can turn off this check by using `update_role_requirements()` and
# setting `bake = FALSE` for the `"id"` role. We recommend doing this on
# the original unprepped recipe, but it will also work on a prepped recipe.
rec &lt;- update_role_requirements(rec, "id", bake = FALSE)
prepped &lt;- prep(rec, df)

# Now you can `bake()` on `new_data` even though `var` is missing
bake(prepped, new_data)
</code></pre>

<hr>
<h2 id='update.step'>Update a recipe step</h2><span id='topic+update.step'></span>

<h3>Description</h3>

<p>This <code>step</code> method for <code>update()</code> takes named arguments as <code>...</code> who's values
will replace the elements of the same name in the actual step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.step_+3A_object">object</code></td>
<td>
<p>A recipe <code>step</code>.</p>
</td></tr>
<tr><td><code id="update.step_+3A_...">...</code></td>
<td>
<p>Key-value pairs where the keys match up with names of elements
in the step, and the values are the new values to update the step with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a step to be updated, it must not already have been trained. Otherwise,
conflicting information can arise between the data returned from
<code>bake(object, new_data = NULL)</code> and the information in the step.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training", ]
biomass_te &lt;- biomass[biomass$dataset == "Testing", ]

# Create a recipe using step_bs() with degree = 3
rec &lt;- recipe(
  HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
  data = biomass_tr
) %&gt;%
  step_bs(carbon, hydrogen, degree = 3)

# Update the step to use degree = 4
rec2 &lt;- rec
rec2$steps[[1]] &lt;- update(rec2$steps[[1]], degree = 4)

# Prep both recipes
rec_prepped &lt;- prep(rec, training = biomass_tr)
rec2_prepped &lt;- prep(rec2, training = biomass_tr)

# To see what changed
bake(rec_prepped, new_data = NULL)
bake(rec2_prepped, new_data = NULL)

# Cannot update a recipe step that has been trained!
## Not run: 
update(rec_prepped$steps[[1]], degree = 4)

## End(Not run)

</code></pre>

<hr>
<h2 id='yj_transform'>Internal Functions</h2><span id='topic+yj_transform'></span><span id='topic+estimate_yj'></span><span id='topic+ellipse_check'></span><span id='topic+printer'></span><span id='topic+prepare'></span><span id='topic+is_trained'></span><span id='topic+sel2char'></span><span id='topic+print_step'></span>

<h3>Description</h3>

<p>These are not to be used directly by the users.
</p>
<p><code>ellipse_check()</code> is deprecated. Instead, empty selections should be
supported by all steps.
</p>
<p>This internal function is used for printing steps.
</p>
<p>This internal function takes a list of selectors (e.g. <code>terms</code>
in most steps) and returns a character vector version for
printing.
</p>
<p>This internal function is used for printing steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yj_transform(x, lambda, ind_neg = NULL, eps = 0.001)

estimate_yj(
  dat,
  limits = c(-5, 5),
  num_unique = 5,
  na_rm = TRUE,
  call = caller_env(2)
)

ellipse_check(...)

printer(
  tr_obj = NULL,
  untr_obj = NULL,
  trained = FALSE,
  width = max(20, options()$width - 30)
)

prepare(x, ...)

is_trained(x)

sel2char(x)

print_step(
  tr_obj = NULL,
  untr_obj = NULL,
  trained = FALSE,
  title = NULL,
  width = max(20, options()$width - 30),
  case_weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yj_transform_+3A_x">x</code></td>
<td>
<p>A list of selectors</p>
</td></tr>
<tr><td><code id="yj_transform_+3A_...">...</code></td>
<td>
<p>Arguments pass in from a call to <code>step</code></p>
</td></tr>
<tr><td><code id="yj_transform_+3A_tr_obj">tr_obj</code></td>
<td>
<p>A character vector of names that have been
resolved during preparing the recipe (e.g. the <code>columns</code> object
of <code><a href="#topic+step_log">step_log()</a></code>).</p>
</td></tr>
<tr><td><code id="yj_transform_+3A_untr_obj">untr_obj</code></td>
<td>
<p>An object of selectors prior to prepping the
recipe (e.g. <code>terms</code> in most steps).</p>
</td></tr>
<tr><td><code id="yj_transform_+3A_trained">trained</code></td>
<td>
<p>A logical for whether the step has been trained.</p>
</td></tr>
<tr><td><code id="yj_transform_+3A_width">width</code></td>
<td>
<p>An integer denoting where the output should be wrapped.</p>
</td></tr>
<tr><td><code id="yj_transform_+3A_title">title</code></td>
<td>
<p>A character, shortly describing the action the step takes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If not empty, a list of quosures. If empty, an error is thrown.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p>A logical
</p>
<p>A character vector
</p>
<p><code>NULL</code>, invisibly.
</p>


<h3>See Also</h3>

<p><a href="#topic+developer_functions">developer_functions</a>
</p>
<p><a href="#topic+developer_functions">developer_functions</a>
</p>
<p><a href="#topic+developer_functions">developer_functions</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
