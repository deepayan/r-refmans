<!DOCTYPE html><html><head><title>Help for package Amelia</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Amelia}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#africa'><p>Economic and Political Indictors in 6 African States</p></a></li>
<li><a href='#amelia'><p>AMELIA: Multiple Imputation of Incomplete Multivariate Data</p></a></li>
<li><a href='#amelia-package'><p>Amelia II: A Program for Missing Data</p></a></li>
<li><a href='#ameliabind'><p>Combine multiple runs of Amelia</p></a></li>
<li><a href='#ameliagui'><p>Interactive GUI for Amelia</p></a></li>
<li><a href='#AmeliaView'><p>Interactive GUI for Amelia</p></a></li>
<li><a href='#combine.output'><p>Combine Multiple Amelia Output Lists</p></a></li>
<li><a href='#compare.density'><p>Compare observed versus imputed densities</p></a></li>
<li><a href='#disperse'><p>Overdispersed starting values diagnostic for multiple imputation</p></a></li>
<li><a href='#freetrade'><p>Trade Policy and Democracy in 9 Asian States</p></a></li>
<li><a href='#mi.combine'><p>Combine results from analyses on imputed data sets</p></a></li>
<li><a href='#mi.meld'><p>Combine Multiple Results From Multiply Imputed Datasets</p></a></li>
<li><a href='#missmap'><p>Missingness Map</p></a></li>
<li><a href='#moPrep'><p>Prepare Multiple Overimputation Settings</p></a></li>
<li><a href='#overimpute'><p>Overimputation diagnostic plot</p></a></li>
<li><a href='#plot.amelia'><p>Summary plots for Amelia objects</p></a></li>
<li><a href='#summary.amelia'><p>Summary of an Amelia object</p></a></li>
<li><a href='#transform.amelia'><p>Transform imputed datasets from Amelia objects</p></a></li>
<li><a href='#tscsPlot'><p>Plot observed and imputed time-series for a single cross-section</p></a></li>
<li><a href='#with.amelia'><p>Execute commands within each imputed data set</p></a></li>
<li><a href='#write.amelia'><p>Write Amelia imputations to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-18</td>
</tr>
<tr>
<td>Title:</td>
<td>A Program for Missing Data</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), Rcpp (&ge; 0.11)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreign, utils, grDevices, graphics, methods, stats, rlang</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11), RcppArmadillo</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool that "multiply imputes" missing data in a single cross-section
  (such as a survey), from a time series (like variables collected for
  each year in a country), or from a time-series-cross-sectional data
  set (such as collected by years for each of several countries).
  Amelia II implements our bootstrapping-based algorithm that gives
  essentially the same answers as the standard IP or EMis approaches,
  is usually considerably faster than existing approaches and can
  handle many more variables.  Unlike Amelia I and other statistically
  rigorous imputation software, it virtually never crashes (but please
  let us know if you find to the contrary!).  The program also
  generalizes existing approaches by allowing for trends in time series
  across observations within a cross-sectional unit, as well as priors
  that allow experts to incorporate beliefs they have about the values
  of missing cells in their data.  Amelia II also includes useful
  diagnostics of the fit of multiple imputation models.  The program
  works from the R command line or via a graphical user interface that
  does not require users to know R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gking.harvard.edu/amelia">https://gking.harvard.edu/amelia</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>tcltk, broom, rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-18 19:28:14 UTC; mblackwell</td>
</tr>
<tr>
<td>Author:</td>
<td>James Honaker [aut],
  Gary King [aut],
  Matthew Blackwell <a href="https://orcid.org/0000-0002-3689-9527"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Blackwell &lt;mblackwell@gov.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-19 19:40:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='africa'>Economic and Political Indictors in 6 African States</h2><span id='topic+africa'></span>

<h3>Description</h3>

<p>Data on a few economic and political variables in six
African States from 1972-1991. The variables are year, country name,
Gross Domestic Product per capita, inflation, trade as a percentage of
GDP, a measure of civil liberties and total population. The data is
from the Africa Research Program. A few cells are missing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>africa</code></pre>


<h3>Format</h3>

<p>A data frame with 7 variables and 120 observations.</p>


<h3>Source</h3>

<p>Africa Research Program <a href="https://scholar.harvard.edu/rbates/data">https://scholar.harvard.edu/rbates/data</a></p>

<hr>
<h2 id='amelia'>AMELIA: Multiple Imputation of Incomplete Multivariate Data</h2><span id='topic+amelia'></span><span id='topic+amelia.amelia'></span><span id='topic+amelia.molist'></span><span id='topic+amelia.default'></span>

<h3>Description</h3>

<p>Runs the bootstrap EM algorithm on incomplete data and creates
imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amelia(x, ...)

## S3 method for class 'amelia'
amelia(x, m = 5, p2s = 1, frontend = FALSE, ...)

## S3 method for class 'molist'
amelia(x, ...)

## Default S3 method:
amelia(
  x,
  m = 5,
  p2s = 1,
  frontend = FALSE,
  idvars = NULL,
  ts = NULL,
  cs = NULL,
  polytime = NULL,
  splinetime = NULL,
  intercs = FALSE,
  lags = NULL,
  leads = NULL,
  startvals = 0,
  tolerance = 1e-04,
  logs = NULL,
  sqrts = NULL,
  lgstc = NULL,
  noms = NULL,
  ords = NULL,
  incheck = TRUE,
  collect = FALSE,
  arglist = NULL,
  empri = NULL,
  priors = NULL,
  autopri = 0.05,
  emburn = c(0, 0),
  bounds = NULL,
  max.resample = 100,
  overimp = NULL,
  boot.type = "ordinary",
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("amelia.ncpus", 1L),
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amelia_+3A_x">x</code></td>
<td>
<p>either a matrix, data.frame, a object of class
&quot;amelia&quot;, or an object of class &quot;molist&quot;. The first two will call the
default S3 method. The third a convenient way to perform more imputations
with the same parameters. The fourth will impute based on the settings from
<code>moPrep</code> and any additional arguments.</p>
</td></tr>
<tr><td><code id="amelia_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.</p>
</td></tr>
<tr><td><code id="amelia_+3A_m">m</code></td>
<td>
<p>the number of imputed datasets to create.</p>
</td></tr>
<tr><td><code id="amelia_+3A_p2s">p2s</code></td>
<td>
<p>an integer value taking either 0 for no screen output,
1 for normal screen printing of iteration numbers, and 2 for detailed
screen output.  See &quot;Details&quot; for specifics on output when p2s=2.</p>
</td></tr>
<tr><td><code id="amelia_+3A_frontend">frontend</code></td>
<td>
<p>a logical value used internally for the GUI.</p>
</td></tr>
<tr><td><code id="amelia_+3A_idvars">idvars</code></td>
<td>
<p>a vector of column numbers or column names that indicates
identification variables.  These will be dropped from the analysis but
copied into the imputed datasets.</p>
</td></tr>
<tr><td><code id="amelia_+3A_ts">ts</code></td>
<td>
<p>column number or variable name indicating the variable identifying time
in time series data.</p>
</td></tr>
<tr><td><code id="amelia_+3A_cs">cs</code></td>
<td>
<p>column number or variable name indicating the cross section variable.</p>
</td></tr>
<tr><td><code id="amelia_+3A_polytime">polytime</code></td>
<td>
<p>integer between 0 and 3 indicating what
power of polynomial should be included in the imputation model
to account for the effects of time.  A setting of 0 would
indicate constant levels, 1 would indicate linear time
effects, 2 would indicate squared effects, and 3 would
indicate cubic time effects.</p>
</td></tr>
<tr><td><code id="amelia_+3A_splinetime">splinetime</code></td>
<td>
<p>interger value of 0 or greater to control cubic
smoothing splines of time. Values between 0 and 3 create a simple
polynomial of time (identical to the polytime argument). Values <code>k</code> greater
than 3 create a spline with an additional <code>k-3</code>
knotpoints.</p>
</td></tr>
<tr><td><code id="amelia_+3A_intercs">intercs</code></td>
<td>
<p>a logical variable indicating if the
time effects of <code>polytime</code> should vary across the
cross-section.</p>
</td></tr>
<tr><td><code id="amelia_+3A_lags">lags</code></td>
<td>
<p>a vector of numbers or names indicating columns in the data
that should have their lags included in the imputation model.</p>
</td></tr>
<tr><td><code id="amelia_+3A_leads">leads</code></td>
<td>
<p>a vector of numbers or names indicating columns in the data
that should have their leads (future values) included in the imputation
model.</p>
</td></tr>
<tr><td><code id="amelia_+3A_startvals">startvals</code></td>
<td>
<p>starting values, 0 for the parameter matrix from
listwise deletion, 1 for an identity matrix.</p>
</td></tr>
<tr><td><code id="amelia_+3A_tolerance">tolerance</code></td>
<td>
<p>the convergence threshold for the EM algorithm.</p>
</td></tr>
<tr><td><code id="amelia_+3A_logs">logs</code></td>
<td>
<p>a vector of column numbers or column names that refer
to variables that require log-linear transformation.</p>
</td></tr>
<tr><td><code id="amelia_+3A_sqrts">sqrts</code></td>
<td>
<p>a vector of numbers or names indicating columns in the data
that should be transformed by a sqaure root function.  Data in this
column cannot be less than zero.</p>
</td></tr>
<tr><td><code id="amelia_+3A_lgstc">lgstc</code></td>
<td>
<p>a vector of numbers or names indicating columns in the data
that should be transformed by a logistic function for proportional data.
Data in this column must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="amelia_+3A_noms">noms</code></td>
<td>
<p>a vector of numbers or names indicating columns in the data
that are nominal variables.</p>
</td></tr>
<tr><td><code id="amelia_+3A_ords">ords</code></td>
<td>
<p>a vector of numbers or names indicating columns in the
data that should be treated as ordinal variables.</p>
</td></tr>
<tr><td><code id="amelia_+3A_incheck">incheck</code></td>
<td>
<p>a logical indicating whether or not the inputs to the
function should be checked before running <code>amelia</code>.  This should
only be set to <code>FALSE</code> if you are extremely confident that your
settings are non-problematic and you are trying to save computational
time.</p>
</td></tr>
<tr><td><code id="amelia_+3A_collect">collect</code></td>
<td>
<p>a logical value indicating whether or
not the garbage collection frequency should be increased during the
imputation model.  Only set this to <code>TRUE</code> if you are experiencing memory
issues as it can significantly slow down the imputation
process</p>
</td></tr>
<tr><td><code id="amelia_+3A_arglist">arglist</code></td>
<td>
<p>an object of class &quot;ameliaArgs&quot; from a previous run of
Amelia. Including this object will use the arguments from that run.</p>
</td></tr>
<tr><td><code id="amelia_+3A_empri">empri</code></td>
<td>
<p>number indicating level of the empirical (or ridge) prior.
This prior shrinks the covariances of the data, but keeps the means
and variances the same for problems of high missingness, small N's or
large correlations among the variables.  Should be kept small,
perhaps 0.5 to 1 percent of the rows of the data; a
reasonable upper bound is around 10 percent of the rows of the
data.</p>
</td></tr>
<tr><td><code id="amelia_+3A_priors">priors</code></td>
<td>
<p>a four or five column matrix containing the priors for
either individual missing observations or variable-wide missing
values.  See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="amelia_+3A_autopri">autopri</code></td>
<td>
<p>allows the EM chain to increase the empirical prior if
the path strays into an nonpositive definite covariance matrix, up
to a maximum empirical prior of the value of this argument times
<code>n</code>, the number of observations.  Must be between 0 and 1, and at
zero this turns off this feature.</p>
</td></tr>
<tr><td><code id="amelia_+3A_emburn">emburn</code></td>
<td>
<p>a numeric vector of length 2, where <code>emburn[1]</code> is
a the minimum EM chain length and <code>emburn[2]</code> is the
maximum EM chain length. These are ignored if they are less than 1.</p>
</td></tr>
<tr><td><code id="amelia_+3A_bounds">bounds</code></td>
<td>
<p>a three column matrix to hold logical bounds on the
imputations. Each row of the matrix should be of the form
<code>c(column.number, lower.bound,upper.bound)</code> See Details below.</p>
</td></tr>
<tr><td><code id="amelia_+3A_max.resample">max.resample</code></td>
<td>
<p>an integer that specifies how many times Amelia
should redraw the imputed values when trying to meet the logical
constraints of <code>bounds</code>. After this value, imputed values are
set to the bounds.</p>
</td></tr>
<tr><td><code id="amelia_+3A_overimp">overimp</code></td>
<td>
<p>a two-column matrix describing which cells are to be
overimputed. Each row of the matrix should be a <code>c(row,column)</code> pair.
Each of these cells will be treated as missing and
replaced with draws from the imputation model.</p>
</td></tr>
<tr><td><code id="amelia_+3A_boot.type">boot.type</code></td>
<td>
<p>choice of bootstrap, currently restricted to either
<code>"ordinary"</code> for the usual non-parametric bootstrap and
<code>"none"</code> for no bootstrap.</p>
</td></tr>
<tr><td><code id="amelia_+3A_parallel">parallel</code></td>
<td>
<p>the type of parallel operation to be used (if any). If
missing, the default is taken from the option
<code>"amelia.parallel"</code> (and if that is not set, <code>"no"</code>).</p>
</td></tr>
<tr><td><code id="amelia_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: the number of processes to be used in parallel
operation: typically one would choose the number of available CPUs.</p>
</td></tr>
<tr><td><code id="amelia_+3A_cl">cl</code></td>
<td>
<p>an optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>. If not supplied, a cluster on the local
machine is created for the duration of the <code>amelia</code> call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple imputation is a method for analyzing incomplete
multivariate data. This function will take an incomplete dataset in
either data frame or matrix form and return <code>m</code> imputed datatsets
with no missing values. The algorithm first creates a bootstrapped
version of the original data, estimates the sufficient statistics
(with priors if specified) by EM on this bootstrapped sample, and
then imputes the missing values of the original data using the
estimated sufficient statistics. It repeats this process <code>m</code>
times to produce the <code>m</code> complete datasets where the
observed values are the same and the unobserved values are drawn
from their posterior distributions.
</p>
<p>The function will start a &quot;fresh&quot; run of the algorithm if <code>x</code> is
either a incomplete matrix or data.frame. In this method, all of the
options will be user-defined or set to their default. If <code>x</code>
is  the output of a previous Amelia run (that is, an object of
class &quot;amelia&quot;), then Amelia will run with the options used in
that previous run. This is a convenient way to run more
imputations of the same model.
</p>
<p>You can provide Amelia with informational priors about the missing
observations in your data.  To specify priors, pass a four or five
column matrix to the <code>priors</code> argument with each row specifying a
different priors as such:
</p>
<p><code> one.prior &lt;- c(row, column, mean,standard deviation)</code>
</p>
<p>or,
</p>
<p><code> one.prior &lt;- c(row, column, minimum, maximum, confidence)</code>.
</p>
<p>So, in the first and second column of the priors matrix should be the
row and column number of the prior being set.  In the other columns
should either be the mean and standard deviation of the prior, or a
minimum, maximum and confidence level for the prior. You must specify
your priors all as distributions or all as confidence ranges.  Note
that ranges are converted to distributions, so setting a confidence of
1 will generate an error.
</p>
<p>Setting a priors for the missing values of an entire variable is done
in the same manner as above, but inputing a <code>0</code> for the row
instead of the row number.  If priors are set for both the entire
variable and an individual observation, the individual prior takes
precedence.
</p>
<p>In addition to priors, Amelia allows for logical bounds on
variables. The <code>bounds</code> argument should be a matrix with 3
columns, with each row referring to a logical bound on a variable. The
first column should be the column number of the variable to be
bounded, the second column should be the lower bounds for that
variable, and the third column should be the upper bound for that
variable. As Amelia enacts these bounds by resampling, particularly
poor bounds will end up resampling forever. Amelia will stop
resampling after <code>max.resample</code> attempts and simply set the
imputation to the relevant bound.
</p>
<p>If each imputation is taking a long time to converge, you can increase
the empirical prior, <code>empri</code>.  This value has the effect of smoothing
out the likelihood surface so that the EM algorithm can more easily find
the maximum.  It should be kept as low as possible and only used if needed.
</p>
<p>Amelia assumes the data is distributed multivariate normal.  There are a
number of variables that can break this assumption.  Usually, though, a
transformation can make any variable roughly continuous and unbounded.
We have included a number of commonly needed transformations for data.
Note that the data will not be transformed in the output datasets and the
transformation is simply useful for climbing the likelihood.
</p>
<p>Amelia can run its imputations in parallel using the methods of the
<span class="pkg">parallel</span> package. The <code>parallel</code> argument names the
parallel backend that Amelia should use. Users on Windows systems must
use the <code>"snow"</code> option and users on Unix-like systems should use
<code>"multicore"</code>.  The <code>multicore</code> backend sets itself up
automatically, but the <code>snow</code> backend requires more setup. You
can pass a predefined cluster from the
<code>parallel::makePSOCKcluster</code> function to the <code>cl</code>
argument. Without this cluster, Amelia will attempt to create a
reasonable default cluster and stop it once computation is
complete. When using the parallel backend, users can set the number of
CPUs to use with the <code>ncpus</code> argument. The defaults for these two
arguments can be set with the options <code>"amelia.parallel"</code> and
<code>"amelia.ncpus"</code>.
</p>
<p>Please refer to the Amelia manual for more information on the function
or the options.
</p>


<h3>Value</h3>

<p>An instance of S3 class &quot;amelia&quot; with the following objects:
</p>
<table>
<tr><td><code>imputations</code></td>
<td>
<p>a list of length <code>m</code> with an imputed dataset in
each entry. The class (matrix or data.frame) of these entries will
match <code>x</code>.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>an integer indicating the number of imputations run.</p>
</td></tr>
<tr><td><code>missMatrix</code></td>
<td>
<p>a matrix identical in size to the original dataset
with 1 indicating a missing observation and a 0 indicating an observed
observation.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>An array with dimensions <code class="reqn">(p+1)</code> by <code class="reqn">(p+1)</code> by <code class="reqn">m</code>  (where
<code class="reqn">p</code> is the number of variables in the imputations model) holding
the converged parameters for each of the <code>m</code> EM chains.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>A <code class="reqn">p</code> by <code class="reqn">m</code> matrix of of the posterior modes for the
complete-data means in each of the EM chains.</p>
</td></tr>
<tr><td><code>covMatrices</code></td>
<td>
<p>An array with dimensions <code class="reqn">(p)</code> by <code class="reqn">(p)</code> by
<code class="reqn">m</code> where the first two dimensions hold the posterior modes of the
covariance matrix of the complete data for each of the EM chains.</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>a integer indicating the exit code of the Amelia run.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>an exit message for the Amelia run</p>
</td></tr>
<tr><td><code>iterHist</code></td>
<td>
<p>a list of iteration histories for each EM chain. See
documentation for details.</p>
</td></tr>
<tr><td><code>arguments</code></td>
<td>
<p>a instance of the class &quot;ameliaArgs&quot; which holds the
arguments used in the Amelia run.</p>
</td></tr>
<tr><td><code>overvalues</code></td>
<td>
<p>a vector of values removed for overimputation. Used to
reformulate the original data from the imputations. </p>
</td></tr>
</table>
<p>Note that the <code>theta</code>, <code>mu</code> and <code>covMatrcies</code> objects
refers to the data as seen by the EM algorithm and is thusly centered,
scaled, stacked, tranformed and rearranged. See the manual for details
and how to access this information.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>amelia(amelia)</code>: Run additional imputations for Amelia output
</p>
</li>
<li> <p><code>amelia(molist)</code>: Perform multiple overimputation from moPrep
</p>
</li>
<li> <p><code>amelia(default)</code>: Run core Amelia algorithm
</p>
</li></ul>


<h3>Author(s)</h3>

<p>James Honaker
</p>
<p>Gary King
</p>
<p>Matt Blackwell
</p>


<h3>References</h3>

<p>Honaker, J., King, G., Blackwell, M. (2011).
Amelia II: A Program for Missing Data.
<em>Journal of Statistical Software</em>, <b>45(7)</b>, 1&ndash;47.
<a href="https://doi.org/10.18637/jss.v045.i07">doi:10.18637/jss.v045.i07</a>
</p>


<h3>See Also</h3>

<p>For imputation diagnostics, <code><a href="#topic+missmap">missmap</a></code>,
<code><a href="#topic+compare.density">compare.density</a></code>,
<code><a href="#topic+overimpute">overimpute</a></code> and <code><a href="#topic+disperse">disperse</a></code>. For time series
plots, <code><a href="#topic+tscsPlot">tscsPlot</a></code>. Also: <code><a href="#topic+plot.amelia">plot.amelia</a></code>,
<code><a href="#topic+write.amelia">write.amelia</a></code>, and <code><a href="#topic+ameliabind">ameliabind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
a.out &lt;- amelia(x = africa, cs = "country", ts = "year", logs = "gdp_pc")
summary(a.out)
plot(a.out)

</code></pre>

<hr>
<h2 id='amelia-package'>Amelia II: A Program for Missing Data</h2><span id='topic+amelia-package'></span>

<h3>Description</h3>

<p>Uses a bootstrap+EM algorithm to impute missing values
from a dataset and produces multiple output datasets for analysis.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> amelia</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2006-03-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> See Manual</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>You can use the package in one of two ways:  either by invoking the 
<code>ameliagui()</code> command and running the program from a graphical 
interface or by loading in your data and then running the <code>amelia</code>
function on the data.
</p>
<p>If you use the GUI in Windows, makes sure that you run R under a Single
Window Interface (SDI) as it will try to grab focus from the GUI if
you don't.
</p>


<h3>Author(s)</h3>

<p>James Honaker, Matthew Blackwell, Gary King
</p>


<h3>References</h3>

<p>James Honaker, Gary King, Matthew Blackwell (2011).
Amelia II: A Program for Missing Data.
<em>Journal of Statistical Software</em>, <b>45(7)</b>, 1&ndash;47.
URL http://www.jstatsoft.org/v45/i07/.
</p>
<p>King, Gary; James Honaker, Anne Joseph, and Kenneth Scheve. \&quot;Analyzing 
Incomplete Political Science Data: An Alternative Algorithm for Multiple 
Imputation\&quot;, <em>American Political Science Review</em>, Vol. 95, No. 1 
(March, 2001): Pp. 49-69.
</p>

<hr>
<h2 id='ameliabind'>Combine multiple runs of Amelia</h2><span id='topic+ameliabind'></span>

<h3>Description</h3>

<p>Combines multiple runs of <code>amelia</code> with the same
arguments and data into one <code>amelia</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ameliabind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ameliabind_+3A_...">...</code></td>
<td>
<p>one or more objects of class <code>amelia</code> with the same
arguments and created from the same data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ameliabind</code> will combine multiple runs of <code>amelia</code> into one
object so that you can utilize diagnostics and modelling on all the
imputations together. This function is useful for combining multiple
runs of <code>amelia</code> run on parallel machines.
</p>
<p>Note that <code>ameliabind</code> only checks that they arguments and the
missingness matrix are identical. Thus, it could be fooled by two
datasets that are identical up to a transformation of one variable.
</p>


<h3>Value</h3>

<p>An object of class <code>amelia</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amelia">amelia</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
a1.out &lt;- amelia(x = africa, cs = "country", ts = "year", logs = "gdp_pc")
a2.out &lt;- amelia(x = africa, cs = "country", ts = "year", logs = "gdp_pc")
all.out &lt;- ameliabind(a1.out, a2.out)
summary(all.out)
plot(all.out)

</code></pre>

<hr>
<h2 id='ameliagui'>Interactive GUI for Amelia</h2><span id='topic+ameliagui'></span><span id='topic+main.close'></span>

<h3>Description</h3>

<p>Brings up the AmeliaView graphical interface, which allows users
to load datasets, manage options and run Amelia from a traditional
windowed environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AmeliaView()
</code></pre>

<hr>
<h2 id='AmeliaView'>Interactive GUI for Amelia</h2><span id='topic+AmeliaView'></span>

<h3>Description</h3>

<p>Brings up the AmeliaView graphical interface, which allows users to load datasets,
manage options and run Amelia from a traditional windowed environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AmeliaView()
</code></pre>


<h3>Details</h3>

<p>Requires the tcltk package.
</p>

<hr>
<h2 id='combine.output'>Combine Multiple Amelia Output Lists</h2><span id='topic+combine.output'></span>

<h3>Description</h3>

<p>This function combines output lists from multiple runs of
Amelia, where each run used the same arguments. The result is one
list, formatted as if Amelia had been run once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.output(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.output_+3A_...">...</code></td>
<td>
<p>a list of Amelia output lists from runs of Amelia with the
same arguments except the number of imputations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for combining the output from Amelia
runs that occurred at different times or in different sessions of
R. It assumes that the arguments given to the runs of Amelia are the
same except for <code>m</code>, the number of imputations, and it uses the
arguments from the first output list as the arguments for the combined
output list.
</p>

<hr>
<h2 id='compare.density'>Compare observed versus imputed densities</h2><span id='topic+compare.density'></span>

<h3>Description</h3>

<p>Plots smoothed density plots of observed and imputed values from output
from the <code>amelia</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.density(
  output,
  var,
  col = c("indianred", "dodgerblue"),
  scaled = FALSE,
  lwd = 1,
  main,
  xlab,
  ylab,
  legend = TRUE,
  frontend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.density_+3A_output">output</code></td>
<td>
<p>output from the function <code>amelia</code>.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_var">var</code></td>
<td>
<p>column number or variable name of the variable to plot.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_col">col</code></td>
<td>
<p>a vector of length 2 containing the color to plot the (1)
imputed density and (2) the observed density.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_scaled">scaled</code></td>
<td>
<p>a logical indicating if the two densities should be
scaled to reflect the difference in number of units in each.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_lwd">lwd</code></td>
<td>
<p>the line width of the density plots.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_main">main</code></td>
<td>
<p>main title of the plot. The default is to title the plot
using the variable name.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_xlab">xlab</code></td>
<td>
<p>the label for the x-axis. The default is the name of the
variable.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_ylab">ylab</code></td>
<td>
<p>the label for the y-axis. The default is &quot;Relative Density.&quot;</p>
</td></tr>
<tr><td><code id="compare.density_+3A_legend">legend</code></td>
<td>
<p>a logical value indicating if a legend should be
plotted.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_frontend">frontend</code></td>
<td>
<p>a logical value used internally for the Amelia GUI.</p>
</td></tr>
<tr><td><code id="compare.density_+3A_...">...</code></td>
<td>
<p>further graphical parameters for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first plots a density plot of the observed units for the
variable <code>var</code> in <code>col[2]</code>. The the function plots a density plot of the mean
or modal imputations for the missing units in <code>col[1]</code>. If a
variable is marked &quot;ordinal&quot; or &quot;nominal&quot; with the <code>ords</code> or
<code>noms</code> options in <code>amelia</code>, then the modal imputation will
be used. If <code>legend</code> is <code>TRUE</code>, then a legend is plotted as well.
</p>


<h3>References</h3>

<p>Abayomi, K. and Gelman, A. and Levy, M. 2005 &quot;Diagnostics for
Multivariate Imputations,&quot; <em>Applied Statistics</em>. 57,3: 273&ndash;291.
</p>


<h3>See Also</h3>

<p>For more information on how densities are computed,
<code><a href="stats.html#topic+density">density</a></code>; Other imputation diagnostics are
<code><a href="#topic+overimpute">overimpute</a></code>, <code><a href="#topic+disperse">disperse</a></code>, and
<code><a href="#topic+tscsPlot">tscsPlot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)

</code></pre>

<hr>
<h2 id='disperse'>Overdispersed starting values diagnostic for multiple imputation</h2><span id='topic+disperse'></span>

<h3>Description</h3>

<p>A visual diagnostic of EM convergence from multiple overdispersed
starting values for an output from <code>amelia</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disperse(
  output,
  m = 5,
  dims = 1,
  p2s = 0,
  frontend = FALSE,
  ...,
  xlim = NULL,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disperse_+3A_output">output</code></td>
<td>
<p>output from the function <code>amelia</code>.</p>
</td></tr>
<tr><td><code id="disperse_+3A_m">m</code></td>
<td>
<p>the number of EM chains to run from overdispersed starting values.</p>
</td></tr>
<tr><td><code id="disperse_+3A_dims">dims</code></td>
<td>
<p>the number of principle components of the parameters to
display and assess convergence on (up to 2).</p>
</td></tr>
<tr><td><code id="disperse_+3A_p2s">p2s</code></td>
<td>
<p>an integer that controls printing to screen. 0 (default)
indicates no printing, 1 indicates normal screen output and 2
indicates diagnostic output.</p>
</td></tr>
<tr><td><code id="disperse_+3A_frontend">frontend</code></td>
<td>
<p>a logical value used internally for the Amelia GUI.</p>
</td></tr>
<tr><td><code id="disperse_+3A_...">...</code></td>
<td>
<p>further graphical parameters for the plot.</p>
</td></tr>
<tr><td><code id="disperse_+3A_xlim">xlim</code></td>
<td>
<p>limits of the plot in the horizontal dimension.</p>
</td></tr>
<tr><td><code id="disperse_+3A_ylim">ylim</code></td>
<td>
<p>limits of the plot in vertical dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tracks the convergence of <code>m</code> EM chains which start
from various overdispersed starting values. This plot should give some
indication of the sensitivity of the EM algorithm to the choice of
starting values in the imputation model in <code>output</code>. If all of
the lines converge to the same point, then we can be confident that
starting values are not affecting the EM algorithm.
</p>
<p>As the parameter space of the imputation model is of a
high-dimension, this plot tracks how the first (and second if
<code>dims</code> is 2) principle component(s) change over the iterations of
the EM algorithm. Thus, the plot is a lower dimensional summary of the
convergence and is subject to all the drawbacks inherent in said
summaries.
</p>
<p>For <code>dims==1</code>, the function plots a horizontal line at the
position where the first EM chain converges. Thus, we are checking
that the other chains converge close to that horizontal line. For
<code>dims==2</code>, the function draws a convex hull around the point of
convergence for the first EM chain. The hull is scaled to be within
the tolerance of the EM algorithm. Thus, we should check that the
other chains end up in this hull.
</p>


<h3>See Also</h3>

<p>Other imputation diagnostics are
<code><a href="#topic+compare.density">compare.density</a></code>, <code><a href="#topic+disperse">disperse</a></code>, and
<code><a href="#topic+tscsPlot">tscsPlot</a></code>
</p>

<hr>
<h2 id='freetrade'>Trade Policy and Democracy in 9 Asian States</h2><span id='topic+freetrade'></span>

<h3>Description</h3>

<p>Economic and political data on nine developing countries in
Asia from 1980 to 1999. This dataset includes 9 variables including
year, country, average tariff rates, Polity IV score, total population,
gross domestic product per capita, gross international reserves, a dummy
variable for if the country had signed an IMF agreement in that year, a
measure of financial openness, and a measure of US hegemony. These data
were used in Milner and Kubota (2005).</p>


<h3>Usage</h3>

<pre><code class='language-R'>freetrade</code></pre>


<h3>Format</h3>

<p>A data frame with 10 variables and 171 observations.</p>


<h3>Source</h3>

<p>World Bank, World Trade Organization, Polity IV and others.</p>


<h3>References</h3>

<p>Helen Milner and Keiko Kubota (2005), &ldquo;Why the move to free trade?
Democracy and trade policy in the developing countries.&rdquo;
<em>International Organization</em>, Vol 59, Issue 1.</p>

<hr>
<h2 id='mi.combine'>Combine results from analyses on imputed data sets</h2><span id='topic+mi.combine'></span>

<h3>Description</h3>

<p>Combine results from statistical models run on multiply imputed
data sets using the so-called Rubin rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.combine(x, conf.int = FALSE, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi.combine_+3A_x">x</code></td>
<td>
<p>List of output from statistical models estimated on
different imputed data sets, as outputted by <code>with(a.out,
expr)</code> where <code>a.out</code> is the output of a call to <code>amelia</code>.</p>
</td></tr>
<tr><td><code id="mi.combine_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating if confidence intervals should
be computed for each quantity of interest (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mi.combine_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence
interval  if <code>conf.level = TRUE</code>. Defaults to 0.95, which
corresponds to a 95 percent confidence interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>tibble</code> that contains:
</p>

<dl>
<dt>term</dt><dd><p>Name of the coefficient or parameter.</p>
</dd>
<dt>estimate</dt><dd><p>Estimate of the parameter, averagine across imputations.</p>
</dd>
<dt>std.error</dt><dd><p>Standard error of the estimate, accounting for
imputation uncertainty.</p>
</dd>
<dt>statistic</dt><dd><p>Value of the t-statistic for the estimated
parameter.</p>
</dd>
<dt>p.value</dt><dd><p>p-value associated with the test of a null
hypothesis that the true coefficient is zero. Uses the
t-distribution with an imputation-adjusted degrees of freedom.</p>
</dd>
<dt>df</dt><dd><p>Imputation-adjusted degrees of freedom for each
parameter.</p>
</dd>
<dt>r</dt><dd><p>Relative increase in variance due to nonresponse.</p>
</dd>
<dt>miss.info</dt><dd><p>Estimated fraction of missing information.</p>
</dd>
<dt>conf.low</dt><dd><p>Lower bound of the estimated confidence interval.
Only present if <code>conf.int = TRUE</code>.</p>
</dd>
<dt>conf.high</dt><dd><p>Upper bound of the estimated confidence interval.
Only present if <code>conf.int = TRUE</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matt Blackwell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
a.out &lt;- amelia(x = africa, cs = "country", ts = "year", logs =
"gdp_pc")

imp.mods &lt;- with(a.out, lm(gdp_pc ~ infl + trade))

mi.combine(imp.mods, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='mi.meld'>Combine Multiple Results From Multiply Imputed Datasets</h2><span id='topic+mi.meld'></span>

<h3>Description</h3>

<p>Combine sets of estimates (and their standard errors) generated from
different multiply imputed datasets into one set of results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.meld(q, se, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi.meld_+3A_q">q</code></td>
<td>
<p>A matrix or data frame of (k) quantities of interest (eg.
coefficients, parameters, means) from (m) multiply imputed datasets.
Default is to assume the matrix is m-by-k (see <code>byrow</code>), thus each
row represents a set of results from one dataset, and each column
represents the different values of a particular quantity of interest
across the imputed datasets.</p>
</td></tr>
<tr><td><code id="mi.meld_+3A_se">se</code></td>
<td>
<p>A matrix or data frame of standard errors that correspond to each of the
elements of the quantities of interest in <code>q</code>.  Should be the same
dimensions as <code>q</code>.</p>
</td></tr>
<tr><td><code id="mi.meld_+3A_byrow">byrow</code></td>
<td>
<p>logical.  If <code>TRUE</code>, <code>q</code> and <code>se</code> are treated as
though each row represents the set of results from one dataset
(thus m-by-k).  If <code>FALSE</code>, each column represents results from one
dataset (thus k-by-m).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Rubin's rules for combining a set of results from multiply imputed
datasets to reflect the average result, with standard errors that both average
uncertainty across models and account for disagreement in the estimated values
across the models.
</p>


<h3>Value</h3>

<table>
<tr><td><code>q.mi</code></td>
<td>
<p>Average value of each quantity of interest across the m models</p>
</td></tr>
<tr><td><code>se.mi</code></td>
<td>
<p>Standard errors of each quantity of interest</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rubin, D. (1987). <em>Multiple Imputation for Nonresponse in Surveys</em>.
New York: Wiley.
</p>
<p>Honaker, J., King, G., Honaker, J. Joseph, A. Scheve K. (2001). Analyzing
Incomplete Political Science Data: An Alternative Algorithm for Multiple
Imputation <em>American Political Science Review</em>, <b>95(1)</b>, 49&ndash;69. (p53)
</p>

<hr>
<h2 id='missmap'>Missingness Map</h2><span id='topic+missmap'></span>

<h3>Description</h3>

<p>Plots a missingness map showing where missingness occurs in
the dataset passed to <code>amelia</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missmap(
  obj,
  vars,
  legend = TRUE,
  col,
  main,
  y.cex = 0.8,
  x.cex = 0.8,
  y.labels,
  y.at,
  csvar = NULL,
  tsvar = NULL,
  rank.order = TRUE,
  margins = c(5, 5),
  gap.xaxis = 1,
  x.las = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missmap_+3A_obj">obj</code></td>
<td>
<p>an object of class &quot;amelia&quot;; typically output from the
function <code>amelia</code>, a matrix or a dataframe.</p>
</td></tr>
<tr><td><code id="missmap_+3A_vars">vars</code></td>
<td>
<p>a vector of column numbers or column names of the data
to include in the plot. The default is to plot all variables.</p>
</td></tr>
<tr><td><code id="missmap_+3A_legend">legend</code></td>
<td>
<p>should a legend be drawn? (True or False)</p>
</td></tr>
<tr><td><code id="missmap_+3A_col">col</code></td>
<td>
<p>a vector of length two where the first element specifies
the color for missing cells and the second element specifies</p>
</td></tr>
<tr><td><code id="missmap_+3A_main">main</code></td>
<td>
<p>main title of the plot. Defaults to &quot;Missingness Map&quot;.</p>
</td></tr>
<tr><td><code id="missmap_+3A_y.cex">y.cex</code></td>
<td>
<p>expansion for the variables names on the x-axis.</p>
</td></tr>
<tr><td><code id="missmap_+3A_x.cex">x.cex</code></td>
<td>
<p>expansion for the unit names on the y-axis.</p>
</td></tr>
<tr><td><code id="missmap_+3A_y.labels">y.labels</code></td>
<td>
<p>a vector of row labels to print on the y-axis</p>
</td></tr>
<tr><td><code id="missmap_+3A_y.at">y.at</code></td>
<td>
<p>a vector of the same length as <code>y.labels</code> with row
nmumbers associated with the labels.</p>
</td></tr>
<tr><td><code id="missmap_+3A_csvar">csvar</code></td>
<td>
<p>column number or name of the variable corresponding to
the unit indicator. Only used when the <code>obj</code> is not of class
<code>amelia</code>.</p>
</td></tr>
<tr><td><code id="missmap_+3A_tsvar">tsvar</code></td>
<td>
<p>column number or name of the variable corresponding to
the time indicator. Only used when the <code>obj</code> is not of class
<code>amelia</code>.</p>
</td></tr>
<tr><td><code id="missmap_+3A_rank.order">rank.order</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the default, then
the order of the variables along the the x-axis is sorted by the
percent missing (from highest to lowest). If <code>FALSE</code>, it is
simply the order of the variables in the data.</p>
</td></tr>
<tr><td><code id="missmap_+3A_margins">margins</code></td>
<td>
<p>a vector of length two that specifies the bottom and
left margins of the plot. Useful for when variable names or
row names are long.</p>
</td></tr>
<tr><td><code id="missmap_+3A_gap.xaxis">gap.xaxis</code></td>
<td>
<p>value to pass to the <code>gap.axis</code> argument of
the <code>axis</code> function that plots the x-axis. See
<code><a href="graphics.html#topic+axis">axis</a></code> for more details. Ignored on R versions less
than 4.0.0.</p>
</td></tr>
<tr><td><code id="missmap_+3A_x.las">x.las</code></td>
<td>
<p>value of the <code>las</code> argument to pass to the
<code><a href="graphics.html#topic+axis">axis</a></code> function creating the x-axis.</p>
</td></tr>
<tr><td><code id="missmap_+3A_...">...</code></td>
<td>
<p>further graphical arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>missmap</code> draws a map of the missingness in a dataset using the
<code>image</code> function. The columns are reordered to put the most
missing variable farthest to the left. The rows are reordered to a
unit-period order if the <code>ts</code> and <code>cs</code> arguments were passed
to <code>amelia</code>. If not, the rows are not reordered.
</p>
<p>The <code>y.labels</code> and <code>y.at</code> commands can be used to associate
labels with rows in the data to identify them in the plot. The y-axis
is internally inverted so that the first row of the data is associated
with the top-most row of the missingness map. The values of
<code>y.at</code> should refer to the rows of the data, not to any point on
the plotting region.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare.density">compare.density</a></code>, <code><a href="#topic+overimpute">overimpute</a></code>,
<code><a href="#topic+tscsPlot">tscsPlot</a></code>, <code><a href="Matrix.html#topic+image">image</a></code>, <code><a href="stats.html#topic+heatmap">heatmap</a></code>
</p>

<hr>
<h2 id='moPrep'>Prepare Multiple Overimputation Settings</h2><span id='topic+moPrep'></span><span id='topic+moPrep.molist'></span><span id='topic+moPrep.default'></span>

<h3>Description</h3>

<p>A function to generate priors for multiple overimputation of
a variable measured with error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moPrep(
  x,
  formula,
  subset,
  error.proportion,
  gold.standard = !missing(subset),
  error.sd
)

## S3 method for class 'molist'
moPrep(x, formula, subset, error.proportion, gold.standard = FALSE, error.sd)

## Default S3 method:
moPrep(
  x,
  formula,
  subset,
  error.proportion,
  gold.standard = !missing(subset),
  error.sd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moPrep_+3A_x">x</code></td>
<td>
<p>either a matrix, data.frame, or a object of class &quot;molist&quot;
from a previous <code>moPrep</code> call. The first two derive the priors
from the data given, and the third will derive the priors from the
first <code>moPrep</code> call and add them to the already defined
priors.</p>
</td></tr>
<tr><td><code id="moPrep_+3A_formula">formula</code></td>
<td>
<p>a formula describing the nature of the measurement
error for the variable. See &quot;Details.&quot;</p>
</td></tr>
<tr><td><code id="moPrep_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
which possess measurement error.</p>
</td></tr>
<tr><td><code id="moPrep_+3A_error.proportion">error.proportion</code></td>
<td>
<p>an optional vector specifying the fraction of
the observed variance that is due to measurement error.</p>
</td></tr>
<tr><td><code id="moPrep_+3A_gold.standard">gold.standard</code></td>
<td>
<p>a logical value indicating if values with no
measurement error should be used to estimate the measurement error
variance.</p>
</td></tr>
<tr><td><code id="moPrep_+3A_error.sd">error.sd</code></td>
<td>
<p>an optional vector specifying the standard error of
the measurement error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates priors for multiple overimputation of data
measured with error. With the <code>formula</code> arugment, you can specify
which variable has the error, what the mean of the latent data is, and
if there are any other proxy measures of the mismeasured variable. The
general syntax for the formula is: <code>errvar ~ mean | proxy</code>,
where <code>errvar</code> is the mismeasured variable, <code>mean</code> is a
formula for the mean of the latent variable (usually just
<code>errvar</code> itself), and <code>proxy</code> is a another mismeasurement of
the same latent variable. The proxies are used to estimate the
variance of the measurement error.
</p>
<p><code>subset</code> and <code>gold.standard</code> refer to the the rows of the
data which are and are not measured with error. Gold-standard rows are
used to estimate the variance of the
measurement. error. <code>error.proportion</code> is used to estimate the
variance of the measurement error by estimating the variance of the
mismeasurement and taking the proportion assumed to be due to
error. <code>error.sd</code> sets the standard error of the measurement
error directly.
</p>


<h3>Value</h3>

<p>An instance of the S3 class &quot;molist&quot; with the following
objects:
</p>

<ul>
<li><p> priors a four-column matrix of the multiple overimputation priors
associated with the data. Each row of the matrix is
<code>c(row,column, prior.mean, prior.sd)</code>
</p>
</li>
<li><p> overimp a two-column matrix of cells to be overimputed. Each
row of the matrix is of the form <code>c(row, column)</code>, which
indicate the row and column of the cell to be overimputed.
</p>
</li>
<li><p> data the object name of the matrix or data.frame to which
priors refer.
</p>
</li></ul>

<p>Note that <code>priors</code> and <code>overimp</code> might contain results from
multiple calls to <code>moPrep</code>, not just the most recent.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>moPrep(molist)</code>: Alter existing moPrep output
</p>
</li>
<li> <p><code>moPrep(default)</code>: Default call to moPrep
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+amelia">amelia</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(africa)
 m.out &lt;- moPrep(africa, trade ~ trade, error.proportion = 0.1)
 a.out &lt;- amelia(m.out, ts = "year", cs = "country")
 plot(a.out)
 m.out &lt;- moPrep(africa, trade ~ trade, error.sd = 1)
 a.out &lt;- amelia(m.out, ts = "year", cs = "country")

</code></pre>

<hr>
<h2 id='overimpute'>Overimputation diagnostic plot</h2><span id='topic+overimpute'></span>

<h3>Description</h3>

<p>Treats each observed value as missing and imputes from the imputation
model from <code>amelia</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overimpute(
  output,
  var,
  draws = 20,
  subset,
  legend = TRUE,
  xlab,
  ylab,
  main,
  frontend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overimpute_+3A_output">output</code></td>
<td>
<p>output from the function <code>amelia</code>.</p>
</td></tr>
<tr><td><code id="overimpute_+3A_var">var</code></td>
<td>
<p>column number or variable name of the variable to
overimpute.</p>
</td></tr>
<tr><td><code id="overimpute_+3A_draws">draws</code></td>
<td>
<p>the number of draws per imputed dataset to generate
overimputations. Total number of simulations will <code>m *
draws</code> where <code>m</code> is the number of imputations.</p>
</td></tr>
<tr><td><code id="overimpute_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the overimputation.</p>
</td></tr>
<tr><td><code id="overimpute_+3A_legend">legend</code></td>
<td>
<p>a logical value indicating if a legend should be
plotted.</p>
</td></tr>
<tr><td><code id="overimpute_+3A_xlab">xlab</code></td>
<td>
<p>the label for the x-axis. The default is &quot;Observed Values.&quot;</p>
</td></tr>
<tr><td><code id="overimpute_+3A_ylab">ylab</code></td>
<td>
<p>the label for the y-axis. The default is &quot;Imputed Values.&quot;</p>
</td></tr>
<tr><td><code id="overimpute_+3A_main">main</code></td>
<td>
<p>main title of the plot. The default is to smartly title the plot
using the variable name.</p>
</td></tr>
<tr><td><code id="overimpute_+3A_frontend">frontend</code></td>
<td>
<p>a logical value used internally for the Amelia GUI.</p>
</td></tr>
<tr><td><code id="overimpute_+3A_...">...</code></td>
<td>
<p>further graphical parameters for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function temporarily treats each observed value in
<code>var</code> as missing and imputes that value based on the imputation
model of <code>output</code>. The dots are the mean imputation and the
vertical lines are the 90% percent confidence intervals for
imputations of each observed value. The diagonal line is the <code class="reqn">y=x</code>
line. If all of the imputations were perfect, then our points would
all fall on the line. A good imputation model would have about 90% of
the confidence intervals containing the truth; that is, about 90% of
the vertical lines should cross the diagonal.
</p>
<p>The color of the vertical lines displays the fraction of missing
observations in the pattern of missingness for that
observation. The legend codes this information. Obviously, the
imputations will be much tighter if there are more observed covariates
to use to impute that observation.
</p>
<p>The <code>subset</code> argument evaluates in the environment of the
data. That is, it can but is not required to refer to variables in the
data frame as if it were attached.
</p>


<h3>Value</h3>

<p>A list that contains (1) the row in the original data
(<code>row</code>), (2) the observed value of that observation
(<code>orig</code>), (2) the mean of the overimputations
(<code>mean.overimputed</code>), (3) the lower bound of the 95%
confidence interval of the overimputations
(<code>lower.overimputed</code>), (4) the upper bound of the 95%
confidence interval of the overimputations
(<code>upper.overimputed</code>), (5) the fraction of the variables
that were missing for that observation in the original data
(<code>prcntmiss</code>), and (6) a matrix of the raw overimputations,
with observations in rows and the different draws in columns (<code>overimps</code>).
</p>


<h3>See Also</h3>

<p>Other imputation diagnostics are
<code><a href="#topic+compare.density">compare.density</a></code>, <code><a href="#topic+disperse">disperse</a></code>, and
<code><a href="#topic+tscsPlot">tscsPlot</a></code>.
</p>

<hr>
<h2 id='plot.amelia'>Summary plots for Amelia objects</h2><span id='topic+plot.amelia'></span>

<h3>Description</h3>

<p>Plots diagnostic plots for the output from the
<code>amelia</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amelia'
plot(x, which.vars, compare = TRUE, overimpute = FALSE, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.amelia_+3A_x">x</code></td>
<td>
<p>an object of class &quot;amelia&quot;; typically output from the
function <code>amelia</code>.</p>
</td></tr>
<tr><td><code id="plot.amelia_+3A_which.vars">which.vars</code></td>
<td>
<p>a vector indicating the variables to plot. The
default is to plot all of the numeric variables that were actually
imputed.</p>
</td></tr>
<tr><td><code id="plot.amelia_+3A_compare">compare</code></td>
<td>
<p>plot the density comparisons for each variable (True or False)</p>
</td></tr>
<tr><td><code id="plot.amelia_+3A_overimpute">overimpute</code></td>
<td>
<p>plot the overimputation for each variable (True or False)</p>
</td></tr>
<tr><td><code id="plot.amelia_+3A_ask">ask</code></td>
<td>
<p>prompt user before changing pages of a plot (True or False)</p>
</td></tr>
<tr><td><code id="plot.amelia_+3A_...">...</code></td>
<td>
<p>further graphical arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.amelia'>Summary of an Amelia object</h2><span id='topic+summary.amelia'></span>

<h3>Description</h3>

<p>Returns summary information from the Amelia run along with
missingles information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amelia'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.amelia_+3A_object">object</code></td>
<td>
<p>an object of class <code>amelia</code>. Typically, an output
from the function <code>amelia</code>.</p>
</td></tr>
<tr><td><code id="summary.amelia_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+amelia">amelia</a></code>, <code><a href="#topic+plot.amelia">plot.amelia</a></code>
</p>

<hr>
<h2 id='transform.amelia'>Transform imputed datasets from Amelia objects</h2><span id='topic+transform.amelia'></span>

<h3>Description</h3>

<p>Updates the imputed datasets from an <code>amelia</code> output
with the specified transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amelia'
transform(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform.amelia_+3A__data">_data</code></td>
<td>
<p>an object of class &quot;amelia&quot;; typically output from the
function <code>amelia</code>.</p>
</td></tr>
<tr><td><code id="transform.amelia_+3A_...">...</code></td>
<td>
<p>further arguments of the form <code>tag = value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>...</code> arugments to <code>transform.amelia</code> are
expressions of the form <code>tag = value</code>, where <code>tag</code> is the
variable that is being updated or created and <code>value</code> is an
expression that is a function of the variables in the imputed
datasets. For instance, if you wanted to create an interaction of two
imputed variables, you could have one argument be <code>intervar =
  var1 * var2</code>. This would either update the current variable
<code>intervar</code> in the imputed data or append a new variable called
<code>intervar</code> to the imputed datasets.
</p>


<h3>Value</h3>

<p>An object of class <code>amelia</code> with its <code>imputations</code> and
<code>missMatrix</code> values updated according to the transformations. In
addition, each of the calls to <code>transform.amelia</code> are stored in
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+transform">transform</a></code>
</p>

<hr>
<h2 id='tscsPlot'>Plot observed and imputed time-series for a single cross-section</h2><span id='topic+tscsPlot'></span>

<h3>Description</h3>

<p>Plots a time series for a given variable in a given cross-section and
provides confidence intervals for the imputed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscsPlot(
  output,
  var,
  cs,
  draws = 100,
  conf = 0.9,
  misscol = "red",
  obscol = "black",
  xlab,
  ylab,
  main,
  pch,
  ylim,
  xlim,
  frontend = FALSE,
  plotall = FALSE,
  nr,
  nc,
  pdfstub,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tscsPlot_+3A_output">output</code></td>
<td>
<p>output from the function <code>amelia</code>.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_var">var</code></td>
<td>
<p>the column number or variable name of the variable to plot.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_cs">cs</code></td>
<td>
<p>the name (or level) of the cross-sectional unit to plot.
Maybe a vector of names which will panel a window of plots</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_draws">draws</code></td>
<td>
<p>the number of imputations on which to base the confidence
intervals.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_conf">conf</code></td>
<td>
<p>the confidence level of the confidence intervals to plot
for the imputated values.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_misscol">misscol</code></td>
<td>
<p>the color of the imputed values and their confidence
intervals.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_obscol">obscol</code></td>
<td>
<p>the color of the points for observed units.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_main">main</code></td>
<td>
<p>overall plot title</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_pch">pch</code></td>
<td>
<p>point shapes for the plot.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_ylim">ylim</code></td>
<td>
<p>y limits (y1, y2) of the plot.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_xlim">xlim</code></td>
<td>
<p>x limits (x1, x2) of the plot.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_frontend">frontend</code></td>
<td>
<p>a logical value for use with the <code>AmeliaView</code> GUI.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_plotall">plotall</code></td>
<td>
<p>a logical value that provides a shortcut for ploting all unique values of the level.
A shortcut for the <code>cs</code> argument, a TRUE value overwrites any
<code>cs</code> argument.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_nr">nr</code></td>
<td>
<p>the number of rows of plots to use when ploting multiple cross-sectional
units.  The default value will try to minimize this value to create a roughly
square representation, up to a value of four.  If all plots do not fit on the
window, a new window will be started.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_nc">nc</code></td>
<td>
<p>the number of columns of plots to use.  See <code>nr</code></p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_pdfstub">pdfstub</code></td>
<td>
<p>a stub string used to write pdf copies of each window created by the
plot.  The default is not to write pdf output, but any string value will turn
on pdf output to the local working directory.  If the stub is <code>mystub</code>,
then plots will be saved as <code>mystub1.pdf</code>, <code>mystub2.pdf</code>, etc.</p>
</td></tr>
<tr><td><code id="tscsPlot_+3A_...">...</code></td>
<td>
<p>further graphical parameters for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cs</code> argument should be a value from the variable set to the
<code>cs</code> argument in the <code>amelia</code> function for this output. This
function will not work if the <code>ts</code> and <code>cs</code> arguments were
not set in the <code>amelia</code> function. If an observation has been
overimputed, <code>tscsPlot</code> will plot both an observed and an imputed
value.
</p>

<hr>
<h2 id='with.amelia'>Execute commands within each imputed data set</h2><span id='topic+with.amelia'></span>

<h3>Description</h3>

<p>Evaluate an R expression in the environments constructed from the
imputed data sets of a call to <code>amelia</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'amelia'
with(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.amelia_+3A_data">data</code></td>
<td>
<p>imputation output from the <code>amelia</code> funtion.</p>
</td></tr>
<tr><td><code id="with.amelia_+3A_expr">expr</code></td>
<td>
<p>expression to evaluate in each imputed data set in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="with.amelia_+3A_...">...</code></td>
<td>
<p>arguments to be passed to (future) methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list the same length as <code>data$imputations</code> that
contains the output of the expression as evaluated in each imputed
data set of <code>data</code>.
</p>


<h3>Author(s)</h3>

<p>Matt Blackwell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(africa)
a.out &lt;- amelia(x = africa, cs = "country", ts = "year", logs =
"gdp_pc")

imp.mods &lt;- with(a.out, lm(gdp_pc ~ infl + trade))

mi.combine(imp.mods, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='write.amelia'>Write Amelia imputations to file</h2><span id='topic+write.amelia'></span>

<h3>Description</h3>

<p>Writes the imptuted datasets to file from a run of <code>amelia</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.amelia(
  obj,
  separate = TRUE,
  file.stem,
  extension = NULL,
  format = "csv",
  impvar = "imp",
  orig.data = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.amelia_+3A_obj">obj</code></td>
<td>
<p>an object of class &quot;amelia&quot;; typically output from the
function <code>amelia</code></p>
</td></tr>
<tr><td><code id="write.amelia_+3A_separate">separate</code></td>
<td>
<p>logical variable. If <code>TRUE</code> (default), the
imputed datasets will be written to separate files, whose names come
from the <code>file.stem</code> and <code>extension</code> arguments. If <code>FALSE</code>,
the imputations are stacked and written as a single file.</p>
</td></tr>
<tr><td><code id="write.amelia_+3A_file.stem">file.stem</code></td>
<td>
<p>the leading part of the filename to save to
output The imputation number and <code>extension</code> will be added to
complete the filename. This can include a directory path.</p>
</td></tr>
<tr><td><code id="write.amelia_+3A_extension">extension</code></td>
<td>
<p>the extension of the filename. This is simply what
follows <code>file.stem</code> and the imputation number.</p>
</td></tr>
<tr><td><code id="write.amelia_+3A_format">format</code></td>
<td>
<p>one of the following output formats: <code>csv</code>,
<code>dta</code> or <code>table</code>. See details.</p>
</td></tr>
<tr><td><code id="write.amelia_+3A_impvar">impvar</code></td>
<td>
<p>the name of imputation number variable written to the
stacked dataset when <code>separate</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="write.amelia_+3A_orig.data">orig.data</code></td>
<td>
<p>logical variable indicating whether the original,
unimputed dataset should be included in the stacked dataset when
<code>separate</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="write.amelia_+3A_...">...</code></td>
<td>
<p>further arguments for the <code>write</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>write.amelia</code> writes the imputed datasets to a file or a set of files
using one of the following functions: <code>write.csv</code>,
<code>write.dta</code>, or <code>write.table</code>. You can pass arguments to
these functions from <code>write.amelia</code>.
</p>
<p>When <code>separate</code> is <code>TRUE</code>, each imputed dataset is written
to its own file. If you were to set <code>file.stem</code> to
<code>"outdata"</code> and the <code>extension</code> to <code>".csv"</code> , then the
resulting filename of the written files will be
</p>
<pre>
  outdata1.csv
  outdata2.csv
  outdata3.csv
  ...
</pre>
<p>and so on.
</p>
<p>When <code>separate</code> is <code>FALSE</code>, the function adds a variable
called <code>impvar</code> to each dataset which indicates the imputed
dataset to which the row belongs. Then, each of the datasets are
stacked together to create one dataset. If <code>orig.data</code> is <code>TRUE</code>,
then the original, unimputed dataset is included at the top of the
stack, with its imputation number set to 0.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+write.csv">write.csv</a></code>, <code><a href="utils.html#topic+write.table">write.table</a></code>, <code><a href="foreign.html#topic+write.dta">write.dta</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
