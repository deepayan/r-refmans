<!DOCTYPE html><html><head><title>Help for package binhf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {binhf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#afgen'><p>NN and Anscombe samples</p></a></li>
<li><a href='#ansc'><p>Anscombe transformation</p></a></li>
<li><a href='#asymean'><p>Asymptotic mean calculation</p></a></li>
<li><a href='#asyvar'><p>Asymptotic variance function</p></a></li>
<li><a href='#binhf.wd'><p>Binomial Haar-Fisz wavelet transform</p></a></li>
<li><a href='#Blocks'><p>Proportion Functions</p></a></li>
<li><a href='#chr20'><p>DNA datasets</p></a></li>
<li><a href='#ebayesthresh.wavelet.wd'><p>Modified EbayesThresh wavelet thresholding function</p></a></li>
<li><a href='#free'><p>Freeman-Tukey transform</p></a></li>
<li><a href='#freeinv'><p>Inverse Freeman-Tukey transform</p></a></li>
<li><a href='#hf.inv2'><p>Haar-NN inverse transform</p></a></li>
<li><a href='#hfdenoise'><p>Simulation function</p></a></li>
<li><a href='#hfdenoise.wav'><p>Denoising function</p></a></li>
<li><a href='#ht'><p>Forward Haar wavelet transform</p></a></li>
<li><a href='#ht.inv'><p>Inverse Haar-NN</p></a></li>
<li><a href='#invansc'><p>Inverse Anscombe transformation</p></a></li>
<li><a href='#invbinhf.wd'><p>Inverse Haar-NN transform</p></a></li>
<li><a href='#norm'><p>Euclidean norm</p></a></li>
<li><a href='#pintens'><p>pintens</p></a></li>
<li><a href='#plotest'><p>Plotting function</p></a></li>
<li><a href='#propest.wav'><p>Proportion estimation function</p></a></li>
<li><a href='#qqnormy'><p>Quantile generator</p></a></li>
<li><a href='#qqstuff'><p>Quantile-quantile information about Haar-NN and Anscombe samples</p></a></li>
<li><a href='#shift'><p>Shift function</p></a></li>
<li><a href='#simsij'><p>Simulation function</p></a></li>
<li><a href='#statgen'><p>Statistics generator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Haar-Fisz Functions for Binomial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), wavethresh, adlift (&ge; 0.9.2), EbayesThresh</td>
</tr>
<tr>
<td>Description:</td>
<td>Binomial Haar-Fisz transforms for Gaussianization as in Nunes and Nason (2009).</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-18 21:49:13 UTC; nunes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-18 22:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='afgen'>NN and Anscombe samples</h2><span id='topic+afgen'></span>

<h3>Description</h3>

<p>Samples binomial Fisz and Anscombe transformed random variables on a grid of binomial probabilities.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afgen(xgrid = seq(0, 1, length = 21), ygrid = seq(0, 1, length = 21), samples = 1000, 
binsize = 32)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afgen_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x co-ordinate probabilities.</p>
</td></tr>
<tr><td><code id="afgen_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of x co-ordinate probabilities.</p>
</td></tr>
<tr><td><code id="afgen_+3A_samples">samples</code></td>
<td>
<p>the number of samples to draw from each random variable.</p>
</td></tr>
<tr><td><code id="afgen_+3A_binsize">binsize</code></td>
<td>
<p>the binomial size of the binomial random variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces sampled values from the random variable:<br /><br /> 
<code class="reqn">\zeta(X_1,X_2)=\frac{X_1-X_2}{ \sqrt{ (X_1+X_2)(2*binsize-X_1-X_2)/ 2*binsize }} 
</code>,<br /><br /> 
where <code class="reqn">X_i</code> are Bin(binsize,<code class="reqn">p_i</code>) random variables, for all combinations of values of <code class="reqn">p_1</code> in xgrid and <code class="reqn">p_2</code> in ygrid.  
For Anscombe's transformation, 
<code class="reqn">A=sin^{-1}\sqrt{(x+3/8)/(binsize+3/4)}</code>, the values correspond to the random variable with the larger binomial probability.
</p>


<h3>Value</h3>

<table>
<tr><td><code>a</code></td>
<td>
<p>an array of dimensions <code>length(xgrid)xlength(ygrid)xsamples</code> of values of binomial Haar-Fisz random variable.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>an array of dimensions <code>length(xgrid)xlength(ygrid)xsamples</code> of values of A.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Anscombe, F.J. (1948) The transformation of poisson, binomial and negative binomial Data, <em>Biometrika</em>,<b>35</b>, 246&ndash;254.<br />
Nunes, M. and Nason, G.P. (2009) A multiscale variance stabilization for binomial sequence proportion estimation. <em>Statistica Sinica</em>, <b>19</b>
(1491&ndash;1510).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ansc">ansc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##
varvalues&lt;-afgen(xgrid=seq(0,1,length=21),ygrid=seq(0,1,length=21),samples=1000,binsize=32)

##creates 1000 samples of the two random variables zeta_B and A for each point 
##(x,y) for x and y regularly-spaced probability vectors of length 21.
##
</code></pre>

<hr>
<h2 id='ansc'>Anscombe transformation</h2><span id='topic+ansc'></span>

<h3>Description</h3>

<p>Does Anscombe's inverse sine transformation on a vector input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ansc(x, binsize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ansc_+3A_x">x</code></td>
<td>
<p>input data vector</p>
</td></tr>
<tr><td><code id="ansc_+3A_binsize">binsize</code></td>
<td>
<p>the binomial size corresponding to the observed binomial values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the Anscombe calculation: <code class="reqn">A=sin^{-1}\sqrt{(x+3/8)/(binsize+3/4)}</code>.</p>


<h3>Value</h3>

<table>
<tr><td><code>y</code></td>
<td>
<p>vector of transformed data corresponding to <span class="env">x</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Anscombe, F.J. (1948) The transformation of poisson, binomial and negative binomial data.  <em>Biometrika</em>, <b>35</b>, 246-254.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+afgen">afgen</a></code>, <code><a href="#topic+hfdenoise">hfdenoise</a></code>, <code><a href="#topic+hfdenoise.wav">hfdenoise.wav</a></code>, <code>link{invansc}</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate binomial data:

x&lt;-rbinom(100,10,.5)

y&lt;-ansc(x,10)

#this is now the transformed data.

</code></pre>

<hr>
<h2 id='asymean'>Asymptotic mean calculation</h2><span id='topic+asymean'></span>

<h3>Description</h3>

<p>This function gives values for the asymptotic mean of the new binomial Fisz random variable for a grid of bivariate proportion values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymean(xgrid = seq(0, 1, length = 21), ygrid = seq(0, 1, length = 21), binsize = 32)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asymean_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x co-ordinate probabilities.</p>
</td></tr>
<tr><td><code id="asymean_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of y co-ordinate probabilities.</p>
</td></tr>
<tr><td><code id="asymean_+3A_binsize">binsize</code></td>
<td>
<p>the binomial size of the binomial random variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>  See <code><a href="#topic+afgen">afgen</a></code> for an explanation of the computation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>zetam1m2</code></td>
<td>
<p>A matrix of dimension <code>length(xgrid)xlength(ygrid)</code> of values of the mean.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Fisz, M. (1955), The Limiting Distribution of a Function of Two Independent Random Variables and its Statistical
Application, <em>Colloquium Mathematicum</em>, <b>3</b>, 138&ndash;146.</p>


<h3>See Also</h3>

<p><code><a href="#topic+asyvar">asyvar</a></code>, <code><a href="#topic+afgen">afgen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
means&lt;-asymean(xgrid=seq(0,1,length=21),ygrid=seq(0,1,length=21),binsize=32)

## this produces a 21x21 matrix for an equally-spaced grid of binomial proportions. 
</code></pre>

<hr>
<h2 id='asyvar'>Asymptotic variance function</h2><span id='topic+asyvar'></span>

<h3>Description</h3>

<p>This function gives values for the asymptotic mean of the new binomial Fisz random variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asyvar(xgrid = seq(0, 1, length = 21), ygrid = seq(0, 1, length = 21))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asyvar_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x co-ordinate probabilities.</p>
</td></tr>
<tr><td><code id="asyvar_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of y co-ordinate probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the form of the asymptotic variance for equal binomial sizes, this does not need a specification of the binomial size 
<code>binsize</code> (see <code><a href="#topic+asymean">asymean</a></code>).
</p>


<h3>Value</h3>

<table>
<tr><td><code>asyvar</code></td>
<td>
<p>A matrix of dimension length(xgrid)xlength(ygrid) of values of the variance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Fisz, M. (1955), The Limiting Distribution of a Function of Two Independent Random Variables and its Statistical
Application, <em>Colloquium Mathematicum</em>, <b>3</b>, 138&ndash;146.</p>


<h3>See Also</h3>

<p><code><a href="#topic+asymean">asymean</a></code>, <code><a href="#topic+statgen">statgen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
variance&lt;-asyvar(xgrid=seq(0,1,length=21),ygrid=seq(0,1,length=21))

## this produces a 21x21 matrix for an equally-spaced grid of binomial proportions. 
</code></pre>

<hr>
<h2 id='binhf.wd'>Binomial Haar-Fisz wavelet transform</h2><span id='topic+binhf.wd'></span>

<h3>Description</h3>

<p>Forward Haar-Fisz transform for binomial random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binhf.wd(x, binsize = 1,print.info=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binhf.wd_+3A_x">x</code></td>
<td>
<p>data vector of binomial observations, of length a power of two.</p>
</td></tr>
<tr><td><code id="binhf.wd_+3A_binsize">binsize</code></td>
<td>
<p>the binomial size corresponding to <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="binhf.wd_+3A_print.info">print.info</code></td>
<td>
<p>boolean to print some information about the coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs the Haar wavelet transform on the data <span class="env">x</span>, and then modifies the wavelet coefficients by <code class="reqn">f_jk=d_jk/\sqrt{c_jk*(N-c_jk)/2N}</code>.  The inverse Haar transform is then performed.  This modification will stabilize the variance of the resulting vector.
</p>


<h3>Value</h3>

<table>
<tr><td><code>l</code></td>
<td>
<p>a list of two components <span class="env">transformed</span>: transformed observations corresponding to <span class="env">x</span> and <span class="env">cnew</span>: 
scaling coefficient vector used in Fisz modification.  This needs to be passed on to <span class="env">invbinhf.wd</span>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Nunes, M.A. and Nason, G.P. (2009) A Multiscale Variance Stabilization for binomial sequence proportion estimation, <em>Statistica Sinica</em>, 
<b>19</b>(4), 1491-1510.</p>


<h3>See Also</h3>

<p><code><a href="#topic+invbinhf.wd">invbinhf.wd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rbinom(256,32,.35)

y&lt;-binhf.wd(x,32)
</code></pre>

<hr>
<h2 id='Blocks'>Proportion Functions</h2><span id='topic+Blocks'></span><span id='topic+Blocksr'></span><span id='topic+Bumps'></span><span id='topic+Bumpsr'></span><span id='topic+Bursts'></span><span id='topic+Burstsr'></span><span id='topic+const'></span><span id='topic+P2'></span><span id='topic+P3'></span><span id='topic+P3a'></span><span id='topic+P4'></span><span id='topic+sinlog'></span><span id='topic+sinlogr'></span>

<h3>Description</h3>

<p>An example Bernoulli proportion function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Blocks(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Blocks_+3A_x">x</code></td>
<td>
<p>a sequence of &lsquo;time points&rsquo; as input into the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A proportion function based on the blocks function of Donoho, or that of Antoniadis and LeBlanc (2000).  The extra &ldquo;r&quot; versions of these functions are reflected at the right endpoint.
</p>


<h3>Value</h3>

<table>
<tr><td><code>y</code></td>
<td>
<p>a vector of function values for the proportion function, corresponding to <span class="env">x</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Antoniadis, A. and LeBlanc, F. (2000) Nonparametric wavelet regression for binary response. <em>Statistics</em>, <b>34</b>, 183&ndash;213.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t&lt;-seq(0,1,length=256)

y&lt;-Blocks(t)

plot(t,y, type="l")
</code></pre>

<hr>
<h2 id='chr20'>DNA datasets</h2><span id='topic+chr20'></span><span id='topic+mhc'></span>

<h3>Description</h3>

<p>Example DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chr20)</code></pre>


<h3>Details</h3>

<p>The datasets are the chromosome 20 sequence of the human genome, and the mhc dataset available from the Human Genome Project website, binary-coded by base pair content and curtailed to a power of two. 
</p>


<h3>Source</h3>

<p><a href="http://www.sanger.ac.uk">http://www.sanger.ac.uk</a> 
</p>

<hr>
<h2 id='ebayesthresh.wavelet.wd'>Modified EbayesThresh wavelet thresholding function</h2><span id='topic+ebayesthresh.wavelet.wd'></span><span id='topic+threshold.wd'></span><span id='topic+negloglik.laplace'></span><span id='topic+wandafromx'></span><span id='topic+madmad'></span>

<h3>Description</h3>

<p>Modified EbayesThresh functions. 
</p>


<h3>Details</h3>

<p>For help on these function, see the original help file supplied with the WaveThresh package.  There is a modification to try and avoid zero noise standard deviation estimation.
</p>

<hr>
<h2 id='free'>Freeman-Tukey transform</h2><span id='topic+free'></span>

<h3>Description</h3>

<p>Does Freeman-Tukey average inverse sine transformation on a vector input.</p>


<h3>Usage</h3>

<pre><code class='language-R'>free(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="free_+3A_x">x</code></td>
<td>
<p>input data vector</p>
</td></tr>
<tr><td><code id="free_+3A_n">n</code></td>
<td>
<p>the binomial size corresponding to the observed binomial values.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>a</code></td>
<td>
<p>vector of transformed data corresponding to <span class="env">x</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Freeman, M. F. and Tukey, J. W. (1950) Transformations related to the angular and the square root. <em>Ann. Math. Stat.</em>, <b>21</b>, 607&ndash;611. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freeinv">freeinv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate binomial data:

x&lt;-rbinom(100,10,.5)

y&lt;-free(x,10)

#this is now the transformed data.

</code></pre>

<hr>
<h2 id='freeinv'>Inverse Freeman-Tukey transform</h2><span id='topic+freeinv'></span>

<h3>Description</h3>

<p>Does the inverse of the Freeman-Tukey inverse sine transformation on a vector input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freeinv(y, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freeinv_+3A_y">y</code></td>
<td>
<p>input data vector.</p>
</td></tr>
<tr><td><code id="freeinv_+3A_n">n</code></td>
<td>
<p>the binomial size corresponding to the observed binomial values.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>a</code></td>
<td>
<p>vector of transformed data corresponding to <span class="env">y</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Freeman, M. F. and Tukey, J. W. (1950) Transformations related to the angular
and the square root. <em>Ann. Math. Stat.</em>, <b>21</b>, 607&ndash;611.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+free">free</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate binomial data:

x&lt;-rbinom(100,10,.5)

y&lt;-free(x,10)

x1&lt;-freeinv(y,10)

#this should be the original data.

</code></pre>

<hr>
<h2 id='hf.inv2'>Haar-NN inverse transform</h2><span id='topic+hf.inv2'></span>

<h3>Description</h3>

<p>Inverse Haar-NN transform for binomial random variables (&quot;in-place&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hf.inv2(data, binsize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hf.inv2_+3A_data">data</code></td>
<td>
<p>data vector of binomial observations, of length a power of two.</p>
</td></tr>
<tr><td><code id="hf.inv2_+3A_binsize">binsize</code></td>
<td>
<p>the binomial size corresponding to <span class="env">x</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs the inverse &quot;in-place&quot; Haar-NN wavelet transform on the data <span class="env">x</span>.
</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Nunes, M.A. and Nason, G.P. (2009)  A Multiscale Variance Stabilization for binomial sequence proportion estimation, 
<em>Statistica Sinica</em>,<b>19</b> (4), 1491&ndash;1510.</p>


<h3>See Also</h3>

<p><code><a href="#topic+invbinhf.wd">invbinhf.wd</a></code></p>

<hr>
<h2 id='hfdenoise'>Simulation function</h2><span id='topic+hfdenoise'></span>

<h3>Description</h3>

<p>Proportion estimation procedure for simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hfdenoise(n = 256, proportion = P2, binsize = 1, thrule = "ebayesthresh",
    van = 8, fam = "DaubLeAsymm", pl = 3, prior = "laplace", vscale = "independent", 
plotstep = FALSE, truncate = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hfdenoise_+3A_n">n</code></td>
<td>
<p>Length of vector to be sampled.</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_proportion">proportion</code></td>
<td>
<p>The function name of the proportion to be sampled.</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_binsize">binsize</code></td>
<td>
<p>The binomial size corresponding to the mean function <span class="env">proportion</span>.</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_thrule">thrule</code></td>
<td>
<p>Thresholding procedure to be used in the smoothing.  Possible values are &quot;sureshrink&quot; and &quot;ebayesthresh&quot;.</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_van">van</code></td>
<td>
<p>the vanishing moments of the decomposing wavelet basis.</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_fam">fam</code></td>
<td>
<p>the wavelet family to be used for the decomposing transform.Possible values are &quot;DaubLeAsymm&quot; and &quot;DaubExPhase&quot;.</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_pl">pl</code></td>
<td>
<p>the primary resolution to be used in the wavelet transform.</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_prior">prior</code></td>
<td>
<p>Prior to be used in ebayesthresh thresholding.</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_vscale">vscale</code></td>
<td>
<p>argument to ebayesthresh thresholding procedure (variance calculation: &quot;independent&quot; or &quot;bylevel&quot;).</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_plotstep">plotstep</code></td>
<td>
<p>Should all steps be plotted in estimation procedure?</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_truncate">truncate</code></td>
<td>
<p>Should the estimates be truncated to lie in [0,1]?</p>
</td></tr>
<tr><td><code id="hfdenoise_+3A_...">...</code></td>
<td>
<p>Any other optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a regularly-spaced vector on the unit interval of length <span class="env">length</span>, and uses these values to create corresponding values using the proportion function.  These values are then used as binomial probabilities to sample &quot;observed&quot; binomial random variables.  The observation vector is then denoised using a wavelet transform defined by the arguments <span class="env">pl</span>, <span class="env">van</span>, <span class="env">fam</span> with thresholding method <span class="env">thrule</span>.  This denoising is done for both Anscombe and the Haar-Fisz method for binomial random variables.  The procedure is repeated <span class="env">times</span> times, and the resulting proportion estimates averaged.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>regular grid on which the proportion function is evaluated.</p>
</td></tr>
<tr><td><code>truep</code></td>
<td>
<p>vector corresponding to <span class="env">x</span> of proportion function values.</p>
</td></tr>
<tr><td><code>fhat</code></td>
<td>
<p>Binomial Haar-Fisz estimate.</p>
</td></tr>
<tr><td><code>fhata</code></td>
<td>
<p>Anscombe inverse sine estimate.</p>
</td></tr>
<tr><td><code>fhatf</code></td>
<td>
<p>Freeman-Tukey average inverse sine estimate.</p>
</td></tr>
<tr><td><code>fl1</code></td>
<td>
<p>lokern estimate using <span class="env">binhf.wd</span> as a preprocessor.</p>
</td></tr>
<tr><td><code>fl2</code></td>
<td>
<p>lokern estimate using Anscombe as a preprocessor.</p>
</td></tr>
<tr><td><code>bbwd</code></td>
<td>
<p>wd object of binomial Haar-Fisz before thresholding.</p>
</td></tr>
<tr><td><code>awd</code></td>
<td>
<p>wd object of Anscombe before thresholding.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>data from which estimates were computed (sampled from <span class="env">truep</span>.</p>
</td></tr>
<tr><td><code>bb</code></td>
<td>
<p>data after being preprocessed with binomial Haar-Fisz.</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>Thresholded wd object of <span class="env">bbwd</span>.</p>
</td></tr>
<tr><td><code>tmp</code></td>
<td>
<p>Thresholded (binomial Haar-Fisz) data before postprocessing.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+simsij">simsij</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>sim&lt;-hfdenoise()

plot(sim$x,sim$truep,type="l", xlab="",ylab="Binomial Proportion")

##^^ shows original proportion to estimate.

lines(sim$x,sim$fhat,col=2)
lines(sim$x,sim$fhata,col=3)

##^^shows the estimates of the proportion from the two transforms.

</code></pre>

<hr>
<h2 id='hfdenoise.wav'>Denoising function</h2><span id='topic+hfdenoise.wav'></span>

<h3>Description</h3>

<p>Denoise algorithm for thresholding methods supplied with wavethresh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hfdenoise.wav(x, binsize, transform = "binhf", meth = "u", van = 1, fam = "DaubExPhase", 
min.level = 3,coarse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hfdenoise.wav_+3A_x">x</code></td>
<td>
<p>vector of observed values, of length a power of two.</p>
</td></tr>
<tr><td><code id="hfdenoise.wav_+3A_binsize">binsize</code></td>
<td>
<p>the binomial size of the observed values <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="hfdenoise.wav_+3A_transform">transform</code></td>
<td>
<p>A Gaussianizing transform.  Possible values are &quot;binhf&quot; or &quot;ansc&quot;.</p>
</td></tr>
<tr><td><code id="hfdenoise.wav_+3A_meth">meth</code></td>
<td>
<p>A wavelet thresholding method.  Possible values are &quot;u&quot; for universal thresholding, or &quot;c&quot; for cross-validation.</p>
</td></tr>
<tr><td><code id="hfdenoise.wav_+3A_van">van</code></td>
<td>
<p>the number of vanishing moments of the wavelet used in the wavelet denoiser.</p>
</td></tr>
<tr><td><code id="hfdenoise.wav_+3A_fam">fam</code></td>
<td>
<p>the wavelet family used in the wavelet denoiser.  Possible values are &quot;DaubLeAsymm&quot; and &quot;DaubExPhase&quot;.</p>
</td></tr>
<tr><td><code id="hfdenoise.wav_+3A_min.level">min.level</code></td>
<td>
<p>the primary resolution level for the wavelet transform denoiser.</p>
</td></tr>
<tr><td><code id="hfdenoise.wav_+3A_coarse">coarse</code></td>
<td>
<p>Boolean variable indicating whether a &quot;coarsening&quot; modification should be applied.  For use with the chromosome datasets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function pre and post-processes the observed data with either Anscombe's transform or the binomial Haar-Fisz transform, using a wavelet denoiser to smooth the data, specified by the inputs <span class="env">min.level</span>, <span class="env">van</span> and <span class="env">fam</span> combined with the thresholding rule <span class="env">meth</span>.If <span class="env">coarse</span> is set to true, the first finest 11 coefficient levels are set to zero, corresponding to coefficients produced from <code class="reqn">2^11</code>= 2048 nucleotide bases.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fhat</code></td>
<td>
<p>vector corresponding to <span class="env">x</span> of the estimated binomial proportion.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires the package wavethresh.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+hfdenoise">hfdenoise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(wavethresh)

#create a sample intensity vector:

int&lt;-sinlog(seq(0,1,length=256))
x&lt;-NULL
for(i in 1:256){
x[i]&lt;-rbinom(1,1,int[i])
}


est&lt;-hfdenoise.wav(x,1,transform="ansc","u",6,"DaubLeAsymm",3,FALSE) 

</code></pre>

<hr>
<h2 id='ht'>Forward Haar wavelet transform</h2><span id='topic+ht'></span><span id='topic+ht2'></span>

<h3>Description</h3>

<p>Forward Haar transform. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ht(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ht_+3A_x">x</code></td>
<td>
<p>data vector of (binomial) observations, of length a power of two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs the Haar wavelet transform on the data <span class="env">x</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ht.inv">ht.inv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rbinom(256,32,.35)
ht(x)
</code></pre>

<hr>
<h2 id='ht.inv'>Inverse Haar-NN</h2><span id='topic+ht.inv'></span>

<h3>Description</h3>

<p>Inverse Haar transform for binomial random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ht.inv(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ht.inv_+3A_data">data</code></td>
<td>
<p>transformed (binomial) observations: can be a list output from <code>ht2</code> or a vector (finest details to coarsest, scaling coefficient).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs the inverse Haar wavelet transform.
</p>


<h3>Value</h3>

<table>
<tr><td><code>res</code></td>
<td>
<p>datapoints in the function domain.</p>
</td></tr>
<tr><td><code>sm1</code></td>
<td>
<p>smooth coefficients during the inverse transform.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nunes, M.A. and Nason, G.P. (2009)  A Multiscale Variance Stabilization for binomial sequence proportion estimation, 
<em>Statistica Sinica</em>,<b>19</b> (4), 1491&ndash;1510.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ht2">ht2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rbinom(256,32,.35)
hx&lt;-ht2(x)
y&lt;-ht.inv(x)
</code></pre>

<hr>
<h2 id='invansc'>Inverse Anscombe transformation</h2><span id='topic+invansc'></span>

<h3>Description</h3>

<p>Does the inverse of Anscombe's inverse sine transformation on a vector input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invansc(y, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invansc_+3A_y">y</code></td>
<td>
<p>input data vector.</p>
</td></tr>
<tr><td><code id="invansc_+3A_n">n</code></td>
<td>
<p>the binomial size corresponding to the observed binomial values.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>vector of transformed data corresponding to <span class="env">y</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Anscombe, F.J. (1948) The transformation of poisson, binomial and negative binomial data.  <em>Biometrika</em>, <b>35</b>, 246-254.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ansc">ansc</a></code>, <code><a href="#topic+hfdenoise">hfdenoise</a></code>, <code><a href="#topic+hfdenoise.wav">hfdenoise.wav</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate binomial data:

x&lt;-rbinom(100,10,.5)

y&lt;-ansc(x,10)

x1&lt;-invansc(y,10)

#this should be the original data.

</code></pre>

<hr>
<h2 id='invbinhf.wd'>Inverse Haar-NN transform</h2><span id='topic+invbinhf.wd'></span>

<h3>Description</h3>

<p>Performs the inverse Haar-NN transform for binomial random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invbinhf.wd(transformed, binsize = 1,print.info=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invbinhf.wd_+3A_transformed">transformed</code></td>
<td>
<p>a list of two components <span class="env">transformed</span>: transformed observations of length a power of two and <span class="env">cnew</span>: scaling coefficient vector used in Fisz modification.</p>
</td></tr>
<tr><td><code id="invbinhf.wd_+3A_binsize">binsize</code></td>
<td>
<p>the binomial size corresponding to the vector transformed.</p>
</td></tr>
<tr><td><code id="invbinhf.wd_+3A_print.info">print.info</code></td>
<td>
<p>boolean to print some information about the coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure performs the Haar wavelet transform on the data <span class="env">transformed</span>, and then modifies the wavelet coefficients by <code class="reqn">d'_jk</code>=<code class="reqn">d_jk</code>*sqrt(<code class="reqn">c_jk</code>(N-<code class="reqn">c_jk</code>)/2N).  The inverse Haar transform is then performed.  This modification will stabilize the variance of the resulting vector.
</p>


<h3>Value</h3>

<table>
<tr><td><code>estimate</code></td>
<td>
<p>a vector of transformed observations corresponding to <span class="env">transformed</span>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires the package wavethresh.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>References</h3>

<p>Nunes, M.A. and Nason, G.P. (2009) &ldquo;A Multiscale Variance Stabilization for binomial sequence proportion estimation&quot;, <em>Statistica Sinica</em>,<b>19</b> (4), 1491&ndash;1510.</p>


<h3>See Also</h3>

<p><code><a href="#topic+binhf.wd">binhf.wd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rbinom(256,32,.35)

y&lt;-binhf.wd(x,32)

x1&lt;-invbinhf.wd(y,32)
</code></pre>

<hr>
<h2 id='norm'>Euclidean norm</h2><span id='topic+norm'></span>

<h3>Description</h3>

<p>Calculates the root squared error of two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm(x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_+3A_x">x</code></td>
<td>
<p>input data vector</p>
</td></tr>
<tr><td><code id="norm_+3A_y">y</code></td>
<td>
<p>input data vector</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>e</code></td>
<td>
<p>error between the two input vectors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate data:

x&lt;-y&lt;-runif(100)

error&lt;-norm(x,y)


#this is the difference between the vectors.

</code></pre>

<hr>
<h2 id='pintens'>pintens</h2><span id='topic+pintens'></span>

<h3>Description</h3>

<p>An example binomial intensity vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pintens)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:1024] 0.278 0.278 0.278 0.278 0.278 ...
</p>


<h3>Details</h3>

<p>The intensity is a vector of length 1024, based on a scaled &lsquo;bumps&rsquo; function of Donoho and Johnstone. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pintens)
plot(pintens,type="l")
</code></pre>

<hr>
<h2 id='plotest'>Plotting function</h2><span id='topic+plotest'></span>

<h3>Description</h3>

<p>Plotting function for proportion estimates procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotest(l, plot.it = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotest_+3A_l">l</code></td>
<td>
<p>A results list from <span class="env">doall</span>.</p>
</td></tr>
<tr><td><code id="plotest_+3A_plot.it">plot.it</code></td>
<td>
<p>Should results be plotted?</p>
</td></tr>
<tr><td><code id="plotest_+3A_verbose">verbose</code></td>
<td>
<p>Should extra information be given during the procedure?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <span class="env">norm</span> to compute errors for estimates produced by <span class="env">doall</span>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>hfn</code></td>
<td>
<p>error between Haar-Fisz estimate and <span class="env">truep</span> of <span class="env">doall</span>.</p>
</td></tr>
<tr><td><code>an</code></td>
<td>
<p>error between Anscombe estimate and <span class="env">truep</span> of <span class="env">doall</span>.</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>error between Freeman-Tukey estimate and <span class="env">truep</span> of <span class="env">doall</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm">norm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim&lt;-hfdenoise()

plotest(sim)

</code></pre>

<hr>
<h2 id='propest.wav'>Proportion estimation function</h2><span id='topic+propest.wav'></span>

<h3>Description</h3>

<p>Proportion estimation procedure for simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propest.wav(proportion = P2, binsize=1,length = 256, times = 100, meth = "u", van = 6, 
fam = "DaubLeAsymm", min.level = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propest.wav_+3A_proportion">proportion</code></td>
<td>
<p>A Bernoulli proportion/binomial mean function.  Examples are <span class="env">P2</span>, <span class="env">P4</span> and <span class="env">sinlog</span>.</p>
</td></tr>
<tr><td><code id="propest.wav_+3A_binsize">binsize</code></td>
<td>
<p>The binomial size corresponding to the mean function <span class="env">proportion</span>.</p>
</td></tr>
<tr><td><code id="propest.wav_+3A_length">length</code></td>
<td>
<p>Length of vector to be produced.  Must be a power of two.</p>
</td></tr>
<tr><td><code id="propest.wav_+3A_times">times</code></td>
<td>
<p>The number of times to sample the proportion.</p>
</td></tr>
<tr><td><code id="propest.wav_+3A_meth">meth</code></td>
<td>
<p>A wavelet thresholding method.  Possible values are &quot;u&quot; for universal thresholding, or &quot;c&quot; for cross-validation.</p>
</td></tr>
<tr><td><code id="propest.wav_+3A_van">van</code></td>
<td>
<p>the number of vanishing moments of the wavelet used in the wavelet denoiser.</p>
</td></tr>
<tr><td><code id="propest.wav_+3A_fam">fam</code></td>
<td>
<p>the wavelet family used in the wavelet denoiser.  Possible values are &quot;DaubLeAsymm&quot; and &quot;DaubExPhase&quot;.</p>
</td></tr>
<tr><td><code id="propest.wav_+3A_min.level">min.level</code></td>
<td>
<p>the primary resolution level for the wavelet transform denoiser.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a regularly-spaced vector on the unit interval of length <span class="env">length</span>, and uses these values to create corresponding values using the proportion function.  These values are then used as binomial probabilities to sample &quot;observed&quot; binomial random variables.  The observation vector is then denoised using a wavelet transform defined by the arguments <span class="env">van</span>, <span class="env">fam</span>, <span class="env">min.level</span> with thresholding method <span class="env">meth</span>.  This denoising is done for both Anscombe and the Haar-Fisz method for binomial random variables.  The procedure is repeated <span class="env">times</span> times, and the resulting proportion estimates averaged.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>regular grid on which the proportion function is evaluated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector corresponding to <span class="env">x</span> of proportion function values.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>matrix of dimensions <span class="env">times</span>x<span class="env">length</span> of sampled binomial variables.</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>matrix of dimensions <span class="env">times</span>x<span class="env">length</span> of estimated values of the proportion function, for the binomial Haar-Fisz transform.</p>
</td></tr>
<tr><td><code>ea</code></td>
<td>
<p>matrix of dimensions <span class="env">times</span>x<span class="env">length</span> of estimated values of the proportion function, for Anscombe's transform.</p>
</td></tr>
<tr><td><code>meanfhat</code></td>
<td>
<p>averaged proportion estimate for the binomial Haar-Fisz transform.</p>
</td></tr>
<tr><td><code>meanfhata</code></td>
<td>
<p>averaged proportion estimate for Anscombe's transform.</p>
</td></tr>
<tr><td><code>amse</code></td>
<td>
<p>average mean square error for the binomial Haar-Fisz transform.</p>
</td></tr>
<tr><td><code>amsea</code></td>
<td>
<p>average mean square error for Anscombe's transform.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim&lt;-propest.wav(proportion = P2, binsize=1,length = 256, times = 1000, meth = "u", 
van = 6, fam = "DaubLeAsymm", min.level = 4)

plot(sim$x,sim$y,type="l",xlab="",ylab="Binomial mean function")

##^^ shows original proportion to estimate.

lines(sim$x,sim$meanfhat,col=2)
lines(sim$x,sim$meanfhata,col=3)

##^^shows the estimates of the proportion from the two transforms.

## End(Not run)
</code></pre>

<hr>
<h2 id='qqnormy'>Quantile generator</h2><span id='topic+qqnormy'></span>

<h3>Description</h3>

<p>A Q-Q value generator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqnormy(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqnormy_+3A_y">y</code></td>
<td>
<p>data sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an equivalent to <span class="env">qqnorm</span>, but returning sorted values.  See <span class="env">qqnorm</span>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>y</code></td>
<td>
<p>vector of quantile values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqstuff">qqstuff</a></code></p>

<hr>
<h2 id='qqstuff'>Quantile-quantile information about Haar-NN and Anscombe samples</h2><span id='topic+qqstuff'></span>

<h3>Description</h3>

<p>A function to generate Q-Q plots (from simulations) for the Anscombe and (binomial) Haar-Fisz transforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqstuff(intensity, binsize = 4, paths = 100, respaths = 1000, plot.q = FALSE, 
plot.sq = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqstuff_+3A_intensity">intensity</code></td>
<td>
<p>an Bernoulli intensity vector, e.g. <span class="env">pintens</span>.</p>
</td></tr>
<tr><td><code id="qqstuff_+3A_binsize">binsize</code></td>
<td>
<p>a binomial size to generate a binomial mean vector.</p>
</td></tr>
<tr><td><code id="qqstuff_+3A_paths">paths</code></td>
<td>
<p>the number of paths sampled from the mean vector to use in Q-Q calculations.</p>
</td></tr>
<tr><td><code id="qqstuff_+3A_respaths">respaths</code></td>
<td>
<p>the number of residual paths to use in squared residual calculations.</p>
</td></tr>
<tr><td><code id="qqstuff_+3A_plot.q">plot.q</code></td>
<td>
<p>A boolean variable, indicating whether simulation Q-Q plots should be outputted or not.</p>
</td></tr>
<tr><td><code id="qqstuff_+3A_plot.sq">plot.sq</code></td>
<td>
<p>A boolean variable, indicating whether simulation squared residual plots should be outputted or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="env">respaths</span> paths are sampled from the mean intensity vector.  From these, the first <span class="env">paths</span> are used to generate Q-Q data, which are then averaged for the Q-Q plots.  The original paths are used to calculate a squared residual vector corresponding to the mean intensity vector. 
</p>


<h3>Value</h3>

<p>qqinfo.  A 8 component list of quantile and residual plot information.
</p>
<table>
<tr><td><code>vmat</code></td>
<td>
<p>A matrix of dimensions respathsxlength(intensity), each row being a path from the intensity vector.</p>
</td></tr>
<tr><td><code>Av</code></td>
<td>
<p>A matrix of dimensions respathsxlength(intensity), each row an Anscombe-transformed path.</p>
</td></tr>
<tr><td><code>bfv</code></td>
<td>
<p>A matrix of dimensions respathsxlength(intensity), each row a binomial Haar-Fisz-transformed path.</p>
</td></tr>
<tr><td><code>vminusl</code></td>
<td>
<p>A matrix of the difference between the paths and the mean intensity.</p>
</td></tr>
<tr><td><code>vminusl</code></td>
<td>
<p>A matrix of the difference between the Anscombe-transformed paths and the mean intensity.</p>
</td></tr>
<tr><td><code>vminusl</code></td>
<td>
<p>A matrix of the difference between the binomial Haar-Fisz-transformed paths and the mean intensity.</p>
</td></tr>
<tr><td><code>Asqres</code></td>
<td>
<p>vector of squared residuals of Anscombe-transformed paths.</p>
</td></tr>
<tr><td><code>bfsqres</code></td>
<td>
<p>vector of squared residuals of binomial Haar-Fisz-transformed paths.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires the package wavethresh.  N.B. Since this function returns a lot of information, assign the output to a variable, to avoid printing endless information in the console.</p>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqnormy">qqnormy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pintens)

a&lt;-qqstuff(intensity=pintens,binsize=4,paths=100,respaths=100,plot.q=TRUE,plot.sq=TRUE)

#plots some interesting graphs.
</code></pre>

<hr>
<h2 id='shift'>Shift function
</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>This function shifts a vector input a certain number of places in the direction desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(v, places, dir = "right")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_v">v</code></td>
<td>

<p>a vector of input values.
</p>
</td></tr>
<tr><td><code id="shift_+3A_places">places</code></td>
<td>

<p>the number of places to shift <span class="env">v</span>.
</p>
</td></tr>
<tr><td><code id="shift_+3A_dir">dir</code></td>
<td>

<p>The direction to shift <span class="env">v</span>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function shifts the vector <span class="env">v</span> by <span class="env">places</span> in the direction of <span class="env">direction</span>, using wrapping at the boundaries. Used for cycle spinning.
</p>


<h3>Value</h3>

<table>
<tr><td><code>vnew</code></td>
<td>
<p>the shifted version of <span class="env">v</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v&lt;-runif(10)

#have a look at v:

v

#now shift the values 4 places to the right...

shift(v,4,dir="right")

</code></pre>

<hr>
<h2 id='simsij'>Simulation function</h2><span id='topic+simsij'></span>

<h3>Description</h3>

<p>Proportion estimation procedure for simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simsij(nsims = 100, n = 256, proportion = P2, binsize = 1,
    thrule = "ebayesthresh", van = 8, fam = "DaubLeAsymm", pl = 3,
    prior = "laplace",
    vscale = "independent", plotstep = FALSE, a = NA,truncate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simsij_+3A_nsims">nsims</code></td>
<td>
<p>The number of times to repeat the function <span class="env">doall</span> (on random datasets from <span class="env">proportion</span>).</p>
</td></tr>
<tr><td><code id="simsij_+3A_n">n</code></td>
<td>
<p>Length of vector to be sampled.</p>
</td></tr>
<tr><td><code id="simsij_+3A_proportion">proportion</code></td>
<td>
<p>The function name of the proportion to be sampled.</p>
</td></tr>
<tr><td><code id="simsij_+3A_binsize">binsize</code></td>
<td>
<p>The binomial size corresponding to the mean function <span class="env">proportion</span>.</p>
</td></tr>
<tr><td><code id="simsij_+3A_thrule">thrule</code></td>
<td>
<p>Thresholding procedure to be used in the smoothing.  Possible values are &quot;sureshrink&quot; and &quot;ebayesthresh&quot;.</p>
</td></tr>
<tr><td><code id="simsij_+3A_van">van</code></td>
<td>
<p>the vanishing moments of the decomposing wavelet basis.</p>
</td></tr>
<tr><td><code id="simsij_+3A_fam">fam</code></td>
<td>
<p>the wavelet family to be used for the decomposing transform.Possible values are &quot;DaubLeAsymm&quot; and &quot;DaubExPhase&quot;.</p>
</td></tr>
<tr><td><code id="simsij_+3A_pl">pl</code></td>
<td>
<p>the primary resolution to be used in the wavelet transform.</p>
</td></tr>
<tr><td><code id="simsij_+3A_prior">prior</code></td>
<td>
<p>Prior to be used in ebayesthresh thresholding.</p>
</td></tr>
<tr><td><code id="simsij_+3A_vscale">vscale</code></td>
<td>
<p>argument to ebayesthresh thresholding procedure (variance calculation: &quot;independent&quot; or &quot;bylevel&quot;).</p>
</td></tr>
<tr><td><code id="simsij_+3A_plotstep">plotstep</code></td>
<td>
<p>Should all steps be plotted in estimation procedure?</p>
</td></tr>
<tr><td><code id="simsij_+3A_a">a</code></td>
<td>
<p>the <span class="env">a</span> argument for <code>EbayesThresh</code>.</p>
</td></tr>
<tr><td><code id="simsij_+3A_truncate">truncate</code></td>
<td>
<p>Should the estimates be truncated to lie in [0,1]?</p>
</td></tr>
<tr><td><code id="simsij_+3A_...">...</code></td>
<td>
<p>Any other optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a regularly-spaced vector on the unit interval of length <span class="env">length</span>, and uses these values to create corresponding values using the proportion function.  These values are then used as binomial probabilities to sample &quot;observed&quot; binomial random variables.  The observation vector is then denoised using a wavelet transform defined by the arguments <span class="env">van</span>, <span class="env">fam</span>, <span class="env">min.level</span> with thresholding method <span class="env">meth</span>.  This denoising is done for both Anscombe and the Haar-Fisz method for binomial random variables.  The procedure is repeated <span class="env">times</span> times, and the resulting proportion estimates averaged.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>regular grid on which the proportion function is evaluated.</p>
</td></tr>
<tr><td><code>truep</code></td>
<td>
<p>vector corresponding to <span class="env">x</span> of proportion function values.</p>
</td></tr>
<tr><td><code>ans</code></td>
<td>
<p>matrix containing the errors from each of the <span class="env">nsims</span> <span class="env">doall</span> runs.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>Array containing the <span class="env">nsims</span> estimates produced by Anscombe and Haar-Fisz.</p>
</td></tr>
<tr><td><code>bin</code></td>
<td>
<p>Matrix of the raw binomial samples for each of the <span class="env">nsims</span> runs.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+hfdenoise">hfdenoise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
a&lt;-simsij(nsims=100)

plot(a$est[1,,1])


##^^ shows 1st binomial Haar-Fisz estimate.

## End(Not run)
</code></pre>

<hr>
<h2 id='statgen'>Statistics generator</h2><span id='topic+statgen'></span>

<h3>Description</h3>

<p>This function generates useful simulation statistics for NN and Anscombe transforms. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statgen(valuelist, xgrid = seq(0, 1, length = 21), ygrid = seq(0, 1, length = 21), 
binsize = 32, plot.m = FALSE, plot.v = FALSE, plot.ks = FALSE, ptype = "persp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statgen_+3A_valuelist">valuelist</code></td>
<td>
<p>a two component list as produced by <span class="env">afgen</span>.</p>
</td></tr>
<tr><td><code id="statgen_+3A_xgrid">xgrid</code></td>
<td>
<p>a vector of x coordinate binomial proportions.</p>
</td></tr>
<tr><td><code id="statgen_+3A_ygrid">ygrid</code></td>
<td>
<p>a vector of x coordinate binomial proportions.</p>
</td></tr>
<tr><td><code id="statgen_+3A_binsize">binsize</code></td>
<td>
<p>binomial size to use in simulations.</p>
</td></tr>
<tr><td><code id="statgen_+3A_plot.m">plot.m</code></td>
<td>
<p>A boolean variable, indicating whether mean simulation plots should be outputted.</p>
</td></tr>
<tr><td><code id="statgen_+3A_plot.v">plot.v</code></td>
<td>
<p>A boolean variable, indicating whether variance simulation plots should be outputted.</p>
</td></tr>
<tr><td><code id="statgen_+3A_plot.ks">plot.ks</code></td>
<td>
<p>A boolean variable, indicating whether Kolmogorov-Smirnov simulation plots should be outputted.</p>
</td></tr>
<tr><td><code id="statgen_+3A_ptype">ptype</code></td>
<td>
<p>where appropriate, the type of plots to be produced.  Possible values are &quot;persp&quot; for 3D persective plots or &quot;contour&quot; for corresponding contour plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function does several sample variance plots, Kolmogorov-Smirnov and mean plots for the data in the variable <span class="env">valuelist</span> 
(for both Anscombe and binomial Haar-Fisz transforms).</p>


<h3>Value</h3>

<table>
<tr><td><code>afm</code></td>
<td>
<p>matrix of sample mean values for binomial Haar-Fisz samples.</p>
</td></tr>
<tr><td><code>anm</code></td>
<td>
<p>matrix of sample mean values for Anscombe samples.</p>
</td></tr>
<tr><td><code>afv</code></td>
<td>
<p>matrix of sample variance values for binomial Haar-Fisz samples.</p>
</td></tr>
<tr><td><code>anv</code></td>
<td>
<p>matrix of sample variance values for Anscombe samples.</p>
</td></tr>
<tr><td><code>afk</code></td>
<td>
<p>matrix of Kolmogorov-Smirnof statistics for binomial Haar-Fisz samples.</p>
</td></tr>
<tr><td><code>ank</code></td>
<td>
<p>matrix of Kolmogorov-Smirnof statistics for Anscombe samples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes (<a href="mailto:m.nunes@ucl.ac.uk">m.nunes@ucl.ac.uk</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+afgen">afgen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-afgen(xgrid = seq(0, 1, length = 21), ygrid = seq(0, 1, length = 21), 
samples = 1000, binsize = 32)

b&lt;-statgen(a,xgrid=seq(0,1,length=21),ygrid=seq(0,1,length=21),binsize=32,plot.m=FALSE,
plot.v=TRUE,plot.ks=FALSE,ptype="persp")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
