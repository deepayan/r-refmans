<!DOCTYPE html><html><head><title>Help for package scModels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scModels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chf_1F1'><p>Kummer's (confluent hypergeometric) function in log-scale</p></a></li>
<li><a href='#fit_params'><p>Functions to estimate parameters of probability distributions by fitting the distributions using optim()</p></a></li>
<li><a href='#gmRNA'><p>Gillespie algorithm for mRNA generating processes</p></a></li>
<li><a href='#Inverse+20Gaussian'><p>Inverse Gaussian Distribution</p></a></li>
<li><a href='#nlogL'><p>Negative log Likelihood functions for Poisson, negative binomial,</p>
Delaporte, Poisson-inverse Gaussian and Poisson-beta distributions</a></li>
<li><a href='#Poisson-beta'><p>Poisson-beta Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fitting Discrete Distribution Models to Count Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>DateNote:</td>
<td>Previous CRAN version 1.0.3 on 2022-03-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lisa Amrhein &lt;amrheinlisa@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for fitting discrete distribution models to count data.
  Included are the Poisson, the negative binomial, the Poisson-inverse gaussian and, most importantly,
  a new implementation of the Poisson-beta distribution (density, distribution and quantile
  functions, and random number generator) together with a needed new implementation of
  Kummer's function (also: confluent hypergeometric function of the first kind). Three
  different implementations of the Gillespie algorithm allow data simulation based on the
  basic, switching or bursting mRNA generating processes. Moreover, likelihood functions for
  four variants of each of the three aforementioned distributions are also available.
  The variants include one population and two population mixtures, both with and without
  zero-inflation. The package depends on the 'MPFR' libraries (<a href="https://www.mpfr.org/">https://www.mpfr.org/</a>) which need to be installed separately 
  (see description at <a href="https://github.com/fuchslab/scModels">https://github.com/fuchslab/scModels</a>).
  This package is supplement to the paper "A mechanistic model for the negative binomial distribution of single-cell mRNA counts" 
  by Lisa Amrhein, Kumar Harsha and Christiane Fuchs (2019) &lt;<a href="https://doi.org/10.1101%2F657619">doi:10.1101/657619</a>&gt; available on bioRxiv.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, gamlss.dist</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gmp (&gt;= 4.2.3), mpfr (&gt;= 3.0.0)</td>
</tr>
<tr>
<td>SystemRequirementsNote:</td>
<td>'MPFR' (MP Floating-Point Reliable Library,
&lt;http://mpfr.org/&gt;) and 'GMP' (GNU Multiple Precision
library,&lt;http://gmplib.org/&gt;)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-23 21:12:52 UTC; lisa.amrhein</td>
</tr>
<tr>
<td>Author:</td>
<td>Lisa Amrhein <a href="https://orcid.org/0000-0002-0370-624X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kumar Harsha <a href="https://orcid.org/0000-0002-3865-5286"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Christiane Fuchs <a href="https://orcid.org/0000-0003-3565-8315"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Pavel Holoborodko [ctb] (Author and copyright holder of 'mpreal.h')</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-24 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chf_1F1'>Kummer's (confluent hypergeometric) function in log-scale</h2><span id='topic+chf_1F1'></span>

<h3>Description</h3>

<p>Kummer's function (also: confluent hypergeometric function of the first kind)
for numeric (non-complex) values and input parameters in log-scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chf_1F1(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chf_1F1_+3A_x">x</code></td>
<td>
<p>numeric value or vector</p>
</td></tr>
<tr><td><code id="chf_1F1_+3A_a">a</code>, <code id="chf_1F1_+3A_b">b</code></td>
<td>
<p>numeric parameters of the Kummer function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the output is in log-scale. So the evaluated function is:
</p>
<p style="text-align: center;"><code class="reqn">\log \left[\sum_{n=0}^\infty \frac{a^{(n)} x^n}{ b^(n) n!}\right]</code>
</p>

<p>where <code class="reqn">a^{(n)}</code> and <code class="reqn">b^{(n)}</code> describe the rising factorial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- chf_1F1(-100:100, 5, 7)
plot(-100:100, x, type='l')
</code></pre>

<hr>
<h2 id='fit_params'>Functions to estimate parameters of probability distributions by fitting the distributions using optim()</h2><span id='topic+fit_params'></span>

<h3>Description</h3>

<p>Functions to estimate parameters of probability distributions by fitting the distributions using optim()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_params(x, type, optim_control = list(maxit = 1000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_params_+3A_x">x</code></td>
<td>
<p>Vector containing the discrete observations</p>
</td></tr>
<tr><td><code id="fit_params_+3A_type">type</code></td>
<td>
<p>Keyword for the probability distribution the data is to be fitted
against. Possible values are (&quot;pois&quot;, &quot;nb&quot;, &quot;del&quot;, pig&quot;, &quot;pb&quot;, &quot;pois2&quot;, &quot;nb2&quot;, &quot;del2&quot;, &quot;pig2&quot;
&quot;pb2&quot;, &quot;zipois&quot;, &quot;zinb&quot;, &quot;zidel&quot;, &quot;zipg&quot;, zipb&quot;, &quot;zipois2&quot;, &quot;zinb2&quot;, &quot;zidel2&quot;, &quot;zipig2&quot;, zipb2&quot;)</p>
</td></tr>
<tr><td><code id="fit_params_+3A_optim_control">optim_control</code></td>
<td>
<p>List of options to override presets in
the optim function; Set to list(maxit = 1000) by default.
For more details, please refer to the 'control' parameter in the
standard 'optim' function in package 'stats'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rnbinom(100, size = 13, mu = 9)
p1 &lt;- fit_params(x1, "nb")
s &lt;- sample(x = c(0,1), size = 100, replace = TRUE, prob = c(0.3,0.7))
x2 &lt;- s*x1 + (1-s) * rnbinom(100, size = 15, mu = 53)
p2 &lt;- fit_params(x2, "nb2")
</code></pre>

<hr>
<h2 id='gmRNA'>Gillespie algorithm for mRNA generating processes</h2><span id='topic+gmRNA'></span><span id='topic+gmRNA_basic'></span><span id='topic+gmRNA_switch'></span><span id='topic+gmRNA_burst'></span><span id='topic+gmRNA_basic_burst'></span><span id='topic+gmRNA_IGbasic_burst'></span>

<h3>Description</h3>

<p>Gillespie algorithms allow synthetic data simulation via three different
underlying mRNA generating processes: the basic process consists of a
simple death-birth model of mRNA transcription and degradation; the
switching process considers additionally gene activation and deactivation,
with mRNA transcription only happening in active gene states; the
bursting process, transcribes mRNA in bursts with geometrically distributed burst sizes.
The basic_burst model combines both the basic and the burst model.
The IGbasic burst model describes the basic model with non-constant transcription rates, but
transcription rates follow an inverse Gaussian distribution governed by one parameter, the mean parameter
of the inverse Gaussian distribution. Additionally a burst transcription occures (with NB distributed
burst sizes), the whole burst (rate and burst sizes) are determined by the rate parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmRNA_basic(n, r.on, r.degr)

gmRNA_switch(n, r.act, r.deact, r.on, r.degr)

gmRNA_burst(n, r.burst, s.burst, r.degr)

gmRNA_basic_burst(n, r.on, r.burst, s.burst, r.degr)

gmRNA_IGbasic_burst(n, r.mu, r.burst, r.degr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmRNA_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="gmRNA_+3A_r.on">r.on</code></td>
<td>
<p>Transcription rate during gene activation (Switching model)</p>
</td></tr>
<tr><td><code id="gmRNA_+3A_r.degr">r.degr</code></td>
<td>
<p>mRNA degradation rate (all models)</p>
</td></tr>
<tr><td><code id="gmRNA_+3A_r.act">r.act</code></td>
<td>
<p>DNA activation rate (Switching Model)</p>
</td></tr>
<tr><td><code id="gmRNA_+3A_r.deact">r.deact</code></td>
<td>
<p>DNA deactivation rate (Switching Model)</p>
</td></tr>
<tr><td><code id="gmRNA_+3A_r.burst">r.burst</code></td>
<td>
<p>Bursty transcription rate (Bursting model, Basic Burst model and IG Basic Burst model)</p>
</td></tr>
<tr><td><code id="gmRNA_+3A_s.burst">s.burst</code></td>
<td>
<p>Mean burst size (Bursting Model and  Basic Burst model)</p>
</td></tr>
<tr><td><code id="gmRNA_+3A_r.mu">r.mu</code></td>
<td>
<p>Mean parameter for the inverse Gaussian distribution (IG Basic Burst model)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- gmRNA_basic(100, 0.75, 0.001)
plot(density(x))
x &lt;- gmRNA_switch(100, 0.23, 0.15, 0.75, 0.001)
plot(density(x))
x &lt;- gmRNA_burst(10, 0.15, 0.75, 0.001)
plot(density(x))
x &lt;- gmRNA_basic_burst(10, 0.75, 0.15, 0.5, 0.001)
plot(density(x))
x &lt;- gmRNA_IGbasic_burst(10, 2, 0.5, 0.1)
plot(density(x))
</code></pre>

<hr>
<h2 id='Inverse+20Gaussian'>Inverse Gaussian Distribution</h2><span id='topic+Inverse+20Gaussian'></span><span id='topic+rInvGaus'></span>

<h3>Description</h3>

<p>random generation function for the inverse Gaussian distribution:
Mu and lambda are the parameters of this distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rInvGaus(n, mu, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inverse+2B20Gaussian_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="Inverse+2B20Gaussian_+3A_mu">mu</code>, <code id="Inverse+2B20Gaussian_+3A_lambda">lambda</code></td>
<td>
<p>Non-negative parameters of the inverse Gaussian distribution (mean and shape)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> RV &lt;- rInvGaus(n = 100, mu = 10, lambda = 2)
</code></pre>

<hr>
<h2 id='nlogL'>Negative log Likelihood functions for Poisson, negative binomial,
Delaporte, Poisson-inverse Gaussian and Poisson-beta distributions</h2><span id='topic+nlogL'></span><span id='topic+nlogL_pois'></span><span id='topic+nlogL_nb'></span><span id='topic+nlogL_del'></span><span id='topic+nlogL_pig'></span><span id='topic+nlogL_pb'></span><span id='topic+nlogL_pois2'></span><span id='topic+nlogL_nb2'></span><span id='topic+nlogL_del2'></span><span id='topic+nlogL_pig2'></span><span id='topic+nlogL_pb2'></span><span id='topic+nlogL_zipois'></span><span id='topic+nlogL_zinb'></span><span id='topic+nlogL_zidel'></span><span id='topic+nlogL_zipig'></span><span id='topic+nlogL_zipb'></span><span id='topic+nlogL_zipois2'></span><span id='topic+nlogL_zinb2'></span><span id='topic+nlogL_zidel2'></span><span id='topic+nlogL_zipig2'></span><span id='topic+nlogL_zipb2'></span>

<h3>Description</h3>

<p>The negative log Likelihood functions for Poisson, negative binomial,
Delaporte, Poisson-inverse Gaussian and Poisson-beta distributions.
Mixing two distributions of the same kind and/or adding zero-inflation
allows to take characteristics of real data into account.
Additionally, one population and two population mixtures - with and
without zero-inflation - allow distribution fitting of the Poisson,
negative binomial, Delaporte, Poisson-inverse Gaussian and the
Poisson-beta distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlogL_pois(data, par.pois)

nlogL_nb(data, par.nb)

nlogL_del(data, par.del)

nlogL_pig(data, par.pig)

nlogL_pb(data, par.pb)

nlogL_pois2(data, par.pois2)

nlogL_nb2(data, par.nb2)

nlogL_del2(data, par.del2)

nlogL_pig2(data, par.pig2)

nlogL_pb2(data, par.pb2)

nlogL_zipois(data, par.zipois)

nlogL_zinb(data, par.zinb)

nlogL_zidel(data, par.zidel)

nlogL_zipig(data, par.zipig)

nlogL_zipb(data, par.zipb)

nlogL_zipois2(data, par.zipois2)

nlogL_zinb2(data, par.zinb2)

nlogL_zidel2(data, par.zidel2)

nlogL_zipig2(data, par.zipig2)

nlogL_zipb2(data, par.zipb2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlogL_+3A_data">data</code></td>
<td>
<p>Vector containing the discrete observations</p>
</td></tr>
<tr><td><code id="nlogL_+3A_par.pois">par.pois</code></td>
<td>
<p>Scalar containing the lambda parameter
of the Poisson distribution</p>
</td></tr>
<tr><td><code id="nlogL_+3A_par.nb">par.nb</code></td>
<td>
<p>Vector of length 2, containing the size and the mu
parameter of the negative binomial distribution</p>
</td></tr>
<tr><td><code id="nlogL_+3A_par.del">par.del</code></td>
<td>
<p>Vector of length 3, containing the mu, sigma and the nu
parameter of the Delaporte distribution</p>
</td></tr>
<tr><td><code id="nlogL_+3A_par.pig">par.pig</code></td>
<td>
<p>Vector of length 2, containing the mu and the sigma
parameter of the Poisson-inverse Gaussian distribution</p>
</td></tr>
<tr><td><code id="nlogL_+3A_par.pb">par.pb</code></td>
<td>
<p>Vector of length 3, containing the alpha, beta
and c parameter of the Poisson-beta distribution</p>
</td></tr>
<tr><td><code id="nlogL_+3A_par.pois2">par.pois2</code>, <code id="nlogL_+3A_par.nb2">par.nb2</code>, <code id="nlogL_+3A_par.del2">par.del2</code>, <code id="nlogL_+3A_par.pig2">par.pig2</code>, <code id="nlogL_+3A_par.pb2">par.pb2</code></td>
<td>
<p>Vector containing the parameters
of the two mixing distributions. First entry represents the
fraction of the first distribution, followed by all parameters
of the first, then all of the second distribution.</p>
</td></tr>
<tr><td><code id="nlogL_+3A_par.zipois">par.zipois</code>, <code id="nlogL_+3A_par.zinb">par.zinb</code>, <code id="nlogL_+3A_par.zidel">par.zidel</code>, <code id="nlogL_+3A_par.zipig">par.zipig</code>, <code id="nlogL_+3A_par.zipb">par.zipb</code></td>
<td>
<p>Vector containing the respective
zero-inflated distribution parameters. The additional first
entry is the inflation parameter for all cases.</p>
</td></tr>
<tr><td><code id="nlogL_+3A_par.zipois2">par.zipois2</code>, <code id="nlogL_+3A_par.zinb2">par.zinb2</code>, <code id="nlogL_+3A_par.zidel2">par.zidel2</code>, <code id="nlogL_+3A_par.zipig2">par.zipig2</code>, <code id="nlogL_+3A_par.zipb2">par.zipb2</code></td>
<td>
<p>Parameters for the zero-inflated
two population model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions nlogL_pois, nlogL_nb, nlogL_del, nlogL_pig, nlogL_pb compute the negative
log-likelihood of Poisson, negative binomial, Poisson-inverse Gaussian and
the Poisson-beta distributions given the data.
Functions nlogL_pois2, nlogL_nb2, nlogL_del2, nlogL_pig2 and nlogL_pb2 compute the negative
log-likelihood values for a two population mixture of distributions whereas
nlogL_zipois, nlogL_zinb, nlogL_zidel, nlogL_zipig, nlogL_zipb compute the same for the
zero-inflated distributions. Furthermore, nlogL_zipois2, nlogL_zinb2, nlogL_zidel2,
nlogL_zipig2 and nlogL_zipb2 are for two population mixtures with zero-inflation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rpois(100, 11)
nl1 &lt;- nlogL_pois(x, 11)
nl2 &lt;- nlogL_pois(x, 13)
x &lt;- rnbinom(100, size = 13, mu = 9)
nl &lt;- nlogL_nb(x, c(13, 9))
x &lt;- gamlss.dist::rDEL(100, mu = 5, sigma = 0.2, nu= 0.5)
nl &lt;- nlogL_del(x, c(5, 0.2, 0.5))
x &lt;- gamlss.dist::rPIG(100, mu = 5, sigma = 0.2)
nl &lt;- nlogL_pig(x, c(5, 0.2))
x &lt;- rpb(n = 1000, alpha=5, beta= 3, c=20)
nl &lt;- nlogL_pb(x, c(5, 3, 20))
s &lt;- sample(x = c(0,1), size = 100, replace = TRUE, prob = c(0.3,0.7))
x &lt;- s*rpois(100, 7) + (1-s)*rpois(100, 13)
nl &lt;- nlogL_pois2(x, c(0.3, 13, 7))
s &lt;- sample(x = c(0,1), size = 100, replace = TRUE, prob = c(0.3,0.7))
x &lt;- s*rnbinom(100, size = 13, mu = 9) + (1-s)*rnbinom(100, size = 17, mu = 29)
nl &lt;- nlogL_nb2(x, c(0.3, 17, 29, 13, 9))
s &lt;- sample(x = c(0,1), size = 100, replace = TRUE, prob = c(0.3,0.7))
x &lt;- s * gamlss.dist::rDEL(100, mu = 5, sigma = 0.2, nu = 0.5) +
     (1 - s) * gamlss.dist::rDEL(100, mu = 20, sigma = 2, nu = 0.1)
nl &lt;- nlogL_del2(x, c(0.7,5, 0.2, 20, 2))
s &lt;- sample(x = c(0,1), size = 100, replace = TRUE, prob = c(0.3,0.7))
x &lt;- s * gamlss.dist::rPIG(100, mu = 5, sigma = 0.2) +
     (1 - s) * gamlss.dist::rPIG(100, mu = 20, sigma = 2)
nl &lt;- nlogL_pig2(x, c(0.7, 5, 0.2, 20, 2))
s &lt;- sample(x = c(0,1), size = 100, replace = TRUE, prob = c(0.3,0.7))
x &lt;- s*rpb(100, 5, 3, 20) + (1-s)*rpb(100, 7, 13, 53)
nl &lt;- nlogL_pb2(x, c(0.7, 7, 13, 53, 5, 3, 20))
x &lt;- c(rep(0, 10), rpois(90, 7))
nl &lt;- nlogL_zipois(x, c(0.1, 7))
x &lt;- c(rep(0,10), rnbinom(90, size = 13, mu = 9))
nl &lt;- nlogL_zinb(x, c(0.1, 13, 9))
x &lt;- c(rep(0,10), gamlss.dist::rDEL(90, mu = 13, sigma = 2, nu = 0.5))
nl &lt;- nlogL_zidel(x, c(0.1, 13, 2, 0.5))
x &lt;- c(rep(0,10), gamlss.dist::rPIG(90, mu = 13, sigma = 2))
nl &lt;- nlogL_zipig(x, c(0.1, 13, 2))
x &lt;- c(rep(0, 10), rpb(n = 90, alpha=5, beta= 3, c=20))
nl &lt;- nlogL_zipb(x, c(0.1, 5, 3, 20))
s &lt;- sample(x = c(0, 1), size = 90, replace = TRUE, prob = c(0.3, 0.7))
x &lt;- c(rep(0, 10), s * rpois(90, 7) + (1 - s) * rpois(90, 13))
nl1 &lt;- nlogL_zipois2(x, c(0.1, 0.63, 7, 13))
s &lt;- sample(x = c(0, 1), size = 90, replace = TRUE, prob = c(0.3, 0.7))
x &lt;- c(rep(0, 10), s * rnbinom(90, size = 13, mu = 9) + (1 - s) * rnbinom(90, size = 17, mu = 29))
nl &lt;- nlogL_zinb2(x, c(0.1, 0.63, 13, 9, 17, 29))
s &lt;- sample(x = c(0, 1), size = 90, replace = TRUE, prob = c(0.3, 0.7))
x &lt;- c(rep(0, 10), s * gamlss.dist::rDEL(90, mu = 13, sigma = 9, nu = 0.5) +
             (1 - s) * gamlss.dist::rDEL(90, mu = 17, sigma = 29, nu = 0.1))
nl &lt;- nlogL_zidel2(x, c(0.1, 0.63, 13, 9, 0.5, 17, 29, 0.1))
s &lt;- sample(x = c(0,1), size = 90, replace = TRUE, prob = c(0.3, 0.7))
x &lt;- c(rep(0, 10), s * gamlss.dist::rPIG(90, mu = 13, sigma = 0.2) +
               (1-s) * gamlss.dist::rPIG(90, mu = 17, sigma = 2))
nl &lt;- nlogL_zipig2(x, c(0.1, 0.63, 13, 0.2, 17, 2))
s &lt;- sample(x = c(0,1), size = 90, replace = TRUE, prob = c(0.3,0.7))
x &lt;- c(rep(0,10), s*rpb(90, 5, 3, 20) + (1-s)*rpb(90, 7, 13, 53))
nl &lt;- nlogL_zipb2(x, c(0.1, 0.63, 7, 13, 53, 5, 3, 20))
</code></pre>

<hr>
<h2 id='Poisson-beta'>Poisson-beta Distribution</h2><span id='topic+Poisson-beta'></span><span id='topic+dpb'></span><span id='topic+ppb'></span><span id='topic+qpb'></span><span id='topic+rpb'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the
Poisson-beta distribution: a Poisson distribution whose parameter itself follows
a beta distribution. Alpha and beta are the parameters of this specific beta
distribution which is scaled on (0, c) in contrast to the usual scaling of the
standard beta distribution on (0,1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpb(x, alpha, beta, c = 1, log = FALSE)

ppb(q, alpha, beta, c = 1, lower.tail = TRUE, log.p = FALSE)

qpb(p, alpha, beta, c = 1, lower.tail = TRUE, log.p = FALSE)

rpb(n, alpha, beta, c = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Poisson-beta_+3A_x">x</code>, <code id="Poisson-beta_+3A_q">q</code></td>
<td>
<p>Vector of (non-negative integer) quantiles</p>
</td></tr>
<tr><td><code id="Poisson-beta_+3A_alpha">alpha</code>, <code id="Poisson-beta_+3A_beta">beta</code></td>
<td>
<p>Non-negative parameters of the beta distribution (shape1 and shape2)</p>
</td></tr>
<tr><td><code id="Poisson-beta_+3A_c">c</code></td>
<td>
<p>Numeric scaling parameter of the beta distribution. The standard beta is
scaled on (0,1) (default) and can be transformed to (0,c).</p>
</td></tr>
<tr><td><code id="Poisson-beta_+3A_log">log</code>, <code id="Poisson-beta_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p)</p>
</td></tr>
<tr><td><code id="Poisson-beta_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Poisson-beta_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
<tr><td><code id="Poisson-beta_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- dpb(x=0:200, alpha=5, beta=3, c=20)
 plot(0:200, X, type='l')
 Y &lt;- dpb(0:10, seq(10.0,11.0,by=0.1), seq(30.0,31.0,by=0.1), seq(10.2,11.2,by=0.1))
 Y &lt;- ppb(q= 0 :200, alpha=5, beta= 3, c=20)
 plot(0:200, Y, type="l")
 Z &lt;- qpb(p= seq(0,1, by= 0.01), alpha=5, beta= 3, c=20)
 plot(seq(0,1, by= 0.01),Z, type="l")
 RV &lt;- rpb(n = 1000, alpha=5, beta= 3, c=20)
 plot(0 : 200, X, type="l")
 lines(density(RV), col="red")
 R2 &lt;- rpb(11, seq(10.0,11.0,by=0.1), seq(30.0,31.0,by=0.1), seq(10.2,11.2,by=0.1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
