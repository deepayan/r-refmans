<!DOCTYPE html><html><head><title>Help for package penAFT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {penAFT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#penAFT-package'><p>Fit and tune the a semiparameteric accelerated failure time model with weight elastic net or weighted sparse group-lasso penalties.</p></a></li>
<li><a href='#genSurvData'><p>Generate a survival dataset from the log-logistic accelerated failure time model.</p></a></li>
<li><a href='#penAFT'><p>Fit the solution path for the regularized semiparametric accelerated failure time model with weighted elastic net or weighted sparse group lasso penalties.</p></a></li>
<li><a href='#penAFT.coef'><p>Extract regression coefficients from fitted model object</p></a></li>
<li><a href='#penAFT.cv'><p>Cross-validation function for fitting a regularized semiparametric accelerated failure time model</p></a></li>
<li><a href='#penAFT.plot'><p>Plot cross-validation curves</p></a></li>
<li><a href='#penAFT.predict'><p>Obtain linear predictor for new subjects using fitted model from <code>penAFT</code> or <code>penAFT.cv</code></p></a></li>
<li><a href='#penAFT.trace'><p>Print trace plot for the regularized Gehan estimator fit using <code>penAFT</code> or <code>penAFT.cv</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit the Regularized Gehan Estimator with Elastic Net and Sparse
Group Lasso Penalties</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The semiparametric accelerated failure time (AFT) model is an attractive alternative to the Cox proportional hazards model. This package provides a suite of functions for fitting one popular estimator of the semiparametric AFT model, the regularized Gehan estimator. Specifically, we provide functions for cross-validation, prediction, coefficient extraction, and visualizing both trace plots and cross-validation curves. For further details, please see Suder, P. M. and Molstad, A. J., (2022+) Scalable algorithms for semiparametric accelerated failure time models in high dimensions, to appear in Statistics in Medicine &lt;<a href="https://doi.org/10.1002%2Fsim.9264">doi:10.1002/sim.9264</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td>ajmolstad.github.io/research</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Matrix, ggplot2, irlba</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-18 02:44:04 UTC; aaron</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron J. Molstad <a href="https://orcid.org/0000-0003-0645-5105"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Piotr M. Suder [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron J. Molstad &lt;amolstad@ufl.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-18 03:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='penAFT-package'>Fit and tune the a semiparameteric accelerated failure time model with weight elastic net or weighted sparse group-lasso penalties.</h2><span id='topic+penAFT-package'></span>

<h3>Description</h3>

<p>This package contains numerous functions related to the penalized Gehan estimator. In particular, the main functions are for solution path computation, cross-validation, prediction, and coefficient extraction. 
</p>


<h3>Details</h3>

<p>The primary functions are <code>penAFT</code> and <code>penAFT.cv</code>, the latter of which performs cross-validation. In general, both functions fit the penalized Gehan estimator. Given <code class="reqn">(\log(y_1), x_1, \delta_1),\dots,(\log(y_n), x_n, \delta_n)</code> where <code class="reqn">y_i</code> is the minimum of the survival time and censoring time, <code class="reqn">x_i</code> is a <code class="reqn">p</code>-dimensional predictor, and <code class="reqn">\delta_i</code> is the indicator of censoring,  <code>penAFT</code> fits the solution path for the argument minimizing
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n^2}\sum_{i=1}^n \sum_{j=1}^n \delta_i \{ \log(y_i) - \log(y_j) - (x_i - x_j)'\beta \}^{-} + \lambda g(\beta)</code>
</p>

<p>where <code class="reqn">\{a \}^{-} := \max(-a, 0) </code>, <code class="reqn">\lambda &gt; 0</code>, and <code class="reqn">g</code> is either the weighted elastic net penalty or weighted sparse group lasso penalty. The weighted elastic net penalty is defined as 
</p>
<p style="text-align: center;"><code class="reqn">\alpha \| w \circ \beta\|_1 + \frac{(1-\alpha)}{2}\|\beta\|_2^2</code>
</p>

<p>where <code class="reqn">w</code> is a set of non-negative weights (which can be specified in the <code>weight.set</code> argument). The weighted sparse group-lasso penalty we consider is
</p>
<p style="text-align: center;"><code class="reqn">\alpha \| w \circ \beta\|_1 + (1-\alpha)\sum_{l=1}^G v_l\|\beta_{\mathcal{G}_l}\|_2</code>
</p>

<p>where again, <code class="reqn">w</code> is a set of non-negative weights and <code class="reqn">v_l</code> are weights applied to each of the <code class="reqn">G</code> (user-specified) groups. 
</p>
<p>For a comprehensive description of the algorithm, and more details about rank-based estimation in general, please refer to the referenced manuscript. 
</p>


<h3>Author(s)</h3>

<p>Aaron J. Molstad and Piotr M. Suder
Maintainer: Aaron J. Molstad &lt;amolstad@ufl.edu&gt;
</p>

<hr>
<h2 id='genSurvData'>Generate a survival dataset from the log-logistic accelerated failure time model.</h2><span id='topic+genSurvData'></span>

<h3>Description</h3>

<p>This is a function for generating synthetic datasets from the log-logistic accelerated failure time model. The purpose of this function is to provide structured data for the examples of the other functions' usage. </p>


<h3>Usage</h3>

<pre><code class='language-R'>genSurvData(n, p, s, mag, cens.quant = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSurvData_+3A_n">n</code></td>
<td>
<p>The numer of subjects to be included in the dataset.</p>
</td></tr>
<tr><td><code id="genSurvData_+3A_p">p</code></td>
<td>
<p>Dimension of the predictor. Note that the function computes the square-root of a <code class="reqn">p \times p</code> covariance matrix, so setting <code>p</code> large may be time-consuming.</p>
</td></tr>
<tr><td><code id="genSurvData_+3A_s">s</code></td>
<td>
<p>The number of nonzero regression coefficients in <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="genSurvData_+3A_mag">mag</code></td>
<td>
<p>The magnitude of the <code>s</code> nonzero regression coefficients. Signs of coefficients are assigned at random.</p>
</td></tr>
<tr><td><code id="genSurvData_+3A_cens.quant">cens.quant</code></td>
<td>
<p>The quantile of true survival times used to set the mean of the exponential distribution from which censoring times are drawn. Default is 0.6. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates predictors to follow a <code class="reqn">p</code>-dimensional multivariate normal distribution whose covariance has an AR(1) structure with lag 0.7. Then, log survival times are generated as
</p>
<p style="text-align: center;"><code class="reqn">\log(T) = X \beta + \epsilon</code>
</p>

<p>where <code class="reqn">\epsilon</code> has independent components drawn from a logistic distribution with location parmeter zero and scale parameter two. Then censoring times are drawn from an exponential distribution with mean equal to the quantile <code>cens.quant</code> of <code class="reqn">T</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>beta</code></td>
<td>
<p>The true data generating regression coefficient vector.</p>
</td></tr>
<tr><td><code>logY</code></td>
<td>
<p>The observed failure times or censoring times on the log scale. </p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>Indicator of censoring; a value of 1 indicates the corresponding component of logY is an observed log failure time and a value of 0 indicates a log censoring time. </p>
</td></tr>
<tr><td><code>Xn</code></td>
<td>
<p>The <code class="reqn">n \times p</code> matrix of predictors.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------------------
# Generate data  
# --------------------------------------
set.seed(1)
genData &lt;- penAFT::genSurvData(n = 50, p = 100, s = 10, mag = 1, cens.quant = 0.6)
X &lt;- genData$X
logY &lt;- genData$logY
delta &lt;- genData$status
str(X)
head(logY)
head(delta)
</code></pre>

<hr>
<h2 id='penAFT'>Fit the solution path for the regularized semiparametric accelerated failure time model with weighted elastic net or weighted sparse group lasso penalties.</h2><span id='topic+penAFT'></span>

<h3>Description</h3>

<p>A function to fit the solution path for the regularized semiparametric accelerated failure time model estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>penAFT(X, logY, delta, nlambda = 50, 
  lambda.ratio.min = 0.1, lambda = NULL, 
  penalty = NULL, alpha = 1, weight.set = NULL, 
  groups = NULL, tol.abs = 1e-8, tol.rel = 2.5e-4, 
  gamma = 0,  standardize = TRUE, 
  admm.max.iter = 1e4, quiet=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penAFT_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">n \times p</code> matrix of predictors. Observations should be organized by row.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_logy">logY</code></td>
<td>
<p>An <code class="reqn">n</code>-dimensional vector of log-survival or log-censoring times.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_delta">delta</code></td>
<td>
<p>An <code class="reqn">n</code>-dimensional binary vector indicating whether the <code class="reqn">j</code>th component of <code>logY</code> is an observed log-survival time (<code class="reqn">\delta_j = 1</code>) or a log-censoring time (<code class="reqn">\delta_j = 0</code>) for <code class="reqn">j=1, \dots, n</code>.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of candidate tuning parameters to consider.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_lambda.ratio.min">lambda.ratio.min</code></td>
<td>
<p>The ratio of maximum to minimum candidate tuning parameter value. As a default, we suggest 0.1, but standard model selection procedures should be applied to select <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_lambda">lambda</code></td>
<td>
<p>An optional (not recommended) prespecified vector of candidate tuning parameters. Should be in descending order. </p>
</td></tr>
<tr><td><code id="penAFT_+3A_penalty">penalty</code></td>
<td>
<p>Either &quot;EN&quot; or &quot;SG&quot; for elastic net or sparse group lasso penalties.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_alpha">alpha</code></td>
<td>
<p>The tuning parameter <code class="reqn">\alpha</code>. See documentation.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_weight.set">weight.set</code></td>
<td>
<p>A list of weights. For both penalties, <code class="reqn">w</code> is an <code class="reqn">n</code>-dimensional vector of nonnegative weights. For &quot;SG&quot; penalty, can also include <code class="reqn">v</code> &ndash; a non-negative vector the length of the number of groups. See documentation for usage example.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_groups">groups</code></td>
<td>
<p>When using penalty &quot;SG&quot;, a <code class="reqn">p</code>-dimensional vector of integers corresponding the to group assignment of each predictor (i.e., column of <code>X</code>).</p>
</td></tr>
<tr><td><code id="penAFT_+3A_tol.abs">tol.abs</code></td>
<td>
<p>Absolute convergence tolerance.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_tol.rel">tol.rel</code></td>
<td>
<p>Relative convergence tolerance.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_gamma">gamma</code></td>
<td>
<p>A non-negative optimization parameter which can improve convergence speed in certain settings. It is highly recommended to set equal to zero.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_standardize">standardize</code></td>
<td>
<p>Should predictors be standardized (i.e., column-wise average zero and scaled to have unit variance) for model fitting?</p>
</td></tr>
<tr><td><code id="penAFT_+3A_admm.max.iter">admm.max.iter</code></td>
<td>
<p>Maximum number of ADMM iterations.</p>
</td></tr>
<tr><td><code id="penAFT_+3A_quiet">quiet</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> variable indicating whether progress should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">(\log y_1, x_1, \delta_1),\dots,(\log y_n, x_n, \delta_n)</code> where <code class="reqn">y_i</code> is the minimum of the survival time and censoring time, <code class="reqn">x_i</code> is a <code class="reqn">p</code>-dimensional predictor, and <code class="reqn">\delta_i</code> is the indicator of censoring,  <code>penAFT</code> fits the solution path for the argument minimizing
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n^2}\sum_{i=1}^n \sum_{j=1}^n \delta_i \{ \log y_i - \log y_j - (x_i - x_j)'\beta \}^{-} + \lambda g(\beta)</code>
</p>

<p>where <code class="reqn">\{a \}^{-} := \max(-a, 0) </code>, <code class="reqn">\lambda &gt; 0</code>, and <code class="reqn">g</code> is either the weighted elastic net penalty (<code>penalty = "EN"</code>) or weighted sparse group lasso penalty (<code>penalty = "SG"</code>).
The weighted elastic net penalty is defined as 
</p>
<p style="text-align: center;"><code class="reqn">\alpha \| w \circ \beta\|_1 + \frac{(1-\alpha)}{2}\|\beta\|_2^2</code>
</p>

<p>where <code class="reqn">w</code> is a set of non-negative weights (which can be specified in the <code>weight.set</code> argument). The weighted sparse group-lasso penalty we consider is
</p>
<p style="text-align: center;"><code class="reqn">\alpha \| w \circ \beta\|_1 + (1-\alpha)\sum_{l=1}^G v_l\|\beta_{\mathcal{G}_l}\|_2</code>
</p>

<p>where again, <code class="reqn">w</code> is a set of non-negative weights and <code class="reqn">v_l</code> are weights applied to each of the <code class="reqn">G</code> groups. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>beta</code></td>
<td>
<p>A <code class="reqn">p \times</code> <code>nlambda</code> sparse matrix consisting of the estimates of <code class="reqn">\beta</code> for the candidate values of <code class="reqn">\lambda</code>. It is recommended to use <code>penAFT.coef</code> to extract coefficients.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The candidate tuning parameter values. </p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>Were predictors standardized to have unit variance for model fitting? </p>
</td></tr>
<tr><td><code>X.mean</code></td>
<td>
<p>The mean of the predictors.</p>
</td></tr>
<tr><td><code>X.sd</code></td>
<td>
<p>The standard deviation of the predictors.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The tuning parameter <code class="reqn">\alpha</code>. See documentation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------------------
# Generate data  
# --------------------------------------
set.seed(1)
genData &lt;- genSurvData(n = 50, p = 50, s = 10, mag = 2, cens.quant = 0.6)
X &lt;- genData$X
logY &lt;- genData$logY
delta &lt;- genData$status


# -----------------------------------------------
# Fit elastic net penalized estimator
# -----------------------------------------------
fit.en &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 50, lambda.ratio.min = 0.01,
                   penalty = "EN",
                   alpha = 1)
                   

coef.en.10 &lt;- penAFT.coef(fit.en, lambda = fit.en$lambda[10])


# ------------------------------------------------
# Fit weighted elastic net penalized estimator
# ------------------------------------------------
weight.set &lt;- list("w" = c(0, 0, rep(1, 48)))
fit.weighted.en &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 50, weight.set = weight.set,
                   penalty = "EN",
                   alpha = 1)
coef.wighted.en.10 &lt;- penAFT.coef(fit.weighted.en, lambda = fit.weighted.en$lambda[10])
                   
                   
# ------------------------------------------------
# Fit ridge penalized estimator with user-specified lambda
# ------------------------------------------------
fit.ridge &lt;- penAFT(X = X, logY = logY, delta = delta,
                   lambda = 10^seq(-4, 4, length=50), 
                   penalty = "EN",
                   alpha = 0)
                   
                   
# -----------------------------------------------
# Fit sparse group penalized estimator
# -----------------------------------------------
groups &lt;- rep(1:5, each = 10)
fit.sg &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 50, lambda.ratio.min = 0.01,
                   penalty = "SG", groups = groups, 
                   alpha = 0.5)
                   
# -----------------------------------------------
# Fit weighted sparse group penalized estimator
# -----------------------------------------------
groups &lt;- rep(1:5, each = 10)
weight.set &lt;- list("w" = c(0, 0, rep(1, 48)), 
      "v" = 1:5)
fit.weighted.sg &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 100, 
                   weight.set = weight.set,
                   penalty = "SG", groups = groups, 
                   alpha = 0.5)

coef.weighted.sg.20 &lt;- penAFT.coef(fit.weighted.sg, lambda = fit.weighted.sg$lambda[20])

</code></pre>

<hr>
<h2 id='penAFT.coef'>Extract regression coefficients from fitted model object</h2><span id='topic+penAFT.coef'></span>

<h3>Description</h3>

<p>A function to extract coefficients along the solution path for the regularized semiparametric acceleratred failure time model estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>penAFT.coef(fit, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penAFT.coef_+3A_fit">fit</code></td>
<td>
<p>A fitted model from <code>penAFT</code> or <code>penAFT.cv</code>.</p>
</td></tr>
<tr><td><code id="penAFT.coef_+3A_lambda">lambda</code></td>
<td>
<p>The tuning parameter value at which to extract coefficients. If <code>NULL</code> and <code>fit</code> is a <code>penAFT.cv</code> object, will use the tuning parameter value with minimum cross-validation linear predictor score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regression coefficients stored in the fitted model objects coming from <code>penAFT</code> or <code>penAFT.cv</code> will (i) be on the scale of standardized predictors if standardization was used (which is the default) and (ii) are stored as a specific sparse matrix so that coefficient extraction is cumbersome. This function returns the regression coefficient estimates on the original scale of the predictors for a particular tuning parmaeter value. It is important to note that this method does not return an estimate of the intercept: the intercept is absored into the error term as the Gehan loss function is invariant to location change. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>beta</code></td>
<td>
<p>The coefficient estimates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------------------
# Generate data  
# --------------------------------------
set.seed(1)
genData &lt;- genSurvData(n = 100, p = 50, s = 10, mag = 1, cens.quant = 0.6)
X &lt;- genData$X
logY &lt;- genData$logY
delta &lt;- genData$status


# --------------------------------------
# Fit elastic net penalized estimator without CV
# --------------------------------------
fit &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 50,
                   penalty = "EN",
                   alpha = 1)

coef.10 &lt;- penAFT.coef(fit, lambda = fit$lambda[10])
coef.20 &lt;- penAFT.coef(fit, lambda = fit$lambda[20])

# Cannot obtain fit at lambda not in fit$lambda
## Not run: coef.error &lt;- penAFT.coef(fit, lambda = 10) # throws error


  # ------------------------------------------
  # Fit elastic net penalized estimator with CV
  # -------------------------------------------
  fit.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                   nlambda = 50,
                   penalty = "EN", 
                   alpha = 1, nfolds = 5)

  ## --- coefficients at lambda minimizing cross-validation error
  coef.cv &lt;- penAFT.coef(fit.cv) 

  ## ---- coefficients at 10th considered lambda 
  coef.cv10 &lt;- penAFT.coef(fit.cv, lambda = fit.cv$full.fit$lambda[10]) 

  # -------------------------------------------
  # Repeat with sparse group lasso without CV
  # -------------------------------------------
  groups &lt;- rep(1:10, each = 5)
  fit.sg &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 50, groups = groups,
                   penalty = "SG",
                   alpha = 0.5)

  coef.sg.10 &lt;- penAFT.coef(fit.sg, lambda = fit.sg$lambda[10])
  coef.sg.20 &lt;- penAFT.coef(fit.sg, lambda = fit.sg$lambda[20])


  # -------------------------------------------
  # Finally, fit sparse group lasso with CV
  # -------------------------------------------
  groups &lt;- rep(1:10, each = 5)
  fit.sg.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                   nlambda = 50, groups = groups,
                   penalty = "SG",
                   alpha = 0.5, nfolds = 5)

  coef.sg.cv &lt;- penAFT.coef(fit.sg.cv)
  coef.sg.cv10 &lt;- penAFT.coef(fit.sg.cv, lambda = fit.sg$full.fit$lambda[20])


</code></pre>

<hr>
<h2 id='penAFT.cv'>Cross-validation function for fitting a regularized semiparametric accelerated failure time model</h2><span id='topic+penAFT.cv'></span>

<h3>Description</h3>

<p>A function to perform cross-validation and compute the solution path for the regularized semiparametric accelerated failure time model estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>penAFT.cv(X, logY, delta, nlambda = 50, 
  lambda.ratio.min = 0.1, lambda = NULL, 
  penalty = NULL, alpha = 1,weight.set = NULL, 
  groups = NULL, tol.abs = 1e-8, tol.rel = 2.5e-4, 
  standardize = TRUE, nfolds = 5, cv.index = NULL, 
  admm.max.iter = 1e4,quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penAFT.cv_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">n \times p</code> matrix of predictors. Observations should be organized by row.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_logy">logY</code></td>
<td>
<p>An <code class="reqn">n</code>-dimensional vector of log-survival or log-censoring times.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_delta">delta</code></td>
<td>
<p>An <code class="reqn">n</code>-dimensional binary vector indicating whether the <code class="reqn">j</code>th component of <code>logY</code> is an observed log-survival time (<code class="reqn">\delta_j = 1</code>) or a log-censoring time (<code class="reqn">\delta_j = 0</code>) for <code class="reqn">j=1, \dots, n</code>.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of candidate tuning parameters to consider.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_lambda.ratio.min">lambda.ratio.min</code></td>
<td>
<p>The ratio of maximum to minimum candidate tuning parameter value. As a default, we suggest 0.1, but standard model selection procedures should be applied to select <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_lambda">lambda</code></td>
<td>
<p>An optional (not recommended) prespecified vector of candidate tuning parameters. Should be in descending order. </p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_penalty">penalty</code></td>
<td>
<p>Either &quot;EN&quot; or &quot;SG&quot; for elastic net or sparse group lasso penalties.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_alpha">alpha</code></td>
<td>
<p>The tuning parameter <code class="reqn">\alpha</code>. See documentation.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_weight.set">weight.set</code></td>
<td>
<p>A list of weights. For both penalties, <code class="reqn">w</code> is an <code class="reqn">n</code>-dimensional vector of nonnegative weights. For &quot;SG&quot; penalty, can also include <code class="reqn">v</code> &ndash; a non-negative vector the length of the number of groups. See documentation for usage example.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_groups">groups</code></td>
<td>
<p>When using penalty &quot;SG&quot;, a <code class="reqn">p</code>-dimensional vector of integers corresponding the to group assignment of each predictor (i.e., column of <code>X</code>).</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_tol.abs">tol.abs</code></td>
<td>
<p>Absolute convergence tolerance.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_tol.rel">tol.rel</code></td>
<td>
<p>Relative convergence tolerance.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_standardize">standardize</code></td>
<td>
<p>Should predictors be standardized (i.e., scaled to have unit variance) for model fitting?</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_nfolds">nfolds</code></td>
<td>
<p>The number of folds to be used for cross-validation. Default is five. Ten is recommended when sample size is especially small.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_cv.index">cv.index</code></td>
<td>
<p>A list of length <code>nfolds</code> of indices to be used for cross-validation. This is to be used if trying to perform cross-validation for both <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>. Use with extreme caution: this overwrites <code>nfolds</code>. </p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_admm.max.iter">admm.max.iter</code></td>
<td>
<p>Maximum number of ADMM iterations.</p>
</td></tr>
<tr><td><code id="penAFT.cv_+3A_quiet">quiet</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> variable indicating whether progress should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">(\log y_1 , x_1, \delta_1),\dots,(\log y_n , x_n, \delta_n)</code> where for subject <code class="reqn">i</code> (<code class="reqn">i = 1, \dots, n</code>), <code class="reqn">y_i</code> is the minimum of the survival time and censoring time, <code class="reqn">x_i</code> is a <code class="reqn">p</code>-dimensional predictor, and <code class="reqn">\delta_i</code> is the indicator of censoring,  <code>penAFT.cv</code> performs <code>nfolds</code> cross-validation for selecting the tuning parameter to be used in the argument minimizing
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n^2}\sum_{i=1}^n \sum_{j=1}^n \delta_i \{ \log y_i - \log y_j  - (x_i - x_j)'\beta \}^{-} + \lambda g(\beta)</code>
</p>

<p>where <code class="reqn">\{a \}^{-} := \max(-a, 0) </code>, <code class="reqn">\lambda &gt; 0</code>, and <code class="reqn">g</code> is either the weighted elastic net penalty (<code>penalty = "EN"</code>) or weighted sparse group lasso penalty (<code>penalty = "SG"</code>).
The weighted elastic net penalty is defined as 
</p>
<p style="text-align: center;"><code class="reqn">\alpha \| w \circ \beta\|_1 + \frac{(1-\alpha)}{2}\|\beta\|_2^2</code>
</p>

<p>where <code class="reqn">w</code> is a set of non-negative weights (which can be specified in the <code>weight.set</code> argument). The weighted sparse group-lasso penalty we consider is
</p>
<p style="text-align: center;"><code class="reqn">\alpha \| w \circ \beta\|_1 + (1-\alpha)\sum_{l=1}^G v_l\|\beta_{\mathcal{G}_l}\|_2</code>
</p>

<p>where again, <code class="reqn">w</code> is a set of non-negative weights and <code class="reqn">v_l</code> are weights applied to each of the <code class="reqn">G</code> groups. 
</p>
<p>Next, we define the cross-validation errors. 
Let <code class="reqn">\mathcal{V}_1, \dots, \mathcal{V}_K</code> be a random <code>nfolds</code> = <code class="reqn">K</code> element partition of <code class="reqn">[n]</code> (the subjects) with the cardinality of each <code class="reqn">\mathcal{V}_k</code> (the &quot;kth fold&quot;&quot;) approximately equal for <code class="reqn">k = 1, \dots, K</code>. 
Let <code class="reqn">{\hat{\beta}}_{\lambda(-\mathcal{V}_k)}</code> be the solution with tuning parameter <code class="reqn">\lambda</code> using only data indexed by <code class="reqn">[n] \setminus \{\mathcal{V}_k\}</code> (i.e., outside the kth fold). Then, definining <code class="reqn">e_i(\beta) := \log y_i - \beta'x_i</code> for <code class="reqn">i= 1, \dots, n</code>, we call 
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{k=1}^K \left[\frac{1}{|\mathcal{V}_k|^2}  \sum_{i \in \mathcal{V}_k} \sum_{j \in \mathcal{V}_k} \delta_i \{e_i({\hat{\beta}}_{\lambda(-\mathcal{V}_k)}) - e_{j}({\hat{\beta}}_{\lambda(-\mathcal{V}_k)})\}^{-}\right],
</code>
</p>

<p>the cross-validated Gehan loss at <code class="reqn">\lambda</code> in the <code class="reqn">k</code>th fold, and refer to the sum over all <code>nfolds</code> = <code class="reqn">K</code> folds as the cross-validated Gehan loss. 
Similarly, letting 
letting
</p>
<p style="text-align: center;"><code class="reqn">
\tilde{e}_i({\hat{\beta}}_\lambda) =  \sum_{k = 1}^K (\log y_i - x_i'{\hat{\beta}}_{\lambda(-\mathcal{V}_k)}) \mathbf{1}(i \in \mathcal{V}_k)</code>
</p>
<p> for each <code class="reqn">i \in [n]</code>,
we call 
</p>
<p style="text-align: center;"><code class="reqn">\left[\sum_{i = 1}^n \sum_{j = 1}^n \delta_i \{\tilde{e}_i({\hat{\beta}}_\lambda) - \tilde{e}_j({\hat{\beta}}_\lambda)\}^{-}\right]</code>
</p>

<p>the cross-validated linear predictor score at <code class="reqn">\lambda</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>full.fit</code></td>
<td>
<p>A model fit with the same output as a model fit using <code>penAFT</code>. See documentation for <code>penAFT</code> for more.</p>
</td></tr>
<tr><td><code>cv.err.linPred</code></td>
<td>
<p>A <code>nlambda</code>-dimensional vector of cross-validated linear predictor scores.</p>
</td></tr>
<tr><td><code>cv.err.obj</code></td>
<td>
<p>A <code>nfolds </code><code class="reqn">\times</code><code>nlambda</code> matrix of cross-valdiation Gehan losses.</p>
</td></tr>
<tr><td><code>cv.index</code></td>
<td>
<p>A list of length <code>nfolds</code>. Each element contains the indices for subjects belonging to that particular fold.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> # --------------------------------------
# Generate data  
# --------------------------------------
set.seed(1)
genData &lt;- genSurvData(n = 50, p = 50, s = 10, mag = 2,  cens.quant = 0.6)
X &lt;- genData$X
logY &lt;- genData$logY
delta &lt;- genData$status
p &lt;- dim(X)[2]

# -----------------------------------------------
# Fit elastic net penalized estimator
# -----------------------------------------------
fit.en &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                   nlambda = 10, lambda.ratio.min = 0.1,
                   penalty = "EN", nfolds = 5,
                   alpha = 1)
# ---- coefficients at tuning parameter minimizing cross-valdiation error
coef.en &lt;- penAFT.coef(fit.en)

# ---- predict at 8th tuning parameter from full fit
Xnew &lt;- matrix(rnorm(10*p), nrow=10)
predict.en &lt;- penAFT.predict(fit.en, Xnew = Xnew, lambda = fit.en$full.fit$lambda[8])


  # -----------------------------------------------
  # Fit sparse group penalized estimator
  # -----------------------------------------------
  groups &lt;- rep(1:5, each = 10)
  fit.sg &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                    nlambda = 50, lambda.ratio.min = 0.01,
                    penalty = "SG", groups = groups, nfolds = 5,
                    alpha = 0.5)
                     
  # -----------------------------------------------
  # Pass fold indices
  # -----------------------------------------------
  groups &lt;- rep(1:5, each = 10)
  cv.index &lt;- list()
  for(k in 1:5){
    cv.index[[k]] &lt;- which(rep(1:5, length=50) == k)
  }
  fit.sg.cvIndex &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                    nlambda = 50, lambda.ratio.min = 0.01,
                    penalty = "SG", groups = groups, 
                    cv.index = cv.index,
                    alpha = 0.5)
  # --- compare cv indices
  ## Not run: fit.sg.cvIndex$cv.index  == cv.index

</code></pre>

<hr>
<h2 id='penAFT.plot'>Plot cross-validation curves</h2><span id='topic+penAFT.plot'></span>

<h3>Description</h3>

<p>A function for plotting the cross-validation curves for the regularized semiparametric accelerated failure time model estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>penAFT.plot(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penAFT.plot_+3A_fit">fit</code></td>
<td>
<p>A fitted model from <code>penAFT.cv</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a plot with the cross-validation curves for the regularized Gehan estimator.  The vertical blue line indicates the tuning parameter which minimized cross-validated linear predictor scores and the vertical black line indicates the tuning parameter which minimized the cross-validated Gehan loss according to the one-standard-error rule. The vertical axis (and blue line) denotes the cross-validated linear predictor scores whereas the right vertical axis (and black line) denotes cross-validated Gehan loss and standard errors). To make matters simple, we do not allow for customization of the plot: please refer to the source code if extensive customization is desired. 
</p>


<h3>Value</h3>

<p>No return value; prints a plot of cross-validation curves as described in Details.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # --------------------------------------
  # Generate data  
  # --------------------------------------
  set.seed(1)
  genData &lt;- genSurvData(n = 50, p = 100, s = 10, mag = 2, cens.quant = 0.6)
  X &lt;- genData$X
  logY &lt;- genData$logY
  delta &lt;- genData$status
  
  
  # ------------------------------------------
  # Fit elastic net penalized estimator with CV
  # -------------------------------------------
  fit.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                    nlambda = 50,
                    penalty = "EN", tol.rel = 1e-5,
                    alpha = 1, nfolds = 10)
  penAFT.plot(fit.cv)


</code></pre>

<hr>
<h2 id='penAFT.predict'>Obtain linear predictor for new subjects using fitted model from <code>penAFT</code> or <code>penAFT.cv</code></h2><span id='topic+penAFT.predict'></span>

<h3>Description</h3>

<p>A function for prediction along the solution path of the regularized semiparametric accelerated failure time model estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>penAFT.predict(fit, Xnew, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penAFT.predict_+3A_fit">fit</code></td>
<td>
<p>A fitted model from <code>penAFT</code> or <code>penAFT.cv</code>.</p>
</td></tr>
<tr><td><code id="penAFT.predict_+3A_xnew">Xnew</code></td>
<td>
<p>A matrix of dimension <code class="reqn">n_{\rm new} \times p</code>. Must be a matrix, even if <code class="reqn">n_{\rm new}= 1</code>.</p>
</td></tr>
<tr><td><code id="penAFT.predict_+3A_lambda">lambda</code></td>
<td>
<p>The value of <code class="reqn">\lambda</code> used to estimate <code class="reqn">\beta</code>. If <code>NULL</code> and <code>fit</code> was obtained using <code>nfolds</code> non-<code>NULL</code>, the function will use the tuning parameter which minimized cross-validation linear predictor scores.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is important to note that the output of this function should not be treated as an estimate of the log-survival time. Because the Gehan loss function is location invariant, the intercept is absored into the error. If predictors were standardized for model fitting, this function returns <code class="reqn">\tilde{X}_{\rm new}\hat{\beta}</code> where <code class="reqn">\tilde{X}_{\rm new}</code> is the version of input <code>Xnew</code> which has been centered and standardized according to the design matrix used to fit the <code>penAFT</code> or <code>penAFT.cv</code> object. If predictors were not standardized, this function returns <code class="reqn">X_{\rm new}\hat{\beta}</code>. 
</p>
<p>We recommend input <code>Xnew</code> as a matrix, although if a <code class="reqn">p</code>-dimensional vector is input, the function will detect this. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>preds</code></td>
<td>
<p>The matrix of linear predictors: rows correspond to rows of <code>Xnew</code>.  </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------------------
# Generate data  
# --------------------------------------
set.seed(1)
genData &lt;- genSurvData(n = 50, p = 50, s = 10, mag = 2, cens.quant = 0.6)
X &lt;- genData$X
logY &lt;- genData$logY
delta &lt;- genData$status

# --- generate data for two new subjects
p &lt;- dim(X)[2]
Xnew &lt;- rbind(rnorm(p), rnorm(p))

# -----------------------------------------------
# Fit elastic net penalized estimator without CV
# -----------------------------------------------
fit &lt;- penAFT(X = X, logY = logY, delta = delta,
                   nlambda = 10, lambda.ratio.min = 0.1,
                   penalty = "EN",
                   alpha = 1)

# predict at 10th candidate tuning parameter
linPred.10 &lt;- penAFT.predict(fit, Xnew = Xnew, lambda = fit$lambda[10])


  # ------------------------------------------
  # Fit elastic net penalized estimator with CV
  # -------------------------------------------
  fit.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                    nlambda = 50,
                    penalty = "EN",
                     alpha = 1, nfolds = 5)
  
  # --- return linear predictor at lambda minimizing cross-validation error 
  linPred.cv &lt;- penAFT.predict(fit.cv, Xnew = Xnew) 
  
  # --- predict at 10th candidate tuning parameter
  linPred.cv10 &lt;- penAFT.predict(fit.cv, Xnew = Xnew, lambda = fit.cv$full.fit$lambda[10]) 
  
  
  # ------------------------------------------
  # Fit penAFT with cross-validation
  # -------------------------------------------
  groups &lt;- rep(1:5, each = 10)
  fit.sg.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                    nlambda = 50, groups = groups,
                    penalty = "SG",
                    alpha = 0.5, nfolds = 5)
  
  # ---- return linear predictor at lambda minimizing cross-validation error 
  linPred.sg.cv &lt;- penAFT.predict(fit.sg.cv, Xnew = Xnew) 
  
  # --- predict at 10th candidate tuning parameter
  linPred.sg.cv10 &lt;- penAFT.predict(fit.sg.cv, Xnew = Xnew, lambda = fit.sg.cv$full.fit$lambda[10]) 



</code></pre>

<hr>
<h2 id='penAFT.trace'>Print trace plot for the regularized Gehan estimator fit using <code>penAFT</code> or <code>penAFT.cv</code></h2><span id='topic+penAFT.trace'></span>

<h3>Description</h3>

<p>Print the trace plot for the regularized Gehan estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>penAFT.trace(fit, groupNames=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penAFT.trace_+3A_fit">fit</code></td>
<td>
<p>A fitted model from <code>penAFT</code> or <code>penAFT.cv</code>.</p>
</td></tr>
<tr><td><code id="penAFT.trace_+3A_groupnames">groupNames</code></td>
<td>
<p>A list of groupnames to be printed when <code>fit</code> used penalty &quot;SG&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>penAFT.trace</code> returns a trace plot for a fitted model obtained from either <code>penAFT</code> or <code>penAFT.cv</code>. If the model is fit using the sparse group-lasso penalty, you may provide names for the groups (in order of the integer values specifying the groups). This feature may not be desired if there are a large number of groups, however. The vertical blue line indicates the tuning parameter which minimized cross-validated linear predictor scores and the vertical black line indicates the tuning parameter minimizing the cross-validated Gehan loss according to the one-standard error rule. 
</p>


<h3>Value</h3>

<p>No return value; prints a trace plot as described in Details.</p>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------------------
# Generate data  
# --------------------------------------
set.seed(1)
genData &lt;- genSurvData(n = 50, p = 50, s = 10, mag = 2, cens.quant = 0.6)
X &lt;- genData$X
logY &lt;- genData$logY
delta &lt;- genData$status


# ------------------------------------------
# Fit elastic net penalized estimator with CV
# -------------------------------------------
fit.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                   nlambda = 10,
                   penalty = "EN",
                   alpha = 1, nfolds = 5)

# -- print plot
penAFT.trace(fit.cv)


  # ------------------------------------------
  # Fit sparse group-lasso estimator with CV
  # -------------------------------------------
  groups &lt;- rep(1:5, length=10)
  fit.sg.cv &lt;- penAFT.cv(X = X, logY = logY, delta = delta,
                    nlambda = 50, groups = groups,
                    penalty = "SG", tol.rel= 1e-5,
                    alpha = 0, nfolds = 5)
  
  penAFT.trace(fit.sg.cv, groupNames = paste("Group", 1:5, sep="-"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
