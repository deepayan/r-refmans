<!DOCTYPE html><html><head><title>Help for package activity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {activity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#activity'><p>Animal activity statistics</p></a></li>
<li><a href='#actmod-class'><p>Activity model class.</p></a></li>
<li><a href='#BCIspeed'><p>Animal speed data</p></a></li>
<li><a href='#BCItime'><p>Animal record time of day data</p></a></li>
<li><a href='#bwcalc'><p>Calculate circular kernel bandwidth.</p></a></li>
<li><a href='#cmean'><p>Circular mean</p></a></li>
<li><a href='#compareAct'><p>Compare activity level estimates</p></a></li>
<li><a href='#compareCkern'><p>Compare circular distributions.</p></a></li>
<li><a href='#compareTimes'><p>Compare activity between times of day</p></a></li>
<li><a href='#density2'><p>Modified kernel density function</p></a></li>
<li><a href='#dvmkern'><p>Circular kernel probability density function.</p></a></li>
<li><a href='#dvonm'><p>von Mises density function</p></a></li>
<li><a href='#fitact'><p>Fit activity model to time-of-day data</p></a></li>
<li><a href='#fitlincirc'><p>Linear-circular regression</p></a></li>
<li><a href='#get_suntimes'><p>Calculates solar event times</p></a></li>
<li><a href='#gettime'><p>Convert time of day data to numeric</p></a></li>
<li><a href='#lincircKern'><p>Linear-circular kernel fit</p></a></li>
<li><a href='#lincircmod-class'><p>An S4 class describing linear-circular relationships.</p></a></li>
<li><a href='#ovl4'><p>Index of overlap between circular distributions.</p></a></li>
<li><a href='#plot.actmod'><p>Plot activity distribution</p></a></li>
<li><a href='#plot.lincircmod'><p>Plot linear-circular relationship</p></a></li>
<li><a href='#redf'><p>Random numbers from empirical distribution function.</p></a></li>
<li><a href='#solartime'><p>Transforms clock time to solar time anchored to sun rise and sunset times for a given location.</p></a></li>
<li><a href='#transtime'><p>Transforms clock time to solar times.</p></a></li>
<li><a href='#trigmolen'><p>title trigonometric moment length</p></a></li>
<li><a href='#wrap'><p>Wraps data on a given range.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Animal Activity Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcus Rowcliffe</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcus Rowcliffe &lt;marcus.rowcliffe@ioz.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to express clock time data relative to 
    anchor points (typically solar); fit kernel density functions to animal 
    activity time data; plot activity distributions; quantify overall 
    levels of activity; statistically compare activity metrics through 
    bootstrapping; evaluate variation in linear variables with time (or 
    other circular variables).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>pbapply</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-27 08:07:46 UTC; Rowcliffe.M</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-27 08:30:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='activity'>Animal activity statistics</h2><span id='topic+activity'></span><span id='topic+activity-package'></span>

<h3>Description</h3>

<p>Provides functions to estimate and compare activity parameters from sensor data.
</p>


<h3>Details</h3>

<p>Sensors that record active animals (eg camera traps) build up a record of
the distribution of activity over the course of the day. Records are more frequent
when animals are more active, and less frequent or absent when animals are inactive.
The area under the distribution of records thus contains information on the overall
level of activity in a sampled population. This package provides tools for plotting
activity distributions, quantifying the overall level of activity with error, and
statistically comparing distributions through bootstrapping.
</p>
<p>The core function is <code>fitact</code>, which creates an <code>actmod</code> object containing
the circular kernel PDF, and the activity level estimate derived from this. The
generic plot function for <code>actmod</code> objects plots the distribution. Functions
starting with <code>compare</code> make statistical comparisons between distributions or
activity estimates. Note that all time or other circular data should be in radians
(in the range 0 to 2*pi).
</p>


<h3>References</h3>

<p>Rowcliffe, M., Kays, R., Kranstauber, B., Carbone, C., Jansen, P.A. (2014) Quantifying animal activity level using camera trap data. Methods in Ecology and Evolution.
</p>

<hr>
<h2 id='actmod-class'>Activity model class.</h2><span id='topic+actmod-class'></span>

<h3>Description</h3>

<p>An S4 class describing activity models fitted to time of observation data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>Object of class <code>"numeric"</code>, the input data.</p>
</dd>
<dt><code>wt</code></dt><dd><p>Object of class <code>"numeric"</code>, weights applied to the data.</p>
</dd>
<dt><code>bw</code></dt><dd><p>Object of class <code>"numeric"</code>, kernel bandwidth.</p>
</dd>
<dt><code>adj</code></dt><dd><p>Object of class <code>"numeric"</code>, kernel bandwidth adjustment multiplier.</p>
</dd>
<dt><code>pdf</code></dt><dd><p>Object of class <code>"matrix"</code> describing fitted probability density function:
Column 1: A regular sequence of radian times at which PDF evaluated; range is [0, 2*pi] if unbounded, and sequence steps are range difference divided by 512.
Column 2: Corresponding circular kernel PDF values.
Additionally if errors bootstrapped:
Column 3: PDF standard error.
Column 4: PDF lower 95% confidence limit. Column 5: PDF upper 95% confidence limit.</p>
</dd>
<dt><code>act</code></dt><dd><p>Object of class <code>"numeric"</code> giving activity level estimate and, if errors boostrapped, standard error and 95 percent confidence limits.</p>
</dd>
</dl>

<hr>
<h2 id='BCIspeed'>Animal speed data</h2><span id='topic+BCIspeed'></span>

<h3>Description</h3>

<p>Barro Colorado Island 2008 data: speeds of animal passages past camera traps
(<code>speed</code>), together with species (<code>species</code>) and time of day (<code>time</code>)
for each record.
</p>


<h3>Format</h3>

<p>A dataframe with 2204 observations and 3 variables.
</p>


<h3>Source</h3>

<p>http://dx.doi.org/10.6084/m9.figshare.1160536
</p>

<hr>
<h2 id='BCItime'>Animal record time of day data</h2><span id='topic+BCItime'></span>

<h3>Description</h3>

<p>Barro Colorado Island 2008 data: times of day at which animal records occured
(<code>time</code>), together with species (<code>species</code>).
</p>


<h3>Format</h3>

<p>A dataframe with 17820 observations and 2 variables.
</p>


<h3>Source</h3>

<p>http://dx.doi.org/10.6084/m9.figshare.1160536
</p>

<hr>
<h2 id='bwcalc'>Calculate circular kernel bandwidth.</h2><span id='topic+bwcalc'></span>

<h3>Description</h3>

<p>Uses an optimisation procedure to calculate the circular kernel bandwidth giving the best fit to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwcalc(dat, K = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwcalc_+3A_dat">dat</code></td>
<td>
<p>Numeric data vector of radian times.</p>
</td></tr>
<tr><td><code id="bwcalc_+3A_k">K</code></td>
<td>
<p>Integer number of values of kappa over which to maximise (see references for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mainly for internal use.
</p>


<h3>Value</h3>

<p>Single numeric bandwidth value.
</p>


<h3>References</h3>

<p>Ridout, M.S. &amp; Linkie, M. (2009) Estimating overlap of daily activity patterns from camera trap data. Journal of Agricultural Biological and Environmental Statistics, 14, 322-337.
</p>

<hr>
<h2 id='cmean'>Circular mean</h2><span id='topic+cmean'></span>

<h3>Description</h3>

<p>Calculates the average direction of a set of radian circular values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmean_+3A_x">x</code></td>
<td>
<p>A vector of radian values.</p>
</td></tr>
<tr><td><code id="cmean_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>mean</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>base::mean</code> function is use internally, and additional arguments, e.g for missing data handling, are passed to this.
</p>


<h3>Value</h3>

<p>A radian value giving mean direction.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
times &lt;- subset(BCItime, species=="ocelot")$time*2*pi
cmean(times)
</code></pre>

<hr>
<h2 id='compareAct'>Compare activity level estimates</h2><span id='topic+compareAct'></span>

<h3>Description</h3>

<p>Wald test for the statistical difference between two or more activitiy level estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareAct(fits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareAct_+3A_fits">fits</code></td>
<td>
<p>A list of fitted <code>actmod</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a Wald test to ask whether the difference between estimates a1 and a2 is
significantly different from 0: statistic W = (a1-a2)^2 / (SE1^2+SE2^2) tested
on chi-sq distribution with 1 degree of freedom.
</p>


<h3>Value</h3>

<p>A matrix with 4 columns: 1. differences between estimates; 2. SEs of the differences; 3. Wald statistics; 4. p-values (H0 is no difference between estimates). Matrix rows give all possible pairwise comparisons, numbered in the order in which they entered in the list <code>fits</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Test whether paca have a sigificantly different activity level from rat.
#Bootstrap reps limited to speed up example.
data(BCItime)
tPaca &lt;- 2*pi*BCItime$time[BCItime$species=="ocelot"]
tRat &lt;- 2*pi*BCItime$time[BCItime$species=="rat"]
fPaca &lt;- fitact(tPaca, sample="data", reps=10)
fRat &lt;- fitact(tRat, sample="data", reps=10)
fPaca@act
fRat@act
compareAct(list(fPaca,fRat))
</code></pre>

<hr>
<h2 id='compareCkern'>Compare circular distributions.</h2><span id='topic+compareCkern'></span>

<h3>Description</h3>

<p>Randomisation test for the probability that two sets of circular observations come from the same distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareCkern(fit1, fit2, reps = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareCkern_+3A_fit1">fit1</code>, <code id="compareCkern_+3A_fit2">fit2</code></td>
<td>
<p>Fitted activity models of class actmod created using function fitact.</p>
</td></tr>
<tr><td><code id="compareCkern_+3A_reps">reps</code></td>
<td>
<p>Number of bootstrap iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates overlap index Dhat4 (see references) for the two fitted distributions, then generates a null distribution of overlap indices using data sampled randomly with replacement from the combined data.
This randomised distribution is then used to define an empirical probability distribution against which  the probability that the observed overlap arose by chance is judged.
When one or both fitted models use weighted distributions, sampling probabilities are taken from the weights. If both models are weighted, the weights must therefore be on the same scale.
</p>


<h3>Value</h3>

<p>A named 4-element vector: obs = observed overlap index; null = mean null overlap index; seNull = standard error of the null distribution; pNull = probability observed index arose by chance.
</p>


<h3>References</h3>

<p>Ridout, M.S. &amp; Linkie, M. (2009) Estimating overlap of daily activity patterns from camera trap data. Journal of Agricultural Biological and Environmental Statistics, 14, 322-337.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example with bootstrap reps limited to reduce run time
data(BCItime)
tPaca &lt;- 2*pi*BCItime$time[BCItime$species=="paca"]
tRat &lt;- 2*pi*BCItime$time[BCItime$species=="rat"]
fPaca &lt;- fitact(tPaca)
fRat &lt;- fitact(tRat)
compareCkern(fPaca,fRat,reps=10)
</code></pre>

<hr>
<h2 id='compareTimes'>Compare activity between times of day</h2><span id='topic+compareTimes'></span>

<h3>Description</h3>

<p>Uses a Wald test to statistically compare activity levels at given radian times of day for a fitted activity distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareTimes(fit, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareTimes_+3A_fit">fit</code></td>
<td>
<p>Fitted <code>actmod</code> object with errors boostrapped (fit using <code>fitact</code> with <code>sample</code> argument != &quot;none&quot;).</p>
</td></tr>
<tr><td><code id="compareTimes_+3A_times">times</code></td>
<td>
<p>Numeric vector of radian times of day at which to compare activity levels. All pairwise comparisons are made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootrapping the activity model yields standard error estimates for the PDF. This function uses these SEs to compute a Wald statistic for the difference between PDF values (by inference activity levels) at given times of day: statistic W = (a1-a2)^2 / (SE1^2+SE2^2) tested on chi-sq distribution with 1 degree of freedom.
</p>


<h3>Value</h3>

<p>A matrix with 4 columns: 1. differences between PDF values; 2. SEs of the differences; 3. Wald statistics; 4. p-values (H0 is no difference between estimates). Matrix rows give all possible pairwise comparisons, numbered in the order in which they appear in vector <code>times</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
tPaca &lt;- 2*pi*BCItime$time[BCItime$species=="paca"]
fPaca &lt;- fitact(tPaca, sample="data", reps=10)
plot(fPaca)
compareTimes(fPaca, c(5.5,6,0.5,1))
</code></pre>

<hr>
<h2 id='density2'>Modified kernel density function</h2><span id='topic+density2'></span>

<h3>Description</h3>

<p>Modifies <code>stats::density</code> by:
Adding SE and 95% confidence intervals for the density to the output; and
Truncating calculation (not just reporting) of density  values on from and/or to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density2(x, reps = 999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density2_+3A_x">x</code></td>
<td>
<p>numeric data vector</p>
</td></tr>
<tr><td><code id="density2_+3A_reps">reps</code></td>
<td>
<p>bootstrap iterations for SE/interval calculation; set to NULL to suppress</p>
</td></tr>
<tr><td><code id="density2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stas::density</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Truncation copes with cases where no data are available outside truncation points.
Truncation is achieved by fitting the density to the data augmented by reflecting it
across each bound using the optimal bandwidth for the unaugmented data, and returning
the resulting densities for the region between the bounds.
</p>


<h3>Value</h3>

<p>A list with the same components as <code>stats::density</code> output plus:
<code>se</code>: standard error of the density
<code>lcl</code>, <code>ucl</code>: lower and upper 95% confidence intervals of the density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
tm &lt;- subset(BCItime, species=="ocelot")$time
dens &lt;- density2(tm, from=0.25, to=0.75)
plot(dens$x, dens$y, type="l")
</code></pre>

<hr>
<h2 id='dvmkern'>Circular kernel probability density function.</h2><span id='topic+dvmkern'></span>

<h3>Description</h3>

<p>Optionally weighted Von Mises kernel probability densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvmkern(x, dat, wt = NULL, bw = NULL, adj = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dvmkern_+3A_x">x</code></td>
<td>
<p>Numeric vector of radian times at which to evaluate the PDF.</p>
</td></tr>
<tr><td><code id="dvmkern_+3A_dat">dat</code></td>
<td>
<p>Numeric vector of radian time data to which the PDF is fitted.</p>
</td></tr>
<tr><td><code id="dvmkern_+3A_wt">wt</code></td>
<td>
<p>A numeric vector of weights for each <code>dat</code> value.</p>
</td></tr>
<tr><td><code id="dvmkern_+3A_bw">bw</code></td>
<td>
<p>Numeric value for kernel bandwidth.</p>
</td></tr>
<tr><td><code id="dvmkern_+3A_adj">adj</code></td>
<td>
<p>Numeric kernel bandwidth multiplier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>bw</code> not provided it is calculated internally using <code>bw.calc</code>. The <code>adj</code> argument is used to adjust <code>bw</code> to facilitate exploration of fit flexibility.
</p>


<h3>Value</h3>

<p>Numeric vector of probability densities evaluated at <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bwcalc">bwcalc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example with made up input
tt &lt;- runif(100,0,2*pi)
xx &lt;- seq(0,2*pi, pi/256)
pdf &lt;- dvmkern(xx, tt)
plot(xx, pdf, type="l")
</code></pre>

<hr>
<h2 id='dvonm'>von Mises density function</h2><span id='topic+dvonm'></span>

<h3>Description</h3>

<p>Probability density function for the von Mises circular distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvonm(x, mu, k, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dvonm_+3A_x">x</code></td>
<td>
<p>numeric angles (assumed to be radian).</p>
</td></tr>
<tr><td><code id="dvonm_+3A_mu">mu</code></td>
<td>
<p>numeric, the mean direction of the distribution.</p>
</td></tr>
<tr><td><code id="dvonm_+3A_k">k</code></td>
<td>
<p>non-negative numeric, the concentration parameter distribution (kappa).</p>
</td></tr>
<tr><td><code id="dvonm_+3A_log">log</code></td>
<td>
<p>if TRUE log probabilities are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If more than one of x, mu and k have length &gt; 1, values are recycled.
</p>


<h3>Value</h3>

<p>Probability density value(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dvonm(seq(0, 2*pi, len=10), pi, 1)
</code></pre>

<hr>
<h2 id='fitact'>Fit activity model to time-of-day data</h2><span id='topic+fitact'></span>

<h3>Description</h3>

<p>Fits kernel density to radian time-of-day data and estimates activity level from this distribution.
Optionally: 1. bootstraps the distribution, in which case SEs and confidence limits are also
stored for activity level and PDF; 2. weights the distribution; 3. truncates the distribution at given times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitact(
  dat,
  wt = NULL,
  reps = 999,
  bw = NULL,
  adj = 1,
  sample = c("none", "data", "model"),
  bounds = NULL,
  show = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitact_+3A_dat">dat</code></td>
<td>
<p>A numeric vector of radian time-of-day data.</p>
</td></tr>
<tr><td><code id="fitact_+3A_wt">wt</code></td>
<td>
<p>A numeric vector of weights for each <code>dat</code> value.</p>
</td></tr>
<tr><td><code id="fitact_+3A_reps">reps</code></td>
<td>
<p>Number of bootstrap iterations to perform. Ignored if <code>sample=="none"</code>.</p>
</td></tr>
<tr><td><code id="fitact_+3A_bw">bw</code></td>
<td>
<p>Numeric value for kernel bandwidth. If NULL, calculated internally.</p>
</td></tr>
<tr><td><code id="fitact_+3A_adj">adj</code></td>
<td>
<p>Numeric bandwidth adjustment multiplier.</p>
</td></tr>
<tr><td><code id="fitact_+3A_sample">sample</code></td>
<td>
<p>Character string defining sampling method for bootstrapping errors (see details).</p>
</td></tr>
<tr><td><code id="fitact_+3A_bounds">bounds</code></td>
<td>
<p>A two-element vector defining radian bounds at which to truncate.</p>
</td></tr>
<tr><td><code id="fitact_+3A_show">show</code></td>
<td>
<p>Logical whether or not to show a progress bar while bootstrapping.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When no <code>bounds</code> are given (default), a circular kernel distribution is fitted using <code>dvmkern</code>.
Otherwise, a normal kernel distribution is used, truncated at the values of <code>bounds</code>, using <code>density2</code>.
</p>
<p>The bandwidth adjustment multiplier <code>adj</code> is provided to allow
exploration of the effect of adjusting the internally calculated bandwidth on
accuracy of activity level estimates.
</p>
<p>The alternative bootstrapping methods defined by <code>sample</code> are:
</p>

<ul>
<li><p><code>"none"</code>: no bootstrapping
</p>
</li>
<li><p><code>"data"</code>: sample from the data
</p>
</li>
<li><p><code>"model"</code>: sample from the fitted probability density distribution
</p>
</li></ul>

<p>It's generally better to sample from the data, but sampling from
the fitted distribution can sometimes provide more sensible confidence intervals when
the number of observations is very small.
</p>


<h3>Value</h3>

<p>An object of type <code>actmod</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fit without confidence limits
data(BCItime)
tm &lt;- 2*pi*subset(BCItime, species=="brocket")$time
mod1 &lt;- fitact(tm)
plot(mod1)

#Fit with confidence limits (limited reps to speed up)
mod2 &lt;- fitact(tm, sample="data", reps=10)
plot(mod2)

#Fit weighted function to correct for detection radius 1.2 times higher
#by day than by night, assuming day between pi/2 (6 am) and pi*2/3 (6 pm)
weight &lt;- 1/ifelse(tm&gt;pi/2 &amp; tm&lt;pi*3/2, 1.2, 1)
mod3 &lt;- fitact(tm, wt=weight)
plot(mod3)
#Overplot unweighted version for comparison
plot(mod1, add=TRUE, tline=list(col=2))

#Fit truncated function to consider only night time records,
#assuming night between pi*3/2 (6 pm) and pi/3 (6 am)
mod4 &lt;- fitact(tm, bounds=c(pi*3/2, pi/2))
plot(mod4, centre="night")
</code></pre>

<hr>
<h2 id='fitlincirc'>Linear-circular regression</h2><span id='topic+fitlincirc'></span>

<h3>Description</h3>

<p>Fits a Von Mises kernel distribution describing a linear variable as a function
of a circular predictor, and boostraps the null distribution in order to evaluate
significance of radial variation in the linear variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitlincirc(circdat, lindat, pCI = 0.95, reps = 10, res = 512)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitlincirc_+3A_circdat">circdat</code></td>
<td>
<p>Numeric vector of radian data matched with <code>lindat</code>.</p>
</td></tr>
<tr><td><code id="fitlincirc_+3A_lindat">lindat</code></td>
<td>
<p>Numeric vector of linear data matched with <code>circdat</code>.</p>
</td></tr>
<tr><td><code id="fitlincirc_+3A_pci">pCI</code></td>
<td>
<p>Single numeric value between 0 and 1 defining proportional confidence interval to return.</p>
</td></tr>
<tr><td><code id="fitlincirc_+3A_reps">reps</code></td>
<td>
<p>Integer number of bootstrap repetitions to perform.</p>
</td></tr>
<tr><td><code id="fitlincirc_+3A_res">res</code></td>
<td>
<p>Resolution of fitted distribution and null confidence interval - specifically a single integer number of points on the circular scale at which to record distributions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deviation of <code>lindat</code> from the null expecation is assessed either visually
by the degree to which the fitted distribution departs from the null confidence
interval (use generic plot function), or quantitatively by column <code>p</code> of
slot <code>fit</code> in the resulting <code>lincircmod-class</code> object.
</p>


<h3>Value</h3>

<p>An object of type <code><a href="#topic+lincircmod-class">lincircmod-class</a></code>
</p>


<h3>References</h3>

<p>Xu, H., Nichols, K. &amp; Schoenberg, F.P. (2011) Directional kernel regression for wind and fire data. Forest Science, 57, 343-352.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example with reps limited to increase speed
data(BCIspeed)
i &lt;- BCIspeed$species=="ocelot"
sp &lt;- log(BCIspeed$speed[i])
tm &lt;- BCIspeed$time[i]*2*pi
mod &lt;- fitlincirc(tm, sp, reps=50)
plot(mod, CircScale=24, xaxp=c(0,24,4), xlab="Time", ylab="log(speed)")
legend(8,-3, c("Fitted speed", "Null CI"), col=1:2, lty=1:2)
</code></pre>

<hr>
<h2 id='get_suntimes'>Calculates solar event times</h2><span id='topic+get_suntimes'></span>

<h3>Description</h3>

<p>Calculates approximate times of sunrise and sunset and day lengths
for given dates at given locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_suntimes(
  date,
  lat,
  lon,
  offset,
  ...,
  tryFormats = c("%Y-%m-%d %H:%M:%OS", "%Y/%m/%d %H:%M:%OS",
    "%Y:%m:%d %H:%M:%OS", "%Y-%m-%d %H:%M", "%Y/%m/%d %H:%M",
    "%Y:%m:%d %H:%M", "%Y-%m-%d", "%Y/%m/%d", "%Y:%m:%d")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_suntimes_+3A_date">date</code></td>
<td>
<p>character, POSIX or Date format date/time value(s)</p>
</td></tr>
<tr><td><code id="get_suntimes_+3A_lat">lat</code>, <code id="get_suntimes_+3A_lon">lon</code></td>
<td>
<p>latitude and longitude in decimal degrees</p>
</td></tr>
<tr><td><code id="get_suntimes_+3A_offset">offset</code></td>
<td>
<p>the time offset in hours relative to UTC (GMT) for results</p>
</td></tr>
<tr><td><code id="get_suntimes_+3A_...">...</code></td>
<td>
<p>arguments passed to as.POSIXlt</p>
</td></tr>
<tr><td><code id="get_suntimes_+3A_tryformats">tryFormats</code></td>
<td>
<p>formats to try when converting date from character, passed to as.POSIXlt</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function adapted from https://www.r-bloggers.com/2014/09/seeing-the-daylight-with-r/
</p>


<h3>Value</h3>

<p>A dataframe with columns sunrise and sunset (given in the timezone defined by offset) and daylength, all expressed in hours.
</p>


<h3>References</h3>

<p>Teets, D.A. 2003. Predicting sunrise and sunset times. The College Mathematics Journal 34(4):317-321.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
dat &lt;- subset(BCItime, species=="ocelot")$date
get_suntimes(dat, 9.156335, -79.847682, -5)
</code></pre>

<hr>
<h2 id='gettime'>Convert time of day data to numeric</h2><span id='topic+gettime'></span>

<h3>Description</h3>

<p>Accepts data of class POSIXct, POSIXlt or character and returns the  time of day element as numeric (any date element is ignored).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gettime(
  x,
  scale = c("radian", "hour", "proportion"),
  ...,
  tryFormats = c("%Y-%m-%d %H:%M:%OS", "%Y/%m/%d %H:%M:%OS",
    "%Y:%m:%d %H:%M:%OS", "%Y-%m-%d %H:%M", "%Y/%m/%d %H:%M",
    "%Y:%m:%d %H:%M", "%Y-%m-%d", "%Y/%m/%d", "%Y:%m:%d")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gettime_+3A_x">x</code></td>
<td>
<p>A vector of POSIXct, POSIXlt or character format time data to convert.</p>
</td></tr>
<tr><td><code id="gettime_+3A_scale">scale</code></td>
<td>
<p>The scale on which to return times (see Value for options).</p>
</td></tr>
<tr><td><code id="gettime_+3A_...">...</code></td>
<td>
<p>arguments passed to as.POSIXlt</p>
</td></tr>
<tr><td><code id="gettime_+3A_tryformats">tryFormats</code></td>
<td>
<p>formats to try when converting date from character, passed to as.POSIXlt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric times of day in units defined by the <code>scale</code> argument:
radian, on the range [0, 2*pi];
hours, on the range [0, 24];
proportion, on the range [0, 1].
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strptime">strptime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
rtime &lt;- gettime(BCItime$date)
htime &lt;- gettime(BCItime$date, "hour")
ptime &lt;- gettime(BCItime$date, "proportion")
summary(rtime)
summary(htime)
summary(ptime)
</code></pre>

<hr>
<h2 id='lincircKern'>Linear-circular kernel fit</h2><span id='topic+lincircKern'></span>

<h3>Description</h3>

<p>Fits a Von Mises kernel distribution describing a linear variable as a function of a circular predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lincircKern(x, circdat, lindat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lincircKern_+3A_x">x</code></td>
<td>
<p>Numeric vector of radian values at which to evaluate the distribution.</p>
</td></tr>
<tr><td><code id="lincircKern_+3A_circdat">circdat</code></td>
<td>
<p>Numeric vector of radian data matched with <code>lindat</code>.</p>
</td></tr>
<tr><td><code id="lincircKern_+3A_lindat">lindat</code></td>
<td>
<p>Numeric vector of linear data matched with <code>circdat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of fitted <code>lindat</code> values matched with <code>x</code>.
</p>


<h3>References</h3>

<p>Xu, H., Nichols, K. &amp; Schoenberg, F.P. (2011) Directional kernel regression for wind and fire data. Forest Science, 57, 343-352.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCIspeed)
i &lt;- BCIspeed$species=="ocelot"
log_speed &lt;- log(BCIspeed$speed[i])
time &lt;- BCIspeed$time[i]*2*pi
circseq &lt;- seq(0,2*pi,pi/256)
trend &lt;- lincircKern(circseq, time, log_speed)
plot(time, log_speed, xlim=c(0, 2*pi))
lines(circseq, trend)
</code></pre>

<hr>
<h2 id='lincircmod-class'>An S4 class describing linear-circular relationships.</h2><span id='topic+lincircmod-class'></span>

<h3>Description</h3>

<p>An S4 class describing linear-circular relationships.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>Object of class <code>"data.frame"</code>, the input data, with columns
<code>lindat</code> (linear data) and <code>circdat</code> (circular data).</p>
</dd>
<dt><code>fit</code></dt><dd><p>Object of class <code>"data.frame"</code>, summary of the model fit, with columns:
<code>x</code>: A regular ascending sequence from 0 to 2*pi at which other columns evaluated;
<code>fit</code>: The linear fitted values;
<code>p</code>: The two tailed probability of observing the fitted values under a random (null) circular distribution;
<code>nullLCL</code>: The lower 95% confidence limit of the null distribution;
<code>nullUCL</code>: The upper 95% confidence limit of the null distribution.</p>
</dd>
</dl>

<hr>
<h2 id='ovl4'>Index of overlap between circular distributions.</h2><span id='topic+ovl4'></span>

<h3>Description</h3>

<p>Calculates Dhat4 overlap index (see reference) between two kernel distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ovl4(fit1, fit2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ovl4_+3A_fit1">fit1</code>, <code id="ovl4_+3A_fit2">fit2</code></td>
<td>
<p>Fitted activity models of class actmod created using function fitact.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses linear interpolation to impute values from kernel distributions.
</p>


<h3>Value</h3>

<p>Scalar overlap index (specifically Dhat4).
</p>


<h3>References</h3>

<p>Ridout, M.S. &amp; Linkie, M. (2009) Estimating overlap of daily activity patterns from camera trap data. Journal of Agricultural Biological and Environmental Statistics, 14, 322-337.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
oceAct &lt;- fitact(subset(BCItime, species=="ocelot")$time*2*pi)
broAct &lt;- fitact(subset(BCItime, species=="brocket")$time*2*pi)
ovl4(oceAct, broAct)
</code></pre>

<hr>
<h2 id='plot.actmod'>Plot activity distribution</h2><span id='topic+plot.actmod'></span>

<h3>Description</h3>

<p>Plot an activity probability distribution from a fitted <code>actmod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'actmod'
plot(
  x,
  xunit = c("clock", "hours", "radians"),
  yunit = c("frequency", "density"),
  data = c("histogram", "rug", "both", "none"),
  centre = c("day", "night"),
  dline = list(lwd = ifelse(data == "rug", 0.1, 1)),
  tline = NULL,
  cline = list(lty = 2),
  add = FALSE,
  xaxis = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.actmod_+3A_x">x</code></td>
<td>
<p>Object of class <code>actmod</code>.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_xunit">xunit</code></td>
<td>
<p>Character string defining x-axis unit.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_yunit">yunit</code></td>
<td>
<p>Character string defining y-axis unit.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_data">data</code></td>
<td>
<p>Character string defining whether to plot the data distribution and if so which style to use.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_centre">centre</code></td>
<td>
<p>Character string defining whether to centre the plot on midday or midnight.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_dline">dline</code></td>
<td>
<p>List of plotting parameters for data lines.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_tline">tline</code></td>
<td>
<p>List of plotting parameters for trend line.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_cline">cline</code></td>
<td>
<p>List of plotting parameters for trend confidence interval lines.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_add">add</code></td>
<td>
<p>Logical defining whether to create a new plot (default) or add to an existing plot.</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_xaxis">xaxis</code></td>
<td>
<p>List of plotting parameters to pass to axis command for x-axis plot (see axis for arguments).</p>
</td></tr>
<tr><td><code id="plot.actmod_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to internal plot call affecting only the plot frame and y axis. Modify x axis through xaxis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When xunit==&quot;clock&quot;, The underlying numeric range of the x-axis is [0,24] if centre==&quot;day&quot;,
or [-12,12] if centre==&quot;night&quot;.
</p>


<h3>Value</h3>

<p>No return value, called to create a plot visualising an activity model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
otm &lt;- 2*pi*subset(BCItime, species=="ocelot")$time
btm &lt;- 2*pi*subset(BCItime, species=="brocket")$time
omod &lt;- fitact(otm)
bmod &lt;- fitact(btm)
plot(omod, yunit="density", data="none")
plot(bmod, yunit="density", data="none", add=TRUE, tline=list(col="red"))
legend("topleft", c("Ocelot", "Brocket deer"), col=1:2, lty=1)

mod &lt;- fitact(otm, sample="data", reps=10)
plot(mod, dline=list(col="grey"),
          tline=list(col="red", lwd=2),
          cline=list(col="red", lty=3))

mod2 &lt;- fitact(otm, bounds=c(pi*3/2, pi/2))
plot(mod2, centre="night")
plot(mod2, centre="night", xlim=c(-6,6), xaxis=list(at=seq(-6,6,2)))
</code></pre>

<hr>
<h2 id='plot.lincircmod'>Plot linear-circular relationship</h2><span id='topic+plot.lincircmod'></span>

<h3>Description</h3>

<p>Plot linear against circular data along with the fitted and null confidence limit distributions from a fitted <code>lincircmod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lincircmod'
plot(
  x,
  CircScale = 2 * pi,
  tlim = c(0, 1),
  fcol = "black",
  flty = 1,
  ncol = "red",
  nlty = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lincircmod_+3A_x">x</code></td>
<td>
<p>Object of class <code>lincircmod</code>.</p>
</td></tr>
<tr><td><code id="plot.lincircmod_+3A_circscale">CircScale</code></td>
<td>
<p>Single numeric value defining the plotting maximum of the circular scale.</p>
</td></tr>
<tr><td><code id="plot.lincircmod_+3A_tlim">tlim</code></td>
<td>
<p>Numeric vector with two elements &gt;=0 and &lt;=1 defining the lower and upper limits at which to plot distributions; default plots the full range.</p>
</td></tr>
<tr><td><code id="plot.lincircmod_+3A_fcol">fcol</code>, <code id="plot.lincircmod_+3A_flty">flty</code>, <code id="plot.lincircmod_+3A_ncol">ncol</code>, <code id="plot.lincircmod_+3A_nlty">nlty</code></td>
<td>
<p>Define line colour (<code>col</code>) and type (<code>lty</code>) for fitted (<code>f</code>) and null (<code>n</code>) distributions; input types as for <code>col</code> and <code>lty</code>, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lincircmod_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the inital plot construction, affecting axes and data plot symbols.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to create a plot visualising a linear-circular relationship.
</p>

<hr>
<h2 id='redf'>Random numbers from empirical distribution function.</h2><span id='topic+redf'></span>

<h3>Description</h3>

<p>Random numbers drawn from an empirical distribution defined by paired values and probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redf(n, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redf_+3A_n">n</code></td>
<td>
<p>Integer number of random numbers to return.</p>
</td></tr>
<tr><td><code id="redf_+3A_fit">fit</code></td>
<td>
<p>Data frame defining the emprical distribution (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution function is defined by <code>fit</code>, which must be a dataframe containing (at least) columns named:
x: a regular sequence of values from which to draw;
y: corresponding pdf values.
</p>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
tm &lt;- 2*pi*subset(BCItime, species=="paca")$time
mod &lt;- fitact(tm)
rn &lt;- redf(1000, as.data.frame(mod@pdf))
</code></pre>

<hr>
<h2 id='solartime'>Transforms clock time to solar time anchored to sun rise and sunset times for a given location.</h2><span id='topic+solartime'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>transtime</code> that takes non-numeric date-time input together with latitude and longitude to calculate mean average sunrise and sunset times, which are then used to anchor the transformation using average anchoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solartime(
  dat,
  lat,
  lon,
  tz,
  ...,
  tryFormats = c("%Y-%m-%d %H:%M:%OS", "%Y/%m/%d %H:%M:%OS",
    "%Y:%m:%d %H:%M:%OS", "%Y-%m-%d %H:%M", "%Y/%m/%d %H:%M",
    "%Y:%m:%d %H:%M", "%Y-%m-%d", "%Y/%m/%d", "%Y:%m:%d")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solartime_+3A_dat">dat</code></td>
<td>
<p>A vector of character, POSIXct or POSIXlt date-time values.</p>
</td></tr>
<tr><td><code id="solartime_+3A_lat">lat</code>, <code id="solartime_+3A_lon">lon</code></td>
<td>
<p>Single numeric values or numeric vectors the same length as <code>dat</code> giving site latitude and longitude in decimal format.</p>
</td></tr>
<tr><td><code id="solartime_+3A_tz">tz</code></td>
<td>
<p>A single numeric value or numeric vector same length as <code>dat</code> giving time zone (see Details).</p>
</td></tr>
<tr><td><code id="solartime_+3A_...">...</code></td>
<td>
<p>arguments passed to as.POSIXlt</p>
</td></tr>
<tr><td><code id="solartime_+3A_tryformats">tryFormats</code></td>
<td>
<p>formats to try when converting date from character, passed to as.POSIXlt</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time zone <code>tz</code> should be expressed in numeric hours relative to UTC (GMT).
</p>


<h3>Value</h3>

<p>A list with elements:
</p>
<p><code>input</code>: event input dates-times in POSIXlt format.
</p>
<p><code>clock</code>: radian clock time data.
</p>
<p><code>solar</code>: radian solar time data anchored to average sun rise and sun set times.
</p>


<h3>References</h3>

<p>Vazquez, C., Rowcliffe, J.M., Spoelstra, K. and Jansen, P.A. in press. Comparing diel activity patterns of wildlife across latitudes and seasons: time transformation using day length. Methods in Ecology and Evolution.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strptime">strptime</a>, <a href="#topic+transtime">transtime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
subdat &lt;- subset(BCItime, species=="ocelot")
times &lt;- solartime(subdat$date, 9.156335, -79.847682, -5)
rawAct &lt;- fitact(times$clock)
avgAct &lt;- fitact(times$solar)
plot(rawAct)
plot(avgAct, add=TRUE, data="n", tline=list(col="cyan"))
</code></pre>

<hr>
<h2 id='transtime'>Transforms clock time to solar times.</h2><span id='topic+transtime'></span>

<h3>Description</h3>

<p>Transforms time expressed relative to either the time of a single solar event (anchor times - Nouvellet et al. 2012), or two solar events (such as sun rise and sun set - Vazquez et al. in press).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transtime(
  dat,
  anchor,
  mnanchor = NULL,
  type = c("average", "equinoctial", "single")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transtime_+3A_dat">dat</code></td>
<td>
<p>A vector of radian event clock times.</p>
</td></tr>
<tr><td><code id="transtime_+3A_anchor">anchor</code></td>
<td>
<p>A vector or matrix matched with <code>dat</code> containing radian anchor times on the day of each event (see Details).</p>
</td></tr>
<tr><td><code id="transtime_+3A_mnanchor">mnanchor</code></td>
<td>
<p>A scalar or two-element vector of numeric radian mean anchor times (see Details).</p>
</td></tr>
<tr><td><code id="transtime_+3A_type">type</code></td>
<td>
<p>The type of transformation to use (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If double anchoring is requested (i.e. <code>type</code> is equinoctial
or average), the <code>anchor</code> argument requires a two-column matrix,
otherwise a vector. The argument <code>mnanchor</code> can usually be left at
its default <code>NULL</code> value. In this case, the mean anchors are set to
<code>c(pi/2, pi*3/2)</code> when <code>type</code>==&quot;equinoctial&quot;, otherwise the
<code>anchor</code> mean(s).
</p>
<p>Although the anchors for transformation are usually likely to be solar
events (e.g. sun rise and/or sunset), they could be other celestial
(e.g. lunar) or human-related (e.g. timing of artificial lighting) events.
</p>


<h3>Value</h3>

<p>A vector of radian transformed times.
</p>


<h3>References</h3>

<p>Vazquez, C., Rowcliffe, J.M., Spoelstra, K. and Jansen, P.A. in press. Comparing diel activity patterns of wildlife across latitudes and seasons: time transformation using day length. Methods in Ecology and Evolution.
</p>
<p>Nouvellet, P., Rasmussen, G.S.A., Macdonald, D.W. and Courchamp, F. 2012. Noisy clocks and silent sunrises: measurement methods of daily activity pattern. Journal of Zoology 286: 179-184.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
subdat &lt;- subset(BCItime, species=="ocelot")
suntimes &lt;- pi/12 * get_suntimes(subdat$date, 9.156335, -79.847682, -5)[, -3]
rawtimes &lt;- subdat$time*2*pi
avgtimes &lt;- transtime(rawtimes, suntimes)
eqntimes &lt;- transtime(rawtimes, suntimes, type="equinoctial")
sngtimes &lt;- transtime(rawtimes, suntimes[,1], type="single")
rawAct &lt;- fitact(rawtimes)
avgAct &lt;- fitact(avgtimes)
eqnAct &lt;- fitact(eqntimes)
sngAct &lt;- fitact(sngtimes)
plot(rawAct)
plot(avgAct, add=TRUE, data="n", tline=list(col="magenta"))
plot(eqnAct, add=TRUE, data="n", tline=list(col="orange"))
plot(sngAct, add=TRUE, data="n", tline=list(col="cyan"))
</code></pre>

<hr>
<h2 id='trigmolen'>title trigonometric moment length</h2><span id='topic+trigmolen'></span>

<h3>Description</h3>

<p>Calculate trigonometric moment length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trigmolen(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trigmolen_+3A_x">x</code></td>
<td>
<p>a vector of circular values, assumed to be radian.</p>
</td></tr>
<tr><td><code id="trigmolen_+3A_p">p</code></td>
<td>
<p>order of trigonometric moment to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trigonometric moment length of the input.
</p>

<hr>
<h2 id='wrap'>Wraps data on a given range.</h2><span id='topic+wrap'></span>

<h3>Description</h3>

<p>Input data outside the given bounds (default radian [0, 2*pi]) are wrapped to appear within the range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap(x, bounds = c(0, 2 * pi))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_+3A_x">x</code></td>
<td>
<p>A vector of numeric data.</p>
</td></tr>
<tr><td><code id="wrap_+3A_bounds">bounds</code></td>
<td>
<p>The range within which to wrap <code>x</code> values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an example of wrapping, on bounds [0, 1], a value of 1.2 will be converted to 0.2, while a value of -0.2 will be converted to 0.8.
</p>


<h3>Value</h3>

<p>A vector of numeric values within the limits defined by <code>bounds</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCItime)
adjtime &lt;- BCItime$time + 1/24
summary(adjtime)
adjtime &lt;- wrap(adjtime, c(0,1))
summary(adjtime)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
