<!DOCTYPE html><html><head><title>Help for package ggpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggpp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggpp-package'><p>ggpp: Grammar Extensions to 'ggplot2'</p></a></li>
<li><a href='#annotate'><p>Annotations supporting NPC</p></a></li>
<li><a href='#birch.df'><p>Birch seedlings' size</p></a></li>
<li><a href='#compute_npcx'><p>Compute npc coordinates</p></a></li>
<li><a href='#dark_or_light'><p>Chose between dark and light color</p></a></li>
<li><a href='#geom_grob'><p>Inset graphical objects</p></a></li>
<li><a href='#geom_label_npc'><p>Text with Normalised Parent Coordinates</p></a></li>
<li><a href='#geom_label_pairwise'><p>Label pairwise comparisons</p></a></li>
<li><a href='#geom_label_s'><p>Linked Text</p></a></li>
<li><a href='#geom_plot'><p>Inset plots</p></a></li>
<li><a href='#geom_point_s'><p>Points linked by a segment</p></a></li>
<li><a href='#geom_quadrant_lines'><p>Reference lines: horizontal plus vertical, and quadrants</p></a></li>
<li><a href='#geom_table'><p>Inset tables</p></a></li>
<li><a href='#geom_x_margin_arrow'><p>Reference arrows on the margins</p></a></li>
<li><a href='#geom_x_margin_grob'><p>Add Grobs on the margins</p></a></li>
<li><a href='#geom_x_margin_point'><p>Reference points on the margins</p></a></li>
<li><a href='#GeomGrob'><p><code>Stat*</code> Objects</p></a></li>
<li><a href='#ggplot'><p>Create a new ggplot plot from time series data</p></a></li>
<li><a href='#ivy.df'><p>Ivy photosynthesis light response</p></a></li>
<li><a href='#position_dodgenudge'><p>Combined positions dodge and nudge</p></a></li>
<li><a href='#position_jitternudge'><p>Combined positions jitter and nudge</p></a></li>
<li><a href='#position_nudge_center'><p>Nudge labels away from a central point</p></a></li>
<li><a href='#position_nudge_keep'><p>Nudge points a fixed distance</p></a></li>
<li><a href='#position_nudge_line'><p>Nudge labels away from a line</p></a></li>
<li><a href='#position_nudge_to'><p>Nudge labels to new positions</p></a></li>
<li><a href='#position_stacknudge'><p>Combined positions stack and nudge</p></a></li>
<li><a href='#quadrant_example.df'><p>Gene expression data</p></a></li>
<li><a href='#scale_continuous_npc'><p>Position scales for continuous data (npcx &amp; npcy)</p></a></li>
<li><a href='#stat_apply_group'><p>Apply a function to x or y values</p></a></li>
<li><a href='#stat_dens1d_filter'><p>Filter observations by local 1D density</p></a></li>
<li><a href='#stat_dens1d_labels'><p>Replace labels in data based on 1D density</p></a></li>
<li><a href='#stat_dens2d_filter'><p>Filter observations by local 2D density</p></a></li>
<li><a href='#stat_dens2d_labels'><p>Replace labels in data based on 2D density</p></a></li>
<li><a href='#stat_fmt_tb'><p>Select and slice a tibble nested in <code>data</code></p></a></li>
<li><a href='#stat_functions'><p>Draw functions as curves</p></a></li>
<li><a href='#stat_panel_counts'><p>Number of observations in a plot panel</p></a></li>
<li><a href='#stat_quadrant_counts'><p>Number of observations in quadrants</p></a></li>
<li><a href='#these2logical'><p>Convert keep.these argument into logical vector</p></a></li>
<li><a href='#try_data_frame'><p>Convert an R object into a tibble</p></a></li>
<li><a href='#ttheme_gtdefault'><p>Table themes</p></a></li>
<li><a href='#ttheme_set'><p>Set default table theme</p></a></li>
<li><a href='#volcano_example.df'><p>Gene expression data</p></a></li>
<li><a href='#weather_18_june_2019.df'><p>Weather data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Grammar Extensions to 'ggplot2'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pedro J. Aphalo &lt;pedro.aphalo@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extensions to 'ggplot2' respecting the grammar of graphics 
    paradigm. Geometries: geom_table(), geom_plot() and geom_grob() add insets to 
    plots using native data coordinates, while geom_table_npc(), geom_plot_npc()
    and geom_grob_npc() do the same using "npc" coordinates through new 
    aesthetics "npcx" and "npcy". Statistics: select observations based on 2D 
    density. Positions: radial nudging away from a center point and nudging away
    from a line or curve; combined stacking and nudging; combined dodging and
    nudging.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), ggplot2 (&ge; 3.3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grid, grDevices, rlang (&ge; 1.0.6), magrittr (&ge; 2.0.1),
glue (&ge; 1.6.0), gridExtra (&ge; 2.3), scales (&ge; 1.2.0), tibble
(&ge; 3.1.8), dplyr (&ge; 1.1.0), xts (&ge; 0.13.0), zoo (&ge; 1.8-11),
MASS (&ge; 7.3-58), polynom (&ge; 1.4-0), lubridate (&ge; 1.9.0),
stringr (&ge; 1.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.40), rmarkdown (&ge; 2.20), ggrepel (&ge; 0.9.2),
gginnards(&ge; 0.1.1), magick (&ge; 2.7.3), testthat (&ge; 3.1.5),
vdiffr (&ge; 1.0.5)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.r4photobiology.info/ggpp/">https://docs.r4photobiology.info/ggpp/</a>,
<a href="https://github.com/aphalo/ggpp">https://github.com/aphalo/ggpp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aphalo/ggpp/issues">https://github.com/aphalo/ggpp/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-07 19:02:09 UTC; aphalo</td>
</tr>
<tr>
<td>Author:</td>
<td>Pedro J. Aphalo <a href="https://orcid.org/0000-0003-3385-972X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kamil Slowikowski <a href="https://orcid.org/0000-0002-2843-6370"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Michał Krassowski <a href="https://orcid.org/0000-0002-9638-7785"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Daniel Sabanés Bové [ctb],
  Stella Banjo [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggpp-package'>ggpp: Grammar Extensions to 'ggplot2'</h2><span id='topic+ggpp'></span><span id='topic+ggpp-package'></span>

<h3>Description</h3>

<p>Extensions to 'ggplot2' respecting the grammar of graphics paradigm. Geometries: geom_table(), geom_plot() and geom_grob() add insets to plots using native data coordinates, while geom_table_npc(), geom_plot_npc() and geom_grob_npc() do the same using &quot;npc&quot; coordinates through new aesthetics &quot;npcx&quot; and &quot;npcy&quot;. Statistics: select observations based on 2D density. Positions: radial nudging away from a center point and nudging away from a line or curve; combined stacking and nudging; combined dodging and nudging.
</p>


<h3>Details</h3>

<p>Package 'ggpp' provides functions that extend the grammar of
graphics as implemented in 'ggplot2'. It attempts to stay true to the
original grammar and to respect the naming conventions used in 'ggplot2'.
</p>
<p>Extensions provided:
</p>

<ul>
<li><p> Geoms adding support for plot, table and grob insets within the
gramamr. Geoms using a parallel pseudo-scale based on native plot coordinates
(npc) to allow annotations consistent with the grammar and so supporting
facets and grouping. Geoms for annotations on the edges of the plotting
area. Geom for easily drawing lines separating the quadrants of a plot.
</p>
</li>
<li><p> Stats for filtering-out/filtering-in observations in regions of a
panel or group where the density of observations is high. Statistics
simultaneously computing summaries, optionally using different functions,
along x and y. Stat computing quadrant counts.
</p>
</li>
<li><p> Position functions implementing multi-directional nudging based on the
data.
</p>
</li>
<li><p> Scales. Pseudo-scales supporting npc coordinates for x and y.
</p>
</li>
<li><p> Specializations of the <code>ggplot()</code> generic accepting time series
objects of classes <code>ts</code> and <code>xts</code> as data argument.
</p>
</li></ul>



<h3>Acknowledgements</h3>

<p>We thank Kamil Slowikowski not only for
contributing ideas and code examples to this package but also for adding
new features to his package 'ggrepel' that allow new use cases for
<code>stat_dens2d_labels()</code>, <code>position_nudge_center()</code>,
<code>position_nudge_line()</code> and <code>position_nudge_to()</code> from this
package. This package includes code copied and/or modified from
that in package 'ggplot2'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pedro J. Aphalo <a href="mailto:pedro.aphalo@helsinki.fi">pedro.aphalo@helsinki.fi</a> (<a href="https://orcid.org/0000-0003-3385-972X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kamil Slowikowski (<a href="https://orcid.org/0000-0002-2843-6370">ORCID</a>) [contributor]
</p>
</li>
<li><p> Michał Krassowski (<a href="https://orcid.org/0000-0002-9638-7785">ORCID</a>) [contributor]
</p>
</li>
<li><p> Daniel Sabanés Bové [contributor]
</p>
</li>
<li><p> Stella Banjo [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Package 'ggplot2' documentation is available at
<a href="https://ggplot2.tidyverse.org/">https://ggplot2.tidyverse.org/</a><br /> Package 'ggplot2' source code at
<a href="https://github.com/tidyverse/ggplot2">https://github.com/tidyverse/ggplot2</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.r4photobiology.info/ggpp/">https://docs.r4photobiology.info/ggpp/</a>
</p>
</li>
<li> <p><a href="https://github.com/aphalo/ggpp">https://github.com/aphalo/ggpp</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/aphalo/ggpp/issues">https://github.com/aphalo/ggpp/issues</a>
</p>
</li></ul>


<hr>
<h2 id='annotate'>Annotations supporting NPC</h2><span id='topic+annotate'></span>

<h3>Description</h3>

<p>A revised version of <code>annotate()</code> from package 'ggplot2' adding support
for <code>npcx</code> and <code>npcy</code> position aesthetics, allowing use of the
geometries defined in the current package such as <code>geom_text_npc()</code>. It
also has a parameter <code>label</code> that directly accepts data frames, ggplots
and grobs as arguments in addition to objects of atomic classes like
character. When package 'ggpmisc' is loaded this definition of
<code>annotate()</code> overrides that in package 'ggplot2'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate(
  geom,
  x = NULL,
  y = NULL,
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  xend = NULL,
  yend = NULL,
  npcx = NULL,
  npcy = NULL,
  label = NULL,
  ...,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_+3A_geom">geom</code></td>
<td>
<p>character Name of geom to use for annotation.</p>
</td></tr>
<tr><td><code id="annotate_+3A_x">x</code>, <code id="annotate_+3A_y">y</code>, <code id="annotate_+3A_xmin">xmin</code>, <code id="annotate_+3A_ymin">ymin</code>, <code id="annotate_+3A_xmax">xmax</code>, <code id="annotate_+3A_ymax">ymax</code>, <code id="annotate_+3A_xend">xend</code>, <code id="annotate_+3A_yend">yend</code>, <code id="annotate_+3A_npcx">npcx</code>, <code id="annotate_+3A_npcy">npcy</code></td>
<td>
<p>numeric Positioning
aesthetics - you must specify at least one of these.</p>
</td></tr>
<tr><td><code id="annotate_+3A_label">label</code></td>
<td>
<p>character, data.frame, ggplot or grob.</p>
</td></tr>
<tr><td><code id="annotate_+3A_...">...</code></td>
<td>
<p>Other named arguments passed on to <code>layer()</code>. These are often
aesthetics, used to set an aesthetic to a fixed value, like color = &quot;red&quot;
or size = 3. They may also be parameters to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="annotate_+3A_na.rm">na.rm</code></td>
<td>
<p>logical If <code>FALSE</code>, the default, missing values are removed
with a warning. If TRUE, missing values are silently removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all position aesthetics are scaled (i.e., they will
expand the limits of the plot so they are visible), but all other
aesthetics are set. This means that layers created with this function will
never affect the legend.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Note</h3>

<p>To use the original definition of <code>annotate()</code> after loading
package 'ggpmisc', use <code>ggplot2::annotate()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()

# Works as ggplot2::annotate()
p + annotate("text", x = 5, y = 32, label = "Some text")
p + annotate("label", x = c(2, 5), y = c(15, 32),
             label = c("A", "B"))
p + annotate("table", x = 5, y = 30,
             label = data.frame(A = 1:2, B = letters[1:2]))
p + annotate("plot", x = 5.5, y = 34,
             label = p + theme_bw(9))
p + annotate("rect", xmin = 3, xmax = 4.2, ymin = 12, ymax = 21, alpha = .2)
p + annotate("segment", x = 2.5, xend = 4, y = 15, yend = 25, colour = "blue")
p + annotate("pointrange", x = 3.5, y = 20, ymin = 12, ymax = 28,
  colour = "red", size = 1.5)

# But ggpmisc::annotate() also works with npcx and npcy pseudo-aesthetics
p + annotate("label_npc", npcx = c(0.1, 0.9), npcy = c(0.1, 0.9),
             label = c("A", "B"))
p + annotate("label_npc", npcx = 0.9, npcy = c(0.1, 0.9),
             label = c("A", "B"))

p + annotate("text_npc", npcx = 0.9, npcy = 0.9, label = "Some text")
p + annotate("text_npc", npcx = "right", npcy = "top", label = "Some text")

p + annotate("table_npc", npcx = 0.9, npcy = 0.9,
             label = data.frame(A = 1:2, B = letters[1:2]))

p + annotate("plot_npc", npcx = 1, npcy = 1,
             label = p + theme_bw(9))
p + annotate("plot_npc", npcx = c(0, 1), npcy = c(0, 1),
             label = list(p + theme_bw(9), p + theme_grey(9)),
             vp.width = 0.3, vp.height = 0.4)

</code></pre>

<hr>
<h2 id='birch.df'>Birch seedlings' size</h2><span id='topic+birch.df'></span><span id='topic+birch_dw.df'></span>

<h3>Description</h3>

<p>A dataset containing the measurements on 350 birch seedlings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birch.df

birch_dw.df
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object with 350 rows and 8 variables.
</p>
<p>A <code>data.frame</code> object with 700 rows and 5 variables.
</p>


<h3>Details</h3>

<p>The data are for seedlings grown in trays with cells or containers
of two different volumes. For each of these types of trays, all cells, 1/2 of
the cells or 1/4 of the cells contained seedlings. Root-collar diameter (mm),
height (cm), dry mass (mg) of stems and roots. Measurements done at the end
of the first growing season, after leaf fall.
</p>


<h3>References</h3>

<p>Aphalo, P. J. and Rikala, R. (2003) Field performance of
silver-birch planting-stock grown at different spacing and in containers of
different volume. <em>New Forests</em>, 25:93-108. <a href="https://doi.org/10.1023/A%3A1022618810937">doi:10.1023/A:1022618810937</a>.
</p>


<h3>See Also</h3>

<p>Other Plant growth and morphology data: 
<code><a href="#topic+ivy.df">ivy.df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colnames(birch.df)
head(birch.df)

colnames(birch_dw.df)
head(birch_dw.df)

</code></pre>

<hr>
<h2 id='compute_npcx'>Compute npc coordinates</h2><span id='topic+compute_npcx'></span><span id='topic+compute_npcy'></span>

<h3>Description</h3>

<p>Convert character-encoded positions to npc units and shift positions to
avoid overlaps when grouping is active. If numeric, validate npc values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_npcx(x, group = 1L, h.step = 0.1, margin.npc = 0.05, each.len = 1)

compute_npcy(y, group = 1L, v.step = 0.1, margin.npc = 0.05, each.len = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_npcx_+3A_x">x</code></td>
<td>
<p>numeric or if character, one of &quot;right&quot;, &quot;left&quot;, &quot;centre&quot;,
&quot;center&quot; or &quot;middle&quot;.</p>
</td></tr>
<tr><td><code id="compute_npcx_+3A_group">group</code></td>
<td>
<p>integer vector, ggplot's group id. Used to shift coordinates to
avoid overlaps.</p>
</td></tr>
<tr><td><code id="compute_npcx_+3A_h.step">h.step</code>, <code id="compute_npcx_+3A_v.step">v.step</code></td>
<td>
<p>numeric [0..1] The step size for shifting coordinates
in npc units. Usually &lt;&lt; 1.</p>
</td></tr>
<tr><td><code id="compute_npcx_+3A_margin.npc">margin.npc</code></td>
<td>
<p>numeric [0..1] The margin added towards the nearest
plotting area edge when converting character coordinates into npc. Usually
&lt;&lt; 1.</p>
</td></tr>
<tr><td><code id="compute_npcx_+3A_each.len">each.len</code></td>
<td>
<p>integer The number of steps per group.</p>
</td></tr>
<tr><td><code id="compute_npcx_+3A_y">y</code></td>
<td>
<p>numeric or if character, one of &quot;top&quot;, &quot;bottom&quot;, &quot;centre&quot;,
&quot;center&quot; or &quot;middle&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use NPC (normalized plot coordinates) instead of
data coordinates. They translate named positions into numeric values in
[0..1] and they can also shift the position according to the group, e.g.,
for each increase in the group number displace the position inwards or
outwards, by a user-supplied distance. They make it possible to set
automatically set default positions for grouped text labels.
</p>
<p>Out of bounds numeric values are constrained to [0..1]. Unrecognized
character values are silently converted into <code>NA_integer_</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with values in the range [0..1] representing
npc coordinates.
</p>


<h3>Note</h3>

<p>These functions are used by several layer functions in packages
'ggpp' and 'ggpmisc', and can be useful to developers of other 'ggplot2'
extensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_npcx("right")
compute_npcx(c("left", "right"))
compute_npcy("bottom")
compute_npcy("bottom", group = 1L:3L)
compute_npcy("bottom", group = 2L)
compute_npcx(0.5)
compute_npcx(1)

</code></pre>

<hr>
<h2 id='dark_or_light'>Chose between dark and light color</h2><span id='topic+dark_or_light'></span>

<h3>Description</h3>

<p>Chose between a pair of contrasting dark and light colors based on a weighted
mean of RGB channels of a color. This function implements a simple approach
to the choice for a color of a plot element to ensure it is visible against a
background color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dark_or_light(
  colors,
  threshold = 0.45,
  dark.color = "black",
  light.color = "white"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dark_or_light_+3A_colors">colors</code></td>
<td>
<p>A vector of color definitions or color names in the background.</p>
</td></tr>
<tr><td><code id="dark_or_light_+3A_threshold">threshold</code></td>
<td>
<p>numeric A value of luminance in [0..1] indicating the switch
point between dark and light background.</p>
</td></tr>
<tr><td><code id="dark_or_light_+3A_dark.color">dark.color</code>, <code id="dark_or_light_+3A_light.color">light.color</code></td>
<td>
<p>A color definition or color name to return as
dark and light colors to contrast light and dark backgrounds respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The switch between dark and light color is based on a quick and
dirty approximation of the luminance of colors computed from RGB values.
This easily computed approximation seems to work well enough. The default
threshold chosen for a switch between black and white may need to be
adjusted for other pairs of colors. Graphic devices can differ in the color
spaces they support, but this is unlikely to affect the choice between
black and white or other pairs of colors with large differences in
luminance.
</p>


<h3>Note</h3>

<p>The current implementation of <code>dark_or_light()</code> ignores
<code>alpha</code>, the transparency component, of all its arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dark_or_light("yellow")
dark_or_light("darkblue")
dark_or_light(c("darkblue", "yellow", "red"))
dark_or_light("#FFFFFF")
dark_or_light("#FFFFFF", dark.color = "darkblue", light.color = "lightgrey")
dark_or_light("#000000", dark.color = "darkblue", light.color = "lightgrey")

</code></pre>

<hr>
<h2 id='geom_grob'>Inset graphical objects</h2><span id='topic+geom_grob'></span><span id='topic+geom_grob_npc'></span>

<h3>Description</h3>

<p><code>geom_grob</code> and <code>geom_grob_npc</code> add Grobs as insets to the ggplot
using syntax similar to that of <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code>,
<code><a href="#topic+geom_text_s">geom_text_s</a></code> and <code><a href="#topic+geom_text_npc">geom_text_npc</a></code>.
In most respects they behave as any other ggplot geometry: they add a layer
containing one or more grobs and grouping and faceting works as usual. The
most common use of <code>geom_grob</code> is to add data labels that are graphical
objects rather than text. <code><a href="#topic+geom_grob_npc">geom_grob_npc</a></code> is used to add grobs
as annotations to plots, but contrary to layer function <code>annotate()</code>,
<code><a href="#topic+geom_grob_npc">geom_grob_npc</a></code> is data driven and respects grouping and facets,
thus plot insets can differ among panels. Of these two geoms only
<code><a href="#topic+geom_grob">geom_grob</a></code> supports the plotting of segments, as
<code><a href="#topic+geom_grob_npc">geom_grob_npc</a></code> uses a coordinate system that is unrelated
to data units and data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_grob(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "segment",
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "segment",
  add.segments = TRUE,
  box.padding = 0.25,
  point.padding = 1e-06,
  segment.linewidth = 0.5,
  min.segment.length = 0,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_grob_npc(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_grob_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_nudge_x">nudge_x</code>, <code id="geom_grob_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_default.colour">default.colour</code>, <code id="geom_grob_+3A_default.color">default.color</code></td>
<td>
<p>A colour definition to use for elements not targeted by
the colour aesthetic.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_colour.target">colour.target</code>, <code id="geom_grob_+3A_color.target">color.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"box"</code> and <code>"segment"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_default.alpha">default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_alpha.target">alpha.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_add.segments">add.segments</code></td>
<td>
<p>logical Display connecting segments or arrows between
original positions and displaced ones if both are available.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_box.padding">box.padding</code>, <code id="geom_grob_+3A_point.padding">point.padding</code></td>
<td>
<p>numeric By how much each end of the segments
should shortened in mm.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_segment.linewidth">segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_min.segment.length">min.segment.length</code></td>
<td>
<p>numeric Segments shorter that the minimum length
are not rendered, in mm.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code><a href="grid.html#topic+arrow">arrow</a></code></p>
</td></tr>
<tr><td><code id="geom_grob_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_grob_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can modify the size of insets with the <code>vp.width</code> and
<code>vp.height</code> aesthetics. These can take a number between 0 (smallest
possible inset) and 1 (whole plotting area width or height). The default
value for for both of these aesthetics is 1/5. Thus, in contrast to
<code><a href="ggplot2.html#topic+geom_text">geom_text</a></code>, <code><a href="ggplot2.html#topic+geom_label">geom_label</a></code>,
<code><a href="#topic+geom_text_s">geom_text_s</a></code> and <code><a href="#topic+geom_label_s">geom_label_s</a></code> the size of the
insets remains the same relative to the size of the plotting area
irrespective of the size the plot is rendered at. The aspect ratio of
insets is preserved and size is adjusted until the whole inset fits within
the viewport.
</p>
<p>By default <code>geom_grob</code> uses <code><a href="#topic+position_nudge_center">position_nudge_center</a></code> and
justification <code>"position"</code>, while <code>geom_grob_npc</code> uses
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code> and justification <code>"inward"</code>. In
contrast to <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a></code> and all other position functions
defined in packages 'ggpp' keep the original coordinates thus allowing the
plotting of connecting segments and arrows.
</p>
<p>This <code>geom_grob</code> and <code>geom_grob_npc</code> require the use tibbles as
argument for <code>data</code>, as the grobs should be stored as a list of
graphics objects (&quot;grob&quot;) to be mapped to the <code>label</code> aesthetic.
</p>
<p>The <code>x</code> and <code>y</code> aesthetics determine the position of the whole
inset grob, similarly to that of a text label, justification is interpreted
as indicating the position of the grob with respect to its <em>x</em> and
<em>y</em> coordinates in the data, and <code>angle</code> is used to rotate the
grob as a whole.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Plot boundaries and clipping</h3>

<p>The &quot;width&quot; and &quot;height&quot; of an inset
as for a text element are 0, so stacking and dodging inset plots will not
work by default, and axis limits are not automatically expanded to include
all inset plots. Obviously, insets do have height and width, but they are
physical units, not data units. The amount of space they occupy on the main
plot is not constant in data units of the base plot: when you modify scale
limits, inset plots stay the same size relative to the physical size of the
base plot.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Position functions</h3>

<p>Many layer functions from package 'ggpp' are
designed to work seamlessly with position functions that keep, rather than
discard, the original <code>x</code> and <code>y</code> positions in <code>data</code> when
computing a new displaced position. See <code><a href="#topic+position_nudge_keep">position_nudge_keep</a></code>,
<code><a href="#topic+position_dodge_keep">position_dodge_keep</a></code>, <code><a href="#topic+position_jitter_keep">position_jitter_keep</a></code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a></code>, <code><a href="#topic+position_nudge_line">position_nudge_line</a></code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a></code>, <code><a href="#topic+position_dodgenudge">position_dodgenudge</a></code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a></code>, and <code><a href="#topic+position_stacknudge">position_stacknudge</a></code>
for examples and details of their use.
</p>


<h3>Note</h3>

<p>The insets are stored nested within the main ggplot object and
contain their own copy of the data, and are rendered as grid grobs as normal
ggplots at the time the main ggplot is rendered. They can have different
themes.
</p>
<p>Use <code><a href="#topic+annotate">annotate</a></code> as redefined in 'ggpp' when adding insets
as annotations (automatically available unless 'ggpp' is not attached).
<code><a href="ggplot2.html#topic+annotate">annotate</a></code> cannot be used with the <code>npcx</code> and
<code>npcy</code> pseudo-aesthetics.
</p>


<h3>References</h3>

<p>The idea of implementing a <code>geom_custom()</code> for grobs has
been discussed as an issue at
<a href="https://github.com/tidyverse/ggplot2/issues/1399">https://github.com/tidyverse/ggplot2/issues/1399</a>.
</p>


<h3>See Also</h3>

<p><code><a href="grid.html#topic+grid-package">grid-package</a></code>, <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code>,
and other documentation of package 'ggplot2'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
df &lt;- tibble(x = 2, y = 15, grob = list(grid::circleGrob(r = 0.2)))

# without nudging no segments are drawn
ggplot(data = mtcars,
       aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl))) +
  geom_grob(data = df,
            aes(x, y, label = grob))

# with nudging segments are drawn
ggplot(data = mtcars,
       aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl))) +
  geom_grob(data = df,
            aes(x, y, label = grob),
            nudge_x = 0.5,
            colour = "red",
            hjust = 0.5,
            vjust = 0.5)

ggplot(data = mtcars,
       aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl))) +
  geom_grob(data = df,
            aes(x, y, label = grob),
            nudge_x = 0.5,
            colour = "red",
            colour.target = "none",
            hjust = 0.5,
            vjust = 0.5)

# with nudging plotting of segments can be disabled
ggplot(data = mtcars,
       aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl))) +
  geom_grob(data = df,
            aes(x, y, label = grob),
            add.segments = FALSE,
            nudge_x = 0.5,
            hjust = 0.5,
            vjust = 0.5)

</code></pre>

<hr>
<h2 id='geom_label_npc'>Text with Normalised Parent Coordinates</h2><span id='topic+geom_label_npc'></span><span id='topic+geom_text_npc'></span>

<h3>Description</h3>

<p><code>geom_text_npc()</code> adds text directly to the plot.
<code>geom_label_npc()</code> draws a rectangle behind the text, making it easier
to read. The difference is that <code>x</code> and <code>y</code> mappings are expected
to be given in <code>npc</code> graphic units, using pseudo-aesthetics. Their
intended use is to add annotations to a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_label_npc(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = grid::unit(0.25, "lines"),
  label.r = grid::unit(0.15, "lines"),
  label.size = 0.25,
  size.unit = "mm",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_text_npc(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_label_npc_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs
to be set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_data">data</code></td>
<td>
<p>A layer specific data set - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_parse">parse</code></td>
<td>
<p>If TRUE, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_nudge_x">nudge_x</code>, <code id="geom_label_npc_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_size.unit">size.unit</code></td>
<td>
<p>How the 'size' aesthetic is interpreted: as millimetres
('&quot;mm&quot;', default), points ('&quot;pt&quot;'), centimetres ('&quot;cm&quot;'), inches ('&quot;in&quot;'),
or picas ('&quot;pc&quot;').</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_label_npc_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If 'TRUE', text that overlaps previous text in the same
layer will not be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These geoms are identical to 'ggplot2'
<code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> and <code><a href="ggplot2.html#topic+geom_label">geom_label</a></code>
except that they interpret <code>npcx</code> and <code>npcy</code> positions in
<code>npc</code> units. They translate <code>npcx</code> and <code>npcy</code> coordinates
using a pseudo-aesthetic with a fixed scale, the translation is done
separately for each plot panel. All aesthetics other than <em>x</em> and
<em>y</em> and grouping work as in normal geoms. These include
<code>linetype</code> and <code>angle</code> in <code>geom_label_npc()</code>.
</p>


<h3>Alignment</h3>

<p>With textual positions and groups a shift is added to
successive labels to avoid overlaps. The shift is based on grouping,
however unused levels are not dropped. In plots with faceting, if not
all groups appear in each panel, there will be blank spaces in between
labels. To solve this pass numeric values for the npc coordinates of each
label instead of character strings.
</p>
<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Plot boundaries and clipping</h3>

<p>Note that when you change the scale
limits for <em>x</em> and/or <em>y</em> of a plot, text labels stay the same
size, as determined by the <code>size</code> aesthetic, given in millimetres. The
actual size as seen in the plotted output is decided during the rendering
of the plot to a graphics device. Limits are expanded only to include the
anchor point of the labels because the &quot;width&quot; and &quot;height&quot; of a text
element are 0 (as seen by ggplot2). Text labels do have height and width,
but in grid units, not data units.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> and
<code><a href="ggplot2.html#topic+geom_label">geom_label</a></code> for additional details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
  x = c(0, 0, 1, 1, 0.5),
  x.chr = c("left", "left", "right", "right", "center"),
  y = c(0, 1, 0, 1, 0.5),
  y.chr = c("bottom", "top", "bottom", "top", "middle"),
  text = c("bottom-left", "top-left", "bottom-right", "top-right", "center-middle")
)

ggplot(df) +
  geom_text_npc(aes(npcx = x, npcy = y, label = text))

ggplot(df) +
  geom_text_npc(aes(npcx = x.chr, npcy = y.chr, label = text))

ggplot(df) +
  geom_text_npc(aes(npcx = x.chr, npcy = y.chr, label = text),
                angle = 90)

ggplot(data = mtcars, mapping = aes(wt, mpg)) +
  geom_point() +
  geom_text_npc(data = df, aes(npcx = x, npcy = y, label = text))

ggplot(data = mtcars, mapping = aes(wt, mpg)) +
  geom_point() +
  geom_text_npc(data = df, aes(npcx = x, npcy = y, label = text)) +
  expand_limits(y = 40, x = 6)

ggplot(data = mtcars) +
  geom_point(mapping = aes(wt, mpg)) +
  geom_label_npc(data = df, aes(npcx = x, npcy = y, label = text))

ggplot(data = mtcars) +
  geom_point(mapping = aes(wt, mpg)) +
  geom_label_npc(data = df, aes(npcx = x.chr, npcy = y.chr, label = text),
                 angle = 90) # ignored by ggplot2 &lt; 3.5.0

</code></pre>

<hr>
<h2 id='geom_label_pairwise'>Label pairwise comparisons</h2><span id='topic+geom_label_pairwise'></span><span id='topic+geom_text_pairwise'></span>

<h3>Description</h3>

<p>Add a plot layer with a text label and a segment connecting two
values along the <code>x</code> aesthetic. These are usually two levels of a
factor mapped to the <code>x</code> aesthetic when used to report significance or
highlighting pairwise comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_label_pairwise(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "all",
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "segment",
  label.padding = grid::unit(0.25, "lines"),
  label.r = grid::unit(0.15, "lines"),
  segment.linewidth = 0.5,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_text_pairwise(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "all",
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "all",
  segment.linewidth = 0.5,
  arrow = NULL,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_label_pairwise_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by
<code><a href="ggplot2.html#topic+aes">aes</a></code>. With <code>inherit.aes = FALSE</code>
(the default) it is not combined with the default mapping at the top level of
the plot. You always need to supply a <code>mapping</code> unless you set
<code>inherit.aes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_data">data</code></td>
<td>
<p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. There
are three types of arguments you can use here:
</p>
 <ul>
<li><p> Aesthetics: to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. </p>
</li>
<li><p> Other arguments to the
layer, for example you override the default <code>stat</code> associated with the
layer. </p>
</li>
<li><p> Other arguments passed on to the stat. </p>
</li></ul>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_nudge_x">nudge_x</code>, <code id="geom_label_pairwise_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_default.colour">default.colour</code>, <code id="geom_label_pairwise_+3A_default.color">default.color</code></td>
<td>
<p>A colour definition to use for elements
not targeted by the colour aesthetic.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_colour.target">colour.target</code>, <code id="geom_label_pairwise_+3A_color.target">color.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_default.alpha">default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_alpha.target">alpha.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_segment.linewidth">segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code><a href="grid.html#topic+arrow">arrow</a></code></p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code> includes a legend if any aesthetics are mapped.
<code>FALSE</code>, the default, never includes it, and <code>TRUE</code> always includes it.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining them.</p>
</td></tr>
<tr><td><code id="geom_label_pairwise_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> takes place at draw
time and in the order of the data, thus its action depends of the size at
which the plot is drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geometries <code>geom_text_pairwise()</code> and
<code>geom_label_pairwise()</code> have an interface similar to that of
<code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> and <code><a href="ggplot2.html#topic+geom_label">geom_label</a></code>, but
add a segment connecting two values along <code>x</code>. In the most
frequent use case they add a segment connecting pairs of levels from a
grouping factor mapped to the <em>x</em> or <em>y</em> aesthetic. They can
also be used to label ranges of values.
</p>
<p>The segment extends from <code>xmin</code> to <code>xmax</code>, and the text label is
located at <code>x</code> with a default that positions the label at the centre
of the bar. The ends of the bar can be terminated with arrow heads given
by parameter <code>arrow</code>, with a default of a plain segment without
arrow tips. The text label is located slightly above the segment by the
default value of <code>vjust</code> in <code>geom_text_pairwise()</code> and on top
of the segment in <code>geom_label_pairwise()</code>.
</p>
<p>Layer functions <code>geom_text_pairwise()</code> and
<code>geom_label_pairwise()</code> use by default
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>. Nudging affects both text label and
bar, and its default of no displacement will very rarely need to be
changed.
</p>
<p>Differently to <code>geom_text_repel()</code> and <code>geom_label_repel()</code>,
<code>geom_text_pairwise()</code> and <code>geom_label_pairwise()</code> do not make
use of additional aesthetics for the segments or boxes, but instead allow
the choice of which elements are targeted by the usual 'ggplot2' aesthetics
and which are rendered using a default constant value. In the grammar of
graphics using the same aesthetic with multiple meanings is not allowed,
thus, the approach used in package 'ggpp' attempts to enforce this.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Under development!</h3>

<p>This geometry is still under development
and its user interface subject to change.
</p>


<h3>Plot boundaries and clipping</h3>

<p>Note that when you change the scale
limits for <em>x</em> and/or <em>y</em> of a plot, text labels stay the same
size, as determined by the <code>size</code> aesthetic, given in millimetres. The
actual size as seen in the plotted output is decided during the rendering
of the plot to a graphics device. Limits are expanded only to include the
anchor point of the labels because the &quot;width&quot; and &quot;height&quot; of a text
element are 0 (as seen by ggplot2). Text labels do have height and width,
but in grid units, not data units. Either function
<code><a href="ggplot2.html#topic+expand_limits">expand_limits</a></code> or the scale expansion can be used to
ensure text labels remain within the plotting area.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). Values outside the range 0..1 displace the text label so
that the anchor point is outside the text label. In addition, you can use
special alignments for justification including <code>"position"</code>,
<code>"inward"</code> and <code>"outward"</code>. Inward always aligns text towards the
center of the plotting area, and outward aligns it away from the center of
the plotting area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"identity"</code>.
</p>


<h3>Aesthetics</h3>

<p>Layer functions <code>geom_text_pairwise()</code> and
<code>geom_label_pairwise()</code> require aesthetics <code>xmin</code>, <code>xmax</code>,
<code>x</code>, <code>y</code> and
<code>label</code> and support aesthetics: <code>alpha</code>, <code>colour</code>,
<code>group</code>, <code>size</code> (of text), <code>family</code>, <code>fontface</code>,
<code>linewidth</code>, <code>linetype</code>, <code>hjust</code> and <code>vjust</code>. In addition,
<code>geom_text_pairwise</code> supports <code>angle</code> and <code>geom_label_pairwise</code> supports
<code>fill</code>. See
<code><a href="ggplot2.html#topic+aes_colour_fill_alpha">aes_colour_fill_alpha</a></code>,
<code><a href="ggplot2.html#topic+aes_linetype_size_shape">aes_linetype_size_shape</a></code>,
<code><a href="ggplot2.html#topic+aes_position">aes_position</a></code>, and
<code><a href="ggplot2.html#topic+aes_group_order">aes_group_order</a></code>.
</p>
<p>In 'ggplot2' <code>linewidth</code> when applied to the border of the box drawn
by <code>geom_label()</code> is given in points rather than in mm because of a
historical error in the code. In other geometries such as
<code>geom_segment()</code> <code>linewidth</code> is given in mm. As in
<code>geom_label_pairwise()</code> it is important to remain consistent among
different <code>linewidth</code> specifications, mm are used both for the box
border and linking segment. To imitate the behaviour of <code>geom_label()</code>
a correction factor of 0.75 (more exactly 1 pt = 0.7528 mm) can be used for
the line width of the border of the box.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_text_s">geom_text_s</a></code>, <code><a href="#topic+geom_label_s">geom_label_s</a></code>,
<code><a href="ggplot2.html#topic+geom_text">geom_text</a></code>, <code><a href="ggplot2.html#topic+geom_label">geom_label</a></code> and
other documentation of package 'ggplot2'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.cars &lt;- mtcars
my.cars$name &lt;- rownames(my.cars)
p1 &lt;- ggplot(my.cars, aes(factor(cyl), mpg)) +
       geom_boxplot(width = 0.33)

# With a factor mapped to x, highlight pairs

my.pairs &lt;-
  data.frame(A = 1:2, B = 2:3, bar.height = c(12, 30),
             p.value = c(0.01, 0.05678))
p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = p.value),
                     parse = TRUE)

p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = sprintf("italic(P)~`=`~%.2f", p.value)),
                     arrow = grid::arrow(angle = 90,
                                         length = unit(1, "mm"),
                                         ends = "both"),
                     parse = TRUE)

p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = sprintf("italic(P)~`=`~%.2f", p.value)),
                     colour = "red",
                     arrow = grid::arrow(angle = 90,
                                         length = unit(1, "mm"),
                                         ends = "both"),
                     parse = TRUE)

p1 +
  geom_label_pairwise(data = my.pairs,
                      aes(xmin = A, xmax = B,
                          y = bar.height,
                          label = sprintf("italic(P)~`=`~%.2f", p.value)),
                      colour = "red", size = 2.75,
                      arrow = grid::arrow(angle = 30,
                                          length = unit(1.5, "mm"),
                                          ends = "both"),
                      parse = TRUE)

p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = sprintf("italic(P)~`=`~%.2f", p.value)),
                     colour = "red", colour.target = "segment",
                     arrow = grid::arrow(angle = 90,
                                         length = unit(1, "mm"),
                                         ends = "both"),
                     parse = TRUE)

p1 +
  geom_text_pairwise(data = my.pairs,
                     aes(xmin = A, xmax = B,
                         y = bar.height,
                         label = sprintf("italic(P)~`=`~%.2f", p.value)),
                     colour = "red", colour.target = "text",
                     arrow = grid::arrow(angle = 90,
                                         length = unit(1, "mm"),
                                         ends = "both"),
                     parse = TRUE)

# with a numeric vector mapped to x, indicate range

p2 &lt;-
  ggplot(my.cars, aes(disp, mpg)) +
    geom_point()

my.ranges &lt;-
  data.frame(A = c(50, 400),
             B = c(200, 500),
             bar.height = 5,
             text = c("small", "large"))

p2 +
  geom_text_pairwise(data = my.ranges,
                     aes(xmin = A, xmax = B,
                     y = bar.height, label = text))

p2 +
  geom_text_pairwise(data = my.ranges,
                     aes(xmin = A, xmax = B,
                         y = bar.height, label = text),
                     angle = 90, hjust = -0.1)

p2 +
  geom_label_pairwise(data = my.ranges,
                      aes(xmin = A, xmax = B,
                          y = bar.height, label = text),
                     angle = 90, hjust = -0.1)

p2 +
  geom_label_pairwise(data = my.ranges,
                      aes(xmin = A, xmax = B,
                          y = bar.height, label = text))

p2 +
  geom_text_pairwise(data = my.ranges,
                     aes(xmin = A, xmax = B,
                         y = bar.height, label = text),
                     arrow = grid::arrow(ends = "both", length = unit(2, "mm")))

</code></pre>

<hr>
<h2 id='geom_label_s'>Linked Text</h2><span id='topic+geom_label_s'></span><span id='topic+geom_text_s'></span>

<h3>Description</h3>

<p>Linked text geometries are most useful for adding data labels to
plots. 'geom_text_s()' and 'geom_label_s()' add text to the plot and for
nudged positions link the original location to the nudged text with a
segment or arrow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_label_s(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = c("text", "box"),
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "all",
  label.padding = grid::unit(0.25, "lines"),
  label.r = grid::unit(0.15, "lines"),
  segment.linewidth = 0.5,
  add.segments = TRUE,
  box.padding = 1e-06,
  point.padding = 1e-06,
  min.segment.length = 0,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_text_s(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "text",
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "all",
  add.segments = TRUE,
  box.padding = 0.25,
  point.padding = 1e-06,
  segment.linewidth = 0.5,
  min.segment.length = 0,
  arrow = NULL,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_label_s_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by
<code><a href="ggplot2.html#topic+aes">aes</a></code>. If specified and with <code>inherit.aes = TRUE</code>
(the default), it is combined with the default mapping at the top level of
the plot. You only need to supply <code>mapping</code> if there isn't a mapping
defined for the plot.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_data">data</code></td>
<td>
<p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. There
are three types of arguments you can use here:
</p>
 <ul>
<li><p> Aesthetics: to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. </p>
</li>
<li><p> Other arguments to the
layer, for example you override the default <code>stat</code> associated with the
layer. </p>
</li>
<li><p> Other arguments passed on to the stat. </p>
</li></ul>
</td></tr>
<tr><td><code id="geom_label_s_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_nudge_x">nudge_x</code>, <code id="geom_label_s_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_default.colour">default.colour</code>, <code id="geom_label_s_+3A_default.color">default.color</code></td>
<td>
<p>A colour definition to use for elements not targeted by
the colour aesthetic.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_colour.target">colour.target</code>, <code id="geom_label_s_+3A_color.target">color.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_default.alpha">default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_alpha.target">alpha.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_segment.linewidth">segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_add.segments">add.segments</code></td>
<td>
<p>logical Display connecting segments or arrows between
original positions and displaced ones if both are available.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_box.padding">box.padding</code>, <code id="geom_label_s_+3A_point.padding">point.padding</code></td>
<td>
<p>numeric By how much each end of the segments
should shortened in mm.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_min.segment.length">min.segment.length</code></td>
<td>
<p>numeric Segments shorter that the minimum length
are not rendered, in mm.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code><a href="grid.html#topic+arrow">arrow</a></code></p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes a legend if any aesthetics are mapped.
<code>FALSE</code> never includes it, and <code>TRUE</code> always includes it.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining them. This is most useful for helper functions that define
both data and aesthetics and shouldn't inherit behaviour from the default
plot specification, e.g., <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_label_s_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> takes place at draw
time and in the order of the data, thus its action depends of the size at
which the plot is drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geometries <code>geom_text_s()</code> and <code>geom_label_s()</code> have an
interface similar to that of <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> and
<code><a href="ggplot2.html#topic+geom_label">geom_label</a></code>, but support additional features.
Similarly to <code>geom_text_repel()</code> and <code>geom_label_repel()</code> when
used together with position functions defined in package 'ggpp' they draw a
segment linking the label at a displaced position to the original position,
usually a point corresponding to an observation to which the label refers.
Another difference is that they allow control of to which graphical
elements the mappings to colour and alpha aesthetics are applied.
Differently to <code>geom_label()</code>, <code>geom_label_s()</code> obeys aesthetic
mappings to <code>linewidth</code> and <code>linetype</code> applied to the line at the
edge of the label box.
</p>
<p>Layer functions <code>geom_text_s()</code> and <code>geom_label_s()</code> use by
default <code><a href="#topic+position_nudge_keep">position_nudge_keep</a></code> which is backwards compatible
with <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>. In contrast to
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>, <code><a href="#topic+position_nudge_keep">position_nudge_keep</a></code>
and all other position functions defined in packages 'ggpp' and 'ggrepel'
keep the original coordinates, thus allowing the plotting of connecting
segments and arrows.
</p>
<p>Differently to <code>geom_text_repel()</code> and <code>geom_label_repel()</code>,
<code>geom_text_s()</code> and <code>geom_label_s()</code> do not make use of
additional aesthetics for the segments or boxes, but instead allow the
choice of which elements are targeted by the aesthetics and which are
rendered in a default colour. In the grammar of graphics using the same
aesthetic with multiple meanings is not allowed, thus, the approach used in
our geoms attempts to enforce this.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Under development!</h3>

<p>These two geometries are still under development
and their user interface subject to change. In 'ggpp' (== 0.5.0) support
for aesthetics related to segments was removed, and replaced with
parameters and a new mechanism for targeting a the usual aesthetics to
text, border, and segment was added.
</p>


<h3>Plot boundaries and clipping</h3>

<p>Note that when you change the scale
limits for <em>x</em> and/or <em>y</em> of a plot, text labels stay the same
size, as determined by the <code>size</code> aesthetic, given in millimetres. The
actual size as seen in the plotted output is decided during the rendering
of the plot to a graphics device. Limits are expanded only to include the
anchor point of the labels because the &quot;width&quot; and &quot;height&quot; of a text
element are 0 (as seen by ggplot2). Text labels do have height and width,
but in grid units, not data units.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Aesthetics</h3>

<p>Layer functions <code>geom_text_s()</code> and
<code>geom_label_s()</code> require aesthetics <code>x</code>, <code>y</code> and
<code>label</code> and support aesthetics: <code>alpha</code>, <code>colour</code>,
<code>group</code>, <code>size</code> (of text), <code>family</code>, <code>fontface</code>,
<code>lineheight</code>, <code>hjust</code> and <code>vjust</code>. In addition,
<code>geom_text_s</code> supports <code>angle</code> and <code>geom_label_s</code> supports
<code>fill</code>, <code>linewidth</code> and <code>linetype</code>. See
<code><a href="ggplot2.html#topic+aes_colour_fill_alpha">aes_colour_fill_alpha</a></code>,
<code><a href="ggplot2.html#topic+aes_linetype_size_shape">aes_linetype_size_shape</a></code>,
<code><a href="ggplot2.html#topic+aes_position">aes_position</a></code>, and
<code><a href="ggplot2.html#topic+aes_group_order">aes_group_order</a></code>.
</p>
<p>In 'ggplot2' <code>linewidth</code> when applied to the border of the box drawn
by <code>geom_label()</code> is given in points rather than in mm because of a
historical error in the code. In other geometries such as
<code>geom_segment()</code> <code>linewidth</code> is given in mm. As in
<code>geom_label_s()</code> it is important to remain consistent among
different <code>linewidth</code> specifications, mm are used both for the box
border and linking segment. To imitate the behaviour of <code>geom_label()</code>
a correction factor of 0.75 (more exactly 1 pt = 0.7528 mm) can be used for
the line width of the border of the box.
</p>


<h3>Position functions</h3>

<p>Many layer functions from package 'ggpp' are
designed to work seamlessly with position functions that keep, rather than
discard, the original <code>x</code> and <code>y</code> positions in <code>data</code> when
computing a new displaced position. See <code><a href="#topic+position_nudge_keep">position_nudge_keep</a></code>,
<code><a href="#topic+position_dodge_keep">position_dodge_keep</a></code>, <code><a href="#topic+position_jitter_keep">position_jitter_keep</a></code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a></code>, <code><a href="#topic+position_nudge_line">position_nudge_line</a></code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a></code>, <code><a href="#topic+position_dodgenudge">position_dodgenudge</a></code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a></code>, and <code><a href="#topic+position_stacknudge">position_stacknudge</a></code>
for examples and details of their use.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_text">geom_text</a></code>, <code><a href="ggplot2.html#topic+geom_label">geom_label</a></code>
and other documentation of package 'ggplot2'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
my.cars &lt;- mtcars[c(TRUE, FALSE, FALSE, FALSE), ]
my.cars$name &lt;- rownames(my.cars)
p &lt;- ggplot(my.cars, aes(wt, mpg, label = name)) +
       geom_point(color = "red")

# Use nudging
p +
  geom_text_s(nudge_x = 0.12) +
  expand_limits(x = 6.2)
p +
  geom_text_s(nudge_x = -0.12) +
  expand_limits(x = 1.5)
p +
  geom_text_s(nudge_x = 0.12,
              arrow = arrow(length = grid::unit(1.5, "mm"))) +
  expand_limits(x = 6.2)
p +
  geom_text_s(nudge_x = 0.12,
              arrow = arrow(length = grid::unit(1.5, "mm")),
              point.padding = 0.4) +
  expand_limits(x = 6.2)
p +
  geom_text_s(hjust = "left", nudge_x = 0.12) +
  expand_limits(x = 6.2)
p +
  geom_text_s(nudge_y = 0.1, nudge_x = 0.07) +
  expand_limits(x = 6.2)
p +
  geom_text_s(nudge_y = 1, angle = 90) +
  expand_limits(y = 30)
p +
  geom_text_s(angle = 90, nudge_y = 1,
              arrow = arrow(length = grid::unit(1.5, "mm")),
              colour.target = "segment", colour = "red") +
  expand_limits(y = 30)
p +
  geom_text_s(angle = 90, nudge_y = 1,
              arrow = arrow(length = grid::unit(1.5, "mm")),
              alpha.target = "segment", alpha = 0.3) +
  expand_limits(y = 30)

p +
  geom_label_s(nudge_x = 0.12) +
  expand_limits(x = 6.2)
p +
  geom_label_s(nudge_x = 0.12, linetype = "dotted", linewidth = 0.4) +
  expand_limits(x = 6.2)
p +
  geom_label_s(nudge_x = 0.12, linewidth = 0.5, label.r = unit(0, "lines")) +
  expand_limits(x = 6.2)
p +
  geom_label_s(nudge_x = 0.12, linewidth = 0) +
  expand_limits(x = 6.2)

# Nudging away from arbitrary point
p +
  geom_label_s(hjust = "outward_1", nudge_x = 0.12) +
  expand_limits(x = 6.2)
p +
  geom_label_s(hjust = "inward_3", nudge_y = 0.4)

p +
  geom_label_s(nudge_y = 1, angle = 90) +
  expand_limits(y = 30)

# Add aesthetic mappings and adjust arrows
p +
  geom_text_s(aes(colour = factor(cyl)),
              angle = 90,
              nudge_y = 1,
              arrow = arrow(angle = 20,
                            length = grid::unit(1.5, "mm"),
                            ends = "first",
                            type = "closed"),
              show.legend = FALSE) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(y = 27)

p +
  geom_text_s(aes(colour = factor(cyl)),
              colour.target = "text",
              angle = 90,
              nudge_y = 1,
              arrow = arrow(angle = 20,
                            length = grid::unit(1.5, "mm"),
                            ends = "first",
                            type = "closed"),
              show.legend = FALSE) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(y = 27)

p +
  geom_label_s(aes(colour = factor(cyl)),
              nudge_x = 0.3,
              arrow = arrow(angle = 20,
                            length = grid::unit(1/3, "lines"))) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(x = 7)

p +
  geom_label_s(aes(colour = factor(cyl)),
              nudge_x = 0.3,
              colour.target = c("box", "segment"),
              linewidth = 0.6,
              arrow = arrow(angle = 20,
                            length = grid::unit(1/3, "lines"))) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(x = 7)

p +
  geom_label_s(aes(colour = factor(cyl), fill = factor(cyl)),
              nudge_x = 0.3,
              alpha.target = "box",
              alpha = 0.1,
              linewidth = 0.5,
              arrow = arrow(angle = 20,
                            length = grid::unit(1/3, "lines"))) +
  scale_colour_discrete(l = 40) + # luminance, make colours darker
  expand_limits(x = 7)#' # Scale height of text, rather than sqrt(height)

p +
  geom_text_s(aes(size = wt), nudge_x = -0.1) +
  scale_radius(range = c(3,6)) + # override scale_area()
    expand_limits(x = c(1.8, 5.5))

</code></pre>

<hr>
<h2 id='geom_plot'>Inset plots</h2><span id='topic+geom_plot'></span><span id='topic+geom_plot_npc'></span>

<h3>Description</h3>

<p><code>geom_plot</code> and <code>geom_plot_npc</code> add ggplot objects as insets to the
base ggplot, using syntax similar to that of
<code><a href="ggplot2.html#topic+geom_label">geom_label</a></code> and <code><a href="#topic+geom_text_s">geom_text_s</a></code>.
In most respects they behave as any other ggplot geometry: they add a layer
containing one or more grobs and grouping and faceting works as usual. The
most common use of <code>geom_plot</code> is to add data labels that are themselves
ggplots rather than text. <code><a href="#topic+geom_plot_npc">geom_plot_npc</a></code> is used to add ggplots
as annotations to plots, but contrary to layer function <code>annotate()</code>,
<code><a href="#topic+geom_plot_npc">geom_plot_npc</a></code> is data driven and respects grouping and facets,
thus plot insets can differ among panels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_plot(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "box",
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "all",
  add.segments = TRUE,
  box.padding = 0.25,
  point.padding = 1e-06,
  segment.linewidth = 0.5,
  min.segment.length = 0,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_plot_npc(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_plot_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_data">data</code></td>
<td>
<p>A layer specific data set - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_nudge_x">nudge_x</code>, <code id="geom_plot_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_default.colour">default.colour</code>, <code id="geom_plot_+3A_default.color">default.color</code></td>
<td>
<p>A colour definition to use for elements not targeted by
the colour aesthetic.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_colour.target">colour.target</code>, <code id="geom_plot_+3A_color.target">color.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"box"</code> and <code>"segment"</code>.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_default.alpha">default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_alpha.target">alpha.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"text"</code>, <code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code>.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_add.segments">add.segments</code></td>
<td>
<p>logical Display connecting segments or arrows between
original positions and displaced ones if both are available.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_box.padding">box.padding</code>, <code id="geom_plot_+3A_point.padding">point.padding</code></td>
<td>
<p>numeric By how much each end of the segments
should shortened in mm.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_segment.linewidth">segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_min.segment.length">min.segment.length</code></td>
<td>
<p>numeric Segments shorter that the minimum length
are not rendered, in mm.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code><a href="grid.html#topic+arrow">arrow</a></code></p>
</td></tr>
<tr><td><code id="geom_plot_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_plot_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can modify the size of inset plots with the <code>vp.width</code> and
<code>vp.height</code> aesthetics. These can take a number between 0 (smallest
possible inset) and 1 (whole plotting area width or height). The default
value for for both of these aesthetics is 1/5. Thus, in contrast to
<code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> and <code><a href="#topic+geom_text_s">geom_text_s</a></code> the size of
the insets remains the same relative to the size of the plotting area
irrespective of how the plot is rendered. The aspect ratio of insets is
preserved and size is adjusted until the whole inset fits within the
viewport.
</p>
<p>By default this geom uses <code><a href="#topic+position_nudge_center">position_nudge_center</a></code> which is
backwards compatible with <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code> but
provides additional control on the direction of the nudging. In contrast to
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>, <code><a href="#topic+position_nudge_center">position_nudge_center</a></code>
and all other position functions defined in packages 'ggpp' and 'ggrepel'
keep the original coordinates thus allowing the plotting of connecting
segments and arrows.
</p>
<p>This geom works only with tibbles as <code>data</code>, as its expects a list of
ggplot objects (<code>"gg"</code> class) to be mapped to the <code>label</code>
aesthetic.
</p>
<p>The <code>x</code> and <code>y</code> aesthetics determine the position of the whole
inset plot, similarly to that of a text label, justification is interpreted
as indicating the position of the plot with respect to its x and y
coordinates in the data, and <code>angle</code> is used to rotate the plot as a
whole.
</p>
<p>Of these two geoms only <code><a href="#topic+geom_plot">geom_plot</a></code> supports the plotting of
segments, as <code><a href="#topic+geom_plot_npc">geom_plot_npc</a></code> uses a coordinate system that is
unrelated to data units and data.In the case of <code>geom_plot_npc()</code>,
<code>npcx</code> and <code>npcy</code> aesthetics determine the position of the inset
plot.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Position functions</h3>

<p>Many layer functions from package 'ggpp' are
designed to work seamlessly with position functions that keep, rather than
discard, the original <code>x</code> and <code>y</code> positions in <code>data</code> when
computing a new displaced position. See <code><a href="#topic+position_nudge_keep">position_nudge_keep</a></code>,
<code><a href="#topic+position_dodge_keep">position_dodge_keep</a></code>, <code><a href="#topic+position_jitter_keep">position_jitter_keep</a></code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a></code>, <code><a href="#topic+position_nudge_line">position_nudge_line</a></code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a></code>, <code><a href="#topic+position_dodgenudge">position_dodgenudge</a></code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a></code>, and <code><a href="#topic+position_stacknudge">position_stacknudge</a></code>
for examples and details of their use.
</p>


<h3>Plot boundaries and clipping</h3>

<p>The &quot;width&quot; and &quot;height&quot; of an inset
as for a text element are 0, so stacking and dodging inset plots will not
work by default, and axis limits are not automatically expanded to include
all inset plots. Obviously, insets do have height and width, but they are
physical units, not data units. The amount of space they occupy on the main
plot is not constant in data units of the base plot: when you modify scale
limits, inset plots stay the same size relative to the physical size of the
base plot.
</p>


<h3>Note</h3>

<p>The insets are stored nested within the main ggplot object and
contain their own copy of the data, and are rendered as grid grobs as normal
ggplots at the time the main ggplot is rendered. They can have different
themes.
</p>
<p>Use <code><a href="#topic+annotate">annotate</a></code> as redefined in 'ggpp' when adding insets
as annotations (automatically available unless 'ggpp' is not attached).
<code><a href="ggplot2.html#topic+annotate">annotate</a></code> cannot be used with the <code>npcx</code> and
<code>npcy</code> pseudo-aesthetics.
</p>


<h3>References</h3>

<p>The idea of implementing a <code>geom_custom()</code> for grobs has
been discussed as an issue at
<a href="https://github.com/tidyverse/ggplot2/issues/1399">https://github.com/tidyverse/ggplot2/issues/1399</a>.
</p>


<h3>See Also</h3>

<p>Other geometries adding layers with insets: 
<code><a href="#topic+geom_table">geom_table</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inset plot with enlarged detail from a region of the main plot
library(tibble)
p &lt;-
  ggplot(data = mtcars, mapping = aes(wt, mpg)) +
  geom_point()

df &lt;- tibble(x = 0.01,
             y = 0.01,
             plot = list(p +
                         coord_cartesian(xlim = c(3, 4),
                                         ylim = c(13, 16)) +
                         labs(x = NULL, y = NULL) +
                         theme_bw(10)))
p +
  expand_limits(x = 0, y = 0) +
  geom_plot_npc(data = df,
                aes(npcx = x, npcy = y, label = plot))

p +
  expand_limits(x = 0, y = 0) +
  geom_plot_npc(data = df,
                aes(npcx = x, npcy = y, label = plot,
                vp.width = 1/2, vp.height = 1/4))

p +
  expand_limits(x = 0, y = 0) +
  geom_plot_npc(data = df,
                aes(npcx = x, npcy = y, label = plot),
                vp.width = 1/4, vp.height = 1/4)

p +
  geom_plot(data = df,
            aes(x = x + 3, y = y + 20, label = plot),
            nudge_x = -1, nudge_y = - 7,
            hjust = 0.5, vjust = 0.5,
            arrow = arrow(length = unit(0.5, "lines")),
            colour = "red",
            vp.width = 1/5, vp.height = 1/5)

</code></pre>

<hr>
<h2 id='geom_point_s'>Points linked by a segment</h2><span id='topic+geom_point_s'></span>

<h3>Description</h3>

<p>The geometry <code>"geom_point_s"</code> provides a super set of the capabilities of
geom <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> from package 'ggplot2' by allowing
plotting of arrows or segments joining the original position of displaced observations
to their current position rendered as points or graphic symbols. The most
common use is to demonstrate the action of different position functions. It
can be also used to highlight observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_point_s(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  nudge_x = 0,
  nudge_y = 0,
  arrow = grid::arrow(length = unit(1/3, "lines")),
  default.colour = "black",
  default.color = default.colour,
  colour.target = "point",
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "all",
  add.segments = TRUE,
  box.padding = 0.25,
  point.padding = 1e-06,
  segment.linewidth = 0.5,
  min.segment.length = 0,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_point_s_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by
<code><a href="ggplot2.html#topic+aes">aes</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), is combined with the default mapping at the top level of the
plot. You only need to supply <code>mapping</code> if there isn't a mapping
defined for the plot.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_data">data</code></td>
<td>
<p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. There
are three types of arguments you can use here:
</p>
 <ul>
<li><p> Aesthetics: to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. </p>
</li>
<li><p> Other arguments to the
layer, for example you override the default <code>stat</code> associated with the
layer. </p>
</li>
<li><p> Other arguments passed on to the stat. </p>
</li></ul>
</td></tr>
<tr><td><code id="geom_point_s_+3A_nudge_x">nudge_x</code>, <code id="geom_point_s_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code><a href="grid.html#topic+arrow">arrow</a></code></p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_default.colour">default.colour</code>, <code id="geom_point_s_+3A_default.color">default.color</code></td>
<td>
<p>A colour definition to use for elements not targeted by
the colour aesthetic.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_colour.target">colour.target</code>, <code id="geom_point_s_+3A_color.target">color.target</code></td>
<td>
<p>A character string, one of <code>"all"</code>,
<code>"point"</code> and <code>"segment"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_default.alpha">default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_alpha.target">alpha.target</code></td>
<td>
<p>A character string, one of <code>"all"</code>,
<code>"segment"</code>, <code>"point"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_add.segments">add.segments</code></td>
<td>
<p>logical Display connecting segments or arrows between
original positions and displaced ones if both are available.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_box.padding">box.padding</code>, <code id="geom_point_s_+3A_point.padding">point.padding</code></td>
<td>
<p>numeric By how much each end of the segments
should shortened in mm.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_segment.linewidth">segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_min.segment.length">min.segment.length</code></td>
<td>
<p>numeric Segments shorter that the minimum length
are not rendered, in mm.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_point_s_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plotting of segments is similar in idea to that implemented in
<code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code> and relies on position functions
that rename instead of only replacing the original <code>x</code> and <code>y</code>
coordinates from the <code>data</code> object.
</p>
<p>By default this geom uses <code><a href="#topic+position_nudge_center">position_nudge_center</a></code> which is backwards
compatible with <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code> but provides additional control
on the direction of the nudging.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Position functions</h3>

<p>Many layer functions from package 'ggpp' are
designed to work seamlessly with position functions that keep, rather than
discard, the original <code>x</code> and <code>y</code> positions in <code>data</code> when
computing a new displaced position. See <code><a href="#topic+position_nudge_keep">position_nudge_keep</a></code>,
<code><a href="#topic+position_dodge_keep">position_dodge_keep</a></code>, <code><a href="#topic+position_jitter_keep">position_jitter_keep</a></code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a></code>, <code><a href="#topic+position_nudge_line">position_nudge_line</a></code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a></code>, <code><a href="#topic+position_dodgenudge">position_dodgenudge</a></code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a></code>, and <code><a href="#topic+position_stacknudge">position_stacknudge</a></code>
for examples and details of their use.
</p>


<h3>Note</h3>

<p>The insets are stored nested within the main ggplot object and
contain their own copy of the data, and are rendered as grid grobs as normal
ggplots at the time the main ggplot is rendered. They can have different
themes.
</p>
<p>Use <code><a href="#topic+annotate">annotate</a></code> as redefined in 'ggpp' when adding insets
as annotations (automatically available unless 'ggpp' is not attached).
<code><a href="ggplot2.html#topic+annotate">annotate</a></code> cannot be used with the <code>npcx</code> and
<code>npcy</code> pseudo-aesthetics.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_point">geom_point</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Same output as with geom_point()
ggplot(mpg[1:20, ],
       aes(cyl, hwy)) +
  geom_point_s(colour = "blue")

# with segment drawn after nudging
ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point_s(position = position_nudge_keep(x = 0.2),
               colour = "red") +
  geom_point_s(colour = "blue")

# with segment drawn after nudging
ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point_s(position = position_nudge_keep(x = 0.2),
               colour = "red",
               colour.target = "all") +
  geom_point_s(colour = "blue")

ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point_s(position = position_nudge_keep(x = 0.2),
               colour = "red",
               colour.target = "segment") +
  geom_point_s(colour = "blue")

ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point_s(position = position_nudge_keep(x = 0.2),
               colour = "red",
               colour.target = "point") +
  geom_point_s(colour = "blue")

ggplot(mpg[1:50, ],
       aes(cyl, hwy, label = drv)) +
  geom_point_s(position = position_jitternudge(width = 0.66, height = 2,
                                               seed = 456,
                                               nudge.from = "jittered",
                                               kept.origin = "original"),
               colour = "red",
               arrow = grid::arrow(length = grid::unit(0.4, "lines"))) +
  geom_point_s(colour = "blue")

</code></pre>

<hr>
<h2 id='geom_quadrant_lines'>Reference lines: horizontal plus vertical, and quadrants</h2><span id='topic+geom_quadrant_lines'></span><span id='topic+geom_vhlines'></span>

<h3>Description</h3>

<p><code>geom_vhlines()</code> adds in a single layer both vertical and horizontal
guide lines. Can be thought of as a convenience function that helps with
producing consistent vertical and horizontal guide lines. It behaves like
<code>geom_vline()</code> and <code>geom_hline()</code>.
<code>geom_quadrant_lines()</code> displays the boundaries of four quadrants
with an arbitrary origin. The quadrants are specified in the same way as
in <code>stat_quadrant_counts()</code> and is intended to be used to add guide
lines consistent with the counts by quadrant computed by this stat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_quadrant_lines(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  pool.along = c("none", "x", "y", "xy"),
  xintercept = 0,
  yintercept = 0,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE,
  ...
)

geom_vhlines(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  xintercept = NULL,
  yintercept = NULL,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_quadrant_lines_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_data">data</code></td>
<td>
<p>A layer specific data set - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_stat">stat</code></td>
<td>
<p>The statistic object to use display the data</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_pool.along">pool.along</code></td>
<td>
<p>character, one of <code>"none"</code>, <code>"x"</code>, <code>"y"</code>, or
<code>"xy"</code> indicating whether to plot or not lines separating quadrants.</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_xintercept">xintercept</code>, <code id="geom_quadrant_lines_+3A_yintercept">yintercept</code></td>
<td>
<p>numeric vectors the coordinates of the origin of the
quadrants.</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and should not inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_quadrant_lines_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code>geom_vhlines()</code> does not provide defaults for the
intercepts and accepts vectors of length &gt; 1, <code>geom_quadrant_lines()</code>
sets by default the intercepts to zero producing the natural quadrants and
only accepts vectors of length one per panel. That is <code>geom_vhlines()</code>
can be used to plot a grid while <code>geom_quadrant_lines()</code> plots at
most one vertical and one horizontal line. In the case of
<code>geom_quadrant_lines()</code> the pooling along axes can be specified in the
same way as in <code><a href="#topic+stat_quadrant_counts">stat_quadrant_counts</a>()</code>.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_abline">geom_abline</a></code>, the topic where
<code>geom_vline()</code> and <code>geom_hline()</code> are described.
</p>
<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+stat_panel_counts">stat_panel_counts</a>()</code>,
<code><a href="#topic+stat_quadrant_counts">stat_quadrant_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
set.seed(4321)
x &lt;- 1:100
y &lt;- rnorm(length(x), mean = 10)
my.data &lt;- data.frame(x, y)

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines() +
  geom_point()

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(linetype = "dotted") +
  geom_point()

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(xintercept = 50,
                      yintercept = 10,
                      colour = "blue") +
  geom_point()

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(xintercept = 50,
                      pool.along = "y",
                      colour = "blue") +
  geom_point()

ggplot(my.data, aes(x, y)) +
  geom_vhlines(xintercept = c(25, 50, 75),
               yintercept = 10 ,
               linetype = "dotted",
               colour = "red") +
  geom_point() +
  theme_bw()

ggplot(my.data, aes(x, y)) +
  geom_vhlines(xintercept = c(25, 50, 75),
               yintercept = c(10, 8),
               linetype = "dotted",
               colour = "red") +
  geom_point() +
  theme_bw()

</code></pre>

<hr>
<h2 id='geom_table'>Inset tables</h2><span id='topic+geom_table'></span><span id='topic+geom_table_npc'></span>

<h3>Description</h3>

<p><code>geom_table</code> and <code>geom_table_npc</code> add data frames as table insets
to the base ggplot, using syntax similar to that of
<code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> and <code><a href="#topic+geom_text_s">geom_text_s</a></code>. In most
respects they behave as any other ggplot geometry: they add a layer
containing one or more grobs and grouping and faceting works as usual. The
most common use of <code>geom_table</code> is to add data labels that are whole
tables rather than text. <code><a href="#topic+geom_table_npc">geom_table_npc</a></code> is used to add tables
as annotations to plots, but contrary to layer function <code>annotate</code>,
<code><a href="#topic+geom_table_npc">geom_table_npc</a></code> is data driven and respects grouping and facets,
thus plot insets can differ among panels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_table(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  nudge_x = 0,
  nudge_y = 0,
  default.colour = "black",
  default.color = default.colour,
  colour.target = "box",
  color.target = colour.target,
  default.alpha = 1,
  alpha.target = "all",
  add.segments = TRUE,
  box.padding = 0.25,
  point.padding = 1e-06,
  segment.linewidth = 0.5,
  min.segment.length = 0,
  arrow = NULL,
  table.theme = NULL,
  table.rownames = FALSE,
  table.colnames = TRUE,
  table.hjust = 0.5,
  parse = FALSE,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_table_npc(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  table.theme = NULL,
  table.rownames = FALSE,
  table.colnames = TRUE,
  table.hjust = 0.5,
  parse = FALSE,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_table_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_data">data</code></td>
<td>
<p>A layer specific data set - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a</p>
</td></tr>
<tr><td><code id="geom_table_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_nudge_x">nudge_x</code>, <code id="geom_table_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_default.colour">default.colour</code>, <code id="geom_table_+3A_default.color">default.color</code></td>
<td>
<p>A colour definition to use for elements not targeted by
the colour aesthetic.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_colour.target">colour.target</code>, <code id="geom_table_+3A_color.target">color.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"box"</code> and <code>"segment"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_default.alpha">default.alpha</code></td>
<td>
<p>numeric in [0..1] A transparency value to use for
elements not targeted by the alpha aesthetic.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_alpha.target">alpha.target</code></td>
<td>
<p>A vector of character strings; <code>"all"</code>,
<code>"segment"</code>, <code>"box"</code>, <code>"box.line"</code>, and
<code>"box.fill"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_add.segments">add.segments</code></td>
<td>
<p>logical Display connecting segments or arrows between
original positions and displaced ones if both are available.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_box.padding">box.padding</code>, <code id="geom_table_+3A_point.padding">point.padding</code></td>
<td>
<p>numeric By how much each end of the segments
should shortened in mm.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_segment.linewidth">segment.linewidth</code></td>
<td>
<p>numeric Width of the segments or arrows in mm.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_min.segment.length">min.segment.length</code></td>
<td>
<p>numeric Segments shorter that the minimum length
are not rendered, in mm.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by
<code><a href="grid.html#topic+arrow">arrow</a></code></p>
</td></tr>
<tr><td><code id="geom_table_+3A_table.theme">table.theme</code></td>
<td>
<p>NULL, list or function A gridExtra ttheme defintion, or
a constructor for a ttheme or NULL for default.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_table.rownames">table.rownames</code>, <code id="geom_table_+3A_table.colnames">table.colnames</code></td>
<td>
<p>logical flag to enable or disable
printing of row names and column names.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_table.hjust">table.hjust</code></td>
<td>
<p>numeric Horizontal justification for the core and column
headings of the table.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_parse">parse</code></td>
<td>
<p>If TRUE, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_table_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>geom_table()</code> uses <code><a href="#topic+position_nudge_center">position_nudge_center</a></code> which is
backwards compatible with <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code> but
provides additional control on the direction of the nudging. In contrast to
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>, <code><a href="#topic+position_nudge_center">position_nudge_center</a></code>
and all other position functions defined in packages 'ggpp' and 'ggrepel'
keep the original coordinates thus allowing the plotting of connecting
segments and arrows.
</p>
<p>This geom works only with tibbles as <code>data</code>, as its expects a list of
data frames (or tibbles) to be mapped to the <code>label</code> aesthetic. A
table is built with function <code>gridExtra::gtable</code> for each data frame
in the list, and formatted according to a table theme or <code>ttheme</code>. The
character strings in the data frame can be parsed into R expressions so the
inset tables can include maths.
</p>
<p>If the argument passed to <code>table.theme</code> is a constructor function
(passing its name without parenthesis), the values mapped to <code>size</code>,
<code>colour</code>, <code>fill</code>, <code>alpha</code>, and <code>family</code> aesthetics will
the passed to this theme constructor for each individual table. In
contrast, if a ready constructed <code>ttheme</code> stored as a list object is
passed as argument (e.g., by calling the constructor, using constructor
name followed by parenthesis), it will be used as is, i.e., mappings to
aesthetics such as <code>colour</code> are ignored if present. By default the
constructor <code>ttheme_gtdefault</code> is used and <code>colour</code> and
<code>fill</code>, are mapped to <code>NA</code>. Mapping these aesthetics to <code>NA</code>
triggers the use of the default <code>base_colour</code> of the <code>ttheme</code>. As
the table is built with function <code>gridExtra::gtable()</code>, for formatting
details, please, consult <code><a href="gridExtra.html#topic+tableGrob">tableGrob</a></code>.
</p>
<p>The <code>x</code> and <code>y</code> aesthetics determine the position of the whole
inset table, similarly to that of a text label, justification is
interpreted as indicating the position of the inset table with respect to
its <em>horizontal</em> and <em>vertical</em> axes (rows and columns in the
data frame), and <code>angle</code> is used to rotate the inset table as a whole.
</p>
<p>Of these two geoms only <code><a href="#topic+geom_grob">geom_grob</a></code> supports the plotting of
segments, as <code><a href="#topic+geom_grob_npc">geom_grob_npc</a></code> uses a coordinate system that is
unrelated to data units and data.In the case of <code>geom_table_npc</code>,
<code>npcx</code> and <code>npcy</code> aesthetics determine the position of the inset
table. Justification as described above for .
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Position functions</h3>

<p>Many layer functions from package 'ggpp' are
designed to work seamlessly with position functions that keep, rather than
discard, the original <code>x</code> and <code>y</code> positions in <code>data</code> when
computing a new displaced position. See <code><a href="#topic+position_nudge_keep">position_nudge_keep</a></code>,
<code><a href="#topic+position_dodge_keep">position_dodge_keep</a></code>, <code><a href="#topic+position_jitter_keep">position_jitter_keep</a></code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a></code>, <code><a href="#topic+position_nudge_line">position_nudge_line</a></code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a></code>, <code><a href="#topic+position_dodgenudge">position_dodgenudge</a></code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a></code>, and <code><a href="#topic+position_stacknudge">position_stacknudge</a></code>
for examples and details of their use.
</p>


<h3>Plot boundaries and clipping</h3>

<p>The &quot;width&quot; and &quot;height&quot; of an inset
as for a text element are 0, so stacking and dodging inset plots will not
work by default, and axis limits are not automatically expanded to include
all inset plots. Obviously, insets do have height and width, but they are
physical units, not data units. The amount of space they occupy on the main
plot is not constant in data units of the base plot: when you modify scale
limits, inset plots stay the same size relative to the physical size of the
base plot.
</p>


<h3>Note</h3>

<p>Complex tables with annotations or different colouring of rows or cells
can be constructed with functions in package 'gridExtra' or in any other
way as long as they can be saved as grid graphical objects and then added
to a ggplot as a new layer with <code><a href="#topic+geom_grob">geom_grob</a></code>.
</p>


<h3>References</h3>

<p>This geometry is inspired on answers to two questions in
Stackoverflow. In contrast to these earlier examples, the current geom
obeys the grammar of graphics, and attempts to be consistent with the
behaviour of 'ggplot2' geometries.
<a href="https://stackoverflow.com/questions/12318120/adding-table-within-the-plotting-region-of-a-ggplot-in-r">https://stackoverflow.com/questions/12318120/adding-table-within-the-plotting-region-of-a-ggplot-in-r</a>
<a href="https://stackoverflow.com/questions/25554548/adding-sub-tables-on-each-panel-of-a-facet-ggplot-in-r?">https://stackoverflow.com/questions/25554548/adding-sub-tables-on-each-panel-of-a-facet-ggplot-in-r?</a>
</p>


<h3>See Also</h3>

<p>Formatting of tables <code>stat_fmt_table</code>,
<code><a href="#topic+ttheme_gtdefault">ttheme_gtdefault</a></code>, <code><a href="#topic+ttheme_set">ttheme_set</a></code>,
<code><a href="gridExtra.html#topic+tableGrob">tableGrob</a></code>.
</p>
<p>Other geometries adding layers with insets: 
<code><a href="#topic+geom_plot">geom_plot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)

mtcars %&gt;%
  group_by(cyl) %&gt;%
  summarize(wt = mean(wt), mpg = mean(mpg)) %&gt;%
  ungroup() %&gt;%
  mutate(wt = sprintf("%.2f", wt),
         mpg = sprintf("%.1f", mpg)) -&gt; tb

df &lt;- tibble(x = 5.45, y = 34, tb = list(tb))

# using defaults
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df,
             aes(x = x, y = y, label = tb))

ggplot(mtcars,
       aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df,
             aes(x = x, y = y, label = tb),
             table.rownames = TRUE,
             table.theme = ttheme_gtstripes)

# settings aesthetics to constants
ggplot(mtcars,
       aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df,
             aes(x = x, y = y, label = tb),
             color = "red", fill = "#FFCCCC",
             family = "serif", size = 5,
             angle = 90, vjust = 0)

# passing a theme constructor as argument
ggplot(mtcars,
       aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df,
             aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtminimal) +
  theme_classic()

df2 &lt;- tibble(x = 5.45,
              y = c(34, 29, 24),
              x1 = c(2.29, 3.12, 4.00),
              y1 = c(26.6, 19.7, 15.1),
              cyl = c(4, 6, 8),
              tb = list(tb[1, 1:3], tb[2, 1:3], tb[3, 1:3]))

# mapped aesthetics
ggplot(mtcars,
       aes(wt, mpg, color = factor(cyl))) +
  geom_point() +
  geom_table(data = df2,
             inherit.aes = TRUE,
             mapping = aes(x = x, y = y, label = tb))

# nudging and segments
ggplot(mtcars,
       aes(wt, mpg, color = factor(cyl))) +
  geom_point(show.legend = FALSE) +
  geom_table(data = df2,
             inherit.aes = TRUE,
             mapping = aes(x = x1, y = y1, label = tb),
             nudge_x = 0.7, nudge_y = 3,
             vjust = 0.5, hjust = 0.5,
             arrow = arrow(length = unit(0.5, "lines"))) +
  theme_classic()

# Using native plot coordinates instead of data coordinates
dfnpc &lt;- tibble(x = 0.95, y = 0.95, tb = list(tb))

ggplot(mtcars,
       aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table_npc(data = dfnpc,
                 aes(npcx = x, npcy = y, label = tb))

</code></pre>

<hr>
<h2 id='geom_x_margin_arrow'>Reference arrows on the margins</h2><span id='topic+geom_x_margin_arrow'></span><span id='topic+geom_y_margin_arrow'></span>

<h3>Description</h3>

<p>Small arrows on plot margins can supplement a 2d display with annotations.
Arrows can be used to highlight specific values along a margin. The geometries
<code>geom_x_margin_arrow()</code> and <code>geom_y_margin_arrow()</code> behave
similarly <code>geom_vline()</code> and <code>geom_hline()</code> and share their &quot;double
personality&quot; as both annotations and geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_x_margin_arrow(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  xintercept,
  sides = "b",
  arrow.length = 0.03,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_y_margin_arrow(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  yintercept,
  sides = "l",
  arrow.length = 0.03,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_x_margin_arrow_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_xintercept">xintercept</code>, <code id="geom_x_margin_arrow_+3A_yintercept">yintercept</code></td>
<td>
<p>numeric Parameters that control the position of
the marginal points. If these are set, data, mapping and show.legend are
overridden.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_sides">sides</code></td>
<td>
<p>A string that controls which sides of the plot the rugs appear
on. It can be set to a string containing any combination of <code>"trbl"</code>,
for top, right, bottom, and left.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_arrow.length">arrow.length</code></td>
<td>
<p>numeric value expressed in npc units for the length of the
arows inwards from the edge of the plotting area.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_x_margin_arrow_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g., <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>See Also</h3>

<p>Other Geometries for marginal annotations in ggplots: 
<code><a href="#topic+geom_x_margin_grob">geom_x_margin_grob</a>()</code>,
<code><a href="#topic+geom_x_margin_point">geom_x_margin_point</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point()
p
p + geom_x_margin_arrow(xintercept = 3.5)
p + geom_y_margin_arrow(yintercept = c(18, 28, 15))
p + geom_x_margin_arrow(data = data.frame(x = c(2.5, 4.5)),
                        mapping = aes(xintercept = x))
p + geom_x_margin_arrow(data = data.frame(x = c(2.5, 4.5)),
                        mapping = aes(xintercept = x),
                        sides="tb")

</code></pre>

<hr>
<h2 id='geom_x_margin_grob'>Add Grobs on the margins</h2><span id='topic+geom_x_margin_grob'></span><span id='topic+geom_y_margin_grob'></span>

<h3>Description</h3>

<p>Margin grobs can supplement a 2d display with annotations. Margin grobs such
as icons or symbols can highlight individual values along a margin. The
geometries <code>geom_x_margin_grob()</code> and <code>geom_y_margin_grob()</code> behave
similarly <code>geom_vline()</code> and <code>geom_hline()</code> and share their &quot;double
personality&quot; as both annotations and geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_x_margin_grob(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  xintercept,
  sides = "b",
  grob.shift = 0,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_y_margin_grob(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  yintercept,
  sides = "l",
  grob.shift = 0,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_x_margin_grob_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_xintercept">xintercept</code>, <code id="geom_x_margin_grob_+3A_yintercept">yintercept</code></td>
<td>
<p>numeric Parameters that control the position of
the marginal points. If these are set, data, mapping and show.legend are
overridden.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_sides">sides</code></td>
<td>
<p>A character string of length one that controls on which side of
the plot the grob annotations appear on. It can be set to a string
containing one of <code>"t"</code>, <code>"r"</code>, <code>"b"</code> or <code>"l"</code>, for
top, right, bottom, and left.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_grob.shift">grob.shift</code></td>
<td>
<p>numeric value expressed in npc units for the shift of the
marginal grob inwards from the edge of the plotting area.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_x_margin_grob_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and
<code>hjust</code> aesthetics. These can either be a number between 0
(right/bottom) and 1 (top/left) or a character (<code>"left"</code>,
<code>"middle"</code>, <code>"right"</code>, <code>"bottom"</code>, <code>"center"</code>,
<code>"top"</code>). In addition, you can use special alignments for
justification including <code>"position"</code>, <code>"inward"</code> and
<code>"outward"</code>. Inward always aligns text towards the center of the
plotting area, and outward aligns it away from the center of the plotting
area. If tagged with <code>_mean</code> or <code>_median</code> (e.g.,
<code>"outward_mean"</code>) the mean or median of the data in the panel along
the corresponding axis is used as center. If the characters following the
underscore represent a number (e.g., <code>"outward_10.5"</code>) the reference
point will be this value in data units. Position justification is computed
based on the direction of the displacement of the position of the label so
that each individual text or label is justified outwards from its original
position. The default justification is <code>"position"</code>.
</p>
<p>If no position displacement is applied, or a position function defined in
'ggplot2' is used, these geometries behave similarly to the corresponding
ones from package 'ggplot2' with a default justification of <code>0.5</code> and
no segment drawn.
</p>


<h3>Position functions</h3>

<p>Many layer functions from package 'ggpp' are
designed to work seamlessly with position functions that keep, rather than
discard, the original <code>x</code> and <code>y</code> positions in <code>data</code> when
computing a new displaced position. See <code><a href="#topic+position_nudge_keep">position_nudge_keep</a></code>,
<code><a href="#topic+position_dodge_keep">position_dodge_keep</a></code>, <code><a href="#topic+position_jitter_keep">position_jitter_keep</a></code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a></code>, <code><a href="#topic+position_nudge_line">position_nudge_line</a></code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a></code>, <code><a href="#topic+position_dodgenudge">position_dodgenudge</a></code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a></code>, and <code><a href="#topic+position_stacknudge">position_stacknudge</a></code>
for examples and details of their use.
</p>


<h3>See Also</h3>

<p><code><a href="grid.html#topic+grid-package">grid-package</a></code>, <code><a href="ggplot2.html#topic+geom_rug">geom_rug</a></code>,
and other documentation of package 'ggplot2'.
</p>
<p>Other Geometries for marginal annotations in ggplots: 
<code><a href="#topic+geom_x_margin_arrow">geom_x_margin_arrow</a>()</code>,
<code><a href="#topic+geom_x_margin_point">geom_x_margin_point</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We can add icons to the margin of a plot to signal events




</code></pre>

<hr>
<h2 id='geom_x_margin_point'>Reference points on the margins</h2><span id='topic+geom_x_margin_point'></span><span id='topic+geom_y_margin_point'></span>

<h3>Description</h3>

<p>Margin points can supplement a 2d display with annotations. Margin points
can highlight individual values along a margin. The geometries
<code>geom_x_margin_point()</code> and <code>geom_y_margin_point()</code> behave
similarly <code>geom_vline()</code> and <code>geom_hline()</code> and share their &quot;double
personality&quot; as both annotations and geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_x_margin_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  xintercept,
  sides = "b",
  point.shift = 0.017,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)

geom_y_margin_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  yintercept,
  sides = "l",
  point.shift = 0.017,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_x_margin_point_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_xintercept">xintercept</code>, <code id="geom_x_margin_point_+3A_yintercept">yintercept</code></td>
<td>
<p>numeric Parameters that control the position of
the marginal points. If these are set, data, mapping and show.legend are
overridden.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_sides">sides</code></td>
<td>
<p>A string that controls which sides of the plot the rugs appear
on. It can be set to a string containing any combination of <code>"trbl"</code>,
for top, right, bottom, and left.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_point.shift">point.shift</code></td>
<td>
<p>numeric value expressed in npc units for the shift of the
rug points inwards from the edge of the plotting area.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_x_margin_point_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>See Also</h3>

<p>Other Geometries for marginal annotations in ggplots: 
<code><a href="#topic+geom_x_margin_arrow">geom_x_margin_arrow</a>()</code>,
<code><a href="#topic+geom_x_margin_grob">geom_x_margin_grob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg)) +
       geom_point()
p
p + geom_x_margin_point(xintercept = 3.5)
p + geom_y_margin_point(yintercept = c(18, 28, 15))
p + geom_x_margin_point(data = data.frame(x = c(2.5, 4.5)),
                        mapping = aes(xintercept = x))
p + geom_x_margin_point(data = data.frame(x = c(2.5, 4.5)),
                        mapping = aes(xintercept = x),
                        sides = "tb")

</code></pre>

<hr>
<h2 id='GeomGrob'><code>Stat*</code> Objects</h2><span id='topic+GeomGrob'></span><span id='topic+GeomGrobNpc'></span><span id='topic+GeomLabelS'></span><span id='topic+GeomLabelNpc'></span><span id='topic+GeomLabelPairwise'></span><span id='topic+GeomXMarginArrow'></span><span id='topic+GeomYMarginArrow'></span><span id='topic+GeomXMarginGrob'></span><span id='topic+GeomYMarginGrob'></span><span id='topic+GeomXMarginPoint'></span><span id='topic+GeomYMarginPoint'></span><span id='topic+GeomPlot'></span><span id='topic+GeomPlotNpc'></span><span id='topic+GeomPointS'></span><span id='topic+GeomQuadrantLines'></span><span id='topic+GeomVHLines'></span><span id='topic+GeomTable'></span><span id='topic+GeomTableNpc'></span><span id='topic+GeomTextS'></span><span id='topic+GeomTextNpc'></span><span id='topic+GeomTextPairwise'></span><span id='topic+PositionNudgeCenter'></span><span id='topic+PositionNudgeLine'></span><span id='topic+PositionFillAndNudge'></span><span id='topic+PositionNudgeTo'></span><span id='topic+Stats'></span><span id='topic+StatApplyGroup'></span><span id='topic+StatDens1dFilter'></span><span id='topic+StatDens1dFilterG'></span><span id='topic+StatDens1dLabels'></span><span id='topic+StatDens2dFilter'></span><span id='topic+StatDens2dFilterG'></span><span id='topic+StatDens2dLabels'></span><span id='topic+StatFmtTb'></span><span id='topic+StatFunctions'></span><span id='topic+StatPanelCounts'></span><span id='topic+StatGroupCounts'></span><span id='topic+StatQuadrantCounts'></span>

<h3>Description</h3>

<p>All <code>stat_*</code> functions (like <code>stat_bin</code>) return a layer that
contains a <code>Stat*</code> object (like <code>StatBin</code>). The <code>Stat*</code>
object is responsible for rendering the data in the plot.
</p>


<h3>Details</h3>

<p>Each of the <code>Stat*</code> objects is a <code><a href="ggplot2.html#topic+ggproto">ggproto</a></code> object, descended
from the top-level <code>Stat</code>, and each implements various methods and
fields. To create a new type of Stat object, you typically will want to
implement one or more of the following:
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2-ggproto</a></code>
</p>

<hr>
<h2 id='ggplot'>Create a new ggplot plot from time series data</h2><span id='topic+ggplot'></span><span id='topic+ggplot.ts'></span><span id='topic+ggplot.xts'></span>

<h3>Description</h3>

<p><code>ggplot()</code> initializes a ggplot object. It can be used to
declare the input spectral object for a graphic and to optionally specify the
set of plot aesthetics intended to be common throughout all
subsequent layers unless specifically overridden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts'
ggplot(
  data,
  mapping = NULL,
  ...,
  time.resolution = "day",
  as.numeric = TRUE,
  environment = parent.frame()
)

## S3 method for class 'xts'
ggplot(
  data,
  mapping = NULL,
  ...,
  time.resolution = "day",
  as.numeric = TRUE,
  environment = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_+3A_data">data</code></td>
<td>
<p>Default spectrum dataset to use for plot. If not a spectrum, the
methods used will be those defined in package <code>ggplot2</code>. See <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
If not specified,
must be suppled in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_mapping">mapping</code></td>
<td>
<p>Default list of aesthetic mappings to use for plot.
If not specified, in the case of spectral objects, a default mapping will
be used.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_time.resolution">time.resolution</code></td>
<td>
<p>character The time unit to which the returned time
values will be rounded.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_as.numeric">as.numeric</code></td>
<td>
<p>logical If TRUE convert time to numeric, expressed as
fractional calendar years.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_environment">environment</code></td>
<td>
<p>If an variable defined in the aesthetic mapping is not
found in the data, ggplot will look for it in this environment. It defaults
to using the environment in which <code>ggplot()</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggplot()</code> is typically used to construct a plot
incrementally, using the + operator to add layers to the
existing ggplot object. This is advantageous in that the
code is explicit about which layers are added and the order
in which they are added. For complex graphics with multiple
layers, initialization with <code>ggplot</code> is recommended.
</p>
<p>There are three common ways to invoke <code>ggplot</code>:
</p>

<ul>
<li> <p><code>ggplot(ts, aes(x, y, &lt;other aesthetics&gt;))</code>
</p>
</li>
<li> <p><code>ggplot(ts)</code>
</p>
</li></ul>

<p>The first method is recommended if all layers use the same
data and the same set of aesthetics, although this method
can also be used to add a layer using data from another
data frame. See the first example below. The second
method specifies the default spectrum object to use for the plot, and the
units to be used for y in the plot,
but no aesthetics are defined up front. This is useful when
one data frame is used predominantly as layers are added,
but the aesthetics may vary from one layer to another. The
third method specifies the default spectrum object to use for the plot,
but no aesthetics are defined up front. This is useful when
one spectrum is used predominantly as layers are added,
but the aesthetics may vary from one layer to another.
</p>


<h3>Value</h3>

<p>A <code>"ggplot"</code> object.
</p>


<h3>Note</h3>

<p>Current implementation does not merge default mapping with user
supplied mapping. If user supplies a mapping, it is used as is.
To add to the default mapping, aes() can be used by itself to compose
the ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(lynx) + geom_line()

</code></pre>

<hr>
<h2 id='ivy.df'>Ivy photosynthesis light response</h2><span id='topic+ivy.df'></span>

<h3>Description</h3>

<p>A dataset containing photosynthesis measurements on four ivy plants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivy.df
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object with 36 rows and 6 variables.
</p>


<h3>Details</h3>

<p>For each plant a light response curve of photosynthesis was measured
using a custom-built system and software that allowed controlling the
concentrations of water vapour and carbon dioxide at the surface of the
leaves, i.e., inside the air boundary layer.
</p>


<h3>References</h3>

<p>Aphalo, P. J. (1991) Interactions in Stomatal Function. PhD
thesis, University of Edinburgh. <a href="http://hdl.handle.net/1842/14758">http://hdl.handle.net/1842/14758</a>.
</p>


<h3>See Also</h3>

<p>Other Plant growth and morphology data: 
<code><a href="#topic+birch.df">birch.df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colnames(ivy.df)
head(ivy.df)

</code></pre>

<hr>
<h2 id='position_dodgenudge'>Combined positions dodge and nudge</h2><span id='topic+position_dodgenudge'></span><span id='topic+position_dodge_keep'></span><span id='topic+position_dodge2_keep'></span><span id='topic+position_dodge2nudge'></span>

<h3>Description</h3>

<p><code>position_dodgenudge()</code> combines into one function the action of
<code><a href="ggplot2.html#topic+position_dodge">position_dodge</a></code> and
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code> and <code>position_dodge2nudge()</code>
combines into one function the action of
<code><a href="ggplot2.html#topic+position_dodge2">position_dodge2</a></code> and
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>. They are useful when labelling plots
such as grouped bars, columns, etc. and when adding dodged to text labels
linked to observations plotted without dodge. It can replace other position
functions as it is backwards compatible. Like all other position functions in
'ggpp' and 'ggrepel' it preserves the initial position to allow drawing of
segments or arrow linking the original position to the displaced one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_dodgenudge(
  width = 1,
  preserve = c("total", "single"),
  x = 0,
  y = 0,
  direction = c("none", "split", "split.x", "split.y", "center"),
  kept.origin = c("dodged", "original", "none")
)

position_dodge_keep(
  width = 1,
  preserve = c("total", "single"),
  kept.origin = "original"
)

position_dodge2_keep(
  width = 1,
  preserve = c("total", "single"),
  kept.origin = "original"
)

position_dodge2nudge(
  width = 1,
  preserve = c("total", "single"),
  padding = 0.1,
  reverse = FALSE,
  x = 0,
  y = 0,
  direction = c("none", "split", "split.x", "split.y", "center"),
  kept.origin = c("dodged", "original", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_dodgenudge_+3A_width">width</code></td>
<td>
<p>Dodging width, when different to the width of the individual
elements. This is useful when you want to align narrow geoms with wider
geoms. See the examples.</p>
</td></tr>
<tr><td><code id="position_dodgenudge_+3A_preserve">preserve</code></td>
<td>
<p>Should dodging preserve the total width of all elements at a
position, or the width of a single element?.</p>
</td></tr>
<tr><td><code id="position_dodgenudge_+3A_x">x</code>, <code id="position_dodgenudge_+3A_y">y</code></td>
<td>
<p>Amount of vertical and horizontal distance to move. A numeric
vector of length 1, or of the same length as rows there are in 'data',
with nudge values in data rows order.</p>
</td></tr>
<tr><td><code id="position_dodgenudge_+3A_direction">direction</code></td>
<td>
<p>One of <code>"none"</code>, <code>"split"</code>, <code>"split.x"</code> or
<code>"split.y"</code>. A value of <code>"none"</code> replicates the behavior of
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>. At the moment <code>"split"</code> changes
the sign of the nudge at zero, which is suitable for column plots with
negative slices.</p>
</td></tr>
<tr><td><code id="position_dodgenudge_+3A_kept.origin">kept.origin</code></td>
<td>
<p>One of <code>"original"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="position_dodgenudge_+3A_padding">padding</code></td>
<td>
<p>Padding between elements at the same position. Elements are
shrunk by this proportion to allow space between them. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="position_dodgenudge_+3A_reverse">reverse</code></td>
<td>
<p>If TRUE, will reverse the default stacking order. This is
useful if you're rotating both the plot and legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The applied dodge is identical to that by
<code><a href="ggplot2.html#topic+position_dodge">position_dodge</a></code> or
<code><a href="ggplot2.html#topic+position_dodge2">position_dodge2</a></code> while nudging is similar to that by
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>.
</p>
<p>There are two posible uses for these functions. First they can be used to
label dodged bars or boxplots. In this case, it is mandatory to use the same
argument to <code>width</code> when passing <code>position_dodge()</code> to
<code>geom_col()</code> and <code>position_dodgenudge()</code> to <code>geom_text()</code> or
<code>geom_label()</code> or their repulsive equivalents. Otherwise the arrows or
segments will fail to connect to the labels. In other words jittering is
computed twice. Jitter should be identical with the same arguments as
<code>position_dodgenudge()</code> as this last function simply call the same code
from package 'ggplot2'.
</p>
<p>The second use is to dodge labels to be connected to elements that have not
been jittered. The return of original positions instead of the dodged
ones is achieved by passing <code>origin = "original"</code> instead of the default
of <code>origin = "dodged"</code>.
</p>


<h3>Value</h3>

<p>A <code>"Position"</code> object.
</p>


<h3>Author(s)</h3>

<p>Michał Krassowski, edited by Pedro J. Aphalo.
</p>


<h3>Source</h3>

<p><a href="https://github.com/slowkow/ggrepel/issues/161">https://github.com/slowkow/ggrepel/issues/161</a>.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>,
<code><a href="ggrepel.html#topic+position_nudge_repel">position_nudge_repel</a></code>.
</p>
<p>Other position adjustments: 
<code><a href="#topic+position_jitternudge">position_jitternudge</a>()</code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a>()</code>,
<code><a href="#topic+position_nudge_keep">position_nudge_keep</a>()</code>,
<code><a href="#topic+position_nudge_line">position_nudge_line</a>()</code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a>()</code>,
<code><a href="#topic+position_stacknudge">position_stacknudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x1 = c(1, 2, 1, 3, -1),
                 x2 = c("a", "a", "b", "b", "b"),
                 grp = c("some long name", "other name", "some name",
                         "another name", "some long name"))

# Add labels to a horizontal column plot (stacked by default)
ggplot(data = df, aes(x1, x2, group = grp)) +
  geom_col(aes(fill = grp), width = 0.8,
           position = position_dodge()) +
  geom_vline(xintercept = 0) +
  geom_text(
    aes(label = grp),
    position = position_dodgenudge(x = 0.09, direction = "split", width = 0.8),
    angle = 90, size = 3) +
  theme(legend.position = "none")

ggplot(data = df, aes(x2, x1, group = grp)) +
  geom_col(aes(fill = grp), width = 0.75,
           position = position_dodge(width = 0.75)) +
  geom_vline(xintercept = 0) +
  geom_text(aes(label = grp),
            position = position_dodgenudge(y = 0.1,
                                           direction = "split",
                                           width = 0.75),
            size = 3) +
  theme(legend.position = "none")

</code></pre>

<hr>
<h2 id='position_jitternudge'>Combined positions jitter and nudge</h2><span id='topic+position_jitternudge'></span><span id='topic+position_jitter_keep'></span>

<h3>Description</h3>

<p><code>position_jitternudge()</code> combines into one function the action of
<code><a href="ggplot2.html#topic+position_jitter">position_jitter</a></code> and
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>. It is useful when labels to jittered
plots and when adding jitter to text labels linked to points plotted without
jitter. It can replace other position functions as it is backwards
compatible. Like all other position functions in 'ggpp' and 'ggrepel' it
preserves the initial position to allow drawing of segments or arrow linking
the original position to the displaced one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_jitternudge(
  width = NULL,
  height = NULL,
  seed = NA,
  x = 0,
  y = 0,
  direction = c("as.is", "alternate", "split"),
  nudge.from = c("original", "original.x", "original.y", "jittered", "jittered.y",
    "jittered.x"),
  kept.origin = c("jittered", "original", "none")
)

position_jitter_keep(
  width = NULL,
  height = NULL,
  seed = NA,
  kept.origin = "original"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_jitternudge_+3A_width">width</code>, <code id="position_jitternudge_+3A_height">height</code></td>
<td>
<p>Amount of vertical and horizontal jitter. The jitter is
added in both positive and negative directions, so the total spread is
twice the value specified here. If omitted, defaults to 40
resolution of the data: this means the jitter values will occupy 80
implied bins. Categorical data is aligned on the integers, so a width or
height of 0.5 will spread the data so it's not possible to see the
distinction between the categories.</p>
</td></tr>
<tr><td><code id="position_jitternudge_+3A_seed">seed</code></td>
<td>
<p>A random seed to make the jitter reproducible. Useful if you need
to apply the same jitter twice, e.g., for a point and a corresponding
label. The random seed is reset after jittering. If <code>NA</code> (the default
value), the seed is initialised with a random value; this makes sure that
two subsequent calls start with a different seed. Use <code>NULL</code> to use
the current random seed and also avoid resetting (the behaviour of ggplot
2.2.1 and earlier).</p>
</td></tr>
<tr><td><code id="position_jitternudge_+3A_x">x</code>, <code id="position_jitternudge_+3A_y">y</code></td>
<td>
<p>Amount of vertical and horizontal distance to move. A numeric
vector of length 1, or of the same length as rows there are in <code>data</code>,
with nudge values in data rows order.</p>
</td></tr>
<tr><td><code id="position_jitternudge_+3A_direction">direction</code></td>
<td>
<p>One of <code>"as.is"</code>, <code>"alternate"</code>, <code>"split"</code>,
<code>"split.x"</code> or <code>"split.y"</code>. A value of <code>"none"</code> replicates
the behavior of <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>. <code>"split"</code>
changes the sign of the nudge depending on the direction of the random
jitter applied to each individual observation, which is suitable for
nudging labels outward of the jittered data.</p>
</td></tr>
<tr><td><code id="position_jitternudge_+3A_nudge.from">nudge.from</code></td>
<td>
<p>One of <code>"original"</code>, <code>"jittered"</code>,
<code>"original.y"</code> (or <code>"jittered.x"</code>), <code>"original.x"</code> (or
<code>"jittered.y"</code>). A value of <code>"original"</code> applies the nudge before
jittering the observations, while <code>"jittered"</code> applies the nudging
after jittering.</p>
</td></tr>
<tr><td><code id="position_jitternudge_+3A_kept.origin">kept.origin</code></td>
<td>
<p>One of <code>"original"</code>, <code>"jittered"</code> or
<code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Jitter with <code>position_jitternudge()</code> is identical to that with
<code><a href="ggplot2.html#topic+position_jitter">position_jitter</a></code> while nudging is enhanced compared
to <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code> by taking into use cases specific
to the combination of jitter and nudge.
</p>
<p>There are two posible uses for this function. First it can be used to label
jittered points in a plot. In this case, it is mandatory to use the same
arguments to <code>width</code>, <code>height</code> and <code>seed</code> when passing
<code>position_jitter()</code> to <code>geom_point()</code> and
<code>position_jitternudge()</code> to <code>geom_text()</code> or to
<code>geom_label()</code> or their repulsive equivalents. Otherwise the arrows or
segments will fail to connect to the labels. In other words jittering is
computed twice. Jitter should be identical with the same arguments as
<code>position_jitternudge()</code> as this last function calls the same code
imported from package 'ggplot2'.
</p>
<p>The second use is to jitter labels to be connected to points that have not
been jittered. The return of original positions instead of the jittered
ones is achieved by passing <code>origin = "original"</code> to override the
default <code>origin = "jittered"</code>.
</p>


<h3>Value</h3>

<p>A <code>"Position"</code> object. The layer function within it returns a
data frame, with the jittered + nudged values in columns <code>x</code> and
<code>y</code> and by default the jittered values with no nudging as
<code>x_orig</code> and <code>y_orig</code>. With <code>nudge.from = "original"</code> the
original values with no jitter and no nudge applied are returned as
<code>x_orig</code> and <code>y_orig</code>.
</p>


<h3>Note</h3>

<p>When <code>direction = "split"</code> is used together with no jitter, the
split to left and right, or up and down is done at random.
</p>


<h3>Author(s)</h3>

<p>Michał Krassowski, edited by Pedro J. Aphalo.
</p>


<h3>Source</h3>

<p><a href="https://github.com/slowkow/ggrepel/issues/161">https://github.com/slowkow/ggrepel/issues/161</a>.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+position_jitter">position_jitter</a></code>,
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>,
<code><a href="ggrepel.html#topic+position_nudge_repel">position_nudge_repel</a></code>.
</p>
<p>Other position adjustments: 
<code><a href="#topic+position_dodgenudge">position_dodgenudge</a>()</code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a>()</code>,
<code><a href="#topic+position_nudge_keep">position_nudge_keep</a>()</code>,
<code><a href="#topic+position_nudge_line">position_nudge_line</a>()</code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a>()</code>,
<code><a href="#topic+position_stacknudge">position_stacknudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
jitter &lt;- position_jitter(width = 0.2, height = 2, seed = 123)

jitter_nudge &lt;- position_jitternudge(width = 0.2, height = 2,
                                     seed = 123, x = 0.1,
                                     direction = "split",
                                     nudge.from = "jittered")
ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point(position = jitter) +
  geom_text_s(position = jitter_nudge)

jitter_nudge &lt;- position_jitternudge(width = 0.2, height = 2,
                                     seed = 123, x = 0.35,
                                     direction = "split",
                                     nudge.from = "original.x")
ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point(position = jitter) +
  geom_text_s(position = jitter_nudge)

jitter &lt;- position_jitter(width = 0, height = 2, seed = 123)

jitter_nudge &lt;- position_jitternudge(width = 0, height = 2,
                                     seed = 123, x = 0.4,
                                     direction = "split",
                                     nudge.from = "original.x")
ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point(position = jitter) +
  geom_text_s(position = jitter_nudge)

jitter_nudge &lt;- position_jitternudge(width = 0, height = 2,
                                     seed = 123, x = 0.4,
                                     direction = "alternate",
                                     nudge.from = "original.x")
ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point(position = jitter) +
  geom_text_s(position = jitter_nudge)

# No nudge, show how points have moved with jitter

ggplot(mpg[1:20, ],
       aes(cyl, hwy, label = drv)) +
  geom_point() +
  geom_point_s(position =
               position_jitter_keep(width = 0.3, height = 2, seed = 123),
               color = "red",
               arrow = grid::arrow(length = unit(0.4, "lines")))

</code></pre>

<hr>
<h2 id='position_nudge_center'>Nudge labels away from a central point</h2><span id='topic+position_nudge_center'></span><span id='topic+position_nudge_centre'></span>

<h3>Description</h3>

<p><code>position_nudge_center()</code> is generally useful for adjusting the position of
labels or text, both on a discrete or continuous scale. In contrast to
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>, <code>position_nudge_center()</code> returns in <code>data</code> both
the original coordinates and the nudged coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_nudge_center(
  x = 0,
  y = 0,
  center_x = NULL,
  center_y = NULL,
  direction = NULL,
  obey_grouping = NULL,
  kept.origin = c("original", "none")
)

position_nudge_centre(
  x = 0,
  y = 0,
  center_x = NULL,
  center_y = NULL,
  direction = NULL,
  obey_grouping = NULL,
  kept.origin = c("original", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_nudge_center_+3A_x">x</code>, <code id="position_nudge_center_+3A_y">y</code></td>
<td>
<p>Amount of vertical and horizontal distance to move. A numeric
vector, that is recycled if shorter than the number of rows in <code>data</code>.</p>
</td></tr>
<tr><td><code id="position_nudge_center_+3A_center_x">center_x</code>, <code id="position_nudge_center_+3A_center_y">center_y</code></td>
<td>
<p>The coordinates of the virtual origin out from which
nudging radiates or splits in opposite directions. A numeric vector of
length 1 or of the same length as rows there are in <code>data</code>, or a
function returning either of these vectors computed from the variables in
data mapped to <code>x</code> or <code>y</code>, respectively.</p>
</td></tr>
<tr><td><code id="position_nudge_center_+3A_direction">direction</code></td>
<td>
<p>One of <code>"none"</code>, <code>"radial"</code>, or <code>"split"</code>. A
value of <code>"none"</code> replicates the behavior of
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>. Which of these three values is the
default depends on the values passed to the other parameters.</p>
</td></tr>
<tr><td><code id="position_nudge_center_+3A_obey_grouping">obey_grouping</code></td>
<td>
<p>A logical flag indicating whether to obey or not
groupings of the observations. By default, grouping is obeyed when both of
the variables mapped to <em>x</em> and <em>y</em> are continuous numeric and
ignored otherwise.</p>
</td></tr>
<tr><td><code id="position_nudge_center_+3A_kept.origin">kept.origin</code></td>
<td>
<p>One of <code>"original"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This position function is backwards compatible with <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>
but extends it by adding support for nudging that varies across the plotting
region, either in opposite directions or radially from a virtual <em>center
point</em>.
</p>
<p>Positive values as arguments to <code>x</code> and <code>y</code> are added to
the original position along either axis. If no arguments are passed to
<code>center_x</code>, <code>center_y</code> or <code>direction</code>, the nudging is
applied as is, as is the case if <code>direction = "none"</code>. If
non-<code>NULL</code> arguments are passed to both <code>center_x</code> and
<code>center_y</code>, <code>direction = "radial"</code> is assumed. In this case, if
<code>x</code> and/or <code>y</code> positive nudging is applied radially outwards from
the center, while if negative, inwards towards the center. When a
non-<code>NULL</code> argument is passed only to one of <code>center_x</code> or
<code>center_y</code>, <code>direction = "split"</code> is assumed. In this case when
the initial location of the point is to the left of <code>center_x</code>,
<code>-x</code> is used instead of <code>x</code> for nudging, and when the initial
location of the point is to the below of <code>center_y</code>, <code>-y</code> is used
instead of <code>y</code> for nudging. If non-<code>NULL</code> arguments are passed to
both <code>center_x</code> and <code>center_y</code>, and <code>direction</code> is passed
<code>"split"</code> as argument, then the split as described above is applied to
both to <em>x</em> and <em>y</em> coordinates.
</p>


<h3>Value</h3>

<p>A <code>"Position"</code> object.
</p>


<h3>Note</h3>

<p>Some situations are handled as special cases. When <code>direction =
  "split"</code> or <code>direction = "radial"</code>, observations at exactly the _center_
are nudged using <code>x</code> and <code>y</code> unchanged. When<code>direction = "split"</code>,
and
both <code>center_x</code> and <code>center_y</code> have been supplied, segments are drawn at
eight different possible angles. When segments are exactly horizontal or
vertical they would be shorter than when drawn at the other four angles, in
which case <code>x</code> or <code>y</code> are adjusted to ensure these segments are of the same
lengths as those at other angles.
</p>
<p>This position is most useful when labelling points forming a cloud or
grouped along vertical or horizontal lines or &quot;divides&quot;.
</p>


<h3>See Also</h3>

<p>[ggplot2::position_nudge()], [ggrepel::position_nudge_repel()].
</p>
<p>Other position adjustments: 
<code><a href="#topic+position_dodgenudge">position_dodgenudge</a>()</code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a>()</code>,
<code><a href="#topic+position_nudge_keep">position_nudge_keep</a>()</code>,
<code><a href="#topic+position_nudge_line">position_nudge_line</a>()</code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a>()</code>,
<code><a href="#topic+position_stacknudge">position_stacknudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = c(1,3,2,5,4,2.5),
  y = c("abc","cd","d","c","bcd","a")
)

# Plain nudging, same as with ggplot2::position_nudge()

ggplot(df, aes(x, y, label = y)) +
  geom_point() +
  geom_text_s(hjust = "left", vjust = "bottom",
              position = position_nudge(x = 0.2, y = 0.2))

ggplot(df, aes(x, y, label = y)) +
  geom_point() +
  geom_text_s(add.segments = FALSE,
              position = position_nudge_center(x = 0.2, y = 0.2)
  )

# "split" nudging

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              add.segments = FALSE,
              position = position_nudge_center(x = 0.2,
                                               y = 0.2,
                                               direction = "split"))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = 0.4,
                                               direction = "split"))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(y = 0.2,
                                               direction = "split"))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = 0.2,
                                               y = 0.3,
                                               center_y = 2,
                                               center_x = 1.5,
                                               direction = "split"))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = 0.06,
                                               y = 0.08,
                                               center_y = 2))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = 0.1,
                                               center_x = 2.51))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = 0.06,
                                               y = 0.08,
                                               center_x = median,
                                               center_y = median,
                                               direction = "split"))

# "Radial" nudging

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = 0.1,
                                               y = 0.2,
                                               direction = "radial"))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = -0.1,
                                               y = -0.1,
                                               direction = "radial"))

df &lt;- data.frame(
  x = -10:10,
  z = (-10:10)^2,
  y = letters[1:21],
  group = rep(c("a", "b"), rep(c(11, 10)))
)

ggplot(df, aes(x, z)) +
  geom_point() +
  geom_line() +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = 0.9,
                                               y = 2.7,
                                               center_x = mean,
                                               center_y = max))

ggplot(df, aes(x, z, color = group)) +
  geom_point() +
  geom_line(color = "black", linetype = "dotted") +
  geom_text_s(aes(label = y),
              position = position_nudge_center(x = -1.2,
                                               y = -3,
                                               center_x = 0,
                                               center_y = "above_max"))

ggplot(df, aes(x, z, color = group)) +
  geom_point() +
  geom_line(color = "black", linetype = "dotted") +
  geom_text(aes(label = y),
            vjust = "inward", hjust = "inward",
            position = position_nudge_center(x = -0.9,
                                             y = -2.7,
                                             center_x = mean,
                                             center_y = max,
                                             obey_grouping = FALSE))

</code></pre>

<hr>
<h2 id='position_nudge_keep'>Nudge points a fixed distance</h2><span id='topic+position_nudge_keep'></span>

<h3>Description</h3>

<p>The function <code>position_nudge_keep()</code> has an additional parameters
compared to <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>, <code>obey_grouping</code> and
by default the same behaviour when the values passed as arguments to <code>x</code>
and <code>y</code> have length one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_nudge_keep(
  x = 0,
  y = 0,
  obey_grouping = NULL,
  kept.origin = c("original", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_nudge_keep_+3A_x">x</code>, <code id="position_nudge_keep_+3A_y">y</code></td>
<td>
<p>Amount of vertical and horizontal distance to move. A numeric
vector of length 1, or of the same length as rows there are in <code>data</code>,
with nudge values in data rows order.</p>
</td></tr>
<tr><td><code id="position_nudge_keep_+3A_obey_grouping">obey_grouping</code></td>
<td>
<p>A logical flag indicating whether to obey or not
groupings of the observations. By default, grouping is obeyed when both of
the variables mapped to <em>x</em> and <em>y</em> are continuous numeric and
ignored otherwise.</p>
</td></tr>
<tr><td><code id="position_nudge_keep_+3A_kept.origin">kept.origin</code></td>
<td>
<p>One of <code>"original"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> or <code>y</code> have length &gt; 1, they are treated
specially. If the lengths is the same as there are rows in data, the nudges
are applied in the order of the rows in data. When they are shorter, they
are recycled and applied to the data values after ordering. This makes it
possible to have alternating mudging right and left or up and down. If
<code>obey_grouping = TRUE</code> is passed in the call, the alternation will
take place within groups.
</p>
<p>As other position functions from package 'ggpp', <code>position_nudge_keep()</code>
by default renames and keeps the original positions of the observations in
<code>data</code> making it possible to draw connecting segments or conencting
arrows.
</p>


<h3>Value</h3>

<p>A <code>"Position"</code> object.
</p>


<h3>Note</h3>

<p>Irrespective of the action, the ordering of rows in <code>data</code> is
preserved.
</p>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodgenudge">position_dodgenudge</a>()</code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a>()</code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a>()</code>,
<code><a href="#topic+position_nudge_line">position_nudge_line</a>()</code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a>()</code>,
<code><a href="#topic+position_stacknudge">position_stacknudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = c(1,3,2,5,4,2.5),
  y = c("abc","cd","d","c","bcd","a")
)

# Plain nudging, same as with ggplot2::position_nudge()

ggplot(df, aes(x, y, label = y)) +
  geom_point() +
  geom_text_s(hjust = "left", vjust = "bottom",
              position = position_nudge_keep(x = 0.2, y = 0.2))

# alternating nudging
ggplot(df, aes(x, y, label = y)) +
  geom_point() +
  geom_text_s(position = position_nudge_keep(x = c(0.2, -0.2)))

# direct nudging
ggplot(df, aes(x, y, label = y)) +
  geom_point() +
  geom_text_s(position = position_nudge_keep(x = rep_len(c(0.2, -0.2), 6)))

</code></pre>

<hr>
<h2 id='position_nudge_line'>Nudge labels away from a line</h2><span id='topic+position_nudge_line'></span>

<h3>Description</h3>

<p><code>position_nudge_line()</code> is generally useful for adjusting the starting
position of labels or text to be repelled while preserving the original
position as the start of the segments. The difference compared to
<code><a href="#topic+position_nudge_center">position_nudge_center</a></code> is that the nudging is away from from a
line or curve fitted to the data points or supplied as coefficients. While
<code>position_nudge_center()</code> is most useful for &quot;round-shaped&quot;, vertically-
or horizontally elongated clouds of points, <code>position_nudge_line()</code> is
most suitable when observations follow a linear or curvilinear relationship
between <em>x</em> and <em>y</em> values. In contrast to
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>, <code>position_nudge_line()</code> returns
in 'data' both the original coordinates and the nudged coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_nudge_line(
  x = NA_real_,
  y = NA_real_,
  xy_relative = c(0.03, 0.03),
  abline = NULL,
  method = NULL,
  formula = y ~ x,
  direction = c("automatic", "none", "split"),
  line_nudge = 1,
  kept.origin = c("original", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_nudge_line_+3A_x">x</code>, <code id="position_nudge_line_+3A_y">y</code></td>
<td>
<p>Amount of vertical and horizontal distance to move. A numeric
vector of length 1 or longer.</p>
</td></tr>
<tr><td><code id="position_nudge_line_+3A_xy_relative">xy_relative</code></td>
<td>
<p>Nudge relative to <em>x</em> and <em>y</em> data expanse, ignored unless
<code>x</code> and <code>y</code> are both <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="position_nudge_line_+3A_abline">abline</code></td>
<td>
<p>a vector of length two giving the intercept and slope.</p>
</td></tr>
<tr><td><code id="position_nudge_line_+3A_method">method</code></td>
<td>
<p>One of <code>"spline"</code>, <code>"lm"</code> or <code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="position_nudge_line_+3A_formula">formula</code></td>
<td>
<p>A model formula for <code><a href="stats.html#topic+lm">lm</a></code> when <code>method =
"lm"</code>. Ignored otherwise.</p>
</td></tr>
<tr><td><code id="position_nudge_line_+3A_direction">direction</code></td>
<td>
<p>One of <code>"automatic"</code>, <code>"none"</code>, or <code>"split"</code>.</p>
</td></tr>
<tr><td><code id="position_nudge_line_+3A_line_nudge">line_nudge</code></td>
<td>
<p>A positive multiplier &gt;= 1, increasing nudging away from
the curve or line compared to nudging from points.</p>
</td></tr>
<tr><td><code id="position_nudge_line_+3A_kept.origin">kept.origin</code></td>
<td>
<p>One of <code>"original"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default amount of nudging is 3
<em>x</em> and <em>y</em> axes, which in most cases is good. In most cases it is best to
apply nudging along a direction perpendicular to the line or curve, if this
is the aim, passing an argument to only one of <code>x</code>, <code>y</code> or
<code>xy_relative</code> will be enough. When <code>direction = "split"</code> nudging
is away from an implicit line or curve on either side with positive
nudging. The line or curve can be smooth spline or linear regression fitted
on-the-fly to the data points, or a straight line defined by its
coefficients passed to <code>abline</code>. The fitting is well defined only if
the observations fall roughly on a curve or straight line that is monotonic
in <code>y</code>. By means of <code>line_nudge</code> one can increment nudging away
from the line or curve compared to away from the points, which is useful
for example to keep labels outside of a confidence band. Direction defaults
to <code>"split"</code> when <code>line_nudge</code> &gt; 1, and otherwise to
<code>"none"</code>.
</p>


<h3>Value</h3>

<p>A <code>"Position"</code> object.
</p>


<h3>Note</h3>

<p>For <code>method = "lm"</code> only model formulas corresponding to
polynomials with no missing terms are supported. If using<code><a href="stats.html#topic+poly">poly</a></code>
in the model formula, <code>raw = TRUE</code> is required.
</p>
<p>In practice, <code>x</code> and <code>y</code> should have the same sign for nudging to
work correctly.
</p>
<p>This position is most useful when labeling points conforming a cloud along
an arbitrary curve or line.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>,
<code><a href="ggrepel.html#topic+position_nudge_repel">position_nudge_repel</a></code>.
</p>
<p>Other position adjustments: 
<code><a href="#topic+position_dodgenudge">position_dodgenudge</a>()</code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a>()</code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a>()</code>,
<code><a href="#topic+position_nudge_keep">position_nudge_keep</a>()</code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a>()</code>,
<code><a href="#topic+position_stacknudge">position_stacknudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(16532)
df &lt;- data.frame(
  x = -10:10,
  y = (-10:10)^2,
  yy = (-10:10)^2 + rnorm(21, 0, 4),
  yyy = (-10:10) + rnorm(21, 0, 4),
  l = letters[1:21]
)

# Setting the nudging distance

ggplot(df, aes(x, y, label = l)) +
  geom_line(linetype = "dotted") +
  geom_point() +
  geom_text(position = position_nudge_line())

ggplot(df, aes(x, y, label = l)) +
  geom_line(linetype = "dotted") +
  geom_point() +
  geom_text_s(position = position_nudge_line())

ggplot(df, aes(x, y, label = l)) +
  geom_line(linetype = "dotted") +
  geom_point() +
  geom_text(position = position_nudge_line(xy_relative = -0.03))

ggplot(df, aes(x, y, label = l)) +
  geom_line(linetype = "dotted") +
  geom_point() +
  geom_text(position = position_nudge_line(x = 0.6, y = 3.2))

ggplot(df, aes(x, y, label = l)) +
  geom_line(linetype = "dotted") +
  geom_point() +
  geom_text(position = position_nudge_line(x = -0.6, y = -4))

# Other curves, using defaults

ggplot(df, aes(x, -y, label = l)) +
  geom_line(linetype = "dotted") +
  geom_point() +
  geom_text(position = position_nudge_line())

ggplot(subset(df, x &gt;= 0), aes(y, sqrt(y), label = l)) +
  geom_line(linetype = "dotted") +
  geom_point() +
  geom_text(position = position_nudge_line())

# Points scattered near a curve or line, we use 'direction = "split"'

ggplot(df, aes(x)) +
  geom_line(aes(y = y), linetype = "dotted") +
  geom_point(aes(y = yy)) +
  geom_text(aes(y = yy, label = l),
            position = position_nudge_line(direction = "split"))

ggplot(subset(df, x &gt;= 0), aes(y, yy)) +
  stat_smooth(method = "lm", formula = y ~ x) +
  geom_point() +
  geom_text(aes(label = l),
            position = position_nudge_line(direction = "split"))

# increasing the nudging for labels near the line

ggplot(subset(df, x &gt;= 0), aes(y, yy)) +
  stat_smooth(method = "lm", formula = y ~ x) +
  geom_point() +
  geom_text(aes(label = l),
              position = position_nudge_line(line_nudge = 2,
                                             direction = "split"))

# fitting a linear model instead of the default spline

ggplot(subset(df, x &gt;= 0), aes(y, yy)) +
  stat_smooth(method = "lm", formula = y ~ x) +
  geom_point() +
  geom_text(aes(label = l),
            position = position_nudge_line(method = "lm",
                                           direction = "split"))

ggplot(subset(df, x &gt;= 0), aes(x, x^2)) +
  stat_smooth(method = "lm", formula = y ~ poly(x, 2, raw = TRUE)) +
  geom_point() +
  geom_text(aes(label = l),
            position = position_nudge_line(method = "lm",
                                           formula = y ~ poly(x, 2, raw = TRUE)))

</code></pre>

<hr>
<h2 id='position_nudge_to'>Nudge labels to new positions</h2><span id='topic+position_nudge_to'></span>

<h3>Description</h3>

<p><code>position_nudge_to()</code> is generally useful for adjusting the position of
labels or text, both on a discrete or continuous scale.
<code>position_nudge_to()</code> differs from <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>
in that the coordinates of the new position are given directly, rather than
as a displacement from the original location. It optionally sets an even
distance among positions. As other position functions in this package, it
preserves the original position to allow the text to be linked back to its
original position with a segment or arrow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_nudge_to(
  x = NULL,
  y = NULL,
  x.action = c("none", "spread"),
  y.action = c("none", "spread"),
  kept.origin = c("original", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_nudge_to_+3A_x">x</code>, <code id="position_nudge_to_+3A_y">y</code></td>
<td>
<p>Coordinates of the destination position. A vector of mode
<code>numeric</code>, that is extended if needed, to the same length as rows
there are in <code>data</code>. The default, <code>NULL</code>, leaves the original
coordinates unchanged.</p>
</td></tr>
<tr><td><code id="position_nudge_to_+3A_x.action">x.action</code>, <code id="position_nudge_to_+3A_y.action">y.action</code></td>
<td>
<p>character string, one of <code>"none"</code>, or
<code>"spread"</code>. With <code>"spread"</code> evenly distributing the positions
within the range of argument <code>x</code> or <code>y</code>, if non-null, or the
range the variable mapped to <em>x</em> or <code>y</code>, otherwise.</p>
</td></tr>
<tr><td><code id="position_nudge_to_+3A_kept.origin">kept.origin</code></td>
<td>
<p>One of <code>"original"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nudged to <code>x</code> and/or <code>y</code> values replace the original ones in
<code>data</code>, while the original coordinates are returned in <code>x_orig</code>
and <code>y_orig</code>. Values supported are those of <em>mode</em> numeric,
thus including dates and times.
</p>
<p>If the length of <code>x</code> and/or <code>y</code> is more than one but less than
rows are present in the data, the vector is both recycled and reordered so
that the nudges are applied sequentially based on the data values. If their
length matches the number of rows in data, they are assumed to be already
in data order.
</p>


<h3>Value</h3>

<p>A <code>"Position"</code> object.
</p>


<h3>Note</h3>

<p>Irrespective of the action, the ordering of rows in <code>data</code> is
preserved.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>,
<code><a href="ggrepel.html#topic+position_nudge_repel">position_nudge_repel</a></code>.
</p>
<p>Other position adjustments: 
<code><a href="#topic+position_dodgenudge">position_dodgenudge</a>()</code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a>()</code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a>()</code>,
<code><a href="#topic+position_nudge_keep">position_nudge_keep</a>()</code>,
<code><a href="#topic+position_nudge_line">position_nudge_line</a>()</code>,
<code><a href="#topic+position_stacknudge">position_stacknudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = c(1,3,2,5,4,2.5),
  y = c(2, 1, 2.5, 1.8, 2.8, 1.5),
  label = c("abc","cd","d","c","bcd","a")
)

# default does nothing
ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text(position = position_nudge_to())

# a single y (or x) value nudges all observations to this data value
ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text(position = position_nudge_to(y = 3))

# with a suitable geom, segments or arrows can be added
ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text_s(position = position_nudge_to(y = 3))

# alternating in y value order because y has fewer values than rows in data
ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text_s(position = position_nudge_to(y = c(3, 0)))

ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text_s(position = position_nudge_to(y = c(0, 3)))

# in data row order because y has as many values as rows in data
ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text_s(position = position_nudge_to(y = rep_len(c(0, 3), 6)))

# spread the values at equal distance within the available space
ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text_s(position =
    position_nudge_to(y = 3, x.action = "spread"))

# spread the values at equal distance within the range given by x
ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text_s(position =
    position_nudge_to(y = 3, x = c(2,4), x.action = "spread"),
    hjust = "center")

ggplot(df, aes(x, y, label = label)) +
  geom_point() +
  geom_text_s(position =
    position_nudge_to(y = 3, x = c(0,6), x.action = "spread"),
    hjust = "center")

</code></pre>

<hr>
<h2 id='position_stacknudge'>Combined positions stack and nudge</h2><span id='topic+position_stacknudge'></span><span id='topic+position_fillnudge'></span><span id='topic+position_stack_keep'></span><span id='topic+position_fill_keep'></span><span id='topic+position_stack_minmax'></span>

<h3>Description</h3>

<p><code>position_stacknudge()</code> is useful when labelling plots such as stacked
bars, stacked columns, stacked lines, etc. In contrast to
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>, <code>position_stacknudge()</code> returns
in <code>data</code> both the original coordinates and the nudged coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_stacknudge(
  vjust = 1,
  reverse = FALSE,
  x = 0,
  y = 0,
  direction = c("none", "split", "split.x", "split.y"),
  kept.origin = c("stacked", "original", "none")
)

position_fillnudge(
  vjust = 1,
  reverse = FALSE,
  x = 0,
  y = 0,
  direction = c("none", "split", "split.x", "split.y"),
  kept.origin = c("stacked", "original", "none")
)

position_stack_keep(vjust = 1, reverse = FALSE, kept.origin = "original")

position_fill_keep(vjust = 1, reverse = FALSE, kept.origin = "original")

position_stack_minmax(
  vjust = 1,
  reverse = FALSE,
  x = 0,
  y = 0,
  direction = c("none", "split", "split.x", "split.y"),
  kept.origin = c("stacked", "original", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_stacknudge_+3A_vjust">vjust</code></td>
<td>
<p>Vertical adjustment for geoms that have a position (like points
or lines), not a dimension (like bars or areas). Set to 0 to align with the
bottom, 0.5 for the middle, and 1 (the default) for the top.</p>
</td></tr>
<tr><td><code id="position_stacknudge_+3A_reverse">reverse</code></td>
<td>
<p>If TRUE, will reverse the default stacking order. This is
useful if you're rotating both the plot and legend.</p>
</td></tr>
<tr><td><code id="position_stacknudge_+3A_x">x</code>, <code id="position_stacknudge_+3A_y">y</code></td>
<td>
<p>Amount of vertical and horizontal distance to move. A numeric
vector of length 1, or of the same length as rows there are in <code>data</code>,
with nudge values in data rows order.</p>
</td></tr>
<tr><td><code id="position_stacknudge_+3A_direction">direction</code></td>
<td>
<p>One of <code>"none"</code>, <code>"split"</code>, <code>"split.x"</code> or
<code>"split.y"</code>. A value of <code>"none"</code> replicates the behavior of
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>. At the moment <code>"split"</code> changes
the sign of the nudge at zero, which is suitable for column plots with
negative slices.</p>
</td></tr>
<tr><td><code id="position_stacknudge_+3A_kept.origin">kept.origin</code></td>
<td>
<p>One of <code>"original"</code>, <code>"stacked"</code> or
<code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>position_fillnudge()</code> is useful when labelling plots such as filled
bars, filled columns, filled lines, etc. In contrast to
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>, <code>position_fillnudge()</code> returns
in <code>data</code> both the original coordinates and the nudged coordinates.
</p>
<p>The wrapper <code>position_nudge_keep()</code> has the same signature and
behaviour as <code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code> nad provides an easier to
remember name when the need is only to have access to both the original and
nudged coordinates.
</p>
<p>These position functions are backwards compatible with
<code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code> but extends it by adding support for
stacking and for geometries that make use of the original position to draw
connecting segments or arrows.
</p>
<p>The wrapper <code>position_stack_keep()</code> has the same signature and
behaviour as <code><a href="ggplot2.html#topic+position_stack">position_stack</a></code> and provides an easier to
remember name when the need is only to have access to both the original and
nudged coordinates.
</p>
<p>The wrapper <code>position_fill_keep()</code> has the same signature and
behaviour as <code><a href="ggplot2.html#topic+position_fill">position_fill</a></code> and provides an easier to
remember name when the need is only to have access to both the original and
nudged coordinates.
</p>
<p>The wrapper <code>position_stack_minmax()</code> has the same signature and
behaviour as <code><a href="#topic+position_stacknudge">position_stacknudge</a></code> but stacks y, ymin and
ymax in parallel, making it possible to stack summaries with error bars,
works correctly with <code>geom_pointrange()</code>, <code>geom_linerange()</code> and
<code>geom_errorbar()</code>.
</p>


<h3>Value</h3>

<p>A <code>"Position"</code> object.
</p>


<h3>Author(s)</h3>

<p>Michał Krassowski, edited by Pedro J. Aphalo.
</p>


<h3>Source</h3>

<p><a href="https://github.com/slowkow/ggrepel/issues/161">https://github.com/slowkow/ggrepel/issues/161</a>.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+position_nudge">position_nudge</a></code>,
<code><a href="ggplot2.html#topic+position_stack">position_stack</a></code>,
<code><a href="ggrepel.html#topic+position_nudge_repel">position_nudge_repel</a></code>.
</p>
<p>Other position adjustments: 
<code><a href="#topic+position_dodgenudge">position_dodgenudge</a>()</code>,
<code><a href="#topic+position_jitternudge">position_jitternudge</a>()</code>,
<code><a href="#topic+position_nudge_center">position_nudge_center</a>()</code>,
<code><a href="#topic+position_nudge_keep">position_nudge_keep</a>()</code>,
<code><a href="#topic+position_nudge_line">position_nudge_line</a>()</code>,
<code><a href="#topic+position_nudge_to">position_nudge_to</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(x1 = c("a", "a", "b", "b", "b"),
                 x2 = c(1, 2, 1, 3, -1),
                 grp = c("some long name", "other name", "some name",
                         "another name", "some long name"))

# Add labels to a horizontal column plot (stacked by default)
ggplot(data = df, aes(x1, x2, group = grp)) +
  geom_col(aes(fill = grp), width=0.5) +
  geom_vline(xintercept = 0) +
  geom_text(
    aes(label = grp),
    position = position_stacknudge(vjust = 0.5, y = 0.3)) +
  theme(legend.position = "none")

# Add labels to a vertical column plot (stacked by default)
ggplot(data = df, aes(x2, x1, group = grp)) +
  geom_col(aes(fill = grp), width=0.5) +
  geom_vline(xintercept = 0) +
  geom_text(
    aes(label = grp),
    position = position_stacknudge(vjust = 0.5, x = -0.3),
    angle = 90) +
  theme(legend.position = "none")

# Add labels to a vertical column plot (stacked by default)
ggplot(data = subset(df, x1 &gt;= 0), aes(x1, x2, group = grp)) +
  geom_col(aes(fill = grp), width=0.5, position = position_fill()) +
  geom_vline(xintercept = 0) +
  geom_text(
    aes(label = grp),
    position = position_fillnudge(vjust = 0.5, x = -0.3),
    angle = 90) +
  theme(legend.position = "none")

# Add label at a fixed distance from the top of each column slice
ggplot(data = df, aes(x1, x2, group = grp)) +
  geom_col(aes(fill = grp), width=0.5) +
  geom_vline(xintercept = 0) +
  geom_text(
    aes(label = grp),
    position = position_stacknudge(vjust = 1, y = -0.2)) +
  theme(legend.position = "none")

# Use geom_text_s(), geom_text_repel() or geom_label_repel() to link
# label to labelled segment or object with an arrow
ggplot(data = df, aes(x2, x1, group = grp)) +
  geom_col(aes(fill = grp), width=0.5) +
  geom_vline(xintercept = 0) +
  geom_text_s(
    aes(label = grp),
    position = position_stacknudge(vjust = 0.5, y = 0.35),
    vjust = "bottom") +
  theme(legend.position = "none")

ggplot(birch_dw.df,
       aes(y = dry.weight * 1e-3, x = Density, fill = Part)) +
   stat_summary(geom = "col", fun = mean,
                position = "stack", alpha = 0.7, width = 0.67) +
   stat_summary(geom = "linerange", fun.data = mean_cl_normal,
                position = position_stack_minmax()) +
  labs(y = "Seedling dry mass (g)") +
  scale_fill_grey(start = 0.7, end = 0.3) +
  facet_wrap(facets = vars(Container))

</code></pre>

<hr>
<h2 id='quadrant_example.df'>Gene expression data</h2><span id='topic+quadrant_example.df'></span>

<h3>Description</h3>

<p>A dataset containing reshaped and simplified output from an
analysis of data from RNAseq done with package edgeR. Original data from
gene expression in the plant species <em>Arabidopsis thaliana</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadrant_example.df
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object with 6088 rows and 6 variables
</p>


<h3>References</h3>

<p>Rai, Neha; O'Hara, Andrew; Farkas, Daniel; Safronov, Omid;
Ratanasopa, Khuanpiroon; Wang, Fang; Lindfors, Anders V.; Jenkins,
Gareth I.; Lehto, Tarja; Salojärvi, Jarkko; Brosché, Mikael; Strid. Åke;
Aphalo, Pedro José; Morales, Luis Orlando (2020) The photoreceptor UVR8
mediates the perception of both UV-B and UV-A wavelengths up to 350 nm of
sunlight with responsivity moderated by cryptochromes. <em>Plant, Cell &amp;
Environment</em>, 43:1513-1527.
</p>


<h3>See Also</h3>

<p>Other Transcriptomics data: 
<code><a href="#topic+volcano_example.df">volcano_example.df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colnames(quadrant_example.df)
head(quadrant_example.df)

</code></pre>

<hr>
<h2 id='scale_continuous_npc'>Position scales for continuous data (npcx &amp; npcy)</h2><span id='topic+scale_continuous_npc'></span><span id='topic+scale_npcx_continuous'></span><span id='topic+scale_npcy_continuous'></span>

<h3>Description</h3>

<p><code>scale_npcx_continuous()</code> and <code>scale_npcy_continuous()</code> are
scales for continuous npcx and npcy aesthetics expressed in &quot;npc&quot; units.
There are no variants. Obviously limits are always the full range of &quot;npc&quot;
units and transformations meaningless. These scales are used by the newly
defined aesthetics <code>npcx</code> and <code>npcy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_npcx_continuous(...)

scale_npcy_continuous(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_continuous_npc_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>continuous_scale()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"Scale"</code> object.
</p>

<hr>
<h2 id='stat_apply_group'>Apply a function to x or y values</h2><span id='topic+stat_apply_group'></span><span id='topic+stat_summary_xy'></span><span id='topic+stat_centroid'></span>

<h3>Description</h3>

<p><code>stat_summary_xy()</code> and <code>stat_centroid()</code> are similar to
<code>ggplot2::stat_summary()</code> but summarize both <code>x</code> and <code>y</code>
values in the same plot layer. Differently to <code>stat_summary()</code> no
grouping based on data <code>values</code> is done; the grouping respected is that
already present based on mappings to aesthetics. This makes it possible to
highlight the actual location of the centroid with <code>geom_point()</code>,
<code>geom_text()</code>, and similar geometries. Instead, if we use
<code>geom_rug()</code> they are only a convenience avoiding the need to add two
separate layers and flipping one of them using <code>orientation = "y"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_apply_group(
  mapping = NULL,
  data = NULL,
  geom = "line",
  .fun.x = NULL,
  .fun.x.args = list(),
  .fun.y = NULL,
  .fun.y.args = list(),
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_summary_xy(
  mapping = NULL,
  data = NULL,
  geom = "point",
  .fun.x = NULL,
  .fun.x.args = list(),
  .fun.y = NULL,
  .fun.y.args = list(),
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_centroid(
  mapping = NULL,
  data = NULL,
  geom = "point",
  .fun = NULL,
  .fun.args = list(),
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_apply_group_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_.fun.x">.fun.x</code>, <code id="stat_apply_group_+3A_.fun.y">.fun.y</code>, <code id="stat_apply_group_+3A_.fun">.fun</code></td>
<td>
<p>function to be applied or the name of the function
to be applied as a character string.</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_.fun.x.args">.fun.x.args</code>, <code id="stat_apply_group_+3A_.fun.y.args">.fun.y.args</code>, <code id="stat_apply_group_+3A_.fun.args">.fun.args</code></td>
<td>
<p>additional arguments to be passed to
the function as a named list.</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_apply_group_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_apply_group</code> applies functions to data.
When possible it is preferable to use transformations through scales or
summary functions such as <code>ggplot2::stat_summary()</code>,
<code>stat_summary_xy()</code> or <code>stat_centroid()</code>. There are some
computations that are not scale transformations but are not usual summaries
either, as the number of data values does not decrease all the way to one row
per group. A typical case for a summary is the computation of quantiles. For
transformations are cumulative ones, e.g., using <code>cumsum()</code>,
<code>runmed()</code> and similar functions. Obviously, it is always possible to
apply such functions to the data before plotting and passing them to a single
layer function. However, it can be useful to apply such functions on-the-fly
to ensure that grouping is consistent between computations and aesthetics.
One particularity of these statistics is that they can apply simultaneously
different functions to <code>x</code> values and to <code>y</code> values when needed. In
contrast to these statistics, <code><a href="ggplot2.html#topic+geom_smooth">geom_smooth</a></code> applies a
function that takes both <code>x</code> and <code>y</code> values as arguments.
</p>
<p>These four statistics are similar. They differ on whether they
return a single or multiple rows of data per group.
</p>


<h3>Value</h3>

<p>A data frame with the same variables as the data input, with either a
single or multiple rows, with the values of <code>x</code> and <code>y</code> variables
replaced by the values returned by the applied functions, or possibly
filled with <code>NA</code> if no function was supplied or available by default.
If the applied function returns a named vector, the names are copied into
columns <code>x.names</code> and/or <code>y.names</code>. If the summary function
applied returns a one row data frame, it will be column bound keeping
the column names, but overwritting columns x and/or y with y from the
summary data frame. In the names returned by <code>.fun.x</code> the letter
&quot;y&quot; is replaced by &quot;x&quot;. These allows the use of the same functions as in
<code>ggplot2::stat_summary()</code>.
</p>

<dl>
<dt>x</dt><dd><p>x-value as returned by <code>.fun.x</code>, with names removed</p>
</dd>
<dt>y</dt><dd><p>y-value as returned by <code>.fun.y</code>, with names removed</p>
</dd>
<dt>x.names</dt><dd><p>if the x-value returned by <code>.fun.x</code> is named, these names</p>
</dd>
<dt>y.names</dt><dd><p>if the y-value returned by <code>.fun.y</code> is named, these names</p>
</dd>
<dt>xmin, xmax</dt><dd><p>values returned by <code>.fun.x</code> under these names, if present</p>
</dd>
<dt>ymin, ymax</dt><dd><p>values returned by <code>.fun.y</code> under these names, if present</p>
</dd>
<dt>&lt;other&gt;</dt><dd><p>additional values as returned by <code>.fun.y</code> under other names</p>
</dd>
</dl>



<h3>Note</h3>

<p>The applied function(s) must accept as first argument a vector that
matches the variables mapped to <code>x</code> or <code>y</code> aesthetics. For
<code>stat_summary_xy()</code> and <code>stat_centroid()</code> the function(s) to be
applied is(are) expected to return a vector of length 1 or a data frame
with only one row, as <code>mean_se()</code>, <code>mean_cl_normal()</code>
<code>mean_cl_boot()</code>, <code>mean_sdl()</code> and <code>median_hilow()</code> from
'ggplot2' do.
</p>
<p>For <code>stat_apply_group</code> the vectors returned by the
the functions applied to <code>x</code> and <code>y</code> must be of exactly the same
length. When only one of <code>.fun.x</code> or <code>.fun.y</code> are passed a
function as argument, the other variable in the returned data is filled
with <code>NA_real_</code>. If other values are desired, they can be set by means
of a user-defined function.
</p>


<h3>References</h3>

<p>Answers to question &quot;R ggplot on-the-fly calculation by grouping variable&quot; at
<a href="https://stackoverflow.com/questions/51412522">https://stackoverflow.com/questions/51412522</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
my.df &lt;- data.frame(X = rep(1:20,2),
                    Y = runif(40),
                    category = rep(c("A","B"), each = 20))

# make sure rows are ordered for X as we will use functions that rely on this
my.df &lt;- my.df[order(my.df[["X"]]), ]

# Centroid
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_centroid(shape = "cross", size = 6) +
  geom_point()

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_centroid(geom = "rug", linewidth = 1.5, .fun = median) +
  geom_point()

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_centroid(geom = "text", aes(label = category)) +
  geom_point()

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_summary_xy(geom = "pointrange",
                  .fun.x = mean, .fun.y = mean_se) +
  geom_point()

# quantiles
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  geom_point() +
  stat_apply_group(geom = "rug", .fun.y = quantile, .fun.x = quantile)

ggplot(my.df, aes(x = X, y = Y)) +
  geom_point() +
  stat_apply_group(geom = "rug", sides = "lr", color = "darkred",
                   .fun.y = quantile) +
  stat_apply_group(geom = "text", hjust = "right", color = "darkred",
                   .fun.y = quantile,
                   .fun.x = function(x) {rep(22, 5)}, # set x to 22
                   mapping = aes(label = after_stat(y.names))) +
                   expand_limits(x = 21)

my.probs &lt;- c(0.25, 0.5, 0.75)
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  geom_point() +
  stat_apply_group(geom = "hline",
                   aes(yintercept = after_stat(y)),
                   .fun.y = quantile,
                   .fun.y.args = list(probs = my.probs))

# cummulative summaries
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.x = function(x) {x},
                   .fun.y = cummax)

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.x = cumsum, .fun.y = cumsum)

# diff returns a shorter vector by 1 for each group
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.x = function(x) {x[-1L]},
                   .fun.y = diff, na.rm = TRUE)

# Running summaries
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  geom_point() +
  stat_apply_group(.fun.x = function(x) {x},
                   .fun.y = runmed, .fun.y.args = list(k = 5))

# Rescaling per group
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.x = function(x) {x},
                   .fun.y = function(x) {(x - min(x)) / (max(x) - min(x))})

# inspecting the returned data
if (requireNamespace("gginnards", quietly = TRUE)) {
  library(gginnards)

  ggplot(my.df, aes(x = X, y = Y, colour = category)) +
    stat_centroid(.fun = mean_se, geom = "debug")

  ggplot(my.df, aes(x = X, y = Y, colour = category)) +
    stat_summary_xy(.fun.y = mean_se, geom = "debug")

  ggplot(my.df, aes(x = X, y = Y, colour = category)) +
    stat_apply_group(.fun.y = cumsum, geom = "debug")

  ggplot(my.df, aes(x = X, y = Y, colour = category)) +
    geom_point() +
    stat_apply_group(geom = "debug",
                    .fun.x = quantile,
                    .fun.x.args = list(probs = my.probs),
                    .fun.y = quantile,
                   .fun.y.args = list(probs = my.probs))
}

</code></pre>

<hr>
<h2 id='stat_dens1d_filter'>Filter observations by local 1D density</h2><span id='topic+stat_dens1d_filter'></span><span id='topic+stat_dens1d_filter_g'></span>

<h3>Description</h3>

<p><code>stat_dens1d_filter</code> Filters-out/filters-in observations in
regions of a plot panel with high density of observations, based on the
values mapped to one of <code>x</code> and <code>y</code> aesthetics.
<code>stat_dens1d_filter_g</code> does the same filtering by group instead of by
panel. This second stat is useful for highlighting observations, while the
first one tends to be most useful when the aim is to prevent clashes among
text labels. By default the data are handled all together, but it is also
possible to control labeling separately in each tail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_dens1d_filter(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  keep.fraction = 0.1,
  keep.number = Inf,
  keep.sparse = TRUE,
  keep.these = FALSE,
  exclude.these = FALSE,
  these.target = "label",
  pool.along = c("x", "none"),
  xintercept = 0,
  invert.selection = FALSE,
  bw = "SJ",
  kernel = "gaussian",
  adjust = 1,
  n = 512,
  return.density = FALSE,
  orientation = c("x", "y"),
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE
)

stat_dens1d_filter_g(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  keep.fraction = 0.1,
  keep.number = Inf,
  keep.sparse = TRUE,
  keep.these = FALSE,
  exclude.these = FALSE,
  these.target = "label",
  pool.along = c("x", "none"),
  xintercept = 0,
  invert.selection = FALSE,
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  bw = "SJ",
  adjust = 1,
  kernel = "gaussian",
  n = 512,
  return.density = FALSE,
  orientation = c("x", "y"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_dens1d_filter_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code> or <code><a href="ggplot2.html#topic+aes_">aes_</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_keep.fraction">keep.fraction</code></td>
<td>
<p>numeric vector of length 1 or 2 [0..1]. The fraction of
the observations (or rows) in <code>data</code> to be retained.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_keep.number">keep.number</code></td>
<td>
<p>integer vector of length 1 or 2. Set the maximum number of
observations to retain, effective only if obeying <code>keep.fraction</code>
would result in a larger number.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_keep.sparse">keep.sparse</code></td>
<td>
<p>logical If <code>TRUE</code>, the default, observations from the
more sparse regions are retained, if <code>FALSE</code> those from the densest
regions.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_keep.these">keep.these</code>, <code id="stat_dens1d_filter_+3A_exclude.these">exclude.these</code></td>
<td>
<p>character vector, integer vector, logical
vector or function that takes one or more variables in data selected by
<code>these.target</code>. Negative integers behave as in R's extraction methods.
The rows from <code>data</code> indicated by <code>keep.these</code> and
<code>exclude.these</code> are kept or excluded irrespective of the local
density.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_these.target">these.target</code></td>
<td>
<p>character, numeric or logical selecting one or more
column(s) of <code>data</code>. If <code>TRUE</code> the whole <code>data</code> object is
passed.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_pool.along">pool.along</code></td>
<td>
<p>character, one of <code>"none"</code> or <code>"x"</code>,
indicating if selection should be done pooling the observations along the
<em>x</em> aesthetic, or separately on either side of <code>xintercept</code>.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_xintercept">xintercept</code></td>
<td>
<p>numeric The split point for the data filtering. If
<code>NA</code> the data are not split.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_invert.selection">invert.selection</code></td>
<td>
<p>logical If <code>TRUE</code>, the complement of the
selected rows are returned.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_bw">bw</code></td>
<td>
<p>numeric or character The smoothing bandwidth to be used. If
numeric, the standard deviation of the smoothing kernel. If character, a
rule to choose the bandwidth, as listed in <code><a href="stats.html#topic+bw.nrd">bw.nrd</a></code>.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_kernel">kernel</code></td>
<td>
<p>character See <code><a href="stats.html#topic+density">density</a></code> for details.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_adjust">adjust</code></td>
<td>
<p>numeric A multiplicative bandwidth adjustment. This makes it
possible to adjust the bandwidth while still using the a bandwidth
estimator through an argument passed to <code>bw</code>. The larger the value
passed to <code>adjust</code> the stronger the smoothing, hence decreasing
sensitivity to local changes in density.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_n">n</code></td>
<td>
<p>numeric Number of equally spaced points at which the density is to
be estimated for applying the cut point. See <code><a href="stats.html#topic+density">density</a></code> for
details.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_return.density">return.density</code></td>
<td>
<p>logical vector of lenght 1. If <code>TRUE</code> add columns
<code>"density"</code> and <code>"keep.obs"</code> to the returned data frame.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_orientation">orientation</code></td>
<td>
<p>character The aesthetic along which density is computed.
Given explicitly by setting orientation to either <code>"x"</code> or <code>"y"</code>.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values should be
stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_dens1d_filter_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 1D density of observations of <em>x</em> or <em>y</em> is computed
with function <code><a href="stats.html#topic+density">density</a></code> and used to select observations,
passing to the geom a subset of the rows in its <code>data</code> input. The
default is to select observations in sparse regions of the plot, but the
selection can be inverted so that only observations in the densest regions
are returned. Specific observations can be protected from being deselected
and &quot;kept&quot; by passing a suitable argument to <code>keep.these</code>. Logical and
integer vectors work as indexes to rows in <code>data</code>, while a values in a
character vector are compared to the character values mapped to the
<code>label</code> aesthetic. A function passed as argument to keep.these will
receive as argument the values in the variable mapped to <code>label</code> and
should return a character, logical or numeric vector as described above. If
no variable has been mapped to <code>label</code>, row names are used in its
place.
</p>
<p>How many rows are retained in addition to those in <code>keep.these</code> is
controlled with arguments passed to <code>keep.number</code> and
<code>keep.fraction</code>. <code>keep.number</code> sets the maximum number of
observations selected, whenever <code>keep.fraction</code> results in fewer
observations selected, it is obeyed. If 'xintercept' is a finite value
within the <em>x</em> range of the data and <code>pool.along</code>
is passed <code>"none"</code> the data as are split into two groups
and <code>keep.number</code> and <code>keep.fraction</code> are applied separately to
each tail with density still computed jointly from all observations. If the
length of <code>keep.number</code> and <code>keep.fraction</code> is one, this value
is used for both tails, if their length is two, the first value is use
for the left tail and the second value for the right tail.
</p>
<p>Computation of density and of the default bandwidth require at least
two observations with different values. If data do not fulfill this
condition, they are kept only if <code>keep.fraction = 1</code>. This is correct
behavior for a single observation, but can be surprising in the case of
multiple observations.
</p>
<p>Parameters <code>keep.these</code> and <code>exclude.these</code> make it possible to
force inclusion or exclusion of observations after the density is computed.
In case of conflict, <code>exclude.these</code> overrides <code>keep.these</code>.
</p>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> a subset of the
rows in input <code>data</code> retained based on a 1D filtering criterion.
</p>


<h3>Note</h3>

<p>Which points are kept and which not depends on how dense and flexible
is the density curve estimate. This depends on the values passed as
arguments to parameters <code>n</code>, <code>bw</code> and <code>kernel</code>. It is
also important to be aware that both <code>geom_text()</code> and
<code>geom_text_repel()</code> can avoid over plotting by discarding labels at
the plot rendering stage, i.e., what is plotted may differ from what is
returned by this statistic.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code> used internally.
</p>
<p>Other statistics returning a subset of data: 
<code><a href="#topic+stat_dens1d_labels">stat_dens1d_labels</a>()</code>,
<code><a href="#topic+stat_dens2d_filter">stat_dens2d_filter</a>()</code>,
<code><a href="#topic+stat_dens2d_labels">stat_dens2d_labels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
random_string &lt;-
  function(len = 6) {
    paste(sample(letters, len, replace = TRUE), collapse = "")
  }

# Make random data.
set.seed(1001)
d &lt;- tibble::tibble(
  x = rnorm(100),
  y = rnorm(100),
  group = rep(c("A", "B"), c(50, 50)),
  lab = replicate(100, { random_string() })
)
d$xg &lt;- d$x
d$xg[51:100] &lt;- d$xg[51:100] + 1

# highlight the 1/10 of observations in sparsest regions of the plot
ggplot(data = d, aes(x, y)) +
  geom_point() +
  geom_rug(sides = "b") +
  stat_dens1d_filter(colour = "red") +
  stat_dens1d_filter(geom = "rug", colour = "red", sides = "b")

# highlight the 1/4 of observations in densest regions of the plot
ggplot(data = d, aes(x, y)) +
  geom_point() +
  geom_rug(sides = "b") +
  stat_dens1d_filter(colour = "blue",
                     keep.fraction = 1/4, keep.sparse = FALSE) +
  stat_dens1d_filter(geom = "rug", colour = "blue",
                     keep.fraction = 1/4, keep.sparse = FALSE,
                     sides = "b")

# switching axes
ggplot(data = d, aes(x, y)) +
  geom_point() +
  geom_rug(sides = "l") +
  stat_dens1d_filter(colour = "red", orientation = "y") +
  stat_dens1d_filter(geom = "rug", colour = "red", orientation = "y",
                     sides = "l")

# highlight 1/10 plus 1/10 observations in high and low density regions
ggplot(data = d, aes(x, y)) +
  geom_point() +
  geom_rug(sides = "b") +
  stat_dens1d_filter(colour = "red") +
  stat_dens1d_filter(geom = "rug", colour = "red", sides = "b") +
  stat_dens1d_filter(colour = "blue", keep.sparse = FALSE) +
  stat_dens1d_filter(geom = "rug",
                     colour = "blue", keep.sparse = FALSE, sides = "b")

# selecting the 1/10 observations in sparsest regions and their complement
ggplot(data = d, aes(x, y)) +
  stat_dens1d_filter(colour = "red") +
  stat_dens1d_filter(geom = "rug", colour = "red", sides = "b") +
  stat_dens1d_filter(colour = "blue", invert.selection = TRUE) +
  stat_dens1d_filter(geom = "rug",
                     colour = "blue", invert.selection = TRUE, sides = "b")

# density filtering done jointly across groups
ggplot(data = d, aes(xg, y, colour = group)) +
  geom_point() +
  geom_rug(sides = "b", colour = "black") +
  stat_dens1d_filter(shape = 1, size = 3, keep.fraction = 1/4, adjust = 2)

# density filtering done independently for each group
ggplot(data = d, aes(xg, y, colour = group)) +
  geom_point() +
  geom_rug(sides = "b") +
  stat_dens1d_filter_g(shape = 1, size = 3, keep.fraction = 1/4, adjust = 2)

# density filtering done jointly across groups by overriding grouping
ggplot(data = d, aes(xg, y, colour = group)) +
  geom_point() +
  geom_rug(sides = "b") +
  stat_dens1d_filter_g(colour = "black",
                       shape = 1, size = 3, keep.fraction = 1/4, adjust = 2)

# label observations
ggplot(data = d, aes(x, y, label = lab, colour = group)) +
  geom_point() +
  stat_dens1d_filter(geom = "text", hjust = "outward")

# looking under the hood with gginnards::geom_debug()
gginnards.installed &lt;- requireNamespace("ggrepel", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    stat_dens1d_filter(geom = "debug")

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    stat_dens1d_filter(geom = "debug", return.density = TRUE)

}

</code></pre>

<hr>
<h2 id='stat_dens1d_labels'>Replace labels in data based on 1D density</h2><span id='topic+stat_dens1d_labels'></span>

<h3>Description</h3>

<p><code>stat_dens1d_labels()</code> Sets values mapped to the
<code>label</code> aesthetic to <code>""</code> or a user provided character string
based on the local density in regions of a plot panel. Its main use is
together with repulsive geoms from package <code><a href="ggrepel.html#topic+ggrepel">ggrepel</a></code>
to restrict labeling to the low density tails of a distribution. By default
the data are handled all together, but it is also possible to control
labeling separately in each tail.
</p>
<p>If there is no mapping to <code>label</code> in <code>data</code>, the mapping is set
to <code>rownames(data)</code>, with a message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_dens1d_labels(
  mapping = NULL,
  data = NULL,
  geom = "text",
  position = "identity",
  ...,
  keep.fraction = 0.1,
  keep.number = Inf,
  keep.sparse = TRUE,
  keep.these = FALSE,
  exclude.these = FALSE,
  these.target = "label",
  pool.along = c("x", "none"),
  xintercept = 0,
  invert.selection = FALSE,
  bw = "SJ",
  kernel = "gaussian",
  adjust = 1,
  n = 512,
  orientation = c("x", "y"),
  label.fill = "",
  return.density = FALSE,
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_dens1d_labels_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code> or <code><a href="ggplot2.html#topic+aes_">aes_</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_keep.fraction">keep.fraction</code></td>
<td>
<p>numeric vector of length 1 or 2 [0..1]. The fraction of
the observations (or rows) in <code>data</code> to be retained.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_keep.number">keep.number</code></td>
<td>
<p>integer vector of length 1 or 2. Set the maximum number of
observations to retain, effective only if obeying <code>keep.fraction</code>
would result in a larger number.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_keep.sparse">keep.sparse</code></td>
<td>
<p>logical If <code>TRUE</code>, the default, observations from the
more sparse regions are retained, if <code>FALSE</code> those from the densest
regions.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_keep.these">keep.these</code>, <code id="stat_dens1d_labels_+3A_exclude.these">exclude.these</code></td>
<td>
<p>character vector, integer vector, logical
vector or function that takes one or more variables in data selected by
<code>these.target</code>. Negative integers behave as in R's extraction methods.
The rows from <code>data</code> indicated by <code>keep.these</code> and
<code>exclude.these</code> are kept or excluded irrespective of the local
density.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_these.target">these.target</code></td>
<td>
<p>character, numeric or logical selecting one or more
column(s) of <code>data</code>. If <code>TRUE</code> the whole <code>data</code> object is
passed.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_pool.along">pool.along</code></td>
<td>
<p>character, one of <code>"none"</code> or <code>"x"</code>,
indicating if selection should be done pooling the observations along the
<em>x</em> aesthetic, or separately on either side of <code>xintercept</code>.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_xintercept">xintercept</code></td>
<td>
<p>numeric The split point for the data filtering.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_invert.selection">invert.selection</code></td>
<td>
<p>logical If <code>TRUE</code>, the complement of the
selected rows are returned.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_bw">bw</code></td>
<td>
<p>numeric or character The smoothing bandwidth to be used. If
numeric, the standard deviation of the smoothing kernel. If character, a
rule to choose the bandwidth, as listed in <code><a href="stats.html#topic+bw.nrd">bw.nrd</a></code>.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_kernel">kernel</code></td>
<td>
<p>character See <code><a href="stats.html#topic+density">density</a></code> for details.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_adjust">adjust</code></td>
<td>
<p>numeric A multiplicative bandwidth adjustment. This makes it
possible to adjust the bandwidth while still using the a bandwidth
estimator through an argument passed to <code>bw</code>. The larger the value
passed to <code>adjust</code> the stronger the smoothing, hence decreasing
sensitivity to local changes in density.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_n">n</code></td>
<td>
<p>numeric Number of equally spaced points at which the density is to
be estimated for applying the cut point. See <code><a href="stats.html#topic+density">density</a></code> for
details.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_orientation">orientation</code></td>
<td>
<p>character The aesthetic along which density is computed.
Given explicitly by setting orientation to either &quot;x&quot; or &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_label.fill">label.fill</code></td>
<td>
<p>character vector of length 1 or a function.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_return.density">return.density</code></td>
<td>
<p>logical vector of lenght 1. If <code>TRUE</code> add columns
<code>"density"</code> and <code>"keep.obs"</code> to the returned data frame.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_dens1d_labels_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_dens1d_labels()</code> is designed to work together with
geometries from package 'ggrepel'. To avoid text labels being plotted over
unlabelled points the corresponding rows in data need to be retained but
labels replaced with the empty character string, <code>""</code>. Function
<code><a href="#topic+stat_dens1d_filter">stat_dens1d_filter</a></code> cannot be used with the repulsive geoms
from 'ggrepel' because it drops the observations.
</p>
<p><code>stat_dens1d_labels()</code> can be useful also in other situations, as the
substitution character string can be set by the user by passing an argument
to <code>label.fill</code>. If this argument is <code>NULL</code> the unselected rows
are filtered out.
</p>
<p>The local density of observations along <em>x</em> or <em>y</em> is computed
with function <code><a href="stats.html#topic+density">density</a></code> and used to select observations,
passing to the geom all the rows in its <code>data</code> input but with with the
text of labels replaced in those &quot;not kept&quot;. The default is to select
observations in sparse regions of the plot, but the selection can be
inverted so that only observations in the densest regions are returned.
Specific observations can be protected from having the label replaced by
passing a suitable argument to <code>keep.these</code>. Logical and integer
vectors function as indexes to rows in <code>data</code>, while a character
vector is compared to values in the variable mapped to the <code>label</code>
aesthetic. A function passed as argument to keep.these will receive as
argument the values in the variable mapped to <code>label</code> and should
return a character, logical or numeric vector as described above.
</p>
<p>How many labels are retained intact in addition to those in
<code>keep.these</code> is controlled with arguments passed to <code>keep.number</code>
and <code>keep.fraction</code>. <code>keep.number</code> sets the maximum number of
observations selected, whenever <code>keep.fraction</code> results in fewer
observations selected, it is obeyed. If <code>xintercept</code> is a finite value
within the <em>x</em> range of the data and <code>pool.along</code> is passed
<code>"none"</code> the data are split into two groups and <code>keep.number</code> and
<code>keep.fraction</code> are applied separately to each tail with density still
computed jointly from all observations. If the length of <code>keep.number</code>
and <code>keep.fraction</code> is one, half this value is used each tail, if
their length is two, the first value is use for the left tail and the
second value for the right tail (or if using <code>orientation = "y"</code> the
lower and upper tails, respectively).
</p>
<p>Computation of density and of the default bandwidth require at least
two observations with different values. If data do not fulfill this
condition, they are kept only if <code>keep.fraction = 1</code>. This is correct
behavior for a single observation, but can be surprising in the case of
multiple observations.
</p>
<p>Parameters <code>keep.these</code> and <code>exclude.these</code> make it possible to
force inclusion or exclusion of labels after the density is computed.
In case of conflict, <code>exclude.these</code> overrides <code>keep.these</code>.
</p>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> the input
<code>data</code> after value substitution based on a 1D the filtering criterion.
</p>


<h3>Note</h3>

<p>Which points are kept and which not depends on how dense and flexible
is the density curve estimate. This depends on the values passed as
arguments to parameters <code>n</code>, <code>bw</code> and <code>kernel</code>. It is
also important to be aware that both <code>geom_text()</code> and
<code>geom_text_repel()</code> can avoid overplotting by discarding labels at
the plot rendering stage, i.e., what is plotted may differ from what is
returned by this statistic.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code> used internally.
</p>
<p>Other statistics returning a subset of data: 
<code><a href="#topic+stat_dens1d_filter">stat_dens1d_filter</a>()</code>,
<code><a href="#topic+stat_dens2d_filter">stat_dens2d_filter</a>()</code>,
<code><a href="#topic+stat_dens2d_labels">stat_dens2d_labels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
random_string &lt;-
  function(len = 6) {
    paste(sample(letters, len, replace = TRUE), collapse = "")
  }

# Make random data.
set.seed(1005)
d &lt;- tibble::tibble(
  x = rnorm(100),
  y = rnorm(100),
  group = rep(c("A", "B"), c(50, 50)),
  lab = replicate(100, { random_string() })
)

# using defaults
ggplot(data = d, aes(x, y, label = lab)) +
  geom_point() +
  stat_dens1d_labels()

ggrepel.installed &lt;- requireNamespace("ggrepel", quietly = TRUE)
if (ggrepel.installed) {
  library(ggrepel)

# using defaults
  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel")

# if no mapping to label is found, it is set row names
  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel")

  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel", pool.along = "none")

  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel",
                       keep.number = c(0, 10), pool.along = "none")

  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel",
                       keep.fraction = c(0, 0.2), pool.along = "none")

# using defaults, along y-axis
  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(orientation = "y", geom = "text_repel")

# example labelling with coordiantes
  ggplot(data = d, aes(x, y, label = sprintf("x = %.2f\ny = %.2f", x, y))) +
    geom_point() +
    stat_dens1d_filter(colour = "red") +
    stat_dens1d_labels(geom = "text_repel", colour = "red", size = 3)

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel")

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel", label.fill = NA)

# we keep labels starting with "a" across the whole plot, but all in sparse
# regions. To achieve this we pass as argument to label.fill a fucntion
# instead of a character string.
  label.fun &lt;- function(x) {ifelse(grepl("^a", x), x, "")}
  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens1d_labels(geom = "text_repel", label.fill = label.fun)
}

# Using geom_debug() we can see that all 100 rows in \code{d} are
# returned. But only those labelled in the previous example still contain
# the original labels.

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug")

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug", return.density = TRUE)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug", label.fill = NULL, return.density = TRUE)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug", label.fill = NA, return.density = TRUE)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens1d_labels(geom = "debug", label.fill = FALSE, return.density = TRUE)
}

</code></pre>

<hr>
<h2 id='stat_dens2d_filter'>Filter observations by local 2D density</h2><span id='topic+stat_dens2d_filter'></span><span id='topic+stat_dens2d_filter_g'></span>

<h3>Description</h3>

<p><code>stat_dens2d_filter</code> Filters-out/filters-in observations in
regions of a plot panel with high density of observations, based on the
values mapped to both <code>x</code> and <code>y</code> aesthetics.
<code>stat_dens2d_filter_g</code> does the filtering by group instead of by
panel. This second stat is useful for highlighting observations, while the
first one tends to be most useful when the aim is to prevent clashes among
text labels. If there is no mapping to <code>label</code> in <code>data</code>, the
mapping is silently set to <code>rownames(data)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_dens2d_filter(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  keep.fraction = 0.1,
  keep.number = Inf,
  keep.sparse = TRUE,
  keep.these = FALSE,
  exclude.these = FALSE,
  these.target = "label",
  pool.along = c("xy", "x", "y", "none"),
  xintercept = 0,
  yintercept = 0,
  invert.selection = FALSE,
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  h = NULL,
  n = NULL,
  return.density = FALSE
)

stat_dens2d_filter_g(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  keep.fraction = 0.1,
  keep.number = Inf,
  keep.sparse = TRUE,
  keep.these = FALSE,
  exclude.these = FALSE,
  these.target = "label",
  pool.along = c("xy", "x", "y", "none"),
  xintercept = 0,
  yintercept = 0,
  invert.selection = FALSE,
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  h = NULL,
  n = NULL,
  return.density = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_dens2d_filter_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code> or <code><a href="ggplot2.html#topic+aes_">aes_</a></code>. Only needs
to be set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_keep.fraction">keep.fraction</code></td>
<td>
<p>numeric [0..1]. The fraction of the observations (or
rows) in <code>data</code> to be retained.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_keep.number">keep.number</code></td>
<td>
<p>integer Set the maximum number of observations to retain,
effective only if obeying <code>keep.fraction</code> would result in a larger
number.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_keep.sparse">keep.sparse</code></td>
<td>
<p>logical If <code>TRUE</code>, the default, observations from the
more sparse regions are retained, if <code>FALSE</code> those from the densest
regions.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_keep.these">keep.these</code>, <code id="stat_dens2d_filter_+3A_exclude.these">exclude.these</code></td>
<td>
<p>character vector, integer vector, logical
vector or function that takes one or more variables in data selected by
<code>these.target</code>. Negative integers behave as in R's extraction methods.
The rows from <code>data</code> indicated by <code>keep.these</code> and
<code>exclude.these</code> are kept or excluded irrespective of the local
density.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_these.target">these.target</code></td>
<td>
<p>character, numeric or logical selecting one or more
column(s) of <code>data</code>. If <code>TRUE</code> the whole <code>data</code> object is
passed.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_pool.along">pool.along</code></td>
<td>
<p>character, one of <code>"none"</code>, <code>"x"</code>, <code>"y"</code>, or
<code>"xy"</code> indicating if selection should be done pooling the observations
along the <em>x</em>, <code>y</code>, both axes or none based on quadrants given by
<code>xintercept</code> and <code>yintercept</code>.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_xintercept">xintercept</code>, <code id="stat_dens2d_filter_+3A_yintercept">yintercept</code></td>
<td>
<p>numeric The center point of the quadrants.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_invert.selection">invert.selection</code></td>
<td>
<p>logical If <code>TRUE</code>, the complement of the
selected rows are returned.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_h">h</code></td>
<td>
<p>vector of bandwidths for x and y directions. Defaults to normal
reference bandwidth (see bandwidth.nrd). A scalar value will be taken to
apply to both directions.</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_n">n</code></td>
<td>
<p>Number of grid points in each direction. Can be scalar or a
length-2 integer vector</p>
</td></tr>
<tr><td><code id="stat_dens2d_filter_+3A_return.density">return.density</code></td>
<td>
<p>logical vector of lenght 1. If <code>TRUE</code> add columns
<code>"density"</code> and <code>"keep.obs"</code> to the returned data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The local density of observations in 2D (<em>x</em> and <em>y</em>) is
computed with function <code><a href="MASS.html#topic+kde2d">kde2d</a></code> and used to select
observations, passing to the geom a subset of the rows in its <code>data</code>
input. The default is to select observations in sparse regions of the plot,
but the selection can be inverted so that only observations in the densest
regions are returned. Specific observations can be protected from being
deselected and &quot;kept&quot; by passing a suitable argument to <code>keep.these</code>.
Logical and integer vectors work as indexes to rows in <code>data</code>, while a
character vector values are compared to the character values mapped to the
<code>label</code> aesthetic. A function passed as argument to keep.these will
receive as argument the values in the variable mapped to <code>label</code> and
should return a character, logical or numeric vector as described above. If
no variable has been mapped to <code>label</code>, row names are used in its
place.
</p>
<p>How many rows are retained in addition to those in <code>keep.these</code> is
controlled with arguments passed to <code>keep.number</code> and
<code>keep.fraction</code>. <code>keep.number</code> sets the maximum number of
observations selected, whenever <code>keep.fraction</code> results in fewer
observations selected, it is obeyed.
</p>
<p>Computation of density and of the default bandwidth require at least
two observations with different values. If data do not fulfill this
condition, they are kept only if <code>keep.fraction = 1</code>. This is correct
behavior for a single observation, but can be surprising in the case of
multiple observations.
</p>
<p>Parameters <code>keep.these</code> and <code>exclude.these</code> make it possible to
force inclusion or exclusion of observations after the density is computed.
In case of conflict, <code>exclude.these</code> overrides <code>keep.these</code>.
</p>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> a subset of the
rows in input <code>data</code> retained based on a 2D-density-based filtering
criterion.
</p>


<h3>Note</h3>

<p>Which points are kept and which not depends on how dense a grid is used
and how flexible the density surface estimate is. This depends on the
values passed as arguments to parameters <code>n</code>, <code>bw</code> and
<code>kernel</code>. It is also important to be aware that both
<code>geom_text()</code> and <code>geom_text_repel()</code> can avoid overplotting by
discarding labels at the plot rendering stage, i.e., what is plotted may
differ from what is returned by this statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat_dens2d_labels">stat_dens2d_labels</a></code> and <code><a href="MASS.html#topic+kde2d">kde2d</a></code> used
internally. Parameters <code>n</code>, <code>h</code> in these statistics correspond to
the parameters with the same name in this imported function. Limits are set
to the limits of the plot scales.
</p>
<p>Other statistics returning a subset of data: 
<code><a href="#topic+stat_dens1d_filter">stat_dens1d_filter</a>()</code>,
<code><a href="#topic+stat_dens1d_labels">stat_dens1d_labels</a>()</code>,
<code><a href="#topic+stat_dens2d_labels">stat_dens2d_labels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
random_string &lt;-
  function(len = 6) {
    paste(sample(letters, len, replace = TRUE), collapse = "")
  }

# Make random data.
set.seed(1001)
d &lt;- tibble::tibble(
  x = rnorm(100),
  y = rnorm(100),
  group = rep(c("A", "B"), c(50, 50)),
  lab = replicate(100, { random_string() })
)

# filter (and here highlight) 1/10 observations in sparsest regions
ggplot(data = d, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(colour = "red")

# filter observations not in the sparsest regions
ggplot(data = d, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(colour = "blue", invert.selection = TRUE)

# filter observations in dense regions of the plot
ggplot(data = d, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(colour = "blue", keep.sparse = FALSE)

# filter 1/2 the observations
ggplot(data = d, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(colour = "red", keep.fraction = 0.5)

# filter 1/2 the observations but cap their number to maximum 12 observations
ggplot(data = d, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(colour = "red",
                     keep.fraction = 0.5,
                     keep.number = 12)

# density filtering done jointly across groups
ggplot(data = d, aes(x, y, colour = group)) +
  geom_point() +
  stat_dens2d_filter(shape = 1, size = 3, keep.fraction = 1/4)

# density filtering done independently for each group
ggplot(data = d, aes(x, y, colour = group)) +
  geom_point() +
  stat_dens2d_filter_g(shape = 1, size = 3, keep.fraction = 1/4)

# density filtering done jointly across groups by overriding grouping
ggplot(data = d, aes(x, y, colour = group)) +
  geom_point() +
  stat_dens2d_filter_g(colour = "black",
                       shape = 1, size = 3, keep.fraction = 1/4)

# label observations
ggplot(data = d, aes(x, y, label = lab, colour = group)) +
  geom_point() +
  stat_dens2d_filter(geom = "text")

ggplot(data = d, aes(x, y, label = lab, colour = group)) +
  geom_point() +
  stat_dens2d_filter(geom = "text",
                     keep.these = function(x) {grepl("^u", x)})

ggplot(data = d, aes(x, y, label = lab, colour = group)) +
  geom_point() +
  stat_dens2d_filter(geom = "text",
                     keep.these = function(x) {grepl("^u", x)})

ggplot(data = d, aes(x, y, label = lab, colour = group)) +
  geom_point() +
  stat_dens2d_filter(geom = "text",
                     keep.these = 1:30)

# looking under the hood with gginnards::geom_debug()
gginnards.installed &lt;- requireNamespace("ggrepel", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    stat_dens2d_filter(geom = "debug")

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens2d_filter(geom = "debug", return.density = TRUE)
}

</code></pre>

<hr>
<h2 id='stat_dens2d_labels'>Replace labels in data based on 2D density</h2><span id='topic+stat_dens2d_labels'></span>

<h3>Description</h3>

<p><code>stat_dens2d_labels()</code> Sets values mapped to the
<code>label</code> aesthetic to <code>""</code> or a user provided character string
based on the local density in regions of a plot panel. Its main use is
together with repulsive geoms from package <code><a href="ggrepel.html#topic+ggrepel">ggrepel</a></code>.
If there is no mapping to <code>label</code> in <code>data</code>, the mapping is set
to <code>rownames(data)</code>, with a message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_dens2d_labels(
  mapping = NULL,
  data = NULL,
  geom = "text",
  position = "identity",
  ...,
  keep.fraction = 0.1,
  keep.number = Inf,
  keep.sparse = TRUE,
  keep.these = FALSE,
  exclude.these = FALSE,
  these.target = "label",
  pool.along = c("xy", "x", "y", "none"),
  xintercept = 0,
  yintercept = 0,
  invert.selection = FALSE,
  h = NULL,
  n = NULL,
  label.fill = "",
  return.density = FALSE,
  na.rm = TRUE,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_dens2d_labels_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code> or <code><a href="ggplot2.html#topic+aes_">aes_</a></code>. Only needs
to be set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_keep.fraction">keep.fraction</code></td>
<td>
<p>numeric [0..1]. The fraction of the observations (or
rows) in <code>data</code> to be retained.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_keep.number">keep.number</code></td>
<td>
<p>integer Set the maximum number of observations to retain,
effective only if obeying <code>keep.fraction</code> would result in a larger
number.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_keep.sparse">keep.sparse</code></td>
<td>
<p>logical If <code>TRUE</code>, the default, observations from the
more sparse regions are retained, if <code>FALSE</code> those from the densest
regions.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_keep.these">keep.these</code>, <code id="stat_dens2d_labels_+3A_exclude.these">exclude.these</code></td>
<td>
<p>character vector, integer vector, logical
vector or function that takes one or more variables in data selected by
<code>these.target</code>. Negative integers behave as in R's extraction methods.
The rows from <code>data</code> indicated by <code>keep.these</code> and
<code>exclude.these</code> are kept or excluded irrespective of the local
density.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_these.target">these.target</code></td>
<td>
<p>character, numeric or logical selecting one or more
column(s) of <code>data</code>. If <code>TRUE</code> the whole <code>data</code> object is
passed.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_pool.along">pool.along</code></td>
<td>
<p>character, one of <code>"none"</code> or <code>"x"</code>,
indicating if selection should be done pooling the observations along the
<em>x</em> aesthetic, or separately on either side of <code>xintercept</code>.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_xintercept">xintercept</code>, <code id="stat_dens2d_labels_+3A_yintercept">yintercept</code></td>
<td>
<p>numeric The split points for the data filtering.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_invert.selection">invert.selection</code></td>
<td>
<p>logical If <code>TRUE</code>, the complement of the
selected rows are returned.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_h">h</code></td>
<td>
<p>vector of bandwidths for x and y directions. Defaults to normal
reference bandwidth (see bandwidth.nrd). A scalar value will be taken to
apply to both directions.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_n">n</code></td>
<td>
<p>Number of grid points in each direction. Can be scalar or a length-2
integer vector</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_label.fill">label.fill</code></td>
<td>
<p>character vector of length 1, a function or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_return.density">return.density</code></td>
<td>
<p>logical vector of lenght 1. If <code>TRUE</code> add columns
<code>"density"</code> and <code>"keep.obs"</code> to the returned data frame.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_dens2d_labels_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_dens2d_labels()</code> is designed to work together with
geometries from package 'ggrepel'. To avoid text labels being plotted over
unlabelled points all the rows in data need to be retained but
labels replaced with the empty character string, <code>""</code>. Function
<code><a href="#topic+stat_dens2d_filter">stat_dens2d_filter</a></code> cannot be used with the repulsive geoms
from 'ggrepel' because it drops observations.
</p>
<p><code>stat_dens2d_labels()</code> can be useful also in other situations, as the
substitution character string can be set by the user by passing an argument
to <code>label.fill</code>. If this argument is <code>NULL</code> the unselected rows
are filtered out identically as by <code>stat_dens2d_filter</code>.
</p>
<p>The local density of observations in 2D (<em>x</em> and <em>y</em>) is computed
with function <code><a href="MASS.html#topic+kde2d">kde2d</a></code> and used to select observations,
passing to the geom all the rows in its <code>data</code> input but with with the
text of labels replaced in those &quot;not kept&quot;. The default is to select
observations in sparse regions of the plot, but the selection can be
inverted so that only observations in the densest regions are returned.
Specific observations can be protected from having the label replaced by
passing a suitable argument to <code>keep.these</code>. Logical and integer
vectors function as indexes to rows in <code>data</code>, while a character
vector is compared to values in the variable mapped to the <code>label</code>
aesthetic. A function passed as argument to <code>keep.these</code> will receive
as its first argument the values in the variable mapped to <code>label</code> and
should return a character, logical or numeric vector as described above.
</p>
<p>How many labels are retained intact in addition to those in
<code>keep.these</code> is controlled with arguments passed to <code>keep.number</code>
and <code>keep.fraction</code>. <code>keep.number</code> sets the maximum number of
observations selected, whenever <code>keep.fraction</code> results in fewer
observations selected, it is obeyed.
</p>
<p>Computation of density and of the default bandwidth require at least
two observations with different values. If data do not fulfill this
condition, they are kept only if <code>keep.fraction = 1</code>. This is correct
behavior for a single observation, but can be surprising in the case of
multiple observations.
</p>
<p>Parameters <code>keep.these</code> and <code>exclude.these</code> make it possible to
force inclusion or exclusion of observations after the density is computed.
In case of conflict, <code>exclude.these</code> overrides <code>keep.these</code>.
</p>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> the input
<code>data</code> after value substitution based on a 2D the filtering criterion.
</p>


<h3>Note</h3>

<p>Which points are kept and which not depends on how dense a grid is used
and how flexible the density surface estimate is. This depends on the
values passed as arguments to parameters <code>n</code>, <code>bw</code> and
<code>kernel</code>. It is also important to be aware that both
<code>geom_text()</code> and <code>geom_text_repel()</code> can avoid overplotting by
discarding labels at the plot rendering stage, i.e., what is plotted may
differ from what is returned by this statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat_dens2d_filter">stat_dens2d_filter</a></code> and <code><a href="MASS.html#topic+kde2d">kde2d</a></code> used
internally. Parameters <code>n</code>, <code>h</code> in this statistic correspond to
the parameters with the same name in this imported function. Limits are set
to the limits of the plot scales.
</p>
<p>Other statistics returning a subset of data: 
<code><a href="#topic+stat_dens1d_filter">stat_dens1d_filter</a>()</code>,
<code><a href="#topic+stat_dens1d_labels">stat_dens1d_labels</a>()</code>,
<code><a href="#topic+stat_dens2d_filter">stat_dens2d_filter</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
random_string &lt;-
  function(len = 6) {
    paste(sample(letters, len, replace = TRUE), collapse = "")
  }

# Make random data.
set.seed(1001)
d &lt;- tibble::tibble(
  x = rnorm(100),
  y = rnorm(100),
  group = rep(c("A", "B"), c(50, 50)),
  lab = replicate(100, { random_string() })
)

# using defaults
ggplot(data = d, aes(x, y, label = lab)) +
  geom_point() +
  stat_dens2d_labels()

ggplot(data = d, aes(x, y, label = lab)) +
  geom_point() +
  stat_dens2d_labels(keep.these = "zoujdg")

ggplot(data = d, aes(x, y, label = lab)) +
  geom_point() +
  stat_dens2d_labels(keep.these = function(x) {grepl("^z", x)})

ggplot(data = d, aes(x, y, label = lab)) +
  geom_point() +
  stat_dens2d_labels(geom = "text_s",
                     position = position_nudge_center(x = 0.1, y = 0.1,
                                                      center_x = mean,
                                                      center_y = mean),
                     vjust = "outward_mean", hjust = "outward_mean") +
  expand_limits(x = c(-4, 4.5))

ggrepel.installed &lt;- requireNamespace("ggrepel", quietly = TRUE)
if (ggrepel.installed) {
  library(ggrepel)

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens2d_labels(geom = "text_repel")

  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens2d_labels(geom = "text_repel", label.fill = NA)

# we keep labels starting with "a" across the whole plot, but all in sparse
# regions. To achieve this we pass as argument to label.fill a fucntion
# instead of a character string.
  label.fun &lt;- function(x) {ifelse(grepl("^a", x), x, "")}
  ggplot(data = d, aes(x, y, label = lab, colour = group)) +
    geom_point() +
    stat_dens2d_labels(geom = "text_repel", label.fill = label.fun)
}
# Using geom_debug() we can see that all 100 rows in \code{d} are
# returned. But only those labelled in the previous example still contain
# the original labels.

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens2d_labels(geom = "debug")

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens2d_labels(geom = "debug", return.density = TRUE)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens2d_labels(geom = "debug", label.fill = NULL)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens2d_labels(geom = "debug", label.fill = FALSE, return.density = TRUE)

  ggplot(data = d, aes(x, y, label = lab)) +
    geom_point() +
    stat_dens2d_labels(geom = "debug", label.fill = NULL, return.density = TRUE)

  ggplot(data = d, aes(x, y)) +
    geom_point() +
    stat_dens2d_labels(geom = "debug")
}

</code></pre>

<hr>
<h2 id='stat_fmt_tb'>Select and slice a tibble nested in <code>data</code></h2><span id='topic+stat_fmt_tb'></span>

<h3>Description</h3>

<p><code>stat_fmt_tb</code> selects, reorders and/or renames columns and
or rows of a tibble nested in <code>data</code>. This stat is intended to be used
to pre-process <code>tibble</code> objects mapped to the <code>label</code> aesthetic
before adding them to a plot with <code>geom_table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_fmt_tb(
  mapping = NULL,
  data = NULL,
  geom = "table",
  tb.vars = NULL,
  tb.rows = NULL,
  digits = 3,
  position = "identity",
  table.theme = NULL,
  table.rownames = FALSE,
  table.colnames = TRUE,
  table.hjust = 0.5,
  parse = FALSE,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_fmt_tb_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code> or <code><a href="ggplot2.html#topic+aes_">aes_</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_tb.vars">tb.vars</code>, <code id="stat_fmt_tb_+3A_tb.rows">tb.rows</code></td>
<td>
<p>character or numeric vectors, optionally named, used
to select and/or rename the columns or rows in the table
returned.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of significant digits to be
retained in data.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_table.theme">table.theme</code></td>
<td>
<p>NULL, list or function A 'gridExtra' <code>ttheme</code>
definition, or a constructor for a <code>ttheme</code> or <code>NULL</code> for
default.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_table.rownames">table.rownames</code>, <code id="stat_fmt_tb_+3A_table.colnames">table.colnames</code></td>
<td>
<p>logical flag to enable or disabling
printing of row names and column names.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_table.hjust">table.hjust</code></td>
<td>
<p>numeric Horizontal justification for the core and column
headings of the table.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether <code>NA</code> values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_fmt_tb_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> a copy of the
input <code>data</code> in which the data frames mapped to <code>label</code> have been
modified.
</p>


<h3>Computed variables</h3>

<p>The output of sequentially applying
<code><a href="dplyr.html#topic+slice">slice</a></code> with <code>tb.rows</code> as argument and
<code><a href="dplyr.html#topic+select">select</a></code> with <code>tb.vars</code> to a list variable
list mapped to <code>label</code> and containing a single tibble per row
in <code>data</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_table">geom_table</a></code> for details on how tables respond
to mapped aesthetics and table themes. For details on predefined table
themes see <code><a href="#topic+ttheme_gtdefault">ttheme_gtdefault</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.df &lt;-
  tibble::tibble(
    x = c(1, 2),
    y = c(0, 4),
    group = c("A", "B"),
    tbs = list(a = tibble::tibble(Xa = 1:6, Y = rep(c("x", "y"), 3)),
               b = tibble::tibble(Xb = 1:3, Y = "x"))
  )

ggplot(my.df, aes(x, y, label = tbs)) +
  stat_fmt_tb() +
  expand_limits(x = c(0,3), y = c(-2, 6))

# Hide column names, diplay row names
ggplot(my.df, aes(x, y, label = tbs)) +
  stat_fmt_tb(table.colnames = FALSE,
              table.rownames = TRUE) +
  expand_limits(x = c(0,3), y = c(-2, 6))

# Use a theme for the table
ggplot(my.df, aes(x, y, label = tbs)) +
  stat_fmt_tb(table.theme = ttheme_gtlight) +
  expand_limits(x = c(0,3), y = c(-2, 6))

# selection and renaming by column position
ggplot(my.df, aes(x, y, label = tbs)) +
  stat_fmt_tb(tb.vars = c(value = 1, group = 2),
               tb.rows = 1:3) +
  expand_limits(x = c(0,3), y = c(-2, 6))

# selection, reordering and renaming by column position
ggplot(my.df, aes(x, y, label = tbs)) +
  stat_fmt_tb(tb.vars = c(group = 2, value = 1),
              tb.rows = 1:3) +
  expand_limits(x = c(0,3), y = c(-2, 6))

# selection and renaming, using partial matching to column name
ggplot(my.df, aes(x, y, label = tbs)) +
  stat_fmt_tb(tb.vars = c(value = "X", group = "Y"),
              tb.rows = 1:3) +
  expand_limits(x = c(0,3), y = c(-2, 6))

</code></pre>

<hr>
<h2 id='stat_functions'>Draw functions as curves</h2><span id='topic+stat_functions'></span>

<h3>Description</h3>

<p><code>stat_functions()</code> computes values from functions and returns new data
containing numeric vectors for <code>x</code> and <code>y</code>. As function definitions
are passed through <code>data</code> this statistic follows the grammar of graphics in
its behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_functions(
  mapping = NULL,
  data = NULL,
  n = 101,
  geom = "line",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_functions_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code> or <code><a href="ggplot2.html#topic+aes_">aes_</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_functions_+3A_data">data</code></td>
<td>
<p>A layer specific dataset. Useful if the function curve is to be
overlaid on other layers.</p>
</td></tr>
<tr><td><code id="stat_functions_+3A_n">n</code></td>
<td>
<p>integer Number of points to interpolate along the x axis.</p>
</td></tr>
<tr><td><code id="stat_functions_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_functions_+3A_position">position</code></td>
<td>
<p>The position adjustment to use on this layer</p>
</td></tr>
<tr><td><code id="stat_functions_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether <code>NA</code> values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_functions_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes it if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_functions_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them.</p>
</td></tr>
<tr><td><code id="stat_functions_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic can be used to plot values computed by functions. As
it follows the grammar of graphics, grouping and facets are supported. In
this it differs from <code><a href="ggplot2.html#topic+geom_function">geom_function</a></code> which behaves
like a plot annotation.
</p>
<p>Aesthetics <code>xmin</code> and <code>xmax</code> should be mapped to numeric values
defining the range of the vector to be created and passed as argument to
the function to compute the <code>y</code> values, and returned as <code>x</code> in
data. <code>n</code> is the length of this <code>x</code> vector.
</p>


<h3>Value</h3>

<p>A plot layer instance.
</p>


<h3>Computed variables</h3>

<p>Data frame with <code>n</code> rows or a multiple of
this, one for each
row in <code>data</code>. </p>

<dl>
<dt>x</dt><dd><p>numeric vector</p>
</dd>
<dt>y</dt><dd><p>numeric vactor</p>
</dd>
<dt>idx</dt><dd><p>integer vector, with values corresponding to rows in the input
<code>data</code>, i.e., for each function</p>
</dd>
</dl>

<p>As shown in one example below <code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code> can be
used to print the computed values returned by any statistic. The output
shown includes also values mapped to aesthetics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# one function

df1 &lt;- data.frame(min = 0, max = pi, fun = I(list(sin)))

ggplot(df1, aes(xmin = min, xmax = max, y = fun)) +
  stat_functions()

ggplot(df1, aes(xmin = min, xmax = max, y = fun)) +
  stat_functions(geom = "point", n = 20)

# two functions

df2 &lt;- data.frame(min = -pi, max = pi,
                  fun = I(list(sin, cos)), name = c("sin", "cos"))

# each function must be in a separate group for correct plotting of lines

ggplot(df2, aes(xmin = min, xmax = max, y = fun, group = after_stat(idx))) +
  stat_functions()

ggplot(df2, aes(xmin = min, xmax = max, y = fun, colour = name)) +
  stat_functions()

ggplot(df2, aes(xmin = min, xmax = max, y = fun)) +
  stat_functions() +
  facet_grid(~ name)

# two curves with same function

df3 &lt;- data.frame(min = c(-pi, 0),
                  max = c(0,pi),
                  fun = I(list(sin, sin)),
                  name = c("negative", "positive"))

ggplot(df3, aes(xmin = min, xmax = max, y = fun, colour = name)) +
  stat_functions()

# We use geom_debug() to see the computed values

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(df1, aes(xmin = min, xmax = max, y = fun)) +
    stat_functions(geom = "debug")

}

</code></pre>

<hr>
<h2 id='stat_panel_counts'>Number of observations in a plot panel</h2><span id='topic+stat_panel_counts'></span><span id='topic+stat_group_counts'></span>

<h3>Description</h3>

<p><code>stat_panel_counts()</code> counts the number of observations in each panel.
<code>stat_group_counts()</code> counts the number of observations in each group.
By default they add one or more text labels to the top right corner of each
panel. Grouping is ignored by <code>stat_panel_counts()</code>. If no grouping
exists, the two statistics behave similarly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_panel_counts(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  label.x = "right",
  label.y = "top",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_group_counts(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  label.x = "right",
  label.y = "top",
  hstep = 0,
  vstep = NULL,
  digits = 2,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_panel_counts_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code> or <code><a href="ggplot2.html#topic+aes_">aes_</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_data">data</code></td>
<td>
<p>A layer specific dataset. Rarely used, as you will not want to
override the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_position">position</code></td>
<td>
<p>The position adjustment to use on this layer</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_label.x">label.x</code>, <code id="stat_panel_counts_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> Coordinates (in npc units) to be used
for absolute positioning of the labels.</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether <code>NA</code> values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes it if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and should not inherit behaviour from the
default plot specification, e.g., <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_hstep">hstep</code>, <code id="stat_panel_counts_+3A_vstep">vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical step
used between labels for different groups.</p>
</td></tr>
<tr><td><code id="stat_panel_counts_+3A_digits">digits</code></td>
<td>
<p>integer Number of digits for fraction and percent labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These statistics can be used to automatically count observations in
each panel of a plot, and by default add these counts as text labels. These
statistics, unlike <code>stat_quadrant_counts()</code> requires only one of
<em>x</em> or <em>y</em> aesthetics and can be used together with statistics
that have the same requirement, like <code>stat_density()</code>.
</p>
<p>The default position of the label is in the top right corner. When using
facets even with free limits for <em>x</em> and <em>y</em> axes, the location
of the labels is consistent across panels. This is achieved by use of
<code>geom = "text_npc"</code> or <code>geom = "label_npc"</code>. To pass the
positions in native data units to <code>label.x</code> and <code>label.y</code>, pass
also explicitly <code>geom = "text"</code>, <code>geom = "label"</code> or some other
geometry that use the <em>x</em> and/or <em>y</em> aesthetics. A vector with
the same length as the number of panels in the figure can be used if
needed.
</p>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> the counts of
observations in each plot panel or per group in each plot panel.
</p>


<h3>Computed variables</h3>

<p>Data frame with one or more rows, one for each
group of observations for which counts are counted in <code>data</code>. </p>

<dl>
<dt>x,npcx</dt><dd><p>x value of label position in data- or npc units, respectively</p>
</dd>
<dt>y,npcy</dt><dd><p>y value of label position in data- or npc units, respectively</p>
</dd>
<dt>count</dt><dd><p>number of  observations as an integer</p>
</dd>
<dt>count.label</dt><dd><p>number of observations as character</p>
</dd></dl>

<p>As shown in one example below <code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code> can be
used to print the computed values returned by any statistic. The output
shown includes also values mapped to aesthetics, like <code>label</code> in the
example. <code>x</code> and <code>y</code> are included in the output only if mapped.
</p>


<h3>Note</h3>

<p>If a factor is mapped to <code>x</code> or to <code>y</code> aesthetics each level
of the factor constitutes a group, in this case the default positioning and
geom using NPC pseudo aesthetics will have to be overriden by passing
<code>geom = "text"</code> and data coordinates used. The default for factors
may change in the future.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+geom_quadrant_lines">geom_quadrant_lines</a>()</code>,
<code><a href="#topic+stat_quadrant_counts">stat_quadrant_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate artificial data with numeric x and y
set.seed(67821)
x &lt;- 1:100
y &lt;- rnorm(length(x), mean = 10)
group &lt;- factor(rep(c("A", "B"), times = 50))
my.data &lt;- data.frame(x, y, group)

# using automatically generated text labels

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_panel_counts()

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_panel_counts()

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_group_counts()

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_group_counts(label.x = "left", hstep = 0.06, vstep = 0)

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_group_counts(aes(label = after_stat(pc.label)))

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_group_counts(aes(label = after_stat(pc.label)), digits = 3)

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_group_counts(aes(label = after_stat(fr.label)))

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_group_counts(aes(label = after_stat(dec.label)))

# one of x or y can be a factor
# label.x or label.y along the factor can be set to "factor" together
# with the use of geom_text()

ggplot(mpg,
       aes(factor(cyl), hwy)) +
  stat_boxplot() +
  stat_group_counts(geom = "text",
                    label.y = 10,
                    label.x = "factor") +
  stat_panel_counts()

# Numeric values can be used to build labels with alternative formats
# Here with sprintf(), but paste() and format() also work.

ggplot(my.data, aes(x, y)) +
 geom_point() +
 stat_panel_counts(aes(label = sprintf("%i observations",
                                       after_stat(count)))) +
 scale_y_continuous(expand = expansion(mult = c(0.05, 0.12)))

ggplot(mpg,
       aes(factor(cyl), hwy)) +
  stat_boxplot() +
  stat_group_counts(geom = "text",
                    aes(label = sprintf("(%i)", after_stat(count))),
                    label.y = 10,
                    label.x = "factor")

ggplot(mpg,
       aes(factor(cyl), hwy)) +
  stat_boxplot() +
  stat_group_counts(aes(label = sprintf("n[%i]~`=`~%i",
                                        after_stat(x), after_stat(count))),
                    parse = TRUE,
                    geom = "text",
                    label.y = 10,
                    label.x = "factor") +
  stat_panel_counts(aes(label = sprintf("sum(n[i])~`=`~%i",
                                        after_stat(count))),
                    parse = TRUE)

# label position

ggplot(my.data, aes(y)) +
  stat_panel_counts(label.x = "left") +
  stat_density(alpha = 0.5)

ggplot(my.data, aes(y, colour = group)) +
  stat_group_counts(label.y = "top") +
  stat_density(aes(fill = group), alpha = 0.3)

# The numeric value can be used as a label as is

ggplot(mpg,
       aes(factor(cyl), hwy)) +
  stat_boxplot() +
  stat_group_counts(geom = "text",
                    aes(label = after_stat(count)),
                    label.x = "factor",
                    label.y = 10) +
  annotate(geom = "text", x = 0.55, y = 10, label = "n[i]~`=`", parse = TRUE)

# We use geom_debug() to see the computed values

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_panel_counts(geom = "debug")
}

if (gginnards.installed) {
  ggplot(my.data, aes(x, y, colour = group)) +
    geom_point() +
    stat_group_counts(geom = "debug")
}

</code></pre>

<hr>
<h2 id='stat_quadrant_counts'>Number of observations in quadrants</h2><span id='topic+stat_quadrant_counts'></span>

<h3>Description</h3>

<p><code>stat_quadrant_counts()</code> counts the number of observations in each
quadrant of a plot panel. By default it adds a text label to the far corner
of each quadrant. It can also be used to obtain the total number of
observations in each of two pairs of quadrants or in the whole panel.
Grouping is ignored, so en every case a single count is computed for each
quadrant in a plot panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_quadrant_counts(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  quadrants = NULL,
  pool.along = c("none", "x", "y", "xy"),
  xintercept = 0,
  yintercept = 0,
  label.x = NULL,
  label.y = NULL,
  digits = 2,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_quadrant_counts_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code> or <code><a href="ggplot2.html#topic+aes_">aes_</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_position">position</code></td>
<td>
<p>The position adjustment to use on this layer</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_quadrants">quadrants</code></td>
<td>
<p>integer vector indicating which quadrants are of interest,
with a <code>OL</code> indicating the whole plot.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_pool.along">pool.along</code></td>
<td>
<p>character, one of <code>"none"</code>, <code>"x"</code> or <code>"y"</code>,
indicating which quadrants to pool to calculate counts by pair of
quadrants.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_xintercept">xintercept</code>, <code id="stat_quadrant_counts_+3A_yintercept">yintercept</code></td>
<td>
<p>numeric the coordinates of the origin of the
quadrants.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_label.x">label.x</code>, <code id="stat_quadrant_counts_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> Coordinates (in npc units) to be used
for absolute positioning of the labels.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_digits">digits</code></td>
<td>
<p>integer Number of digits for fraction and percent labels.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether <code>NA</code> values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and should not inherit behaviour from the
default plot specification, e.g., <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_quadrant_counts_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic can be used to automatically count observations in
each of the four quadrants of a plot, and by default add these counts as
text labels. Values exactly equal to <code>xintercept</code> or
<code>yintercept</code> are counted together with those larger than the
intercepts. An argument value of zero, passed to formal parameter
<code>quadrants</code> is interpreted as a request for the count of all
observations in each plot panel.
</p>
<p>The default origin of quadrants is at <code>xintercept = 0</code>,
<code>yintercept = 0</code>. Also by default, counts are computed for all
quadrants within the <em>x</em> and <em>y</em> scale limits, but ignoring any
marginal scale expansion. The default positions of the labels is in the
farthest corner or edge of each quadrant using npc coordinates.
Consequently, when using facets even with free limits for <em>x</em> and
<em>y</em> axes, the location of the labels is consistent across panels. This
is achieved by use of <code>geom = "text_npc"</code> or <code>geom =
  "label_npc"</code>. To pass the positions in native data units, pass <code>geom =
  "text"</code> explicitly as argument.
</p>


<h3>Value</h3>

<p>A plot layer instance. Using as output <code>data</code> the counts of
observations per plot quadrant.
</p>


<h3>Computed variables</h3>

<p>Data frame with one to four rows, one for each
quadrant for which counts are counted in <code>data</code>. </p>

<dl>
<dt>quadrant</dt><dd><p>integer, one of 0:4</p>
</dd> <dt>x</dt><dd><p>x value of label position in
data units</p>
</dd> <dt>y</dt><dd><p>y value of label position in data units</p>
</dd> <dt>npcx</dt><dd><p>x
value of label position in npc units</p>
</dd> <dt>npcy</dt><dd><p>y value of label position
in npc units</p>
</dd> <dt>count</dt><dd><p>number of  observations in the quadrant(s)</p>
</dd>
<dt>total</dt><dd><p>number of onservations in data</p>
</dd>
<dt>count.label</dt><dd><p>number of observations as character</p>
</dd>
<dt>pc.label</dt><dd><p>percent of observations as character</p>
</dd>
<dt>fr.label</dt><dd><p>fraction of observations as character</p>
</dd> </dl>
<p>.
</p>
<p>As shown in one example below <code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code> can be
used to print the computed values returned by any statistic. The output
shown includes also values mapped to aesthetics, like <code>label</code> in the
example.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+geom_quadrant_lines">geom_quadrant_lines</a>()</code>,
<code><a href="#topic+stat_panel_counts">stat_panel_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate artificial data
set.seed(4321)
x &lt;- -50:50
y &lt;- rnorm(length(x), mean = 0)
my.data &lt;- data.frame(x, y)

# using automatically generated text labels, default origin at (0, 0)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts(aes(label = after_stat(pc.label)))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts(aes(label = after_stat(fr.label)))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts(aes(label = after_stat(dec.label)))

ggplot(my.data, aes(x, y)) +
 geom_point() +
  geom_quadrant_lines() +
  stat_quadrant_counts(aes(label = sprintf("%i observations", after_stat(count)))) +
  scale_y_continuous(expand = expansion(c(0.05, 0.15))) # reserve space

# user specified origin

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue", xintercept = 10, yintercept = -1) +
  stat_quadrant_counts(colour = "blue", xintercept = 10, yintercept = -1) +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue", xintercept = 10, yintercept = -1) +
  stat_quadrant_counts(aes(label = after_stat(pc.label)),
                       colour = "blue", xintercept = 10, yintercept = -1) +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

# more digits in labels

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue", xintercept = 10, yintercept = -1) +
  stat_quadrant_counts(aes(label = after_stat(pc.label)), digits = 3,
                       colour = "blue", xintercept = 10, yintercept = -1) +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue", xintercept = 10, yintercept = -1) +
  stat_quadrant_counts(aes(label = after_stat(fr.label)),
                       colour = "blue", xintercept = 10, yintercept = -1) +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

# grouped quadrants

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue",
                      pool.along = "x") +
  stat_quadrant_counts(colour = "blue", label.x = "right",
                       pool.along = "x") +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

# whole panel

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quadrant_counts(quadrants = 0, label.x = "left", label.y = "bottom") +
  scale_y_continuous(expand = expansion(mult = c(0.15, 0.05)))

# use a different geometry

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quadrant_counts(geom = "text") # use geom_text()

# Numeric values can be used to build labels with alternative formats
# Here with sprintf(), but paste() and format() also work.

ggplot(my.data, aes(x, y)) +
  geom_quadrant_lines(colour = "blue") +
  stat_quadrant_counts(aes(label = sprintf("%i of %i genes",
                       after_stat(count), after_stat(total))),
                       colour = "blue") +
  geom_point() +
  scale_y_continuous(expand = expansion(mult = 0.15))

# We use geom_debug() to see the computed values

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)
if (gginnards.installed) {
  library(gginnards)

  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quadrant_counts(geom = "debug")

  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quadrant_counts(geom = "debug", xintercept = 50)
}

</code></pre>

<hr>
<h2 id='these2logical'>Convert keep.these argument into logical vector</h2><span id='topic+these2logical'></span>

<h3>Description</h3>

<p>Convert keep.these argument into logical vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>these2logical(these, data, these.target = "label")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="these2logical_+3A_these">these</code></td>
<td>
<p>character vector, integer vector, logical vector or
function that takes the variable mapped to the <code>label</code> aesthetic as
first argument and returns a character vector or a logical vector. These
rows from <code>data</code> are selected irrespective of the local density.</p>
</td></tr>
<tr><td><code id="these2logical_+3A_data">data</code></td>
<td>
<p>data.frame The plot layer's data set.</p>
</td></tr>
<tr><td><code id="these2logical_+3A_these.target">these.target</code></td>
<td>
<p>character The name of the variable (or aesthetic) in
which to select the target passed through <code>these</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='try_data_frame'>Convert an R object into a tibble</h2><span id='topic+try_data_frame'></span><span id='topic+try_tibble'></span>

<h3>Description</h3>

<p>This functions tries to convert any R object into a data.frame object.
If <code>x</code> is already a data.frame, it is returned as is. If it is
a list or a vector it is converted by means of <code>as.data.frame()</code>.
If of any other type, a conversion into an object of class <code>xts</code> is
attempted by means of <code>try.xts()</code> and if successful the <code>xts</code>
object is converted into a data frame with a variable <code>time</code>
containing times as <code>POSIXct</code> and the remaining data columns with
the time series data. In this conversion row names are stripped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_data_frame(
  x,
  time.resolution = "month",
  as.numeric = FALSE,
  col.names = NULL
)

try_tibble(x, time.resolution = "month", as.numeric = FALSE, col.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_data_frame_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="try_data_frame_+3A_time.resolution">time.resolution</code></td>
<td>
<p>character The time unit to which the returned time
values will be rounded.</p>
</td></tr>
<tr><td><code id="try_data_frame_+3A_as.numeric">as.numeric</code></td>
<td>
<p>logical If TRUE convert time to numeric, expressed as
fractional calendar years.</p>
</td></tr>
<tr><td><code id="try_data_frame_+3A_col.names">col.names</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble::tibble</code> object, derived from <code>data.frame</code>.
</p>


<h3>Warning!</h3>

<p>The time zone was set to &quot;UTC&quot; by try.xts() in the test
cases I used. Setting TZ to &quot;UTC&quot; can cause some trouble as several
frequently used functions have as default the local or system TZ and will
apply a conversion before printing or plotting time data, which in addition
is affected by summer/winter time transitions. This should be taken into
account as even for yearly data when conversion is to POSIXct a day (1st of
January) will be set, but then shifted some hours if printed on a TZ
different from &quot;UTC&quot;. I recommend reading the documentation of package
<code><a href="lubridate.html#topic+lubridate-package">lubridate-package</a></code> where the irregularities of time
data and the difficulties they cause are very well described. In many cases
when working with time series with yearly observations it is best to work
with numeric values for years.
</p>


<h3>Note</h3>

<p>This function can be used to easily convert time series data into a
format that can be easily plotted with package <code>ggplot2</code>.
<code>try_tibble</code> is another name for <code>try_data_frame</code> which tracks
the separation and re-naming of <code>data_frame</code> into
<code>tibble::tibble</code> in the imported packages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(lynx)
try_tibble(lynx)
try_tibble(lynx, as.numeric = TRUE)
try_tibble(lynx, "year")
class(austres)
try_tibble(austres)
try_tibble(austres, as.numeric = TRUE)
try_tibble(austres, "quarter")
class(cars)
try_tibble(cars)

</code></pre>

<hr>
<h2 id='ttheme_gtdefault'>Table themes</h2><span id='topic+ttheme_gtdefault'></span><span id='topic+ttheme_gtminimal'></span><span id='topic+ttheme_gtbw'></span><span id='topic+ttheme_gtplain'></span><span id='topic+ttheme_gtdark'></span><span id='topic+ttheme_gtlight'></span><span id='topic+ttheme_gtsimple'></span><span id='topic+ttheme_gtstripes'></span>

<h3>Description</h3>

<p>Additional theme constructors for use with <code><a href="#topic+geom_table">geom_table</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttheme_gtdefault(
  base_size = 10,
  base_colour = "black",
  base_family = "",
  parse = FALSE,
  padding = unit(c(0.8, 0.6), "char"),
  ...
)

ttheme_gtminimal(
  base_size = 10,
  base_colour = "black",
  base_family = "",
  parse = FALSE,
  padding = unit(c(0.5, 0.4), "char"),
  ...
)

ttheme_gtbw(
  base_size = 10,
  base_colour = "black",
  base_family = "",
  parse = FALSE,
  padding = unit(c(1, 0.6), "char"),
  ...
)

ttheme_gtplain(
  base_size = 10,
  base_colour = "black",
  base_family = "",
  parse = FALSE,
  padding = unit(c(0.8, 0.6), "char"),
  ...
)

ttheme_gtdark(
  base_size = 10,
  base_colour = "grey90",
  base_family = "",
  parse = FALSE,
  padding = unit(c(0.8, 0.6), "char"),
  ...
)

ttheme_gtlight(
  base_size = 10,
  base_colour = "grey10",
  base_family = "",
  parse = FALSE,
  padding = unit(c(0.8, 0.6), "char"),
  ...
)

ttheme_gtsimple(
  base_size = 10,
  base_colour = "grey10",
  base_family = "",
  parse = FALSE,
  padding = unit(c(0.5, 0.4), "char"),
  ...
)

ttheme_gtstripes(
  base_size = 10,
  base_colour = "grey10",
  base_family = "",
  parse = FALSE,
  padding = unit(c(0.8, 0.6), "char"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttheme_gtdefault_+3A_base_size">base_size</code></td>
<td>
<p>numeric, default font size.</p>
</td></tr>
<tr><td><code id="ttheme_gtdefault_+3A_base_colour">base_colour</code></td>
<td>
<p>default font colour.</p>
</td></tr>
<tr><td><code id="ttheme_gtdefault_+3A_base_family">base_family</code></td>
<td>
<p>default font family.</p>
</td></tr>
<tr><td><code id="ttheme_gtdefault_+3A_parse">parse</code></td>
<td>
<p>logical, default behaviour for parsing text as plotmath.</p>
</td></tr>
<tr><td><code id="ttheme_gtdefault_+3A_padding">padding</code></td>
<td>
<p>length-2 unit vector specifying the horizontal and vertical
padding of text within each cell.</p>
</td></tr>
<tr><td><code id="ttheme_gtdefault_+3A_...">...</code></td>
<td>
<p>further arguments to control the gtable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the theme, the base_colour, which is
mapped to the <code>colour</code> aesthetic if present, is applied to only the
text elements, or to the text elements and rules. The difference is
exemplified below.
</p>


<h3>Value</h3>

<p>A <code>list</code> object that can be used as <code>ttheme</code> in the
construction of tables with functions from package 'gridExtra'.
</p>


<h3>Note</h3>

<p>These theme constructors are wrappers on
<code>gridExtra::ttheme_default()</code> and <code>gridExtra::ttheme_minimal()</code>.
They can also be used with <code><a href="gridExtra.html#topic+grid.table">grid.table</a></code> if desired.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)

mtcars %&gt;%
  group_by(cyl) %&gt;%
  summarize(wt = mean(wt), mpg = mean(mpg)) %&gt;%
  ungroup() %&gt;%
  mutate(wt = sprintf("%.2f", wt),
         mpg = sprintf("%.1f", mpg)) -&gt; tb

df &lt;- tibble(x = 5.45, y = 34, tb = list(tb))

# Same as the default theme constructor
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtdefault) +
  theme_classic()

# Minimal theme constructor
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtminimal) +
  theme_classic()

# A theme with white background
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtbw) +
  theme_bw()

# Default colour of theme superceded by aesthetic constant
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtbw, colour = "darkblue") +
  theme_bw()

# A theme with dark background
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtdark) +
  theme_dark()

# Default colour of theme superceded by aesthetic constant
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtdark, colour = "yellow") +
  theme_dark()

# A theme with light background
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtlight)

# Default colour of theme superceded by aesthetic constant
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtlight, colour = "darkred")

# Default colour of theme superceded by aesthetic constant
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtsimple)

# Default colour of theme superceded by aesthetic constant
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb),
             table.theme = ttheme_gtstripes) +
  theme_dark()

</code></pre>

<hr>
<h2 id='ttheme_set'>Set default table theme</h2><span id='topic+ttheme_set'></span>

<h3>Description</h3>

<p>Set R option to the theme to use as current default. This function is
implemented differently but is used in the same way as
<code>ggplot2::theme_set()</code> but affects the default table-theme instead
of the plot theme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttheme_set(table.theme = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttheme_set_+3A_table.theme">table.theme</code></td>
<td>
<p>NULL, list or function A gridExtra ttheme defintion, or
a constructor for a ttheme or NULL for default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the previous value of the option.
</p>


<h3>Note</h3>

<p>The ttheme is set when a plot object is constructed, and consequently
the option setting does not affect rendering of ready built plot objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)

mtcars %&gt;%
  group_by(cyl) %&gt;%
  summarize(wt = mean(wt), mpg = mean(mpg)) %&gt;%
  ungroup() %&gt;%
  mutate(wt = sprintf("%.2f", wt),
         mpg = sprintf("%.1f", mpg)) -&gt; tb

df &lt;- tibble(x = 5.45, y = 34, tb = list(tb))

# Same as the default theme constructor
ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb))

# set a new default
old_ttheme &lt;- ttheme_set(ttheme_gtstripes)

ggplot(mtcars, aes(wt, mpg, colour = factor(cyl))) +
  geom_point() +
  geom_table(data = df, aes(x = x, y = y, label = tb))

# restore previous setting
ttheme_set(old_ttheme)

</code></pre>

<hr>
<h2 id='volcano_example.df'>Gene expression data</h2><span id='topic+volcano_example.df'></span>

<h3>Description</h3>

<p>A dataset containing reshaped and simplified output from an
analysis of data from RNAseq done with package edgeR. Original data from
gene expression in the plant species <em>Arabidopsis thaliana</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volcano_example.df
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object with 1218 rows and 5 variables
</p>


<h3>References</h3>

<p>Rai, Neha; O'Hara, Andrew; Farkas, Daniel; Safronov, Omid;
Ratanasopa, Khuanpiroon; Wang, Fang; Lindfors, Anders V.; Jenkins,
Gareth I.; Lehto, Tarja; Salojärvi, Jarkko; Brosché, Mikael; Strid. Åke;
Aphalo, Pedro José; Morales, Luis Orlando (2020) The photoreceptor UVR8
mediates the perception of both UV-B and UV-A wavelengths up to 350 nm of
sunlight with responsivity moderated by cryptochromes. <em>Plant, Cell &amp;
Environment</em>, 43:1513-1527.
</p>


<h3>See Also</h3>

<p>Other Transcriptomics data: 
<code><a href="#topic+quadrant_example.df">quadrant_example.df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colnames(volcano_example.df)
head(volcano_example.df)

</code></pre>

<hr>
<h2 id='weather_18_june_2019.df'>Weather data</h2><span id='topic+weather_18_june_2019.df'></span>

<h3>Description</h3>

<p>A data set containing weather data measured in Viikki, Helsinki,
Finland. Values for all variables are means of 12 readings at 5 seconds
intervals. Sun angles were computed with R package 'photobiology'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weather_18_june_2019.df
</code></pre>


<h3>Format</h3>

<p>A tibble with 18 columns and 1440 rows.
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> time (yyyy-mm-dd hh:mm:ss)
</p>
</li>
<li><p> PAR_umol (umol m-2 s-1)
</p>
</li>
<li><p> PAR_diff_fr (/1)
</p>
</li>
<li><p> global_watt (W m-2)
</p>
</li>
<li><p> day_of_year
</p>
</li>
<li><p> month_of_year
</p>
</li>
<li><p> month_name
</p>
</li>
<li><p> calendar_year
</p>
</li>
<li><p> solar_time (h)
</p>
</li>
<li><p> sun_elevation (degrees above horizon)
</p>
</li>
<li><p> sun_azimuth (degrees)
</p>
</li>
<li><p> was_sunny (T/F)
</p>
</li>
<li><p> wind_speed (m s-1)
</p>
</li>
<li><p> wind_direction (degrees)
</p>
</li>
<li><p> air_temperature_C (C)
</p>
</li>
<li><p> air_RH (
</p>
</li>
<li><p> air_DP (C)
</p>
</li>
<li><p> air_pressure
</p>
</li></ul>



<h3>References</h3>

<p>P. J. Aphalo, unpublished data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(weather_18_june_2019.df)
head(weather_18_june_2019.df)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
