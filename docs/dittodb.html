<!DOCTYPE html><html><head><title>Help for package dittodb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dittodb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.dittodb_env'><p>an environment for dittodb storing state</p></a></li>
<li><a href='#capture_requests'><p>Capture and record database transactions and save them as mocks</p></a></li>
<li><a href='#check_for_pkg'><p>Check if a package is installed</p></a></li>
<li><a href='#clean_statement'><p>Clean a statement string</p></a></li>
<li><a href='#db_path_sanitize'><p>Switch illegal characters for legal ones</p></a></li>
<li><a href='#dittodb_debug_level'><p>Get the dittodb debug level and evaluate if it is above a level</p></a></li>
<li><a href='#driver-specifc-mock-connections'><p>Driver-specific mock classes</p></a></li>
<li><a href='#expect_sql'><p>Detect if a specific SQL statement is sent</p></a></li>
<li><a href='#get_dbname'><p>Get the <code>dbname</code> from a connection call</p></a></li>
<li><a href='#get_redactor'><p>Get the current redactor</p></a></li>
<li><a href='#get_type'><p>Get the type of an SQL statement</p></a></li>
<li><a href='#hash'><p>Make a (short) hash from a string</p></a></li>
<li><a href='#hash_db_object'><p>Extract a hash from a (result) object</p></a></li>
<li><a href='#make_path'><p>make a mock path</p></a></li>
<li><a href='#mock-db-methods'><p>Methods for interacting with DB mocks instead of an actual database</p></a></li>
<li><a href='#mockdb'><p>Run DBI queries against a mocked database</p></a></li>
<li><a href='#mockPaths'><p>Set an alternate directory for mock API fixtures</p></a></li>
<li><a href='#nycflights_sqlite'><p>An SQLite connection to a subset of nycflights13</p></a></li>
<li><a href='#nycflights13_create_sql'><p>Create a standardised database for testing</p></a></li>
<li><a href='#nycflights13_create_sqlite'><p>Create an in-memory SQLite database for testing</p></a></li>
<li><a href='#redact_columns'><p>Redact columns from a dataframe with the default redactors</p></a></li>
<li><a href='#sanitize_table_id'><p>Sanitize Table id</p></a></li>
<li><a href='#serialize_bit64'><p>Make a data.frame with pre-serialized integer64 columns</p></a></li>
<li><a href='#set_dittodb_debug_level'><p>Set dittodb's debug level</p></a></li>
<li><a href='#use_dittodb'><p>Use dittodb in your tests</p></a></li>
<li><a href='#with_mock_path'><p>Run the DBI queries in an alternate mock directory</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Test Environment for Database Requests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dittodb.jonkeane.com/">https://dittodb.jonkeane.com/</a>, <a href="https://github.com/ropensci/dittodb">https://github.com/ropensci/dittodb</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/dittodb/issues">https://github.com/ropensci/dittodb/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Testing and documenting code that communicates with remote
  databases can be painful. Although the interaction with R is usually relatively 
  simple (e.g. data(frames) passed to and from a database), because they rely on 
  a separate service and the data there, testing them can be difficult to set up,
  unsustainable in a continuous integration environment, or impossible without 
  replicating an entire production cluster. This package addresses that by 
  allowing you to make recordings from your database interactions and then play 
  them back while testing (or in other contexts) all without needing to spin up 
  or have access to the database your code would typically connect to.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), DBI</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, glue, methods, rlang, utils, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64, callr, covr, dplyr, dbplyr, knitr, nycflights13, odbc,
RMariaDB, RPostgres, RPostgreSQL, RSQLite, spelling, testthat,
withr, rmarkdown, lintr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'capture-requests.R' 'connection.R' 'dbExistsTable.R'
'dbListTables-Fields.R' 'driver-specific-connections.R'
'dbQueries-Results.R' 'dbMisc.R' 'mock-paths.R' 'dittodb-env.R'
'expect-sql.R' 'mock-db.R' 'nycflights13-sql.R' 'paths.R'
'quote.R' 'redact.R' 'serialize-bit64.R' 'transactions.R'
'use-dittodb.R' 'utils.R' 'vctrs_s3_register.R'</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-13 14:03:21 UTC; jkeane</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan Keane <a href="https://orcid.org/0000-0001-7087-9776"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mauricio Vargas <a href="https://orcid.org/0000-0003-1017-7574"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Helen Miller [rev] (reviewed the package for rOpenSci, see
    https://github.com/ropensci/software-review/issues/366),
  Etienne Racine [rev] (reviewed the package for rOpenSci, see
    https://github.com/ropensci/software-review/issues/366)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Keane &lt;jkeane@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-13 14:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='.dittodb_env'>an environment for dittodb storing state</h2><span id='topic+.dittodb_env'></span>

<h3>Description</h3>

<p>an environment for dittodb storing state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.dittodb_env
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 1.
</p>

<hr>
<h2 id='capture_requests'>Capture and record database transactions and save them as mocks</h2><span id='topic+capture_requests'></span><span id='topic+start_db_capturing'></span><span id='topic+stop_db_capturing'></span><span id='topic+capture_db_requests'></span>

<h3>Description</h3>

<p>When creating database fixtures, it can sometimes be helpful to record
the responses from the database for use in crafting tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_db_capturing(path, redact_columns = NULL)

stop_db_capturing()

capture_db_requests(expr, path, redact_columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capture_requests_+3A_path">path</code></td>
<td>
<p>the path to record mocks (default if missing: the first path in
<code>db_mock_paths()</code>.</p>
</td></tr>
<tr><td><code id="capture_requests_+3A_redact_columns">redact_columns</code></td>
<td>
<p>a character vector of columns to redact. Any column
that matches an entry will be redacted with a standard value for the column
type (e.g. characters will be replaced with &quot;[redacted]&quot;)</p>
</td></tr>
<tr><td><code id="capture_requests_+3A_expr">expr</code></td>
<td>
<p>an expression to evaluate while capturing requests (for
<code>capture_db_requests()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can start capturing with <code>start_db_capturing()</code> and end it with
<code>stop_db_capturing()</code>. All queries run against a database will be executed like
normal, but their responses will be saved to the mock path given, so that if
you use the same queries later inside of a <code><a href="#topic+with_mock_db">with_mock_db</a></code> block, the
database functions will return as if they had been run against the database.
</p>
<p>Alternatively, you can wrap the code that you are trying to capture in the
function <code>capture_db_requests({...})</code> this does the same thing as
<code>start_db_capturing()</code> and <code>stop_db_capturing()</code> but without needing to
remember to stop the recording.
</p>
<p>You can redact certain columns using the <code>redact_columns</code> argument. This will
replace the values in the column with a generic redacted version. This works
by always passing the data being saved through <code><a href="#topic+redact_columns">redact_columns</a></code>.
</p>
<p><em>note</em> You should always call <code><a href="DBI.html#topic+dbConnect">DBI::dbConnect</a></code> inside of the capturing
block. When you connect to the database, dittodb sets up the mocks for the
specific database you're connecting to when you call <code><a href="DBI.html#topic+dbConnect">DBI::dbConnect</a></code>.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibily)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (check_for_pkg("RSQLite", message)) {
  # Temporary files for examples
  nycflights_path &lt;- tempfile()

  con &lt;- nycflights13_create_sqlite(location = nycflights_path)
  dbDisconnect(con)

  start_db_capturing()
  con &lt;- dbConnect(RSQLite::SQLite(), nycflights_path)

  df_1 &lt;- dbGetQuery(con, "SELECT * FROM airlines LIMIT 1")
  res &lt;- dbSendQuery(con, "SELECT * FROM airlines LIMIT 2")
  df_2 &lt;- dbFetch(res)
  dbClearResult(res)

  dbDisconnect(con)
  stop_db_capturing()

  start_db_capturing(redact_columns = "carrier")
  con &lt;- dbConnect(RSQLite::SQLite(), nycflights_path)

  df_3 &lt;- dbGetQuery(con, "SELECT * FROM airlines LIMIT 3")

  dbDisconnect(con)
  stop_db_capturing()

  with_mock_db({
    con &lt;- dbConnect(RSQLite::SQLite(), nycflights_path)

    # the result from df1 above
    print(dbGetQuery(con, "SELECT * FROM airlines LIMIT 1"))

    # the result from df3 above
    print(dbGetQuery(con, "SELECT * FROM airlines LIMIT 3"))
  })
}

</code></pre>

<hr>
<h2 id='check_for_pkg'>Check if a package is installed</h2><span id='topic+check_for_pkg'></span>

<h3>Description</h3>

<p>Uses <code>requireNamespace()</code> to check if a package is already installed and
provides options for issuing an error, warning, etc. in case the package is
not installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_for_pkg(package, func = stop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_for_pkg_+3A_package">package</code></td>
<td>
<p>the name of the package to check for</p>
</td></tr>
<tr><td><code id="check_for_pkg_+3A_func">func</code></td>
<td>
<p>what should this check call if the package is not installed?
This can be any function, but <code>stop</code>, <code>warning</code>, <code>skip</code>, etc. are likely
candidates (default: <code>stop</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is only exported for use in examples.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the package is installed, <code>FALSE</code> if it is not (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_for_pkg("DBI")
check_for_pkg("no-such-package", func = message)
</code></pre>

<hr>
<h2 id='clean_statement'>Clean a statement string</h2><span id='topic+clean_statement'></span>

<h3>Description</h3>

<p>SQL statement strings sometimes have characters and specifications that don't
change the meaning or are determined at query time. To avoid this, before
hashing a statement we clean/strip these from the statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_statement(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_statement_+3A_string">string</code></td>
<td>
<p>an SQL statement to clean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the SQL statement stripped of extraneous bits
</p>

<hr>
<h2 id='db_path_sanitize'>Switch illegal characters for legal ones</h2><span id='topic+db_path_sanitize'></span>

<h3>Description</h3>

<p>Inspired by the <a href="https://CRAN.R-project.org/package=fs">fs</a> package's
<code>path_sanitize</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_path_sanitize(filename, replacement = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_path_sanitize_+3A_filename">filename</code></td>
<td>
<p>the file or folder to sanitize</p>
</td></tr>
<tr><td><code id="db_path_sanitize_+3A_replacement">replacement</code></td>
<td>
<p>what should the illegal character(s) be replaced with?
(default: &quot;_&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sanitized string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db_path_sanitize('this:string"has?issues')
</code></pre>

<hr>
<h2 id='dittodb_debug_level'>Get the dittodb debug level and evaluate if it is above a level</h2><span id='topic+dittodb_debug_level'></span>

<h3>Description</h3>

<p>Get the dittodb debug level and evaluate if it is above a level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dittodb_debug_level(level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dittodb_debug_level_+3A_level">level</code></td>
<td>
<p>the level to test against (greater than or equal to)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dittodb_debug_level(0)
dittodb_debug_level(2)
</code></pre>

<hr>
<h2 id='driver-specifc-mock-connections'>Driver-specific mock classes</h2><span id='topic+driver-specifc-mock-connections'></span><span id='topic+DBIMockSQLiteConnection-class'></span><span id='topic+DBIMockRPostgreSQLConnection-class'></span><span id='topic+DBIMockRPostgresConnection-class'></span><span id='topic+DBIMockMariaDBConnection-class'></span>

<h3>Description</h3>

<p>Each of the drivers that are supported have their own mock connection class.
They all inherit from <code>DBIMockConnection</code> as well as their own driver's
connection class. Each is only really available if the corresponding package
is installed.
</p>

<hr>
<h2 id='expect_sql'>Detect if a specific SQL statement is sent</h2><span id='topic+expect_sql'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_sql(object, regexp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_sql_+3A_object">object</code></td>
<td>
<p>the expression to evaluate</p>
</td></tr>
<tr><td><code id="expect_sql_+3A_regexp">regexp</code></td>
<td>
<p>the statement to match</p>
</td></tr>
<tr><td><code id="expect_sql_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="testthat.html#topic+expect_error">testthat::expect_error()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes all you need to check is if a specific SQL statement has been sent
and you don't care about retrieving the results.
</p>
<p>This works by raising an error that contains the statement that is sent to the
database as well as the location of the result. Currently, <code>expect_sql()</code> only
works with <code><a href="DBI.html#topic+dbSendQuery">DBI::dbSendQuery()</a></code> (and most implementations of <code><a href="DBI.html#topic+dbGetQuery">DBI::dbGetQuery()</a></code>
which call <code><a href="DBI.html#topic+dbSendQuery">DBI::dbSendQuery()</a></code> internally).
</p>
<p><em>Note:</em> this function is experimental and will likely evolve over time. Please
be prepared that new releases might break backwards compatibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check_for_pkg("RSQLite", message)) {
  with_mock_db({
    con &lt;- dbConnect(RSQLite::SQLite(), dbname = "not_a_db")

    expect_sql(
      dbGetQuery(con, "SELECT carrier, name FROM airlines LIMIT 3"),
      "SELECT carrier, name FROM airlines LIMIT 3"
    )
  })
}
</code></pre>

<hr>
<h2 id='get_dbname'>Get the <code>dbname</code> from a connection call</h2><span id='topic+get_dbname'></span>

<h3>Description</h3>

<p>Get the <code>dbname</code> from a connection call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dbname(dots, drv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dbname_+3A_dots">dots</code></td>
<td>
<p>from the argument being passed to the connection</p>
</td></tr>
<tr><td><code id="get_dbname_+3A_drv">drv</code></td>
<td>
<p>from the argument being passed to the connection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the name, sanitized if needed
</p>

<hr>
<h2 id='get_redactor'>Get the current redactor</h2><span id='topic+get_redactor'></span>

<h3>Description</h3>

<p>This function should generally not be used, but must be exported for the
query recording function to work properly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_redactor()
</code></pre>


<h3>Value</h3>

<p>the current list of columns to redact
</p>

<hr>
<h2 id='get_type'>Get the type of an SQL statement</h2><span id='topic+get_type'></span>

<h3>Description</h3>

<p>Get the type of an SQL statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type(statement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_+3A_statement">statement</code></td>
<td>
<p>the statement to extract the first word from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the first word in the statement
</p>

<hr>
<h2 id='hash'>Make a (short) hash from a string</h2><span id='topic+hash'></span>

<h3>Description</h3>

<p>Make a (short) hash from a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash(string, n = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hash_+3A_string">string</code></td>
<td>
<p>the string to hash</p>
</td></tr>
<tr><td><code id="hash_+3A_n">n</code></td>
<td>
<p>how long should the hash be? (default: 6)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a hash for the string
</p>

<hr>
<h2 id='hash_db_object'>Extract a hash from a (result) object</h2><span id='topic+hash_db_object'></span>

<h3>Description</h3>

<p>This function should generally not be used, but must be exported for the
query recording function to work properly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash_db_object(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hash_db_object_+3A_obj">obj</code></td>
<td>
<p>the DBI result object to hash</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hash for the object
</p>

<hr>
<h2 id='make_path'>make a mock path</h2><span id='topic+make_path'></span>

<h3>Description</h3>

<p>make a mock path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_path(path, type, hash)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_path_+3A_path">path</code></td>
<td>
<p>the path to look in</p>
</td></tr>
<tr><td><code id="make_path_+3A_type">type</code></td>
<td>
<p>what type of query is it? (e.g. <code>SELECT</code>, <code>INSERT</code>)</p>
</td></tr>
<tr><td><code id="make_path_+3A_hash">hash</code></td>
<td>
<p>the hash of the query</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a constructed path to a mock
</p>

<hr>
<h2 id='mock-db-methods'>Methods for interacting with DB mocks instead of an actual database</h2><span id='topic+mock-db-methods'></span><span id='topic+DBIMockConnection-class'></span><span id='topic+dbDisconnect+2CDBIMockConnection-method'></span><span id='topic+dbMockConnect'></span><span id='topic+dbExistsTable+2CDBIMockConnection+2Ccharacter-method'></span><span id='topic+dbExistsTable+2CDBIMockConnection+2CId-method'></span><span id='topic+dbListTables+2CDBIMockConnection-method'></span><span id='topic+dbListFields+2CDBIMockConnection+2Ccharacter-method'></span><span id='topic+dbListFields+2CDBIMockConnection+2CId-method'></span><span id='topic+dbListFields+2CDBIMockConnection+2CANY-method'></span><span id='topic+DBIMockResult-class'></span><span id='topic+dbSendQuery+2CDBIMockConnection+2Ccharacter-method'></span><span id='topic+dbSendQuery+2CDBIMockConnection+2CSQL-method'></span><span id='topic+dbSendStatement+2CDBIMockConnection+2Ccharacter-method'></span><span id='topic+dbFetch+2CDBIMockResult-method'></span><span id='topic+fetch+2CDBIMockResult+2CANY-method'></span><span id='topic+fetch+2CDBIMockResult-method'></span><span id='topic+fetch+2CDBIMockResult+2Cmissing-method'></span><span id='topic+dbClearResult+2CDBIMockResult-method'></span><span id='topic+dbHasCompleted+2CDBIMockResult-method'></span><span id='topic+dbGetQuery+2CDBIMockRPostgreSQLConnection+2Ccharacter-method'></span><span id='topic+dbGetRowsAffected+2CDBIMockResult-method'></span><span id='topic+dbGetInfo+2CDBIMockConnection-method'></span><span id='topic+dbWriteTable+2CDBIMockConnection+2Ccharacter+2Cdata.frame-method'></span><span id='topic+dbRemoveTable+2CDBIMockConnection+2Ccharacter-method'></span><span id='topic+dbColumnInfo+2CDBIMockResult-method'></span><span id='topic+dbGetInfo+2CDBIMockResult-method'></span><span id='topic+dbQuoteIdentifier+2CDBIMockRPostgresConnection+2Ccharacter-method'></span><span id='topic+dbQuoteIdentifier+2CDBIMockRPostgresConnection+2CSQL-method'></span><span id='topic+dbQuoteString+2CDBIMockRPostgresConnection+2Ccharacter-method'></span><span id='topic+dbQuoteString+2CDBIMockRPostgresConnection+2CSQL-method'></span><span id='topic+dbQuoteString+2CDBIMockMariaDBConnection+2Ccharacter-method'></span><span id='topic+dbQuoteString+2CDBIMockMariaDBConnection+2CSQL-method'></span><span id='topic+dbBegin+2CDBIMockConnection-method'></span><span id='topic+dbCommit+2CDBIMockConnection-method'></span><span id='topic+dbRollback+2CDBIMockConnection-method'></span>

<h3>Description</h3>

<p>Various methods (<code>dbSendQuery</code>, <code>dbFetchQuery</code>) that are mocks of the
<a href="https://CRAN.R-project.org/package=DBI">DBI</a> methods of the same name.
Instead of actually interacting with a database, they read in mock responses
and the code proceeds after that. These aren't used directly, but are part of
how dittodb works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DBIMockConnection'
dbDisconnect(conn, ...)

dbMockConnect(drv, ...)

## S4 method for signature 'DBIMockConnection,character'
dbExistsTable(conn, name, ...)

## S4 method for signature 'DBIMockConnection,Id'
dbExistsTable(conn, name, ...)

## S4 method for signature 'DBIMockConnection'
dbListTables(conn, ...)

## S4 method for signature 'DBIMockConnection,character'
dbListFields(conn, name, ...)

## S4 method for signature 'DBIMockConnection,Id'
dbListFields(conn, name, ...)

## S4 method for signature 'DBIMockConnection,ANY'
dbListFields(conn, name, ...)

## S4 method for signature 'DBIMockConnection,character'
dbSendQuery(conn, statement, ...)

## S4 method for signature 'DBIMockConnection,SQL'
dbSendQuery(conn, statement, ...)

## S4 method for signature 'DBIMockConnection,character'
dbSendStatement(conn, statement, ...)

## S4 method for signature 'DBIMockResult'
dbFetch(res, n = -1, ...)

## S4 method for signature 'DBIMockResult,ANY'
fetch(res, n = -1, ...)

## S4 method for signature 'DBIMockResult,missing'
fetch(res, n = -1, ...)

## S4 method for signature 'DBIMockResult'
dbClearResult(res, n, ...)

## S4 method for signature 'DBIMockResult'
dbHasCompleted(res, ...)

## S4 method for signature 'DBIMockRPostgreSQLConnection,character'
dbGetQuery(conn, statement, ...)

## S4 method for signature 'DBIMockResult'
dbGetRowsAffected(res, ...)

## S4 method for signature 'DBIMockConnection'
dbGetInfo(dbObj, ...)

## S4 method for signature 'DBIMockConnection,character,data.frame'
dbWriteTable(conn, name, value, ...)

## S4 method for signature 'DBIMockConnection,character'
dbRemoveTable(conn, name, ...)

## S4 method for signature 'DBIMockResult'
dbColumnInfo(res, ...)

## S4 method for signature 'DBIMockResult'
dbGetInfo(dbObj, ...)

## S4 method for signature 'DBIMockRPostgresConnection,character'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'DBIMockRPostgresConnection,SQL'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'DBIMockRPostgresConnection,character'
dbQuoteString(conn, x, ...)

## S4 method for signature 'DBIMockRPostgresConnection,SQL'
dbQuoteString(conn, x, ...)

## S4 method for signature 'DBIMockMariaDBConnection,character'
dbQuoteString(conn, x, ...)

## S4 method for signature 'DBIMockMariaDBConnection,SQL'
dbQuoteString(conn, x, ...)

## S4 method for signature 'DBIMockConnection'
dbBegin(conn, ..., name = NULL)

## S4 method for signature 'DBIMockConnection'
dbCommit(conn, ..., name = NULL)

## S4 method for signature 'DBIMockConnection'
dbRollback(conn, ..., name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mock-db-methods_+3A_conn">conn</code></td>
<td>
<p>a database connection (for dispatch with these methods, it should
be of class <code>DBIMockConnection</code>)</p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_...">...</code></td>
<td>
<p>arguments passed on inside of the methods</p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_drv">drv</code></td>
<td>
<p>a DB driver for use in <code><a href="DBI.html#topic+dbConnect">dbConnect</a></code></p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_name">name</code></td>
<td>
<p>name of the table (for <code><a href="DBI.html#topic+dbListFields">dbListFields</a></code>, <code><a href="DBI.html#topic+dbWriteTable">dbWriteTable</a></code>,
<code><a href="DBI.html#topic+dbRemoveTable">dbRemoveTable</a></code>)</p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_statement">statement</code></td>
<td>
<p>an SQL statement to execute</p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_res">res</code></td>
<td>
<p>a result object (for dispatch with these methods, it should be of
class <code>DBIMockResult</code>)</p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_n">n</code></td>
<td>
<p>number of results to fetch (ignored)</p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_dbobj">dbObj</code></td>
<td>
<p>a database object (a connection, result, etc.) for use in
<code><a href="DBI.html#topic+dbGetInfo">dbGetInfo</a></code></p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_value">value</code></td>
<td>
<p>a value (generally a <code>data.frame</code>) for use in <code><a href="DBI.html#topic+dbWriteTable">dbWriteTable</a></code></p>
</td></tr>
<tr><td><code id="mock-db-methods_+3A_x">x</code></td>
<td>
<p>a name to quote (for <code><a href="DBI.html#topic+dbQuoteIdentifier">dbQuoteIdentifier</a></code>)</p>
</td></tr>
</table>

<hr>
<h2 id='mockdb'>Run DBI queries against a mocked database</h2><span id='topic+mockdb'></span><span id='topic+with_mock_db'></span><span id='topic+start_mock_db'></span><span id='topic+stop_mock_db'></span>

<h3>Description</h3>

<p>Wrap a chunk of code in <code>with_mock_db()</code> to use mocked databases that will
use fixtures instead of connecting to a real database. Alternatively, you can
start and stop using a mocked database with <code>start_mock_db()</code> and
<code>stop_mock_db()</code> respectively.to execute the whole thing without needing to
remember to stop the mocking. When testing with dittodb, it will look for
fixtures in all entries of <code><a href="#topic+db_mock_paths">db_mock_paths</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_mock_db(expr)

start_mock_db()

stop_mock_db()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mockdb_+3A_expr">expr</code></td>
<td>
<p>the expression to execute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You only need to use one approach: either use <code>start_mock_db()</code> to start
using mocks and then <code>stop_mock_db()</code> to stop or use <code>with_mock_db()</code> wrapped
around the code you want to execute against the mocked database. You don't
need to (and should not) use both at the same time. Generally
<code>with_mock_db()</code> is preferred because it is slightly safer and you don't have
to remember to <code>stop_mock_db()</code> when you're done. However, it is easier to
step through tests interactively using <code>start_mock_db()</code>/<code>stop_mock_db()</code>.
</p>
<p>Connections should be made after <code>start_mock_db()</code> if you're using that
function or they should be made inside of <code>with_mock_db()</code> if you're using
that function because dittodb uses the database name (given in <code>dbname</code> or
<code>Database</code> argument of <code><a href="DBI.html#topic+dbConnect">dbConnect</a></code> depending on the driver) to separate
different fixtures. For ODBC connections with only a dsn provided, the dsn is
used for this directory.
</p>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Add the mocks included with dittodb to the db_mock_paths to use them below
db_mock_paths(system.file("nycflight_mocks", package = "dittodb"), last = TRUE)

if (check_for_pkg("RSQLite", message) &amp; check_for_pkg("testthat", message)) {
  # using  `with_mock_db()`
  with_mock_db({
    con &lt;- dbConnect(
      RSQLite::SQLite(),
      dbname = "nycflights"
    )

    testthat::test_that("We get one airline", {
      one_airline &lt;- dbGetQuery(
        con,
        "SELECT carrier, name FROM airlines LIMIT 1"
      )
      testthat::expect_s3_class(one_airline, "data.frame")
      testthat::expect_equal(nrow(one_airline), 1)
      testthat::expect_equal(one_airline$carrier, "9E")
      testthat::expect_equal(one_airline$name, "Endeavor Air Inc.")
    })

    dbDisconnect(con)
  })

  # using `start_mock_db()` and `stop_mock_db()`
  start_mock_db()
    con &lt;- dbConnect(
      RSQLite::SQLite(),
      dbname = "nycflights"
    )

  testthat::test_that("We get one airline", {
    one_airline &lt;- dbGetQuery(
      con,
      "SELECT carrier, name FROM airlines LIMIT 1"
    )
    testthat::expect_s3_class(one_airline, "data.frame")
    testthat::expect_equal(nrow(one_airline), 1)
    testthat::expect_equal(one_airline$carrier, "9E")
    testthat::expect_equal(one_airline$name, "Endeavor Air Inc.")
  })

  dbDisconnect(con)
  stop_mock_db()
}
</code></pre>

<hr>
<h2 id='mockPaths'>Set an alternate directory for mock API fixtures</h2><span id='topic+mockPaths'></span><span id='topic+db_mock_paths'></span><span id='topic+.db_mock_paths'></span>

<h3>Description</h3>

<p>By default, <code>with_mock_api</code> will look for mocks relative to the current
working directory (or the test directory). If you want to look in other
places, you can call <code>db_mock_paths</code> to add directories to the search path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_mock_paths(new, last = FALSE, replace = FALSE)

.db_mock_paths(new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mockPaths_+3A_new">new</code></td>
<td>
<p>either a character vector of path(s) to add, or <code>NULL</code> to reset
to the default.</p>
</td></tr>
<tr><td><code id="mockPaths_+3A_last">last</code></td>
<td>
<p>a logical, should the new path given be added to the end of the
list of paths? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mockPaths_+3A_replace">replace</code></td>
<td>
<p>logical, should the path replace the current mock paths
(<code>TRUE</code>) or should they be appended (to the beginning) of the current mock
paths (default, <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It works like <code><a href="base.html#topic+libPaths">base::.libPaths()</a></code>: any directories you specify will be added
to the list and searched first. The default directory will be searched last.
Only unique values are kept: if you provide a path that is already found in
<code>db_mock_paths</code>, the result effectively moves that path to the first
position.
</p>
<p>When you are capturing fixtures (e.g. with <code><a href="#topic+start_db_capturing">start_db_capturing</a></code>), the first
path is used as the path to save the fixtures in. For this reason, you may
want to set the <code>last</code> argument to <code>TRUE</code> if you want to read from a
directory but don't want to write to it.
</p>
<p>For finer-grained control, or to completely override the defaults or any
additions made by calls to <code>db_mock_paths(...)</code>, you can set the option
&quot;dittodb.mock.paths&quot;. If the option &quot;dittodb.mock.paths&quot; is set it will be
used instead of any paths set with <code>db_mock_paths(...)</code> or even inside of
<code>with_mock_path()</code>
</p>
<p>This function is similar to <code>.mockPaths()</code> from
<a href="https://CRAN.R-project.org/package=httptest">httptest</a>
</p>
<p>The function <code>.db_mock_paths</code> is the same as <code>db_mock_paths</code> although it is
deprecated and should not be used.
</p>


<h3>Value</h3>

<p>If <code>new</code> is omitted, the function returns the current search paths, a
character vector. If <code>new</code> is provided, the updated value will be returned
invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># reset mock paths to default
db_mock_paths(NULL)

identical(db_mock_paths(), c("tests/testthat/", "."))
db_mock_paths("/var/somewhere/else")
identical(db_mock_paths(), c("/var/somewhere/else", "tests/testthat/", "."))
db_mock_paths(NULL)
identical(db_mock_paths(), c("tests/testthat/", "."))
db_mock_paths("/var/somewhere/else", last = TRUE)
identical(db_mock_paths(), c("tests/testthat/", ".", "/var/somewhere/else"))
</code></pre>

<hr>
<h2 id='nycflights_sqlite'>An SQLite connection to a subset of nycflights13</h2><span id='topic+nycflights_sqlite'></span>

<h3>Description</h3>

<p>Included with dittodb is a small subset of
<a href="https://CRAN.R-project.org/package=nycflights13"><code>nycflights13</code></a>
prepopulated into a <code>sqlite</code> database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nycflights_sqlite()
</code></pre>


<h3>Details</h3>

<p>This database is helpful for getting to know dittodb and running example
code. It contains a small subset of the data in nycflights13: namely only the
flights and planes that had a destination of ORD or MDW (the codes for the
two major airports in Chicago) in February of 2013. The airports table has
also been limited to only the New York and Chicago area airports.
</p>


<h3>Value</h3>

<p>an RSQLiteConnection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check_for_pkg("RSQLite", message)) {
  con &lt;- nycflights_sqlite()

  DBI::dbGetQuery(con, "SELECT flight, tailnum, origin, dest FROM flights LIMIT 10")
  DBI::dbGetQuery(con, "SELECT faa, name, lat, lon, alt, tz FROM airports")

  DBI::dbDisconnect(con)
}
</code></pre>

<hr>
<h2 id='nycflights13_create_sql'>Create a standardised database for testing</h2><span id='topic+nycflights13_create_sql'></span>

<h3>Description</h3>

<p>Using the connection given in <code>con</code>, create a database including a few tables
from the <a href="https://CRAN.R-project.org/package=nycflights13"><code>nycflights13</code></a> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nycflights13_create_sql(con, schema = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nycflights13_create_sql_+3A_con">con</code></td>
<td>
<p>an SQL connection (i.e a PostgreSQL connection)</p>
</td></tr>
<tr><td><code id="nycflights13_create_sql_+3A_schema">schema</code></td>
<td>
<p>schema to write the tables (&quot;&quot;, or no schema by default)</p>
</td></tr>
<tr><td><code id="nycflights13_create_sql_+3A_...">...</code></td>
<td>
<p>additional parameters to connect to a database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the connection given in <code>con</code> invisibly, generally called for the
side effects of writing to the database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (check_for_pkg("RSQLite", message)) {
  con &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

  nycflights13_create_sql(con)

  DBI::dbGetQuery(
    con,
    "SELECT year, month, day, carrier, flight, tailnum FROM flights LIMIT 10"
  )

  DBI::dbDisconnect(con)
}

</code></pre>

<hr>
<h2 id='nycflights13_create_sqlite'>Create an in-memory SQLite database for testing</h2><span id='topic+nycflights13_create_sqlite'></span>

<h3>Description</h3>

<p>Create an in-memory SQLite database for testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nycflights13_create_sqlite(location = ":memory:", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nycflights13_create_sqlite_+3A_location">location</code></td>
<td>
<p>where to store the database</p>
</td></tr>
<tr><td><code id="nycflights13_create_sqlite_+3A_...">...</code></td>
<td>
<p>additional parameters to connect to a database (most are passed on
to <code><a href="#topic+nycflights13_create_sql">nycflights13_create_sql</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RSQLiteConnection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (check_for_pkg("RSQLite", message)) {
  con &lt;- nycflights13_create_sqlite()

  DBI::dbGetQuery(
    con,
    "SELECT year, month, day, carrier, flight, tailnum FROM flights LIMIT 10"
  )

  DBI::dbDisconnect(con)
}

</code></pre>

<hr>
<h2 id='redact_columns'>Redact columns from a dataframe with the default redactors</h2><span id='topic+redact_columns'></span>

<h3>Description</h3>

<p>This function redacts the columns specified in <code>columns</code> in the data given in
<code>data</code> using dittodb's standard redactors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redact_columns(data, columns, ignore.case = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redact_columns_+3A_data">data</code></td>
<td>
<p>a dataframe to redact</p>
</td></tr>
<tr><td><code id="redact_columns_+3A_columns">columns</code></td>
<td>
<p>character, the columns to redact</p>
</td></tr>
<tr><td><code id="redact_columns_+3A_ignore.case">ignore.case</code></td>
<td>
<p>should case be ignored? (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="redact_columns_+3A_...">...</code></td>
<td>
<p>additional options to pass on to <code>grep()</code> when matching the column
names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The column names given in the <code>columns</code> argument are treated as regular
expressions, however they always have <code>^</code> and <code>$</code> added to the beginning and
end of the strings. So if you would like to match any column that starts with
the string <code>sensitive</code> (e.g. <code>sensitive_name</code>, <code>sensitive_date</code>) you could
use <code style="white-space: pre;">&#8288;"sensitive.*&#8288;</code> and this would catch all of those columns (though it would
not catch a column called <code>most_sensitive_name</code>).
</p>
<p>The standard redactors replace all values in the column with the following
values based on the columns type:
</p>

<ul>
<li><p> integer &ndash; <code>9L</code>
</p>
</li>
<li><p> numeric &ndash; <code>9</code>
</p>
</li>
<li><p> character &ndash; <code>"[redacted]"</code>
</p>
</li>
<li> <p><code>POSIXct</code> (date times) &ndash; <code>as.POSIXct("1988-10-11T17:00:00", tz = tzone)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>data, with the columns specified in <code>columns</code> duly redacted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check_for_pkg("nycflights13", message)) {
  small_flights &lt;- head(nycflights13::flights)

  # with no columns specified, redacting does nothing
  redact_columns(small_flights, columns = NULL)

  # integer
  redact_columns(small_flights, columns = c("arr_time"))

  # numeric
  redact_columns(small_flights, columns = c("arr_delay"))

  # characters
  redact_columns(small_flights, columns = c("origin", "dest"))

  # datetiems
  redact_columns(small_flights, columns = c("time_hour"))
}
</code></pre>

<hr>
<h2 id='sanitize_table_id'>Sanitize Table id</h2><span id='topic+sanitize_table_id'></span>

<h3>Description</h3>

<p>Tables are identified and specified with a large number of ways across
drivers. For the purposes of dittodb, the details are less important since
we almost always just want a flat representation (<em>ie</em> for filenames). This
takes the various formats and returns a string with various elements
separated by dots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitize_table_id(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanitize_table_id_+3A_id">id</code></td>
<td>
<p>the table identifier (an <code>Id</code>, a vector of strings, or a string)</p>
</td></tr>
<tr><td><code id="sanitize_table_id_+3A_...">...</code></td>
<td>
<p>additional arguments (to allow for things like <code>schema_name</code> that
<code>odbc</code> uses.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the first word in the statement
</p>

<hr>
<h2 id='serialize_bit64'>Make a data.frame with pre-serialized integer64 columns</h2><span id='topic+serialize_bit64'></span>

<h3>Description</h3>

<p><code>integer64</code> types do not <code>dput</code> wells with <code>hexNumeric</code>. Instead, we serialize and
then unserialize them cf truecluster/bit64#27 and store that as one expression per column
This makes the resulting data.frame awkward, but it will be recorded by <code>dput</code> in a
way that does get read back in faithfully (so long as the expression isn't quoted).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialize_bit64(df_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialize_bit64_+3A_df_in">df_in</code></td>
<td>
<p>the data.frame to pre-serialize <code>integer64</code> columns from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame where each <code>integer64</code> column is a serialized expression of itself
</p>

<hr>
<h2 id='set_dittodb_debug_level'>Set dittodb's debug level</h2><span id='topic+set_dittodb_debug_level'></span>

<h3>Description</h3>

<p>It can be helpful to see what's going on by increasing dittodb's verbosity
which will show what's going on under the hood (e.g. what queries are being
requested, from where). This sets the option <code>dittodb.debug</code> to the value
given in the <code>level</code> argument. The option can be set directly with
<code>options(dittodb.debug = n)</code> as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_dittodb_debug_level(level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_dittodb_debug_level_+3A_level">level</code></td>
<td>
<p>a numeric, the level to set to (e.g. 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>level</code> argument is a numeric, where 0 is the default and (relatively)
silent. The higher the level, the more verbose dittodb will be.
</p>
<p>Currently, dittodb only has one level of debugging (any value 1 or
greater), but more might be used in the future.
</p>


<h3>Value</h3>

<p>the level, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_dittodb_debug_level(1)
set_dittodb_debug_level(0)
</code></pre>

<hr>
<h2 id='use_dittodb'>Use dittodb in your tests</h2><span id='topic+use_dittodb'></span>

<h3>Description</h3>

<p>If you would like to use dittodb in your package, and you are already using
<a href="https://CRAN.R-project.org/package=testthat">testthat</a>, use this function to
add dittodb to Suggests in the package DESCRIPTION and loads it in
<code>tests/testthat/helper.R</code>. Call it once when you're setting up a new package
test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_dittodb(path = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_dittodb_+3A_path">path</code></td>
<td>
<p>character path to the package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be called with the path to your package source as the
<code>path</code> argument. The function is idempotent: if dittodb is already added to
these files, no additional changes will be made.
</p>
<p>It will:
</p>

<ul>
<li><p> add dittodb to the <code>Suggests</code> field of the DESCRIPTION file in the
current working directory
</p>
</li>
<li><p> add <code>library(dittodb)</code> to the file <code>tests/testthat/helper.R</code> (creating it
if it doesn't already exist)
</p>
</li></ul>



<h3>Value</h3>

<p>Nothing: called for file system side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
use_dittodb()
use_dittodb("/path/to/package")

## End(Not run)
</code></pre>

<hr>
<h2 id='with_mock_path'>Run the DBI queries in an alternate mock directory</h2><span id='topic+with_mock_path'></span>

<h3>Description</h3>

<p>When testing with dittodb, wrap your tests in <code>with_mock_path({})</code> to use the
database fixtures located in other directories. dittodb will look for
fixtures in the directory specified by the user, which can be a temporary
or permanent location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_mock_path(path, expr, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_mock_path_+3A_path">path</code></td>
<td>
<p>the alternate directory</p>
</td></tr>
<tr><td><code id="with_mock_path_+3A_expr">expr</code></td>
<td>
<p>the expression to execute</p>
</td></tr>
<tr><td><code id="with_mock_path_+3A_replace">replace</code></td>
<td>
<p>logical, should the path replace the current mock paths
(<code>TRUE</code>) or should they be appended (to the beginning) of the current mock
paths (default, <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called to execute the expression(s) in <code>expr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Only run if RSQLite and testthat are available
if (check_for_pkg("RSQLite", message) &amp; check_for_pkg("testthat", message)) {
  with_mock_path(
    system.file("nycflight_mocks", package = "dittodb"),
    with_mock_db({
      con &lt;- DBI::dbConnect(
        RSQLite::SQLite(),
        dbname = "nycflights"
      )

      one_airline &lt;- dbGetQuery(
        con,
        "SELECT carrier, name FROM airlines LIMIT 1"
      )
      testthat::test_that("We get one airline", {
        testthat::expect_s3_class(one_airline, "data.frame")
        testthat::expect_equal(nrow(one_airline), 1)
        testthat::expect_equal(one_airline$carrier, "9E")
        testthat::expect_equal(one_airline$name, "Endeavor Air Inc.")
      })
      one_airline
    })
  )
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
