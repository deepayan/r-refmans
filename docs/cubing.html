<!DOCTYPE html><html><head><title>Help for package cubing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cubing}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#animate'><p>Create Cube Animations</p></a></li>
<li><a href='#comparison'><p>Logical Comparison for Cube Objects</p></a></li>
<li><a href='#composition'><p>Composition Operators For Cube Objects</p></a></li>
<li><a href='#cubieCube'><p>Create and Convert CubieCubes</p></a></li>
<li><a href='#cycle'><p>Cycle and Twist Cubies</p></a></li>
<li><a href='#getMovesCube'><p>Create a Cube for a Move Sequence</p></a></li>
<li><a href='#getMovesPattern'><p>Get Moves for Patterned Cubes</p></a></li>
<li><a href='#invCube'><p>Calculate Inverse Cube</p></a></li>
<li><a href='#invMoves'><p>Manipulate Move Sequences</p></a></li>
<li><a href='#move'><p>Moving a Cube and Creating a Move Sequence</p></a></li>
<li><a href='#plot.cube'><p>Cube Object 2D Plot</p></a></li>
<li><a href='#plot3D.cube'><p>Cube Object Interactive 3D Plot</p></a></li>
<li><a href='#read.cubesolve'><p>Read Cube Solving Reconstructions</p></a></li>
<li><a href='#rotate'><p>Perform Rotations, Wide Moves and Middle Slice Moves</p></a></li>
<li><a href='#rotations'><p>Create and Plot All Rotations of a Cube</p></a></li>
<li><a href='#scramble'><p>Generate Random Cubes, Moves and Scrambles</p></a></li>
<li><a href='#solvable'><p>Solved and Solvability Tests for Cube Objects</p></a></li>
<li><a href='#solver'><p>Rubik's Cube Solver</p></a></li>
<li><a href='#stickerCube'><p>Create and Convert StickerCubes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-04-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Rubik's Cube Solving</td>
</tr>
<tr>
<td>Author:</td>
<td>Alec Stephenson.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alec Stephenson &lt;alec_stephenson@hotmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, utils, stats, rgl</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for visualizing, animating, solving and 
        analyzing the Rubik's cube. Includes data structures for
		solvable and unsolvable cubes, random moves and random 
		state scrambles and cubes, 3D displays and animations 
		using 'OpenGL', patterned cube generation, and lightweight 
		solvers. See Rokicki, T. (2008) &lt;<a href="https://arxiv.org/abs/0803.3435">arXiv:0803.3435</a>&gt; for the
		Kociemba solver.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-15 07:02:11 UTC; ste6an</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-23 12:29:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='animate'>Create Cube Animations</h2><span id='topic+animate'></span>

<h3>Description</h3>

<p>Create cubing animation and record png frames using OpenGL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate(aCube, moves, fpt = 8, colvec = getOption("cubing.colors"), recolor = FALSE, 
   bg = grey(0.8), rand.col = FALSE, size = 0.98, col.interior = grey(0.5), 
   al.interior = 0.4, al.exterior = 1, start.delay = 2, move.delay = 0, rinit = 30, 
   bbox = TRUE, bbcolor = "#333377", bbemission = "#333377", bbspecular = "#3333FF", 
   bbshininess = 5, bbalpha = 0.5, movie = NULL, dir = file.path(getwd(), movie), 
   verbose = TRUE, start.fdelay = fpt, end.fdelay = fpt, move.fdelay = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_+3A_acube">aCube</code></td>
<td>
<p>Any cube object.</p>
</td></tr>
<tr><td><code id="animate_+3A_moves">moves</code></td>
<td>
<p>A move sequence; either a single string or a character vector with 
one element per move. Can include URFDLBEMS face turns, wide turns and xyz 
rotations.</p>
</td></tr>
<tr><td><code id="animate_+3A_fpt">fpt</code></td>
<td>
<p>Number of frames per quarter turn. Must be a non-negative even integer. 
Whole cube rotations and wide moves use half the number of frames.</p>
</td></tr>
<tr><td><code id="animate_+3A_colvec">colvec</code></td>
<td>
<p>Vector of sticker colors. The default is the <code>cubing.colors</code> option.</p>
</td></tr>
<tr><td><code id="animate_+3A_recolor">recolor</code></td>
<td>
<p>If <code>TRUE</code>, previous rotations are ignored 
and therefore the cube is recolored when initially displayed.</p>
</td></tr>
<tr><td><code id="animate_+3A_bg">bg</code></td>
<td>
<p>Background color.</p>
</td></tr>
<tr><td><code id="animate_+3A_rand.col">rand.col</code></td>
<td>
<p>If <code>TRUE</code> then sticker colors are chosen at
random and <code>colvec</code> is ignored.</p>
</td></tr>
<tr><td><code id="animate_+3A_size">size</code></td>
<td>
<p>Size of the individual cubies. Must be less than one. Values closer
to one give cubes that look stickerless because the gap between cubies 
decreases. Smaller sizes give exploded cubes.</p>
</td></tr>
<tr><td><code id="animate_+3A_col.interior">col.interior</code></td>
<td>
<p>Color of the cube interior.</p>
</td></tr>
<tr><td><code id="animate_+3A_al.interior">al.interior</code></td>
<td>
<p>Alpha value of cube interior.</p>
</td></tr>
<tr><td><code id="animate_+3A_al.exterior">al.exterior</code></td>
<td>
<p>Alpha value of cube exterior.</p>
</td></tr>
<tr><td><code id="animate_+3A_start.delay">start.delay</code></td>
<td>
<p>The delay in seconds added to the start.</p>
</td></tr>
<tr><td><code id="animate_+3A_move.delay">move.delay</code></td>
<td>
<p>The delay in seconds between moves 
(turns or rotations).</p>
</td></tr>
<tr><td><code id="animate_+3A_rinit">rinit</code></td>
<td>
<p>The initial plot is rotated <code>rinit</code> degrees about the z-axis.</p>
</td></tr>
<tr><td><code id="animate_+3A_bbox">bbox</code></td>
<td>
<p>Use a bounding box?</p>
</td></tr>
<tr><td><code id="animate_+3A_bbcolor">bbcolor</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="animate_+3A_bbemission">bbemission</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="animate_+3A_bbspecular">bbspecular</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="animate_+3A_bbshininess">bbshininess</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="animate_+3A_bbalpha">bbalpha</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="animate_+3A_movie">movie</code></td>
<td>
<p>If <code>movie</code> is a character string, then a png file is saved for every frame,
using <code>movie</code> as the base file name. The following arguments are only relevant when
<code>movie</code> is a character string.</p>
</td></tr>
<tr><td><code id="animate_+3A_dir">dir</code></td>
<td>
<p>The directory where the png frames are stored. If the directory does not
exist then it is created. By default the name of the directory is the same as the base 
filename and is located within the working directory.</p>
</td></tr>
<tr><td><code id="animate_+3A_verbose">verbose</code></td>
<td>
<p>Print progress on the saving of the png frames?</p>
</td></tr>	
<tr><td><code id="animate_+3A_start.fdelay">start.fdelay</code></td>
<td>
<p>The number of additional repeated frames added to the start.</p>
</td></tr>
<tr><td><code id="animate_+3A_end.fdelay">end.fdelay</code></td>
<td>
<p>The number of additional repeated frames added to the end.</p>
</td></tr>
<tr><td><code id="animate_+3A_move.fdelay">move.fdelay</code></td>
<td>
<p>The number of additional repeated frames between moves 
(turns or rotations).</p>
</td></tr>
<tr><td><code id="animate_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The move U3 represents three quarter turns in a clockwise direction, and so the animation
is different to the quarter turn anti-clockwise move U', even though the resulting cube is
the same. This similarly applies to the U3' and U moves, and to the half turn moves U2 and 
U2'. Wide turns can be denoted by lower case or w notation, so u2 and Uw2 are equivalent.
</p>
<p>This function uses the <span class="rlang"><b>R</b></span> package <b>rgl</b> which is an interface to OpenGL.
During the animation, the cube can be rotated using a mouse, and the rotations
will be captured in the png frames if <code>movie</code> is not <code>NULL</code>. See the 
documentation for the <b>rgl</b> package to explore the large number of options available.
</p>
<p>Following the production of the png frames, you can create movies or gifs using
external utilities. One powerful command line utility is ffmpeg. ImageMagick is
a software suite which performs similar conversions.
</p>
<p>The <code>plot3D</code> function also uses the <b>rgl</b> package to produce interactive plots 
for individual cubes.
</p>
<p>For a 2D version of the animate function, see <code>plot.seqCubes</code>.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3D.cube">plot3D.cube</a></code>, <code><a href="#topic+plot.cube">plot.cube</a></code>, 
<code><a href="#topic+plot.rotCubes">plot.rotCubes</a></code>, <code><a href="#topic+plot.seqCubes">plot.seqCubes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>scramb &lt;- "D2F2UF2DR2DBL'BRULRUL2FL'U'"
aCube &lt;- getMovesCube(scramb)
mvs &lt;- "x2D'R'L2'U'FU'F'D'U'U'R'y'R'U'Ry'RU'R'U'RUR'U'R'U'F'UFRU'"
## Not run: animate(aCube, mvs, movie = "ChoWRSolve")
</code></pre>

<hr>
<h2 id='comparison'>Logical Comparison for Cube Objects</h2><span id='topic++3D+3D.cube'></span><span id='topic+all.equal.cube'></span>

<h3>Description</h3>

<p>Determine if two cubes are equal, accounting for recoloring and rotation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
aCube == bCube 
## S3 method for class 'cube'
all.equal(target, current, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparison_+3A_acube">aCube</code>, <code id="comparison_+3A_target">target</code></td>
<td>
<p>Any cube object.</p>
</td></tr>
<tr><td><code id="comparison_+3A_bcube">bCube</code>, <code id="comparison_+3A_current">current</code></td>
<td>
<p>Any cube object.</p>
</td></tr>
<tr><td><code id="comparison_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two cubes are defined to be equal via <code>==</code> if they are the same except perhaps for 
a recoloring. This means that the permutation and orientation components are the 
same but the spatial orientation component may be different.
</p>
<p>Two cubes are defined to be the same via <code>all.equal</code> if and only if one cube is equal 
to the other following any of the 24 rotations of the whole cube (including 
the no rotation case).
</p>
<p>For testing if two cubes are exactly identical, you can use the <span class="rlang"><b>R</b></span> function
<code>identical</code>, however the cubes must be of the same type; either both cubieCubes 
or both stickerCubes.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.solvable">is.solvable</a></code>, <code><a href="#topic+is.solved">is.solved</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- randCube()
bCube &lt;- rotate(aCube, "y'")
aCube == bCube
</code></pre>

<hr>
<h2 id='composition'>Composition Operators For Cube Objects</h2><span id='topic++25v+25'></span><span id='topic++25e+25'></span><span id='topic++25c+25'></span>

<h3>Description</h3>

<p>Composition operators for cubieCube objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aCube %v% bCube
aCube %e% bCube
aCube %c% bCube
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="composition_+3A_acube">aCube</code></td>
<td>
<p>A cubieCube object.</p>
</td></tr>
<tr><td><code id="composition_+3A_bcube">bCube</code></td>
<td>
<p>A cubieCube object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both arguments must be cubieCube objects, not stickerCube objects.
</p>
<p>If A and B are cubes then A <code>%v%</code> B is the composition 
(or multiplication) of A and B. This means that if <code>a</code> and 
<code>b</code> are move sequences that produce A and B respectively from
the solved cube <code>I</code>, then A <code>%v%</code> B is produced using the combined 
move sequence <code>ab</code> applied to <code>I</code>. Typically we just write AB 
for A <code>%v%</code> B.
</p>
<p>Similarly to matrix multiplication, the operator <code>%v%</code> is associative but 
in general not commutative, with A<code>I</code> and <code>I</code>A both equal to A. 
Every 3x3x3 cube A has a unique inverse cube A' where AA' 
and A'A are both equal to <code>I</code>. The inverse cube can be calculated 
using the <code>invCube</code> function.  
</p>
<p>The <code>%e%</code> and <code>%c%</code> operators are similar to <code>%v%</code> but they compose 
only the edges and corners respectively. Use of these operators may create an unsolvable 
cube from two solvable cubes. They largely exist for internal reasons. See the help page on 
<code>cycleEdges</code> for details of their impact on solvability.
</p>


<h3>Value</h3>

<p>A cubieCube object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cycleEdges">cycleEdges</a></code>, <code><a href="#topic+getMovesCube">getMovesCube</a></code>, <code><a href="#topic+invCube">invCube</a></code>, 
<code><a href="#topic+is.solvable">is.solvable</a></code>, <code><a href="#topic+move">move</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getCubieCube("Superflip")
bCube &lt;- getCubieCube("EasyCheckerboard")
aCube %v% bCube
</code></pre>

<hr>
<h2 id='cubieCube'>Create and Convert CubieCubes</h2><span id='topic+getCubieCube'></span><span id='topic+cubieCube'></span><span id='topic+as.cubieCube'></span><span id='topic+is.cubieCube'></span>

<h3>Description</h3>

<p>Creates, converts and tests for cubieCube objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCubieCube(pattern = c("Solved","Superflip","EasyCheckerboard","Wire","PlusMinus",
  "Tablecloth","Spiral","SpeedsolvingLogo","VerticalStripes","OppositeCorners",
  "Cross","UnionJack","CubeInTheCube","CubeInACubeInACube","Anaconda","Python",
  "BlackMamba","GreenMamba","FourSpots","SixSpots","Twister","Kilt","Tetris",
  "DontCrossLine","Hi","HiAllAround","AreYouHigh","CUAround","OrderInChaos","Quote",
  "MatchingPictures","3T","LooseStrap","ZZLine","Doubler","CheckerZigzag",
  "ExchangedDuckFeet","StripeDotSolved","Picnic","PercentSign","Mirror",
  "PlusMinusCheck","FacingCheckerboards","OppositeCheckerboards","4Plus2Dots",
  "Rockets","Slash","Pillars","TwistedDuckFeet","RonsCubeInACube","Headlights",
  "CrossingSnake","Cage","4Crosses","Pyraminx","EdgeTriangle","TwistedRings",
  "ExchangedRings","TwistedChickenFeet","ExchangedChickenFeet","CornerPyramid",
  "TwistedPeaks","ExchangedPeaks","SixTwoOne","YinYang","YanYing","HenrysSnake",
  "TwistedCorners","QuickMaths"))
cubieCube(string)
as.cubieCube(aCube)
is.cubieCube(aCube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubieCube_+3A_pattern">pattern</code></td>
<td>
<p>A character string giving a pattern for the returned cube.
Approximately seventy different patterns are available. The default pattern
is the solved cube. The patterns and names are derived from the ruwix.com website.</p>
</td></tr>
<tr><td><code id="cubieCube_+3A_string">string</code></td>
<td>
<p>A character string representing the color on each cube sticker. The string
must contain only the letters URFLBD, representing the color on each face, and may contain 
any amount of white space. There must be 9 occurrences of each letter, or 8 occurrences if 
the centre stickers are omitted. A character vector can also be given instead of a character 
string, with one element for each letter. The sticker template can be displayed using the 
code at the end of the Examples section below.</p>
</td></tr>
<tr><td><code id="cubieCube_+3A_acube">aCube</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>is.cubieCube</code> function returns <code>TRUE</code> for cubieCube objects and <code>FALSE</code> 
otherwise. The <code>as.cubieCube</code> function converts a cube object to a cubieCube object and
returns an error for other arguments. 
</p>
<p>The <code>getCubieCube</code> function creates cubieCube objects using known patterns. The 
<code>cubieCube</code> function creates cubieCube objects using colors entered by the user. 
For alternative ways of creating cubieCube objects, see <code>randCube</code> and <code>getMovesCube</code>.
</p>
<p>A cubieCube is a list with five vector elements. The first four are cp ep co eo for the
corner permuation, edge permuation, corner orientation, and edge orientation. The fifth, spor,
tracks the fixed centres and therefore represents the spatial orientation. It exists to avoid
recoloring the cube when plotting it after a rotation, middle slice move or wide move. 
</p>
<p>A stickerCube object does not hold information on spatial orientation, therefore if
you convert a cubieCube to a stickerCube, and then convert back to a cubieCube, the 
spor vector will be reset to <code>1:6</code>.
</p>
<p>The <code>cubieCube</code> function contains a large amount of bulletproofing to ensure the cube
has valid cubies that are stickered correctly, but the cube may or may not be solvable. Both 
stickerCube and cubieCube objects are designed to hold both solvable and
unsolvable cubes. You can test solvability with the <code>is.solvable</code> function.
</p>


<h3>Value</h3>

<p>A logical value for <code>is.cubieCube</code>. 
A cubieCube object for all other functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMovesCube">getMovesCube</a></code>, <code><a href="#topic+is.solvable">is.solvable</a></code>, 
<code><a href="#topic+randCube">randCube</a></code>, <code><a href="#topic+stickerCube">stickerCube</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getCubieCube("Wire")
bCube &lt;- cubieCube("UUUUUUUUU RLLRRRLLR BBFFFFFBB DDDDDDDDD LRRLLLRRL FFBBBBBFF")
cCube &lt;- cubieCube("FBBBUFRRB DUUFRUFFB DBRBFDUFL FRDDDLDDL UUFULLLLL RDRRBLURB")
identical(aCube, bCube)
is.cubieCube(aCube)

## Not run: plot(aCube)
## Not run: plot3D(aCube)
## Not run: plot(cCube)
## Not run: plot3D(cCube)

## Not run: plot(getCubieCube(), numbers = TRUE)
## Not run: plot(getCubieCube(), numbers = TRUE, blank = TRUE)
</code></pre>

<hr>
<h2 id='cycle'>Cycle and Twist Cubies</h2><span id='topic+cycleEdges'></span><span id='topic+cycleCorners'></span><span id='topic+flipEdges'></span><span id='topic+twistCorners'></span>

<h3>Description</h3>

<p>Functions for cycling permuatations and altering orientations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipEdges(aCube, flip = 1:12)
twistCorners(aCube, clock = numeric(0), anti = numeric(0))
cycleEdges(aCube, cycle, right = TRUE, orient = TRUE)
cycleCorners(aCube, cycle, right = TRUE, orient = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycle_+3A_acube">aCube</code></td>
<td>
<p>A cubieCube object.</p>
</td></tr>
<tr><td><code id="cycle_+3A_flip">flip</code></td>
<td>
<p>An integer vector subset of <code>1:12</code> giving the set of edges to flip. 
By default, all edges are flipped.</p>
</td></tr>
<tr><td><code id="cycle_+3A_clock">clock</code></td>
<td>
<p>An integer vector subset of <code>1:8</code> giving the set of corners to twist 
clockwise. By default, none are twisted.</p>
</td></tr>
<tr><td><code id="cycle_+3A_anti">anti</code></td>
<td>
<p>An integer vector subset of <code>1:8</code> giving the set of corners to twist 
anti-clockwise. By default, none are twisted.</p>
</td></tr>
<tr><td><code id="cycle_+3A_cycle">cycle</code></td>
<td>
<p>An integer vector representing the permutation cycle. See Details.</p>
</td></tr>
<tr><td><code id="cycle_+3A_right">right</code></td>
<td>
<p>If <code>FALSE</code>, cycles to the left. See Details.</p>
</td></tr>
<tr><td><code id="cycle_+3A_orient">orient</code></td>
<td>
<p>Controls the orientation change for the permuation cycle. If <code>TRUE</code>
each cubie is re-oriented according to the cubie it replaces, so the orientation
vector does not change. If <code>FALSE</code> each cubie orientation is fixed so that the
orientation vector also cycles.</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>The <code>cycle</code> vector should be given according to mathematical cycle notation. For
example, the vector <code>c(5,3,7)</code> means that the edge at position 5 moves to 3, 3 moves
to 7 and 7 moves to 5. The vectors <code>c(3,7,5)</code> and <code>c(7,5,3)</code> are equivalent.
The length of the vector is the length of the cycle, and so this example is a 3-cycle.
If <code>right</code> is <code>FALSE</code> it cycles in the opposite direction, so 7 moves to 3,
3 moves to 5 and 5 moves to 7.
</p>
<p>All of these functions can change the solvability of a cube. Solvability of a cube can be 
tested using the <code>is.solvable</code> function. For orientation solvability, the sum of the 
edge orientation vector must be even, and the sum of the corner orientation 
vector must be divisible by three. For the edge orientation to remain solvable, you must flip an
even number of edges. For the corner orientation to remain solvable, the difference between
the number of clockwise and anti-clockwise twists must be divisible by three. For example,
the number of twists in each direction could be the same (a difference of zero), or you could
have three clockwise twists and no anti-clockwise twists.
</p>
<p>The sign of a permuation (even or odd) changes under a 2-cycle, which is just a swapping of two 
elements. In mathematical terminology this is called a transposition. A k-cycle can be written 
as k-1 transpositions, and therefore a k-cycle will change the sign of a permuatation if and 
only if k is even. So for a solvable cube to remain solvable, the length of <code>cycle</code> should
be odd.
</p>
<p>Two binary operators within the package that also impact solvability are <code>%e%</code> and 
<code>%c%</code>, which are composition operators for only edges and only corners respectively.
If two cubes A and B are solvable, then A <code>%e%</code> B may be unsolvable because the edge 
and corner permuations may be of different sign; the orientations will always remain solvable.
It is also possibe for A <code>%e%</code> B to be solvable but B <code>%e%</code> A to be unsolvable.
The same reasoning applies to <code>%c%</code>. 
</p>
<p>In detail: if A and B have odd permutations, then both A <code>%e%</code> B and B <code>%e%</code> A
become unsolvable. If A and B have even permutations, then both A <code>%e%</code> B and 
B <code>%e%</code> A remain solvable. If A has even and B has odd, then A <code>%e%</code> B is
unsolvable but B <code>%e%</code> A is solvable.
</p>


<h3>Value</h3>

<p>A cubieCube object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++25v+25">%v%</a></code>, <code><a href="#topic+is.solvable">is.solvable</a></code>, <code><a href="#topic+is.solved">is.solved</a></code>, <code><a href="#topic+invCube">invCube</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getCubieCube("Superflip")
aCube &lt;- flipEdges(aCube, flip = 1:12)
is.solved(aCube)
aCube &lt;- twistCorners(aCube, clock = 3:6, anti = 2)
is.solvable(aCube)
aCube &lt;- cycleEdges(aCube, c(2,10,5,6))
is.solvable(aCube)
</code></pre>

<hr>
<h2 id='getMovesCube'>Create a Cube for a Move Sequence</h2><span id='topic+getMovesCube'></span>

<h3>Description</h3>

<p>Creates a cube that corresponds to a move sequence via post-multiplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMovesCube(moves = character(0), cubie = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMovesCube_+3A_moves">moves</code></td>
<td>
<p>A move sequence; either a single string or a character vector with 
one element per move. Can include URFDLB face turns. Cannot include rotations, 
middle slice moves or wide moves.</p>
</td></tr>
<tr><td><code id="getMovesCube_+3A_cubie">cubie</code></td>
<td>
<p>If <code>FALSE</code>, produce a stickerCube rather than a cubieCube.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cube object created by this function represents the application of the move sequence
by means of post-multiplication with the composition operator <code>%v%</code>. If A
is a cube and <code>m</code> is the move sequence, then A <code>%v% getMovesCube(m)</code> is the 
cube that results from applying the move sequence to A. In particular, if A
is the solved state then this is just <code>getMovesCube(m)</code>. If <code>m</code> represents
a scramble sequence, then <code>getMovesCube(m)</code> is the scrambled cube state.
</p>
<p>The move sequence cannot include rotations, middle slice moves or wide moves because 
these cannot be expressed via post-multiplication. To implement these moves, see the <code>move</code> and <code>rotate</code> functions.  
</p>


<h3>Value</h3>

<p>A cube object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++25v+25">%v%</a></code>, <code><a href="#topic+invMoves">invMoves</a></code>,
<code><a href="#topic+move">move</a></code>, <code><a href="#topic+rotate">rotate</a></code>, <code><a href="#topic+slice">slice</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>scramb &lt;- "D2F2UF2DR2DBL'BRULRUL2FL'U'"
aCube &lt;- getMovesCube(scramb)
mvs &lt;- "x2D'R'L2'U'FU'F'D'U'U'R'y'R'U'Ry'RU'R'U'RUR'U'R'U'F'UFRU'"
is.solved(move(aCube, mvs))
</code></pre>

<hr>
<h2 id='getMovesPattern'>Get Moves for Patterned Cubes</h2><span id='topic+getMovesPattern'></span>

<h3>Description</h3>

<p>Extracts the move sequence for a patterned cube. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMovesPattern(pattern = c("Solved","Superflip","EasyCheckerboard","Wire","PlusMinus",
  "Tablecloth","Spiral","SpeedsolvingLogo","VerticalStripes","OppositeCorners",
  "Cross","UnionJack","CubeInTheCube","CubeInACubeInACube","Anaconda","Python",
  "BlackMamba","GreenMamba","FourSpots","SixSpots","Twister","Kilt","Tetris",
  "DontCrossLine","Hi","HiAllAround","AreYouHigh","CUAround","OrderInChaos","Quote",
  "MatchingPictures","3T","LooseStrap","ZZLine","Doubler","CheckerZigzag",
  "ExchangedDuckFeet","StripeDotSolved","Picnic","PercentSign","Mirror",
  "PlusMinusCheck","FacingCheckerboards","OppositeCheckerboards","4Plus2Dots",
  "Rockets","Slash","Pillars","TwistedDuckFeet","RonsCubeInACube","Headlights",
  "CrossingSnake","Cage","4Crosses","Pyraminx","EdgeTriangle","TwistedRings",
  "ExchangedRings","TwistedChickenFeet","ExchangedChickenFeet","CornerPyramid",
  "TwistedPeaks","ExchangedPeaks","SixTwoOne","YinYang","YanYing","HenrysSnake",
  "TwistedCorners","QuickMaths"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMovesPattern_+3A_pattern">pattern</code></td>
<td>
<p>A character string giving a pattern for the corresponding cube.
Approximately seventy different patterns are available. The default pattern
is the solved cube, returning an empty character vector. The patterns and 
names are derived from the ruwix.com website.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly for internal use. It is used by the functions
<code>getCubieCube</code> and <code>getStickerCube</code> to produce patterned cubes
via <code>getMovesCube</code>. The returned move sequence contains only URFDLB
face turns.
</p>


<h3>Value</h3>

<p>A character vector of moves. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCubieCube">getCubieCube</a></code>, <code><a href="#topic+getMovesCube">getMovesCube</a></code>, 
<code><a href="#topic+getStickerCube">getStickerCube</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getMovesPattern()
getMovesPattern("Solved")
getMovesPattern("Wire")
getMovesPattern("UnionJack")
</code></pre>

<hr>
<h2 id='invCube'>Calculate Inverse Cube</h2><span id='topic+invCube'></span>

<h3>Description</h3>

<p>Calculates the inverse of a cube. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invCube(aCube, edges = TRUE, corners = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invCube_+3A_acube">aCube</code></td>
<td>
<p>A cubieCube object.</p>
</td></tr>
<tr><td><code id="invCube_+3A_edges">edges</code></td>
<td>
<p>If <code>FALSE</code>, the inverse is not taken for the edges.</p>
</td></tr>
<tr><td><code id="invCube_+3A_corners">corners</code></td>
<td>
<p>If <code>FALSE</code>, the inverse is not taken for the corners.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every 3x3x3 cube A has a unique inverse cube A' where AA' and 
A'A are both equal to the solved state. The cube A does not need to be solvable. 
Larger cubes do not have unique inverses because larger cubes have indistinct 
pieces in the centres.
</p>
<p>One use of the inverse is to enable the <code>solver</code> function to generate
moves towards a target state that is not the solved state. For an initial 
cube A and a target state B the solver is applied to B'A. The moves of the
solver then represent post-multiplication by A'B, which when applied to A
gives AA'B which is equal to B, the target state. Only B'A needs to be 
solvable; both A and B could be unsolvable.
</p>
<p>A solvable cube will always remain solvable after the function <code>invCube</code>
is applied, even if <code>edges</code> or <code>corners</code> is <code>FALSE</code>. This is
because the sign (even or odd) of a permutation is the same as the sign of the
inverse permutation.  
</p>


<h3>Value</h3>

<p>A cubieCube object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++25v+25">%v%</a></code>, <code><a href="#topic+invMoves">invMoves</a></code>, 
<code><a href="#topic+is.solvable">is.solvable</a></code>, <code><a href="#topic+solver">solver</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getCubieCube("Tetris")
is.solved(aCube %v% invCube(aCube))
is.solved(invCube(aCube) %v% aCube)

## Not run: plot(aCube)
## Not run: plot(invCube(aCube))
## Not run: plot3D(aCube)
## Not run: plot3D(invCube(aCube))
</code></pre>

<hr>
<h2 id='invMoves'>Manipulate Move Sequences</h2><span id='topic+invMoves'></span><span id='topic+mirMoves'></span><span id='topic+rotMoves'></span><span id='topic+moveOrder'></span>

<h3>Description</h3>

<p>Invert, mirror and rotate move sequences, and calculate the order of a 
move sequence.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invMoves(moves, revseq = TRUE, collapse = NULL)
mirMoves(moves, mirror = c("0","UD","DU","RL","LR","FB","BF"), collapse = NULL)
rotMoves(moves, rotation = c("0","x","x1","x3'","y","y1","y3'","z","z1","z3'",
	"x2","x2'","y2","y2'","z2","z2'","x'","x3","x1'","y'","y3","y1'","z'","z3",
	"z1'"), invrot = FALSE, collapse = NULL)
moveOrder(moves)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invMoves_+3A_moves">moves</code></td>
<td>
<p>A move sequence. Either a character sting, which may include 
white space, or a character vector where each element is a single move.
For <code>moveOrder</code>, can include only URFDLB face turns. For other 
functions, can include URFDLBEMS face turns, URFDLB wide turns and xyz 
rotations.</p>
</td></tr>
<tr><td><code id="invMoves_+3A_revseq">revseq</code></td>
<td>
<p>If <code>FALSE</code>, the move sequence is not reversed so that only
the direction of the turns is altered.</p>
</td></tr>
<tr><td><code id="invMoves_+3A_mirror">mirror</code></td>
<td>
<p>The mirror to be used. The U/D mirror can be specified using the UD
or DU character string. Similarly for R/L and F/B.</p>
</td></tr>
<tr><td><code id="invMoves_+3A_rotation">rotation</code></td>
<td>
<p>The rotation to be used.</p>
</td></tr>
<tr><td><code id="invMoves_+3A_invrot">invrot</code></td>
<td>
<p>Inverts the direction of the rotation.</p>
</td></tr>
<tr><td><code id="invMoves_+3A_collapse">collapse</code></td>
<td>
<p>If not <code>NULL</code> then the returned moves are output as a 
single string with <code>collapse</code> as the separator, rather than a character
vector of moves. If <code>collapse</code> is the empty string then a single
string with no separator is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>moveOrder</code> an integer value is returned giving the order of the move 
sequence, which is the number of times it needs to be applied for the solved cube 
to return to its solved state. The largest order for any sequence is known to be 
1260; for example, the order of <code>"R U2 D' B D'"</code> is 1260.
</p>
<p>For other functions, a move sequence is returned. The returned move sequence will 
always use the canonical form for the turn notation: U not U1, U' not U1', and 
Uw not u for wide turns. However any form may be used for the input.
</p>
<p>The Examples section below demonstrates the relationship between rotated move 
sequences. If the rotation is r and the rotated move sequence is <code>m</code>, then the 
move sequence r<code>m</code>r' is equivalent to the original. If <code>invrot</code> is 
<code>TRUE</code>, then this becomes r'<code>m</code>r. 
</p>


<h3>Value</h3>

<p>A character vector of moves, or a character string if <code>collapse</code> is 
not <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+move">move</a></code>, <code><a href="#topic+invCube">invCube</a></code>, 
<code><a href="#topic+rotate">rotate</a></code>, <code><a href="#topic+scramble">scramble</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mv &lt;- "RB'y'F2MD'"
invMoves(mv)
mirMoves(mv, mirror = "RL")

iCube &lt;- getCubieCube("TwistedChickenFeet")
rmv &lt;- rotMoves(mv, rotation = "x")
aCube &lt;- move(iCube, c("x", rmv, "x'"))
bCube &lt;- move(iCube, mv)
identical(aCube, bCube)

moveOrder("RU2D'BD'")
</code></pre>

<hr>
<h2 id='move'>Moving a Cube and Creating a Move Sequence</h2><span id='topic+move'></span><span id='topic+plot.seqCubes'></span>

<h3>Description</h3>

<p>Applies moves to a cube and creates a move sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move(aCube, moves, history = FALSE)
## S3 method for class 'seqCubes'
plot(x, initial = TRUE, which = 1:length(moves), ask = FALSE, 
    colvec = getOption("cubing.colors"), recolor = FALSE, show.rot = TRUE, 
    title = NULL, cex.title = 1, font.title = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_+3A_acube">aCube</code></td>
<td>
<p>A cubieCube object.</p>
</td></tr>
<tr><td><code id="move_+3A_moves">moves</code></td>
<td>
<p>A move sequence; either a single string or a character vector with 
one element per move. Can include URFDLBEMS face turns, URFDLB wide turns and 
xyz rotations.</p>
</td></tr>
<tr><td><code id="move_+3A_history">history</code></td>
<td>
<p>If <code>TRUE</code> the output is a list containing the initial cube 
state and every subsequent cube state created during the move sequence. 
If <code>FALSE</code> (the default) only the final cube state is returned.</p>
</td></tr>	
<tr><td><code id="move_+3A_x">x</code></td>
<td>
<p>An object produced by the <code>move</code> function when <code>history</code>
is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="move_+3A_initial">initial</code></td>
<td>
<p>Plot the initial cube state?</p>
</td></tr>
<tr><td><code id="move_+3A_which">which</code></td>
<td>
<p>If only a subset of subsequent cube states are to be plotted, 
specify a subset of the numbers <code>1:length(moves)</code>.</p>
</td></tr>
<tr><td><code id="move_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the user is asked before each plot.</p>
</td></tr>
<tr><td><code id="move_+3A_colvec">colvec</code></td>
<td>
<p>Vector of sticker colors. The default is the
<code>cubing.colors</code> option.</p>
</td></tr>
<tr><td><code id="move_+3A_recolor">recolor</code></td>
<td>
<p>If <code>TRUE</code>, the spatial orientation is ignored 
and therefore the cube is recolored.</p>
</td></tr>
<tr><td><code id="move_+3A_show.rot">show.rot</code></td>
<td>
<p>Should rotation moves be plotted?</p>
</td></tr>
<tr><td><code id="move_+3A_title">title</code></td>
<td>
<p>If specified as a character string, the first plot represents a
title page with <code>title</code> in the centre. This is useful for putting a 
title page on multiple page graphing devices such as pdf.</p>
</td></tr>
<tr><td><code id="move_+3A_cex.title">cex.title</code></td>
<td>
<p>Size of title on title page.</p>
</td></tr>
<tr><td><code id="move_+3A_font.title">font.title</code></td>
<td>
<p>Font of title on title page.</p>
</td></tr>
<tr><td><code id="move_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>move</code> gives the result of applying the move sequence
<code>moves</code> to the cube <code>aCube</code>. All rotations xyz, face turns
URFDLBEMS, and wide moves URFDLB are allowed. Moves specifications such 
as U U1 U' U1' U2 U2' U3 U3' and rotation specifications such as x x1 x' 
x1' x2 x2' x3 x3' are all allowed. For wide moves, lower case lettering 
and w notation are both allowed, so u2 and Uw2 are equivalent. If 
<code>moves</code> is a single string, it may contain any amount of white space.
</p>
<p>The definition of the E M S middle slice moves is respectively given by D'Uy' L'Rx' B'Fz'.
In particular, the S slice direction is different to what you may find elsewhere;
the definition used for S in this package is consistent with the rotation directions. 
</p>
<p>When <code>history</code> is <code>TRUE</code> a list is created of class seqCubes. The
list contains cubieCube objects. The length of the list is the number of moves 
plus one, where the first element of the list is the original cube.
</p>
<p>The <code>plot.seqCubes</code> function plots a list of class seqCubes. It can be
regarded and a 2D version of the animate function. For permanent recording 
of the 2D plots for the move sequence, it is helpful to open a multiple page 
graphing device such as pdf. A pdf file can then be created and used as a flick 
book.
</p>


<h3>Value</h3>

<p>For <code>move</code>, either a cubieCube object, or (if <code>history</code> is <code>TRUE</code>)
an object of class <code>seqCubes</code>, which is a list where each element is a 
cubieCube. An attribute of the list stores the move sequence.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code>, <code><a href="#topic+getMovesCube">getMovesCube</a></code>, <code><a href="#topic+invMoves">invMoves</a></code>,
<code><a href="#topic+plot.cube">plot.cube</a></code>, <code><a href="#topic+rotate">rotate</a></code>, <code><a href="#topic+slice">slice</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>scramb &lt;- "D2F2UF2DR2DBL'BRULRUL2FL'U'"
aCube &lt;- getMovesCube(scramb)
mvs &lt;- "x2D'R'L2'U'FU'F'D'U'U'R'y'R'U'Ry'RU'R'U'RUR'U'R'U'F'UFRU'"
is.solved(move(aCube, mvs))
sCubes &lt;- move(aCube, mvs, history = TRUE)
## Not run: plot(sCubes, title = "SeungBeom Cho\nWorld Record Solve\n4.59")

## Not run: pdf("SeungBeomCho.pdf")
## Not run: plot(sCubes, title = "SeungBeom Cho\nWorld Record Solve\n4.59")
## Not run: dev.off()
</code></pre>

<hr>
<h2 id='plot.cube'>Cube Object 2D Plot</h2><span id='topic+plot.cube'></span>

<h3>Description</h3>

<p>Plots a 2D representation of a cube object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
plot(x, colvec = getOption("cubing.colors"), recolor = FALSE,   
   xlab = "", ylab = "", main = "", centres = TRUE, numbers = FALSE, 
   text.size = 1, text.col = "black", rand.col = FALSE, blank = FALSE, 
   ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cube_+3A_x">x</code></td>
<td>
<p>Any cube object.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_colvec">colvec</code></td>
<td>
<p>Vector of sticker colors. The default is the
<code>cubing.colors</code> option.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_recolor">recolor</code></td>
<td>
<p>If <code>TRUE</code>, previous rotations are ignored 
and therefore the cube is recolored.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_xlab">xlab</code>, <code id="plot.cube_+3A_ylab">ylab</code></td>
<td>
<p>Plot labels.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_centres">centres</code></td>
<td>
<p>Add identifier text to the centre stickers.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_numbers">numbers</code></td>
<td>
<p>Add identifier text to all stickers.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_text.size">text.size</code></td>
<td>
<p>Size of text.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_text.col">text.col</code></td>
<td>
<p>Color of text. The default is black but if you are
using black stickers then purple is a good choice. White does not 
read well on yellow stickers.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_rand.col">rand.col</code></td>
<td>
<p>If <code>TRUE</code> then sticker colors are chosen at
random and <code>colvec</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_blank">blank</code></td>
<td>
<p>If <code>TRUE</code> then all colors are set to ghost white.
This is designed to create a template plot for the sticker naming 
schemes.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting
functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code>, <code><a href="#topic+plot3D.cube">plot3D.cube</a></code>, 
<code><a href="#topic+plot.rotCubes">plot.rotCubes</a></code>, <code><a href="#topic+plot.seqCubes">plot.seqCubes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getCubieCube("Superflip")
## Not run: plot(aCube)
</code></pre>

<hr>
<h2 id='plot3D.cube'>Cube Object Interactive 3D Plot</h2><span id='topic+plot3D.cube'></span><span id='topic+plot3D'></span>

<h3>Description</h3>

<p>Plots an interactive 3D representation of a cube object using OpenGL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
plot3D(x, colvec = getOption("cubing.colors"), recolor = FALSE, 
   bg = grey(0.8), rand.col = FALSE, size = 0.98, col.interior = grey(0.5), 
   al.interior = 0.4, al.exterior = 1, rinit = 30, bbox = TRUE, bbcolor = 
   "#333377", bbemission = "#333377", bbspecular = "#3333FF", bbshininess = 
   5, bbalpha = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3D.cube_+3A_x">x</code></td>
<td>
<p>Any cube object.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_colvec">colvec</code></td>
<td>
<p>Vector of sticker colors. The default is the
<code>cubing.colors</code> option.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_recolor">recolor</code></td>
<td>
<p>If <code>TRUE</code>, previous rotations are ignored 
and therefore the cube is recolored.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_bg">bg</code></td>
<td>
<p>Background color.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_rand.col">rand.col</code></td>
<td>
<p>If <code>TRUE</code> then sticker colors are chosen at
random and <code>colvec</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_size">size</code></td>
<td>
<p>Size of the individual cubies. Must be less than one. Values closer
to one give cubes that look stickerless because the gap between cubies 
decreases. Smaller sizes give exploded cubes.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_col.interior">col.interior</code></td>
<td>
<p>Color of the cube interior.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_al.interior">al.interior</code></td>
<td>
<p>Alpha value of cube interior.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_al.exterior">al.exterior</code></td>
<td>
<p>Alpha value of cube exterior.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_rinit">rinit</code></td>
<td>
<p>The initial plot is rotated <code>rinit</code> degrees about the z-axis.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_bbox">bbox</code></td>
<td>
<p>Use a bounding box?</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_bbcolor">bbcolor</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_bbemission">bbemission</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_bbspecular">bbspecular</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_bbshininess">bbshininess</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_bbalpha">bbalpha</code></td>
<td>
<p>Bounding box parameter.</p>
</td></tr>
<tr><td><code id="plot3D.cube_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <span class="rlang"><b>R</b></span> package <b>rgl</b> which is an interface to OpenGL.
The cube can be rotated using a mouse. See the documentation for the <b>rgl</b>
package to explore the large number of options available.
</p>
<p>The <code>animate</code> function also uses the <b>rgl</b> package to produce cubing
animations.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+animate">animate</a></code>, <code><a href="#topic+plot.cube">plot.cube</a></code>, 
<code><a href="#topic+plot.rotCubes">plot.rotCubes</a></code>, <code><a href="#topic+plot.seqCubes">plot.seqCubes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getCubieCube("Superflip")
## Not run: plot3D(aCube)
</code></pre>

<hr>
<h2 id='read.cubesolve'>Read Cube Solving Reconstructions</h2><span id='topic+read.cubesolve'></span>

<h3>Description</h3>

<p>Reads cube solving scrambles and solutions for the cube solves website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.cubesolve(n, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.cubesolve_+3A_n">n</code></td>
<td>
<p>A single integer <code>n</code> giving the id for the solve.</p>
</td></tr>
<tr><td><code id="read.cubesolve_+3A_warn">warn</code></td>
<td>
<p>If <code>FALSE</code>, an error is returned when the id does not
exist. If <code>TRUE</code>, a warning is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads from the html source of the www.cubesolv.es website, and
may fail if the website subsequently changes. 
</p>
<p>Round brackets immediately followed by any single digit are expanded upon 
reading, for example (R U)4 becomes R U R U R U R U. All other round brackets 
are removed. Commutator and conjugate notation is not implemented, so square 
brackets cannot be used and a warning is given if they are found.
</p>
<p>The website does not have automated checking and therefore a typographic
error may lead to non-valid moves (or cubes that do not solve). This most
commonly occurs when the space between two valid moves is accidentally omitted.  
</p>


<h3>Value</h3>

<p>A list containing the scramble, solution and description. The scramble and solution
items are character vectors of moves. The description is a character string. If the 
scramble or solution (or both) is missing, then length zero vectors are returned
for these items.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMovesCube">getMovesCube</a></code>, <code><a href="#topic+invMoves">invMoves</a></code>, <code><a href="#topic+is.solved">is.solved</a></code>,
<code><a href="#topic+move">move</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: cho &lt;- read.cubesolve(4995)
## Not run: aCube &lt;- getMovesCube(cho$scramble)
## Not run: mv &lt;- cho$solution
## Not run: is.solved(move(aCube, mv))
</code></pre>

<hr>
<h2 id='rotate'>Perform Rotations, Wide Moves and Middle Slice Moves</h2><span id='topic+rotate'></span><span id='topic+slice'></span><span id='topic+wide'></span>

<h3>Description</h3>

<p>Functions for rotating the whole cube and performing middle slice (E M S) 
and wide (Uw Rw Fw Dw Lw Bw) moves. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wide(aCube, wmv)
slice(aCube, smv)
rotate(aCube, rot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_acube">aCube</code></td>
<td>
<p>A cubieCube object.</p>
</td></tr>
<tr><td><code id="rotate_+3A_smv">smv</code></td>
<td>
<p>A single string giving a middle slice move. Must be one of
E E1 E' E1' E2 E2' E3 E3' M M1 M' M1' M2 M2' M3 M3' S S1 S' S1' S2 
S2' S3 S3'.</p>
</td></tr>
<tr><td><code id="rotate_+3A_wmv">wmv</code></td>
<td>
<p>A single string giving a wide move. Lower case letters and w
notation are both allowed. For turns on the U face must be one of 
Uw u Uw1 u1 Uw' u' Uw1' u1' Uw2 u2 Uw2' u2' Uw3 u3 Uw3' u3', and 
similarly for the R F D L B faces.</p>
</td></tr>
<tr><td><code id="rotate_+3A_rot">rot</code></td>
<td>
<p>A rotation. This can be specified using an integer or a character
string. If an integer, must be a number between 1 and 24 representing one
of the 24 possible rotations in space. The number 1 is the no rotation case.
If a character string, must be one of 0 x x1 x' x1' x2 x2' x3 x3' y y1 y' y1' 
y2 y2' y3 y3' z z1 z' z1' z2 z2' z3 z3' where the 0 character string represents 
no rotation. Character strings correspond only to the 10 distinct rotations 
around the the x, y and z axes (including the no rotation case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used internally by the <code>move</code> function for
performing rotations, wide moves and middle slice moves, but can also be called 
directly if you only need to perform a single move. In most circumstances it is 
better to use the <code>move</code> function.
</p>
<p>The definition of the E M S middle slice moves is respectively given by D'Uy' L'Rx' B'Fz'.
In particular, the S slice direction is different to what you may find elsewhere;
the definition used for S in this package is consistent with the rotation directions.  
</p>


<h3>Value</h3>

<p>A cubieCube object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+move">move</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getCubieCube("HenrysSnake")
bCube &lt;- slice(rotate(aCube, "z'"), "M2") 
cCube &lt;- move(aCube, "z'M2")
identical(bCube, cCube)

## Not run: plot(cCube)
## Not run: plot3D(cCube)
</code></pre>

<hr>
<h2 id='rotations'>Create and Plot All Rotations of a Cube</h2><span id='topic+rotations'></span><span id='topic+plot.rotCubes'></span>

<h3>Description</h3>

<p>Creates and plots all 24 possible whole cube rotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotations(aCube)
## S3 method for class 'rotCubes'
plot(x, which = 1:24, ask = FALSE,  colvec = 
  getOption("cubing.colors"), recolor = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotations_+3A_acube">aCube</code></td>
<td>
<p>A cubieCube object.</p>
</td></tr>
<tr><td><code id="rotations_+3A_x">x</code></td>
<td>
<p>An object produced by the <code>rotations</code> function.</p>
</td></tr>
<tr><td><code id="rotations_+3A_which">which</code></td>
<td>
<p>If only a subset of the rotations is to be plotted, 
specify a subset of the numbers <code>1:24</code>.</p>
</td></tr>
<tr><td><code id="rotations_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, the user is asked before each plot.</p>
</td></tr>
<tr><td><code id="rotations_+3A_colvec">colvec</code></td>
<td>
<p>Vector of sticker colors. The default is the
<code>cubing.colors</code> option.</p>
</td></tr>
<tr><td><code id="rotations_+3A_recolor">recolor</code></td>
<td>
<p>If <code>TRUE</code>, the spatial orientation is ignored 
and therefore the cube is recolored.</p>
</td></tr>
<tr><td><code id="rotations_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 24 possible spatial orientations, including the original 
no rotation case. The <code>rotations</code> function produces all of these
cubes as a list of class <code>rotCubes</code>, which can be subsequently 
plotted by <code>plot.rotCubes</code>.
</p>
<p>The 24 cubes produced by <code>rotations</code> are all related to each 
other via some rotation and therefore they are all the same as defined
by the <code>all.equal.cube</code> function. If the original cube has symmetric 
properties then the set of 24 may contain equivalent cubes as defined
by the <code>==.cube</code> operator. In the case of the solved cube all 24 
will be equivalent.
</p>


<h3>Value</h3>

<p>For <code>rotations</code>, an object of class <code>rotCubes</code>, which is a 
list of length 24 where each element is a cubieCube.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++3D+3D.cube">==.cube</a></code>, <code><a href="#topic+all.equal.cube">all.equal.cube</a></code>,
<code><a href="#topic+rotate">rotate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rCubes &lt;- rotations(randCube())
all.equal(rCubes[[5]], rCubes[[10]])
rCubes[[5]] == rCubes[[10]]
## Not run: plot(rCubes)
</code></pre>

<hr>
<h2 id='scramble'>Generate Random Cubes, Moves and Scrambles</h2><span id='topic+scramble'></span><span id='topic+randCube'></span><span id='topic+randMoves'></span>

<h3>Description</h3>

<p>Generate random cubes, random move sequences, and scrambles. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randCube(n = 1, cubie = TRUE, solvable = TRUE, drop = TRUE, spor = 1:6)
randMoves(n = 1, nm = 20, drop = TRUE)
scramble(n = 1, state = FALSE, nm = 20, drop = TRUE, type = c("KB", "ZT", 
  "TF", "ZZ", "CFOP"), maxMoves = 24, bound = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scramble_+3A_n">n</code></td>
<td>
<p>Number of cubes, move sequences or scrambles to generate.</p>
</td></tr>
<tr><td><code id="scramble_+3A_cubie">cubie</code></td>
<td>
<p>If <code>FALSE</code>, simulate stickerCubes rather than cubieCubes.</p>
</td></tr>
<tr><td><code id="scramble_+3A_solvable">solvable</code></td>
<td>
<p>If <code>FALSE</code>, then solvable and unsolvable cubes can
be simulated. See Details.</p>
</td></tr>
<tr><td><code id="scramble_+3A_drop">drop</code></td>
<td>
<p>If <code>FALSE</code>, then a list of one element is returned when <code>n</code>
is equal to one.</p>
</td></tr>
<tr><td><code id="scramble_+3A_spor">spor</code></td>
<td>
<p>The spatial orientation vector that is added to each simulated cubieCube.</p>
</td></tr>
<tr><td><code id="scramble_+3A_nm">nm</code></td>
<td>
<p>The number of moves in the move sequence or the scramble. Ignored for
<code>scramble</code> if <code>state</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scramble_+3A_state">state</code></td>
<td>
<p>If <code>FALSE</code> (the default), use a random moves scramble. If
<code>TRUE</code>, use a random state scramble.</p>
</td></tr>
<tr><td><code id="scramble_+3A_type">type</code></td>
<td>
<p>The type of solver used for the random state scramble. This and all
following arguments are ignored unless <code>state</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scramble_+3A_maxmoves">maxMoves</code></td>
<td>
<p>Argument passed to the solver.</p>
</td></tr>
<tr><td><code id="scramble_+3A_bound">bound</code></td>
<td>
<p>Argument passed to the solver.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>If <code>solvable</code> is <code>TRUE</code>, the <code>randCube</code> function generates a 
solvable cube where every solvable state is equally likely. If <code>solvable</code> 
is <code>FALSE</code>, it generates a random cube where every obtainable physical
construction is equally likely. The resulting cube may or may not be solvable: 
the chance of it being solvable is only 1 in 12.
</p>
<p>The <code>randMoves</code> function generates a random move sequence using URFDLB face 
turns, restricted so that you cannot get two moves in a row on the same face, or
three moves in a row on opposing faces. An alternative way of constructing a
random cube is <code>getMovesCube(randMoves())</code>. If <code>nm</code> is 20 or more
then every solvable state has a non-zero chance of occuring, but the states
will not be equally likely to occur.  
</p>
<p>The <code>scramble</code> function generates random move scrambles by default (which
just uses the <code>randMoves</code> function), but will generate random state
scrambles when <code>state</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A cube object or list of cube objects for <code>randCube</code>.
A move sequence or list of move sequences for <code>randMoves</code> and <code>scramble</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMovesCube">getMovesCube</a></code>, <code><a href="#topic+invCube">invCube</a></code>, <code><a href="#topic+invMoves">invMoves</a></code>, 
<code><a href="#topic+is.solvable">is.solvable</a></code>, <code><a href="#topic+solver">solver</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>randCube()
getMovesCube(randMoves())
sapply(randCube(20, solvable = FALSE), is.solvable)
randMoves(5, nm = 25)
scramble(nm = 17)
scramble(state = TRUE, type = "ZT", maxMoves = 24)
</code></pre>

<hr>
<h2 id='solvable'>Solved and Solvability Tests for Cube Objects</h2><span id='topic+is.solved'></span><span id='topic+is.solvable'></span><span id='topic+parity'></span>

<h3>Description</h3>

<p>Determine if a cube is solved or solvable, and calculate the
sign of the corner and edge permutations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.solved(aCube, split = FALSE, co = TRUE, eo = TRUE)
is.solvable(aCube, split = FALSE)
parity(aCube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solvable_+3A_acube">aCube</code></td>
<td>
<p>Any cube object.</p>
</td></tr>
<tr><td><code id="solvable_+3A_split">split</code></td>
<td>
<p>Split output into logical vector? See Details.</p>
</td></tr>
<tr><td><code id="solvable_+3A_co">co</code></td>
<td>
<p>If <code>FALSE</code>, ignore corner orientation.</p>
</td></tr>
<tr><td><code id="solvable_+3A_eo">eo</code></td>
<td>
<p>If <code>FALSE</code>, ignore edge orientation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cubieCube and stickerCube objects contain Rubik's cubes that can 
be physically constructed from properly stickered cubies, but they are 
not necessarily solvable. These functions test for solved and solvable 
cubes. The <code>parity</code> function gives the permuation sign (+1 for even 
and -1 for odd) for the corner and edge permuations. For a cube to be 
solvable, the two signs must be the same.
</p>
<p>For <code>is.solved</code>, a logical value for each separate permutation and 
orientation component will be given if <code>split</code> is <code>TRUE</code>.  
</p>
<p>For <code>is.solvable</code>, logical values corresponding to permuatation 
parity, edge orientation and corner orientation will be given if 
<code>split</code> is <code>TRUE</code>. The cube is only solvable if all three 
values are <code>TRUE</code>. The edge and corner orientation values
correspond to the fact that if all but one edge (or corner) orientation
is known, then the orientation of the final edge (or corner) must 
be fixed for the cube to be solvable. More precisely, the sum of the
edge orientation vector must be even, and the sum of the corner
orientation vector must be divisible by three.  
</p>


<h3>Value</h3>

<p>A logical value or vector for <code>is.solved</code> and <code>is.solvable</code>.
A named integer vector of length two for <code>parity</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++3D+3D.cube">==.cube</a></code>, <code><a href="#topic+randCube">randCube</a></code>, <code><a href="#topic+solver">solver</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- randCube()
is.solvable(aCube)
aCube &lt;- randCube(solvable = FALSE)
is.solvable(aCube)
</code></pre>

<hr>
<h2 id='solver'>Rubik's Cube Solver</h2><span id='topic+solver'></span>

<h3>Description</h3>

<p>Cube solvers to generate moves to a target cube state. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solver(aCube, tCube, type = c("KB", "ZT", "TF"), inv = FALSE, 
    maxMoves = switch(type, KB = 24, ZT = 20, TF = 16), bound = 
    TRUE, collapse = NULL, divide = FALSE, history = FALSE, 
    verbose = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solver_+3A_acube">aCube</code></td>
<td>
<p>A cubieCube object giving the cube to be solved. 
If <code>tCube</code> is not specified then the object must be solvable.</p>
</td></tr>
<tr><td><code id="solver_+3A_tcube">tCube</code></td>
<td>
<p>A cubieCube object giving the target state. If not specified,
then the target state is the solved state. See Details.</p>
</td></tr>
<tr><td><code id="solver_+3A_type">type</code></td>
<td>
<p>The type of solver used. KB is Kociemba. ZT is Zemdegs-Twist.
TF is Twist-Flip.</p>
</td></tr>
<tr><td><code id="solver_+3A_inv">inv</code></td>
<td>
<p>If <code>TRUE</code> the moves are inverted. For producing
random state scrambles.</p>
</td></tr>
<tr><td><code id="solver_+3A_maxmoves">maxMoves</code></td>
<td>
<p>The maximum number of moves allowed for the search phases
of the algorithm. The search algorithm may take a long time for smaller
move requirements. The default value depends on the solver.</p>
</td></tr>
<tr><td><code id="solver_+3A_bound">bound</code></td>
<td>
<p>By default the <code>maxMoves</code> value cannot be too small to
avoid the search algorithm taking an excessively long time or never 
returning. If <code>bound</code> is set to <code>FALSE</code> this safety measure is 
removed, allowing any value of <code>maxMoves</code> to be specified. This is
not recommended unless you know the cube can be solved within a small
number of moves.</p>
</td></tr>
<tr><td><code id="solver_+3A_collapse">collapse</code></td>
<td>
<p>If not <code>NULL</code> then the returned moves are output as a 
single string with <code>collapse</code> as the separator, rather than a character
vector of moves. If <code>collapse</code> is the empty string then a single
string with no separator is returned.</p>
</td></tr>
<tr><td><code id="solver_+3A_divide">divide</code></td>
<td>
<p>If <code>TRUE</code>, a period symbol is placed between the phases
of the search algorithm.</p>
</td></tr>
<tr><td><code id="solver_+3A_history">history</code></td>
<td>
<p>If <code>TRUE</code> the solver returns a list where the second element 
gives a matrix object that provides information on the history of the search 
algorithm. Mainly used for debugging.</p>
</td></tr>
<tr><td><code id="solver_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> print details of the status of the search. Mainly
used for debugging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The solver produces a move sequence that brings <code>aCube</code> to either a solved 
state or to the target state <code>tCube</code>. If the target state is specified, then
<code>invCube(tCube) %v% aCube</code> must be solvable, but the two cubes <code>aCube</code>
and <code>tCube</code> could be unsolvable. See the help file on <code>invCube</code> for
more details.
</p>
<p>The KB algorithm is a 2-phase search. The ZT algorithm is similar but allows for
twisting corners at the end to solve the corner orientation. The TF algorithm
allows for twisting corners and flipping edges at the end to solve both corner and
edge orientation. The twisting and flipping procedures are given as attributes in 
the returned object. If <code>inv</code> is <code>TRUE</code>, then they need to be performed 
at the start from the solved (or target) state.
</p>
<p>The ZT and TF solvers may not produce a smaller move count than KB because the aim of 
the solver is to return any solution that consists of <code>maxMoves</code> moves or less.
If smaller move counts are required then <code>maxMoves</code> should be specified.
</p>
<p>These solvers are lightweight in the sense that they use small look-up tables (move 
tables and prune tables). If <code>maxMoves</code> is small then it can take a few seconds
to find a solution.
</p>
<p>The look-up tables for a solver are silently loaded into memory the first time the solver 
is used. The tables are hidden objects that are not visible to the user. If you wish to 
ensure that all tables are already loaded into memory (for example, if you want to do timing
comparisons), then you can run each type of solver once, using any cube other than the 
solved (or target) state.
</p>
<p>The solvers will never produce two moves in a row on the same face, but may produce three
(or even four) moves in a row on opposite faces if this coincides with the break
between the two search phases. They cannot produce three moves in a row on opposite faces 
within the same search phase. This behaviour is a design choice in order to minimize second
phase solutions that are rejected due to move sequences across the phase break.
</p>


<h3>Value</h3>

<p>A character vector of moves, or a character string if <code>collapse</code> is not <code>NULL</code>.
For ZT the vector (or string) has a twist attribute. For TF the vector (or string) has
twist and flip attributes.
</p>
<p>If history is <code>TRUE</code>, then a list of length two is returned where the second element
is a matrix that provides information on the history of the search algorithm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMovesCube">getMovesCube</a></code>, <code><a href="#topic+invCube">invCube</a></code>, <code><a href="#topic+invMoves">invMoves</a></code>, 
<code><a href="#topic+is.solvable">is.solvable</a></code>, <code><a href="#topic+scramble">scramble</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getCubieCube("EasyCheckerboard")
## Not run: plot(aCube)
## Not run: plot3D(aCube)
mvs &lt;- solver(aCube, type = "KB")
is.solved(aCube %v% getMovesCube(mvs))
</code></pre>

<hr>
<h2 id='stickerCube'>Create and Convert StickerCubes</h2><span id='topic+getStickerCube'></span><span id='topic+stickerCube'></span><span id='topic+as.stickerCube'></span><span id='topic+is.stickerCube'></span>

<h3>Description</h3>

<p>Creates, converts and tests for stickerCube objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStickerCube(pattern = c("Solved","Superflip","EasyCheckerboard","Wire","PlusMinus",
  "Tablecloth","Spiral","SpeedsolvingLogo","VerticalStripes","OppositeCorners",
  "Cross","UnionJack","CubeInTheCube","CubeInACubeInACube","Anaconda","Python",
  "BlackMamba","GreenMamba","FourSpots","SixSpots","Twister","Kilt","Tetris",
  "DontCrossLine","Hi","HiAllAround","AreYouHigh","CUAround","OrderInChaos","Quote",
  "MatchingPictures","3T","LooseStrap","ZZLine","Doubler","CheckerZigzag",
  "ExchangedDuckFeet","StripeDotSolved","Picnic","PercentSign","Mirror",
  "PlusMinusCheck","FacingCheckerboards","OppositeCheckerboards","4Plus2Dots",
  "Rockets","Slash","Pillars","TwistedDuckFeet","RonsCubeInACube","Headlights",
  "CrossingSnake","Cage","4Crosses","Pyraminx","EdgeTriangle","TwistedRings",
  "ExchangedRings","TwistedChickenFeet","ExchangedChickenFeet","CornerPyramid",
  "TwistedPeaks","ExchangedPeaks","SixTwoOne","YinYang","YanYing","HenrysSnake",
  "TwistedCorners","QuickMaths"))
stickerCube(string)
as.stickerCube(aCube)
is.stickerCube(aCube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stickerCube_+3A_pattern">pattern</code></td>
<td>
<p>A character string giving a pattern for the returned cube.
Approximately seventy different patterns are available. The default pattern
is the solved cube. The patterns and names are derived from the ruwix.com website.</p>
</td></tr>
<tr><td><code id="stickerCube_+3A_string">string</code></td>
<td>
<p>A character string representing the color on each cube sticker. The string
must contain only the letters URFLBD, representing the color on each face, and may contain 
any amount of white space. There must be 9 occurrences of each letter, or 8 occurrences if 
the centre stickers are omitted. A character vector can also be given instead of a character 
string, with one element for each letter. The sticker template can be displayed using the 
code at the end of the Examples section below.</p>
</td></tr>
<tr><td><code id="stickerCube_+3A_acube">aCube</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>is.stickerCube</code> function returns <code>TRUE</code> for stickerCube objects and <code>FALSE</code> 
otherwise. The <code>as.stickerCube</code> function converts a cube object to a stickerCube object and
returns an error for other arguments. 
</p>
<p>The <code>getStickerCube</code> function creates stickerCube objects using known patterns. The 
<code>stickerCube</code> function creates stickerCube objects using colors entered by the user.
For alternative ways of creating stickerCube objects, see <code>randCube</code> and <code>getMovesCube</code>. 
</p>
<p>A <code>stickerCube</code> is a named character vector of length 54 where each element is one of the
six letters URFLBD. The element named U5 is always equal to the character string U as this 
represents a centre sticker. The elements named R5 F5 L5 B5 D5 are similarly fixed.
</p>
<p>The <code>stickerCube</code> function contains a large amount of bulletproofing to ensure the cube
has valid cubies that are stickered correctly, but the cube may or may not be solvable. Both 
stickerCube and cubieCube objects are designed to hold both solvable and
unsolvable cubes. You can test solvability with the <code>is.solvable</code> function.
</p>


<h3>Value</h3>

<p>A logical value for <code>is.stickerCube</code>. 
A stickerCube object for all other functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMovesCube">getMovesCube</a></code>, <code><a href="#topic+is.solvable">is.solvable</a></code>, 
<code><a href="#topic+randCube">randCube</a></code>, <code><a href="#topic+cubieCube">cubieCube</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>aCube &lt;- getStickerCube("Wire")
bCube &lt;- stickerCube("UUUUUUUUU RLLRRRLLR BBFFFFFBBD DDDDDDDDL RRLLLRRLF FBBBBBFF")
cCube &lt;- stickerCube("FBBBUFRRB DUUFRUFFB DBRBFDUFLF RDDDLDDLU UFULLLLLR DRRBLURB")
identical(aCube, bCube)
is.stickerCube(aCube)

## Not run: plot(aCube)
## Not run: plot3D(aCube)
## Not run: plot(cCube)
## Not run: plot3D(cCube)

## Not run: plot(getStickerCube(), numbers = TRUE)
## Not run: plot(getStickerCube(), numbers = TRUE, blank = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
