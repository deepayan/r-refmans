<!DOCTYPE html><html lang="en"><head><title>Help for package qlcVisualize</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qlcVisualize}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qlcVisualize-package'>
<p>Visualizations for Quantitative Language Comparison</p></a></li>
<li><a href='#addContour'>
<p>Add contourlines to a map</p></a></li>
<li><a href='#boundary'>
<p>Checking boundary parameters for plotting of <code>levelMap</code></p></a></li>
<li><a href='#dialects'>
<p>Multiple correspondences of &quot;f&quot;-like sounds in German Dialects</p></a></li>
<li><a href='#factorMap'>
<p>Visualising nominal data with various factors.</p></a></li>
<li><a href='#haspelmath'>
<p>Data about indefinite constructions in 39 different languages</p></a></li>
<li><a href='#heeringa'>
<p>Heeringa-style colours</p></a></li>
<li><a href='#hessen'>
<p>Extract from the SyHD Project on the syntax of the dialect of Hessen (Germany)</p></a></li>
<li><a href='#levelMap'>
<p>Drawing multi-level maps (e.g. semantic maps or linguistic isoglosses)</p></a></li>
<li><a href='#vmap'>
<p>Plotting a Voronoi-map (&quot;v-map&quot;)</p></a></li>
<li><a href='#weightedMap'>
<p>Construct weighted map using Voronoi tessellation and cartogram weighting</p></a></li>
<li><a href='#window'>
<p>Producing windows of class &quot;owin&quot;</p></a></li>
<li><a href='#world'>
<p>Boundary of the World fitting all Glottolog languages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Visualization for Quantitative Language Comparison</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of visualizations as used in quantitative language 
  comparison. Currently implemented are visualisations dealing nominal data with 
  multiple levels ("level map" and "factor map"), and assistance for making 
  weighted geographical Voronoi-maps ("weighted map").</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-31</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cysouw/qlcVisualize">https://github.com/cysouw/qlcVisualize</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cysouw/qlcVisualize/issues">https://github.com/cysouw/qlcVisualize/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>alphahull, automap, cartogramR, concaveman, fields, geodata,
gstat, mapplots, maps, MASS, methods, qlcMatrix, RSpectra,
seriation, sf, sp, spatstat.geom, spatstat.random, stars</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rnaturalearth, mapdata, lingtypology</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-31 13:52:15 UTC; cysouw</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Cysouw <a href="https://orcid.org/0000-0003-3168-4946"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Cysouw &lt;cysouw@mac.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-01 04:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='qlcVisualize-package'>
Visualizations for Quantitative Language Comparison
</h2><span id='topic+qlcVisualize-package'></span><span id='topic+qlcVisualize'></span>

<h3>Description</h3>

<p>A collection of specific visualisations of data as used in quantitative language comparison.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> qlcVisualize</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-07-31</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Currently implemented are visualisations dealing nominal data with multiple levels <a href="#topic+lmap">lmap</a> (&quot;levelMap&quot;) and <a href="#topic+fmap">fmap</a> (&quot;factorMap&quot;), and some assistance for making of weighted geographic Voronoi maps <a href="#topic+wmap">wmap</a> (&quot;weigthedMap&quot;).
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>

<hr>
<h2 id='addContour'>
Add contourlines to a map
</h2><span id='topic+addContour'></span>

<h3>Description</h3>

<p>Convenience function to add contourlines to a map, specifically geared towards suggesting boundaries to the result of <a href="#topic+weightedMap">weightedMap</a>. Internally based on a krige-interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addContour(heights, points, window, crs,
           levels = c(0.4, 0.45, 0.5), grid = 50000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addContour_+3A_heights">heights</code></td>
<td>

<p>Numeric vector with the same length as <code>points</code>. Typically a 0/1 vector describing presence or absence of a features.
</p>
</td></tr>
<tr><td><code id="addContour_+3A_points">points</code></td>
<td>

<p>Locations of the datapoints as <code>sfc_POINTS</code> or an sf object with such a geometry.
</p>
</td></tr>
<tr><td><code id="addContour_+3A_window">window</code></td>
<td>

<p>Window for the interpolation as <code>sfc_POLYGON</code> or an sf object with such a geometry.
</p>
</td></tr>
<tr><td><code id="addContour_+3A_crs">crs</code></td>
<td>

<p>A crs in WKT format.
</p>
</td></tr>
<tr><td><code id="addContour_+3A_levels">levels</code></td>
<td>

<p>Levels on which to draw the contourlines. Multiple lines get thicker towards higher values to suggest a center. These levels have to be related relative to the <code>heights</code>.
</p>
</td></tr>
<tr><td><code id="addContour_+3A_grid">grid</code></td>
<td>

<p>Number of points inside the window for the krige-interpolation. Higher numbers lead to nicers contourlines, but take longer to evaluate.
</p>
</td></tr>
<tr><td><code id="addContour_+3A_...">...</code></td>
<td>

<p>Additional specifications passed internally to <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, a grid is made inside the window and the height is interpolated using ordinary kriging from <code>[gstat]{krige}</code> with a model suggested by <code><a href="automap.html#topic+autofitVariogram">autofitVariogram</a></code>.
</p>


<h3>Value</h3>

<p>Contourlines are added to the current plot.
</p>


<h3>Note</h3>

<p>This is a preliminary convenience function that will be used to overhaul <code><a href="#topic+levelMap">levelMap</a></code>
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weightedMap">weightedMap</a></code> for more involved example
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hessen)

# continuous variable between 0 and 1
data &lt;- hessen$data[,1:3]
heights &lt;- round(data[,1]/rowSums(data), digits = 1)
cols &lt;- heat.colors(11)
names(cols) &lt;- names(table(heights))

# boundary as sf
w &lt;- sf::st_as_sf(hessen$boundary)
sf::st_crs(w) &lt;- 4326
w &lt;- sf::st_transform(w, 2397)

# points as sf
p &lt;- sf::st_as_sf(hessen$villages, coords = c("longitude", "latitude"))
sf::st_crs(p) &lt;- 4326
p &lt;- sf::st_transform(p, 2397)

# plot map
plot(p, col = cols[as.character(heights)], border = NA, pch = 19)
plot(w, add = TRUE, border = "grey")

# add boundary
addContour(heights, points = p, window = w, crs = 2397, grid = 1000,
            levels = c(0.25, 0.35, 0.45), col = "blue")
</code></pre>

<hr>
<h2 id='boundary'>
Checking boundary parameters for plotting of <code>levelMap</code>
</h2><span id='topic+boundary'></span>

<h3>Description</h3>

<p>The function <code><a href="#topic+levelMap">levelMap</a></code> can be tweaked by various parameters determining the boundary of the interpolation. The function <code>boundary</code> helps finding suitable parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary(points, density = 0.02, grid = 10, box.offset = 0.1
  , tightness = "auto", manual = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boundary_+3A_points">points</code></td>
<td>

<p>Points, typically a two-column matrix with x and y coordinates.
</p>
</td></tr>
<tr><td><code id="boundary_+3A_density">density</code></td>
<td>

<p>Density of points below which there should be no interpolation.
</p>
</td></tr>
<tr><td><code id="boundary_+3A_grid">grid</code></td>
<td>

<p>Density of the grid.
</p>
</td></tr>
<tr><td><code id="boundary_+3A_box.offset">box.offset</code></td>
<td>

<p>Distance of the box around the points.
</p>
</td></tr>
<tr><td><code id="boundary_+3A_tightness">tightness</code></td>
<td>

<p>Parameter influencing how tightly the boundary should be wrapped around the points. Passed internally to <a href="MASS.html#topic+kde2d">kde2d</a>. When <code>"auto"</code> this defaults to <a href="MASS.html#topic+bandwidth.nrd">bandwidth.nrd</a>. Lower values will result in tighter boundaries.
</p>
</td></tr>
<tr><td><code id="boundary_+3A_manual">manual</code></td>
<td>

<p>Manually added boundary points in the form of a two-column matrix with coordinates.
</p>
</td></tr>
<tr><td><code id="boundary_+3A_plot">plot</code></td>
<td>

<p>Logical: by default the impact of the chosen parameters is shown. If <code>FALSE</code> then coordinates are returned that are the outside of the boundary.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of trying to use a polygon as a boundary for the interpolation internally in <code><a href="#topic+levelMap">levelMap</a></code> it turned out to be easier to use a collection of points that mark the outside.
</p>


<h3>Value</h3>

<p>By default, returns a plot with the original points in black, the points below density in red, and the box around the points in blue. Contour lines of the density are shown to choose different density parameters.
</p>
<p>When <code>plot = FALSE</code>, the blue and red points from the graphic are returned as a two-column matrix of x and y coordinates.
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>


<h3>See Also</h3>

<p>Used internally in <code><a href="#topic+levelMap">levelMap</a></code>. The parameters of this function can be passed through, typically <code>density</code> and <code>box.offset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hessen)

# show impact of the chosen parameters
boundary(hessen$villages, density = 0.1, grid = 20
  , manual = cbind(x = c(8.3, 9.2), y = c(49.9, 50.0)))

# return coordinates
boundary(hessen$villages, plot = FALSE)

# abstract example, showing tightness in action
oldpar&lt;-par("mfrow")
par(mfrow = c(1,3))

p &lt;- cbind(c(1:10, 1:10), c(1:10, 10:1))
boundary(p, density = 0.005, grid = 20, tightness = "auto")
boundary(p, density = 0.005, grid = 20, tightness = 5)
boundary(p, density = 0.005, grid = 20, tightness = 3)

par(mfrow = oldpar)

</code></pre>

<hr>
<h2 id='dialects'>
Multiple correspondences of &quot;f&quot;-like sounds in German Dialects
</h2><span id='topic+dialects'></span>

<h3>Description</h3>

<p>In total 34 different words in which an f-like sound occurs. The different pronunciations of this sound in 183 different German villages are included in this dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dialects)</code></pre>


<h3>Format</h3>

<p>List of 2:
</p>

<dl>
<dt><code>villages</code></dt><dd><p>Dataframe with two variables LONGITUDE and LATITUDE for all 183 villages.</p>
</dd>
<dt><code>data</code></dt><dd><p>Matrix with 34 columns showing the pronunciation in the 183 villages.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Excerpt from <a href="https://github.com/cysouw/PAD/">https://github.com/cysouw/PAD/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# might give error message because of non-ASCII phonetic symbols
data(dialects)
require(mapdata)
map("worldHires", "Germany", fill = TRUE, col = "grey90")

lmap(dialects$villages, dialects$data[,21]
  , levels = c(0.20, 0.22, 0.24), add = TRUE, position = "topleft")

title(main = "f-sound in \'Kochlöffel\'")

## End(Not run)
</code></pre>

<hr>
<h2 id='factorMap'>
Visualising nominal data with various factors.
</h2><span id='topic+factorMap'></span><span id='topic+fmap'></span><span id='topic+limage'></span>

<h3>Description</h3>

<p>A factor map (&quot;fmap&quot;) is a counterpart of the base function <code><a href="graphics.html#topic+image">image</a></code>. In contrast to an image, a factor map can be used for nominal data with various levels (instead of continuous numerical data). A matrix (or a dataframe coerced as matrix) is visualised by showing the most frequent contents of the cells by colouring. There are various methods for ordering of rows and columns provided, alike to a <code><a href="stats.html#topic+heatmap">heatmap</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorMap(x, order = NULL, col = rainbow(4), show.remaining = FALSE,
  col.remaining = "grey", pch.na = 20, col.na = "lightgrey", legend = length(col),
  labels.x = rownames(x), labels.y = colnames(x), cex.axis = 1, cex.legend = 1,
  cex.remaining = 1, font = "", asp = nrow(x)/ncol(x), method = "hamming",
  control = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factorMap_+3A_x">x</code></td>
<td>

<p>A matrix or dataframe with the data to be displayed. Rows are shown on the x-axis, columns on the y-axis, showing the row- and column-names in the display. All data in the whole matrix is interpreted as one large factor with different levels.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_order">order</code></td>
<td>

<p>How should rows and columns be ordered? By default the order of the data matrix <code>x</code> is used. Many possible algorithmic orderings are available, see Details. custom orderings should simply be applied to the <code>x</code> matrix beforehand, then without invoking this <code>order</code> argument.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_col">col</code></td>
<td>

<p>Colors to be used for the display. By default, the colours specified here are used in order of frequency of the phenomena in the data (i.e. <code>order(table(x), decreasing = TRUE</code>). A named vector of colors (or a named list) are applied to the levels as named. All other levels are shown as 'others'. Optionally use <code>show.remaining</code> to show labels for these others in the visualisation.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_show.remaining">show.remaining</code></td>
<td>

<p>Logical: should all levels without color be shown inside the boxes as text?
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_col.remaining">col.remaining</code></td>
<td>

<p>Which color should the text of the uncolored levels have?
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_pch.na">pch.na</code></td>
<td>

<p>Symbol to be used for NA elements. Use <code>NULL</code> for no symbol, but complete coloring of the boxes.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_col.na">col.na</code></td>
<td>

<p>Color to be used for NA elements.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_legend">legend</code></td>
<td>

<p>How many levels should be shown in the legend (in the order of frequency? Alternatively, provide a vector with names of the levels to be shown. Use <code>NULL</code> to suppress the legend.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_labels.x">labels.x</code></td>
<td>

<p>Labels to be used on the x-axis. Defaults to rownames of the data. Use <code>NULL</code> to suppress labels.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_labels.y">labels.y</code></td>
<td>

<p>Labels to be used on the y-axis. Defaults to colnames of the data. Use <code>NULL</code> to suppress labels.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_cex.axis">cex.axis</code></td>
<td>

<p>Size of the row and columns names of <code>x</code>, shown as axis labels.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_cex.legend">cex.legend</code></td>
<td>

<p>Size of the legend text.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_cex.remaining">cex.remaining</code></td>
<td>

<p>Size of the text in the boxes. Only shown when <code>show.remaining = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_font">font</code></td>
<td>

<p>Font to be used in the plotting, can be necessary for unusual unicode symbols. Passed internally to <code>par(family)</code>.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_asp">asp</code></td>
<td>

<p>Aspect-ratio of the plotting of the boxes. By default the complete plot will be approximately square. Use the value 1 for all square boxes. Manually resizing the boxes by changing the plotting window can be achieved by setting <code>asp = NA</code>.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_method">method</code></td>
<td>

<p>Method used to determine similarity, passed to <a href="qlcMatrix.html#topic+sim.obs">sim.obs</a>, which is used internally to determine the order of rows and columns, using the method chosen in <code>order</code>.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_control">control</code></td>
<td>

<p>List of options passed to <a href="seriation.html#topic+seriate">seriate</a>.
</p>
</td></tr>
<tr><td><code id="factorMap_+3A_plot">plot</code></td>
<td>

<p>By default, a plot is returned. When <code>FALSE</code>, nothing is plotted, but the re-ordering is returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are many different orderings implemented: <code>"pca"</code> and <code>"varimax"</code> use the second dimension of <a href="stats.html#topic+prcomp">prcomp</a> and <a href="stats.html#topic+varimax">varimax</a> respectively. <code>"eig"</code> will use the first eigenvector as computed by <a href="RSpectra.html#topic+eigs">eigs</a>. This is really quick for large datasets. <code>"mds"</code> will use the first dimension of <a href="stats.html#topic+cmdscale">cmdscale</a>.
</p>
<p>Further, all methods as provided in the function <a href="seriation.html#topic+seriate">seriate</a> can be called. Specifcally, <code>"R2E"</code> and <code>"MDS_angle"</code> seem worthwhile to try out. Any parameters for these methods can be passed using the option <code>control</code>.
</p>


<h3>Value</h3>

<p>A plot is returned by default. When <code>plot = FALSE</code>, a list is returned with the reordering of the rows and the columns.
</p>


<h3>Note</h3>

<p>Note that it is slightly confusing that the resulting image is a transposed version of the data matrix (rows of the matrix are shown as horizontal lines in the graphic, and they are shown from bottom to top). This is standard practice though, also used in <a href="graphics.html#topic+image">image</a> and <a href="stats.html#topic+heatmap">heatmap</a>, so it is continued here.
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code> in base and <a href="seriation.html#topic+pimage">pimage</a> in the package <code>seriation</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a simple data matrix
x &lt;- matrix(letters[1:5],3,5)
x[2,3] &lt;- x[1,4] &lt;- NA
rownames(x) &lt;- c("one", "two", "three")
colnames(x) &lt;- 1:5
x

# some basic factor maps
factorMap(x, asp = 1)
factorMap(x, col = heat.colors(5), asp = NA)
factorMap(x, col = list(b = "red", e = "blue"), show.remaining = TRUE)

## Not run: 
# more interesting example, different "f" sounds in german dialects
# note that fonts might be problematic on some platforms
# plotting window should be made really large as well
data(dialects)
factorMap(dialects$data, col = rainbow(8), order = "R2E"
    , cex.axis = 0.3, cex.legend = 0.7
    , show.remaining = TRUE, cex.remaining = 0.2)

# get reordering of rows
# to identify the group of words with "p-f" correspondences
factorMap(dialects$data, order = "R2E", plot = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='haspelmath'>
Data about indefinite constructions in 39 different languages
</h2><span id='topic+haspelmath'></span>

<h3>Description</h3>

<p>Summary of the data in Haspelmath (1997), classical example of the usage of semantic maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(haspelmath)</code></pre>


<h3>Format</h3>

<p>The dataset is a matrix with nine rows, describing the different indefinite functions, and 134 columns documenting for each individual construction which functions are possibly expressed by it.
</p>


<h3>Source</h3>

<p>Haspelmath, Martin. Indefinite Pronouns. Oxford Studies in Typology and Linguistic Theory. Oxford: Clarendon, 1997.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(haspelmath)
## English data
haspelmath[,7:9]
</code></pre>

<hr>
<h2 id='heeringa'>
Heeringa-style colours
</h2><span id='topic+heeringa'></span>

<h3>Description</h3>

<p>Proposed in Heeringa (2004) to colour a (dis)similarity by decomposing it into three dimensions (using <code>cmdscale</code> here) and then mapping these dimensions to RGB to make colours. Highly useful to visualize pairwise similarities between geographic regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heeringa(dist, power = 0.5, mapping = c(1, 2, 3), method = "eigs", center = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heeringa_+3A_dist">dist</code></td>
<td>

<p><code><a href="stats.html#topic+dist">dist</a></code> object specifying distances between points.
</p>
</td></tr>
<tr><td><code id="heeringa_+3A_power">power</code></td>
<td>

<p>Factor used to influence the results of the multidimensional scaling. Values closer to one will lead to clearer separated colours, while higher values will lead to more gradual colours.
</p>
</td></tr>
<tr><td><code id="heeringa_+3A_mapping">mapping</code></td>
<td>

<p>Optional vector to change the mapping of the dimensions to the colours. Should be of length 3, specifying to which color each of the three dimensions is mapped. A 1 means 'red', a 2 means 'green' and a 3 means 'blue'. Adding a minus reverses the mapping.
</p>
</td></tr>
<tr><td><code id="heeringa_+3A_method">method</code></td>
<td>

<p>Method used to determine the colour dimensions. Either <code>mds</code> (nicer colourbalance) or <code>eigs</code> (much faster).
</p>
</td></tr>
<tr><td><code id="heeringa_+3A_center">center</code></td>
<td>

<p>Optionally, specify an index of one of the points to be put in the center of the coloring scheme, i.e. this point will become grey and all other points will be colored relative to this point.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This proposal goes back to Heeringa (2004). The idea is to visualize distances by mapping the first three dimensions of a multidimensional scaling to the the red-green-blue scales. The <code>mapping</code> vector can be used to change the mapping to the colours.
</p>


<h3>Value</h3>

<p>A vector of colours of the same length as the size of the dist object.
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>


<h3>References</h3>

<p>Heeringa, Wilbert. &quot;Measuring Dialect Pronunciation Differences Using Levenshtein Distance.&quot; Ph.D. Thesis, Rijksuniversiteit Groningen, 2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hessen)
tess &lt;- weightedMap(hessen$villages, window = hessen$boundary, crs = 2397)
d &lt;- dist(hessen$data, method = "canberra")

# different mappings of the colors
c1 &lt;- heeringa(d)
plot(tess$weightedVoronoi, col = c1, border = NA)

c2 &lt;- heeringa(d, power = 1, mapping = c(3, -2, 1))
plot(tess$weightedVoronoi, col = c2, border = NA)
</code></pre>

<hr>
<h2 id='hessen'>
Extract from the SyHD Project on the syntax of the dialect of Hessen (Germany)
</h2><span id='topic+hessen'></span>

<h3>Description</h3>

<p>An example dataset of dialect data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hessen)</code></pre>


<h3>Format</h3>

<p>List of 3
</p>

<dl>
<dt><code>boundary</code></dt><dd><p>An object of type <code>owin</code> describing a geographical boundary. This format is necessary for Voronoi diagrams.</p>
</dd>
<dt><code>villages</code></dt><dd><p>A dataframe with two variables &quot;longitude&quot; and &quot;latitude&quot; for the 157 villages on this there is data in this dataset.</p>
</dd>
<dt><code>data</code></dt><dd><p>Dataframe with 56 different characteristics of these 157 villages, distributed over 15 different variables (as indicated in the column names).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data from <a href="https://www.syhd.info/startseite/index.html">https://www.syhd.info/startseite/index.html</a>
</p>


<h3>References</h3>

<p>Jürg Fleischer, Simon Kasper &amp; Alexandra N. Lenz (2012): Die Erhebung syntaktischer Phänomene durch die indirekte Methode: Ergebnisse und Erfahrungen aus dem Forschungsprojekt &quot;Syntax hessischer Dialekte&quot; (SyHD). In: Zeitschrift für Dialektologie und Linguistik 79/1, 2-42.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hessen)

tessalation &lt;- weightedMap(hessen$villages, window = hessen$boundary, crs = 2397)
plot(tessalation$weightedVoronoi)
</code></pre>

<hr>
<h2 id='levelMap'>
Drawing multi-level maps (e.g. semantic maps or linguistic isoglosses)
</h2><span id='topic+levelMap'></span><span id='topic+lmap'></span>

<h3>Description</h3>

<p>A multi-level map (&quot;lmap&quot;) is a plot of the distribution of nominal data with multiple levels in space. Such visualisations have two direct use-case in linguistics, viz. semantic maps and isoglosses. The drawing if the lines in space is performed by interpolation in this function (see details).
</p>
<p>Semantic maps (Haspelmath 2003) are a visualisation of linguistic diversity. A semantic map shows a predefined configuration of functions/senses in two-dimensional space with an overlay of language-specific encoding of these functions/senses. An level-map tries to emulate this linguistic visualisation in an automatic fashion with various options for visual presentation.
</p>
<p>Isoglosses show lines surrounding similar phenomena in space. Instead of drawing an exact boundary around measured points, an interpolation-technique is used here to show areas of interest. By only showing boundaries, multiple phenomena can be shown in one graphic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levelMap(points, data,
   main = NULL, draw = 5, levels = c(0.41, 0.46, 0.51),
   labels = NULL, cex = 0.7, col = "rainbow", add = FALSE,
   ignore.others = FALSE, normalize.frequency = FALSE, scale.pies = FALSE,
   lambda = NA, legend = TRUE, position = "bottomleft", cex.legend = 0.7,
   font = "", note = TRUE, file.out = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="levelMap_+3A_points">points</code></td>
<td>

<p>Coordinates of the data points specified as a two-column matrix or dataframe.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_data">data</code></td>
<td>

<p>Language data to be plotted as contour-overlay over the points. Either specified as a vector of language-specific forms, or as a numeric matrix with the forms as columns and the points as rows (the language-specific forms should be specified as <code>colnames</code>). The values in the matrix designate the occurrence of the forms, allowing for the encoding of frequency/typicality and of overlap of different forms being used in the same function. see Details.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_main">main</code></td>
<td>

<p>Title for the plot
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_draw">draw</code></td>
<td>

<p>Which forms to be drawn by contours. Specifying a numeric value will only draw the uppermost frequent forms in the data, by default only the topmost five forms are drawn (automatically ordered by frequency). Alternatively, a vector with names or column-indices of the forms to be drawn can be specified.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_levels">levels</code></td>
<td>

<p>height of contours to be drawn. Internally, all values are normalized between zero and one, so only values between those extremes are sensible. Line thickness is automatically balanced.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_labels">labels</code></td>
<td>

<p>Optionally, character vector with labels for the points, to be drawn instead of symbols in the plot. Should be a vector of the same length as the number of points. Alternatively, a single character-string is repeated for all points.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_cex">cex</code></td>
<td>

<p>Character expansion of the labels (see previous option). Also influences the size of symbols or pie-charts.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_col">col</code></td>
<td>

<p>Colour specification, either in the form of the name of a built-in color palettes, like <a href="grDevices.html#topic+rainbow">rainbow</a>, or a manually specified vector of colors. When <a href="base.html#topic+NULL">NULL</a>, an attempt is made to use grey-scales.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_add">add</code></td>
<td>

<p>Logical: should the plot be added to an existing plot or not?
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_ignore.others">ignore.others</code></td>
<td>

<p>Logical: ignore all other categories, not selected through <code>draw</code>.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_normalize.frequency">normalize.frequency</code></td>
<td>

<p>Logical: should rows of data (points in the plot) be normalized to 1? Useful only for data that represent frequency of occurence as columns. Note that setting this to <code>FALSE</code> influences the behaviour of <code>levels</code>.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_scale.pies">scale.pies</code></td>
<td>

<p>logical: for multivalued data: should the size of the pies represent frequencies (<code>TRUE</code>) or all be of the same size (<code>FALSE</code>, by default)?
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_lambda">lambda</code></td>
<td>

<p>Parameter for the interpolation, passed internally to the function <a href="fields.html#topic+Krig">Krig</a>. Low values result in more detailed boundaries around the measured points.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_legend">legend</code></td>
<td>

<p>Logical: should a legend be added?
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_position">position</code></td>
<td>

<p>Where should the legend be positioned? Passed internally to <a href="graphics.html#topic+legend">legend</a>.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_cex.legend">cex.legend</code></td>
<td>

<p>Character expansion passed to <a href="graphics.html#topic+legend">legend</a>, and also used for the indication of the levels in the plot
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_font">font</code></td>
<td>

<p>Font to be used for the legend and the labels. Passed internally to <code>par(family)</code>.
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_note">note</code></td>
<td>

<p>Logical: should a note be added to the bottom of the graphic to document the levels of the countour lines?
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_file.out">file.out</code></td>
<td>

<p>Location for writing the image to a file instead of plotting it on screen
</p>
</td></tr>
<tr><td><code id="levelMap_+3A_...">...</code></td>
<td>

<p>Additional parameters optionally passed to <a href="#topic+boundary">boundary</a> for the specification of the area of interpolation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea is to use some kind of interpolation to show areas of high-occurrence of a specific phenomenon. Internally Kriging is used, and then only contour lines are shown of the interpolation. Multiple lines are suggested to indicate the probibalistic interpretation of the lines.
</p>


<h3>Value</h3>

<p>A plot is produces with the different phenomena in space surrounded by lines. When multiple options are possible at each point then pie charts are added.
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># isogloss example
# choose one feature from hessen dataset (number 4)
data(hessen)
f4 &lt;- hessen$data[,9:13]

# look for area for interpolation, changing density and grid parameters
# suitable parameters can be passed through to function levelMap below
boundary(hessen$villages, density = 0.1, grid = 10)

# useful size of pies has to be determined by changing cex
plot(hessen$boundary, main = NULL)
levelMap(hessen$villages, f4, draw = 3, cex = 0.8, normalize.frequency = TRUE
  , density = 0.1, grid = 10, add = TRUE, cex.legend = 0.5, scale.pies = TRUE)

## Not run: 
# another isogloss example:
# "f" sounds in German dialects in the words "Kochlöffel"
# might give Unicode-errors because of phonetic symbols
require(mapdata)
map("worldHires", "Germany", fill = TRUE, col = "grey90")

data(dialects)
levelMap(dialects$villages, dialects$data[,21], levels = c(0.20, 0.22, 0.24)
    , add = TRUE, position = "topleft")
title(main = "f-sound in \'Kochlöffel\'")

## End(Not run)

# semantic map example
# location of points via multidimensional scaling of complete data
data(haspelmath)
d &lt;- dist(haspelmath)
p &lt;- MASS::isoMDS(d)$points

# testing boundary parameters
boundary(p)
boundary(p, density = 0.004, box = 0.15, tightness = 8)

# labels to be plotted instead of points
text &lt;- gsub("\\.", "\n", rownames(haspelmath))

# show a few languages for Haspelmaths indefinite data
# using a quick dummy function to set all parameters
indef &lt;- function(columns) {
  levelMap(p, haspelmath[,columns]
    , levels = 0.1, labels = text
    , density = 0.004, box = 0.15, tightness = 8
    , lambda = 0.1, note = FALSE)
}

oldpar &lt;- par("mfcol")
par(mfcol = c(2,3))

indef(1:3)
indef(4:6)
indef(7:9)
indef(10:12)
indef(13:17)
indef(18:22)

par(mfcol = oldpar)

</code></pre>

<hr>
<h2 id='vmap'>
Plotting a Voronoi-map (&quot;v-map&quot;)
</h2><span id='topic+vmap'></span><span id='topic+voronoimap'></span><span id='topic+voronoi'></span>

<h3>Description</h3>

<p>These functions are deprecated: use <a href="#topic+weightedMap">weightedMap</a> instead.
</p>
<p>A Voronoi-map (voronoi-tessellation, also known as dirichlet tessellation) is used in quantitative dialectology. This function is a convenience wrapper to easily produce dialect maps with voronoi tessellations. Also described here are a helper functions to produce the tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmap(tessellation, col = NULL, add = FALSE,
  outer.border = "black", border = "grey", lwd = 1, ...)

voronoi(points, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vmap_+3A_tessellation">tessellation</code></td>
<td>

<p>Tessellation of class <code><a href="spatstat.geom.html#topic+tess">tess</a></code> from the library <code>spatstat.geom</code>. Can easily be produces by using the convenience function <code>voronoi</code> provided here.
</p>
</td></tr>
<tr><td><code id="vmap_+3A_col">col</code></td>
<td>

<p>Vector of colors for the filling of the tessellation. Is recycled when there are more tiles than colours. The order of the tiles is the same as the order of the points as specified in the function <code><a href="#topic+voronoi">voronoi</a></code>.
</p>
</td></tr>
<tr><td><code id="vmap_+3A_add">add</code></td>
<td>

<p>Add graphics to an existing plot
</p>
</td></tr>
<tr><td><code id="vmap_+3A_outer.border">outer.border</code></td>
<td>

<p>Colour of the outer border. Specifying <code>NA</code> removes the border.
</p>
</td></tr>
<tr><td><code id="vmap_+3A_border">border</code></td>
<td>

<p>Colour of the inner borders. Specifying <code>NA</code> removes all borders.
</p>
</td></tr>
<tr><td><code id="vmap_+3A_lwd">lwd</code></td>
<td>

<p>Line width of borders.
</p>
</td></tr>
<tr><td><code id="vmap_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <a href="graphics.html#topic+polygon">polygon</a>.
</p>
</td></tr>
<tr><td><code id="vmap_+3A_points">points</code></td>
<td>

<p>Two-column matrix with all coordinates of the points to make a Voronoi tessellation.
</p>
</td></tr>
<tr><td><code id="vmap_+3A_window">window</code></td>
<td>

<p>Outer boundary for the Voronoi tessellation. Should be in the form of an <code><a href="spatstat.geom.html#topic+owin">owin</a></code> object. There are two helper functions provided here to get such object. Note that the function <code><a href="#topic+voronoi">voronoi</a></code> will give warnings if there are points outside of this window.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code is almost completely based on functions from the <code>spatstat.geom</code> package. For convenience, first some geographical boundaries can easily be accessed and converted for use in <code>spatstat.geom</code>. Then a Voronoi tessellation can be made (based on the function <code><a href="spatstat.geom.html#topic+dirichlet">dirichlet</a></code>, which in turn is based on <code>deldir</code> from the package <code>deldir</code>). Finally, this tessellation can be plotted filled with different colours.
</p>
<p>Any legends have to be added manually by using <code><a href="graphics.html#topic+legend">legend</a></code>, see examples below.
</p>
<p>The function <code>voronoi</code> returns a warning when points are attested that lie outside of the specified border. For these points there is no polygon specified. Indices for the rejected points outside the border can be accessed by <code>attr(x, "rejects")</code>.
</p>


<h3>Value</h3>

<p><code>voronoi</code> returns a tessellation of the class <code>tess</code> from the package <code>spatstat.geom</code>. When points outside of the border are attested, the indices of these points are added to an attribute &quot;rejects&quot;.
<code>vmap</code> plots a map.
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make a Voronoi tessellation for some villages in hessen
data(hessen)
plot(hessen$boundary)
points(hessen$villages, cex = 0.3)

tessellation &lt;- voronoi(hessen$villages, hessen$boundary)
plot(tessellation)

# make a resizable plot with random colour specification
vmap(tessellation, col = rainbow(5), border = NA)
legend("bottomright", legend = c("a","b","c","d","e"), fill = rainbow(5))

# use actual colors from data, using first feature from supplied data
# multiple levels cannot easily be shown
# consider \link{lmap} for more detail
d1 &lt;- hessen$data[,1:3]
d1 &lt;- d1[,1]/rowSums(d1)
vmap(tessellation, col = rgb(1, 1-d1, 1-d1))
text(hessen$villages,labels=hessen$data[,1],cex=.5)
legend("bottomright", legend = c("es mir", "mir es / other"),
  fill = c("red", "white"))

# Use distances to determine colour, as proposed by Heeringa (2004)
# Note that different methods to establish distances can lead to rather
# different results! Also try method = "euclidean"
d &lt;- dist(hessen$data, method = "canberra")
cols &lt;- heeringa(d)
vmap(tessellation, col = cols, border = NA)

## End(Not run)
</code></pre>

<hr>
<h2 id='weightedMap'>
Construct weighted map using Voronoi tessellation and cartogram weighting
</h2><span id='topic+weightedMap'></span><span id='topic+wmap'></span>

<h3>Description</h3>

<p>A weighted map (&quot;wmap&quot;) is a combination of a Voronoi tessellation with cartogram weighting. A Voronoi map is a tessellation of a surface based on a set of geographic points. It is used to display areal patterns without overlap. Additionally, the size of the tiles can be weighted by cartogram-deformation to allow for varying the visual impression of the data. Specifically, this allows for equal-area-sized tiles to equally represent all data-points in the visual display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedMap(x, y = NULL, window = NULL, crs = NULL, weights = "equal",
  grouping = NULL, holes = NULL, concavity = 2, expansion = 1000,
  method = "dcn", maxit = 10, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedMap_+3A_x">x</code></td>
<td>

<p>Coordinates of the data-points, either an <code>sf</code> object or a two-column matrix/dataframe with x ('longitude') and y ('latitude') coordinates. Alternatively, only specify the x-coordinates here and use the <code>y</code> parameter for the y-coordinates.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_y">y</code></td>
<td>

<p>Latitude (y-coordinates), when the parameter <code>x</code> is used for longitude only.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_window">window</code></td>
<td>

<p>Geographical window within which the Voronoi-tessellation will be displayed. Typically an <code>sf</code> (multi)polygon, but an attempt is made to interpret other formats (e.g. <code>owin</code> from Spatstat, <code>SpatVector</code> from Terra and <code>Spatial</code> from sp). Consider libraries like <code>geodata</code> and <code>rnaturalearth</code> to obtain suitable windows. Polygons that do not contain any coordinates are removed (with a warning). Coordinates that do not lie within the window are removed (with a warning).
</p>
<p>When no window is provided (by default), then a concave hull is induced from the coordinates (using <code><a href="concaveman.html#topic+concaveman">concaveman</a></code>). Various other parameters explained below can be used to influence this hull.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_crs">crs</code></td>
<td>

<p>Coordinate reference system that is necessary for the projection of the map. When not provided, an attempt is made to extract a crs from the provided coordinates or from the provided window. Without any crs there will be a warning and <code>EPSG:3857</code> will be assumed. Note that the ubiquitous <code>EPSG:4326</code> is strictly speaking not a projection and results in various errors; use a projected version like <code>EPSG:3857</code> instead, or use any of the numerous better alternatives (see examples below for some ideas).
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_weights">weights</code></td>
<td>

<p>Vector with weights for the deformation of the Voronoi-tiles. Should have the same length as the number of coordinates provided. The weights are passed to <code><a href="cartogramR.html#topic+cartogramR">cartogramR</a></code> to perform the deformation. Defaults to <code>"equal"</code> for equal-area tiles. When <code>NULL</code> no weighting is performed, but a non-weighted Voronoi-map is still produced.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_grouping">grouping</code></td>
<td>

<p>Influence the form of the concave window around the coordinates. Only used when there is no <code>window</code> provided. A vector with the same length as the number of coordinates, listing for each coordinate to which group it belongs. An attempt is made to make separate windows for each group. Note that a high value for the parameter <code>expansion</code> might result in overlap.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_holes">holes</code></td>
<td>

<p>A list of <code>x,y</code> coordinates where holes should be inferred. When <code>window = NULL</code> there will be holes inserted inside the window around the coordinates specified within a distance as specified in <code>expansion</code> from the nearest points around the coordinates. Not used when there is an explicit window provided.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_concavity">concavity</code></td>
<td>

<p>Influence the form of the concave window around the coordinates. Only used when there is no <code>window</code> provided. Parameter passed internally to <code><a href="concaveman.html#topic+concaveman">concaveman</a></code> determining the concavity of the hull. High values result in more convex hulls. Low values (especially between 1 and 0) lead to highly concave (&quot;wiggly&quot;) windows.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_expansion">expansion</code></td>
<td>

<p>Influence the form of the concave window around the coordinates. Only used when there is no <code>window</code> provided. Expands the window (value in meters), and results in more &quot;rounded&quot; windows.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_method">method</code></td>
<td>

<p>Method used for cartogram deformation, passed to <code><a href="cartogramR.html#topic+cartogramR">cartogramR</a></code>. By default, the older-quicker-less accurate method <code>dcn</code> is used. More modern and accurate methods <code>gsm</code> and <code>gn</code> can also be used, but they might lead to strange results with more complex windows. They also sometimes lead to strange results, or downright stall. Lower <code>maxit</code> might prevent these problems, but lead to less accurate weighting. Also consider the option <code>verbose</code> to get an indication where things go wring.
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations to find a suitable deformation. Parameter passed internally to <code><a href="cartogramR.html#topic+cartogramR">cartogramR</a></code>. Higher values lead to better approximations of the size of the polygons to the weights. However, with complex maps it might take very long to converge (or even never finish).
</p>
</td></tr>
<tr><td><code id="weightedMap_+3A_verbose">verbose</code></td>
<td>

<p>With <code>verbose = 1</code> turn on verbose output for <code><a href="cartogramR.html#topic+cartogramR">cartogramR</a></code> to check where the deformation might run wild
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, the Voronoi-tessellation is made without respecting the window, and only afterwards the window is superimposed on the tessellation. In some circumstances with internal holes in the window provided, an attempt is made to return tiles that do not jump across such holes. However, sometimes artefacts are still visible in the output.
</p>
<p>Warnings are produced when coordinates lie outside the window provided. The results should still work, but without these points outside. Any colouring or other uses of the results have to be adapted accordingly by using the information in <code>$outsideWindow</code>. Polygons without any points inside are likewise removed with a warning.
</p>
<p>To deal with overlapping coordinates some jitter is automatically applied to the coordinates provided.
</p>


<h3>Value</h3>

<p>List of various lengths, depending on specified parameters. Use the names to select any of these results:
</p>
<table role = "presentation">
<tr><td><code>crs:</code></td>
<td>

<p>The crs in WKT format.
</p>
</td></tr>
<tr><td><code>points:</code></td>
<td>

<p>The coordinates as provided, but as a projected <code>sfc_POINT</code> object.
</p>
</td></tr>
<tr><td><code>grouping:</code></td>
<td>

<p>Character vector with the provided grouping, or the grouping as induced from any provided window.
</p>
</td></tr>
<tr><td><code>window:</code></td>
<td>

<p>The window around the coordinates as a projected <code>sfc_POLYGON</code> or <code>sfc_MULTIPOLYGON</code> object. Some polygons from a provided window might have been removed because they are empty.
</p>
</td></tr>
<tr><td><code>emptyPolygons:</code></td>
<td>

<p>Numeric vector with the indices of the polygons that are removed because they do not contain any of the coordinates provided.
</p>
</td></tr>
<tr><td><code>outsideWindow:</code></td>
<td>

<p>Numeric vector with the indices of the coordinates that are removed because they are outside of the window provided.
</p>
</td></tr>
<tr><td><code>voronoi:</code></td>
<td>

<p>Voronoi-tessellation of the window as a projected <code>sfc_MULTIPOLYGON</code> object.
</p>
</td></tr>
<tr><td><code>weights:</code></td>
<td>

<p>Numeric vector with the weights used for the deformation. Weights for coordinates outside of the window are removed.
</p>
</td></tr>
<tr><td><code>weightedPoints:</code></td>
<td>

<p>Coordinates after the weighting-deformation, specified as a projected <code>sfc_POINT</code> object.
</p>
</td></tr>
<tr><td><code>weightedWindow:</code></td>
<td>

<p>Window after the weighting-deformation, specified as a projected <code>sfc_POLYGON</code> or <code>sfc_MULTIPOLYGON</code> object.
</p>
</td></tr>
<tr><td><code>weightedMap:</code></td>
<td>

<p>Voronoi-tessellation after the weighting-deformation, specified as a projected <code>sfc_MULTIPOLYGON</code> object.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>With more complex windows the deformation by <code><a href="cartogramR.html#topic+cartogramR">cartogramR</a></code> might throw errors (like &quot;IllegalArgumentException&quot;) or fall into an infinite loop. Try to reduce <code>maxit</code> and check <code>verbose = 1</code> to get an idea what might be going wrong.
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a window from coordinates
# note the Germany-centered Gauss-Kruger projection "EPSG:2397"
# consider increasing 'maxit' to remove the warning about convergence
data(hessen)
v &lt;- weightedMap(hessen$villages, expansion = 4000, crs = 2397, maxit = 2)
plot(v$weightedVoronoi)

# show the original locations before the transformation in orange
plot(v$points, add = TRUE, col = "green", cex = .5)
# show the new locations after transformation in red
plot(v$weightedPoints, add = TRUE, col = "blue", cex = .5)

# add the real border of Hessen for comparison
h &lt;- sf::st_as_sf(hessen$boundary)
sf::st_crs(h) &lt;- 4326
h &lt;- sf::st_transform(h, 2397)
plot(h, add = TRUE, border = "red")

# use the Voronoi tiles e.g. for Heeringa-colouring (see function "heeringa()")
d &lt;- dist(hessen$data, method = "canberra")
plot(v$weightedVoronoi, col = heeringa(d), border = NA)
plot(v$weightedWindow, add = TRUE, lwd = 2)

# grouping-vector can be used to make separations in the base-map
groups &lt;- rep("a", times = 157)
groups[157] &lt;- "b"
groups[c(58,59)] &lt;- "c"
groups[c(101, 102, 107)] &lt;- "d"
# holes-list can be used to add holes inside the region
holes &lt;- list(c(9, 50.5), c(9.6, 51.3), c(8.9, 51))
v &lt;- weightedMap(hessen$villages, grouping = groups, holes = holes,
                  crs = 2397, expansion = 3000)
plot(v$weightedVoronoi, col = "grey")

## Not run: 
# extensive example using data from WALS (https://wals.info). Both the worldmap
# and the WALS data are downloaded directly. The worldmap is projected and
# deformed so that each datapoint has equal area on the map.

# load worldmap
data(world)

# try different projections
azimuth_equaldist  &lt;- "+proj=aeqd +lat_0=90 +lon_0=45"
mollweide_atlantic &lt;- "+proj=moll +lon_0=11.5"
mollweide_pacific  &lt;- "+proj=moll +lon_0=151"

plot(sf::st_transform(world, crs = azimuth_equaldist))

# load WALS data, example feature 13: "tone"
library(lingtypology)
feature &lt;- "13A"
wals &lt;- wals.feature(feature)
head(wals)

# get glottolog coordinates and correct errors in WALS
wals$glottocode[wals$glottocode == "poqo1257"] &lt;- "poqo1253"
wals$glottocode[wals$glottocode == "mamc1234"] &lt;- "mamm1241"
wals$glottocode[wals$glottocode == "tuka1247"] &lt;- "tuka1248"
wals$glottocode[wals$glottocode == "bali1280"] &lt;- "unea1237"
wals &lt;- merge(wals[,c("glottocode", "wals.code", feature)],
              glottolog[,c("glottocode", "longitude", "latitude")])

# calculate an equally-weighted voronoi transformation
v &lt;- weightedMap(wals$longitude, wals$latitude, window = world,
                  crs = mollweide_atlantic, method = "dcn", maxit = 10)

# prepare colors
cols &lt;- c("lightsalmon", "grey", "lightpink")
names(cols) &lt;- names(table(wals[,feature]))
cols &lt;- cols[c(2,3,1)]

# the map
plot(v$weightedVoronoi, col = cols[wals[,feature]], border = "darkgrey", lwd = 0.2)
plot(v$weightedWindow, border = "black", add = TRUE, lwd = 0.5)
legend("bottomleft", legend = names(cols), fill = cols, cex = .7)

# add contourlines
height &lt;- c(0, 0.5, 1)
names(height) &lt;- c("No tones", "Simple tone system", "Complex tone system")
addContour(height = height[wals[,feature]],
           points = v$weightedPoints,
           window = v$weightedWindow,
           crs = v$crs,
           col = "darkred", levels = c(0.2, 0.4, 0.6))

# Alternative: using points instead of polygons
cols[2:3] &lt;- c("orange", "red")
plot(v$weightedPoints, col = cols[wals[,feature]], cex = 1, pch = 19)
plot(v$weightedWindow, add = T, border = "darkgrey", lwd = 0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='window'>
Producing windows of class &quot;owin&quot;
</h2><span id='topic+hullToOwin'></span><span id='topic+gadmToOwin'></span><span id='topic+mapsToOwin'></span>

<h3>Description</h3>

<p>These functions are deprecated: use <a href="#topic+weightedMap">weightedMap</a> instead.
</p>
<p>Different ways to easily produce windows of class &quot;owin&quot; from the package &quot;spatstat&quot; are presented here. These are used by <a href="#topic+voronoi">voronoi</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hullToOwin(points, shift, alpha)
mapsToOwin(country, database = "world")
gadmToOwin(country, sub = NULL, level = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window_+3A_points">points</code></td>
<td>

<p>Set of points that need a window around them. Two column matrix.
</p>
</td></tr>
<tr><td><code id="window_+3A_shift">shift</code></td>
<td>

<p>The amount of space around the outer points at determining the window.
</p>
</td></tr>
<tr><td><code id="window_+3A_alpha">alpha</code></td>
<td>

<p>Parameter for the 'curviness': lower values show more detail. Passed internally to <a href="alphahull.html#topic+ahull">ahull</a>.
</p>
</td></tr>
<tr><td><code id="window_+3A_country">country</code></td>
<td>

<p>Name of the country to obtain borders and turn them into an <code><a href="spatstat.geom.html#topic+owin">owin</a></code> object needed for the function <code><a href="#topic+voronoi">voronoi</a></code>. For <code>mapsToOwin</code> check <code><a href="maps.html#topic+map">map</a></code> how to specify the names. For <code>gadmToOwin</code>, check <a href="https://gadm.org">https://gadm.org</a>.
</p>
</td></tr>
<tr><td><code id="window_+3A_database">database</code></td>
<td>

<p>Database as used by <code><a href="maps.html#topic+map">map</a></code>.
</p>
</td></tr>
<tr><td><code id="window_+3A_sub">sub</code>, <code id="window_+3A_level">level</code></td>
<td>

<p>Names for Subdivisions of countries as available in the GADM database
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>hullToOwin</code>, the function <a href="alphahull.html#topic+ahull">ahull</a> is used to make a hull around the points. This is then converted to an &quot;owin&quot; window.
</p>
<p>The functions <code>mapsToOwin</code> and <code>GadmToWin</code> use external topogaphic boundaries to produce windows.
</p>


<h3>Value</h3>

<p>All functions return an object of class <code>owin</code> from the package <code>spatstat</code>.
</p>


<h3>Note</h3>

<p>Includes code from code from Andrew Bevan, based on code from Dylan Beaudette, see <a href="https://stat.ethz.ch/pipermail/r-sig-geo/2012-March/014409.html">https://stat.ethz.ch/pipermail/r-sig-geo/2012-March/014409.html</a>.
</p>
<p>The function <code>gadmToOwin</code> needs online access to download the data. The data is saved in the current working directory, and will not be downloaded again when it is already available there.
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw &lt;cysouw@mac.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Boundary of the German state "Hessen"
# This will need to access the online GADM database
# and might take some time
boundary &lt;- gadmToOwin("DEU", "Hessen", 1)

# A window does not have to be continuous
random &lt;- mapsToOwin(c("Germany", "Greece"))
plot(random, main = NULL)

# hull around some points
# note influence of alpha and shift
data(hessen)

hull &lt;- hullToOwin(hessen$villages, shift = 0.2, alpha = 1)
plot(hull)
points(hessen$villages)

hull &lt;- hullToOwin(hessen$villages, shift = 0.1, alpha = 0.2)
plot(hull)
points(hessen$villages)

## End(Not run)
</code></pre>

<hr>
<h2 id='world'>
Boundary of the World fitting all Glottolog languages
</h2><span id='topic+world'></span>

<h3>Description</h3>

<p>A polygon representing a worldmap tailored to be not too detailed, but still fitting all glottolog languages inside the polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("world")</code></pre>


<h3>Format</h3>

<p>The format is a <code>sfc_POLYGON</code> of length 475 with an EPSG:4326 projection.
</p>


<h3>Details</h3>

<p>Some trickery was needed to produce a lightweight polygon to represent the worldmap in reasonably accuracy without becoming too large and unwiedly. The polygons are such that all coordinates for languages as listed in the glottolog (version 5) are inside these polygons.
</p>
<p>The map has a basic EPSG:4326 projection, so longitude-latitude coordinates can immediately be added to it. However, this does not look very nice, because the polygon from Eurasia wraps around. Consider more suitable projections, see examples. To allow for a nice pacific-centered projection Greenland has been clipped.
</p>


<h3>Source</h3>

<p>Polygons are based on the data from <a href="https://www.naturalearthdata.com">https://www.naturalearthdata.com</a> with adjustments. Glottolog coordinates to select and adjust the polygons are from <a href="https://glottolog.org">https://glottolog.org</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(world)
plot(world)

# use different projections
azimuth_equaldist &lt;- "+proj=aeqd +lat_0=90 +lon_0=45"
mollweide_atlantic &lt;- "+proj=moll +lon_0=11.5"
mollweide_pacific &lt;- "+proj=moll +lon_0=151"

plot(sf::st_transform(world, crs = azimuth_equaldist))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
