<!DOCTYPE html><html><head><title>Help for package provenance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {provenance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ALR'><p>Additive logratio transformation</p></a></li>
<li><a href='#amalgamate'><p>Group components of a composition</p></a></li>
<li><a href='#as.acomp'><p>create an <code>acomp</code> object</p></a></li>
<li><a href='#as.compositional'><p>create a <code>compositional</code> object</p></a></li>
<li><a href='#as.counts'><p>create a <code>counts</code> object</p></a></li>
<li><a href='#as.data.frame'><p>create a <code>data.frame</code> object</p></a></li>
<li><a href='#as.varietal'><p>create a <code>varietal</code> object</p></a></li>
<li><a href='#botev'><p>Compute the optimal kernel bandwidth</p></a></li>
<li><a href='#bray.diss'><p>Bray-Curtis dissimilarity</p></a></li>
<li><a href='#CA'><p>Correspondence Analysis</p></a></li>
<li><a href='#central.counts'><p>Calculate central compositions</p></a></li>
<li><a href='#CLR'><p>Centred logratio transformation</p></a></li>
<li><a href='#combine'><p>Combine samples of distributional data</p></a></li>
<li><a href='#densities'><p>A list of rock and mineral densities</p></a></li>
<li><a href='#diss.distributional'><p>Calculate the dissimilarity matrix between two datasets of class</p>
<code>distributional</code>, <code>compositional</code>, <code>counts</code> or
<code>varietal</code></a></li>
<li><a href='#endmembers'><p>Petrographic end-member compositions</p></a></li>
<li><a href='#get.f'><p>Calculate the largest fraction that is likely to be missed</p></a></li>
<li><a href='#get.n'><p>Calculate the number of grains required to achieve a desired level of sampling resolution</p></a></li>
<li><a href='#get.p'><p>Calculate the probability of missing a given population fraction</p></a></li>
<li><a href='#GPA'><p>Generalised Procrustes Analysis of configurations</p></a></li>
<li><a href='#indscal'><p>Individual Differences Scaling of provenance data</p></a></li>
<li><a href='#KDE'><p>Create a kernel density estimate</p></a></li>
<li><a href='#KDEs'><p>Generate an object of class <code>KDEs</code></p></a></li>
<li><a href='#KS.diss'><p>Kolmogorov-Smirnov dissimilarity</p></a></li>
<li><a href='#Kuiper.diss'><p>Kuiper dissimilarity</p></a></li>
<li><a href='#lines.ternary'><p>Ternary line plotting</p></a></li>
<li><a href='#MDS'><p>Multidimensional Scaling</p></a></li>
<li><a href='#minsorting'><p>Assess settling equivalence of detrital components</p></a></li>
<li><a href='#Namib'><p>An example dataset</p></a></li>
<li><a href='#PCA'><p>Principal Component Analysis</p></a></li>
<li><a href='#plot.CA'><p>Point-counting biplot</p></a></li>
<li><a href='#plot.compositional'><p>Plot a pie chart</p></a></li>
<li><a href='#plot.distributional'><p>Plot continuous data as histograms or cumulative age distributions</p></a></li>
<li><a href='#plot.GPA'><p>Plot a Procrustes configuration</p></a></li>
<li><a href='#plot.INDSCAL'><p>Plot an INDSCAL group configuration and source weights</p></a></li>
<li><a href='#plot.KDE'><p>Plot a kernel density estimate</p></a></li>
<li><a href='#plot.KDEs'><p>Plot one or more kernel density estimates</p></a></li>
<li><a href='#plot.MDS'><p>Plot an MDS configuration</p></a></li>
<li><a href='#plot.minsorting'><p>Plot inferred grain size distributions</p></a></li>
<li><a href='#plot.PCA'><p>Compositional biplot</p></a></li>
<li><a href='#plot.ternary'><p>Plot a ternary diagram</p></a></li>
<li><a href='#points.ternary'><p>Ternary point plotting</p></a></li>
<li><a href='#procrustes'><p>Generalised Procrustes Analysis of provenance data</p></a></li>
<li><a href='#provenance'><p>Menu-based interface for <code>provenance</code></p></a></li>
<li><a href='#radialplot.counts'><p>Visualise point-counting data on a radial plot</p></a></li>
<li><a href='#read.compositional'><p>Read a .csv file with compositional data</p></a></li>
<li><a href='#read.counts'><p>Read a .csv file with point-counting data</p></a></li>
<li><a href='#read.densities'><p>Read a .csv file with mineral and rock densities</p></a></li>
<li><a href='#read.distributional'><p>Read a .csv file with distributional data</p></a></li>
<li><a href='#read.varietal'><p>Read a .csv file with varietal data</p></a></li>
<li><a href='#restore'><p>Undo the effect of hydraulic sorting</p></a></li>
<li><a href='#SH.diss'><p>Sircombe and Hazelton distance</p></a></li>
<li><a href='#SNSM'><p>varietal data example</p></a></li>
<li><a href='#subset'><p>Get a subset of provenance data</p></a></li>
<li><a href='#summaryplot'><p>Joint plot of several provenance datasets</p></a></li>
<li><a href='#ternary'><p>Define a ternary composition</p></a></li>
<li><a href='#ternary.ellipse'><p>Ternary confidence ellipse</p></a></li>
<li><a href='#text.ternary'><p>Ternary text plotting</p></a></li>
<li><a href='#varietal2distributional'><p>Convert varietal to distributional data</p></a></li>
<li><a href='#Wasserstein.diss'><p>Wasserstein distance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Toolbox for Sedimentary Provenance Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Bundles a number of established statistical methods to facilitate the visual interpretation of large datasets in sedimentary geology. Includes functionality for adaptive kernel density estimation, principal component analysis, correspondence analysis, multidimensional scaling, generalised procrustes analysis and individual differences scaling using a variety of dissimilarity measures. Univariate provenance proxies, such as single-grain ages or (isotopic) compositions are compared with the Kolmogorov-Smirnov, Kuiper, Wasserstein-2 or Sircombe-Hazelton L2 distances. Categorical provenance proxies such as chemical compositions are compared with the Aitchison and Bray-Curtis distances,and count data with the chi-square distance. Varietal data can either be converted to one or more distributional datasets, or directly compared using the multivariate Wasserstein distance. Also included are tools to plot compositional and count data on ternary diagrams and point-counting data on radial plots, to calculate the sample size required for specified levels of statistical precision, and to assess the effects of hydraulic sorting on detrital compositions. Includes an intuitive query-based user interface for users who are not proficient in R.</td>
</tr>
<tr>
<td>Author:</td>
<td>Pieter Vermeesch [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pieter Vermeesch &lt;p.vermeesch@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), IsoplotR (&ge; 5.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>transport, T4transport</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.ucl.ac.uk/~ucfbpve/provenance/">https://www.ucl.ac.uk/~ucfbpve/provenance/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-28 11:25:20 UTC; pvermees</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-28 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ALR'>Additive logratio transformation</h2><span id='topic+ALR'></span><span id='topic+ALR.default'></span><span id='topic+ALR.compositional'></span>

<h3>Description</h3>

<p>Calculates Aitchison's additive logratio transformation for a
dataset of class <code>compositional</code> or a compositional data
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALR(x, ...)

## Default S3 method:
ALR(x, inverse = FALSE, ...)

## S3 method for class 'compositional'
ALR(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ALR_+3A_x">x</code></td>
<td>
<p>an object of class <code>compositional</code> OR a matrix of numerical values</p>
</td></tr>
<tr><td><code id="ALR_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="ALR_+3A_inverse">inverse</code></td>
<td>
<p>perform the inverse inverse logratio transformation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of ALR coordinates OR an object of class
<code>compositional</code> (if <code>inverse=TRUE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># logratio plot of trace element concentrations:
data(Namib)
alr &lt;- ALR(Namib$Trace)
pairs(alr[,1:5])
title('log(X/Pb)')
</code></pre>

<hr>
<h2 id='amalgamate'>Group components of a composition</h2><span id='topic+amalgamate'></span><span id='topic+amalgamate.default'></span><span id='topic+amalgamate.compositional'></span><span id='topic+amalgamate.counts'></span><span id='topic+amalgamate.SRDcorrected'></span><span id='topic+amalgamate.varietal'></span>

<h3>Description</h3>

<p>Adds several components of a composition together into a single
component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amalgamate(x, ...)

## Default S3 method:
amalgamate(x, ...)

## S3 method for class 'compositional'
amalgamate(x, ...)

## S3 method for class 'counts'
amalgamate(x, ...)

## S3 method for class 'SRDcorrected'
amalgamate(x, ...)

## S3 method for class 'varietal'
amalgamate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amalgamate_+3A_x">x</code></td>
<td>
<p>a compositional dataset</p>
</td></tr>
<tr><td><code id="amalgamate_+3A_...">...</code></td>
<td>
<p>a series of new labels assigned to strings or vectors of
strings denoting the components that need amalgamating</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same class as <code>X</code> with fewer
components
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
HMcomponents &lt;- c("zr","tm","rt","TiOx","sph","ap","ep",
                  "gt","st","amp","cpx","opx")
am &lt;- amalgamate(Namib$PTHM,feldspars=c("KF","P"),
                 lithics=c("Lm","Lv","Ls"),heavies=HMcomponents)
plot(ternary(am))
</code></pre>

<hr>
<h2 id='as.acomp'>create an <code>acomp</code> object</h2><span id='topic+as.acomp'></span>

<h3>Description</h3>

<p>Convert an object of class <code>compositional</code> to an object of
class <code>acomp</code> for use in the <code>compositions</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.acomp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.acomp_+3A_x">x</code></td>
<td>
<p>an object of class <code>compositional</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
qfl &lt;- ternary(Namib$PT,c('Q'),c('KF','P'),c('Lm','Lv','Ls'))
plot(qfl,type="QFL.dickinson")
qfl.acomp &lt;- as.acomp(qfl)
## uncomment the next two lines to plot an error
## ellipse using the 'compositions' package: 
# library(compositions)
# ellipses(mean(qfl.acomp),var(qfl.acomp),r=2)
</code></pre>

<hr>
<h2 id='as.compositional'>create a <code>compositional</code> object</h2><span id='topic+as.compositional'></span>

<h3>Description</h3>

<p>Convert an object of class <code>matrix</code>, <code>data.frame</code> or
<code>acomp</code> to an object of class <code>compositional</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.compositional(x, method = NULL, colmap = "rainbow")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.compositional_+3A_x">x</code></td>
<td>
<p>an object of class <code>matrix</code>, <code>data.frame</code> or
<code>acomp</code></p>
</td></tr>
<tr><td><code id="as.compositional_+3A_method">method</code></td>
<td>
<p>dissimilarity measure, either <code>"aitchison"</code> for
Aitchison's CLR-distance or <code>"bray"</code> for the Bray-Curtis
distance.</p>
</td></tr>
<tr><td><code id="as.compositional_+3A_colmap">colmap</code></td>
<td>
<p>the colour map to be used in pie charts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>compositional</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
PT.acomp &lt;- as.acomp(Namib$PT)
PT.compositional &lt;- as.compositional(PT.acomp)
print(Namib$PT$x - PT.compositional$x)
## uncomment the following lines for an illustration of using this 
## function to integrate 'provenance' with 'compositions'
# library(compositions)
# data(Glacial)
# a.glac &lt;- acomp(Glacial)
# c.glac &lt;- as.compositional(a.glac)
# summaryplot(c.glac,ncol=8)
</code></pre>

<hr>
<h2 id='as.counts'>create a <code>counts</code> object</h2><span id='topic+as.counts'></span>

<h3>Description</h3>

<p>Convert an object of class <code>matrix</code> or <code>data.frame</code> to an
object of class <code>counts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.counts(x, method = "chisq", colmap = "rainbow")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.counts_+3A_x">x</code></td>
<td>
<p>an object of class <code>matrix</code> or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="as.counts_+3A_method">method</code></td>
<td>
<p>either <code>"chisq"</code> (for the chi-square distance)
or <code>"bray"</code> (for the Bray-Curtis distance)</p>
</td></tr>
<tr><td><code id="as.counts_+3A_colmap">colmap</code></td>
<td>
<p>the colour map to be used in pie charts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>counts</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(0,100,0,30,11,2,94,36,0),nrow=3,ncol=3)
rownames(X) &lt;- 1:3
colnames(X) &lt;- c('a','b','c')
comp &lt;- as.counts(X)
d &lt;- diss(comp)
</code></pre>

<hr>
<h2 id='as.data.frame'>create a <code>data.frame</code> object</h2><span id='topic+as.data.frame'></span><span id='topic+as.data.frame.compositional'></span><span id='topic+as.data.frame.counts'></span>

<h3>Description</h3>

<p>Convert an object of class <code>compositional</code> to a
<code>data.frame</code> for use in the <code>robCompositions</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compositional'
as.data.frame(x, ...)

## S3 method for class 'counts'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
<p>an object of class <code>compositional</code></p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to the generic function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
Major.frame &lt;- as.data.frame(Namib$Major)
## uncomment the next two lines to plot an error
## ellipse using the robCompositions package:
# library(robCompositions)
# plot(pcaCoDa(Major.frame))
</code></pre>

<hr>
<h2 id='as.varietal'>create a <code>varietal</code> object</h2><span id='topic+as.varietal'></span>

<h3>Description</h3>

<p>Convert an object of class <code>matrix</code> or <code>data.frame</code> to an
object of class <code>varietal</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.varietal(x, snames = NULL, method = "KS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.varietal_+3A_x">x</code></td>
<td>
<p>an object of class <code>matrix</code> or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="as.varietal_+3A_snames">snames</code></td>
<td>
<p>either a vector of sample names, an integer marking
the length of the sample name prefix, or <code>NULL</code>.
<code>read.varietal</code> assumes that the row names of the
<code>.csv</code> file consist of character strings marking the
sample names, followed by a number.</p>
</td></tr>
<tr><td><code id="as.varietal_+3A_method">method</code></td>
<td>
<p>either <code>'KS'</code> (for the Kolmogorov-Smirnov
statistic) or <code>'W2'</code> (for the Wasserstein-2 distance).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>varietal</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- system.file("SNSM/Ttn_chem.csv",package="provenance")
ap1 &lt;- read.csv(fn)
ap2 &lt;- as.varietal(x=ap1,snames=3)
</code></pre>

<hr>
<h2 id='botev'>Compute the optimal kernel bandwidth</h2><span id='topic+botev'></span>

<h3>Description</h3>

<p>Uses the diffusion algorithm of Botev (2011)
to calculate the bandwidth for kernel density estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>botev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="botev_+3A_x">x</code></td>
<td>
<p>a vector of ordinal data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar value with the optimal bandwidth
</p>


<h3>Author(s)</h3>

<p>Zdravko Botev
</p>


<h3>References</h3>

<p>Botev, Z. I., J. F. Grotowski, and
D. P. Kroese. &quot;Kernel density estimation via diffusion.&quot; The Annals
of Statistics 38.5 (2010): 2916-2957.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fname &lt;- system.file("Namib/DZ.csv",package="provenance")
bw &lt;- botev(read.distributional(fname)$x$N1)
print(bw)
</code></pre>

<hr>
<h2 id='bray.diss'>Bray-Curtis dissimilarity</h2><span id='topic+bray.diss'></span><span id='topic+bray.diss.default'></span><span id='topic+bray.diss.compositional'></span>

<h3>Description</h3>

<p>Calculates the Bray-Curtis dissimilarity between two samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bray.diss(x, ...)

## Default S3 method:
bray.diss(x, y, ...)

## S3 method for class 'compositional'
bray.diss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bray.diss_+3A_x">x</code></td>
<td>
<p>a vector containing the first compositional sample</p>
</td></tr>
<tr><td><code id="bray.diss_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="bray.diss_+3A_y">y</code></td>
<td>
<p>a vector of <code>length(x)</code> containing the second
compositional sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
print(bray.diss(Namib$HM$x["N1",],Namib$HM$x["N2",]))
</code></pre>

<hr>
<h2 id='CA'>Correspondence Analysis</h2><span id='topic+CA'></span>

<h3>Description</h3>

<p>Performs Correspondence Analysis of point-counting data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CA(x, nf = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CA_+3A_x">x</code></td>
<td>
<p>an object of class <code>counts</code></p>
</td></tr>
<tr><td><code id="CA_+3A_nf">nf</code></td>
<td>
<p>number of correspondence factors (dimensions)</p>
</td></tr>
<tr><td><code id="CA_+3A_...">...</code></td>
<td>
<p>optional arguments to the <code>corresp</code> function of the
<code>MASS</code> package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of classes <code>CA</code>, which is synonymous to the
MASS package's <code>correspondence</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
plot(CA(Namib$PT))
</code></pre>

<hr>
<h2 id='central.counts'>Calculate central compositions</h2><span id='topic+central.counts'></span>

<h3>Description</h3>

<p>Computes the logratio mean composition of a continuous mixture of
point-counting data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'counts'
central(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="central.counts_+3A_x">x</code></td>
<td>
<p>an object of class <code>counts</code></p>
</td></tr>
<tr><td><code id="central.counts_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The central composition assumes that the observed
point-counting distribution is the combination of two sources
of scatter: counting uncertainty and true geological
dispersion.
</p>


<h3>Value</h3>

<p>an <code>[5 x n]</code> matrix with <code>n</code> being the number
of categories and the rows containing:
</p>

<dl>
<dt>theta</dt><dd><p> the &lsquo;central&rsquo; composition. </p>
</dd>
<dt>err</dt><dd><p> the standard error for the central composition. </p>
</dd>
<dt>sigma</dt><dd><p> the overdispersion parameter, i.e. the coefficient of
variation of the underlying logistic normal
distribution. <code>central</code> computes a continuous
mixture model for each component (column)
separately. Covariance terms are not reported.</p>
</dd>
<dt>LL</dt><dd><p> the lower limit of a &lsquo;1 sigma&rsquo; region for <code>theta</code>. </p>
</dd>
<dt>UL</dt><dd><p> the upper limit of a &lsquo;1 sigma&rsquo; region for <code>theta</code>. </p>
</dd>
<dt>mswd</dt><dd><p> the mean square of the weighted deviates, a.k.a.
reduced chi-square statistic.</p>
</dd>
<dt>p.value</dt><dd><p> the p-value for age homogeneity </p>
</dd>
</dl>


<hr>
<h2 id='CLR'>Centred logratio transformation</h2><span id='topic+CLR'></span><span id='topic+CLR.default'></span><span id='topic+CLR.compositional'></span>

<h3>Description</h3>

<p>Calculates Aitchison's centered logratio transformation for a
dataset of class <code>compositional</code> or a compositional data
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CLR(x, ...)

## Default S3 method:
CLR(x, inverse = FALSE, ...)

## S3 method for class 'compositional'
CLR(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CLR_+3A_x">x</code></td>
<td>
<p>an object of class <code>compositional</code> OR a matrix of
numerical values</p>
</td></tr>
<tr><td><code id="CLR_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="CLR_+3A_inverse">inverse</code></td>
<td>
<p>perform the inverse inverse logratio transformation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of CLR coordinates OR an object of class
<code>compositional</code> (if <code>inverse=TRUE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following code shows that applying provenance's PCA function
# to compositional data is equivalent to applying R's built-in
# princomp function to the CLR transformed data.
data(Namib)
plot(PCA(Namib$Major))
dev.new()
clrdat &lt;- CLR(Namib$Major)
biplot(princomp(clrdat))
</code></pre>

<hr>
<h2 id='combine'>Combine samples of distributional data</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>Lumps all single grain analyses of several samples together under a
new name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_x">x</code></td>
<td>
<p>a distributional dataset</p>
</td></tr>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>a series of new labels assigned to strings or vectors of
strings denoting the samples that need amalgamating</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distributional data object with fewer samples than
<code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
combined &lt;- combine(Namib$DZ,
                    east=c('N3','N4','N5','N6','N7','N8','N9','N10'),
                    west=c('N1','N2','N11','N12','T8','T13'))
summaryplot(KDEs(combined))
</code></pre>

<hr>
<h2 id='densities'>A list of rock and mineral densities</h2><span id='topic+densities'></span>

<h3>Description</h3>

<p>List of rock and mineral densities using the following
abbreviations: Q (quartz), KF (K-feldspar), P (plagioclase), F
(feldspar), Lvf (felsic/porfiritic volcanic rock fragments), Lvm
(microlithic / porfiritic / trachitic volcanic rock fragments), Lcc
(calcite), Lcd (dolomite), Lp (marl), Lch (chert), Lms
(argillaceous / micaceous rock fragments), Lmv (metavolcanics), Lmf
(metasediments), Lmb (metabasites), Lv (volcanic rock fragments),
Lc (carbonates), Ls (sedimentary rock fragments), Lm (metamorphic
rock fragments), Lu (serpentinite), mica, opaques, FeOx
(Fe-oxides), turbids, zr (zircon), tm (tourmaline), rt (rutile),
TiOx (Ti-oxides), sph (titanite), ap (apatite), mon (monazite), oth
(other minerals), ep (epidote), othLgM (prehnite + pumpellyite +
lawsonite + carpholite), gt (garnet), ctd (chloritoid), st
(staurolite), and (andalusite), ky (kyanite), sil (sillimanite),
amp (amphibole), px (pyroxene), cpx (clinopyroxene), opx
(orthopyroxene), ol (olivine), spinel and othHM (other heavy
minerals).
</p>


<h3>Author(s)</h3>

<p>Alberto Resentini and Pieter Vermeesch
</p>


<h3>References</h3>

<p>Resentini, A, Malusa M G and Garzanti, E. &quot;MinSORTING:
An Excel worksheet for modelling mineral grain-size distribution in
sediments, with application to detrital geochronology and
provenance studies.&quot; Computers &amp; Geosciences 59 (2013): 90-97.
</p>
<p>Garzanti, E, Ando, S and Vezzoli, G. &quot;Settling
equivalence of detrital minerals and grain-size dependence of
sediment composition.&quot; Earth and Planetary Science Letters 273.1
(2008): 138-151.
</p>


<h3>See Also</h3>

<p>restore, minsorting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N8 &lt;- subset(Namib$HM,select="N8")
distribution &lt;- minsorting(N8,densities,phi=2,sigmaphi=1,medium="air",by=0.05)
plot(distribution)
</code></pre>

<hr>
<h2 id='diss.distributional'>Calculate the dissimilarity matrix between two datasets of class
<code>distributional</code>, <code>compositional</code>, <code>counts</code> or
<code>varietal</code></h2><span id='topic+diss.distributional'></span><span id='topic+diss.compositional'></span><span id='topic+diss.counts'></span><span id='topic+diss.varietal'></span>

<h3>Description</h3>

<p>Calculate the dissimilarity matrix between two datasets of class
<code>distributional</code> or <code>compositional</code> using the Kolmogorov-Smirnov,
Sircombe-Hazelton, Aitchison or Bray-Curtis distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'distributional'
diss(x, method = NULL, log = FALSE, verbose = FALSE, ...)

## S3 method for class 'compositional'
diss(x, method = NULL, ...)

## S3 method for class 'counts'
diss(x, method = NULL, ...)

## S3 method for class 'varietal'
diss(x, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diss.distributional_+3A_x">x</code></td>
<td>
<p>an object of class <code>distributional</code>,
<code>compositional</code> or <code>counts</code></p>
</td></tr>
<tr><td><code id="diss.distributional_+3A_method">method</code></td>
<td>
<p>if <code>x</code> has class <code>distributional</code>: either
<code>"KS"</code>, <code>"Wasserstein"</code>, <code>"Kuiper"</code> or
<code>"SH"</code>;
</p>
<p>if <code>x</code> has class <code>compositional</code>: either
<code>"aitchison"</code> or <code>"bray"</code>;
</p>
<p>if <code>x</code> has class <code>counts</code>: either <code>"chisq"</code> or
<code>"bray"</code>;
</p>
<p>if <code>x</code> has class <code>varietal</code>: either <code>"KS"</code>,
<code>"W2_1D"</code> or <code>"W2"</code>.</p>
</td></tr>
<tr><td><code id="diss.distributional_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code>, subjects the distributional
data to a logarithmic transformation before calculating the
Wasserstein distance.</p>
</td></tr>
<tr><td><code id="diss.distributional_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, gives progress updates
during the construction of the dissimilarity matrix.</p>
</td></tr>
<tr><td><code id="diss.distributional_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"KS"</code> stands for the Kolmogorov-Smirnov statistic,
<code>"W2_1D"</code> for the 1-dimensional Wasserstein-2 distance,
<code>"Kuiper"</code> for the Kuiper statistic, <code>"SH"</code> for the
Sircombe-Hazelton distance, <code>"aitchison"</code> for the
Aitchison logratio distance, <code>"bray"</code> for the Bray-Curtis
distance, <code>"chisq"</code> for the Chi-square distance, and &quot;W2&quot;
for the 2-dimensional Wasserstein-2 distance.
</p>


<h3>Value</h3>

<p>an object of class <code>diss</code>
</p>


<h3>See Also</h3>

<p>KS.diss bray.diss SH.diss Wasserstein.diss Kuiper.diss
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
print(round(100*diss(Namib$DZ)))
</code></pre>

<hr>
<h2 id='endmembers'>Petrographic end-member compositions</h2><span id='topic+endmembers'></span>

<h3>Description</h3>

<p>A compositional dataset comprising the mineralogical compositions 
of the following end-members: <code>undissected_magmatic_arc</code>, 
<code>dissected_magmatic_arc</code>, <code>ophiolite</code>, 
<code>recycled_clastic</code>, 
<code>undissected_continental_block</code>, 
<code>transitional_continental_block</code>, 
<code>dissected_continental_block</code>, 
<code>subcreted_axial_belt</code> and 
<code>subducted_axial_belt</code>
</p>


<h3>Author(s)</h3>

<p>Alberto Resentini and Pieter Vermeesch
</p>


<h3>References</h3>

<p>Resentini, A, Malusa M G and Garzanti, E. &quot;MinSORTING:
An Excel worksheet for modelling mineral grain-size distribution in
sediments, with application to detrital geochronology and
provenance studies.&quot; Computers &amp; Geosciences 59 (2013): 90-97.
</p>
<p>Garzanti, E, Ando, S and Vezzoli, G. &quot;Settling
equivalence of detrital minerals and grain-size dependence of
sediment composition.&quot; Earth and Planetary Science Letters 273.1
(2008): 138-151.
</p>


<h3>See Also</h3>

<p>minsorting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ophiolite &lt;- subset(endmembers,select="ophiolite")
plot(minsorting(ophiolite,densities,by=0.05))
</code></pre>

<hr>
<h2 id='get.f'>Calculate the largest fraction that is likely to be missed</h2><span id='topic+get.f'></span>

<h3>Description</h3>

<p>For a given sample size, returns the largest fraction which has
been sampled with (1-p) x 100 % likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.f(n, p = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.f_+3A_n">n</code></td>
<td>
<p>the number of grains in the detrital sample</p>
</td></tr>
<tr><td><code id="get.f_+3A_p">p</code></td>
<td>
<p>the required level of confidence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the largest fraction that is sampled with at least (1-p) x
100% certainty
</p>


<h3>References</h3>

<p>Vermeesch, Pieter. &quot;How many grains are needed for a provenance study?&quot;
Earth and Planetary Science Letters 224.3 (2004): 441-451.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(get.f(60))
print(get.f(117))
</code></pre>

<hr>
<h2 id='get.n'>Calculate the number of grains required to achieve a desired level of sampling resolution</h2><span id='topic+get.n'></span>

<h3>Description</h3>

<p>Returns the number of grains that need to be analysed to decrease
the likelihood of missing any fraction greater than a given size
below a given level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.n(p = 0.05, f = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.n_+3A_p">p</code></td>
<td>
<p>the probability that all n grains in the sample have missed
at least one fraction of size <code>f</code></p>
</td></tr>
<tr><td><code id="get.n_+3A_f">f</code></td>
<td>
<p>the size of the smallest resolvable fraction (0&lt;f&lt;1)</p>
</td></tr>
<tr><td><code id="get.n_+3A_n">n</code></td>
<td>
<p>the number of grains in the sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of grains needed to reduce the chance of missing
at least one fraction f of the total population to less than <code>p</code>
</p>


<h3>References</h3>

<p>Vermeesch, Pieter. &quot;How many grains are needed for a
provenance study?.&quot; Earth and Planetary Science Letters 224.3
(2004): 441-451.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># number of grains required to be 99% that no fraction greater than 5% was missed:
print(get.n(0.01))
# number of grains required to be 90% that no fraction greater than 10% was missed:
print(get.n(p=0.1,f=0.1))
</code></pre>

<hr>
<h2 id='get.p'>Calculate the probability of missing a given population fraction</h2><span id='topic+get.p'></span>

<h3>Description</h3>

<p>For a given sample size, returns the likelihood of missing any
fraction greater than a given size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.p(n, f = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.p_+3A_n">n</code></td>
<td>
<p>the number of grains in the detrital sample</p>
</td></tr>
<tr><td><code id="get.p_+3A_f">f</code></td>
<td>
<p>the size of the smallest resolvable fraction
(0&lt;<code>f</code>&lt;1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the probability that all <code>n</code> grains in the sample have
missed at least one fraction of size <code>f</code>
</p>


<h3>References</h3>

<p>Vermeesch,
Pieter. &quot;How many grains are needed for a provenance study?.&quot;
Earth and Planetary Science Letters 224.3 (2004): 441-451.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(get.p(60))
print(get.p(117))
</code></pre>

<hr>
<h2 id='GPA'>Generalised Procrustes Analysis of configurations</h2><span id='topic+GPA'></span>

<h3>Description</h3>

<p>Given a number of (2D) configurations, this function uses a
combination of transformations (reflections, rotations,
translations and scaling) to find a &lsquo;consensus&rsquo; configuration which
best matches all the component configurations in a least-squares
sense.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPA(X, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPA_+3A_x">X</code></td>
<td>
<p>a list of dissimilarity matrices</p>
</td></tr>
<tr><td><code id="GPA_+3A_scale">scale</code></td>
<td>
<p>boolean flag indicating if the transformation should
include the scaling operation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a two column vector with the coordinates of the group
configuration
</p>


<h3>See Also</h3>

<p>procrustes
</p>

<hr>
<h2 id='indscal'>Individual Differences Scaling of provenance data</h2><span id='topic+indscal'></span>

<h3>Description</h3>

<p>Performs 3-way Multidimensional Scaling analysis using Carroll and
Chang (1970)'s INdividual Differences SCALing method as implemented
using De Leeuw and Mair (2011)'s stress majorization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indscal(..., type = "ordinal", itmax = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indscal_+3A_...">...</code></td>
<td>
<p>a sequence of datasets of class <code>distributional</code>,
<code>compositional</code>, <code>counts</code> or <code>varietal</code>, OR a
single object of class <code>varietal</code>.</p>
</td></tr>
<tr><td><code id="indscal_+3A_type">type</code></td>
<td>
<p>is either &quot;ratio&quot; or &quot;ordinal&quot;</p>
</td></tr>
<tr><td><code id="indscal_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>INDSCAL</code>, i.e. a list containing
the following items:
</p>
<p><code>delta</code>: Observed dissimilarities
</p>
<p><code>obsdiss</code>: List of observed dissimilarities, normalized
</p>
<p><code>confdiss</code>: List of configuration dissimilarities
</p>
<p><code>conf</code>: List of matrices of final configurations
</p>
<p><code>gspace</code>: Joint configurations aka group stimulus space
</p>
<p><code>cweights</code>: Configuration weights
</p>
<p><code>stress</code>: Stress-1 value
</p>
<p><code>spp</code>: Stress per point
</p>
<p><code>sps</code>: Stress per subject (matrix)
</p>
<p><code>ndim</code>: Number of dimensions
</p>
<p><code>model</code>: Type of smacof model
</p>
<p><code>niter</code>: Number of iterations
</p>
<p><code>nobj</code>: Number of objects
</p>


<h3>Author(s)</h3>

<p>Jan de Leeuw and Patrick Mair
</p>


<h3>References</h3>

<p>de Leeuw, J., &amp; Mair, P. (2009). Multidimensional scaling using
majorization: The R package smacof. Journal of Statistical
Software, 31(3), 1-30, &lt;https://www.jstatsoft.org/v31/i03/&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
attach(Namib)
plot(indscal(DZ,HM,PT,Major,Trace))

## End(Not run)
</code></pre>

<hr>
<h2 id='KDE'>Create a kernel density estimate</h2><span id='topic+KDE'></span>

<h3>Description</h3>

<p>Turns a vector of numbers into an object of class <code>KDE</code> using
a combination of the Botev (2010) bandwidth selector and the
Abramson (1982) adaptive kernel bandwidth modifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KDE(x, from = NA, to = NA, bw = NA, adaptive = TRUE, log = FALSE, n = 512, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KDE_+3A_x">x</code></td>
<td>
<p>a vector of numbers</p>
</td></tr>
<tr><td><code id="KDE_+3A_from">from</code></td>
<td>
<p>minimum age of the time axis. If <code>NULL</code>, this is
set automatically</p>
</td></tr>
<tr><td><code id="KDE_+3A_to">to</code></td>
<td>
<p>maximum age of the time axis. If <code>NULL</code>, this is set
automatically</p>
</td></tr>
<tr><td><code id="KDE_+3A_bw">bw</code></td>
<td>
<p>the bandwidth of the KDE. If NULL, <code>bw</code> will be
calculated automatically using <code>botev()</code></p>
</td></tr>
<tr><td><code id="KDE_+3A_adaptive">adaptive</code></td>
<td>
<p>boolean flag controlling if the adaptive KDE
modifier of Abramson (1982) is used</p>
</td></tr>
<tr><td><code id="KDE_+3A_log">log</code></td>
<td>
<p>transform the ages to a log scale if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="KDE_+3A_n">n</code></td>
<td>
<p>horizontal resolution of the density estimate</p>
</td></tr>
<tr><td><code id="KDE_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to <code>density</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>KDE</code>, i.e. a list containing the
following items:
</p>
<p><code>x</code>: horizontal plot coordinates
</p>
<p><code>y</code>: vertical plot coordinates
</p>
<p><code>bw</code>: the base bandwidth of the density estimate
</p>
<p><code>ages</code>: the data values from the input to the <code>KDE</code> function
</p>


<h3>See Also</h3>

<p>KDEs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
samp &lt;- Namib$DZ$x[['N1']]
dens &lt;- KDE(samp,0,3000,kernel="epanechnikov")
plot(dens)
</code></pre>

<hr>
<h2 id='KDEs'>Generate an object of class <code>KDEs</code></h2><span id='topic+KDEs'></span>

<h3>Description</h3>

<p>Convert a dataset of class <code>distributional</code> into an object of
class <code>KDEs</code> for further processing by the <code>summaryplot</code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KDEs(
  x,
  from = NA,
  to = NA,
  bw = NA,
  samebandwidth = TRUE,
  adaptive = TRUE,
  normalise = FALSE,
  log = FALSE,
  n = 512,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KDEs_+3A_x">x</code></td>
<td>
<p>an object of class <code>distributional</code></p>
</td></tr>
<tr><td><code id="KDEs_+3A_from">from</code></td>
<td>
<p>minimum limit of the x-axis.</p>
</td></tr>
<tr><td><code id="KDEs_+3A_to">to</code></td>
<td>
<p>maximum limit of the x-axis.</p>
</td></tr>
<tr><td><code id="KDEs_+3A_bw">bw</code></td>
<td>
<p>the bandwidth of the kernel density estimates. If
<code>bw = NA</code>, the bandwidth will be set automatically using
<code>botev()</code></p>
</td></tr>
<tr><td><code id="KDEs_+3A_samebandwidth">samebandwidth</code></td>
<td>
<p>boolean flag indicating whether the same
bandwidth should be used for all samples. If
<code>samebandwidth = TRUE</code> and <code>bw = NULL</code>, then the
function will use the median bandwidth of all the samples.</p>
</td></tr>
<tr><td><code id="KDEs_+3A_adaptive">adaptive</code></td>
<td>
<p>boolean flag switching on the adaptive bandwidth
modifier of Abramson (1982)</p>
</td></tr>
<tr><td><code id="KDEs_+3A_normalise">normalise</code></td>
<td>
<p>boolean flag indicating whether or not the KDEs
should all integrate to the same value.</p>
</td></tr>
<tr><td><code id="KDEs_+3A_log">log</code></td>
<td>
<p>boolean flag indicating whether the data should by
plotted on a logarithmic scale.</p>
</td></tr>
<tr><td><code id="KDEs_+3A_n">n</code></td>
<td>
<p>horizontal resolution of the density estimates</p>
</td></tr>
<tr><td><code id="KDEs_+3A_...">...</code></td>
<td>
<p>optional parameters to be passed on to <code>density</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>KDEs</code>, i.e. a list containing the
following items:
</p>
<p><code>kdes</code>: a named list with objects of class <code>KDE</code>
</p>
<p><code>from</code>: the beginning of the common time scale
</p>
<p><code>to</code>: the end of the common time scale
</p>
<p><code>themax</code>: the maximum probability density of all the KDEs
</p>
<p><code>pch</code>: the plot symbol to be used by <code>plot.KDEs</code>
</p>
<p><code>xlabel</code>: the x-axis label to be used by <code>plot.KDEs</code>
</p>


<h3>See Also</h3>

<p>KDE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
KDEs &lt;- KDEs(Namib$DZ,0,3000,pch=NA)
summaryplot(KDEs,ncol=3)
</code></pre>

<hr>
<h2 id='KS.diss'>Kolmogorov-Smirnov dissimilarity</h2><span id='topic+KS.diss'></span><span id='topic+KS.diss.default'></span><span id='topic+KS.diss.distributional'></span>

<h3>Description</h3>

<p>Returns the Kolmogorov-Smirnov dissimilarity between two samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KS.diss(x, ...)

## Default S3 method:
KS.diss(x, y, ...)

## S3 method for class 'distributional'
KS.diss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KS.diss_+3A_x">x</code></td>
<td>
<p>the first sample as a vector</p>
</td></tr>
<tr><td><code id="KS.diss_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="KS.diss_+3A_y">y</code></td>
<td>
<p>the second sample as a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar value representing the maximum vertical distance
between the two cumulative distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
print(KS.diss(Namib$DZ$x[['N1']],Namib$DZ$x[['T8']]))
</code></pre>

<hr>
<h2 id='Kuiper.diss'>Kuiper dissimilarity</h2><span id='topic+Kuiper.diss'></span><span id='topic+Kuiper.diss.default'></span><span id='topic+Kuiper.diss.distributional'></span>

<h3>Description</h3>

<p>Returns the Kuiper dissimilarity between two samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kuiper.diss(x, ...)

## Default S3 method:
Kuiper.diss(x, y, ...)

## S3 method for class 'distributional'
Kuiper.diss(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kuiper.diss_+3A_x">x</code></td>
<td>
<p>the first sample as a vector</p>
</td></tr>
<tr><td><code id="Kuiper.diss_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="Kuiper.diss_+3A_y">y</code></td>
<td>
<p>the second sample as a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar value representing the sum of the maximum vertical
distances above and below the cumulative distributions of x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
print(Kuiper.diss(Namib$DZ$x[['N1']],Namib$DZ$x[['T8']]))
</code></pre>

<hr>
<h2 id='lines.ternary'>Ternary line plotting</h2><span id='topic+lines.ternary'></span>

<h3>Description</h3>

<p>Add lines to an existing ternary diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ternary'
lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.ternary_+3A_x">x</code></td>
<td>
<p>an object of class <code>ternary</code>, or a three-column data
frame or matrix</p>
</td></tr>
<tr><td><code id="lines.ternary_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>lines</code> function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tern &lt;- ternary(Namib$PT,'Q',c('KF','P'),c('Lm','Lv','Ls'))
plot(tern,pch=21,bg='red',labels=NULL)
middle &lt;- matrix(c(0.01,0.49,0.01,0.49,0.98,0.02),2,3)
lines(ternary(middle))
</code></pre>

<hr>
<h2 id='MDS'>Multidimensional Scaling</h2><span id='topic+MDS'></span><span id='topic+MDS.default'></span><span id='topic+MDS.compositional'></span><span id='topic+MDS.counts'></span><span id='topic+MDS.distributional'></span><span id='topic+MDS.varietal'></span>

<h3>Description</h3>

<p>Performs classical or nonmetric Multidimensional Scaling analysis
of provenance data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDS(x, ...)

## Default S3 method:
MDS(x, classical = FALSE, k = 2, ...)

## S3 method for class 'compositional'
MDS(x, classical = FALSE, k = 2, ...)

## S3 method for class 'counts'
MDS(x, classical = FALSE, k = 2, ...)

## S3 method for class 'distributional'
MDS(x, classical = FALSE, k = 2, nb = 0, ...)

## S3 method for class 'varietal'
MDS(x, classical = FALSE, k = 2, nb = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDS_+3A_x">x</code></td>
<td>
<p>an object of class <code>distributional</code>,
<code>compositional</code>, <code>counts</code>, <code>varietal</code> or
<code>diss</code></p>
</td></tr>
<tr><td><code id="MDS_+3A_...">...</code></td>
<td>
<p>optional arguments
</p>
<p>If <code>x</code> has class <code>distributional</code>, <code>...</code> is passed
on to <code>diss.distributional</code>.
</p>
<p>If <code>x</code> has class <code>compositional</code>, <code>...</code> is passed on
to <code>diss.compositional</code>.
</p>
<p>If <code>x</code> has class <code>counts</code>, <code>...</code> is passed on to
<code>diss.counts</code>.
</p>
<p>If <code>x</code> has class <code>varietal</code>, <code>...</code> is passed on to
<code>diss.varietal</code>.
</p>
<p>Otherwise, <code>...</code> is passed on to <code>cmdscale</code> (if
<code>classical=TRUE</code>), to <code>isoMDS</code> (if
<code>classical=FALSE</code>).</p>
</td></tr>
<tr><td><code id="MDS_+3A_classical">classical</code></td>
<td>
<p>boolean flag indicating whether classical
(<code>TRUE</code>) or nonmetric (<code>FALSE</code>) MDS should be used</p>
</td></tr>
<tr><td><code id="MDS_+3A_k">k</code></td>
<td>
<p>the desired dimensionality of the solution</p>
</td></tr>
<tr><td><code id="MDS_+3A_nb">nb</code></td>
<td>
<p>number of bootstrap resamples. If <code>nb&gt;0</code>, then
<code>plot.MDS(...)</code> will visualise the sampling uncertainty as
polygons (inspired by Nordsvan et al. 2020). The bigger
<code>nb</code>, the slower the calculations. <code>nb=10</code> seems a
good compromise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>MDS</code>, i.e. a list containing the
following items:
</p>
<p><code>points</code>: a two column vector of the fitted configuration
</p>
<p><code>classical</code>: a boolean flag indicating whether the MDS
configuration was obtained by classical (<code>TRUE</code>) or nonmetric
(<code>FALSE</code>) MDS.
</p>
<p><code>diss</code>: the dissimilarity matrix used for the MDS analysis
</p>
<p><code>stress</code>: (only if <code>classical=TRUE</code>) the final stress
achieved (in percent)
</p>


<h3>References</h3>

<p>Nordsvan, A.R., Kirscher, U., Kirkland, C.L., Barham, M. and
Brennan, D.T., 2020. Resampling (detrital) zircon age distributions
for accurate multidimensional scaling solutions. Earth-Science
Reviews, p.103149.
</p>
<p>Vermeesch, P., 2013, Multi-sample comparison of detrital age
distributions. Chemical Geology v.341, 140-146,
doi:10.1016/j.chemgeo.2013.01.010
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
plot(MDS(Namib$Major,classical=TRUE))
</code></pre>

<hr>
<h2 id='minsorting'>Assess settling equivalence of detrital components</h2><span id='topic+minsorting'></span>

<h3>Description</h3>

<p>Models grain size distribution of minerals and rock fragments of
different densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minsorting(
  X,
  dens,
  sname = NULL,
  phi = 2,
  sigmaphi = 1,
  medium = "freshwater",
  from = -2.25,
  to = 5.5,
  by = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minsorting_+3A_x">X</code></td>
<td>
<p>an object of class <code>compositional</code></p>
</td></tr>
<tr><td><code id="minsorting_+3A_dens">dens</code></td>
<td>
<p>a vector of mineral and rock densities</p>
</td></tr>
<tr><td><code id="minsorting_+3A_sname">sname</code></td>
<td>
<p>sample name if unspecified, the first sample of the
dataset will be used</p>
</td></tr>
<tr><td><code id="minsorting_+3A_phi">phi</code></td>
<td>
<p>the mean grain size of the sample in Krumbein's phi
units</p>
</td></tr>
<tr><td><code id="minsorting_+3A_sigmaphi">sigmaphi</code></td>
<td>
<p>the standard deviation of the grain size
distirbution, in phi units</p>
</td></tr>
<tr><td><code id="minsorting_+3A_medium">medium</code></td>
<td>
<p>the transport medium, one of either &quot;air&quot;,
&quot;freshwater&quot; or &quot;seawater&quot;</p>
</td></tr>
<tr><td><code id="minsorting_+3A_from">from</code></td>
<td>
<p>the minimum grain size to be evaluated, in phi units</p>
</td></tr>
<tr><td><code id="minsorting_+3A_to">to</code></td>
<td>
<p>the maximum grain size to be evaluated, in phi units</p>
</td></tr>
<tr><td><code id="minsorting_+3A_by">by</code></td>
<td>
<p>the grain size interval of the output table, in phi units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>minsorting</code>, i.e. a list with two
tables:
</p>
<p>mfract: the grain size distribution of each mineral (sum of the columns = 1)
</p>
<p>mcomp: the composition of each grain size fraction (sum of the rows = 1)
</p>


<h3>Author(s)</h3>

<p>Alberto Resentini and Pieter Vermeesch
</p>


<h3>References</h3>

<p>Resentini, A, Malusa, M G and Garzanti, E. &quot;MinSORTING:
An Excel worksheet for modelling mineral grain-size distribution in
sediments, with application to detrital geochronology and
provenance studies.&quot; Computers &amp; Geosciences 59 (2013): 90-97.
</p>
<p>Garzanti, E, Ando, S and Vezzoli, G. &quot;Settling equivalence of
detrital minerals and grain-size dependence of sediment
composition.&quot; Earth and Planetary Science Letters 273.1 (2008):
138-151.
</p>


<h3>See Also</h3>

<p>restore
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(endmembers,densities)
distribution &lt;- minsorting(endmembers,densities,sname='ophiolite',phi=2,
                           sigmaphi=1,medium="seawater",by=0.05)
plot(distribution,cumulative=FALSE)
</code></pre>

<hr>
<h2 id='Namib'>An example dataset</h2><span id='topic+Namib'></span>

<h3>Description</h3>

<p>A large dataset of provenance data from Namibia comprised of 14
sand samples from the Namib Sand Sea and 2 samples from the Orange
River.
</p>


<h3>Details</h3>

<p><code>Namib</code> is a list containing the following 6 items:
</p>
<p><code>DZ</code>: a <code>distributional</code> dataset containing the zircon
U-Pb ages for ca. 100 grains from each sample, as well as their
(1-sigma) analytical uncertainties.
</p>
<p><code>PT</code>: a <code>compositional</code> dataset with the bulk petrography
of the samples, i.e. the quartz (&lsquo;Q&rsquo;), K-feldspar (&lsquo;KF&rsquo;),
plagioclase (&lsquo;P&rsquo;), and lithic fragments of metamorphic (&lsquo;Lm&rsquo;),
volcanic (&lsquo;Lv&rsquo;) and sedimentary (&lsquo;Ls&rsquo;) origin.
</p>
<p><code>HM</code>: a <code>compositional</code> dataset containing the heavy
mineral composition of the samples, comprised of zircon (&lsquo;zr&rsquo;),
tourmaline (&lsquo;tm&rsquo;), rutile (&lsquo;rt&rsquo;), Ti-oxides (&lsquo;TiOx&rsquo;), titanite
(&lsquo;sph&rsquo;), apatite (&lsquo;ap&rsquo;), epidote (&lsquo;ep&rsquo;), garnet (&lsquo;gt&rsquo;), staurolite
(&lsquo;st&rsquo;), andalusite (&lsquo;and&rsquo;), kyanite (&lsquo;ky&rsquo;), sillimanite (&lsquo;sil&rsquo;),
amphibole (&lsquo;amp&rsquo;), clinopyroxene (&lsquo;cpx&rsquo;) and orthopyroxene (&lsquo;opx&rsquo;).
</p>
<p><code>PTHM</code>: a <code>compositional</code> dataset combining the variables
contained in <code>PT</code> and <code>HM</code> plus &lsquo;mica&rsquo;, &lsquo;opaques&rsquo;,
'turbids' and 'other' transparent heavy minerals (&lsquo;LgM&rsquo;),
normalised to 100.
</p>
<p><code>Major</code>: a <code>compositional</code> dataset listing the
concentrations (in wt
TiO2, P2O5 and MnO.
</p>
<p><code>Trace</code>: a <code>compositional</code> data listing the concentrations
(in ppm) of Rb, Sr, Ba, Sc, Y, La, Ce, Pr, Nd, Sm, Gd, Dy, Er, Yb, Th,
U, Zr, Hf, V, Nb, Cr, Co, Ni, Cu, Zn, Ga and Pb.
</p>


<h3>Author(s)</h3>

<p>Pieter Vermeesch and Eduardo Garzanti
</p>


<h3>References</h3>

<p>Vermeesch, P. and Garzanti, E., Making geological sense
of 'Big Data' in sedimentary provenance analysis, Chemical Geology
409 (2015) 20-27
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samp &lt;- Namib$DZ$x[['N1']]
dens &lt;- KDE(samp,0,3000)
plot(dens)
</code></pre>

<hr>
<h2 id='PCA'>Principal Component Analysis</h2><span id='topic+PCA'></span>

<h3>Description</h3>

<p>Performs PCA of compositional data using a centred logratio
distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCA(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCA_+3A_x">x</code></td>
<td>
<p>an object of class <code>compositional</code></p>
</td></tr>
<tr><td><code id="PCA_+3A_...">...</code></td>
<td>
<p>optional arguments to R's <code>princomp</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of classes <code>PCA</code>, which is synonymous to the
stats package's <code>prcomp</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
plot(MDS(Namib$Major,classical=TRUE))
dev.new()
plot(PCA(Namib$Major),asp=1)
print("This example demonstrates the equivalence of classical MDS and PCA")
</code></pre>

<hr>
<h2 id='plot.CA'>Point-counting biplot</h2><span id='topic+plot.CA'></span>

<h3>Description</h3>

<p>Plot the results of a correspondence analysis as a biplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CA'
plot(x, labelcol = "black", vectorcol = "red", components = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CA_+3A_x">x</code></td>
<td>
<p>an object of class <code>CA</code></p>
</td></tr>
<tr><td><code id="plot.CA_+3A_labelcol">labelcol</code></td>
<td>
<p>colour of the sample labels (may be a vector).</p>
</td></tr>
<tr><td><code id="plot.CA_+3A_vectorcol">vectorcol</code></td>
<td>
<p>colour of the vector loadings for the variables</p>
</td></tr>
<tr><td><code id="plot.CA_+3A_components">components</code></td>
<td>
<p>two-element vector of components to be plotted</p>
</td></tr>
<tr><td><code id="plot.CA_+3A_...">...</code></td>
<td>
<p>optional arguments of the generic <code>biplot</code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>CA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
plot(CA(Namib$PT))
</code></pre>

<hr>
<h2 id='plot.compositional'>Plot a pie chart</h2><span id='topic+plot.compositional'></span>

<h3>Description</h3>

<p>Plots an object of class <code>compositional</code> as a pie chart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compositional'
plot(x, sname, annotate = TRUE, colmap = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.compositional_+3A_x">x</code></td>
<td>
<p>an object of class <code>compositional</code></p>
</td></tr>
<tr><td><code id="plot.compositional_+3A_sname">sname</code></td>
<td>
<p>the sample name</p>
</td></tr>
<tr><td><code id="plot.compositional_+3A_annotate">annotate</code></td>
<td>
<p>a boolean flag controlling if the pies of the
pie-chart should be labelled</p>
</td></tr>
<tr><td><code id="plot.compositional_+3A_colmap">colmap</code></td>
<td>
<p>an optional string with the name of one of R's
built-in colour palettes (e.g., heat.colors, terrain.colors,
topo.colors, cm.colors), which are to be used for plotting the
data.</p>
</td></tr>
<tr><td><code id="plot.compositional_+3A_...">...</code></td>
<td>
<p>optional parameters to be passed on to the graphics
object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
plot(Namib$Major,'N1',colmap='heat.colors')
</code></pre>

<hr>
<h2 id='plot.distributional'>Plot continuous data as histograms or cumulative age distributions</h2><span id='topic+plot.distributional'></span>

<h3>Description</h3>

<p>Plot one or several samples from a <code>distributional</code> dataset as
a histogram or Cumulative Age Distributions (CAD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'distributional'
plot(
  x,
  snames = NULL,
  annotate = TRUE,
  CAD = FALSE,
  pch = NA,
  verticals = TRUE,
  colmap = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.distributional_+3A_x">x</code></td>
<td>
<p>an object of class <code>distributional</code></p>
</td></tr>
<tr><td><code id="plot.distributional_+3A_snames">snames</code></td>
<td>
<p>a string or a vector of string with the names of the
samples that need plotting if <code>snames</code> is a vector, then
the function will default to a CAD.</p>
</td></tr>
<tr><td><code id="plot.distributional_+3A_annotate">annotate</code></td>
<td>
<p>boolean flag indicating whether the x- and y-axis
should be labelled</p>
</td></tr>
<tr><td><code id="plot.distributional_+3A_cad">CAD</code></td>
<td>
<p>boolean flag indicating whether the data should be
plotted as a cumulative age distribution or a histogram. For
multi-sample plots, the function will override this value with
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.distributional_+3A_pch">pch</code></td>
<td>
<p>an optional symbol to mark the sample points along the
CAD</p>
</td></tr>
<tr><td><code id="plot.distributional_+3A_verticals">verticals</code></td>
<td>
<p>boolean flag indicating if the horizontal lines of
the CAD should be connected by vertical lines</p>
</td></tr>
<tr><td><code id="plot.distributional_+3A_colmap">colmap</code></td>
<td>
<p>an optional string with the name of one of R's
built-in colour palettes (e.g., heat.colors, terrain.colors,
topo.colors, cm.colors), which are to be used for plotting the
data.</p>
</td></tr>
<tr><td><code id="plot.distributional_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>plot</code> function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
plot(Namib$DZ,c('N1','N2'))
</code></pre>

<hr>
<h2 id='plot.GPA'>Plot a Procrustes configuration</h2><span id='topic+plot.GPA'></span>

<h3>Description</h3>

<p>Plots the group configuration of a Generalised Procrustes Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GPA'
plot(x, pch = NA, pos = NULL, col = "black", bg = "white", cex = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.GPA_+3A_x">x</code></td>
<td>
<p>an object of class <code>GPA</code></p>
</td></tr>
<tr><td><code id="plot.GPA_+3A_pch">pch</code></td>
<td>
<p>plot symbol</p>
</td></tr>
<tr><td><code id="plot.GPA_+3A_pos">pos</code></td>
<td>
<p>position of the sample labels relative to the plot
symbols if pch != NA</p>
</td></tr>
<tr><td><code id="plot.GPA_+3A_col">col</code></td>
<td>
<p>plot colour (may be a vector)</p>
</td></tr>
<tr><td><code id="plot.GPA_+3A_bg">bg</code></td>
<td>
<p>background colour (may be a vector)</p>
</td></tr>
<tr><td><code id="plot.GPA_+3A_cex">cex</code></td>
<td>
<p>relative size of plot symbols</p>
</td></tr>
<tr><td><code id="plot.GPA_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>plot</code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>procrustes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
GPA &lt;- procrustes(Namib$DZ,Namib$HM)
coast &lt;- c('N1','N2','N3','N10','N11','N12','T8','T13')
snames &lt;- names(Namib$DZ)
bgcol &lt;- rep('yellow',length(snames))
bgcol[which(snames %in% coast)] &lt;- 'red'
plot(GPA,pch=21,bg=bgcol)
</code></pre>

<hr>
<h2 id='plot.INDSCAL'>Plot an INDSCAL group configuration and source weights</h2><span id='topic+plot.INDSCAL'></span>

<h3>Description</h3>

<p>Given an object of class <code>INDSCAL</code>, generates two plots: the
group configuration and the subject weights. Together, these
describe a 3-way MDS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'INDSCAL'
plot(
  x,
  asp = 1,
  pch = NA,
  pos = NULL,
  col = "black",
  bg = "white",
  cex = 1,
  xlab = "X",
  ylab = "Y",
  xaxt = "n",
  yaxt = "n",
  option = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.INDSCAL_+3A_x">x</code></td>
<td>
<p>an object of class <code>INDSCAL</code></p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_asp">asp</code></td>
<td>
<p>the aspect ratio of the plot</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_pch">pch</code></td>
<td>
<p>plot symbol (may be a vector)</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_pos">pos</code></td>
<td>
<p>position of the sample labels relative to the plot
symbols if pch != NA</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_col">col</code></td>
<td>
<p>plot colour (may be a vector)</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_bg">bg</code></td>
<td>
<p>background colour (may be a vector)</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_cex">cex</code></td>
<td>
<p>relative size of plot symbols</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_xlab">xlab</code></td>
<td>
<p>a string with the label of the x axis</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_ylab">ylab</code></td>
<td>
<p>a string with the label of the y axis</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_xaxt">xaxt</code></td>
<td>
<p>if = 's', adds ticks to the x axis</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_yaxt">yaxt</code></td>
<td>
<p>if = 's', adds ticks to the y axis</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_option">option</code></td>
<td>
<p>either:
</p>
<p><code>0</code>: only plot the group configuration, do not show the source
weights
</p>
<p><code>1</code>: only show the source weights, do not plot the group
configuration
</p>
<p><code>2</code>: show both the group configuration and source weights in
separate windows</p>
</td></tr>
<tr><td><code id="plot.INDSCAL_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic plot function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>indscal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
coast &lt;- c('N1','N2','N3','N10','N11','N12','T8','T13')
snames &lt;- names(Namib$DZ)
pch &lt;- rep(21,length(snames))
pch[which(snames %in% coast)] &lt;- 22
plot(indscal(Namib$DZ,Namib$HM),pch=pch)
</code></pre>

<hr>
<h2 id='plot.KDE'>Plot a kernel density estimate</h2><span id='topic+plot.KDE'></span>

<h3>Description</h3>

<p>Plots an object of class <code>KDE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KDE'
plot(x, pch = "|", xlab = "age [Ma]", ylab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.KDE_+3A_x">x</code></td>
<td>
<p>an object of class <code>KDE</code></p>
</td></tr>
<tr><td><code id="plot.KDE_+3A_pch">pch</code></td>
<td>
<p>the symbol used to show the samples. May be a vector.
Set <code>pch = NA</code> to turn them off.</p>
</td></tr>
<tr><td><code id="plot.KDE_+3A_xlab">xlab</code></td>
<td>
<p>the label of the x-axis</p>
</td></tr>
<tr><td><code id="plot.KDE_+3A_ylab">ylab</code></td>
<td>
<p>the label of the y-axis</p>
</td></tr>
<tr><td><code id="plot.KDE_+3A_...">...</code></td>
<td>
<p>optional parameters to be passed on to the graphics
object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>KDE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
samp &lt;- Namib$DZ$x[['N1']]
dens &lt;- KDE(samp,from=0,to=3000)
plot(dens)
</code></pre>

<hr>
<h2 id='plot.KDEs'>Plot one or more kernel density estimates</h2><span id='topic+plot.KDEs'></span>

<h3>Description</h3>

<p>Plots an object of class <code>KDEs</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KDEs'
plot(x, sname = NA, annotate = TRUE, pch = "|", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.KDEs_+3A_x">x</code></td>
<td>
<p>an object of class <code>KDEs</code></p>
</td></tr>
<tr><td><code id="plot.KDEs_+3A_sname">sname</code></td>
<td>
<p>optional sample name. If <code>sname=NA</code>, all samples
are shown on a summary plot</p>
</td></tr>
<tr><td><code id="plot.KDEs_+3A_annotate">annotate</code></td>
<td>
<p>add a time axis?</p>
</td></tr>
<tr><td><code id="plot.KDEs_+3A_pch">pch</code></td>
<td>
<p>symbol to be used to mark the sample points along the
x-axis. Change to <code>NA</code> to omit.</p>
</td></tr>
<tr><td><code id="plot.KDEs_+3A_...">...</code></td>
<td>
<p>optional parameters to be passed on to the
<code>summaryplot</code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>KDEs summaryplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
kdes &lt;- KDEs(Namib$DZ)
plot(kdes,ncol=2)
</code></pre>

<hr>
<h2 id='plot.MDS'>Plot an MDS configuration</h2><span id='topic+plot.MDS'></span>

<h3>Description</h3>

<p>Plots the coordinates of a multidimensional scaling analysis as an
X-Y scatter plot or &lsquo;map&rsquo; and, if x$classical = FALSE, a Shepard
plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MDS'
plot(
  x,
  nnlines = FALSE,
  pch = NA,
  pos = NULL,
  cex = 1,
  col = "black",
  bg = "white",
  oma = rep(1, 4),
  mar = rep(2, 4),
  mgp = c(2, 1, 0),
  xpd = NA,
  Shepard = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MDS_+3A_x">x</code></td>
<td>
<p>an object of class <code>MDS</code></p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_nnlines">nnlines</code></td>
<td>
<p>if TRUE, draws nearest neighbour lines</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_pch">pch</code></td>
<td>
<p>plot character (see ?plot for details). May be a vector.</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_pos">pos</code></td>
<td>
<p>position of the sample labels relative to the plot
symbols if <code>pch != NA</code></p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_cex">cex</code></td>
<td>
<p>relative size of plot symbols (see <code>?par</code> for
details)</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_col">col</code></td>
<td>
<p>plot colour (may be a vector)</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_bg">bg</code></td>
<td>
<p>background colour (may be a vector)</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_oma">oma</code></td>
<td>
<p>A vector of the form <code>c(bottom, left, top, right)</code>
giving the size of the outer margins in lines of text.</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form <code>c(bottom, left,
top, right)</code> that gives the number of lines of margin to be
specified on the four sides of the plot.</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_mgp">mgp</code></td>
<td>
<p>The margin line (in <code>mex</code> units) for the axis
title, axis labels and axis line. See <code>?par</code> for further
details.</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_xpd">xpd</code></td>
<td>
<p>A logical value or <code>NA</code>.  See <code>?par</code> for
further details.</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_shepard">Shepard</code></td>
<td>
<p>either:
</p>
<p><code>0</code>: only plot the MDS configuration, do not show the Shepard plot
</p>
<p><code>1</code>: only show the Shepard plot, do not plot the MDS configuration
</p>
<p><code>2</code>: show both the MDS configuration and Shepard plot in separate
windows</p>
</td></tr>
<tr><td><code id="plot.MDS_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>plot</code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>MDS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
mds &lt;- MDS(Namib$DZ)
coast &lt;- c('N1','N2','N3','N10','N11','N12','T8','T13')
snames &lt;- names(Namib$DZ)
bgcol &lt;- rep('yellow',length(snames))
bgcol[which(snames %in% coast)] &lt;- 'red'
plot(mds,pch=21,bg=bgcol)
</code></pre>

<hr>
<h2 id='plot.minsorting'>Plot inferred grain size distributions</h2><span id='topic+plot.minsorting'></span>

<h3>Description</h3>

<p>Plot the grain size distributions of the different minerals under
consideration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'minsorting'
plot(x, cumulative = FALSE, components = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.minsorting_+3A_x">x</code></td>
<td>
<p>an object of class <code>minsorting</code></p>
</td></tr>
<tr><td><code id="plot.minsorting_+3A_cumulative">cumulative</code></td>
<td>
<p>boolean flag indicating whether the grain size
distribution should be plotted as a density or cumulative
probability curve.</p>
</td></tr>
<tr><td><code id="plot.minsorting_+3A_components">components</code></td>
<td>
<p>string or list of strings with the names of a
subcomposition that needs plotting</p>
</td></tr>
<tr><td><code id="plot.minsorting_+3A_...">...</code></td>
<td>
<p>optional parameters to be passed on to graphics::matplot
(see <code>?par</code> for details)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>minsorting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(endmembers,densities)
OPH &lt;- subset(endmembers,select="ophiolite")
distribution &lt;- minsorting(OPH,densities,phi=2,sigmaphi=1,
                           medium="air",by=0.05)
plot(distribution,components=c('F','px','opaques'))
</code></pre>

<hr>
<h2 id='plot.PCA'>Compositional biplot</h2><span id='topic+plot.PCA'></span>

<h3>Description</h3>

<p>Plot the results of a principal components analysis as a biplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCA'
plot(
  x,
  labelcol = "black",
  vectorcol = "red",
  choices = 1L:2L,
  scale = 1,
  pc.biplot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PCA_+3A_x">x</code></td>
<td>
<p>an object of class <code>PCA</code></p>
</td></tr>
<tr><td><code id="plot.PCA_+3A_labelcol">labelcol</code></td>
<td>
<p>colour(s) of the sample labels (may be a vector).</p>
</td></tr>
<tr><td><code id="plot.PCA_+3A_vectorcol">vectorcol</code></td>
<td>
<p>colour of the vector loadings for the variables</p>
</td></tr>
<tr><td><code id="plot.PCA_+3A_choices">choices</code></td>
<td>
<p>see the help pages of the generic <code>biplot</code>
function.</p>
</td></tr>
<tr><td><code id="plot.PCA_+3A_scale">scale</code></td>
<td>
<p>see the help pages of the generic <code>biplot</code>
function.</p>
</td></tr>
<tr><td><code id="plot.PCA_+3A_pc.biplot">pc.biplot</code></td>
<td>
<p>see the help pages of the generic <code>biplot</code>
function.</p>
</td></tr>
<tr><td><code id="plot.PCA_+3A_...">...</code></td>
<td>
<p>optional arguments of the generic <code>biplot</code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>PCA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
plot(PCA(Namib$Major))
</code></pre>

<hr>
<h2 id='plot.ternary'>Plot a ternary diagram</h2><span id='topic+plot.ternary'></span>

<h3>Description</h3>

<p>Plots triplets of compositional data on a ternary diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ternary'
plot(
  x,
  type = "grid",
  pch = NA,
  pos = NULL,
  labels = names(x),
  showpath = FALSE,
  bg = NA,
  col = "cornflowerblue",
  ticks = seq(0, 1, 0.25),
  ticklength = 0.02,
  lty = 2,
  lwd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ternary_+3A_x">x</code></td>
<td>
<p>an object of class <code>ternary</code>, or a three-column data
frame or matrix</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_type">type</code></td>
<td>
<p>adds annotations to the ternary diagram, one of either
<code>empty</code>, <code>grid</code>, <code>QFL.descriptive</code>,
<code>QFL.folk</code> or <code>QFL.dickinson</code></p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_pch">pch</code></td>
<td>
<p>plot character, see <code>?par</code> for details (may be a
vector)</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_pos">pos</code></td>
<td>
<p>position of the sample labels relative to the plot
symbols if pch != NA</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_labels">labels</code></td>
<td>
<p>vector of strings to be added to the plot symbols</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_showpath">showpath</code></td>
<td>
<p>if <code>x</code> has class <code>SRDcorrected</code>, and
<code>showpath</code>==TRUE, the intermediate values of the SRD
correction will be plotted on the ternary diagram as well as
the final composition</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_bg">bg</code></td>
<td>
<p>background colour for the plot symbols (may be a vector)</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_col">col</code></td>
<td>
<p>colour to be used for the background lines (if
applicable)</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_ticks">ticks</code></td>
<td>
<p>vector of tick values between 0 and 1</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_ticklength">ticklength</code></td>
<td>
<p>number between 0 and 1 to mark the length of the
ticks</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_lty">lty</code></td>
<td>
<p>line type for the annotations (see <code>type</code>)</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_lwd">lwd</code></td>
<td>
<p>line thickness for the annotations</p>
</td></tr>
<tr><td><code id="plot.ternary_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>points</code> function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>ternary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
tern &lt;- ternary(Namib$PT,'Q',c('KF','P'),c('Lm','Lv','Ls'))
plot(tern,type='QFL.descriptive',pch=21,bg='red',labels=NULL)
</code></pre>

<hr>
<h2 id='points.ternary'>Ternary point plotting</h2><span id='topic+points.ternary'></span><span id='topic+lines'></span><span id='topic+text'></span>

<h3>Description</h3>

<p>Add points to an existing ternary diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ternary'
points(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points.ternary_+3A_x">x</code></td>
<td>
<p>an object of class <code>ternary</code>, or a three-column data
frame or matrix</p>
</td></tr>
<tr><td><code id="points.ternary_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>points</code> function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tern &lt;- ternary(Namib$PT,'Q',c('KF','P'),c('Lm','Lv','Ls'))
plot(tern,pch=21,bg='red',labels=NULL)
# add the geometric mean composition as a yellow square:
gmean &lt;- ternary(exp(colMeans(log(tern$x))))
points(gmean,pch=22,bg='yellow')
</code></pre>

<hr>
<h2 id='procrustes'>Generalised Procrustes Analysis of provenance data</h2><span id='topic+procrustes'></span>

<h3>Description</h3>

<p>Given a number of input datasets, this function performs an MDS
analysis on each of these and the feeds the resulting
configurations into the <code>GPA()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procrustes(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procrustes_+3A_...">...</code></td>
<td>
<p>a sequence of datasets of classes <code>distributional</code>,
<code>counts</code>, <code>compositional</code> and <code>varietal</code> OR a
single object of class <code>varietal</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>GPA</code>, i.e. a list containing the
following items:
</p>
<p><code>points</code>: a two column vector with the coordinates of the
group configuration
</p>
<p><code>labels</code>: a list with the sample names
</p>


<h3>Author(s)</h3>

<p>Pieter Vermeesch
</p>


<h3>References</h3>

<p>Gower, J.C. (1975). Generalized Procrustes analysis,
Psychometrika, 40, 33-50.
</p>


<h3>See Also</h3>

<p>GPA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
gpa1 &lt;- procrustes(Namib$DZ,Namib$HM)
plot(gpa1)

data(SNSM)
gpa2 &lt;- procrustes(SNSM$ap)
plot(gpa2)
</code></pre>

<hr>
<h2 id='provenance'>Menu-based interface for <code>provenance</code></h2><span id='topic+provenance'></span><span id='topic+_PACKAGE'></span><span id='topic+provenance-package'></span>

<h3>Description</h3>

<p>For those less familiar with the syntax of the <code>R</code> programming
language, the <code>provenance()</code> function provides a user-friendly
way to access the most important functionality in the form of a
menu-based query interface. Further details and examples are
provided on <a href="https://www.ucl.ac.uk/~ucfbpve/provenance/">https://www.ucl.ac.uk/~ucfbpve/provenance/</a>
</p>
<p><code>provenance</code> provides statistical tools to interpret large
amounts of distributional (single grain analyses) and compositional
(mineralogical and bulk chemical) data from the command line, or
using a menu-based user interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>provenance()
</code></pre>


<h3>Details</h3>

<p>A list of documented functions may be viewed by typing
<code>help(package='provenance')</code>.  Detailed instructions are
provided at <a href="https://www.ucl.ac.uk/~ucfbpve/provenance/">https://www.ucl.ac.uk/~ucfbpve/provenance/</a> and in
the Sedimentary Geology paper by Vermeesch, Resentini and Garzanti
(2016).
</p>


<h3>Author(s)</h3>

<p>Pieter Vermeesch
</p>
<p><strong>Maintainer</strong>: Pieter Vermeesch <a href="mailto:p.vermeesch@ucl.ac.uk">p.vermeesch@ucl.ac.uk</a>
</p>


<h3>References</h3>

<p>Vermeesch, P., Resentini, A. and Garzanti, E., an R
package for statistical provenance analysis, Sedimentary
Geology, doi:10.1016/j.sedgeo.2016.01.009.
</p>
<p>Vermeesch, P., Resentini, A. and Garzanti, E., 2016, An
R package for statistical provenance analysis, Sedimentary
Geology, 336, 14-25.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.ucl.ac.uk/~ucfbpve/provenance/">https://www.ucl.ac.uk/~ucfbpve/provenance/</a>
</p>
</li></ul>


<hr>
<h2 id='radialplot.counts'>Visualise point-counting data on a radial plot</h2><span id='topic+radialplot.counts'></span>

<h3>Description</h3>

<p>Implementation of a graphical device developed by Rex Galbraith to
display several estimates of the same quantity that have different
standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'counts'
radialplot(
  x,
  num = 1,
  den = 2,
  from = NA,
  to = NA,
  t0 = NA,
  sigdig = 2,
  show.numbers = FALSE,
  pch = 21,
  levels = NA,
  clabel = "",
  bg = c("white", "red"),
  title = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radialplot.counts_+3A_x">x</code></td>
<td>
<p>an object of class <code>counts</code></p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_num">num</code></td>
<td>
<p>index or name of the numerator variable</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_den">den</code></td>
<td>
<p>index or name of the denominator variable</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_from">from</code></td>
<td>
<p>minimum limit of the radial scale</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_to">to</code></td>
<td>
<p>maximum limit of the radial scale</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_t0">t0</code></td>
<td>
<p>central value</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_sigdig">sigdig</code></td>
<td>
<p>the number of significant digits of the numerical
values reported in the title of the graphical output.</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_show.numbers">show.numbers</code></td>
<td>
<p>boolean flag (<code>TRUE</code> to show sample
numbers)</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_pch">pch</code></td>
<td>
<p>plot character (default is a filled circle)</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_levels">levels</code></td>
<td>
<p>a vector with additional values to be displayed as
different background colours of the plot symbols.</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_clabel">clabel</code></td>
<td>
<p>label of the colour legend</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_bg">bg</code></td>
<td>
<p>a vector of two background colours for the plot symbols.
If <code>levels=NA</code>, then only the first colour is used. If
<code>levels</code> is a vector of numbers, then <code>bg</code> is used to
construct a colour ramp.</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_title">title</code></td>
<td>
<p>add a title to the plot?</p>
</td></tr>
<tr><td><code id="radialplot.counts_+3A_...">...</code></td>
<td>
<p>additional arguments to the generic <code>points</code>
function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The radial plot (Galbraith, 1988, 1990) is a graphical device that
was specifically designed to display heteroscedastic data, and is
constructed as follows.  Consider a set of dates
<code class="reqn">\{t_1,...,t_i,...,t_n\}</code> and uncertainties
<code class="reqn">\{s[t_1],...,s[t_i],...,s[t_n]\}</code>. Define <code class="reqn">z_i = z[t_i]</code>
to be a transformation of <code class="reqn">t_i</code> (e.g., <code class="reqn">z_i = log[t_i]</code>),
and let <code class="reqn">s[z_i]</code> be its propagated analytical uncertainty
(i.e., <code class="reqn">s[z_i] = s[t_i]/t_i</code> in the case of a logarithmic
transformation). Create a scatterplot of <code class="reqn">(x_i,y_i)</code> values,
where <code class="reqn">x_i = 1/s[z_i]</code> and <code class="reqn">y_i = (z_i-z_\circ)/s[z_i]</code>,
where <code class="reqn">z_\circ</code> is some reference value such as the mean. The
slope of a line connecting the origin of this scatterplot with any
of the <code class="reqn">(x_i,y_i)</code>s is proportional to <code class="reqn">z_i</code> and, hence,
the date <code class="reqn">t_i</code>.  These dates can be more easily visualised by
drawing a radial scale at some convenient distance from the origin
and annotating it with labelled ticks at the appropriate
angles. While the angular position of each data point represents
the date, its horizontal distance from the origin is proportional
to the precision. Imprecise measurements plot on the left hand side
of the radial plot, whereas precise age determinations are found
further towards the right. Thus, radial plots allow the observer to
assess both the magnitude and the precision of quantitative data in
one glance.
</p>


<h3>References</h3>

<p>Galbraith, R.F., 1988. Graphical display of estimates
having differing standard errors. Technometrics, 30(3),
pp.271-281.
</p>
<p>Galbraith, R.F., 1990. The radial plot: graphical assessment of
spread in ages. International Journal of Radiation Applications and
Instrumentation. Part D. Nuclear Tracks and Radiation Measurements,
17(3), pp.207-214.
</p>
<p>Galbraith, R.F. and Laslett, G.M., 1993. Statistical models for
mixed fission track ages. Nuclear Tracks and Radiation
Measurements, 21(4), pp.459-470.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
radialplot(Namib$PT,components=c('Q','P'))
</code></pre>

<hr>
<h2 id='read.compositional'>Read a .csv file with compositional data</h2><span id='topic+read.compositional'></span>

<h3>Description</h3>

<p>Reads a data table containing compositional data (e.g. chemical
concentrations)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.compositional(
  fname,
  method = NULL,
  colmap = "rainbow",
  sep = ",",
  dec = ".",
  row.names = 1,
  header = TRUE,
  check.names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.compositional_+3A_fname">fname</code></td>
<td>
<p>a string with the path to the .csv file</p>
</td></tr>
<tr><td><code id="read.compositional_+3A_method">method</code></td>
<td>
<p>either &quot;bray&quot; (for the Bray-Curtis distance) or
&quot;aitchison&quot; (for Aitchison's central logratio distance). If
omitted, the function defaults to 'aitchison', unless there are
zeros present in the data.</p>
</td></tr>
<tr><td><code id="read.compositional_+3A_colmap">colmap</code></td>
<td>
<p>an optional string with the name of one of R's
built-in colour palettes (e.g., heat.colors, terrain.colors,
topo.colors, cm.colors), which are to be used for plotting the
data.</p>
</td></tr>
<tr><td><code id="read.compositional_+3A_sep">sep</code></td>
<td>
<p>the field separator character.  Values on each line of
the file are separated by this character.</p>
</td></tr>
<tr><td><code id="read.compositional_+3A_dec">dec</code></td>
<td>
<p>the character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="read.compositional_+3A_row.names">row.names</code></td>
<td>
<p>a vector of row names.  This can be a vector
giving the actual row names, or a single number giving the
column of the which contains the row names, or character string
the name of the table column containing the row names.</p>
</td></tr>
<tr><td><code id="read.compositional_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains
the names of the variables as its first line.</p>
</td></tr>
<tr><td><code id="read.compositional_+3A_check.names">check.names</code></td>
<td>
<p>logical.  If <code>TRUE</code> then the names of the
variables in the frame are checked to ensure that they are
syntactically variable names.</p>
</td></tr>
<tr><td><code id="read.compositional_+3A_...">...</code></td>
<td>
<p>optional arguments to the built-in <code>read.table</code>
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>compositional</code>, i.e. a list with
the following items:
</p>
<p><code>x</code>: a data frame with the samples as rows and the categories as columns
</p>
<p><code>method</code>: either &quot;aitchison&quot; (for Aitchison's centred logratio
distance) or &quot;bray&quot; (for the Bray-Curtis distance)
</p>
<p><code>colmap</code>: the colour map provided by the input argument
</p>
<p><code>name</code>: the name of the data object, extracted from the file path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fname &lt;- system.file("Namib/Major.csv",package="provenance")
    Major &lt;- read.compositional(fname)
    plot(PCA(Major))
</code></pre>

<hr>
<h2 id='read.counts'>Read a .csv file with point-counting data</h2><span id='topic+read.counts'></span>

<h3>Description</h3>

<p>Reads a data table containing point-counting data
(e.g. petrographic, heavy mineral, palaeontological or
palynological data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.counts(
  fname,
  method = "chisq",
  colmap = "rainbow",
  sep = ",",
  dec = ".",
  row.names = 1,
  header = TRUE,
  check.names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.counts_+3A_fname">fname</code></td>
<td>
<p>a string with the path to the .csv file</p>
</td></tr>
<tr><td><code id="read.counts_+3A_method">method</code></td>
<td>
<p>either &quot;chisq&quot; (for the chi-square distance) or
&quot;bray&quot; (for the Bray-Curtis distance)</p>
</td></tr>
<tr><td><code id="read.counts_+3A_colmap">colmap</code></td>
<td>
<p>an optional string with the name of one of R's
built-in colour palettes (e.g., heat.colors, terrain.colors,
topo.colors, cm.colors), which are to be used for plotting the
data.</p>
</td></tr>
<tr><td><code id="read.counts_+3A_sep">sep</code></td>
<td>
<p>the field separator character.  Values on each line of
the file are separated by this character.</p>
</td></tr>
<tr><td><code id="read.counts_+3A_dec">dec</code></td>
<td>
<p>the character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="read.counts_+3A_row.names">row.names</code></td>
<td>
<p>a vector of row names.  This can be a vector
giving the actual row names, or a single number giving the
column of the which contains the row names, or character string
the name of the table column containing the row names.</p>
</td></tr>
<tr><td><code id="read.counts_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains
the names of the variables as its first line.</p>
</td></tr>
<tr><td><code id="read.counts_+3A_check.names">check.names</code></td>
<td>
<p>logical.  If <code>TRUE</code> then the names of the
variables in the frame are checked to ensure that they are
syntactically variable names.</p>
</td></tr>
<tr><td><code id="read.counts_+3A_...">...</code></td>
<td>
<p>optional arguments to the built-in <code>read.table</code>
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>counts</code>, i.e. a list with the
following items:
</p>
<p><code>x</code>: a data frame with the samples as rows and the categories
as columns
</p>
<p><code>colmap</code>: the colour map provided by the input argument
</p>
<p><code>name</code>: the name of the data object, extracted from the file path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fname &lt;- system.file("Namib/HM.csv",package="provenance")
    Major &lt;- read.counts(fname)
    #plot(PCA(HM))
</code></pre>

<hr>
<h2 id='read.densities'>Read a .csv file with mineral and rock densities</h2><span id='topic+read.densities'></span>

<h3>Description</h3>

<p>Reads a data table containing densities to be used for
hydraulic sorting corrections (minsorting and srd functions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.densities(
  fname,
  sep = ",",
  dec = ".",
  header = TRUE,
  check.names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.densities_+3A_fname">fname</code></td>
<td>
<p>a string with the path to the .csv file</p>
</td></tr>
<tr><td><code id="read.densities_+3A_sep">sep</code></td>
<td>
<p>the field separator character.  Values on each line of
the file are separated by this character.</p>
</td></tr>
<tr><td><code id="read.densities_+3A_dec">dec</code></td>
<td>
<p>the character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="read.densities_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains
the names of the variables as its first line.</p>
</td></tr>
<tr><td><code id="read.densities_+3A_check.names">check.names</code></td>
<td>
<p>logical.  If <code>TRUE</code> then the names of the
variables in the frame are checked to ensure that they are
syntactically variable names.</p>
</td></tr>
<tr><td><code id="read.densities_+3A_...">...</code></td>
<td>
<p>optional arguments to the built-in <code>read.table</code>
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with mineral and rock densities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib,densities)
N8 &lt;- subset(Namib$HM,select="N8")
distribution &lt;- minsorting(N8,densities,phi=2,sigmaphi=1,medium="air",by=0.05)
plot(distribution)
</code></pre>

<hr>
<h2 id='read.distributional'>Read a .csv file with distributional data</h2><span id='topic+read.distributional'></span>

<h3>Description</h3>

<p>Reads a data table containing distributional data, i.e. lists of
continuous data such as detrital zircon U-Pb ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.distributional(
  fname,
  errorfile = NA,
  method = "KS",
  xlab = "age [Ma]",
  colmap = "rainbow",
  sep = ",",
  dec = ".",
  header = TRUE,
  check.names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.distributional_+3A_fname">fname</code></td>
<td>
<p>the path of a .csv file with the input data, arranged
in columns.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_errorfile">errorfile</code></td>
<td>
<p>the (optional) path of a .csv file with the
standard errors of the input data, arranged by column in the
same order as <code>fname</code>. Must be specified if the data are
to be compared with the Sircombe-Hazelton dissimilarity.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_method">method</code></td>
<td>
<p>an optional string specifying the dissimilarity
measure which should be used for comparing this with other
datasets. Should be one of either <code>"KS"</code> (for
Kolmogorov-Smirnov), <code>"Kuiper"</code> (for Kuiper) or
<code>"SH"</code> (for Sircombe and Hazelton). If <code>method =
"SH"</code>, then <code>errorfile</code> should be specified. If
<code>method = "SH"</code> and <code>errorfile</code> is unspecified, then
the program will default back to the Kolmogorov-Smirnov
dissimilarity.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_xlab">xlab</code></td>
<td>
<p>an optional string specifying the nature and units of
the data.  This string is used to label kernel density
estimates.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_colmap">colmap</code></td>
<td>
<p>an optional string with the name of one of R's
built-in colour palettes (e.g., heat.colors, terrain.colors,
topo.colors, cm.colors), which are to be used for plotting the
data.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_sep">sep</code></td>
<td>
<p>the field separator character.  Values on each line of
the file are separated by this character.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_dec">dec</code></td>
<td>
<p>the character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains
the names of the variables as its first line.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_check.names">check.names</code></td>
<td>
<p>logical.  If <code>TRUE</code> then the names of the
variables in the frame are checked to ensure that they are
syntactically variable names.</p>
</td></tr>
<tr><td><code id="read.distributional_+3A_...">...</code></td>
<td>
<p>optional arguments to the built-in <code>read.csv</code>
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>distributional</code>, i.e. a list with
the following items:
</p>
<p><code>x</code>: a named list of vectors containing the numerical data for
each sample
</p>
<p><code>err</code>: an (optional) named list of vectors containing the
standard errors of <code>x</code>
</p>
<p><code>method</code>: either &quot;KS&quot; (for Kolmogorov-Smirnov), &quot;Kuiper&quot; (for
the Kuiper statistic) or &quot;SH&quot; (for Sircombe Hazelton)
</p>
<p><code>breaks</code>: a vector with the locations of the histogram bin edges
</p>
<p><code>xlab</code>: a string containing the label to be given to the
x-axis on all plots
</p>
<p><code>colmap</code>: the colour map provided by the input argument
</p>
<p><code>name</code>: the name of the data object, extracted from the file path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    agefile &lt;- system.file("Namib/DZ.csv",package="provenance")
    errfile &lt;- system.file("Namib/DZerr.csv",package="provenance")
    DZ &lt;- read.distributional(agefile,errfile)
    plot(KDE(DZ$x$N1))
</code></pre>

<hr>
<h2 id='read.varietal'>Read a .csv file with varietal data</h2><span id='topic+read.varietal'></span>

<h3>Description</h3>

<p>Reads a data table containing compositional data (e.g. chemical
concentrations) for multiple grains and multiple samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.varietal(
  fname,
  snames = NULL,
  sep = ",",
  dec = ".",
  method = "KS",
  check.names = FALSE,
  row.names = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.varietal_+3A_fname">fname</code></td>
<td>
<p>file name (character string)</p>
</td></tr>
<tr><td><code id="read.varietal_+3A_snames">snames</code></td>
<td>
<p>either a vector of sample names, an integer marking
the length of the sample name prefix, or
<code>NULL</code>. <code>read.varietal</code> assumes that the row names of
the <code>.csv</code> file consist of character strings marking the
sample names, followed by a number.</p>
</td></tr>
<tr><td><code id="read.varietal_+3A_sep">sep</code></td>
<td>
<p>the field separator character.  Values on each line of
the file are separated by this character.</p>
</td></tr>
<tr><td><code id="read.varietal_+3A_dec">dec</code></td>
<td>
<p>the character used in the file for decimal points.</p>
</td></tr>
<tr><td><code id="read.varietal_+3A_method">method</code></td>
<td>
<p>an optional string specifying the dissimilarity
measure which should be used for comparing this with other
datasets. Should be one of either <code>"KS"</code> (for
Kolmogorov-Smirnov) or <code>"Kuiper"</code> (for Kuiper)</p>
</td></tr>
<tr><td><code id="read.varietal_+3A_check.names">check.names</code></td>
<td>
<p>logical.  If <code>TRUE</code> then the names of the
variables in the frame are checked to ensure that they are
syntactically variable names.</p>
</td></tr>
<tr><td><code id="read.varietal_+3A_row.names">row.names</code></td>
<td>
<p>logical. See the documentation for the
<code>read.table</code> function.</p>
</td></tr>
<tr><td><code id="read.varietal_+3A_...">...</code></td>
<td>
<p>optional arguments to the built-in <code>read.csv</code>
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>varietal</code>, i.e. a list with the
following items:
</p>
<p><code>x</code>: a compositional data table
</p>
<p><code>snames</code>: a vector of strings corresponding to the sample names
</p>
<p><code>name</code>: the name of the dataset, extracted from the file path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- system.file("SNSM/Ttn_chem.csv",package="provenance")
Ttn &lt;- read.varietal(fname=fn,snames=3)
plot(MDS(Ttn))
</code></pre>

<hr>
<h2 id='restore'>Undo the effect of hydraulic sorting</h2><span id='topic+restore'></span>

<h3>Description</h3>

<p>Restore the detrital composition back to a specified source rock density (SRD)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restore(X, dens, target = 2.71)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restore_+3A_x">X</code></td>
<td>
<p>an object of class <code>compositional</code></p>
</td></tr>
<tr><td><code id="restore_+3A_dens">dens</code></td>
<td>
<p>a vector of rock and mineral densities</p>
</td></tr>
<tr><td><code id="restore_+3A_target">target</code></td>
<td>
<p>the target density (in g/cm3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>SRDcorrected</code>, i.e. an object of class
<code>compositional</code> which is a daughter of class <code>compositional</code>
containing the restored composition, plus one additional member called
<code>restoration</code>, containing the intermediate steps of the SRD correction
algorithm.
</p>


<h3>Author(s)</h3>

<p>Alberto Resentini and Pieter Vermeesch
</p>


<h3>References</h3>

<p>Garzanti E, Ando, S and Vezzoli, G.  &quot;Settling
equivalence of detrital minerals and grain-size dependence of
sediment composition.&quot; Earth and Planetary Science Letters 273.1
(2008): 138-151.
</p>


<h3>See Also</h3>

<p>minsorting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib,densities)
rescomp &lt;- restore(Namib$PTHM,densities,2.71)
HMcomp &lt;- c("zr","tm","rt","sph","ap","ep","gt",
            "st","amp","cpx","opx")
amcomp &lt;- amalgamate(rescomp,Plag="P",HM=HMcomp,Opq="opaques")
plot(ternary(amcomp),showpath=TRUE)
</code></pre>

<hr>
<h2 id='SH.diss'>Sircombe and Hazelton distance</h2><span id='topic+SH.diss'></span>

<h3>Description</h3>

<p>Calculates Sircombe and Hazelton's L2 distance between the Kernel
Functional Estimates (KFEs, not to be confused with Kernel Density
Estimates!) of two samples with specified analytical uncertainties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SH.diss(x, i, j, c.con = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SH.diss_+3A_x">x</code></td>
<td>
<p>an object of class <code>distributional</code></p>
</td></tr>
<tr><td><code id="SH.diss_+3A_i">i</code></td>
<td>
<p>index of the first sample</p>
</td></tr>
<tr><td><code id="SH.diss_+3A_j">j</code></td>
<td>
<p>index of the second sample</p>
</td></tr>
<tr><td><code id="SH.diss_+3A_c.con">c.con</code></td>
<td>
<p>smoothing bandwidth of the kernel functional estimate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar value expressing the L2 distance between the KFEs
of samples i and j
</p>


<h3>Author(s)</h3>

<p>Keith Sircombe and Martin Hazelton
</p>


<h3>References</h3>

<p>Sircombe, K. N., and M. L. Hazelton. &quot;Comparison of
detrital zircon age distributions by kernel functional estimation.&quot;
Sedimentary Geology 171.1 (2004): 91-111.
</p>


<h3>See Also</h3>

<p>KS.diss
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datfile &lt;- system.file("Namib/DZ.csv",package="provenance")
errfile &lt;- system.file("Namib/DZerr.csv",package="provenance")
DZ &lt;- read.distributional(datfile,errfile)
d &lt;- SH.diss(DZ,1,2)
print(d)
</code></pre>

<hr>
<h2 id='SNSM'>varietal data example</h2><span id='topic+SNSM'></span>

<h3>Description</h3>

<p>A list of varietal datasets including detrital zircon
(<code>zr</code>), apatite (<code>ap</code>) and titanite
(<code>tit</code>) compositions from the Sierra Nevada de Santa
Marta, provided by L. Caracciolo (FAU Erlangen).
</p>


<h3>Author(s)</h3>

<p>Luca Caracciolo, Diana Hatzenbuehler and David Chew.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(MDS(SNSM$tit))
</code></pre>

<hr>
<h2 id='subset'>Get a subset of provenance data</h2><span id='topic+subset'></span><span id='topic+subset.distributional'></span><span id='topic+subset.compositional'></span><span id='topic+subset.counts'></span><span id='topic+subset.varietal'></span>

<h3>Description</h3>

<p>Return a subset of provenance data according to some specified
indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'distributional'
subset(x, subset = NULL, select = NULL, ...)

## S3 method for class 'compositional'
subset(x, subset = NULL, components = NULL, select = NULL, ...)

## S3 method for class 'counts'
subset(x, subset = NULL, components = NULL, select = NULL, ...)

## S3 method for class 'varietal'
subset(x, subset = NULL, components = NULL, select = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>an object of class <code>distributional</code>,
<code>compositional</code>, <code>counts</code> or <code>varietal</code>.</p>
</td></tr>
<tr><td><code id="subset_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or rows to
keep: missing values are taken as false.</p>
</td></tr>
<tr><td><code id="subset_+3A_select">select</code></td>
<td>
<p>a vector of sample names</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>optional arguments for the generic subset function</p>
</td></tr>
<tr><td><code id="subset_+3A_components">components</code></td>
<td>
<p>vector of categories (column names) to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same class as <code>x</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+amalgamate">amalgamate</a>, <a href="#topic+combine">combine</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
coast &lt;- c("N1","N2","T8","T13","N12","N13")
ZTRcoast &lt;- subset(Namib$HM,select=coast,components=c('gt','cpx','ep'))
DZcoast &lt;- subset(Namib$DZ,select=coast)
summaryplot(ZTRcoast,KDEs(DZcoast),ncol=2)
</code></pre>

<hr>
<h2 id='summaryplot'>Joint plot of several provenance datasets</h2><span id='topic+summaryplot'></span>

<h3>Description</h3>

<p>Arranges kernel density estimates and pie charts in a grid format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryplot(..., ncol = 1, pch = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryplot_+3A_...">...</code></td>
<td>
<p>a sequence of datasets of class <code>compositional</code>,
<code>distributional</code>, <code>counts</code> or <code>KDEs</code>.</p>
</td></tr>
<tr><td><code id="summaryplot_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns</p>
</td></tr>
<tr><td><code id="summaryplot_+3A_pch">pch</code></td>
<td>
<p>(optional) symbol to be used to mark the sample points
along the x-axis of the KDEs (if appropriate).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary plot of all the data comprised of KDEs for the
datasets of class <code>KDEs</code>, pie charts for those of class
<code>compositional</code> or <code>counts</code> and histograms for those
of class <code>distributional</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+KDEs">KDEs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
KDEs &lt;- KDEs(Namib$DZ,0,3000)
summaryplot(KDEs,Namib$HM,Namib$PT,ncol=2)
</code></pre>

<hr>
<h2 id='ternary'>Define a ternary composition</h2><span id='topic+ternary'></span>

<h3>Description</h3>

<p>Create an object of class <code>ternary</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ternary(X, x = 1, y = 2, z = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ternary_+3A_x">X</code></td>
<td>
<p>an object of class <code>compositional</code> OR a matrix or
data frame with numerical data</p>
</td></tr>
<tr><td><code id="ternary_+3A_x">x</code></td>
<td>
<p>string/number or a vector of strings/numbers indicating the
variables/indices making up the first subcomposition of the ternary system.</p>
</td></tr>
<tr><td><code id="ternary_+3A_y">y</code></td>
<td>
<p>second (set of) variables</p>
</td></tr>
<tr><td><code id="ternary_+3A_z">z</code></td>
<td>
<p>third (set of) variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>ternary</code>, i.e. a list containing:
</p>
<p>x: a three column matrix (or vector) of ternary compositions.
</p>
<p>and (if X is of class <code>SRDcorrected</code>)
</p>
<p>restoration: a list of intermediate ternary compositions inherited
from the SRD correction
</p>


<h3>See Also</h3>

<p>restore
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
tern &lt;- ternary(Namib$PT,c('Q'),c('KF','P'),c('Lm','Lv','Ls'))
plot(tern,type="QFL")
</code></pre>

<hr>
<h2 id='ternary.ellipse'>Ternary confidence ellipse</h2><span id='topic+ternary.ellipse'></span><span id='topic+ternary.ellipse.default'></span><span id='topic+ternary.ellipse.compositional'></span><span id='topic+ternary.ellipse.counts'></span>

<h3>Description</h3>

<p>plot a <code class="reqn">100(1-\alpha)\%</code> confidence region around the data or
around its mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ternary.ellipse(x, ...)

## Default S3 method:
ternary.ellipse(x, alpha = 0.05, population = TRUE, ...)

## S3 method for class 'compositional'
ternary.ellipse(x, alpha = 0.05, population = TRUE, ...)

## S3 method for class 'counts'
ternary.ellipse(x, alpha = 0.05, population = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ternary.ellipse_+3A_x">x</code></td>
<td>
<p>an object of class <code>ternary</code></p>
</td></tr>
<tr><td><code id="ternary.ellipse_+3A_...">...</code></td>
<td>
<p>optional formatting arguments</p>
</td></tr>
<tr><td><code id="ternary.ellipse_+3A_alpha">alpha</code></td>
<td>
<p>cutoff level for the confidence ellipse</p>
</td></tr>
<tr><td><code id="ternary.ellipse_+3A_population">population</code></td>
<td>
<p>show the standard deviation of the entire
population or the standard error of the mean?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
tern &lt;- ternary(Namib$Major,'CaO','Na2O','K2O')
plot(tern)
ternary.ellipse(tern)
</code></pre>

<hr>
<h2 id='text.ternary'>Ternary text plotting</h2><span id='topic+text.ternary'></span>

<h3>Description</h3>

<p>Add text an existing ternary diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ternary'
text(x, labels = 1:nrow(x$x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text.ternary_+3A_x">x</code></td>
<td>
<p>an object of class <code>ternary</code>, or a three-column data
frame or matrix</p>
</td></tr>
<tr><td><code id="text.ternary_+3A_labels">labels</code></td>
<td>
<p>a character vector or expression specifying the text
to be written</p>
</td></tr>
<tr><td><code id="text.ternary_+3A_...">...</code></td>
<td>
<p>optional arguments to the generic <code>text</code> function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
tern &lt;- ternary(Namib$Major,'CaO','Na2O','K2O')
plot(tern,pch=21,bg='red',labels=NULL)
# add the geometric mean composition as a text label:
gmean &lt;- ternary(exp(colMeans(log(tern$x))))
text(gmean,labels='geometric mean')
</code></pre>

<hr>
<h2 id='varietal2distributional'>Convert varietal to distributional data</h2><span id='topic+varietal2distributional'></span>

<h3>Description</h3>

<p>Convert an object of class <code>varietal</code> either to a list of
distributional objects by breaking it up into separate elements, or
to a single distributional object corresponding to the first
principal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varietal2distributional(x, bycol = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varietal2distributional_+3A_x">x</code></td>
<td>
<p>an object of class <code>varietal</code>.</p>
</td></tr>
<tr><td><code id="varietal2distributional_+3A_bycol">bycol</code></td>
<td>
<p>logical. If <code>TRUE</code>, returns a list of
distributional objects (one for each element). If <code>FALSE</code>,
returns a single distributional object (containing the PC1
scores for each sample).</p>
</td></tr>
<tr><td><code id="varietal2distributional_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, shows the PCA biplot that is
used when <code>bycol</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Ttn_file &lt;- system.file("SNSM/Ttn_chem.csv",package="provenance")
Ttn &lt;- read.varietal(fn=Ttn_file,snames=3)
varietal2distributional(Ttn,bycol=FALSE,plot=TRUE)
</code></pre>

<hr>
<h2 id='Wasserstein.diss'>Wasserstein distance</h2><span id='topic+Wasserstein.diss'></span><span id='topic+Wasserstein.diss.default'></span><span id='topic+Wasserstein.diss.distributional'></span><span id='topic+Wasserstein.diss.varietal'></span>

<h3>Description</h3>

<p>Returns the Wasserstein distance between two samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wasserstein.diss(x, ...)

## Default S3 method:
Wasserstein.diss(x, y, ...)

## S3 method for class 'distributional'
Wasserstein.diss(x, log = FALSE, ...)

## S3 method for class 'varietal'
Wasserstein.diss(x, package = "transport", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wasserstein.diss_+3A_x">x</code></td>
<td>
<p>the first sample as a vector</p>
</td></tr>
<tr><td><code id="Wasserstein.diss_+3A_...">...</code></td>
<td>
<p>optional arguments to the
<code>transport::wasserstein()</code> or
<code>T4transport::wasserstein()</code> functions. Warning: the
latter function is very slow.</p>
</td></tr>
<tr><td><code id="Wasserstein.diss_+3A_y">y</code></td>
<td>
<p>the second sample as a vector</p>
</td></tr>
<tr><td><code id="Wasserstein.diss_+3A_log">log</code></td>
<td>
<p>logical. Take the lograthm of the data before
calculating the distances?</p>
</td></tr>
<tr><td><code id="Wasserstein.diss_+3A_package">package</code></td>
<td>
<p>the name of the package that provides the 2D
Wasserstein distance. Currently, this can be either
<code>'transport'</code> or <code>T4transport</code>.</p>
</td></tr>
<tr><td><code id="Wasserstein.diss_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, gives progress updates
during the construction of the dissimilarity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar value
</p>


<h3>Author(s)</h3>

<p>The default S3 method was written by Pieter Vermeesch,
using modified code from Dominic Schuhmacher's <code>transport</code>
package (<code>transport1d</code> function), as implemented in
<code>IsoplotR</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Namib)
print(Wasserstein.diss(Namib$DZ$x[['N1']],Namib$DZ$x[['T8']]))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
