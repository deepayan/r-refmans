<!DOCTYPE html><html><head><title>Help for package FKF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FKF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fkf'><p>Fast Kalman filter</p></a></li>
<li><a href='#FKF-package'><p>FKF: Fast Kalman Filter</p></a></li>
<li><a href='#fks'><p>Fast Kalman Smoother</p></a></li>
<li><a href='#plot.fkf'><p>Plotting fkf objects</p></a></li>
<li><a href='#plot.fks'><p>Plotting fks objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast Kalman Filter</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a fast and flexible implementation of the Kalman
        filter and smoother, which can deal with NAs. It is entirely written in C and relies fully on linear algebra subroutines contained in
        BLAS and LAPACK. Due to the speed of the filter, the fitting of
        high-dimensional linear state space models to large datasets
        becomes possible. This package also contains a plot function
        for the visualization of the state vector and graphical
        diagnostics of the residuals.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/waternumbers/FKF/issues">https://github.com/waternumbers/FKF/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://waternumbers.github.io/FKF/">https://waternumbers.github.io/FKF/</a>,
<a href="https://github.com/waternumbers/FKF">https://github.com/waternumbers/FKF</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 17:34:50 UTC; paul</td>
</tr>
<tr>
<td>Author:</td>
<td>David Luethi [aut],
  Philipp Erb [aut],
  Simon Otziger [aut],
  Daniel McDonald [aut],
  Paul Smith <a href="https://orcid.org/0000-0002-0034-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Smith &lt;paul@waternumbers.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fkf'>Fast Kalman filter</h2><span id='topic+fkf'></span>

<h3>Description</h3>

<p>This function allows for fast and flexible Kalman filtering. Both, the
measurement and transition equation may be multivariate and parameters
are allowed to be time-varying. In addition &ldquo;NA&rdquo;-values in the
observations are supported. <code>fkf</code> wraps the <code>C</code>-function
<code>FKF</code> which fully relies on linear algebra subroutines contained
in BLAS and LAPACK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fkf(a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fkf_+3A_a0">a0</code></td>
<td>
<p>A <code>vector</code> giving the initial value/estimation of the state variable.</p>
</td></tr>
<tr><td><code id="fkf_+3A_p0">P0</code></td>
<td>
<p>A <code>matrix</code> giving the variance of <code>a0</code>.</p>
</td></tr>
<tr><td><code id="fkf_+3A_dt">dt</code></td>
<td>
<p>A <code>matrix</code> giving the intercept of the transition equation (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="fkf_+3A_ct">ct</code></td>
<td>
<p>A <code>matrix</code> giving the intercept of the measurement equation (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="fkf_+3A_tt">Tt</code></td>
<td>
<p>An <code>array</code> giving the factor of the transition equation (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="fkf_+3A_zt">Zt</code></td>
<td>
<p>An <code>array</code> giving the factor of the measurement equation (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="fkf_+3A_hht">HHt</code></td>
<td>
<p>An <code>array</code> giving the variance of the innovations of the transition equation (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="fkf_+3A_ggt">GGt</code></td>
<td>
<p>An <code>array</code> giving the variance of the disturbances of the measurement equation (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="fkf_+3A_yt">yt</code></td>
<td>
<p>A <code>matrix</code> containing the observations. &ldquo;NA&rdquo;-values are allowed (see <b>Details</b>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>State space form</strong>
</p>
<p>The following notation is closest to the one of Koopman et al.
The state space model is represented by the transition equation and
the measurement equation. Let <code class="reqn">m</code> be the dimension of the state
variable, <code class="reqn">d</code> be the dimension of the observations, and <code class="reqn">n</code>
the number of observations. The transition equation and the
measurement equation are given by
</p>
<p style="text-align: center;"><code class="reqn">\alpha_{t + 1} = d_t + T_t \cdot \alpha_t + H_t \cdot \eta_t</code>
</p>
 
<p style="text-align: center;"><code class="reqn">y_t = c_t + Z_t \cdot \alpha_t + G_t \cdot \epsilon_t,</code>
</p>

<p>where <code class="reqn">\eta_t</code> and <code class="reqn">\epsilon_t</code> are iid
<code class="reqn">N(0, I_m)</code> and iid <code class="reqn">N(0, I_d)</code>,
respectively, and <code class="reqn">\alpha_t</code> denotes the state
variable. The parameters admit the following dimensions:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">\alpha_{t} \in R^{m}</code> </td><td style="text-align: left;">
<code class="reqn">d_{t} \in R^m</code> </td><td style="text-align: left;">
<code class="reqn">\eta_{t} \in R^m</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">T_{t} \in R^{m \times m}</code> </td><td style="text-align: left;">
<code class="reqn">H_{t} \in R^{m \times m}</code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">y_{t} \in R^d</code> </td><td style="text-align: left;">
<code class="reqn">c_t \in R^d</code> </td><td style="text-align: left;">
<code class="reqn">\epsilon_{t} \in R^d</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">Z_{t} \in R^{d \times m}</code> </td><td style="text-align: left;">
<code class="reqn">G_{t} \in R^{d \times d}</code> </td><td style="text-align: left;"> 
</td>
</tr>

</table>

<p>Note that <code>fkf</code> takes as input <code>HHt</code> and <code>GGt</code> which
corresponds to <code class="reqn">H_t H_t^\prime</code> and <code class="reqn">G_t G_t^\prime</code>. 
</p>

<p><strong>Iteration:</strong>
</p>
<p>The filter iterations are implemented using the expected values
</p>
<p style="text-align: center;"><code class="reqn">a_{t} = E[\alpha_t | y_1,\ldots,y_{t-1}]</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{t|t} = E[\alpha_t | y_1,\ldots,y_{t}]</code>
</p>

<p>and variances
</p>
<p style="text-align: center;"><code class="reqn">P_{t} = Var[\alpha_t | y_1,\ldots,y_{t-1}]</code>
</p>

<p style="text-align: center;"><code class="reqn">P_{t|t} = Var[\alpha_t | y_1,\ldots,y_{t}]</code>
</p>

<p>of the state <code class="reqn">\alpha_{t}</code> in the following way
(for the case of no NA's):
</p>
<p>Initialisation: Set <code class="reqn">t=1</code> with <code class="reqn">a_{t} = a0</code> and <code class="reqn">P_{t}=P0</code>
</p>
<p>Updating equations:
</p>
<p style="text-align: center;"><code class="reqn">v_t = y_t - c_t - Z_t a_t</code>
</p>

<p style="text-align: center;"><code class="reqn">F_t = Z_t P_t Z_t^{\prime} + G_t G_t^\prime</code>
</p>

<p style="text-align: center;"><code class="reqn">K_t = P_t Z_t^{\prime} F_{t}^{-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{t|t} = a_t + K_t v_t</code>
</p>

<p style="text-align: center;"><code class="reqn">P_{t|t} = P_t - P_t Z_t^\prime K_t^\prime</code>
</p>

<p>Prediction equations:
</p>
<p style="text-align: center;"><code class="reqn">a_{t+1} = d_{t} + T_{t} a_{t|t}</code>
</p>

<p style="text-align: center;"><code class="reqn">P_{t+1} = T_{t} P_{t|t} T_{t}^{\prime} + H_t H_t^\prime</code>
</p>

<p>Next iteration: Set <code class="reqn">t=t+1</code> and goto &ldquo;Updating equations&rdquo;.
</p>

<p><strong>NA-values:</strong>
</p>
<p>NA-values in the observation matrix <code>yt</code> are supported.  If
particular observations <code>yt[,i]</code> contain NAs, the NA-values are
removed and the measurement equation is adjusted accordingly.  When
the full vector <code>yt[,i]</code> is missing the Kalman filter reduces to
a prediction step.
</p>

<p><strong>Parameters:</strong>
</p>
<p>The parameters can either be constant or deterministic
time-varying. Assume the number of observations is <code class="reqn">n</code>
(i.e. <code class="reqn">y = (y_t)_{t = 1, \ldots, n}, y_t = (y_{t1}, \ldots,
  y_{td})</code>). Then, the parameters admit the following
classes and dimensions:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>dt</code> </td><td style="text-align: left;"> either a <code class="reqn">m \times n</code> (time-varying) or a <code class="reqn">m \times 1</code> (constant) matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Tt</code> </td><td style="text-align: left;"> either a <code class="reqn">m \times m \times n</code> or a <code class="reqn">m \times m \times 1</code> array. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>HHt</code> </td><td style="text-align: left;"> either a <code class="reqn">m \times m \times n</code> or a <code class="reqn">m \times m \times 1</code> array. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ct</code> </td><td style="text-align: left;"> either a <code class="reqn">d \times n</code> or a <code class="reqn">d \times 1</code> matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Zt</code> </td><td style="text-align: left;"> either a <code class="reqn">d \times m \times n</code> or a <code class="reqn">d \times m \times 1</code> array. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>GGt</code> </td><td style="text-align: left;"> either a <code class="reqn">d \times d \times n</code> or a <code class="reqn">d \times d \times 1</code> array. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>yt</code> </td><td style="text-align: left;"> a <code class="reqn">d \times n</code> matrix.
  </td>
</tr>

</table>


<p><strong>BLAS and LAPACK routines used:</strong>
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>fkf</code> basically wraps the <code>C</code>-function
<code>FKF</code>, which entirely relies on linear algebra subroutines
provided by BLAS and LAPACK. The following functions are used:
</p>

<table>
<tr>
 <td style="text-align: right;">
    BLAS: </td><td style="text-align: left;"> <code>dcopy</code>, <code>dgemm</code>, <code>daxpy</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
    LAPACK: </td><td style="text-align: left;"> <code>dpotri</code>, <code>dpotrf</code>.
  </td>
</tr>

</table>

<p><code>FKF</code> is called through the <code>.Call</code> interface.  Internally,
<code>FKF</code> extracts the dimensions, allocates memory, and initializes
the <span class="rlang"><b>R</b></span>-objects to be returned. <code>FKF</code> subsequently calls
<code>cfkf</code> which performs the Kalman filtering.
</p>
<p>The only critical part is to compute the inverse of <code class="reqn">F_t</code>
and the determinant of <code class="reqn">F_t</code>. If the inverse can not be
computed, the filter stops and returns the corresponding message in
<code>status</code> (see <b>Value</b>). If the computation of the
determinant fails, the filter will continue, but the log-likelihood
(element <code>logLik</code>) will be &ldquo;NA&rdquo;.
</p>
<p>The inverse is computed in two steps:
First, the Cholesky factorization of <code class="reqn">F_t</code> is
calculated by <code>dpotrf</code>. Second, <code>dpotri</code> calculates the
inverse based on the output of <code>dpotrf</code>. <br />
The determinant of <code class="reqn">F_t</code> is computed using again the
Cholesky decomposition.
</p>
<p>The first element of both <code>at</code> and <code>Pt</code> is filled with the
function arguments <code>a0</code> and <code>P0</code>, and the last, i.e. the (n +
1)-th, element of <code>at</code> and <code>Pt</code> contains the predictions for the next time step.
</p>


<h3>Value</h3>

<p>An S3-object of class &ldquo;fkf&rdquo;, which is a list with the following elements:
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>att</code> </td><td style="text-align: left;"> A <code class="reqn">m \times n</code>-matrix containing the filtered state variables, i.e. att[,t] = <code class="reqn">a_{t|t}</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>at</code> </td><td style="text-align: left;"> A <code class="reqn">m \times (n + 1)</code>-matrix containing the predicted state variables, i.e. at[,t] = <code class="reqn">a_t</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Ptt</code> </td><td style="text-align: left;"> A <code class="reqn">m \times m \times n</code>-array containing the variance of <code>att</code>, i.e. Ptt[,,t] = <code class="reqn">P_{t|t}</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Pt</code> </td><td style="text-align: left;"> A <code class="reqn">m \times m \times (n + 1)</code>-array containing the variances of <code>at</code>, i.e. Pt[,,t] = <code class="reqn">P_t</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>vt</code> </td><td style="text-align: left;"> A <code class="reqn">d \times n</code>-matrix of the prediction errors i.e. vt[,t] = <code class="reqn">v_t</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Ft</code> </td><td style="text-align: left;"> A <code class="reqn">d \times d \times n</code>-array which contains the variances of <code>vt</code>, i.e. Ft[,,t] = <code class="reqn">F_t</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Kt</code> </td><td style="text-align: left;"> A <code class="reqn">m \times d \times n</code>-array containing the &ldquo;Kalman gain&rdquo; i.e. Kt[,,t] = <code class="reqn">k_t</code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>logLik</code> </td><td style="text-align: left;"> The log-likelihood. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>status</code> </td><td style="text-align: left;"> A vector which contains the status of LAPACK's <code>dpotri</code> and <code>dpotrf</code>. <code class="reqn">(0, 0)</code> means successful exit.</td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>sys.time</code> </td><td style="text-align: left;"> The time elapsed as an object of class &ldquo;proc_time&rdquo;.
</td>
</tr>

</table>



<h3>References</h3>

<p>Harvey, Andrew C. (1990). <em>Forecasting, Structural Time Series
Models and the Kalman Filter</em>.  Cambridge University Press.
</p>
<p>Hamilton, James D. (1994). <em>Time Series Analysis</em>.  Princeton
University Press.
</p>
<p>Koopman, S. J., Shephard, N., Doornik, J. A. (1999).
<em>Statistical algorithms for models in state space using SsfPack
2.2</em>. Econometrics Journal, Royal Economic Society, vol. 2(1), pages
107-160.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fkf">plot</a></code> to visualize and analyze <code>fkf</code>-objects, <code><a href="stats.html#topic+KalmanRun">KalmanRun</a></code> from the stats package, function <code>dlmFilter</code> from package <code>dlm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## &lt;---------------------------------------------------------------------------&gt;
## Example: Local level model for the Nile's annual flow.
## &lt;---------------------------------------------------------------------------&gt;
## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)          
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

y &lt;- Nile
y[c(3, 10)] &lt;- NA  # NA values can be handled

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0) 
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- y[1]            # Estimation of the first year flow 
P0 &lt;- matrix(100)     # Variance of 'a0'

## Estimate parameters:
fit.fkf &lt;- optim(c(HHt = var(y, na.rm = TRUE) * .5,
                   GGt = var(y, na.rm = TRUE) * .5),
                 fn = function(par, ...)
                 -fkf(HHt = matrix(par[1]), GGt = matrix(par[2]), ...)$logLik,
                 yt = rbind(y), a0 = a0, P0 = P0, dt = dt, ct = ct,
                 Zt = Zt, Tt = Tt)

## Filter Nile data with estimated parameters:
fkf.obj &lt;- fkf(a0, P0, dt, ct, Tt, Zt, HHt = matrix(fit.fkf$par[1]),
               GGt = matrix(fit.fkf$par[2]), yt = rbind(y))

## Compare with the stats' structural time series implementation:
fit.stats &lt;- StructTS(y, type = "level")

fit.fkf$par
fit.stats$coef

## Plot the flow data together with fitted local levels:
plot(y, main = "Nile flow")
lines(fitted(fit.stats), col = "green")
lines(ts(fkf.obj$att[1, ], start = start(y), frequency = frequency(y)), col = "blue")
legend("top", c("Nile flow data", "Local level (StructTS)", "Local level (fkf)"),
       col = c("black", "green", "blue"), lty = 1)

</code></pre>

<hr>
<h2 id='FKF-package'>FKF: Fast Kalman Filter</h2><span id='topic+FKF'></span><span id='topic+FKF-package'></span>

<h3>Description</h3>

<p>This is a fast and flexible implementation of the Kalman filter and smoother, which can deal with NAs. It is entirely written in C and relies fully on linear algebra subroutines contained in BLAS and LAPACK. Due to the speed of the filter, the fitting of high-dimensional linear state space models to large datasets becomes possible. This package also contains a plot function for the visualization of the state vector and graphical diagnostics of the residuals.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul Smith <a href="mailto:paul@waternumbers.co.uk">paul@waternumbers.co.uk</a> (<a href="https://orcid.org/0000-0002-0034-3412">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> David Luethi
</p>
</li>
<li><p> Philipp Erb
</p>
</li>
<li><p> Simon Otziger
</p>
</li>
<li><p> Daniel McDonald <a href="mailto:daniel@stat.ubc.ca">daniel@stat.ubc.ca</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://waternumbers.github.io/FKF/">https://waternumbers.github.io/FKF/</a>
</p>
</li>
<li> <p><a href="https://github.com/waternumbers/FKF">https://github.com/waternumbers/FKF</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/waternumbers/FKF/issues">https://github.com/waternumbers/FKF/issues</a>
</p>
</li></ul>


<hr>
<h2 id='fks'>Fast Kalman Smoother</h2><span id='topic+fks'></span>

<h3>Description</h3>

<p>This function can be run after running <code><a href="#topic+fkf">fkf</a></code> to produce
&quot;smoothed&quot; estimates of the state variable <code class="reqn">\alpha_t</code>.
Unlike the output of the filter, these estimates are conditional
on the entire set of <code class="reqn">n</code> data points rather than only the past, see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fks(FKFobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fks_+3A_fkfobj">FKFobj</code></td>
<td>
<p>An S3-object of class &quot;fkf&quot;, returned by <code><a href="#topic+fkf">fkf</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following notation is taken from the <code><a href="#topic+fkf">fkf</a></code> function descriptions
and is close to the one of Koopman et al. The smoother estimates
</p>
<p style="text-align: center;"><code class="reqn">a_{t|n} = E[\alpha_{t} | y_1,\ldots,y_n]</code>
</p>

<p style="text-align: center;"><code class="reqn">P_{t|n} = Var[\alpha_{t} | y_1,\ldots,y_n]</code>
</p>

<p>based on the outputs of the forward filtering pass performed by <code><a href="#topic+fkf">fkf</a></code>.
</p>
<p>The formulation of Koopman and Durbin is used which evolves the two values
<code class="reqn">r_{t} \in R^m</code> and <code class="reqn">N_{t} \in R^{m \times m}</code>
to avoid inverting the covariance matrix.
</p>
<p><strong>Iteration:</strong>
</p>
<p>If there are no missing values the iteration proceeds as follows:
</p>
<p>Initialisation: Set <code class="reqn">t=n</code>, with <code class="reqn">r_t =0</code> and <code class="reqn">N_t =0</code>.
</p>
<p>Evolution equations:
</p>
<p style="text-align: center;"><code class="reqn">L = T_{t} - T_{t}K_{t}Z_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{t-1} = Z_{t}^\prime F_{t}^{-1} v_{t} + L^\prime r_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">N_{t-1} = Z_{t}^\prime F_{t}^{-1} Z_{t} + L^\prime N_{t} L</code>
</p>

<p>Updating equations:
</p>
<p style="text-align: center;"><code class="reqn">a_{t|n} = a_{t|t-1} + P_{t|t-1}r_{t-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">P_{t|n} = P_{t|t-1} - P_{t|t-1}N_{t-1}P_{t|t-1}</code>
</p>

<p>Next iteration: Set <code class="reqn">t=t-1</code> and goto &ldquo;Evolution equations&rdquo;.
</p>


<h3>Value</h3>

<p>An S3-object of class &quot;fks&quot; which is a list with the following elements:
</p>
<p><code>ahatt</code>  A <code class="reqn">m \times n</code>-matrix containing the
smoothed state variables, i.e. ahatt[,t] = <code class="reqn">a_{t|n}</code><br />
<code>Vt</code>  A <code class="reqn">m \times m \times n</code>-array
containing the variances of <code>ahatt</code>, i.e. Vt[,,t] = <code class="reqn">P_{t|n}</code><br />
</p>


<h3>References</h3>

<p>Koopman, S. J. and Durbin, J. (2000). <em>Fast filtering and smoothing for multivariate state space models</em> Journal of Time Series Analysis Vol. 21, No. 3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## &lt;---------------------------------------------------------------------------&gt;
## Example: Local level model for the Nile's annual flow.
## &lt;---------------------------------------------------------------------------&gt;
## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

y &lt;- Nile
y[c(3, 10)] &lt;- NA  # NA values can be handled

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- y[1]            # Estimation of the first year flow
P0 &lt;- matrix(100)     # Variance of 'a0'

## Estimate parameters:
fit.fkf &lt;- optim(c(HHt = var(y, na.rm = TRUE) * .5,
                   GGt = var(y, na.rm = TRUE) * .5),
                 fn = function(par, ...)
                   -fkf(HHt = matrix(par[1]), GGt = matrix(par[2]), ...)$logLik,
                 yt = rbind(y), a0 = a0, P0 = P0, dt = dt, ct = ct,
                 Zt = Zt, Tt = Tt)

## Filter Nile data with estimated parameters:
fkf.obj &lt;- fkf(a0, P0, dt, ct, Tt, Zt, HHt = matrix(fit.fkf$par[1]),
               GGt = matrix(fit.fkf$par[2]), yt = rbind(y))

## Smooth the data based on the filter object
fks.obj &lt;- fks(fkf.obj)

## Plot the flow data together with local levels:
plot(y, main = "Nile flow")
lines(ts(fkf.obj$att[1, ], start = start(y), frequency = frequency(y)), col = "blue")
lines(ts(fks.obj$ahatt[1,], start = start(y), frequency = frequency(y)), col = "red")
legend("top", c("Nile flow data", "Local level (fkf)","Local level (fks)"),
       col = c("black", "green", "blue", "red"), lty = 1)

</code></pre>

<hr>
<h2 id='plot.fkf'>Plotting fkf objects</h2><span id='topic+plot.fkf'></span>

<h3>Description</h3>

<p>Plotting method for objects of class <code><a href="#topic+fkf">fkf</a></code>. This function
provides tools for graphical analysis of the Kalman filter output:
Visualization of the state vector, QQ-plot of the individual
residuals, QQ-plot of the Mahalanobis distance, auto- as well as
crosscorrelation function of the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fkf'
plot(
  x,
  type = c("state", "resid.qq", "qqchisq", "acf"),
  CI = 0.95,
  at.idx = 1:nrow(x$at),
  att.idx = 1:nrow(x$att),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fkf_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+fkf">fkf</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fkf_+3A_type">type</code></td>
<td>
<p>A string stating what shall be plotted (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="plot.fkf_+3A_ci">CI</code></td>
<td>
<p>The confidence interval in case <code>type == "state"</code>. Set
<code>CI</code> to <code>NA</code> if no confidence interval shall be plotted.</p>
</td></tr>
<tr><td><code id="plot.fkf_+3A_at.idx">at.idx</code></td>
<td>
<p>An vector giving the indexes of the predicted state variables
which shall be plotted if <code>type == "state"</code>.</p>
</td></tr>
<tr><td><code id="plot.fkf_+3A_att.idx">att.idx</code></td>
<td>
<p>An vector giving the indexes of the filtered state variables
which shall be plotted if <code>type == "state"</code>.</p>
</td></tr>
<tr><td><code id="plot.fkf_+3A_...">...</code></td>
<td>
<p>Arguments passed to either <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>, <code><a href="stats.html#topic+qqplot">qqplot</a></code> or <code><a href="stats.html#topic+acf">acf</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>type</code> states what shall be plotted. <code>type</code>
must partially match one of the following:
</p>

<dl>
<dt><code>state</code></dt><dd><p>The state variables are plotted. By the
arguments <code>at.idx</code> and <code>att.idx</code>, the user can specify
which of the predicted (<code class="reqn">a_{t}</code>) and filtered
(<code class="reqn">a_{t|t}</code>) state variables will be drawn.</p>
</dd>
<dt><code>resid.qq</code></dt><dd><p>Draws a QQ-plot for each residual-series in<code>vt</code>.</p>
</dd>
<dt><code>qqchisq</code></dt><dd><p>A Chi-Squared QQ-plot will be drawn to graphically
test for multivariate normality of the residuals based on the
Mahalanobis distance.</p>
</dd>
<dt><code>acf</code></dt><dd><p>Creates a pairs plot with the autocorrelation
function (<code><a href="stats.html#topic+acf">acf</a></code>) on the diagonal panels and the
crosscorrelation function (<code><a href="stats.html#topic+ccf">ccf</a></code>) of the residuals on the
off-diagnoal panels.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Invisibly returns an list with components:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>distance</code> </td><td style="text-align: left;"> The Mahalanobis distance of the residuals as a
  vector of length <code class="reqn">n</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>std.resid</code> </td><td style="text-align: left;"> The standardized residuals as an <code class="reqn">d \times
    n</code>-matrix. It should hold that <code class="reqn">std.resid_{ij} \; iid \sim N_d(0, I)</code>,
</td>
</tr>

</table>

<p>where <code class="reqn">d</code> denotes the dimension of the data and <code class="reqn">n</code> the number
of observations.
</p>


<h3>usage</h3>

<p><code>plot(x, type = c("state", "resid.qq", "qqchisq", "acf"),
CI = 0.95, at.idx = 1:nrow(x$at), att.idx = 1:nrow(x$att), ...)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fkf">fkf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## &lt;---------------------------------------------------------------------------&gt;
## Example: Local level model for the treering data
## &lt;---------------------------------------------------------------------------&gt;
## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)          
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

y &lt;- treering
y[c(3, 10)] &lt;- NA  # NA values can be handled

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- array(1,c(1,1,1))
a0 &lt;- y[1]            # Estimation of the first width
P0 &lt;- matrix(100)     # Variance of 'a0'

## Estimate parameters:
fit.fkf &lt;- optim(c(HHt = var(y, na.rm = TRUE) * .5,
                   GGt = var(y, na.rm = TRUE) * .5),
                 fn = function(par, ...)
                 -fkf(HHt = array(par[1],c(1,1,1)), GGt = array(par[2],c(1,1,1)), ...)$logLik,
                 yt = rbind(y), a0 = a0, P0 = P0, dt = dt, ct = ct,
                 Zt = Zt, Tt = Tt)

## Filter tree ring data with estimated parameters:
fkf.obj &lt;- fkf(a0, P0, dt, ct, Tt, Zt, HHt = array(fit.fkf$par[1],c(1,1,1)),
               GGt = array(fit.fkf$par[2],c(1,1,1)), yt = rbind(y))

## Plot the width together with fitted local levels:
plot(y, main = "Treering data")
lines(ts(fkf.obj$att[1, ], start = start(y), frequency = frequency(y)), col = "blue")
legend("top", c("Treering data", "Local level"), col = c("black", "blue"), lty = 1)

## Check the residuals for normality:
plot(fkf.obj, type = "resid.qq")

## Test for autocorrelation:
plot(fkf.obj, type = "acf", na.action = na.pass)

</code></pre>

<hr>
<h2 id='plot.fks'>Plotting fks objects</h2><span id='topic+plot.fks'></span>

<h3>Description</h3>

<p>Plotting method for objects of class <code><a href="#topic+fks">fks</a></code>. This function
provides tools visualisation of the state vector of the Kalman smoother output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fks'
plot(x, CI = 0.95, ahatt.idx = 1:nrow(x$ahatt), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fks_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+fks">fks</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fks_+3A_ci">CI</code></td>
<td>
<p>The confidence interval in case <code>type == "state"</code>. Set
<code>CI</code> to <code>NA</code> if no confidence interval shall be plotted.</p>
</td></tr>
<tr><td><code id="plot.fks_+3A_ahatt.idx">ahatt.idx</code></td>
<td>
<p>An vector giving the indexes of the predicted state variables
which shall be plotted if <code>type == "state"</code>.</p>
</td></tr>
<tr><td><code id="plot.fks_+3A_...">...</code></td>
<td>
<p>Arguments passed to either <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>, <code><a href="stats.html#topic+qqplot">qqplot</a></code> or <code><a href="stats.html#topic+acf">acf</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state variables are plotted. By the argument <code>ahatt.idx</code>, the user can specify
which of the smoothed (<code class="reqn">a_{t|n}</code>) state variables will be drawn.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fks">fks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## &lt;---------------------------------------------------------------------------&gt;
## Example 3: Local level model for the treering data
## &lt;---------------------------------------------------------------------------&gt;
## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)          
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

y &lt;- treering
y[c(3, 10)] &lt;- NA  # NA values can be handled

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- array(1,c(1,1,1))
a0 &lt;- y[1]            # Estimation of the first width
P0 &lt;- matrix(100)     # Variance of 'a0'

## Estimate parameters:
fit.fkf &lt;- optim(c(HHt = var(y, na.rm = TRUE) * .5,
                   GGt = var(y, na.rm = TRUE) * .5),
                 fn = function(par, ...)
                 -fkf(HHt = array(par[1],c(1,1,1)), GGt = array(par[2],c(1,1,1)), ...)$logLik,
                 yt = rbind(y), a0 = a0, P0 = P0, dt = dt, ct = ct,
                 Zt = Zt, Tt = Tt)

## Filter tree ring data with estimated parameters:
fkf.obj &lt;- fkf(a0, P0, dt, ct, Tt, Zt, HHt = array(fit.fkf$par[1],c(1,1,1)),
               GGt = array(fit.fkf$par[2],c(1,1,1)), yt = rbind(y))

fks.obj &lt;- fks(fkf.obj)
plot(fks.obj)
lines(as.numeric(y),col="blue")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
