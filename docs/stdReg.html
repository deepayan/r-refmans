<!DOCTYPE html><html><head><title>Help for package stdReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stdReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#confint.stdCoxph'>
<p>Confidence interval</p></a></li>
<li><a href='#confint.stdGee'>
<p>Confidence interval</p></a></li>
<li><a href='#confint.stdGlm'>
<p>Confidence interval</p></a></li>
<li><a href='#confint.stdParfrailty'>
<p>Confidence interval</p></a></li>
<li><a href='#parfrailty'>
<p>Fits shared frailty gamma-Weibull models</p></a></li>
<li><a href='#plot.stdCoxph'>
<p>Plots Cox regression standardization fit</p></a></li>
<li><a href='#plot.stdGee'>
<p>Plots GEE regression standardization fit</p></a></li>
<li><a href='#plot.stdGlm'>
<p>Plots GLM regression standardization fit</p></a></li>
<li><a href='#plot.stdParfrailty'>
<p>Plots parfrailty standardization fit</p></a></li>
<li><a href='#print.summary.parfrailty'>
<p>Prints summary of parfrailty fit</p></a></li>
<li><a href='#print.summary.stdCoxph'>
<p>Prints summary of Cox regression standardization fit</p></a></li>
<li><a href='#print.summary.stdGee'>
<p>Prints summary of GEE regression standardization fit</p></a></li>
<li><a href='#print.summary.stdGlm'>
<p>Prints summary of GLM regression standardization fit</p></a></li>
<li><a href='#print.summary.stdParfrailty'>
<p>Prints summary of Frailty standardization fit</p></a></li>
<li><a href='#stdCoxph'>
<p>Regression standardization in Cox proportional hazards models</p></a></li>
<li><a href='#stdGee'>
<p>Regression standardization in conditional generalized estimating equations</p></a></li>
<li><a href='#stdGlm'>
<p>Regression standardization in generalized linear models</p></a></li>
<li><a href='#stdParfrailty'>
<p>Regression standardization in shared frailty gamma-Weibull models</p></a></li>
<li><a href='#summary.parfrailty'>
<p>Summarizes parfrailty fit</p></a></li>
<li><a href='#summary.stdCoxph'>
<p>Summarizes Cox regression standardization fit</p></a></li>
<li><a href='#summary.stdGee'>
<p>Summarizes GEE regression standardization fit</p></a></li>
<li><a href='#summary.stdGlm'>
<p>Summarizes GLM regression standardization fit</p></a></li>
<li><a href='#summary.stdParfrailty'>
<p>Summarizes Frailty standardization fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regression Standardization</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Arvid Sjolander and Elisabeth Dahlqwist</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arvid Sjolander &lt;arvid.sjolander@ki.se&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functionality for regression standardization. Four general classes of models are allowed; generalized linear models, conditional generalized estimating equation models, Cox proportional hazards models and shared frailty gamma-Weibull models. Sjolander, A. (2016) &lt;<a href="https://doi.org/10.1007%2Fs10654-016-0157-3">doi:10.1007/s10654-016-0157-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, survival, data.table, numDeriv, drgee</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-17 06:23:57 UTC; arvsjo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-17 06:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='confint.stdCoxph'>
Confidence interval
</h2><span id='topic+confint.stdCoxph'></span>

<h3>Description</h3>

<p>This is a <code>confint</code> method for class <code>"stdCoxph"</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdCoxph'
confint(object, parm, level = 0.95, fun, type="plain", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.stdCoxph_+3A_object">object</code></td>
<td>

<p>an object of class <code>"stdCoxph"</code>.  
</p>
</td></tr> 
<tr><td><code id="confint.stdCoxph_+3A_parm">parm</code></td>
<td>

<p>not used.
</p>
</td></tr>
<tr><td><code id="confint.stdCoxph_+3A_level">level</code></td>
<td>

<p>the coverage probability of the confidence intervals. 
</p>
</td></tr>
<tr><td><code id="confint.stdCoxph_+3A_fun">fun</code></td>
<td>

<p>a function of one matrix argument with <code>q</code> rows and <code>p</code> columns, 
which returns a vector of length <code>q</code>. 
</p>
</td></tr>
<tr><td><code id="confint.stdCoxph_+3A_type">type</code></td>
<td>

<p>a string specifying the type of confidence interval; <code>plain</code> 
(for untransformed) or <code>log</code> (for log-transformed). 
</p>
</td></tr>
<tr><td><code id="confint.stdCoxph_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint.stdCoxph</code> extracts the <code>est</code> element from <code>object</code>, and 
inputs this to <code>fun</code>. It then uses the delta method to compute a confidence 
interval for the output of <code>fun</code>.   
</p>


<h3>Value</h3>

<p>a matrix with <code>q</code> rows and 2 columns, containing the computed confidence interval. 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>

<hr>
<h2 id='confint.stdGee'>
Confidence interval
</h2><span id='topic+confint.stdGee'></span>

<h3>Description</h3>

<p>This is a <code>confint</code> method for class <code>"stdGee"</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdGee'
confint(object, parm, level = 0.95, fun, type="plain", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.stdGee_+3A_object">object</code></td>
<td>

<p>an object of class <code>"stdGee"</code>.  
</p>
</td></tr> 
<tr><td><code id="confint.stdGee_+3A_parm">parm</code></td>
<td>

<p>not used.
</p>
</td></tr>
<tr><td><code id="confint.stdGee_+3A_level">level</code></td>
<td>

<p>the coverage probability of the confidence intervals. 
</p>
</td></tr>
<tr><td><code id="confint.stdGee_+3A_fun">fun</code></td>
<td>

<p>a function of one vector argument of length <code>p</code>, which returns a scalar. 
</p>
</td></tr>
<tr><td><code id="confint.stdGee_+3A_type">type</code></td>
<td>

<p>a string specifying the type of confidence interval; <code>plain</code> 
(for untransformed) or <code>log</code> (for log-transformed). 
</p>
</td></tr>
<tr><td><code id="confint.stdGee_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint.stdGee</code> extracts the <code>est</code> element from <code>object</code>, and 
inputs this to <code>fun</code>. It then uses the delta method to compute a confidence 
interval for the output of <code>fun</code>.   
</p>


<h3>Value</h3>

<p>a matrix with 1 row and 2 columns, containing the computed confidence interval. 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>

<hr>
<h2 id='confint.stdGlm'>
Confidence interval
</h2><span id='topic+confint.stdGlm'></span>

<h3>Description</h3>

<p>This is a <code>confint</code> method for class <code>"stdGlm"</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdGlm'
confint(object, parm, level = 0.95, fun, type="plain", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.stdGlm_+3A_object">object</code></td>
<td>

<p>an object of class <code>"stdGlm"</code>.  
</p>
</td></tr> 
<tr><td><code id="confint.stdGlm_+3A_parm">parm</code></td>
<td>

<p>not used.
</p>
</td></tr>
<tr><td><code id="confint.stdGlm_+3A_level">level</code></td>
<td>

<p>the coverage probability of the confidence intervals. 
</p>
</td></tr>
<tr><td><code id="confint.stdGlm_+3A_fun">fun</code></td>
<td>

<p>a function of one vector argument of length <code>p</code>, which returns a scalar. 
</p>
</td></tr>
<tr><td><code id="confint.stdGlm_+3A_type">type</code></td>
<td>

<p>a string specifying the type of confidence interval; <code>plain</code> 
(for untransformed) or <code>log</code> (for log-transformed). 
</p>
</td></tr>
<tr><td><code id="confint.stdGlm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint.stdGlm</code> extracts the <code>est</code> element from <code>object</code>, and 
inputs this to <code>fun</code>. It then uses the delta method to compute a confidence 
interval for the output of <code>fun</code>.   
</p>


<h3>Value</h3>

<p>a matrix with 1 row and 2 columns, containing the computed confidence interval. 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>

<hr>
<h2 id='confint.stdParfrailty'>
Confidence interval
</h2><span id='topic+confint.stdParfrailty'></span>

<h3>Description</h3>

<p>This is a <code>confint</code> method for class <code>"stdParfrailty"</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdParfrailty'
confint(object, parm, level = 0.95, fun, type="plain", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.stdParfrailty_+3A_object">object</code></td>
<td>

<p>an object of class <code>"stdParfrailty"</code>.  
</p>
</td></tr> 
<tr><td><code id="confint.stdParfrailty_+3A_parm">parm</code></td>
<td>

<p>not used.
</p>
</td></tr>
<tr><td><code id="confint.stdParfrailty_+3A_level">level</code></td>
<td>

<p>the coverage probability of the confidence intervals. 
</p>
</td></tr>
<tr><td><code id="confint.stdParfrailty_+3A_fun">fun</code></td>
<td>

<p>a function of one matrix argument with <code>q</code> rows and <code>p</code> columns, 
which returns a vector of length <code>q</code>. 
</p>
</td></tr>
<tr><td><code id="confint.stdParfrailty_+3A_type">type</code></td>
<td>

<p>a string specifying the type of confidence interval; <code>plain</code> 
(for untransformed) or <code>log</code> (for log-transformed). 
</p>
</td></tr>
<tr><td><code id="confint.stdParfrailty_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint.stdParfrailty</code> extracts the <code>est</code> element from <code>object</code>, and 
inputs this to <code>fun</code>. It then uses the delta method to compute a confidence 
interval for the output of <code>fun</code>.   
</p>


<h3>Value</h3>

<p>a matrix with <code>q</code> rows and 2 columns, containing the computed confidence interval. 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>

<hr>
<h2 id='parfrailty'>
Fits shared frailty gamma-Weibull models
</h2><span id='topic+parfrailty'></span>

<h3>Description</h3>

<p><code>parfrailty</code> fits shared frailty gamma-Weibull models. It is specifically 
designed to work with the function <code>stdParfrailty</code>, which performs regression 
standardization in shared frailty gamma-Weibull models.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parfrailty(formula, data, clusterid, init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parfrailty_+3A_formula">formula</code></td>
<td>

<p>an object of class &quot;<code>formula</code>&quot;, on the same format as accepted by the 
<code>coxph</code> function in the <span class="pkg">survival</span> package.  
</p>
</td></tr>  
<tr><td><code id="parfrailty_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. 
</p>
</td></tr>  
<tr><td><code id="parfrailty_+3A_clusterid">clusterid</code></td>
<td>

<p>an string containing the name of a cluster identification variable. 
</p>
</td></tr>
<tr><td><code id="parfrailty_+3A_init">init</code></td>
<td>

<p>an optional vector of initial values for the model parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parfrailty</code> fits the shared frailty gamma-Weibull model 
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t_{ij}|C_{ij})=\lambda(t_{ij};\alpha,\eta)U_iexp\{h(C_{ij};\beta)\},</code>
</p>

<p>where <code class="reqn">t_{ij}</code> and <code class="reqn">C_{ij}</code> are the survival time and covariate vector
for subject <code class="reqn">j</code> in cluster <code class="reqn">i</code>, respectively. <code class="reqn">\lambda(t;\alpha,\eta)</code> is the 
Weibull baseline hazard function
</p>
<p style="text-align: center;"><code class="reqn">\eta t^{\eta-1}\alpha^{-\eta},</code>
</p>
  
<p>where <code class="reqn">\eta</code> is the shape parameter and <code class="reqn">\alpha</code> is the scale parameter.
<code class="reqn">U_i</code> is the unobserved frailty term for cluster <code class="reqn">i</code>, which is assumed 
to have a gamma distribution with scale = 1/shape = <code class="reqn">\phi</code>. <code class="reqn">h(X;\beta)</code> 
is the regression function as specified by the <code>formula</code> argument, 
parametrized by a vector <code class="reqn">\beta</code>. The ML estimates 
<code class="reqn">\{log(\hat{\alpha}),log(\hat{\eta}),log(\hat{\phi}),\hat{\beta}\}</code> 
are obtained by maximizing the marginal (over <code class="reqn">U</code>) likelihood.  
</p>


<h3>Value</h3>

<p>An object of class <code>"parfrailty"</code> is a list containing:
</p>
<table>
<tr><td><code>est</code></td>
<td>

<p>the ML estimates <code class="reqn">\{log(\hat{\alpha}),log(\hat{\eta}),
log(\hat{\phi}),\hat{\beta}\}</code>.
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>the variance-covariance vector of the ML estimates.
</p>
</td></tr> 
<tr><td><code>score</code></td>
<td>

<p>a matrix containing the cluster-specific contributions to the ML score equations. 
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If left truncation is present, it is assumed that it is strong left truncation. 
This means that, even if the truncation time may be subject-specific, the whole 
cluster is unobserved if at least one subject in the cluster dies before 
his/her truncation time. If all subjects in the cluster survive beyond their 
subject-specific truncation times, then the whole cluster is observed 
(Van den Berg and Drepper, 2016). 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander and Elisabeth Dahlqwist. 
</p>


<h3>References</h3>

<p>Dahlqwist E., Pawitan Y., Sjolander A. (2019). Regression standardization 
and attributable fraction estimation with between-within frailty models for 
clustered survival data. <em>Statistical Methods in Medical Research</em> 
<b>28</b>(2), 462-485.
</p>
<p>Van den Berg G.J., Drepper B. (2016). Inference for shared frailty survival 
models with left-truncated data. <em>Econometric Reviews</em>, 35(6), 1075-1098.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(survival)

#simulate data
n &lt;- 1000
m &lt;- 3
alpha &lt;- 1.5
eta &lt;- 1
phi &lt;- 0.5
beta &lt;- 1
id &lt;- rep(1:n, each=m)
U &lt;- rep(rgamma(n, shape=1/phi,scale=phi), each=m)
X &lt;- rnorm(n*m)
#reparametrize scale as in rweibull function
weibull.scale &lt;- alpha/(U*exp(beta*X))^(1/eta)
T &lt;- rweibull(n*m, shape=eta, scale=weibull.scale)

#right censoring
C &lt;- runif(n*m, 0,10)
D &lt;- as.numeric(T&lt;C)
T &lt;- pmin(T, C)
             
#strong left-truncation
L &lt;- runif(n*m, 0, 2)
incl &lt;- T&gt;L
incl &lt;- ave(x=incl, id, FUN=sum)==m
dd &lt;- data.frame(L, T, D, X, id)
dd &lt;- dd[incl, ]  
 
fit &lt;- parfrailty(formula=Surv(L, T, D)~X, data=dd, clusterid="id")
print(summary(fit))


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.stdCoxph'>
Plots Cox regression standardization fit
</h2><span id='topic+plot.stdCoxph'></span>

<h3>Description</h3>

<p>This is a <code>plot</code> method for class <code>"stdCoxph"</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdCoxph'
plot(x, plot.CI = TRUE, CI.type = "plain", CI.level = 0.95,
  transform = NULL, contrast = NULL, reference = NULL, legendpos="bottomleft", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stdCoxph_+3A_x">x</code></td>
<td>

<p>an object of class <code>"stdCoxph"</code>.
</p>
</td></tr>
<tr><td><code id="plot.stdCoxph_+3A_plot.ci">plot.CI</code></td>
<td>

<p>logical, indicating whether confidence intervals should be added to the plot. 
</p>
</td></tr>
<tr><td><code id="plot.stdCoxph_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals. 
</p>
</td></tr>
<tr><td><code id="plot.stdCoxph_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, on decimal form. 
</p>
</td></tr>
<tr><td><code id="plot.stdCoxph_+3A_transform">transform</code></td>
<td>

<p>a string. If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized survival 
function <code class="reqn">\theta(t,x)</code> is transformed into <code class="reqn">\psi(t,x)=log\{\theta(t,x)\}</code>, 
<code class="reqn">\psi(t,x)=log[\theta(t,x)/\{1-\theta(t,x)\}]</code>, or 
<code class="reqn">\psi(t,x)=\theta(t,x)/\{1-\theta(t,x)\}</code>, respectively. If left unspecified, 
<code class="reqn">\psi(t,x)=\theta(t,x)</code>.  
</p>
</td></tr>
<tr><td><code id="plot.stdCoxph_+3A_contrast">contrast</code></td>
<td>

<p>a string. If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(t,x)-\psi(t,x_0)</code>
or <code class="reqn">\psi(t,x) / \psi(t,x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference 
level specified by the <code>reference</code> argument. 
</p>
</td></tr>
<tr><td><code id="plot.stdCoxph_+3A_reference">reference</code></td>
<td>

<p>must be specified if <code>contrast</code> is specified. 
</p>
</td></tr>
<tr><td><code id="plot.stdCoxph_+3A_legendpos">legendpos</code></td>
<td>

<p>position of the legend; see help for <code>legend</code>. 
</p>
</td></tr>
<tr><td><code id="plot.stdCoxph_+3A_...">...</code></td>
<td>

<p>further arguments passed on to plot.default. 
</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdCoxph">stdCoxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdCoxph

</code></pre>

<hr>
<h2 id='plot.stdGee'>
Plots GEE regression standardization fit
</h2><span id='topic+plot.stdGee'></span>

<h3>Description</h3>

<p>This is a <code>plot</code> method for class <code>"stdGee"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdGee'
plot(x, CI.type = "plain", CI.level = 0.95,
  transform = NULL, contrast = NULL, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stdGee_+3A_x">x</code></td>
<td>

<p>an object of class <code>"stdGee"</code>.
</p>
</td></tr>
<tr><td><code id="plot.stdGee_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals. 
</p>
</td></tr>
<tr><td><code id="plot.stdGee_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, on decimal form. 
</p>
</td></tr>
<tr><td><code id="plot.stdGee_+3A_transform">transform</code></td>
<td>

<p>a string. If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized 
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=log\{\theta(x)\}</code>, 
<code class="reqn">\psi(x)=log[\theta(x)/\{1-\theta(x)\}]</code>, or 
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively. If left unspecified, 
<code class="reqn">\psi(x)=\theta(x)</code>.  
</p>
</td></tr>
<tr><td><code id="plot.stdGee_+3A_contrast">contrast</code></td>
<td>

<p>a string. If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference 
level specified by the <code>reference</code> argument. 
</p>
</td></tr>
<tr><td><code id="plot.stdGee_+3A_reference">reference</code></td>
<td>

<p>must be specified if <code>contrast</code> is specified. 
</p>
</td></tr>
<tr><td><code id="plot.stdGee_+3A_...">...</code></td>
<td>

<p>further arguments passed on to plot.default. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdGee">stdGee</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdGee

</code></pre>

<hr>
<h2 id='plot.stdGlm'>
Plots GLM regression standardization fit
</h2><span id='topic+plot.stdGlm'></span>

<h3>Description</h3>

<p>This is a <code>plot</code> method for class <code>"stdGlm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdGlm'
plot(x, CI.type = "plain", CI.level = 0.95,
  transform = NULL, contrast = NULL, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stdGlm_+3A_x">x</code></td>
<td>

<p>an object of class <code>"stdGlm"</code>.
</p>
</td></tr>
<tr><td><code id="plot.stdGlm_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals. 
</p>
</td></tr>
<tr><td><code id="plot.stdGlm_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, on decimal form. 
</p>
</td></tr>
<tr><td><code id="plot.stdGlm_+3A_transform">transform</code></td>
<td>

<p>a string. If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized 
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=log\{\theta(x)\}</code>, 
<code class="reqn">\psi(x)=log[\theta(x)/\{1-\theta(x)\}]</code>, or 
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively. If left unspecified, 
<code class="reqn">\psi(x)=\theta(x)</code>.  
</p>
</td></tr>
<tr><td><code id="plot.stdGlm_+3A_contrast">contrast</code></td>
<td>

<p>a string. If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference 
level specified by the <code>reference</code> argument. 
</p>
</td></tr>
<tr><td><code id="plot.stdGlm_+3A_reference">reference</code></td>
<td>

<p>must be specified if <code>contrast</code> is specified. 
</p>
</td></tr>
<tr><td><code id="plot.stdGlm_+3A_...">...</code></td>
<td>

<p>further arguments passed on to plot.default. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdGlm">stdGlm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdGlm

</code></pre>

<hr>
<h2 id='plot.stdParfrailty'>
Plots parfrailty standardization fit
</h2><span id='topic+plot.stdParfrailty'></span>

<h3>Description</h3>

<p>This is a <code>plot</code> method for class <code>"stdParfrailty"</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdParfrailty'
plot(x, plot.CI = TRUE, CI.type = "plain", CI.level = 0.95,
  transform = NULL, contrast = NULL, reference = NULL, legendpos="bottomleft", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stdParfrailty_+3A_x">x</code></td>
<td>

<p>an object of class <code>"stdParfrailty"</code>.
</p>
</td></tr> 
<tr><td><code id="plot.stdParfrailty_+3A_plot.ci">plot.CI</code></td>
<td>

<p>logical, indicating whether confidence intervals should be added to the plot. 
</p>
</td></tr> 
<tr><td><code id="plot.stdParfrailty_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals. 
</p>
</td></tr>
<tr><td><code id="plot.stdParfrailty_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, on decimal form. 
</p>
</td></tr>
<tr><td><code id="plot.stdParfrailty_+3A_transform">transform</code></td>
<td>

<p>a string. If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized survival 
function <code class="reqn">\theta(t,x)</code> is transformed into <code class="reqn">\psi(t,x)=log\{\theta(t,x)\}</code>, 
<code class="reqn">\psi(t,x)=log[\theta(t,x)/\{1-\theta(t,x)\}]</code>, or 
<code class="reqn">\psi(t,x)=\theta(t,x)/\{1-\theta(t,x)\}</code>, respectively. If left unspecified, 
<code class="reqn">\psi(t,x)=\theta(t,x)</code>.  
</p>
</td></tr>
<tr><td><code id="plot.stdParfrailty_+3A_contrast">contrast</code></td>
<td>

<p>a string. If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(t,x)-\psi(t,x_0)</code>
or <code class="reqn">\psi(t,x) / \psi(t,x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference 
level specified by the <code>reference</code> argument. 
</p>
</td></tr>
<tr><td><code id="plot.stdParfrailty_+3A_reference">reference</code></td>
<td>

<p>must be specified if <code>contrast</code> is specified. 
</p>
</td></tr>
<tr><td><code id="plot.stdParfrailty_+3A_legendpos">legendpos</code></td>
<td>

<p>position of the legend; see help for <code>legend</code>. 
</p>
</td></tr>
<tr><td><code id="plot.stdParfrailty_+3A_...">...</code></td>
<td>

<p>further arguments passed on to plot.default. 
</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdParfrailty">stdParfrailty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdParfrailty

</code></pre>

<hr>
<h2 id='print.summary.parfrailty'>
Prints summary of parfrailty fit
</h2><span id='topic+print.summary.parfrailty'></span>

<h3>Description</h3>

<p>This is a <code>print</code> method for class <code>"summary.parfrailty"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.parfrailty'
print(x, digits = max(3L, getOption("digits") - 3L),
                             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.parfrailty_+3A_x">x</code></td>
<td>

<p>an object of class <code>"summary.parfrailty"</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.parfrailty_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to use when printing.
</p>
</td></tr>
<tr><td><code id="print.summary.parfrailty_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander and Elisabeth Dahlqwist
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parfrailty">parfrailty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for frailty

</code></pre>

<hr>
<h2 id='print.summary.stdCoxph'>
Prints summary of Cox regression standardization fit
</h2><span id='topic+print.summary.stdCoxph'></span>

<h3>Description</h3>

<p>This is a <code>print</code> method for class <code>"summary.stdCoxph"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.stdCoxph'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.stdCoxph_+3A_x">x</code></td>
<td>

<p>an object of class <code>"summary.stdCoxph"</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.stdCoxph_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdCoxph">stdCoxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdCoxph

</code></pre>

<hr>
<h2 id='print.summary.stdGee'>
Prints summary of GEE regression standardization fit
</h2><span id='topic+print.summary.stdGee'></span>

<h3>Description</h3>

<p>This is a <code>print</code> method for class <code>"summary.stdGee"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.stdGee'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.stdGee_+3A_x">x</code></td>
<td>

<p>an object of class <code>"summary.stdGee"</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.stdGee_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdGee">stdGee</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdGee

</code></pre>

<hr>
<h2 id='print.summary.stdGlm'>
Prints summary of GLM regression standardization fit
</h2><span id='topic+print.summary.stdGlm'></span>

<h3>Description</h3>

<p>This is a <code>print</code> method for class <code>"summary.stdGlm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.stdGlm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.stdGlm_+3A_x">x</code></td>
<td>

<p>an object of class <code>"summary.stdGlm"</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.stdGlm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdGlm">stdGlm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdGlm

</code></pre>

<hr>
<h2 id='print.summary.stdParfrailty'>
Prints summary of Frailty standardization fit
</h2><span id='topic+print.summary.stdParfrailty'></span>

<h3>Description</h3>

<p>This is a <code>print</code> method for class <code>"summary.stdParfrailty"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.stdParfrailty'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.stdParfrailty_+3A_x">x</code></td>
<td>

<p>an object of class <code>"summary.stdParfrailty"</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.stdParfrailty_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdParfrailty">stdParfrailty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdParfrailty

</code></pre>

<hr>
<h2 id='stdCoxph'>
Regression standardization in Cox proportional hazards models
</h2><span id='topic+stdCoxph'></span>

<h3>Description</h3>

<p><code>stdCoxph</code> performs regression standardization in Cox proportional hazards models,
at specified values of the exposure, over the sample covariate distribution.
Let <code class="reqn">T</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the survival outcome, the exposure, and a
vector of covariates, respectively. <code>stdCoxph</code> uses a fitted Cox 
proportional hazards model to estimate the standardized 
survival function <code class="reqn">\theta(t,x)=E\{S(t|X=x,Z)\}</code>, where <code class="reqn">t</code> is a specific value of <code class="reqn">T</code>, 
<code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, and the expectation is over the marginal 
distribution of <code class="reqn">Z</code>.     
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdCoxph(fit, data, X, x, t, clusterid, subsetnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdCoxph_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>"coxph"</code>, as returned by the <code>coxph</code> function 
in the <span class="pkg">survival</span> package, but without special terms <code>strata</code>, <code>cluster</code> or <code>tt</code>. 
Only <code>breslow</code> method for handling ties is allowed. If arguments 
<code>weights</code> and/or <code>subset</code> are used when fitting the model, 
then the same weights and subset are used in <code>stdGlm</code>.  
</p>
</td></tr>
<tr><td><code id="stdCoxph_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. This should be the same 
data frame as was used to fit the model in <code>fit</code>.
</p>
</td></tr>
<tr><td><code id="stdCoxph_+3A_x">X</code></td>
<td>

<p>a string containing the name of the exposure variable <code class="reqn">X</code> in <code>data</code>. 
</p>
</td></tr>
<tr><td><code id="stdCoxph_+3A_x">x</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">X</code> at which to estimate 
the standardized survival function. If <code class="reqn">X</code> is binary (0/1) or
a factor, then <code>x</code> defaults to all values of <code class="reqn">X</code>. If <code class="reqn">X</code> is numeric,
then <code>x</code> defaults to the mean of <code class="reqn">X</code>. If <code>x</code> is set to <code>NA</code>,
then <code class="reqn">X</code> is not altered. This produces an estimate of the marginal survival 
function <code class="reqn">S(t)=E\{S(t|X,Z)\}</code>.   
</p>
</td></tr>
<tr><td><code id="stdCoxph_+3A_t">t</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">T</code> at which to estimate 
the standardized survival function. It defaults to all the observed event times
in <code>data</code>. 
</p>
</td></tr>
<tr><td><code id="stdCoxph_+3A_clusterid">clusterid</code></td>
<td>

<p>an optional string containing the name of a cluster identification variable when data are clustered.
</p>
</td></tr>
<tr><td><code id="stdCoxph_+3A_subsetnew">subsetnew</code></td>
<td>

<p>an optional logical statement specifying a subset of observations to be used in 
the standardization. This set is assumed to be a subset of the subset (if any)
that was used to fit the regression model. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stdCoxph</code> assumes that a Cox proportional hazards model 
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t|X,Z)=\lambda_0(t)exp\{h(X,Z;\beta)\}</code>
</p>

<p>has been fitted. Breslow's 
estimator of the cumulative baseline hazard <code class="reqn">\Lambda_0(t)=\int_0^t\lambda_0(u)du</code>
is used together with the partial likelihood estimate of <code class="reqn">\beta</code> to obtain 
estimates of the survival function <code class="reqn">S(t|X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t|X=x,Z)=exp[-\hat{\Lambda}_0(t)exp\{h(X=x,Z;\hat{\beta})\}].</code>
</p>
 
<p>For each <code class="reqn">t</code> in the <code>t</code> argument and for each <code class="reqn">x</code> in the <code>x</code> argument, 
these estimates are averaged across all subjects (i.e. all observed values of <code class="reqn">Z</code>)
to produce estimates 
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(t,x)=\sum_{i=1}^n \hat{S}(t|X=x,Z_i)/n,</code>
</p>
 
<p>where <code class="reqn">Z_i</code> is the value of <code class="reqn">Z</code> for subject <code class="reqn">i</code>, <code class="reqn">i=1,...,n</code>. 
The variance for <code class="reqn">\hat{\theta}(t,x)</code> is obtained by the sandwich formula. 
</p>


<h3>Value</h3>

<p>An object of class <code>"stdCoxph"</code> is a list containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments.     
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>a matrix with <code>length(t)</code> rows and <code>length(x)</code> columns, where the element 
on row <code>i</code> and column <code>j</code> is equal to <code class="reqn">\hat{\theta}</code>(<code>t[i],x[j]</code>). 
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>a list with <code>length(t)</code> elements. Each element is a square matrix with 
<code>length(x)</code> rows. In the <code>k:th</code> matrix, the element on row <code>i</code> 
and column <code>j</code> is the (estimated) covariance of <code class="reqn">\hat{\theta}</code>(<code>t[k]</code>,<code>x[i]</code>) 
and <code class="reqn">\hat{\theta}</code>(<code>t[k]</code>,<code>x[j]</code>).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Standardized survival functions are sometimes referred to as (direct) adjusted
survival functions in the literature.
</p>
<p><code>stdCoxph</code> does not currently handle time-varying exposures or covariates. 
</p>
<p><code>stdCoxph</code> internally loops over all values in the <code>t</code> argument. Therefore,
the function will usually be considerably faster if <code>length(t)</code> is small.
</p>
<p>The variance calculation performed by <code>stdCoxph</code> does not condition on 
the observed covariates <code class="reqn">\bar{Z}=(Z_1,...,Z_n)</code>. To see how this matters, 
note that 
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(t,x)\}=E[var\{\hat{\theta}(t,x)|\bar{Z}\}]+var[E\{\hat{\theta}(t,x)|\bar{Z}\}].</code>
</p>
 
<p>The usual parameter <code class="reqn">\beta</code> in a Cox proportional hazards model does not 
depend on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is independent of 
<code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that the 
term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance 
decomposition for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However, 
<code class="reqn">\theta(t,x)</code> depends on <code class="reqn">\bar{Z}</code> through the average over the sample 
distribution for <code class="reqn">Z</code>, and thus the term <code class="reqn">var[E\{\hat{\theta}(t,x)|\bar{Z}\}]</code> 
is not 0, unless one conditions on <code class="reqn">\bar{Z}</code>. The variance calculation by 
Gail and Byar (1986) ignores this term, and thus effectively conditions on 
<code class="reqn">\bar{Z}</code>.      
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>References</h3>

<p>Chang I.M., Gelman G., Pagano M. (1982). Corrected group prognostic curves
and summary statistics. <em>Journal of Chronic Diseases</em> <b>35</b>, 669-674.
</p>
<p>Gail M.H. and Byar D.P. (1986). Variance calculations for direct adjusted survival
curves, with applications to testing for no treatment effect. <em>Biometrical Journal</em>
<b>28</b>(5), 587-599. 
</p>
<p>Makuch R.W. (1982). Adjusted survival curve estimation using covariates.
<em>Journal of Chronic Diseases</em> <b>35</b>, 437-443.
</p>
<p>Sjolander A. (2016). Regression standardization with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>31</b>(6), 563-574.
</p>
<p>Sjolander A. (2016). Estimation of causal effect measures with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>33</b>(9), 847-858.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(survival)

n &lt;- 1000
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean=Z)
T &lt;- rexp(n, rate=exp(X+Z+X*Z)) #survival time
C &lt;- rexp(n, rate=exp(X+Z+X*Z)) #censoring time
U &lt;- pmin(T, C) #time at risk
D &lt;- as.numeric(T &lt; C) #event indicator
dd &lt;- data.frame(Z, X, U, D)
fit &lt;- coxph(formula=Surv(U, D)~X+Z+X*Z, data=dd, method="breslow")
fit.std &lt;- stdCoxph(fit=fit, data=dd, X="X", x=seq(-1,1,0.5), t=1:5)
print(summary(fit.std, t=3))
plot(fit.std)

</code></pre>

<hr>
<h2 id='stdGee'>
Regression standardization in conditional generalized estimating equations
</h2><span id='topic+stdGee'></span>

<h3>Description</h3>

<p><code>stdGee</code> performs regression standardization in linear and log-linear 
fixed effects models, at specified values of the exposure, over the sample 
covariate distribution. Let <code class="reqn">Y</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the outcome, 
the exposure, and a vector of covariates, respectively. It is assumed that data
are clustered with a cluster indicator <code class="reqn">i</code>. <code>stdGee</code> uses 
fitted fixed effects model, with cluster-specific intercept <code class="reqn">a_i</code> 
(see <code>details</code>), to estimate the standardized mean 
<code class="reqn">\theta(x)=E\{E(Y|i,X=x,Z)\}</code>, where <code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, 
and the outer expectation is over the marginal distribution of <code class="reqn">(a_i,Z)</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdGee(fit, data, X, x, clusterid, subsetnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdGee_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>"gee"</code>, with argument <code>cond = TRUE</code>, as returned 
by the <code>gee</code> function in the <span class="pkg">drgee</span> package. If arguments 
<code>weights</code> and/or <code>subset</code> are used when fitting the model, then the 
same weights and subset are used in <code>stdGee</code>.  
</p>
</td></tr> 
<tr><td><code id="stdGee_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. This should be the same 
data frame as was used to fit the model in <code>fit</code>.
</p>
</td></tr>
<tr><td><code id="stdGee_+3A_x">X</code></td>
<td>

<p>a string containing the name of the exposure variable <code class="reqn">X</code> in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="stdGee_+3A_x">x</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">X</code> at which to estimate 
the standardized mean. If <code class="reqn">X</code> is binary (0/1) or
a factor, then <code>x</code> defaults to all values of <code class="reqn">X</code>. If <code class="reqn">X</code> is numeric,
then <code>x</code> defaults to the mean of <code class="reqn">X</code>. If <code>x</code> is set to <code>NA</code>,
then <code class="reqn">X</code> is not altered. This produces an estimate of the marginal mean
<code class="reqn">E(Y)=E\{E(Y|X,Z)\}</code>. 
</p>
</td></tr>
<tr><td><code id="stdGee_+3A_clusterid">clusterid</code></td>
<td>

<p>an mandatory string containing the name of a cluster identification variable.
Must be identical to the clusterid variable used in the gee call. 
</p>
</td></tr>
<tr><td><code id="stdGee_+3A_subsetnew">subsetnew</code></td>
<td>

<p>an optional logical statement specifying a subset of observations to be used in 
the standardization. This set is assumed to be a subset of the subset (if any)
that was used to fit the regression model. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stdGee</code> assumes that a fixed effects model 
</p>
<p style="text-align: center;"><code class="reqn">\eta\{E(Y|i,X,Z)\}=a_i+h(X,Z;\beta)</code>
</p>
 
<p>has been fitted. The link function <code class="reqn">\eta</code> is assumed to be the identity link
or the log link. The conditional generalized estimating equation (CGGE)
estimate of <code class="reqn">\beta</code> is used to obtain estimates of the cluster-specific 
means:
</p>
<p style="text-align: center;"><code class="reqn">\hat{a}_i=\sum_{j=1}^{n_i}r_{ij}/n_i,</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">r_{ij}=Y_{ij}-h(X_{ij},Z_{ij};\hat{\beta})</code>
</p>

<p>if <code class="reqn">\eta</code> is the identity link, and
</p>
<p style="text-align: center;"><code class="reqn">r_{ij}=Y_{ij}exp\{-h(X_{ij},Z_{ij};\hat{\beta})\}</code>
</p>

<p>if <code class="reqn">\eta</code> is the log link, and <code class="reqn">(X_{ij},Z_{ij})</code> is the value of 
<code class="reqn">(X,Z)</code> for subject <code class="reqn">j</code> in cluster <code class="reqn">i</code>, <code class="reqn">j=1,...,n_i</code>, 
<code class="reqn">i=1,...,n</code>. The CGEE estimate of <code class="reqn">\beta</code> and the estimate of 
<code class="reqn">a_i</code> are used to estimate the mean <code class="reqn">E(Y|i,X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{E}(Y|i,X=x,Z)=\eta^{-1}\{\hat{a}_i+h(X=x,Z;\hat{\beta})\}.</code>
</p>
 
<p>For each <code class="reqn">x</code> in the <code>x</code> argument, these estimates are averaged across 
all subjects (i.e. all observed values of <code class="reqn">Z</code> and all estimated values of 
<code class="reqn">a_i</code>) to produce estimates  
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(x)=\sum_{i=1}^n \sum_{j=1}^{n_i} \hat{E}(Y|i,X=x,Z_i)/N,</code>
</p>

<p>where <code class="reqn">N=\sum_{i=1}^n n_i</code>. The variance for <code class="reqn">\hat{\theta}(x)</code> is 
obtained by the sandwich formula. 
</p>


<h3>Value</h3>

<p>An object of class <code>"stdGee"</code> is a list containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments.     
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>a vector with length equal to <code>length(x)</code>, where element <code>j</code> is equal to 
<code class="reqn">\hat{\theta}</code>(<code>x[j]</code>).
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>a square matrix with <code>length(x)</code> rows, where the element 
on row <code>i</code> and column <code>j</code> is the (estimated) covariance of 
<code class="reqn">\hat{\theta}</code>(<code>x[i]</code>) and 
<code class="reqn">\hat{\theta}</code>(<code>x[j]</code>).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The variance calculation performed by <code>stdGee</code> does not condition on 
the observed covariates <code class="reqn">\bar{Z}=(Z_{11},...,Z_{nn_i})</code>. To see how this 
matters, note that 
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(x)\}=E[var\{\hat{\theta}(x)|\bar{Z}\}]+var[E\{\hat{\theta}(x)|\bar{Z}\}].</code>
</p>
 
<p>The usual parameter <code class="reqn">\beta</code> in a generalized linear model does not depend 
on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is 
independent of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), 
so that the term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding 
variance decomposition for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However, 
<code class="reqn">\theta(x)</code> depends on <code class="reqn">\bar{Z}</code> through the average over the sample 
distribution for <code class="reqn">Z</code>, and thus the term <code class="reqn">var[E\{\hat{\theta}(x)|\bar{Z}\}]</code> 
is not 0, unless one conditions on <code class="reqn">\bar{Z}</code>. 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Goetgeluk S. and Vansteelandt S. (2008). Conditional generalized estimating 
equations for the analysis of clustered and longitudinal data. 
<em>Biometrics</em> <b>64</b>(3), 772-780.
</p>
<p>Martin R.S. (2017). Estimation of average marginal effects in multiplicative 
unobserved effects panel models. <em>Economics Letters</em> <b>160</b>, 16-19.
</p>
<p>Sjolander A. (2019). Estimation of marginal causal effects in the presence of 
confounding by cluster. <em>Biostatistics</em> doi: 10.1093/biostatistics/kxz054
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(drgee)

n &lt;- 1000
ni &lt;- 2
id &lt;- rep(1:n, each=ni)
ai &lt;- rep(rnorm(n), each=ni)
Z &lt;- rnorm(n*ni)
X &lt;- rnorm(n*ni, mean=ai+Z)
Y &lt;- rnorm(n*ni, mean=ai+X+Z+0.1*X^2)
dd &lt;- data.frame(id, Z, X, Y)
fit &lt;- gee(formula=Y~X+Z+I(X^2), data=dd, clusterid="id", link="identity",
  cond=TRUE)
fit.std &lt;- stdGee(fit=fit, data=dd, X="X", x=seq(-3,3,0.5), clusterid="id")
print(summary(fit.std, contrast="difference", reference=2))
plot(fit.std)

</code></pre>

<hr>
<h2 id='stdGlm'>
Regression standardization in generalized linear models
</h2><span id='topic+stdGlm'></span>

<h3>Description</h3>

<p><code>stdGlm</code> performs regression standardization in generalized linear models,
at specified values of the exposure, over the sample covariate distribution.
Let <code class="reqn">Y</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the outcome, the exposure, and a
vector of covariates, respectively. <code>stdGlm</code> uses a fitted generalized linear
model to estimate the standardized 
mean <code class="reqn">\theta(x)=E\{E(Y|X=x,Z)\}</code>, where <code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, 
and the outer expectation is over the marginal distribution of <code class="reqn">Z</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdGlm(fit, data, X, x, clusterid, case.control = FALSE, subsetnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdGlm_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. If arguments <code>weights</code> and/or <code>subset</code>
are used when fitting the model, then the same weights and subset are used 
in <code>stdGlm</code>.  
</p>
</td></tr> 
<tr><td><code id="stdGlm_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. This should be the same 
data frame as was used to fit the model in <code>fit</code>.
</p>
</td></tr>
<tr><td><code id="stdGlm_+3A_x">X</code></td>
<td>

<p>a string containing the name of the exposure variable <code class="reqn">X</code> in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="stdGlm_+3A_x">x</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">X</code> at which to estimate 
the standardized mean. If <code class="reqn">X</code> is binary (0/1) or
a factor, then <code>x</code> defaults to all values of <code class="reqn">X</code>. If <code class="reqn">X</code> is numeric,
then <code>x</code> defaults to the mean of <code class="reqn">X</code>. If <code>x</code> is set to <code>NA</code>,
then <code class="reqn">X</code> is not altered. This produces an estimate of the marginal mean
<code class="reqn">E(Y)=E\{E(Y|X,Z)\}</code>. 
</p>
</td></tr>
<tr><td><code id="stdGlm_+3A_clusterid">clusterid</code></td>
<td>

<p>an optional string containing the name of a cluster identification variable when data are clustered. 
</p>
</td></tr>
<tr><td><code id="stdGlm_+3A_case.control">case.control</code></td>
<td>

<p>logical. Do data come from a case-control study? Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="stdGlm_+3A_subsetnew">subsetnew</code></td>
<td>

<p>an optional logical statement specifying a subset of observations to be used in 
the standardization. This set is assumed to be a subset of the subset (if any)
that was used to fit the regression model. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stdGlm</code> assumes that a generalized linear model 
</p>
<p style="text-align: center;"><code class="reqn">\eta\{E(Y|X,Z)\}=h(X,Z;\beta)</code>
</p>

<p>has been fitted. The maximum likelihood estimate of <code class="reqn">\beta</code> is used to obtain 
estimates of the mean <code class="reqn">E(Y|X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{E}(Y|X=x,Z)=\eta^{-1}\{h(X=x,Z;\hat{\beta})\}.</code>
</p>
 
<p>For each <code class="reqn">x</code> in the <code>x</code> argument, these estimates are averaged across 
all subjects (i.e. all observed values of <code class="reqn">Z</code>) to produce estimates  
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(x)=\sum_{i=1}^n \hat{E}(Y|X=x,Z_i)/n,</code>
</p>
 
<p>where <code class="reqn">Z_i</code> is the value of <code class="reqn">Z</code> for subject <code class="reqn">i</code>, <code class="reqn">i=1,...,n</code>.
The variance for <code class="reqn">\hat{\theta}(x)</code> is obtained by the sandwich formula. 
</p>


<h3>Value</h3>

<p>An object of class <code>"stdGlm"</code> is a list containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments.     
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>a vector with length equal to <code>length(x)</code>, where element <code>j</code> is equal to 
<code class="reqn">\hat{\theta}</code>(<code>x[j]</code>).
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>a square matrix with <code>length(x)</code> rows, where the element 
on row <code>i</code> and column <code>j</code> is the (estimated) covariance of 
<code class="reqn">\hat{\theta}</code>(<code>x[i]</code>) and 
<code class="reqn">\hat{\theta}</code>(<code>x[j]</code>).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The variance calculation performed by <code>stdGlm</code> does not condition on 
the observed covariates <code class="reqn">\bar{Z}=(Z_1,...,Z_n)</code>. To see how this matters, note that 
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(x)\}=E[var\{\hat{\theta}(x)|\bar{Z}\}]+var[E\{\hat{\theta}(x)|\bar{Z}\}].</code>
</p>
 
<p>The usual parameter <code class="reqn">\beta</code> in a generalized linear model does not depend 
on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is 
independent of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that the 
term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance decomposition 
for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However, <code class="reqn">\theta(x)</code> depends 
on <code class="reqn">\bar{Z}</code> through the average over the sample distribution for <code class="reqn">Z</code>, 
and thus the term <code class="reqn">var[E\{\hat{\theta}(x)|\bar{Z}\}]</code> is not 0, unless one 
conditions on <code class="reqn">\bar{Z}</code>. 
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Rothman K.J., Greenland S., Lash T.L. (2008). <em>Modern Epidemiology</em>, 3rd edition. 
Lippincott, Williams \&amp; Wilkins.
</p>
<p>Sjolander A. (2016). Regression standardization with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>31</b>(6), 563-574.
</p>
<p>Sjolander A. (2016). Estimation of causal effect measures with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>33</b>(9), 847-858.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Example 1: continuous outcome
n &lt;- 1000
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean=Z)
Y &lt;- rnorm(n, mean=X+Z+0.1*X^2)
dd &lt;- data.frame(Z, X, Y)
fit &lt;- glm(formula=Y~X+Z+I(X^2), data=dd)
fit.std &lt;- stdGlm(fit=fit, data=dd, X="X", x=seq(-3,3,0.5))
print(summary(fit.std))
plot(fit.std)

##Example 2: binary outcome
n &lt;- 1000
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean=Z)
Y &lt;- rbinom(n, 1, prob=(1+exp(X+Z))^(-1))
dd &lt;- data.frame(Z, X, Y)
fit &lt;- glm(formula=Y~X+Z+X*Z, family="binomial", data=dd)
fit.std &lt;- stdGlm(fit=fit, data=dd, X="X", x=seq(-3,3,0.5))
print(summary(fit.std))
plot(fit.std)
</code></pre>

<hr>
<h2 id='stdParfrailty'>
Regression standardization in shared frailty gamma-Weibull models
</h2><span id='topic+stdParfrailty'></span>

<h3>Description</h3>

<p><code>stdParfrailty</code> performs regression standardization in shared frailty gamma-Weibull models,
at specified values of the exposure, over the sample covariate distribution.
Let <code class="reqn">T</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the survival outcome, the exposure, and a
vector of covariates, respectively. <code>stdParfrailty</code> uses a fitted Cox 
proportional hazards model to estimate the standardized 
survival function <code class="reqn">\theta(t,x)=E\{S(t|X=x,Z)\}</code>, where <code class="reqn">t</code> is a specific value of <code class="reqn">T</code>, 
<code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, and the expectation is over the marginal 
distribution of <code class="reqn">Z</code>.     
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdParfrailty(fit, data, X, x, t, clusterid, subsetnew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdParfrailty_+3A_fit">fit</code></td>
<td>

<p>an object of class <code>"parfrailty"</code>, as returned by the <code>parfrailty</code> function 
in the <span class="pkg">stdReg</span> package.  
</p>
</td></tr>
<tr><td><code id="stdParfrailty_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. This should be the same 
data frame as was used to fit the model in <code>fit</code>.
</p>
</td></tr>
<tr><td><code id="stdParfrailty_+3A_x">X</code></td>
<td>

<p>a string containing the name of the exposure variable <code class="reqn">X</code> in <code>data</code>. 
</p>
</td></tr>
<tr><td><code id="stdParfrailty_+3A_x">x</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">X</code> at which to estimate 
the standardized survival function. If <code class="reqn">X</code> is binary (0/1) or
a factor, then <code>x</code> defaults to all values of <code class="reqn">X</code>. If <code class="reqn">X</code> is numeric,
then <code>x</code> defaults to the mean of <code class="reqn">X</code>. If <code>x</code> is set to <code>NA</code>,
then <code class="reqn">X</code> is not altered. This produces an estimate of the marginal survival 
function <code class="reqn">S(t)=E\{S(t|X,Z)\}</code>. 
</p>
</td></tr>
<tr><td><code id="stdParfrailty_+3A_t">t</code></td>
<td>

<p>an optional vector containing the specific values of <code class="reqn">T</code> at which to estimate 
the standardized survival function. It defaults to all the observed event times
in <code>data</code>. 
</p>
</td></tr>
<tr><td><code id="stdParfrailty_+3A_clusterid">clusterid</code></td>
<td>

<p>a string containing the name of the cluster identification variable.
</p>
</td></tr>
<tr><td><code id="stdParfrailty_+3A_subsetnew">subsetnew</code></td>
<td>

<p>an optional logical statement specifying a subset of observations to be used in 
the standardization. This set is assumed to be a subset of the subset (if any)
that was used to fit the regression model. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stdParfrailty</code> assumes that a shared frailty gamma-Weibull model 
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t_{ij}|X_{ij},Z_{ij})=\lambda(t_{ij};\alpha,\eta)U_iexp\{h(X_{ij},Z_{ij};\beta)\}</code>
</p>

<p>has been fitted, with parametrization as descibed in the help section for <code>parfrailty</code>.
Integrating out the gamma frailty gives the survival function
</p>
<p style="text-align: center;"><code class="reqn">S(t|X,Z)=[1+\phi\Lambda_0(t;\alpha,\eta)exp\{h(X,Z;\beta)\}]^{-1/\phi},</code>
</p>

<p>where <code class="reqn">\Lambda_0(t;\alpha,\eta)</code> is the cumulative baseline hazard
</p>
<p style="text-align: center;"><code class="reqn">(t/\alpha)^{\eta}.</code>
</p>

<p>The ML estimates of <code class="reqn">(\alpha,\eta,\phi,\beta)</code> are used to obtain 
estimates of the survival function <code class="reqn">S(t|X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t|X=x,Z)=[1+\hat{\phi}\Lambda_0(t;\hat{\alpha},\hat{\eta})exp\{h(X,Z;\hat{\beta})\}]^{-1/\hat{\phi}}.</code>
</p>
 
<p>For each <code class="reqn">t</code> in the <code>t</code> argument and for each <code class="reqn">x</code> in the <code>x</code> argument, 
these estimates are averaged across all subjects (i.e. all observed values of <code class="reqn">Z</code>)
to produce estimates 
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(t,x)=\sum_{i=1}^n \hat{S}(t|X=x,Z_i)/n.</code>
</p>
 
<p>The variance for <code class="reqn">\hat{\theta}(t,x)</code> is obtained by the sandwich formula. 
</p>


<h3>Value</h3>

<p>An object of class <code>"stdParfrailty"</code> is a list containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments.     
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>a matrix with <code>length(t)</code> rows and <code>length(x)</code> columns, where the element 
on row <code>i</code> and column <code>j</code> is equal to <code class="reqn">\hat{\theta}</code>(<code>t[i],x[j]</code>). 
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>a list with <code>length(t)</code> elements. Each element is a square matrix with 
<code>length(x)</code> rows. In the <code>k:th</code> matrix, the element on row <code>i</code> 
and column <code>j</code> is the (estimated) covariance of <code class="reqn">\hat{\theta}</code>(<code>t[k]</code>,<code>x[i]</code>) 
and <code class="reqn">\hat{\theta}</code>(<code>t[k]</code>,<code>x[j]</code>).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Standardized survival functions are sometimes referred to as (direct) adjusted
survival functions in the literature.
</p>
<p><code>stdParfrailty</code> does not currently handle time-varying exposures or covariates. 
</p>
<p><code>stdParfrailty</code> internally loops over all values in the <code>t</code> argument. Therefore,
the function will usually be considerably faster if <code>length(t)</code> is small.
</p>
<p>The variance calculation performed by <code>stdParfrailty</code> does not condition on 
the observed covariates <code class="reqn">\bar{Z}=(Z_1,...,Z_n)</code>. To see how this matters, note that 
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(t,x)\}=E[var\{\hat{\theta}(t,x)|\bar{Z}\}]+var[E\{\hat{\theta}(t,x)|\bar{Z}\}].</code>
</p>
 
<p>The usual parameter <code class="reqn">\beta</code> in a Cox proportional hazards model does not depend 
on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is 
independent of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that the 
term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance decomposition 
for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However, <code class="reqn">\theta(t,x)</code> depends 
on <code class="reqn">\bar{Z}</code> through the average over the sample distribution for <code class="reqn">Z</code>, 
and thus the term <code class="reqn">var[E\{\hat{\theta}(t,x)|\bar{Z}\}]</code> is not 0, unless one 
conditions on <code class="reqn">\bar{Z}</code>. The variance calculation by Gail and Byar (1986) ignores this term,
and thus effectively conditions on <code class="reqn">\bar{Z}</code>.      
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>References</h3>

<p>Chang I.M., Gelman G., Pagano M. (1982). Corrected group prognostic curves
and summary statistics. <em>Journal of Chronic Diseases</em> <b>35</b>, 669-674.
</p>
<p>Dahlqwist E., Pawitan Y., Sjolander A. (2019). Regression standardization 
and attributable fraction estimation with between-within frailty models for 
clustered survival data. <em>Statistical Methods in Medical Research</em> 
<b>28</b>(2), 462-485.
</p>
<p>Gail M.H. and Byar D.P. (1986). Variance calculations for direct adjusted survival
curves, with applications to testing for no treatement effect. <em>Biometrical Journal</em>
<b>28</b>(5), 587-599. 
</p>
<p>Makuch R.W. (1982). Adjusted survival curve estimation using covariates.
<em>Journal of Chronic Diseases</em> <b>35</b>, 437-443.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(survival)

#simulate data
n &lt;- 1000
m &lt;- 3
alpha &lt;- 1.5
eta &lt;- 1
phi &lt;- 0.5
beta &lt;- 1
id &lt;- rep(1:n, each=m)
U &lt;- rep(rgamma(n, shape=1/phi, scale=phi), each=m)
X &lt;- rnorm(n*m)
#reparametrize scale as in rweibull function
weibull.scale &lt;- alpha/(U*exp(beta*X))^(1/eta)
T &lt;- rweibull(n*m, shape=eta, scale=weibull.scale)

#right censoring
C &lt;- runif(n*m, 0, 10)
D &lt;- as.numeric(T&lt;C)
T &lt;- pmin(T, C)
  
#strong left-truncation
L &lt;- runif(n*m, 0, 2)
incl &lt;- T&gt;L
incl &lt;- ave(x=incl, id, FUN=sum)==m
dd &lt;- data.frame(L, T, D, X, id)
dd &lt;- dd[incl, ]  
 
fit &lt;- parfrailty(formula=Surv(L, T, D)~X, data=dd, clusterid="id")
fit.std &lt;- stdParfrailty(fit=fit, data=dd, X="X", x=seq(-1,1,0.5), t=1:5, clusterid="id")
print(summary(fit.std, t=3))
plot(fit.std)


## End(Not run)

</code></pre>

<hr>
<h2 id='summary.parfrailty'>
Summarizes parfrailty fit
</h2><span id='topic+summary.parfrailty'></span>

<h3>Description</h3>

<p>This is a <code>summary</code> method for class <code>"parfrailty"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parfrailty'
summary(object, CI.type = "plain", CI.level = 0.95, 
  digits=max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.parfrailty_+3A_object">object</code></td>
<td>

<p>an object of class <code>"parfrailty"</code>.
</p>
</td></tr>
<tr><td><code id="summary.parfrailty_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals.
</p>
</td></tr>
<tr><td><code id="summary.parfrailty_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, in decimal form. 
</p>
</td></tr>
<tr><td><code id="summary.parfrailty_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to use when printing..  
</p>
</td></tr>
<tr><td><code id="summary.parfrailty_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander and Elisabeth Dahlqwist.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parfrailty">parfrailty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for frailty

</code></pre>

<hr>
<h2 id='summary.stdCoxph'>
Summarizes Cox regression standardization fit
</h2><span id='topic+summary.stdCoxph'></span>

<h3>Description</h3>

<p>This is a <code>summary</code> method for class <code>"stdCoxph"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdCoxph'
summary(object, t, CI.type = "plain", CI.level = 0.95,
  transform = NULL, contrast = NULL, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stdCoxph_+3A_object">object</code></td>
<td>

<p>an object of class <code>"stdCoxph"</code>.
</p>
</td></tr>
<tr><td><code id="summary.stdCoxph_+3A_t">t</code></td>
<td>

<p>numeric, indicating the times at which to summarize. It defaults to the specified 
value(s) of the argument <code>t</code> in the <code>stdCox</code> function.   
</p>
</td></tr>
<tr><td><code id="summary.stdCoxph_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals.
</p>
</td></tr>
<tr><td><code id="summary.stdCoxph_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, on decimal form. 
</p>
</td></tr>
<tr><td><code id="summary.stdCoxph_+3A_transform">transform</code></td>
<td>

<p>a string. If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized survival 
function <code class="reqn">\theta(t,x)</code> is transformed into <code class="reqn">\psi(t,x)=log\{\theta(t,x)\}</code>, 
<code class="reqn">\psi(t,x)=log[\theta(t,x)/\{1-\theta(t,x)\}]</code>, or 
<code class="reqn">\psi(t,x)=\theta(t,x)/\{1-\theta(t,x)\}</code>, respectively. If left unspecified, 
<code class="reqn">\psi(t,x)=\theta(t,x)</code>.  
</p>
</td></tr>
<tr><td><code id="summary.stdCoxph_+3A_contrast">contrast</code></td>
<td>

<p>a string. If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(t,x)-\psi(t,x_0)</code>
or <code class="reqn">\psi(t,x) / \psi(t,x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference 
level specified by the <code>reference</code> argument. 
</p>
</td></tr>
<tr><td><code id="summary.stdCoxph_+3A_reference">reference</code></td>
<td>

<p>must be specified if <code>contrast</code> is specified. 
</p>
</td></tr>
<tr><td><code id="summary.stdCoxph_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdCoxph">stdCoxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdCoxph

</code></pre>

<hr>
<h2 id='summary.stdGee'>
Summarizes GEE regression standardization fit
</h2><span id='topic+summary.stdGee'></span>

<h3>Description</h3>

<p>This is a <code>summary</code> method for class <code>"stdGee"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdGee'
summary(object, CI.type = "plain", CI.level = 0.95,
  transform = NULL, contrast = NULL, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stdGee_+3A_object">object</code></td>
<td>

<p>an object of class <code>"stdGee"</code>.
</p>
</td></tr> 
<tr><td><code id="summary.stdGee_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals.
</p>
</td></tr>
<tr><td><code id="summary.stdGee_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, on decimal form. 
</p>
</td></tr>
<tr><td><code id="summary.stdGee_+3A_transform">transform</code></td>
<td>

<p>a string. If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized 
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=log\{\theta(x)\}</code>, 
<code class="reqn">\psi(x)=log[\theta(x)/\{1-\theta(x)\}]</code>, or 
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively. If left unspecified, 
<code class="reqn">\psi(x)=\theta(x)</code>.  
</p>
</td></tr>
<tr><td><code id="summary.stdGee_+3A_contrast">contrast</code></td>
<td>

<p>a string. If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference 
level specified by the <code>reference</code> argument. 
</p>
</td></tr>
<tr><td><code id="summary.stdGee_+3A_reference">reference</code></td>
<td>

<p>must be specified if <code>contrast</code> is specified. 
</p>
</td></tr>
<tr><td><code id="summary.stdGee_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdGee">stdGee</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdGee

</code></pre>

<hr>
<h2 id='summary.stdGlm'>
Summarizes GLM regression standardization fit
</h2><span id='topic+summary.stdGlm'></span>

<h3>Description</h3>

<p>This is a <code>summary</code> method for class <code>"stdGlm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdGlm'
summary(object, CI.type = "plain", CI.level = 0.95,
  transform = NULL, contrast = NULL, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stdGlm_+3A_object">object</code></td>
<td>

<p>an object of class <code>"stdGlm"</code>.
</p>
</td></tr> 
<tr><td><code id="summary.stdGlm_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals.
</p>
</td></tr>
<tr><td><code id="summary.stdGlm_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, on decimal form. 
</p>
</td></tr>
<tr><td><code id="summary.stdGlm_+3A_transform">transform</code></td>
<td>

<p>a string. If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized 
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=log\{\theta(x)\}</code>, 
<code class="reqn">\psi(x)=log[\theta(x)/\{1-\theta(x)\}]</code>, or 
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively. If left unspecified, 
<code class="reqn">\psi(x)=\theta(x)</code>.  
</p>
</td></tr>
<tr><td><code id="summary.stdGlm_+3A_contrast">contrast</code></td>
<td>

<p>a string. If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference 
level specified by the <code>reference</code> argument. 
</p>
</td></tr>
<tr><td><code id="summary.stdGlm_+3A_reference">reference</code></td>
<td>

<p>must be specified if <code>contrast</code> is specified. 
</p>
</td></tr>
<tr><td><code id="summary.stdGlm_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdGlm">stdGlm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdGlm

</code></pre>

<hr>
<h2 id='summary.stdParfrailty'>
Summarizes Frailty standardization fit
</h2><span id='topic+summary.stdParfrailty'></span>

<h3>Description</h3>

<p>This is a <code>summary</code> method for class <code>"stdParfrailty"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stdParfrailty'
summary(object, t, CI.type = "plain", CI.level = 0.95,
  transform = NULL, contrast = NULL, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stdParfrailty_+3A_object">object</code></td>
<td>

<p>an object of class <code>"stdParfrailty"</code>.
</p>
</td></tr> 
<tr><td><code id="summary.stdParfrailty_+3A_t">t</code></td>
<td>

<p>numeric, indicating the times at which to summarize. It defaults to the specified 
value(s) of the argument <code>t</code> in the <code>stdCox</code> function.   
</p>
</td></tr>
<tr><td><code id="summary.stdParfrailty_+3A_ci.type">CI.type</code></td>
<td>

<p>string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals.
</p>
</td></tr>
<tr><td><code id="summary.stdParfrailty_+3A_ci.level">CI.level</code></td>
<td>

<p>desired coverage probability of confidence intervals, on decimal form. 
</p>
</td></tr>
<tr><td><code id="summary.stdParfrailty_+3A_transform">transform</code></td>
<td>

<p>a string. If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized survival 
function <code class="reqn">\theta(t,x)</code> is transformed into <code class="reqn">\psi(t,x)=log\{\theta(t,x)\}</code>, 
<code class="reqn">\psi(t,x)=log[\theta(t,x)/\{1-\theta(t,x)\}]</code>, or 
<code class="reqn">\psi(t,x)=\theta(t,x)/\{1-\theta(t,x)\}</code>, respectively. If left unspecified, 
<code class="reqn">\psi(t,x)=\theta(t,x)</code>.  
</p>
</td></tr>
<tr><td><code id="summary.stdParfrailty_+3A_contrast">contrast</code></td>
<td>

<p>a string. If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(t,x)-\psi(t,x_0)</code>
or <code class="reqn">\psi(t,x) / \psi(t,x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference 
level specified by the <code>reference</code> argument. 
</p>
</td></tr>
<tr><td><code id="summary.stdParfrailty_+3A_reference">reference</code></td>
<td>

<p>must be specified if <code>contrast</code> is specified. 
</p>
</td></tr>
<tr><td><code id="summary.stdParfrailty_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdParfrailty">stdParfrailty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for stdParfrailty

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
