<!DOCTYPE html><html><head><title>Help for package animint2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {animint2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+.gganimint'><p>Add a new component to a ggplot or theme object.</p></a></li>
<li><a href='#absoluteGrob'><p>Absolute grob</p></a></li>
<li><a href='#add_theme'><p>Modify properties of an element in a theme object</p></a></li>
<li><a href='#addShowSelectedForLegend'><p>Add a showSelected aesthetic if legend is specified</p></a></li>
<li><a href='#addSSandCSasAesthetics'><p>Add the showSelected/clickSelects params to the aesthetics mapping</p></a></li>
<li><a href='#aes'><p>Define aesthetic mappings.</p></a></li>
<li><a href='#aes_'><p>Define aesthetic mappings from strings, or quoted calls and formulas.</p></a></li>
<li><a href='#aes_all'><p>Given a character vector, create a set of identity mappings</p></a></li>
<li><a href='#aes_auto'><p>Automatic aesthetic mapping</p></a></li>
<li><a href='#aes_colour_fill_alpha'><p>Colour related aesthetics: colour, fill and alpha</p></a></li>
<li><a href='#aes_linetype_size_shape'><p>Differentiation related aesthetics: linetype, size, shape</p></a></li>
<li><a href='#aes_position'><p>Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend</p></a></li>
<li><a href='#animint'><p>Create an animint</p></a></li>
<li><a href='#animint2-gganimintproto'><p>Base gganimintproto classes for ggplot2</p></a></li>
<li><a href='#animint2dir'><p>Compile and render an animint in a local directory.</p></a></li>
<li><a href='#animint2pages'><p>Publish a list of ggplots as interactive visualizations on a GitHub repository</p></a></li>
<li><a href='#animintOutput'><p>Shiny ui output function</p></a></li>
<li><a href='#annotate'><p>Create an annotation layer.</p></a></li>
<li><a href='#annotation_custom'><p>Annotation: Custom grob.</p></a></li>
<li><a href='#annotation_logticks'><p>Annotation: log tick marks</p></a></li>
<li><a href='#annotation_map'><p>Annotation: maps.</p></a></li>
<li><a href='#annotation_raster'><p>Annotation: High-performance rectangular tiling.</p></a></li>
<li><a href='#as_labeller'><p>Coerce to labeller function</p></a></li>
<li><a href='#as.list.gganimintproto'><p>Convert a gganimintproto object to a list</p></a></li>
<li><a href='#autoplot'><p>Create a complete ggplot appropriate to a particular data type</p></a></li>
<li><a href='#benchplot'><p>Benchmark plot creation time.</p>
Broken down into construct, build, render and draw times.</a></li>
<li><a href='#borders'><p>Create a layer of map borders.</p></a></li>
<li><a href='#breakpoints'>
<p>The breakpointError of simulated signals</p></a></li>
<li><a href='#calc_element'><p>Calculate the element properties, by inheriting properties from its parents</p></a></li>
<li><a href='#checkAnimationTimeVar'><p>Check animation variable for errors</p></a></li>
<li><a href='#checkExtraParams'><p>Check <code>extra_params</code> argument for duplicates, non-named list</p></a></li>
<li><a href='#checkForSSandCSasAesthetics'><p>Check if showSelected and clickSelects have been used as aesthetics</p>
as in old syntax. If yes, raise error</a></li>
<li><a href='#checkPlotForAnimintExtensions'><p>Performs error checking on the plot for animint extensions</p></a></li>
<li><a href='#checkPlotList'><p>Check plot.list for errors</p></a></li>
<li><a href='#checkSingleShowSelectedValue'><p>Issue warnings for non interactive plots where there is only one</p>
showSelected value</a></li>
<li><a href='#colsNotToCopy'><p>Filter out columns that do not need to be copied</p></a></li>
<li><a href='#continuous_scale'><p>Continuous scale constructor.</p></a></li>
<li><a href='#coord_cartesian'><p>Cartesian coordinates.</p></a></li>
<li><a href='#coord_fixed'><p>Cartesian coordinates with fixed relationship between x and y scales.</p></a></li>
<li><a href='#coord_flip'><p>Flipped cartesian coordinates.</p></a></li>
<li><a href='#coord_map'><p>Map projections.</p></a></li>
<li><a href='#coord_munch'><p>Munch coordinates data</p></a></li>
<li><a href='#coord_polar'><p>Polar coordinates.</p></a></li>
<li><a href='#coord_trans'><p>Transformed cartesian coordinate system.</p></a></li>
<li><a href='#cut_interval'><p>Cut up numeric vector into useful groups.</p></a></li>
<li><a href='#diamonds'><p>Prices of 50,000 round cut diamonds</p></a></li>
<li><a href='#discrete_scale'><p>Discrete scale constructor.</p></a></li>
<li><a href='#draw_key'><p>Key drawing functions</p></a></li>
<li><a href='#economics'><p>US economic time series.</p></a></li>
<li><a href='#element_blank'><p>Theme element: blank.</p>
This theme element draws nothing, and assigns no space</a></li>
<li><a href='#element_grob'><p>Generate grid grob from theme element</p></a></li>
<li><a href='#element_line'><p>Theme element: line.</p></a></li>
<li><a href='#element_rect'><p>Theme element: rectangle.</p></a></li>
<li><a href='#element_text'><p>Theme element: text.</p></a></li>
<li><a href='#expand_limits'><p>Expand the plot limits with data.</p></a></li>
<li><a href='#facet'><p>Facet specification.</p></a></li>
<li><a href='#facet_grid'><p>Lay out panels in a grid.</p></a></li>
<li><a href='#facet_null'><p>Facet specification: a single panel.</p></a></li>
<li><a href='#facet_wrap'><p>Wrap a 1d ribbon of panels into 2d.</p></a></li>
<li><a href='#faithfuld'><p>2d density estimate of Old Faithful data</p></a></li>
<li><a href='#FluView'>
<p>FluView</p></a></li>
<li><a href='#format.gganimintproto'><p>Format a gganimintproto object</p></a></li>
<li><a href='#fortify'><p>Fortify a model with data.</p></a></li>
<li><a href='#fortify.lm'><p>Supplement the data fitted to a linear model with model fit statistics.</p></a></li>
<li><a href='#fortify.map'><p>Fortify method for map objects.</p></a></li>
<li><a href='#fortify.sp'><p>Fortify method for classes from the sp package.</p></a></li>
<li><a href='#g_train_layout'><p>Learn the layout of panels within a plot.</p></a></li>
<li><a href='#generation.loci'>
<p>Evolution simulation</p></a></li>
<li><a href='#geom_abline'><p>Lines: horizontal, vertical, and specified by slope and intercept.</p></a></li>
<li><a href='#geom_bar'><p>Bars, rectangles with bases on x-axis</p></a></li>
<li><a href='#geom_bin2d'><p>Add heatmap of 2d bin counts.</p></a></li>
<li><a href='#geom_blank'><p>Blank, draws nothing.</p></a></li>
<li><a href='#geom_contour'><p>Display contours of a 3d surface in 2d.</p></a></li>
<li><a href='#geom_count'><p>Count the number of observations at each location.</p></a></li>
<li><a href='#geom_crossbar'><p>Vertical intervals: lines, crossbars &amp; errorbars.</p></a></li>
<li><a href='#geom_density'><p>Display a smooth density estimate.</p></a></li>
<li><a href='#geom_density_2d'><p>Contours from a 2d density estimate.</p></a></li>
<li><a href='#geom_dotplot'><p>Dot plot</p></a></li>
<li><a href='#geom_errorbarh'><p>Horizontal error bars</p></a></li>
<li><a href='#geom_freqpoly'><p>Histograms and frequency polygons.</p></a></li>
<li><a href='#geom_hex'><p>Hexagon binning.</p></a></li>
<li><a href='#geom_jitter'><p>Points, jittered to reduce overplotting.</p></a></li>
<li><a href='#geom_label'><p>Textual annotations.</p></a></li>
<li><a href='#geom_map'><p>Polygons from a reference map.</p></a></li>
<li><a href='#geom_path'><p>Connect observations.</p></a></li>
<li><a href='#geom_point'><p>Points, as for a scatterplot</p></a></li>
<li><a href='#geom_polygon'><p>Polygon, a filled path.</p></a></li>
<li><a href='#geom_raster'><p>Draw rectangles.</p></a></li>
<li><a href='#geom_ribbon'><p>Ribbons and area plots.</p></a></li>
<li><a href='#geom_rug'><p>Marginal rug plots.</p></a></li>
<li><a href='#geom_segment'><p>Line segments and curves.</p></a></li>
<li><a href='#geom_smooth'><p>Add a smoothed conditional mean.</p></a></li>
<li><a href='#geom_spoke'><p>A line segment parameterised by location, direction and distance.</p></a></li>
<li><a href='#geom_tallrect'><p>ggplot2 geom with xmin and xmax aesthetics that covers the entire y range, useful for clickSelects background elements.</p></a></li>
<li><a href='#geom_violin'><p>Violin plot.</p></a></li>
<li><a href='#geom_widerect'><p>ggplot2 geom with ymin and ymax aesthetics that covers the entire x range, useful for clickSelects background elements.</p></a></li>
<li><a href='#getCommonChunk'><p>Save the common columns for each tsv to one chunk</p></a></li>
<li><a href='#getLayerName'><p>Gives a unique name to each layer in <code>saveLayer</code></p></a></li>
<li><a href='#getLayerParams'><p>Get all parameters for a layer</p></a></li>
<li><a href='#getLegend'><p>Function to get legend information for each scale</p></a></li>
<li><a href='#getLegendList'><p>Function to get legend information from ggplot</p></a></li>
<li><a href='#getTextSize'><p>Function to process text size with different types of unit</p></a></li>
<li><a href='#getUniqueAxisLabels'><p>Get unique axis labels for the plot</p></a></li>
<li><a href='#gg_dep'><p>Give a deprecation error, warning, or message, depending on version number.</p></a></li>
<li><a href='#gganimintproto'><p>Create a new gganimintproto object</p></a></li>
<li><a href='#ggplot'><p>Create a new ggplot plot.</p></a></li>
<li><a href='#ggplot_build'><p>Build ggplot for rendering.</p></a></li>
<li><a href='#ggplot_gtable'><p>Build a plot with all the usual bits and pieces.</p></a></li>
<li><a href='#ggplotGrob'><p>Generate a ggplot2 plot grob.</p></a></li>
<li><a href='#ggsave'><p>Save a ggplot (or other grid object) with sensible defaults</p></a></li>
<li><a href='#ggtheme'><p>ggplot2 themes</p></a></li>
<li><a href='#graphical-units'><p>Graphical units</p></a></li>
<li><a href='#guide_colourbar'><p>Continuous colour bar guide.</p></a></li>
<li><a href='#guide_legend'><p>Legend guide.</p></a></li>
<li><a href='#guides'><p>Set guides for each scale.</p></a></li>
<li><a href='#hmisc'><p>Wrap up a selection of summary functions from Hmisc to make it easy to use</p>
with <code>stat_summary</code>.</a></li>
<li><a href='#intreg'>
<p>Interval regression</p></a></li>
<li><a href='#is.Coord'><p>Is this object a coordinate system?</p></a></li>
<li><a href='#is.facet'><p>Is this object a facetting specification?</p></a></li>
<li><a href='#is.gganimintproto'><p>Is an object a gganimintproto object?</p></a></li>
<li><a href='#is.ggplot'><p>Reports whether x is a ggplot object</p></a></li>
<li><a href='#is.rel'><p>Reports whether x is a rel object</p></a></li>
<li><a href='#is.rgb'><p>Check if character is an RGB hexadecimal color value</p></a></li>
<li><a href='#is.theme'><p>Reports whether x is a theme object</p></a></li>
<li><a href='#issueSelectorWarnings'><p>Issue warnings for selectors</p></a></li>
<li><a href='#knit_print.animint'><p>Insert an interactive animation into an R markdown document using a customized print method.</p></a></li>
<li><a href='#label_bquote'><p>Backquoted labeller</p></a></li>
<li><a href='#labeller'><p>Generic labeller function for facets</p></a></li>
<li><a href='#labellers'><p>Labeller functions</p></a></li>
<li><a href='#labs'><p>Change axis labels, legend titles, plot title/subtitle and below-plot</p>
caption.</a></li>
<li><a href='#last_plot'><p>Retrieve the last plot to be modified or created.</p></a></li>
<li><a href='#layer'><p>Create a new layer</p></a></li>
<li><a href='#limits'><p>Generate correct scale type for specified limits</p></a></li>
<li><a href='#lims'><p>Convenience functions to set the axis limits.</p></a></li>
<li><a href='#luv_colours'><p><code>colors()</code> in Luv space.</p></a></li>
<li><a href='#make_bar'><p>Convenience function for an interactive bar that might otherwise be</p>
created using stat_summary(geom=&quot;bar&quot;).</a></li>
<li><a href='#make_tallrect'><p>Make a clickSelects geom_tallrect that completely tiles the x</p>
range. This makes it easy to construct tallrects for the common
case of selecting a particular x value.</a></li>
<li><a href='#make_tallrect_or_widerect'><p>Make a clickSelects geom_widerect or geom_tallrect that completely</p>
tiles the x or y range. This function is used internally by
make_tallrect or make_widerect, which are more user-friendly.</a></li>
<li><a href='#make_text'><p>Convenvience function for a showSelected plot label.</p></a></li>
<li><a href='#make_widerect'><p>Make a clickSelects geom_widerect that completely tiles the y</p>
range. This makes it easy to construct widerects for the common
case of selecting a particular y value.</a></li>
<li><a href='#map_data'><p>Create a data frame of map data.</p></a></li>
<li><a href='#margin'><p>Define margins.</p></a></li>
<li><a href='#mean_se'><p>Calculate mean and standard errors on either side.</p></a></li>
<li><a href='#merge_recurse'><p>Merge a list of data frames.</p></a></li>
<li><a href='#midwest'><p>Midwest demographics.</p></a></li>
<li><a href='#mpg'><p>Fuel economy data from 1999 and 2008 for 38 popular models of car</p></a></li>
<li><a href='#msleep'><p>An updated and expanded version of the mammals sleep dataset.</p></a></li>
<li><a href='#newEnvironment'><p>Environment to store meta data</p></a></li>
<li><a href='#parsePlot'><p>Convert a ggplot to a list.</p></a></li>
<li><a href='#position_dodge'><p>Adjust position by dodging overlaps to the side.</p></a></li>
<li><a href='#position_fill'><p>Stack overlapping objects on top of one another.</p></a></li>
<li><a href='#position_identity'><p>Don't adjust position</p></a></li>
<li><a href='#position_jitter'><p>Jitter points to avoid overplotting.</p></a></li>
<li><a href='#position_jitterdodge'><p>Adjust position by simultaneously dodging and jittering</p></a></li>
<li><a href='#position_nudge'><p>Nudge points.</p></a></li>
<li><a href='#presidential'><p>Terms of 11 presidents from Eisenhower to Obama.</p></a></li>
<li><a href='#print.animint'><p>print animint</p></a></li>
<li><a href='#print.gganimintplot'><p>Draw plot on current graphics device.</p></a></li>
<li><a href='#print.gganimintproto'><p>Print a gganimintproto object</p></a></li>
<li><a href='#pt.to.lines'><p>Convert <code>pt</code> value to <code>lines</code></p></a></li>
<li><a href='#qplot'><p>Quick plot</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rel'><p>Relative sizing for theme elements</p></a></li>
<li><a href='#remove_missing'><p>Convenience function to remove missing values from a data.frame</p></a></li>
<li><a href='#renderAnimint'><p>Create an animint output element</p></a></li>
<li><a href='#resolution'><p>Compute the &quot;resolution&quot; of a data vector.</p></a></li>
<li><a href='#saveChunks'><p>Split data set into chunks and save them to separate files.</p></a></li>
<li><a href='#scale_alpha'><p>Alpha scales.</p></a></li>
<li><a href='#scale_colour_brewer'><p>Sequential, diverging and qualitative colour scales from colorbrewer.org</p></a></li>
<li><a href='#scale_colour_gradient'><p>Smooth gradient between two colours</p></a></li>
<li><a href='#scale_colour_grey'><p>Sequential grey colour scale.</p></a></li>
<li><a href='#scale_colour_hue'><p>Qualitative colour scale with evenly spaced hues.</p></a></li>
<li><a href='#scale_continuous'><p>Continuous position scales (x &amp; y).</p></a></li>
<li><a href='#scale_date'><p>Position scale, date &amp; date times</p></a></li>
<li><a href='#scale_identity'><p>Use values without scaling.</p></a></li>
<li><a href='#scale_linetype'><p>Scale for line patterns.</p></a></li>
<li><a href='#scale_manual'><p>Create your own discrete scale.</p></a></li>
<li><a href='#scale_shape'><p>Scale for shapes, aka glyphs.</p></a></li>
<li><a href='#scale_size'><p>Scale size (area or radius).</p></a></li>
<li><a href='#scale_size_animint'><p>Scale point sizes using circle area, but specifying the radius in</p>
pixels.</a></li>
<li><a href='#scale_x_discrete'><p>Discrete position.</p></a></li>
<li><a href='#seals'><p>Vector field of seal movements.</p></a></li>
<li><a href='#selectSSandCS'><p>Separate .variable/.value selectors</p></a></li>
<li><a href='#setPlotSizes'><p>Set plot width and height for all plots</p></a></li>
<li><a href='#should_stop'><p>Used in examples to illustrate when errors should occur.</p></a></li>
<li><a href='#split_recursive'><p>Split data.frame into recursive list of data.frame.</p></a></li>
<li><a href='#stat_ecdf'><p>Empirical Cumulative Density Function</p></a></li>
<li><a href='#stat_ellipse'><p>Plot data ellipses.</p></a></li>
<li><a href='#stat_function'><p>Superimpose a function.</p></a></li>
<li><a href='#stat_identity'><p>Identity statistic.</p></a></li>
<li><a href='#stat_qq'><p>Calculation for quantile-quantile plot.</p></a></li>
<li><a href='#stat_summary_2d'><p>Bin and summarise in 2d (rectangle &amp; hexagons)</p></a></li>
<li><a href='#stat_summary_bin'><p>Summarise y values at unique/binned x x.</p></a></li>
<li><a href='#stat_unique'><p>Remove duplicates.</p></a></li>
<li><a href='#summary.gganimintplot'><p>Displays a useful description of a ggplot object</p></a></li>
<li><a href='#switch_axes'><p>Flip axes in case of coord_flip</p>
Switches column names. Eg. xmin to ymin, yntercept to xintercept etc.</a></li>
<li><a href='#theme'><p>Set theme elements</p></a></li>
<li><a href='#theme_animint'><p>theme for passing animint specific params</p></a></li>
<li><a href='#theme_update'><p>Get, set and update themes.</p></a></li>
<li><a href='#toRGB'><p>Convert R colors to RGB hexadecimal color values</p></a></li>
<li><a href='#train_position'><p>Train position scales with data</p></a></li>
<li><a href='#transform_position'><p>Convenience function to transform all position variables.</p></a></li>
<li><a href='#transform_shape'><p>Function to transform R shapes into d3 shapes...</p></a></li>
<li><a href='#translate_qplot_ggplot'><p>Translating between qplot and ggplot</p></a></li>
<li><a href='#translate_qplot_lattice'><p>Translating between qplot and lattice</p></a></li>
<li><a href='#txhousing'><p>Housing sales in TX.</p></a></li>
<li><a href='#update_gallery'><p>Update gallery</p></a></li>
<li><a href='#update_geom_defaults'><p>Modify geom/stat aesthetic defaults for future plots</p></a></li>
<li><a href='#update_labels'><p>Update axis/legend labels</p></a></li>
<li><a href='#UStornadoes'>
<p>Tornadoes in the United States from 1950 to 2012</p></a></li>
<li><a href='#varied.chunk'><p>Extract subset for each data.frame in a list of data.frame</p></a></li>
<li><a href='#waiver'><p>A waiver object.</p></a></li>
<li><a href='#WorldBank'>
<p>Demographics by country from 1960 to 2012</p></a></li>
<li><a href='#worldPop'>
<p>World population by subcontinent</p></a></li>
<li><a href='#zeroGrob'><p>The zero grob draws nothing and has zero size.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Animated Interactive Grammar of Graphics</td>
</tr>
<tr>
<td>Version:</td>
<td>2024.1.24</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://animint.github.io/animint2/">https://animint.github.io/animint2/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/animint/animint2/issues">https://github.com/animint/animint2/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided for defining animated,
 interactive data visualizations in R code, and rendering
 on a web page. The 2018 Journal of Computational and 
 Graphical Statistics paper,
 &lt;<a href="https://doi.org/10.1080%2F10618600.2018.1513367">doi:10.1080/10618600.2018.1513367</a>&gt;
 describes the concepts implemented.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>servr, digest, RJSONIO, grid, gtable (&ge; 0.1.1), MASS, plyr
(&ge; 1.7.1), reshape2, scales (&ge; 0.4.1), stats, knitr (&ge;
1.5.33), data.table (&ge; 1.9.8), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gert, gitcreds, gh, sp, gistr (&ge; 0.2), shiny, RColorBrewer,
htmltools, rmarkdown, testthat, devtools, httr, maps,
ggplot2movies, hexbin, Hmisc, lattice, mapproj, mgcv, nlme,
rpart, svglite, ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'gganimintproto.r' 'aaa-.r' 'aes-calculated.r'
'aes-colour-fill-alpha.r' 'aes-group-order.r'
'aes-linetype-size-shape.r' 'aes-position.r' 'utilities.r'
'aes.r' 'legend-draw.r' 'geom-.r' 'annotation-custom.r'
'annotation-logticks.r' 'geom-polygon.r' 'geom-map.r'
'annotation-map.r' 'geom-raster.r' 'annotation-raster.r'
'annotation.r' 'autoplot.r' 'bench.r' 'bin.R' 'coord-.r'
'coord-cartesian-.r' 'coord-fixed.r' 'coord-flip.r'
'coord-map.r' 'coord-munch.r' 'coord-polar.r'
'coord-quickmap.R' 'coord-transform.r' 'data.R' 'facet-.r'
'facet-grid-.r' 'facet-labels.r' 'facet-layout.r'
'facet-locate.r' 'facet-null.r' 'facet-viewports.r'
'facet-wrap.r' 'fortify-lm.r' 'fortify-map.r'
'fortify-spatial.r' 'fortify.r' 'stat-.r' 'geom-abline.r'
'geom-rect.r' 'geom-bar.r' 'geom-bin2d.r' 'geom-blank.r'
'geom-path.r' 'geom-contour.r' 'geom-count.r' 'geom-crossbar.r'
'geom-segment.r' 'geom-curve.r' 'geom-defaults.r'
'geom-ribbon.r' 'geom-density.r' 'geom-density2d.r'
'geom-dotplot.r' 'geom-errorbar.r' 'geom-errorbarh.r'
'geom-freqpoly.r' 'geom-hex.r' 'geom-histogram.r'
'geom-hline.r' 'geom-jitter.r' 'geom-label.R'
'geom-linerange.r' 'geom-point.r' 'geom-pointrange.r'
'geom-rug.r' 'geom-smooth.r' 'geom-spoke.r' 'geom-text.r'
'geom-tile.r' 'geom-violin.r' 'geom-vline.r' 'ggplot2.r'
'grob-absolute.r' 'grob-dotstack.r' 'grob-null.r' 'grouping.r'
'guide-colorbar.r' 'guide-legend.r' 'guides-.r' 'guides-axis.r'
'guides-grid.r' 'hexbin.R' 'labels.r' 'layer.r' 'limits.r'
'margins.R' 'panel.r' 'plot-build.r' 'plot-construction.r'
'plot-last.r' 'plot.r' 'position-.r' 'position-collide.r'
'position-dodge.r' 'position-fill.r' 'position-identity.r'
'position-jitter.r' 'position-jitterdodge.R' 'position-nudge.R'
'position-stack.r' 'quick-plot.r' 'range.r' 'save.r' 'scale-.r'
'scale-alpha.r' 'scale-brewer.r' 'scale-continuous.r'
'scale-date.r' 'scale-discrete-.r' 'scale-gradient.r'
'scale-grey.r' 'scale-hue.r' 'scale-identity.r'
'scale-linetype.r' 'scale-manual.r' 'scale-shape.r'
'scale-size.r' 'scale-type.R' 'scales-.r' 'stat-bin.r'
'stat-bin2d.r' 'stat-bindot.r' 'stat-binhex.r' 'stat-contour.r'
'stat-count.r' 'stat-density-2d.r' 'stat-density.r'
'stat-ecdf.r' 'stat-ellipse.R' 'stat-function.r'
'stat-identity.r' 'stat-qq.r' 'stat-smooth-methods.r'
'stat-smooth.r' 'stat-sum.r' 'stat-summary-2d.r'
'stat-summary-bin.R' 'stat-summary-hex.r' 'stat-summary.r'
'stat-unique.r' 'stat-ydensity.r' 'summary.r'
'theme-defaults.r' 'theme-elements.r' 'theme.r'
'translate-qplot-ggplot.r' 'translate-qplot-lattice.r'
'utilities-break.r' 'utilities-grid.r' 'utilities-help.r'
'utilities-matrix.r' 'utilities-resolution.r'
'utilities-table.r' 'uu_zxx.r' 'uu_zzz.r' 'z_animint.R'
'z_animintHelpers.R' 'z_facets.R' 'z_geoms.R'
'z_helperFunctions.R' 'z_knitr.R' 'z_pages.R' 'z_print.R'
'z_scales.R' 'z_theme_animint.R' 'z_transformShape.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 21:01:58 UTC; th798</td>
</tr>
<tr>
<td>Author:</td>
<td>Toby Hocking [aut, cre] (Original animint code),
  Hadley Wickham [aut] (Forked ggplot2 code),
  Winston Chang [aut] (Forked ggplot2 code),
  RStudio [cph] (Forked ggplot2 code),
  Nicholas Lewin-Koh [aut] (hexGrob),
  Martin Maechler [aut] (hexGrob),
  Randall Prium [aut] (cut_width),
  Susan VanderPlas [aut] (Animint GSOC 2013),
  Carson Sievert [aut] (Animint GSOC 2014),
  Kevin Ferris [aut] (Animint GSOC 2015),
  Jun Cai [aut] (Animint GSOC 2015),
  Faizan Khan [aut] (Animint GSOC 2016-2017),
  Vivek Kumar [aut] (Animint GSOC 2018),
  Himanshu Singh [aut] (Animint2 GSoC 2020),
  Yufan Fei [aut] (Animint2 GSoC 2022),
  Jocelyne Chen [aut] (Animint2 GSoC 2023)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Toby Hocking &lt;toby.hocking@r-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2B.gganimint'>Add a new component to a ggplot or theme object.</h2><span id='topic++2B.gganimint'></span><span id='topic++25+2B+25'></span><span id='topic++25+2Breplace+25'></span>

<h3>Description</h3>

<p>This operator allows you to add objects to a ggplot or theme object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gganimint'
e1 + e2

e1 %+% e2

e1 %+replace% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.gganimint_+3A_e1">e1</code></td>
<td>
<p>An object of class <code>ggplot</code> or <code>theme</code></p>
</td></tr>
<tr><td><code id="+2B2B.gganimint_+3A_e2">e2</code></td>
<td>
<p>A component to add to <code>e1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the first object is an object of class <code>ggplot</code>, you can add
the following types of objects, and it will return a modified ggplot
object.
</p>

<ul>
<li> <p><code>data.frame</code>: replace current data.frame
(must use <code>%+%</code>)
</p>
</li>
<li> <p><code>uneval</code>: replace current aesthetics
</p>
</li>
<li> <p><code>layer</code>: add new layer
</p>
</li>
<li> <p><code>theme</code>: update plot theme
</p>
</li>
<li> <p><code>scale</code>: replace current scale
</p>
</li>
<li> <p><code>coord</code>: override current coordinate system
</p>
</li>
<li> <p><code>facet</code>: override current coordinate faceting
</p>
</li></ul>

<p>If the first object is an object of class <code>theme</code>, you can add
another theme object. This will return a modified theme object.
</p>
<p>For theme objects, the <code>+</code> operator and the <code>%+replace%</code>
can be used to modify elements in themes.
</p>
<p>The <code>+</code> operator updates the elements of e1 that differ from
elements specified (not NULL) in e2.
Thus this operator can be used to incrementally add or modify attributes
of a ggplot theme.
</p>
<p>In contrast, the <code>%+replace%</code> operator replaces the
entire element; any element of a theme not specified in e2 will not be
present in the resulting theme (i.e. NULL).
Thus this operator can be used to overwrite an entire theme.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theme">theme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Adding objects to a ggplot object
p &lt;- ggplot(mtcars, aes(wt, mpg, colour = disp)) +
  geom_point()

p
p + coord_cartesian(ylim = c(0, 40))
p + scale_colour_continuous(breaks = c(100, 300))
p + guides(colour = "colourbar")

# Use a different data frame
m &lt;- mtcars[1:10, ]
p %+% m

### Adding objects to a theme object
# Compare these results of adding theme objects to other theme objects
add_el &lt;- theme_grey() + theme(text = element_text(family = "Times"))
rep_el &lt;- theme_grey() %+replace% theme(text = element_text(family = "Times"))

add_el$text
rep_el$text

</code></pre>

<hr>
<h2 id='absoluteGrob'>Absolute grob</h2><span id='topic+absoluteGrob'></span>

<h3>Description</h3>

<p>This grob has fixed dimensions and position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absoluteGrob(
  grob,
  width = NULL,
  height = NULL,
  xmin = NULL,
  ymin = NULL,
  vp = NULL
)
</code></pre>


<h3>Details</h3>

<p>It's still experimental
</p>

<hr>
<h2 id='add_theme'>Modify properties of an element in a theme object</h2><span id='topic+add_theme'></span>

<h3>Description</h3>

<p>Modify properties of an element in a theme object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_theme(t1, t2, t2name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_theme_+3A_t1">t1</code></td>
<td>
<p>A theme object</p>
</td></tr>
<tr><td><code id="add_theme_+3A_t2">t2</code></td>
<td>
<p>A theme object that is to be added to <code>t1</code></p>
</td></tr>
<tr><td><code id="add_theme_+3A_t2name">t2name</code></td>
<td>
<p>A name of the t2 object. This is used for printing
informative error messages.</p>
</td></tr>
</table>

<hr>
<h2 id='addShowSelectedForLegend'>Add a showSelected aesthetic if legend is specified</h2><span id='topic+addShowSelectedForLegend'></span>

<h3>Description</h3>

<p>Add a showSelected aesthetic if legend is specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addShowSelectedForLegend(meta, legend, L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addShowSelectedForLegend_+3A_meta">meta</code></td>
<td>
<p>meta object with all information</p>
</td></tr>
<tr><td><code id="addShowSelectedForLegend_+3A_legend">legend</code></td>
<td>
<p>legend to scan for showSelected</p>
</td></tr>
<tr><td><code id="addShowSelectedForLegend_+3A_l">L</code></td>
<td>
<p>layer of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>L : Layer with additional mapping to new aesthetic
</p>

<hr>
<h2 id='addSSandCSasAesthetics'>Add the showSelected/clickSelects params to the aesthetics mapping</h2><span id='topic+addSSandCSasAesthetics'></span>

<h3>Description</h3>

<p>Add the showSelected/clickSelects params to the aesthetics mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSSandCSasAesthetics(aesthetics, extra_params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSSandCSasAesthetics_+3A_aesthetics">aesthetics</code></td>
<td>
<p>list. Original aesthetics mapping of the layer</p>
</td></tr>
<tr><td><code id="addSSandCSasAesthetics_+3A_extra_params">extra_params</code></td>
<td>
<p>named list containing the details of showSelected
and clickSelects values of the layer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used before calling ggplot_build in parsePlot and while checking
animint extensions to raise error
</p>


<h3>Value</h3>

<p>Modified aesthetics list with showSelected/clickSelects params added
</p>

<hr>
<h2 id='aes'>Define aesthetic mappings.</h2><span id='topic+aes'></span>

<h3>Description</h3>

<p>Generate aesthetic mappings that describe how variables in the data are
mapped to visual properties (aesthetics) of geoms. This function also
standardise aesthetic names by performs partial name matching, converting
color to colour, and old style R names to ggplot names (eg. pch to shape,
cex to size)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_+3A_x">x</code>, <code id="aes_+3A_y">y</code>, <code id="aes_+3A_...">...</code></td>
<td>
<p>List of name value pairs giving aesthetics to map to
variables. The names for x and y aesthetics can be omitted (because
they are so common); all other aesthetics must be named.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+aes_q">aes_q</a></code>/<code><a href="#topic+aes_string">aes_string</a></code> for standard
evaluation versions of <code>aes</code>.
</p>
<p>See
<code><a href="#topic+aes_colour_fill_alpha">aes_colour_fill_alpha</a></code>, 
<code><a href="#topic+aes_linetype_size_shape">aes_linetype_size_shape</a></code> and <code><a href="#topic+aes_position">aes_position</a></code>
for more specific examples with different aesthetics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aes(x = mpg, y = wt)
aes(mpg, wt)

# You can also map aesthetics to functions of variables
aes(x = mpg ^ 2, y = wt / cyl)

# Aesthetic names are automatically standardised
aes(col = x)
aes(fg = x)
aes(color = x)
aes(colour = x)

# aes is almost always used with ggplot() or a layer
ggplot(mpg, aes(displ, hwy)) + geom_point()
ggplot(mpg) + geom_point(aes(displ, hwy))

# Aesthetics supplied to ggplot() are used as defaults for every layer
# you can override them, or supply different aesthetics for each layer
</code></pre>

<hr>
<h2 id='aes_'>Define aesthetic mappings from strings, or quoted calls and formulas.</h2><span id='topic+aes_'></span><span id='topic+aes_string'></span><span id='topic+aes_q'></span>

<h3>Description</h3>

<p>Aesthetic mappings describe how variables in the data are mapped to visual
properties (aesthetics) of geoms. <code><a href="#topic+aes">aes</a></code> uses non-standard
evaluation to capture the variable names. <code>aes_</code> and <code>aes_string</code>
require you to explicitly quote the inputs either with <code>""</code> for
<code>aes_string()</code>, or with <code>quote</code> or <code>~</code> for <code>aes_()</code>.
(<code>aes_q</code> is an alias to <code>aes_</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes_(x, y, ...)

aes_string(x, y, ...)

aes_q(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes__+3A_x">x</code>, <code id="aes__+3A_y">y</code>, <code id="aes__+3A_...">...</code></td>
<td>
<p>List of name value pairs. Elements must be either
quoted calls, strings, one-sided formulas or constants.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's better to use <code>aes_q()</code>, because there's no easy way to create the
equivalent to <code>aes(colour = "my colour")</code> or <code>aes{x = `X$1`}</code>
with <code>aes_string()</code>.
</p>
<p><code>aes_string</code> and <code>aes_</code> are particularly useful when writing
functions that create plots because you can use strings or quoted
names/calls to define the aesthetic mappings, rather than having to use
<code><a href="base.html#topic+substitute">substitute</a></code> to generate a call to <code>aes()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aes">aes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Three ways of generating the same aesthetics
aes(mpg, wt, col = cyl)
aes_(quote(mpg), quote(wt), col = quote(cyl))
aes_(~mpg, ~wt, col = ~cyl)
aes_string("mpg", "wt", col = "cyl")

# You can't easily mimic these calls with aes_string
aes(`$100`, colour = "smooth")
aes_(~ `$100`, colour = "smooth")
# Ok, you can, but it requires a _lot_ of quotes
aes_string("`$100`", colour = '"smooth"')

# Convert strings to names with as.name
var &lt;- "cyl"
aes(col = x)
aes_(col = as.name(var))
</code></pre>

<hr>
<h2 id='aes_all'>Given a character vector, create a set of identity mappings</h2><span id='topic+aes_all'></span>

<h3>Description</h3>

<p>Given a character vector, create a set of identity mappings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes_all(vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_all_+3A_vars">vars</code></td>
<td>
<p>vector of variable names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>aes_all(names(mtcars))
aes_all(c("x", "y", "col", "pch"))
</code></pre>

<hr>
<h2 id='aes_auto'>Automatic aesthetic mapping</h2><span id='topic+aes_auto'></span>

<h3>Description</h3>

<p>Automatic aesthetic mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aes_auto(data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aes_auto_+3A_data">data</code></td>
<td>
<p>data.frame or names of variables</p>
</td></tr>
<tr><td><code id="aes_auto_+3A_...">...</code></td>
<td>
<p>aesthetics that need to be explicitly mapped.</p>
</td></tr>
</table>

<hr>
<h2 id='aes_colour_fill_alpha'>Colour related aesthetics: colour, fill and alpha</h2><span id='topic+aes_colour_fill_alpha'></span><span id='topic+colour'></span><span id='topic+color'></span><span id='topic+fill'></span>

<h3>Description</h3>

<p>This page demonstrates the usage of a sub-group
of aesthetics; colour, fill and alpha.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Bar chart example
c &lt;- ggplot(mtcars, aes(factor(cyl)))
# Default plotting
c + geom_bar()
# To change the interior colouring use fill aesthetic
c + geom_bar(fill = "red")
# Compare with the colour aesthetic which changes just the bar outline
c + geom_bar(colour = "red")
# Combining both, you can see the changes more clearly
c + geom_bar(fill = "white", colour = "red")

# The aesthetic fill also takes different colouring scales
# setting fill equal to a factor variable uses a discrete colour scale
k &lt;- ggplot(mtcars, aes(factor(cyl), fill = factor(vs)))
k + geom_bar()

# Fill aesthetic can also be used with a continuous variable
m &lt;- ggplot(faithfuld, aes(waiting, eruptions))
m + geom_raster()
m + geom_raster(aes(fill = density))

# Some geoms don't use both aesthetics (i.e. geom_point or geom_line)
b &lt;- ggplot(economics, aes(x = date, y = unemploy))
b + geom_line()
b + geom_line(colour = "green")
b + geom_point()
b + geom_point(colour = "red")

# For large datasets with overplotting the alpha
# aesthetic will make the points more transparent
df &lt;- data.frame(x = rnorm(5000), y = rnorm(5000))
h  &lt;- ggplot(df, aes(x,y))
h + geom_point()
h + geom_point(alpha = 0.5)
h + geom_point(alpha = 1/10)

# Alpha can also be used to add shading
j &lt;- b + geom_line()
j
yrng &lt;- range(economics$unemploy)
j &lt;- j + geom_rect(aes(NULL, NULL, xmin = start, xmax = end, fill = party),
ymin = yrng[1], ymax = yrng[2], data = presidential)
j
j + scale_fill_manual(values = alpha(c("blue", "red"), .3))

</code></pre>

<hr>
<h2 id='aes_linetype_size_shape'>Differentiation related aesthetics: linetype, size, shape</h2><span id='topic+aes_linetype_size_shape'></span><span id='topic+linetype'></span><span id='topic+size'></span><span id='topic+shape'></span>

<h3>Description</h3>

<p>This page demonstrates the usage of a sub-group
of aesthetics; linetype, size and shape.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Line types should be specified with either an integer, a name, or with a string of
# an even number (up to eight) of hexadecimal digits which give the lengths in
# consecutive positions in the string.
# 0 = blank, 1 = solid, 2 = dashed, 3 = dotted, 4 = dotdash, 5 = longdash, 6 = twodash

# Data
df &lt;- data.frame(x = 1:10 , y = 1:10)
f &lt;- ggplot(df, aes(x, y))
f + geom_line(linetype = 2)
f + geom_line(linetype = "dotdash")

# An example with hex strings, the string "33" specifies three units on followed
# by three off and "3313" specifies three units on followed by three off followed
# by one on and finally three off.
f + geom_line(linetype = "3313")

# Mapping line type from a variable
ggplot(economics_long, aes(date, value01)) +
  geom_line(aes(linetype = variable))

# Size examples
# Should be specified with a numerical value (in millimetres),
# or from a variable source
p &lt;- ggplot(mtcars, aes(wt, mpg))
p + geom_point(size = 4)
p + geom_point(aes(size = qsec))
p + geom_point(size = 2.5) +
  geom_hline(yintercept = 25, size = 3.5)

# Shape examples
# Shape takes four types of values: an integer in [0, 25],
# a single character-- which uses that character as the plotting symbol,
# a . to draw the smallest rectangle that is visible (i.e., about one pixel)
# an NA to draw nothing
p + geom_point()
p + geom_point(shape = 5)
p + geom_point(shape = "k", size = 3)
p + geom_point(shape = ".")
p + geom_point(shape = NA)

# Shape can also be mapped from a variable
p + geom_point(aes(shape = factor(cyl)))

# A look at all 25 symbols
df2 &lt;- data.frame(x = 1:5 , y = 1:25, z = 1:25)
s &lt;- ggplot(df2, aes(x, y))
s + geom_point(aes(shape = z), size = 4) +
  scale_shape_identity()
# While all symbols have a foreground colour, symbols 19-25 also take a
# background colour (fill)
s + geom_point(aes(shape = z), size = 4, colour = "Red") +
  scale_shape_identity()
s + geom_point(aes(shape = z), size = 4, colour = "Red", fill = "Black") +
  scale_shape_identity()
</code></pre>

<hr>
<h2 id='aes_position'>Position related aesthetics: x, y, xmin, xmax, ymin, ymax, xend, yend</h2><span id='topic+aes_position'></span><span id='topic+x'></span><span id='topic+y'></span><span id='topic+xmin'></span><span id='topic+xmax'></span><span id='topic+ymin'></span><span id='topic+ymax'></span><span id='topic+xend'></span><span id='topic+yend'></span>

<h3>Description</h3>

<p>This page demonstrates the usage of a sub-group
of aesthetics; x, y, xmin, xmax, ymin, ymax, xend, and yend.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate data: means and standard errors of means for prices
# for each type of cut
dmod &lt;- lm(price ~ cut, data = diamonds)
cuts &lt;- data.frame(cut = unique(diamonds$cut), predict(dmod, data.frame(cut =
unique(diamonds$cut)), se = TRUE)[c("fit", "se.fit")])
se &lt;- ggplot(cuts, aes(x = cut, y = fit, ymin = fit - se.fit,
ymax = fit + se.fit, colour = cut))
se + geom_pointrange()

# Using annotate
p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p + annotate("rect", xmin = 2, xmax = 3.5, ymin = 2, ymax = 25,
  fill = "dark grey", alpha = .5)

# Geom_segment examples
p + geom_segment(aes(x = 2, y = 15, xend = 2, yend = 25),
  arrow = arrow(length = unit(0.5, "cm")))
p + geom_segment(aes(x = 2, y = 15, xend = 3, yend = 15),
  arrow = arrow(length = unit(0.5, "cm")))
p + geom_segment(aes(x = 5, y = 30, xend = 3.5, yend = 25),
  arrow = arrow(length = unit(0.5, "cm")))

# You can also use geom_segment to recreate plot(type = "h") :
counts &lt;- as.data.frame(table(x = rpois(100, 5)))
counts$x &lt;- as.numeric(as.character(counts$x))
with(counts, plot(x, Freq, type = "h", lwd = 10))

ggplot(counts, aes(x, Freq)) +
  geom_segment(aes(yend = 0, xend = x), size = 10)
</code></pre>

<hr>
<h2 id='animint'>Create an animint</h2><span id='topic+animint'></span>

<h3>Description</h3>

<p>Create an animated, interactive data visualization. The easiest
way to get started is by reading the Animint2 Manual,
https://rcdata.nau.edu/genomic-ml/animint2-manual/Ch02-ggplot2.html
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animint(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animint_+3A_...">...</code></td>
<td>
<p>ggplots and options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a list with the items in ... and
attaches the animint class. It also provides default names for
un-named ggplots. The list should contain ggplots and
options. Each geom can be made interactive by using the 
showSelected and clickSelects parameters; each should be a
character vector of selection variable names. For example
geom_line(clickSelects=&quot;country&quot;) means that clicking the line
changes the value of the &quot;country&quot; selection variable;
geom_point(showSelected=&quot;year&quot;) means to only show the subset of
data for the currently selected year.
</p>


<h3>Value</h3>

<p>list of class animint
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('data.table'))setDTthreads(1)#for CRAN.
library(animint2)
data(WorldBank, package="animint2")
years &lt;- unique(WorldBank[, "year", drop=FALSE])
y1960 &lt;- subset(WorldBank, year==1960)
animint(
  title="Linked scatterplot and time series", #web page title.
  time=list(variable="year",ms=3000), #variable and time delay used for animation.
  duration=list(year=1000), #smooth transition duration in milliseconds.
  selector.types=list(country="multiple"), #single/multiple selection for each variable.
  first=list( #selected values to show when viz is first rendered.
    country=c("Canada", "Japan"),
    year=1970),
  ## ggplots are rendered together for an interactive data viz.
  ts=ggplot()+
    theme_animint(width=500)+
    make_tallrect(WorldBank, "year")+
    geom_text(aes(
      year, life.expectancy, label=country),
      showSelected="country",
      clickSelects="country",
      hjust=1,
      data=y1960)+
    scale_x_continuous(limits=c(1950, NA))+
    geom_line(aes(
      year, life.expectancy, group=country, color=region),
      clickSelects="country",
      data=WorldBank,
      size=4,
      alpha=0.55),
  scatter=ggplot()+
    geom_point(aes(
      fertility.rate, life.expectancy,
      key=country, colour=region, size=population),
      showSelected="year",
      clickSelects="country",
      data=WorldBank)+
    geom_text(aes(
      fertility.rate, life.expectancy,
      key=country,
      label=country),
      showSelected=c("country", "year"),
      data=WorldBank)+
    geom_text(aes(
      5, 80, key=1, label=paste("year =", year)),
      showSelected="year",
      data=years)+
    scale_size_animint(pixel.range=c(2,20), breaks=10^(4:9)))
</code></pre>

<hr>
<h2 id='animint2-gganimintproto'>Base gganimintproto classes for ggplot2</h2><span id='topic+animint2-gganimintproto'></span><span id='topic+Geom'></span><span id='topic+GeomCustomAnn'></span><span id='topic+GeomLogticks'></span><span id='topic+GeomPolygon'></span><span id='topic+GeomMap'></span><span id='topic+GeomAnnotationMap'></span><span id='topic+GeomRaster'></span><span id='topic+GeomRasterAnn'></span><span id='topic+Coord'></span><span id='topic+CoordCartesian'></span><span id='topic+CoordFixed'></span><span id='topic+CoordFlip'></span><span id='topic+CoordMap'></span><span id='topic+CoordPolar'></span><span id='topic+CoordQuickmap'></span><span id='topic+CoordTrans'></span><span id='topic+Stat'></span><span id='topic+GeomAbline'></span><span id='topic+GeomRect'></span><span id='topic+GeomBar'></span><span id='topic+GeomBin2d'></span><span id='topic+GeomBlank'></span><span id='topic+GeomPath'></span><span id='topic+GeomLine'></span><span id='topic+GeomStep'></span><span id='topic+GeomContour'></span><span id='topic+GeomCrossbar'></span><span id='topic+GeomSegment'></span><span id='topic+GeomCurve'></span><span id='topic+GeomRibbon'></span><span id='topic+GeomArea'></span><span id='topic+GeomDensity'></span><span id='topic+GeomDensity2d'></span><span id='topic+GeomDotplot'></span><span id='topic+GeomErrorbar'></span><span id='topic+GeomErrorbarh'></span><span id='topic+GeomFreqpoly'></span><span id='topic+GeomHex'></span><span id='topic+GeomHline'></span><span id='topic+GeomLabel'></span><span id='topic+GeomLinerange'></span><span id='topic+GeomPoint'></span><span id='topic+GeomPointrange'></span><span id='topic+GeomRug'></span><span id='topic+GeomSmooth'></span><span id='topic+GeomSpoke'></span><span id='topic+GeomText'></span><span id='topic+GeomTile'></span><span id='topic+GeomViolin'></span><span id='topic+GeomVline'></span><span id='topic+Position'></span><span id='topic+PositionDodge'></span><span id='topic+PositionFill'></span><span id='topic+PositionIdentity'></span><span id='topic+PositionJitter'></span><span id='topic+PositionJitterdodge'></span><span id='topic+PositionNudge'></span><span id='topic+PositionStack'></span><span id='topic+Scale'></span><span id='topic+ScaleContinuous'></span><span id='topic+ScaleDiscrete'></span><span id='topic+ScaleContinuousPosition'></span><span id='topic+ScaleContinuousDatetime'></span><span id='topic+ScaleContinuousDate'></span><span id='topic+ScaleDiscretePosition'></span><span id='topic+ScaleDiscreteIdentity'></span><span id='topic+ScaleContinuousIdentity'></span><span id='topic+a_scales_list'></span><span id='topic+ScalesList'></span><span id='topic+StatBin'></span><span id='topic+StatBin2d'></span><span id='topic+StatBindot'></span><span id='topic+StatBinhex'></span><span id='topic+StatContour'></span><span id='topic+StatCount'></span><span id='topic+StatDensity2d'></span><span id='topic+StatDensity'></span><span id='topic+StatEcdf'></span><span id='topic+StatEllipse'></span><span id='topic+StatFunction'></span><span id='topic+StatIdentity'></span><span id='topic+StatQq'></span><span id='topic+StatSmooth'></span><span id='topic+StatSum'></span><span id='topic+StatSummary2d'></span><span id='topic+StatSummaryBin'></span><span id='topic+StatSummaryHex'></span><span id='topic+StatSummary'></span><span id='topic+StatUnique'></span><span id='topic+StatYdensity'></span><span id='topic+GeomTallRect'></span><span id='topic+GeomWideRect'></span>

<h3>Description</h3>

<p>If you are creating a new geom, stat, position, or scale in another package,
you'll need to extend from <code>animint2::Geom</code>, <code>animint2::Stat</code>,
<code>animint2::Position</code>, or <code>animint2::Scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_scales_list()

ScalesList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ScalesList</code> (inherits from <code>gganimintproto</code>) of length 9.
</p>


<h3>Geoms</h3>

<p>All <code>geom_*</code> functions (like <code>geom_point</code>) return a layer that
contains a <code>Geom*</code> object (like <code>GeomPoint</code>). The <code>Geom*</code>
object is responsible for rendering the data in the plot.
</p>
<p>Each of the <code>Geom*</code> objects is a <code><a href="#topic+gganimintproto">gganimintproto</a></code> object, descended
from the top-level <code>Geom</code>, and each implements various methods and
fields. To create a new type of Geom object, you typically will want to
implement one or more of the following:
</p>
<p>Compared to <code>Stat</code> and <code>Position</code>, <code>Geom</code> is a little
different because the execution of the setup and compute functions is
split up. <code>setup_data</code> runs before position adjustments, and
<code>draw_layer</code> is not run until render time,  much later. This
means there is no <code>setup_params</code> because it's hard to communicate
the changes.
</p>

<ul>
<li><p> Override either <code>draw_panel(self, data, panel_scales, coord)</code> or
<code>draw_group(self, data, panel_scales, coord)</code>. <code>draw_panel</code> is
called once per panel, <code>draw_group</code> is called once per group.
</p>
<p>Use <code>draw_panel</code> if each row in the data represents a
single element. Use <code>draw_group</code> if each group represents
an element (e.g. a smooth, a violin).
</p>
<p><code>data</code> is a data frame of scaled aesthetics. <code>panel_scales</code>
is a list containing information about the scales in the current
panel. <code>coord</code> is a coordinate specification. You'll
need to call <code>coord$transform(data, panel_scales)</code> to work
with non-Cartesian coords. To work with non-linear coordinate systems,
you typically need to convert into a primitive geom (e.g. point, path
or polygon), and then pass on to the corresponding draw method
for munching.
</p>
<p>Must return a grob. Use <code><a href="#topic+zeroGrob">zeroGrob</a></code> if there's nothing to
draw.
</p>
</li>
<li> <p><code>draw_key</code>: Renders a single legend key.
</p>
</li>
<li> <p><code>required_aes</code>: A character vector of aesthetics needed to
render the geom.
</p>
</li>
<li> <p><code>default_aes</code>: A list (generated by <code><a href="#topic+aes">aes</a>()</code> of
default values for aesthetics.
</p>
</li>
<li> <p><code>reparameterise</code>: Converts width and height to xmin and xmax,
and ymin and ymax values. It can potentially set other values as well.
</p>
</li></ul>



<h3>Coordinate systems</h3>

<p>All <code>coord_*</code> functions (like <code>coord_trans</code>) return a <code>Coord*</code>
object (like <code>CoordTrans</code>). The <code>Coord*</code> object is responsible for
adjusting the position of overlapping geoms.
</p>
<p>The way that the <code>coord_*</code> functions work is slightly different from the
<code>geom_*</code> and <code>stat_*</code> functions, because a <code>coord_*</code> function
actually &quot;instantiates&quot; the <code>Coord*</code> object by creating a descendant,
and returns that.
</p>
<p>Each of the <code>Coord*</code> objects is a <code><a href="#topic+gganimintproto">gganimintproto</a></code> object,
descended from the top-level <code>Coord</code>.  To create a new type of Coord
object, you typically will want to implement one or more of the following:
</p>

<ul>
<li> <p><code>aspect</code>: Returns the desired aspect ratio for the plot.
</p>
</li>
<li> <p><code>labels</code>: Returns a list containing labels for x and y.
</p>
</li>
<li> <p><code>render_fg</code>: Renders foreground elements.
</p>
</li>
<li> <p><code>render_bg</code>: Renders background elements.
</p>
</li>
<li> <p><code>render_axis_h</code>: Renders the horizontal axis.
</p>
</li>
<li> <p><code>render_axis_v</code>: Renders the vertical axis.
</p>
</li>
<li> <p><code>range</code>: Returns the x and y ranges
</p>
</li>
<li> <p><code>train</code>: Return the trained scale ranges.
</p>
</li>
<li> <p><code>transform</code>: Transforms x and y coordinates.
</p>
</li>
<li> <p><code>distance</code>: Calculates distance.
</p>
</li>
<li> <p><code>is_linear</code>: Returns <code>TRUE</code> if the coordinate system is
linear; <code>FALSE</code> otherwise.
</p>
</li></ul>



<h3>Stats</h3>

<p>All <code>stat_*</code> functions (like <code>stat_bin</code>) return a layer that
contains a <code>Stat*</code> object (like <code>StatBin</code>). The <code>Stat*</code>
object is responsible for rendering the data in the plot.
</p>
<p>Each of the <code>Stat*</code> objects is a <code><a href="#topic+gganimintproto">gganimintproto</a></code> object, descended
from the top-level <code>Stat</code>, and each implements various methods and
fields. To create a new type of Stat object, you typically will want to
implement one or more of the following:
</p>

<ul>
<li><p> Override one of :
<code>compute_layer(self, data, scales, ...)</code>,
<code>compute_panel(self, data, scales, ...)</code>, or
<code>compute_group(self, data, scales, ...)</code>.
</p>
<p><code>compute_layer()</code> is called once per layer, <code>compute_panel_()</code>
is called once per panel, and <code>compute_group()</code> is called once per
group. All must return a data frame.
</p>
<p>It's usually best to start by overriding <code>compute_group</code>: if
you find substantial performance optimisations, override higher up.
You'll need to read the source code of the default methods to see
what else you should be doing.
</p>
<p><code>data</code> is a data frame containing the variables named according
to the aesthetics that they're mapped to. <code>scales</code> is a list
containing the <code>x</code> and <code>y</code> scales. There functions are called
before the facets are trained, so they are global scales, not local
to the individual panels.<code>...</code> contains the parameters returned by
<code>setup_params()</code>.
</p>
</li>
<li> <p><code>setup_params(data, params)</code>: called once for each layer.
Used to setup defaults that need to complete dataset, and to inform
the user of important choices. Should return list of parameters.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: called once for each layer,
after <code>setp_params()</code>. Should return modified <code>data</code>.
Default methods removes all rows containing a missing value in
required aesthetics (with a warning if <code>!na.rm</code>).
</p>
</li>
<li> <p><code>required_aes</code>: A character vector of aesthetics needed to
render the geom.
</p>
</li>
<li> <p><code>default_aes</code>: A list (generated by <code><a href="#topic+aes">aes</a>()</code> of
default values for aesthetics.
</p>
</li></ul>



<h3>Positions</h3>

<p>All <code>position_*</code> functions (like <code>position_dodge</code>) return a
<code>Position*</code> object (like <code>PositionDodge</code>). The <code>Position*</code>
object is responsible for adjusting the position of overlapping geoms.
</p>
<p>The way that the <code>position_*</code> functions work is slightly different from
the <code>geom_*</code> and <code>stat_*</code> functions, because a <code>position_*</code>
function actually &quot;instantiates&quot; the <code>Position*</code> object by creating a
descendant, and returns that.
</p>
<p>Each of the <code>Position*</code> objects is a <code><a href="#topic+gganimintproto">gganimintproto</a></code> object,
descended from the top-level <code>Position</code>, and each implements the
following methods:
</p>

<ul>
<li> <p><code>compute_layer(self, data, params, panel)</code> is called once
per layer. <code>panel</code> is currently an internal data structure, so
this method should not be overriden.
</p>
</li>
<li> <p><code>compute_panel(self, data, params, panel)</code> is called once per
panel and should return a modified data frame.
</p>
<p><code>data</code> is a data frame containing the variables named according
to the aesthetics that they're mapped to. <code>scales</code> is a list
containing the <code>x</code> and <code>y</code> scales. There functions are called
before the facets are trained, so they are global scales, not local
to the individual panels. <code>params</code> contains the parameters returned by
<code>setup_params()</code>.
</p>
</li>
<li> <p><code>setup_params(data, params)</code>: called once for each layer.
Used to setup defaults that need to complete dataset, and to inform
the user of important choices. Should return list of parameters.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: called once for each layer,
after <code>setp_params()</code>. Should return modified <code>data</code>.
Default checks that required aesthetics are present.
</p>
</li></ul>

<p>And the following fields
</p>

<ul>
<li> <p><code>required_aes</code>: a character vector giving the aesthetics
that must be present for this position adjustment to work.
</p>
</li></ul>



<h3>Scales</h3>

<p>All <code>scale_*</code> functions (like <code>scale_x_continuous</code>) return a
<code>Scale*</code> object (like <code>ScaleContinuous</code>). The <code>Scale*</code>
object represents a single scale.
</p>
<p>Each of the <code>Scale*</code> objects is a <code><a href="#topic+gganimintproto">gganimintproto</a></code> object,
descended from the top-level <code>Scale</code>.
</p>


<h3>See Also</h3>

<p>gganimintproto
</p>

<hr>
<h2 id='animint2dir'>Compile and render an animint in a local directory.</h2><span id='topic+animint2dir'></span>

<h3>Description</h3>

<p>This function converts an animint plot.list into a directory of
files which can be used to render the interactive data
visualization in a web browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animint2dir(
  plot.list,
  out.dir = NULL,
  json.file = "plot.json",
  open.browser = interactive(),
  css.file = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animint2dir_+3A_plot.list">plot.list</code></td>
<td>
<p>a named list of ggplots and option lists.</p>
</td></tr>
<tr><td><code id="animint2dir_+3A_out.dir">out.dir</code></td>
<td>
<p>directory to store html/js/csv files. If it exists
already, it will be removed before writing the new
directory/files.</p>
</td></tr>
<tr><td><code id="animint2dir_+3A_json.file">json.file</code></td>
<td>
<p>character string that names the JSON file with
metadata associated with the plot.</p>
</td></tr>
<tr><td><code id="animint2dir_+3A_open.browser">open.browser</code></td>
<td>
<p>logical (default TRUE if interactive), should R
open a browser? If TRUE, we look at the animint.browser option to
determine how. If it is set to &quot;browseURL&quot; then we use a file URL
(be sure to configure your browser to allow access to local
files, as some browsers block this by default). Otherwise
(default) we use <code>servr::httd(out.dir)</code>.</p>
</td></tr>
<tr><td><code id="animint2dir_+3A_css.file">css.file</code></td>
<td>
<p>character string for non-empty css file to
include. Provided file will be copied to the output directory as
styles.css</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible list of ggplots in list format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('data.table'))setDTthreads(1)#for CRAN.

## Make a Gapminder plot (aka Google motion chart), which is actually
## just a scatterplot with size and color that moves over time.
library(animint2)
data(WorldBank)
gapminder &lt;- list(
  title="Linked scatterplot and time series",
  ts=ggplot()+
    make_tallrect(WorldBank, "year")+
    geom_line(aes(year, life.expectancy, group=country, color=region),
              clickSelects="country",
              data=WorldBank, size=4, alpha=3/5),
  time=list(variable="year",ms=3000),
  duration=list(year=1000),
  scatter=ggplot()+
    geom_point(aes(fertility.rate, life.expectancy,
                   key=country, colour=region, size=population),
               showSelected="year",
               clickSelects="country",
               data=WorldBank)+
    geom_text(aes(fertility.rate, life.expectancy, label=country),
              showSelected=c("country", "year"),
              data=WorldBank)+
    make_text(WorldBank, 5, 80, "year")+
    scale_size_animint(pixel.range=c(2,20), breaks=10^(4:9)))
animint2dir(gapminder)

data(worldPop)
## Linked bar and line plots of world population by subcontinent,
## inspired by polychartjs.
popPlots &lt;- list(
  bars=ggplot()+
    geom_bar(aes(x=subcontinent, y=population),
             clickSelects="subcontinent",
             showSelected="year",
             data=worldPop, stat="identity", position="identity")+
    ## This make_text creates a geom_text that shows the current
    ## selected value of the year variable.
    make_text(worldPop, 1, 3e6, "year")+
    coord_flip(),
  lines=ggplot()+
    ## This make_tallrect tiles the background of the lineplot with
    ## rects that can be clicked to select the year variable.
    make_tallrect(worldPop, "year")+
    ## This geom_point does not have aes(clickSelects) so its alpha
    ## transparency behaves normally: all points have alpha=1/4.
    geom_point(aes(year, population, colour=type),
               data=worldPop, size=4, alpha=1/4)+
    ## This geom_line DOES have aes(clickSelects) so only the
    ## selected line has the specified alpha=3/4. The other
    ## unselected lines have 0.5 less (alpha=1/4).
    geom_line(aes(year, population, group=subcontinent),
              clickSelects="subcontinent",
              data=worldPop, size=4, alpha=3/4))
animint2dir(popPlots)
## Make it animated by specifying year as the variable to animate and
## an interval of 2000 milliseconds between animation frames.
popAnim &lt;- c(popPlots, list(time=list(variable="year",ms=2000)))
animint2dir(popAnim)
## Make the animation smooth by specifying a duration of 1000 ms for
## geoms with aes(showSelected=year).
popSmooth &lt;- c(popAnim, list(duration=list(year=1000)))
animint2dir(popSmooth)

</code></pre>

<hr>
<h2 id='animint2pages'>Publish a list of ggplots as interactive visualizations on a GitHub repository</h2><span id='topic+animint2pages'></span>

<h3>Description</h3>

<p>This function takes a named list of ggplots, generates interactive animations,
and pushes the generated files to a specified GitHub repository. You can
choose to keep the repository private or public.
Before using this function set your appropriate git 'user.username' and 'user.email'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animint2pages(
  plot.list,
  github_repo,
  commit_message = "Commit from animint2pages",
  private = FALSE,
  required_opts = c("title", "source"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animint2pages_+3A_plot.list">plot.list</code></td>
<td>
<p>A named list of ggplots and option lists.</p>
</td></tr>
<tr><td><code id="animint2pages_+3A_github_repo">github_repo</code></td>
<td>
<p>The name of the GitHub repository to which the
files will be pushed.</p>
</td></tr>
<tr><td><code id="animint2pages_+3A_commit_message">commit_message</code></td>
<td>
<p>A string specifying the commit message for
the pushed files.</p>
</td></tr>
<tr><td><code id="animint2pages_+3A_private">private</code></td>
<td>
<p>A logical flag indicating whether the GitHub
repository should be private or not (default FALSE).</p>
</td></tr>
<tr><td><code id="animint2pages_+3A_required_opts">required_opts</code></td>
<td>
<p>Character vector of plot.list element names
which are checked (stop with an error if not present). Use
required_opts=NULL to skip check.</p>
</td></tr>
<tr><td><code id="animint2pages_+3A_...">...</code></td>
<td>
<p>Additional options passed onto <code>animint2dir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the initialized GitHub repository object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(animint2)
p1 &lt;- ggplot(mtcars, aes(x = mpg, y = wt)) +
  geom_point()
p2 &lt;- ggplot(mtcars, aes(x = hp, y = wt)) +
  geom_point()
viz &lt;- list(plot1 = p1, plot2 = p2)
animint2pages(
  viz,
  github_repo = "my_animint2_plots",
  commit_message = "New animint",
  private = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='animintOutput'>Shiny ui output function</h2><span id='topic+animintOutput'></span>

<h3>Description</h3>

<p>Shiny ui output function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animintOutput(outputId)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animintOutput_+3A_outputid">outputId</code></td>
<td>
<p>output variable to read the plot from</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>http://shiny.rstudio.com/articles/building-outputs.html
</p>

<hr>
<h2 id='annotate'>Create an annotation layer.</h2><span id='topic+annotate'></span>

<h3>Description</h3>

<p>This function adds geoms to a plot. Unlike typical a geom function,
the properties of the geoms are not mapped from variables of a data frame,
but are instead passed in as vectors. This is useful for adding small annotations
(such as text labels) or if you have your data in vectors, and for some
reason don't want to put them in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate(
  geom,
  x = NULL,
  y = NULL,
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  xend = NULL,
  yend = NULL,
  ...,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_+3A_geom">geom</code></td>
<td>
<p>name of geom to use for annotation</p>
</td></tr>
<tr><td><code id="annotate_+3A_x">x</code>, <code id="annotate_+3A_y">y</code>, <code id="annotate_+3A_xmin">xmin</code>, <code id="annotate_+3A_ymin">ymin</code>, <code id="annotate_+3A_xmax">xmax</code>, <code id="annotate_+3A_ymax">ymax</code>, <code id="annotate_+3A_xend">xend</code>, <code id="annotate_+3A_yend">yend</code></td>
<td>
<p>positioning aesthetics -
you must specify at least one of these.</p>
</td></tr>
<tr><td><code id="annotate_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="annotate_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all position aesthetics are scaled (i.e. they will expand the
limits of the plot so they are visible), but all other aesthetics are
set. This means that layers created with this function will never
affect the legend.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate("text", x = 4, y = 25, label = "Some text")
p + annotate("text", x = 2:5, y = 25, label = "Some text")
p + annotate("rect", xmin = 3, xmax = 4.2, ymin = 12, ymax = 21,
  alpha = .2)
p + annotate("segment", x = 2.5, xend = 4, y = 15, yend = 25,
  colour = "blue")
p + annotate("pointrange", x = 3.5, y = 20, ymin = 12, ymax = 28,
  colour = "red", size = 1.5)

p + annotate("text", x = 2:3, y = 20:21, label = c("my label", "label 2"))
</code></pre>

<hr>
<h2 id='annotation_custom'>Annotation: Custom grob.</h2><span id='topic+annotation_custom'></span>

<h3>Description</h3>

<p>This is a special geom intended for use as static annotations
that are the same in every panel. These annotations will not
affect scales (i.e. the x and y axes will not grow to cover the range
of the grob, and the grob will not be modified by any ggplot settings or mappings).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_custom(grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_custom_+3A_grob">grob</code></td>
<td>
<p>grob to display</p>
</td></tr>
<tr><td><code id="annotation_custom_+3A_xmin">xmin</code>, <code id="annotation_custom_+3A_xmax">xmax</code></td>
<td>
<p>x location (in data coordinates) giving horizontal
location of raster</p>
</td></tr>
<tr><td><code id="annotation_custom_+3A_ymin">ymin</code>, <code id="annotation_custom_+3A_ymax">ymax</code></td>
<td>
<p>y location (in data coordinates) giving vertical
location of raster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most useful for adding tables, inset plots, and other grid-based decorations.
</p>


<h3>Note</h3>

<p><code>annotation_custom</code> expects the grob to fill the entire viewport
defined by xmin, xmax, ymin, ymax. Grobs with a different (absolute) size
will be center-justified in that region.
Inf values can be used to fill the full plot panel (see examples).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dummy plot
df &lt;- data.frame(x = 1:10, y = 1:10)
base &lt;- ggplot(df, aes(x, y)) +
  geom_blank() +
  theme_bw()

# Full panel annotation
base + annotation_custom(
  grob = grid::roundrectGrob(),
  xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
)

# Inset plot
df2 &lt;- data.frame(x = 1 , y = 1)
g &lt;- ggplotGrob(ggplot(df2, aes(x, y)) +
  geom_point() +
  theme(plot.background = element_rect(colour = "black")))
base +
  annotation_custom(grob = g, xmin = 1, xmax = 10, ymin = 8, ymax = 10)
</code></pre>

<hr>
<h2 id='annotation_logticks'>Annotation: log tick marks</h2><span id='topic+annotation_logticks'></span>

<h3>Description</h3>

<p>This annotation adds log tick marks with diminishing spacing.
These tick marks probably make sense only for base 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_logticks(
  base = 10,
  sides = "bl",
  scaled = TRUE,
  short = unit(0.1, "cm"),
  mid = unit(0.2, "cm"),
  long = unit(0.3, "cm"),
  colour = "black",
  size = 0.5,
  linetype = 1,
  alpha = 1,
  color = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_logticks_+3A_base">base</code></td>
<td>
<p>the base of the log (default 10)</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_sides">sides</code></td>
<td>
<p>a string that controls which sides of the plot the log ticks appear on.
It can be set to a string containing any of <code>"trbl"</code>, for top, right,
bottom, and left.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_scaled">scaled</code></td>
<td>
<p>is the data already log-scaled? This should be <code>TRUE</code>
(default) when the data is already transformed with <code>log10()</code> or when
using <code>scale_y_log10</code>. It should be <code>FALSE</code> when using
<code>coord_trans(y = "log10")</code>.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_short">short</code></td>
<td>
<p>a <code><a href="grid.html#topic+unit">unit</a></code> object specifying the length of the
short tick marks</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_mid">mid</code></td>
<td>
<p>a <code><a href="grid.html#topic+unit">unit</a></code> object specifying the length of the
middle tick marks. In base 10, these are the &quot;5&quot; ticks.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_long">long</code></td>
<td>
<p>a <code><a href="grid.html#topic+unit">unit</a></code> object specifying the length of the
long tick marks. In base 10, these are the &quot;1&quot; (or &quot;10&quot;) ticks.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_colour">colour</code></td>
<td>
<p>Colour of the tick marks.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_size">size</code></td>
<td>
<p>Thickness of tick marks, in mm.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_linetype">linetype</code></td>
<td>
<p>Linetype of tick marks (<code>solid</code>, <code>dashed</code>, etc.)</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_alpha">alpha</code></td>
<td>
<p>The transparency of the tick marks.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_color">color</code></td>
<td>
<p>An alias for <code>colour</code>.</p>
</td></tr>
<tr><td><code id="annotation_logticks_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to the layer</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scale_y_continuous">scale_y_continuous</a></code>, <code><a href="#topic+scale_y_log10">scale_y_log10</a></code> for log scale
transformations.
</p>
<p><code><a href="#topic+coord_trans">coord_trans</a></code> for log coordinate transformations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a log-log plot (without log ticks)
a &lt;- ggplot(msleep, aes(bodywt, brainwt)) +
 geom_point(na.rm = TRUE) +
 scale_x_log10(
   breaks = scales::trans_breaks("log10", function(x) 10^x),
   labels = scales::trans_format("log10", scales::math_format(10^.x))
 ) +
 scale_y_log10(
   breaks = scales::trans_breaks("log10", function(x) 10^x),
   labels = scales::trans_format("log10", scales::math_format(10^.x))
 ) +
 theme_bw()

a + annotation_logticks()                # Default: log ticks on bottom and left
a + annotation_logticks(sides = "lr")    # Log ticks for y, on left and right
a + annotation_logticks(sides = "trbl")  # All four sides

# Hide the minor grid lines because they don't align with the ticks
a + annotation_logticks(sides = "trbl") + theme(panel.grid.minor = element_blank())

# Another way to get the same results as 'a' above: log-transform the data before
# plotting it. Also hide the minor grid lines.
b &lt;- ggplot(msleep, aes(log10(bodywt), log10(brainwt))) +
 geom_point(na.rm = TRUE) +
 scale_x_continuous(name = "body", labels = scales::math_format(10^.x)) +
 scale_y_continuous(name = "brain", labels = scales::math_format(10^.x)) +
 theme_bw() + theme(panel.grid.minor = element_blank())

b + annotation_logticks()

# Using a coordinate transform requires scaled = FALSE
t &lt;- ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  coord_trans(x = "log10", y = "log10") +
  theme_bw()
t + annotation_logticks(scaled = FALSE)

# Change the length of the ticks
a + annotation_logticks(
  short = unit(.5,"mm"),
  mid = unit(3,"mm"),
  long = unit(4,"mm")
)
</code></pre>

<hr>
<h2 id='annotation_map'>Annotation: maps.</h2><span id='topic+annotation_map'></span>

<h3>Description</h3>

<p>Annotation: maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_map(map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_map_+3A_map">map</code></td>
<td>
<p>data frame representing a map.  Most map objects can be
converted into the right format by using <code><a href="#topic+fortify">fortify</a></code></p>
</td></tr>
<tr><td><code id="annotation_map_+3A_...">...</code></td>
<td>
<p>other arguments used to modify aesthetics</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {
usamap &lt;- map_data("state")

seal.sub &lt;- subset(seals, long &gt; -130 &amp; lat &lt; 45 &amp; lat &gt; 40)
ggplot(seal.sub, aes(x = long, y = lat)) +
  annotation_map(usamap, fill = "NA", colour = "grey50") +
  geom_segment(aes(xend = long + delta_long, yend = lat + delta_lat))

seal2 &lt;- transform(seal.sub,
  latr = cut(lat, 2),
  longr = cut(long, 2))

ggplot(seal2,  aes(x = long, y = lat)) +
  annotation_map(usamap, fill = "NA", colour = "grey50") +
  geom_segment(aes(xend = long + delta_long, yend = lat + delta_lat)) +
  facet_grid(latr ~ longr, scales = "free", space = "free")
}
</code></pre>

<hr>
<h2 id='annotation_raster'>Annotation: High-performance rectangular tiling.</h2><span id='topic+annotation_raster'></span>

<h3>Description</h3>

<p>This is a special version of <code><a href="#topic+geom_raster">geom_raster</a></code> optimised for static
annotations that are the same in every panel. These annotations will not
affect scales (i.e. the x and y axes will not grow to cover the range
of the raster, and the raster must already have its own colours).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_raster(raster, xmin, xmax, ymin, ymax, interpolate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_raster_+3A_raster">raster</code></td>
<td>
<p>raster object to display</p>
</td></tr>
<tr><td><code id="annotation_raster_+3A_xmin">xmin</code>, <code id="annotation_raster_+3A_xmax">xmax</code></td>
<td>
<p>x location (in data coordinates) giving horizontal
location of raster</p>
</td></tr>
<tr><td><code id="annotation_raster_+3A_ymin">ymin</code>, <code id="annotation_raster_+3A_ymax">ymax</code></td>
<td>
<p>y location (in data coordinates) giving vertical
location of raster</p>
</td></tr>
<tr><td><code id="annotation_raster_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most useful for adding bitmap images.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
rainbow &lt;- matrix(hcl(seq(0, 360, length.out = 50 * 50), 80, 70), nrow = 50)
ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  annotation_raster(rainbow, 15, 20, 3, 4)
# To fill up whole plot
ggplot(mtcars, aes(mpg, wt)) +
  annotation_raster(rainbow, -Inf, Inf, -Inf, Inf) +
  geom_point()

rainbow2 &lt;- matrix(hcl(seq(0, 360, length.out = 10), 80, 70), nrow = 1)
ggplot(mtcars, aes(mpg, wt)) +
  annotation_raster(rainbow2, -Inf, Inf, -Inf, Inf) +
  geom_point()
rainbow2 &lt;- matrix(hcl(seq(0, 360, length.out = 10), 80, 70), nrow = 1)
ggplot(mtcars, aes(mpg, wt)) +
  annotation_raster(rainbow2, -Inf, Inf, -Inf, Inf, interpolate = TRUE) +
  geom_point()
</code></pre>

<hr>
<h2 id='as_labeller'>Coerce to labeller function</h2><span id='topic+as_labeller'></span>

<h3>Description</h3>

<p>This transforms objects to labeller functions. Used internally by
<code><a href="#topic+labeller">labeller</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_labeller(x, default = label_value, multi_line = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_labeller_+3A_x">x</code></td>
<td>
<p>Object to coerce to a labeller function. If a named
character vector, it is used as a lookup table before being
passed on to <code>default</code>. If a non-labeller function, it is
assumed it takes and returns character vectors and is applied to
the labels. If a labeller, it is simply applied to the labels.</p>
</td></tr>
<tr><td><code id="as_labeller_+3A_default">default</code></td>
<td>
<p>Default labeller to process the labels produced by
lookup tables or modified by non-labeller functions.</p>
</td></tr>
<tr><td><code id="as_labeller_+3A_multi_line">multi_line</code></td>
<td>
<p>Whether to display the labels of multiple factors
on separate lines. This is passed to the labeller function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+labeller">labeller</a>()</code>, <a href="#topic+labellers">labellers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(disp, drat)) + geom_point()
p + facet_wrap(~am)

# Rename labels on the fly with a lookup character vector
to_string &lt;- as_labeller(c(`0` = "Zero", `1` = "One"))
p + facet_wrap(~am, labeller = to_string)

# Quickly transform a function operating on character vectors to a
# labeller function:
appender &lt;- function(string, suffix = "-foo") paste0(string, suffix)
p + facet_wrap(~am, labeller = as_labeller(appender))

# If you have more than one facetting variable, be sure to dispatch
# your labeller to the right variable with labeller()
p + facet_grid(cyl ~ am, labeller = labeller(am = to_string))
</code></pre>

<hr>
<h2 id='as.list.gganimintproto'>Convert a gganimintproto object to a list</h2><span id='topic+as.list.gganimintproto'></span>

<h3>Description</h3>

<p>This will not include the object's <code>super</code> member.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gganimintproto'
as.list(x, inherit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.gganimintproto_+3A_x">x</code></td>
<td>
<p>A gganimintproto object to convert to a list.</p>
</td></tr>
<tr><td><code id="as.list.gganimintproto_+3A_inherit">inherit</code></td>
<td>
<p>If <code>TRUE</code> (the default), flatten all inherited items into
the returned list. If <code>FALSE</code>, do not include any inherited items.</p>
</td></tr>
<tr><td><code id="as.list.gganimintproto_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code>as.list.environment</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='autoplot'>Create a complete ggplot appropriate to a particular data type</h2><span id='topic+autoplot'></span>

<h3>Description</h3>

<p><code>autoplot</code> uses ggplot2 to draw a particular plot for an object of a
particular class in a single command. This defines the S3 generic that
other classes and packages can extend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot_+3A_object">object</code></td>
<td>
<p>an object, whose class will determine the behaviour of autoplot</p>
</td></tr>
<tr><td><code id="autoplot_+3A_...">...</code></td>
<td>
<p>other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggplot">ggplot</a></code> and <code><a href="#topic+fortify">fortify</a></code>
</p>

<hr>
<h2 id='benchplot'>Benchmark plot creation time.
Broken down into construct, build, render and draw times.</h2><span id='topic+benchplot'></span>

<h3>Description</h3>

<p>Benchmark plot creation time.
Broken down into construct, build, render and draw times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchplot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="benchplot_+3A_x">x</code></td>
<td>
<p>code to create ggplot2 plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>benchplot(ggplot(mtcars, aes(mpg, wt)) + geom_point())
benchplot(ggplot(mtcars, aes(mpg, wt)) + geom_point() + facet_grid(. ~ cyl))
</code></pre>

<hr>
<h2 id='borders'>Create a layer of map borders.</h2><span id='topic+borders'></span>

<h3>Description</h3>

<p>Create a layer of map borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>borders(
  database = "world",
  regions = ".",
  fill = NA,
  colour = "grey50",
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="borders_+3A_database">database</code></td>
<td>
<p>map data, see <code><a href="maps.html#topic+map">map</a></code> for details</p>
</td></tr>
<tr><td><code id="borders_+3A_regions">regions</code></td>
<td>
<p>map region</p>
</td></tr>
<tr><td><code id="borders_+3A_fill">fill</code></td>
<td>
<p>fill colour</p>
</td></tr>
<tr><td><code id="borders_+3A_colour">colour</code></td>
<td>
<p>border colour</p>
</td></tr>
<tr><td><code id="borders_+3A_xlim">xlim</code>, <code id="borders_+3A_ylim">ylim</code></td>
<td>
<p>latitudinal and logitudinal range for extracting map
polygons, see <code><a href="maps.html#topic+map">map</a></code> for details.</p>
</td></tr>
<tr><td><code id="borders_+3A_...">...</code></td>
<td>
<p>other arguments passed onto <code><a href="#topic+geom_polygon">geom_polygon</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {

ia &lt;- map_data("county", "iowa")
mid_range &lt;- function(x) mean(range(x))
seats &lt;- plyr::ddply(ia, "subregion", plyr::colwise(mid_range, c("lat", "long")))
ggplot(ia, aes(long, lat)) +
  geom_polygon(aes(group = group), fill = NA, colour = "grey60") +
  geom_text(aes(label = subregion), data = seats, size = 2, angle = 45)

data(us.cities)
capitals &lt;- subset(us.cities, capital == 2)
ggplot(capitals, aes(long, lat)) +
  borders("state") +
  geom_point(aes(size = pop)) +
  scale_size_area() +
  coord_quickmap()

# Same map, with some world context
ggplot(capitals, aes(long, lat)) +
  borders("world", xlim = c(-130, -60), ylim = c(20, 50)) +
  geom_point(aes(size = pop)) +
  scale_size_area() +
  coord_quickmap()
}
</code></pre>

<hr>
<h2 id='breakpoints'>
The breakpointError of simulated signals
</h2><span id='topic+breakpoints'></span>

<h3>Description</h3>

<p>Two noisy signals were sampled from a latent signal with known
breakpoints, which were used to measure the error of estimated
models with 1,...,20 segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breakpoints)</code></pre>


<h3>Format</h3>

<p>A list of 5 data.frames: error contains the breakpointError of the
estimated models, signals contains the noisy signals, breaks contains
the breakpoints in the estimated signals, segments contains the
estimated segments, and imprecision contains the normalized imprecision
curves which were used to evaluate the error.
</p>


<h3>Source</h3>

<p>The breakpointError package was used to measure the model error, see
etc/breakpoints.R. 
</p>

<hr>
<h2 id='calc_element'>Calculate the element properties, by inheriting properties from its parents</h2><span id='topic+calc_element'></span>

<h3>Description</h3>

<p>Calculate the element properties, by inheriting properties from its parents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_element(element, theme, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_element_+3A_element">element</code></td>
<td>
<p>The name of the theme element to calculate</p>
</td></tr>
<tr><td><code id="calc_element_+3A_theme">theme</code></td>
<td>
<p>A theme object (like theme_grey())</p>
</td></tr>
<tr><td><code id="calc_element_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, print out which elements this one inherits from</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- theme_grey()
calc_element('text', t)

# Compare the "raw" element definition to the element with calculated inheritance
t$axis.text.x
calc_element('axis.text.x', t, verbose = TRUE)

# This reports that axis.text.x inherits from axis.text,
# which inherits from text. You can view each of them with:
t$axis.text.x
t$axis.text
t$text

</code></pre>

<hr>
<h2 id='checkAnimationTimeVar'>Check animation variable for errors</h2><span id='topic+checkAnimationTimeVar'></span>

<h3>Description</h3>

<p>Check animation variable for errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkAnimationTimeVar(timeVarList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkAnimationTimeVar_+3A_timevarlist">timeVarList</code></td>
<td>
<p><code>plot.list$time</code> in <code>animint2dir</code> to check
for errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> :Stops with an error for invalid input
</p>

<hr>
<h2 id='checkExtraParams'>Check <code>extra_params</code> argument for duplicates, non-named list</h2><span id='topic+checkExtraParams'></span>

<h3>Description</h3>

<p>Check <code>extra_params</code> argument for duplicates, non-named list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkExtraParams(extra_params, aes_mapping)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkExtraParams_+3A_extra_params">extra_params</code></td>
<td>
<p>named list containing the details of showSelected
and clickSelects values of the layer</p>
</td></tr>
<tr><td><code id="checkExtraParams_+3A_aes_mapping">aes_mapping</code></td>
<td>
<p>aesthetics mapping of the layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified <code>extra_params</code> list
</p>

<hr>
<h2 id='checkForSSandCSasAesthetics'>Check if showSelected and clickSelects have been used as aesthetics
as in old syntax. If yes, raise error</h2><span id='topic+checkForSSandCSasAesthetics'></span>

<h3>Description</h3>

<p>Check if showSelected and clickSelects have been used as aesthetics
as in old syntax. If yes, raise error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkForSSandCSasAesthetics(aesthetics, plot_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkForSSandCSasAesthetics_+3A_aesthetics">aesthetics</code></td>
<td>
<p>list. aesthetics mapping of the layer</p>
</td></tr>
<tr><td><code id="checkForSSandCSasAesthetics_+3A_plot_name">plot_name</code></td>
<td>
<p>character vector of the plot the layer belongs to</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> Throws error if used as aesthetics
</p>

<hr>
<h2 id='checkPlotForAnimintExtensions'>Performs error checking on the plot for animint extensions</h2><span id='topic+checkPlotForAnimintExtensions'></span>

<h3>Description</h3>

<p>Performs error checking on the plot for animint extensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPlotForAnimintExtensions(p, plot_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPlotForAnimintExtensions_+3A_p">p</code></td>
<td>
<p>plot from <code>plot.list</code> to check for errors</p>
</td></tr>
<tr><td><code id="checkPlotForAnimintExtensions_+3A_plot_name">plot_name</code></td>
<td>
<p>plot name error check. Should be alphanumeric and should
begin with an alphabet</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> :Stops with an error for invalid input
</p>

<hr>
<h2 id='checkPlotList'>Check plot.list for errors</h2><span id='topic+checkPlotList'></span>

<h3>Description</h3>

<p>Check that plot.list is a list and every element is named
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPlotList(plot.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPlotList_+3A_plot.list">plot.list</code></td>
<td>
<p>from <code>animint2dir</code> to check for errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an error for invalid values
</p>

<hr>
<h2 id='checkSingleShowSelectedValue'>Issue warnings for non interactive plots where there is only one
showSelected value</h2><span id='topic+checkSingleShowSelectedValue'></span>

<h3>Description</h3>

<p>Issue warnings for non interactive plots where there is only one
showSelected value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSingleShowSelectedValue(selectors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSingleShowSelectedValue_+3A_selectors">selectors</code></td>
<td>
<p>selectors to check for warnings</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='colsNotToCopy'>Filter out columns that do not need to be copied</h2><span id='topic+colsNotToCopy'></span>

<h3>Description</h3>

<p>Filter out columns that do not need to be copied
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colsNotToCopy(g, s.aes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colsNotToCopy_+3A_g">g</code></td>
<td>
<p>Geom with columns</p>
</td></tr>
<tr><td><code id="colsNotToCopy_+3A_s.aes">s.aes</code></td>
<td>
<p>Selector aesthetics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of columns not to be copied
</p>

<hr>
<h2 id='continuous_scale'>Continuous scale constructor.</h2><span id='topic+continuous_scale'></span>

<h3>Description</h3>

<p>Continuous scale constructor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous_scale(
  aesthetics,
  scale_name,
  palette,
  name = waiver(),
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  rescaler = rescale,
  oob = censor,
  expand = waiver(),
  na.value = NA_real_,
  trans = "identity",
  guide = "legend"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuous_scale_+3A_aesthetics">aesthetics</code></td>
<td>
<p>the names of the aesthetics that this scale works with</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_scale_name">scale_name</code></td>
<td>
<p>the name of the scale</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_palette">palette</code></td>
<td>
<p>a palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as axis or legend title. If
<code>NULL</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_breaks">breaks</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
transformation object
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="continuous_scale_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks.
</p>
</li></ul>
</td></tr>
<tr><td><code id="continuous_scale_+3A_labels">labels</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="continuous_scale_+3A_limits">limits</code></td>
<td>
<p>A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_rescaler">rescaler</code></td>
<td>
<p>Used by diverging and n colour gradients
(i.e. <code><a href="#topic+scale_colour_gradient2">scale_colour_gradient2</a></code>, <code><a href="#topic+scale_colour_gradientn">scale_colour_gradientn</a></code>).
A function used to scale the input values to the range [0, 1].</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_oob">oob</code></td>
<td>
<p>Function that handles limits outside of the scale limits
(out of bounds). The default replaces out of bounds values with NA.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_expand">expand</code></td>
<td>
<p>A numeric vector of length two giving multiplicative and
additive expansion constants. These constants ensure that the data is
placed some distance away from the axes. The defaults are
<code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for
discrete variables.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_trans">trans</code></td>
<td>
<p>Either the name of a transformation object, or the
object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;exp&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;reciprocal&quot;, &quot;reverse&quot; and &quot;sqrt&quot;.
</p>
<p>A transformation object bundles together a transform, it's inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code>name_trans</code>, e.g.
<code><a href="scales.html#topic+boxcox_trans">boxcox_trans</a></code>. You can create your own
transformation with <code><a href="scales.html#topic+trans_new">trans_new</a></code>.</p>
</td></tr>
<tr><td><code id="continuous_scale_+3A_guide">guide</code></td>
<td>
<p>Name of guide object, or object itself.</p>
</td></tr>
</table>

<hr>
<h2 id='coord_cartesian'>Cartesian coordinates.</h2><span id='topic+coord_cartesian'></span>

<h3>Description</h3>

<p>The Cartesian coordinate system is the most familiar, and common, type of
coordinate system. Setting limits on the coordinate system will zoom the
plot (like you're looking at it with a magnifying glass), and will not
change the underlying data like setting limits on a scale will.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_cartesian(xlim = NULL, ylim = NULL, expand = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_cartesian_+3A_xlim">xlim</code>, <code id="coord_cartesian_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="coord_cartesian_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># There are two ways of zooming the plot display: with scales or
# with coordinate systems.  They work in two rather different ways.

p &lt;- ggplot(mtcars, aes(disp, wt)) +
  geom_point() +
  geom_smooth()
p

# Setting the limits on a scale converts all values outside the range to NA.
p + scale_x_continuous(limits = c(325, 500))

# Setting the limits on the coordinate system performs a visual zoom.
# The data is unchanged, and we just view a small portion of the original
# plot. Note how smooth continues past the points visible on this plot.
p + coord_cartesian(xlim = c(325, 500))

# By default, the same expansion factor is applied as when setting scale
# limits. You can set the limits precisely by setting expand = FALSE
p + coord_cartesian(xlim = c(325, 500), expand = FALSE)

# Simiarly, we can use expand = FALSE to turn off expansion with the
# default limits
p + coord_cartesian(expand = FALSE)

# You can see the same thing with this 2d histogram
d &lt;- ggplot(diamonds, aes(carat, price)) +
  stat_bin2d(bins = 25, colour = "white")
d

# When zooming the scale, the we get 25 new bins that are the same
# size on the plot, but represent smaller regions of the data space
d + scale_x_continuous(limits = c(0, 1))

# When zooming the coordinate system, we see a subset of original 50 bins,
# displayed bigger
d + coord_cartesian(xlim = c(0, 1))
</code></pre>

<hr>
<h2 id='coord_fixed'>Cartesian coordinates with fixed relationship between x and y scales.</h2><span id='topic+coord_fixed'></span><span id='topic+coord_equal'></span>

<h3>Description</h3>

<p>A fixed scale coordinate system forces a specified ratio between the
physical representation of data units on the axes. The ratio represents the
number of units on the y-axis equivalent to one unit on the x-axis. The
default, <code>ratio = 1</code>, ensures that one unit on the x-axis is the same
length as one unit on the y-axis. Ratios higher than one make units on the
y axis longer than units on the x-axis, and vice versa. This is similar to
<code><a href="MASS.html#topic+eqscplot">eqscplot</a></code>, but it works for all types of graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_fixed_+3A_ratio">ratio</code></td>
<td>
<p>aspect ratio, expressed as <code>y / x</code></p>
</td></tr>
<tr><td><code id="coord_fixed_+3A_xlim">xlim</code>, <code id="coord_fixed_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="coord_fixed_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ensures that the ranges of axes are equal to the specified ratio by
# adjusting the plot aspect ratio

p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point()
p + coord_fixed(ratio = 1)
p + coord_fixed(ratio = 5)
p + coord_fixed(ratio = 1/5)

# Resize the plot to see that the specified aspect ratio is maintained
</code></pre>

<hr>
<h2 id='coord_flip'>Flipped cartesian coordinates.</h2><span id='topic+coord_flip'></span>

<h3>Description</h3>

<p>Flipped cartesian coordinates so that horizontal becomes vertical, and
vertical, horizontal. This is primarily useful for converting geoms and
statistics which display y conditional on x, to x conditional on y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_flip(xlim = NULL, ylim = NULL, expand = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_flip_+3A_xlim">xlim</code>, <code id="coord_flip_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="coord_flip_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- ggplot(diamonds, aes(carat)) +
  geom_histogram()
h
h + coord_flip()
h + coord_flip() + scale_x_reverse()

# You can also use it to flip line and area plots:
df &lt;- data.frame(x = 1:5, y = (1:5) ^ 2)
ggplot(df, aes(x, y)) +
  geom_area()
last_plot() + coord_flip()
</code></pre>

<hr>
<h2 id='coord_map'>Map projections.</h2><span id='topic+coord_map'></span><span id='topic+coord_quickmap'></span>

<h3>Description</h3>

<p>The representation of a portion of the earth, which is approximately spherical,
onto a flat 2D plane requires a projection. This is what
<code><a href="#topic+coord_map">coord_map</a></code> does. These projections account for the fact that the
actual length (in km) of one degree of longitude varies between the equator
and the pole. Near the equator, the ratio between the lengths of one degree
of latitude and one degree of longitude is approximately 1. Near the pole, it
is tends towards infinity because the length of one degree of longitude tends
towards 0. For regions that span only a few degrees and are not too close to
the poles, setting the aspect ratio of the plot to the appropriate lat/lon
ratio approximates the usual mercator projection. This is what
<code>coord_quickmap</code> does. With <code><a href="#topic+coord_map">coord_map</a></code> all elements of the
graphic have to be projected which is not the case here. So
<code><a href="#topic+coord_quickmap">coord_quickmap</a></code> has the advantage of being much faster, in
particular for complex plots such as those using with
<code><a href="#topic+geom_tile">geom_tile</a></code>, at the expense of correctness in the projection.
This coordinate system provides the full range of map projections available
in the mapproj package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_map(
  projection = "mercator",
  ...,
  orientation = NULL,
  xlim = NULL,
  ylim = NULL
)

coord_quickmap(xlim = NULL, ylim = NULL, expand = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_map_+3A_projection">projection</code></td>
<td>
<p>projection to use, see
<code><a href="mapproj.html#topic+mapproject">mapproject</a></code> for list</p>
</td></tr>
<tr><td><code id="coord_map_+3A_...">...</code></td>
<td>
<p>other arguments passed on to
<code><a href="mapproj.html#topic+mapproject">mapproject</a></code></p>
</td></tr>
<tr><td><code id="coord_map_+3A_orientation">orientation</code></td>
<td>
<p>projection orientation, which defaults to
<code>c(90, 0, mean(range(x)))</code>.  This is not optimal for many
projections, so you will have to supply your own. See
<code><a href="mapproj.html#topic+mapproject">mapproject</a></code> for more information.</p>
</td></tr>
<tr><td><code id="coord_map_+3A_xlim">xlim</code></td>
<td>
<p>manually specific x limits (in degrees of longitude)</p>
</td></tr>
<tr><td><code id="coord_map_+3A_ylim">ylim</code></td>
<td>
<p>manually specific y limits (in degrees of latitude)</p>
</td></tr>
<tr><td><code id="coord_map_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {
nz &lt;- map_data("nz")
# Prepare a map of NZ
nzmap &lt;- ggplot(nz, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")

# Plot it in cartesian coordinates
nzmap
# With correct mercator projection
nzmap + coord_map()
# With the aspect ratio approximation
nzmap + coord_quickmap()

# Other projections
nzmap + coord_map("cylindrical")
nzmap + coord_map("azequalarea", orientation = c(-36.92,174.6,0))

states &lt;- map_data("state")
usamap &lt;- ggplot(states, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")

# Use cartesian coordinates
usamap
# With mercator projection
usamap + coord_map()
usamap + coord_quickmap()
# See ?mapproject for coordinate systems and their parameters
usamap + coord_map("gilbert")
usamap + coord_map("lagrange")

# For most projections, you'll need to set the orientation yourself
# as the automatic selection done by mapproject is not available to
# ggplot
usamap + coord_map("orthographic")
usamap + coord_map("stereographic")
usamap + coord_map("conic", lat0 = 30)
usamap + coord_map("bonne", lat0 = 50)

# World map, using geom_path instead of geom_polygon
world &lt;- map_data("world")
worldmap &lt;- ggplot(world, aes(x = long, y = lat, group = group)) +
  geom_path() +
  scale_y_continuous(breaks = (-2:2) * 30) +
  scale_x_continuous(breaks = (-4:4) * 45)

# Orthographic projection with default orientation (looking down at North pole)
worldmap + coord_map("ortho")
# Looking up up at South Pole
worldmap + coord_map("ortho", orientation = c(-90, 0, 0))
# Centered on New York (currently has issues with closing polygons)
worldmap + coord_map("ortho", orientation = c(41, -74, 0))
}
</code></pre>

<hr>
<h2 id='coord_munch'>Munch coordinates data</h2><span id='topic+coord_munch'></span>

<h3>Description</h3>

<p>This function &quot;munches&quot; lines, dividing each line into many small pieces
so they can be transformed independently. Used inside geom functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_munch(coord, data, range, segment_length = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_munch_+3A_coord">coord</code></td>
<td>
<p>Coordinate system definition.</p>
</td></tr>
<tr><td><code id="coord_munch_+3A_data">data</code></td>
<td>
<p>Data set to transform - should have variables <code>x</code> and
<code>y</code> are chopped up into small pieces (as defined by <code>group</code>).
All other variables are duplicated as needed.</p>
</td></tr>
<tr><td><code id="coord_munch_+3A_range">range</code></td>
<td>
<p>Panel range specification.</p>
</td></tr>
<tr><td><code id="coord_munch_+3A_segment_length">segment_length</code></td>
<td>
<p>Target segment length</p>
</td></tr>
</table>

<hr>
<h2 id='coord_polar'>Polar coordinates.</h2><span id='topic+coord_polar'></span>

<h3>Description</h3>

<p>The polar coordinate system is most commonly used for pie charts, which
are a stacked bar chart in polar coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_polar(theta = "x", start = 0, direction = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_polar_+3A_theta">theta</code></td>
<td>
<p>variable to map angle to (<code>x</code> or <code>y</code>)</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_start">start</code></td>
<td>
<p>offset of starting point from 12 o'clock in radians</p>
</td></tr>
<tr><td><code id="coord_polar_+3A_direction">direction</code></td>
<td>
<p>1, clockwise; -1, anticlockwise</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># NOTE: Use these plots with caution - polar coordinates has
# major perceptual problems.  The main point of these examples is
# to demonstrate how these common plots can be described in the
# grammar.  Use with EXTREME caution.

#' # A pie chart = stacked bar chart + polar coordinates
pie &lt;- ggplot(mtcars, aes(x = factor(1), fill = factor(cyl))) +
 geom_bar(width = 1)
pie + coord_polar(theta = "y")



# A coxcomb plot = bar chart + polar coordinates
cxc &lt;- ggplot(mtcars, aes(x = factor(cyl))) +
  geom_bar(width = 1, colour = "black")
cxc + coord_polar()
# A new type of plot?
cxc + coord_polar(theta = "y")

# The bullseye chart
pie + coord_polar()

# Hadley's favourite pie chart
df &lt;- data.frame(
  variable = c("does not resemble", "resembles"),
  value = c(20, 80)
)
ggplot(df, aes(x = "", y = value, fill = variable)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_manual(values = c("red", "yellow")) +
  coord_polar("y", start = pi / 3) +
  labs(title = "Pac man")

# Windrose + doughnut plot
if (require("ggplot2movies")) {
movies$rrating &lt;- cut_interval(movies$rating, length = 1)
movies$budgetq &lt;- cut_number(movies$budget, 4)

doh &lt;- ggplot(movies, aes(x = rrating, fill = budgetq))

# Wind rose
doh + geom_bar(width = 1) + coord_polar()
# Race track plot
doh + geom_bar(width = 0.9, position = "fill") + coord_polar(theta = "y")
}

</code></pre>

<hr>
<h2 id='coord_trans'>Transformed cartesian coordinate system.</h2><span id='topic+coord_trans'></span>

<h3>Description</h3>

<p><code>coord_trans</code> is different to scale transformations in that it occurs after
statistical transformation and will affect the visual appearance of geoms - there is
no guarantee that straight lines will continue to be straight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_trans(
  x = "identity",
  y = "identity",
  limx = NULL,
  limy = NULL,
  xtrans,
  ytrans
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_trans_+3A_x">x</code>, <code id="coord_trans_+3A_y">y</code></td>
<td>
<p>transformers for x and y axes</p>
</td></tr>
<tr><td><code id="coord_trans_+3A_limx">limx</code>, <code id="coord_trans_+3A_limy">limy</code></td>
<td>
<p>limits for x and y axes. (Named so for backward
compatibility)</p>
</td></tr>
<tr><td><code id="coord_trans_+3A_xtrans">xtrans</code>, <code id="coord_trans_+3A_ytrans">ytrans</code></td>
<td>
<p>Deprecated; use <code>x</code> and <code>y</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All current transformations only work with continuous values - see
<code><a href="scales.html#topic+trans_new">trans_new</a></code> for list of transformations, and instructions on
how to create your own.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Three ways of doing transformation in ggplot:
#  * by transforming the data
ggplot(diamonds, aes(log10(carat), log10(price))) +
  geom_point()
#  * by transforming the scales
ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()
#  * by transforming the coordinate system:
ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  coord_trans(x = "log10", y = "log10")

# The difference between transforming the scales and
# transforming the coordinate system is that scale
# transformation occurs BEFORE statistics, and coordinate
# transformation afterwards.  Coordinate transformation also
# changes the shape of geoms:

d &lt;- subset(diamonds, carat &gt; 0.5)

ggplot(d, aes(carat, price)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_log10() +
  scale_y_log10()

ggplot(d, aes(carat, price)) +
  geom_point() +
  geom_smooth(method = "lm") +
  coord_trans(x = "log10", y = "log10")

# Here I used a subset of diamonds so that the smoothed line didn't
# drop below zero, which obviously causes problems on the log-transformed
# scale

# With a combination of scale and coordinate transformation, it's
# possible to do back-transformations:
ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_log10() +
  scale_y_log10() +
  coord_trans(x = scales::exp_trans(10), y = scales::exp_trans(10))

# cf.
ggplot(diamonds, aes(carat, price)) +
  geom_point() +
  geom_smooth(method = "lm")

# Also works with discrete scales
df &lt;- data.frame(a = abs(rnorm(26)),letters)
plot &lt;- ggplot(df,aes(a,letters)) + geom_point()

plot + coord_trans(x = "log10")
plot + coord_trans(x = "sqrt")

</code></pre>

<hr>
<h2 id='cut_interval'>Cut up numeric vector into useful groups.</h2><span id='topic+cut_interval'></span><span id='topic+cut_number'></span><span id='topic+cut_width'></span>

<h3>Description</h3>

<p><code>cut_interval</code> makes <code>n</code> groups with equal range, <code>cut_number</code>
makes <code>n</code> groups with (approximately) equal numbers of observations;
<code>cut_width</code> makes groups of width <code>width</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_interval(x, n = NULL, length = NULL, ...)

cut_number(x, n = NULL, ...)

cut_width(
  x,
  width,
  center = NULL,
  boundary = NULL,
  closed = c("right", "left")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_interval_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_n">n</code></td>
<td>
<p>number of intervals to create, OR</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_length">length</code></td>
<td>
<p>length of each interval</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="base.html#topic+cut">cut</a></code></p>
</td></tr>
<tr><td><code id="cut_interval_+3A_width">width</code></td>
<td>
<p>The bin width.</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_center">center</code>, <code id="cut_interval_+3A_boundary">boundary</code></td>
<td>
<p>Specify either the position of edge or the center of
a bin. Since all bins are aligned, specifying the position of a single bin
(which doesn't need to be in the range of the data) affects the location of
all bins. If not specified, uses the &quot;tile layers algorithm&quot;, and sets
the boundary to half of the binwidth.
</p>
<p>To center on integers, <code>width = 1</code> and <code>center = 0</code>.
<code>boundary = 0.5</code>.</p>
</td></tr>
<tr><td><code id="cut_interval_+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Randall Prium contributed most of the implementation of
<code>cut_width</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cut_number">cut_number</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>table(cut_interval(1:100, 10))
table(cut_interval(1:100, 11))

table(cut_number(runif(1000), 10))

table(cut_width(runif(1000), 0.1))
table(cut_width(runif(1000), 0.1, boundary = 0))
table(cut_width(runif(1000), 0.1, center = 0))
</code></pre>

<hr>
<h2 id='diamonds'>Prices of 50,000 round cut diamonds</h2><span id='topic+diamonds'></span>

<h3>Description</h3>

<p>A dataset containing the prices and other attributes of almost 54,000
diamonds. The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diamonds
</code></pre>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables:
</p>

<ul>
<li><p> price: price in US dollars ($326&ndash;$18,823)
</p>
</li>
<li><p> carat: weight of the diamond (0.2&ndash;5.01)
</p>
</li>
<li><p> cut: quality of the cut (Fair, Good, Very Good, Premium, Ideal)
</p>
</li>
<li><p> color: diamond colour, from J (worst) to D (best)
</p>
</li>
<li><p> clarity: a measurement of how clear the diamond is
(I1 (worst), SI1, SI2, VS1, VS2, VVS1, VVS2, IF (best))
</p>
</li>
<li><p> x: length in mm (0&ndash;10.74)
</p>
</li>
<li><p> y: width in mm (0&ndash;58.9)
</p>
</li>
<li><p> z: depth in mm (0&ndash;31.8)
</p>
</li>
<li><p> depth: total depth percentage = z / mean(x, y) = 2 * z / (x + y) (43&ndash;79)
</p>
</li>
<li><p> table: width of top of diamond relative to widest point (43&ndash;95)
</p>
</li></ul>


<hr>
<h2 id='discrete_scale'>Discrete scale constructor.</h2><span id='topic+discrete_scale'></span>

<h3>Description</h3>

<p>Discrete scale constructor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete_scale(
  aesthetics,
  scale_name,
  palette,
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  na.value = NA,
  drop = TRUE,
  guide = "legend"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete_scale_+3A_aesthetics">aesthetics</code></td>
<td>
<p>the names of the aesthetics that this scale works with</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_scale_name">scale_name</code></td>
<td>
<p>the name of the scale</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_palette">palette</code></td>
<td>
<p>a palette function that when called with a single integer
argument (the number of levels in the scale) returns the values that
they should take</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_name">name</code></td>
<td>
<p>the name of the scale - used as the axis label or the legend
title</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_breaks">breaks</code></td>
<td>
<p>control the breaks in the guide.  There are four possible
types of input:
</p>

<ul>
<li> <p><code>NULL</code>: don't display any breaks
</p>
</li>
<li><p> a character vector giving the breaks as they should appear on the
axis or in the legend.
</p>
</li>
<li> <p><code>waiver()</code> to use the default break computation.
</p>
</li>
<li><p> a function, that when called with a single argument, a character
vector giving the limits of the scale, returns a character vector
specifying which breaks to display.
</p>
</li></ul>

<p>This parameter does not affect in any way how the data is scaled - it
only affects the appearance of the legend.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_labels">labels</code></td>
<td>
<p><code>NULL</code> for no labels, <code>waiver()</code> for default
labels (labels the same as breaks), a character vector the same length
as breaks, or a named character vector whose names are used to match
replacement the labels for matching breaks.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_limits">limits</code></td>
<td>
<p>A character vector specifying the data range for the scale.
and the default order of their display in guides.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_expand">expand</code></td>
<td>
<p>a numeric vector of length two, giving a multiplicative and
additive constant used to expand the range of the scales so that there
is a small gap between the data and the axes. The defaults are (0,0.6)
for discrete scales and (0.05,0) for continuous scales.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_na.value">na.value</code></td>
<td>
<p>how should missing values be displayed?</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale?
The default, <code>TRUE</code>, uses the levels that appear in the data;
<code>FALSE</code> uses all the levels in the factor.</p>
</td></tr>
<tr><td><code id="discrete_scale_+3A_guide">guide</code></td>
<td>
<p>the name of, or actual function, used to create the
guide. See <code><a href="#topic+guides">guides</a></code> for more info.</p>
</td></tr>
</table>

<hr>
<h2 id='draw_key'>Key drawing functions</h2><span id='topic+draw_key'></span><span id='topic+draw_key_point'></span><span id='topic+draw_key_abline'></span><span id='topic+draw_key_rect'></span><span id='topic+draw_key_polygon'></span><span id='topic+draw_key_blank'></span><span id='topic+draw_key_crossbar'></span><span id='topic+draw_key_path'></span><span id='topic+draw_key_vpath'></span><span id='topic+draw_key_dotplot'></span><span id='topic+draw_key_pointrange'></span><span id='topic+draw_key_smooth'></span><span id='topic+draw_key_text'></span><span id='topic+draw_key_label'></span><span id='topic+draw_key_vline'></span>

<h3>Description</h3>

<p>Each Geom has an associated function that draws the key when the geom needs
to be displayed in a legend. These are the options built into ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_key_point(data, params, size)

draw_key_abline(data, params, size)

draw_key_rect(data, params, size)

draw_key_polygon(data, params, size)

draw_key_blank(data, params, size)

draw_key_crossbar(data, params, size)

draw_key_path(data, params, size)

draw_key_vpath(data, params, size)

draw_key_dotplot(data, params, size)

draw_key_pointrange(data, params, size)

draw_key_smooth(data, params, size)

draw_key_text(data, params, size)

draw_key_label(data, params, size)

draw_key_vline(data, params, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_key_+3A_data">data</code></td>
<td>
<p>A single row data frame containing the scaled aesthetics to
display in this key</p>
</td></tr>
<tr><td><code id="draw_key_+3A_params">params</code></td>
<td>
<p>A list of additional parameters supplied to the geom.</p>
</td></tr>
<tr><td><code id="draw_key_+3A_size">size</code></td>
<td>
<p>Width and height of key in mm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob.
</p>

<hr>
<h2 id='economics'>US economic time series.</h2><span id='topic+economics'></span><span id='topic+economics_long'></span>

<h3>Description</h3>

<p>This dataset was produced from US economic time series data available from
<a href="https://fred.stlouisfed.org/">https://fred.stlouisfed.org/</a>. <code>economics</code> is in &quot;wide&quot;
format, <code>economics_long</code> is in &quot;long&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>economics

economics_long
</code></pre>


<h3>Format</h3>

<p>A data frame with 478 rows and 6 variables
</p>

<ul>
<li><p> date.  Month of data collection
</p>
</li>
<li><p> psavert, personal savings rate,
</p>
</li>
<li><p> pce, personal consumption expenditures, in billions of dollars,
</p>
</li>
<li><p> unemploy, number of unemployed in thousands,
</p>
</li>
<li><p> uempmed, median duration of unemployment, in week,
</p>
</li>
<li><p> pop, total population, in thousands,
</p>
</li></ul>

<p>An object of class <code>data.frame</code> with 2870 rows and 4 columns.
</p>

<hr>
<h2 id='element_blank'>Theme element: blank.
This theme element draws nothing, and assigns no space</h2><span id='topic+element_blank'></span>

<h3>Description</h3>

<p>Theme element: blank.
This theme element draws nothing, and assigns no space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_blank()
</code></pre>

<hr>
<h2 id='element_grob'>Generate grid grob from theme element</h2><span id='topic+element_grob'></span>

<h3>Description</h3>

<p>Generate grid grob from theme element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_grob(element, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_grob_+3A_element">element</code></td>
<td>
<p>Theme element, i.e. <code>element_rect</code> or similar.</p>
</td></tr>
<tr><td><code id="element_grob_+3A_...">...</code></td>
<td>
<p>Other arguments to control specific of rendering. This is
usually at least position. See the source code for individual methods.</p>
</td></tr>
</table>

<hr>
<h2 id='element_line'>Theme element: line.</h2><span id='topic+element_line'></span>

<h3>Description</h3>

<p>Theme element: line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_line(
  colour = NULL,
  size = NULL,
  linetype = NULL,
  lineend = NULL,
  color = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_line_+3A_colour">colour</code></td>
<td>
<p>line colour</p>
</td></tr>
<tr><td><code id="element_line_+3A_size">size</code></td>
<td>
<p>line size</p>
</td></tr>
<tr><td><code id="element_line_+3A_linetype">linetype</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="element_line_+3A_lineend">lineend</code></td>
<td>
<p>line end</p>
</td></tr>
<tr><td><code id="element_line_+3A_color">color</code></td>
<td>
<p>an alias for <code>colour</code></p>
</td></tr>
</table>

<hr>
<h2 id='element_rect'>Theme element: rectangle.</h2><span id='topic+element_rect'></span>

<h3>Description</h3>

<p>Most often used for backgrounds and borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_rect(
  fill = NULL,
  colour = NULL,
  size = NULL,
  linetype = NULL,
  color = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_rect_+3A_fill">fill</code></td>
<td>
<p>fill colour</p>
</td></tr>
<tr><td><code id="element_rect_+3A_colour">colour</code></td>
<td>
<p>border colour</p>
</td></tr>
<tr><td><code id="element_rect_+3A_size">size</code></td>
<td>
<p>border size</p>
</td></tr>
<tr><td><code id="element_rect_+3A_linetype">linetype</code></td>
<td>
<p>border linetype</p>
</td></tr>
<tr><td><code id="element_rect_+3A_color">color</code></td>
<td>
<p>an alias for <code>colour</code></p>
</td></tr>
</table>

<hr>
<h2 id='element_text'>Theme element: text.</h2><span id='topic+element_text'></span>

<h3>Description</h3>

<p>Theme element: text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_text(
  family = NULL,
  face = NULL,
  colour = NULL,
  size = NULL,
  hjust = NULL,
  vjust = NULL,
  angle = NULL,
  lineheight = NULL,
  color = NULL,
  margin = NULL,
  debug = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_text_+3A_family">family</code></td>
<td>
<p>font family</p>
</td></tr>
<tr><td><code id="element_text_+3A_face">face</code></td>
<td>
<p>font face (&quot;plain&quot;, &quot;italic&quot;, &quot;bold&quot;, &quot;bold.italic&quot;)</p>
</td></tr>
<tr><td><code id="element_text_+3A_colour">colour</code></td>
<td>
<p>text colour</p>
</td></tr>
<tr><td><code id="element_text_+3A_size">size</code></td>
<td>
<p>text size (in pts)</p>
</td></tr>
<tr><td><code id="element_text_+3A_hjust">hjust</code></td>
<td>
<p>horizontal justification (in [0, 1])</p>
</td></tr>
<tr><td><code id="element_text_+3A_vjust">vjust</code></td>
<td>
<p>vertical justification (in [0, 1])</p>
</td></tr>
<tr><td><code id="element_text_+3A_angle">angle</code></td>
<td>
<p>angle (in [0, 360])</p>
</td></tr>
<tr><td><code id="element_text_+3A_lineheight">lineheight</code></td>
<td>
<p>line height</p>
</td></tr>
<tr><td><code id="element_text_+3A_color">color</code></td>
<td>
<p>an alias for <code>colour</code></p>
</td></tr>
<tr><td><code id="element_text_+3A_margin">margin</code></td>
<td>
<p>margins around the text. See <code><a href="#topic+margin">margin</a></code> for more
details. When creating a theme, the margins should be placed on the
side of the text facing towards the center of the plot.</p>
</td></tr>
<tr><td><code id="element_text_+3A_debug">debug</code></td>
<td>
<p>If <code>TRUE</code>, aids visual debugging by drawing a solid
rectangle behind the complete text area, and a point where each label
is anchored.</p>
</td></tr>
</table>

<hr>
<h2 id='expand_limits'>Expand the plot limits with data.</h2><span id='topic+expand_limits'></span>

<h3>Description</h3>

<p>panels or all plots.  This function is a thin wrapper around
<code><a href="#topic+geom_blank">geom_blank</a></code> that makes it easy to add such values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_limits(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_limits_+3A_...">...</code></td>
<td>
<p>named list of aesthetics specifying the value (or values) that
should be included in each scale.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point()
p + expand_limits(x = 0)
p + expand_limits(y = c(1, 9))
p + expand_limits(x = 0, y = 0)

ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = cyl)) +
  expand_limits(colour = seq(2, 10, by = 2))
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = factor(cyl))) +
  expand_limits(colour = factor(seq(2, 10, by = 2)))
</code></pre>

<hr>
<h2 id='facet'>Facet specification.</h2><span id='topic+facet'></span>

<h3>Description</h3>

<p>Create new facetting specification.  For internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet(..., shrink = TRUE, subclass = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_+3A_...">...</code></td>
<td>
<p>object fields</p>
</td></tr>
<tr><td><code id="facet_+3A_shrink">shrink</code></td>
<td>
<p>shrink scales to fit output of statistics, not raw data</p>
</td></tr>
</table>

<hr>
<h2 id='facet_grid'>Lay out panels in a grid.</h2><span id='topic+facet_grid'></span>

<h3>Description</h3>

<p>Lay out panels in a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_grid(
  facets,
  margins = FALSE,
  scales = "fixed",
  space = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = NULL,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_grid_+3A_facets">facets</code></td>
<td>
<p>a formula with the rows (of the tabular display) on the LHS
and the columns (of the tabular display) on the RHS; the dot in the
formula is used to indicate there should be no faceting on this dimension
(either row or column). The formula can also be provided as a string
instead of a classical formula object</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_margins">margins</code></td>
<td>
<p>either a logical value or a character
vector. Margins are additional facets which contain all the data
for each of the possible values of the faceting variables. If
<code>FALSE</code>, no additional facets are included (the
default). If <code>TRUE</code>, margins are included for all faceting
variables. If specified as a character vector, it is the names of
variables for which margins are to be created.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_scales">scales</code></td>
<td>
<p>Are scales shared across all facets (the default,
<code>"fixed"</code>), or do they vary across rows (<code>"free_x"</code>),
columns (<code>"free_y"</code>), or both rows and columns (<code>"free"</code>)</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_space">space</code></td>
<td>
<p>If <code>"fixed"</code>, the default, all panels have the same size.
If <code>"free_y"</code> their height will be proportional to the length of the
y scale; if <code>"free_x"</code> their width will be proportional to the
length of the x scale; or if <code>"free"</code> both height and width will
vary.  This setting has no effect unless the appropriate scales also vary.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with formulae of the type <code>~cyl + am</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="#topic+labeller">labeller</a>()</code>. See
<code><a href="#topic+label_value">label_value</a></code> for more details and pointers to other
options.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top and
right of the plot. If <code>"x"</code>, the top labels will be
displayed to the bottom. If <code>"y"</code>, the right-hand side
labels will be displayed to the left. Can also be set to
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="facet_grid_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(displ, cty)) + geom_point()

p + facet_grid(. ~ cyl)
p + facet_grid(drv ~ .)
p + facet_grid(drv ~ cyl)

# To change plot order of facet grid,
# change the order of variable levels with factor()

# If you combine a facetted dataset with a dataset that lacks those
# facetting variables, the data will be repeated across the missing
# combinations:
df &lt;- data.frame(displ = mean(mpg$displ), cty = mean(mpg$cty))
p +
  facet_grid(. ~ cyl) +
  geom_point(data = df, colour = "red", size = 2)

# Free scales -------------------------------------------------------
# You can also choose whether the scales should be constant
# across all panels (the default), or whether they should be allowed
# to vary
mt &lt;- ggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) +
  geom_point()

mt + facet_grid(. ~ cyl, scales = "free")

# If scales and space are free, then the mapping between position
# and values in the data will be the same across all panels. This
# is particularly useful for categorical axes
ggplot(mpg, aes(drv, model)) +
  geom_point() +
  facet_grid(manufacturer ~ ., scales = "free", space = "free") +
  theme(strip.text.y = element_text(angle = 0))

# Facet labels ------------------------------------------------------
p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p

# label_both() displays both variable name and value
p + facet_grid(vs ~ cyl, labeller = label_both)

# label_parsed() parses text into mathematical expressions, see ?plotmath
mtcars$cyl2 &lt;- factor(mtcars$cyl, labels = c("alpha", "beta", "sqrt(x, y)"))
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  facet_grid(. ~ cyl2, labeller = label_parsed)

# label_bquote() makes it easy to construct math expressions
p + facet_grid(. ~ vs, labeller = label_bquote(cols = alpha ^ .(vs)))

# The facet strips can be displayed near the axes with switch
data &lt;- transform(mtcars,
  am = factor(am, levels = 0:1, c("Automatic", "Manual")),
  gear = factor(gear, levels = 3:5, labels = c("Three", "Four", "Five"))
)
p &lt;- ggplot(data, aes(mpg, disp)) + geom_point()
p + facet_grid(am ~ gear, switch = "both")
# It looks better without boxes around the strips
p + facet_grid(am ~ gear, switch = "both") +
  theme(strip.background = element_blank())

# Margins ----------------------------------------------------------

# Margins can be specified by logically (all yes or all no) or by specific
# variables as (character) variable names
mg &lt;- ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point()
mg + facet_grid(vs + am ~ gear)
mg + facet_grid(vs + am ~ gear, margins = TRUE)
mg + facet_grid(vs + am ~ gear, margins = "am")
# when margins are made over "vs", since the facets for "am" vary
# within the values of "vs", the marginal facet for "vs" is also
# a margin over "am".
mg + facet_grid(vs + am ~ gear, margins = "vs")
mg + facet_grid(vs + am ~ gear, margins = "gear")
mg + facet_grid(vs + am ~ gear, margins = c("gear", "am"))

</code></pre>

<hr>
<h2 id='facet_null'>Facet specification: a single panel.</h2><span id='topic+facet_null'></span>

<h3>Description</h3>

<p>Facet specification: a single panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_null(shrink = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_null_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># facet_null is the default facetting specification if you
# don't override it with facet_grid or facet_wrap
ggplot(mtcars, aes(mpg, wt)) + geom_point()
</code></pre>

<hr>
<h2 id='facet_wrap'>Wrap a 1d ribbon of panels into 2d.</h2><span id='topic+facet_wrap'></span>

<h3>Description</h3>

<p>Most displays are roughly rectangular, so if you have a categorical
variable with many levels, it doesn't make sense to try and display them
all in one row (or one column). To solve this dilemma, <code>facet_wrap</code>
wraps a 1d sequence of panels into 2d, making best use of screen real estate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facet_wrap(
  facets,
  nrow = NULL,
  ncol = NULL,
  scales = "fixed",
  shrink = TRUE,
  labeller = "label_value",
  as.table = TRUE,
  switch = NULL,
  drop = TRUE,
  dir = "h"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facet_wrap_+3A_facets">facets</code></td>
<td>
<p>Either a formula or character vector. Use either a
one sided formula, <code>~a + b</code>, or a character vector, <code>c("a", "b")</code>.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_nrow">nrow</code>, <code id="facet_wrap_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_scales">scales</code></td>
<td>
<p>should Scales be fixed (<code>"fixed"</code>, the default),
free (<code>"free"</code>), or free in one dimension (<code>"free_x"</code>,
<code>"free_y"</code>).</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_shrink">shrink</code></td>
<td>
<p>If <code>TRUE</code>, will shrink scales to fit output of
statistics, not raw data. If <code>FALSE</code>, will be range of raw data
before statistical summary.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes one data frame of labels and
returns a list or data frame of character vectors. Each input
column corresponds to one factor. Thus there will be more than
one with formulae of the type <code>~cyl + am</code>. Each output
column gets displayed as one separate line in the strip
label. This function should inherit from the &quot;labeller&quot; S3 class
for compatibility with <code><a href="#topic+labeller">labeller</a>()</code>. See
<code><a href="#topic+label_value">label_value</a></code> for more details and pointers to other
options.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_as.table">as.table</code></td>
<td>
<p>If <code>TRUE</code>, the default, the facets are laid out like
a table with highest values at the bottom-right. If <code>FALSE</code>, the
facets are laid out like a plot with the highest value at the top-right.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_switch">switch</code></td>
<td>
<p>By default, the labels are displayed on the top of
the plot. If <code>switch</code> is <code>"x"</code>, they will be displayed
to the bottom. If <code>"y"</code>, they will be displayed to the
left, near the y axis.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, the default, all factor levels not used in the
data will automatically be dropped. If <code>FALSE</code>, all factor levels
will be shown, regardless of whether or not they appear in the data.</p>
</td></tr>
<tr><td><code id="facet_wrap_+3A_dir">dir</code></td>
<td>
<p>Direction: either &quot;h&quot; for horizontal, the default, or &quot;v&quot;, for
vertical.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(~class)

# Control the number of rows and columns with nrow and ncol
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(~class, nrow = 4)


# You can facet by multiple variables
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(~ cyl + drv)
# Or use a character vector:
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(c("cyl", "drv"))

# Use the `labeller` option to control how labels are printed:
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(c("cyl", "drv"), labeller = "label_both")

# To change the order in which the panels appear, change the levels
# of the underlying factor.
mpg$class2 &lt;- reorder(mpg$class, mpg$displ)
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(~class2)

# By default, the same scales are used for all panels. You can allow
# scales to vary across the panels with the `scales` argument.
# Free scales make it easier to see patterns within each panel, but
# harder to compare across panels.
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  facet_wrap(~class, scales = "free")

# To repeat the same data in every panel, simply construct a data frame
# that does not contain the facetting variable.
ggplot(mpg, aes(displ, hwy)) +
  geom_point(data = transform(mpg, class = NULL), colour = "grey85") +
  geom_point() +
  facet_wrap(~class)

# Use `switch` to display the facet labels near an axis, acting as
# a subtitle for this axis. This is typically used with free scales
# and a theme without boxes around strip labels.
ggplot(economics_long, aes(date, value)) +
  geom_line() +
  facet_wrap(~variable, scales = "free_y", nrow = 2, switch = "x") +
  theme(strip.background = element_blank())

</code></pre>

<hr>
<h2 id='faithfuld'>2d density estimate of Old Faithful data</h2><span id='topic+faithfuld'></span>

<h3>Description</h3>

<p>A 2d density estimate of the waiting and eruptions variables data
<a href="datasets.html#topic+faithful">faithful</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faithfuld
</code></pre>


<h3>Format</h3>

<p>A data frame with 5,625 observations and 3 variables.
</p>

<hr>
<h2 id='FluView'>
FluView
</h2><span id='topic+FluView'></span>

<h3>Description</h3>

<p>Data about Flu outbreaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("FluView")</code></pre>


<h3>Format</h3>

<p>The format is a named list of two data.frames.
</p>

<hr>
<h2 id='format.gganimintproto'>Format a gganimintproto object</h2><span id='topic+format.gganimintproto'></span>

<h3>Description</h3>

<p>Format a gganimintproto object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gganimintproto'
format(x, ..., flat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.gganimintproto_+3A_x">x</code></td>
<td>
<p>A gganimintproto object to print.</p>
</td></tr>
<tr><td><code id="format.gganimintproto_+3A_...">...</code></td>
<td>
<p>If the gganimintproto object has a <code>print</code> method, further arguments
will be passed to it. Otherwise, these arguments are unused.</p>
</td></tr>
<tr><td><code id="format.gganimintproto_+3A_flat">flat</code></td>
<td>
<p>If <code>TRUE</code> (the default), show a flattened list of all local
and inherited members. If <code>FALSE</code>, show the inheritance hierarchy.</p>
</td></tr>
</table>

<hr>
<h2 id='fortify'>Fortify a model with data.</h2><span id='topic+fortify'></span>

<h3>Description</h3>

<p>Rather than using this function, I now recomend using the <span class="pkg">broom</span>
package, which implements a much wider range of methods. <code>fortify</code>
may be deprecated in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify_+3A_model">model</code></td>
<td>
<p>model or other R object to convert to data frame</p>
</td></tr>
<tr><td><code id="fortify_+3A_data">data</code></td>
<td>
<p>original dataset, if needed</p>
</td></tr>
<tr><td><code id="fortify_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fortify.lm">fortify.lm</a></code>
</p>

<hr>
<h2 id='fortify.lm'>Supplement the data fitted to a linear model with model fit statistics.</h2><span id='topic+fortify.lm'></span>

<h3>Description</h3>

<p>If you have missing values in your model data, you may need to refit
the model with <code>na.action = na.exclude</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
fortify(model, data = model$model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.lm_+3A_model">model</code></td>
<td>
<p>linear model</p>
</td></tr>
<tr><td><code id="fortify.lm_+3A_data">data</code></td>
<td>
<p>data set, defaults to data used to fit model</p>
</td></tr>
<tr><td><code id="fortify.lm_+3A_...">...</code></td>
<td>
<p>not used by this method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data with extra columns:
</p>
<table>
<tr><td><code>.hat</code></td>
<td>
<p>Diagonal of the hat matrix</p>
</td></tr>
<tr><td><code>.sigma</code></td>
<td>
<p>Estimate of residual standard deviation when
corresponding observation is dropped from model</p>
</td></tr>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance, <code><a href="stats.html#topic+cooks.distance">cooks.distance</a></code></p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted values of model</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>Residuals</p>
</td></tr>
<tr><td><code>.stdresid</code></td>
<td>
<p>Standardised residuals</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(mpg ~ wt, data = mtcars)
head(fortify(mod))
head(fortify(mod, mtcars))

plot(mod, which = 1)

ggplot(mod, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE)

ggplot(mod, aes(.fitted, .stdresid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE)

ggplot(fortify(mod, mtcars), aes(.fitted, .stdresid)) +
  geom_point(aes(colour = factor(cyl)))

ggplot(fortify(mod, mtcars), aes(mpg, .stdresid)) +
  geom_point(aes(colour = factor(cyl)))

plot(mod, which = 2)
ggplot(mod) +
  stat_qq(aes(sample = .stdresid)) +
  geom_abline()

plot(mod, which = 3)
ggplot(mod, aes(.fitted, sqrt(abs(.stdresid)))) +
  geom_point() +
  geom_smooth(se = FALSE)

plot(mod, which = 4)
ggplot(mod, aes(seq_along(.cooksd), .cooksd)) +
  geom_bar(stat = "identity")

plot(mod, which = 5)
ggplot(mod, aes(.hat, .stdresid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() + geom_smooth(se = FALSE)

ggplot(mod, aes(.hat, .stdresid)) +
  geom_point(aes(size = .cooksd)) +
  geom_smooth(se = FALSE, size = 0.5)

plot(mod, which = 6)
ggplot(mod, aes(.hat, .cooksd)) +
  geom_vline(xintercept = 0, colour = NA) +
  geom_abline(slope = seq(0, 3, by = 0.5), colour = "white") +
  geom_smooth(se = FALSE) +
  geom_point()

ggplot(mod, aes(.hat, .cooksd)) +
  geom_point(aes(size = .cooksd / .hat)) +
  scale_size_area()
</code></pre>

<hr>
<h2 id='fortify.map'>Fortify method for map objects.</h2><span id='topic+fortify.map'></span>

<h3>Description</h3>

<p>This function turns a map into a data frame that can more easily be
plotted with ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.map_+3A_model">model</code></td>
<td>
<p>map object</p>
</td></tr>
<tr><td><code id="fortify.map_+3A_data">data</code></td>
<td>
<p>not used by this method</p>
</td></tr>
<tr><td><code id="fortify.map_+3A_...">...</code></td>
<td>
<p>not used by this method</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+map_data">map_data</a></code> and <code><a href="#topic+borders">borders</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {
ca &lt;- map("county", "ca", plot = FALSE, fill = TRUE)
head(fortify(ca))
ggplot(ca, aes(long, lat)) +
  geom_polygon(aes(group = group))

tx &lt;- map("county", "texas", plot = FALSE, fill = TRUE)
head(fortify(tx))
ggplot(tx, aes(long, lat)) +
  geom_polygon(aes(group = group), colour = "white")
}
</code></pre>

<hr>
<h2 id='fortify.sp'>Fortify method for classes from the sp package.</h2><span id='topic+fortify.sp'></span><span id='topic+fortify.SpatialPolygonsDataFrame'></span><span id='topic+fortify.SpatialPolygons'></span><span id='topic+fortify.Polygons'></span><span id='topic+fortify.Polygon'></span><span id='topic+fortify.SpatialLinesDataFrame'></span><span id='topic+fortify.Lines'></span><span id='topic+fortify.Line'></span>

<h3>Description</h3>

<p>To figure out the correct variable name for region, inspect
<code>as.data.frame(model)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygonsDataFrame'
fortify(model, data, ...)

## S3 method for class 'SpatialPolygons'
fortify(model, data, ...)

## S3 method for class 'Polygons'
fortify(model, data, ...)

## S3 method for class 'Polygon'
fortify(model, data, ...)

## S3 method for class 'SpatialLinesDataFrame'
fortify(model, data, ...)

## S3 method for class 'Lines'
fortify(model, data, ...)

## S3 method for class 'Line'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.sp_+3A_model">model</code></td>
<td>
<p><code>SpatialPolygonsDataFrame</code> to convert into a dataframe.</p>
</td></tr>
<tr><td><code id="fortify.sp_+3A_data">data</code></td>
<td>
<p>not used by this method</p>
</td></tr>
<tr><td><code id="fortify.sp_+3A_...">...</code></td>
<td>
<p>not used by this method</p>
</td></tr>
</table>

<hr>
<h2 id='g_train_layout'>Learn the layout of panels within a plot.</h2><span id='topic+g_train_layout'></span>

<h3>Description</h3>

<p>This is determined by the facet, which returns a data frame, than
when joined to the data to be plotted tells us which panel it should
appear in, where that panel appears in the grid, and what scales it
uses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_train_layout(panel, facet, data, plot_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_train_layout_+3A_panel">panel</code></td>
<td>
<p>the panel object to train</p>
</td></tr>
<tr><td><code id="g_train_layout_+3A_facet">facet</code></td>
<td>
<p>the facetting specification</p>
</td></tr>
<tr><td><code id="g_train_layout_+3A_data">data</code></td>
<td>
<p>a list of data frames (one for each layer), and one for the plot</p>
</td></tr>
<tr><td><code id="g_train_layout_+3A_plot_data">plot_data</code></td>
<td>
<p>the default data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As well as the layout info, this function also adds empty lists in which
to house the x and y scales.
</p>


<h3>Value</h3>

<p>an updated panel object
</p>

<hr>
<h2 id='generation.loci'>
Evolution simulation
</h2><span id='topic+generation.loci'></span>

<h3>Description</h3>

<p>Allele frequencies for 100 loci and 12 populations were simulated
over 100 generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(generation.loci)</code></pre>


<h3>Format</h3>

<p>A data frame with 120000 observations on the following 4 variables.
</p>

<dl>
<dt><code>locus</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>population</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>generation</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>frequency</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>color</code></dt><dd><p>factor: blue, red, or neutral</p>
</dd>
<dt><code>type</code></dt><dd><p>factor: balancing, none, or positive</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data generated using nicholsonppp::sim.drift.selection, see code in
etc/generation.loci.R.
</p>

<hr>
<h2 id='geom_abline'>Lines: horizontal, vertical, and specified by slope and intercept.</h2><span id='topic+geom_abline'></span><span id='topic+geom_hline'></span><span id='topic+geom_vline'></span>

<h3>Description</h3>

<p>These paired geoms and stats add straight lines to a plot, either
horizontal, vertical or specified by slope and intercept. These are useful
for annotating plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_abline(
  mapping = NULL,
  data = NULL,
  ...,
  slope,
  intercept,
  na.rm = FALSE,
  show.legend = NA
)

geom_hline(
  mapping = NULL,
  data = NULL,
  ...,
  yintercept,
  na.rm = FALSE,
  show.legend = NA
)

geom_vline(
  mapping = NULL,
  data = NULL,
  ...,
  xintercept,
  na.rm = FALSE,
  show.legend = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_abline_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_abline_+3A_xintercept">xintercept</code>, <code id="geom_abline_+3A_yintercept">yintercept</code>, <code id="geom_abline_+3A_slope">slope</code>, <code id="geom_abline_+3A_intercept">intercept</code></td>
<td>
<p>Parameters that control the
position of the line. If these are set, <code>data</code>, <code>mapping</code> and
<code>show.legend</code> are overridden</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These geoms act slightly different to other geoms. You can supply the
parameters in two ways: either as arguments to the layer function,
or via aesthetics. If you use arguments, e.g.
<code>geom_abline(intercept = 0, slope = 1)</code>, then behind the scenes
the geom makes a new data frame containing just the data you've supplied.
That means that the lines will be the same in all facets; if you want them
to vary across facets, construct the data frame yourself and use aesthetics.
</p>
<p>Unlike most other geoms, these geoms do not inherit aesthetics from the plot
default, because they do not understand x and y aesthetics which are
commonly set in the plot. They also do not affect the x and y scales.
</p>


<h3>Aesthetics</h3>

<p>These geoms are drawn using with <code><a href="#topic+geom_line">geom_line</a></code> so support the
same aesthetics: alpha, colour, linetype and size. They also each have
aesthetics that control the position of the line:
</p>

<ul>
<li> <p><code>geom_vline</code>: <code>xintercept</code>
</p>
</li>
<li> <p><code>geom_hline</code>: <code>yintercept</code>
</p>
</li>
<li> <p><code>geom_abline</code>: <code>slope</code> and <code>intercept</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>See <code><a href="#topic+geom_segment">geom_segment</a></code> for a more general approach to
adding straight line segments to a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()

# Fixed values
p + geom_vline(xintercept = 5)
p + geom_vline(xintercept = 1:5)
p + geom_hline(yintercept = 20)

p + geom_abline() # Can't see it - outside the range of the data
p + geom_abline(intercept = 20)

# Calculate slope and intercept of line of best fit
coef(lm(mpg ~ wt, data = mtcars))
p + geom_abline(intercept = 37, slope = -5)
# But this is easier to do with geom_smooth:
p + geom_smooth(method = "lm", se = FALSE)

# To show different lines in different facets, use aesthetics
p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  facet_wrap(~ cyl)

mean_wt &lt;- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
p + geom_hline(aes(yintercept = wt), mean_wt)

# You can also control other aesthetics
ggplot(mtcars, aes(mpg, wt, colour = wt)) +
  geom_point() +
  geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
  facet_wrap(~ cyl)
</code></pre>

<hr>
<h2 id='geom_bar'>Bars, rectangles with bases on x-axis</h2><span id='topic+geom_bar'></span><span id='topic+stat_count'></span>

<h3>Description</h3>

<p>There are two types of bar charts, determined by what is mapped to bar
height. By default, <code>geom_bar</code> uses <code>stat="count"</code> which makes the
height of the bar proportion to the number of cases in each group (or if the
<code>weight</code> aethetic is supplied, the sum of the weights). If you want the
heights of the bars to represent values in the data, use
<code>stat="identity"</code> and map a variable to the <code>y</code> aesthetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_bar(
  mapping = NULL,
  data = NULL,
  stat = "count",
  position = "stack",
  ...,
  width = NULL,
  binwidth = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_count(
  mapping = NULL,
  data = NULL,
  geom = "bar",
  position = "stack",
  ...,
  width = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_bar_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_width">width</code></td>
<td>
<p>Bar width. By default, set to 90% of the resolution of the data.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_binwidth">binwidth</code></td>
<td>
<p><code>geom_bar</code> no longer has a binwidth argument - if
you use it you'll get an warning telling to you use
<code><a href="#topic+geom_histogram">geom_histogram</a></code> instead.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bar_+3A_geom">geom</code>, <code id="geom_bar_+3A_stat">stat</code></td>
<td>
<p>Override the default connection between <code>geom_bar</code> and
<code>stat_count</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bar chart maps the height of the bar to a variable, and so the base of the
bar must always be shown to produce a valid visual comparison. This is why it doesn't make sense to use a log-scaled y axis with a
bar chart.
</p>
<p>By default, multiple x's occurring in the same place will be stacked atop one
another by <code><a href="#topic+position_stack">position_stack</a></code>. If you want them to be dodged
side-to-side, see <code><a href="#topic+position_dodge">position_dodge</a></code>. Finally,
<code><a href="#topic+position_fill">position_fill</a></code> shows relative proportions at each x by stacking
the bars and then stretching or squashing to the same height.
</p>


<h3>Aesthetics</h3>

<p><code>geom_bar</code> understands the following aesthetics (required aesthetics are in bold):

</p>

  <ul>
<li> <p><strong>x</strong>
  </p>
</li>
<li><p> alpha
  </p>
</li>
<li><p> colour
  </p>
</li>
<li><p> fill
  </p>
</li>
<li><p> linetype
  </p>
</li>
<li><p> size
</p>
</li></ul>




<h3>Computed variables</h3>


<dl>
<dt>count</dt><dd><p>number of points in bin</p>
</dd>
<dt>prop</dt><dd><p>groupwise proportion</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+geom_histogram">geom_histogram</a></code> for continuous data,
<code><a href="#topic+position_dodge">position_dodge</a></code> for creating side-by-side barcharts.
</p>
<p><code><a href="#topic+stat_bin">stat_bin</a></code>, which bins data in ranges and counts the
cases in each range. It differs from <code>stat_count</code>, which counts the
number of cases at each x position (without binning into ranges).
<code><a href="#topic+stat_bin">stat_bin</a></code> requires continuous x data, whereas
<code>stat_count</code> can be used for both discrete and continuous x data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># geom_bar is designed to make it easy to create bar charts that show
# counts (or sums of weights)
g &lt;- ggplot(mpg, aes(class))
# Number of cars in each class:
g + geom_bar()
# Total engine displacement of each class
g + geom_bar(aes(weight = displ))

# To show (e.g.) means, you need stat = "identity"
df &lt;- data.frame(trt = c("a", "b", "c"), outcome = c(2.3, 1.9, 3.2))
ggplot(df, aes(trt, outcome)) +
  geom_bar(stat = "identity")
# But geom_point() display exactly the same information and doesn't
# require the y-axis to touch zero.
ggplot(df, aes(trt, outcome)) +
  geom_point()

# You can also use geom_bar() with continuous data, in which case
# it will show counts at unique locations
df &lt;- data.frame(x = rep(c(2.9, 3.1, 4.5), c(5, 10, 4)))
ggplot(df, aes(x)) + geom_bar()
# cf. a histogram of the same data
ggplot(df, aes(x)) + geom_histogram(binwidth = 0.5)


# Bar charts are automatically stacked when multiple bars are placed
# at the same location
g + geom_bar(aes(fill = drv))

# You can instead dodge, or fill them
g + geom_bar(aes(fill = drv), position = "dodge")
g + geom_bar(aes(fill = drv), position = "fill")

# To change plot order of bars, change levels in underlying factor
reorder_size &lt;- function(x) {
  factor(x, levels = names(sort(table(x))))
}
ggplot(mpg, aes(reorder_size(class))) + geom_bar()

</code></pre>

<hr>
<h2 id='geom_bin2d'>Add heatmap of 2d bin counts.</h2><span id='topic+geom_bin2d'></span><span id='topic+stat_bin_2d'></span><span id='topic+stat_bin2d'></span>

<h3>Description</h3>

<p>Add heatmap of 2d bin counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_bin2d(
  mapping = NULL,
  data = NULL,
  stat = "bin2d",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin_2d(
  mapping = NULL,
  data = NULL,
  geom = "tile",
  position = "identity",
  ...,
  bins = 30,
  binwidth = NULL,
  drop = TRUE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_bin2d_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_geom">geom</code>, <code id="geom_bin2d_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_bin2d</code> and <code>stat_bin2d</code>.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_bins">bins</code></td>
<td>
<p>numeric vector giving number of bins in both vertical and
horizontal directions. Set to 30 by default.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric vector giving bin width in both vertical and
horizontal directions. Overrides <code>bins</code> if both set.</p>
</td></tr>
<tr><td><code id="geom_bin2d_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> removes all cells with 0 counts.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_bin2d</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>fill
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+stat_binhex">stat_binhex</a></code> for hexagonal binning
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- ggplot(diamonds, aes(x, y)) + xlim(4, 10) + ylim(4, 10)
d + geom_bin2d()

# You can control the size of the bins by specifying the number of
# bins in each direction:
d + geom_bin2d(bins = 10)
d + geom_bin2d(bins = 30)

# Or by specifying the width of the bins
d + geom_bin2d(binwidth = c(0.1, 0.1))
</code></pre>

<hr>
<h2 id='geom_blank'>Blank, draws nothing.</h2><span id='topic+geom_blank'></span>

<h3>Description</h3>

<p>The blank geom draws nothing, but can be a useful way of ensuring common
scales between different plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_blank(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_blank_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_blank_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(wt, mpg))
# Nothing to see here!
</code></pre>

<hr>
<h2 id='geom_contour'>Display contours of a 3d surface in 2d.</h2><span id='topic+geom_contour'></span><span id='topic+stat_contour'></span>

<h3>Description</h3>

<p>Display contours of a 3d surface in 2d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_contour(
  mapping = NULL,
  data = NULL,
  stat = "contour",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_contour(
  mapping = NULL,
  data = NULL,
  geom = "contour",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_contour_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square)</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel)</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1)</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_contour_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_contour</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li>
<li><p>weight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>level</dt><dd><p>height of contour</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+geom_density_2d">geom_density_2d</a></code>: 2d density contours
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Basic plot
v &lt;- ggplot(faithfuld, aes(waiting, eruptions, z = density))
v + geom_contour()

# Or compute from raw data
ggplot(faithful, aes(waiting, eruptions)) +
  geom_density_2d()


# Setting bins creates evenly spaced contours in the range of the data
v + geom_contour(bins = 2)
v + geom_contour(bins = 10)

# Setting binwidth does the same thing, parameterised by the distance
# between contours
v + geom_contour(binwidth = 0.01)
v + geom_contour(binwidth = 0.001)

# Other parameters
v + geom_contour(aes(colour = ..level..))
v + geom_contour(colour = "red")
v + geom_raster(aes(fill = density)) +
  geom_contour(colour = "white")

</code></pre>

<hr>
<h2 id='geom_count'>Count the number of observations at each location.</h2><span id='topic+geom_count'></span><span id='topic+stat_sum'></span>

<h3>Description</h3>

<p>This is a variant <code><a href="#topic+geom_point">geom_point</a></code> that counts the number of
observations at each location, then maps the count to point size. It
useful when you have discrete data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_count(
  mapping = NULL,
  data = NULL,
  stat = "sum",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_sum(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_count_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_count_+3A_geom">geom</code>, <code id="geom_count_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_count</code> and <code>stat_sum</code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_point</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>shape
</p>
</li>
<li><p>size
</p>
</li>
<li><p>stroke
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>n</dt><dd><p>number of observations at position</p>
</dd>
<dt>prop</dt><dd><p>percent of points in that panel at that position</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(cty, hwy)) +
 geom_point()

ggplot(mpg, aes(cty, hwy)) +
 geom_count()

# Best used in conjunction with scale_size_area which ensures that
# counts of zero would be given size 0. Doesn't make much different
# here because the smallest count is already close to 0.
ggplot(mpg, aes(cty, hwy)) +
 geom_count()
 scale_size_area()

# Display proportions instead of counts -------------------------------------
# By default, all categorical variables in the plot form the groups.
# Specifying geom_count without a group identifier leads to a plot which is
# not useful:
d &lt;- ggplot(diamonds, aes(x = cut, y = clarity))
d + geom_count(aes(size = ..prop..))
# To correct this problem and achieve a more desirable plot, we need
# to specify which group the proportion is to be calculated over.
d + geom_count(aes(size = ..prop.., group = 1)) +
  scale_size_area(max_size = 10)

# Or group by x/y variables to have rows/columns sum to 1.
d + geom_count(aes(size = ..prop.., group = cut)) +
  scale_size_area(max_size = 10)
d + geom_count(aes(size = ..prop.., group = clarity)) +
  scale_size_area(max_size = 10)
</code></pre>

<hr>
<h2 id='geom_crossbar'>Vertical intervals: lines, crossbars &amp; errorbars.</h2><span id='topic+geom_crossbar'></span><span id='topic+geom_errorbar'></span><span id='topic+geom_linerange'></span><span id='topic+geom_pointrange'></span>

<h3>Description</h3>

<p>Various ways of representing a vertical interval defined by <code>x</code>,
<code>ymin</code> and <code>ymax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_crossbar(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  fatten = 2.5,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_errorbar(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_linerange(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_pointrange(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  fatten = 4,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_crossbar_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_fatten">fatten</code></td>
<td>
<p>A multiplicative factor used to increase the size of the
middle bar in <code>geom_crossbar()</code> and the middle point in
<code>geom_pointrange()</code>.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_crossbar_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_linerange</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>ymax</strong></p>
</li>
<li><p><strong>ymin</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+stat_summary">stat_summary</a></code> for examples of these guys in use,
<code><a href="#topic+geom_smooth">geom_smooth</a></code> for continuous analog
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Create a simple example dataset
df &lt;- data.frame(
  trt = factor(c(1, 1, 2, 2)),
  resp = c(1, 5, 3, 4),
  group = factor(c(1, 2, 1, 2)),
  upper = c(1.1, 5.3, 3.3, 4.2),
  lower = c(0.8, 4.6, 2.4, 3.6)
)

p &lt;- ggplot(df, aes(trt, resp, colour = group))
p + geom_linerange(aes(ymin = lower, ymax = upper))
p + geom_pointrange(aes(ymin = lower, ymax = upper))
p + geom_crossbar(aes(ymin = lower, ymax = upper), width = 0.2)
p + geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)

# Draw lines connecting group means
p +
  geom_line(aes(group = group)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)

# If you want to dodge bars and errorbars, you need to manually
# specify the dodge width
p &lt;- ggplot(df, aes(trt, resp, fill = group))
p +
 geom_bar(position = "dodge", stat = "identity") +
 geom_errorbar(aes(ymin = lower, ymax = upper), position = "dodge", width = 0.25)

# Because the bars and errorbars have different widths
# we need to specify how wide the objects we are dodging are
dodge &lt;- position_dodge(width=0.9)
p +
  geom_bar(position = dodge, stat = "identity") +
  geom_errorbar(aes(ymin = lower, ymax = upper), position = dodge, width = 0.25)
</code></pre>

<hr>
<h2 id='geom_density'>Display a smooth density estimate.</h2><span id='topic+geom_density'></span><span id='topic+stat_density'></span>

<h3>Description</h3>

<p>A kernel density estimate, useful for display the distribution of variables
with underlying smoothness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_density(
  mapping = NULL,
  data = NULL,
  stat = "density",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_density(
  mapping = NULL,
  data = NULL,
  geom = "area",
  position = "stack",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  trim = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_density_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_geom">geom</code>, <code id="geom_density_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_density</code> and <code>stat_density</code>.</p>
</td></tr>
<tr><td><code id="geom_density_+3A_bw">bw</code></td>
<td>
<p>the smoothing bandwidth to be used, see
<code><a href="stats.html#topic+density">density</a></code> for details</p>
</td></tr>
<tr><td><code id="geom_density_+3A_adjust">adjust</code></td>
<td>
<p>adjustment of the bandwidth, see
<code><a href="stats.html#topic+density">density</a></code> for details</p>
</td></tr>
<tr><td><code id="geom_density_+3A_kernel">kernel</code></td>
<td>
<p>kernel used for density estimation, see
<code><a href="stats.html#topic+density">density</a></code> for details</p>
</td></tr>
<tr><td><code id="geom_density_+3A_trim">trim</code></td>
<td>
<p>This parameter only matters if you are displaying multiple
densities in one plot. If <code>FALSE</code>, the default, each density is
computed on the full range of the data. If <code>TRUE</code>, each density
is computed over the range of that group: this typically means the
estimated x values will not line-up, and hence you won't be able to
stack density values.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_density</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li>
<li><p>weight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>density</dt><dd><p>density estimate</p>
</dd>
<dt>count</dt><dd><p>density * number of points - useful for stacked density
plots</p>
</dd>
<dt>scaled</dt><dd><p>density estimate, scaled to maximum of 1</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <code><a href="#topic+geom_histogram">geom_histogram</a></code>, <code><a href="#topic+geom_freqpoly">geom_freqpoly</a></code> for
other methods of displaying continuous distribution.
See <code><a href="#topic+geom_violin">geom_violin</a></code> for a compact density display.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(diamonds, aes(carat)) +
  geom_density()

ggplot(diamonds, aes(carat)) +
  geom_density(adjust = 1/5)
ggplot(diamonds, aes(carat)) +
  geom_density(adjust = 5)

ggplot(diamonds, aes(depth, colour = cut)) +
  geom_density() +
  xlim(55, 70)
ggplot(diamonds, aes(depth, fill = cut, colour = cut)) +
  geom_density(alpha = 0.1) +
  xlim(55, 70)


# Stacked density plots: if you want to create a stacked density plot, you
# probably want to 'count' (density * n) variable instead of the default
# density

# Loses marginal densities
ggplot(diamonds, aes(carat, fill = cut)) +
  geom_density(position = "stack")
# Preserves marginal densities
ggplot(diamonds, aes(carat, ..count.., fill = cut)) +
  geom_density(position = "stack")

# You can use position="fill" to produce a conditional density estimate
ggplot(diamonds, aes(carat, ..count.., fill = cut)) +
  geom_density(position = "fill")

</code></pre>

<hr>
<h2 id='geom_density_2d'>Contours from a 2d density estimate.</h2><span id='topic+geom_density_2d'></span><span id='topic+geom_density2d'></span><span id='topic+stat_density_2d'></span><span id='topic+stat_density2d'></span>

<h3>Description</h3>

<p>Perform a 2D kernel density estimation using kde2d and display the
results with contours. This can be useful for dealing with overplotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_density_2d(
  mapping = NULL,
  data = NULL,
  stat = "density2d",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_density_2d(
  mapping = NULL,
  data = NULL,
  geom = "density_2d",
  position = "identity",
  ...,
  contour = TRUE,
  n = 100,
  h = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_density_2d_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square)</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel)</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1)</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_geom">geom</code>, <code id="geom_density_2d_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_density_2d</code> and <code>stat_density_2d</code>.</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_contour">contour</code></td>
<td>
<p>If <code>TRUE</code>, contour the results of the 2d density
estimation</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_n">n</code></td>
<td>
<p>number of grid points in each direction</p>
</td></tr>
<tr><td><code id="geom_density_2d_+3A_h">h</code></td>
<td>
<p>Bandwidth (vector of length two). If <code>NULL</code>, estimated
using <code><a href="MASS.html#topic+bandwidth.nrd">bandwidth.nrd</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_density_2d</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>Computed variables</h3>

<p>Same as <code><a href="#topic+stat_contour">stat_contour</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_contour">geom_contour</a></code> for contour drawing geom,
<code><a href="#topic+stat_sum">stat_sum</a></code> for another way of dealing with overplotting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- ggplot(faithful, aes(x = eruptions, y = waiting)) +
 geom_point() +
 xlim(0.5, 6) +
 ylim(40, 110)
m + geom_density_2d()

m + stat_density_2d(aes(fill = ..level..), geom = "polygon")

set.seed(4393)
dsmall &lt;- diamonds[sample(nrow(diamonds), 1000), ]
d &lt;- ggplot(dsmall, aes(x, y))
# If you map an aesthetic to a categorical variable, you will get a
# set of contours for each value of that variable
d + geom_density_2d(aes(colour = cut))

# If we turn contouring off, we can use use geoms like tiles:
d + stat_density_2d(geom = "raster", aes(fill = ..density..), contour = FALSE)
# Or points:
d + stat_density_2d(geom = "point", aes(size = ..density..), n = 20, contour = FALSE)

</code></pre>

<hr>
<h2 id='geom_dotplot'>Dot plot</h2><span id='topic+geom_dotplot'></span>

<h3>Description</h3>

<p>In a dot plot, the width of a dot corresponds to the bin width
(or maximum width, depending on the binning algorithm), and dots are
stacked, with each dot representing one observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dotplot(
  mapping = NULL,
  data = NULL,
  position = "identity",
  ...,
  binwidth = NULL,
  binaxis = "x",
  method = "dotdensity",
  binpositions = "bygroup",
  stackdir = "up",
  stackratio = 1,
  dotsize = 1,
  stackgroups = FALSE,
  origin = NULL,
  right = TRUE,
  width = 0.9,
  drop = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dotplot_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_binwidth">binwidth</code></td>
<td>
<p>When <code>method</code> is &quot;dotdensity&quot;, this specifies maximum bin
width. When <code>method</code> is &quot;histodot&quot;, this specifies bin width.
Defaults to 1/30 of the range of the data</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_binaxis">binaxis</code></td>
<td>
<p>The axis to bin along, &quot;x&quot; (default) or &quot;y&quot;</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_method">method</code></td>
<td>
<p>&quot;dotdensity&quot; (default) for dot-density binning, or
&quot;histodot&quot; for fixed bin widths (like stat_bin)</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_binpositions">binpositions</code></td>
<td>
<p>When <code>method</code> is &quot;dotdensity&quot;, &quot;bygroup&quot; (default)
determines positions of the bins for each group separately. &quot;all&quot; determines
positions of the bins with all the data taken together; this is used for
aligning dot stacks across multiple groups.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_stackdir">stackdir</code></td>
<td>
<p>which direction to stack the dots. &quot;up&quot; (default),
&quot;down&quot;, &quot;center&quot;, &quot;centerwhole&quot; (centered, but with dots aligned)</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_stackratio">stackratio</code></td>
<td>
<p>how close to stack the dots. Default is 1, where dots just
just touch. Use smaller values for closer, overlapping dots.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_dotsize">dotsize</code></td>
<td>
<p>The diameter of the dots relative to <code>binwidth</code>, default 1.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_stackgroups">stackgroups</code></td>
<td>
<p>should dots be stacked across groups? This has the effect
that <code>position = "stack"</code> should have, but can't (because this geom has
some odd properties).</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_origin">origin</code></td>
<td>
<p>When <code>method</code> is &quot;histodot&quot;, origin of first bin</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_right">right</code></td>
<td>
<p>When <code>method</code> is &quot;histodot&quot;, should intervals be closed
on the right (a, b], or not [a, b)</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_width">width</code></td>
<td>
<p>When <code>binaxis</code> is &quot;y&quot;, the spacing of the dot stacks
for dodging.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_drop">drop</code></td>
<td>
<p>If TRUE, remove all bins with zero counts</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_dotplot_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With dot-density binning, the bin positions are determined by the data and
<code>binwidth</code>, which is the maximum width of each bin. See Wilkinson
(1999) for details on the dot-density binning algorithm.
</p>
<p>With histodot binning, the bins have fixed positions and fixed widths, much
like a histogram.
</p>
<p>When binning along the x axis and stacking along the y axis, the numbers on
y axis are not meaningful, due to technical limitations of ggplot2. You can
hide the y axis, as in one of the examples, or manually scale it
to match the number of dots.
</p>


<h3>Aesthetics</h3>

<p><code>geom_dotplot</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x</dt><dd><p>center of each bin, if binaxis is &quot;x&quot;</p>
</dd>
<dt>y</dt><dd><p>center of each bin, if binaxis is &quot;x&quot;</p>
</dd>
<dt>binwidth</dt><dd><p>max width of each bin if method is &quot;dotdensity&quot;;
width of each bin if method is &quot;histodot&quot;</p>
</dd>
<dt>count</dt><dd><p>number of points in bin</p>
</dd>
<dt>ncount</dt><dd><p>count, scaled to maximum of 1</p>
</dd>
<dt>density</dt><dd><p>density of points in bin, scaled to integrate to 1,
if method is &quot;histodot&quot;</p>
</dd>
<dt>ndensity</dt><dd><p>density, scaled to maximum of 1, if method is &quot;histodot&quot;</p>
</dd>
</dl>



<h3>References</h3>

<p>Wilkinson, L. (1999) Dot plots. The American Statistician,
53(3), 276-281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(x = mpg)) + geom_dotplot()
ggplot(mtcars, aes(x = mpg)) + geom_dotplot(binwidth = 1.5)

# Use fixed-width bins
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(method="histodot", binwidth = 1.5)

# Some other stacking methods
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(binwidth = 1.5, stackdir = "center")
ggplot(mtcars, aes(x = mpg)) +
  geom_dotplot(binwidth = 1.5, stackdir = "centerwhole")

# y axis isn't really meaningful, so hide it
ggplot(mtcars, aes(x = mpg)) + geom_dotplot(binwidth = 1.5) +
  scale_y_continuous(NULL, breaks = NULL)

# Overlap dots vertically
ggplot(mtcars, aes(x = mpg)) + geom_dotplot(binwidth = 1.5, stackratio = .7)

# Expand dot diameter
ggplot(mtcars, aes(x = mpg)) + geom_dotplot(binwidth = 1.5, dotsize = 1.25)


# Examples with stacking along y axis instead of x
ggplot(mtcars, aes(x = 1, y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "center")

ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "center")

ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "centerwhole")

ggplot(mtcars, aes(x = factor(vs), fill = factor(cyl), y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "center", position = "dodge")

# binpositions="all" ensures that the bins are aligned between groups
ggplot(mtcars, aes(x = factor(am), y = mpg)) +
  geom_dotplot(binaxis = "y", stackdir = "center", binpositions="all")

# Stacking multiple groups, with different fill
ggplot(mtcars, aes(x = mpg, fill = factor(cyl))) +
  geom_dotplot(stackgroups = TRUE, binwidth = 1, binpositions = "all")

ggplot(mtcars, aes(x = mpg, fill = factor(cyl))) +
  geom_dotplot(stackgroups = TRUE, binwidth = 1, method = "histodot")

ggplot(mtcars, aes(x = 1, y = mpg, fill = factor(cyl))) +
  geom_dotplot(binaxis = "y", stackgroups = TRUE, binwidth = 1, method = "histodot")

</code></pre>

<hr>
<h2 id='geom_errorbarh'>Horizontal error bars</h2><span id='topic+geom_errorbarh'></span>

<h3>Description</h3>

<p>Horizontal error bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_errorbarh(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_errorbarh_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_errorbarh_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_errorbarh</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>xmax</strong></p>
</li>
<li><p><strong>xmin</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>height
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_errorbar">geom_errorbar</a></code>: vertical error bars
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  trt = factor(c(1, 1, 2, 2)),
  resp = c(1, 5, 3, 4),
  group = factor(c(1, 2, 1, 2)),
  se = c(0.1, 0.3, 0.3, 0.2)
)

# Define the top and bottom of the errorbars

p &lt;- ggplot(df, aes(resp, trt, colour = group))
p + geom_point() +
  geom_errorbarh(aes(xmax = resp + se, xmin = resp - se))
p + geom_point() +
  geom_errorbarh(aes(xmax = resp + se, xmin = resp - se, height = .2))
</code></pre>

<hr>
<h2 id='geom_freqpoly'>Histograms and frequency polygons.</h2><span id='topic+geom_freqpoly'></span><span id='topic+geom_histogram'></span><span id='topic+stat_bin'></span>

<h3>Description</h3>

<p>Display a 1d distribution by dividing into bins and counting the number
of observations in each bin. Histograms use bars; frequency polygons use
lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_freqpoly(
  mapping = NULL,
  data = NULL,
  stat = "bin",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_histogram(
  mapping = NULL,
  data = NULL,
  stat = "bin",
  position = "stack",
  ...,
  binwidth = NULL,
  bins = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin(
  mapping = NULL,
  data = NULL,
  geom = "bar",
  position = "stack",
  ...,
  binwidth = NULL,
  bins = NULL,
  center = NULL,
  boundary = NULL,
  closed = c("right", "left"),
  pad = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_freqpoly_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins. The default is to use <code>bins</code>
bins that cover the range of the data. You should always override
this value, exploring multiple widths to find the best to illustrate the
stories in your data.
</p>
<p>The bin width of a date variable is the number of days in each time; the
bin width of a time variable is the number of seconds.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_bins">bins</code></td>
<td>
<p>Number of bins. Overridden by <code>binwidth</code>. Defaults to 30</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_geom">geom</code>, <code id="geom_freqpoly_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_histogram</code>/<code>geom_freqpoly</code> and <code>stat_bin</code>.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_center">center</code></td>
<td>
<p>The center of one of the bins.  Note that if center is above or
below the range of the data, things will be shifted by an appropriate
number of <code>width</code>s. To center on integers, for example, use
<code>width=1</code> and <code>center=0</code>, even if <code>0</code> is outside the range
of the data.  At most one of <code>center</code> and <code>boundary</code> may be
specified.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_boundary">boundary</code></td>
<td>
<p>A boundary between two bins. As with <code>center</code>, things
are shifted when <code>boundary</code> is outside the range of the data. For
example, to center on integers, use <code>width = 1</code> and <code>boundary =
0.5</code>, even if <code>1</code> is outside the range of the data.  At most one of
<code>center</code> and <code>boundary</code> may be specified.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
<tr><td><code id="geom_freqpoly_+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, adds empty bins at either end of x. This ensures
frequency polygons touch 0. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>stat_bin</code> uses 30 bins - this is not a good default,
but the idea is to get you experimenting with different binwidths. You
may need to look at a few to uncover the full story behind your data.
</p>


<h3>Aesthetics</h3>

<p><code>geom_histogram</code> uses the same aesthetics as <code>geom_bar</code>;
<code>geom_freqpoly</code> uses the same aesthetics as <code>geom_line</code>.
</p>


<h3>Computed variables</h3>


<dl>
<dt>count</dt><dd><p>number of points in bin</p>
</dd>
<dt>density</dt><dd><p>density of points in bin, scaled to integrate to 1</p>
</dd>
<dt>ncount</dt><dd><p>count, scaled to maximum of 1</p>
</dd>
<dt>ndensity</dt><dd><p>density, scaled to maximum of 1</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stat_count">stat_count</a></code>, which counts the number of cases at each x
posotion, without binning. It is suitable for both discrete and continuous
x data, whereas <a href="#topic+stat_bin">stat_bin</a> is suitable only for continuous x data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(diamonds, aes(carat)) +
  geom_histogram()
ggplot(diamonds, aes(carat)) +
  geom_histogram(binwidth = 0.01)
ggplot(diamonds, aes(carat)) +
  geom_histogram(bins = 200)

# Rather than stacking histograms, it's easier to compare frequency
# polygons
ggplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(binwidth = 500)
ggplot(diamonds, aes(price, colour = cut)) +
  geom_freqpoly(binwidth = 500)

# To make it easier to compare distributions with very different counts,
# put density on the y axis instead of the default count
ggplot(diamonds, aes(price, ..density.., colour = cut)) +
  geom_freqpoly(binwidth = 500)

if (require("ggplot2movies")) {
# Often we don't want the height of the bar to represent the
# count of observations, but the sum of some other variable.
# For example, the following plot shows the number of movies
# in each rating.
m &lt;- ggplot(movies, aes(rating))
m + geom_histogram(binwidth = 0.1)

# If, however, we want to see the number of votes cast in each
# category, we need to weight by the votes variable
m + geom_histogram(aes(weight = votes), binwidth = 0.1) + ylab("votes")

# For transformed scales, binwidth applies to the transformed data.
# The bins have constant width on the transformed scale.
m + geom_histogram() + scale_x_log10()
m + geom_histogram(binwidth = 0.05) + scale_x_log10()

# For transformed coordinate systems, the binwidth applies to the
# raw data. The bins have constant width on the original scale.

# Using log scales does not work here, because the first
# bar is anchored at zero, and so when transformed becomes negative
# infinity. This is not a problem when transforming the scales, because
# no observations have 0 ratings.
m + geom_histogram(origin = 0) + coord_trans(x = "log10")
# Use origin = 0, to make sure we don't take sqrt of negative values
m + geom_histogram(origin = 0) + coord_trans(x = "sqrt")

}
rm(movies)
</code></pre>

<hr>
<h2 id='geom_hex'>Hexagon binning.</h2><span id='topic+geom_hex'></span><span id='topic+stat_bin_hex'></span><span id='topic+stat_binhex'></span>

<h3>Description</h3>

<p>Hexagon binning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_hex(
  mapping = NULL,
  data = NULL,
  stat = "binhex",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin_hex(
  mapping = NULL,
  data = NULL,
  geom = "hex",
  position = "identity",
  ...,
  bins = 30,
  binwidth = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_hex_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_geom">geom</code>, <code id="geom_hex_+3A_stat">stat</code></td>
<td>
<p>Override the default connection between <code>geom_hex</code> and
<code>stat_binhex.</code></p>
</td></tr>
<tr><td><code id="geom_hex_+3A_bins">bins</code></td>
<td>
<p>numeric vector giving number of bins in both vertical and
horizontal directions. Set to 30 by default.</p>
</td></tr>
<tr><td><code id="geom_hex_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric vector giving bin width in both vertical and
horizontal directions. Overrides <code>bins</code> if both set.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_hex</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+stat_bin2d">stat_bin2d</a></code> for rectangular binning
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- ggplot(diamonds, aes(carat, price))
d + geom_hex()


# You can control the size of the bins by specifying the number of
# bins in each direction:
d + geom_hex(bins = 10)
d + geom_hex(bins = 30)

# Or by specifying the width of the bins
d + geom_hex(binwidth = c(1, 1000))
d + geom_hex(binwidth = c(.1, 500))

</code></pre>

<hr>
<h2 id='geom_jitter'>Points, jittered to reduce overplotting.</h2><span id='topic+geom_jitter'></span>

<h3>Description</h3>

<p>The jitter geom is a convenient default for geom_point with position =
'jitter'. It's a useful way of handling overplotting caused by discreteness
in smaller datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_jitter(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "jitter",
  ...,
  width = NULL,
  height = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_jitter_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_width">width</code>, <code id="geom_jitter_+3A_height">height</code></td>
<td>
<p>Amount of vertical and horizontal jitter. The jitter
is added in both positive and negative directions, so the total spread
is twice the value specified here.
</p>
<p>If omitted, defaults to 40% of the resolution of the data: this means the
jitter values will occupy 80% of the implied bins. Categorical data
is aligned on the integers, so a width or height of 0.5 will spread the
data so it's not possible to see the distinction between the categories.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_jitter_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_point</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>shape
</p>
</li>
<li><p>size
</p>
</li>
<li><p>stroke
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_point">geom_point</a></code> for regular, unjittered points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(cyl, hwy))
p + geom_point()
p + geom_jitter()

# Add aesthetic mappings
p + geom_jitter(aes(colour = class))

# Use smaller width/height to emphasise categories
ggplot(mpg, aes(cyl, hwy)) + geom_jitter()
ggplot(mpg, aes(cyl, hwy)) + geom_jitter(width = 0.25)

# Use larger width/height to completely smooth away discreteness
ggplot(mpg, aes(cty, hwy)) + geom_jitter()
ggplot(mpg, aes(cty, hwy)) + geom_jitter(width = 0.5, height = 0.5)
</code></pre>

<hr>
<h2 id='geom_label'>Textual annotations.</h2><span id='topic+geom_label'></span><span id='topic+geom_text'></span>

<h3>Description</h3>

<p><code>geom_text</code> adds text directly to the plot. <code>geom_label</code> draws
a rectangle underneath the text, making it easier to read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_label(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = unit(0.25, "lines"),
  label.r = unit(0.15, "lines"),
  label.size = 0.25,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_text(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_label_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_parse">parse</code></td>
<td>
<p>If TRUE, the labels will be parsed into expressions and
displayed as described in ?plotmath</p>
</td></tr>
<tr><td><code id="geom_label_+3A_nudge_x">nudge_x</code>, <code id="geom_label_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_label_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. A quick and dirty way</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note the the &quot;width&quot; and &quot;height&quot; of a text element are 0, so stacking
and dodging text will not work by default, and axis limits are not
automatically expanded to include all text. Obviously, labels do have
height and width, but they are physical units, not data units. The amount of
space they occupy on that plot is not constant in data units: when you
resize a plot, labels stay the same size, but the size of the axes changes.
</p>


<h3>Aesthetics</h3>

<p><code>geom_text</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>label</strong></p>
</li>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>angle
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>family
</p>
</li>
<li><p>fontface
</p>
</li>
<li><p>hjust
</p>
</li>
<li><p>lineheight
</p>
</li>
<li><p>size
</p>
</li>
<li><p>vjust
</p>
</li></ul>



<h3><code>geom_label</code></h3>

<p>Currently <code>geom_label</code> does not support the <code>rot</code> parameter and
is considerably slower than <code>geom_text</code>. The <code>fill</code> aesthetic
controls the background colour of the label.
</p>


<h3>Alignment</h3>

<p>You can modify text alignment with the <code>vjust</code> and <code>hjust</code>
aesthetics. These can either be a number between 0 (right/bottom) and
1 (top/left) or a character (&quot;left&quot;, &quot;middle&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;center&quot;,
&quot;top&quot;). There are two special alignments: &quot;inward&quot; and &quot;outward&quot;.
Inward always aligns text towards the center, and outward aligns
it away from the center
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg, label = rownames(mtcars)))

p + geom_text()
# Avoid overlaps
p + geom_text(check_overlap = TRUE)
# Labels with background
p + geom_label()
# Change size of the label
p + geom_text(size = 10)

# Set aesthetics to fixed value
p + geom_point() + geom_text(hjust = 0, nudge_x = 0.05)
p + geom_point() + geom_text(vjust = 0, nudge_y = 0.5)
p + geom_point() + geom_text(angle = 45)
## Not run: 
# Doesn't work on all systems
p + geom_text(family = "Times New Roman")

## End(Not run)

# Add aesthetic mappings
p + geom_text(aes(colour = factor(cyl)))
p + geom_text(aes(colour = factor(cyl))) +
  scale_colour_discrete(l = 40)
p + geom_label(aes(fill = factor(cyl)), colour = "white", fontface = "bold")

p + geom_text(aes(size = wt))
# Scale height of text, rather than sqrt(height)
p + geom_text(aes(size = wt)) + scale_radius(range = c(3,6))

# You can display expressions by setting parse = TRUE.  The
# details of the display are described in ?plotmath, but note that
# geom_text uses strings, not expressions.
p + geom_text(aes(label = paste(wt, "^(", cyl, ")", sep = "")),
  parse = TRUE)

# Add a text annotation
p +
  geom_text() +
  annotate("text", label = "plot mpg vs. wt", x = 2, y = 15, size = 8, colour = "red")


# Aligning labels and bars --------------------------------------------------
df &lt;- data.frame(
  x = factor(c(1, 1, 2, 2)),
  y = c(1, 3, 2, 1),
  grp = c("a", "b", "a", "b")
)

# ggplot2 doesn't know you want to give the labels the same virtual width
# as the bars:
ggplot(data = df, aes(x, y, fill = grp, label = y)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(position = "dodge")
# So tell it:
ggplot(data = df, aes(x, y, fill = grp, label = y)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(position = position_dodge(0.9))
# Use you can't nudge and dodge text, so instead adjust the y postion
ggplot(data = df, aes(x, y, fill = grp, label = y)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(y = y + 0.05), position = position_dodge(0.9), vjust = 0)

# To place text in the middle of each bar in a stacked barplot, you
# need to do the computation yourself
df &lt;- transform(df, mid_y = ave(df$y, df$x, FUN = function(val) cumsum(val) - (0.5 * val)))

ggplot(data = df, aes(x, y, fill = grp, label = y)) +
 geom_bar(stat = "identity") +
 geom_text(aes(y = mid_y))

# Justification -------------------------------------------------------------
df &lt;- data.frame(
  x = c(1, 1, 2, 2, 1.5),
  y = c(1, 2, 1, 2, 1.5),
  text = c("bottom-left", "bottom-right", "top-left", "top-right", "center")
)
ggplot(df, aes(x, y)) +
  geom_text(aes(label = text))
ggplot(df, aes(x, y)) +
  geom_text(aes(label = text), vjust = "inward", hjust = "inward")

</code></pre>

<hr>
<h2 id='geom_map'>Polygons from a reference map.</h2><span id='topic+geom_map'></span>

<h3>Description</h3>

<p>Does not affect position scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_map(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  ...,
  map,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_map_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_map">map</code></td>
<td>
<p>Data frame that contains the map coordinates.  This will
typically be created using <code><a href="#topic+fortify">fortify</a></code> on a spatial object.
It must contain columns <code>x</code> or <code>long</code>, <code>y</code> or
<code>lat</code>, and <code>region</code> or <code>id</code>.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_map_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_map</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>map_id</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># When using geom_polygon, you will typically need two data frames:
# one contains the coordinates of each polygon (positions),  and the
# other the values associated with each polygon (values).  An id
# variable links the two together

ids &lt;- factor(c("1.1", "2.1", "1.2", "2.2", "1.3", "2.3"))

values &lt;- data.frame(
  id = ids,
  value = c(3, 3.1, 3.1, 3.2, 3.15, 3.5)
)

positions &lt;- data.frame(
  id = rep(ids, each = 4),
  x = c(2, 1, 1.1, 2.2, 1, 0, 0.3, 1.1, 2.2, 1.1, 1.2, 2.5, 1.1, 0.3,
  0.5, 1.2, 2.5, 1.2, 1.3, 2.7, 1.2, 0.5, 0.6, 1.3),
  y = c(-0.5, 0, 1, 0.5, 0, 0.5, 1.5, 1, 0.5, 1, 2.1, 1.7, 1, 1.5,
  2.2, 2.1, 1.7, 2.1, 3.2, 2.8, 2.1, 2.2, 3.3, 3.2)
)

ggplot(values) + geom_map(aes(map_id = id), map = positions) +
  expand_limits(positions)
ggplot(values, aes(fill = value)) +
  geom_map(aes(map_id = id), map = positions) +
  expand_limits(positions)
ggplot(values, aes(fill = value)) +
  geom_map(aes(map_id = id), map = positions) +
  expand_limits(positions) + ylim(0, 3)

# Better example
crimes &lt;- data.frame(state = tolower(rownames(USArrests)), USArrests)
crimesm &lt;- reshape2::melt(crimes, id = 1)
if (require(maps)) {
  states_map &lt;- map_data("state")
  ggplot(crimes, aes(map_id = state)) +
    geom_map(aes(fill = Murder), map = states_map) +
    expand_limits(x = states_map$long, y = states_map$lat)

  last_plot() + coord_map()
  ggplot(crimesm, aes(map_id = state)) +
    geom_map(aes(fill = value), map = states_map) +
    expand_limits(x = states_map$long, y = states_map$lat) +
    facet_wrap( ~ variable)
}
</code></pre>

<hr>
<h2 id='geom_path'>Connect observations.</h2><span id='topic+geom_path'></span><span id='topic+geom_line'></span><span id='topic+geom_step'></span>

<h3>Description</h3>

<p><code>geom_path()</code> connects the observations in the order in which they appear
in the data. <code>geom_line()</code> connects them in order of the variable on the
x axis. <code>geom_step()</code> creates a stairstep plot, highlighting exactly
when changes occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_path(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 1,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_line(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_step(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  direction = "hv",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_path_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square)</p>
</td></tr>
<tr><td><code id="geom_path_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel)</p>
</td></tr>
<tr><td><code id="geom_path_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1)</p>
</td></tr>
<tr><td><code id="geom_path_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">arrow</a></code></p>
</td></tr>
<tr><td><code id="geom_path_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_path_+3A_direction">direction</code></td>
<td>
<p>direction of stairs: 'vh' for vertical then horizontal, or
'hv' for horizontal then vertical</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_path</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_polygon">geom_polygon</a></code>: Filled paths (polygons);
<code><a href="#topic+geom_segment">geom_segment</a></code>: Line segments
</p>


<h3>Examples</h3>

<pre><code class='language-R'># geom_line() is suitable for time series
ggplot(economics, aes(date, unemploy)) + geom_line()
ggplot(economics_long, aes(date, value01, colour = variable)) +
  geom_line()

# geom_step() is useful when you want to highlight exactly when
# the y value chanes
recent &lt;- economics[economics$date &gt; as.Date("2013-01-01"), ]
ggplot(recent, aes(date, unemploy)) + geom_line()
ggplot(recent, aes(date, unemploy)) + geom_step()

# geom_path lets you explore how two variables are related over time,
# e.g. unemployment and personal savings rate
m &lt;- ggplot(economics, aes(unemploy/pop, psavert))
m + geom_path()
m + geom_path(aes(colour = as.numeric(date)))

# Changing parameters ----------------------------------------------
ggplot(economics, aes(date, unemploy)) +
  geom_line(colour = "red")

# Use the arrow parameter to add an arrow to the line
# See ?arrow for more details
c &lt;- ggplot(economics, aes(x = date, y = pop))
c + geom_line(arrow = arrow())
c + geom_line(
  arrow = arrow(angle = 15, ends = "both", type = "closed")
)

# Control line join parameters
df &lt;- data.frame(x = 1:3, y = c(4, 1, 9))
base &lt;- ggplot(df, aes(x, y))
base + geom_path(size = 10)
base + geom_path(size = 10, lineend = "round")
base + geom_path(size = 10, linejoin = "mitre", lineend = "butt")

# NAs break the line. Use na.rm = T to suppress the warning message
df &lt;- data.frame(
  x = 1:5,
  y1 = c(1, 2, 3, 4, NA),
  y2 = c(NA, 2, 3, 4, 5),
  y3 = c(1, 2, NA, 4, 5)
)
ggplot(df, aes(x, y1)) + geom_point() + geom_line()
ggplot(df, aes(x, y2)) + geom_point() + geom_line()
ggplot(df, aes(x, y3)) + geom_point() + geom_line()


# Setting line type vs colour/size
# Line type needs to be applied to a line as a whole, so it can
# not be used with colour or size that vary across a line
x &lt;- seq(0.01, .99, length.out = 100)
df &lt;- data.frame(
  x = rep(x, 2),
  y = c(qlogis(x), 2 * qlogis(x)),
  group = rep(c("a","b"),
  each = 100)
)
p &lt;- ggplot(df, aes(x=x, y=y, group=group))
# These work
p + geom_line(linetype = 2)
p + geom_line(aes(colour = group), linetype = 2)
p + geom_line(aes(colour = x))
# But this doesn't
should_stop(p + geom_line(aes(colour = x), linetype=2))

</code></pre>

<hr>
<h2 id='geom_point'>Points, as for a scatterplot</h2><span id='topic+geom_point'></span>

<h3>Description</h3>

<p>The point geom is used to create scatterplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_point_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_point_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scatterplot is useful for displaying the relationship between two
continuous variables, although it can also be used with one continuous
and one categorical variable, or two categorical variables.  See
<code><a href="#topic+geom_jitter">geom_jitter</a></code> for possibilities.
</p>
<p>The <em>bubblechart</em> is a scatterplot with a third variable mapped to
the size of points.  There are no special names for scatterplots where
another variable is mapped to point shape or colour, however.
</p>
<p>The biggest potential problem with a scatterplot is overplotting: whenever
you have more than a few points, points may be plotted on top of one
another. This can severely distort the visual appearance of the plot.
There is no one solution to this problem, but there are some techniques
that can help.  You can add additional information with
<code><a href="#topic+geom_smooth">geom_smooth</a></code> or
<code><a href="#topic+geom_density_2d">geom_density_2d</a></code>.    Alternatively, you can
summarise the number of points at each location and display that in some
way, using <code><a href="#topic+stat_sum">stat_sum</a></code>. Another technique is to use transparent
points, e.g. <code>geom_point(alpha = 0.05)</code>.
</p>


<h3>Aesthetics</h3>

<p><code>geom_point</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>shape
</p>
</li>
<li><p>size
</p>
</li>
<li><p>stroke
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scale_size">scale_size</a></code> to see scale area of points, instead of
radius, <code><a href="#topic+geom_jitter">geom_jitter</a></code> to jitter points to reduce (mild)
overplotting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg))
p + geom_point()

# Add aesthetic mappings
p + geom_point(aes(colour = factor(cyl)))
p + geom_point(aes(shape = factor(cyl)))
p + geom_point(aes(size = qsec))

# Change scales
p + geom_point(aes(colour = cyl)) + scale_colour_gradient(low = "blue")
p + geom_point(aes(shape = factor(cyl))) + scale_shape(solid = FALSE)

# Set aesthetics to fixed value
ggplot(mtcars, aes(wt, mpg)) + geom_point(colour = "red", size = 3)


# Varying alpha is useful for large datasets
d &lt;- ggplot(diamonds, aes(carat, price))
d + geom_point(alpha = 1/10)
d + geom_point(alpha = 1/20)
d + geom_point(alpha = 1/100)


# For shapes that have a border (like 21), you can colour the inside and
# outside separately. Use the stroke aesthetic to modify the width of the
# border
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(shape = 21, colour = "black", fill = "white", size = 5, stroke = 5)


# You can create interesting shapes by layering multiple points of
# different sizes
p &lt;- ggplot(mtcars, aes(mpg, wt, shape = factor(cyl)))
p + geom_point(aes(colour = factor(cyl)), size = 4) +
  geom_point(colour = "grey90", size = 1.5)
p + geom_point(colour = "black", size = 4.5) +
  geom_point(colour = "pink", size = 4) +
  geom_point(aes(shape = factor(cyl)))

# These extra layers don't usually appear in the legend, but we can
# force their inclusion
p + geom_point(colour = "black", size = 4.5, show.legend = TRUE) +
  geom_point(colour = "pink", size = 4, show.legend = TRUE) +
  geom_point(aes(shape = factor(cyl)))

# geom_point warns when missing values have been dropped from the data set
# and not plotted, you can turn this off by setting na.rm = TRUE
mtcars2 &lt;- transform(mtcars, mpg = ifelse(runif(32) &lt; 0.2, NA, mpg))
ggplot(mtcars2, aes(wt, mpg)) + geom_point()
ggplot(mtcars2, aes(wt, mpg)) + geom_point(na.rm = TRUE)

</code></pre>

<hr>
<h2 id='geom_polygon'>Polygon, a filled path.</h2><span id='topic+geom_polygon'></span>

<h3>Description</h3>

<p>Polygon, a filled path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_polygon(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_polygon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_polygon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_polygon</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_path">geom_path</a></code> for an unfilled polygon,
<code><a href="#topic+geom_ribbon">geom_ribbon</a></code> for a polygon anchored on the x-axis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># When using geom_polygon, you will typically need two data frames:
# one contains the coordinates of each polygon (positions),  and the
# other the values associated with each polygon (values).  An id
# variable links the two together

ids &lt;- factor(c("1.1", "2.1", "1.2", "2.2", "1.3", "2.3"))

values &lt;- data.frame(
  id = ids,
  value = c(3, 3.1, 3.1, 3.2, 3.15, 3.5)
)

positions &lt;- data.frame(
  id = rep(ids, each = 4),
  x = c(2, 1, 1.1, 2.2, 1, 0, 0.3, 1.1, 2.2, 1.1, 1.2, 2.5, 1.1, 0.3,
  0.5, 1.2, 2.5, 1.2, 1.3, 2.7, 1.2, 0.5, 0.6, 1.3),
  y = c(-0.5, 0, 1, 0.5, 0, 0.5, 1.5, 1, 0.5, 1, 2.1, 1.7, 1, 1.5,
  2.2, 2.1, 1.7, 2.1, 3.2, 2.8, 2.1, 2.2, 3.3, 3.2)
)

# Currently we need to manually merge the two together
datapoly &lt;- merge(values, positions, by = c("id"))

(p &lt;- ggplot(datapoly, aes(x = x, y = y)) + geom_polygon(aes(fill = value, group = id)))

# Which seems like a lot of work, but then it's easy to add on
# other features in this coordinate system, e.g.:

stream &lt;- data.frame(
  x = cumsum(runif(50, max = 0.1)),
  y = cumsum(runif(50,max = 0.1))
)

p + geom_line(data = stream, colour = "grey30", size = 5)

# And if the positions are in longitude and latitude, you can use
# coord_map to produce different map projections.
</code></pre>

<hr>
<h2 id='geom_raster'>Draw rectangles.</h2><span id='topic+geom_raster'></span><span id='topic+geom_rect'></span><span id='topic+geom_tile'></span>

<h3>Description</h3>

<p><code>geom_rect</code> and <code>geom_tile</code> do the same thing, but are
parameterised differently. <code>geom_rect</code> uses the locations of the four
corners (<code>xmin</code>, <code>xmax</code>, <code>ymin</code> and <code>ymax</code>).
<code>geom_tile</code> uses the center of the tile and its size (<code>x</code>,
<code>y</code>, <code>width</code>, <code>height</code>). <code>geom_raster</code> is a high
performance special case for when all the tiles are the same size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_raster(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  hjust = 0.5,
  vjust = 0.5,
  interpolate = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rect(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_tile(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_raster_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_hjust">hjust</code>, <code id="geom_raster_+3A_vjust">vjust</code></td>
<td>
<p>horizontal and vertical justification of the grob.  Each
justification value should be a number between 0 and 1.  Defaults to 0.5
for both, centering each pixel over its data location.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_raster_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_tile</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># The most common use for rectangles is to draw a surface. You always want
# to use geom_raster here because it's so much faster, and produces
# smaller output when saving to PDF
ggplot(faithfuld, aes(waiting, eruptions)) +
 geom_raster(aes(fill = density))

# Interpolation smooths the surface &amp; is most helpful when rendering images.
ggplot(faithfuld, aes(waiting, eruptions)) +
 geom_raster(aes(fill = density), interpolate = TRUE)

# If you want to draw arbitrary rectangles, use geom_tile() or geom_rect()
df &lt;- data.frame(
  x = rep(c(2, 5, 7, 9, 12), 2),
  y = rep(c(1, 2), each = 5),
  z = factor(rep(1:5, each = 2)),
  w = rep(diff(c(0, 4, 6, 8, 10, 14)), 2)
)
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = z))
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = z, width = w), colour = "grey50")
ggplot(df, aes(xmin = x - w / 2, xmax = x + w / 2, ymin = y, ymax = y + 1)) +
  geom_rect(aes(fill = z, width = w), colour = "grey50")


# Justification controls where the cells are anchored
df &lt;- expand.grid(x = 0:5, y = 0:5)
df$z &lt;- runif(nrow(df))
# default is compatible with geom_tile()
ggplot(df, aes(x, y, fill = z)) + geom_raster()
# zero padding
ggplot(df, aes(x, y, fill = z)) + geom_raster(hjust = 0, vjust = 0)

# Inspired by the image-density plots of Ken Knoblauch
cars &lt;- ggplot(mtcars, aes(mpg, factor(cyl)))
cars + geom_point()
cars + stat_bin2d(aes(fill = ..count..), binwidth = c(3,1))
cars + stat_bin2d(aes(fill = ..density..), binwidth = c(3,1))

cars + stat_density(aes(fill = ..density..), geom = "raster", position = "identity")
cars + stat_density(aes(fill = ..count..), geom = "raster", position = "identity")

</code></pre>

<hr>
<h2 id='geom_ribbon'>Ribbons and area plots.</h2><span id='topic+geom_ribbon'></span><span id='topic+geom_area'></span>

<h3>Description</h3>

<p>For each continuous x value, <code>geom_interval</code> displays a y interval.
<code>geom_area</code> is a special case of <code>geom_ribbon</code>, where the
minimum of the range is fixed to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_ribbon(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_area(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "stack",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_ribbon_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_ribbon_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An area plot is the continuous analog of a stacked bar chart (see
<code><a href="#topic+geom_bar">geom_bar</a></code>), and can be used to show how composition of the
whole varies over the range of x.  Choosing the order in which different
components is stacked is very important, as it becomes increasing hard to
see the individual pattern as you move up the stack.
</p>


<h3>Aesthetics</h3>

<p><code>geom_ribbon</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>ymax</strong></p>
</li>
<li><p><strong>ymin</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_bar">geom_bar</a></code> for discrete intervals (bars),
<code><a href="#topic+geom_linerange">geom_linerange</a></code> for discrete intervals (lines),
<code><a href="#topic+geom_polygon">geom_polygon</a></code> for general polygons
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
huron &lt;- data.frame(year = 1875:1972, level = as.vector(LakeHuron))
h &lt;- ggplot(huron, aes(year))

h + geom_ribbon(aes(ymin=0, ymax=level))
h + geom_area(aes(y = level))

# Add aesthetic mappings
h +
  geom_ribbon(aes(ymin = level - 1, ymax = level + 1), fill = "grey70") +
  geom_line(aes(y = level))
</code></pre>

<hr>
<h2 id='geom_rug'>Marginal rug plots.</h2><span id='topic+geom_rug'></span>

<h3>Description</h3>

<p>Marginal rug plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_rug(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  sides = "bl",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_rug_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_sides">sides</code></td>
<td>
<p>A string that controls which sides of the plot the rugs appear on.
It can be set to a string containing any of <code>"trbl"</code>, for top, right,
bottom, and left.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_rug_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_rug</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg))
p + geom_point()
p + geom_point() + geom_rug()
p + geom_point() + geom_rug(sides="b")    # Rug on bottom only
p + geom_point() + geom_rug(sides="trbl") # All four sides
p + geom_point() + geom_rug(position='jitter')
</code></pre>

<hr>
<h2 id='geom_segment'>Line segments and curves.</h2><span id='topic+geom_segment'></span><span id='topic+geom_curve'></span>

<h3>Description</h3>

<p><code>geom_segment</code> draws a straight line between points (x1, y1) and
(x2, y2). <code>geom_curve</code> draws a curved line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_segment(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_curve(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  curvature = 0.5,
  angle = 90,
  ncp = 5,
  arrow = NULL,
  lineend = "butt",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_segment_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_arrow">arrow</code></td>
<td>
<p>specification for arrow heads, as created by arrow()</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square)</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_curvature">curvature</code></td>
<td>
<p>A numeric value giving the amount of curvature.
Negative values produce left-hand curves, positive values
produce right-hand curves, and zero produces a straight line.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_angle">angle</code></td>
<td>
<p>A numeric value between 0 and 180,
giving an amount to skew the control
points of the curve.  Values less than 90 skew the curve towards
the start point and values greater than 90 skew the curve
towards the end point.</p>
</td></tr>
<tr><td><code id="geom_segment_+3A_ncp">ncp</code></td>
<td>
<p>The number of control points used to draw the curve.
More control points creates a smoother curve.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_segment</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>xend</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p><strong>yend</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+geom_path">geom_path</a></code> and <code><a href="#topic+geom_line">geom_line</a></code> for multi-
segment lines and paths.
</p>
<p><code><a href="#topic+geom_spoke">geom_spoke</a></code> for a segment parameterised by a location
(x, y), and an angle and radius.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point()

df &lt;- data.frame(x1 = 2.62, x2 = 3.57, y1 = 21.0, y2 = 15.0)
b +
 geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), data = df) +
 geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "segment"), data = df)

b + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2), data = df, curvature = -0.2)
b + geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2), data = df, curvature = 1)
b + geom_curve(
  aes(x = x1, y = y1, xend = x2, yend = y2),
  data = df,
  arrow = arrow(length = unit(0.03, "npc"))
)

ggplot(seals, aes(long, lat)) +
  geom_segment(aes(xend = long + delta_long, yend = lat + delta_lat),
    arrow = arrow(length = unit(0.1,"cm"))) +
  borders("state")

# You can also use geom_segment to recreate plot(type = "h") :
counts &lt;- as.data.frame(table(x = rpois(100,5)))
counts$x &lt;- as.numeric(as.character(counts$x))
with(counts, plot(x, Freq, type = "h", lwd = 10))

ggplot(counts, aes(x, Freq)) +
  geom_segment(aes(xend = x, yend = 0), size = 10, lineend = "butt")
</code></pre>

<hr>
<h2 id='geom_smooth'>Add a smoothed conditional mean.</h2><span id='topic+geom_smooth'></span><span id='topic+stat_smooth'></span>

<h3>Description</h3>

<p>Aids the eye in seeing patterns in the presence of overplotting.
<code>geom_smooth</code> and <code>stat_smooth</code> are effectively aliases: they
both use the same arguments. Use <code>geom_smooth</code> unless you want to
display the results with a non-standard geom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_smooth(
  mapping = NULL,
  data = NULL,
  stat = "smooth",
  position = "identity",
  ...,
  method = "auto",
  formula = y ~ x,
  se = TRUE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_smooth(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = "auto",
  formula = y ~ x,
  se = TRUE,
  n = 80,
  span = 0.75,
  fullrange = FALSE,
  level = 0.95,
  method.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_smooth_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_method">method</code></td>
<td>
<p>smoothing method (function) to use, eg. lm, glm, gam, loess,
rlm. For datasets with n &lt; 1000 default is <code><a href="stats.html#topic+loess">loess</a></code>. For datasets
with 1000 or more observations defaults to gam, see <code><a href="mgcv.html#topic+gam">gam</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_formula">formula</code></td>
<td>
<p>formula to use in smoothing function, eg. <code>y ~ x</code>,
<code>y ~ poly(x, 2)</code>, <code>y ~ log(x)</code></p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_se">se</code></td>
<td>
<p>display confidence interval around smooth? (TRUE by default, see
level to control</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_geom">geom</code>, <code id="geom_smooth_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_smooth</code> and <code>stat_smooth</code>.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_n">n</code></td>
<td>
<p>number of points to evaluate smoother at</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_span">span</code></td>
<td>
<p>Controls the amount of smoothing for the default loess smoother.
Smaller numbers produce wigglier lines, larger numbers produce smoother
lines.</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_fullrange">fullrange</code></td>
<td>
<p>should the fit span the full range of the plot, or just
the data</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_level">level</code></td>
<td>
<p>level of confidence interval to use (0.95 by default)</p>
</td></tr>
<tr><td><code id="geom_smooth_+3A_method.args">method.args</code></td>
<td>
<p>List of additional arguments passed on to the modelling
function defined by <code>method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation is performed by the (currently undocumented)
<code>predictdf</code> generic and its methods.  For most methods the standard
error bounds are computed using the <code><a href="stats.html#topic+predict">predict</a></code> method - the
exceptions are <code>loess</code> which uses a t-based approximation, and
<code>glm</code> where the normal confidence interval is constructed on the link
scale, and then back-transformed to the response scale.
</p>


<h3>Aesthetics</h3>

<p><code>geom_smooth</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li>
<li><p>weight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>y</dt><dd><p>predicted value</p>
</dd>
<dt>ymin</dt><dd><p>lower pointwise confidence interval around the mean</p>
</dd>
<dt>ymax</dt><dd><p>upper pointwise confidence interval around the mean</p>
</dd>
<dt>se</dt><dd><p>standard error</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See individual modelling functions for more details:
<code><a href="stats.html#topic+lm">lm</a></code> for linear smooths,
<code><a href="stats.html#topic+glm">glm</a></code> for generalised linear smooths,
<code><a href="stats.html#topic+loess">loess</a></code> for local smooths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth()

# Use span to control the "wiggliness" of the default loess smoother
# The span is the fraction of points used to fit each local regression:
# small numbers make a wigglier curve, larger numbers make a smoother curve.
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(span = 0.3)

# Instead of a loess smooth, you can use any other modelling function:
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ splines::bs(x, 3), se = FALSE)

# Smoothes are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet

ggplot(mpg, aes(displ, hwy, colour = class)) +
  geom_point() +
  geom_smooth(se = FALSE, method = "lm")
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(span = 0.8) +
  facet_wrap(~drv)


binomial_smooth &lt;- function(...) {
  geom_smooth(method = "glm", method.args = list(family = "binomial"), ...)
}
# To fit a logistic regression, you need to coerce the values to
# a numeric vector lying between 0 and 1.
ggplot(rpart::kyphosis, aes(Age, Kyphosis)) +
  geom_jitter(height = 0.05) +
  binomial_smooth()

ggplot(rpart::kyphosis, aes(Age, as.numeric(Kyphosis) - 1)) +
  geom_jitter(height = 0.05) +
  binomial_smooth()

ggplot(rpart::kyphosis, aes(Age, as.numeric(Kyphosis) - 1)) +
  geom_jitter(height = 0.05) +
  binomial_smooth(formula = y ~ splines::ns(x, 2))

# But in this case, it's probably better to fit the model yourself
# so you can exercise more control and see whether or not it's a good model

</code></pre>

<hr>
<h2 id='geom_spoke'>A line segment parameterised by location, direction and distance.</h2><span id='topic+geom_spoke'></span><span id='topic+stat_spoke'></span>

<h3>Description</h3>

<p>A line segment parameterised by location, direction and distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spoke(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_spoke_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_spoke_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_spoke</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>angle</strong></p>
</li>
<li><p><strong>radius</strong></p>
</li>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- expand.grid(x = 1:10, y=1:10)
df$angle &lt;- runif(100, 0, 2*pi)
df$speed &lt;- runif(100, 0, sqrt(0.1 * df$x))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_spoke(aes(angle = angle), radius = 0.5)

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_spoke(aes(angle = angle, radius = speed))
</code></pre>

<hr>
<h2 id='geom_tallrect'>ggplot2 geom with xmin and xmax aesthetics that covers the entire y range, useful for clickSelects background elements.</h2><span id='topic+geom_tallrect'></span>

<h3>Description</h3>

<p>ggplot2 geom with xmin and xmax aesthetics that covers the entire y range, useful for clickSelects background elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_tallrect(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_tallrect_+3A_mapping">mapping</code></td>
<td>
<p>aesthetic mapping</p>
</td></tr>
<tr><td><code id="geom_tallrect_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="geom_tallrect_+3A_stat">stat</code></td>
<td>
<p>statistic mapping, defaults to identity</p>
</td></tr>
<tr><td><code id="geom_tallrect_+3A_position">position</code></td>
<td>
<p>position mapping, defaults to identity</p>
</td></tr>
<tr><td><code id="geom_tallrect_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="geom_tallrect_+3A_na.rm">na.rm</code></td>
<td>
<p>remove missing values?</p>
</td></tr>
<tr><td><code id="geom_tallrect_+3A_show.legend">show.legend</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
<tr><td><code id="geom_tallrect_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('data.table'))setDTthreads(1)#for CRAN.

library(animint2)

## Example: 2 plots, 2 selectors, but only interacting with 1 plot.
data(breakpoints)
only.error &lt;- subset(breakpoints$error,type=="E")
only.segments &lt;- subset(only.error,bases.per.probe==bases.per.probe[1])
signal.colors &lt;- c(estimate="#0adb0a", latent="#0098ef")
breakpointError &lt;- list(
  signal=ggplot()+
    geom_point(aes(
      position, signal),
      showSelected="bases.per.probe",
      data=breakpoints$signals)+
    geom_line(aes(
      position, signal), 
      colour=signal.colors[["latent"]],
      data=breakpoints$imprecision)+
    geom_segment(aes(
      first.base, mean, xend=last.base, yend=mean),
      showSelected=c("segments", "bases.per.probe"),
      colour=signal.colors[["estimate"]],
      data=breakpoints$segments)+
    geom_vline(aes(
      xintercept=base),
      showSelected=c("segments", "bases.per.probe"),
      colour=signal.colors[["estimate"]],
      linetype="dashed",
      data=breakpoints$breaks),
  error=ggplot()+
    geom_vline(aes(
      xintercept=segments), 
      clickSelects="segments",
      data=only.segments, lwd=17, alpha=1/2)+
    geom_line(aes(
      segments, error, group=bases.per.probe),
      clickSelects="bases.per.probe",
      data=only.error, lwd=4))
animint2dir(breakpointError)
</code></pre>

<hr>
<h2 id='geom_violin'>Violin plot.</h2><span id='topic+geom_violin'></span><span id='topic+stat_ydensity'></span>

<h3>Description</h3>

<p>Violin plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_violin(
  mapping = NULL,
  data = NULL,
  stat = "ydensity",
  position = "dodge",
  ...,
  draw_quantiles = NULL,
  trim = TRUE,
  scale = "area",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_ydensity(
  mapping = NULL,
  data = NULL,
  geom = "violin",
  position = "dodge",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  trim = TRUE,
  scale = "area",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_violin_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_draw_quantiles">draw_quantiles</code></td>
<td>
<p>If <code>not(NULL)</code> (default), draw horizontal lines
at the given quantiles of the density estimate.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_trim">trim</code></td>
<td>
<p>If <code>TRUE</code> (default), trim the tails of the violins
to the range of the data. If <code>FALSE</code>, don't trim the tails.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_scale">scale</code></td>
<td>
<p>if &quot;area&quot; (default), all violins have the same area (before trimming
the tails). If &quot;count&quot;, areas are scaled proportionally to the number of
observations. If &quot;width&quot;, all violins have the same maximum width.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_geom">geom</code>, <code id="geom_violin_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_violin</code> and <code>stat_ydensity</code>.</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_bw">bw</code></td>
<td>
<p>the smoothing bandwidth to be used, see
<code><a href="stats.html#topic+density">density</a></code> for details</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_adjust">adjust</code></td>
<td>
<p>adjustment of the bandwidth, see
<code><a href="stats.html#topic+density">density</a></code> for details</p>
</td></tr>
<tr><td><code id="geom_violin_+3A_kernel">kernel</code></td>
<td>
<p>kernel used for density estimation, see
<code><a href="stats.html#topic+density">density</a></code> for details</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_violin</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li>
<li><p>alpha
</p>
</li>
<li><p>colour
</p>
</li>
<li><p>fill
</p>
</li>
<li><p>linetype
</p>
</li>
<li><p>size
</p>
</li>
<li><p>weight
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>density</dt><dd><p>density estimate</p>
</dd>
<dt>scaled</dt><dd><p>density estimate, scaled to maximum of 1</p>
</dd>
<dt>count</dt><dd><p>density * number of points - probably useless for violin plots</p>
</dd>
<dt>violinwidth</dt><dd><p>density scaled for the violin plot, according to area, counts
or to a constant maximum width</p>
</dd>
<dt>n</dt><dd><p>number of points</p>
</dd>
<dt>width</dt><dd><p>width of violin bounding box</p>
</dd>
</dl>



<h3>References</h3>

<p>Hintze, J. L., Nelson, R. D. (1998) Violin Plots: A Box
Plot-Density Trace Synergism. The American Statistician 52, 181-184.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_violin">geom_violin</a></code> for examples, and <code><a href="#topic+stat_density">stat_density</a></code>
for examples with data along the x axis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(factor(cyl), mpg))
p + geom_violin()


p + geom_violin() + geom_jitter(height = 0)
p + geom_violin() + coord_flip()

# Scale maximum width proportional to sample size:
p + geom_violin(scale = "count")

# Scale maximum width to 1 for all violins:
p + geom_violin(scale = "width")

# Default is to trim violins to the range of the data. To disable:
p + geom_violin(trim = FALSE)

# Use a smaller bandwidth for closer density fit (default is 1).
p + geom_violin(adjust = .5)

# Add aesthetic mappings
# Note that violins are automatically dodged when any aesthetic is
# a factor
p + geom_violin(aes(fill = cyl))
p + geom_violin(aes(fill = factor(cyl)))
p + geom_violin(aes(fill = factor(vs)))
p + geom_violin(aes(fill = factor(am)))

# Set aesthetics to fixed value
p + geom_violin(fill = "grey80", colour = "#3366FF")

# Show quartiles
p + geom_violin(draw_quantiles = c(0.25, 0.5, 0.75))

# Scales vs. coordinate transforms -------
if (require("ggplot2movies")) {
# Scale transformations occur before the density statistics are computed.
# Coordinate transformations occur afterwards.  Observe the effect on the
# number of outliers.
m &lt;- ggplot(movies, aes(y = votes, x = rating, group = cut_width(rating, 0.5)))
m + geom_violin()
m + geom_violin() + scale_y_log10()
m + geom_violin() + coord_trans(y = "log10")
m + geom_violin() + scale_y_log10() + coord_trans(y = "log10")

# Violin plots with continuous x:
# Use the group aesthetic to group observations in violins
ggplot(movies, aes(year, budget)) + geom_violin()
ggplot(movies, aes(year, budget)) +
  geom_violin(aes(group = cut_width(year, 10)), scale = "width")
}

</code></pre>

<hr>
<h2 id='geom_widerect'>ggplot2 geom with ymin and ymax aesthetics that covers the entire x range, useful for clickSelects background elements.</h2><span id='topic+geom_widerect'></span>

<h3>Description</h3>

<p>ggplot2 geom with ymin and ymax aesthetics that covers the entire x range, useful for clickSelects background elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_widerect(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_widerect_+3A_mapping">mapping</code></td>
<td>
<p>aesthetic mapping</p>
</td></tr>
<tr><td><code id="geom_widerect_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="geom_widerect_+3A_stat">stat</code></td>
<td>
<p>statistic mapping, defaults to identity</p>
</td></tr>
<tr><td><code id="geom_widerect_+3A_position">position</code></td>
<td>
<p>position mapping, defaults to identity</p>
</td></tr>
<tr><td><code id="geom_widerect_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="geom_widerect_+3A_na.rm">na.rm</code></td>
<td>
<p>remove missing values?</p>
</td></tr>
<tr><td><code id="geom_widerect_+3A_show.legend">show.legend</code></td>
<td>
<p>TRUE OR FALSE</p>
</td></tr>
<tr><td><code id="geom_widerect_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>TRUE OR FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run:  
   source(system.file("examples/WorldBank.R", package = "animint"))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='getCommonChunk'>Save the common columns for each tsv to one chunk</h2><span id='topic+getCommonChunk'></span>

<h3>Description</h3>

<p>Save the common columns for each tsv to one chunk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCommonChunk(built, chunk.vars, aes.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCommonChunk_+3A_built">built</code></td>
<td>
<p>data.frame of built data.</p>
</td></tr>
<tr><td><code id="getCommonChunk_+3A_chunk.vars">chunk.vars</code></td>
<td>
<p>which variables to chunk on.</p>
</td></tr>
<tr><td><code id="getCommonChunk_+3A_aes.list">aes.list</code></td>
<td>
<p>a character vector of aesthetics.</p>
</td></tr>
<tr><td><code id="getCommonChunk_+3A_vars">vars</code></td>
<td>
<p>character vector of chunk variable names to split on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of common and varied data to save, or NULL if there is
no common data.
</p>

<hr>
<h2 id='getLayerName'>Gives a unique name to each layer in <code>saveLayer</code></h2><span id='topic+getLayerName'></span>

<h3>Description</h3>

<p>Gives a unique name to each layer in <code>saveLayer</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLayerName(L, geom_num, p.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLayerName_+3A_l">L</code></td>
<td>
<p>layer in saveLayer to be named</p>
</td></tr>
<tr><td><code id="getLayerName_+3A_geom_num">geom_num</code></td>
<td>
<p>the number of the layer to be saved</p>
</td></tr>
<tr><td><code id="getLayerName_+3A_p.name">p.name</code></td>
<td>
<p>the name of the plot to which the layer belongs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a unique name for the layer
</p>

<hr>
<h2 id='getLayerParams'>Get all parameters for a layer</h2><span id='topic+getLayerParams'></span>

<h3>Description</h3>

<p>Get all parameters for a layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLayerParams(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLayerParams_+3A_l">l</code></td>
<td>
<p>A single layer of the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All parameters in the layer
</p>

<hr>
<h2 id='getLegend'>Function to get legend information for each scale</h2><span id='topic+getLegend'></span>

<h3>Description</h3>

<p>Function to get legend information for each scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLegend(mb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLegend_+3A_mb">mb</code></td>
<td>
<p>single entry from guides_merge() list of legend data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of legend information, NULL if guide=FALSE.
</p>

<hr>
<h2 id='getLegendList'>Function to get legend information from ggplot</h2><span id='topic+getLegendList'></span>

<h3>Description</h3>

<p>Function to get legend information from ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLegendList(plistextra)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLegendList_+3A_plistextra">plistextra</code></td>
<td>
<p>output from ggplot_build(p)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing information for each legend
</p>

<hr>
<h2 id='getTextSize'>Function to process text size with different types of unit</h2><span id='topic+getTextSize'></span>

<h3>Description</h3>

<p>Function to process text size with different types of unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTextSize(element.name, theme)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTextSize_+3A_element.name">element.name</code></td>
<td>
<p>The name of the theme element</p>
</td></tr>
<tr><td><code id="getTextSize_+3A_theme">theme</code></td>
<td>
<p>combined theme from plot_theme()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character of text size, with unit pt/px
</p>

<hr>
<h2 id='getUniqueAxisLabels'>Get unique axis labels for the plot</h2><span id='topic+getUniqueAxisLabels'></span>

<h3>Description</h3>

<p>Get unique axis labels for the plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUniqueAxisLabels(plot.meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUniqueAxisLabels_+3A_plot.meta">plot.meta</code></td>
<td>
<p>contains axis labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified <code>plot.meta</code> with unique axis labels
</p>

<hr>
<h2 id='gg_dep'>Give a deprecation error, warning, or message, depending on version number.</h2><span id='topic+gg_dep'></span>

<h3>Description</h3>

<p>Version numbers have the format &lt;major&gt;.&lt;minor&gt;.&lt;subminor&gt;, like 0.9.2.
This function compares the current version number of ggplot2 against the
specified <code>version</code>, which is the most recent version before the
function (or other object) was deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_dep(version, msg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_dep_+3A_version">version</code></td>
<td>
<p>The last version of ggplot2 where this function was good
(in other words, the last version where it was not deprecated).</p>
</td></tr>
<tr><td><code id="gg_dep_+3A_msg">msg</code></td>
<td>
<p>The message to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gg_dep</code> will give an error, warning, or message, depending on the
difference between the current ggplot2 version and the specified
<code>version</code>.
</p>
<p>If the current major number is greater than <code>version</code>'s major number,
or if the current minor number is more than 1 greater than <code>version</code>'s
minor number, give an error.
</p>
<p>If the current minor number differs from <code>version</code>'s minor number by
one, give a warning.
</p>
<p>If the current subminor number differs from <code>version</code>'s subminor
number, print a message.
</p>

<hr>
<h2 id='gganimintproto'>Create a new gganimintproto object</h2><span id='topic+gganimintproto'></span><span id='topic+gganimintproto_parent'></span>

<h3>Description</h3>

<p>gganimintproto is inspired by the proto package, but it has some important
differences. Notably, it cleanly supports cross-package inheritance, and has
faster performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gganimintproto(`_class` = NULL, `_inherit` = NULL, ...)

gganimintproto_parent(parent, self)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gganimintproto_+3A__class">_class</code></td>
<td>
<p>Class name to assign to the object. This is stored as the class
attribute of the object. If <code>NULL</code> (the default), no class name will
be added to the object.</p>
</td></tr>
<tr><td><code id="gganimintproto_+3A__inherit">_inherit</code></td>
<td>
<p>gganimintproto object to inherit from. If <code>NULL</code>, don't inherit
from any object.</p>
</td></tr>
<tr><td><code id="gganimintproto_+3A_...">...</code></td>
<td>
<p>A list of members in the gganimintproto object.</p>
</td></tr>
<tr><td><code id="gganimintproto_+3A_parent">parent</code>, <code id="gganimintproto_+3A_self">self</code></td>
<td>
<p>Access parent class <code>parent</code> of object <code>self</code>.</p>
</td></tr>
</table>


<h3>Calling gganimintproto methods</h3>

<p>gganimintproto methods can take an optional <code>self</code> argument: if it is present,
it is a regular method; if it's absent, it's a &quot;static&quot; method (i.e. it
doesn't use any fields).
</p>
<p>Imagine you have a gganimintproto object <code>Adder</code>, which has a
method <code>addx = function(self, n) n + self$x</code>. Then, to call this
function, you would use <code>Adder$addx(10)</code> &ndash; the <code>self</code> is passed
in automatically by the wrapper function. <code>self</code> be located anywhere
in the function signature, although customarily it comes first.
</p>


<h3>Calling methods in a parent</h3>

<p>To explicitly call a methods in a parent, use
<code>gganimintproto_parent(Parent, self)</code>.
</p>

<hr>
<h2 id='ggplot'>Create a new ggplot plot.</h2><span id='topic+ggplot'></span><span id='topic+ggplot.default'></span><span id='topic+ggplot.data.frame'></span>

<h3>Description</h3>

<p><code>ggplot()</code> initializes a ggplot object. It can be used to
declare the input data frame for a graphic and to specify the
set of plot aesthetics intended to be common throughout all
subsequent layers unless specifically overridden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot(data = NULL, mapping = aes(), ..., environment = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_+3A_data">data</code></td>
<td>
<p>Default dataset to use for plot. If not already a data.frame,
will be converted to one by <code><a href="#topic+fortify">fortify</a></code>. If not specified,
must be suppled in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_mapping">mapping</code></td>
<td>
<p>Default list of aesthetic mappings to use for plot.
If not specified, must be suppled in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not currently used.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_environment">environment</code></td>
<td>
<p>If an variable defined in the aesthetic mapping is not
found in the data, ggplot will look for it in this environment. It defaults
to using the environment in which <code>ggplot()</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggplot()</code> is typically used to construct a plot
incrementally, using the + operator to add layers to the
existing ggplot object. This is advantageous in that the
code is explicit about which layers are added and the order
in which they are added. For complex graphics with multiple
layers, initialization with <code>ggplot</code> is recommended.
</p>
<p>There are three common ways to invoke <code>ggplot</code>:
</p>

<ul>
<li> <p><code>ggplot(df, aes(x, y, &lt;other aesthetics&gt;))</code>
</p>
</li>
<li> <p><code>ggplot(df)</code>
</p>
</li>
<li> <p><code>ggplot()</code>
</p>
</li></ul>

<p>The first method is recommended if all layers use the same
data and the same set of aesthetics, although this method
can also be used to add a layer using data from another
data frame. See the first example below. The second
method specifies the default data frame to use for the plot,
but no aesthetics are defined up front. This is useful when
one data frame is used predominantly as layers are added,
but the aesthetics may vary from one layer to another. The
third method initializes a skeleton <code>ggplot</code> object which
is fleshed out as layers are added. This method is useful when
multiple data frames are used to produce different layers, as
is often the case in complex graphics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(gp = factor(rep(letters[1:3], each = 10)),
                 y = rnorm(30))
# Compute sample mean and standard deviation in each group
ds &lt;- plyr::ddply(df, "gp", plyr::summarise, mean = mean(y), sd = sd(y))

# Declare the data frame and common aesthetics.
# The summary data frame ds is used to plot
# larger red points in a second geom_point() layer.
# If the data = argument is not specified, it uses the
# declared data frame from ggplot(); ditto for the aesthetics.
ggplot(df, aes(x = gp, y = y)) +
   geom_point() +
   geom_point(data = ds, aes(y = mean),
              colour = 'red', size = 3)
# Same plot as above, declaring only the data frame in ggplot().
# Note how the x and y aesthetics must now be declared in
# each geom_point() layer.
ggplot(df) +
   geom_point(aes(x = gp, y = y)) +
   geom_point(data = ds, aes(x = gp, y = mean),
                 colour = 'red', size = 3)
# Set up a skeleton ggplot object and add layers:
ggplot() +
  geom_point(data = df, aes(x = gp, y = y)) +
  geom_point(data = ds, aes(x = gp, y = mean),
                        colour = 'red', size = 3) +
  geom_errorbar(data = ds, aes(x = gp, y = mean,
                    ymin = mean - sd, ymax = mean + sd),
                    colour = 'red', width = 0.4)
</code></pre>

<hr>
<h2 id='ggplot_build'>Build ggplot for rendering.</h2><span id='topic+ggplot_build'></span><span id='topic+layer_data'></span><span id='topic+layer_scales'></span><span id='topic+layer_grob'></span>

<h3>Description</h3>

<p><code>ggplot_build</code> takes the plot object, and performs all steps necessary
to produce an object that can be rendered.  This function outputs two pieces:
a list of data frames (one for each layer), and a panel object, which
contain all information about axis limits, breaks etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_build(plot)

layer_data(plot, i = 1L)

layer_scales(plot, i = 1L, j = 1L)

layer_grob(plot, i = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_build_+3A_plot">plot</code></td>
<td>
<p>ggplot object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>layer_data</code>, <code>layer_grob</code>, and <code>layer_scales</code> are helper
functions that returns the data, grob, or scales associated with a given
layer. These are useful for tests.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.gganimintplot">print.gganimintplot</a></code> and <code><a href="#topic+benchplot">benchplot</a></code> for
functions that contain the complete set of steps for generating
a ggplot2 plot.
</p>

<hr>
<h2 id='ggplot_gtable'>Build a plot with all the usual bits and pieces.</h2><span id='topic+ggplot_gtable'></span>

<h3>Description</h3>

<p>This function builds all grobs necessary for displaying the plot, and
stores them in a special data structure called a <code><a href="gtable.html#topic+gtable">gtable</a></code>.
This object is amenable to programmatic manipulation, should you want
to (e.g.) make the legend box 2 cm wide, or combine multiple plots into
a single display, preserving aspect ratios across the plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_gtable(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_gtable_+3A_data">data</code></td>
<td>
<p>plot data generated by <code><a href="#topic+ggplot_build">ggplot_build</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="gtable.html#topic+gtable">gtable</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.gganimintplot">print.gganimintplot</a></code> and <code>link{benchplot}</code> for
for functions that contain the complete set of steps for generating
a ggplot2 plot.
</p>

<hr>
<h2 id='ggplotGrob'>Generate a ggplot2 plot grob.</h2><span id='topic+ggplotGrob'></span>

<h3>Description</h3>

<p>Generate a ggplot2 plot grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplotGrob(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplotGrob_+3A_x">x</code></td>
<td>
<p>ggplot2 object</p>
</td></tr>
</table>

<hr>
<h2 id='ggsave'>Save a ggplot (or other grid object) with sensible defaults</h2><span id='topic+ggsave'></span>

<h3>Description</h3>

<p><code>ggsave()</code> is a convenient function for saving a plot. It defaults to
saving the last plot that you displayed, using the size of the current
graphics device. It also guesses the type of graphics device from the
extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggsave(
  filename,
  plot = last_plot(),
  device = NULL,
  path = NULL,
  scale = 1,
  width = NA,
  height = NA,
  units = c("in", "cm", "mm"),
  dpi = 300,
  limitsize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggsave_+3A_filename">filename</code></td>
<td>
<p>File name to create on disk.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_plot">plot</code></td>
<td>
<p>Plot to save, defaults to last plot displayed.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_device">device</code></td>
<td>
<p>Device to use (function or any of the recognized extensions,
e.g. <code>"pdf"</code>). By default, extracted from filename extension.
<code>ggsave</code> currently recognises eps/ps, tex (pictex), pdf, jpeg, tiff,
png, bmp, svg and wmf (windows only).</p>
</td></tr>
<tr><td><code id="ggsave_+3A_path">path</code></td>
<td>
<p>Path to save plot to (combined with filename).</p>
</td></tr>
<tr><td><code id="ggsave_+3A_scale">scale</code></td>
<td>
<p>Multiplicative scaling factor.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_width">width</code>, <code id="ggsave_+3A_height">height</code></td>
<td>
<p>Plot dimensions, defaults to size of current graphics
device.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_units">units</code></td>
<td>
<p>Units for width and height when specified explicitly (in, cm,
or mm)</p>
</td></tr>
<tr><td><code id="ggsave_+3A_dpi">dpi</code></td>
<td>
<p>Resolution used for raster outputs.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_limitsize">limitsize</code></td>
<td>
<p>When <code>TRUE</code> (the default), <code>ggsave</code> will not
save images larger than 50x50 inches, to prevent the common error of
specifying dimensions in pixels.</p>
</td></tr>
<tr><td><code id="ggsave_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to graphics device</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ggplot(mtcars, aes(mpg, wt)) + geom_point()

ggsave(file.path(tempdir(), "mtcars.pdf"))
ggsave(file.path(tempdir(), "mtcars.png"))

ggsave(file.path(tempdir(), "mtcars.pdf"), width = 4, height = 4)
ggsave(file.path(tempdir(), "mtcars.pdf"), width = 20, height = 20, units = "cm")

unlink(file.path(tempdir(), "mtcars.pdf"))
unlink(file.path(tempdir(), "mtcars.png"))

# specify device when saving to a file with unknown extension
# (for example a server supplied temporary file)
file &lt;- tempfile()
ggsave(file, device = "pdf")
unlink(file)

## End(Not run)
</code></pre>

<hr>
<h2 id='ggtheme'>ggplot2 themes</h2><span id='topic+ggtheme'></span><span id='topic+theme_grey'></span><span id='topic+theme_gray'></span><span id='topic+theme_bw'></span><span id='topic+theme_linedraw'></span><span id='topic+theme_light'></span><span id='topic+theme_minimal'></span><span id='topic+theme_classic'></span><span id='topic+theme_dark'></span><span id='topic+theme_void'></span>

<h3>Description</h3>

<p>Themes set the general aspect of the plot such as the colour of the
background, gridlines, the size and colour of fonts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_grey(base_size = 11, base_family = "")

theme_gray(base_size = 11, base_family = "")

theme_bw(base_size = 12, base_family = "")

theme_linedraw(base_size = 12, base_family = "")

theme_light(base_size = 12, base_family = "")

theme_minimal(base_size = 12, base_family = "")

theme_classic(base_size = 12, base_family = "")

theme_dark(base_size = 12, base_family = "")

theme_void(base_size = 12, base_family = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggtheme_+3A_base_size">base_size</code></td>
<td>
<p>base font size</p>
</td></tr>
<tr><td><code id="ggtheme_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>theme_gray</code></dt><dd>
<p>The signature ggplot2 theme with a grey background and white gridlines,
designed to put the data forward yet make comparisons easy.</p>
</dd>
<dt><code>theme_bw</code></dt><dd>
<p>The classic dark-on-light ggplot2 theme. May work better for presentations
displayed with a projector.</p>
</dd>
<dt><code>theme_linedraw</code></dt><dd>
<p>A theme with only black lines of various widths on white backgrounds,
reminiscent of a line drawings. Serves a purpose similar to <code>theme_bw</code>.
Note that this theme has some very thin lines (&lt;&lt; 1 pt) which some journals
may refuse.</p>
</dd>
<dt><code>theme_light</code></dt><dd>
<p>A theme similar to <code>theme_linedraw</code> but with light grey lines and axes,
to direct more attention towards the data.</p>
</dd>
<dt><code>theme_dark</code></dt><dd>
<p>The dark cousin of <code>theme_light</code>, with similar line sizes but a dark background. Useful to make thin coloured lines pop out.</p>
</dd>
<dt><code>theme_minimal</code></dt><dd>
<p>A minimalistic theme with no background annotations.</p>
</dd>
<dt><code>theme_classic</code></dt><dd>
<p>A classic-looking theme, with x and y axis lines and no gridlines.</p>
</dd>
<dt><code>theme_void</code></dt><dd>
<p>A completely empty theme.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars) + geom_point(aes(x = wt, y = mpg,
     colour = factor(gear))) + facet_wrap(~am)

p
p + theme_gray()
p + theme_bw()
p + theme_linedraw()
p + theme_light()
p + theme_dark()
p + theme_minimal()
p + theme_classic()
p + theme_void()

</code></pre>

<hr>
<h2 id='graphical-units'>Graphical units</h2><span id='topic+graphical-units'></span><span id='topic+.pt'></span><span id='topic+.stroke'></span>

<h3>Description</h3>

<p>Multiply size in mm by these constants in order to convert to the units
that grid uses internally for <code>lwd</code> and <code>fontsize</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pt

.stroke
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>

<hr>
<h2 id='guide_colourbar'>Continuous colour bar guide.</h2><span id='topic+guide_colourbar'></span><span id='topic+guide_colorbar'></span>

<h3>Description</h3>

<p>Colour bar guide shows continuous color scales mapped onto values.
Colour bar is available with <code>scale_fill</code> and <code>scale_colour</code>.
For more information, see the inspiration for this function:
<a href="http://www.mathworks.com/help/techdoc/ref/colorbar.html">Matlab's colorbar function</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_colourbar(
  title = waiver(),
  title.position = NULL,
  title.theme = NULL,
  title.hjust = NULL,
  title.vjust = NULL,
  label = TRUE,
  label.position = NULL,
  label.theme = NULL,
  label.hjust = NULL,
  label.vjust = NULL,
  barwidth = NULL,
  barheight = NULL,
  nbin = 20,
  raster = TRUE,
  ticks = TRUE,
  draw.ulim = TRUE,
  draw.llim = TRUE,
  direction = NULL,
  default.unit = "line",
  reverse = FALSE,
  order = 0,
  ...
)

guide_colorbar(
  title = waiver(),
  title.position = NULL,
  title.theme = NULL,
  title.hjust = NULL,
  title.vjust = NULL,
  label = TRUE,
  label.position = NULL,
  label.theme = NULL,
  label.hjust = NULL,
  label.vjust = NULL,
  barwidth = NULL,
  barheight = NULL,
  nbin = 20,
  raster = TRUE,
  ticks = TRUE,
  draw.ulim = TRUE,
  draw.llim = TRUE,
  direction = NULL,
  default.unit = "line",
  reverse = FALSE,
  order = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_colourbar_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_title.position">title.position</code></td>
<td>
<p>A character string indicating the position of a
title. One of &quot;top&quot; (default for a vertical guide), &quot;bottom&quot;, &quot;left&quot;
(default for a horizontal guide), or &quot;right.&quot;</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_title.theme">title.theme</code></td>
<td>
<p>A theme object for rendering the title text. Usually the
object of <code><a href="#topic+element_text">element_text</a></code> is expected. By default, the theme is
specified by <code>legend.title</code> in <code><a href="#topic+theme">theme</a></code> or theme.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_title.hjust">title.hjust</code></td>
<td>
<p>A number specifying horizontal justification of the
title text.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_title.vjust">title.vjust</code></td>
<td>
<p>A number specifying vertical justification of the title
text.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_label">label</code></td>
<td>
<p>logical. If <code>TRUE</code> then the labels are drawn. If
<code>FALSE</code> then the labels are invisible.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_label.position">label.position</code></td>
<td>
<p>A character string indicating the position of a
label. One of &quot;top&quot;, &quot;bottom&quot; (default for horizontal guide), &quot;left&quot;, or
&quot;right&quot; (default for vertical guide).</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_label.theme">label.theme</code></td>
<td>
<p>A theme object for rendering the label text. Usually the
object of <code><a href="#topic+element_text">element_text</a></code> is expected. By default, the theme is
specified by <code>legend.text</code> in <code><a href="#topic+theme">theme</a></code> or theme.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_label.hjust">label.hjust</code></td>
<td>
<p>A numeric specifying horizontal justification of the
label text.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_label.vjust">label.vjust</code></td>
<td>
<p>A numeric specifying vertical justification of the label
text.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_barwidth">barwidth</code></td>
<td>
<p>A numeric or a <code><a href="grid.html#topic+unit">unit</a></code> object specifying
the width of the colorbar. Default value is <code>legend.key.width</code> or
<code>legend.key.size</code> in <code><a href="#topic+theme">theme</a></code> or theme.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_barheight">barheight</code></td>
<td>
<p>A numeric or a <code><a href="grid.html#topic+unit">unit</a></code> object specifying
the height of the colorbar. Default value is <code>legend.key.height</code> or
<code>legend.key.size</code> in <code><a href="#topic+theme">theme</a></code> or theme.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_nbin">nbin</code></td>
<td>
<p>A numeric specifying the number of bins for drawing colorbar. A
smoother colorbar for a larger value.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_raster">raster</code></td>
<td>
<p>A logical. If <code>TRUE</code> then the colorbar is rendered as a
raster object. If <code>FALSE</code> then the colorbar is rendered as a set of
rectangles. Note that not all graphics devices are capable of rendering
raster image.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_ticks">ticks</code></td>
<td>
<p>A logical specifying if tick marks on colorbar should be
visible.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_draw.ulim">draw.ulim</code></td>
<td>
<p>A logical specifying if the upper limit tick marks should
be visible.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_draw.llim">draw.llim</code></td>
<td>
<p>A logical specifying if the lower limit tick marks should
be visible.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_default.unit">default.unit</code></td>
<td>
<p>A character string indicating <code><a href="grid.html#topic+unit">unit</a></code>
for <code>barwidth</code> and <code>barheight</code>.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_reverse">reverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the colorbar is reversed. By default,
the highest value is on the top and the lowest value is on the bottom</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_order">order</code></td>
<td>
<p>positive integer less that 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_colourbar_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Guides can be specified in each <code>scale_*</code> or in <code><a href="#topic+guides">guides</a></code>.
<code>guide="legend"</code> in <code>scale_*</code> is syntactic sugar for
<code>guide=guide_legend()</code> (e.g. <code>scale_color_manual(guide = "legend")</code>).
As for how to specify the guide for each scale in more detail,
see <code><a href="#topic+guides">guides</a></code>.
</p>


<h3>Value</h3>

<p>A guide object
</p>


<h3>See Also</h3>

<p>Other guides: 
<code><a href="#topic+guide_legend">guide_legend</a>()</code>,
<code><a href="#topic+guides">guides</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- reshape2::melt(outer(1:4, 1:4), varnames = c("X1", "X2"))

p1 &lt;- ggplot(df, aes(X1, X2)) + geom_tile(aes(fill = value))
p2 &lt;- p1 + geom_point(aes(size = value))

# Basic form
p1 + scale_fill_continuous(guide = "colorbar")
p1 + scale_fill_continuous(guide = guide_colorbar())
p1 + guides(fill = guide_colorbar())

# Control styles

# bar size
p1 + guides(fill = guide_colorbar(barwidth = 0.5, barheight = 10))

# no label
p1 + guides(fill = guide_colorbar(label = FALSE))

# no tick marks
p1 + guides(fill = guide_colorbar(ticks = FALSE))

# label position
p1 + guides(fill = guide_colorbar(label.position = "left"))

# label theme
p1 + guides(fill = guide_colorbar(label.theme = element_text(colour = "blue", angle = 0)))

# small number of bins
p1 + guides(fill = guide_colorbar(nbin = 3))

# large number of bins
p1 + guides(fill = guide_colorbar(nbin = 100))

# make top- and bottom-most ticks invisible
p1 + scale_fill_continuous(limits = c(0,20), breaks = c(0, 5, 10, 15, 20),
 guide = guide_colorbar(nbin=100, draw.ulim = FALSE, draw.llim = FALSE))

# guides can be controlled independently
p2 +
  scale_fill_continuous(guide = "colorbar") +
  scale_size(guide = "legend")
p2 + guides(fill = "colorbar", size = "legend")

p2 +
  scale_fill_continuous(guide = guide_colorbar(direction = "horizontal")) +
  scale_size(guide = guide_legend(direction = "vertical"))
</code></pre>

<hr>
<h2 id='guide_legend'>Legend guide.</h2><span id='topic+guide_legend'></span>

<h3>Description</h3>

<p>Legend type guide shows key (i.e., geoms) mapped onto values.
Legend guides for various scales are integrated if possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_legend(
  title = waiver(),
  title.position = NULL,
  title.theme = NULL,
  title.hjust = NULL,
  title.vjust = NULL,
  label = TRUE,
  label.position = NULL,
  label.theme = NULL,
  label.hjust = NULL,
  label.vjust = NULL,
  keywidth = NULL,
  keyheight = NULL,
  direction = NULL,
  default.unit = "line",
  override.aes = list(),
  nrow = NULL,
  ncol = NULL,
  byrow = FALSE,
  reverse = FALSE,
  order = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_legend_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="#topic+waiver">waiver</a></code>), the name of the scale object or the name
specified in <code><a href="#topic+labs">labs</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_title.position">title.position</code></td>
<td>
<p>A character string indicating the position of a
title. One of &quot;top&quot; (default for a vertical guide), &quot;bottom&quot;, &quot;left&quot;
(default for a horizontal guide), or &quot;right.&quot;</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_title.theme">title.theme</code></td>
<td>
<p>A theme object for rendering the title text. Usually the
object of <code><a href="#topic+element_text">element_text</a></code> is expected. By default, the theme is
specified by <code>legend.title</code> in <code><a href="#topic+theme">theme</a></code> or theme.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_title.hjust">title.hjust</code></td>
<td>
<p>A number specifying horizontal justification of the
title text.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_title.vjust">title.vjust</code></td>
<td>
<p>A number specifying vertical justification of the title
text.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_label">label</code></td>
<td>
<p>logical. If <code>TRUE</code> then the labels are drawn. If
<code>FALSE</code> then the labels are invisible.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_label.position">label.position</code></td>
<td>
<p>A character string indicating the position of a
label. One of &quot;top&quot;, &quot;bottom&quot; (default for horizontal guide), &quot;left&quot;, or
&quot;right&quot; (default for vertical guide).</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_label.theme">label.theme</code></td>
<td>
<p>A theme object for rendering the label text. Usually the
object of <code><a href="#topic+element_text">element_text</a></code> is expected. By default, the theme is
specified by <code>legend.text</code> in <code><a href="#topic+theme">theme</a></code> or theme.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_label.hjust">label.hjust</code></td>
<td>
<p>A numeric specifying horizontal justification of the
label text.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_label.vjust">label.vjust</code></td>
<td>
<p>A numeric specifying vertical justification of the label
text.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_keywidth">keywidth</code></td>
<td>
<p>A numeric or a <code><a href="grid.html#topic+unit">unit</a></code> object specifying
the width of the legend key. Default value is <code>legend.key.width</code> or
<code>legend.key.size</code> in <code><a href="#topic+theme">theme</a></code> or theme.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_keyheight">keyheight</code></td>
<td>
<p>A numeric or a <code><a href="grid.html#topic+unit">unit</a></code> object specifying
the height of the legend key. Default value is <code>legend.key.height</code> or
<code>legend.key.size</code> in <code><a href="#topic+theme">theme</a></code> or theme.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the direction of the guide.
One of &quot;horizontal&quot; or &quot;vertical.&quot;</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_default.unit">default.unit</code></td>
<td>
<p>A character string indicating <code><a href="grid.html#topic+unit">unit</a></code>
for <code>keywidth</code> and <code>keyheight</code>.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_override.aes">override.aes</code></td>
<td>
<p>A list specifying aesthetic parameters of legend key.
See details and examples.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_nrow">nrow</code></td>
<td>
<p>The desired number of rows of legends.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_ncol">ncol</code></td>
<td>
<p>The desired number of column of legends.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_byrow">byrow</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default) the legend-matrix is
filled by columns, otherwise the legend-matrix is filled by rows.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_reverse">reverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the order of legends is reversed.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_order">order</code></td>
<td>
<p>positive integer less that 99 that specifies the order of
this guide among multiple guides. This controls the order in which
multiple guides are displayed, not the contents of the guide itself.
If 0 (default), the order is determined by a secret algorithm.</p>
</td></tr>
<tr><td><code id="guide_legend_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Guides can be specified in each <code>scale_*</code> or in <code><a href="#topic+guides">guides</a></code>.
<code>guide="legend"</code> in <code>scale_*</code> is syntactic sugar for
<code>guide=guide_legend()</code> (e.g. <code>scale_color_manual(guide = "legend")</code>).
As for how to specify the guide for each scale in more detail,
see <code><a href="#topic+guides">guides</a></code>.
</p>


<h3>Value</h3>

<p>A guide object
</p>


<h3>See Also</h3>

<p>Other guides: 
<code><a href="#topic+guide_colourbar">guide_colourbar</a>()</code>,
<code><a href="#topic+guides">guides</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- reshape2::melt(outer(1:4, 1:4), varnames = c("X1", "X2"))

p1 &lt;- ggplot(df, aes(X1, X2)) + geom_tile(aes(fill = value))
p2 &lt;- p1 + geom_point(aes(size = value))

# Basic form
p1 + scale_fill_continuous(guide = "legend")
p1 + scale_fill_continuous(guide = guide_legend())

# Guide title
p1 + scale_fill_continuous(guide = guide_legend(title = "V")) # title text
p1 + scale_fill_continuous(guide = guide_legend(title = NULL)) # no title

# Control styles

# key size
p1 + guides(fill = guide_legend(keywidth = 3, keyheight = 1))

# title position
p1 + guides(fill = guide_legend(title = "LEFT", title.position = "left"))

# title text styles via element_text
p1 + guides(fill =
  guide_legend(
    title.theme = element_text(
      size = 15,
      face = "italic",
      colour = "red",
      angle = 0
    )
  )
)

# label position
p1 + guides(fill = guide_legend(label.position = "left", label.hjust = 1))

# label styles
p1 + scale_fill_continuous(breaks = c(5, 10, 15),
  labels = paste("long", c(5, 10, 15)),
  guide = guide_legend(
    direction = "horizontal",
    title.position = "top",
    label.position = "bottom",
    label.hjust = 0.5,
    label.vjust = 1,
    label.theme = element_text(angle = 90)
  )
)

# Set aesthetic of legend key

# very low alpha value make it difficult to see legend key
p3 &lt;- ggplot(diamonds, aes(carat, price)) +
  geom_point(aes(colour = color), alpha = 1/100)
p3

# override.aes overwrites the alpha
p3 + guides(colour = guide_legend(override.aes = list(alpha = 1)))

# multiple row/col legends
df &lt;- data.frame(x = 1:20, y = 1:20, color = letters[1:20])
p &lt;- ggplot(df, aes(x, y)) +
  geom_point(aes(colour = color))
p + guides(col = guide_legend(nrow = 8))
p + guides(col = guide_legend(ncol = 8))
p + guides(col = guide_legend(nrow = 8, byrow = TRUE))
p + guides(col = guide_legend(ncol = 8, byrow = TRUE))

# reversed order legend
p + guides(col = guide_legend(reverse = TRUE))

</code></pre>

<hr>
<h2 id='guides'>Set guides for each scale.</h2><span id='topic+guides'></span>

<h3>Description</h3>

<p>Guides for each scale can be set in call of <code>scale_*</code> with argument
<code>guide</code>, or in <code>guides</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guides(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guides_+3A_...">...</code></td>
<td>
<p>List of scale guide pairs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the mapping between scale and guide.
</p>


<h3>See Also</h3>

<p>Other guides: 
<code><a href="#topic+guide_colourbar">guide_colourbar</a>()</code>,
<code><a href="#topic+guide_legend">guide_legend</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ggplot object

dat &lt;- data.frame(x = 1:5, y = 1:5, p = 1:5, q = factor(1:5),
 r = factor(1:5))
p &lt;- ggplot(dat, aes(x, y, colour = p, size = q, shape = r)) + geom_point()

# without guide specification
p

# Show colorbar guide for colour.
# All these examples below have a same effect.

p + guides(colour = "colorbar", size = "legend", shape = "legend")
p + guides(colour = guide_colorbar(), size = guide_legend(),
  shape = guide_legend())
p +
 scale_colour_continuous(guide = "colorbar") +
 scale_size_discrete(guide = "legend") +
 scale_shape(guide = "legend")

 # Remove some guides
 p + guides(colour = "none")
 p + guides(colour = "colorbar",size = "none")

# Guides are integrated where possible

p + guides(colour = guide_legend("title"), size = guide_legend("title"),
  shape = guide_legend("title"))
# same as
g &lt;- guide_legend("title")
p + guides(colour = g, size = g, shape = g)

p + theme(legend.position = "bottom")

# position of guides

p + theme(legend.position = "bottom", legend.box = "horizontal")

# Set order for multiple guides
ggplot(mpg, aes(displ, cty)) +
  geom_point(aes(size = hwy, colour = cyl, shape = drv)) +
  guides(
   colour = guide_colourbar(order = 1),
   shape = guide_legend(order = 2),
   size = guide_legend(order = 3)
 )

</code></pre>

<hr>
<h2 id='hmisc'>Wrap up a selection of summary functions from Hmisc to make it easy to use
with <code><a href="#topic+stat_summary">stat_summary</a></code>.</h2><span id='topic+hmisc'></span><span id='topic+mean_cl_boot'></span><span id='topic+mean_cl_normal'></span><span id='topic+mean_sdl'></span><span id='topic+median_hilow'></span>

<h3>Description</h3>

<p>See the Hmisc documentation for details of their options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_cl_boot(x, ...)

mean_cl_normal(x, ...)

mean_sdl(x, ...)

median_hilow(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmisc_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="hmisc_+3A_...">...</code></td>
<td>
<p>other arguments passed on to the respective Hmisc function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+smean.cl.boot">smean.cl.boot</a></code>,
<code><a href="Hmisc.html#topic+smean.cl.normal">smean.cl.normal</a></code>, <code><a href="Hmisc.html#topic+smean.sdl">smean.sdl</a></code>,
<code><a href="Hmisc.html#topic+smedian.hilow">smedian.hilow</a></code>
</p>

<hr>
<h2 id='intreg'>
Interval regression
</h2><span id='topic+intreg'></span>

<h3>Description</h3>

<p>Learning model complexity using max-margin interval regression. We have
observed several noisy piecewise constant signals, and we have
weak labels about how many change-points occur in several regions. Max
margin interval regression is an algorithm that uses this information to
learn a penalty function for accurate change-point detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(intreg)</code></pre>


<h3>Format</h3>

<p>There are 7 related data.frames: signals contains the noisy
piecewise constant signals, annotations contains the weak labels,
segments and breaks contain the segmentation model, selection contains
the penalty and cost information, intervals contains the target
intervals of penalty values for each signal, and model describes the
learned max margin interval regression model.
</p>

<hr>
<h2 id='is.Coord'>Is this object a coordinate system?</h2><span id='topic+is.Coord'></span>

<h3>Description</h3>

<p>Is this object a coordinate system?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Coord(x)
</code></pre>

<hr>
<h2 id='is.facet'>Is this object a facetting specification?</h2><span id='topic+is.facet'></span>

<h3>Description</h3>

<p>Is this object a facetting specification?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.facet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.facet_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.gganimintproto'>Is an object a gganimintproto object?</h2><span id='topic+is.gganimintproto'></span>

<h3>Description</h3>

<p>Is an object a gganimintproto object?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.gganimintproto(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.gganimintproto_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>

<hr>
<h2 id='is.ggplot'>Reports whether x is a ggplot object</h2><span id='topic+is.ggplot'></span>

<h3>Description</h3>

<p>Reports whether x is a ggplot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ggplot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ggplot_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.rel'>Reports whether x is a rel object</h2><span id='topic+is.rel'></span>

<h3>Description</h3>

<p>Reports whether x is a rel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rel_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.rgb'>Check if character is an RGB hexadecimal color value</h2><span id='topic+is.rgb'></span>

<h3>Description</h3>

<p>Check if character is an RGB hexadecimal color value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rgb(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rgb_+3A_x">x</code></td>
<td>
<p>character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True/False value
</p>

<hr>
<h2 id='is.theme'>Reports whether x is a theme object</h2><span id='topic+is.theme'></span>

<h3>Description</h3>

<p>Reports whether x is a theme object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.theme(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.theme_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>

<hr>
<h2 id='issueSelectorWarnings'>Issue warnings for selectors</h2><span id='topic+issueSelectorWarnings'></span>

<h3>Description</h3>

<p>Issue warnings for selectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>issueSelectorWarnings(geoms, selector.aes, duration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="issueSelectorWarnings_+3A_geoms">geoms</code></td>
<td>
<p><code>geoms</code> to check for warnings</p>
</td></tr>
<tr><td><code id="issueSelectorWarnings_+3A_selector.aes">selector.aes</code></td>
<td>
<p>selectors for each geom</p>
</td></tr>
<tr><td><code id="issueSelectorWarnings_+3A_duration">duration</code></td>
<td>
<p>animation variable information to check for <code>key</code> value</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='knit_print.animint'>Insert an interactive animation into an R markdown document using a customized print method.</h2><span id='topic+knit_print.animint'></span>

<h3>Description</h3>

<p>Insert an interactive animation into an R markdown document using a customized print method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'animint'
knit_print(x, options, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_print.animint_+3A_x">x</code></td>
<td>
<p>named list of ggplots and option lists to pass to <code>animint2dir</code>.</p>
</td></tr>
<tr><td><code id="knit_print.animint_+3A_options">options</code></td>
<td>
<p>knitr options.</p>
</td></tr>
<tr><td><code id="knit_print.animint_+3A_...">...</code></td>
<td>
<p>placeholder.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carson Sievert
</p>


<h3>References</h3>

<p>https://github.com/yihui/knitr/blob/master/vignettes/knit_print.Rmd
</p>

<hr>
<h2 id='label_bquote'>Backquoted labeller</h2><span id='topic+label_bquote'></span>

<h3>Description</h3>

<p><code><a href="#topic+label_bquote">label_bquote</a>()</code> offers a flexible way of labelling
facet rows or columns with plotmath expressions. Backquoted
variables will be replaced with their value in the facet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_bquote(rows = NULL, cols = NULL, default = label_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_bquote_+3A_rows">rows</code></td>
<td>
<p>Backquoted labelling expression for rows.</p>
</td></tr>
<tr><td><code id="label_bquote_+3A_cols">cols</code></td>
<td>
<p>Backquoted labelling expression for columns.</p>
</td></tr>
<tr><td><code id="label_bquote_+3A_default">default</code></td>
<td>
<p>Default labeller function for the rows or the
columns when no plotmath expression is provided.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+labellers">labellers</a>, <code><a href="#topic+labeller">labeller</a>()</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The variables mentioned in the plotmath expression must be
# backquoted and referred to by their names.
p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p + facet_grid(vs ~ ., labeller = label_bquote(alpha ^ .(vs)))
p + facet_grid(. ~ vs, labeller = label_bquote(cols = .(vs) ^ .(vs)))
p + facet_grid(. ~ vs + am, labeller = label_bquote(cols = .(am) ^ .(vs)))
</code></pre>

<hr>
<h2 id='labeller'>Generic labeller function for facets</h2><span id='topic+labeller'></span>

<h3>Description</h3>

<p>This function makes it easy to assign different labellers to
different factors. The labeller can be a function or it can be a
named character vectors that will serve as a lookup table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labeller(
  ...,
  .rows = NULL,
  .cols = NULL,
  keep.as.numeric = NULL,
  .multi_line = TRUE,
  .default = label_value
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labeller_+3A_...">...</code></td>
<td>
<p>Named arguments of the form <code>variable =
labeller</code>. Each labeller is passed to <code><a href="#topic+as_labeller">as_labeller</a>()</code>
and can be a lookup table, a function taking and returning
character vectors, or simply a labeller function.</p>
</td></tr>
<tr><td><code id="labeller_+3A_.rows">.rows</code>, <code id="labeller_+3A_.cols">.cols</code></td>
<td>
<p>Labeller for a whole margin (either the rows or
the columns). It is passed to <code><a href="#topic+as_labeller">as_labeller</a>()</code>. When a
margin-wide labeller is set, make sure you don't mention in
<code>...</code> any variable belonging to the margin.</p>
</td></tr>
<tr><td><code id="labeller_+3A_keep.as.numeric">keep.as.numeric</code></td>
<td>
<p>Deprecated. All supplied labellers and
on-labeller functions should be able to work with character
labels.</p>
</td></tr>
<tr><td><code id="labeller_+3A_.multi_line">.multi_line</code></td>
<td>
<p>Whether to display the labels of multiple
factors on separate lines. This is passed to the labeller
function.</p>
</td></tr>
<tr><td><code id="labeller_+3A_.default">.default</code></td>
<td>
<p>Default labeller for variables not specified. Also
used with lookup tables or non-labeller functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of functions, if the labeller has class <code>labeller</code>, it
is directly applied on the data frame of labels. Otherwise, it is
applied to the columns of the data frame of labels. The data frame
is then processed with the function specified in the
<code>.default</code> argument. This is intended to be used with
functions taking a character vector such as
<code><a href="Hmisc.html#topic+capitalize">capitalize</a></code>.
</p>


<h3>Value</h3>

<p>A labeller function to supply to <code><a href="#topic+facet_grid">facet_grid</a></code>
for the argument <code>labeller</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_labeller">as_labeller</a>()</code>, <a href="#topic+labellers">labellers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p1 &lt;- ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point()

# You can assign different labellers to variables:
p1 + facet_grid(vs + am ~ gear,
  labeller = labeller(vs = label_both, am = label_value))

# Or whole margins:
p1 + facet_grid(vs + am ~ gear,
  labeller = labeller(.rows = label_both, .cols = label_value))

# You can supply functions operating on strings:
capitalize &lt;- function(string) {
  substr(string, 1, 1) &lt;- toupper(substr(string, 1, 1))
  string
}
p2 &lt;- ggplot(msleep, aes(x = sleep_total, y = awake)) + geom_point()
p2 + facet_grid(vore ~ conservation, labeller = labeller(vore = capitalize))

# Or use character vectors as lookup tables:
conservation_status &lt;- c(
  cd = "Conservation Dependent",
  en = "Endangered",
  lc = "Least concern",
  nt = "Near Threatened",
  vu = "Vulnerable",
  domesticated = "Domesticated"
)
## Source: http://en.wikipedia.org/wiki/Wikipedia:Conservation_status

p2 + facet_grid(vore ~ conservation, labeller = labeller(
  .default = capitalize,
  conservation = conservation_status
))

# In the following example, we rename the levels to the long form,
# then apply a wrap labeller to the columns to prevent cropped text
msleep$conservation2 &lt;- plyr::revalue(msleep$conservation,
  conservation_status)

p2 %+% msleep + facet_grid(vore ~ conservation2)
p2 %+% msleep +
  facet_grid(vore ~ conservation2,
    labeller = labeller(conservation2 = label_wrap_gen(10))
  )

# labeller() is especially useful to act as a global labeller. You
# can set it up once and use it on a range of different plots with
# different facet specifications.

global_labeller &lt;- labeller(
  vore = capitalize,
  conservation = conservation_status,
  conservation2 = label_wrap_gen(10),
  .default = label_both
)

p2 + facet_grid(vore ~ conservation, labeller = global_labeller)
p2 + facet_wrap(~vore, labeller = global_labeller)
p2 %+% msleep + facet_wrap(~conservation2, labeller = global_labeller)

</code></pre>

<hr>
<h2 id='labellers'>Labeller functions</h2><span id='topic+labellers'></span><span id='topic+label_value'></span><span id='topic+label_both'></span><span id='topic+label_context'></span><span id='topic+label_parsed'></span><span id='topic+label_wrap_gen'></span>

<h3>Description</h3>

<p>Labeller functions are in charge of formatting the strip labels of
facet grids and wraps. Most of them accept a <code>multi_line</code>
argument to control whether multiple factors (defined in formulae
such as <code>~first + second</code>) should be displayed on a single
line separated with commas, or each on their own line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_value(labels, multi_line = TRUE)

label_both(labels, multi_line = TRUE, sep = ": ")

label_context(labels, multi_line = TRUE, sep = ": ")

label_parsed(labels, multi_line = TRUE)

label_wrap_gen(width = 25, multi_line = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labellers_+3A_labels">labels</code></td>
<td>
<p>Data frame of labels. Usually contains only one
element, but facetting over multiple factors entails multiple
label variables.</p>
</td></tr>
<tr><td><code id="labellers_+3A_multi_line">multi_line</code></td>
<td>
<p>Whether to display the labels of multiple factors
on separate lines.</p>
</td></tr>
<tr><td><code id="labellers_+3A_sep">sep</code></td>
<td>
<p>String separating variables and values.</p>
</td></tr>
<tr><td><code id="labellers_+3A_width">width</code></td>
<td>
<p>Maximum number of characters before wrapping the strip.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>label_value()</code> only displays the value of a factor while
<code>label_both()</code> displays both the variable name and the factor
value. <code>label_context()</code> is context-dependent and uses
<code>label_value()</code> for single factor facetting and
<code>label_both()</code> when multiple factors are
involved. <code>label_wrap_gen()</code> uses <code><a href="base.html#topic+strwrap">strwrap</a>()</code>
for line wrapping.
</p>
<p><code>label_parsed()</code> interprets the labels as plotmath
expressions. <code><a href="#topic+label_bquote">label_bquote</a>()</code> offers a more flexible
way of constructing plotmath expressions. See examples and
<code><a href="base.html#topic+bquote">bquote</a>()</code> for details on the syntax of the
argument.
</p>


<h3>Writing New Labeller Functions</h3>

<p>Note that an easy way to write a labeller function is to
transform a function operating on character vectors with
<code><a href="#topic+as_labeller">as_labeller</a>()</code>.
</p>
<p>A labeller function accepts a data frame of labels (character
vectors) containing one column for each factor. Multiple factors
occur with formula of the type <code>~first + second</code>.
</p>
<p>The return value must be a rectangular list where each 'row'
characterises a single facet. The list elements can be either
character vectors or lists of plotmath expressions. When multiple
elements are returned, they get displayed on their own new lines
(i.e., each facet gets a multi-line strip of labels).
</p>
<p>To illustrate, let's say your labeller returns a list of two
character vectors of length 3. This is a rectangular list because
all elements have the same length. The first facet will get the
first elements of each vector and display each of them on their
own line. Then the second facet gets the second elements of each
vector, and so on.
</p>
<p>If it's useful to your labeller, you can retrieve the <code>type</code>
attribute of the incoming data frame of labels. The value of this
attribute reflects the kind of strips your labeller is dealing
with: <code>"cols"</code> for columns and <code>"rows"</code> for rows. Note
that <code><a href="#topic+facet_wrap">facet_wrap</a>()</code> has columns by default and rows
when the strips are switched with the <code>switch</code> option. The
<code>facet</code> attribute also provides metadata on the labels. It
takes the values <code>"grid"</code> or <code>"wrap"</code>.
</p>
<p>For compatibility with <code><a href="#topic+labeller">labeller</a>()</code>, each labeller
function must have the <code>labeller</code> S3 class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+labeller">labeller</a>()</code>, <code><a href="#topic+as_labeller">as_labeller</a>()</code>,
<code><a href="#topic+label_bquote">label_bquote</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars$cyl2 &lt;- factor(mtcars$cyl, labels = c("alpha", "beta", "gamma"))
p &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point()

# Displaying only the values
p + facet_grid(. ~ cyl)
p + facet_grid(. ~ cyl, labeller = label_value)


# Displaying both the values and the variables
p + facet_grid(. ~ cyl, labeller = label_both)

# Displaying only the values or both the values and variables
# depending on whether multiple factors are facetted over
p + facet_grid(am ~ vs+cyl, labeller = label_context)

# Interpreting the labels as plotmath expressions
p + facet_grid(. ~ cyl2)
p + facet_grid(. ~ cyl2, labeller = label_parsed)
p + facet_wrap(~vs + cyl2, labeller = label_parsed)

</code></pre>

<hr>
<h2 id='labs'>Change axis labels, legend titles, plot title/subtitle and below-plot
caption.</h2><span id='topic+labs'></span><span id='topic+xlab'></span><span id='topic+ylab'></span><span id='topic+ggtitle'></span>

<h3>Description</h3>

<p>Change axis labels, legend titles, plot title/subtitle and below-plot
caption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labs(...)

xlab(label)

ylab(label)

ggtitle(label, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labs_+3A_...">...</code></td>
<td>
<p>a list of new names in the form aesthetic = &quot;new name&quot;</p>
</td></tr>
<tr><td><code id="labs_+3A_label">label</code></td>
<td>
<p>The text for the axis, plot title or caption below the plot.</p>
</td></tr>
<tr><td><code id="labs_+3A_subtitle">subtitle</code></td>
<td>
<p>the text for the subtitle for the plot which will be
displayed below the title. Leave <code>NULL</code> for no subtitle.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point()
p + labs(title = "New plot title")
p + labs(x = "New x label")
p + xlab("New x label")
p + ylab("New y label")
p + ggtitle("New plot title")

# Can add a subtitle to plots with either of the following
p + ggtitle("New plot title", subtitle = "A subtitle")
p + labs(title = "New plot title", subtitle = "A subtitle")

# Can add a plot caption underneath the whole plot (for sources, notes or
# copyright), similar to the \code{sub} parameter in base R, with the
# following
p + labs(caption = "(based on data from ...)")

# This should work independently of other functions that modify the
# the scale names
p + ylab("New y label") + ylim(2, 4)
p + ylim(2, 4) + ylab("New y label")

# The labs function also modifies legend labels
p &lt;- ggplot(mtcars, aes(mpg, wt, colour = cyl)) + geom_point()
p + labs(colour = "Cylinders")

# Can also pass in a list, if that is more convenient
p + labs(list(title = "Title", subtitle = "Subtitle", x = "X", y = "Y"))
</code></pre>

<hr>
<h2 id='last_plot'>Retrieve the last plot to be modified or created.</h2><span id='topic+last_plot'></span>

<h3>Description</h3>

<p>Retrieve the last plot to be modified or created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_plot()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+ggsave">ggsave</a></code>
</p>

<hr>
<h2 id='layer'>Create a new layer</h2><span id='topic+layer'></span>

<h3>Description</h3>

<p>A layer is a combination of data, stat and geom with a potential position
adjustment. Usually layers are created using <code>geom_*</code> or <code>stat_*</code>
calls but it can also be created directly using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer(
  geom = NULL,
  stat = NULL,
  data = NULL,
  mapping = NULL,
  position = NULL,
  params = list(),
  inherit.aes = TRUE,
  subset = NULL,
  show.legend = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="layer_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="layer_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="layer_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="layer_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="layer_+3A_params">params</code></td>
<td>
<p>Additional parameters to the <code>geom</code> and <code>stat</code>.</p>
</td></tr>
<tr><td><code id="layer_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="layer_+3A_subset">subset</code></td>
<td>
<p>DEPRECATED. An older way of subsetting the dataset used in a
layer.</p>
</td></tr>
<tr><td><code id="layer_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># geom calls are just a short cut for layer
ggplot(mpg, aes(displ, hwy)) + geom_point()
# shortcut for
ggplot(mpg, aes(displ, hwy)) +
  layer(geom = "point", stat = "identity", position = "identity",
    params = list(na.rm = FALSE)
  )

# use a function as data to plot a subset of global data
ggplot(mpg, aes(displ, hwy)) +
  layer(geom = "point", stat = "identity", position = "identity",
    data = head, params = list(na.rm = FALSE)
  )

</code></pre>

<hr>
<h2 id='limits'>Generate correct scale type for specified limits</h2><span id='topic+limits'></span>

<h3>Description</h3>

<p>Generate correct scale type for specified limits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limits(lims, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limits_+3A_var">var</code></td>
<td>
<p>name of variable</p>
</td></tr>
<tr><td><code id="limits_+3A_limits">limits</code></td>
<td>
<p>vector of limits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>animint2:::limits(c(1, 5), "x")
animint2:::limits(c(5, 1), "x")
animint2:::limits(c("A", "b", "c"), "x")
animint2:::limits(c("A", "b", "c"), "fill")
animint2:::limits(as.Date(c("2008-01-01", "2009-01-01")), "x")
</code></pre>

<hr>
<h2 id='lims'>Convenience functions to set the axis limits.</h2><span id='topic+lims'></span><span id='topic+xlim'></span><span id='topic+ylim'></span>

<h3>Description</h3>

<p>Observations not in this range will be dropped completely and
not passed to any other layers.  If a NA value is substituted for one of the
limits that limit is automatically calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lims(...)

xlim(...)

ylim(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lims_+3A_...">...</code></td>
<td>
<p>If numeric, will create a continuous scale, if factor or
character, will create a discrete scale.  For <code>lims</code>, every
argument must be named.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For changing x or y axis limits <strong>without</strong> dropping data
observations, see <code><a href="#topic+coord_cartesian">coord_cartesian</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># xlim
xlim(15, 20)
xlim(20, 15)
xlim(c(10, 20))
xlim("a", "b", "c")

ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  xlim(15, 20)
# with automatic lower limit
ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  xlim(NA, 20)

# Change both xlim and ylim
ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  lims(x = c(10, 20), y = c(3, 5))
</code></pre>

<hr>
<h2 id='luv_colours'><code>colors()</code> in Luv space.</h2><span id='topic+luv_colours'></span>

<h3>Description</h3>

<p>All built-in <code><a href="grDevices.html#topic+colors">colors</a>()</code> translated into Luv colour space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>luv_colours
</code></pre>


<h3>Format</h3>

<p>A data frame with 657 observations and 4 variables:
</p>

<dl>
<dt>L,u,v</dt><dd><p>Position in Luv colour space</p>
</dd>
<dt>col</dt><dd><p>Colour name</p>
</dd>
</dl>


<hr>
<h2 id='make_bar'>Convenience function for an interactive bar that might otherwise be
created using stat_summary(geom=&quot;bar&quot;).</h2><span id='topic+make_bar'></span>

<h3>Description</h3>

<p>Convenience function for an interactive bar that might otherwise be
created using stat_summary(geom=&quot;bar&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_bar(data, x.name, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_bar_+3A_data">data</code></td>
<td>
<p>data.frame to analyze for unique x.name values.</p>
</td></tr>
<tr><td><code id="make_bar_+3A_x.name">x.name</code></td>
<td>
<p>variable to be used for x, clickSelects.</p>
</td></tr>
<tr><td><code id="make_bar_+3A_alpha">alpha</code></td>
<td>
<p>transparency of selected bar, default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a geom_bar layer.
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>

<hr>
<h2 id='make_tallrect'>Make a clickSelects geom_tallrect that completely tiles the x
range. This makes it easy to construct tallrects for the common
case of selecting a particular x value.</h2><span id='topic+make_tallrect'></span>

<h3>Description</h3>

<p>Make a clickSelects geom_tallrect that completely tiles the x
range. This makes it easy to construct tallrects for the common
case of selecting a particular x value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tallrect(data, x.name, even = FALSE, alpha = 1/2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tallrect_+3A_data">data</code></td>
<td>
<p>data.frame to analyze for unique x.name values.</p>
</td></tr>
<tr><td><code id="make_tallrect_+3A_x.name">x.name</code></td>
<td>
<p>variable to be used for x, clickSelects.</p>
</td></tr>
<tr><td><code id="make_tallrect_+3A_even">even</code></td>
<td>
<p>Logical parameter, should tallrects be of even width?</p>
</td></tr>
<tr><td><code id="make_tallrect_+3A_alpha">alpha</code></td>
<td>
<p>transparency of a selected tallrect, default 1/2.</p>
</td></tr>
<tr><td><code id="make_tallrect_+3A_...">...</code></td>
<td>
<p>passed to geom_tallrect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a geom_tallrect layer.
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>

<hr>
<h2 id='make_tallrect_or_widerect'>Make a clickSelects geom_widerect or geom_tallrect that completely
tiles the x or y range. This function is used internally by
make_tallrect or make_widerect, which are more user-friendly.</h2><span id='topic+make_tallrect_or_widerect'></span>

<h3>Description</h3>

<p>Make a clickSelects geom_widerect or geom_tallrect that completely
tiles the x or y range. This function is used internally by
make_tallrect or make_widerect, which are more user-friendly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tallrect_or_widerect(
  aes.prefix,
  geom_xrect,
  data,
  var.name,
  even = FALSE,
  alpha = 0.5,
  ...,
  data.fun = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tallrect_or_widerect_+3A_aes.prefix">aes.prefix</code></td>
<td>
<p>&quot;x&quot; or &quot;y&quot;</p>
</td></tr>
<tr><td><code id="make_tallrect_or_widerect_+3A_geom_xrect">geom_xrect</code></td>
<td>
<p>geom_tallrect or geom_widerect</p>
</td></tr>
<tr><td><code id="make_tallrect_or_widerect_+3A_data">data</code></td>
<td>
<p>data.frame to analyze for unique var.name values.</p>
</td></tr>
<tr><td><code id="make_tallrect_or_widerect_+3A_var.name">var.name</code></td>
<td>
<p>variable to be used for clickSelects</p>
</td></tr>
<tr><td><code id="make_tallrect_or_widerect_+3A_even">even</code></td>
<td>
<p>Logical parameter, should xrects be of even width?</p>
</td></tr>
<tr><td><code id="make_tallrect_or_widerect_+3A_alpha">alpha</code></td>
<td>
<p>transparency of a selected xrect, default 1/2.</p>
</td></tr>
<tr><td><code id="make_tallrect_or_widerect_+3A_...">...</code></td>
<td>
<p>passed to geom_xrect</p>
</td></tr>
<tr><td><code id="make_tallrect_or_widerect_+3A_data.fun">data.fun</code></td>
<td>
<p>called on data passed to geom_xrect(aes(..),
data.fun(df)) this is useful in facetted plots, for adding
columns to the data.frame, if you want that geom in only one
panel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a geom_xrect layer
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>

<hr>
<h2 id='make_text'>Convenvience function for a showSelected plot label.</h2><span id='topic+make_text'></span>

<h3>Description</h3>

<p>Convenvience function for a showSelected plot label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_text(data, x, y, label.var, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_text_+3A_data">data</code></td>
<td>
<p>data.frame of relevant data</p>
</td></tr>
<tr><td><code id="make_text_+3A_x">x</code></td>
<td>
<p>x coordinate of label position</p>
</td></tr>
<tr><td><code id="make_text_+3A_y">y</code></td>
<td>
<p>y coordinate of label position</p>
</td></tr>
<tr><td><code id="make_text_+3A_label.var">label.var</code></td>
<td>
<p>variable matching showSelected, used to obtain label value</p>
</td></tr>
<tr><td><code id="make_text_+3A_format">format</code></td>
<td>
<p>String format for label. Use %d, %f, etc. to insert relevant label.var value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a geom_text layer.
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>

<hr>
<h2 id='make_widerect'>Make a clickSelects geom_widerect that completely tiles the y
range. This makes it easy to construct widerects for the common
case of selecting a particular y value.</h2><span id='topic+make_widerect'></span>

<h3>Description</h3>

<p>Make a clickSelects geom_widerect that completely tiles the y
range. This makes it easy to construct widerects for the common
case of selecting a particular y value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_widerect(data, y.name, even = FALSE, alpha = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_widerect_+3A_data">data</code></td>
<td>
<p>data.frame to analyze for unique y.name values.</p>
</td></tr>
<tr><td><code id="make_widerect_+3A_y.name">y.name</code></td>
<td>
<p>variable to be used for y, clickSelects.</p>
</td></tr>
<tr><td><code id="make_widerect_+3A_even">even</code></td>
<td>
<p>Logical parameter, should widerects be of even width?</p>
</td></tr>
<tr><td><code id="make_widerect_+3A_alpha">alpha</code></td>
<td>
<p>transparency of a selected widerect, default 1/2.</p>
</td></tr>
<tr><td><code id="make_widerect_+3A_...">...</code></td>
<td>
<p>passed to geom_widerect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a geom_widerect layer.
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>

<hr>
<h2 id='map_data'>Create a data frame of map data.</h2><span id='topic+map_data'></span>

<h3>Description</h3>

<p>Create a data frame of map data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_data(map, region = ".", exact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_data_+3A_map">map</code></td>
<td>
<p>name of map provided by the <span class="pkg">maps</span> package.  These
include <code><a href="maps.html#topic+county">county</a></code>, <code><a href="maps.html#topic+france">france</a></code>,
<code><a href="maps.html#topic+italy">italy</a></code>, <code><a href="maps.html#topic+nz">nz</a></code>,
<code><a href="maps.html#topic+state">state</a></code>, <code><a href="maps.html#topic+usa">usa</a></code>,
<code><a href="maps.html#topic+world">world</a></code>, <code><a href="maps.html#topic+world2">world2</a></code>.</p>
</td></tr>
<tr><td><code id="map_data_+3A_region">region</code></td>
<td>
<p>name of subregions to include.  Defaults to <code>.</code> which
includes all subregion.  See documentation for <code><a href="maps.html#topic+map">map</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="map_data_+3A_exact">exact</code></td>
<td>
<p>should the <code>region</code> be treated as a regular expression
(<code>FALSE</code>) or as a fixed string (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="map_data_+3A_...">...</code></td>
<td>
<p>all other arguments passed on to <code><a href="maps.html#topic+map">map</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("maps")) {
states &lt;- map_data("state")
arrests &lt;- USArrests
names(arrests) &lt;- tolower(names(arrests))
arrests$region &lt;- tolower(rownames(USArrests))

choro &lt;- merge(states, arrests, sort = FALSE, by = "region")
choro &lt;- choro[order(choro$order), ]
ggplot(choro, aes(long, lat)) +
  geom_polygon(aes(group = group, fill = assault)) +
  coord_map("albers",  at0 = 45.5, lat1 = 29.5)

ggplot(choro, aes(long, lat)) +
  geom_polygon(aes(group = group, fill = assault / murder)) +
  coord_map("albers",  at0 = 45.5, lat1 = 29.5)
}
</code></pre>

<hr>
<h2 id='margin'>Define margins.</h2><span id='topic+margin'></span>

<h3>Description</h3>

<p>This is a convenient function that creates a grid unit object of the
correct length to use for setting margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margin(t = 0, r = 0, b = 0, l = 0, unit = "pt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margin_+3A_t">t</code>, <code id="margin_+3A_r">r</code>, <code id="margin_+3A_b">b</code>, <code id="margin_+3A_l">l</code></td>
<td>
<p>Dimensions of each margin. (To remember order, think trouble).</p>
</td></tr>
<tr><td><code id="margin_+3A_unit">unit</code></td>
<td>
<p>Default units of dimensions. Defaults to &quot;pt&quot; so it
can be most easily scaled with the text.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>margin(4)
margin(4, 2)
margin(4, 3, 2, 1)
</code></pre>

<hr>
<h2 id='mean_se'>Calculate mean and standard errors on either side.</h2><span id='topic+mean_se'></span>

<h3>Description</h3>

<p>Calculate mean and standard errors on either side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_se(x, mult = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_se_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="mean_se_+3A_mult">mult</code></td>
<td>
<p>number of multiples of standard error</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>for use with <code><a href="#topic+stat_summary">stat_summary</a></code>
</p>

<hr>
<h2 id='merge_recurse'>Merge a list of data frames.</h2><span id='topic+merge_recurse'></span>

<h3>Description</h3>

<p>Merge a list of data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_recurse(dfs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_recurse_+3A_dfs">dfs</code></td>
<td>
<p>list of data frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>

<hr>
<h2 id='midwest'>Midwest demographics.</h2><span id='topic+midwest'></span>

<h3>Description</h3>

<p>Demographic information of midwest counties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midwest
</code></pre>


<h3>Format</h3>

<p>A data frame with 437 rows and 28 variables
</p>

<ul>
<li><p> PID
</p>
</li>
<li><p> county
</p>
</li>
<li><p> state
</p>
</li>
<li><p> area
</p>
</li>
<li><p> poptotal.  Total population
</p>
</li>
<li><p> popdensity. Population density
</p>
</li>
<li><p> popwhite.  Number of whites.
</p>
</li>
<li><p> popblack.  Number of blacks.
</p>
</li>
<li><p> popamerindian.  Number of American Indians.
</p>
</li>
<li><p> popasian.  Number of Asians.
</p>
</li>
<li><p> popother.  Number of other races.
</p>
</li>
<li><p> percwhite.  Percent white.
</p>
</li>
<li><p> percblack.  Percent black.
</p>
</li>
<li><p> percamerindan.  Percent American Indian.
</p>
</li>
<li><p> percasian. Percent Asian.
</p>
</li>
<li><p> percother. Percent other races.
</p>
</li>
<li><p> popadults.  Number of adults.
</p>
</li>
<li><p> perchsd.
</p>
</li>
<li><p> percollege.  Percent college educated.
</p>
</li>
<li><p> percprof.  Percent profession.
</p>
</li>
<li><p> poppovertyknown.
</p>
</li>
<li><p> percpovertyknown
</p>
</li>
<li><p> percbelowpoverty
</p>
</li>
<li><p> percchildbelowpovert
</p>
</li>
<li><p> percadultpoverty
</p>
</li>
<li><p> percelderlypoverty
</p>
</li>
<li><p> inmetro.  In a metro area.
</p>
</li>
<li><p> category'
</p>
</li></ul>


<hr>
<h2 id='mpg'>Fuel economy data from 1999 and 2008 for 38 popular models of car</h2><span id='topic+mpg'></span>

<h3>Description</h3>

<p>This dataset contains a subset of the fuel economy data that the EPA makes
available on <a href="https://fueleconomy.gov">https://fueleconomy.gov</a>. It contains only models which
had a new release every year between 1999 and 2008 - this was used as a
proxy for the popularity of the car.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpg
</code></pre>


<h3>Format</h3>

<p>A data frame with 234 rows and 11 variables
</p>

<ul>
<li><p> manufacturer.
</p>
</li>
<li><p> model.
</p>
</li>
<li><p> displ. engine displacement, in litres
</p>
</li>
<li><p> year.
</p>
</li>
<li><p> cyl. number of cylinders
</p>
</li>
<li><p> trans. type of transmission
</p>
</li>
<li><p> drv. f = front-wheel drive, r = rear wheel drive, 4 = 4wd
</p>
</li>
<li><p> cty. city miles per gallon
</p>
</li>
<li><p> hwy. highway miles per gallon
</p>
</li>
<li><p> fl.
</p>
</li>
<li><p> class.
</p>
</li></ul>


<hr>
<h2 id='msleep'>An updated and expanded version of the mammals sleep dataset.</h2><span id='topic+msleep'></span>

<h3>Description</h3>

<p>This is an updated and expanded version of the mammals sleep dataset.
Updated sleep times and weights were taken from V. M. Savage and G. B.
West. A quantitative, theoretical framework for understanding mammalian
sleep. Proceedings of the National Academy of Sciences, 104 (3):1051-1056,
2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msleep
</code></pre>


<h3>Format</h3>

<p>A data frame with 83 rows and 11 variables
</p>

<ul>
<li><p> name. common name
</p>
</li>
<li><p> genus.
</p>
</li>
<li><p> vore. carnivore, omnivore or herbivore?
</p>
</li>
<li><p> order.
</p>
</li>
<li><p> conservation. the conservation status of the animal
</p>
</li>
<li><p> sleep_total. total amount of sleep, in hours
</p>
</li>
<li><p> sleep_rem. rem sleep, in hours
</p>
</li>
<li><p> sleep_cycle. length of sleep cycle, in hours
</p>
</li>
<li><p> awake. amount of time spent awake, in hours
</p>
</li>
<li><p> brainwt. brain weight in kilograms
</p>
</li>
<li><p> bodywt. body weight in kilograms
</p>
</li></ul>



<h3>Details</h3>

<p>Additional variables order, conservation status and vore were added from
wikipedia.
</p>

<hr>
<h2 id='newEnvironment'>Environment to store meta data</h2><span id='topic+newEnvironment'></span>

<h3>Description</h3>

<p>Get a new environment to store meta-data. Used to alter state in the
lower-level functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newEnvironment()
</code></pre>


<h3>Value</h3>

<p>A new environment to store meta data
</p>

<hr>
<h2 id='parsePlot'>Convert a ggplot to a list.</h2><span id='topic+parsePlot'></span>

<h3>Description</h3>

<p>Convert a ggplot to a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parsePlot(meta, plot, plot.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parsePlot_+3A_meta">meta</code></td>
<td>
<p>environment with previously calculated plot data, and a new plot to parse, already stored in plot and plot.name.</p>
</td></tr>
<tr><td><code id="parsePlot_+3A_plot">plot</code></td>
<td>
<p>ggplot list object</p>
</td></tr>
<tr><td><code id="parsePlot_+3A_plot.name">plot.name</code></td>
<td>
<p>name of plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, info is stored in meta.
</p>

<hr>
<h2 id='position_dodge'>Adjust position by dodging overlaps to the side.</h2><span id='topic+position_dodge'></span>

<h3>Description</h3>

<p>Adjust position by dodging overlaps to the side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_dodge(width = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_dodge_+3A_width">width</code></td>
<td>
<p>Dodging width, when different to the width of the individual
elements. This is useful when you want to align narrow geoms with wider
geoms. See the examples for a use case.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_fill">position_fill</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
  geom_bar(position = "dodge")

ggplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(position="dodge")

# To dodge items with different widths, you need to be explicit
df &lt;- data.frame(x = c("a","a","b","b"), y = 2:5, g = rep(1:2, 2))
p &lt;- ggplot(df, aes(x, y, group = g)) +
  geom_bar(
    stat = "identity", position = "dodge",
    fill = "grey50", colour = "black"
  )
p

# A line range has no width:
p + geom_linerange(aes(ymin = y-1, ymax = y+1), position = "dodge")
# You need to explicitly specify the width for dodging
p + geom_linerange(aes(ymin = y-1, ymax = y+1),
  position = position_dodge(width = 0.9))

# Similarly with error bars:
p + geom_errorbar(aes(ymin = y-1, ymax = y+1), width = 0.2,
  position = "dodge")
p + geom_errorbar(aes(ymin = y-1, ymax = y+1, width = 0.2),
  position = position_dodge(width = 0.90))

</code></pre>

<hr>
<h2 id='position_fill'>Stack overlapping objects on top of one another.</h2><span id='topic+position_fill'></span><span id='topic+position_stack'></span>

<h3>Description</h3>

<p><code>position_fill</code> additionally standardises each stack to have unit
height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_fill()

position_stack()
</code></pre>


<h3>See Also</h3>

<p>See <code><a href="#topic+geom_bar">geom_bar</a></code> and <code><a href="#topic+geom_area">geom_area</a></code> for
more examples.
</p>
<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stacking is the default behaviour for most area plots:
ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) + geom_bar()
# Fill makes it easier to compare proportions
ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) +
  geom_bar(position = "fill")

# To change stacking order, use factor() to change order of levels
mtcars$vs &lt;- factor(mtcars$vs, levels = c(1,0))
ggplot(mtcars, aes(factor(cyl), fill = factor(vs))) + geom_bar()

ggplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(binwidth = 500)
# When used with a histogram, position_fill creates a conditional density
# estimate
ggplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(binwidth = 500, position = "fill")

# Stacking is also useful for time series
data.set &lt;- data.frame(
  Time = c(rep(1, 4),rep(2, 4), rep(3, 4), rep(4, 4)),
  Type = rep(c('a', 'b', 'c', 'd'), 4),
  Value = rpois(16, 10)
)

ggplot(data.set, aes(Time, Value)) + geom_area(aes(fill = Type))

# If you want to stack lines, you need to say so:
ggplot(data.set, aes(Time, Value)) + geom_line(aes(colour = Type))
ggplot(data.set, aes(Time, Value)) +
  geom_line(position = "stack", aes(colour = Type))

# But realise that this makes it *much* harder to compare individual
# trends
</code></pre>

<hr>
<h2 id='position_identity'>Don't adjust position</h2><span id='topic+position_identity'></span>

<h3>Description</h3>

<p>Don't adjust position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_identity()
</code></pre>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_fill">position_fill</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>
</p>

<hr>
<h2 id='position_jitter'>Jitter points to avoid overplotting.</h2><span id='topic+position_jitter'></span>

<h3>Description</h3>

<p>Jitter points to avoid overplotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_jitter(width = NULL, height = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_jitter_+3A_width">width</code>, <code id="position_jitter_+3A_height">height</code></td>
<td>
<p>Amount of vertical and horizontal jitter. The jitter
is added in both positive and negative directions, so the total spread
is twice the value specified here.
</p>
<p>If omitted, defaults to 40% of the resolution of the data: this means the
jitter values will occupy 80% of the implied bins. Categorical data
is aligned on the integers, so a width or height of 0.5 will spread the
data so it's not possible to see the distinction between the categories.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_fill">position_fill</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(am, vs)) + geom_point()

# Default amount of jittering will generally be too much for
# small datasets:
ggplot(mtcars, aes(am, vs)) + geom_jitter()

# Two ways to override
ggplot(mtcars, aes(am, vs)) +
  geom_jitter(width = 0.1, height = 0.1)
ggplot(mtcars, aes(am, vs)) +
  geom_jitter(position = position_jitter(width = 0.1, height = 0.1))
</code></pre>

<hr>
<h2 id='position_jitterdodge'>Adjust position by simultaneously dodging and jittering</h2><span id='topic+position_jitterdodge'></span>

<h3>Description</h3>

<p>Adjust position by simultaneously dodging and jittering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_jitterdodge(
  jitter.width = NULL,
  jitter.height = 0,
  dodge.width = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_jitterdodge_+3A_jitter.width">jitter.width</code></td>
<td>
<p>degree of jitter in x direction. Defaults to 40% of the
resolution of the data.</p>
</td></tr>
<tr><td><code id="position_jitterdodge_+3A_jitter.height">jitter.height</code></td>
<td>
<p>degree of jitter in y direction. Defaults to 0.</p>
</td></tr>
<tr><td><code id="position_jitterdodge_+3A_dodge.width">dodge.width</code></td>
<td>
<p>the amount to dodge in the x direction. Defaults to 0.75,
the default <code>position_dodge()</code> width.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_fill">position_fill</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>,
<code><a href="#topic+position_nudge">position_nudge</a>()</code>
</p>

<hr>
<h2 id='position_nudge'>Nudge points.</h2><span id='topic+position_nudge'></span>

<h3>Description</h3>

<p>This is useful if you want to nudge labels a little ways from their
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_nudge(x = 0, y = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_nudge_+3A_x">x</code>, <code id="position_nudge_+3A_y">y</code></td>
<td>
<p>Amount of vertical and horizontal distance to move.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other position adjustments: 
<code><a href="#topic+position_dodge">position_dodge</a>()</code>,
<code><a href="#topic+position_fill">position_fill</a>()</code>,
<code><a href="#topic+position_identity">position_identity</a>()</code>,
<code><a href="#topic+position_jitterdodge">position_jitterdodge</a>()</code>,
<code><a href="#topic+position_jitter">position_jitter</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = c(1,3,2,5),
  y = c("a","c","d","c")
)

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text(aes(label = y))

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_text(aes(label = y), position = position_nudge(y = -0.1))
</code></pre>

<hr>
<h2 id='presidential'>Terms of 11 presidents from Eisenhower to Obama.</h2><span id='topic+presidential'></span>

<h3>Description</h3>

<p>The names of each president, the start and end date of their term, and
their party of 11 US presidents from Eisenhower to Obama.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presidential
</code></pre>


<h3>Format</h3>

<p>A data frame with 11 rows and 4 variables
</p>

<hr>
<h2 id='print.animint'>print animint</h2><span id='topic+print.animint'></span>

<h3>Description</h3>

<p>Print animint by rendering to local directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'animint'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.animint_+3A_x">x</code></td>
<td>
<p>List of ggplots and options. In particular the out.dir
option is passed along to animint2dir.</p>
</td></tr>
<tr><td><code id="print.animint_+3A_...">...</code></td>
<td>
<p>passed to animint2dir</p>
</td></tr>
</table>


<h3>Value</h3>

<p>same as animint2dir
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>

<hr>
<h2 id='print.gganimintplot'>Draw plot on current graphics device.</h2><span id='topic+print.gganimintplot'></span><span id='topic+plot.gganimintplot'></span>

<h3>Description</h3>

<p>Draw plot on current graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gganimintplot'
print(x, newpage = is.null(vp), vp = NULL, ...)

## S3 method for class 'gganimintplot'
plot(x, newpage = is.null(vp), vp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gganimintplot_+3A_x">x</code></td>
<td>
<p>plot to display</p>
</td></tr>
<tr><td><code id="print.gganimintplot_+3A_newpage">newpage</code></td>
<td>
<p>draw new (empty) page first?</p>
</td></tr>
<tr><td><code id="print.gganimintplot_+3A_vp">vp</code></td>
<td>
<p>viewport to draw plot in</p>
</td></tr>
<tr><td><code id="print.gganimintplot_+3A_...">...</code></td>
<td>
<p>other arguments not used by this method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the result of <code><a href="#topic+ggplot_build">ggplot_build</a></code>, which
is a list with components that contain the plot itself, the data,
information about the scales, panels etc.
</p>

<hr>
<h2 id='print.gganimintproto'>Print a gganimintproto object</h2><span id='topic+print.gganimintproto'></span>

<h3>Description</h3>

<p>If a gganimintproto object has a <code>$print</code> method, this will call that method.
Otherwise, it will print out the members of the object, and optionally, the
members of the inherited objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gganimintproto'
print(x, ..., flat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gganimintproto_+3A_x">x</code></td>
<td>
<p>A gganimintproto object to print.</p>
</td></tr>
<tr><td><code id="print.gganimintproto_+3A_...">...</code></td>
<td>
<p>If the gganimintproto object has a <code>print</code> method, further arguments
will be passed to it. Otherwise, these arguments are unused.</p>
</td></tr>
<tr><td><code id="print.gganimintproto_+3A_flat">flat</code></td>
<td>
<p>If <code>TRUE</code> (the default), show a flattened list of all local
and inherited members. If <code>FALSE</code>, show the inheritance hierarchy.</p>
</td></tr>
</table>

<hr>
<h2 id='pt.to.lines'>Convert <code>pt</code> value to <code>lines</code></h2><span id='topic+pt.to.lines'></span>

<h3>Description</h3>

<p>Convert <code>pt</code> value to <code>lines</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pt.to.lines(pt_value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pt.to.lines_+3A_pt_value">pt_value</code></td>
<td>
<p>Value in <code>pt</code> to be converted to <code>lines</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value in <code>lines</code>
</p>


<h3>Note</h3>

<p>Does NOT work if input is not in <code>pt</code>. Input is returned as is.
</p>

<hr>
<h2 id='qplot'>Quick plot</h2><span id='topic+qplot'></span><span id='topic+quickplot'></span>

<h3>Description</h3>

<p><code>qplot</code> is the basic plotting function in the ggplot2 package,
designed to be familiar if you're used to base <code><a href="graphics.html#topic+plot">plot</a>()</code>.
It's a convenient wrapper for creating a number of different types of plots
using a consistent calling scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qplot(
  x,
  y = NULL,
  ...,
  data,
  facets = NULL,
  margins = FALSE,
  geom = "auto",
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  log = "",
  main = NULL,
  xlab = deparse(substitute(x)),
  ylab = deparse(substitute(y)),
  asp = NA,
  stat = NULL,
  position = NULL
)

quickplot(
  x,
  y = NULL,
  ...,
  data,
  facets = NULL,
  margins = FALSE,
  geom = "auto",
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  log = "",
  main = NULL,
  xlab = deparse(substitute(x)),
  ylab = deparse(substitute(y)),
  asp = NA,
  stat = NULL,
  position = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qplot_+3A_x">x</code>, <code id="qplot_+3A_y">y</code>, <code id="qplot_+3A_...">...</code></td>
<td>
<p>Aesthetics passed into each layer</p>
</td></tr>
<tr><td><code id="qplot_+3A_data">data</code></td>
<td>
<p>Data frame to use (optional).  If not specified, will create
one, extracting vectors from the current environment.</p>
</td></tr>
<tr><td><code id="qplot_+3A_facets">facets</code></td>
<td>
<p>faceting formula to use. Picks <code><a href="#topic+facet_wrap">facet_wrap</a></code> or
<code><a href="#topic+facet_grid">facet_grid</a></code> depending on whether the formula is one-
or two-sided</p>
</td></tr>
<tr><td><code id="qplot_+3A_margins">margins</code></td>
<td>
<p>See <code>facet_grid</code>: display marginal facets?</p>
</td></tr>
<tr><td><code id="qplot_+3A_geom">geom</code></td>
<td>
<p>Character vector specifying geom(s) to draw. Defaults to
&quot;point&quot; if x and y are specified, and &quot;histogram&quot; if only x is specified.</p>
</td></tr>
<tr><td><code id="qplot_+3A_xlim">xlim</code>, <code id="qplot_+3A_ylim">ylim</code></td>
<td>
<p>X and y axis limits</p>
</td></tr>
<tr><td><code id="qplot_+3A_log">log</code></td>
<td>
<p>Which variables to log transform (&quot;x&quot;, &quot;y&quot;, or &quot;xy&quot;)</p>
</td></tr>
<tr><td><code id="qplot_+3A_main">main</code>, <code id="qplot_+3A_xlab">xlab</code>, <code id="qplot_+3A_ylab">ylab</code></td>
<td>
<p>Character vector (or expression) giving plot title,
x axis label, and y axis label respectively.</p>
</td></tr>
<tr><td><code id="qplot_+3A_asp">asp</code></td>
<td>
<p>The y/x aspect ratio</p>
</td></tr>
<tr><td><code id="qplot_+3A_stat">stat</code>, <code id="qplot_+3A_position">position</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use data from data.frame
qplot(mpg, wt, data = mtcars)
qplot(mpg, wt, data = mtcars, colour = cyl)
qplot(mpg, wt, data = mtcars, size = cyl)
qplot(mpg, wt, data = mtcars, facets = vs ~ am)


qplot(1:10, rnorm(10), colour = runif(10))
qplot(1:10, letters[1:10])
mod &lt;- lm(mpg ~ wt, data = mtcars)
qplot(resid(mod), fitted(mod))

f &lt;- function() {
   a &lt;- 1:10
   b &lt;- a ^ 2
   qplot(a, b)
}
f()

# To set aesthetics, wrap in I()
qplot(mpg, wt, data = mtcars, colour = I("red"))

# qplot will attempt to guess what geom you want depending on the input
# both x and y supplied = scatterplot
qplot(mpg, wt, data = mtcars)
# just x supplied = histogram
qplot(mpg, data = mtcars)
# just y supplied = scatterplot, with x = seq_along(y)
qplot(y = mpg, data = mtcars)

# Use different geoms
qplot(mpg, wt, data = mtcars, geom = "path")
qplot(mpg, data = mtcars, geom = "dotplot")

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+alpha'></span><span id='topic+unit'></span><span id='topic+arrow'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>grid</dt><dd><p><code><a href="grid.html#topic+arrow">arrow</a></code>, <code><a href="grid.html#topic+unit">unit</a></code></p>
</dd>
<dt>scales</dt><dd><p><code><a href="scales.html#topic+alpha">alpha</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(displ, hwy)) +
  geom_point(alpha = 0.5, colour = "blue")

ggplot(mpg, aes(displ, hwy)) +
  geom_point(colour = alpha("blue", 0.5))
</code></pre>

<hr>
<h2 id='rel'>Relative sizing for theme elements</h2><span id='topic+rel'></span>

<h3>Description</h3>

<p>Relative sizing for theme elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel_+3A_x">x</code></td>
<td>
<p>A number representing the relative size</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = 1:3, y = 1:3)
ggplot(df, aes(x, y)) +
  geom_point() +
  theme(axis.title.x = element_text(size = rel(2.5)))
</code></pre>

<hr>
<h2 id='remove_missing'>Convenience function to remove missing values from a data.frame</h2><span id='topic+remove_missing'></span>

<h3>Description</h3>

<p>Remove all non-complete rows, with a warning if <code>na.rm = FALSE</code>.
ggplot is somewhat more accommodating of missing values than R generally.
For those stats which require complete data, missing values will be
automatically removed with a warning. If <code>na.rm = TRUE</code> is supplied
to the statistic, the warning will be suppressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_missing(df, na.rm = FALSE, vars = names(df), name = "", finite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_missing_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="remove_missing_+3A_na.rm">na.rm</code></td>
<td>
<p>If true, will suppress warning message.</p>
</td></tr>
<tr><td><code id="remove_missing_+3A_vars">vars</code></td>
<td>
<p>Character vector of variables to check for missings in</p>
</td></tr>
<tr><td><code id="remove_missing_+3A_name">name</code></td>
<td>
<p>Optional function name to improve error message.</p>
</td></tr>
<tr><td><code id="remove_missing_+3A_finite">finite</code></td>
<td>
<p>If <code>TRUE</code>, will also remove non-finite values.</p>
</td></tr>
</table>

<hr>
<h2 id='renderAnimint'>Create an animint output element</h2><span id='topic+renderAnimint'></span>

<h3>Description</h3>

<p>Shiny server output function customized for animint plots 
(similar to <code>shiny::plotOutput</code> and friends).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renderAnimint(expr, env = parent.frame(), quoted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renderAnimint_+3A_expr">expr</code></td>
<td>
<p>An expression that creates a list of ggplot objects.</p>
</td></tr>
<tr><td><code id="renderAnimint_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>.</p>
</td></tr>
<tr><td><code id="renderAnimint_+3A_quoted">quoted</code></td>
<td>
<p>Is expr a quoted expression (with <code>quote()</code>)? 
This is useful if you want to save an expression in a variable.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>http://shiny.rstudio.com/articles/building-outputs.html
</p>

<hr>
<h2 id='resolution'>Compute the &quot;resolution&quot; of a data vector.</h2><span id='topic+resolution'></span>

<h3>Description</h3>

<p>The resolution is is the smallest non-zero distance between adjacent
values.  If there is only one unique value, then the resolution is defined
to be one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolution(x, zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolution_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="resolution_+3A_zero">zero</code></td>
<td>
<p>should a zero value be automatically included in the
computation of resolution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If x is an integer vector, then it is assumed to represent a discrete
variable, and the resolution is 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resolution(1:10)
resolution((1:10) - 0.5)
resolution((1:10) - 0.5, FALSE)
resolution(c(1,2, 10, 20, 50))
resolution(as.integer(c(1, 10, 20, 50)))  # Returns 1
</code></pre>

<hr>
<h2 id='saveChunks'>Split data set into chunks and save them to separate files.</h2><span id='topic+saveChunks'></span>

<h3>Description</h3>

<p>Split data set into chunks and save them to separate files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveChunks(x, meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveChunks_+3A_x">x</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="saveChunks_+3A_meta">meta</code></td>
<td>
<p>environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recursive list of chunk file names.
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>

<hr>
<h2 id='scale_alpha'>Alpha scales.</h2><span id='topic+scale_alpha'></span><span id='topic+scale_alpha_continuous'></span><span id='topic+scale_alpha_discrete'></span>

<h3>Description</h3>

<p><code>scale_alpha</code> is an alias for <code>scale_alpha_continuous</code> since
that is the most common use of alpha, and it saves a bit of typing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_alpha(..., range = c(0.1, 1))

scale_alpha_continuous(..., range = c(0.1, 1))

scale_alpha_discrete(..., range = c(0.1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_alpha_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+continuous_scale">continuous_scale</a></code>
or <code><a href="#topic+discrete_scale">discrete_scale</a></code> as appropriate, to control name, limits,
breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_alpha_+3A_range">range</code></td>
<td>
<p>range of output alpha values.  Should lie between 0 and 1.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>(p &lt;- ggplot(mtcars, aes(mpg, cyl)) +
  geom_point(aes(alpha = cyl)))
p + scale_alpha("cylinders")
p + scale_alpha("number\nof\ncylinders")

p + scale_alpha(range = c(0.4, 0.8))

(p &lt;- ggplot(mtcars, aes(mpg, cyl)) +
  geom_point(aes(alpha = factor(cyl))))
p + scale_alpha_discrete(range = c(0.4, 0.8))
</code></pre>

<hr>
<h2 id='scale_colour_brewer'>Sequential, diverging and qualitative colour scales from colorbrewer.org</h2><span id='topic+scale_colour_brewer'></span><span id='topic+scale_fill_brewer'></span><span id='topic+scale_colour_distiller'></span><span id='topic+scale_fill_distiller'></span><span id='topic+scale_color_brewer'></span><span id='topic+scale_color_distiller'></span>

<h3>Description</h3>

<p>ColorBrewer provides sequential, diverging and qualitative colour schemes
which are particularly suited and tested to display discrete values (levels
of a factor) on a map. ggplot2 can use those colours in discrete scales. It
also allows to smoothly interpolate 6 colours from any palette to a
continuous scale (6 colours per palette gives nice gradients; more results in
more saturated colours which do not look as good). However, the original
colour schemes (particularly the qualitative ones) were not intended for this
and the perceptual result is left to the appreciation of the user.
See <a href="https://colorbrewer2.org">https://colorbrewer2.org</a> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_brewer(..., type = "seq", palette = 1, direction = 1)

scale_fill_brewer(..., type = "seq", palette = 1, direction = 1)

scale_colour_distiller(
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)

scale_fill_distiller(
  ...,
  type = "seq",
  palette = 1,
  direction = -1,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_brewer_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
to control name, limits, breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_type">type</code></td>
<td>
<p>One of &quot;seq&quot; (sequential), &quot;div&quot; (diverging) or &quot;qual&quot;
(qualitative)</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_palette">palette</code></td>
<td>
<p>If a string, will use that named palette. If a number, will
index into the list of palettes of appropriate <code>type</code></p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colours in the scale. If 1, the default,
colours are as output by <code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer::brewer.pal()</a></code>. If -1, the
order of colours is reversed.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_colour_brewer_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
</table>


<h3>Palettes</h3>

<p>The following palettes are available for use with these scales:
</p>

<dl>
<dt>Diverging</dt><dd><p>BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral</p>
</dd>
<dt>Qualitative</dt><dd><p>Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3</p>
</dd>
<dt>Sequential</dt><dd><p>Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges,
OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other colour scales:
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a></code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a></code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsamp &lt;- diamonds[sample(nrow(diamonds), 1000), ]
(d &lt;- ggplot(dsamp, aes(carat, price)) +
  geom_point(aes(colour = clarity)))

# Change scale label
d + scale_colour_brewer()
d + scale_colour_brewer("Diamond\nclarity")

# Select brewer palette to use, see ?scales::brewer_pal for more details
d + scale_colour_brewer(palette = "Greens")
d + scale_colour_brewer(palette = "Set1")


# scale_fill_brewer works just the same as
# scale_colour_brewer but for fill colours
p &lt;- ggplot(diamonds, aes(x = price, fill = cut)) +
  geom_histogram(position = "dodge", binwidth = 1000)
p + scale_fill_brewer()
# the order of colour can be reversed
p + scale_fill_brewer(direction = -1)
# the brewer scales look better on a darker background
p + scale_fill_brewer(direction = -1) + theme_dark()


# Use distiller variant with continous data
v &lt;- ggplot(faithfuld) +
  geom_tile(aes(waiting, eruptions, fill = density))
v
v + scale_fill_distiller()
v + scale_fill_distiller(palette = "Spectral")
</code></pre>

<hr>
<h2 id='scale_colour_gradient'>Smooth gradient between two colours</h2><span id='topic+scale_colour_gradient'></span><span id='topic+scale_fill_gradient'></span><span id='topic+scale_colour_gradient2'></span><span id='topic+scale_fill_gradient2'></span><span id='topic+scale_colour_gradientn'></span><span id='topic+scale_fill_gradientn'></span><span id='topic+scale_colour_continuous'></span><span id='topic+scale_colour_datetime'></span><span id='topic+scale_colour_date'></span><span id='topic+scale_fill_continuous'></span><span id='topic+scale_fill_datetime'></span><span id='topic+scale_fill_date'></span><span id='topic+scale_color_continuous'></span><span id='topic+scale_color_gradient'></span><span id='topic+scale_color_gradient2'></span><span id='topic+scale_color_gradientn'></span>

<h3>Description</h3>

<p><code>scale_*_gradient</code> creates a two colour gradient (low-high),
<code>scale_*_gradient2</code> creates a diverging colour gradient (low-mid-high),
<code>scale_*_gradientn</code> creats a n-colour gradient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_gradient(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)

scale_fill_gradient(
  ...,
  low = "#132B43",
  high = "#56B1F7",
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)

scale_colour_gradient2(
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)

scale_fill_gradient2(
  ...,
  low = muted("red"),
  mid = "white",
  high = muted("blue"),
  midpoint = 0,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar"
)

scale_colour_gradientn(
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  colors
)

scale_fill_gradientn(
  ...,
  colours,
  values = NULL,
  space = "Lab",
  na.value = "grey50",
  guide = "colourbar",
  colors
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_gradient_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
to control name, limits, breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_low">low</code>, <code id="scale_colour_gradient_+3A_high">high</code></td>
<td>
<p>Colours for low and high ends of the gradient.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_space">space</code></td>
<td>
<p>colour space in which to calculate gradient. Must be &quot;Lab&quot; -
other values are deprecated.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_guide">guide</code></td>
<td>
<p>Type of legend. Use <code>"colourbar"</code> for continuous
colour bar, or <code>"legend"</code> for discrete colour legend.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_mid">mid</code></td>
<td>
<p>colour for mid point</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_midpoint">midpoint</code></td>
<td>
<p>The midpoint (in data value) of the diverging scale.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_colours">colours</code>, <code id="scale_colour_gradient_+3A_colors">colors</code></td>
<td>
<p>Vector of colours to use for n-colour gradient.</p>
</td></tr>
<tr><td><code id="scale_colour_gradient_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default colours are generated with <span class="pkg">munsell</span> and
<code>mnsl(c("2.5PB 2/4", "2.5PB 7/10")</code>. Generally, for continuous
colour scales you want to keep hue constant, but vary chroma and
luminance. The <span class="pkg">munsell</span> package makes this easy to do using the
Munsell colour system.
</p>


<h3>See Also</h3>

<p><code><a href="scales.html#topic+seq_gradient_pal">seq_gradient_pal</a></code> for details on underlying
palette
</p>
<p>Other colour scales:
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a></code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a></code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = runif(100),
  y = runif(100),
  z1 = rnorm(100),
  z2 = abs(rnorm(100))
)

# Default colour scale colours from light blue to dark blue
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z2))

# For diverging colour scales use gradient2
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z1)) +
  scale_colour_gradient2()

# Use your own colour scale with gradientn
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z1)) +
  scale_colour_gradientn(colours = terrain.colors(10))

# Equivalent fill scales do the same job for the fill aesthetic
ggplot(faithfuld, aes(waiting, eruptions)) +
  geom_raster(aes(fill = density)) +
  scale_fill_gradientn(colours = terrain.colors(10))

# Adjust colour choices with low and high
ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z2)) +
  scale_colour_gradient(low = "white", high = "black")
# Avoid red-green colour contrasts because ~10% of men have difficulty
# seeing them
</code></pre>

<hr>
<h2 id='scale_colour_grey'>Sequential grey colour scale.</h2><span id='topic+scale_colour_grey'></span><span id='topic+scale_fill_grey'></span><span id='topic+scale_color_grey'></span>

<h3>Description</h3>

<p>Based on <code><a href="grDevices.html#topic+gray.colors">gray.colors</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_grey(..., start = 0.2, end = 0.8, na.value = "red")

scale_fill_grey(..., start = 0.2, end = 0.8, na.value = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_grey_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
to control name, limits, breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_colour_grey_+3A_start">start</code></td>
<td>
<p>grey value at low end of palette</p>
</td></tr>
<tr><td><code id="scale_colour_grey_+3A_end">end</code></td>
<td>
<p>grey value at high end of palette</p>
</td></tr>
<tr><td><code id="scale_colour_grey_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other colour scales:
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a></code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a></code>,
<code><a href="#topic+scale_colour_hue">scale_colour_hue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point(aes(colour = factor(cyl)))
p + scale_colour_grey()
p + scale_colour_grey(end = 0)

# You may want to turn off the pale grey background with this scale
p + scale_colour_grey() + theme_bw()

# Colour of missing values is controlled with na.value:
miss &lt;- factor(sample(c(NA, 1:5), nrow(mtcars), replace = TRUE))
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = miss)) +
  scale_colour_grey()
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = miss)) +
  scale_colour_grey(na.value = "green")
</code></pre>

<hr>
<h2 id='scale_colour_hue'>Qualitative colour scale with evenly spaced hues.</h2><span id='topic+scale_colour_hue'></span><span id='topic+scale_fill_hue'></span><span id='topic+scale_colour_discrete'></span><span id='topic+scale_fill_discrete'></span><span id='topic+scale_color_discrete'></span><span id='topic+scale_color_hue'></span>

<h3>Description</h3>

<p>Qualitative colour scale with evenly spaced hues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_hue(
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50"
)

scale_fill_hue(
  ...,
  h = c(0, 360) + 15,
  c = 100,
  l = 65,
  h.start = 0,
  direction = 1,
  na.value = "grey50"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_hue_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code>
to control name, limits, breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_h">h</code></td>
<td>
<p>range of hues to use, in [0, 360]</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_c">c</code></td>
<td>
<p>chroma (intensity of colour), maximum value varies depending on
combination of hue and luminance.</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_l">l</code></td>
<td>
<p>luminance (lightness), in [0, 100]</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_h.start">h.start</code></td>
<td>
<p>hue to start at</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_direction">direction</code></td>
<td>
<p>direction to travel around the colour wheel,
1 = clockwise, -1 = counter-clockwise</p>
</td></tr>
<tr><td><code id="scale_colour_hue_+3A_na.value">na.value</code></td>
<td>
<p>Colour to use for missing values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other colour scales:
<code><a href="#topic+scale_colour_brewer">scale_colour_brewer</a></code>,
<code><a href="#topic+scale_colour_gradient">scale_colour_gradient</a></code>,
<code><a href="#topic+scale_colour_grey">scale_colour_grey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dsamp &lt;- diamonds[sample(nrow(diamonds), 1000), ]
(d &lt;- ggplot(dsamp, aes(carat, price)) + geom_point(aes(colour = clarity)))

# Change scale label
d + scale_colour_hue()
d + scale_colour_hue("clarity")
d + scale_colour_hue(expression(clarity[beta]))

# Adjust luminosity and chroma
d + scale_colour_hue(l = 40, c = 30)
d + scale_colour_hue(l = 70, c = 30)
d + scale_colour_hue(l = 70, c = 150)
d + scale_colour_hue(l = 80, c = 150)

# Change range of hues used
d + scale_colour_hue(h = c(0, 90))
d + scale_colour_hue(h = c(90, 180))
d + scale_colour_hue(h = c(180, 270))
d + scale_colour_hue(h = c(270, 360))

# Vary opacity
# (only works with pdf, quartz and cairo devices)
d &lt;- ggplot(dsamp, aes(carat, price, colour = clarity))
d + geom_point(alpha = 0.9)
d + geom_point(alpha = 0.5)
d + geom_point(alpha = 0.2)

# Colour of missing values is controlled with na.value:
miss &lt;- factor(sample(c(NA, 1:5), nrow(mtcars), replace = TRUE))
ggplot(mtcars, aes(mpg, wt)) + geom_point(aes(colour = miss))
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = miss)) +
  scale_colour_hue(na.value = "black")

</code></pre>

<hr>
<h2 id='scale_continuous'>Continuous position scales (x &amp; y).</h2><span id='topic+scale_continuous'></span><span id='topic+scale_x_continuous'></span><span id='topic+scale_y_continuous'></span><span id='topic+scale_x_log10'></span><span id='topic+scale_y_log10'></span><span id='topic+scale_x_reverse'></span><span id='topic+scale_y_reverse'></span><span id='topic+scale_x_sqrt'></span><span id='topic+scale_y_sqrt'></span>

<h3>Description</h3>

<p><code>scale_x_continuous</code> and <code>scale_y_continuous</code> are the key functions.
The others, <code>scale_x_log10</code>, <code>scale_y_sqrt</code> etc, are aliases
that set the <code>trans</code> argument to commonly used transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_continuous(
  name = waiver(),
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = censor,
  na.value = NA_real_,
  trans = "identity"
)

scale_y_continuous(
  name = waiver(),
  breaks = waiver(),
  minor_breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  expand = waiver(),
  oob = censor,
  na.value = NA_real_,
  trans = "identity"
)

scale_x_log10(...)

scale_y_log10(...)

scale_x_reverse(...)

scale_y_reverse(...)

scale_x_sqrt(...)

scale_y_sqrt(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_continuous_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as axis or legend title. If
<code>NULL</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_breaks">breaks</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
transformation object
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_continuous_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_continuous_+3A_labels">labels</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_continuous_+3A_limits">limits</code></td>
<td>
<p>A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_expand">expand</code></td>
<td>
<p>A numeric vector of length two giving multiplicative and
additive expansion constants. These constants ensure that the data is
placed some distance away from the axes. The defaults are
<code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for
discrete variables.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_oob">oob</code></td>
<td>
<p>Function that handles limits outside of the scale limits
(out of bounds). The default replaces out of bounds values with NA.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_trans">trans</code></td>
<td>
<p>Either the name of a transformation object, or the
object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;exp&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;reciprocal&quot;, &quot;reverse&quot; and &quot;sqrt&quot;.
</p>
<p>A transformation object bundles together a transform, it's inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code>name_trans</code>, e.g.
<code><a href="scales.html#topic+boxcox_trans">boxcox_trans</a></code>. You can create your own
transformation with <code><a href="scales.html#topic+trans_new">trans_new</a></code>.</p>
</td></tr>
<tr><td><code id="scale_continuous_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>scale_(x|y)_continuous</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scale_date">scale_date</a></code> for date/time position scales.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(ggplot2movies)) {
m &lt;- ggplot(subset(movies, votes &gt; 1000), aes(rating, votes)) +
  geom_point(na.rm = TRUE)
m

# Manipulating the default position scales lets you:

#  * change the axis labels
m + scale_y_continuous("number of votes")
m + scale_y_continuous(quote(votes ^ alpha))

#  * modify the axis limits
m + scale_y_continuous(limits = c(0, 5000))
m + scale_y_continuous(limits = c(1000, 10000))
m + scale_x_continuous(limits = c(7, 8))

# you can also use the short hand functions xlim and ylim
m + ylim(0, 5000)
m + ylim(1000, 10000)
m + xlim(7, 8)

#  * choose where the ticks appear
m + scale_x_continuous(breaks = 1:10)
m + scale_x_continuous(breaks = c(1,3,7,9))

#  * manually label the ticks
m + scale_x_continuous(breaks = c(2,5,8), labels = c("two", "five", "eight"))
m + scale_x_continuous(breaks = c(2,5,8), labels = c("horrible", "ok", "awesome"))
m + scale_x_continuous(breaks = c(2,5,8), labels = expression(Alpha, Beta, Omega))

# There are a few built in transformation that you can use:
m + scale_y_log10()
m + scale_y_sqrt()
m + scale_y_reverse()
# You can also create your own and supply them to the trans argument.
# See ?scales::trans_new

# You can control the formatting of the labels with the formatter
# argument.  Some common formats are built into the scales package:
df &lt;- data.frame(
  x = rnorm(10) * 100000,
  y = seq(0, 1, length.out = 10)
)
p &lt;- ggplot(df, aes(x, y)) + geom_point()
p + scale_y_continuous(labels = scales::percent)
p + scale_y_continuous(labels = scales::dollar)
p + scale_x_continuous(labels = scales::comma)

# Other shortcut functions
ggplot(movies, aes(rating, votes)) +
  geom_point() +
  ylim(1e4, 5e4)
#   * axis labels
ggplot(movies, aes(rating, votes)) +
  geom_point() +
  labs(x = "My x axis", y = "My y axis")
#   * log scaling
ggplot(movies, aes(rating, votes)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()
}

</code></pre>

<hr>
<h2 id='scale_date'>Position scale, date &amp; date times</h2><span id='topic+scale_date'></span><span id='topic+scale_x_date'></span><span id='topic+scale_y_date'></span><span id='topic+scale_x_datetime'></span><span id='topic+scale_y_datetime'></span>

<h3>Description</h3>

<p>Use <code>scale_*_date</code> with <code>Date</code> variables, and
<code>scale_*_datetime</code> with <code>POSIXct</code> variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_date(
  name = waiver(),
  breaks = waiver(),
  date_breaks = waiver(),
  labels = waiver(),
  date_labels = waiver(),
  minor_breaks = waiver(),
  date_minor_breaks = waiver(),
  limits = NULL,
  expand = waiver()
)

scale_y_date(
  name = waiver(),
  breaks = waiver(),
  date_breaks = waiver(),
  labels = waiver(),
  date_labels = waiver(),
  minor_breaks = waiver(),
  date_minor_breaks = waiver(),
  limits = NULL,
  expand = waiver()
)

scale_x_datetime(
  name = waiver(),
  breaks = waiver(),
  date_breaks = waiver(),
  labels = waiver(),
  date_labels = waiver(),
  minor_breaks = waiver(),
  date_minor_breaks = waiver(),
  limits = NULL,
  expand = waiver()
)

scale_y_datetime(
  name = waiver(),
  breaks = waiver(),
  date_breaks = waiver(),
  labels = waiver(),
  date_labels = waiver(),
  minor_breaks = waiver(),
  date_minor_breaks = waiver(),
  limits = NULL,
  expand = waiver()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_date_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as axis or legend title. If
<code>NULL</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_breaks">breaks</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
transformation object
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_date_+3A_date_breaks">date_breaks</code></td>
<td>
<p>A string giving the distance between breaks like &quot;2
weeks&quot;, or &quot;10 years&quot;. If both <code>breaks</code> and <code>date_breaks</code> are
specified, <code>date_breaks</code> wins.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_labels">labels</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_date_+3A_date_labels">date_labels</code></td>
<td>
<p>A string giving the formatting specification for the
labels. Codes are defined in <code><a href="base.html#topic+strftime">strftime</a></code>. If both <code>labels</code>
and <code>date_labels</code> are specified, <code>date_labels</code> wins.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_minor_breaks">minor_breaks</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_date_+3A_date_minor_breaks">date_minor_breaks</code></td>
<td>
<p>A string giving the distance between minor breaks
like &quot;2 weeks&quot;, or &quot;10 years&quot;. If both <code>minor_breaks</code> and
<code>date_minor_breaks</code> are specified, <code>date_minor_breaks</code> wins.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_limits">limits</code></td>
<td>
<p>A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum.</p>
</td></tr>
<tr><td><code id="scale_date_+3A_expand">expand</code></td>
<td>
<p>A numeric vector of length two giving multiplicative and
additive expansion constants. These constants ensure that the data is
placed some distance away from the axes. The defaults are
<code>c(0.05, 0)</code> for continuous variables, and <code>c(0, 0.6)</code> for
discrete variables.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scale_continuous">scale_continuous</a></code> for continuous position scales.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>last_month &lt;- Sys.Date() - 0:29
df &lt;- data.frame(
  date = last_month,
  price = runif(30)
)
base &lt;- ggplot(df, aes(date, price)) +
  geom_line()

# The date scale will attempt to pick sensible defaults for
# major and minor tick marks. Override with date_breaks, date_labels
# date_minor_breaks arguments.
base + scale_x_date(date_labels = "%b %d")
base + scale_x_date(date_breaks = "1 week", date_labels = "%W")
base + scale_x_date(date_minor_breaks = "1 day")

# Set limits
base + scale_x_date(limits = c(Sys.Date() - 7, NA))
</code></pre>

<hr>
<h2 id='scale_identity'>Use values without scaling.</h2><span id='topic+scale_identity'></span><span id='topic+scale_colour_identity'></span><span id='topic+scale_fill_identity'></span><span id='topic+scale_shape_identity'></span><span id='topic+scale_linetype_identity'></span><span id='topic+scale_alpha_identity'></span><span id='topic+scale_size_identity'></span><span id='topic+scale_color_identity'></span>

<h3>Description</h3>

<p>Use values without scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_identity(..., guide = "none")

scale_fill_identity(..., guide = "none")

scale_shape_identity(..., guide = "none")

scale_linetype_identity(..., guide = "none")

scale_alpha_identity(..., guide = "none")

scale_size_identity(..., guide = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_identity_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+discrete_scale">discrete_scale</a></code> or
<code><a href="#topic+continuous_scale">continuous_scale</a></code></p>
</td></tr>
<tr><td><code id="scale_identity_+3A_guide">guide</code></td>
<td>
<p>Guide to use for this scale - defaults to <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(luv_colours, aes(u, v)) +
  geom_point(aes(colour = col), size = 3) +
  scale_color_identity() +
  coord_equal()

df &lt;- data.frame(
  x = 1:4,
  y = 1:4,
  colour = c("red", "green", "blue", "yellow")
)
ggplot(df, aes(x, y)) + geom_tile(aes(fill = colour))
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity()

# To get a legend guide, specify guide = "legend"
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity(guide = "legend")
# But you'll typically also need to supply breaks and labels:
ggplot(df, aes(x, y)) +
  geom_tile(aes(fill = colour)) +
  scale_fill_identity("trt", labels = letters[1:4], breaks = df$colour,
  guide = "legend")

# cyl scaled to appropriate size
ggplot(mtcars, aes(mpg, wt)) + geom_point(aes(size = cyl))

# cyl used as point size
ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(size = cyl)) +
  scale_size_identity()
</code></pre>

<hr>
<h2 id='scale_linetype'>Scale for line patterns.</h2><span id='topic+scale_linetype'></span><span id='topic+scale_linetype_continuous'></span><span id='topic+scale_linetype_discrete'></span>

<h3>Description</h3>

<p>Default line types based on a set supplied by Richard Pearson,
University of Manchester.  Line types can not be mapped to continuous
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_linetype(..., na.value = "blank")

scale_linetype_continuous(...)

scale_linetype_discrete(..., na.value = "blank")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_linetype_+3A_...">...</code></td>
<td>
<p>common discrete scale parameters: <code>name</code>, <code>breaks</code>,
<code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See
<code><a href="#topic+discrete_scale">discrete_scale</a></code> for more details</p>
</td></tr>
<tr><td><code id="scale_linetype_+3A_na.value">na.value</code></td>
<td>
<p>The linetype to use for <code>NA</code> values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>base &lt;- ggplot(economics_long, aes(date, value01))
base + geom_line(aes(group = variable))
base + geom_line(aes(linetype = variable))

# See scale_manual for more flexibility
</code></pre>

<hr>
<h2 id='scale_manual'>Create your own discrete scale.</h2><span id='topic+scale_manual'></span><span id='topic+scale_colour_manual'></span><span id='topic+scale_fill_manual'></span><span id='topic+scale_size_manual'></span><span id='topic+scale_shape_manual'></span><span id='topic+scale_linetype_manual'></span><span id='topic+scale_alpha_manual'></span><span id='topic+scale_color_manual'></span>

<h3>Description</h3>

<p>Create your own discrete scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_manual(..., values)

scale_fill_manual(..., values)

scale_size_manual(..., values)

scale_shape_manual(..., values)

scale_linetype_manual(..., values)

scale_alpha_manual(..., values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_manual_+3A_...">...</code></td>
<td>
<p>common discrete scale parameters: <code>name</code>, <code>breaks</code>,
<code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See
<code><a href="#topic+discrete_scale">discrete_scale</a></code> for more details</p>
</td></tr>
<tr><td><code id="scale_manual_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to.  If this
is a named vector, then the values will be matched based on the names.
If unnamed, values will be matched in order (usually alphabetical) with
the limits of the scale.  Any data values that don't match will be
given <code>na.value</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(colour = factor(cyl)))

p + scale_colour_manual(values = c("red","blue", "green"))
p + scale_colour_manual(
  values = c("8" = "red","4" = "blue","6" = "green"))
# With rgb hex values
p + scale_colour_manual(values = c("#FF0000", "#0000FF", "#00FF00"))

# As with other scales you can use breaks to control the appearance
# of the legend
cols &lt;- c("8" = "red","4" = "blue","6" = "darkgreen", "10" = "orange")
p + scale_colour_manual(values = cols)
p + scale_colour_manual(values = cols, breaks = c("4", "6", "8"))
p + scale_colour_manual(values = cols, breaks = c("8", "6", "4"))
p + scale_colour_manual(values = cols, breaks = c("4", "6", "8"),
  labels = c("four", "six", "eight"))

# And limits to control the possible values of the scale
p + scale_colour_manual(values = cols, limits = c("4", "8"))
p + scale_colour_manual(values = cols, limits = c("4", "6", "8", "10"))

# Notice that the values are matched with limits, and not breaks
p + scale_colour_manual(limits = c(6, 8, 4), breaks = c(8, 4, 6),
  values = c("grey50", "grey80", "black"))

</code></pre>

<hr>
<h2 id='scale_shape'>Scale for shapes, aka glyphs.</h2><span id='topic+scale_shape'></span><span id='topic+scale_shape_discrete'></span><span id='topic+scale_shape_continuous'></span>

<h3>Description</h3>

<p>A continuous variable can not be mapped to shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_shape(..., solid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_shape_+3A_...">...</code></td>
<td>
<p>common discrete scale parameters: <code>name</code>, <code>breaks</code>,
<code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See
<code><a href="#topic+discrete_scale">discrete_scale</a></code> for more details</p>
</td></tr>
<tr><td><code id="scale_shape_+3A_solid">solid</code></td>
<td>
<p>Are the shapes solid, <code>TRUE</code>, or hollow <code>FALSE</code>?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dsmall &lt;- diamonds[sample(nrow(diamonds), 100), ]

(d &lt;- ggplot(dsmall, aes(carat, price)) + geom_point(aes(shape = cut)))
d + scale_shape(solid = TRUE) # the default
d + scale_shape(solid = FALSE)
d + scale_shape(name = "Cut of diamond")
d + scale_shape(name = "Cut of\ndiamond")

# To change order of levels, change order of
# underlying factor
levels(dsmall$cut) &lt;- c("Fair", "Good", "Very Good", "Premium", "Ideal")

# Need to recreate plot to pick up new data
ggplot(dsmall, aes(price, carat)) + geom_point(aes(shape = cut))

# Or for short:
d %+% dsmall
</code></pre>

<hr>
<h2 id='scale_size'>Scale size (area or radius).</h2><span id='topic+scale_size'></span><span id='topic+scale_size_continuous'></span><span id='topic+scale_radius'></span><span id='topic+scale_size_discrete'></span><span id='topic+scale_size_area'></span><span id='topic+scale_size_datetime'></span><span id='topic+scale_size_date'></span>

<h3>Description</h3>

<p><code>scale_size</code> scales area, <code>scale_radius</code> scales radius. The size
aesthetic is most commonly used for points and text, and humans perceive
the area of points (not their radius), so this provides for optimal
perception. <code>scale_size_area</code> ensures that a value of 0 is mapped
to a size of 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_radius(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_size(
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  range = c(1, 6),
  trans = "identity",
  guide = "legend"
)

scale_size_area(..., max_size = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_size_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as axis or legend title. If
<code>NULL</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_breaks">breaks</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
transformation object
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_size_+3A_labels">labels</code></td>
<td>
<p>One of: </p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_size_+3A_limits">limits</code></td>
<td>
<p>A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2 that specifies the minimum and
maximum size of the plotting symbol after transformation.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_trans">trans</code></td>
<td>
<p>Either the name of a transformation object, or the
object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;exp&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;reciprocal&quot;, &quot;reverse&quot; and &quot;sqrt&quot;.
</p>
<p>A transformation object bundles together a transform, it's inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code>name_trans</code>, e.g.
<code><a href="scales.html#topic+boxcox_trans">boxcox_trans</a></code>. You can create your own
transformation with <code><a href="scales.html#topic+trans_new">trans_new</a></code>.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_guide">guide</code></td>
<td>
<p>Name of guide object, or object itself.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+continuous_scale">continuous_scale</a></code>
to control name, limits, breaks, labels and so forth.</p>
</td></tr>
<tr><td><code id="scale_size_+3A_max_size">max_size</code></td>
<td>
<p>Size of largest points.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scale_size_area">scale_size_area</a></code> if you want 0 values to be mapped
to points with size 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mpg, aes(displ, hwy, size = hwy)) +
   geom_point()
p
p + scale_size("Highway mpg")
p + scale_size(range = c(0, 10))

# If you want zero value to have zero size, use scale_size_area:
p + scale_size_area()

# This is most useful when size is a count
ggplot(mpg, aes(class, cyl)) +
  geom_count() +
  scale_size_area()

# If you want to map size to radius (usually bad idea), use scale_radius
p + scale_radius()
</code></pre>

<hr>
<h2 id='scale_size_animint'>Scale point sizes using circle area, but specifying the radius in
pixels.</h2><span id='topic+scale_size_animint'></span>

<h3>Description</h3>

<p>Scale point sizes using circle area, but specifying the radius in
pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_size_animint(pixel.range = c(2, 20), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_size_animint_+3A_pixel.range">pixel.range</code></td>
<td>
<p>min and max circle radius in pixels.</p>
</td></tr>
<tr><td><code id="scale_size_animint_+3A_...">...</code></td>
<td>
<p>passed to continuous_scale.</p>
</td></tr>
</table>

<hr>
<h2 id='scale_x_discrete'>Discrete position.</h2><span id='topic+scale_x_discrete'></span><span id='topic+scale_y_discrete'></span>

<h3>Description</h3>

<p>You can use continuous positions even with a discrete position scale -
this allows you (e.g.) to place labels between bars in a bar chart.
Continuous positions are numeric values starting at one for the first
level, and increasing by one for each level (i.e. the labels are placed
at integer positions).  This is what allows jittering to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_discrete(..., expand = waiver())

scale_y_discrete(..., expand = waiver())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_discrete_+3A_...">...</code></td>
<td>
<p>common discrete scale parameters: <code>name</code>, <code>breaks</code>,
<code>labels</code>, <code>na.value</code>, <code>limits</code> and <code>guide</code>.  See
<code><a href="#topic+discrete_scale">discrete_scale</a></code> for more details</p>
</td></tr>
<tr><td><code id="scale_x_discrete_+3A_expand">expand</code></td>
<td>
<p>a numeric vector of length two giving multiplicative and
additive expansion constants. These constants ensure that the data is
placed some distance away from the axes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(diamonds, aes(cut)) + geom_bar()


# The discrete position scale is added automatically whenever you
# have a discrete position.

(d &lt;- ggplot(subset(diamonds, carat &gt; 1), aes(cut, clarity)) +
      geom_jitter())

d + scale_x_discrete("Cut")
d + scale_x_discrete("Cut", labels = c("Fair" = "F","Good" = "G",
  "Very Good" = "VG","Perfect" = "P","Ideal" = "I"))

# Use limits to adjust the which levels (and in what order)
# are displayed
d + scale_x_discrete(limits = c("Fair","Ideal"))

# you can also use the short hand functions xlim and ylim
d + xlim("Fair","Ideal", "Good")
d + ylim("I1", "IF")

# See ?reorder to reorder based on the values of another variable
ggplot(mpg, aes(manufacturer, cty)) + geom_point()
ggplot(mpg, aes(reorder(manufacturer, cty), cty)) + geom_point()
ggplot(mpg, aes(reorder(manufacturer, displ), cty)) + geom_point()

# Use abbreviate as a formatter to reduce long names
ggplot(mpg, aes(reorder(manufacturer, displ), cty)) +
  geom_point() +
  scale_x_discrete(labels = abbreviate)

</code></pre>

<hr>
<h2 id='seals'>Vector field of seal movements.</h2><span id='topic+seals'></span>

<h3>Description</h3>

<p>This vector field was produced from the data described in Brillinger, D.R.,
Preisler, H.K., Ager, A.A. and Kie, J.G. &quot;An exploratory data analysis
(EDA) of the paths of moving animals&quot;. J. Statistical Planning and
Inference 122 (2004), 43-63, using the methods of Brillinger, D.R.,
&quot;Learning a potential function from a trajectory&quot;, Signal Processing
Letters. December (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seals
</code></pre>


<h3>Format</h3>

<p>A data frame with 1155 rows and 4 variables
</p>


<h3>References</h3>

<p><a href="https://www.stat.berkeley.edu/~brill/Papers/jspifinal.pdf">https://www.stat.berkeley.edu/~brill/Papers/jspifinal.pdf</a>
</p>

<hr>
<h2 id='selectSSandCS'>Separate .variable/.value selectors</h2><span id='topic+selectSSandCS'></span>

<h3>Description</h3>

<p>Separate .variable/.value selectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectSSandCS(aesthetics_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectSSandCS_+3A_aesthetics_list">aesthetics_list</code></td>
<td>
<p>aesthetics mapping of the layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified <code>aes.list</code> list with separated
showSelected.variable/value
</p>

<hr>
<h2 id='setPlotSizes'>Set plot width and height for all plots</h2><span id='topic+setPlotSizes'></span>

<h3>Description</h3>

<p>Set plot width and height for all plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPlotSizes(meta, AllPlotsInfo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPlotSizes_+3A_meta">meta</code></td>
<td>
<p>meta object with all information</p>
</td></tr>
<tr><td><code id="setPlotSizes_+3A_allplotsinfo">AllPlotsInfo</code></td>
<td>
<p>plot info list</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. Sizes are stored in meta object
</p>

<hr>
<h2 id='should_stop'>Used in examples to illustrate when errors should occur.</h2><span id='topic+should_stop'></span>

<h3>Description</h3>

<p>Used in examples to illustrate when errors should occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>should_stop(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="should_stop_+3A_expr">expr</code></td>
<td>
<p>code to evaluate.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>should_stop(stop("Hi!"))
should_stop(should_stop("Hi!"))
</code></pre>

<hr>
<h2 id='split_recursive'>Split data.frame into recursive list of data.frame.</h2><span id='topic+split_recursive'></span>

<h3>Description</h3>

<p>Split data.frame into recursive list of data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_recursive(x, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_recursive_+3A_x">x</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="split_recursive_+3A_vars">vars</code></td>
<td>
<p>character vector of variable names to split on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recursive list of data.frame.
</p>

<hr>
<h2 id='stat_ecdf'>Empirical Cumulative Density Function</h2><span id='topic+stat_ecdf'></span>

<h3>Description</h3>

<p>Empirical Cumulative Density Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ecdf(
  mapping = NULL,
  data = NULL,
  geom = "step",
  position = "identity",
  ...,
  n = NULL,
  pad = TRUE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ecdf_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_n">n</code></td>
<td>
<p>if NULL, do not interpolate. If not NULL, this is the number
of points to interpolate with.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, pad the ecdf with additional points (-Inf, 0)
and (Inf, 1)</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_ecdf_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Computed variables</h3>


<dl>
<dt>x</dt><dd><p>x in data</p>
</dd>
<dt>y</dt><dd><p>cumulative density corresponding x</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(x = rnorm(1000))
ggplot(df, aes(x)) + stat_ecdf(geom = "step")

df &lt;- data.frame(x = c(rnorm(100, 0, 3), rnorm(100, 0, 10)),
                 g = gl(2, 100))

ggplot(df, aes(x, colour = g)) + stat_ecdf()

</code></pre>

<hr>
<h2 id='stat_ellipse'>Plot data ellipses.</h2><span id='topic+stat_ellipse'></span>

<h3>Description</h3>

<p>The method for calculating the ellipses has been modified from
<code>car::ellipse</code> (Fox and Weisberg, 2011)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ellipse(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  ...,
  type = "t",
  level = 0.95,
  segments = 51,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ellipse_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_type">type</code></td>
<td>
<p>The type of ellipse.
The default <code>"t"</code> assumes a multivariate t-distribution, and
<code>"norm"</code> assumes a multivariate normal distribution.
<code>"euclid"</code> draws a circle with the radius equal to <code>level</code>,
representing the euclidean distance from the center.
This ellipse probably won't appear circular unless <code>coord_fixed()</code> is applied.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_level">level</code></td>
<td>
<p>The confidence level at which to draw an ellipse (default is 0.95),
or, if <code>type="euclid"</code>, the radius of the circle to be drawn.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_segments">segments</code></td>
<td>
<p>The number of segments to be used in drawing the ellipse.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_ellipse_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>John Fox and Sanford Weisberg (2011). An R Companion to
Applied Regression, Second Edition. Thousand Oaks CA: Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(faithful, aes(waiting, eruptions)) +
  geom_point() +
  stat_ellipse()

ggplot(faithful, aes(waiting, eruptions, color = eruptions &gt; 3)) +
  geom_point() +
  stat_ellipse()

ggplot(faithful, aes(waiting, eruptions, color = eruptions &gt; 3)) +
  geom_point() +
  stat_ellipse(type = "norm", linetype = 2) +
  stat_ellipse(type = "t")

ggplot(faithful, aes(waiting, eruptions, color = eruptions &gt; 3)) +
  geom_point() +
  stat_ellipse(type = "norm", linetype = 2) +
  stat_ellipse(type = "euclid", level = 3) +
  coord_fixed()

ggplot(faithful, aes(waiting, eruptions, fill = eruptions &gt; 3)) +
  stat_ellipse(geom = "polygon")
</code></pre>

<hr>
<h2 id='stat_function'>Superimpose a function.</h2><span id='topic+stat_function'></span>

<h3>Description</h3>

<p>Superimpose a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_function(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  ...,
  fun,
  xlim = NULL,
  n = 101,
  args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_function_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_function_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_function_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_function_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_function_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_function_+3A_fun">fun</code></td>
<td>
<p>function to use</p>
</td></tr>
<tr><td><code id="stat_function_+3A_xlim">xlim</code></td>
<td>
<p>Optionally, restrict the range of the function to this range.</p>
</td></tr>
<tr><td><code id="stat_function_+3A_n">n</code></td>
<td>
<p>number of points to interpolate along</p>
</td></tr>
<tr><td><code id="stat_function_+3A_args">args</code></td>
<td>
<p>list of additional arguments to pass to <code>fun</code></p>
</td></tr>
<tr><td><code id="stat_function_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_function_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_function_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_function</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p>y
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x</dt><dd><p>x's along a grid</p>
</dd>
<dt>y</dt><dd><p>value of function evaluated at corresponding x</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1492)
df &lt;- data.frame(
  x = rnorm(100)
)
x &lt;- df$x
base &lt;- ggplot(df, aes(x)) + geom_density()
base + stat_function(fun = dnorm, colour = "red")
base + stat_function(fun = dnorm, colour = "red", args = list(mean = 3))

# Plot functions without data
# Examples adapted from Kohske Takahashi

# Specify range of x-axis
ggplot(data.frame(x = c(0, 2)), aes(x)) +
  stat_function(fun = exp, geom = "line")

# Plot a normal curve
ggplot(data.frame(x = c(-5, 5)), aes(x)) + stat_function(fun = dnorm)

# To specify a different mean or sd, use the args parameter to supply new values
ggplot(data.frame(x = c(-5, 5)), aes(x)) +
  stat_function(fun = dnorm, args = list(mean = 2, sd = .5))

# Two functions on the same plot
f &lt;- ggplot(data.frame(x = c(0, 10)), aes(x))
f + stat_function(fun = sin, colour = "red") +
  stat_function(fun = cos, colour = "blue")

# Using a custom function
test &lt;- function(x) {x ^ 2 + x + 20}
f + stat_function(fun = test)
</code></pre>

<hr>
<h2 id='stat_identity'>Identity statistic.</h2><span id='topic+stat_identity'></span>

<h3>Description</h3>

<p>The identity statistic leaves the data unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_identity(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_identity_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_identity_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(wt, mpg))
p + stat_identity()
</code></pre>

<hr>
<h2 id='stat_qq'>Calculation for quantile-quantile plot.</h2><span id='topic+stat_qq'></span><span id='topic+geom_qq'></span>

<h3>Description</h3>

<p>Calculation for quantile-quantile plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_qq(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  distribution = stats::qnorm,
  dparams = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_qq(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  distribution = stats::qnorm,
  dparams = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_qq_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_distribution">distribution</code></td>
<td>
<p>Distribution function to use, if x not specified</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_dparams">dparams</code></td>
<td>
<p>Additional parameters passed on to <code>distribution</code>
function.</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_qq_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_qq</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>sample</strong></p>
</li>
<li><p>x
</p>
</li>
<li><p>y
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>sample</dt><dd><p>sample quantiles</p>
</dd>
<dt>theoretical</dt><dd><p>theoretical quantiles</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(y = rt(200, df = 5))
p &lt;- ggplot(df, aes(sample = y))
p + stat_qq()
p + geom_point(stat = "qq")

# Use fitdistr from MASS to estimate distribution params
params &lt;- as.list(MASS::fitdistr(df$y, "t")$estimate)
ggplot(df, aes(sample = y)) +
  stat_qq(distribution = qt, dparams = params["df"])

# Using to explore the distribution of a variable
ggplot(mtcars) +
  stat_qq(aes(sample = mpg))
ggplot(mtcars) +
  stat_qq(aes(sample = mpg, colour = factor(cyl)))

</code></pre>

<hr>
<h2 id='stat_summary_2d'>Bin and summarise in 2d (rectangle &amp; hexagons)</h2><span id='topic+stat_summary_2d'></span><span id='topic+stat_summary2d'></span><span id='topic+stat_summary_hex'></span>

<h3>Description</h3>

<p><code>stat_summary_2d</code> is a 2d variation of <code><a href="#topic+stat_summary">stat_summary</a></code>.
<code>stat_summary_hex</code> is a hexagonal variation of
<code><a href="#topic+stat_summary_2d">stat_summary_2d</a></code>. The data are divided into bins defined
by <code>x</code> and <code>y</code>, and then the values of <code>z</code> in each cell is
are summarised with <code>fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_summary_2d(
  mapping = NULL,
  data = NULL,
  geom = "tile",
  position = "identity",
  ...,
  bins = 30,
  binwidth = NULL,
  drop = TRUE,
  fun = "mean",
  fun.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_summary_hex(
  mapping = NULL,
  data = NULL,
  geom = "hex",
  position = "identity",
  ...,
  bins = 30,
  binwidth = NULL,
  drop = TRUE,
  fun = "mean",
  fun.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_summary_2d_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_bins">bins</code></td>
<td>
<p>numeric vector giving number of bins in both vertical and
horizontal directions. Set to 30 by default.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric vector giving bin width in both vertical and
horizontal directions. Overrides <code>bins</code> if both set.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_drop">drop</code></td>
<td>
<p>drop if the output of <code>fun</code> is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_fun">fun</code></td>
<td>
<p>function for summary.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_fun.args">fun.args</code></td>
<td>
<p>A list of extra arguments to pass to <code>fun</code></p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_summary_2d_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>


<ul>
<li> <p><code>x</code>: horizontal position
</p>
</li>
<li> <p><code>y</code>: vertical position
</p>
</li>
<li> <p><code>z</code>: value passed to the summary function
</p>
</li></ul>



<h3>Computed variables</h3>


<dl>
<dt>x,y</dt><dd><p>Location</p>
</dd>
<dt>value</dt><dd><p>Value of summary statistic.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stat_summary_hex">stat_summary_hex</a></code> for hexagonal summarization.
<code><a href="#topic+stat_bin2d">stat_bin2d</a></code> for the binning options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- ggplot(diamonds, aes(carat, depth, z = price))
d + stat_summary_2d()

# Specifying function
d + stat_summary_2d(fun = function(x) sum(x^2))
d + stat_summary_2d(fun = var)
d + stat_summary_2d(fun = "quantile", fun.args = list(probs = 0.1))

if (requireNamespace("hexbin")) {
d + stat_summary_hex()
}
</code></pre>

<hr>
<h2 id='stat_summary_bin'>Summarise y values at unique/binned x x.</h2><span id='topic+stat_summary_bin'></span><span id='topic+stat_summary'></span>

<h3>Description</h3>

<p><code>stat_summary</code> operates on unique <code>x</code>; <code>stat_summary_bin</code>
operators on binned <code>x</code>. They are more flexible versions of
<code><a href="#topic+stat_bin">stat_bin</a></code>: instead of just counting, they can compute any
aggregate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_summary_bin(
  mapping = NULL,
  data = NULL,
  geom = "pointrange",
  position = "identity",
  ...,
  fun.data = NULL,
  fun.y = NULL,
  fun.ymax = NULL,
  fun.ymin = NULL,
  fun.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_summary(
  mapping = NULL,
  data = NULL,
  geom = "pointrange",
  position = "identity",
  ...,
  fun.data = NULL,
  fun.y = NULL,
  fun.ymax = NULL,
  fun.ymin = NULL,
  fun.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_summary_bin_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_fun.data">fun.data</code></td>
<td>
<p>A function that is given the complete data and should
return a data frame with variables <code>ymin</code>, <code>y</code>, and <code>ymax</code>.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_fun.ymin">fun.ymin</code>, <code id="stat_summary_bin_+3A_fun.y">fun.y</code>, <code id="stat_summary_bin_+3A_fun.ymax">fun.ymax</code></td>
<td>
<p>Alternatively, supply three individual
functions that are each passed a vector of x's and should return a
single number.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_fun.args">fun.args</code></td>
<td>
<p>Optional additional arguments passed on to the functions.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_summary_bin_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_summary</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li><p><strong>x</strong></p>
</li>
<li><p><strong>y</strong></p>
</li></ul>



<h3>Summary functions</h3>

<p>You can either supply summary functions individually (<code>fun.y</code>,
<code>fun.ymax</code>, <code>fun.ymin</code>), or as a single function (<code>fun.data</code>):
</p>

<dl>
<dt>fun.data</dt><dd><p>Complete summary function. Should take numeric vector as
input and return data frame as output</p>
</dd>
<dt>fun.ymin</dt><dd><p>ymin summary function (should take numeric vector and
return single number)</p>
</dd>
<dt>fun.y</dt><dd><p>y summary function (should take numeric vector and return
single number)</p>
</dd>
<dt>fun.ymax</dt><dd><p>ymax summary function (should take numeric vector and
return single number)</p>
</dd>
</dl>

<p>A simple vector function is easiest to work with as you can return a single
number, but is somewhat less flexible. If your summary function computes
multiple values at once (e.g. ymin and ymax), use <code>fun.data</code>.
</p>
<p>If no aggregation functions are suppled, will default to
<code><a href="#topic+mean_se">mean_se</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_errorbar">geom_errorbar</a></code>, <code><a href="#topic+geom_pointrange">geom_pointrange</a></code>,
<code><a href="#topic+geom_linerange">geom_linerange</a></code>, <code><a href="#topic+geom_crossbar">geom_crossbar</a></code> for geoms to
display summarised data
</p>

<hr>
<h2 id='stat_unique'>Remove duplicates.</h2><span id='topic+stat_unique'></span>

<h3>Description</h3>

<p>Remove duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_unique(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_unique_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="#topic+aes">aes</a></code> or
<code><a href="#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="#topic+fortify">fortify</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame.</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_unique_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>stat_unique</code>understands the following aesthetics (required aesthetics are in bold):
</p>
<ul>
<li></li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mtcars, aes(vs, am)) + geom_point(alpha = 0.1)
ggplot(mtcars, aes(vs, am)) + geom_point(alpha = 0.1, stat="unique")
</code></pre>

<hr>
<h2 id='summary.gganimintplot'>Displays a useful description of a ggplot object</h2><span id='topic+summary.gganimintplot'></span>

<h3>Description</h3>

<p>Displays a useful description of a ggplot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gganimintplot'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gganimintplot_+3A_object">object</code></td>
<td>
<p>ggplot2 object to summarise</p>
</td></tr>
<tr><td><code id="summary.gganimintplot_+3A_...">...</code></td>
<td>
<p>other arguments ignored (for compatibility with generic)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point()
summary(p)
</code></pre>

<hr>
<h2 id='switch_axes'>Flip axes in case of coord_flip
Switches column names. Eg. xmin to ymin, yntercept to xintercept etc.</h2><span id='topic+switch_axes'></span>

<h3>Description</h3>

<p>Flip axes in case of coord_flip
Switches column names. Eg. xmin to ymin, yntercept to xintercept etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_axes(col.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switch_axes_+3A_col.names">col.names</code></td>
<td>
<p>Column names which need to be switched</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column names with x and y axes switched
</p>

<hr>
<h2 id='theme'>Set theme elements</h2><span id='topic+theme'></span>

<h3>Description</h3>

<p>Use this function to modify theme settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme(..., complete = FALSE, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_+3A_...">...</code></td>
<td>
<p>a list of element name, element pairings that modify the
existing theme.</p>
</td></tr>
<tr><td><code id="theme_+3A_complete">complete</code></td>
<td>
<p>set this to TRUE if this is a complete theme, such as
the one returned <code>by theme_grey()</code>. Complete themes behave
differently when added to a ggplot object.</p>
</td></tr>
<tr><td><code id="theme_+3A_validate">validate</code></td>
<td>
<p>TRUE to run validate_element, FALSE to bypass checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Theme elements can inherit properties from other theme elements.
For example, <code>axis.title.x</code> inherits from <code>axis.title</code>,
which in turn inherits from <code>text</code>. All text elements inherit
directly or indirectly from <code>text</code>; all lines inherit from
<code>line</code>, and all rectangular objects inherit from <code>rect</code>.
</p>
<p>For more examples of modifying properties using inheritance,
<code><a href="#topic++25+2Breplace+25">%+replace%</a></code>.
</p>
<p>To see a graphical representation of the inheritance tree, see the
last example below.
</p>


<h3>Theme elements</h3>

<p>The individual theme elements are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  line             </td><td style="text-align: left;"> all line elements
                   (<code>element_line</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  rect             </td><td style="text-align: left;"> all rectangular elements
                   (<code>element_rect</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  text             </td><td style="text-align: left;"> all text elements
                   (<code>element_text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  title            </td><td style="text-align: left;"> all title elements: plot, axes, legends
                   (<code>element_text</code>; inherits from <code>text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  aspect.ratio     </td><td style="text-align: left;"> aspect ratio of the panel </td>
</tr>
<tr>
 <td style="text-align: left;">

  axis.title       </td><td style="text-align: left;"> label of axes
                   (<code>element_text</code>; inherits from <code>text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.title.x     </td><td style="text-align: left;"> x axis label
                   (<code>element_text</code>; inherits from <code>axis.title</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.title.y     </td><td style="text-align: left;"> y axis label
                   (<code>element_text</code>; inherits from <code>axis.title</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.text        </td><td style="text-align: left;"> tick labels along axes
                   (<code>element_text</code>; inherits from <code>text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.text.x      </td><td style="text-align: left;"> x axis tick labels
                   (<code>element_text</code>; inherits from <code>axis.text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.text.y      </td><td style="text-align: left;"> y axis tick labels
                   (<code>element_text</code>; inherits from <code>axis.text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.ticks       </td><td style="text-align: left;"> tick marks along axes
                   (<code>element_line</code>; inherits from <code>line</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.ticks.x     </td><td style="text-align: left;"> x axis tick marks
                   (<code>element_line</code>; inherits from <code>axis.ticks</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.ticks.y     </td><td style="text-align: left;"> y axis tick marks
                   (<code>element_line</code>; inherits from <code>axis.ticks</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.ticks.length  </td><td style="text-align: left;"> length of tick marks
                   (<code>unit</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.line        </td><td style="text-align: left;"> lines along axes
                   (<code>element_line</code>; inherits from <code>line</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.line.x      </td><td style="text-align: left;"> line along x axis
                   (<code>element_line</code>; inherits from <code>axis.line</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  axis.line.y      </td><td style="text-align: left;"> line along y axis
                   (<code>element_line</code>; inherits from <code>axis.line</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">

  legend.background  </td><td style="text-align: left;"> background of legend
                   (<code>element_rect</code>; inherits from <code>rect</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.margin    </td><td style="text-align: left;"> extra space added around legend
                   (<code>unit</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.key       </td><td style="text-align: left;"> background underneath legend keys
                   (<code>element_rect</code>; inherits from <code>rect</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.key.size  </td><td style="text-align: left;"> size of legend keys
                   (<code>unit</code>; inherits from <code>legend.key.size</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.key.height  </td><td style="text-align: left;"> key background height
                   (<code>unit</code>; inherits from <code>legend.key.size</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.key.width   </td><td style="text-align: left;"> key background width
                   (<code>unit</code>; inherits from <code>legend.key.size</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.text      </td><td style="text-align: left;"> legend item labels
                   (<code>element_text</code>; inherits from <code>text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.text.align  </td><td style="text-align: left;"> alignment of legend labels
                   (number from 0 (left) to 1 (right)) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.title     </td><td style="text-align: left;"> title of legend
                   (<code>element_text</code>; inherits from <code>title</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.title.align </td><td style="text-align: left;"> alignment of legend title
                   (number from 0 (left) to 1 (right)) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.position  </td><td style="text-align: left;"> the position of legends
                   ("none", "left", "right", "bottom", "top", or two-element
                     numeric vector) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.direction </td><td style="text-align: left;"> layout of items in legends
                   ("horizontal" or "vertical") </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.justification </td><td style="text-align: left;"> anchor point for positioning legend inside plot
                   ("center" or two-element numeric vector) </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.box       </td><td style="text-align: left;"> arrangement of multiple legends
                   ("horizontal" or "vertical") </td>
</tr>
<tr>
 <td style="text-align: left;">
  legend.box.just  </td><td style="text-align: left;"> justification of each legend within the overall
                   bounding box, when there are multiple legends
                   ("top", "bottom", "left", or "right")</td>
</tr>
<tr>
 <td style="text-align: left;">

  panel.background </td><td style="text-align: left;"> background of plotting area, drawn underneath plot
                   (<code>element_rect</code>; inherits from <code>rect</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.border     </td><td style="text-align: left;"> border around plotting area, drawn on top of plot
                   so that it covers tick marks and grid lines. This should
                   be used with <code>fill=NA</code>
                   (<code>element_rect</code>; inherits from <code>rect</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.margin     </td><td style="text-align: left;"> margin around facet panels
                   (<code>unit</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.margin.x   </td><td style="text-align: left;"> horizontal margin around facet panels
                   (<code>unit</code>; inherits from <code>panel.margin</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.margin.y   </td><td style="text-align: left;"> vertical margin around facet panels
                   (<code>unit</code>; inherits from <code>panel.margin</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.grid       </td><td style="text-align: left;"> grid lines
                   (<code>element_line</code>; inherits from <code>line</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.grid.major </td><td style="text-align: left;"> major grid lines
                   (<code>element_line</code>; inherits from <code>panel.grid</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.grid.minor </td><td style="text-align: left;"> minor grid lines
                   (<code>element_line</code>; inherits from <code>panel.grid</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.grid.major.x </td><td style="text-align: left;"> vertical major grid lines
                   (<code>element_line</code>; inherits from <code>panel.grid.major</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.grid.major.y </td><td style="text-align: left;"> horizontal major grid lines
                   (<code>element_line</code>; inherits from <code>panel.grid.major</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.grid.minor.x </td><td style="text-align: left;"> vertical minor grid lines
                   (<code>element_line</code>; inherits from <code>panel.grid.minor</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.grid.minor.y </td><td style="text-align: left;"> horizontal minor grid lines
                   (<code>element_line</code>; inherits from <code>panel.grid.minor</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  panel.ontop        </td><td style="text-align: left;"> option to place the panel (background, gridlines)
                          over the data layers.  Usually used with a transparent
                          or blank <code>panel.background</code>. (<code>logical</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">

  plot.background  </td><td style="text-align: left;"> background of the entire plot
                   (<code>element_rect</code>; inherits from <code>rect</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  plot.title       </td><td style="text-align: left;"> plot title (text appearance)
                   (<code>element_text</code>; inherits from <code>title</code>)
                   left-aligned by default</td>
</tr>
<tr>
 <td style="text-align: left;">
  plot.subtitle    </td><td style="text-align: left;"> plot subtitle (text appearance)
                   (<code>element_text</code>; inherits from <code>title</code>)
                   left-aligned by default</td>
</tr>
<tr>
 <td style="text-align: left;">
  plot.caption     </td><td style="text-align: left;"> caption below the plot (text appearance)
                   (<code>element_text</code>; inherits from <code>title</code>)
                   right-aligned by default</td>
</tr>
<tr>
 <td style="text-align: left;">
  plot.margin      </td><td style="text-align: left;"> margin around entire plot
                   (<code>unit</code> with the sizes of the top, right, bottom, and
                    left margins) </td>
</tr>
<tr>
 <td style="text-align: left;">

  strip.background </td><td style="text-align: left;"> background of facet labels
                   (<code>element_rect</code>; inherits from <code>rect</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  strip.text       </td><td style="text-align: left;"> facet labels
                   (<code>element_text</code>; inherits from <code>text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  strip.text.x     </td><td style="text-align: left;"> facet labels along horizontal direction
                   (<code>element_text</code>; inherits from <code>strip.text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  strip.text.y     </td><td style="text-align: left;"> facet labels along vertical direction
                   (<code>element_text</code>; inherits from <code>strip.text</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  strip.switch.pad.grid </td><td style="text-align: left;"> space between strips and axes when strips are switched
                   (<code>unit</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  strip.switch.pad.wrap </td><td style="text-align: left;"> space between strips and axes when strips are switched
                   (<code>unit</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic++25+2Breplace+25">%+replace%</a></code>
</p>
<p><code><a href="#topic+rel">rel</a></code>
</p>
<p><code><a href="#topic+element_blank">element_blank</a></code>
</p>
<p><code><a href="#topic+element_line">element_line</a></code>
</p>
<p><code><a href="#topic+element_rect">element_rect</a></code>
</p>
<p><code><a href="#topic+element_text">element_text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point()
p
p + theme(panel.background = element_rect(colour = "pink"))
p + theme_bw()

# Scatter plot of gas mileage by vehicle weight
p &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point()
# Calculate slope and intercept of line of best fit
coef(lm(mpg ~ wt, data = mtcars))
p + geom_abline(intercept = 37, slope = -5)
# Calculate correlation coefficient
with(mtcars, cor(wt, mpg, use = "everything", method = "pearson"))
#annotate the plot
p + geom_abline(intercept = 37, slope = -5) +
geom_text(data = data.frame(), aes(4.5, 30, label = "Pearson-R = -.87"))

# Change the axis labels
# Original plot
p
p + labs(x = "Vehicle Weight", y = "Miles per Gallon")
# Or
p + labs(x = "Vehicle Weight", y = "Miles per Gallon")

# Change title appearance
p &lt;- p + labs(title = "Vehicle Weight-Gas Mileage Relationship")
# Set title to twice the base font size
p + theme(plot.title = element_text(size = rel(2)))
p + theme(plot.title = element_text(size = rel(2), colour = "blue"))

# Add a subtitle and adjust bottom margin
p + labs(title = "Vehicle Weight-Gas Mileage Relationship",
         subtitle = "You need to wrap long subtitleson manually") +
    theme(plot.subtitle = element_text(margin = margin(b = 20)))

# Changing plot look with themes
DF &lt;- data.frame(x = rnorm(400))
m &lt;- ggplot(DF, aes(x = x)) +
  geom_histogram()
# Default is theme_grey()
m
# Compare with
m + theme_bw()

# Manipulate Axis Attributes
m + theme(axis.line = element_line(size = 3, colour = "red", linetype = "dotted"))
m + theme(axis.text = element_text(colour = "blue"))
m + theme(axis.text.y = element_blank())
m + theme(axis.ticks = element_line(size = 2))
m + theme(axis.title.y = element_text(size = rel(1.5), angle = 90))
m + theme(axis.title.x = element_blank())
m + theme(axis.ticks.length = unit(.85, "cm"))

# Legend Attributes
z &lt;- ggplot(mtcars, aes(wt, mpg)) +
  geom_point(aes(colour = factor(cyl)))
z
z + theme(legend.position = "none")
z + theme(legend.position = "bottom")
# Or use relative coordinates between 0 and 1
z + theme(legend.position = c(.5, .5))
# Add a border to the whole legend
z + theme(legend.background = element_rect(colour = "black"))
# Legend margin controls extra space around outside of legend:
z + theme(legend.background = element_rect(),
          legend.margin = unit(1, "cm"))
z + theme(legend.background = element_rect(),
          legend.margin = unit(0, "cm"))
# Or to just the keys
z + theme(legend.key = element_rect(colour = "black"))
z + theme(legend.key = element_rect(fill = "yellow"))
z + theme(legend.key.size = unit(2.5, "cm"))
z + theme(legend.text = element_text(size = 20, colour = "red", angle = 45))
z + theme(legend.title = element_text(face = "italic"))

# To change the title of the legend use the name argument
# in one of the scale options
z + scale_colour_brewer(name = "My Legend")
z + scale_colour_grey(name = "Number of \nCylinders")

# Panel and Plot Attributes
z + theme(panel.background = element_rect(fill = "black"))
z + theme(panel.border = element_rect(linetype = "dashed", colour = "black"))
z + theme(panel.grid.major = element_line(colour = "blue"))
z + theme(panel.grid.minor = element_line(colour = "red", linetype = "dotted"))
z + theme(panel.grid.major = element_line(size = 2))
z + theme(panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank())
z + theme(plot.background = element_rect())
z + theme(plot.background = element_rect(fill = "green"))

# Faceting Attributes
set.seed(4940)
dsmall &lt;- diamonds[sample(nrow(diamonds), 1000), ]
k &lt;- ggplot(dsmall, aes(carat, ..density..)) +
  geom_histogram(binwidth = 0.2) +
  facet_grid(. ~ cut)
k + theme(strip.background = element_rect(colour = "purple", fill = "pink",
                                          size = 3, linetype = "dashed"))
k + theme(strip.text.x = element_text(colour = "red", angle = 45, size = 10,
                                      hjust = 0.5, vjust = 0.5))
k + theme(panel.margin = unit(5, "lines"))
k + theme(panel.margin.y = unit(0, "lines"))

# Put gridlines on top
meanprice &lt;- tapply(diamonds$price, diamonds$cut, mean)
cut &lt;- factor(levels(diamonds$cut), levels = levels(diamonds$cut))
df &lt;- data.frame(meanprice, cut)
g &lt;- ggplot(df, aes(cut, meanprice)) + geom_bar(stat = "identity")
g + geom_bar(stat = "identity") +
    theme(panel.background = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_blank(),
          panel.ontop = TRUE)

# Modify a theme and save it
mytheme &lt;- theme_grey() + theme(plot.title = element_text(colour = "red"))
p + mytheme


</code></pre>

<hr>
<h2 id='theme_animint'>theme for passing animint specific params</h2><span id='topic+theme_animint'></span>

<h3>Description</h3>

<p>Theme without checks. This allows us to write
<code>theme_animint(width=500)</code>, instead of <code>theme(animint.width=500)</code>
which gives an error in ggplot2 because users should be informed
if they mis-type standard theme element
names. https://github.com/hadley/ggplot2/issues/938
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_animint(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_animint_+3A_...">...</code></td>
<td>
<p>theme options such as <code>width</code>. Use <code>update_axes=c("x", "y")</code> to update the axes of plots. Works for single selection variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot theme list with names such as <code>animint.width</code>.
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars$cyl &lt;- as.factor(mtcars$cyl)
p &lt;- ggplot() +
  geom_point(aes(x=wt, y=mpg, colour=cyl),
             data=mtcars) +
  ## set width and height values and update both axes
  theme_animint(width=600, height=600, update_axes=c("x", "y"))
viz &lt;- list(plot=p, selector.types=list(cyl="single"))
animint2dir(viz)
</code></pre>

<hr>
<h2 id='theme_update'>Get, set and update themes.</h2><span id='topic+theme_update'></span><span id='topic+theme_replace'></span><span id='topic+theme_get'></span><span id='topic+theme_set'></span>

<h3>Description</h3>

<p>Use <code>theme_get</code> to get the current theme, and <code>theme_set</code> to
completely override it. <code>theme_update</code> and <code>theme_replace</code> are
shorthands for changing individual elements in the current theme.
<code>theme_update</code> uses the <code>+</code> operator, so that any unspecified
values in the theme element will default to the values they are set in the
theme. <code>theme_replace</code> will completely replace the element, so any
unspecified values will overwrite the current value in the theme with <code>NULL</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_update(...)

theme_replace(...)

theme_get()

theme_set(new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_update_+3A_...">...</code></td>
<td>
<p>named list of theme settings</p>
</td></tr>
<tr><td><code id="theme_update_+3A_new">new</code></td>
<td>
<p>new theme (a list of theme elements)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic++25+2Breplace+25">%+replace%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) +
  geom_point()
p
old &lt;- theme_set(theme_bw())
p
theme_set(old)
p

#theme_replace NULLs out the fill attribute of panel.background,
#resulting in a white background:
theme_get()$panel.background
old &lt;- theme_replace(panel.background = element_rect(colour = "pink"))
theme_get()$panel.background
p
theme_set(old)

#theme_update only changes the colour attribute, leaving the others intact:
old &lt;- theme_update(panel.background = element_rect(colour = "pink"))
theme_get()$panel.background
p
theme_set(old)

theme_get()


ggplot(mtcars, aes(mpg, wt)) +
  geom_point(aes(color = mpg)) +
  theme(legend.position = c(0.95, 0.95),
        legend.justification = c(1, 1))
last_plot() +
 theme(legend.background = element_rect(fill = "white", colour = "white", size = 3))

</code></pre>

<hr>
<h2 id='toRGB'>Convert R colors to RGB hexadecimal color values</h2><span id='topic+toRGB'></span>

<h3>Description</h3>

<p>Convert R colors to RGB hexadecimal color values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toRGB(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toRGB_+3A_x">x</code></td>
<td>
<p>character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hexadecimal color value or &quot;transparent&quot; if is.na
</p>

<hr>
<h2 id='train_position'>Train position scales with data</h2><span id='topic+train_position'></span>

<h3>Description</h3>

<p>If panel-specific scales are not already present, will clone from
the scales provided in the parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_position(panel, data, x_scale, y_scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_position_+3A_panel">panel</code></td>
<td>
<p>the panel object to train</p>
</td></tr>
<tr><td><code id="train_position_+3A_data">data</code></td>
<td>
<p>a list of data frames (one for each layer)</p>
</td></tr>
<tr><td><code id="train_position_+3A_x_scale">x_scale</code></td>
<td>
<p>x scale for the plot</p>
</td></tr>
<tr><td><code id="train_position_+3A_y_scale">y_scale</code></td>
<td>
<p>y scale for the plot</p>
</td></tr>
</table>

<hr>
<h2 id='transform_position'>Convenience function to transform all position variables.</h2><span id='topic+transform_position'></span>

<h3>Description</h3>

<p>Convenience function to transform all position variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_position(df, trans_x = NULL, trans_y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_position_+3A_trans_x">trans_x</code>, <code id="transform_position_+3A_trans_y">trans_y</code></td>
<td>
<p>Transformation functions for x and y aesthetics.
(will transform x, xmin, xmax, xend etc)</p>
</td></tr>
<tr><td><code id="transform_position_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>trans_x</code> and <code>trans_y</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='transform_shape'>Function to transform R shapes into d3 shapes...</h2><span id='topic+transform_shape'></span>

<h3>Description</h3>

<p>Function to transform R shapes into d3 shapes...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_shape(dframe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_shape_+3A_dframe">dframe</code></td>
<td>
<p>Data frame with columns shape, fill, colour.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame transformed so that shape corresponds to d3 shape. Also includes Rshape column for debugging.
</p>

<hr>
<h2 id='translate_qplot_ggplot'>Translating between qplot and ggplot</h2><span id='topic+translate_qplot_ggplot'></span>

<h3>Description</h3>

<p>Within ggplot2, there are two basic methods to create plots, with qplot()
and ggplot(). qplot() is designed primarily for interactive use: it makes
a number of assumptions that speed most cases, but when designing multilayered
plots with different data sources it can get in the way. This section
describes what those defaults are, and how they map to the fuller ggplot()
syntax.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# By default, qplot() assumes that you want a scatterplot,
# i.e., you want to use geom_point()
# qplot(x, y, data = data)
# ggplot(data, aes(x, y)) + geom_point()

# Using Aesthetics

# If you map additional aesthetics, these will be added to the defaults. With
# qplot() there is no way to use different aesthetic mappings (or data) in
# different layers
# qplot(x, y, data = data, shape = shape, colour = colour)
# ggplot(data, aes(x, y, shape = shape, colour = colour)) + geom_point()
#
# Aesthetic parameters in qplot() always try to map the aesthetic to a
# variable. If the argument is not a variable but a value, effectively a new column
# is added to the original dataset with that value. To set an aesthetic to a
# value and override the default appearance, you surround the value with I() in
# qplot(), or pass it as a parameter to the layer.
# qplot(x, y, data = data, colour = I("red"))
# ggplot(data, aes(x, y)) + geom_point(colour = "red")

# Changing the geom parameter changes the geom added to the plot
# qplot(x, y, data = data, geom = "line")
# ggplot(data, aes(x, y)) + geom_line()

# Not all geoms require both x and y, e.g., geom_bar() and geom_histogram().
# For these two geoms, if the y aesthetic is not supplied, both qplot and
# ggplot commands default to "count" on the y-axis
# ggplot(data, aes(x)) + geom_bar()
# qplot(x, data = data, geom = "bar")

# If a vector of multiple geom names is supplied to the geom argument, each
# geom will be added in turn
# qplot(x, y, data = data, geom = c("point", "smooth"))
# ggplot(data, aes(x, y)) + geom_point() + geom_smooth()

# Unlike the rest of ggplot2, stats and geoms are independent
# qplot(x, y, data = data, stat = "bin")
# ggplot(data, aes(x, y)) + geom_point(stat = "bin")
#
# Any layer parameters will be passed on to all layers. Most layers will ignore
# parameters that they don't need
# qplot(x, y, data = data, geom = c("point", "smooth"), method = "lm")
# ggplot(data, aes(x, y)) + geom_point(method = "lm") + geom_smooth(method = "lm")

# Scales and axes

# You can control basic properties of the x and y scales with the xlim, ylim,
# xlab and ylab arguments
# qplot(x, y, data = data, xlim = c(1, 5), xlab = "my label")
# ggplot(data, aes(x, y)) + geom_point() +
# scale_x_continuous("my label", limits = c(1, 5))

# qplot(x, y, data = data, xlim = c(1, 5), ylim = c(10, 20))
# ggplot(data, aes(x, y)) + geom_point() +
# scale_x_continuous(limits = c(1, 5)) + scale_y_continuous(limits = c(10, 20))

# Like plot(), qplot() has a convenient way of log transforming the axes.
# qplot(x, y, data = data, log = "xy")
# ggplot(data, aes(x, y)) + geom_point() + scale_x_log10() + scale_y_log10()
# There are many other possible transformations, but not all are
# accessible from within qplot(), see ?scale_continuous for more

# Plot options

# qplot() recognises the same options as plot does, and converts them to their
# ggplot2 equivalents. See ?theme for more on ggplot options
# qplot(x, y, data = data, main="title", asp = 1)
# ggplot(data, aes(x, y)) + geom_point() + labs(title = "title") + theme(aspect.ratio = 1)
</code></pre>

<hr>
<h2 id='translate_qplot_lattice'>Translating between qplot and lattice</h2><span id='topic+translate_qplot_lattice'></span>

<h3>Description</h3>

<p>The major difference between lattice and ggplot2 is that lattice uses a
formula based interface. ggplot2 does not because the formula does not
generalise well to more complicated situations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lattice)

if (require("ggplot2movies")) {
xyplot(rating ~ year, data=movies)
qplot(year, rating, data=movies)

xyplot(rating ~ year | Comedy + Action, data = movies)
qplot(year, rating, data = movies, facets = ~ Comedy + Action)
# Or maybe
qplot(year, rating, data = movies, facets = Comedy ~ Action)

# While lattice has many different functions to produce different types of
# graphics (which are all basically equivalent to setting the panel argument),
# ggplot2 has qplot().

stripplot(~ rating, data = movies, jitter.data = TRUE)
qplot(rating, 1, data = movies, geom = "jitter")

histogram(~ rating, data = movies)
qplot(rating, data = movies, geom = "histogram")

xyplot(wt ~ mpg, mtcars, type = c("p","smooth"))
qplot(mpg, wt, data = mtcars, geom = c("point","smooth"))
}

# The capabilities for scale manipulations are similar in both ggplot2 and
# lattice, although the syntax is a little different.

xyplot(wt ~ mpg | cyl, mtcars, scales = list(y = list(relation = "free")))
qplot(mpg, wt, data = mtcars) + facet_wrap(~ cyl, scales = "free")

xyplot(wt ~ mpg | cyl, mtcars, scales = list(log = 10))
qplot(mpg, wt, data = mtcars, log = "xy")

xyplot(wt ~ mpg | cyl, mtcars, scales = list(log = 2))
qplot(mpg, wt, data = mtcars) +
  scale_x_continuous(trans = scales::log2_trans()) +
  scale_y_continuous(trans = scales::log2_trans())

xyplot(wt ~ mpg, mtcars, group = cyl, auto.key = TRUE)
# Map directly to an aesthetic like colour, size, or shape.
qplot(mpg, wt, data = mtcars, colour = cyl)

xyplot(wt ~ mpg, mtcars, xlim = c(20,30))
# Works like lattice, except you can't specify a different limit
# for each panel/facet
qplot(mpg, wt, data = mtcars, xlim = c(20,30))

# Both lattice and ggplot2 have similar options for controlling labels on the plot.

xyplot(wt ~ mpg, mtcars, xlab = "Miles per gallon", ylab = "Weight",
  main = "Weight-efficiency tradeoff")
qplot(mpg, wt, data = mtcars, xlab = "Miles per gallon", ylab = "Weight",
  main = "Weight-efficiency tradeoff")

xyplot(wt ~ mpg, mtcars, aspect = 1)
qplot(mpg, wt, data = mtcars, asp = 1)

# par.settings() is equivalent to + theme() and trellis.options.set()
# and trellis.par.get() to theme_set() and theme_get().
# More complicated lattice formulas are equivalent to rearranging the data
# before using ggplot2.

</code></pre>

<hr>
<h2 id='txhousing'>Housing sales in TX.</h2><span id='topic+txhousing'></span>

<h3>Description</h3>

<p>Information about the housing market in Texas provided by the TAMU
real estate center, <a href="https://www.recenter.tamu.edu/">https://www.recenter.tamu.edu/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>txhousing
</code></pre>


<h3>Format</h3>

<p>A data frame with 8602 observations and 9 variables:
</p>

<dl>
<dt>city</dt><dd><p>Name of MLS area</p>
</dd>
<dt>year,month,date</dt><dd><p>Date</p>
</dd>
<dt>sales</dt><dd><p>Number of sales</p>
</dd>
<dt>volume</dt><dd><p>Total value of sales</p>
</dd>
<dt>median</dt><dd><p>Median sale price</p>
</dd>
<dt>listings</dt><dd><p>Total active listings</p>
</dd>
<dt>inventory</dt><dd><p>&quot;Months inventory&quot;: amount of time it would take to sell
all current listings at current pace of sales.</p>
</dd>
</dl>


<hr>
<h2 id='update_gallery'>Update gallery</h2><span id='topic+update_gallery'></span>

<h3>Description</h3>

<p>A gallery is a collection of meta-data about animints that have
been published to github pages. A gallery is defined as a github
repo that should have two source files in the gh-pages branch:
repos.txt (list of github repositories, one owner/repo per line)
and index.Rmd (source for web page with links to animints). To
perform the update, first repos.txt is read, then we clone each
repo which is not already present in meta.csv, and parse meta-data
(title, source, Capture.PNG) from the gh-pages branch, and write
the meta.csv/error.csv/Capture.PNG files, render index.Rmd to
index.html, commit, and push origin. For an example, see the main
gallery, <a href="https://github.com/animint/gallery/tree/gh-pages">https://github.com/animint/gallery/tree/gh-pages</a>
which is updated using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_gallery(gallery_path = "~/R/gallery")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_gallery_+3A_gallery_path">gallery_path</code></td>
<td>
<p>path to local github repo with gh-pages
active.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of data tables (meta and error).
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>

<hr>
<h2 id='update_geom_defaults'>Modify geom/stat aesthetic defaults for future plots</h2><span id='topic+update_geom_defaults'></span><span id='topic+update_stat_defaults'></span>

<h3>Description</h3>

<p>Modify geom/stat aesthetic defaults for future plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_geom_defaults(geom, new)

update_stat_defaults(stat, new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_geom_defaults_+3A_new">new</code></td>
<td>
<p>Named list of aesthetics.</p>
</td></tr>
<tr><td><code id="update_geom_defaults_+3A_stat">stat</code>, <code id="update_geom_defaults_+3A_geom">geom</code></td>
<td>
<p>Name of geom/stat to modify (like <code>"point"</code> or
<code>"bin"</code>), or a Geom/Stat object (like <code>GeomPoint</code> or
<code>StatBin</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>update_geom_defaults("point", list(colour = "darkblue"))
ggplot(mtcars, aes(mpg, wt)) + geom_point()
update_geom_defaults("point", list(colour = "black"))
</code></pre>

<hr>
<h2 id='update_labels'>Update axis/legend labels</h2><span id='topic+update_labels'></span>

<h3>Description</h3>

<p>Update axis/legend labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_labels(p, labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_labels_+3A_p">p</code></td>
<td>
<p>plot to modify</p>
</td></tr>
<tr><td><code id="update_labels_+3A_labels">labels</code></td>
<td>
<p>named list of new labels</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- ggplot(mtcars, aes(mpg, wt)) + geom_point()
update_labels(p, list(x = "New x"))
update_labels(p, list(x = expression(x / y ^ 2)))
update_labels(p, list(x = "New x", y = "New Y"))
update_labels(p, list(colour = "Fail silently"))
</code></pre>

<hr>
<h2 id='UStornadoes'>
Tornadoes in the United States from 1950 to 2012
</h2><span id='topic+UStornadoes'></span>

<h3>Description</h3>

<p>Each row documents 1 tornado.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(UStornadoes)</code></pre>


<h3>Format</h3>

<p>A data frame with 41620 observations on the following 32 variables.
</p>

<dl>
<dt><code>fips</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>ID</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>year</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>month</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>day</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>date</code></dt><dd><p>factor</p>
</dd>
<dt><code>time</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>tz</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>state</code></dt><dd><p>factor</p>
</dd>
<dt><code>state.tnum</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>f</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>injuries</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fatalities</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>propertyLoss</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>cropLoss</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>startLat</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>startLong</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>endLat</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>endLong</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>trackLength</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>trackWidth</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>numStatesAffected</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>stateNumber</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>segmentNumber</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>FipsCounty1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>FipsCounty2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>FipsCounty3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>FipsCounty4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>TotalPop2012</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>LandArea</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>TornadoesSqMile</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>weight</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>NOAA SVRGIS data (Severe Report Database + Geographic Information System)
http://www.spc.noaa.gov/gis/svrgis/
</p>

<hr>
<h2 id='varied.chunk'>Extract subset for each data.frame in a list of data.frame</h2><span id='topic+varied.chunk'></span>

<h3>Description</h3>

<p>Extract subset for each data.frame in a list of data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varied.chunk(dt.or.list, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varied.chunk_+3A_dt.or.list">dt.or.list</code></td>
<td>
<p>a data.table or a list of data.table.</p>
</td></tr>
<tr><td><code id="varied.chunk_+3A_cols">cols</code></td>
<td>
<p>cols that each data.frame would keep.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data.frame.
</p>

<hr>
<h2 id='waiver'>A waiver object.</h2><span id='topic+waiver'></span>

<h3>Description</h3>

<p>A waiver is a &quot;flag&quot; object, similar to <code>NULL</code>, that indicates the
calling function should just use the default value.  It is used in certain
functions to distinguish between displaying nothing (<code>NULL</code>) and
displaying a default value calculated elsewhere (<code>waiver()</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waiver()
</code></pre>

<hr>
<h2 id='WorldBank'>
Demographics by country from 1960 to 2012
</h2><span id='topic+WorldBank'></span>

<h3>Description</h3>

<p>Each row is one year of demographics for one country.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(WorldBank)</code></pre>


<h3>Format</h3>

<p>A data frame with 11342 observations on the following 15 variables.
</p>

<dl>
<dt><code>iso2c</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>country</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>year</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fertility.rate</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>life.expectancy</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>population</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GDP.per.capita.Current.USD</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>15.to.25.yr.female.literacy</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>iso3c</code></dt><dd><p>factor</p>
</dd>
<dt><code>region</code></dt><dd><p>factor</p>
</dd>
<dt><code>capital</code></dt><dd><p>factor</p>
</dd>
<dt><code>longitude</code></dt><dd><p>factor</p>
</dd>
<dt><code>latitude</code></dt><dd><p>factor</p>
</dd>
<dt><code>income</code></dt><dd><p>factor</p>
</dd>
<dt><code>lending</code></dt><dd><p>factor</p>
</dd>
</dl>



<h3>Source</h3>

<p>Copied from the googleVis package.
</p>

<hr>
<h2 id='worldPop'>
World population by subcontinent
</h2><span id='topic+worldPop'></span>

<h3>Description</h3>

<p>World population data are used as a simple example on the polychart.js
website, and so these data can be used to recreate that example using animint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(worldPop)</code></pre>


<h3>Format</h3>

<p>A data frame with 294 observations on the following 4 variables.
</p>

<dl>
<dt><code>subcontinent</code></dt><dd><p>factor: the subcontinent name</p>
</dd>
<dt><code>year</code></dt><dd><p>integer: year of measurement</p>
</dd>
<dt><code>population</code></dt><dd><p>integer: number of people in that
subcontinent during that year</p>
</dd>
<dt><code>type</code></dt><dd><p>factor with levels <code>actual</code> <code>estimate</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>https://github.com/Polychart/polychart2/blob/master/example/population.coffee
</p>

<hr>
<h2 id='zeroGrob'>The zero grob draws nothing and has zero size.</h2><span id='topic+zeroGrob'></span>

<h3>Description</h3>

<p>The zero grob draws nothing and has zero size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroGrob()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
