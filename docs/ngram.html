<!DOCTYPE html><html><head><title>Help for package ngram</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ngram}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ngram-package'><p>ngram: Fast n-Gram Tokenization</p></a></li>
<li><a href='#babble'><p>ngram Babbler</p></a></li>
<li><a href='#concatenate'><p>Concatenate</p></a></li>
<li><a href='#getseed'><p>getseed</p></a></li>
<li><a href='#getters'><p>ngram Getters</p></a></li>
<li><a href='#multiread'><p>Multiread</p></a></li>
<li><a href='#ngram'><p>n-gram Tokenization</p></a></li>
<li><a href='#ngram-class'><p>Class ngram</p></a></li>
<li><a href='#ngram-print'><p>ngram printing</p></a></li>
<li><a href='#phrasetable'><p>Get Phrasetable</p></a></li>
<li><a href='#preprocess'><p>Basic Text Preprocessor</p></a></li>
<li><a href='#rcorpus'><p>Random Corpus</p></a></li>
<li><a href='#splitter'><p>Character Splitter</p></a></li>
<li><a href='#string.summary'><p>Text Summary</p></a></li>
<li><a href='#Tokenize-AsWeka'><p>Weka-like n-gram Tokenization</p></a></li>
<li><a href='#wordcount'><p>wordcount</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast n-Gram 'Tokenization'</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>An n-gram is a sequence of n "words" taken, in order, from a
    body of text.  This is a collection of utilities for creating,
    displaying, summarizing, and "babbling" n-grams.  The
    'tokenization' and "babbling" are handled by very efficient C
    code, which can even be built as its own standalone library.
    The babbler is a simple Markov chain.  The package also offers
    a vignette with complete example 'workflows' and information about
    the utilities offered in the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD 2-clause License</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Drew Schmidt &lt;wrathematics@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wrathematics/ngram">https://github.com/wrathematics/ngram</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wrathematics/ngram/issues">https://github.com/wrathematics/ngram/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 18:38:15 UTC; mschmid3</td>
</tr>
<tr>
<td>Author:</td>
<td>Drew Schmidt [aut, cre],
  Christian Heckendorf [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ngram-package'>ngram: Fast n-Gram Tokenization</h2><span id='topic+ngram-package'></span>

<h3>Description</h3>

<p>An n-gram is a sequence of n &quot;words&quot; taken from a
body of text.  This package offers utilities for creating, 
displaying, summarizing, and &quot;babbling&quot; n-grams.  The 
tokenization and &quot;babbling&quot; are handled by very efficient C
code, which can even be build as its own standalone library.
The babbler is a simple Markov chain.
</p>


<h3>Details</h3>

<p>The ngram package is distributed under the permissive 2-clause BSD license.
If you find the code here useful, please let us know and/or cite the
package, whatever is appropriate.
</p>
<p>The package has its own PRNG; we use an implementation of MT1997 for all
non-deterministic choices.
</p>

<hr>
<h2 id='babble'>ngram Babbler</h2><span id='topic+babble'></span><span id='topic+babble+2Cngram-method'></span>

<h3>Description</h3>

<p>The babbler uses its own internal PRNG (i.e., not R's), so seeds cannot be
managed as with R's seeds.  The generator is an implementation of MT19937.
</p>
<p>At this time, we note that the seed may not guarantee the same results
across machines. Currently only Solaris produces different values from
mainstream platforms (Windows, Mac, Linux, FreeBSD), but potentially others
could as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>babble(ng, genlen = 150, seed = getseed())

## S4 method for signature 'ngram'
babble(ng, genlen = 150, seed = getseed())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="babble_+3A_ng">ng</code></td>
<td>
<p>An ngram object.</p>
</td></tr>
<tr><td><code id="babble_+3A_genlen">genlen</code></td>
<td>
<p>Generated length, i.e., the number of words to babble.</p>
</td></tr>
<tr><td><code id="babble_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A markov chain babbler.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ngram">ngram</a></code>, <code><a href="#topic+getseed">getseed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ngram)

str = "A B A C A B B"
ng = ngram(str)
babble(ng, genlen=5, seed=1234)

</code></pre>

<hr>
<h2 id='concatenate'>Concatenate</h2><span id='topic+concatenate'></span>

<h3>Description</h3>

<p>A quick utility for concatenating strings together.  This is
handy because if you want to generate the n-grams for several different
texts, you must first put them into a single string unless the text is
composed of sentences that should not be joined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concatenate(..., collapse = " ", rm.space = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concatenate_+3A_...">...</code></td>
<td>
<p>Input text(s).</p>
</td></tr>
<tr><td><code id="concatenate_+3A_collapse">collapse</code></td>
<td>
<p>A character to separate the input strings if a vector of
strings is supplied; otherwise this does nothing.</p>
</td></tr>
<tr><td><code id="concatenate_+3A_rm.space">rm.space</code></td>
<td>
<p>logical; determines if spaces should be removed from the
final string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+preprocess">preprocess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ngram)

words = c("a", "b", "c")
wordcount(words)
str = concatenate(words)
wordcount(str)

</code></pre>

<hr>
<h2 id='getseed'>getseed</h2><span id='topic+getseed'></span>

<h3>Description</h3>

<p>A seed generator for use with the ngram package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getseed()
</code></pre>


<h3>Details</h3>

<p>Uses a 96-bit hash of the current process id, time, and a random
uniform value from R's random generator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+babble">babble</a></code>
</p>

<hr>
<h2 id='getters'>ngram Getters</h2><span id='topic+getters'></span><span id='topic+ng_order'></span><span id='topic+ng_order+2Cngram-method'></span><span id='topic+get.ngrams'></span><span id='topic+get.ngrams+2Cngram-method'></span><span id='topic+get.string'></span><span id='topic+get.string+2Cngram-method'></span><span id='topic+get.nextwords'></span><span id='topic+get.nextwords+2Cngram-method'></span>

<h3>Description</h3>

<p>Some simple &quot;getters&quot; for <code>ngram</code> objects. Necessary since the internal
representation is not a native R object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ng_order(ng, decreasing = FALSE)

## S4 method for signature 'ngram'
ng_order(ng, decreasing = FALSE)

get.ngrams(ng)

## S4 method for signature 'ngram'
get.ngrams(ng)

get.string(ng)

## S4 method for signature 'ngram'
get.string(ng)

get.nextwords(ng)

## S4 method for signature 'ngram'
get.nextwords(ng)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getters_+3A_ng">ng</code></td>
<td>
<p>An ngram object.</p>
</td></tr>
<tr><td><code id="getters_+3A_decreasing">decreasing</code></td>
<td>
<p>Should the sorted order be in descending order?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ngram.order</code> returns an R vector with the original corpus order of the ngrams.
</p>
<p><code>get.ngrams()</code> returns an R vector of all n-grams.
</p>
<p><code>get.nextwords()</code> does nothing at the moment; it will be implemented in
future releases.
</p>
<p><code>getnstring()</code> recovers the input string as an R string.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ngram-class">ngram-class</a></code>, <code><a href="#topic+ngram">ngram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ngram)

str = "A B A C A B B"
ng = ngram(str)
get.ngrams(ng)[ng_order(ng)]

</code></pre>

<hr>
<h2 id='multiread'>Multiread</h2><span id='topic+multiread'></span>

<h3>Description</h3>

<p>Read in a collection of text files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiread(
  path = ".",
  extension = "txt",
  recursive = FALSE,
  ignore.case = FALSE,
  prune.empty = TRUE,
  pathnames = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiread_+3A_path">path</code></td>
<td>
<p>The base file path to search.</p>
</td></tr>
<tr><td><code id="multiread_+3A_extension">extension</code></td>
<td>
<p>An extension or the &quot;*&quot; wildcard (for everything).  For example, 
to read in files ending <code>.txt</code>, you could specify 
<code>extension="txt"</code>.  For the purposes of this function,
each of <code>*.txt</code>, <code>*txt</code>, <code>.txt</code>, and <code>txt</code>
are treated the same.</p>
</td></tr>
<tr><td><code id="multiread_+3A_recursive">recursive</code></td>
<td>
<p>Logical; should the search include all subdirectories?</p>
</td></tr>
<tr><td><code id="multiread_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical; should case be ignored in the extension? For example, if
<code>TRUE</code>, then <code>.r</code> and <code>.R</code> files are treated the
same.</p>
</td></tr>
<tr><td><code id="multiread_+3A_prune.empty">prune.empty</code></td>
<td>
<p>Logical; should empty files be removed from the returned list?</p>
</td></tr>
<tr><td><code id="multiread_+3A_pathnames">pathnames</code></td>
<td>
<p>Logical; should the full path be included in the names of the
returned list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>extension</code> argument is not a general regular
expression pattern, but a simplified pattern.  For example,
the pattern <code>*.txt</code> is really equivalent to 
<code>*[.]txt$</code> as a regular expression.  If you need more
complicated patterns, you should directly use the <code>dir()</code>
function.
</p>


<h3>Value</h3>

<p>A named list of strings, where the names are the file names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path = system.file(package="ngram")

### Read all files in the base path
multiread(path, extension="*")

### Read all .r/.R files recursively (warning: lots of text)
multiread(path, extension="r", recursive=TRUE, ignore.case=TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='ngram'>n-gram Tokenization</h2><span id='topic+ngram'></span><span id='topic+tokenize'></span>

<h3>Description</h3>

<p>The <code>ngram()</code> function is the main workhorse of this package.  It takes
an input string and converts it into the internal n-gram representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngram(str, n = 2, sep = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngram_+3A_str">str</code></td>
<td>
<p>The input text.</p>
</td></tr>
<tr><td><code id="ngram_+3A_n">n</code></td>
<td>
<p>The 'n' as in 'n-gram'.</p>
</td></tr>
<tr><td><code id="ngram_+3A_sep">sep</code></td>
<td>
<p>A set of separator characters for the &quot;words&quot;.  See details for
information about how this works; it works a little differently
from <code>sep</code> arguments in R functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On evaluation, a copy of the input string is produced and stored as an
external pointer.  This is necessary because the internal list
representation just points to the first char of each word in the input
string.  So if you (or R's gc) deletes the input string, basically all hell
breaks loose.
</p>
<p>The <code>sep</code> parameter splits at any of the characters in 
the string.  So <code>sep=", "</code> splits at a comma or a space.
</p>


<h3>Value</h3>

<p>An <code>ngram</code> class object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ngram-class">ngram-class</a></code>, <code><a href="#topic+getters">getters</a></code>, 
<code><a href="#topic+phrasetable">phrasetable</a></code>, <code><a href="#topic+babble">babble</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ngram)

str = "A B A C A B B"
ngram(str, n=2)

str = "A,B,A,C A B B"
### Split at a space
print(ngram(str), output="full")
### Split at a comma
print(ngram(str, sep=","), output="full")
### Split at a space or a comma
print(ngram(str, sep=", "), output="full")

</code></pre>

<hr>
<h2 id='ngram-class'>Class ngram</h2><span id='topic+ngram-class'></span>

<h3>Description</h3>

<p>An n-gram is an ordered sequence of n &quot;words&quot; taken from a body of &quot;text&quot;.
The terms &quot;words&quot; and &quot;text&quot; can easily be interpreted literally, or with a
more loose interpretation.
</p>


<h3>Details</h3>

<p>For example, consider the sequence &quot;A B A C A B B&quot;.  If we examine the
2-grams (or bigrams) of this sequence, they are
</p>
<p>A B, B A, A C, C A, A B, B B
</p>
<p>or without repetition:
</p>
<p>A B, B A, A C, C A, B B
</p>
<p>That is, we take the input string and group the &quot;words&quot; 2 at a time (because
<code>n=2</code>).  Notice that the number of n-grams and the number of words are
not obviously related; counting repetition, the number of n-grams is equal
to
</p>
<p><code>nwords - n + 1</code>
</p>
<p>Bounds ignoring repetition are highly dependent on the input.  A correct but
useless bound is
</p>
<p><code>\#ngrams = nwords - (\#repeats - 1) - (n - 1)</code>
</p>
<p>An <code>ngram</code> object is an S4 class container that stores some basic
summary information (e.g., n), and several external pointers.  For
information on how to construct an <code>ngram</code> object, see
<code><a href="#topic+ngram">ngram</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>str_ptr</code></dt><dd><p>A pointer to a copy of the original input string.</p>
</dd>
<dt><code>strlen</code></dt><dd><p>The length of the string.</p>
</dd>
<dt><code>n</code></dt><dd><p>The eponymous 'n' as in 'n-gram'.</p>
</dd>
<dt><code>ngl_ptr</code></dt><dd><p>A pointer to the processed list of n-grams.</p>
</dd>
<dt><code>ngsize</code></dt><dd><p>The length of the ngram list, or in other words, the number of
unique n-grams in the input string.</p>
</dd>
<dt><code>sl_ptr</code></dt><dd><p>A pointer to the list of words from the input string.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+ngram">ngram</a></code>
</p>

<hr>
<h2 id='ngram-print'>ngram printing</h2><span id='topic+ngram-print'></span><span id='topic+print+2Cngram-method'></span><span id='topic+show+2Cngram-method'></span>

<h3>Description</h3>

<p>Print methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ngram'
print(x, output = "summary")

## S4 method for signature 'ngram'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngram-print_+3A_x">x</code>, <code id="ngram-print_+3A_object">object</code></td>
<td>
<p>An ngram object.</p>
</td></tr>
<tr><td><code id="ngram-print_+3A_output">output</code></td>
<td>
<p>a character string; determines what exactly is printed.
Options are &quot;summary&quot;, &quot;truncated&quot;, and &quot;full&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>output=="summary"</code>, then just a simple representation of the n-gram
object will be printed; for example, &quot;An ngram object with 5 2-grams&quot;.
</p>
<p>If <code>output=="truncated"</code>, then the n-grams will be printed up to a
maximum of 5 total.
</p>
<p>If <code>output=="full"</code> then all n-grams will be printed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ngram">ngram</a>, <a href="#topic+babble">babble</a></code>
</p>

<hr>
<h2 id='phrasetable'>Get Phrasetable</h2><span id='topic+phrasetable'></span><span id='topic+get.phrasetable'></span>

<h3>Description</h3>

<p>Get a table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.phrasetable(ng)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phrasetable_+3A_ng">ng</code></td>
<td>
<p>An ngram object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ngram-class">ngram-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ngram)

str = "A B A C A B B"
ng = ngram(str)
get.phrasetable(ng)

</code></pre>

<hr>
<h2 id='preprocess'>Basic Text Preprocessor</h2><span id='topic+preprocess'></span>

<h3>Description</h3>

<p>A simple text preprocessor for use with the <code>ngram()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess(
  x,
  case = "lower",
  remove.punct = FALSE,
  remove.numbers = FALSE,
  fix.spacing = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_+3A_x">x</code></td>
<td>
<p>Input text.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_case">case</code></td>
<td>
<p>Option to change the case of the text. Value should be &quot;upper&quot;,
&quot;lower&quot;, or NULL (no change).</p>
</td></tr>
<tr><td><code id="preprocess_+3A_remove.punct">remove.punct</code></td>
<td>
<p>Logical; should punctuation be removed?</p>
</td></tr>
<tr><td><code id="preprocess_+3A_remove.numbers">remove.numbers</code></td>
<td>
<p>Logical; should numbers be removed?</p>
</td></tr>
<tr><td><code id="preprocess_+3A_fix.spacing">fix.spacing</code></td>
<td>
<p>Logical; should multi/trailing spaces be collapsed/removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input text <code>x</code> must already be in the correct form for
<code>ngram()</code>, i.e., a single string (character vector of length 1).
</p>
<p>The <code>case</code> argument can take 3 possible values: <code>NULL</code>, in which
case nothing is done, or <code>lower</code> or <code>upper</code>, wherein the case of
the input text will be made lower/upper case, repesctively.
</p>


<h3>Value</h3>

<p><code>concat()</code> returns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ngram)

x = "Watch  out    for snakes!  111"
preprocess(x)
preprocess(x, remove.punct=TRUE, remove.numbers=TRUE)

</code></pre>

<hr>
<h2 id='rcorpus'>Random Corpus</h2><span id='topic+rcorpus'></span>

<h3>Description</h3>

<p>Generate a corpus of random &quot;words&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcorpus(nwords = 50, alphabet = letters, minwordlen = 1, maxwordlen = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcorpus_+3A_nwords">nwords</code></td>
<td>
<p>Number of words to generate.</p>
</td></tr>
<tr><td><code id="rcorpus_+3A_alphabet">alphabet</code></td>
<td>
<p>The pool of &quot;letters&quot; that word generation coes from.  By default,
it is the lowercase roman alphabet.</p>
</td></tr>
<tr><td><code id="rcorpus_+3A_minwordlen">minwordlen</code>, <code id="rcorpus_+3A_maxwordlen">maxwordlen</code></td>
<td>
<p>The min/max length of words in the generated corpus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcorpus(10)

</code></pre>

<hr>
<h2 id='splitter'>Character Splitter</h2><span id='topic+splitter'></span>

<h3>Description</h3>

<p>A utility function for use with n-gram modeling.  This function
splits a string based on various options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitter(
  string,
  split.char = FALSE,
  split.space = TRUE,
  spacesep = "_",
  split.punct = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitter_+3A_string">string</code></td>
<td>
<p>An input string.</p>
</td></tr>
<tr><td><code id="splitter_+3A_split.char">split.char</code></td>
<td>
<p>Logical; should a split occur after every character?</p>
</td></tr>
<tr><td><code id="splitter_+3A_split.space">split.space</code></td>
<td>
<p>Logical; determines if spaces should be preserved as characters in
the n-gram tokenization.  The character(s) used for spaces are
determined by the <code>spacesep</code> argument.
characters.</p>
</td></tr>
<tr><td><code id="splitter_+3A_spacesep">spacesep</code></td>
<td>
<p>The character(s) to represent a space in the case that
<code>split.space=TRUE</code>.  Should not just be a space(s).</p>
</td></tr>
<tr><td><code id="splitter_+3A_split.punct">split.punct</code></td>
<td>
<p>Logical; determines if splits should occur at punctuation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that choosing <code>split.char=TRUE</code> necessarily implies 
<code>split.punct=TRUE</code> as well &mdash; but <em>not</em> necessarily that
<code>split.space=TRUE</code>.
</p>


<h3>Value</h3>

<p>A string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = "watch out! a snake!"

splitter(x, split.char=TRUE)
splitter(x, split.space=TRUE, spacesep="_")
splitter(x, split.punct=TRUE)


</code></pre>

<hr>
<h2 id='string.summary'>Text Summary</h2><span id='topic+string.summary'></span>

<h3>Description</h3>

<p>Text Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string.summary(string, wordlen_max = 10, senlen_max = 10, syllen_max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string.summary_+3A_string">string</code></td>
<td>
<p>An input string.</p>
</td></tr>
<tr><td><code id="string.summary_+3A_wordlen_max">wordlen_max</code>, <code id="string.summary_+3A_senlen_max">senlen_max</code>, <code id="string.summary_+3A_syllen_max">syllen_max</code></td>
<td>
<p>The maximum lengths of words/sentences/syllables to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>string_summary</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = "a b a c a b b"

string.summary(x)

</code></pre>

<hr>
<h2 id='Tokenize-AsWeka'>Weka-like n-gram Tokenization</h2><span id='topic+Tokenize-AsWeka'></span><span id='topic+ngram_asweka'></span>

<h3>Description</h3>

<p>An n-gram tokenizer with identical output to the <code>NGramTokenizer</code>
function from the RWeka package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngram_asweka(str, min = 2, max = 2, sep = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tokenize-AsWeka_+3A_str">str</code></td>
<td>
<p>The input text.</p>
</td></tr>
<tr><td><code id="Tokenize-AsWeka_+3A_min">min</code>, <code id="Tokenize-AsWeka_+3A_max">max</code></td>
<td>
<p>The minimum and maximum 'n' as in 'n-gram'.</p>
</td></tr>
<tr><td><code id="Tokenize-AsWeka_+3A_sep">sep</code></td>
<td>
<p>A set of separator characters for the &quot;words&quot;.  See details for
information about how this works; it works a little differently
from <code>sep</code> arguments in R functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This n-gram tokenizer behaves similarly in both input and return to 
the tokenizer in RWeka.  Unlike the tokenizer <code>ngram()</code>, the
return is not a special class of external pointers; it is a vector,
and therefore can be serialized via <code>save()</code> or <code>saveRDS()</code>.
</p>


<h3>Value</h3>

<p>A vector of n-grams listed in decreasing blocks of n, in order within a
block.  The output matches that of RWeka's n-gram tokenizer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ngram">ngram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ngram)

str = "A B A C A B B"
ngram_asweka(str, min=2, max=4)

</code></pre>

<hr>
<h2 id='wordcount'>wordcount</h2><span id='topic+wordcount'></span><span id='topic+wordcount.character'></span><span id='topic+wordcount.ngram'></span>

<h3>Description</h3>

<p><code>wordcount()</code> counts words.  Currently a &quot;word&quot; is a clustering of
characters separated from another clustering of charactersby at least 1
space.  That is the law.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wordcount(x, sep = " ", count_fun = sum)

## S3 method for class 'character'
wordcount(x, sep = " ", count_fun = sum)

## S3 method for class 'ngram'
wordcount(x, sep = " ", count_fun = sum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wordcount_+3A_x">x</code></td>
<td>
<p>A string or vector of strings, or an ngram object.</p>
</td></tr>
<tr><td><code id="wordcount_+3A_sep">sep</code></td>
<td>
<p>The characters used to separate words.</p>
</td></tr>
<tr><td><code id="wordcount_+3A_count_fun">count_fun</code></td>
<td>
<p>The function to use for aggregation if <code>x</code> has length greater than 1.
Useful ones include <code>sum</code> and <code>identity</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A count.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+preprocess">preprocess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ngram)

words = c("a", "b", "c")
words
wordcount(words)

str = concatenate(words, collapse="")
str
wordcount(str)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
