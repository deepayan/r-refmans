<!DOCTYPE html><html lang="en"><head><title>Help for package servr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {servr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auth_basic'><p>Generate Basic authentication strings</p></a></li>
<li><a href='#browse_last'><p>Reopen the last browsed page</p></a></li>
<li><a href='#create_server'><p>Create a server</p></a></li>
<li><a href='#daemon_stop'><p>Utilities for daemonized servers</p></a></li>
<li><a href='#httd'><p>Serve static files under a directory</p></a></li>
<li><a href='#jekyll'><p>Serve R Markdown based websites</p></a></li>
<li><a href='#make'><p>Serve files under a directory based on GNU Make</p></a></li>
<li><a href='#random_port'><p>Find a random available TCP port</p></a></li>
<li><a href='#redirect'><p>Create a redirect response</p></a></li>
<li><a href='#serve_example'><p>A convenience function to serve examples in this package</p></a></li>
<li><a href='#server_config'><p>Server configurations</p></a></li>
<li><a href='#vign'><p>Serve R Markdown/HTML package vignettes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Simple HTTP Server to Serve Static Files or Dynamic Documents</td>
</tr>
<tr>
<td>Version:</td>
<td>0.32</td>
</tr>
<tr>
<td>Description:</td>
<td>Start an HTTP server in R to serve static files, or dynamic
    documents that can be converted to HTML files (e.g., R Markdown) under a
    given directory.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mime (&ge; 0.2), httpuv (&ge; 1.5.2), xfun (&ge; 0.48), jsonlite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tools, later, rstudioapi, knitr (&ge; 1.9), rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yihui/servr">https://github.com/yihui/servr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yihui/servr/issues">https://github.com/yihui/servr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-04 15:28:44 UTC; yihui</td>
</tr>
<tr>
<td>Author:</td>
<td>Yihui Xie <a href="https://orcid.org/0000-0003-0645-5666"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Carson Sievert [ctb],
  Jesse Anderson [ctb],
  Ramnath Vaidyanathan [ctb],
  Romain Lesur [ctb],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yihui Xie &lt;xie@yihui.name&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-04 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auth_basic'>Generate Basic authentication strings</h2><span id='topic+auth_basic'></span>

<h3>Description</h3>

<p>Combine usernames with passwords with colons, and generate base64-encoded
strings to be used for user authentication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auth_basic(user, password)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auth_basic_+3A_user">user</code></td>
<td>
<p>A vector of usernames.</p>
</td></tr>
<tr><td><code id="auth_basic_+3A_password">password</code></td>
<td>
<p>A vector of passwords.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of encoded credentials.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>servr::auth_basic("foo", "B@R")
</code></pre>

<hr>
<h2 id='browse_last'>Reopen the last browsed page</h2><span id='topic+browse_last'></span>

<h3>Description</h3>

<p>If you have launched a page in the browser via <span class="pkg">servr</span> but closed it
later, you may call this function to reopen it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>browse_last(open = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="browse_last_+3A_open">open</code></td>
<td>
<p>Whether to reopen the lastly browsed page. If <code>FALSE</code>, the
URL of the previously browsed page will be returned.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>servr::browse_last()
</code></pre>

<hr>
<h2 id='create_server'>Create a server</h2><span id='topic+create_server'></span>

<h3>Description</h3>

<p>Create a server with a custom handler to handle the HTTP request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_server(..., handler, ws_open = function(ws) NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_server_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+server_config">server_config</a>()</code>.</p>
</td></tr>
<tr><td><code id="create_server_+3A_handler">handler</code></td>
<td>
<p>A function that takes the HTTP request and returns a response.</p>
</td></tr>
<tr><td><code id="create_server_+3A_ws_open">ws_open</code></td>
<td>
<p>A function to be called back when a WebSocket connection is
established (see <code>httpuv::<a href="httpuv.html#topic+startServer">startServer</a>()</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# always return 'Success:' followed by the requested path
s = servr::create_server(handler = function(req) {
    list(status = 200L, body = paste("Success:", req$PATH_INFO))
})
s$url

browseURL(paste0(s$url, "/hello"))
browseURL(paste0(s$url, "/world"))

s$stop_server()

</code></pre>

<hr>
<h2 id='daemon_stop'>Utilities for daemonized servers</h2><span id='topic+daemon_stop'></span><span id='topic+daemon_list'></span>

<h3>Description</h3>

<p><code>daemon_list()</code> returns IDs of servers, which can be used to stop the
daemonized servers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daemon_stop(which = daemon_list())

daemon_list()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="daemon_stop_+3A_which">which</code></td>
<td>
<p>A integer vector of the server IDs; by default, IDs of all
existing servers in the current R session obtained from
<code>daemon_list()</code>, i.e., all daemon servers will be stopped by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>daemon_list()</code> returns a list of existing server
IDs, and <code>daemon_stop()</code> returns an invisible <code>NULL</code>.
</p>

<hr>
<h2 id='httd'>Serve static files under a directory</h2><span id='topic+httd'></span><span id='topic+httr'></span><span id='topic+httw'></span>

<h3>Description</h3>

<p>If there is an &lsquo;<span class="file">index.html</span>&rsquo; under this directory, it will be displayed;
otherwise the list of files is displayed, with links on their names. After we
run this function, we can go to &lsquo;<span class="samp">&#8288;http://localhost:port&#8288;</span>&rsquo; to browse the
web pages either created from R or read from HTML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httd(dir = ".", ..., response = NULL)

httr(dir = ".", ...)

httw(
  dir = ".",
  watch = ".",
  pattern = NULL,
  all_files = FALSE,
  filter = NULL,
  handler = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="httd_+3A_dir">dir</code></td>
<td>
<p>The root directory to serve.</p>
</td></tr>
<tr><td><code id="httd_+3A_...">...</code></td>
<td>
<p>Server configurations passed to <code><a href="#topic+server_config">server_config</a>()</code>.</p>
</td></tr>
<tr><td><code id="httd_+3A_response">response</code></td>
<td>
<p>A function of the form <code>function(path, res, ...)</code> that
takes a file path and server response as input, and return a new response.
This can be useful for post-processing the response (for experts only).</p>
</td></tr>
<tr><td><code id="httd_+3A_watch">watch</code></td>
<td>
<p>A directory under which <code>httw()</code> is to watch for changes.
If it is a relative path, it is relative to the <code>dir</code> argument.</p>
</td></tr>
<tr><td><code id="httd_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression passed to <code><a href="base.html#topic+list.files">list.files</a>()</code> to
determine the files to watch.</p>
</td></tr>
<tr><td><code id="httd_+3A_all_files">all_files</code></td>
<td>
<p>Whether to watch all files including the hidden files.</p>
</td></tr>
<tr><td><code id="httd_+3A_filter">filter</code></td>
<td>
<p>A function to filter the file paths returned from
<code>list.files()</code> (e.g., you can exclude certain files from the watch
list).</p>
</td></tr>
<tr><td><code id="httd_+3A_handler">handler</code></td>
<td>
<p>A function to be called every time any files are changed or
added under the directory; its argument is a character vector of the
filenames of the files modified or added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>httd()</code> is a static file server by default (its <code>response</code>
argument can turn it into a dynamic file server).
</p>
<p><code>httr()</code> is based on <code>httd()</code> with a custom
<code>response</code> function that executes R files via <code>xfun::record()</code>,
so that you will see the output of an R script as an HTML page. The page
will be automatically updated when the R script is modified and saved.
</p>
<p><code>httw()</code> is similar to <code>httd()</code> but watches for changes
under the directory: if an HTML file is being viewed in the browser, and
any files are modified under the directory, the HTML page will be
automatically refreshed.
</p>


<h3>References</h3>

<p><a href="https://github.com/yihui/servr">https://github.com/yihui/servr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
servr::httd()

</code></pre>

<hr>
<h2 id='jekyll'>Serve R Markdown based websites</h2><span id='topic+jekyll'></span><span id='topic+rmdv2'></span><span id='topic+rmdv1'></span>

<h3>Description</h3>

<p>R Markdown documents (with the filename extension &lsquo;<span class="file">.Rmd</span>&rsquo;) are
re-compiled using <span class="pkg">knitr</span> or <span class="pkg">rmarkdown</span> when necessary (source files
are newer than output files), and the HTML pages will be automatically
refreshed in the web browser accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jekyll(
  dir = ".",
  input = c(".", "_source", "_posts"),
  output = c(".", "_posts", "_posts"),
  script = c("Makefile", "build.R"),
  serve = TRUE,
  command = "jekyll build",
  ...
)

rmdv2(dir = ".", script = c("Makefile", "build.R"), in_session = FALSE, ...)

rmdv1(dir = ".", script = c("Makefile", "build.R"), in_session = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jekyll_+3A_dir">dir</code></td>
<td>
<p>the root directory of the website</p>
</td></tr>
<tr><td><code id="jekyll_+3A_input">input</code></td>
<td>
<p>the input directories that contain R Markdown documents (the
directories must be relative instead of absolute; same for <code>output</code>
directories)</p>
</td></tr>
<tr><td><code id="jekyll_+3A_output">output</code></td>
<td>
<p>the output directories corresponding to <code>input</code>; for an
input document &lsquo;<span class="file">foo.Rmd</span>&rsquo; under the directory <code>input[i]</code>, its
output document &lsquo;<span class="file">foo.md</span>&rsquo; (or &lsquo;<span class="file">foo.html</span>&rsquo;) is generated under
<code>output[i]</code> if the output document is older than the input document</p>
</td></tr>
<tr><td><code id="jekyll_+3A_script">script</code></td>
<td>
<p>a Makefile (see <code><a href="#topic+make">make</a></code>), or (if Makefile not found)
the name of an R script to re-build R Markdown documents, which will be
executed via command line of the form <code>Rscript build.R arg1 arg2</code>
where <code>build.R</code> is the script specified by this argument, <code>arg1</code>
is the input filename, and <code>arg2</code> is the output filename; inside the R
script, you can use <code><a href="base.html#topic+commandArgs">commandArgs</a>(TRUE)</code> to capture
<code>c(arg1, arg2)</code>, e.g. <code>knitr::knit(commandArgs(TRUE)[1],
commandArgs(TRUE)[2])</code>; if this R script is not found, either, internal
compiling methods will be used, which are basically
<code><a href="knitr.html#topic+knit">knit</a>()</code>, <code><a href="knitr.html#topic+knit2html">knit2html</a>()</code>, or
<code><a href="rmarkdown.html#topic+render">render</a>()</code></p>
</td></tr>
<tr><td><code id="jekyll_+3A_serve">serve</code></td>
<td>
<p>whether to serve the website; if <code>FALSE</code>, the R Markdown
documents and the website will be compiled but not served</p>
</td></tr>
<tr><td><code id="jekyll_+3A_command">command</code></td>
<td>
<p>a command to build the Jekyll website; by default, it is
<code>jekyll build</code>, and you can use alternative commands, such as
<code>bundle exec jekyll build</code></p>
</td></tr>
<tr><td><code id="jekyll_+3A_...">...</code></td>
<td>
<p>Server configurations passed to <code><a href="#topic+server_config">server_config</a>()</code>.</p>
</td></tr>
<tr><td><code id="jekyll_+3A_in_session">in_session</code></td>
<td>
<p>whether to render the R Markdown documents in the current R
session (<code>TRUE</code>) or in a separate new R session (<code>FALSE</code>); if the
former, the argument <code>script</code> can be a function with two arguments,
the filenames of the source document and the output document, respectively;
an internal function (basically <code>rmarkdown::render()</code> or
<code>knitr::knit2html()</code>) will be used if the <code>script</code> argument is
not a function and <code>in_session = TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>jekyll()</code> sets up a web server to serve a Jekyll-based
website. A connection is established between R and the HTML pages through
WebSockets so that R can notify the HTML pages to refresh themselves if any R
Markdown documents have been re-compiled.
</p>
<p>The functions <code>rmdv1()</code> and <code>rmdv2()</code> are similar to
<code>jekyll()</code>, and the only difference is the way to compile R Markdown
documents: <code>rmdv1()</code> uses the <span class="pkg">markdown</span> package (a.k.a R Markdown
v1) via <code><a href="knitr.html#topic+knit2html">knit2html</a>()</code>, and <code>rmdv2()</code> calls
<code><a href="rmarkdown.html#topic+render">render</a>()</code> in the <span class="pkg">rmarkdown</span> package (a.k.a R
Markdown v2).
</p>


<h3>Note</h3>

<p>Apparently <code>jekyll()</code> and <code>rmdv1()</code> require the <span class="pkg">knitr</span>
package, and <code>rmdv2()</code> requires <span class="pkg">rmarkdown</span>. You have to install
them before calling the server functions here.
</p>
<p>All R Markdown documents are compiled in separate R sessions by default. If
you have any R Markdown documents that should not be compiled as standalone
documents (e.g. child documents), you can use different filename
extensions, such as &lsquo;<span class="file">.Rmarkdown</span>&rsquo;.
</p>
<p>The <code>baseurl</code> argument does not work in <code>jekyll()</code>, and the base
URL setting will be read from &lsquo;<span class="file">_config.yml</span>&rsquo; (the &lsquo;<span class="samp">&#8288;baseurl&#8288;</span>&rsquo; field)
of the website if present. You should not pass <code>baseurl</code> to the
function <code>jekyll()</code> directly.
</p>
<p>For the sake of reproducibility, you are recommended to compile each
source document in a separate R session (i.e., use the default
<code>in_session = FALSE</code>) to make sure they can compile on their own,
otherwise the current workspace may affect the evaluation of the code
chunks in these source documents. Sometimes it might be useful to compile a
document in the current R session. For example, if reading data is
time-consuming and it is not convenient to cache it (using the <span class="pkg">knitr</span>
chunk option <code>cache = TRUE</code>), you may read the data once, temporarily
turn off the evaluation of that code chunk, and keep on working on the rest
of code chunks so that data will not be read over and over again.
</p>


<h3>References</h3>

<p>R Markdown v1: <a href="https://cran.r-project.org/package=markdown">https://cran.r-project.org/package=markdown</a>. R
Markdown v2: <a href="https://rmarkdown.rstudio.com">https://rmarkdown.rstudio.com</a>. For Jekyll, see
<a href="https://jekyllrb.com">https://jekyllrb.com</a>. The GitHub repository
<a href="https://github.com/yihui/blogdown-jekyll">https://github.com/yihui/blogdown-jekyll</a> is an example of serving Jekyll
websites with <code>servr::jekyll()</code>.
</p>


<h3>See Also</h3>

<p>The <span class="pkg">blogdown</span> package (based on Hugo and R Markdown v2) is a
better alternative to Jekyll: <a href="https://github.com/rstudio/blogdown/">https://github.com/rstudio/blogdown/</a>. I
strongly recommend you to try it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) servr::rmdv1()  # serve the current dir with R Markdown v1
if (interactive()) servr::rmdv2()  # or R Markdown v2

# built-in examples
servr::serve_example("rmd", servr::rmdv1)
servr::serve_example("rmd", servr::rmdv2)
</code></pre>

<hr>
<h2 id='make'>Serve files under a directory based on GNU Make</h2><span id='topic+make'></span>

<h3>Description</h3>

<p>You can define how and when to rebuild files (such as R Markdown files) using
Make rules, e.g. a rule <code>_posts/%.md: _source/%.Rmd</code> with a command
to build &lsquo;<span class="file">.Rmd</span>&rsquo; to &lsquo;<span class="file">.md</span>&rsquo; will be executed if and only if
&lsquo;<span class="file">foo.Rmd</span>&rsquo; is newer than &lsquo;<span class="file">foo.md</span>&rsquo;. The exit status of the command
<code>make -q</code> will decide whether to rebuild files: rebuilding occurs
only when the exit code is not <code>0</code>. When an HTML file has been rebuilt,
it will be automatically refreshed in the web browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make(dir = ".", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_+3A_dir">dir</code></td>
<td>
<p>The root directory to serve.</p>
</td></tr>
<tr><td><code id="make_+3A_...">...</code></td>
<td>
<p>Server configurations passed to <code><a href="#topic+server_config">server_config</a>()</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>You must have installed GNU Make to use this function. This is normally
not a problem for Linux and OS X users (it should be available by default).
For Windows users, you can either install GNU Make, or just install
<a href="https://cran.r-project.org/bin/windows/Rtools/">Rtools</a>, which also
contains GNU Make.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some built-in examples (if you are not familiar with make, you can take a
# look at the Makefile of each example)
servr::serve_example("make1", servr::make)
servr::serve_example("make2", servr::make)
</code></pre>

<hr>
<h2 id='random_port'>Find a random available TCP port</h2><span id='topic+random_port'></span>

<h3>Description</h3>

<p>Test a series of random TCP ports from 3000 to 8000 (excluding a few that are
considered unsafe by Chrome) and return the first available one. A web server
can be later started on this port.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_port(
  port = 4321L,
  host = getOption("servr.host", "127.0.0.1"),
  n = 20,
  exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_port_+3A_port">port</code></td>
<td>
<p>The preferred port(s).</p>
</td></tr>
<tr><td><code id="random_port_+3A_host">host</code></td>
<td>
<p>A string that is a valid IPv4 address that is owned by this
server, or <code>"0.0.0.0"</code> to listen on all IP addresses.</p>
</td></tr>
<tr><td><code id="random_port_+3A_n">n</code></td>
<td>
<p>The maximum number of random ports to be tested.</p>
</td></tr>
<tr><td><code id="random_port_+3A_exclude">exclude</code></td>
<td>
<p>A vector of port numbers not to be considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A port number, or an error if no ports are available.
</p>

<hr>
<h2 id='redirect'>Create a redirect response</h2><span id='topic+redirect'></span>

<h3>Description</h3>

<p>Create a response to redirect to a destination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redirect(dest, status = 301L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redirect_+3A_dest">dest</code></td>
<td>
<p>A destination path.</p>
</td></tr>
<tr><td><code id="redirect_+3A_status">status</code></td>
<td>
<p>The status code (usually <code>301</code> or <code>302</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>servr::redirect("https://www.r-project.org")
</code></pre>

<hr>
<h2 id='serve_example'>A convenience function to serve examples in this package</h2><span id='topic+serve_example'></span>

<h3>Description</h3>

<p>Use server functions to serve built-in examples of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serve_example(name, FUN, ..., run = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serve_example_+3A_name">name</code></td>
<td>
<p>the directory name of the example under the directory
<code>system.file('examples', package = 'servr')</code></p>
</td></tr>
<tr><td><code id="serve_example_+3A_fun">FUN</code></td>
<td>
<p>a server function that takes the example path as its first
argument, e.g. <code><a href="#topic+httd">httd</a></code>, or <code><a href="#topic+rmdv1">rmdv1</a></code></p>
</td></tr>
<tr><td><code id="serve_example_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="serve_example_+3A_run">run</code></td>
<td>
<p>whether to run the example (this is mainly for <code>R CMD
check</code> purposes: the examples will not be really served when the R session
is not interactive, so they will not block <code>R CMD check</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if <code>run = FALSE</code>, otherwise the value returned from
<code>FUN()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># R Markdown v1 or v2
servr::serve_example("rmd", servr::rmdv1)
servr::serve_example("rmd", servr::rmdv2)

# GNU Make
servr::serve_example("make1", servr::make)
servr::serve_example("make2", servr::make)
</code></pre>

<hr>
<h2 id='server_config'>Server configurations</h2><span id='topic+server_config'></span>

<h3>Description</h3>

<p>The server functions in this package are configured through this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_config(
  dir = ".",
  host = getOption("servr.host", "127.0.0.1"),
  port,
  browser,
  daemon,
  interval = getOption("servr.interval", 1),
  baseurl = "",
  initpath = "",
  hosturl = identity,
  auth = getOption("servr.auth"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="server_config_+3A_dir">dir</code></td>
<td>
<p>The root directory to serve.</p>
</td></tr>
<tr><td><code id="server_config_+3A_host">host</code></td>
<td>
<p>A string that is a valid IPv4 address that is owned by this
server, or <code>"0.0.0.0"</code> to listen on all IP addresses.</p>
</td></tr>
<tr><td><code id="server_config_+3A_port">port</code></td>
<td>
<p>The TCP port number. If it is not explicitly set, the default
value will be looked up in this order: First, the command line argument of
the form <code>-pNNNN</code> (N is a digit from 0 to 9). If it was passed to R
when R was started, <code>NNNN</code> will be used as the port number. Second,
the environment variable <code>R_SERVR_PORT</code>. Third, the global option
<code>servr.port</code> (e.g., <code>options(servr.port = 4322)</code>). If none of
these command-line arguments, variables, or options were set, the default
port will be <code>4321</code>. If this port is not available, a random available
port will be used.</p>
</td></tr>
<tr><td><code id="server_config_+3A_browser">browser</code></td>
<td>
<p>Whether to launch the default web browser. By default, it is
<code>TRUE</code> if the R session is <code><a href="base.html#topic+interactive">interactive</a>()</code>, or when a
command line argument <code>-b</code> was passed to R (see
<code><a href="base.html#topic+commandArgs">commandArgs</a>()</code>). N.B. the RStudio viewer is used as the web
browser if available.</p>
</td></tr>
<tr><td><code id="server_config_+3A_daemon">daemon</code></td>
<td>
<p>Whether to launch a daemonized server (the server does not
block the current R session) or a blocking server. By default, it is the
global option <code>getOption('servr.daemon')</code> (e.g., you can set
<code>options(servr.daemon = TRUE)</code>); if this option was not set,
<code>daemon = TRUE</code> if a command line argument <code>-d</code> was passed to R
(through <code>Rscript</code>), or the server is running in an interactive R
session. Note, however, that even though the server does not block the
current R session, it is running in the same single-threaded process.
Therefore, if a request is made from this same session, the client and
server <em>will</em> block each other. If this is your use case, a better
solution is to use a package such as <code>callr</code> to run a <code>servr</code>
in a separate process, e.g, <code>rx &lt;- callr::r_bg(function()
servr::httd(daemon = FALSE)); do_stuff(); rx$kill()</code> (the
<code>do_stuff()</code> function may want to wait a couple of seconds before
making requests, to allow the server time to start).</p>
</td></tr>
<tr><td><code id="server_config_+3A_interval">interval</code></td>
<td>
<p>The time interval used to check if an HTML page needs to be
rebuilt (by default, it is checked every second).</p>
</td></tr>
<tr><td><code id="server_config_+3A_baseurl">baseurl</code></td>
<td>
<p>The base URL (the full URL will be
<code>http://host:port/baseurl</code>).</p>
</td></tr>
<tr><td><code id="server_config_+3A_initpath">initpath</code></td>
<td>
<p>The initial path in the URL (e.g. you can open a specific
HTML file initially).</p>
</td></tr>
<tr><td><code id="server_config_+3A_hosturl">hosturl</code></td>
<td>
<p>A function that takes the host address and returns a character
string to be used in the URL, e.g., <code>function(host) { if (host ==
'127.0.0.1') 'localhost' else host}</code> to convert <code>127.0.0.1</code> to
<code>localhost</code> in the URL.</p>
</td></tr>
<tr><td><code id="server_config_+3A_auth">auth</code></td>
<td>
<p>A list of the form <code>list(scheme, creds)</code> containing the
authentication scheme and credentials. See
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication</a> for
more info. Please note that this argument is <em>by no means</em> intended
for serious HTTP applications and there is <em>no warranty</em> on security.
You should use other dedicated software packages or services if security is
important. You have been warned.</p>
</td></tr>
<tr><td><code id="server_config_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print messages when launching the server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of configuration information of the form <code>list(host,
  port, start_server = function(app) {}, ...)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# an example of authentication
servr::httd(auth = list(scheme = "Basic", creds = servr::auth_basic("john", "pa$s!")))

</code></pre>

<hr>
<h2 id='vign'>Serve R Markdown/HTML package vignettes</h2><span id='topic+vign'></span>

<h3>Description</h3>

<p>Serve package vignettes under the &lsquo;<span class="file">vignettes/</span>&rsquo; directory. Because the
HTML output files should not be included in the source package, this function
renders R Markdown/HTML vignettes, displays them in the web browser, and
deletes the HTML output files. You will see the HTML output when you click
the links on the &lsquo;<span class="file">.Rmd</span>&rsquo; or &lsquo;<span class="file">.Rhtml</span>&rsquo; files (unlike the static HTTP
server, the compiled output instead of the source document is displayed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vign(dir = ".", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vign_+3A_dir">dir</code></td>
<td>
<p>The root directory to serve.</p>
</td></tr>
<tr><td><code id="vign_+3A_...">...</code></td>
<td>
<p>Server configurations passed to <code><a href="#topic+server_config">server_config</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When developing R packages, you may want to preview your vignettes once in a
while. You can certainly click the button in RStudio to do it, but that
requires you to install the package and rebuild the vignettes. With this
function, your vignette will be rebuilt automatically when you update the
source document. Moreover, because the compilation takes place in the current
R session, you can take advantage of <code>devtools::load_all()</code> (which has a
keyboard shortcut in the RStudio IDE) to reload your package and see the
updated vignette in the web browser.
</p>


<h3>Note</h3>

<p>You are supposed to call this function from the root directory of your
package. If that is not the case, you should provide the correct path to
the &lsquo;<span class="file">vignettes/</span>&rsquo; directory of your package to the <code>dir</code> argument.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
