<!DOCTYPE html><html><head><title>Help for package roahd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {roahd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#roahd'><p>roahd: RObust Analysis for High dimensional Data.</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#append_fData'><p>Append two compatible univariate functional datasets</p></a></li>
<li><a href='#append_mfData'><p>Append two compatible multivariate functional datasets</p></a></li>
<li><a href='#area_ordered'><p>Area-under-curve order relation between univariate functional data</p></a></li>
<li><a href='#area_under_curve'><p>Area under curve of elements of univariate functional data</p></a></li>
<li><a href='#as.mfData'><p>Converting object to <code>mfData</code> class</p></a></li>
<li><a href='#BCIntervalSpearman'><p>Bootstrap Confidence Interval on Spearman's Correlation Coefficient between Univariate Functional Datasets</p></a></li>
<li><a href='#BCIntervalSpearmanMultivariate'><p>Bootstrap Confidence Interval on Spearman's Correlation Coefficient of a Multivariate Functional Dataset</p></a></li>
<li><a href='#BD'><p>Band Depth for univariate functional data</p></a></li>
<li><a href='#BD_relative'><p>Relative Band Depth of functions in a univariate functional dataset</p></a></li>
<li><a href='#BTestSpearman'><p>Bootstrap Hypothesis Test on Spearman Correlation Coefficients for Multivariate Functional Data</p></a></li>
<li><a href='#cor_kendall'><p>Kendall's tau correlation coefficient for bivariate functional data</p></a></li>
<li><a href='#cor_spearman'><p>Spearman's correlation coefficient for multivariate functional data</p></a></li>
<li><a href='#cor_spearman_accuracy'><p>Bootstrap Spearman's correlation coefficient for multivariate functional data</p></a></li>
<li><a href='#cov_fun'><p>Covariance function for functional data</p></a></li>
<li><a href='#depthgram'><p>Depthgram for univariate and multivariate functional data sets</p></a></li>
<li><a href='#EI'><p>Epigraph Index of univariate functional dataset</p></a></li>
<li><a href='#exp_cov_function'><p>Exponential covariance function over a grid</p></a></li>
<li><a href='#fbplot'><p>Functional boxplot of univariate and multivariate functional data</p></a></li>
<li><a href='#fData'><p><code>S3</code> Class for univariate functional datasets.</p></a></li>
<li><a href='#fDColorPalette'><p>A set of fancy color to plot functional datasets</p></a></li>
<li><a href='#generate_gauss_fdata'><p>Generation of gaussian univariate functional data</p></a></li>
<li><a href='#generate_gauss_mfdata'><p>Generation of gaussian multivariate functional data</p></a></li>
<li><a href='#HI'><p>Hypograph Index of univariate functional dataset</p></a></li>
<li><a href='#HRD'><p>Half-Region Depth for univariate functional data</p></a></li>
<li><a href='#max_ordered'><p>Maximum order relation between univariate functional data</p></a></li>
<li><a href='#maxima'><p>Maxima of a univariate functional dataset</p></a></li>
<li><a href='#MBD'><p>Modified Band Depth for univariate functional data</p></a></li>
<li><a href='#MBD_relative'><p>Relative Modified Band Depth of functions in a univariate functional dataset</p></a></li>
<li><a href='#mean.fData'><p>Cross-sectional mean of of a fData object.</p></a></li>
<li><a href='#mean.mfData'><p>Cross-sectional mean of of a mfData object.</p></a></li>
<li><a href='#median_fData'><p>Median of a univariate functional dataset</p></a></li>
<li><a href='#median_mfData'><p>Median of a multivariate functional dataset</p></a></li>
<li><a href='#MEI'><p>Modified Epigraph Index of univariate functional dataset</p></a></li>
<li><a href='#mfD_healthy'><p>ECG trace of healthy subjects</p></a></li>
<li><a href='#mfD_LBBB'><p>ECG trace of subjects suffering from Left-Bundle-Branch-Block (LBBB)</p></a></li>
<li><a href='#mfData'><p><code>S3</code> class for multivariate functional datasets</p></a></li>
<li><a href='#MHI'><p>Modified Hypograph Index of univariate functional dataset</p></a></li>
<li><a href='#MHRD'><p>Modified Half-Region Depth for univariate functional data</p></a></li>
<li><a href='#minima'><p>Minima of a univariate functional dataset</p></a></li>
<li><a href='#multiMBD'><p>(Modified) Band Depth for multivariate functional data</p></a></li>
<li><a href='#multiMEI'><p>Modified Epigraph Index for multivariate functional data</p></a></li>
<li><a href='#multiMHI'><p>Modified Hypograph Index for multivariate functional data</p></a></li>
<li><a href='#multivariate_outliergram'><p>Outliergram for multivariate functional datasets</p></a></li>
<li><a href='#outliergram'><p>Outliergram for univariate functional data sets</p></a></li>
<li><a href='#plot.Cov'><p>Specialized method to plot <code>Cov</code> objects</p></a></li>
<li><a href='#plot.depthgram'><p>Specialized method to plot 'depthgram' objects</p></a></li>
<li><a href='#plot.fData'><p>Specialized method to plot <code>fData</code> objects</p></a></li>
<li><a href='#plot.mfData'><p>Specialized method to plot <code>mfData</code> objects</p></a></li>
<li><a href='#plus-.fData'><p>Operator <code>+</code> and <code>-</code> for <code>fData</code> objects</p></a></li>
<li><a href='#set_alpha'><p>Function to setup alpha value for a set of colors</p></a></li>
<li><a href='#sub-.fData'><p>Operator <code>sub-.fData</code> to subset <code>fData</code> objects</p></a></li>
<li><a href='#sub-.mfData'><p>Operator <code>sub-.mfData</code> to subset <code>mfData</code> objects</p></a></li>
<li><a href='#times-.fData'><p>Operator <code>*</code> and <code>/</code> for <code>fData</code> objects</p></a></li>
<li><a href='#toListOfValues'><p>Manipulation of <code>mfData</code> list of values</p></a></li>
<li><a href='#toRowMatrixForm'><p>Conversion of vector/array/matrix to row-matrix form</p></a></li>
<li><a href='#unfold'><p>Unfolding a univariate functional dataset</p></a></li>
<li><a href='#warp'><p>Warp elements of a univariate functional dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Analysis of High Dimensional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of methods for the robust analysis of univariate and
    multivariate functional data, possibly in high-dimensional cases, and hence
    with attention to computational efficiency and simplicity of use. See the R 
    Journal publication of Ieva et al. (2019) &lt;<a href="https://doi.org/10.32614%2FRJ-2019-032">doi:10.32614/RJ-2019-032</a>&gt; for an 
    in-depth presentation of the 'roahd' package. See Aleman-Gomez et al. (2021) 
    &lt;<a href="https://doi.org/10.48550/arXiv.2103.08874">doi:10.48550/arXiv.2103.08874</a>&gt; for details about the concept of depthgram.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, withr, vdiffr</td>
</tr>
<tr>
<td>Imports:</td>
<td>scales, robustbase, magrittr, dplyr, ggplot2, plotly</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://astamm.github.io/roahd/">https://astamm.github.io/roahd/</a>, <a href="https://github.com/astamm/roahd">https://github.com/astamm/roahd</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/astamm/roahd/issues">https://github.com/astamm/roahd/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-03 16:59:47 UTC; stamm-a</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Tarabelloni [aut],
  Ana Arribas-Gil [aut],
  Francesca Ieva [aut],
  Anna Maria Paganoni [aut],
  Juan Romo [aut],
  Francesco Palma [ctb],
  Aymeric Stamm <a href="https://orcid.org/0000-0002-8725-3654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cre],
  Antonio Elias-Fernandez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aymeric Stamm &lt;aymeric.stamm@math.cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-04 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='roahd'>roahd: RObust Analysis for High dimensional Data.</h2><span id='topic+roahd'></span><span id='topic+roahd-package'></span>

<h3>Description</h3>

<p>A package meant to collect and provide methods for the analysis of univariate
and multivariate functional datasets through the use of robust methods, with
special focus on computation of depths and outlier detection.
Special care was devoted to the efficient implementation of robust methods,
so that they can be employed also in high-dimensional datasets,
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aymeric Stamm <a href="mailto:aymeric.stamm@math.cnrs.fr">aymeric.stamm@math.cnrs.fr</a> (<a href="https://orcid.org/0000-0002-8725-3654">ORCID</a>) [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Nicholas Tarabelloni <a href="mailto:nicholas.tarabelloni@polimi.it">nicholas.tarabelloni@polimi.it</a>
</p>
</li>
<li><p> Ana Arribas-Gil <a href="mailto:aarribas@est-econ.uc3m.es">aarribas@est-econ.uc3m.es</a>
</p>
</li>
<li><p> Francesca Ieva <a href="mailto:francesca.ieva@polimi.it">francesca.ieva@polimi.it</a>
</p>
</li>
<li><p> Anna Maria Paganoni <a href="mailto:anna.paganoni@polimi.it">anna.paganoni@polimi.it</a>
</p>
</li>
<li><p> Juan Romo <a href="mailto:romo@est-econ.uc3m.es">romo@est-econ.uc3m.es</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Francesco Palma <a href="mailto:frapalma7892@gmail.com">frapalma7892@gmail.com</a> [contributor]
</p>
</li>
<li><p> Antonio Elias-Fernandez [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://astamm.github.io/roahd/">https://astamm.github.io/roahd/</a>
</p>
</li>
<li> <p><a href="https://github.com/astamm/roahd">https://github.com/astamm/roahd</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/astamm/roahd/issues">https://github.com/astamm/roahd/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='append_fData'>Append two compatible univariate functional datasets</h2><span id='topic+append_fData'></span>

<h3>Description</h3>

<p>This is a convenience function that simplifies the task of appending univariate
functional observations of two datasets to a unique univariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_fData(fD1, fD2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_fData_+3A_fd1">fD1</code></td>
<td>
<p>is the first functional dataset, stored into an <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="append_fData_+3A_fd2">fD2</code></td>
<td>
<p>is the second functional dataset, stored into an <code>fData</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two original datasets must be compatible, i.e. must be defined on the same grid.
If we denote with <code class="reqn">X_1, \ldots, X_n</code> the first dataset, defined over the
grid <code class="reqn">I = t_1, \ldots, t_P</code>, and with <code class="reqn">Y_1, \ldots, Y_m</code> the second functional dataset,
defined on the same grid, the method returns the union dataset obtained by taking all the
<code class="reqn">n + m</code> observations together.
</p>


<h3>Value</h3>

<p>The function returns an <code>fData</code> object containing the union of <code>fD1</code> and <code>fD2</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+append_mfData">append_mfData</a></code>, <code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two simple univariate datasets

grid = seq(0, 2 * pi, length.out = 100)

values1 = matrix( c(sin(grid),
                    sin(2 * grid)), nrow = 2, ncol = length(grid),
                   byrow=TRUE)

values2 = matrix( c(cos(grid),
                    cos(2 * grid)), nrow = 2, ncol = length(grid),
                   byrow=TRUE)

fD1 = fData( grid, values1 )
fD2 = fData( grid, values2 )

# Appending them to a unique dataset
append_fData(fD1, fD2)

</code></pre>

<hr>
<h2 id='append_mfData'>Append two compatible multivariate functional datasets</h2><span id='topic+append_mfData'></span>

<h3>Description</h3>

<p>This is a convenience function that simplifies the task of appending multivariate
functional observations of two datasets to a unique multivariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_mfData(mfD1, mfD2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_mfData_+3A_mfd1">mfD1</code></td>
<td>
<p>is the first multivariate functional dataset, stored into an <code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="append_mfData_+3A_mfd2">mfD2</code></td>
<td>
<p>is the second multivariate functional dataset, stored into an <code>mfData</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two original datasets must be compatible, i.e. must have same number of components
(dimensions) and must be defined on the same grid. If we denote with
<code class="reqn">X_1^(i), \ldots, X_n^(i)</code>, <code class="reqn">i=0, \ldots, L</code> the first dataset, defined over the
grid <code class="reqn">I = t_1, \ldots, t_P</code>, and with <code class="reqn">Y_1^(i), \ldots, Y_m^(i)</code>, <code class="reqn">i=0, \ldots, L</code>
the second functional dataset, the method returns the union dataset obtained by taking all the
<code class="reqn">n + m</code> observations together.
</p>


<h3>Value</h3>

<p>The function returns a <code>mfData</code> object containing the union of <code>mfD1</code> and <code>mfD2</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+append_fData">append_fData</a></code>, <code><a href="#topic+mfData">mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating two simple bivariate datasets

grid = seq(0, 2 * pi, length.out = 100)

values11 = matrix( c(sin(grid),
                     sin(2 * grid)), nrow = 2, ncol = length(grid),
                   byrow=TRUE)
values12 = matrix( c(sin(3 * grid),
                     sin(4 * grid)), nrow = 2, ncol = length(grid),
                   byrow=TRUE)
values21 = matrix( c(cos(grid),
                     cos(2 * grid)), nrow = 2, ncol = length(grid),
                   byrow=TRUE)
values22 = matrix( c(cos(3 * grid),
                     cos(4 * grid)), nrow = 2, ncol = length(grid),
                   byrow=TRUE)

mfD1 = mfData( grid, list(values11, values12) )
mfD2 = mfData( grid, list(values21, values22) )

# Appending them to a unique dataset
append_mfData(mfD1, mfD2)

</code></pre>

<hr>
<h2 id='area_ordered'>Area-under-curve order relation between univariate functional data</h2><span id='topic+area_ordered'></span>

<h3>Description</h3>

<p>This function implements an order relation between univariate functional data
based on the area-under-curve relation, that is to say a pre-order relation
obtained by comparing the area-under-curve of two different functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area_ordered(fData, gData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_ordered_+3A_fdata">fData</code></td>
<td>
<p>the first univariate functional dataset containing elements to
be compared, in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="area_ordered_+3A_gdata">gData</code></td>
<td>
<p>the second univariate functional dataset containing elements to
be compared , in form of <code>fData</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>
and another functional dataset <code class="reqn">Y_1(t),</code> <code class="reqn">Y_2(t), \ldots, Y_M(t)</code>
defined over the same compact interval <code class="reqn">I=[a,b]</code>, the function computes
the area-under-curve (namely, the integral) in both the datasets, and checks
whether the first ones are lower or equal than the second ones.
</p>
<p>By default the function tries to compare each <code class="reqn">X_i(t)</code> with the
corresponding <code class="reqn">Y_i(t)</code>, thus assuming <code class="reqn">N=M</code>, but when either
<code class="reqn">N=1</code> or <code class="reqn">M=1</code>, the comparison is carried out cycling over the
dataset with fewer elements. In all the other cases (<code class="reqn">N\neq M,</code> and
either <code class="reqn">N \neq 1</code> or <code class="reqn">M \neq 1</code>) the function stops.
</p>


<h3>Value</h3>

<p>The function returns a logical vector of length <code class="reqn">\max(N,M)</code>
containing the value of the predicate for all the corresponding elements.
</p>


<h3>References</h3>

<p>Valencia, D., Romo, J. and Lillo, R. (2015). A Kendall correlation
coefficient for functional dependence, <em>Universidad Carlos III de Madrid
technical report</em>,
<code>http://EconPapers.repec.org/RePEc:cte:wsrepe:ws133228</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area_under_curve">area_under_curve</a></code>, <code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P = 1e3

grid = seq( 0, 1, length.out = P )

Data_1 = matrix( c( 1 * grid,
                    2 *  grid ),
                 nrow = 2, ncol = P, byrow = TRUE )

Data_2 = matrix( 3 * ( 0.5 - abs( grid - 0.5 ) ),
                 nrow = 1, byrow = TRUE )

Data_3 = rbind( Data_1, Data_1 )


fD_1 = fData( grid, Data_1 )
fD_2 = fData( grid, Data_2 )
fD_3 = fData( grid, Data_3 )

area_ordered( fD_1, fD_2 )

area_ordered( fD_2, fD_3 )

</code></pre>

<hr>
<h2 id='area_under_curve'>Area under curve of elements of univariate functional data</h2><span id='topic+area_under_curve'></span>

<h3>Description</h3>

<p>This method computes the (signed) area under the curve of elements of a
univariate functional dataset, namely, their integral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area_under_curve(fData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_under_curve_+3A_fdata">fData</code></td>
<td>
<p>the functional dataset containing elements whose areas under the
curve have to be computed, in form of <code>fData</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
defined over a compact interval <code class="reqn">I=[a,b]</code> and observed on an evenly
spaced 1D grid <code class="reqn">[a = t_0, t_1, \ldots, t_{P-1} = b] \subset I</code>, the
function computes:
</p>
<p style="text-align: center;"><code class="reqn"> \sum_{i=1}^{P-2} \frac{X(t_{i+1}) - X(t_{i-1})}{2} h \approx \int_a^b
X(t) dt,</code>
</p>

<p>where <code class="reqn">h = t_1 - t_0</code>.
</p>


<h3>Value</h3>

<p>The function returns a numeric vector containing the values of areas
under the curve for all the elements of the functional dataset
<code>fData</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+area_ordered">area_ordered</a></code>, <code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P = 1e3
grid = seq( 0, 1, length.out = P )

fD = fData( grid,
            matrix( c( sin( 2 * pi * grid ),
                       cos( 2 * pi * grid ),
                       4 * grid * ( 1 - grid ) ),
                    nrow = 3, ncol = P, byrow = TRUE ) )
plot( fD )

area_under_curve( fD )

</code></pre>

<hr>
<h2 id='as.mfData'>Converting object to <code>mfData</code> class</h2><span id='topic+as.mfData'></span><span id='topic+as.mfData.list'></span>

<h3>Description</h3>

<p>This S3 method provides a way to convert some objects to the class
<code>mfData</code>, thus obtaining a multivariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mfData(x, ...)

## S3 method for class 'list'
as.mfData(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mfData_+3A_x">x</code></td>
<td>
<p>a list of univariate functional datasets, provided in form of
<code>fData</code> objects.</p>
</td></tr>
<tr><td><code id="as.mfData_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>mfData</code> object, obtained starting from
argument <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid = seq( 0, 1, length.out = 100 )

fD_1 = fData( grid, sin( 2 * pi * grid ) )
fD_2 = fData( grid, cos( 2 * pi * grid ) )

plot( as.mfData( list( fD_1, fD_2 ) ) )

</code></pre>

<hr>
<h2 id='BCIntervalSpearman'>Bootstrap Confidence Interval on Spearman's Correlation Coefficient between Univariate Functional Datasets</h2><span id='topic+BCIntervalSpearman'></span>

<h3>Description</h3>

<p>This function computes the bootstrap confidence interval of coverage probability
<code class="reqn">1 - \alpha</code> for the Spearman correlation coefficient between two univariate functional samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BCIntervalSpearman(
  fD1,
  fD2,
  ordering = "MEI",
  bootstrap_iterations = 1000,
  alpha = 0.05,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BCIntervalSpearman_+3A_fd1">fD1</code></td>
<td>
<p>is the first univariate functional sample in form of an <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="BCIntervalSpearman_+3A_fd2">fD2</code></td>
<td>
<p>is the first univariate functional sample in form of an <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="BCIntervalSpearman_+3A_ordering">ordering</code></td>
<td>
<p>is either <code>MEI</code> (default) or <code>MHI</code>, and indicates the ordering relation
to be used during in the Spearman's coefficient computation.</p>
</td></tr>
<tr><td><code id="BCIntervalSpearman_+3A_bootstrap_iterations">bootstrap_iterations</code></td>
<td>
<p>is the number of bootstrap iterations to use in order to estimate the
confidence interval (default is 1000).</p>
</td></tr>
<tr><td><code id="BCIntervalSpearman_+3A_alpha">alpha</code></td>
<td>
<p>controls the coverage probability (1-<code>alpha</code>).</p>
</td></tr>
<tr><td><code id="BCIntervalSpearman_+3A_verbose">verbose</code></td>
<td>
<p>whether to log information on the progression of bootstrap iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes two samples of compatible functional data (i.e., they must be defined over the
same grid and have same number of observations) and computes a bootstrap confidence interval for
their Spearman correlation coefficient.
</p>


<h3>Value</h3>

<p>The function returns a list of two elements, <code>lower</code> and <code>upper</code>, representing
the lower and upper end of the bootstrap confidence interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_spearman">cor_spearman</a></code>, <code><a href="#topic+cor_spearman_accuracy">cor_spearman_accuracy</a></code>, <code><a href="#topic+fData">fData</a></code>,
<code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+BCIntervalSpearmanMultivariate">BCIntervalSpearmanMultivariate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

N &lt;- 200
P &lt;- 100

grid &lt;- seq(0, 1, length.out = P)

# Creating an exponential covariance function to simulate Gaussian data
Cov &lt;- exp_cov_function(grid, alpha = 0.3, beta = 0.4)

# Simulating (independent) Gaussian functional data with given center and covariance function
Data_1 &lt;- generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = Cov )
Data_2 &lt;- generate_gauss_fdata(
  N = N,
  centerline = sin(2 * pi * grid),
  Cov = Cov
)

# Using the simulated data as (independent) components of a bivariate functional dataset
mfD &lt;- mfData(grid, list(Data_1, Data_2))


BCIntervalSpearman(mfD$fDList[[1]], mfD$fDList[[2]], ordering = "MEI")
BCIntervalSpearman(mfD$fDList[[1]], mfD$fDList[[2]], ordering = "MHI")


# BC intervals contain zero since the functional samples are uncorrelated.

</code></pre>

<hr>
<h2 id='BCIntervalSpearmanMultivariate'>Bootstrap Confidence Interval on Spearman's Correlation Coefficient of a Multivariate Functional Dataset</h2><span id='topic+BCIntervalSpearmanMultivariate'></span>

<h3>Description</h3>

<p>This function computes the bootstrap confidence intervals of coverage probability
<code class="reqn">1 - \alpha</code> for the Spearman correlation coefficients within a multivariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BCIntervalSpearmanMultivariate(
  mfD,
  ordering = "MEI",
  bootstrap_iterations = 1000,
  alpha = 0.05,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BCIntervalSpearmanMultivariate_+3A_mfd">mfD</code></td>
<td>
<p>is the multivariate functional sample in form of <code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="BCIntervalSpearmanMultivariate_+3A_ordering">ordering</code></td>
<td>
<p>is either <code>MEI</code> (default) or <code>MHI</code>, and indicates the ordering relation
to be used during in the Spearman's coefficient computation.</p>
</td></tr>
<tr><td><code id="BCIntervalSpearmanMultivariate_+3A_bootstrap_iterations">bootstrap_iterations</code></td>
<td>
<p>is the number of bootstrap iterations to use in order to estimate the
confidence intervals (default is 1000).</p>
</td></tr>
<tr><td><code id="BCIntervalSpearmanMultivariate_+3A_alpha">alpha</code></td>
<td>
<p>controls the coverage probability (1-<code>alpha</code>).</p>
</td></tr>
<tr><td><code id="BCIntervalSpearmanMultivariate_+3A_verbose">verbose</code></td>
<td>
<p>whether to log information on the progression of bootstrap iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a multivariate functional dataset and computes a matrix of bootstrap confidence
intervals for its Spearman correlation coefficients.
</p>


<h3>Value</h3>

<p>The function returns a list of two elements, <code>lower</code> and <code>upper</code>, representing
the matrices of lower and upper ends of the bootstrap confidence intervals for each pair of
components. The elements on the main diagonal are set to 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_spearman">cor_spearman</a></code>, <code><a href="#topic+cor_spearman_accuracy">cor_spearman_accuracy</a></code>, <code><a href="#topic+fData">fData</a></code>,
<code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+BCIntervalSpearman">BCIntervalSpearman</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

N &lt;- 200
P &lt;- 100
grid &lt;- seq(0, 1, length.out = P)

# Creating an exponential covariance function to simulate Gaussian data
Cov &lt;- exp_cov_function(grid, alpha = 0.3, beta = 0.4)

# Simulating (independent) Gaussian functional data with given center and covariance function
Data_1 &lt;- generate_gauss_fdata(
  N = N,
  centerline = sin(2 * pi * grid),
  Cov = Cov
)
Data_2 &lt;- generate_gauss_fdata(
  N = N,
  centerline = sin(4 * pi * grid),
  Cov = Cov
)
Data_3 &lt;- generate_gauss_fdata(
  N = N,
  centerline = sin(6 * pi * grid),
  Cov = Cov
)

# Using the simulated data as (independent) components of a multivariate functional dataset
mfD &lt;- mfData(grid, list(Data_1, Data_2, Data_3))


BCIntervalSpearmanMultivariate(mfD, ordering = "MEI")


# BC intervals contain zero since the functional samples are uncorrelated.

</code></pre>

<hr>
<h2 id='BD'>Band Depth for univariate functional data</h2><span id='topic+BD'></span><span id='topic+BD.fData'></span><span id='topic+BD.default'></span>

<h3>Description</h3>

<p>This function computes the Band Depth (BD) of elements of a functional
dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BD(Data)

## S3 method for class 'fData'
BD(Data)

## Default S3 method:
BD(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BD_+3A_data">Data</code></td>
<td>
<p>either an object of class <code>fData</code> or a matrix-like dataset
of functional data (e.g. <code>fData$values</code>),
with observations as rows and measurements over grid points as columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
this function computes the sample BD of each element with respect to the
other elements of the dataset, i.e.:
</p>
<p style="text-align: center;"><code class="reqn"> BD( X( t ) ) = {N \choose 2 }^{-1} \sum_{1 \leq i_1 &lt; i_2 \leq N} I(
G(X) \subset B( X_{i_1}, X_{i_2} ) ),</code>
</p>

<p>where <code class="reqn">G(X)</code> is the graphic of <code class="reqn">X(t)</code>, <code class="reqn">B(X_{i_1},X_{i_2})</code> is
the envelope of <code class="reqn">X_{i_1}(t)</code> and <code class="reqn">X_{i_2}(t)</code>, and <code class="reqn">X \in
\left\{X_1, \ldots, X_N\right\}</code>.
</p>
<p>See the References section for more details.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the values of BD for the
given dataset.
</p>


<h3>References</h3>

<p>Lopez-Pintado, S. and Romo, J. (2009). On the Concept of Depth for Functional
Data, <em>Journal of the American Statistical Association</em>, 104, 718-734.
</p>
<p>Lopez-Pintado, S. and Romo. J. (2007). Depth-based inference for functional
data, <em>Computational Statistics &amp; Data Analysis</em> 51, 4957-4968.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MBD">MBD</a></code>, <code><a href="#topic+BD_relative">BD_relative</a></code>,
<code><a href="#topic+MBD_relative">MBD_relative</a></code>, <code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid = seq( 0, 1, length.out = 1e2 )


D = matrix( c( 1 + sin( 2 * pi * grid ),
               0 + sin( 4 * pi * grid ),
               1 - sin( pi * ( grid - 0.2 ) ),
               0.1 + cos( 2 * pi * grid ),
               0.5 + sin( 3 * pi + grid ),
               -2 + sin( pi * grid ) ),
            nrow = 6, ncol = length( grid ), byrow = TRUE )

fD = fData( grid, D )

BD( fD )

BD( D )

</code></pre>

<hr>
<h2 id='BD_relative'>Relative Band Depth of functions in a univariate functional dataset</h2><span id='topic+BD_relative'></span><span id='topic+BD_relative.fData'></span><span id='topic+BD_relative.default'></span>

<h3>Description</h3>

<p>This function computes Band Depth (BD) of elements of a univariate functional
dataset with respect to another univariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BD_relative(Data_target, Data_reference)

## S3 method for class 'fData'
BD_relative(Data_target, Data_reference)

## Default S3 method:
BD_relative(Data_target, Data_reference)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BD_relative_+3A_data_target">Data_target</code></td>
<td>
<p>is the univariate functional dataset, provided either as
a <code>fData</code> object or in matrix
form (N observations as rows and P measurements as columns), whose BD
have to be computed with respect to the reference dataset.</p>
</td></tr>
<tr><td><code id="BD_relative_+3A_data_reference">Data_reference</code></td>
<td>
<p>is the dataset, provided either as a <code>fData</code>
object or in matrix form (N observations
as rows and P measurements as columns), containing the reference
univariate functional data that must be used to compute the band depths of
elements in <code>Data_target</code>. If <code>Data_target</code> is <code>fData</code>, it
must be of class <code>fData</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset of elements <code class="reqn">X_1(t), X_2(t),
\ldots, X_N(t)</code>, and another univariate functional dataset of elements
<code class="reqn">Y_1(t), Y_2(t) \ldots, Y_M(t)</code>, this function computes the BD of
elements of the former with respect to elements of the latter, i.e.:
</p>
<p style="text-align: center;"><code class="reqn"> BD( X_i( t ) ) = {M \choose 2 }^{-1} \sum_{1 \leq i_1 &lt; i_2 \leq M} I(
G(X_i) \subset B( Y_{i_1}, Y_{i_2} ) ), \quad \forall i = 1, \ldots, N,</code>
</p>

<p>where <code class="reqn">G(X_i)</code> is the graphic of <code class="reqn">X_i(t)</code> and <code class="reqn">B(Y_{i_1},Y_{i_2})</code> is
the envelope of <code class="reqn">Y_{i_1}(t)</code> and <code class="reqn">Y_{i_2}(t)</code>.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the BD of elements in
<code>Data_target</code> with respect to elements in <code>Data_reference</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BD">BD</a></code>, <code><a href="#topic+MBD">MBD</a></code>, <code><a href="#topic+MBD_relative">MBD_relative</a></code>,
<code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid = seq( 0, 1, length.out = 1e2 )

Data_ref = matrix( c( 0  + sin( 2 * pi * grid ),
                      1  + sin( 2 * pi * grid ),
                      -1 + sin( 2 * pi * grid ) ),
                   nrow = 3, ncol = length( grid ), byrow = TRUE )

Data_test_1 = matrix( c( 0.6 + sin( 2 * pi * grid ) ),
                      nrow = 1, ncol = length( grid ), byrow = TRUE )

Data_test_2 = matrix( c( 0.6 + sin( 2 * pi * grid ) ),
                      nrow = length( grid ), ncol = 1, byrow = TRUE )

Data_test_3 = 0.6 + sin( 2 * pi * grid )

Data_test_4 = array( 0.6 + sin( 2 * pi * grid ), dim = length( grid ) )

Data_test_5 = array( 0.6 + sin( 2 * pi * grid ), dim = c( 1, length( grid ) ) )

Data_test_6 = array( 0.6 + sin( 2 * pi * grid ), dim = c( length( grid ), 1 ) )

Data_test_7 = matrix( c( 0.5  + sin( 2 * pi * grid ),
                         -0.5 + sin( 2 * pi * grid ),
                         1.1 + sin( 2 * pi * grid ) ),
                      nrow = 3, ncol = length( grid ), byrow = TRUE )

fD_ref = fData( grid, Data_ref )
fD_test_1 = fData( grid, Data_test_1 )
fD_test_2 = fData( grid, Data_test_2 )
fD_test_3 = fData( grid, Data_test_3 )
fD_test_4 = fData( grid, Data_test_4 )
fD_test_5 = fData( grid, Data_test_5 )
fD_test_6 = fData( grid, Data_test_6 )
fD_test_7 = fData( grid, Data_test_7 )

BD_relative( fD_test_1, fD_ref )
BD_relative( Data_test_1, Data_ref )

BD_relative( fD_test_2, fD_ref )
BD_relative( Data_test_2, Data_ref )

BD_relative( fD_test_3, fD_ref )
BD_relative( Data_test_3, Data_ref )

BD_relative( fD_test_4, fD_ref )
BD_relative( Data_test_4, Data_ref )

BD_relative( fD_test_5, fD_ref )
BD_relative( Data_test_5, Data_ref )

BD_relative( fD_test_6, fD_ref )
BD_relative( Data_test_6, Data_ref )

BD_relative( fD_test_7, fD_ref )
BD_relative( Data_test_7, Data_ref )

</code></pre>

<hr>
<h2 id='BTestSpearman'>Bootstrap Hypothesis Test on Spearman Correlation Coefficients for Multivariate Functional Data</h2><span id='topic+BTestSpearman'></span>

<h3>Description</h3>

<p>This function performs a bootstrap test that checks whether the Spearman correlation structures
(e.g. matrices) of two populations of compatible multivariate functional data are equal or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BTestSpearman(
  mfD1,
  mfD2,
  bootstrap_iterations = 1000,
  ordering = "MEI",
  normtype = "f",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BTestSpearman_+3A_mfd1">mfD1</code></td>
<td>
<p>is the first functional dataset, specified in form of <code>mfData</code> object; it must
be compatible with <code>mfD2</code>.</p>
</td></tr>
<tr><td><code id="BTestSpearman_+3A_mfd2">mfD2</code></td>
<td>
<p>is the second functional dataset, specified in form of <code>mfData</code> object; it must
be compatible with <code>mfD1</code>.</p>
</td></tr>
<tr><td><code id="BTestSpearman_+3A_bootstrap_iterations">bootstrap_iterations</code></td>
<td>
<p>is the number of bootstrap iterations to be performed.</p>
</td></tr>
<tr><td><code id="BTestSpearman_+3A_ordering">ordering</code></td>
<td>
<p>is the kind of ordering to be used in the computation of Spearman's correlation
coefficient (default is <code>MEI</code>).</p>
</td></tr>
<tr><td><code id="BTestSpearman_+3A_normtype">normtype</code></td>
<td>
<p>is the norm to be used when comparing the Spearman correlation matrices of the two
functional datasets (default is Frobenius, allowed values are the same as for parameter <code>type</code> in
the base function <code>norm</code>).</p>
</td></tr>
<tr><td><code id="BTestSpearman_+3A_verbose">verbose</code></td>
<td>
<p>a boolean flag specifying whether to print the progress of bootstrap iterations or not (default is FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a first multivariate functional population, <code class="reqn">X_1^(i), \ldots, X_n^(i)</code> with <code class="reqn">i=1, \ldots, L</code>,
defined on the grid <code class="reqn">I = t_1, \ldots, t_P</code>, and a second multivariate functional population,
<code class="reqn">Y_1^(i), \ldots, Y_m^(i)</code> with <code class="reqn">i=1, \ldots, L</code>, defined on the same grid <code class="reqn">I</code>, the
function performs a bootstrap test to check the hypothesis:
</p>
<p style="text-align: center;"><code class="reqn">H_0: R_X = R_Y</code>
</p>

<p style="text-align: center;"><code class="reqn">H_1: R_X \neq R_Y,</code>
</p>

<p>where R_X and R_Y denote the L x L matrices of Spearman correlation coefficients of the two populations.
</p>

<ul>
<li><p>The two functional samples must have the same number of components and must be defined over the same
discrete interval <code class="reqn">t_1, \ldots, t_P</code>.
</p>
</li>
<li><p>The test is performed through a bootstrap argument, so
a number of bootstrap iterations must be specified as well. A high value for this parameter may result
in slow performances of the test (you may consider setting <code>verbose</code> to <code>TRUE</code> to get
hints on the process).</p>
</li></ul>



<h3>Value</h3>

<p>The function returns the estimates of the test's p-value and statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BCIntervalSpearman">BCIntervalSpearman</a></code>, <code><a href="#topic+BCIntervalSpearmanMultivariate">BCIntervalSpearmanMultivariate</a></code>, <code><a href="#topic+mfData">mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

N  &lt;- 200
P &lt;- 100
L &lt;- 2

grid &lt;- seq(0, 1, length.out = P)

# Creating an exponential covariance function to simulate Gaussian data
Cov &lt;- exp_cov_function(grid, alpha = 0.3, beta = 0.4)

# Simulating two populations of bivariate functional data
#
# The first population has very high correlation between first and second component
centerline_1 &lt;- matrix(
  data = rep(sin(2 * pi * grid)),
  nrow = L,
  ncol = P,
  byrow = TRUE
)
values1 &lt;- generate_gauss_mfdata(
  N = N,
  L = L,
  correlations = 0.9,
  centerline = centerline_1,
  listCov = list(Cov, Cov)
)
mfD1 &lt;- mfData(grid, values1)

# Pointwise estimate
cor_spearman(mfD1)

# The second population has zero correlation between first and second component
centerline_2 &lt;- matrix(
  data = rep(cos(2 * pi * grid)),
  nrow = L,
  ncol = P,
  byrow = TRUE
)
values2 &lt;- generate_gauss_mfdata(
  N = N,
  L = L,
  correlations = 0,
  centerline = centerline_2,
  listCov = list(Cov, Cov)
)
mfD2 &lt;- mfData(grid, values2)

# Pointwise estimate
cor_spearman(mfD2)

# Applying the test

BTestSpearman(mfD1, mfD2)

</code></pre>

<hr>
<h2 id='cor_kendall'>Kendall's tau correlation coefficient for bivariate functional data</h2><span id='topic+cor_kendall'></span>

<h3>Description</h3>

<p>This function computes the Kendall's tau correlation coefficient for a
bivariate functional dataset, with either a max or area-under-curve order
order relation between univariate functional elements (components).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_kendall(mfD, ordering = "max")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_kendall_+3A_mfd">mfD</code></td>
<td>
<p>a bivariate functional dataset whose Kendall's tau coefficient
must be computed, in form of bivariate <code>mfData</code> object
(<code>mfD$L=2</code>).</p>
</td></tr>
<tr><td><code id="cor_kendall_+3A_ordering">ordering</code></td>
<td>
<p>the ordering relation to use on functional observations,
either <code>"max"</code> for the maximum relation or <code>"area"</code> for the area
under the curve relation (default is <code>"max"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a bivariate functional dataset, with first components <code class="reqn">X_1(t),
X_2(t), \ldots, X_N(t)</code> and second components <code class="reqn">Y_1(t), Y_2(t), \ldots,
Y_N(t)</code>, the function exploits either the order relation based on the maxima
or the area-under-curve relation to compare data and produce concordances and
discordances, that are then used to compute the tau coefficient.
</p>
<p>See the references for more details.
</p>


<h3>Value</h3>

<p>The function returns the Kendall's tau correlation coefficient for
the bivariate dataset provided with <code>mfData</code>.
</p>


<h3>References</h3>

<p>Valencia, D., Romo, J. and Lillo, R. (2015). A Kendall correlation
coefficient for functional dependence, <em>Universidad Carlos III de Madrid
technical report</em>,
<code>http://EconPapers.repec.org/RePEc:cte:wsrepe:ws133228</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+area_ordered">area_ordered</a></code>,
<code><a href="#topic+max_ordered">max_ordered</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### TOTALLY INDEPENDENT COMPONENTS
N = 2e2
P = 1e3

grid = seq( 0, 1, length.out = P )

# Creating an exponential covariance function to simulate guassian data
Cov = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Simulating (independent) gaussian functional data with given center and
# covariance function
Data_1 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = Cov )
Data_2 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = Cov )

# Using the simulated data as (independent) components of a bivariate functional
# dataset
mfD = mfData( grid, list( Data_1, Data_2 ) )

# Correlation approx. zero (components were created independently)
cor_kendall( mfD, ordering = 'max' )

# Correlation approx. zero (components were created independently)
cor_kendall( mfD, ordering = 'area' )

#### TOTALLY DEPENDENT COMPONENTS

# Nonlinear transform of first component
Data_3 = t( apply( Data_1, 1, exp ) )

# Creating bivariate dataset starting from nonlinearly-dependent components
mfD = mfData( grid, list( Data_1, Data_3 ) )

# Correlation very high (components are nonlinearly dependent)
cor_kendall( mfD, ordering = 'max' )

# Correlation very high (components are nonlinearly dependent)
cor_kendall( mfD, ordering = 'area' )

</code></pre>

<hr>
<h2 id='cor_spearman'>Spearman's correlation coefficient for multivariate functional data</h2><span id='topic+cor_spearman'></span>

<h3>Description</h3>

<p>This function computes the Spearman's correlation coefficient for a
multivariate functional dataset, with either a Modified Epigraph Index (MEI)
or Modified Hypograph Index (MHI) ranking of univariate elements of data
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_spearman(mfD, ordering = "MEI")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_spearman_+3A_mfd">mfD</code></td>
<td>
<p>a multivariate functional dataset whose Spearman's correlation
coefficient must be computed, in form of multivariate <code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="cor_spearman_+3A_ordering">ordering</code></td>
<td>
<p>the ordering relation to use on functional observations,
either <code>"MEI"</code> for MEI or <code>"MHI"</code> for MHI (default is
<code>"MEI"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a multivariate functional dataset, with first components <code class="reqn">X^1_1(t),
X^1_2(t), \ldots, X^1_N(t)</code>, second components <code class="reqn">X^2_1(t), X^2_2(t),
\ldots, X^2_N(t)</code>, etc., the function exploits either the MEI or MHI to
compute the matrix of Spearman's correlation coefficients. Such matrix is
symmetrical and has ones on the diagonal. The entry (i, j) represents the
Spearman correlation coefficient between curves of component i and j.
</p>
<p>See the references for more details.
</p>


<h3>Value</h3>

<p>If the original dataset is bivariate, the function returns only the
scalar value of the correlation coefficient for the two components. When
the number of components is L &gt;2, it returns the whole matrix of Spearman's
correlation coefficients for all the components.
</p>


<h3>References</h3>

<p>Valencia, D., Romo, J. and Lillo, R. (2015). Spearman coefficient for
functions, <em>Universidad Carlos III de Madrid technical report</em>,
<code>http://EconPapers.repec.org/RePEc:cte:wsrepe:ws133329</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+MEI">MEI</a></code>, <code><a href="#topic+MHI">MHI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### TOTALLY INDEPENDENT COMPONENTS

N = 2e2
P = 1e3

grid = seq( 0, 1, length.out = P )

# Creating an exponential covariance function to simulate guassian data
Cov = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Simulating (independent) gaussian functional data with given center and
# covariance function
Data_1 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = Cov )
Data_2 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = Cov )

# Using the simulated data as (independent) components of a bivariate functional
# dataset
mfD = mfData( grid, list( Data_1, Data_2 ) )

# Correlation approx. zero (components were created independently)
cor_spearman( mfD, ordering = 'MEI' )

# Correlation approx. zero (components were created independently)
cor_spearman( mfD, ordering = 'MHI' )

#### TOTALLY DEPENDENT COMPONENTS

# Nonlinear transform of first component
Data_3 = t( apply( Data_1, 1, exp ) )

# Creating bivariate dataset starting from nonlinearly-dependent components
mfD = mfData( grid, list( Data_1, Data_3 ) )

# Correlation very high (components are nonlinearly dependent)
cor_spearman( mfD, ordering = 'MEI' )

# Correlation very high (components are nonlinearly dependent)
cor_spearman( mfD, ordering = 'MHI' )

</code></pre>

<hr>
<h2 id='cor_spearman_accuracy'>Bootstrap Spearman's correlation coefficient for multivariate functional data</h2><span id='topic+cor_spearman_accuracy'></span>

<h3>Description</h3>

<p>This function computes the bootstrap estimates of standard error and bias of
the Spearman's correlation coefficient for a multivariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_spearman_accuracy(
  mfD,
  ordering = "MEI",
  bootstrap_iterations = 1000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_spearman_accuracy_+3A_mfd">mfD</code></td>
<td>
<p>a multivariate functional dataset whose Spearman's correlation
coefficient must be computed, in form of multivariate <code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="cor_spearman_accuracy_+3A_ordering">ordering</code></td>
<td>
<p>the ordering relation to use on functional observations,
either <code>"MEI"</code> for MEI or <code>"MHI"</code> for MHI (default is
<code>"MEI"</code>).</p>
</td></tr>
<tr><td><code id="cor_spearman_accuracy_+3A_bootstrap_iterations">bootstrap_iterations</code></td>
<td>
<p>the number of bootstrap iterations to be used for
estimation of bias and standard error.</p>
</td></tr>
<tr><td><code id="cor_spearman_accuracy_+3A_verbose">verbose</code></td>
<td>
<p>a logical flag specifying whether to log information on the
estimation progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a multivariate functional dataset <code class="reqn">X_1^(i), \ldots, X_n^(i)</code>,
<code class="reqn">i=0, \ldots, L</code> defined over the grid <code class="reqn">I = t_0, \ldots, t_P</code>, having
components <code class="reqn">i=1, \ldots, L</code>, and a chosen ordering strategy (MEI or MHI),
the function computes the matrix of Spearman's correlation indices of the
dataset components, as well as their bias and standard deviation estimates
through a specified number of bootstrap iterations (bias and standard error
are updated with on-line formulas).
</p>


<h3>Value</h3>

<p>a list of three elements: <code>mean</code>, the mean of the matrix of
correlation coefficients; <code>bias</code>, a matrix containing the estimated
bias (mean - point estimate of correlation coefficients); <code>sd</code>, a
matrix containing the estimated standard deviation of the coefficients'
matrix. In case the multivariate functional dataset has only two
components, the return type is scalar and not matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_spearman">cor_spearman</a></code>, <code><a href="#topic+mfData">mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 200
P &lt;- 100

grid &lt;- seq(0, 1, length.out = P)

# Creating an exponential covariance function to simulate Gaussian data
Cov &lt;- exp_cov_function(grid, alpha = 0.3, beta = 0.4)

# Simulating (independent) Gaussian functional data with given center and covariance function

Data_1 &lt;- generate_gauss_fdata(
  N = N,
  centerline = sin(2 * pi * grid),
  Cov = Cov
)

Data_2 &lt;- generate_gauss_fdata(
  N = N,
  centerline = sin(2 * pi * grid),
  Cov = Cov
)

# Using the simulated data as (independent) components of a bivariate functional dataset
mfD &lt;- mfData(grid, list(Data_1, Data_2))


# Computes bootstrap estimate of Spearman correlation
cor_spearman_accuracy(mfD, ordering = "MEI")
cor_spearman_accuracy(mfD, ordering = "MHI")


</code></pre>

<hr>
<h2 id='cov_fun'>Covariance function for functional data</h2><span id='topic+cov_fun'></span><span id='topic+cov_fun.fData'></span><span id='topic+cov_fun.mfData'></span>

<h3>Description</h3>

<p><code>S3</code> method to compute the sample covariance and cross-covariance
functions for a set of functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_fun(X, Y = NULL)

## S3 method for class 'fData'
cov_fun(X, Y = NULL)

## S3 method for class 'mfData'
cov_fun(X, Y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_fun_+3A_x">X</code></td>
<td>
<p>is the (eventually first) functional dataset, i.e. either an object
of class <code>fData</code> or an object of class <code>mfData</code>;</p>
</td></tr>
<tr><td><code id="cov_fun_+3A_y">Y</code></td>
<td>
<p>is the (optional) second functional dataset to be used to compute the
cross-covariance function,  either <code>NULL</code> or an <code>fData</code> or
<code>mfData</code> object (see the Value section for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate random function X, defined
over the grid <code class="reqn">I = [a,b]</code>, the covariance
function is defined as:
</p>
<p style="text-align: center;"><code class="reqn">C(s,t) = Cov( X(s), X(t) ), \qquad s,t \in I.</code>
</p>

<p>Given another random function, Y, defined over the same grid as X, the cross-
covariance function of X and Y is:
</p>
<p style="text-align: center;"><code class="reqn">C^{X,Y}( s,t ) =  Cov( X(s), Y(t) ), \qquad s, t \in I.</code>
</p>

<p>For a generic L-dimensional random function X, i.e. an L-dimensional
multivariate functional datum, the covariance function is defined as the set
of blocks:
</p>
<p style="text-align: center;"><code class="reqn">C_{i,j}(s,t) = Cov( X_i(s), X_j(t)), i,j = 1, ...,L, s,t \in I,</code>
</p>

<p>while the cross-covariance function is defined by the blocks:
</p>
<p style="text-align: center;"><code class="reqn">C^{X,Y}_{i,j}(s,t) = Cov( X_i(s), Y_j(t))</code>
</p>

<p>The method <code>cov_fun</code> provides the sample estimator of the covariance or
cross-covariance functions for univariate or multivariate functional datasets.
</p>
<p>The class of <code>X</code> (<code>fData</code> or <code>mfData</code>) is used to dispatch the
correct implementation of the method.
</p>


<h3>Value</h3>

<p>The following cases are given:
</p>

<ul>
<li><p>if <code>X</code> is of class <code>fData</code> and <code>Y</code> is <code>NULL</code>, then
the covariance function of <code>X</code> is returned;
</p>
</li>
<li><p>if <code>X</code> is of class <code>fData</code> and <code>Y</code> is of
class <code>fData</code>,
the cross-covariance function of the two datasets is returned;
</p>
</li>
<li><p>if <code>X</code> is of class <code>mfData</code> and <code>Y</code> is <code>NULL</code>,
the upper-triangular blocks of the covariance function of <code>X</code>
are returned (in form of list and by row, i.e. in the sequence 1_1, 1_2, ...,
1_L, 2_2, ... - have a look at the labels of the list with <code>str</code>);
</p>
</li>
<li><p>if <code>X</code> is of class <code>mfData</code> and <code>Y</code> is of
class <code>fData</code>,
the cross-covariances of <code>X</code>'s components and <code>Y</code> are
returned (in form of list);
</p>
</li>
<li><p>if <code>X</code> is of class <code>mfData</code> and <code>Y</code> is of
class <code>mfData</code>,
the upper-triangular blocks of the cross-covariance of <code>X</code>'s and
<code>Y</code>'s components are returned (in form of list and by row, i.e. in the
sequence 1_1, 1_2, ..., 1_L, 2_2, ... - have a look at the labels
of the list with <code>str</code>));</p>
</li></ul>

<p>In any case, the return type is either an instance of the <code>S3</code> class <code>Cov</code>
or a list of instances of such class (for the case of multivariate
functional data).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>, <code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+plot.Cov">plot.Cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating a univariate functional dataset
N = 1e2

P = 1e2
t0 = 0
t1 = 1

time_grid = seq( t0, t1, length.out = P )

Cov = exp_cov_function( time_grid, alpha = 0.3, beta = 0.4 )

D1 = generate_gauss_fdata( N, centerline = sin( 2 * pi * time_grid ), Cov = Cov )
D2 = generate_gauss_fdata( N, centerline = sin( 2 * pi * time_grid ), Cov = Cov )

fD1 = fData( time_grid, D1 )
fD2 = fData( time_grid, D2 )

# Computing the covariance function of fD1

C = cov_fun( fD1 )
str( C )

# Computing the cross-covariance function of fD1 and fD2
CC = cov_fun( fD1, fD2 )
str( CC )

# Generating a multivariate functional dataset
L = 3

C1 = exp_cov_function( time_grid, alpha = 0.1, beta = 0.2 )
C2 = exp_cov_function( time_grid, alpha = 0.2, beta = 0.5 )
C3 = exp_cov_function( time_grid, alpha = 0.3, beta = 1 )

centerline = matrix( c( sin( 2 * pi * time_grid ),
                        sqrt( time_grid ),
                        10 * ( time_grid - 0.5 ) * time_grid ),
                     nrow = 3, byrow = TRUE )

D3 = generate_gauss_mfdata( N, L, centerline,
                       correlations = c( 0.5, 0.5, 0.5 ),
                       listCov = list( C1, C2, C3 ) )

# adding names for better readability of BC3's labels
names( D3 ) = c( 'comp1', 'comp2', 'comp3' )
mfD3 = mfData( time_grid, D3 )

D1 = generate_gauss_fdata( N, centerline = sin( 2 * pi * time_grid ),
                              Cov = Cov )
fD1 = fData( time_grid, D1 )

# Computing the block covariance function of mfD3
BC3 = cov_fun( mfD3 )
str( BC3 )

# computing cross-covariance between mfData and fData objects
CC = cov_fun( mfD3, fD1 )
str( CC )

</code></pre>

<hr>
<h2 id='depthgram'>Depthgram for univariate and multivariate functional data sets</h2><span id='topic+depthgram'></span><span id='topic+depthgram.default'></span><span id='topic+depthgram.fData'></span><span id='topic+depthgram.mfData'></span>

<h3>Description</h3>

<p>This function computes the three 'DepthGram' representations from a p-variate
functional data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthgram(
  Data,
  marginal_outliers = FALSE,
  boxplot_factor = 1.5,
  outliergram_factor = 1.5,
  ids = NULL
)

## Default S3 method:
depthgram(
  Data,
  marginal_outliers = FALSE,
  boxplot_factor = 1.5,
  outliergram_factor = 1.5,
  ids = NULL
)

## S3 method for class 'fData'
depthgram(
  Data,
  marginal_outliers = FALSE,
  boxplot_factor = 1.5,
  outliergram_factor = 1.5,
  ids = NULL
)

## S3 method for class 'mfData'
depthgram(
  Data,
  marginal_outliers = FALSE,
  boxplot_factor = 1.5,
  outliergram_factor = 1.5,
  ids = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthgram_+3A_data">Data</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of length <code>L</code> (number of components)
in which each element is an <code style="white-space: pre;">&#8288;N x P&#8288;</code> matrix with <code>N</code> individuals and <code>P</code>
time points. Alternatively, it can also be an object of class
<code><a href="#topic+fData">fData</a></code> or of class <code><a href="#topic+mfData">mfData</a></code>.</p>
</td></tr>
<tr><td><code id="depthgram_+3A_marginal_outliers">marginal_outliers</code></td>
<td>
<p>A boolean specifying whether the function should
return shape and amplitude outliers over each dimension. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="depthgram_+3A_boxplot_factor">boxplot_factor</code></td>
<td>
<p>A numeric value specifying the inflation factor for
marginal functional boxplots. This is ignored if <code>marginal_outliers == FALSE</code>. Defaults to <code>1.5</code>.</p>
</td></tr>
<tr><td><code id="depthgram_+3A_outliergram_factor">outliergram_factor</code></td>
<td>
<p>A numeric value specifying the inflation factor for
marginal outliergrams. This is ignored if <code>marginal_outliers == FALSE</code>.
Defaults to <code>1.5</code>.</p>
</td></tr>
<tr><td><code id="depthgram_+3A_ids">ids</code></td>
<td>
<p>A character vector specifying labels for individual observations.
Defaults to <code>NULL</code>, in which case observations will remain unlabelled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>depthgram</code> which is a list with the following
items:
</p>

<ul>
<li> <p><code>mbd.mei.d</code>: vector MBD of the MEI dimension-wise.
</p>
</li>
<li> <p><code>mei.mbd.d</code>: vector MEI of the MBD dimension-wise.
</p>
</li>
<li> <p><code>mbd.mei.t</code>: vector MBD of the MEI time-wise.
</p>
</li>
<li> <p><code>mei.mbd.t</code>: vector MEI of the MEI time-wise.
</p>
</li>
<li> <p><code>mbd.mei.t2</code>: vector MBD of the MEI time/correlation-wise.
</p>
</li>
<li> <p><code>mei.mbd.t2</code>: vector MEI of the MBD time/correlation-wise.
</p>
</li>
<li> <p><code>shp.out.det</code>: detected shape outliers by dimension.
</p>
</li>
<li> <p><code>mag.out.det</code>: detected magnitude outliers by dimension.
</p>
</li>
<li> <p><code>mbd.d</code>: matrix <code style="white-space: pre;">&#8288;n x p&#8288;</code> of MBD dimension-wise.
</p>
</li>
<li> <p><code>mei.d</code>: matrix <code style="white-space: pre;">&#8288;n x p&#8288;</code> of MEI dimension-wise.
</p>
</li>
<li> <p><code>mbd.t</code>: matrix <code style="white-space: pre;">&#8288;n x p&#8288;</code> of MBD time-wise.
</p>
</li>
<li> <p><code>mei.t</code>: matrix <code style="white-space: pre;">&#8288;n x p&#8288;</code> of MEI time-wise.
</p>
</li>
<li> <p><code>mbd.t2</code>: matrix <code style="white-space: pre;">&#8288;n x p&#8288;</code> of MBD time/correlation-wise
</p>
</li>
<li> <p><code>mei.t2</code>: matrix <code style="white-space: pre;">&#8288;n x p&#8288;</code> of MBD time/correlation-wise.
</p>
</li></ul>



<h3>References</h3>

<p>Aleman-Gomez, Y., Arribas-Gil, A., Desco, M. Elias-Fernandez, A., and Romo,
J. (2021). &quot;Depthgram: Visualizing Outliers in High Dimensional Functional
Data with application to Task fMRI data exploration&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 2e2
P &lt;- 1e3
grid &lt;- seq(0, 1, length.out = P)
Cov &lt;- exp_cov_function(grid, alpha = 0.3, beta = 0.4)

Data &lt;- list()
Data[[1]] &lt;- generate_gauss_fdata(
  N,
  centerline = sin(2 * pi * grid),
  Cov = Cov
)
Data[[2]] &lt;- generate_gauss_fdata(
  N,
  centerline = sin(2 * pi * grid),
  Cov = Cov
)
names &lt;- paste0("id_", 1:nrow(Data[[1]]))

DG1 &lt;- depthgram(Data, marginal_outliers = TRUE, ids = names)

fD &lt;- fData(grid, Data[[1]])
DG2 &lt;- depthgram(fD, marginal_outliers = TRUE, ids = names)

mfD &lt;- mfData(grid, Data)
DG3 &lt;- depthgram(mfD, marginal_outliers = TRUE, ids = names)
</code></pre>

<hr>
<h2 id='EI'>Epigraph Index of univariate functional dataset</h2><span id='topic+EI'></span><span id='topic+EI.fData'></span><span id='topic+EI.default'></span>

<h3>Description</h3>

<p>This function computes the Epigraphic Index (EI) of elements of a univariate
functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EI(Data)

## S3 method for class 'fData'
EI(Data)

## Default S3 method:
EI(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EI_+3A_data">Data</code></td>
<td>
<p>either an <code>fData</code> object or a matrix-like dataset of
functional data (e.g. <code>fData$values</code>), with observations as rows and
measurements over grid points as columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
defined over a compact interval <code class="reqn">I=[a,b]</code>, this function computes the
EI, i.e.:
</p>
<p style="text-align: center;"><code class="reqn">EI( X(t) ) = \frac{1}{N} \sum_{i=1}^N I( G( X_i(t) ) \subset
epi( X(t) ) ) = \frac{1}{N} \sum_{i=1}^N I( X_i(t) \geq X(t), \ \
\forall t \in I), </code>
</p>

<p>where <code class="reqn">G(X_i(t))</code> indicates the graph of <code class="reqn">X_i(t)</code>, <code class="reqn">epi( X(t))</code>
indicates the epigraph of <code class="reqn">X(t)</code>.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the values of EI for each
element of the functional dataset provided in <code>Data</code>.
</p>


<h3>References</h3>

<p>Lopez-Pintado, S. and Romo, J. (2012). A half-region depth for functional
data, <em>Computational Statistics and Data Analysis</em>, 55, 1679-1695.
</p>
<p>Arribas-Gil, A., and Romo, J. (2014). Shape outlier detection and
visualization for functional data: the outliergram, <em>Biostatistics</em>,
15(4), 603-619.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MEI">MEI</a></code>, <code><a href="#topic+HI">HI</a></code>, <code><a href="#topic+MHI">MHI</a></code>,
<code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e2

grid = seq( 0, 1, length.out = P )

C = exp_cov_function( grid, alpha = 0.2, beta = 0.3 )

Data = generate_gauss_fdata( N,
                             centerline = sin( 2 * pi * grid ),
                             C )
fD = fData( grid, Data )

EI( fD )

EI( Data )

</code></pre>

<hr>
<h2 id='exp_cov_function'>Exponential covariance function over a grid</h2><span id='topic+exp_cov_function'></span>

<h3>Description</h3>

<p>This function computes the discretization of an exponential
covariance function of the form:
</p>
<p style="text-align: center;"><code class="reqn">C( s, t ) = \alpha e^{ - \beta | s - t | }</code>
</p>

<p>over a 1D grid <code class="reqn">[t_0, t_1, \ldots, t_{P-1}]</code>, thus obtaining the
<code class="reqn">P \times P</code> matrix
of values:
</p>
<p style="text-align: center;"><code class="reqn"> C_{i,j} = C( t_i, t_j ) = \alpha e^{ - \beta | t_i - t_j | } .</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>exp_cov_function(grid, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_cov_function_+3A_grid">grid</code></td>
<td>
<p>a vector of time points.</p>
</td></tr>
<tr><td><code id="exp_cov_function_+3A_alpha">alpha</code></td>
<td>
<p>the alpha parameter in the exponential covariance formula.</p>
</td></tr>
<tr><td><code id="exp_cov_function_+3A_beta">beta</code></td>
<td>
<p>the beta parameter in the exponential covariance formula.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+generate_gauss_fdata">generate_gauss_fdata</a></code>,
<code><a href="#topic+generate_gauss_mfdata">generate_gauss_mfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid = seq( 0, 1, length.out = 5e2 )

alpha = 0.2
beta = 0.3

dev.new()
image( exp_cov_function( grid, alpha, beta ),
       main = 'Exponential covariance function',
       xlab = 'grid', ylab = 'grid')


</code></pre>

<hr>
<h2 id='fbplot'>Functional boxplot of univariate and multivariate functional data</h2><span id='topic+fbplot'></span><span id='topic+fbplot.fData'></span><span id='topic+fbplot.mfData'></span>

<h3>Description</h3>

<p>This function can be used to perform the functional boxplot of univariate or
multivariate functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbplot(
  Data,
  Depths = "MBD",
  Fvalue = 1.5,
  adjust = FALSE,
  display = TRUE,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)

## S3 method for class 'fData'
fbplot(
  Data,
  Depths = "MBD",
  Fvalue = 1.5,
  adjust = FALSE,
  display = TRUE,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)

## S3 method for class 'mfData'
fbplot(
  Data,
  Depths = list(def = "MBD", weights = "uniform"),
  Fvalue = 1.5,
  adjust = FALSE,
  display = TRUE,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbplot_+3A_data">Data</code></td>
<td>
<p>the univariate or multivariate functional dataset whose
functional boxplot must be determined, in form of <code>fData</code> or
<code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="fbplot_+3A_depths">Depths</code></td>
<td>
<p>either a vector containing the depths for each element of the
dataset, or:
</p>

<ul>
<li> <p><em>univariate case</em>: a string containing the name of the method you
want to use to compute it. The default is <code>'MBD'</code>.
</p>
</li>
<li> <p><em>multivariate case</em>: a list with elements <code>def</code>, containing the
name of the depth notion to be used to compute depths (<code>BD</code> or
<code>MBD</code>), and <code>weights</code>, containing the value of parameter
<code>weights</code> to be passed to the depth function. Default is
<code>list(def = 'MBD', weights = 'uniform')</code>.
</p>
</li></ul>

<p>In both cases the name of the functions to compute depths must be available
in the caller's environment.</p>
</td></tr>
<tr><td><code id="fbplot_+3A_fvalue">Fvalue</code></td>
<td>
<p>the value of the inflation factor <code class="reqn">F</code>, default is <code>F =
1.5</code>.</p>
</td></tr>
<tr><td><code id="fbplot_+3A_adjust">adjust</code></td>
<td>
<p>either <code>FALSE</code> if you would like the default value for the
inflation factor, <code class="reqn">F = 1.5</code>, to be used, or (for now <b>only in the
univariate functional case</b>) a list specifying the parameters required by
the adjustment:
</p>

<ul>
<li> <p><code>N_trials</code>: the number of repetitions of the adjustment procedure
based on the simulation of a gaussian population of functional data, each
one producing an adjusted value of <code class="reqn">F</code>, which will lead to the averaged
adjusted value <code class="reqn">\bar{F}</code>. Default is 20.
</p>
</li>
<li> <p><code>trial_size</code>: the number of elements in the gaussian population of
functional data that will be simulated at each repetition of the adjustment
procedure. Default is 8 * <code>Data$N</code>.
</p>
</li>
<li> <p><code>TPR</code>: the True Positive Rate of outliers, i.e. the proportion of
observations in a dataset without amplitude outliers that have to be
considered outliers. Default is <code>2 * pnorm(4 * qnorm(0.25))</code>.
</p>
</li>
<li> <p><code>F_min</code>: the minimum value of <code class="reqn">F</code>, defining the left boundary
for the optimization problem aimed at finding, for a given dataset of
simulated gaussian data associated to <code>Data</code>, the optimal value of
<code class="reqn">F</code>. Default is 0.5.
</p>
</li>
<li> <p><code>F_max</code>: the maximum value of <code class="reqn">F</code>, defining the right boundary
for the optimization problem aimed at finding, for a given dataset of
simulated gaussian data associated to <code>Data</code>, the optimal value of
<code class="reqn">F</code>. Default is 5.
</p>
</li>
<li> <p><code>tol</code>: the tolerance to be used in the optimization problem aimed at
finding, for a given dataset of simulated gaussian data associated to
<code>Data</code>, the optimal value of <code class="reqn">F</code>. Default is <code>1e-3</code>.
</p>
</li>
<li> <p><code>maxiter</code>: the maximum number of iterations to solve the
optimization problem aimed at finding, for a given dataset of simulated
gaussian data associated to <code>Data</code>, the optimal value of <code class="reqn">F</code>.
Default is <code>100</code>.
</p>
</li>
<li> <p><code>VERBOSE</code>: a parameter controlling the verbosity of the adjustment
process.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fbplot_+3A_display">display</code></td>
<td>
<p>either a logical value indicating whether you want the
functional boxplot to be displayed, or the number of the graphical device
where you want the functional boxplot to be displayed.</p>
</td></tr>
<tr><td><code id="fbplot_+3A_xlab">xlab</code></td>
<td>
<p>the label to use on the x axis when displaying the functional
boxplot.</p>
</td></tr>
<tr><td><code id="fbplot_+3A_ylab">ylab</code></td>
<td>
<p>the label (or list of labels for the multivariate functional
case) to use on the y axis when displaying the functional boxplot.</p>
</td></tr>
<tr><td><code id="fbplot_+3A_main">main</code></td>
<td>
<p>the main title (or list of titles for the multivariate functional
case) to be used when displaying the functional boxplot.</p>
</td></tr>
<tr><td><code id="fbplot_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be used in plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Even when used in graphical way to plot the functional boxplot, the
function returns a list of three elements:
</p>

<ul>
<li> <p><code>Depths</code>: contains the depths of each element of the functional
dataset.
</p>
</li>
<li> <p><code>Fvalue</code>: is the value of F used to obtain the outliers.
</p>
</li>
<li> <p><code>ID_out</code>: contains the vector of indices of dataset elements flagged
as outliers (if any).
</p>
</li></ul>



<h3>Adjustment</h3>

<p>In the <b>univariate functional case</b>, when the adjustment option is
selected, the value of <code class="reqn">F</code> is optimized for the univariate functional
dataset provided with <code>Data</code>.
</p>
<p>In practice, a number <code>adjust$N_trials</code> of times a synthetic population
(of size <code>adjust$tiral_size</code> with the same covariance (robustly
estimated from data) and centerline as <code>fData</code> is simulated without
outliers and each time an optimized value <code class="reqn">F_i</code> is computed so that a
given proportion (<code>adjust$TPR</code>) of observations is flagged as outliers.
The final value of <code>F</code> for the functional boxplot is determined as an
average of <code class="reqn">F_1, F_2, \dots, F_{N_{trials}}</code>. At each time step the
optimization problem is solved using <code>stats::uniroot</code> (Brent's method).
</p>


<h3>References</h3>


<ol>
<li><p> Sun, Y., &amp; Genton, M. G. (2012). Functional boxplots. Journal of
Computational and Graphical Statistics.
</p>
</li>
<li><p> Sun, Y., &amp; Genton, M. G. (2012). Adjusted functional boxplots for
spatio-temporal data visualization and outlier detection. Environmetrics,
23(1), 54-64.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>, <code><a href="#topic+MBD">MBD</a></code>, <code><a href="#topic+BD">BD</a></code>,
<code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+multiMBD">multiMBD</a></code>, <code><a href="#topic+multiBD">multiBD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# UNIVARIATE FUNCTIONAL BOXPLOT - NO ADJUSTMENT

set.seed(1)

N = 2 * 100 + 1
P = 2e2

grid = seq( 0, 1, length.out = P )

D = 10 * matrix( sin( 2 * pi * grid ), nrow = N, ncol = P, byrow = TRUE )

D = D + rexp(N, rate = 0.05)


# c( 0, 1 : (( N - 1 )/2), -( ( ( N - 1 ) / 2 ) : 1 ) )^4


fD = fData( grid, D )

dev.new()
oldpar &lt;- par(mfrow = c(1, 1))
par(mfrow = c(1, 3))

plot( fD, lwd = 2, main = 'Functional dataset',
      xlab = 'time', ylab = 'values' )

fbplot( fD, main = 'Functional boxplot', xlab = 'time', ylab = 'values', Fvalue = 1.5 )

boxplot(fD$values[,1], ylim = range(fD$values), main = 'Boxplot of functional dataset at t_0 ' )

par(oldpar)

# UNIVARIATE FUNCTIONAL BOXPLOT - WITH ADJUSTMENT


set.seed( 161803 )

P = 2e2
grid = seq( 0, 1, length.out = P )

N = 1e2

# Generating a univariate synthetic gaussian dataset
Data = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ),
                             Cov = exp_cov_function( grid,
                                                     alpha = 0.3,
                                                     beta  = 0.4 ) )
fD = fData( grid, Data )

dev.new()

fbplot( fD, adjust = list( N_trials = 10,
                           trial_size = 5 * N,
                           VERBOSE = TRUE ),
                     xlab = 'time', ylab = 'Values',
                     main = 'My adjusted functional boxplot' )


# MULTIVARIATE FUNCTIONAL BOXPLOT - NO ADJUSTMENT

set.seed( 1618033 )

P = 1e2
N = 1e2
L = 2

grid = seq( 0, 1, length.out = 1e2 )

C1 = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )
C2 = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Generating a bivariate functional dataset of gaussian data with partially
# correlated components
Data = generate_gauss_mfdata( N, L,
                              centerline = matrix( sin( 2 * pi * grid ),
                                                   nrow = 2, ncol = P,
                                                   byrow = TRUE ),
                              correlations = rep( 0.5, 1 ),
                              listCov = list( C1, C2 ) )

mfD = mfData( grid, Data )

dev.new()
fbplot( mfD, Fvalue = 2.5, xlab = 'time', ylab = list( 'Values 1',
                                                       'Values 2' ),
        main = list( 'First component', 'Second component' ) )



</code></pre>

<hr>
<h2 id='fData'><code>S3</code> Class for univariate functional datasets.</h2><span id='topic+fData'></span>

<h3>Description</h3>

<p>This function implements a constructor for elements of <code>S3</code> class
<code>fData</code>, aimed at implementing a representation of a functional
dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fData(grid, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fData_+3A_grid">grid</code></td>
<td>
<p>the evenly spaced grid over which the functional observations are
measured. It must be a numeric vector of length <code>P</code>.</p>
</td></tr>
<tr><td><code id="fData_+3A_values">values</code></td>
<td>
<p>the values of the observations in the functional dataset,
provided in form of a 2D data structure (e.g. matrix or array) having as
rows the observations and as columns their measurements over the 1D grid of
length <code>P</code> specified in <code>grid</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional dataset is represented as a collection of measurement of the
observations on an evenly spaced, 1D grid of discrete points (representing,
e.g. time), namely, for functional data defined over a grid <code class="reqn">[t_0,
 t_1, \ldots, t_{P-1}]</code>:
</p>
<p style="text-align: center;"><code class="reqn"> f_{i,j} = f_i( t_0 + j h ), \quad h =  \frac{t_P - t_0}{N},
 \quad \forall j = 1, \ldots, P, \quad \forall i = 1, \ldots
 N.</code>
</p>



<h3>Value</h3>

<p>The function returns a <code>S3</code> object of class <code>fData</code>, containing
the following elements:
</p>

<ul>
<li><p>&quot;<code>N</code>&quot;: the number of elements in the dataset;
</p>
</li>
<li><p>&quot;<code>P</code>&quot;: the number of points in the 1D grid over which elements
are measured;
</p>
</li>
<li><p>&quot;<code>t0</code>&quot;: the starting point of the 1D grid;
</p>
</li>
<li><p>&quot;<code>tP</code>&quot;: the ending point of the 1D grid;
</p>
</li>
<li><p>&quot;<code>values</code>&quot;: the matrix of measurements of the functional
observations on the 1D grid provided with <code>grid</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+generate_gauss_fdata">generate_gauss_fdata</a></code>, <code><a href="#topic+sub-.fData">sub-.fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining parameters
N = 20
P = 1e2

# One dimensional grid
grid = seq( 0, 1, length.out = P )

# Generating an exponential covariance function (see related help for more
# information )
C = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Generating a synthetic dataset with a gaussian distribution and
# required mean and covariance function:
values = generate_gauss_fdata( N,
                               centerline = sin( 2 * pi * grid ),
                               Cov = C )

fD = fData( grid, values )

</code></pre>

<hr>
<h2 id='fDColorPalette'>A set of fancy color to plot functional datasets</h2><span id='topic+fDColorPalette'></span>

<h3>Description</h3>

<p>This function can be used to generate a palette of colors useful to plot
functional datasets with the <code>plot</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fDColorPalette(N, hue_range = c(0, 360), alpha = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fDColorPalette_+3A_n">N</code></td>
<td>
<p>number of different colors (ideally, functional observations).</p>
</td></tr>
<tr><td><code id="fDColorPalette_+3A_hue_range">hue_range</code></td>
<td>
<p>the range of hues in the HCL scheme.</p>
</td></tr>
<tr><td><code id="fDColorPalette_+3A_alpha">alpha</code></td>
<td>
<p>the alpha channel parameter(s) of the colors (transparency).</p>
</td></tr>
<tr><td><code id="fDColorPalette_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code>scales::hue_pal</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function, built around <code>scales::hue_pal</code>, allows to set up the
HCL parameters of the set of colors desired, and besides to set up the
alpha channel value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fData">plot.fData</a></code>, <code><a href="#topic+plot.mfData">plot.mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 1e2
angular_grid = seq( 0, 359, length.out = N )

dev.new()
plot( angular_grid, angular_grid,
      col = fDColorPalette( N, hue_range = c( 0, 359 ), alpha = 1 ),
      pch = 16, cex = 3 )

</code></pre>

<hr>
<h2 id='generate_gauss_fdata'>Generation of gaussian univariate functional data</h2><span id='topic+generate_gauss_fdata'></span>

<h3>Description</h3>

<p><code>generate_gauss_fdata</code> generates a dataset of univariate functional data
with a desired mean and covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_gauss_fdata(N, centerline, Cov = NULL, CholCov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_gauss_fdata_+3A_n">N</code></td>
<td>
<p>the number of distinct functional observations to generate.</p>
</td></tr>
<tr><td><code id="generate_gauss_fdata_+3A_centerline">centerline</code></td>
<td>
<p>the centerline of the distribution, represented as a one-
dimensional data structure  of length <code class="reqn">P</code> containing the measurement of
the centerline on grid points.</p>
</td></tr>
<tr><td><code id="generate_gauss_fdata_+3A_cov">Cov</code></td>
<td>
<p>the covariance operator (provided in form of a <code class="reqn">P \times P</code> matrix) that has to be used in the generation of <code class="reqn">\epsilon(t)</code>. At
least one argument between <code>Cov</code> and <code>CholCov</code> should be different
from <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="generate_gauss_fdata_+3A_cholcov">CholCov</code></td>
<td>
<p>the Cholesky factor of the covariance operator (provided in
form of a <code class="reqn">P \times P</code> matrix) that has to be used in the
generation of observations from the process <code class="reqn">\epsilon(t)</code>. At least one
argument between <code>Cov</code> and <code>CholCov</code> should be different from
<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In particular, the following model is considered for the generation of data:
</p>
<p style="text-align: center;"><code class="reqn">X(t) = m( t ) + \epsilon( t ), \quad t \in I = [a, b]</code>
</p>

<p>where <code class="reqn">m(t)</code> is the center and <code class="reqn">\epsilon(t)</code> is a centered gaussian
process with covariance function <code class="reqn">C_i</code>.
That is to say:
</p>
<p style="text-align: center;"><code class="reqn">Cov( \epsilon(s), \epsilon(t) ) = C( s, t ), \quad \forall s, t \in
  I</code>
</p>

<p>All the functions are supposed to be observed on an evenly-spaced, one-
dimensional grid of P points: <code class="reqn">[a = t_0, t_1, \ldots, t_{P-1} = b]
\subset I </code>.
</p>


<h3>Value</h3>

<p>The function returns a matrix containing the discretized
values of the generated observations (in form of an <code class="reqn">N \times P</code>
matrix).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exp_cov_function">exp_cov_function</a></code>, <code><a href="#topic+fData">fData</a></code>,
<code><a href="#topic+generate_gauss_mfdata">generate_gauss_mfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 30
P = 1e2

t0 = 0
tP = 1

time_grid = seq( t0, tP, length.out = P )

C = exp_cov_function( time_grid, alpha = 0.1, beta = 0.2 )

CholC = chol( C )

centerline = sin( 2 * pi * time_grid )

invisible(generate_gauss_fdata( N, centerline, Cov = C ))

invisible(generate_gauss_fdata( N, centerline, CholCov = CholC ))

</code></pre>

<hr>
<h2 id='generate_gauss_mfdata'>Generation of gaussian multivariate functional data</h2><span id='topic+generate_gauss_mfdata'></span>

<h3>Description</h3>

<p><code>generate_gauss_mfdata</code> generates a dataset of multivariate functional
data with a desired mean and covariance function in each dimension and a
desired correlation structure among components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_gauss_mfdata(
  N,
  L,
  centerline,
  correlations,
  listCov = NULL,
  listCholCov = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_gauss_mfdata_+3A_n">N</code></td>
<td>
<p>the number of distinct functional observations to generate.</p>
</td></tr>
<tr><td><code id="generate_gauss_mfdata_+3A_l">L</code></td>
<td>
<p>the number of components of the multivariate functional data.</p>
</td></tr>
<tr><td><code id="generate_gauss_mfdata_+3A_centerline">centerline</code></td>
<td>
<p>the centerline of the distribution, represented as a
2-dimensional data structure with L rows (one for each dimension) having the
measurements along the grid as columns.</p>
</td></tr>
<tr><td><code id="generate_gauss_mfdata_+3A_correlations">correlations</code></td>
<td>
<p>is the vector containing the <code class="reqn">1/2 L (L-1)</code>
correlation coefficients <code class="reqn">\rho_{ij}</code> in the model generating data.
They have to be provided in the following order:
</p>
<p style="text-align: center;"><code class="reqn">(\rho_{1,2},\ldots,\rho_{1,L},\rho_{2,3},\ldots,\rho_{2,L},\ldots,
\rho_{L,L-1}),</code>
</p>

<p>that is to say, the row-wise, upper triangular part of the correlation matrix
without the diagonal.</p>
</td></tr>
<tr><td><code id="generate_gauss_mfdata_+3A_listcov">listCov</code></td>
<td>
<p>a list containing the <code class="reqn">L</code> covariance operators (provided
in form of a <code class="reqn">P \times P</code> matrix), one for each component of the
multivariate functional random variable, that have to be used in the
generation of the processes <code class="reqn">\epsilon_1(t), \ldots, \epsilon_L(t)</code>.
At least one argument between <code>listCov</code> and <code>listCholCov</code> must be
different from <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="generate_gauss_mfdata_+3A_listcholcov">listCholCov</code></td>
<td>
<p>the Cholesky factor of the <code class="reqn">L</code> covariance operators
(in <code class="reqn">P \times P</code> matrix form), one for each component of the
multivariate functional random variable, that have to be used in the
generation of the processes <code class="reqn">\epsilon_1(t), \ldots, \epsilon_L(t)</code>.
At least one argument between <code>listCov</code> and <code>listCholCov</code> must be
different from <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In particular, the following model is considered for the generation of data:
</p>
<p style="text-align: center;"><code class="reqn">X(t) = ( m_1( t ) + \epsilon_1( t ), \ldots, m_L(t) +
 \epsilon_L(t)), \quad t \in I = [a, b]</code>
</p>

<p>where <code class="reqn">L</code> is the number of components of the multivariate functional
random variable, <code class="reqn">m_i(t)</code> is the <code class="reqn">i-</code>th component of the center and
<code class="reqn">\epsilon_i(t)</code> is a centered gaussian process with covariance function
<code class="reqn">C_i</code>. That is to say:
</p>
<p style="text-align: center;"><code class="reqn">Cov( \epsilon_{i}(s), \epsilon_{i}(t) ) = C( s, t ), \quad \forall i =
 1, \ldots, L, \quad \forall s, t \in I</code>
</p>

<p>A correlation structure among <code class="reqn">\epsilon_1(t),\ldots,\epsilon_L(t)</code> is
allowed in the following way:
</p>
<p style="text-align: center;"><code class="reqn"> Cor( \epsilon_i(t), \epsilon_j(t)) = \rho_{i,j}, \quad \forall
i \neq j, \quad \forall t \in I.</code>
</p>

<p>All the functions are supposed to be observed on an evenly-spaced, one-
dimensional grid of P points: <code class="reqn">[ a = t_0, t_1, \ldots, t_{P-1} = b]
\subset I </code>.
</p>


<h3>Value</h3>

<p>The function returns a list of L matrices, one for each component of
the multivariate functional random variable, containing the discretized
values of the generated observations (in form of <code class="reqn">N \times P</code>
matrices).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exp_cov_function">exp_cov_function</a></code>, <code><a href="#topic+mfData">mfData</a></code>,
<code><a href="#topic+generate_gauss_fdata">generate_gauss_fdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 30
P = 1e2
L = 3

time_grid = seq( 0, 1, length.out = P )

C1 = exp_cov_function( time_grid, alpha = 0.1, beta = 0.2 )
C2 = exp_cov_function( time_grid, alpha = 0.2, beta = 0.5 )
C3 = exp_cov_function( time_grid, alpha = 0.3, beta = 1 )


centerline = matrix( c( sin( 2 * pi * time_grid ),
                        sqrt( time_grid ),
                        10 * ( time_grid - 0.5 ) * time_grid ),
                     nrow = 3, byrow = TRUE )

generate_gauss_mfdata( N, L, centerline,
                       correlations = c( 0.5, 0.5, 0.5 ),
                       listCov = list( C1, C2, C3 ) )

CholC1 = chol( C1 )
CholC2 = chol( C2 )
CholC3 = chol( C3 )

generate_gauss_mfdata( N, L, centerline,
                       correlations = c( 0.5, 0.5, 0.5 ),
                      listCholCov = list( CholC1, CholC2, CholC3 ) )

</code></pre>

<hr>
<h2 id='HI'>Hypograph Index of univariate functional dataset</h2><span id='topic+HI'></span><span id='topic+HI.fData'></span><span id='topic+HI.default'></span>

<h3>Description</h3>

<p>This function computes the Hypograph Index (HI) of elements of a univariate
functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HI(Data)

## S3 method for class 'fData'
HI(Data)

## Default S3 method:
HI(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HI_+3A_data">Data</code></td>
<td>
<p>either an <code>fData</code> object or a matrix-like dataset of
functional data (e.g. <code>fData$values</code>),
with observations as rows and measurements over grid points as columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
defined over a compact interval <code class="reqn">I=[a,b]</code>, this function computes the
HI, i.e.:
</p>
<p style="text-align: center;"><code class="reqn">HI( X(t) ) = \frac{1}{N} \sum_{i=1}^N I( G( X_i(t) ) \subset
hyp( X(t) ) ) = \frac{1}{N} \sum_{i=1}^N I( X_i(t) \leq X(t), \ \
\forall t \in I), </code>
</p>

<p>where <code class="reqn">G(X_i(t))</code> indicates the graph of <code class="reqn">X_i(t)</code>, <code class="reqn">hyp( X(t))</code>
indicates the hypograph of <code class="reqn">X_i(t)</code>.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the values of HI for each
element of the functional dataset provided in <code>Data</code>.
</p>


<h3>References</h3>

<p>Lopez-Pintado, S. and Romo, J. (2012). A half-region depth for functional
data, <em>Computational Statistics and Data Analysis</em>, 55, 1679-1695.
</p>
<p>Arribas-Gil, A., and Romo, J. (2014). Shape outlier detection and
visualization for functional data: the outliergram, <em>Biostatistics</em>,
15(4), 603-619.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MHI">MHI</a></code>, <code><a href="#topic+EI">EI</a></code>, <code><a href="#topic+MEI">MEI</a></code>,
<code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e2

grid = seq( 0, 1, length.out = P )

C = exp_cov_function( grid, alpha = 0.2, beta = 0.3 )

Data = generate_gauss_fdata( N,
                             centerline = sin( 2 * pi * grid ),
                             C )
fD = fData( grid, Data )

HI( fD )

HI( Data )

</code></pre>

<hr>
<h2 id='HRD'>Half-Region Depth for univariate functional data</h2><span id='topic+HRD'></span><span id='topic+HRD.fData'></span><span id='topic+HRD.default'></span>

<h3>Description</h3>

<p>This function computes the Half-Region Depth (HRD) of elements of a univariate
functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HRD(Data)

## S3 method for class 'fData'
HRD(Data)

## Default S3 method:
HRD(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HRD_+3A_data">Data</code></td>
<td>
<p>either an <code>fData</code> object or a matrix-like dataset of
functional data (e.g. <code>fData$values</code>),
with observations as rows and measurements over grid points as columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
defined over a compact interval <code class="reqn">I=[a,b]</code>, this function computes the HRD
of its elements, i.e.:
</p>
<p style="text-align: center;"><code class="reqn">HRD(X(t)) = \min( EI( X(t) ), HI(X(t)) ),</code>
</p>

<p>where <code class="reqn">EI(X(t))</code> indicates the Epigraph Index (EI) of <code class="reqn">X(t)</code> with
respect to the dataset, and <code class="reqn">HI(X(t))</code> indicates the Hypograph Index of
<code class="reqn">X(t)</code> with respect to the dataset.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the values of HRD for each
element of the functional dataset provided in <code>Data</code>.
</p>


<h3>References</h3>

<p>Lopez-Pintado, S. and Romo, J. (2012). A half-region depth for functional
data, <em>Computational Statistics and Data Analysis</em>, 55, 1679-1695.
</p>
<p>Arribas-Gil, A., and Romo, J. (2014). Shape outlier detection and
visualization for functional data: the outliergram, <em>Biostatistics</em>,
15(4), 603-619.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MHRD">MHRD</a></code>, <code><a href="#topic+EI">EI</a></code>, <code><a href="#topic+HI">HI</a></code>,
<code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e2

grid = seq( 0, 1, length.out = P )

C = exp_cov_function( grid, alpha = 0.2, beta = 0.3 )

Data = generate_gauss_fdata( N,
                             centerline = sin( 2 * pi * grid ),
                             C )

fD = fData( grid, Data )

HRD( fD )

HRD( Data )

</code></pre>

<hr>
<h2 id='max_ordered'>Maximum order relation between univariate functional data</h2><span id='topic+max_ordered'></span>

<h3>Description</h3>

<p>This function implements an order relation between univariate functional data
based on the maximum relation, that is to say a pre-order relation obtained
by comparing the maxima of two different functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_ordered(fData, gData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_ordered_+3A_fdata">fData</code></td>
<td>
<p>the first univariate functional dataset containing elements to
be compared, in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="max_ordered_+3A_gdata">gData</code></td>
<td>
<p>the second univariate functional dataset containing elements to
be compared, in form of <code>fData</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>
and another functional dataset <code class="reqn">Y_1(t),</code> <code class="reqn">Y_2(t), \ldots, Y_M(t)</code>
defined over the same compact interval <code class="reqn">I=[a,b]</code>, the function computes
the maxima in both the datasets, and checks whether the first ones are lower
or equal than the second ones.
</p>
<p>By default the function tries to compare each <code class="reqn">X_i(t)</code> with the
corresponding <code class="reqn">Y_i(t)</code>, thus assuming <code class="reqn">N=M</code>, but when either
<code class="reqn">N=1</code> or <code class="reqn">M=1</code>, the comparison is carried out cycling over the
dataset with fewer elements. In all the other cases (<code class="reqn">N\neq M,</code> and
either <code class="reqn">N \neq 1</code> or <code class="reqn">M \neq 1</code>) the function stops.
</p>


<h3>Value</h3>

<p>The function returns a logical vector of length <code class="reqn">\max(N,M)</code>
containing the value of the predicate for all the corresponding elements.
</p>


<h3>References</h3>

<p>Valencia, D., Romo, J. and Lillo, R. (2015). A Kendall correlation
coefficient for functional dependence, <em>Universidad Carlos III de Madrid
technical report</em>,
<code>http://EconPapers.repec.org/RePEc:cte:wsrepe:ws133228</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxima">maxima</a></code>, <code><a href="#topic+minima">minima</a></code>, <code><a href="#topic+fData">fData</a></code>,
<code><a href="#topic+area_ordered">area_ordered</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P = 1e2

grid = seq( 0, 1, length.out = P )

Data_1 = matrix( c( 1 * grid,
                    2 *  grid ),
                 nrow = 2, ncol = P, byrow = TRUE )

Data_2 = matrix( 3 * ( 0.5 - abs( grid - 0.5 ) ),
                 nrow = 1, byrow = TRUE )

Data_3 = rbind( Data_1, Data_1 )


fD_1 = fData( grid, Data_1 )
fD_2 = fData( grid, Data_2 )
fD_3 = fData( grid, Data_3 )

max_ordered( fD_1, fD_2 )

max_ordered( fD_2, fD_3 )

</code></pre>

<hr>
<h2 id='maxima'>Maxima of a univariate functional dataset</h2><span id='topic+maxima'></span>

<h3>Description</h3>

<p>This function computes the maximum value of each element of a univariate
functional dataset, optionally returning also the value of the grid where
they are fulfilled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxima(fData, ..., which = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxima_+3A_fdata">fData</code></td>
<td>
<p>the functional dataset containing elements whose maxima have to
be computed, in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="maxima_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
<tr><td><code id="maxima_+3A_which">which</code></td>
<td>
<p>logical flag specifying whether the grid values where maxima are
fulfilled have to be returned too.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>which = FALSE</code>, the function returns a vector containing the
maxima for each element of the functional dataset; if <code>which = TRUE</code>,
the function returns a <code>data.frame</code> whose field <code>value</code> contains
the values of maxima, and <code>grid</code> contains the grid points where maxima
are reached.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minima">minima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P = 1e3

grid = seq( 0, 1, length.out = P )

Data = matrix( c( 1 * grid,
                  2 *  grid,
                  3 * ( 0.5 - abs( grid - 0.5 ) ) ),
               nrow = 3, ncol = P, byrow = TRUE )

fD = fData( grid, Data )

maxima( fD, which = TRUE )

</code></pre>

<hr>
<h2 id='MBD'>Modified Band Depth for univariate functional data</h2><span id='topic+MBD'></span><span id='topic+MBD.fData'></span><span id='topic+MBD.default'></span>

<h3>Description</h3>

<p>This function computes the Modified Band Depth (MBD) of elements of a
functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MBD(Data, manage_ties = FALSE)

## S3 method for class 'fData'
MBD(Data, manage_ties = FALSE)

## Default S3 method:
MBD(Data, manage_ties = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MBD_+3A_data">Data</code></td>
<td>
<p>either a <code>fData</code> object or a matrix-like dataset of functional
data (e.g. <code>fData$values</code>), with observations as rows and measurements
over grid points as columns.</p>
</td></tr>
<tr><td><code id="MBD_+3A_manage_ties">manage_ties</code></td>
<td>
<p>a logical flag specifying whether a check for ties and
relative treatment must be carried out or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
defined over a compact interval <code class="reqn">I= [a,b]</code>,
this function computes the sample MBD of each element with respect to the
other elements of the dataset, i.e.:
</p>
<p style="text-align: center;"><code class="reqn"> MBD( X( t ) ) = {N \choose 2 }^{-1} \sum_{1 \leq i_1 &lt; i_2 \leq N}
\tilde{\lambda}\big( {t : \min( X_{i_1}(t), X_{i_2}(t) ) \leq X(t) \leq
\max( X_{i_1}(t), X_{i_2}(t) ) } \big), </code>
</p>

<p>where <code class="reqn">\tilde{\lambda}(\cdot)</code> is the normalized Lebesgue measure over
<code class="reqn">I=[a,b]</code>, that is <code class="reqn">\tilde{\lambda(A)} = \lambda( A ) / ( b - a )</code>.
</p>
<p>See the References section for more details.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the values of MBD for the
given dataset.
</p>


<h3>References</h3>

<p>Lopez-Pintado, S. and Romo, J. (2009). On the Concept of Depth for Functional
Data, <em>Journal of the American Statistical Association</em>, 104, 718-734.
</p>
<p>Lopez-Pintado, S. and Romo. J. (2007). Depth-based inference for functional
data, <em>Computational Statistics &amp; Data Analysis</em> 51, 4957-4968.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BD">BD</a></code>, <code><a href="#topic+MBD_relative">MBD_relative</a></code>,
<code><a href="#topic+BD_relative">BD_relative</a></code>, <code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid = seq( 0, 1, length.out = 1e2 )


D = matrix( c( 1 + sin( 2 * pi * grid ),
               0 + sin( 4 * pi * grid ),
               1 - sin( pi * ( grid - 0.2 ) ),
               0.1 + cos( 2 * pi * grid ),
               0.5 + sin( 3 * pi + grid ),
               -2 + sin( pi * grid ) ),
            nrow = 6, ncol = length( grid ), byrow = TRUE )

fD = fData( grid, D )

MBD( fD )

MBD( D )

</code></pre>

<hr>
<h2 id='MBD_relative'>Relative Modified Band Depth of functions in a univariate functional dataset</h2><span id='topic+MBD_relative'></span><span id='topic+MBD_relative.fData'></span><span id='topic+MBD_relative.default'></span>

<h3>Description</h3>

<p>This function computes Modified Band Depth (BD) of elements of a univariate
functional dataset with respect to another univariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MBD_relative(Data_target, Data_reference)

## S3 method for class 'fData'
MBD_relative(Data_target, Data_reference)

## Default S3 method:
MBD_relative(Data_target, Data_reference)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MBD_relative_+3A_data_target">Data_target</code></td>
<td>
<p>is the univariate functional dataset, provided either as
an <code>fData</code> object or in matrix
form (N observations as rows and P measurements as columns), whose MBD
have to be computed with respect to the reference dataset.</p>
</td></tr>
<tr><td><code id="MBD_relative_+3A_data_reference">Data_reference</code></td>
<td>
<p>is the dataset, provided either as an <code>fData</code>
object or in matrix form (N observations
as rows and P measurements as columns), containing the reference
univariate functional data that must be used to compute the MBD of
elements in <code>Data_target</code>. If <code>Data_target</code> is <code>fData</code>, it
must be of class <code>fData</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset of elements <code class="reqn">X_1(t), X_2(t),
\ldots, X_N(t)</code>, and another univariate functional dataset of elements
<code class="reqn">Y_1(t), Y_2(t) \ldots, Y_M(t)</code>, defined over the same compact interval
<code class="reqn">I=[a,b]</code>, this function computes the MBD of
elements of the former with respect to elements of the latter, i.e.:
</p>
<p style="text-align: center;"><code class="reqn"> MBD( X_i( t ) ) = {M \choose 2 }^{-1} \sum_{1 \leq i_1 &lt; i_2 \leq M}
\tilde{\lambda}\big( {t : \min( Y_{i_1}(t), Y_{i_2}(t) ) \leq X_i(t) \leq
\max( Y_{i_1}(t), Y_{i_2}(t) ) } \big),</code>
</p>

<p><code class="reqn">\forall i = 1, \ldots, N</code>, where <code class="reqn">\tilde{\lambda}(\cdot)</code> is the
normalized Lebesgue measure over <code class="reqn">I=[a,b]</code>, that is
<code class="reqn">\tilde{\lambda(A)} = \lambda( A ) / ( b - a )</code>.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the MBD of elements in
<code>Data_target</code> with respect to elements in <code>Data_reference</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MBD">MBD</a></code>, <code><a href="#topic+BD">BD</a></code>, <code><a href="#topic+BD_relative">BD_relative</a></code>,
<code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid = seq( 0, 1, length.out = 1e2 )

Data_ref = matrix( c( 0  + sin( 2 * pi * grid ),
                      1  + sin( 2 * pi * grid ),
                      -1 + sin( 2 * pi * grid ) ),
                   nrow = 3, ncol = length( grid ), byrow = TRUE )

Data_test_1 = matrix( c( 0.6 + sin( 2 * pi * grid ) ),
                      nrow = 1, ncol = length( grid ), byrow = TRUE )

Data_test_2 = matrix( c( 0.6 + sin( 2 * pi * grid ) ),
                      nrow = length( grid ), ncol = 1, byrow = TRUE )

Data_test_3 = 0.6 + sin( 2 * pi * grid )

Data_test_4 = array( 0.6 + sin( 2 * pi * grid ), dim = length( grid ) )

Data_test_5 = array( 0.6 + sin( 2 * pi * grid ), dim = c( 1, length( grid ) ) )

Data_test_6 = array( 0.6 + sin( 2 * pi * grid ), dim = c( length( grid ), 1 ) )

Data_test_7 = matrix( c( 0.5  + sin( 2 * pi * grid ),
                         -0.5 + sin( 2 * pi * grid ),
                         1.1 + sin( 2 * pi * grid ) ),
                      nrow = 3, ncol = length( grid ), byrow = TRUE )

fD_ref = fData( grid, Data_ref )
fD_test_1 = fData( grid, Data_test_1 )
fD_test_2 = fData( grid, Data_test_2 )
fD_test_3 = fData( grid, Data_test_3 )
fD_test_4 = fData( grid, Data_test_4 )
fD_test_5 = fData( grid, Data_test_5 )
fD_test_6 = fData( grid, Data_test_6 )
fD_test_7 = fData( grid, Data_test_7 )

MBD_relative( fD_test_1, fD_ref )
MBD_relative( Data_test_1, Data_ref )

MBD_relative( fD_test_2, fD_ref )
MBD_relative( Data_test_2, Data_ref )

MBD_relative( fD_test_3, fD_ref )
MBD_relative( Data_test_3, Data_ref )

MBD_relative( fD_test_4, fD_ref )
MBD_relative( Data_test_4, Data_ref )

MBD_relative( fD_test_5, fD_ref )
MBD_relative( Data_test_5, Data_ref )

MBD_relative( fD_test_6, fD_ref )
MBD_relative( Data_test_6, Data_ref )

MBD_relative( fD_test_7, fD_ref )
MBD_relative( Data_test_7, Data_ref )


</code></pre>

<hr>
<h2 id='mean.fData'>Cross-sectional mean of of a fData object.</h2><span id='topic+mean.fData'></span>

<h3>Description</h3>

<p>This <code>S3</code> method implements the <b>cross-sectional</b> mean of a
univariate functional dataset stored in a <code>fData</code> object, i.e. the
mean computed point-by-point along the grid over which the dataset is
defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fData'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.fData_+3A_x">x</code></td>
<td>
<p>the univariate functional dataset whose cross-sectional mean must be
computed, in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="mean.fData_+3A_...">...</code></td>
<td>
<p>possible additional parameters. This argument is kept for
compatibility with the <code>S3</code> definition of <code>mean</code>, but it is not
actually used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>fData</code> object with one observation
defined on the same grid as the argument <code>x</code>'s representing the
desired cross-sectional mean.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 1e2
P = 1e2
grid = seq( 0, 1, length.out = P )

# Generating a gaussian functional sample with desired mean
target_mean = sin( 2 * pi * grid )
C = exp_cov_function( grid, alpha = 0.2, beta = 0.2 )
fD = fData( grid, generate_gauss_fdata( N,
                                      centerline = target_mean,
                                       Cov = C ) )

# Graphical representation of the mean
plot( fD )
plot( mean( fD ), col = 'black', lwd = 2, lty = 2, add = TRUE )


</code></pre>

<hr>
<h2 id='mean.mfData'>Cross-sectional mean of of a mfData object.</h2><span id='topic+mean.mfData'></span>

<h3>Description</h3>

<p>This <code>S3</code> method implements the <b>cross-sectional</b> mean of a
multivariate functional dataset stored in a <code>mfData</code> object, i.e. the
mean computed point-by-point along the grid over which the dataset is
defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfData'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.mfData_+3A_x">x</code></td>
<td>
<p>the multivariate functional dataset whose cross-sectional mean must
be computed, in form of <code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="mean.mfData_+3A_...">...</code></td>
<td>
<p>possible additional parameters. This argument is kept for
compatibility with the <code>S3</code> definition of <code>mean</code>, but it is not
actually used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>mfData</code> object with one observation
defined on the same grid as the argument <code>x</code>'s representing the
desired cross-sectional mean.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 1e2
L = 3
P = 1e2
grid = seq( 0, 1, length.out = P )

# Generating a gaussian functional sample with desired mean
target_mean = sin( 2 * pi * grid )
C = exp_cov_function( grid, alpha = 0.2, beta = 0.2 )
# Independent components
correlations = c( 0, 0, 0 )
mfD = mfData( grid,
              generate_gauss_mfdata( N, L,
                                     correlations = correlations,
                                     centerline = matrix( target_mean,
                                                          nrow = 3,
                                                          ncol = P,
                                                          byrow = TRUE ),
                                     listCov = list( C, C, C ) )
)

# Graphical representation of the mean
oldpar &lt;- par(mfrow = c(1, 1))
par(mfrow = c(1, L))

for(iL in 1:L)
{
  plot(mfD$fDList[[iL]])
  plot(
    mean(mfD)$fDList[[iL]],
    col = 'black',
    lwd = 2,
    lty = 2,
    add = TRUE
  )
}

par(oldpar)

</code></pre>

<hr>
<h2 id='median_fData'>Median of a univariate functional dataset</h2><span id='topic+median_fData'></span>

<h3>Description</h3>

<p>This method computes the sample median of a univariate functional dataset
based on a definition of depth for univariate functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_fData(fData, type = "MBD", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_fData_+3A_fdata">fData</code></td>
<td>
<p>the univariate functional dataset whose
median is required, in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="median_fData_+3A_type">type</code></td>
<td>
<p>a string specifying the name of the function defining the depth
for univariate data to be used. It must be a valid name of a function defined
in the current environment, default is <code>MBD</code>.</p>
</td></tr>
<tr><td><code id="median_fData_+3A_...">...</code></td>
<td>
<p>additional parameters to be used in the function specified by
argument <code>type</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provided a definition of functional depth for univariate data,
the corresponding median (i.e. the deepest element of the sample) is returned as the desired median.
This method does <b>not</b> coincide with the computation of the
cross-sectional median of the sample of the point-by-point measurements on
the grid. Hence, the sample median is a member of the dataset provided.
</p>


<h3>Value</h3>

<p>The function returns a <code>fData</code> object containing the desired
sample median.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>, <code><a href="#topic+mean.fData">mean.fData</a></code>,
<code><a href="#topic+median_mfData">median_mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 1e2
P = 1e2
grid = seq( 0, 1, length.out = P )

# Generating a gaussian functional sample with desired mean
# Being the distribution symmetric, the sample mean and median are coincident
target_median = sin( 2 * pi * grid )
C = exp_cov_function( grid, alpha = 0.2, beta = 0.2 )
fD = fData( grid, generate_gauss_fdata( N,
                                      centerline = target_median,
                                       Cov = C ) )

# Graphical representation of the mean
plot( fD )
plot( median_fData( fD ), col = 'black', lwd = 2, lty = 2, add = TRUE )

</code></pre>

<hr>
<h2 id='median_mfData'>Median of a multivariate functional dataset</h2><span id='topic+median_mfData'></span>

<h3>Description</h3>

<p>This method computes the sample median of a multivariate functional dataset
based on a definition of depth for multivariate functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_mfData(mfData, type = "multiMBD", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_mfData_+3A_mfdata">mfData</code></td>
<td>
<p>the multivariate functional dataset whose
median is required, in form of <code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="median_mfData_+3A_type">type</code></td>
<td>
<p>a string specifying the name of the function defining the depth
for multivariate data to be used. It must be a valid name of a function
defined in the current environment, default is <code>multiMBD</code>.</p>
</td></tr>
<tr><td><code id="median_mfData_+3A_...">...</code></td>
<td>
<p>additional parameters to be used in the function specified by
argument <code>type</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provided a definition of functional depth for multivariate data,
the corresponding median (i.e. the deepest element of the sample) is returned
as the desired median.
This method does <b>not</b> coincide with the computation of the
cross-sectional median of the sample of the point-by-point measurements on
the grid. Hence, the sample median is a member of the dataset provided.
</p>


<h3>Value</h3>

<p>The function returns a <code>mfData</code> object containing the desired
sample median.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+mean.mfData">mean.mfData</a></code>,
<code><a href="#topic+median_fData">median_fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 1e2
L = 3
P = 1e2
grid = seq( 0, 1, length.out = P )

# Generating a gaussian functional sample with desired mean
# Being the distribution symmetric, the sample mean and median are coincident
target_median = sin( 2 * pi * grid )
C = exp_cov_function( grid, alpha = 0.2, beta = 0.2 )

# Strongly dependent components
correlations = c( 0.9, 0.9, 0.9 )
mfD = mfData( grid,
              generate_gauss_mfdata( N, L,
                                     correlations = correlations,
                                     centerline = matrix( target_median,
                                                          nrow = 3,
                                                          ncol = P,
                                                          byrow = TRUE ),
                                     listCov = list( C, C, C ) )
)

med_mfD = median_mfData( mfD, type = 'multiMBD', weights = 'uniform' )

# Graphical representation of the mean
oldpar &lt;- par(mfrow = c(1, 1))
par(mfrow = c(1, L))

for(iL in 1:L)
{
  plot(mfD$fDList[[iL]])
  plot(
    med_mfD$fDList[[iL]],
    col = 'black',
    lwd = 2,
    lty = 2,
    add = TRUE
  )
}

par(oldpar)

</code></pre>

<hr>
<h2 id='MEI'>Modified Epigraph Index of univariate functional dataset</h2><span id='topic+MEI'></span><span id='topic+MEI.fData'></span><span id='topic+MEI.default'></span>

<h3>Description</h3>

<p>This function computes the Modified Epigraphic Index (MEI) of elements of a
univariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEI(Data)

## S3 method for class 'fData'
MEI(Data)

## Default S3 method:
MEI(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEI_+3A_data">Data</code></td>
<td>
<p>either an <code>fData</code> object or a matrix-like dataset of
functional data (e.g. <code>fData$values</code>),
with observations as rows and measurements over grid points as columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
defined over a compact interval <code class="reqn">I=[a,b]</code>, this function computes the
MEI, i.e.:
</p>
<p style="text-align: center;"><code class="reqn">MEI( X(t) ) = \frac{1}{N} \sum_{i=1}^N \tilde{\lambda}( X(t) \leq
X_i(t) ), </code>
</p>

<p>where <code class="reqn">\tilde{\lambda}(\cdot)</code> is the normalized Lebesgue measure over
<code class="reqn">I=[a,b]</code>, that is <code class="reqn">\tilde{\lambda(A)} = \lambda( A ) / ( b - a )</code>.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the values of MEI for each
element of the functional dataset provided in <code>Data</code>.
</p>


<h3>References</h3>

<p>Lopez-Pintado, S. and Romo, J. (2012). A half-region depth for functional
data, <em>Computational Statistics and Data Analysis</em>, 55, 1679-1695.
</p>
<p>Arribas-Gil, A., and Romo, J. (2014). Shape outlier detection and
visualization for functional data: the outliergram, <em>Biostatistics</em>,
15(4), 603-619.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EI">EI</a></code>, <code><a href="#topic+MHI">MHI</a></code>, <code><a href="#topic+HI">HI</a></code>,
<code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e2

grid = seq( 0, 1, length.out = P )

C = exp_cov_function( grid, alpha = 0.2, beta = 0.3 )

Data = generate_gauss_fdata( N,
                             centerline = sin( 2 * pi * grid ),
                             C )

fD = fData( grid, Data )

MEI( fD )

MEI( Data )

</code></pre>

<hr>
<h2 id='mfD_healthy'>ECG trace of healthy subjects</h2><span id='topic+mfD_healthy'></span>

<h3>Description</h3>

<p>A dataset containing the 8-Lead ECG traces of 50 healthy subjects. They can be used to compare the
signals of pathological subjects stored in <code>mfD_LBBB</code> and <code>mfD_RBBB</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfD_healthy
</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+mfData">mfData</a></code> object.
</p>


<h3>Details</h3>

<p>The 8 leads are, in order, V1, V2, V3, V4, V5, D1 and D2. The signals have been registered and
smoothed over an evenly spaced grid of 1024 time points at 1kHz.
</p>

<hr>
<h2 id='mfD_LBBB'>ECG trace of subjects suffering from Left-Bundle-Branch-Block (LBBB)</h2><span id='topic+mfD_LBBB'></span>

<h3>Description</h3>

<p>A dataset containing the 8-Lead ECG traces of 50 subjects suffering from
Left-Bundle-Branch-Block (LBBB), a cardiac pathology affecting the conduction process and resulting
in some peculiar distortions of the ECG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfD_LBBB
</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+mfData">mfData</a></code> object.
</p>


<h3>Details</h3>

<p>The 8 leads are, in order, V1, V2, V3, V4, V5, D1 and D2. The signals have been registered and
smoothed over an evenly spaced grid of 1024 time points at 1kHz.
</p>

<hr>
<h2 id='mfData'><code>S3</code> class for multivariate functional datasets</h2><span id='topic+mfData'></span>

<h3>Description</h3>

<p>This function implements a constructor for elements of <code>S3</code> class
<code>mfData</code>, aimed at implementing a representation of a multivariate
functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfData(grid, Data_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfData_+3A_grid">grid</code></td>
<td>
<p>the (evenly spaced) grid over which the functional dataset is
defined.</p>
</td></tr>
<tr><td><code id="mfData_+3A_data_list">Data_list</code></td>
<td>
<p>a <code>list</code> containing the <code>L</code> components of the
multivariate functional dataset, defined as 2D data structures (e.g. matrix
or array) having as rows the <code>N</code> observations and as columns the
<code>P</code> measurements on the grid provided by <code>grid</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional dataset is represented as a collection of <code>L</code> components,
each one an object of class <code>fData</code>. Each component must contain elements
defined on the same grid as the others, and must contain the same number of
elements (<code>N</code>).
</p>


<h3>Value</h3>

<p>The function returns a <code>S3</code> object of class <code>mfData</code>, containing
the following elements:
</p>

<ul>
<li><p>&quot;<code>N</code>&quot;: the number of elements in the dataset;
</p>
</li>
<li><p>&quot;<code>L</code>&quot;: the number of components of the functional dataset;
</p>
</li>
<li><p>&quot;<code>P</code>&quot;: the number of points in the 1D grid over which elements
are measured;
</p>
</li>
<li><p>&quot;<code>t0</code>&quot;: the starting point of the 1D grid;
</p>
</li>
<li><p>&quot;<code>tP</code>&quot;: the ending point of the 1D grid;
</p>
</li>
<li><p>&quot;<code>fDList</code>&quot;: the list of <code>fData</code> objects representing the
<code>L</code> components as corresponding univariate functional datasets.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>, <code><a href="#topic+generate_gauss_fdata">generate_gauss_fdata</a></code>,
<code><a href="#topic+generate_gauss_mfdata">generate_gauss_mfdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining parameters
N = 1e2

P = 1e3

t0 = 0
t1 = 1

# Defining the measurement grid
grid = seq( t0, t1, length.out = P )

# Generating an exponential covariance matrix to be used in the simulation of
# the functional datasets (see the related help for details)
C = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Simulating the measurements of two univariate functional datasets with
# required center and covariance function
Data_1 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = C )
Data_2 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = C )

# Building the mfData object
mfData( grid, list( Data_1, Data_2 ) )

</code></pre>

<hr>
<h2 id='MHI'>Modified Hypograph Index of univariate functional dataset</h2><span id='topic+MHI'></span><span id='topic+MHI.fData'></span><span id='topic+MHI.default'></span>

<h3>Description</h3>

<p>This function computes the Modified Hypograph Index (MEI) of elements of a
univariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MHI(Data)

## S3 method for class 'fData'
MHI(Data)

## Default S3 method:
MHI(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MHI_+3A_data">Data</code></td>
<td>
<p>either an <code>fData</code> object or a matrix-like dataset of
functional data (e.g. <code>fData$values</code>),
with observations as rows and measurements over grid points as columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
defined over a compact interval <code class="reqn">I=[a,b]</code>, this function computes the
MHI, i.e.:
</p>
<p style="text-align: center;"><code class="reqn">MHI( X(t) ) = \frac{1}{N} \sum_{i=1}^N \tilde{\lambda}( X(t) \geq
X_i(t) ), </code>
</p>

<p>where <code class="reqn">\tilde{\lambda}(\cdot)</code> is the normalized Lebesgue measure over
<code class="reqn">I=[a,b]</code>, that is <code class="reqn">\tilde{\lambda(A)} = \lambda( A ) / ( b - a )</code>.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the values of MHI for each
element of the functional dataset provided in <code>Data</code>.
</p>


<h3>References</h3>

<p>Lopez-Pintado, S. and Romo, J. (2012). A half-region depth for functional
data, <em>Computational Statistics and Data Analysis</em>, 55, 1679-1695.
</p>
<p>Arribas-Gil, A., and Romo, J. (2014). Shape outlier detection and
visualization for functional data: the outliergram, <em>Biostatistics</em>,
15(4), 603-619.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HI">HI</a></code>, <code><a href="#topic+MEI">MEI</a></code>, <code><a href="#topic+EI">EI</a></code>,
<code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e2

grid = seq( 0, 1, length.out = P )

C = exp_cov_function( grid, alpha = 0.2, beta = 0.3 )

Data = generate_gauss_fdata( N,
                             centerline = sin( 2 * pi * grid ),
                             C )
fD = fData( grid, Data )

MHI( fD )

MHI( Data )

</code></pre>

<hr>
<h2 id='MHRD'>Modified Half-Region Depth for univariate functional data</h2><span id='topic+MHRD'></span><span id='topic+MHRD.fData'></span><span id='topic+MHRD.default'></span>

<h3>Description</h3>

<p>This function computes the Modified Half-Region Depth (MHRD) of elements of
a univariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MHRD(Data)

## S3 method for class 'fData'
MHRD(Data)

## Default S3 method:
MHRD(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MHRD_+3A_data">Data</code></td>
<td>
<p>either an <code>fData</code> object or a matrix-like dataset of
functional data (e.g. <code>fData$values</code>),
with observations as rows and measurements over grid points as columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset, <code class="reqn">X_1(t), X_2(t), \ldots, X_N(t)</code>,
defined over a compact interval <code class="reqn">I=[a,b]</code>, this function computes the MHRD
of its elements, i.e.:
</p>
<p style="text-align: center;"><code class="reqn">MHRD(X(t)) = \min( MEI( X(t) ), MHI(X(t)) ),</code>
</p>

<p>where <code class="reqn">MEI(X(t))</code> indicates the Modified Epigraph Index (MEI) of
<code class="reqn">X(t)</code> with respect to the dataset, and <code class="reqn">MHI(X(t))</code> indicates the
Modified Hypograph Index of <code class="reqn">X(t)</code> with respect to the dataset.
</p>


<h3>Value</h3>

<p>The function returns a vector containing the values of MHRD for each
element of the functional dataset provided in <code>Data</code>.
</p>


<h3>References</h3>

<p>Lopez-Pintado, S. and Romo, J. (2012). A half-region depth for functional
data, <em>Computational Statistics and Data Analysis</em>, 55, 1679-1695.
</p>
<p>Arribas-Gil, A., and Romo, J. (2014). Shape outlier detection and
visualization for functional data: the outliergram, <em>Biostatistics</em>,
15(4), 603-619.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HRD">HRD</a></code>, <code><a href="#topic+MEI">MEI</a></code>, <code><a href="#topic+MHI">MHI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e2

grid = seq( 0, 1, length.out = P )

C = exp_cov_function( grid, alpha = 0.2, beta = 0.3 )

Data = generate_gauss_fdata( N,
                             centerline = sin( 2 * pi * grid ),
                             C )
fD = fData( grid, Data )

MHRD( fD )

MHRD( Data )

</code></pre>

<hr>
<h2 id='minima'>Minima of a univariate functional dataset</h2><span id='topic+minima'></span>

<h3>Description</h3>

<p>This function computes computes the minimum value of each element of a
univariate functional dataset, optionally returning also the value of the grid
where they are fulfilled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minima(fData, ..., which = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minima_+3A_fdata">fData</code></td>
<td>
<p>the functional dataset containing elements whose minima have to
be computed, in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="minima_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
<tr><td><code id="minima_+3A_which">which</code></td>
<td>
<p>logical flag specifying whether the grid values where minima are
fulfilled have to be returned too.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>which = FALSE</code>, the function returns a vector containing the
minima for each element of the functional dataset; if <code>which = TRUE</code>,
the function returns a <code>data.frame</code> whose field <code>value</code> contains
the values of minima, and <code>grid</code> contains the grid points where minima
are reached.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxima">maxima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P = 1e3

grid = seq( 0, 1, length.out = P )

Data = matrix( c( 1 * grid,
                  2 *  grid,
                  3 * ( 0.5 - abs( grid - 0.5 ) ) ),
               nrow = 3, ncol = P, byrow = TRUE )

fD = fData( grid, Data )

minima( fD, which = TRUE )

</code></pre>

<hr>
<h2 id='multiMBD'>(Modified) Band Depth for multivariate functional data</h2><span id='topic+multiMBD'></span><span id='topic+multiMBD.mfData'></span><span id='topic+multiMBD.default'></span><span id='topic+multiBD'></span><span id='topic+multiBD.mfData'></span><span id='topic+multiBD.default'></span>

<h3>Description</h3>

<p>These functions compute the Band Depth (BD) and Modified Band Depth (MBD) of
elements of a multivariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiMBD(Data, weights = "uniform", manage_ties = FALSE)

## S3 method for class 'mfData'
multiMBD(Data, weights = "uniform", manage_ties = FALSE)

## Default S3 method:
multiMBD(Data, weights = "uniform", manage_ties = FALSE)

multiBD(Data, weights = "uniform")

## S3 method for class 'mfData'
multiBD(Data, weights = "uniform")

## Default S3 method:
multiBD(Data, weights = "uniform")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiMBD_+3A_data">Data</code></td>
<td>
<p>specifies the the multivariate functional dataset.
It is either an object of class <code>mfData</code> or a list of 2-dimensional
matrices having as rows the elements of that component and as columns the
measurements of the functional data over the grid.</p>
</td></tr>
<tr><td><code id="multiMBD_+3A_weights">weights</code></td>
<td>
<p>either a set of weights (of the same length of <code>Data</code>
) or the string <code>"uniform"</code> specifying that a set of uniform weights
(of value <code class="reqn">1 / L</code>, where <code class="reqn">L</code> is the number of dimensions of the
functional dataset and thus the length of <code>Data</code>) is to be used.</p>
</td></tr>
<tr><td><code id="multiMBD_+3A_manage_ties">manage_ties</code></td>
<td>
<p>a logical flag specifying whether the check for ties and
the relative treatment is to be carried out while computing the MBDs in each
dimension. It is directly passed to <code>MBD</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a multivariate functional dataset composed of <code class="reqn">N</code> elements with
<code class="reqn">L</code> components each, <code class="reqn">\mathbf{X_1} =( X^1_1(t),</code> <code class="reqn">X^2_1(t),
\ldots, X^L_1(t))</code>, and a set of <code class="reqn">L</code> non-negative weights,
</p>
<p style="text-align: center;"><code class="reqn"> w_1, w_2, \ldots, w_L, \qquad \sum_{i=1}^L w_i = 1,</code>
</p>

<p>these functions compute the BD and MBD of each element of the functional
dataset, namely:
</p>
<p style="text-align: center;"><code class="reqn"> BD( \mathbf{X_j} ) = \sum_{i=1}^{L} w_i BD( X^i_j ), \quad \forall
j = 1, \ldots N.</code>
</p>

<p style="text-align: center;"><code class="reqn"> MBD( \mathbf{X_j} ) = \sum_{i=1}^{L} w_i MBD( X^i_j ), \quad \forall
j = 1, \ldots N.</code>
</p>



<h3>Value</h3>

<p>The function returns a vector containing the depths of each element
of the multivariate functional dataset.
</p>


<h3>References</h3>

<p>Ieva, F. and Paganoni, A. M. (2013). Depth measures for multivariate
functional data, <em>Communications in Statistics: Theory and Methods</em>,
41, 1265-1276.
</p>
<p>Tarabelloni, N., Ieva, F., Biasi, R. and Paganoni, A. M. (2015). Use of
Depth Measure for Multivariate Functional Data in Disease Prediction: An
Application to Electrocardiograph Signals, <em>International Journal of
Biostatistics</em>, 11.2, 189-201.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MBD">MBD</a></code>, <code><a href="#topic+BD">BD</a></code>, <code><a href="#topic+toListOfValues">toListOfValues</a></code>,
<code><a href="#topic+mfData">mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e3

grid = seq( 0, 10, length.out = P )

# Generating an exponential covariance function to be used to simulate gaussian
# functional data
Cov = exp_cov_function( grid, alpha = 0.2, beta = 0.8 )

# First component of the multivariate guassian functional dataset
Data_1 = generate_gauss_fdata( N, centerline = rep( 0, P ), Cov = Cov )

# First component of the multivariate guassian functional dataset
Data_2 = generate_gauss_fdata( N, centerline = rep( 0, P ), Cov = Cov )

mfD = mfData( grid, list( Data_1, Data_2 ) )

multiBD( mfD, weights = 'uniform' )
multiMBD( mfD, weights = 'uniform', manage_ties = TRUE )

multiBD( mfD, weights = c( 1/3, 2/3 ))
multiMBD( mfD, weights = c( 1/3, 2/3 ), manage_ties = FALSE )

multiBD( list( Data_1, Data_2 ), weights = 'uniform')
multiMBD( list( Data_1, Data_2 ), weights = 'uniform', manage_ties = TRUE )

multiBD( list( Data_1, Data_2 ), weights = c( 1/3, 2/3 ))
multiMBD( list( Data_1, Data_2 ), weights = c( 1/3, 2/3 ), manage_ties = FALSE )

</code></pre>

<hr>
<h2 id='multiMEI'>Modified Epigraph Index for multivariate functional data</h2><span id='topic+multiMEI'></span><span id='topic+multiMEI.mfData'></span><span id='topic+multiMEI.default'></span>

<h3>Description</h3>

<p>These functions compute the Modified Epigraph Index of
elements of a multivariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiMEI(Data, weights = "uniform")

## S3 method for class 'mfData'
multiMEI(Data, weights = "uniform")

## Default S3 method:
multiMEI(Data, weights = "uniform")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiMEI_+3A_data">Data</code></td>
<td>
<p>specifies the the multivariate functional dataset.
It is either an object of class <code>mfData</code> or a list of 2-dimensional
matrices having as rows the elements of that component and as columns the
measurements of the functional data over the grid.</p>
</td></tr>
<tr><td><code id="multiMEI_+3A_weights">weights</code></td>
<td>
<p>either a set of weights (of the same length of <code>Data</code>
) or the string <code>"uniform"</code> specifying that a set of uniform weights
(of value <code class="reqn">1 / L</code>, where <code class="reqn">L</code> is the number of dimensions of the
functional dataset and thus the length of <code>Data</code>) is to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a multivariate functional dataset composed of <code class="reqn">N</code> elements with
<code class="reqn">L</code> components each, <code class="reqn">\mathbf{X_1} =( X^1_1(t),</code> <code class="reqn">X^2_1(t),
\ldots, X^L_1(t))</code>, and a set of <code class="reqn">L</code> non-negative weights,
</p>
<p style="text-align: center;"><code class="reqn"> w_1, w_2, \ldots, w_L, \qquad \sum_{i=1}^L w_i = 1,</code>
</p>

<p>these functions compute the MEI of each element of the functional
dataset, namely:
</p>
<p style="text-align: center;"><code class="reqn"> MEI( \mathbf{X_j} ) = \sum_{i=1}^{L} w_i MEI( X^i_j ), \quad \forall
j = 1, \ldots N.</code>
</p>



<h3>Value</h3>

<p>The function returns a vector containing the values of MEI of each element
of the multivariate functional dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+MEI">MEI</a></code>, <code><a href="#topic+MHI">MHI</a></code>, <code><a href="#topic+multiMHI">multiMHI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 20
P = 1e3

grid = seq( 0, 10, length.out = P )

# Generating an exponential covariance function to be used to simulate gaussian
# functional data
Cov = exp_cov_function( grid, alpha = 0.2, beta = 0.8 )

# First component of the multivariate guassian functional dataset
Data_1 = generate_gauss_fdata( N, centerline = rep( 0, P ), Cov = Cov )

# First component of the multivariate guassian functional dataset
Data_2 = generate_gauss_fdata( N, centerline = rep( 0, P ), Cov = Cov )

mfD = mfData( grid, list( Data_1, Data_2 ) )

# Uniform weights
multiMEI( mfD, weights = 'uniform' )

# Non-uniform, custom weights
multiMEI( mfD, weights = c(2/3, 1/3) )

</code></pre>

<hr>
<h2 id='multiMHI'>Modified Hypograph Index for multivariate functional data</h2><span id='topic+multiMHI'></span><span id='topic+multiMHI.mfData'></span><span id='topic+multiMHI.default'></span>

<h3>Description</h3>

<p>These functions compute the Modified Hypograph Index of
elements of a multivariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiMHI(Data, weights = "uniform")

## S3 method for class 'mfData'
multiMHI(Data, weights = "uniform")

## Default S3 method:
multiMHI(Data, weights = "uniform")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiMHI_+3A_data">Data</code></td>
<td>
<p>specifies the the multivariate functional dataset.
It is either an object of class <code>mfData</code> or a list of 2-dimensional
matrices having as rows the elements of that component and as columns the
measurements of the functional data over the grid.</p>
</td></tr>
<tr><td><code id="multiMHI_+3A_weights">weights</code></td>
<td>
<p>either a set of weights (of the same length of <code>Data</code>
) or the string <code>"uniform"</code> specifying that a set of uniform weights
(of value <code class="reqn">1 / L</code>, where <code class="reqn">L</code> is the number of dimensions of the
functional dataset and thus the length of <code>Data</code>) is to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a multivariate functional dataset composed of <code class="reqn">N</code> elements with
<code class="reqn">L</code> components each, <code class="reqn">\mathbf{X_1} =( X^1_1(t),</code> <code class="reqn">X^2_1(t),
\ldots, X^L_1(t))</code>, and a set of <code class="reqn">L</code> non-negative weights,
</p>
<p style="text-align: center;"><code class="reqn"> w_1, w_2, \ldots, w_L, \qquad \sum_{i=1}^L w_i = 1,</code>
</p>

<p>these functions compute the MHI of each element of the functional
dataset, namely:
</p>
<p style="text-align: center;"><code class="reqn"> MHI( \mathbf{X_j} ) = \sum_{i=1}^{L} w_i MHI( X^i_j ), \quad \forall
j = 1, \ldots N.</code>
</p>



<h3>Value</h3>

<p>The function returns a vector containing the values of MHI of each element
of the multivariate functional dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+MHI">MHI</a></code>, <code><a href="#topic+MEI">MEI</a></code>, <code><a href="#topic+multiMEI">multiMEI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 20
P = 1e3

grid = seq( 0, 10, length.out = P )

# Generating an exponential covariance function to be used to simulate gaussian
# functional data
Cov = exp_cov_function( grid, alpha = 0.2, beta = 0.8 )

# First component of the multivariate guassian functional dataset
Data_1 = generate_gauss_fdata( N, centerline = rep( 0, P ), Cov = Cov )

# First component of the multivariate guassian functional dataset
Data_2 = generate_gauss_fdata( N, centerline = rep( 0, P ), Cov = Cov )

mfD = mfData( grid, list( Data_1, Data_2 ) )

# Uniform weights
multiMHI( mfD, weights = 'uniform' )

# Non-uniform, custom weights
multiMHI( mfD, weights = c(2/3, 1/3) )

</code></pre>

<hr>
<h2 id='multivariate_outliergram'>Outliergram for multivariate functional datasets</h2><span id='topic+multivariate_outliergram'></span>

<h3>Description</h3>

<p>This function performs the outliergram of a multivariate functional dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivariate_outliergram(
  mfData,
  MBD_data = NULL,
  MEI_data = NULL,
  weights = "uniform",
  p_check = 0.05,
  Fvalue = 1.5,
  shift = TRUE,
  display = TRUE,
  xlab = NULL,
  ylab = NULL,
  main = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multivariate_outliergram_+3A_mfdata">mfData</code></td>
<td>
<p>the multivariate functional dataset whose outliergram has to be
determined;</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_mbd_data">MBD_data</code></td>
<td>
<p>a vector containing the MBD for each element of the dataset; If missing, MBDs
are computed with the specified choice of weights;</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_mei_data">MEI_data</code></td>
<td>
<p>a vector containing the MEI for each element of the dataset.
If not not provided, MEIs are computed;</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_weights">weights</code></td>
<td>
<p>the weights choice to be used to compute multivariate MBDs and MEIs;</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_p_check">p_check</code></td>
<td>
<p>percentage of observations with either low or high MEI to be
checked for outliers in the secondary step (shift towards the center of the
dataset).</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_fvalue">Fvalue</code></td>
<td>
<p>the <code class="reqn">F</code> value to be used in the procedure that finds the
shape outliers by looking at the lower parabolic limit in the outliergram.
Default is <code>1.5</code>;</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_shift">shift</code></td>
<td>
<p>whether to apply the shifting algorithm to properly manage observations having low
or high MEI. Default is TRUE.</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_display">display</code></td>
<td>
<p>either a logical value indicating whether you want the
outliergram to be displayed, or the number of the graphical device
where you want the outliergram to be displayed;</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_xlab">xlab</code></td>
<td>
<p>the label to use on the x axis in the outliergram plot;</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_ylab">ylab</code></td>
<td>
<p>the label to use on the x axis in the outliergram plot;</p>
</td></tr>
<tr><td><code id="multivariate_outliergram_+3A_main">main</code></td>
<td>
<p>the title to use in the outliergram;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method applies the extension of the univariate outliergram to the case of multivariate
functional datasets. Differently from the function for the univariate case, only the
outliergram plot is displayed.
</p>


<h3>Adjustment</h3>

<p>Differently from the case of univariate functional data, in this case the function does not apply
an automatic tuning of the F parameter, since the related procedure would become computationally
too heavy for general datasets. If a good value of F is sought, it is recommended to run several
trials of the outliergram and manually select the best value.
</p>


<h3>References</h3>

<p>Ieva, F. &amp; Paganoni, A.M. Stat Papers (2017). https://doi.org/10.1007/s00362-017-0953-1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outliergram">outliergram</a></code>, <code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+MBD">MBD</a></code>,
<code><a href="#topic+MEI">MEI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 2e2
P = 1e2

t0 = 0
t1 = 1

set.seed(1)

# Defining the measurement grid
grid = seq( t0, t1, length.out = P )

# Generating an exponential covariance matrix to be used in the simulation of
# the functional datasets (see the related help for details)
C = exp_cov_function( grid, alpha = 0.3, beta = 0.2)

# Simulating the measurements of two univariate functional datasets with
# required center and covariance function
f1 = function(x) x * ( 1 - x )
f2 = function(x) x^3
Data = generate_gauss_mfdata( N, L = 2,
                              centerline = matrix(c(sin(2 * pi * grid),
                                                    cos(2 * pi * grid)), nrow=2, byrow=TRUE),
                              listCov = list(C, C), correlations = 0.1 )

# Building the mfData object
mfD = mfData( grid, Data )


dev.new()
out = multivariate_outliergram(mfD, Fvalue = 2., shift=TRUE)
col_non_outlying = scales::hue_pal( h = c( 180, 270 ),
                                    l = 60 )( N - length( out$ID_outliers ) )
col_non_outlying = set_alpha( col_non_outlying, 0.5 )
col_outlying = scales::hue_pal( h = c( - 90, 180  ),
                                c = 150 )( length( out$ID_outliers ) )
colors = rep('black', N)
colors[out$ID_outliers] = col_outlying
colors[colors == 'black'] = col_non_outlying

lwd = rep(1, N)
lwd[out$ID_outliers] = 2

dev.new()
plot(mfD, col=colors, lwd=lwd)

</code></pre>

<hr>
<h2 id='outliergram'>Outliergram for univariate functional data sets</h2><span id='topic+outliergram'></span>

<h3>Description</h3>

<p>This function performs the outliergram of a univariate functional data set,
possibly with an adjustment of the true positive rate of outliers discovered
under assumption of gaussianity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliergram(
  fData,
  MBD_data = NULL,
  MEI_data = NULL,
  p_check = 0.05,
  Fvalue = 1.5,
  adjust = FALSE,
  display = TRUE,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outliergram_+3A_fdata">fData</code></td>
<td>
<p>the univariate functional dataset whose outliergram has to be
determined.</p>
</td></tr>
<tr><td><code id="outliergram_+3A_mbd_data">MBD_data</code></td>
<td>
<p>a vector containing the MBD for each element of the dataset.
If missing, MBDs are computed.</p>
</td></tr>
<tr><td><code id="outliergram_+3A_mei_data">MEI_data</code></td>
<td>
<p>a vector containing the MEI for each element of the dataset.
If not not provided, MEIs are computed.</p>
</td></tr>
<tr><td><code id="outliergram_+3A_p_check">p_check</code></td>
<td>
<p>percentage of observations with either low or high MEI to be
checked for outliers in the secondary step (shift towards the center of the
dataset).</p>
</td></tr>
<tr><td><code id="outliergram_+3A_fvalue">Fvalue</code></td>
<td>
<p>the <code class="reqn">F</code> value to be used in the procedure that finds the
shape outliers by looking at the lower parabolic limit in the outliergram.
Default is <code>1.5</code>. You can also leave the default value and, by providing
the parameter <code>adjust</code>, specify that you want <code>Fvalue</code> to be
adjusted for the dataset provided in <code>fData</code>.</p>
</td></tr>
<tr><td><code id="outliergram_+3A_adjust">adjust</code></td>
<td>
<p>either <code>FALSE</code> if you would like the default value for the
inflation factor, <code class="reqn">F = 1.5</code>, to be used, or a list specifying the
parameters required by the adjustment.
</p>

<ul>
<li><p>&quot;<code>N_trials</code>&quot;: the number of repetitions of the adjustment
procedure based on the simulation of a gaussian population of functional
data, each one producing an adjusted value of <code class="reqn">F</code>, which will lead
to the averaged adjusted value <code class="reqn">\bar{F}</code>. Default is 20;
</p>
</li>
<li><p>&quot;<code>trial_size</code>&quot;: the number of elements in the gaussian
population of functional data that will be simulated at each repetition of
the adjustment procedure. Default is <code>5 * fData$N</code>;
</p>
</li>
<li><p>&quot;<code>TPR</code>&quot;: the True Positive Rate of outliers, i.e. the proportion
of observations in a dataset without shape outliers that have to be considered
outliers. Default is <code>2 * pnorm( 4 * qnorm( 0.25 ) )</code>;
</p>
</li>
<li><p>&quot;<code>F_min</code>&quot;: the minimum value of <code class="reqn">F</code>, defining the left
boundary for the optimization problem aimed at finding, for a given dataset
of simulated gaussian data associated to <code>fData</code>, the optimal value of
<code class="reqn">F</code>. Default is 0.5;
</p>
</li>
<li><p>&quot;<code>F_max</code>&quot;: the maximum value of <code class="reqn">F</code>, defining the right
boundary for the optimization problem aimed at finding, for a given dataset
of simulated gaussian data associated to <code>fData</code>, the optimal value of
<code class="reqn">F</code>. Default is 20;
</p>
</li>
<li><p>&quot;<code>tol</code>&quot;: the tolerance to be used in the optimization problem
aimed at finding, for a given dataset of simulated gaussian data associated
to <code>fData</code>, the optimal value of <code class="reqn">F</code>. Default is <code>1e-3</code>;
</p>
</li>
<li><p>&quot;<code>maxiter</code>&quot;: the maximum number of iterations to solve the
optimization problem aimed at finding, for a given dataset of simulated
gaussian data associated to <code>fData</code>, the optimal value of <code class="reqn">F</code>.
Default is <code>100</code>;
</p>
</li>
<li><p>&quot;<code>VERBOSE</code>&quot;: a parameter controlling the verbosity of the
adjustment process;
</p>
</li></ul>
</td></tr>
<tr><td><code id="outliergram_+3A_display">display</code></td>
<td>
<p>either a logical value indicating whether you want the
outliergram to be displayed, or the number of the graphical device
where you want the outliergram to be displayed.</p>
</td></tr>
<tr><td><code id="outliergram_+3A_xlab">xlab</code></td>
<td>
<p>a list of two labels to use on the x axis when displaying the
functional dataset and the outliergram</p>
</td></tr>
<tr><td><code id="outliergram_+3A_ylab">ylab</code></td>
<td>
<p>a list of two labels to use on the y axis when displaying the
functional dataset and the outliergram;</p>
</td></tr>
<tr><td><code id="outliergram_+3A_main">main</code></td>
<td>
<p>a list of two titles to be used on the plot of the functional
dataset and the outliergram;</p>
</td></tr>
<tr><td><code id="outliergram_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be used <em>only</em> in the plot
of the functional dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Even when used graphically to plot the outliergram, the function returns a
list containing:
</p>

<ul>
<li><p><code>Fvalue</code>: the value of the parameter F used;
</p>
</li>
<li><p><code>d</code>: the vector of values of the parameter <code class="reqn">d</code> for each observation
(distance to the parabolic border of the outliergram);
</p>
</li>
<li><p><code>ID_outliers</code>: the vector of observations id corresponding to outliers.</p>
</li></ul>



<h3>Adjustment</h3>

<p>When the adjustment option is selected, the value of <code class="reqn">F</code> is optimized for
the univariate functional dataset provided with <code>fData</code>. In practice,
a number <code>adjust$N_trials</code> of times a synthetic population
(of size <code>adjust$trial_size</code> with the same covariance (robustly
estimated from data) and centerline as <code>fData</code> is simulated without
outliers and each time an optimized value <code class="reqn">F_i</code> is computed so that a
given proportion (<code>adjust$TPR</code>) of observations is flagged as outliers.
The final value of <code>F</code> for the outliergram is determined as an average
of <code class="reqn">F_1, F_2, \ldots, F_{N_{trials}}</code>. At each time step the optimization
problem is solved using <code>stats::uniroot</code> (Brent's method).
</p>


<h3>References</h3>

<p>Arribas-Gil, A., and Romo, J. (2014). Shape outlier detection and visualization
for functional data: the outliergram, <em>Biostatistics</em>, 15(4), 603-619.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>, <code><a href="#topic+MEI">MEI</a></code>, <code><a href="#topic+MBD">MBD</a></code>,
<code><a href="#topic+fbplot">fbplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1618)

N &lt;- 200
P &lt;- 200
N_extra &lt;- 4

grid &lt;- seq(0, 1, length.out = P)

Cov &lt;- exp_cov_function(grid, alpha = 0.2, beta = 0.8)

Data &lt;- generate_gauss_fdata(
  N = N,
  centerline = sin(4 * pi * grid),
  Cov = Cov
)

Data_extra &lt;- array(0, dim = c(N_extra, P))

Data_extra[1, ] &lt;- generate_gauss_fdata(
  N = 1,
  centerline = sin(4 * pi * grid + pi / 2),
  Cov = Cov
)

Data_extra[2, ] &lt;- generate_gauss_fdata(
  N = 1,
  centerline = sin(4 * pi * grid - pi / 2),
  Cov = Cov
)

Data_extra[3, ] &lt;- generate_gauss_fdata(
  N = 1,
  centerline = sin(4 * pi * grid + pi / 3),
  Cov = Cov
)

Data_extra[4, ] &lt;- generate_gauss_fdata(
  N = 1,
  centerline = sin(4 * pi * grid - pi / 3),
  Cov = Cov
)

Data &lt;- rbind(Data, Data_extra)

fD &lt;- fData(grid, Data)

# Outliergram with default Fvalue = 1.5
outliergram(fD, display = TRUE)

# Outliergram with Fvalue enforced to 2.5
outliergram(fD, Fvalue = 2.5, display = TRUE)


# Outliergram with estimated Fvalue to ensure TPR of 1%
outliergram(
  fData = fD,
  adjust = list(
    N_trials = 10,
    trial_size = 5 * nrow(Data),
    TPR = 0.01,
    VERBOSE = FALSE
  ),
  display = TRUE
)


</code></pre>

<hr>
<h2 id='plot.Cov'>Specialized method to plot <code>Cov</code> objects</h2><span id='topic+plot.Cov'></span>

<h3>Description</h3>

<p>This function performs the plot of an object of class <code>Cov</code>, i.e. a
covariance or cross-covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Cov'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Cov_+3A_x">x</code></td>
<td>
<p>the covariance or cross-covariance function of class <code>Cov</code>.</p>
</td></tr>
<tr><td><code id="plot.Cov_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be used in plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It builds above the function <code>graphics::image</code>, therefore any additional
parameter suitable for <code>graphics::image</code> will also be suitable as <code>...</code>
argument to <code>plot.Cov</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov_fun">cov_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating a univariate functional dataset
N = 1e2

P = 1e2
t0 = 0
t1 = 1

time_grid = seq( t0, t1, length.out = P )

Cov = exp_cov_function( time_grid, alpha = 0.3, beta = 0.4 )

D1 = generate_gauss_fdata( N, centerline = sin( 2 * pi * time_grid ), Cov = Cov )

fD1 = fData( time_grid, D1 )

# Computing the covariance function of fD1

plot( cov_fun( fD1 ), main = 'Covariance function', xlab = 'time', ylab = 'time' )

</code></pre>

<hr>
<h2 id='plot.depthgram'>Specialized method to plot 'depthgram' objects</h2><span id='topic+plot.depthgram'></span>

<h3>Description</h3>

<p>This function plots the three 'DepthGram' representations from the output of
the <code><a href="#topic+depthgram">depthgram</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'depthgram'
plot(
  x,
  limits = FALSE,
  ids = NULL,
  print = FALSE,
  plot_title = "",
  shorten = TRUE,
  col = NULL,
  pch = 19,
  sp = 2,
  st = 4,
  sa = 10,
  text_labels = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.depthgram_+3A_x">x</code></td>
<td>
<p>An object of class <code>depthgram</code> as output by the
<code><a href="#topic+depthgram">depthgram</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_limits">limits</code></td>
<td>
<p>A boolean specifying whether the empirical limits for outlier
detection should be drawn. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_ids">ids</code></td>
<td>
<p>A character vector specifying labels for individual observations.
Defaults to <code>NULL</code>, in which case observations will named by their id
number in order of appearance.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_print">print</code></td>
<td>
<p>A boolean specifying whether the graphical output should be
optimized for printed version. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_plot_title">plot_title</code></td>
<td>
<p>A character string specifying the main title for the plot.
Defaults to <code>""</code>, which means no title.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_shorten">shorten</code></td>
<td>
<p>A boolean specifying whether labels must be shorten to 15
characters. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_col">col</code></td>
<td>
<p>Color palette used for the plot. Defaults to <code>NULL</code>, in which case
a default palette produced by the <code><a href="grDevices.html#topic+hcl">hcl</a></code> function is
used.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_pch">pch</code></td>
<td>
<p>Point shape. See <code><a href="plotly.html#topic+plotly">plotly</a></code> for more details.
Defaults to <code>19</code>.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_sp">sp</code></td>
<td>
<p>Point size. See <code><a href="plotly.html#topic+plotly">plotly</a></code> for more details.
Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_st">st</code></td>
<td>
<p>Label size. See <code><a href="plotly.html#topic+plotly">plotly</a></code> for more details.
Defaults to <code>4</code>.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_sa">sa</code></td>
<td>
<p>Axis title sizes. See <code><a href="plotly.html#topic+plotly">plotly</a></code> for more
details. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_text_labels">text_labels</code></td>
<td>
<p>A character vector specifying the labels for the
individuals. It is overridden if <code>limits = TRUE</code>, for which only outliers
labels are shown. See <code><a href="plotly.html#topic+plotly">plotly</a></code> for more details.
Defaults to <code>""</code>.</p>
</td></tr>
<tr><td><code id="plot.depthgram_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the base <code><a href="base.html#topic+plot">plot</a></code>
function. Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:
</p>

<ul>
<li> <p><code>p</code>: list with all the interactive (plotly) depthGram plots;
</p>
</li>
<li> <p><code>out</code>: outliers detected;
</p>
</li>
<li> <p><code>colors</code>: used colors for plotting.
</p>
</li></ul>



<h3>References</h3>

<p>Aleman-Gomez, Y., Arribas-Gil, A., Desco, M. Elias-Fernandez, A., and Romo,
J. (2021). &quot;Depthgram: Visualizing Outliers in High Dimensional Functional
Data with application to Task fMRI data exploration&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 50
P &lt;- 50
grid &lt;- seq(0, 1, length.out = P)
Cov &lt;- exp_cov_function(grid, alpha = 0.3, beta = 0.4)

Data &lt;- list()
Data[[1]] &lt;- generate_gauss_fdata(
  N,
  centerline = sin(2 * pi * grid),
  Cov = Cov
)
Data[[2]] &lt;- generate_gauss_fdata(
  N,
  centerline = sin(2 * pi * grid),
  Cov = Cov
)
names &lt;- paste0("id_", 1:nrow(Data[[1]]))
DG &lt;- depthgram(Data, marginal_outliers = TRUE, ids = names)
plot(DG)
</code></pre>

<hr>
<h2 id='plot.fData'>Specialized method to plot <code>fData</code> objects</h2><span id='topic+plot.fData'></span>

<h3>Description</h3>

<p>This function performs the plot of a functional univariate dataset stored in
an object of class <code>fData</code>. It is able to accept all the usual
customizable graphical parameters, otherwise it will use the default ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fData'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fData_+3A_x">x</code></td>
<td>
<p>the univariate functional dataset in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="plot.fData_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be used in plotting functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e2

# One dimensional grid
grid = seq( 0, 1, length.out = P )

# Generating an exponential covariance function (see related help for more
# information )
C = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Generating a synthetic dataset with a gaussian distribution and
# required mean and covariance function:
values = generate_gauss_fdata( N,
                               centerline = sin( 2 * pi * grid ),
                               Cov = C )

fD = fData( grid, values )

plot( fD )


</code></pre>

<hr>
<h2 id='plot.mfData'>Specialized method to plot <code>mfData</code> objects</h2><span id='topic+plot.mfData'></span>

<h3>Description</h3>

<p>This function performs the plot of a functional multivariate dataset stored
in an object of class <code>mfData</code>. It is able to accept all the usual
customizable graphical parameters, otherwise it will use the default ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfData'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mfData_+3A_x">x</code></td>
<td>
<p>the multivariate functional dataset in form of <code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="plot.mfData_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be used in plotting functions
(see <code>Details</code> for the use of <code>ylab</code> and <code>main</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current active graphical device is split into a number of sub-figures,
each one meant to contain the plot of the corresponding dimension of the
<code>mfData</code> object. In particular, they are arranged in a rectangular
lattice with a number of rows equal to <code class="reqn"> \lfloor \sqrt{ L } \rfloor </code>
and a number of columns equal to <code class="reqn"> \lceil L / \lfloor \sqrt{L} \rfloor
\rceil </code>.
</p>
<p>A special use of the graphical parameters allows to set up y-labels and
titles for all the sub-figures in the graphical window. In particular,
parameters <code>ylab</code> and <code>main</code> can take as argument either a single
string, that are repeatedly used for all the sub-graphics, or a list of
different strings (one for each of the <code>L</code> dimensions) that have to be
used in the corresponding graphic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>, <code><a href="#topic+fData">fData</a></code>, <code><a href="#topic+plot.fData">plot.fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 1e2

P = 1e3

t0 = 0
t1 = 1

# Defining the measurement grid
grid = seq( t0, t1, length.out = P )

# Generating an exponential covariance matrix to be used in the simulation of
# the functional datasets (see the related help for details)
C = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Simulating the measurements of two univariate functional datasets with
# required center and covariance function
Data_1 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = C )
Data_2 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = C )

# Building the mfData object and plotting tt
plot( mfData( grid, list( Data_1, Data_2 ) ),
      xlab = 'time', ylab = list( '1st dim.', '2nd dim.' ),
      main = list( 'An important plot here', 'And another one here' ) )

</code></pre>

<hr>
<h2 id='plus-.fData'>Operator <code>+</code> and <code>-</code> for <code>fData</code> objects</h2><span id='topic+plus-.fData'></span><span id='topic++2B.fData'></span><span id='topic+-.fData'></span>

<h3>Description</h3>

<p>These methods provide operators <code>+</code> and <code>-</code> to perform sums
or differences between an <code>fData</code> object and either another
<code>fData</code> object or other compliant data structures, like matrices or
vectors or arrays, representing the pointwise measurements of the second
term of the  sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fData'
fD + A

## S3 method for class 'fData'
fD - A
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plus-.fData_+3A_fd">fD</code></td>
<td>
<p>the univariate functional dataset in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="plus-.fData_+3A_a">A</code></td>
<td>
<p>either an <code>fData</code> object, defined on the very same grid of
<code>fD</code>, or a 1D data structure (such as 1D array or raw
numeric vector), or a 2D data structure (such as 2D array or raw numeric
matrix ), that specifies the second term of the sum.
In case of a 1D data structure, the sum is performed element-wise between
each element of  <code>fD</code> and <code>A</code>, and <code>A</code> must have length
<code>P</code>, size of <code>fD</code>'s grid.
In case of a 2D data structure, the sum is performed element-wise between
corresponding elements of <code>fD</code> and <code>A</code>'s rows. In this case,
<code>A</code> must have <code>P</code> columns, as the size of <code>fD</code>'s grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the second term of the operation is an <code>fData</code> object, it must be
defined over the same grid as the first.
</p>


<h3>Value</h3>

<p>The function returns an <code>fData</code> object, whose function values
have undergone the sum/difference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fD = fData( seq( 0, 1, length.out = 10 ),
            values = matrix( seq( 1, 10 ),
                             nrow = 21, ncol = 10, byrow = TRUE ) )
fD + 1 : 10

fD + array( 1, dim = c( 1, 10 ) )

fD + fD

fD = fData( seq( 0, 1, length.out = 10 ),
            values = matrix( seq( 1, 10 ),
                             nrow = 21, ncol = 10, byrow = TRUE ) )
fD - 2 : 11

fD - array( 1, dim = c( 1, 10 ) )

fD - fD

</code></pre>

<hr>
<h2 id='set_alpha'>Function to setup alpha value for a set of colors</h2><span id='topic+set_alpha'></span>

<h3>Description</h3>

<p><code>set_alpha</code> manipulates a vector of color representations in order
to setup the alpha value, and get the desired transparency level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_alpha(col, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_alpha_+3A_col">col</code></td>
<td>
<p>a vector of colors</p>
</td></tr>
<tr><td><code id="set_alpha_+3A_alpha">alpha</code></td>
<td>
<p>the value(s) of alpha for (each of) the colors.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fDColorPalette">fDColorPalette</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
original_col = c( 'blue', 'red', 'green', 'yellow' )

alpha_col = set_alpha( original_col, 0.5 )

alpha_col = set_alpha( original_col, c(0.5, 0.5, 0.2, 0.1 ) )

dev.new()
oldpar &lt;- par(mfrow = c(1, 1))
par(mfrow = c(1, 2))

plot( seq_along( original_col ),
      seq_along( original_col ),
      col = original_col,
      pch = 16,
      cex = 2,
      main = 'Original colors' )

plot( seq_along( alpha_col ),
      seq_along( alpha_col ),
      col = alpha_col,
      pch = 16,
      cex = 2,
      main = 'Alpha colors' )

par(oldpar)

</code></pre>

<hr>
<h2 id='sub-.fData'>Operator <code>sub-.fData</code> to subset <code>fData</code> objects</h2><span id='topic+sub-.fData'></span><span id='topic++5B.fData'></span>

<h3>Description</h3>

<p>This method provides an easy and natural way to subset a functional dataset
stored in a <code>fData</code> object, without having to deal with the inner
representation of <code>fData</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fData'
fD[i, j, as_fData = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub-.fData_+3A_fd">fD</code></td>
<td>
<p>the univariate functional dataset in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="sub-.fData_+3A_i">i</code></td>
<td>
<p>a valid expression to subset rows ( observations ) of the univariate
functional dataset.</p>
</td></tr>
<tr><td><code id="sub-.fData_+3A_j">j</code></td>
<td>
<p>a valid expression to subset columns ( measurements over the grid )
of the univariate functional dataset (must be contiguous).</p>
</td></tr>
<tr><td><code id="sub-.fData_+3A_as_fdata">as_fData</code></td>
<td>
<p>logical flag to specify whether the output should be returned
as an <code>fData</code> object containing the required subset or as a matrix of
values, default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The method returns either an <code>fData</code> object ( if <code>as_fData
= TRUE </code> ) or a <code>matrix</code> ( if <code>as_fData = FALSE </code> ) containing the
required subset ( both in terms  of observations and measurement points ) of
the univariate functional dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 20
P = 1e2

# One dimensional grid
grid = seq( 0, 1, length.out = P )

# Generating an exponential covariance function (see related help for more
# information )
C = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Generating a synthetic dataset with a gaussian distribution and
# required mean and covariance function:
fD = fData( grid,
            generate_gauss_fdata( N,
                                  centerline = sin( 2 * pi * grid ),
                                  Cov = C ) )

dev.new()
oldpar &lt;- par(mfrow = c(1, 1))
par(mfrow = c(2, 2))

# Original data
plot(fD)

# Subsetting observations
plot(fD[c(1, 2, 3), , as_fData = TRUE])

# Subsetting measurements
plot(fD[, 1:30])

# Subsetting both observations and measurements
plot(fD[1:10, 50:P])

par(oldpar)

# Subsetting both observations and measurements but returning a matrix
fD[1:10, 50:P, as_fData = FALSE]

</code></pre>

<hr>
<h2 id='sub-.mfData'>Operator <code>sub-.mfData</code> to subset <code>mfData</code> objects</h2><span id='topic+sub-.mfData'></span><span id='topic++5B.mfData'></span>

<h3>Description</h3>

<p>This method provides an easy and natural way to subset a multivariate
functional dataset stored in a <code>mfData</code> object, without having to
deal with the inner representation of <code>mfData</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfData'
mfD[i, j]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub-.mfData_+3A_mfd">mfD</code></td>
<td>
<p>the multivariate functional dataset in form of <code>mfData</code> object.</p>
</td></tr>
<tr><td><code id="sub-.mfData_+3A_i">i</code></td>
<td>
<p>a valid expression to subset rows ( observations ) of the univariate
functional dataset.</p>
</td></tr>
<tr><td><code id="sub-.mfData_+3A_j">j</code></td>
<td>
<p>a valid expression to subset columns ( measurements over the grid )
of the univariate functional dataset (must be contiguous).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The method returns and <code>mfData</code> object containing the
required subset ( both in terms  of observations and measurement points ) of
the multivariate functional dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining parameters
N = 1e2

P = 1e3

t0 = 0
t1 = 1

# Defining the measurement grid
grid = seq( t0, t1, length.out = P )

# Generating an exponential covariance matrix to be used in the simulation of
# the functional datasets (see the related help for details)
C = exp_cov_function( grid, alpha = 0.3, beta = 0.4 )

# Simulating the measurements of two univariate functional datasets with
# required center and covariance function
Data_1 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = C )
Data_2 = generate_gauss_fdata( N, centerline = sin( 2 * pi * grid ), Cov = C )

# Building the mfData object
mfD = mfData( grid, list( Data_1, Data_2 ) )

# Subsetting the first 10 elements and 10 time points
mfD[1:10, 1:10]

# Subsetting only observations
mfD[1:10,]

# Subsetting only time points (contiguously)
mfD[,1:10]

</code></pre>

<hr>
<h2 id='times-.fData'>Operator <code>*</code> and <code>/</code> for <code>fData</code> objects</h2><span id='topic+times-.fData'></span><span id='topic++2A.fData'></span><span id='topic++2F.fData'></span>

<h3>Description</h3>

<p>These methods provide operators <code>*</code> and <code>/</code> to perform products
or divisions between an <code>fData</code> object and either a number or a
compliant 1D data structure, like numeric vector, array or
matrix. The operation is computed by performing the element-wise product
or division between <code>fD</code>'s observations and the provided value(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fData'
fD * a

## S3 method for class 'fData'
fD / a
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="times-.fData_+3A_fd">fD</code></td>
<td>
<p>the univariate functional dataset in form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="times-.fData_+3A_a">a</code></td>
<td>
<p>either a single number or a 1D data structure (such as numeric
raw vector, matrix or array) specifying the factor(s) to use in the
multiplication/division of <code>fD</code> elements' values.
In the latter case, each factor is used with the corresponding element in
<code>fD</code>, hence a must have length <code>N</code>, number of observations in
<code>fD</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the second argument is a 1D data structure, it must have length <code>N</code>
equal to the number of observations in <code>fD</code>.
</p>


<h3>Value</h3>

<p>The function returns an <code>fData</code> object, whose function values
have undergone the product/division.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 11
fD = fData( seq( 0, 1, length.out = 10 ),
            values = matrix( seq( 1, 10 ),
                             nrow = N, ncol = 10, byrow = TRUE ) )
fD * 2

fD * seq( 1, N )


N = 11
fD = fData( seq( 0, 1, length.out = 10 ),
            values = matrix( seq( 1, 10 ),
                             nrow = N, ncol = 10, byrow = TRUE ) )
fD / 2

fD / rep( 10, N )

</code></pre>

<hr>
<h2 id='toListOfValues'>Manipulation of <code>mfData</code> list of values</h2><span id='topic+toListOfValues'></span>

<h3>Description</h3>

<p>This utility function manipulates a <code>mfData</code> object in order to extract
from the list of its <code>fData</code> objects ( namely, <code>mfData$fDList</code> )
the measurement values of each component and stores them into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toListOfValues(mfData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toListOfValues_+3A_mfdata">mfData</code></td>
<td>
<p>the multivariate functional dataset in form of <code>mfData</code>
object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code>mfData</code> of <code>L</code> components, the function is equivalent to
<code> list( mfData$fDList[[ 1 ]]$values,</code> <code>..., </code>
<code> mfData$fDList[[ L ]]$values ) </code>.
</p>


<h3>Value</h3>

<p>The function returns the list of values of each <code>fData</code> object
representing the components of <code>mfData</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfData">mfData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid = seq( 0, 1, length.out = 5 )

D_1 = matrix( 1 : 5, nrow = 10, ncol = 5, byrow = TRUE )
D_2 = 2 * D_1
D_3 = 3 * D_1

mfD = mfData( grid, list( D_1, D_2, D_3 ) )
mfD

toListOfValues( mfD )

</code></pre>

<hr>
<h2 id='toRowMatrixForm'>Conversion of vector/array/matrix to row-matrix form</h2><span id='topic+toRowMatrixForm'></span>

<h3>Description</h3>

<p>This function manipulates a numeric data structure of vector/array/matrix
type in order to obtain a matrix representation.
For 1D data structures and column/row arrays and matrices the output is
turned in a matrix format with just one row.
If the input structure is rectangular, instead, it is only converted in
matrix format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toRowMatrixForm(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toRowMatrixForm_+3A_d">D</code></td>
<td>
<p>a generic array, matrix or vector to be converted in
row-matrix format.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The function is <b>not</b> supposed to work with arbitrary N-dimensional
arrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
toRowMatrixForm( 1 : 10 )

toRowMatrixForm( array( 1 : 10, dim = c(1,10 ) ) )

toRowMatrixForm( array( 1 : 10, dim = c( 10, 1 ) ) )

toRowMatrixForm( matrix( 1 : 10, ncol = 10, nrow = 1 ) )

toRowMatrixForm( matrix( 1 : 10, ncol = 1, nrow = 10 ) )

toRowMatrixForm( matrix( 1 : 12, ncol = 3, nrow = 4 ) )

toRowMatrixForm( matrix( 1 : 12, ncol = 4, nrow = 3 ) )

</code></pre>

<hr>
<h2 id='unfold'>Unfolding a univariate functional dataset</h2><span id='topic+unfold'></span>

<h3>Description</h3>

<p>This function operates on a univariate functional dataset and transforms its
observations unfolding their values and turning them into monotone functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfold(fData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfold_+3A_fdata">fData</code></td>
<td>
<p>the univariate functional dataset in form of <code>fData</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each function of the <code>fData</code> object is transformed into a non-monotone
function into a monotone function by &ldquo;unfolding&rdquo; it at any of its maxima.
For more details about the definition of the transform, see the reference.
</p>


<h3>Value</h3>

<p>The function returns an <code>fData</code> object whose observations are
the unfolded version of the corresponding observations in the argument
<code>fData</code>.
</p>


<h3>References</h3>

<p>Arribas-Gil, A. and Romo, J. (2012). Robust depth-based estimation
in the time warping model, <em>Biostatistics</em>, 13 (3), 398&ndash;414.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>, <code><a href="#topic+warp">warp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P = 1e3

time_grid = seq( 0, 1, length.out = P )

D = matrix( c( sin( 2 * pi * time_grid ),
               cos( 2 * pi * time_grid ),
               sin( 10 * pi * time_grid ) * time_grid + 2 ),
            ncol = P, nrow = 3, byrow = TRUE )

# Functional dataset
fD = fData( time_grid, D )

# Unfolded version
fD_unfold = unfold( fD )

dev.new()
oldpar &lt;- par(mfrow = c(1, 1))
par(mfrow = c(1, 2))

plot(fD, main = 'Original data')
plot(fD_unfold, main = 'Unfolded data')

par(oldpar)

</code></pre>

<hr>
<h2 id='warp'>Warp elements of a univariate functional dataset</h2><span id='topic+warp'></span>

<h3>Description</h3>

<p>This function carries out the warping of elements of a univariate functional
dataset by using a set of pre-computed warping functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp(fData, warpings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp_+3A_fdata">fData</code></td>
<td>
<p>the functional dataset whose observations must be warped in
form of <code>fData</code> object.</p>
</td></tr>
<tr><td><code id="warp_+3A_warpings">warpings</code></td>
<td>
<p>the warping functions <code class="reqn">H_1, \ldots, H_N</code>, in form of
<code>fData</code> object, defined over the registered/warped grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a univariate functional dataset <code class="reqn">X_1(t), \ldots, X_N(t)</code> and a set
of warping functions <code class="reqn">H_1(t), \ldots, H_N(t)</code>, such that:
</p>
<p style="text-align: center;"><code class="reqn"> H_i : s \longrightarrow t = H_i(s), \quad \forall i = 1, \ldots, N,</code>
</p>

<p>where <code class="reqn">s</code> spans the warped (or registered) grid and <code class="reqn">t</code> spans the
original grid, the function computes the warping given by the following
composition:
</p>
<p style="text-align: center;"><code class="reqn"> X_1 \circ H_1(t), \ldots, X_N \circ H_N(t).</code>
</p>



<h3>Value</h3>

<p>The function returns the univariate functional dataset of warped
functions, in form of <code>fData</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fData">fData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed( 1618033 )

N = 30

t0 = 0
t1 = 1
P = 1e3 + 1

time_grid = seq( t0, t1, length.out = P )

means = round( runif( N,
                      t0 + (t1 - t0) / 8,
                      t1 - (t1 - t0) / 8  ), 3 )

Data = matrix( sapply( means,
                       function( m )( dnorm( time_grid, mean = m, sd = 0.05 ) ) ),
               ncol = P, nrow = N, byrow = TRUE )

fD = fData( time_grid, Data )

# Piecewise linear warpings
template_warping = function( m )( c( time_grid[ time_grid &lt;= 0.5 ] * m / 0.5,
                                     ( time_grid[ time_grid &gt; 0.5 ]
                                       - 0.5 ) * (1 - m ) / 0.5 + m ) )


warpings = matrix( sapply( means, template_warping ),
                   ncol = P,
                   nrow = N, byrow = TRUE )

wfD = fData( time_grid, warpings )

fD_warped = warp( fD, wfD )

dev.new()
oldpar &lt;- par(mfrow = c(1, 1))
par(mfrow = c(1, 3))

plot( fD,
     main = 'Unregistered functions', xlab = 'actual grid', ylab = 'values'  )
plot( wfD,
     main = 'Warping functions', xlab = 'registered grid',
     ylab = 'actual grid' )
plot( fD_warped,
     main = 'Warped functions', xlab = 'registered grid',
     ylab = 'values' )

par(oldpar)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
