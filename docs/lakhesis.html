<!DOCTYPE html><html><head><title>Help for package lakhesis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lakhesis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ca.procrustes'><p>Correspondence Analysis with Procrustes Fitting</p></a></li>
<li><a href='#ca.procrustes.curve'><p>Seriate Using Reference Curve</p></a></li>
<li><a href='#ca.procrustes.poly'><p>Projection onto Reference Curve</p></a></li>
<li><a href='#concentration.col'><p>Kendall-Doran Concentration</p></a></li>
<li><a href='#element.eval'><p>Evaluating Element Fit</p></a></li>
<li><a href='#im.csv.read'><p>Read csv File to Incidence Matrix</p></a></li>
<li><a href='#im.long'><p>Convert Incidence Matrix to Pairs (Long Format)</p></a></li>
<li><a href='#im.merge'><p>Merge Two Incidence Matrices</p></a></li>
<li><a href='#im.ref'><p>Create Reference Matrix</p></a></li>
<li><a href='#kappa.coef'><p>Kappa Concentration</p></a></li>
<li><a href='#lakhesize'><p>Lakhesize</p></a></li>
<li><a href='#LC'><p>Lakhesis Calculator</p></a></li>
<li><a href='#qfStrands'><p>Quattro Fontanili - Strands</p></a></li>
<li><a href='#quattrofontanili'><p>Quattro Fontanili</p></a></li>
<li><a href='#spearman.sq'><p>Spearman Correlation Squared</p></a></li>
<li><a href='#strand.extract'><p>Strand Extract</p></a></li>
<li><a href='#strand.suppress'><p>Suppress Element from Strands</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Consensus Seriation for Binary Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Determining consensus seriations for binary incidence matrices, using a two-step process of Procrustes-fit correspondence analysis for heuristic selection of partial seriations and iterative regression to establish a single consensus. Contains the Lakhesis Calculator, a graphical platform for identifying seriated sequences. Collins-Elliott (2024) <a href="https://volweb.utk.edu/~scolli46/sceLakhesis.pdf">https://volweb.utk.edu/~scolli46/sceLakhesis.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, readr, ca, ggplot2, Rdpack, shiny, shinydashboard,
bslib</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-08 07:03:42 UTC; tennessee10</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen A. Collins-Elliott
    <a href="https://orcid.org/0000-0002-5642-6903"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen A. Collins-Elliott &lt;sce@utk.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-10 17:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ca.procrustes'>Correspondence Analysis with Procrustes Fitting</h2><span id='topic+ca.procrustes'></span>

<h3>Description</h3>

<p>Fit scores of correspondence analysis on an incidence matrix to those produced by reference matrix which contain an ideal seriation using a Procrustes method (on the reference matrix, see <code><a href="#topic+im.ref">im.ref</a></code>). Rotation is determined by minimizing Euclidean distance from each row score to the nearest reference row score. Correspondence analysis is performed using the <code><a href="ca.html#topic+ca">ca</a></code> package (Nenadic and Greenacre 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ca.procrustes(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ca.procrustes_+3A_obj">obj</code></td>
<td>
<p>An incidence matrix of size n x k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following:.
</p>

<ul>
<li> <p><code>ref</code> The Procrustes-fit coordinates of the scores of the reference seriation.
</p>
</li>
<li> <p><code>x</code> The Procrustes-fit coordinates of the row scores of the data.
</p>
</li>
<li> <p><code>x.dat</code> A data frame containing the following information related to the fit of the row score after Procrustes fitting: <code>index</code>, the row name, <code>match</code>, the reference point nearest to the row score, and <code>dist</code>, the Euclidean distance between the row score and reference score point.
</p>
</li>
<li> <p><code>y</code> The Procrustes-fit coordinates of the column scores of the data.
</p>
</li>
<li> <p><code>y.dat</code> A data frame containing the same information as <code>x.dat</code>, but with respect to the column scores.
</p>
</li></ul>



<h3>References</h3>

<p>Nenadic O, Greenacre MJ (2007).
&ldquo;Correspondence Analysis in R, with Two- and Three-dimensional Graphics: The ca Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>20</b>, 1&ndash;13.
<a href="https://doi.org/10.18637/jss.v020.i03">doi:10.18637/jss.v020.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
ca.procrustes(quattrofontanili)

</code></pre>

<hr>
<h2 id='ca.procrustes.curve'>Seriate Using Reference Curve</h2><span id='topic+ca.procrustes.curve'></span>

<h3>Description</h3>

<p>Obtain a ranking of row and column scores projected onto a reference curve of an ideal seriation (row and column scores are ranked separately). Scores of correspondence analysis have been fit to those produced by reference matrix contain an ideal seriation using a Procrustes method, projecting them. Rotation is determined by minimizing Euclidean distance from each row score to the nearest reference row score. Correspondence analysis is performed using the <code><a href="ca.html#topic+ca">ca</a></code> package (Nenadic and Greenacre 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ca.procrustes.curve(obj, resolution = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ca.procrustes.curve_+3A_obj">obj</code></td>
<td>
<p>An incidence matrix of size n x k.</p>
</td></tr>
<tr><td><code id="ca.procrustes.curve_+3A_resolution">resolution</code></td>
<td>
<p>Number of samples to use for plotting points along polynomial curve (default is 10000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of the following:.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;Procrustes1,Procrustes2&#8288;</code> The location of the point on the biplot after fitting.
</p>
</li>
<li> <p><code>CurveIndex</code> The orthogonal projection of the point onto the reference curve, given as the index of the point sampled along <code class="reqn">y = \beta_2 x^2 + \beta_0</code>.
</p>
</li>
<li> <p><code>Distance</code> The squared Euclidean distance of the point to the nearest point on the reference curve.
</p>
</li>
<li> <p><code>Rank</code> The ranking of the row or column, a range of <code style="white-space: pre;">&#8288;1:nrow`` and &#8288;</code>1:ncol&ldquo;.
</p>
</li>
<li> <p><code>Type</code> Either <code>row</code> or <code>col</code>.
</p>
</li>
<li> <p><code>sel</code> Data frame column used in <code>shiny</code> app to indicate whether point is selected in biplot/curve projection.
</p>
</li></ul>



<h3>References</h3>

<p>Nenadic O, Greenacre MJ (2007).
&ldquo;Correspondence Analysis in R, with Two- and Three-dimensional Graphics: The ca Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>20</b>, 1&ndash;13.
<a href="https://doi.org/10.18637/jss.v020.i03">doi:10.18637/jss.v020.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
ca.procrustes.curve(quattrofontanili)

</code></pre>

<hr>
<h2 id='ca.procrustes.poly'>Projection onto Reference Curve</h2><span id='topic+ca.procrustes.poly'></span>

<h3>Description</h3>

<p>Performs a polynomial regression on the row reference scores and orthogonally projects data points on to the reference curve. Sampling can be increased to refine ranking and avoid ties, but default is largely sufficient. Correspondence analysis is performed using the <code><a href="ca.html#topic+ca">ca</a></code> package (Nenadic and Greenacre 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ca.procrustes.poly(obj, resolution = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ca.procrustes.poly_+3A_obj">obj</code></td>
<td>
<p>An incidence matrix of size n x k.</p>
</td></tr>
<tr><td><code id="ca.procrustes.poly_+3A_resolution">resolution</code></td>
<td>
<p>Number of samples to use for plotting points along polynomial curve (default is 10000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following:.
</p>

<ul>
<li><p> 'ref&ldquo; The Procrustes-fit coordinates of the scores of the reference seriation.
</p>
</li>
<li> <p><code>x</code> The Procrustes-fit coordinates of the row scores of the data.
</p>
</li>
<li> <p><code>x.dat</code> A data frame containing the following information related to the fit of the row score after Procrustes fitting: <code>index</code>, the row name, <code>match</code>, the reference point nearest to the row score, and <code>dist</code>, the Euclidean distance between the row score and reference score point.
</p>
</li>
<li> <p><code>y</code> The Procrustes-fit coordinates of the column scores of the data.
</p>
</li>
<li> <p><code>y.dat</code> A data frame containing the same information as <code>x.dat</code>, but with respect to the column scores.
</p>
</li></ul>



<h3>References</h3>

<p>Nenadic O, Greenacre MJ (2007).
&ldquo;Correspondence Analysis in R, with Two- and Three-dimensional Graphics: The ca Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>20</b>, 1&ndash;13.
<a href="https://doi.org/10.18637/jss.v020.i03">doi:10.18637/jss.v020.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
ca.procrustes.poly(quattrofontanili)

</code></pre>

<hr>
<h2 id='concentration.col'>Kendall-Doran Concentration</h2><span id='topic+concentration.col'></span>

<h3>Description</h3>

<p>The Kendall-Doran measure of concentration (Kendall 1963; Doran 1971). In a seriated matrix, this function computes the total number cells between the first and last non-zero value, column by column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration.col(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration.col_+3A_obj">obj</code></td>
<td>
<p>A seriated binary matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The measure of concentration.
</p>


<h3>References</h3>

<p>Doran J (1971).
&ldquo;Computer Analysis of Data from the la Tène Cemetry at Münsingen-Rain.&rdquo;
In Hodson FR, Kendall DG, Táutu P (eds.), <em>Mathematics in the Archaeological and Historical Sciences</em>, 422&ndash;431.
Edinburgh University Press, Edinburgh.<br /><br /> Kendall DG (1963).
&ldquo;A Statistical Approach to Flinders Petrie's Sequence Dating.&rdquo;
<em>Bulletin of the International Statistical Institute</em>, <b>40</b>, 657&ndash;680.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
concentration.col(quattrofontanili)

</code></pre>

<hr>
<h2 id='element.eval'>Evaluating Element Fit</h2><span id='topic+element.eval'></span>

<h3>Description</h3>

<p>Performs a goodness-of-fit test on individual row and column elements using deviance, using a quadratic-logistic model to fit row and column occurrences. In the case of perfect separation of 0/1 values, an <code>NA</code> value is assigned. Results are reported as <code class="reqn">p</code> values for each row and column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element.eval(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element.eval_+3A_obj">obj</code></td>
<td>
<p>A seriated binary matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing results in frames for row and column elements:
</p>

<ul>
<li> <p><code>RowFit</code> a data frame containing
</p>

<ul>
<li> <p><code>id</code> Row element
</p>
</li>
<li> <p><code>p.val</code> <code class="reqn">p</code> values of the row elements
</p>
</li></ul>

</li>
<li> <p><code>ColFit</code> a data frame containing
</p>

<ul>
<li> <p><code>id</code> Column element
</p>
</li>
<li> <p><code>p.val</code> <code class="reqn">p</code> values of the column elements
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
element.eval(quattrofontanili)

</code></pre>

<hr>
<h2 id='im.csv.read'>Read csv File to Incidence Matrix</h2><span id='topic+im.csv.read'></span>

<h3>Description</h3>

<p>Wrapper around the <code><a href="readr.html#topic+read_csv">read_csv</a></code> function from the <code>readr</code> package (Wickham et al. 2024). Read a <code>.csv</code> file in which the first column represents row elements and the second column represents column elements, and convert it into an incidence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>im.csv.read(
  filename,
  header = FALSE,
  characterencoding = "iso-8859-1",
  remove.hapax = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im.csv.read_+3A_filename">filename</code></td>
<td>
<p>The filename to uploaded (must be in <code>.csv</code> format).</p>
</td></tr>
<tr><td><code id="im.csv.read_+3A_header">header</code></td>
<td>
<p>If the <code>.csv</code> file contains a header. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="im.csv.read_+3A_characterencoding">characterencoding</code></td>
<td>
<p>File encoding as used by <code><a href="readr.html#topic+locale">locale</a></code>. Default is <code>"iso-8859-1"</code> to handle special characters.</p>
</td></tr>
<tr><td><code id="im.csv.read_+3A_remove.hapax">remove.hapax</code></td>
<td>
<p>Remove any row or column which has a sum of 1 (i.e., is only attested once), since they do not directly contribute to the result of the seriation. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An incidence matrix of binary values (0 = row/column occurrence is absence; 1 = row/column occurrence is present).
</p>


<h3>References</h3>

<p>Wickham H, Hester J, Bryan J (2024).
<em>readr: Read Rectangular Text Data</em>.
R package version 2.1.5, https://github.com/tidyverse/readr, <a href="https://readr.tidyverse.org">https://readr.tidyverse.org</a>.
</p>

<hr>
<h2 id='im.long'>Convert Incidence Matrix to Pairs (Long Format)</h2><span id='topic+im.long'></span>

<h3>Description</h3>

<p>Take an incidence matrix and convert it to a data frame of two columns, where the first column represents the row elements of the incidence matrix and the second column represents the column elements of the incidence matrix. Each row pair represents the incidence (or occurrence) of that row and column element together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>im.long(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im.long_+3A_obj">obj</code></td>
<td>
<p>An incidence matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of two columns (row and column of the incidence matrix), in which row of the data frame represents a pair of an
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quattrofontanili)
qf &lt;- im.long(quattrofontanili)

# to export for uploading into the Lakhesis Calculator, use write.table() to 
# remove both row and column names:

# write.table(qf, file = 'qf.csv', row.names = FALSE, col.names = FALSE, sep = ",")

</code></pre>

<hr>
<h2 id='im.merge'>Merge Two Incidence Matrices</h2><span id='topic+im.merge'></span>

<h3>Description</h3>

<p>From two incidience matrices, create a single incidence matrix. Matrices may contain same row or column elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>im.merge(obj1, obj2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im.merge_+3A_obj1">obj1</code>, <code id="im.merge_+3A_obj2">obj2</code></td>
<td>
<p>Two incidence matrices of any size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single incidence matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quattrofontanili)
qf1 &lt;- quattrofontanili[1:20, 1:40]
qf1 &lt;- qf1[rowSums(qf1) != 0, colSums(qf1) != 0]

qf2 &lt;- quattrofontanili[30:50, 20:60]
qf2 &lt;- qf2[rowSums(qf2) != 0, colSums(qf2) != 0]

im.merge(qf1, qf2)

</code></pre>

<hr>
<h2 id='im.ref'>Create Reference Matrix</h2><span id='topic+im.ref'></span>

<h3>Description</h3>

<p>Create an ideal reference matrix of well-seriated values of the same size as the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>im.ref(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="im.ref_+3A_obj">obj</code></td>
<td>
<p>A matrix of size <code class="reqn">n \times k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code class="reqn">n \times k</code> with 1s along the diagonal. If <code class="reqn">n &gt; k</code>, 1s are placed from cell <code class="reqn">(i,i)</code> to <code class="reqn">(i,i+k-n)</code>, with 0 in all other cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>im.ref(matrix(NA, 5, 5))
im.ref(matrix(1, 7, 12))

</code></pre>

<hr>
<h2 id='kappa.coef'>Kappa Concentration</h2><span id='topic+kappa.coef'></span>

<h3>Description</h3>

<p>The concentration coefficient <code class="reqn">\kappa</code>, which extends the Kendall-Doran measure of concentration to include rows and then weights the total measure by the total sum of values in the matrix. See <code><a href="#topic+concentration.col">concentration.col</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coef'
kappa(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kappa.coef_+3A_obj">obj</code></td>
<td>
<p>A seriated binary matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">\kappa</code> coefficient of concentration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
kappa.coef(quattrofontanili)

</code></pre>

<hr>
<h2 id='lakhesize'>Lakhesize</h2><span id='topic+lakhesize'></span>

<h3>Description</h3>

<p>This function returns the row and column consensus seriation for a <code>list</code> of strands, containing their rankings, the results of their PCA, and coefficients of association and concentration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lakhesize(strands, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lakhesize_+3A_strands">strands</code></td>
<td>
<p>A <code>list</code> of strands, which are data frames returned by <code><a href="#topic+ca.procrustes.curve">ca.procrustes.curve</a></code>.</p>
</td></tr>
<tr><td><code id="lakhesize_+3A_obj">obj</code></td>
<td>
<p>The intial incidence matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consensus seriation is achieved by iterative, multi-step linear regression using simulation. On one iteration, strands are chosen at random, omitting incomplete or missing pairs, using PCA to determine the best-fitting line for their rankings. Both strands' rankings are then regressed onto that line to determine missing values, and then re-ranked, repeating until all strands have been regressed. PCA of the simulated rankings is then used to determine the final sequence of the row and column elements.
</p>


<h3>Value</h3>

<p>A <code>list</code> of the following:
</p>

<ul>
<li> <p><code>RowConsensus</code> Data frame of the consensus seriation of the row elements in the order of their projection on the first principal axis. Contains one column, <code>Row</code>.
</p>
</li>
<li> <p><code>ColConsensus</code> Data frame of the consensus seriation of the column elements in the order of their project onto the first principal axis. Contains one column, <code>Column</code>.
</p>
</li>
<li> <p><code>RowPCA</code> The results of <code style="white-space: pre;">&#8288;\link[stats]{prcomp}&#8288;</code> performed on the row elements of strands.
</p>
</li>
<li> <p><code>ColPCA</code> The results of <code style="white-space: pre;">&#8288;\link[stats]{prcomp}&#8288;</code> performed on the column elements of strands.
</p>
</li>
<li> <p><code>Coef</code>  A data frame containing the coefficients of agreement and concentration:
</p>

<ul>
<li> <p><code>Strand</code> The number of the strand.
</p>
</li>
<li> <p><code>Consensus.Spearman.Sq</code> the measure of agreement, i.e., how well each strand accords with the consensus seriation. Using the square of Spearman's rank correlation coefficient, <code class="reqn">\rho^2</code>, between each strand and the consensus ranking, agreement is computed as the product of <code class="reqn">\rho^2</code> for their row and column rankings, <code class="reqn">\rho_r^2</code><code class="reqn">\rho_c^2</code>.
</p>
</li>
<li> <p><code>Concentration.Kappa</code> the concentration coefficient <code class="reqn">\kappa</code>, which provides a measure of the optimality of each strand (see <code><a href="#topic+kappa.coef">kappa.coef</a></code>).
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
data("qfStrands")
lakhesize(qfStrands, quattrofontanili)

</code></pre>

<hr>
<h2 id='LC'>Lakhesis Calculator</h2><span id='topic+LC'></span>

<h3>Description</h3>

<p>Launch Lakhesis Calculator, a graphical interface to explore binary matrices via correspondence analysis, select potentially well-seriated sequences, and perform consensus seriation. Interface is made with <code>ggplot2</code>, <code>shiny</code>, <code>shinydashboard</code>, and <code>bslib</code> (Wickham 2016; Chang et al. 2024; Chang and Borges Ribeiro 2021; Sievert et al. 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LC()
</code></pre>


<h3>Details</h3>

<p>Input is done in the calculator, via a &quot;long&quot; format a two-column <code>.csv</code> file giving pairs of row and column incidences. See <code><a href="#topic+im.csv.read">im.csv.read</a></code> for details. Conversion of a pre-existing incidence matrix to long format can be performed with <code><a href="#topic+im.long">im.long</a></code>.
</p>
<p>Results can be downloaded from the calculator as an <code>.rds</code> file containing a <code>list</code> of the following:
</p>

<ul>
<li> <p><code>results</code> The consensus seriation, PCA, and coefficients of agreement and concentration
(<code><a href="#topic+lakhesize">lakhesize</a></code>).
</p>
</li>
<li> <p><code>strands</code> The strands selected by the investigator.
</p>
</li>
<li> <p><code>im.seriated</code> The incidence matrix of the consensus seriation.
</p>
</li></ul>



<h3>Value</h3>

<p>Opens the Lakhesis Calculator.
</p>


<h3>References</h3>

<p>Chang W, Borges Ribeiro B (2021).
<em>shinydashboard: Create Dashboards with 'Shiny'</em>.
<a href="https://CRAN.R-project.org/package=shinydashboard">https://CRAN.R-project.org/package=shinydashboard</a>.<br /><br /> Chang W, Cheng J, Allaire JJ, Sievert C, Schloerke B, Xie Y, Allen J, McPherson J, Dipert A, Borges B (2024).
<em>shiny: Web Application Framework for R</em>.
R package version 1.8.1.9001; https://github.com/rstudio/shiny, <a href="https://shiny.posit.co">https://shiny.posit.co</a>.<br /><br /> Sievert C, Cheng J, Aden-Buie G (2024).
<em>bslib: Custom &lsquo;Bootstrap&rsquo; &lsquo;Sass&rsquo; Themes for &lsquo;shiny&rsquo; and &lsquo;rmarkdown&rsquo;</em>.
R package version 0.7.0, https://github.com/rstudio/bslib, <a href="https://rstudio.github.io/bslib/">https://rstudio.github.io/bslib/</a>.<br /><br /> Wickham H (2016).
<em>ggplot2: Elegant Graphics for Data Analysis</em>.
Springer, New York.
</p>

<hr>
<h2 id='qfStrands'>Quattro Fontanili - Strands</h2><span id='topic+qfStrands'></span>

<h3>Description</h3>

<p>Three seriated strands selected from <code><a href="#topic+quattrofontanili">quattrofontanili</a></code> data, identified by the package author as an example for the documentation of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("qfStrands")
</code></pre>


<h3>Format</h3>

<p>A list containing data frames output by <code><a href="#topic+ca.procrustes.curve">ca.procrustes.curve</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("qfStrands")
print(qfStrands)

</code></pre>

<hr>
<h2 id='quattrofontanili'>Quattro Fontanili</h2><span id='topic+quattrofontanili'></span>

<h3>Description</h3>

<p>The seriation of tombs from necropoleis at Veii, primarily Quattro Fontanili, but also Valle la Fata, Vaccareccia, and Picazzano, in southern Etruria, established by Close-Brooks and Ridgway (1979).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("quattrofontanili")
</code></pre>


<h3>Format</h3>

<p>A seriated incidence matrix of 81 rows (tombs) and 82 columns (types).
</p>

<p>Data entered from Close-Brooks and Ridgway (1979), an English translation of the authors' original publication in <em>Notizie degli Scavi</em> (1963). Descriptions of types may be found in that paper.

</p>


<h3>References</h3>

<p>Close-Brooks J, Ridgway D (1979).
&ldquo;Veii in the Iron Age.&rdquo;
In Ridgway D, Ridgway FR (eds.), <em>Italy Before the Romans</em>, 95&ndash;127.
Academic Press, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
print(quattrofontanili)

</code></pre>

<hr>
<h2 id='spearman.sq'>Spearman Correlation Squared</h2><span id='topic+spearman.sq'></span>

<h3>Description</h3>

<p>The square of Spearman's rank correlation coefficient applied to two rankings (Spearman 1904). Rows with <code>NA</code> values are automatically removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spearman.sq(r1, r2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spearman.sq_+3A_r1">r1</code>, <code id="spearman.sq_+3A_r2">r2</code></td>
<td>
<p>Two vectors of paired ranks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The square of Spearman's rank correlation coefficient with NA values removed.
</p>


<h3>References</h3>

<p>Spearman C (1904).
&ldquo;The Proof and Measurement of Association between Two Things.&rdquo;
<em>American Journal of Psychology</em>, <b>15</b>, 72&ndash;101.
<a href="https://doi.org/10.2307/1412159">doi:10.2307/1412159</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># e.g., for two partial seriations:
x &lt;- c(1, 2, 3, 4, NA, 5, 6, NA, 7.5, 7.5, 9)
y &lt;- c(23, 17, 19, NA, 21, 22, 25, 26, 27, 36, 32)
spearman.sq(x, y)

</code></pre>

<hr>
<h2 id='strand.extract'>Strand Extract</h2><span id='topic+strand.extract'></span>

<h3>Description</h3>

<p>From a <code>list</code> of strands produced by <code><a href="#topic+ca.procrustes.curve">ca.procrustes.curve</a></code>, extract two matrices containing the ranks of the rows and columns. The row/column elements are contained in the rows, and the strands are contained in the columns. NA values are entered where a given row/column element is missing from that strand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strand.extract(strands, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strand.extract_+3A_strands">strands</code></td>
<td>
<p>A list of <code>strands</code>, which are data frames returned by <code><a href="#topic+ca.procrustes.curve">ca.procrustes.curve</a></code>.</p>
</td></tr>
<tr><td><code id="strand.extract_+3A_obj">obj</code></td>
<td>
<p>The intial incidence matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two matrices:
</p>

<ul>
<li> <p><code>Row</code> A matrix of the ranks of the row elements.
</p>
</li>
<li> <p><code>Col</code> A matrix of the ranks of the column elements.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
data("qfStrands")
strand.extract(qfStrands, quattrofontanili)

</code></pre>

<hr>
<h2 id='strand.suppress'>Suppress Element from Strands</h2><span id='topic+strand.suppress'></span>

<h3>Description</h3>

<p>Given a list of strands, remove a row or column element and re-run seriation by correspondence analysis with Procrustes fitting (<code><a href="#topic+ca.procrustes.curve">ca.procrustes.curve</a></code>) to generate a new list of strands that exclude the specified elements. If the resulting strand lacks sufficient points to perform correspondence analysis, that strand is deleted in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strand.suppress(strands, obj, elements)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strand.suppress_+3A_strands">strands</code></td>
<td>
<p>A list of strands, which are data frames returned by <code><a href="#topic+ca.procrustes.curve">ca.procrustes.curve</a></code>.</p>
</td></tr>
<tr><td><code id="strand.suppress_+3A_obj">obj</code></td>
<td>
<p>The intial incidence matrix.</p>
</td></tr>
<tr><td><code id="strand.suppress_+3A_elements">elements</code></td>
<td>
<p>A vector of one or more row or column ids to suppress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the strands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("quattrofontanili")
data("qfStrands")
strand.suppress(qfStrands, quattrofontanili, "QF II 15-16")

strand.suppress(qfStrands, quattrofontanili, c("QF II 15-16", "I", "XIV"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
