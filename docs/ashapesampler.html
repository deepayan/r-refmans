<!DOCTYPE html><html lang="en"><head><title>Help for package ashapesampler</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ashapesampler}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_overlap_2D'><p>Calculate Overlap 2D</p></a></li>
<li><a href='#calc_overlap_3D'><p>calculate overlap in three dimensions (calc_overlap_3D)</p></a></li>
<li><a href='#cap_intersect_vol'><p>Intersection of spheres</p></a></li>
<li><a href='#circ_face_2D'><p>Circumcenter face - three points in 2D</p>
Given 3 sets of coordinates, calculates the circumcenter</a></li>
<li><a href='#circ_face_3D'><p>Circumcenter face - three points in 3D</p>
Given 3 sets of coordinates, calculates the circumcenter</a></li>
<li><a href='#circ_tet_3D'><p>Circumcenter tetrahedron - 4 points in 3D</p>
Given 3D coordinates of 4 points, calculates circumcenter</a></li>
<li><a href='#circle_overlap_cc'><p>Circle Overlap Centered on Circumference</p></a></li>
<li><a href='#circle_overlap_ia'><p>Circle Overlap Inner Annulus</p></a></li>
<li><a href='#circumcenter_face'><p>circumcenter Face</p></a></li>
<li><a href='#circumcenter_tet'><p>circumcenter Tetrahedra</p></a></li>
<li><a href='#count_neighbors'><p>Neighbors function - finds number of neighbors for each point in point cloud.</p></a></li>
<li><a href='#euclid_dists_point_cloud_2D'><p>Euclidean Distance Point Cloud 2D</p></a></li>
<li><a href='#euclid_dists_point_cloud_3D'><p>Euclidean Distance Point Cloud 3D</p></a></li>
<li><a href='#extract_complex_edges'><p>Returns the edges of complex.</p></a></li>
<li><a href='#extract_complex_faces'><p>Returns faces of complex.</p></a></li>
<li><a href='#extract_complex_tet'><p>Returns tetrahedra of complex (3 dimensions)</p></a></li>
<li><a href='#extreme_pts'><p>Extreme points</p>
Finds the boundary points of a simplicial complex</a></li>
<li><a href='#generate_ashape2d'><p>Generate 2D alpha shape</p></a></li>
<li><a href='#generate_ashape3d'><p>Generate 3D alpha shape</p></a></li>
<li><a href='#get_alpha_complex'><p>Get alpha complex</p></a></li>
<li><a href='#get_area'><p>Get area</p></a></li>
<li><a href='#get_volume'><p>Get volume</p></a></li>
<li><a href='#n_bound_connect_2D'><p>n Bound Connect 2D</p></a></li>
<li><a href='#n_bound_connect_3D'><p>N Bound Connect 3D</p></a></li>
<li><a href='#n_bound_homology_2D'><p>n Bound Homology 2D</p></a></li>
<li><a href='#n_bound_homology_3D'><p>n Bound Homology 3D</p></a></li>
<li><a href='#read_alpha_txt'><p>Read alpha text file</p></a></li>
<li><a href='#readOFF'><p>Read OFF File</p></a></li>
<li><a href='#runif_annulus'><p>Uniform Sampling from Annulus</p></a></li>
<li><a href='#runif_ball_3D'><p>Uniform Ball 3D</p></a></li>
<li><a href='#runif_cube'><p>r Uniform Cube</p></a></li>
<li><a href='#runif_disk'><p>Uniform sampling from disk</p></a></li>
<li><a href='#runif_shell_3D'><p>Uniform Shell 3D</p></a></li>
<li><a href='#runif_square'><p>Uniform Sampling from Square</p></a></li>
<li><a href='#sampling2Dashape'><p>Sampling 2D alpha shapes</p></a></li>
<li><a href='#sampling3Dashape'><p>Sample 3D alpha shapes</p></a></li>
<li><a href='#sphere_overlap_cs'><p>sphere overlap when one is centered on circumference of the other</p></a></li>
<li><a href='#sphere_overlap_is'><p>sphere overlap inner shell</p></a></li>
<li><a href='#spherical_cap'><p>Spherical cap</p></a></li>
<li><a href='#tau_bound'><p>tau_bound</p></a></li>
<li><a href='#write_alpha_txt'><p>Write Alpha Text file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generating Alpha Shapes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Understanding morphological variation is an important task in many applications. Recent studies in computational biology have focused on developing computational tools for the task of sub-image selection which aims at identifying structural features that best describe the variation between classes of shapes. A major part in assessing the utility of these approaches is to demonstrate their performance on both simulated and real datasets. However, when creating a model for shape statistics, real data can be difficult to access and the sample sizes for these data are often small due to them being expensive to collect. Meanwhile, the landscape of current shape simulation methods has been mostly limited to approaches that use black-box inference&mdash;making it difficult to systematically assess the power and calibration of sub-image models. In this R package, we introduce the alpha-shape sampler: a probabilistic framework for simulating realistic 2D and 3D shapes based on probability distributions which can be learned from real data or explicitly stated by the user. The 'ashapesampler' package supports two mechanisms for sampling shapes in two and three dimensions. The first, empirically sampling based on an existing data set, was highlighted in the original main text of the paper. The second, probabilistic sampling from a known distribution, is the computational implementation of the theory derived in that paper. Work based on Winn-Nunez et al. (2024) &lt;<a href="https://doi.org/10.1101%2F2024.01.09.574919">doi:10.1101/2024.01.09.574919</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>pracma, alphahull, alphashape3d, truncnorm, stats, Rvcg, TDA,
doParallel, foreach, parallel, dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rgl, ggplot2, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 01:21:30 UTC; etwin</td>
</tr>
<tr>
<td>Author:</td>
<td>Emily Winn-Nunez <a href="https://orcid.org/0000-0001-6759-5406"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lorin Crawford <a href="https://orcid.org/0000-0003-0178-8242"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emily Winn-Nunez &lt;emily_winn-nunez@brown.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_overlap_2D'>Calculate Overlap 2D</h2><span id='topic+calc_overlap_2D'></span>

<h3>Description</h3>

<p>This function calculates the minimum coverage percentage of an alpha ball over the bounded
area being considered. 0 is no coverage, 1 means complete coverage.
For the square, r is the length of the side. For circle, r is the radius. For
the annulus, r and min_r are the two radii.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_overlap_2D(alpha, r = 1, rmin = 0.01, bound = "square")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_overlap_2D_+3A_alpha">alpha</code></td>
<td>
<p>radius of alpha ball</p>
</td></tr>
<tr><td><code id="calc_overlap_2D_+3A_r">r</code></td>
<td>
<p>length of square, radius of circle, or outer radius of annulus</p>
</td></tr>
<tr><td><code id="calc_overlap_2D_+3A_rmin">rmin</code></td>
<td>
<p>inner radius of annulus</p>
</td></tr>
<tr><td><code id="calc_overlap_2D_+3A_bound">bound</code></td>
<td>
<p>manifold shape, options are &quot;square&quot;, &quot;circle&quot;, or &quot;annulus&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>area of overlap
</p>

<hr>
<h2 id='calc_overlap_3D'>calculate overlap in three dimensions (calc_overlap_3D)</h2><span id='topic+calc_overlap_3D'></span>

<h3>Description</h3>

<p>Calculates the volume of intersection divided by the volume of the manifold.
For the cube, r is the length of the side. For sphere, r is the radius. For
the annulus, r and min_r are the two radii.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_overlap_3D(alpha, r = 1, rmin = 0.01, bound = "cube")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_overlap_3D_+3A_alpha">alpha</code></td>
<td>
<p>radius of one sphere</p>
</td></tr>
<tr><td><code id="calc_overlap_3D_+3A_r">r</code></td>
<td>
<p>radius of second sphere or outer radius of shell or length of
cube side</p>
</td></tr>
<tr><td><code id="calc_overlap_3D_+3A_rmin">rmin</code></td>
<td>
<p>inner radius of shell, only needed if bound=shell</p>
</td></tr>
<tr><td><code id="calc_overlap_3D_+3A_bound">bound</code></td>
<td>
<p>manifold type, options are &quot;cube&quot;, &quot;shell&quot;, and &quot;sphere&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume of overlap
</p>

<hr>
<h2 id='cap_intersect_vol'>Intersection of spheres</h2><span id='topic+cap_intersect_vol'></span>

<h3>Description</h3>

<p>Called for sphere overlaps with alpha &gt; r*sqrt(2). Integral precalculated and
numbers plugged in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cap_intersect_vol(alpha, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cap_intersect_vol_+3A_alpha">alpha</code></td>
<td>
<p>radius 1</p>
</td></tr>
<tr><td><code id="cap_intersect_vol_+3A_r">r</code></td>
<td>
<p>radius 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume of intersection of spheres.
</p>

<hr>
<h2 id='circ_face_2D'>Circumcenter face - three points in 2D
Given 3 sets of coordinates, calculates the circumcenter</h2><span id='topic+circ_face_2D'></span>

<h3>Description</h3>

<p>Circumcenter face - three points in 2D
Given 3 sets of coordinates, calculates the circumcenter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_face_2D(points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circ_face_2D_+3A_points">points</code></td>
<td>
<p>3x2 matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1x2 vector, coordinates of circumcenter
</p>

<hr>
<h2 id='circ_face_3D'>Circumcenter face - three points in 3D
Given 3 sets of coordinates, calculates the circumcenter</h2><span id='topic+circ_face_3D'></span>

<h3>Description</h3>

<p>Circumcenter face - three points in 3D
Given 3 sets of coordinates, calculates the circumcenter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_face_3D(points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circ_face_3D_+3A_points">points</code></td>
<td>
<p>3x3 matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1x3 vector, coordinates of circumcenter
</p>

<hr>
<h2 id='circ_tet_3D'>Circumcenter tetrahedron - 4 points in 3D
Given 3D coordinates of 4 points, calculates circumcenter</h2><span id='topic+circ_tet_3D'></span>

<h3>Description</h3>

<p>Circumcenter tetrahedron - 4 points in 3D
Given 3D coordinates of 4 points, calculates circumcenter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_tet_3D(points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circ_tet_3D_+3A_points">points</code></td>
<td>
<p>4x3 matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1x3 vector, coordinates of circumcenter
</p>

<hr>
<h2 id='circle_overlap_cc'>Circle Overlap Centered on Circumference</h2><span id='topic+circle_overlap_cc'></span>

<h3>Description</h3>

<p>Circle overlap cc is subfunction for repeated code in calc_overlap_2D
Returns the area of two overlapping circles where one is centered on the other's
Circumference. (cc = centered on circumference )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle_overlap_cc(alpha, r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_overlap_cc_+3A_alpha">alpha</code></td>
<td>
<p>radius 1</p>
</td></tr>
<tr><td><code id="circle_overlap_cc_+3A_r">r</code></td>
<td>
<p>radius 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>area of overlap
</p>

<hr>
<h2 id='circle_overlap_ia'>Circle Overlap Inner Annulus</h2><span id='topic+circle_overlap_ia'></span>

<h3>Description</h3>

<p>Circle overlap ia (inner annulus) calculates area needed to subtract
when calculating area of overlap of annulus and circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle_overlap_ia(alpha, R, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_overlap_ia_+3A_alpha">alpha</code></td>
<td>
<p>radius of circle</p>
</td></tr>
<tr><td><code id="circle_overlap_ia_+3A_r">R</code></td>
<td>
<p>outer radius of annulus</p>
</td></tr>
<tr><td><code id="circle_overlap_ia_+3A_r">r</code></td>
<td>
<p>inner radius of annulus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>area of overlap
</p>

<hr>
<h2 id='circumcenter_face'>circumcenter Face</h2><span id='topic+circumcenter_face'></span>

<h3>Description</h3>

<p>This function finds the circumcenters of the faces of a simplicial complex given the
list of vertex coordinates and the set of faces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circumcenter_face(v_list, f_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circumcenter_face_+3A_v_list">v_list</code></td>
<td>
<p>matrix of vertex coordinates</p>
</td></tr>
<tr><td><code id="circumcenter_face_+3A_f_list">f_list</code></td>
<td>
<p>matrix with 3 columns with face information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>circ_mat, matrix of coordinates of circumcenters of faces.
</p>

<hr>
<h2 id='circumcenter_tet'>circumcenter Tetrahedra</h2><span id='topic+circumcenter_tet'></span>

<h3>Description</h3>

<p>This function finds the circumcenters of the tetrahedra/3-simplices of a simplicial
complex given the list of vertex coordinates and the set of tetrahedra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circumcenter_tet(v_list, t_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circumcenter_tet_+3A_v_list">v_list</code></td>
<td>
<p>matrix of vertex coordinates</p>
</td></tr>
<tr><td><code id="circumcenter_tet_+3A_t_list">t_list</code></td>
<td>
<p>matrix of 4 columns with tetrahedra</p>
</td></tr>
</table>


<h3>Value</h3>

<p>circ_mat, matrix of coordinates of circumcenters of teterahedra
</p>

<hr>
<h2 id='count_neighbors'>Neighbors function - finds number of neighbors for each point in point cloud.</h2><span id='topic+count_neighbors'></span>

<h3>Description</h3>

<p>Neighbors function - finds number of neighbors for each point in point cloud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_neighbors(v_list, complex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_neighbors_+3A_v_list">v_list</code></td>
<td>
<p>2 or 3 column matrix</p>
</td></tr>
<tr><td><code id="count_neighbors_+3A_complex">complex</code></td>
<td>
<p>simplicial complex object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n_list vector where each entry is number of neighbors for a point
</p>

<hr>
<h2 id='euclid_dists_point_cloud_2D'>Euclidean Distance Point Cloud 2D</h2><span id='topic+euclid_dists_point_cloud_2D'></span>

<h3>Description</h3>

<p>Calculates the distance matrix of a point from the point cloud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclid_dists_point_cloud_2D(point, point_cloud)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euclid_dists_point_cloud_2D_+3A_point">point</code></td>
<td>
<p>cartesian coordinates of 2D point</p>
</td></tr>
<tr><td><code id="euclid_dists_point_cloud_2D_+3A_point_cloud">point_cloud</code></td>
<td>
<p>3 column matrix with cartesian coordinates of 2D point cloud</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of distances from the point to each point in the point cloud
</p>

<hr>
<h2 id='euclid_dists_point_cloud_3D'>Euclidean Distance Point Cloud 3D</h2><span id='topic+euclid_dists_point_cloud_3D'></span>

<h3>Description</h3>

<p>Calculates the distance matrix of a point from the point cloud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclid_dists_point_cloud_3D(point, point_cloud)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euclid_dists_point_cloud_3D_+3A_point">point</code></td>
<td>
<p>cartesian coordinates of 3D point</p>
</td></tr>
<tr><td><code id="euclid_dists_point_cloud_3D_+3A_point_cloud">point_cloud</code></td>
<td>
<p>3 column matrix with cartesian coordinates of 3D point cloud</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of distances from the point to each point in the point cloud
</p>

<hr>
<h2 id='extract_complex_edges'>Returns the edges of complex.</h2><span id='topic+extract_complex_edges'></span>

<h3>Description</h3>

<p>Returns the edges of complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_complex_edges(complex, n_vert = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_complex_edges_+3A_complex">complex</code></td>
<td>
<p>complex object from TDA packages</p>
</td></tr>
<tr><td><code id="extract_complex_edges_+3A_n_vert">n_vert</code></td>
<td>
<p>number of vertices in complex; default is 0, specifying
this parameter speeds up the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>edge_list data frame or if empty NULL
</p>

<hr>
<h2 id='extract_complex_faces'>Returns faces of complex.</h2><span id='topic+extract_complex_faces'></span>

<h3>Description</h3>

<p>Returns faces of complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_complex_faces(complex, n_vert = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_complex_faces_+3A_complex">complex</code></td>
<td>
<p>complex object from TDA package</p>
</td></tr>
<tr><td><code id="extract_complex_faces_+3A_n_vert">n_vert</code></td>
<td>
<p>number of vertices in the complex; default is 0, specifying
this parameter speeds up function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>face_list data frame of points forming faces in complex
</p>

<hr>
<h2 id='extract_complex_tet'>Returns tetrahedra of complex (3 dimensions)</h2><span id='topic+extract_complex_tet'></span>

<h3>Description</h3>

<p>Returns tetrahedra of complex (3 dimensions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_complex_tet(complex, n_vert = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_complex_tet_+3A_complex">complex</code></td>
<td>
<p>complex object from TDA package</p>
</td></tr>
<tr><td><code id="extract_complex_tet_+3A_n_vert">n_vert</code></td>
<td>
<p>number of vertices in the complex; default is 0, specifying this
parameter speeds up function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tet_list data frame of points forming tetrahedra in complex
</p>

<hr>
<h2 id='extreme_pts'>Extreme points
Finds the boundary points of a simplicial complex</h2><span id='topic+extreme_pts'></span>

<h3>Description</h3>

<p>Extreme points
Finds the boundary points of a simplicial complex
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extreme_pts(complex, n_vert, dimension)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extreme_pts_+3A_complex">complex</code></td>
<td>
<p>complex list object</p>
</td></tr>
<tr><td><code id="extreme_pts_+3A_n_vert">n_vert</code></td>
<td>
<p>number of vertices in the complex</p>
</td></tr>
<tr><td><code id="extreme_pts_+3A_dimension">dimension</code></td>
<td>
<p>number, 2 or 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of all vertices on the boundary
</p>

<hr>
<h2 id='generate_ashape2d'>Generate 2D alpha shape</h2><span id='topic+generate_ashape2d'></span>

<h3>Description</h3>

<p>Generate 2D alpha shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_ashape2d(
  point_cloud,
  J,
  tau,
  delta = 0.05,
  afixed = TRUE,
  mu = NULL,
  sig = NULL,
  sample_rad = NULL,
  acc_rad = NULL,
  k_min = 2,
  eps = 1e-04,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_ashape2d_+3A_point_cloud">point_cloud</code></td>
<td>
<p>2 column matrix of all points from all shapes in initial
data set</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_j">J</code></td>
<td>
<p>number of shapes in initial (sub) data set</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_tau">tau</code></td>
<td>
<p>tau bound vector for shapes input</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_delta">delta</code></td>
<td>
<p>probability of not preserving homology; default is 0.05</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_afixed">afixed</code></td>
<td>
<p>boolean, whether to sample alpha or leave fixed based on tau. Default FALSE</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_mu">mu</code></td>
<td>
<p>mean of truncated distribution from which alpha sampled; default tau/3</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_sig">sig</code></td>
<td>
<p>standard deviation of truncated distribution from which alpha
sampled; default tau/12</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_sample_rad">sample_rad</code></td>
<td>
<p>radius of ball around each point in point cloud from which to
sample; default tau/8</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_acc_rad">acc_rad</code></td>
<td>
<p>radius of ball to check around potential sampled points for whether
to accept or reject new point; default tau/4</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_k_min">k_min</code></td>
<td>
<p>number of points needed in radius tau of point cloud to accept a sample</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_eps">eps</code></td>
<td>
<p>amount to subtract from tau/2 to give alpha. Defaul 1e-4.</p>
</td></tr>
<tr><td><code id="generate_ashape2d_+3A_cores">cores</code></td>
<td>
<p>number of computer cores for parallelizing. Default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new_ashape two dimensional alpha shape object from alphahull library
</p>

<hr>
<h2 id='generate_ashape3d'>Generate 3D alpha shape</h2><span id='topic+generate_ashape3d'></span>

<h3>Description</h3>

<p>Generate 3D alpha shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_ashape3d(
  point_cloud,
  J,
  tau,
  delta = 0.05,
  afixed = TRUE,
  mu = NULL,
  sig = NULL,
  sample_rad = NULL,
  acc_rad = NULL,
  k_min = 3,
  eps = 1e-04,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_ashape3d_+3A_point_cloud">point_cloud</code></td>
<td>
<p>3 column matrix of all points from all shapes in initial
data set</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_j">J</code></td>
<td>
<p>number of shapes in initial data set</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_tau">tau</code></td>
<td>
<p>tau bound for the shapes</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_delta">delta</code></td>
<td>
<p>probability of not preserving homology; default is 0.05</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_afixed">afixed</code></td>
<td>
<p>boolean, whether to sample alpha or leave fixed based on tau. Default FALSE</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_mu">mu</code></td>
<td>
<p>mean of truncated distribution from which alpha sampled; default tau/3</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_sig">sig</code></td>
<td>
<p>standard deviation of truncated distribution from which alpha
sampled; default tau/12</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_sample_rad">sample_rad</code></td>
<td>
<p>radius of ball around each point in point cloud from which to
sample; default tau/8</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_acc_rad">acc_rad</code></td>
<td>
<p>radius of ball to check around potential sampled points for whether
to accept or reject new point; default tau/4</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_k_min">k_min</code></td>
<td>
<p>number of points needed in radius 2 alpha of point cloud to accept a sample</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_eps">eps</code></td>
<td>
<p>amount to subtract from tau/2 to give alpha. Defaul 1e-4.</p>
</td></tr>
<tr><td><code id="generate_ashape3d_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallelizing. Default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new_ashape three dimensional alpha shape object from alphashape3d library
</p>

<hr>
<h2 id='get_alpha_complex'>Get alpha complex</h2><span id='topic+get_alpha_complex'></span>

<h3>Description</h3>

<p>Generates alpha complex for a set of points and parameter alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alpha_complex(points, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_alpha_complex_+3A_points">points</code></td>
<td>
<p>point cloud for alpha complex, in form of 2 column of 3 column
matrix with nonzero number of rows</p>
</td></tr>
<tr><td><code id="get_alpha_complex_+3A_alpha">alpha</code></td>
<td>
<p>alpha parameter for building the alpha complex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>complex list of vertices, edges, faces, and tetrahedra.
</p>

<hr>
<h2 id='get_area'>Get area</h2><span id='topic+get_area'></span>

<h3>Description</h3>

<p>Quickly calculate which area needed for a homology bound; here to clean up
code above
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_area(r, rmin, bound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_area_+3A_r">r</code></td>
<td>
<p>side length (square) or radius (circle, annulus)</p>
</td></tr>
<tr><td><code id="get_area_+3A_rmin">rmin</code></td>
<td>
<p>radius of inner circle for annulus</p>
</td></tr>
<tr><td><code id="get_area_+3A_bound">bound</code></td>
<td>
<p>square, circle, or annulus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>area, number
</p>

<hr>
<h2 id='get_volume'>Get volume</h2><span id='topic+get_volume'></span>

<h3>Description</h3>

<p>Quickly calculate which volume needed for a homology bound; here to clean up
code above
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_volume(r, rmin, bound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_volume_+3A_r">r</code></td>
<td>
<p>side length (cube) or radius (sphere, shell)</p>
</td></tr>
<tr><td><code id="get_volume_+3A_rmin">rmin</code></td>
<td>
<p>radius of inner sphere for shell</p>
</td></tr>
<tr><td><code id="get_volume_+3A_bound">bound</code></td>
<td>
<p>cube, sphere, shell</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume, number
</p>

<hr>
<h2 id='n_bound_connect_2D'>n Bound Connect 2D</h2><span id='topic+n_bound_connect_2D'></span>

<h3>Description</h3>

<p>This is the bound for connectivity based on samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_bound_connect_2D(alpha, delta = 0.05, r = 1, rmin = 0.01, bound = "square")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_bound_connect_2D_+3A_alpha">alpha</code></td>
<td>
<p>alpha parameter for alpha shape</p>
</td></tr>
<tr><td><code id="n_bound_connect_2D_+3A_delta">delta</code></td>
<td>
<p>probability of isolated point</p>
</td></tr>
<tr><td><code id="n_bound_connect_2D_+3A_r">r</code></td>
<td>
<p>length of square, radius of circle, or outer radius of annulus</p>
</td></tr>
<tr><td><code id="n_bound_connect_2D_+3A_rmin">rmin</code></td>
<td>
<p>inner radius of annulus</p>
</td></tr>
<tr><td><code id="n_bound_connect_2D_+3A_bound">bound</code></td>
<td>
<p>manifold shape, options are &quot;square&quot;, &quot;circle&quot;, or &quot;annulus&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>minimum number of points to meet probability threshold.
</p>

<hr>
<h2 id='n_bound_connect_3D'>N Bound Connect 3D</h2><span id='topic+n_bound_connect_3D'></span>

<h3>Description</h3>

<p>Function returns the minimum number of points to preserve the homology with
an open cover of radius alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_bound_connect_3D(alpha, delta = 0.05, r = 1, rmin = 0.01, bound = "cube")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_bound_connect_3D_+3A_alpha">alpha</code></td>
<td>
<p>radius of open balls around points</p>
</td></tr>
<tr><td><code id="n_bound_connect_3D_+3A_delta">delta</code></td>
<td>
<p>probability of isolated point</p>
</td></tr>
<tr><td><code id="n_bound_connect_3D_+3A_r">r</code></td>
<td>
<p>radius of sphere, outer radius of shell, or length of cube side</p>
</td></tr>
<tr><td><code id="n_bound_connect_3D_+3A_rmin">rmin</code></td>
<td>
<p>inner radius of shell</p>
</td></tr>
<tr><td><code id="n_bound_connect_3D_+3A_bound">bound</code></td>
<td>
<p>manifold from which points sampled. Options are sphere, shell, cube</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer of minimum number of points needed
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a cube with probability 0.05 of isolated points
n_bound_connect_3D(0.2, 0.05,0.9)
# For a sphere with probability 0.01 of isolated points
n_bound_connect_3D(0.2, 0.01, 1, bound="sphere")
# For a shell with probability 0.1 isolated points.
n_bound_connect_3D(0.2, 0.1, 1, 0.25, bound="shell")
</code></pre>

<hr>
<h2 id='n_bound_homology_2D'>n Bound Homology 2D</h2><span id='topic+n_bound_homology_2D'></span>

<h3>Description</h3>

<p>#' Function returns the minimum number of points to preserve the homology with
an open cover of radius alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_bound_homology_2D(area, epsilon, tau = 1, delta = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_bound_homology_2D_+3A_area">area</code></td>
<td>
<p>area of manifold from which points being sampled</p>
</td></tr>
<tr><td><code id="n_bound_homology_2D_+3A_epsilon">epsilon</code></td>
<td>
<p>size of balls of cover</p>
</td></tr>
<tr><td><code id="n_bound_homology_2D_+3A_tau">tau</code></td>
<td>
<p>number bound</p>
</td></tr>
<tr><td><code id="n_bound_homology_2D_+3A_delta">delta</code></td>
<td>
<p>probability of not recovering homology</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n, number of points needed
</p>

<hr>
<h2 id='n_bound_homology_3D'>n Bound Homology 3D</h2><span id='topic+n_bound_homology_3D'></span>

<h3>Description</h3>

<p>Calculates number of points needed to be samped from manifold for open
ball cover to have same homology as original manifold. See Niyogi et al 2008
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_bound_homology_3D(volume, epsilon, tau = 1, delta = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_bound_homology_3D_+3A_volume">volume</code></td>
<td>
<p>volume of manifold from which points being sampled</p>
</td></tr>
<tr><td><code id="n_bound_homology_3D_+3A_epsilon">epsilon</code></td>
<td>
<p>size of balls of cover</p>
</td></tr>
<tr><td><code id="n_bound_homology_3D_+3A_tau">tau</code></td>
<td>
<p>number bound</p>
</td></tr>
<tr><td><code id="n_bound_homology_3D_+3A_delta">delta</code></td>
<td>
<p>probability of not recovering homology</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n, number of points needed
</p>

<hr>
<h2 id='read_alpha_txt'>Read alpha text file</h2><span id='topic+read_alpha_txt'></span>

<h3>Description</h3>

<p>Read alpha text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_alpha_txt(file_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_alpha_txt_+3A_file_name">file_name</code></td>
<td>
<p>name and path of file to be read. File is of format output
by write_alpha_txt function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>alpha shape object
</p>

<hr>
<h2 id='readOFF'>Read OFF File</h2><span id='topic+readOFF'></span>

<h3>Description</h3>

<p>This is a function to read OFF files for triangular meshes into the form
that is required to use other functions in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readOFF(file_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readOFF_+3A_file_name">file_name</code></td>
<td>
<p>path and name of file to be read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>complex_info list object containing two components, &quot;Vertices&quot; which
holds the vertex coordinates and &quot;cmplx&quot; which holds the complex list
object.
</p>

<hr>
<h2 id='runif_annulus'>Uniform Sampling from Annulus</h2><span id='topic+runif_annulus'></span>

<h3>Description</h3>

<p>Returns points uniformly sampled from annulus in plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_annulus(n, rmax = 1, rmin = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif_annulus_+3A_n">n</code></td>
<td>
<p>number of points to sample</p>
</td></tr>
<tr><td><code id="runif_annulus_+3A_rmax">rmax</code></td>
<td>
<p>radius of outer circle of annulus</p>
</td></tr>
<tr><td><code id="runif_annulus_+3A_rmin">rmin</code></td>
<td>
<p>radius of inner circle of annulus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n by 2 matrix of points sampled
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 100 points from annulus with rmax=1 and rmin=0.5
runif_annulus(100)
# Sample 100 points from annulus with rmax=0.75 and rmin=0.25
runif_annulus(100, 0.75, 0.25)
</code></pre>

<hr>
<h2 id='runif_ball_3D'>Uniform Ball 3D</h2><span id='topic+runif_ball_3D'></span>

<h3>Description</h3>

<p>Returns points uniformly centered from closed ball of radius r in 3D space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_ball_3D(n, r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif_ball_3D_+3A_n">n</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="runif_ball_3D_+3A_r">r</code></td>
<td>
<p>radius of ball, default r=1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n by 3 matrix of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 100 points from unit ball
runif_ball_3D(100)
# Sample 100 points from ball of radius 0.5
runif_ball_3D(100, r=0.5)
</code></pre>

<hr>
<h2 id='runif_cube'>r Uniform Cube</h2><span id='topic+runif_cube'></span>

<h3>Description</h3>

<p>Returns points uniformly sampled from cube or rectangular prism in space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_cube(n, xmin = 0, xmax = 1, ymin = 0, ymax = 1, zmin = 0, zmax = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif_cube_+3A_n">n</code></td>
<td>
<p>number of points to be sampled</p>
</td></tr>
<tr><td><code id="runif_cube_+3A_xmin">xmin</code></td>
<td>
<p>miniumum x coordinate</p>
</td></tr>
<tr><td><code id="runif_cube_+3A_xmax">xmax</code></td>
<td>
<p>maximum x coordinate</p>
</td></tr>
<tr><td><code id="runif_cube_+3A_ymin">ymin</code></td>
<td>
<p>minimum y coordinate</p>
</td></tr>
<tr><td><code id="runif_cube_+3A_ymax">ymax</code></td>
<td>
<p>maximum y coordinate</p>
</td></tr>
<tr><td><code id="runif_cube_+3A_zmin">zmin</code></td>
<td>
<p>minimum z coordinate</p>
</td></tr>
<tr><td><code id="runif_cube_+3A_zmax">zmax</code></td>
<td>
<p>maximum z coordinate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n by 3 matrix of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 100 points from unit cube
runif_cube(100)
# Sample 100 points from unit cube centered on origin
runif_cube(100, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)
</code></pre>

<hr>
<h2 id='runif_disk'>Uniform sampling from disk</h2><span id='topic+runif_disk'></span>

<h3>Description</h3>

<p>Returns points uniformly sampled from disk of radius r in plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_disk(n, r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif_disk_+3A_n">n</code></td>
<td>
<p>number of points to sample</p>
</td></tr>
<tr><td><code id="runif_disk_+3A_r">r</code></td>
<td>
<p>radius of disk</p>
</td></tr>
</table>


<h3>Value</h3>

<p>points n by 2 matrix of points sampled
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 100 points from unit disk
runif_disk(100)
# Sample 100 points from disk of radius 0.7
runif_disk(100, 0.7)
</code></pre>

<hr>
<h2 id='runif_shell_3D'>Uniform Shell 3D</h2><span id='topic+runif_shell_3D'></span>

<h3>Description</h3>

<p>Returns points uniformly sampled from spherical shell in 3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_shell_3D(n, rmax = 1, rmin = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif_shell_3D_+3A_n">n</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="runif_shell_3D_+3A_rmax">rmax</code></td>
<td>
<p>radius of outer sphere</p>
</td></tr>
<tr><td><code id="runif_shell_3D_+3A_rmin">rmin</code></td>
<td>
<p>radius of inner sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n by 3 matrix of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 100 points with defaults rmax=1, rmin=0.5
runif_shell_3D(100)
# Sample 100 points with rmax=0.75, rmin=0.25
runif_shell_3D(100, 0.75, 0.25)
</code></pre>

<hr>
<h2 id='runif_square'>Uniform Sampling from Square</h2><span id='topic+runif_square'></span>

<h3>Description</h3>

<p>Returns points uniformly sampled from square or rectangle in plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_square(n, xmin = 0, xmax = 1, ymin = 0, ymax = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif_square_+3A_n">n</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="runif_square_+3A_xmin">xmin</code></td>
<td>
<p>minimum x coordinate</p>
</td></tr>
<tr><td><code id="runif_square_+3A_xmax">xmax</code></td>
<td>
<p>maximum x coordinate</p>
</td></tr>
<tr><td><code id="runif_square_+3A_ymin">ymin</code></td>
<td>
<p>minimum y coordinate</p>
</td></tr>
<tr><td><code id="runif_square_+3A_ymax">ymax</code></td>
<td>
<p>maximum y coordinate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n by 2 matrix of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 100 points from unit square
runif_square(100)
# Sample 100 points from unit square centered at origin
runif_square(100, 0.5, 0.5, 0.5, 0.5)
</code></pre>

<hr>
<h2 id='sampling2Dashape'>Sampling 2D alpha shapes</h2><span id='topic+sampling2Dashape'></span>

<h3>Description</h3>

<p>This function takes parameter input from user and returns list of two dimensional
alpha shape objects from the ahull package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling2Dashape(
  N,
  n.dependent = TRUE,
  nconnect = TRUE,
  nhomology = FALSE,
  n.noise = FALSE,
  afixed = FALSE,
  mu = 0.24,
  sigma = 0.05,
  delta = 0.05,
  n = 20,
  alpha = 0.24,
  lambda = 3,
  r = 1,
  rmin = 0.25,
  bound = "square"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampling2Dashape_+3A_n">N</code></td>
<td>
<p>number of alpha shapes to sample</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_n.dependent">n.dependent</code></td>
<td>
<p>boolean, whether the number of points n are dependent on alpha</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_nconnect">nconnect</code></td>
<td>
<p>boolean, whether user wants shapes to have one connected component
with high probability</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_nhomology">nhomology</code></td>
<td>
<p>boolean, whether user wants shapes to preserve homology of
underlying manifold with high probability</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_n.noise">n.noise</code></td>
<td>
<p>boolean, whether to add noise variable to number of points n
for more variety in shapes</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_afixed">afixed</code></td>
<td>
<p>boolean, whether alpha is fixed for all shapes sampled</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_mu">mu</code></td>
<td>
<p>mean value of truncated normal from which alpha is sampled</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of truncated normal distribution from which
alpha is sampled</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_delta">delta</code></td>
<td>
<p>probability of getting disconnected shape or not preserving homology</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_n">n</code></td>
<td>
<p>minimum number of points to be sampled for each alpha shape</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_alpha">alpha</code></td>
<td>
<p>chosen fixed alpha; only used if afixed = TRUE</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_lambda">lambda</code></td>
<td>
<p>parameter for adding noise to n; only used if n.noise=TRUE</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_r">r</code></td>
<td>
<p>length of radius of circle, side length of square, or outer radius of annulus</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_rmin">rmin</code></td>
<td>
<p>inner radius of annulus</p>
</td></tr>
<tr><td><code id="sampling2Dashape_+3A_bound">bound</code></td>
<td>
<p>compact manifold to be sampled from; either square, circle, or annulus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of alpha shapes of length N
</p>

<hr>
<h2 id='sampling3Dashape'>Sample 3D alpha shapes</h2><span id='topic+sampling3Dashape'></span>

<h3>Description</h3>

<p>This function takes parameter input from user and returns list of three dimensional
alpha shape objects from the ahull package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling3Dashape(
  N,
  n.dependent = TRUE,
  nconnect = TRUE,
  nhomology = FALSE,
  n.noise = FALSE,
  afixed = FALSE,
  mu = 0.24,
  sigma = 0.05,
  delta = 0.05,
  n = 20,
  alpha = 0.24,
  lambda = 3,
  r = 1,
  rmin = 0.25,
  bound = "cube"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampling3Dashape_+3A_n">N</code></td>
<td>
<p>number of alpha shapes to sample</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_n.dependent">n.dependent</code></td>
<td>
<p>boolean, whether the number of points n are dependent on alpha</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_nconnect">nconnect</code></td>
<td>
<p>boolean, whether user wants shapes to have one connected component
with high probability</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_nhomology">nhomology</code></td>
<td>
<p>boolean, whether user wants shapes to preserve homology of
underlying manifold with high probability</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_n.noise">n.noise</code></td>
<td>
<p>boolean, whether to add noise variable to number of points n
for more variety in shapes</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_afixed">afixed</code></td>
<td>
<p>boolean, whether alpha is fixed for all shapes sampled</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_mu">mu</code></td>
<td>
<p>mean value of truncated normal from which alpha is sampled</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of truncated normal distribution from which
alpha is sampled</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_delta">delta</code></td>
<td>
<p>probability of getting disconnected shape or not preserving homology</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_n">n</code></td>
<td>
<p>minimum number of points to be sampled for each alpha shape</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_alpha">alpha</code></td>
<td>
<p>chosen fixed alpha; only used if afixed = TRUE</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_lambda">lambda</code></td>
<td>
<p>parameter for adding noise to n; only used if n.noise=TRUE</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_r">r</code></td>
<td>
<p>length of radius of circle, side length of square, or outer radius of annulus</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_rmin">rmin</code></td>
<td>
<p>inner radius of annulus</p>
</td></tr>
<tr><td><code id="sampling3Dashape_+3A_bound">bound</code></td>
<td>
<p>compact manifold to be sampled from; either cube, sphere, or shell</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of alpha shapes of length N
</p>

<hr>
<h2 id='sphere_overlap_cs'>sphere overlap when one is centered on circumference of the other</h2><span id='topic+sphere_overlap_cs'></span>

<h3>Description</h3>

<p>Sphere overlap cs is subfunction for repeated code in calc_overlap_3D
Returns the area of two overlapping spheres where one is centered on the
other's surface (cs = centered on surface)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere_overlap_cs(alpha, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere_overlap_cs_+3A_alpha">alpha</code></td>
<td>
<p>radius 1</p>
</td></tr>
<tr><td><code id="sphere_overlap_cs_+3A_r">r</code></td>
<td>
<p>radius 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume of intersection
</p>

<hr>
<h2 id='sphere_overlap_is'>sphere overlap inner shell</h2><span id='topic+sphere_overlap_is'></span>

<h3>Description</h3>

<p>Sphere overlap is (inner shell) calculates area needed to subtract
when calculating volume of overlap of shell and sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere_overlap_is(alpha, rmax, rmin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphere_overlap_is_+3A_alpha">alpha</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
<tr><td><code id="sphere_overlap_is_+3A_rmax">rmax</code></td>
<td>
<p>outer radius of shell</p>
</td></tr>
<tr><td><code id="sphere_overlap_is_+3A_rmin">rmin</code></td>
<td>
<p>inner radius of shell</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume of intersection
</p>

<hr>
<h2 id='spherical_cap'>Spherical cap</h2><span id='topic+spherical_cap'></span>

<h3>Description</h3>

<p>Calculates the volume of a sphere cap given radius r and height of cap h
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherical_cap(r, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spherical_cap_+3A_r">r</code></td>
<td>
<p>radius</p>
</td></tr>
<tr><td><code id="spherical_cap_+3A_h">h</code></td>
<td>
<p>height of cap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>v_c volume of spherical cap
</p>

<hr>
<h2 id='tau_bound'>tau_bound</h2><span id='topic+tau_bound'></span>

<h3>Description</h3>

<p>This function finds the bound of tau for one shape, which is the maximum length of the
fiber bundle off of a shape for determining the density of points necessary
to recover the homology from the open cover. See Niyogi et al 2008. Function
checks length of edges and distances to circumcenters from each vertex before
checking against the rest of the point cloud and finds the minimum length.
We then keep the largest tau to account for the possibility of nonuniformity
among points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau_bound(v_list, complex, extremes = NULL, cores = 1, sumstat = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tau_bound_+3A_v_list">v_list</code></td>
<td>
<p>matrix or data frame of cartesian coordinates of vertices in
in point cloud</p>
</td></tr>
<tr><td><code id="tau_bound_+3A_complex">complex</code></td>
<td>
<p>list of each vertex, edge, face, and (in 3D) tetrahedron in
a simplicial complex; same form as complex object in TDA package</p>
</td></tr>
<tr><td><code id="tau_bound_+3A_extremes">extremes</code></td>
<td>
<p>matrix or data frame of cartesian coordinates of vertices on
the boundary of the data frame. If no list given, function will
assume all points are extreme and check them all. Inclusion of
this parameter speeds up the process both within this function
and when calculating alpha because you will get a bigger (but
still valid) tau bound.</p>
</td></tr>
<tr><td><code id="tau_bound_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallelizing. Default 1.</p>
</td></tr>
<tr><td><code id="tau_bound_+3A_sumstat">sumstat</code></td>
<td>
<p>string for summary statistic to be used to get final tau for
shape. Default is 'mean'. Options are 'median', 'min', and 'max'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tau_vec, vector real nonnegative number. Tau values for each point
</p>

<hr>
<h2 id='write_alpha_txt'>Write Alpha Text file</h2><span id='topic+write_alpha_txt'></span>

<h3>Description</h3>

<p>Write Alpha Text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_alpha_txt(ashape, file_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_alpha_txt_+3A_ashape">ashape</code></td>
<td>
<p>alpha shape object, can be 2D or 3D alpha shape</p>
</td></tr>
<tr><td><code id="write_alpha_txt_+3A_file_name">file_name</code></td>
<td>
<p>path and name of file to create and write text to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>does not return anything; writes file that can be read back to R via
read_alpha_txt
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
