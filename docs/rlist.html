<!DOCTYPE html><html><head><title>Help for package rlist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rlist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rlist-package'><p>The rlist package</p></a></li>
<li><a href='#.evalwith'><p>Convert an object to evaluating environment for list elements Users should not</p>
directly use this function</a></li>
<li><a href='#args_env'><p>create an environment for args</p></a></li>
<li><a href='#args_list'><p>create a list for args</p></a></li>
<li><a href='#callwith'><p>Evaluate a function with a modified default values</p></a></li>
<li><a href='#contains'><p>Test if a vector contains certain values</p></a></li>
<li><a href='#dots'><p>Substitute ...</p></a></li>
<li><a href='#getnames'><p>Get the names of an object</p></a></li>
<li><a href='#is.empty'><p>Check if an object is empty (has length 0)</p></a></li>
<li><a href='#List'><p>Create a <code>List environment</code> that wraps given <code>data</code> and</p>
most list functions are defined for chainable operations.</a></li>
<li><a href='#list.all'><p>Examine if a condition is true for all elements of a list</p></a></li>
<li><a href='#list.any'><p>Examine if a condition is true for at least one list element</p></a></li>
<li><a href='#list.append'><p>Append elements to a list</p></a></li>
<li><a href='#list.apply'><p>Apply a function to each list element (<code>lapply</code>)</p></a></li>
<li><a href='#list.cases'><p>Get all unique cases of a list field by expression</p></a></li>
<li><a href='#list.cbind'><p>Bind all list elements by column</p></a></li>
<li><a href='#list.class'><p>Classify list elments into unique but non-exclusive cases</p></a></li>
<li><a href='#list.clean'><p>Clean a list by a function</p></a></li>
<li><a href='#list.common'><p>Get all common cases by expression for a list</p></a></li>
<li><a href='#list.count'><p>Count the number of elements that satisfy given condition</p></a></li>
<li><a href='#list.do'><p>Call a function with a list of arguments</p></a></li>
<li><a href='#list.exclude'><p>Exclude members of a list that meet given condition.</p></a></li>
<li><a href='#list.expand'><p>Create a list from all combinations of factors</p></a></li>
<li><a href='#list.extract'><p>Extract an element from a list or vector</p></a></li>
<li><a href='#list.filter'><p>Filter a list or vector by a series of conditions</p></a></li>
<li><a href='#list.find'><p>Find a specific number of elements in a list or vector</p>
satisfying a given condition</a></li>
<li><a href='#list.findi'><p>Find the indices of a number of elements in a list or vector</p>
satisfying a given condition</a></li>
<li><a href='#list.first'><p>Find the first element that meets a condition</p></a></li>
<li><a href='#list.flatten'><p>Flatten a nested list to a one-level list</p></a></li>
<li><a href='#list.group'><p>Divide list/vector elements into exclusive groups</p></a></li>
<li><a href='#list.insert'><p>Insert a series of lists at the given index</p></a></li>
<li><a href='#list.is'><p>Return a logical vector that indicates if each member of a list</p>
satisfies a given condition</a></li>
<li><a href='#list.iter'><p>Iterate a list by evaluating an expression on</p>
each list element</a></li>
<li><a href='#list.join'><p>Join two lists by single or multiple keys</p></a></li>
<li><a href='#list.last'><p>Find the last element that meets a condition</p></a></li>
<li><a href='#list.load'><p>Load a list from file</p></a></li>
<li><a href='#list.map'><p>Map each element in a list or vector by an expression.</p></a></li>
<li><a href='#list.maps'><p>Map multiple lists with an expression</p></a></li>
<li><a href='#list.mapv'><p>Map each member of a list by an expression to a vector.</p></a></li>
<li><a href='#list.match'><p>Select members of a list that match given regex pattern</p></a></li>
<li><a href='#list.merge'><p>Merge a number of named lists in sequential order</p></a></li>
<li><a href='#list.names'><p>Get or set the names of a list by expression</p></a></li>
<li><a href='#list.order'><p>Give the order of each list element by expression</p></a></li>
<li><a href='#list.parse'><p>Convert an object to list with identical structure</p></a></li>
<li><a href='#list.prepend'><p>Prepend elements to a list</p></a></li>
<li><a href='#list.rbind'><p>Bind all list elements by row</p></a></li>
<li><a href='#list.remove'><p>Remove members from a list by index or name</p></a></li>
<li><a href='#list.reverse'><p>Reverse a list</p></a></li>
<li><a href='#list.sample'><p>Sample a list or vector</p></a></li>
<li><a href='#list.save'><p>Save a list to a file</p></a></li>
<li><a href='#list.search'><p>Search a list recusively by an expression</p></a></li>
<li><a href='#list.select'><p>Select by name or expression for each member of a list</p></a></li>
<li><a href='#list.serialize'><p>Serialize a list</p></a></li>
<li><a href='#list.skip'><p>Skip a number of elements</p></a></li>
<li><a href='#list.skipWhile'><p>Keep skipping elements while a condition holds</p></a></li>
<li><a href='#list.sort'><p>Sort a list by given expressions</p></a></li>
<li><a href='#list.stack'><p>Stack all list elements to tabular data</p></a></li>
<li><a href='#list.subset'><p>Subset a list</p></a></li>
<li><a href='#list.table'><p>Generate a table for a list by expression</p></a></li>
<li><a href='#list.take'><p>Take a number of elements</p></a></li>
<li><a href='#list.takeWhile'><p>Keep taking elements while a condition holds</p></a></li>
<li><a href='#list.ungroup'><p>Ungroup a list by taking out second-level elements</p></a></li>
<li><a href='#list.unserialize'><p>Unserialize a file</p></a></li>
<li><a href='#list.unzip'><p>Transform a list of elements with similar structure into a list of decoupled fields</p></a></li>
<li><a href='#list.update'><p>Update a list by appending or modifying its elements.</p></a></li>
<li><a href='#list.which'><p>Give the indices of list elements satisfying</p>
a given condition</a></li>
<li><a href='#list.zip'><p>Combine multiple lists element-wisely.</p></a></li>
<li><a href='#nyweather'><p>New York hourly weather data</p></a></li>
<li><a href='#set_argnames'><p>Make names for unnamed symbol arguments</p></a></li>
<li><a href='#subset.list'><p>Subset a list by a logical condition</p></a></li>
<li><a href='#tryEval'><p>Try to evaluate an expression and return a default value if</p>
an error occurs or otherwise return its value.</a></li>
<li><a href='#tryGet'><p>Try to get the value of a symbol if exists or return a default value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Toolbox for Non-Tabular Data Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.6.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Kun Ren &lt;ken@renkun.me&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kun Ren &lt;ken@renkun.me&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of functions for data manipulation with
    list objects, including mapping, filtering, grouping, sorting,
    updating, searching, and other useful functions. Most functions
    are designed to be pipeline friendly so that data processing with
    lists can be chained.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15)</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-02</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, stringdist</td>
</tr>
<tr>
<td>Imports:</td>
<td>yaml, jsonlite, XML, data.table</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://renkun-ken.github.io/rlist/">https://renkun-ken.github.io/rlist/</a>,
<a href="https://github.com/renkun-ken/rlist">https://github.com/renkun-ken/rlist</a>,
<a href="https://renkun-ken.github.io/rlist-tutorial/">https://renkun-ken.github.io/rlist-tutorial/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/renkun-ken/rlist/issues">https://github.com/renkun-ken/rlist/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-02 23:36:14 UTC; ken</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-03 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rlist-package'>The rlist package</h2><span id='topic+rlist-package'></span>

<h3>Description</h3>

<p>rlist is a set of tools for working with list objects. Its goal
is to make it easier to work with lists by providing a wide range
of functions that operate on non-tabular data stored in them.
</p>
<p>The package provides a set of functions for data manipulation with
list objects, including mapping, filtering, grouping, sorting,
updating, searching, and other useful functions. Most functions
are designed to be pipeline friendly so that data processing with
lists can be chained.
</p>
<p>rlist Tutorial (<a href="https://renkun-ken.github.io/rlist-tutorial/">https://renkun-ken.github.io/rlist-tutorial/</a>) is a complete guide to rlist.
</p>

<hr>
<h2 id='.evalwith'>Convert an object to evaluating environment for list elements Users should not
directly use this function</h2><span id='topic+.evalwith'></span>

<h3>Description</h3>

<p>Convert an object to evaluating environment for list elements Users should not
directly use this function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.evalwith(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".evalwith_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='args_env'>create an environment for args</h2><span id='topic+args_env'></span>

<h3>Description</h3>

<p>create an environment for args
</p>


<h3>Usage</h3>

<pre><code class='language-R'>args_env(..., parent = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="args_env_+3A_...">...</code></td>
<td>
<p>objects</p>
</td></tr>
<tr><td><code id="args_env_+3A_parent">parent</code></td>
<td>
<p>parent environment</p>
</td></tr>
</table>

<hr>
<h2 id='args_list'>create a list for args</h2><span id='topic+args_list'></span>

<h3>Description</h3>

<p>create a list for args
</p>


<h3>Usage</h3>

<pre><code class='language-R'>args_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="args_list_+3A_...">...</code></td>
<td>
<p>objects</p>
</td></tr>
</table>

<hr>
<h2 id='callwith'>Evaluate a function with a modified default values</h2><span id='topic+callwith'></span>

<h3>Description</h3>

<p>Evaluate a function with a modified default values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callwith(fun, args, dots = list(), keep.null = FALSE, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callwith_+3A_fun">fun</code></td>
<td>
<p>either a function or a non-empty character string naming the function to be called</p>
</td></tr>
<tr><td><code id="callwith_+3A_args">args</code></td>
<td>
<p>a list of values to modify the default arguments of the function</p>
</td></tr>
<tr><td><code id="callwith_+3A_dots">dots</code></td>
<td>
<p>the user-specific input (usually from ...)</p>
</td></tr>
<tr><td><code id="callwith_+3A_keep.null">keep.null</code></td>
<td>
<p><code>TRUE</code> to keep <code>NULL</code> values after argument modifications</p>
</td></tr>
<tr><td><code id="callwith_+3A_envir">envir</code></td>
<td>
<p>the environment to evaluate the function call</p>
</td></tr>
</table>

<hr>
<h2 id='contains'>Test if a vector contains certain values</h2><span id='topic+contains'></span>

<h3>Description</h3>

<p>Test if a vector contains certain values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains(table, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contains_+3A_table">table</code></td>
<td>
<p>the values to be matched against</p>
</td></tr>
<tr><td><code id="contains_+3A_x">x</code></td>
<td>
<p>the values to be matched</p>
</td></tr>
</table>

<hr>
<h2 id='dots'>Substitute ...</h2><span id='topic+dots'></span>

<h3>Description</h3>

<p>Substitute ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dots_+3A_...">...</code></td>
<td>
<p>parameters to substitute</p>
</td></tr>
</table>

<hr>
<h2 id='getnames'>Get the names of an object</h2><span id='topic+getnames'></span>

<h3>Description</h3>

<p>Get the names of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getnames(x, def = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getnames_+3A_x">x</code></td>
<td>
<p>the object to extract names</p>
</td></tr>
<tr><td><code id="getnames_+3A_def">def</code></td>
<td>
<p>the value to return if the object has <code>NULL</code> names.
For vectorization purpose, set this to <code>character(1L)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in vectorization when the names of an object
is to be supplied.  <code>NULL</code> value will break the vectorization while
setting <code>def = character(1L)</code> makes the names vectorizable.
</p>

<hr>
<h2 id='is.empty'>Check if an object is empty (has length 0)</h2><span id='topic+is.empty'></span>

<h3>Description</h3>

<p>Check if an object is empty (has length 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.empty_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>NULL</code> value, zero-length vector or list have length zero,
which is called empty.
</p>

<hr>
<h2 id='List'>Create a <code>List environment</code> that wraps given <code>data</code> and
most list functions are defined for chainable operations.</h2><span id='topic+List'></span>

<h3>Description</h3>

<p>Create a <code>List environment</code> that wraps given <code>data</code> and
most list functions are defined for chainable operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>List(data = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="List_+3A_data">data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most list functions are defined in <code>List environment</code>.
In addition to these functions, <code>call(fun,...)</code> calls
external function <code>fun</code> with additional parameters specifies in
<code>...</code>.
</p>
<p>To extract the data from List <code>x</code>, call <code>x$data</code> or simply
<code>x[]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
m &lt;- List(x)
m$filter(type=='B')$
  map(score$c1) []

m$group(type)$
  map(g ~ List(g)$
      map(score)$
      call(unlist)$
      call(mean) []) []

# Subsetting, extracting, and assigning

p &lt;- List(list(a=1,b=2))
p['a']
p[['a']]
p$a &lt;- 2
p['b'] &lt;- NULL
p[['a']] &lt;- 3
</code></pre>

<hr>
<h2 id='list.all'>Examine if a condition is true for all elements of a list</h2><span id='topic+list.all'></span>

<h3>Description</h3>

<p>Examine if a condition is true for all elements of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.all(.data, cond, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.all_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.all_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression</p>
</td></tr>
<tr><td><code id="list.all_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If true <code>NA</code> values are ignored in
the evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>cond</code> is evaluated to be <code>TRUE</code>
for all elements in <code>.data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.any">list.any</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.all(x, type=='B')
list.all(x, mean(unlist(score))&gt;=6)
list.all(x, score$c2 &gt; 8 || score$c3 &gt; 5, na.rm = TRUE)
list.all(x, score$c2 &gt; 8 || score$c3 &gt; 5, na.rm = FALSE)
</code></pre>

<hr>
<h2 id='list.any'>Examine if a condition is true for at least one list element</h2><span id='topic+list.any'></span>

<h3>Description</h3>

<p>Examine if a condition is true for at least one list element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.any(.data, cond, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.any_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.any_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression</p>
</td></tr>
<tr><td><code id="list.any_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If true <code>NA</code> values are ignored in
the evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>cond</code> is evaluated to be <code>TRUE</code>
for any element in <code>.data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.all">list.all</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.any(x,type=='B')
list.any(x,mean(unlist(score))&gt;=6)
list.any(x, score$c2 &gt; 8 || score$c3 &gt; 5, na.rm = TRUE)
list.any(x, score$c2 &gt; 8 || score$c3 &gt; 5, na.rm = FALSE)
</code></pre>

<hr>
<h2 id='list.append'>Append elements to a list</h2><span id='topic+list.append'></span>

<h3>Description</h3>

<p>Append elements to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.append(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.append_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.append_+3A_...">...</code></td>
<td>
<p>A <code>vector</code> or <code>list</code> to append after <code>x</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.prepend">list.prepend</a></code>, <code><a href="#topic+list.insert">list.insert</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- list(a=1,b=2,c=3)
list.append(x,d=4,e=5)
list.append(x,d=4,f=c(2,3))

## End(Not run)
</code></pre>

<hr>
<h2 id='list.apply'>Apply a function to each list element (<code>lapply</code>)</h2><span id='topic+list.apply'></span>

<h3>Description</h3>

<p>Apply a function to each list element (<code>lapply</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.apply(.data, .fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.apply_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.apply_+3A_.fun">.fun</code></td>
<td>
<p><code>function</code></p>
</td></tr>
<tr><td><code id="list.apply_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>FUN</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='list.cases'>Get all unique cases of a list field by expression</h2><span id='topic+list.cases'></span>

<h3>Description</h3>

<p>Get all unique cases of a list field by expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.cases(.data, expr, simplify = TRUE, sorted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.cases_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.cases_+3A_expr">expr</code></td>
<td>
<p>A lambda expression. The function will returns all cases
of the elements if <code>expr</code> is missing.</p>
</td></tr>
<tr><td><code id="list.cases_+3A_simplify">simplify</code></td>
<td>
<p><code>logical</code>. Should atomic vectors be simplified
by <code>unlist</code>?</p>
</td></tr>
<tr><td><code id="list.cases_+3A_sorted">sorted</code></td>
<td>
<p><code>logical</code>. Should the cases be sorted in ascending order?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.cases(x,type)
list.cases(x,mean(unlist(score)))

foo &lt;- list(x = LETTERS[1:3], y = LETTERS[3:5])
list.cases(foo)
</code></pre>

<hr>
<h2 id='list.cbind'>Bind all list elements by column</h2><span id='topic+list.cbind'></span>

<h3>Description</h3>

<p>The function binds all list elements by column. Each element of the list is expected
to be an atomic vector, <code>data.frame</code>, or <code>data.table</code> of the same length.
If list elements are also lists, the binding will flatten the lists and may produce
undesired results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.cbind(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.cbind_+3A_.data">.data</code></td>
<td>
<p><code>list</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.cbind">list.cbind</a></code>, <code><a href="#topic+list.stack">list.stack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(data.frame(i=1:5,x=rnorm(5)),
   data.frame(y=rnorm(5),z=rnorm(5)))
list.cbind(x)
</code></pre>

<hr>
<h2 id='list.class'>Classify list elments into unique but non-exclusive cases</h2><span id='topic+list.class'></span>

<h3>Description</h3>

<p>In non-tabular data, a certain field may take multiple values in a
collection non-exclusively. To classify these elements into different
cases, this function detects all possible cases and for each case all
elements are examined whether to belong to that case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.class(.data, ..., sorted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.class_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.class_+3A_...">...</code></td>
<td>
<p>keys</p>
</td></tr>
<tr><td><code id="list.class_+3A_sorted">sorted</code></td>
<td>
<p><code>TRUE</code> to sort the group keys. Ignored when the key has
multiple entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of possible cases each of which contains elements belonging to
the case non-exclusively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-
  list(
    p1=list(name='Ken',age=24,
      interest=c('reading','music','movies'),
      lang=list(r=2,csharp=4,python=3)),
    p2=list(name='James',age=25,
      interest=c('sports','music'),
      lang=list(r=3,java=2,cpp=5)),
    p3=list(name='Penny',age=24,
      interest=c('movies','reading'),
      lang=list(r=1,cpp=4,python=2)))
list.class(x,interest)
list.class(x,names(lang))
</code></pre>

<hr>
<h2 id='list.clean'>Clean a list by a function</h2><span id='topic+list.clean'></span>

<h3>Description</h3>

<p>This function removes all elements evaluated to be
<code>TRUE</code> by an indicator function. The removal can be recursive
so that the resulted list surely does not include such elements in
any level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.clean(.data, fun = is.null, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.clean_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code> to operate over.</p>
</td></tr>
<tr><td><code id="list.clean_+3A_fun">fun</code></td>
<td>
<p>A <code>character</code> or a <code>function</code> that returns
<code>TRUE</code> or <code>FALSE</code> to indicate if an element of
<code>.data</code> should be removed.</p>
</td></tr>
<tr><td><code id="list.clean_+3A_recursive">recursive</code></td>
<td>
<p><code>logical</code>. Should the list be
cleaned recursively? Set to FALSE by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Raw data is usually not completely ready for analysis, and needs to
be cleaned up to certain standards. For example, some data operations
require that the input does not include <code>NULL</code> values in any
level, therefore <code>fun = "is.null"</code> and <code>recursive = TRUE</code>
can be useful to clean out all <code>NULL</code> values in a list at any
level.
</p>
<p>Sometimes, not only <code>NULL</code> values are undesired,
empty vectors or lists are also unwanted. In this case,
<code>fun = function(x) length(x) == 0L</code> can be useful to remove
all empty elements of zero length. This works because
<code>length(NULL) == 0L</code>, <code>length(list()) == 0L</code> and
<code>length(numeric()) == 0L</code> are all <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a=NULL,b=list(x=NULL,y=character()),d=1,e=2)
list.clean(x)
list.clean(x, recursive = TRUE)
list.clean(x, function(x) length(x) == 0L, TRUE)
</code></pre>

<hr>
<h2 id='list.common'>Get all common cases by expression for a list</h2><span id='topic+list.common'></span>

<h3>Description</h3>

<p>Get all common cases by expression for a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.common(.data, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.common_+3A_.data">.data</code></td>
<td>
<p><code>list</code></p>
</td></tr>
<tr><td><code id="list.common_+3A_expr">expr</code></td>
<td>
<p>An anonymous (or &quot;lambda&quot;) expression to determine common cases. If one
is not specified, <code>list.common</code> simply returns all identical sub-elements within lists.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c('a','b','c'),c('a','b'),c('b','c'))
list.common(x, .)
x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.common(x,type)
list.common(x,names(score))

foo &lt;- list(x = LETTERS[1:3], y = LETTERS[3:5])
list.common(foo)
</code></pre>

<hr>
<h2 id='list.count'>Count the number of elements that satisfy given condition</h2><span id='topic+list.count'></span>

<h3>Description</h3>

<p>Count the number of elements that satisfy given condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.count(.data, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.count_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.count_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression for each element of <code>.data</code> to evaluate. If
<code>cond</code> is missing then the total number of elements in <code>.data</code> will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer that indicates the number of elements with which <code>cond</code> is evaluated
to be <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.count(x, type=='B')
list.count(x, min(unlist(score)) &gt;= 9)
</code></pre>

<hr>
<h2 id='list.do'>Call a function with a list of arguments</h2><span id='topic+list.do'></span>

<h3>Description</h3>

<p>Call a function with a list of arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.do(.data, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.do_+3A_.data">.data</code></td>
<td>
<p><code>list</code>. <code>vector</code> will be coreced to <code>list</code> before
being passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="list.do_+3A_fun">fun</code></td>
<td>
<p>The <code>function</code> to call</p>
</td></tr>
<tr><td><code id="list.do_+3A_...">...</code></td>
<td>
<p>The additional parameters passed to <code>do.call</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- lapply(1:3, function(i) { c(a=i,b=i^2)})
df &lt;- lapply(1:3, function(i) { data.frame(a=i,b=i^2,c=letters[i])})
list.do(x, rbind)
</code></pre>

<hr>
<h2 id='list.exclude'>Exclude members of a list that meet given condition.</h2><span id='topic+list.exclude'></span>

<h3>Description</h3>

<p>Exclude members of a list that meet given condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.exclude(.data, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.exclude_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.exclude_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression to exclude items</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.exclude(x, type=='B')
list.exclude(x, min(score$c1,score$c2) &gt;= 8)
</code></pre>

<hr>
<h2 id='list.expand'>Create a list from all combinations of factors</h2><span id='topic+list.expand'></span>

<h3>Description</h3>

<p>Create a list from all combinations of the supplied
vectors or lists, extending the functionality of
<a href="base.html#topic+expand.grid">expand.grid</a> from data frame to list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.expand(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.expand_+3A_...">...</code></td>
<td>
<p>vectors or lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of all combinations of the supplied vectors or
lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.expand(x=1:10, y=c("a","b","c"))
list.expand(x=list(c(1,2), c(2,3)), y = c("a","b","c"))
list.expand(
  a=list(list(x=1,y="a"), list(x=2, y="b")),
  b=list(c("x","y"), c("y","z","w")))
</code></pre>

<hr>
<h2 id='list.extract'>Extract an element from a list or vector</h2><span id='topic+list.extract'></span>

<h3>Description</h3>

<p>Extract an element from a list or vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.extract()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a=1, b=2, c=3)
list.extract(x, 1)
list.extract(x, 'a')
</code></pre>

<hr>
<h2 id='list.filter'>Filter a list or vector by a series of conditions</h2><span id='topic+list.filter'></span>

<h3>Description</h3>

<p>The function recursively filters the data by a given series of
conditions. The filter can be a single condition or multiple
conditions. <code>.data</code> will be filtered by the first condition;
then the results will be filtered by the second condition, if any;
then the results will be filtered by the third, if any, etc. The
results only contain elements satisfying all conditions specified
in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.filter(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.filter_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.filter_+3A_...">...</code></td>
<td>
<p>logical conditions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>elements in <code>.data</code> satisfying all conditions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.filter(x, type=='B')
list.filter(x, min(score$c1, score$c2) &gt;= 8)
list.filter(x, type=='B', score$c2 &gt;= 8)
</code></pre>

<hr>
<h2 id='list.find'>Find a specific number of elements in a list or vector
satisfying a given condition</h2><span id='topic+list.find'></span>

<h3>Description</h3>

<p>Find a specific number of elements in a list or vector
satisfying a given condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.find(.data, cond, n = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.find_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.find_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression</p>
</td></tr>
<tr><td><code id="list.find_+3A_n">n</code></td>
<td>
<p>The number of items to find. (<code>n = 1L</code> by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or vector of at most <code>n</code> elements in <code>.data</code>
found to satisfy <code>cond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.find(x, type=='B', 1)
list.find(x, min(score$c1,score$c2) &gt;= 9)
</code></pre>

<hr>
<h2 id='list.findi'>Find the indices of a number of elements in a list or vector
satisfying a given condition</h2><span id='topic+list.findi'></span>

<h3>Description</h3>

<p>Find the indices of a number of elements in a list or vector
satisfying a given condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.findi(.data, cond, n = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.findi_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.findi_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression</p>
</td></tr>
<tr><td><code id="list.findi_+3A_n">n</code></td>
<td>
<p>The number of items to find. (<code>n = 1L</code> by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector consisting of the elements indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.findi(x, type=='B')
list.findi(x, min(score$c1,score$c2) &gt;= 8)
list.findi(x, min(score$c1,score$c2) &lt;= 8, n = 2)
</code></pre>

<hr>
<h2 id='list.first'>Find the first element that meets a condition</h2><span id='topic+list.first'></span>

<h3>Description</h3>

<p>Find the first element that meets a condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.first(.data, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.first_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.first_+3A_cond">cond</code></td>
<td>
<p>a logical lambda expression</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.last">list.last</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.first(x, score$c1 &lt; 10)
list.first(x, score$c1 &lt; 9 || score$c3 &gt;= 5) # NULL for all results are NA or FALSE
</code></pre>

<hr>
<h2 id='list.flatten'>Flatten a nested list to a one-level list</h2><span id='topic+list.flatten'></span>

<h3>Description</h3>

<p>Flatten a nested list to a one-level list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.flatten(x, use.names = TRUE, classes = "ANY")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.flatten_+3A_x">x</code></td>
<td>
<p><code>list</code></p>
</td></tr>
<tr><td><code id="list.flatten_+3A_use.names">use.names</code></td>
<td>
<p><code>logical</code>. Should the names of <code>x</code> be kept?</p>
</td></tr>
<tr><td><code id="list.flatten_+3A_classes">classes</code></td>
<td>
<p>A character vector of class names, or &quot;ANY&quot; to match any class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is essentially a slightly modified version of <code>flatten2</code>
provided by Tommy at <a href="https://stackoverflow.com/a/8139959/2906900">stackoverflow.com</a> who
has full credit of the implementation of this function.
</p>


<h3>Author(s)</h3>

<p><a href="https://stackoverflow.com/users/662787/tommy">Tommy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- list(a=1,b=list(b1=2,b2=3),c=list(c1=list(c11='a',c12='x'),c2=3))
list.flatten(p)

p &lt;- list(a=1,b=list(x="a",y="b",z=10))
list.flatten(p, classes = "numeric")
list.flatten(p, classes = "character")
</code></pre>

<hr>
<h2 id='list.group'>Divide list/vector elements into exclusive groups</h2><span id='topic+list.group'></span>

<h3>Description</h3>

<p>Divide list/vector elements into exclusive groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.group(.data, ..., sorted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.group_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.group_+3A_...">...</code></td>
<td>
<p>One or more expressions in the scope of each element to evaluate
as keys</p>
</td></tr>
<tr><td><code id="list.group_+3A_sorted">sorted</code></td>
<td>
<p><code>TRUE</code> to sort the group keys. Ignored when the key has
multiple entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of group elements each contain all the elements in <code>.data</code>
belonging to the group
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.ungroup">list.ungroup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.group(x, type)
list.group(x, mean(unlist(score)))
</code></pre>

<hr>
<h2 id='list.insert'>Insert a series of lists at the given index</h2><span id='topic+list.insert'></span>

<h3>Description</h3>

<p>Insert a series of lists at the given index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.insert(.data, index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.insert_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.insert_+3A_index">index</code></td>
<td>
<p>The index at which the lists are inserted</p>
</td></tr>
<tr><td><code id="list.insert_+3A_...">...</code></td>
<td>
<p>A group of lists</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.append">list.append</a></code>, <code><a href="#topic+list.prepend">list.prepend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.insert(x, 2, p2.1 = list(type='B',score=list(c1=8,c2=9)))

## End(Not run)
</code></pre>

<hr>
<h2 id='list.is'>Return a logical vector that indicates if each member of a list
satisfies a given condition</h2><span id='topic+list.is'></span><span id='topic+list.if'></span>

<h3>Description</h3>

<p>Return a logical vector that indicates if each member of a list
satisfies a given condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.is(.data, cond, use.names = TRUE)

list.if(.data, cond, use.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.is_+3A_.data">.data</code></td>
<td>
<p><code>list</code></p>
</td></tr>
<tr><td><code id="list.is_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression</p>
</td></tr>
<tr><td><code id="list.is_+3A_use.names">use.names</code></td>
<td>
<p><code>logical</code> Should the names of <code>.data</code> be kept?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.is(x,type=='B')
list.is(x,min(score$c1,score$c2) &gt;= 8)
</code></pre>

<hr>
<h2 id='list.iter'>Iterate a list by evaluating an expression on
each list element</h2><span id='topic+list.iter'></span>

<h3>Description</h3>

<p>Iterate a list by evaluating an expression on
each list element
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.iter(.data, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.iter_+3A_.data">.data</code></td>
<td>
<p><code>list</code></p>
</td></tr>
<tr><td><code id="list.iter_+3A_expr">expr</code></td>
<td>
<p>A lambda expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(.data)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.iter(x,cat(paste(type,'\n')))
list.iter(x,cat(str(.)))
</code></pre>

<hr>
<h2 id='list.join'>Join two lists by single or multiple keys</h2><span id='topic+list.join'></span>

<h3>Description</h3>

<p>Join two lists by single or multiple keys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.join(x, y, xkey, ykey, ..., keep.order = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.join_+3A_x">x</code></td>
<td>
<p>The first list</p>
</td></tr>
<tr><td><code id="list.join_+3A_y">y</code></td>
<td>
<p>The second list</p>
</td></tr>
<tr><td><code id="list.join_+3A_xkey">xkey</code></td>
<td>
<p>A lambda expression that determines the key for list <code>x</code></p>
</td></tr>
<tr><td><code id="list.join_+3A_ykey">ykey</code></td>
<td>
<p>A lambda expression that determines the key for list <code>y</code>,
same to <code>xkey</code> if missing</p>
</td></tr>
<tr><td><code id="list.join_+3A_...">...</code></td>
<td>
<p>The additional parameters passed to <code>merge.data.frame</code></p>
</td></tr>
<tr><td><code id="list.join_+3A_keep.order">keep.order</code></td>
<td>
<p>Should the order of <code>x</code> be kept?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>l1 &lt;- list(p1=list(name='Ken',age=20),
       p2=list(name='James',age=21),
       p3=list(name='Jenny',age=20))
l2 &lt;- list(p1=list(name='Jenny',age=20,type='A'),
       p2=list(name='Ken',age=20,type='B'),
       p3=list(name='James',age=22,type='A'))
list.join(l1, l2, name)
list.join(l1, l2, .[c('name','age')])
</code></pre>

<hr>
<h2 id='list.last'>Find the last element that meets a condition</h2><span id='topic+list.last'></span>

<h3>Description</h3>

<p>Find the last element that meets a condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.last(.data, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.last_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.last_+3A_cond">cond</code></td>
<td>
<p>a logical lambda expression</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.first">list.first</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.last(x, score$c1 &lt; 10)
list.last(x, score$c1 &lt; 9 || score$c3 &gt;= 5) # NULL for all results are NA or FALSE
</code></pre>

<hr>
<h2 id='list.load'>Load a list from file</h2><span id='topic+list.load'></span>

<h3>Description</h3>

<p>Load a list from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.load(
  file,
  type = tools::file_ext(file),
  ...,
  guess = c("json", "yaml", "rds", "rdata", "xml"),
  action = c("none", "merge", "ungroup"),
  progress = length(file) &gt;= 5L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.load_+3A_file">file</code></td>
<td>
<p>a <code>character</code> vector. The file as input.</p>
</td></tr>
<tr><td><code id="list.load_+3A_type">type</code></td>
<td>
<p>The type of input which, by default, is determined
by file extension. Currently supports RData, RDS, JSON, YAML.</p>
</td></tr>
<tr><td><code id="list.load_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the loader function</p>
</td></tr>
<tr><td><code id="list.load_+3A_guess">guess</code></td>
<td>
<p>a <code>character</code> vector to guess iteratively if
<code>type</code> of <code>file</code> is unrecognized, <code>NA</code> or empty
string.</p>
</td></tr>
<tr><td><code id="list.load_+3A_action">action</code></td>
<td>
<p>The post-processing action if multiple files are
supplied. This parameter will be ignored if only a single file
is supplied.
</p>
<p><code>'none'</code> (default) to leave the resulted list as
a list of elements corresponding to elements in <code>file</code>
vector.
</p>
<p><code>'merge'</code> to merge the list elements iteratively,
the later lists always modify the former ones through
<code>modifyList</code>.
</p>
<p><code>'ungroup'</code> to ungroup the list elements, especially when
each file is a page of elements with identical structure.</p>
</td></tr>
<tr><td><code id="list.load_+3A_progress">progress</code></td>
<td>
<p><code>TRUE</code> to show a text progress bar in console
while loading files. By default, if <code>file</code> contains 5 elements,
then the progress bar will automatically be triggered to indicate
loading progress.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
list.load('list.rds')
list.load('list.rdata')
list.load('list.yaml')
list.load('list.json')

## End(Not run)
</code></pre>

<hr>
<h2 id='list.map'>Map each element in a list or vector by an expression.</h2><span id='topic+list.map'></span>

<h3>Description</h3>

<p>Map each element in a list or vector by an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.map(.data, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.map_+3A_.data">.data</code></td>
<td>
<p>a <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.map_+3A_expr">expr</code></td>
<td>
<p>A lambda expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> in which each element is mapped by <code>expr</code> in <code>.data</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.mapv">list.mapv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.map(x, type)
list.map(x, min(score$c1,score$c2))
</code></pre>

<hr>
<h2 id='list.maps'>Map multiple lists with an expression</h2><span id='topic+list.maps'></span>

<h3>Description</h3>

<p>Map multiple lists with an expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.maps(expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.maps_+3A_expr">expr</code></td>
<td>
<p>An implicit lambda expression where only <code>.i</code> and
<code>.name</code> are defined.</p>
</td></tr>
<tr><td><code id="list.maps_+3A_...">...</code></td>
<td>
<p>Named arguments of lists with equal length. The names of the
lists are available as symbols that represent the element for each list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
l1 &lt;- list(p1=list(x=1,y=2), p2=list(x=3,y=4), p3=list(x=1,y=3))
l2 &lt;- list(2,3,5)
list.maps(a$x*b+a$y,a=l1,b=l2)
list.maps(..1$x*..2+..1$y,l1,l2)

## End(Not run)
</code></pre>

<hr>
<h2 id='list.mapv'>Map each member of a list by an expression to a vector.</h2><span id='topic+list.mapv'></span>

<h3>Description</h3>

<p>Map each member of a list by an expression to a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.mapv(.data, expr, as, use.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.mapv_+3A_.data">.data</code></td>
<td>
<p>a <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.mapv_+3A_expr">expr</code></td>
<td>
<p>a lambda expression</p>
</td></tr>
<tr><td><code id="list.mapv_+3A_as">as</code></td>
<td>
<p>the mode to corece. Missing to <code>unlist</code>
the mapped results.</p>
</td></tr>
<tr><td><code id="list.mapv_+3A_use.names">use.names</code></td>
<td>
<p>Should the names of the results be preserved?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> in which each element is mapped by <code>expr</code> in <code>.data</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.map">list.map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.mapv(x, type)
list.mapv(x, min(score$c1,score$c2))
</code></pre>

<hr>
<h2 id='list.match'>Select members of a list that match given regex pattern</h2><span id='topic+list.match'></span>

<h3>Description</h3>

<p>Select members of a list that match given regex pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.match(.data, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.match_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.match_+3A_pattern">pattern</code></td>
<td>
<p><code>character</code>. The regex pattern to match the name of the members</p>
</td></tr>
<tr><td><code id="list.match_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>grep</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.match(x,'p[12]')
list.match(x,'3')
</code></pre>

<hr>
<h2 id='list.merge'>Merge a number of named lists in sequential order</h2><span id='topic+list.merge'></span>

<h3>Description</h3>

<p>The function merges a number of lists in sequential order
by <code>modifyList</code>, that is, the later list always
modifies the former list and form a merged list, and the
resulted list is again being merged with the next list.
The process is repeated until all lists in <code>...</code> or
<code>list</code> are exausted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.merge(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.merge_+3A_...">...</code></td>
<td>
<p>named lists</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List merging is usually useful in the merging of program
settings or configuraion with multiple versions across time,
or multiple administrative levels. For example, a program
settings may have an initial version in which most keys are
defined and specified. In later versions, partial modifications
are recorded. In this case, list merging can be useful to merge
all versions of settings in release order of these versions. The
result is an fully updated settings with all later modifications
applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l1 &lt;- list(a=1,b=list(x=1,y=1))
l2 &lt;- list(a=2,b=list(z=2))
l3 &lt;- list(a=2,b=list(x=3))
list.merge(l1,l2,l3)
</code></pre>

<hr>
<h2 id='list.names'>Get or set the names of a list by expression</h2><span id='topic+list.names'></span>

<h3>Description</h3>

<p>Get or set the names of a list by expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.names(.data, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.names_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.names_+3A_expr">expr</code></td>
<td>
<p>the expression whose value will be set as the name
for each list element. If missing then the names of the list will be
returned. If <code>NULL</code> then the names of the list will be removed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>list.names(c(1,2,3))
list.names(c(a=1,b=2,c=3))
list.names(c(1,2,3),letters[.])
list.names(list(list(name='A',value=10),list(name='B',value=20)), name)
</code></pre>

<hr>
<h2 id='list.order'>Give the order of each list element by expression</h2><span id='topic+list.order'></span>

<h3>Description</h3>

<p>Give the order of each list element by expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.order(.data, ..., keep.names = FALSE, na.last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.order_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.order_+3A_...">...</code></td>
<td>
<p>A group of lambda expressions</p>
</td></tr>
<tr><td><code id="list.order_+3A_keep.names">keep.names</code></td>
<td>
<p>Whether to keep the names of <code>x</code> in the result</p>
</td></tr>
<tr><td><code id="list.order_+3A_na.last">na.last</code></td>
<td>
<p>The way to deal with <code>NA</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>integer</code> vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list.sort">list.sort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.order(x, type, (score$c2)) # order by type (ascending) and score$c2 (descending)
list.order(x, min(score$c1,score$c2))
list.order(x, min(score$c1,score$c2), keep.names=TRUE)
</code></pre>

<hr>
<h2 id='list.parse'>Convert an object to list with identical structure</h2><span id='topic+list.parse'></span><span id='topic+list.parse.default'></span><span id='topic+list.parse.matrix'></span><span id='topic+list.parse.data.frame'></span><span id='topic+list.parse.character'></span>

<h3>Description</h3>

<p>This function converts an object representing data to
list that represents the same data. For example, a
<code>data.frame</code> stored tabular data column-wisely,
that is, each column represents a vector of a certain
type. <code>list.parse</code> converts a <code>data.frame</code> to
a list which represents the data row-wisely so that it
can be more convinient to perform other non-tabular data
manipulation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.parse(x, ...)

## Default S3 method:
list.parse(x, ...)

## S3 method for class 'matrix'
list.parse(x, ...)

## S3 method for class 'data.frame'
list.parse(x, ...)

## S3 method for class 'character'
list.parse(x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.parse_+3A_x">x</code></td>
<td>
<p><code>An object</code></p>
</td></tr>
<tr><td><code id="list.parse_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to converter function</p>
</td></tr>
<tr><td><code id="list.parse_+3A_type">type</code></td>
<td>
<p>The type of data to parse. Currently json and yaml are supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> object representing the data in <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(a=1:3,type=c('A','C','B'))
list.parse(x)

x &lt;- matrix(rnorm(1000),ncol=5)
rownames(x) &lt;- paste0('item',1:nrow(x))
colnames(x) &lt;- c('a','b','c','d','e')
list.parse(x)

z &lt;- '
a:
  type: x
  class: A
  registered: yes
'
list.parse(z, type='yaml')
</code></pre>

<hr>
<h2 id='list.prepend'>Prepend elements to a list</h2><span id='topic+list.prepend'></span>

<h3>Description</h3>

<p>Prepend elements to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.prepend(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.prepend_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.prepend_+3A_...">...</code></td>
<td>
<p>The <code>vector</code> or <code>list</code> to prepend before <code>x</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.append">list.append</a></code>, <code><a href="#topic+list.insert">list.insert</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a=1,b=2,c=3)
list.prepend(x, d=4, e=5)
list.prepend(x, d=4, f=c(2,3))
</code></pre>

<hr>
<h2 id='list.rbind'>Bind all list elements by row</h2><span id='topic+list.rbind'></span>

<h3>Description</h3>

<p>The function binds all list elements by row. Each element of the list is expected
to be an atomic vector, <code>data.frame</code>, or <code>data.table</code>. If list elements
are also lists, the result can be a list-valued matrix. In this case,
<code>list.stack</code> may produce a better result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.rbind(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.rbind_+3A_.data">.data</code></td>
<td>
<p><code>list</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.cbind">list.cbind</a></code>, <code><a href="#topic+list.stack">list.stack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- lapply(1:3,function(i) { c(a=i,b=i^2)})
df &lt;- lapply(1:3,function(i) { data.frame(a=i,b=i^2,c=letters[i])})
list.rbind(x)
list.rbind(df)
</code></pre>

<hr>
<h2 id='list.remove'>Remove members from a list by index or name</h2><span id='topic+list.remove'></span>

<h3>Description</h3>

<p>Remove members from a list by index or name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.remove(.data, range = integer())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.remove_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.remove_+3A_range">range</code></td>
<td>
<p>A numeric vector of indices or
a character vector of names to remove from <code>.data</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.remove(x, 'p1')
list.remove(x, c(1,2))
</code></pre>

<hr>
<h2 id='list.reverse'>Reverse a list</h2><span id='topic+list.reverse'></span>

<h3>Description</h3>

<p>Reverse a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.reverse(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.reverse_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a=1,b=2,c=3)
list.reverse(x)
</code></pre>

<hr>
<h2 id='list.sample'>Sample a list or vector</h2><span id='topic+list.sample'></span>

<h3>Description</h3>

<p>Sample a list or vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.sample(.data, size, replace = FALSE, weight = 1, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.sample_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.sample_+3A_size">size</code></td>
<td>
<p><code>integer</code>. The size of the sample</p>
</td></tr>
<tr><td><code id="list.sample_+3A_replace">replace</code></td>
<td>
<p><code>logical</code>. Should sampling be with replacement?</p>
</td></tr>
<tr><td><code id="list.sample_+3A_weight">weight</code></td>
<td>
<p>A lambda expression to determine the weight of
each list member, which only takes effect if <code>prob</code>
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="list.sample_+3A_prob">prob</code></td>
<td>
<p>A <code>vector</code> of probability weights for
obtaining the elements of the list being sampled.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = 1, b = c(1,2,3), c = c(2,3,4))
list.sample(x, 2, weight = sum(.))
</code></pre>

<hr>
<h2 id='list.save'>Save a list to a file</h2><span id='topic+list.save'></span>

<h3>Description</h3>

<p>Save a list to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.save(x, file, type = tools::file_ext(file), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.save_+3A_x">x</code></td>
<td>
<p>The list to save</p>
</td></tr>
<tr><td><code id="list.save_+3A_file">file</code></td>
<td>
<p>The file for output</p>
</td></tr>
<tr><td><code id="list.save_+3A_type">type</code></td>
<td>
<p>The type of output which, by default, is determined
by file extension. Currently supports RData, RDS, JSON, YAML.</p>
</td></tr>
<tr><td><code id="list.save_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the output function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- lapply(1:5,function(i) data.frame(a=i,b=i^2))
list.save(x, 'list.rds')
list.save(x, 'list.rdata')
list.save(x, 'list.yaml')
list.save(x, 'list.json')

## End(Not run)
</code></pre>

<hr>
<h2 id='list.search'>Search a list recusively by an expression</h2><span id='topic+list.search'></span>

<h3>Description</h3>

<p>Search a list recusively by an expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.search(.data, expr, classes = "ANY", n, unlist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.search_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.search_+3A_expr">expr</code></td>
<td>
<p>a lambda expression</p>
</td></tr>
<tr><td><code id="list.search_+3A_classes">classes</code></td>
<td>
<p>a character vector of class names that restrict the search.
By default, the range is unrestricted (<code>ANY</code>).</p>
</td></tr>
<tr><td><code id="list.search_+3A_n">n</code></td>
<td>
<p>the maximal number of vectors to return</p>
</td></tr>
<tr><td><code id="list.search_+3A_unlist">unlist</code></td>
<td>
<p><code>logical</code> Should the result be unlisted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>list.search</code> evaluates an expression (<code>expr</code>) recursively
along a list (<code>.data</code>).
</p>
<p>If the expression results in a single-valued logical vector and its
value is <code>TRUE</code>, the whole vector will be collected If it results
in multi-valued or non-logical vector, the non-<code>NA</code> values
resulted from the expression will be collected.
</p>
<p>To search whole vectors that meet certain condition, specify the
expression that returns a single logical value.
</p>
<p>To search the specific values within the vectors, use subsetting in the
expression, that is, <code>.[cond]</code> or lambda expression like
<code>x -&gt; x[cond]</code> where <code>cond</code> is a logical vector used to
select the elements in the vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Exact search

x &lt;- list(p1 = list(type='A',score=c(c1=9)),
       p2 = list(type=c('A','B'),score=c(c1=8,c2=9)),
       p3 = list(type=c('B','C'),score=c(c1=9,c2=7)),
       p4 = list(type=c('B','C'),score=c(c1=8,c2=NA)))

## Search exact values
list.search(x, identical(., 'A'))
list.search(x, identical(., c('A','B')))
list.search(x, identical(., c(9,7)))
list.search(x, identical(., c(c1=9,c2=7)))

## Search all equal values
list.search(x, all(. == 9))
list.search(x, all(. == c(8,9)))
list.search(x, all(. == c(8,9), na.rm = TRUE))

## Search any equal values
list.search(x, any(. == 9))
list.search(x, any(. == c(8,9)))

# Fuzzy search

data &lt;- list(
  p1 = list(name='Ken',age=24),
  p2 = list(name='Kent',age=26),
  p3 = list(name='Sam',age=24),
  p4 = list(name='Keynes',age=30),
  p5 = list(name='Kwen',age=31)
)

list.search(data, grepl('^K\\w+n$', .), 'character')

## Not run: 
library(stringdist)
list.search(data, stringdist(., 'Ken') &lt;= 1, 'character')
list.search(data, stringdist(., 'Man') &lt;= 2, 'character')
list.search(data, stringdist(., 'Man') &gt; 2, 'character')

## End(Not run)

data &lt;- list(
  p1 = list(name=c('Ken', 'Ren'),age=24),
  p2 = list(name=c('Kent', 'Potter'),age=26),
  p3 = list(name=c('Sam', 'Lee'),age=24),
  p4 = list(name=c('Keynes', 'Bond'),age=30),
  p5 = list(name=c('Kwen', 'Hu'),age=31))

list.search(data, .[grepl('e', .)], 'character')

## Not run: 
list.search(data, all(stringdist(., 'Ken') &lt;= 1), 'character')
list.search(data, any(stringdist(., 'Ken') &gt; 1), 'character')

## End(Not run)
</code></pre>

<hr>
<h2 id='list.select'>Select by name or expression for each member of a list</h2><span id='topic+list.select'></span>

<h3>Description</h3>

<p>Select by name or expression for each member of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.select_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.select_+3A_...">...</code></td>
<td>
<p>A group of implicit labmda expressions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.select(x, type)
list.select(x, tp = type)
list.select(x, type, score)
list.select(x, type, score.range = range(unlist(score)))
</code></pre>

<hr>
<h2 id='list.serialize'>Serialize a list</h2><span id='topic+list.serialize'></span>

<h3>Description</h3>

<p>Serialize a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.serialize(x, file, type = tools::file_ext(file), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.serialize_+3A_x">x</code></td>
<td>
<p><code>list</code></p>
</td></tr>
<tr><td><code id="list.serialize_+3A_file">file</code></td>
<td>
<p>The file for output</p>
</td></tr>
<tr><td><code id="list.serialize_+3A_type">type</code></td>
<td>
<p>The type of serialization, including native serializer and
json serializer, which is by default determined by file extension</p>
</td></tr>
<tr><td><code id="list.serialize_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the serializer function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.unserialize">list.unserialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- list(a=1,b=2,c=3)
list.serialize(x,'test.dat')
list.serialize(x,'test.json')

## End(Not run)
</code></pre>

<hr>
<h2 id='list.skip'>Skip a number of elements</h2><span id='topic+list.skip'></span>

<h3>Description</h3>

<p>Skip the first <code>n</code> elements of a list or vector and
return the remaining elements if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.skip(.data, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.skip_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.skip_+3A_n">n</code></td>
<td>
<p><code>integer</code>. The number of elements to skip</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.skipWhile">list.skipWhile</a></code>, <code><a href="#topic+list.take">list.take</a></code>,
<code><a href="#topic+list.takeWhile">list.takeWhile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a=1,b=2,c=3)
list.skip(x, 1)
list.skip(x, 2)
</code></pre>

<hr>
<h2 id='list.skipWhile'>Keep skipping elements while a condition holds</h2><span id='topic+list.skipWhile'></span>

<h3>Description</h3>

<p>Keep skipping elements in a list or vector while a
condition holds for the element. As long as the condition
is violated, the element will be kept and all remaining
elements are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.skipWhile(.data, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.skipWhile_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.skipWhile_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.skip">list.skip</a></code>, <code><a href="#topic+list.take">list.take</a></code>,
<code><a href="#topic+list.takeWhile">list.takeWhile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.skipWhile(x, type=='A')
list.skipWhile(x, min(score$c1,score$c2) &gt;= 8)
</code></pre>

<hr>
<h2 id='list.sort'>Sort a list by given expressions</h2><span id='topic+list.sort'></span>

<h3>Description</h3>

<p>Sort a list by given expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.sort(.data, ..., na.last = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.sort_+3A_.data">.data</code></td>
<td>
<p>a <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.sort_+3A_...">...</code></td>
<td>
<p>A group of lambda expressions. For each expression, the data
is sorted ascending by default unless the expression is enclosed by ().</p>
</td></tr>
<tr><td><code id="list.sort_+3A_na.last">na.last</code></td>
<td>
<p>The way to deal with <code>NA</code>s.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.order">list.order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.sort(x, type, (score$c2)) # sort by score$c2 in descending order
list.sort(x, min(score$c1,score$c2))
</code></pre>

<hr>
<h2 id='list.stack'>Stack all list elements to tabular data</h2><span id='topic+list.stack'></span>

<h3>Description</h3>

<p>Stack all list elements to tabular data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.stack(.data, ..., data.table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.stack_+3A_.data">.data</code></td>
<td>
<p><code>list</code> of <code>vector</code>s, <code>list</code>s,
<code>data.frame</code>s or <code>data.table</code>s.</p>
</td></tr>
<tr><td><code id="list.stack_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>data.table::rbindlist</code>.</p>
</td></tr>
<tr><td><code id="list.stack_+3A_data.table">data.table</code></td>
<td>
<p><code>TRUE</code> to keep the result as <code>data.table</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- lapply(1:3, function(i) { list(a=i,b=i^2) })
list.stack(x)

x &lt;- lapply(1:3, function(i) { list(a=i,b=i^2,c=letters[i])})
list.stack(x)

x &lt;- lapply(1:3, function(i) { data.frame(a=i,b=i^2,c=letters[i]) })
list.stack(x)

x &lt;- lapply(1:3, function(i) { data.frame(a=c(i,i+1), b=c(i^2,i^2+1))})
list.stack(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='list.subset'>Subset a list</h2><span id='topic+list.subset'></span>

<h3>Description</h3>

<p>Subset a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.subset()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.subset(x, c('p1','p2'))
list.subset(x, grepl('^p', names(x)))
## Not run: 
list.subset(x, stringdist::stringdist(names(x), 'x1') &lt;= 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='list.table'>Generate a table for a list by expression</h2><span id='topic+list.table'></span>

<h3>Description</h3>

<p>Generate a table for a list by expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.table(.data, ..., table.args = list(useNA = "ifany"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.table_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.table_+3A_...">...</code></td>
<td>
<p>A group of lambda expressions. If missing,
<code>table</code> will be directly called upon <code>.data</code> with
<code>table.args</code>.</p>
</td></tr>
<tr><td><code id="list.table_+3A_table.args">table.args</code></td>
<td>
<p><code>list</code>. The additional parameters
passed to <code>table</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.table(x, type)
list.table(x, type, c1 = score$c1)
list.table(x, type, score$c1, table.args = list(dnn=c('type','c1')))
</code></pre>

<hr>
<h2 id='list.take'>Take a number of elements</h2><span id='topic+list.take'></span>

<h3>Description</h3>

<p>Take the first <code>n</code> elements out from a list or
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.take(.data, n, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.take_+3A_.data">.data</code></td>
<td>
<p><code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.take_+3A_n">n</code></td>
<td>
<p><code>integer</code>. The number of elements to take</p>
</td></tr>
<tr><td><code id="list.take_+3A_force">force</code></td>
<td>
<p><code>TRUE</code> to disable the length check</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.takeWhile">list.takeWhile</a></code>, <code><a href="#topic+list.skip">list.skip</a></code>,
<code><a href="#topic+list.skipWhile">list.skipWhile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a=1,b=2,c=3)
list.take(x,1)
list.take(x,10)
</code></pre>

<hr>
<h2 id='list.takeWhile'>Keep taking elements while a condition holds</h2><span id='topic+list.takeWhile'></span>

<h3>Description</h3>

<p>Keep taking elements out from a list or vector while
a condition holds for the element. If the condition is
violated for an element, the element will not be taken and
all taken elements will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.takeWhile(.data, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.takeWhile_+3A_.data">.data</code></td>
<td>
<p><code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.takeWhile_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.take">list.take</a></code>, <code><a href="#topic+list.skip">list.skip</a></code>,
<code><a href="#topic+list.skipWhile">list.skipWhile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.takeWhile(x, type=='B')
list.takeWhile(x, min(score$c1,score$c2) &gt;= 8)
</code></pre>

<hr>
<h2 id='list.ungroup'>Ungroup a list by taking out second-level elements</h2><span id='topic+list.ungroup'></span>

<h3>Description</h3>

<p>This functon reverses the grouping operation by taking out
second-level elements of a nested list and removing the labels
of the first-level elements. For example, a list may be created
from paged data, that is, its first-level elements only indicate
the page container. To unpage the list, the first-level elements
must be removed and their inner elements should be taken out to
to the first level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.ungroup(.data, level = 1L, ..., group.names = FALSE, sort.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.ungroup_+3A_.data">.data</code></td>
<td>
<p><code>list</code></p>
</td></tr>
<tr><td><code id="list.ungroup_+3A_level">level</code></td>
<td>
<p>integer to indicate to which level of list elements
should be ungroupped to the first level.</p>
</td></tr>
<tr><td><code id="list.ungroup_+3A_...">...</code></td>
<td>
<p>Preserved use of parameter passing</p>
</td></tr>
<tr><td><code id="list.ungroup_+3A_group.names">group.names</code></td>
<td>
<p><code>logical</code>. Should the group names be
preserved?</p>
</td></tr>
<tr><td><code id="list.ungroup_+3A_sort.names">sort.names</code></td>
<td>
<p><code>logical</code>. Should the members be sorted
after ungrouping?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.group">list.group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
xg &lt;- list.group(x, type)
list.ungroup(xg)

x &lt;- list(a = list(a1 = list(x=list(x1=2,x2=3),y=list(y1=1,y2=3))),
       b = list(b1 = list(x=list(x1=2,x2=6),y=list(y1=3,y2=2))))
list.ungroup(x, level = 1)
list.ungroup(x, level = 2)
list.ungroup(x, level = 2, group.names = TRUE)
</code></pre>

<hr>
<h2 id='list.unserialize'>Unserialize a file</h2><span id='topic+list.unserialize'></span>

<h3>Description</h3>

<p>Unserialize a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.unserialize(file, type = tolower(tools::file_ext(file)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.unserialize_+3A_file">file</code></td>
<td>
<p>The file as input</p>
</td></tr>
<tr><td><code id="list.unserialize_+3A_type">type</code></td>
<td>
<p>The type of serialization, including native unserializer and
json unserializer, which is by default determined by file extension</p>
</td></tr>
<tr><td><code id="list.unserialize_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the unserializer function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.serialize">list.serialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
list.unserialize('test.dat')
list.unserialize('test.json')

## End(Not run)
</code></pre>

<hr>
<h2 id='list.unzip'>Transform a list of elements with similar structure into a list of decoupled fields</h2><span id='topic+list.unzip'></span>

<h3>Description</h3>

<p>Transform a list of elements with similar structure into a list of decoupled fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.unzip(
  .data,
  .fields = c("intersect", "union"),
  ...,
  .aggregate = "simplify2array",
  .missing = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.unzip_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> of elements containing common fields</p>
</td></tr>
<tr><td><code id="list.unzip_+3A_.fields">.fields</code></td>
<td>
<p><code>'intersect'</code> to select only common fields for
all <code>.data</code>'s elements. <code>'union'</code> to select any field that
is defined in any elements in <code>.data</code>.</p>
</td></tr>
<tr><td><code id="list.unzip_+3A_...">...</code></td>
<td>
<p>The custom aggregate functions. Can be a named list of functions or
character vectors. If a function is specified as a list of functions, then the
functions will be evaluated recursively on the result of the field. Use <code>identity</code> to
avoid aggregating results. Use <code>NULL</code> to remove certain field.</p>
</td></tr>
<tr><td><code id="list.unzip_+3A_.aggregate">.aggregate</code></td>
<td>
<p>The default aggregate function, by default, <code>simplify2array</code>.
Can be a function, character vector or a list of functions. Use <code>identity</code> to avoid
aggregating results.</p>
</td></tr>
<tr><td><code id="list.unzip_+3A_.missing">.missing</code></td>
<td>
<p>When <code>.fields</code> is <code>'union'</code> and some elements do not contain
certain fields, then <code>NULL</code> will be replaced by the value of <code>.missing</code>,
by default, <code>NA</code>. This often makes the result more friendly.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.zip">list.zip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.unzip(list(p1 = list(a = 1, b = 2), p2 = list(a = 2, b = 3)))
list.unzip(list(p1 = list(a = 1, b = 2), p2 = list(a = 2, b = 3, c = 4)))
list.unzip(list(p1 = list(a = 1, b = 2), p2 = list(a = 2, b = 3, c = 4)), 'union')
list.unzip(list(p1 = list(a = 1, b = 2), p2 = list(a = 2, b = 3, c = 4)), 'union', a = 'identity')
list.unzip(list(p1 = list(a = 1, b = 2), p2 = list(a = 2, b = 3, c = 4)), 'intersect', a = NULL)

x &lt;-
 list(april = list(n_days = 30,
   holidays = list(list('2015-04-01', 'april fools'),
 list('2015-04-05', 'easter')),
   month_info = c(number = '4', season = 'spring')),
     july = list(n_days = 31,
 holidays = list(list('2014-07-04', 'july 4th')),
   month_info = c(number = '7', season = 'summer')))
list.unzip(x, holidays = c('list.ungroup', 'unname', 'list.stack',
  function(df) setNames(df, c("date", "name"))))
</code></pre>

<hr>
<h2 id='list.update'>Update a list by appending or modifying its elements.</h2><span id='topic+list.update'></span>

<h3>Description</h3>

<p>The function updates each element of a list by evaluating
a group of expressions in the scope of the element. If the
name of an expression alreadys exists in an list element,
then the field with the name will be updated. Otherwise,
the value with the name will be appended to the list
element. The functionality is essentially done by
<code>modifyList</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.update(.data, ..., keep.null = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.update_+3A_.data">.data</code></td>
<td>
<p><code>list</code></p>
</td></tr>
<tr><td><code id="list.update_+3A_...">...</code></td>
<td>
<p>A group of labmda expressions</p>
</td></tr>
<tr><td><code id="list.update_+3A_keep.null">keep.null</code></td>
<td>
<p>Should <code>NULL</code> values be preserved
for <code>modifyList</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.update(x, high=max(score$c1,score$c2), low=min(score$c1,score$c2))
list.update(x, exams=length(score))
list.update(x, grade=ifelse(type=='A', score$c1, score$c2))
list.update(x, score=list(min=0, max=10))
</code></pre>

<hr>
<h2 id='list.which'>Give the indices of list elements satisfying
a given condition</h2><span id='topic+list.which'></span>

<h3>Description</h3>

<p>Give the indices of list elements satisfying
a given condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.which(.data, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.which_+3A_.data">.data</code></td>
<td>
<p>A <code>list</code> or <code>vector</code></p>
</td></tr>
<tr><td><code id="list.which_+3A_cond">cond</code></td>
<td>
<p>A logical lambda expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>integer</code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
list.which(x, type == 'B')
list.which(x, min(score$c1,score$c2) &gt;= 8)
</code></pre>

<hr>
<h2 id='list.zip'>Combine multiple lists element-wisely.</h2><span id='topic+list.zip'></span>

<h3>Description</h3>

<p>Combine multiple lists element-wisely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.zip(..., use.argnames = TRUE, use.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.zip_+3A_...">...</code></td>
<td>
<p><code>list</code>s</p>
</td></tr>
<tr><td><code id="list.zip_+3A_use.argnames">use.argnames</code></td>
<td>
<p><code>logical</code>. Should the names of the
arguments be used as the names of list items?</p>
</td></tr>
<tr><td><code id="list.zip_+3A_use.names">use.names</code></td>
<td>
<p><code>logical</code>. Should the names of the first
argument be used as the zipped list?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list.unzip">list.unzip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1,2,3)
y &lt;- list('x','y','z')
list.zip(num=x,sym=y)
</code></pre>

<hr>
<h2 id='nyweather'>New York hourly weather data</h2><span id='topic+nyweather'></span>

<h3>Description</h3>

<p>A non-tabular data of the hourly weather conditions of the New York City
from 2013-01-01 to 2013-03-01.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nyweather
</code></pre>


<h3>Format</h3>

<p>See <a href="https://openweathermap.org/weather-data">https://openweathermap.org/weather-data</a>
</p>


<h3>Details</h3>

<p>Fetch date: 2014-11-23.
</p>
<p>Processed by rlist.
</p>
<p>To retrieve the data, please visit <a href="https://openweathermap.org/api">https://openweathermap.org/api</a> for
API usage.
</p>

<hr>
<h2 id='set_argnames'>Make names for unnamed symbol arguments</h2><span id='topic+set_argnames'></span>

<h3>Description</h3>

<p>Make names for unnamed symbol arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_argnames(args, data = args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_argnames_+3A_args">args</code></td>
<td>
<p>the unevaluated argument list</p>
</td></tr>
<tr><td><code id="set_argnames_+3A_data">data</code></td>
<td>
<p>the list to be named (<code>args</code> by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The elements of an unevaluated list of arguments may or may not
have names as given by user. For example, <code>list.select</code> requires user
to specify the fields to select. These fields are unevaluated arguments,
some of which are symbols and others are calls. For the symbols, it is natural
to make the resulted lists to have the same name for the particular arguments.
</p>

<hr>
<h2 id='subset.list'>Subset a list by a logical condition</h2><span id='topic+subset.list'></span>

<h3>Description</h3>

<p>Subset a list by a logical condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
subset(x, subset, select, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.list_+3A_x">x</code></td>
<td>
<p>The list to subset</p>
</td></tr>
<tr><td><code id="subset.list_+3A_subset">subset</code></td>
<td>
<p>A logical lambda expression of subsetting condition</p>
</td></tr>
<tr><td><code id="subset.list_+3A_select">select</code></td>
<td>
<p>A lambda expression to evaluate for each selected item</p>
</td></tr>
<tr><td><code id="subset.list_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(p1 = list(type='A',score=list(c1=10,c2=8)),
       p2 = list(type='B',score=list(c1=9,c2=9)),
       p3 = list(type='B',score=list(c1=9,c2=7)))
subset(x, type == 'B')
subset(x, select = score)
subset(x, min(score$c1, score$c2) &gt;= 8, data.frame(score))
subset(x, type == 'B', score$c1)
do.call(rbind,
   subset(x, min(score$c1, score$c2) &gt;= 8, data.frame(score)))
</code></pre>

<hr>
<h2 id='tryEval'>Try to evaluate an expression and return a default value if
an error occurs or otherwise return its value.</h2><span id='topic+tryEval'></span>

<h3>Description</h3>

<p>Try to evaluate an expression and return a default value if
an error occurs or otherwise return its value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryEval(expr, def = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tryEval_+3A_expr">expr</code></td>
<td>
<p>the expression to evaluate</p>
</td></tr>
<tr><td><code id="tryEval_+3A_def">def</code></td>
<td>
<p>the default value if an error occurs in the evaluation
of <code>expr</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a=c(x=1,y=2),b=c(x=2,p=3))
list.map(x, tryEval(x+y, NA))
</code></pre>

<hr>
<h2 id='tryGet'>Try to get the value of a symbol if exists or return a default value</h2><span id='topic+tryGet'></span>

<h3>Description</h3>

<p>Try to get the value of a symbol if exists or return a default value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryGet(symbol, def = NULL, ..., envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tryGet_+3A_symbol">symbol</code></td>
<td>
<p>the symbol to examine</p>
</td></tr>
<tr><td><code id="tryGet_+3A_def">def</code></td>
<td>
<p>the default value if the symbol does not exist</p>
</td></tr>
<tr><td><code id="tryGet_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>exists</code> and <code>get</code></p>
</td></tr>
<tr><td><code id="tryGet_+3A_envir">envir</code></td>
<td>
<p>the environment to examine whether the symbol exists
and get the symbol</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the symbol is examined in <code>envir</code> without inheritance,
that is, if the symbol does not exist in <code>envir</code> the default value
<code>def</code> will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a=c(x=1,y=2),b=c(x=2,p=3))
list.map(x, tryGet(y,0))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
