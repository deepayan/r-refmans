<!DOCTYPE html><html><head><title>Help for package CVR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CVR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alcohol'><p>Data sets for the alcohol dependence example</p></a></li>
<li><a href='#CVR'><p>Fit canonical variate regression with tuning parameters selected by cross validation.</p></a></li>
<li><a href='#CVR-package'>
<p>Canonical Variate Regression</p></a></li>
<li><a href='#cvrsolver'><p>Canonical Variate Regression.</p></a></li>
<li><a href='#mouse'><p>Data sets for the mouse body weight example</p></a></li>
<li><a href='#plot.CVR'><p>Plot a CVR object.</p></a></li>
<li><a href='#SimulateCVR'><p>Generate simulation data.</p></a></li>
<li><a href='#SparseCCA'><p>Sparse canonical correlation analysis.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Canonical Variate Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-03-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Chongliang Luo, Kun Chen.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chongliang Luo &lt;chongliang.luo@uconn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform canonical variate regression (CVR) for two sets of covariates and a univariate
            response, with regularization and weight parameters tuned by cross validation.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.1), PMA</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-03-22 03:15:52 UTC; chongliang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-03-22 14:13:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='alcohol'>Data sets for the alcohol dependence example</h2><span id='topic+alcohol'></span>

<h3>Description</h3>

<p>A list of 3 data frames that contains the gene expression, 
DNA methylation and AUD (alcohol use disorder) of 46 human subjects. 
The data is already screened for quality control. 
For the raw data see the link below. For more details see the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alcohol
</code></pre>


<h3>Format</h3>

<p>A list of 3 data frames:
</p>

<dl>
<dt>gene</dt><dd><p>Human  gene expression. A data frame of 46 rows and 300 columns.</p>
</dd>
<dt>meth</dt><dd><p>Human DNA methylation. A data frame of 46 rows and 500 columns.</p>
</dd>
<dt>disorder</dt><dd><p>Human AUD indicator. A data frame of 46 rows and 1 column.
The first 23 subjects are AUDs and the others are matched controls.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Alcohol dependence: <a href="http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE49393">http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE49393</a>.
</p>


<h3>References</h3>

<p>Chongliang Luo, Jin Liu, Dipak D. Dey and Kun Chen (2016) Canonical variate regression. 
Biostatistics, doi: 10.1093/biostatistics/kxw001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############## Alcohol dependence example ######################
data(alcohol)
gene &lt;- scale(as.matrix(alcohol$gene))
meth &lt;- scale(as.matrix(alcohol$meth))
disorder &lt;- as.matrix(alcohol$disorder)
alcohol.X &lt;- list(X1 = gene, X2 = meth)
## Not run: 
  foldid &lt;- c(rep(1:5, 4), c(3,4,5), rep(1:5, 4), c(1,2,5))
  ##  table(foldid, disorder)
  ## there maybe warnings due to the glm refitting with small sample size
  alcohol.cvr &lt;- CVR(disorder, alcohol.X, rankseq = 2, etaseq = 0.02, 
                     family = "b", penalty = "L1", foldid = foldid )
  plot(alcohol.cvr)
  plot(gene %*% alcohol.cvr$solution$W[[1]][, 1], meth %*% alcohol.cvr$solution$W[[2]][, 1])
  cor(gene %*% alcohol.cvr$solution$W[[1]], meth %*% alcohol.cvr$solution$W[[2]])

## End(Not run)

</code></pre>

<hr>
<h2 id='CVR'>Fit canonical variate regression with tuning parameters selected by cross validation.</h2><span id='topic+CVR'></span>

<h3>Description</h3>

<p>This function fits the solution path of canonical variate regression, 
with tuning parameters selected by  cross validation. The tuning parameters 
include the rank, the  <code class="reqn">\eta</code> and the <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVR(Y, Xlist, rankseq = 2, neta = 10, etaseq = NULL, nlam = 50, 
     Lamseq = NULL, family = c("gaussian", "binomial", "poisson"),  
     Wini = NULL, penalty = c("GL1", "L1"), nfold = 10, foldid = NULL,  
     opts = list(), type.measure = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CVR_+3A_y">Y</code></td>
<td>
<p>A univariate response variable.</p>
</td></tr>
<tr><td><code id="CVR_+3A_xlist">Xlist</code></td>
<td>
<p>A list of two covariate matrices as in <code>cvrsolver</code>.</p>
</td></tr>
<tr><td><code id="CVR_+3A_rankseq">rankseq</code></td>
<td>
<p>A sequence of candidate ranks. The default is a single value 2.</p>
</td></tr>
<tr><td><code id="CVR_+3A_neta">neta</code></td>
<td>
<p>Number of <code class="reqn">\eta</code> values. The default is 10.</p>
</td></tr>
<tr><td><code id="CVR_+3A_etaseq">etaseq</code></td>
<td>
<p>A sequence of  length <code>neta</code> containing candidate <code class="reqn">\eta</code> values between 0 and 1. 
The default is 10^seq(-2, log10(0.9), length = neta).</p>
</td></tr>
<tr><td><code id="CVR_+3A_nlam">nlam</code></td>
<td>
<p>Number of  <code class="reqn">\lambda</code> values. The default is 50.</p>
</td></tr>
<tr><td><code id="CVR_+3A_lamseq">Lamseq</code></td>
<td>
<p>A matrix of   <code class="reqn">\lambda</code>  values. The column number is the number of sets in <code>Xlist</code>,
and the row number is <code>nlam</code>. The default is 10^(seq(-2, 2, length = nlam)) for each column.</p>
</td></tr>
<tr><td><code id="CVR_+3A_family">family</code></td>
<td>
<p>Type of response as in <code>cvrsolver</code>. The default is <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="CVR_+3A_wini">Wini</code></td>
<td>
<p>A list of initial loading W's. The default is from the SparseCCA solution. See <code>SparseCCA</code>.</p>
</td></tr>
<tr><td><code id="CVR_+3A_penalty">penalty</code></td>
<td>
<p>Type of penalty on loading matrices W's as in <code>cvrsolver</code>. The default is <code>"GL1"</code>.</p>
</td></tr>
<tr><td><code id="CVR_+3A_nfold">nfold</code></td>
<td>
<p>Number of folds in cross validation. The default is 10.</p>
</td></tr>
<tr><td><code id="CVR_+3A_foldid">foldid</code></td>
<td>
<p>Specifying training and testing sets in cross validation; random generated if not supplied. 
It remains the same across different rank and <code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code id="CVR_+3A_opts">opts</code></td>
<td>
<p>A list of options for controlling the algorithm. The default of <code>opts$spthresh</code> is 0.4, which means 
we only search sparse models with at most 40% nonzero entries in W1 and W2. See the other options 
(<code>standardization</code>, <code>maxIters</code> and <code>tol</code>) in <code>cvrsolver</code>.</p>
</td></tr>
<tr><td><code id="CVR_+3A_type.measure">type.measure</code></td>
<td>
<p>Type of measurement used in cross validation. <code>"mse"</code> for Gaussian, <code>"auc"</code> for binomial,
and <code>"deviance"</code> for binomial and Poisson.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, the rank, <code class="reqn">\eta</code> and <code class="reqn">\lambda</code> are tuned by  cross validation. CVR then is refitted with
all  data using  the selected tuning parameters.  The <code>plot</code> function  shows the tuning of  <code class="reqn">\lambda</code>, 
with selected rank and <code class="reqn">\eta</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;CVR&quot; containing the following components
</p>
<table>
<tr><td><code>cverror</code></td>
<td>
<p>A matrix containing the CV errors. The number of rows is the length 
of <code>etaseq</code> and the number of columns is the length of <code>rankseq</code>.</p>
</td></tr>
<tr><td><code>etahat</code></td>
<td>
<p>Selected <code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code>rankhat</code></td>
<td>
<p>Selected rank.</p>
</td></tr>
<tr><td><code>Lamhat</code></td>
<td>
<p>Selected  <code class="reqn">\lambda</code>'s.</p>
</td></tr>
<tr><td><code>Alphapath</code></td>
<td>
<p>An array containing  the fitted paths of the intercept term <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code>Betapath</code></td>
<td>
<p>An array containing the fitted paths of the regression coefficient <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>W1path</code>, <code>W2path</code></td>
<td>
<p>Arrays containing the fitted paths of  W1 and W2.</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p><code>foldid</code> used in cross validation.</p>
</td></tr>
<tr><td><code>cvout</code></td>
<td>
<p>Cross validation results using selected <code class="reqn">\eta</code> and rank.</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>A list including the solutions of <code class="reqn">\alpha</code>, <code class="reqn">\beta</code>, W1 and W2, by refitting all the data 
using selected tuning parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chongliang Luo, Kun Chen.
</p>


<h3>References</h3>

<p>Chongliang Luo, Jin Liu, Dipak D. Dey and Kun Chen (2016) Canonical variate regression. 
Biostatistics, doi: 10.1093/biostatistics/kxw001.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cvrsolver">cvrsolver</a></code>, <code><a href="#topic+SparseCCA">SparseCCA</a></code>, <code><a href="#topic+SimulateCVR">SimulateCVR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############## Gaussian response ###################### 
set.seed(42)   
mydata &lt;- SimulateCVR(family = "g", n = 100, rank = 4, p1 = 50, p2 = 70,  
                  pnz = 10, beta = c(2, 1, 0, 0))
X1 &lt;- mydata$X1;
X2 &lt;- mydata$X2
Xlist &lt;- list(X1 = X1, X2 = X2); 
Y &lt;- mydata$y
## fix rank = 4, tune eta and lambda   
##out_cvr &lt;- CVR(Y, Xlist, rankseq = 4, neta = 5, nlam = 25,  
##               family = "g", nfold = 5)
## out_cvr$solution$W[[1]];  
## out_cvr$solution$W[[2]];     
### uncomment to see plots 
## plot.CVR(out_cvr)
## 
## Distance of subspaces 
##U &lt;- mydata$U
##Pj &lt;- function(U) U %*% solve(t(U) %*% U, t(U)) 
##sum((Pj(U) - (Pj(X1 %*% out_cvr$sol$W[[1]]) + Pj(X2 %*% out_cvr$sol$W[[2]]))/2)^2) 
## Precision/Recall rate
## the first 10 rows of the true W1 and W2 are set to be nonzero
##W12 &lt;- rbind(out_cvr$sol$W[[1]], out_cvr$sol$W[[1]])
##W12norm &lt;- apply(W12, 1, function(a)sqrt(sum(a^2)))
##prec &lt;- sum(W12norm[c(1:10, 51:60)] != 0)/sum(W12norm != 0); prec 
##rec &lt;- sum(W12norm[c(1:10, 51:60)] != 0)/20; rec
## sequential SparseCCA, compare the Distance of subspaces and Prec/Rec
##W12s &lt;- SparseCCA(X1, X2, 4)
## Distance larger than CVR's 
##sum((Pj(U) - (Pj(X1 %*% W12s$W1) + Pj(X2 %*% W12s$W2))/2)^2) 
##W12snorm &lt;- apply(rbind(W12s$W1, W12s$W2), 1, function(a)sqrt(sum(a^2)))
## compare Prec/Rec 
##sum(W12snorm[c(1:10, 51:60)] != 0)/sum(W12snorm != 0);  
##sum(W12snorm[c(1:10, 51:60)] != 0)/20; 

############## binary response ########################
set.seed(12) 
mydata &lt;- SimulateCVR(family = "binomial", n = 300, rank = 4, p1 = 50,  
                       p2 = 70, pnz = 10, beta = c(2, 1, 0, 0))
X1 &lt;- mydata$X1; X2 &lt;- mydata$X2
Xlist &lt;- list(X1 = X1, X2 = X2); 
Y &lt;- mydata$y
## out_cvr &lt;- CVR(Y, Xlist, 4, neta = 5, nlam=25, family = "b", nfold = 5)  
## out_cvr$sol$W[[1]];  
## out_cvr$sol$W[[2]];    
## plot.CVR(out_cvr)

############## Poisson response ######################
set.seed(34)
mydata &lt;- SimulateCVR(family = "p", n = 100, rank = 4, p1 = 50,    
                       p2 = 70, pnz = 10, beta = c(0.2, 0.1, 0, 0))
X1 &lt;- mydata$X1; X2 &lt;- mydata$X2
Xlist &lt;- list(X1 = X1, X2 = X2); 
Y &lt;- mydata$y
## etaseq &lt;- 10^seq(-3, log10(0.95), len = 10)
## out_cvr &lt;- CVR(Y, Xlist, 4, neta = 5, nlam = 25, family = "p", nfold = 5)
## out_cvr$sol$W[[1]];  
## out_cvr$sol$W[[2]];    
## plot.CVR(out_cvr)  
</code></pre>

<hr>
<h2 id='CVR-package'>
Canonical Variate Regression
</h2><span id='topic+CVR-package'></span>

<h3>Description</h3>

<p>Perform canonical variate regression (CVR) for two sets of covariates and a univariate
response, with regularization and weight parameters tuned by cross validation.  
</p>


<h3>Details</h3>

<p>Index of help topics:
</p>
<pre>
CVR                     Fit canonical variate regression with tuning
                        parameters selected by cross validation.
CVR-package             Canonical Variate Regression
SimulateCVR             Generate simulation data.
SparseCCA               Sparse canonical correlation analysis.
alcohol                 Data sets for the alcohol dependence example
cvrsolver               Canonical Variate Regression.
mouse                   Data sets for the mouse body weight example
plot.CVR                Plot a CVR object.
</pre>
<p>functions: <code>cvrsolver</code>, <code>SparseCCA</code>, <code>SimulateCVR</code>, <code>CVR</code>, <code>plot.CVR</code>.</p>


<h3>Author(s)</h3>

<p>Chongliang Luo, Kun Chen.
</p>
<p>Maintainer: Chongliang Luo &lt;chongliang.luo@uconn.edu&gt;
</p>


<h3>References</h3>

<p>Chongliang Luo, Jin Liu, Dipak D. Dey and Kun Chen (2016) Canonical variate regression. Accepted by Biostatistics, doi: 10.1093/biostatistics/kxw001.
</p>
<p>Daniela M. Witten,  Robert Tibshirani and Trevor Hastie (2009) A penalized matrix decomposition, with applications to sparse principal components and canonical correlation analysis. Biostatistics 10(3), 515-534. 
</p>


<h3>See Also</h3>

<p>PMA.
</p>

<hr>
<h2 id='cvrsolver'>Canonical Variate Regression.</h2><span id='topic+cvrsolver'></span>

<h3>Description</h3>

<p>Perform canonical variate regression with a set of fixed tuning parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvrsolver(Y, Xlist, rank, eta, Lam, family, Wini, penalty, opts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvrsolver_+3A_y">Y</code></td>
<td>
<p>A response matrix. The response can be continuous, binary or Poisson.</p>
</td></tr>
<tr><td><code id="cvrsolver_+3A_xlist">Xlist</code></td>
<td>
<p>A list of covariate matrices. Cannot contain missing values.</p>
</td></tr>
<tr><td><code id="cvrsolver_+3A_rank">rank</code></td>
<td>
<p>Number of pairs of canonical variates.</p>
</td></tr>
<tr><td><code id="cvrsolver_+3A_eta">eta</code></td>
<td>
<p>Weight parameter between 0 and 1.</p>
</td></tr>
<tr><td><code id="cvrsolver_+3A_lam">Lam</code></td>
<td>
<p>A vector of penalty parameters <code class="reqn">\lambda</code> for regularizing the loading matrices 
corresponding to the covariate matrices in <code>Xlist</code>.</p>
</td></tr>
<tr><td><code id="cvrsolver_+3A_family">family</code></td>
<td>
<p>Type of response. <code>"gaussian"</code> if Y is continuous, <code>"binomial"</code> if Y is binary, and <code>"poisson"</code> if Y is Poisson.</p>
</td></tr>
<tr><td><code id="cvrsolver_+3A_wini">Wini</code></td>
<td>
<p>A list of initial loading matrices W's. It must be provided. See <code>cvr</code> and <code>scca</code> for using sCCA solution as the default.</p>
</td></tr>
<tr><td><code id="cvrsolver_+3A_penalty">penalty</code></td>
<td>
<p>Type of penalty on W's. &quot;GL1&quot; for rowwise sparsity and 
&quot;L1&quot; for entrywise sparsity.</p>
</td></tr>
<tr><td><code id="cvrsolver_+3A_opts">opts</code></td>
<td>
<p>A list of options for controlling the algorithm. Some of the options are: 
</p>
<p><code>standardization</code>:  need to standardize the data? Default is TRUE.
</p>
<p><code>maxIters</code>:         maximum number of iterations allowed in the algorithm. The default is 300. 
</p>
<p><code>tol</code>:              convergence criterion. Stop iteration if the relative change in the objective is less than <code>tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CVR is used for extracting canonical variates and also predicting the response 
for multiple sets of covariates (Xlist = list(X1, X2)) and response (Y). 
The covariates can be, for instance, gene expression, SNPs or DNA methylation data. 
The response can be, for instance, quantitative measurement or binary phenotype.            
The criterion minimizes the objective function 
</p>
<p style="text-align: center;"><code class="reqn">(\eta/2)\sum_{k &lt; j} ||X_kW_k - X_jW_j||_F^2 + (1-\eta)\sum_{k} l_k(\alpha, \beta, Y,X_kW_k)
  + \sum_k \rho_k(\lambda_k, W_k),</code>
</p>

<p>s.t. <code class="reqn">W_k'X_k'X_kW_k = I_r,</code>    for  <code class="reqn">k = 1, 2, \ldots, K</code>. 
<code class="reqn">l_k()</code> are general loss functions with intercept <code class="reqn">\alpha</code> and coefficients <code class="reqn">\beta</code>. <code class="reqn">\eta</code> is the weight parameter and 
<code class="reqn">\lambda_k</code> are the regularization parameters. <code class="reqn">r</code> is the rank, i.e. the number of canonical pairs.          
By adjusting <code class="reqn">\eta</code>, one can change the weight of the first correlation term and the second prediction term. 
<code class="reqn">\eta=0</code> is reduced rank regression and <code class="reqn">\eta=1</code> is sparse CCA (with orthogonal constrained W's). By choosing appropriate <code class="reqn">\lambda_k</code> 
one can induce sparsity of <code class="reqn">W_k</code>'s to select useful variables for predicting Y.                       
<code class="reqn">W_k</code>'s with <code class="reqn">B_k</code>'s and (<code class="reqn">\alpha, \beta</code>) are iterated using an ADMM algorithm. See the reference for details.
</p>


<h3>Value</h3>

<p>An object containing the following components
</p>
<table>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations the algorithm takes.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>A list of fitted loading matrices.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>A list of fitted <code class="reqn">B_k</code>'s.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>A list of fitted <code class="reqn">B_kW_k</code>'s.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Fitted intercept term in the general loss term.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Fitted regression coefficients in the general loss term.</p>
</td></tr>
<tr><td><code>objvals</code></td>
<td>
<p>A sequence of the objective values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chongliang Luo, Kun Chen.
</p>


<h3>References</h3>

<p>Chongliang Luo, Jin Liu, Dipak D. Dey and Kun Chen (2016) Canonical variate regression. 
Biostatistics, doi: 10.1093/biostatistics/kxw001.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimulateCVR">SimulateCVR</a></code>, <code><a href="#topic+CVR">CVR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see  SimulateCVR for simulation examples, see CVR for parameter tuning.
</code></pre>

<hr>
<h2 id='mouse'>Data sets for the mouse body weight example</h2><span id='topic+mouse'></span>

<h3>Description</h3>

<p>A list of 3 data frames that contains the genotype, gene expression and body-mass index of 
294 mice. The data is already screened for quality control. 
For the raw data see the links below. For more details see the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mouse
</code></pre>


<h3>Format</h3>

<p>A list of 3 data frames:
</p>

<dl>
<dt>geno</dt><dd><p>Mouse genotype. A data frame of 294 rows and 163 columns.</p>
</dd>
<dt>expr</dt><dd><p>Mouse gene expression. A data frame of 294 rows and 215 columns.</p>
</dd>
<dt>bmi</dt><dd><p>Mouse body-mass index. A data frame of 294 rows and 1 column.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Mouse genotype: <a href="http://www.genetics.org/cgi/content/full/genetics.110.116087/DC1">http://www.genetics.org/cgi/content/full/genetics.110.116087/DC1</a>
Mouse gene expression: <a href="ftp://ftp.ncbi.nlm.nih.gov/pub/geo/DATA/SeriesMatrix/GSE2814/">ftp://ftp.ncbi.nlm.nih.gov/pub/geo/DATA/SeriesMatrix/GSE2814/</a>
Mouse body-mass index: <a href="http://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/MouseWeight/">http://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/MouseWeight/</a>.
</p>


<h3>References</h3>

<p>Chongliang Luo, Jin Liu, Dipak D. Dey and Kun Chen (2016) Canonical variate regression. 
Biostatistics, doi: 10.1093/biostatistics/kxw001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############## Mouse body weight example ######################
data(mouse)
expr &lt;- scale(as.matrix(mouse$expr))
geno &lt;- scale(as.matrix(mouse$geno))
bmi &lt;- as.matrix(mouse$bmi)
mouse.X &lt;- list(X1 = expr, X2 = geno)
## Not run: 
 mouse.cvr &lt;- CVR(bmi, mouse.X, rankseq = 2, etaseq = 0.04, family = "g", penalty = "L1")
 plot(mouse.cvr)
 plot(expr %*% mouse.cvr$solution$W[[1]][, 2], geno %*% mouse.cvr$solution$W[[2]][, 2])
 cor(expr %*% mouse.cvr$solution$W[[1]], geno %*% mouse.cvr$solution$W[[2]]) 
 
## End(Not run)

</code></pre>

<hr>
<h2 id='plot.CVR'>Plot a CVR object.</h2><span id='topic+plot.CVR'></span>

<h3>Description</h3>

<p>Plot the tuning of CVR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CVR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CVR_+3A_x">x</code></td>
<td>
<p>A CVR object.</p>
</td></tr>
<tr><td><code id="plot.CVR_+3A_...">...</code></td>
<td>
<p>Other graphical parameters used in plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first plot is mean cv error vs log(<code class="reqn">\lambda</code>). The type of mean cv error is
decided by <code>type.measure</code> (see parameters of <code>CVR</code>). The selected  <code class="reqn">\lambda</code>  is marked 
by a vertical line in the plot. The second plot is sparsity vs log(<code class="reqn">\lambda</code>). 
Sparsity is the proportion of non-zero elements in fitted W1 and W2. 
The threshold is marked by a horizontal line. 
Press ENTER to see the second plot, which shows the tuning of <code class="reqn">\eta</code>.
</p>

<hr>
<h2 id='SimulateCVR'>Generate simulation data.</h2><span id='topic+SimulateCVR'></span>

<h3>Description</h3>

<p>Generate two sets of covariates and an univariate response driven by several latent factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateCVR(family = c("gaussian", "binomial", "poisson"), n = 100,  
         rank = 4, p1 = 50, p2 = 70, pnz = 10, sigmax = 0.2,   
         sigmay = 0.5, beta = c(2, 1, 0, 0), standardization = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateCVR_+3A_family">family</code></td>
<td>
<p>Type of response. <code>"gaussian"</code> for continuous response, <code>"binomial"</code>
for binary response, and <code>"poisson"</code> for Poisson response. The default is <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_n">n</code></td>
<td>
<p>Number of rows. The default is 100.</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_rank">rank</code></td>
<td>
<p>Number of latent factors generating the covariates.  The default is 4.</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_p1">p1</code></td>
<td>
<p>Number of variables in X1. The default is 50.</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_p2">p2</code></td>
<td>
<p>Number of variables in X2. The default is 70.</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_pnz">pnz</code></td>
<td>
<p>Number of variables in X1 and X2 related to the signal. The default is 10.</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_sigmax">sigmax</code></td>
<td>
<p>Standard deviation of normal noise in X1 and X2. The default is 0.2.</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_sigmay">sigmay</code></td>
<td>
<p>Standard deviation of normal noise in Y. Only used when the response is Gaussian. The default is 0.5.</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_beta">beta</code></td>
<td>
<p>Numeric vector, the coefficients used to generate respose from the latent factors. The default is c(2, 1, 0, 0).</p>
</td></tr>
<tr><td><code id="SimulateCVR_+3A_standardization">standardization</code></td>
<td>
<p>Logical. If TRUE, standardize X1 and X2 before output. The default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The latent factors in U are randomly generated normal vectors, 
</p>
<p><code class="reqn">X_1 = U*V_1 + \sigma_x*E_1, X_2 = U*V_2 + \sigma_x*E_2, E_1, E_2</code> are N(0,1) noise matrices.
</p>
<p>The nonzero entries of <code class="reqn">V_1</code> and <code class="reqn">V_2</code> are generated from Uniform([-1,-0.5]U[0.5,1]).
</p>
<p>For Gaussian response, 
</p>
<p><code class="reqn">y = U*\beta + \sigma_y*e_y, e_y</code> is N(0,1) noise vector,
</p>
<p>for binary response, 
</p>
<p><code class="reqn">y \sim rbinom(n, 1, 1/(1 + \exp(-U*\beta)))</code>,
</p>
<p>and for Poisson response,
</p>
<p><code class="reqn">y \sim rpois(n, \exp(U*\beta))</code>.
</p>
<p>See the reference for more details.
</p>


<h3>Value</h3>

<table>
<tr><td><code>X1</code>, <code>X2</code></td>
<td>
<p>The two sets of covariates with dimensions  n*p1 and n*p2 respectively.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The  response vector with length   n.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>The true latent factor matrix with dimension  n*rank.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The coefficients used to generate response from <code>U</code>. The length is rank.</p>
</td></tr>
<tr><td><code>V1</code>, <code>V2</code></td>
<td>
<p>The true loading matrices for X1 and X2 with dimensions  p1*rank and p2*rank. The first <code>pnz</code> rows are nonzero.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chongliang Luo, Kun Chen.
</p>


<h3>References</h3>

<p>Chongliang Luo, Jin Liu, Dipak D. Dey and Kun Chen (2016) Canonical variate regression. 
Biostatistics, doi: 10.1093/biostatistics/kxw001.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CVR">CVR</a></code>, <code><a href="#topic+cvrsolver">cvrsolver</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> set.seed(42)
 mydata &lt;- SimulateCVR(family = "g", n = 100, rank = 4, p1 = 50, p2 = 70, 
                   pnz = 10, beta = c(2, 1, 0, 0))
 X1 &lt;- mydata$X1
 X2 &lt;- mydata$X2
 Xlist &lt;- list(X1 = X1, X2 = X2); 
 Y &lt;- mydata$y
 opts &lt;- list(standardization = FALSE, maxIters = 300, tol = 0.005)
 ## use sparse CCA solution as initial values, see SparseCCA()
 Wini &lt;- SparseCCA(X1, X2, 4, 0.7, 0.7) 
 ## perform CVR with fixed eta and lambda, see cvrsolver()
 fit &lt;- cvrsolver(Y, Xlist, rank = 4, eta = 0.5, Lam = c(1, 1), 
                 family = "gaussian", Wini, penalty = "GL1", opts)
 ## check sparsity recovery
 fit$W[[1]]; 
 fit$W[[2]];
 ## check orthogonality
 X1W1 &lt;- X1 %*% fit$W[[1]]; 
 t(X1W1) %*% X1W1
</code></pre>

<hr>
<h2 id='SparseCCA'>Sparse canonical correlation analysis.</h2><span id='topic+SparseCCA'></span>

<h3>Description</h3>

<p>Get sparse CCA solutions of X1 and X2. Use <code>CCA</code> and <code>CCA.permute</code> from PMA package. 
See PMA package for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseCCA(X1, X2, rank = 2, penaltyx1 = NULL, penaltyx2 = NULL, 
             nperms = 25, ifplot = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseCCA_+3A_x1">X1</code>, <code id="SparseCCA_+3A_x2">X2</code></td>
<td>
<p>Numeric matrices representing the two sets of covariates. They should have the same number of rows and 
cannot contain missing values.</p>
</td></tr>
<tr><td><code id="SparseCCA_+3A_rank">rank</code></td>
<td>
<p>The number of canonical variate pairs wanted. The default is 2.</p>
</td></tr>
<tr><td><code id="SparseCCA_+3A_penaltyx1">penaltyx1</code>, <code id="SparseCCA_+3A_penaltyx2">penaltyx2</code></td>
<td>
<p>Numeric vectors as the penalties to be applied to X1 and X2. The defaults are seq(0.1, 0.7, len = 20).
See PMA package for details.</p>
</td></tr>
<tr><td><code id="SparseCCA_+3A_nperms">nperms</code></td>
<td>
<p>Number of times the data should be permuted. The default is 25. Don't use too small value. See PMA package for details.</p>
</td></tr>
<tr><td><code id="SparseCCA_+3A_ifplot">ifplot</code></td>
<td>
<p>0 or 1.  The default is 0 which means don't plot the result. See PMA package for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generally used for tuning the penalties in sparse CCA if <code>penaltyx1</code> and <code>penaltyx2</code> are supplied as vectors.
The CCA solution is based on PMD algorithm and the tuning is based on permutation.
The fitted  W1 and W2 are scaled so that the diagonals of W1'X1'X1W1 and W2'X2'X2W2 are all 1's.
</p>
<p>Specifically, if a single value of mild penalty is provided for both <code>penaltyx1</code> and <code>penaltyx2</code>, the result can be used as 
initial values of W's in CVR. For instance, with <code>penaltyx1 = 0.7</code> and <code>penaltyx2 = 0.7</code>,  
the fitted W1 and W2 are only shrinked, but mostly not zero yet.
</p>


<h3>Value</h3>

<table>
<tr><td><code>W1</code></td>
<td>
<p>Loading matrix corresponding to X1. X1*W1 gives the canonical variates from X1.</p>
</td></tr>
<tr><td><code>W2</code></td>
<td>
<p>Loading matrix corresponding to X2. X2*W2 gives the canonical variates from X2.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chongliang Luo, Kun Chen.
</p>


<h3>References</h3>

<p>Daniela M. Witten,  Robert Tibshirani and Trevor Hastie (2009) A penalized matrix decomposition, with applications to 
sparse principal components and canonical correlation analysis. Biostatistics 10(3), 515-534.
</p>
<p>Chongliang Luo, Jin Liu, Dipak D. Dey and Kun Chen (2016) Canonical variate regression. 
Biostatistics, doi: 10.1093/biostatistics/kxw001.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CVR">CVR</a></code>, <code>CCA</code>, <code>CCA.permute</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
