<!DOCTYPE html><html><head><title>Help for package phenex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phenex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyzeBits'><p>Bit Analysis</p></a></li>
<li><a href='#avhrr'><p>AVHRR Daily Dataset</p></a></li>
<li><a href='#avhrrcomp'><p>Example of AVHRR Composite Data</p></a></li>
<li><a href='#bise'><p>Best index slope extraction</p></a></li>
<li><a href='#correctedValues'><p>Corrected Value Accessor</p></a></li>
<li><a href='#date2doy'><p>Date to Julian Day Converter</p></a></li>
<li><a href='#detectSeasons'><p>Season Detection</p></a></li>
<li><a href='#integrateTimeserie'><p>Integration of timeserie</p></a></li>
<li><a href='#leapYears'><p>Leap Year Check</p></a></li>
<li><a href='#modelledValues'><p>Modelled Value Accessor</p></a></li>
<li><a href='#modelNDVI'><p>Main function for NDVI correction and modelling</p></a></li>
<li><a href='#modelValues'><p>NDVI modelling</p></a></li>
<li><a href='#modis'><p>MODIS Daily Dataset</p></a></li>
<li><a href='#modiscomp'><p>MODIS Composite Dataset</p></a></li>
<li><a href='#NDVI-class'><p>Class <code>"NDVI"</code></p></a></li>
<li><a href='#phenoPhase'><p>Phenological Phase Extraction</p></a></li>
<li><a href='#rsquare'><p>Squared Pearson correlation coefficient</p></a></li>
<li><a href='#runningAvg'><p>Running Average</p></a></li>
<li><a href='#seasons'><p>Seasons Accessor</p></a></li>
<li><a href='#values'><p>Raw Value Accessor</p></a></li>
<li><a href='#yearlength'><p>Number of Days</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Auxiliary Functions for Phenological Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-05-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian Lange, Daniel Doktor</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Doktor &lt;daniel.doktor@ufz.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides some easy-to-use functions for 
	spatial analyses of (plant-) phenological data 
	sets and satellite observations of vegetation.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, foreach, DEoptim</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-05-24 11:27:45 UTC; langema</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-05-29 11:35:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyzeBits'>Bit Analysis</h2><span id='topic+analyzeBits'></span>

<h3>Description</h3>

<p>Analyses bits of a 16-bit integer</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzeBits(value, mode=1, bitpos=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyzeBits_+3A_value">value</code></td>
<td>
<p>A 16-bit integer value</p>
</td></tr>
<tr><td><code id="analyzeBits_+3A_mode">mode</code></td>
<td>
<p>If mode is 0, the algorithm returns the bit on position &lsquo;bitpos&rsquo;. If mode is 1 (default), the algorithm returns the most significant bit, 
if mode is 2 it returns the second significant bit and if mode is 3 the return value is the integer value of the last four bits</p>
</td></tr>
<tr><td><code id="analyzeBits_+3A_bitpos">bitpos</code></td>
<td>
<p>An integer value between 0 and 15 determining the position of the bit to read when mode is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine analyses 16-bit integer values to get the indicators of MEDOKADS data</p>


<h3>Value</h3>

<p>An integer value respective to parameter &lsquo;mode&rsquo;.</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>References</h3>

<p>Koslowsky, D., Billing, H. and Friedrich, K. (2005): MEDOKADS: A long-term data set for detection and monitoring for desertification risks in the mediterranean. In <em>RGLDD Conference</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>value &lt;- -32768
res &lt;- analyzeBits(value, mode=3)
res
</code></pre>

<hr>
<h2 id='avhrr'>AVHRR Daily Dataset</h2><span id='topic+avhrr'></span><span id='topic+avhrr.ndvi'></span>

<h3>Description</h3>

<p>This data set gives an example of daily NDVI data from the MEDOKADS data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avhrr</code></pre>


<h3>Format</h3>

<p>A vector containing 365 NDVI values from satellite observations.</p>


<h3>Source</h3>

<p>MEDOKADS Data Set</p>


<h3>References</h3>

<p>Koslowsky, D., Billing, H. and Friedrich, K. (2005): MEDOKADS: A long-term data set for detection and monitoring for desertification risks in the mediterranean. In <em>RGLDD Conference</em>.
</p>

<hr>
<h2 id='avhrrcomp'>Example of AVHRR Composite Data</h2><span id='topic+avhrrcomp'></span><span id='topic+avhrr.ndvi.comp'></span>

<h3>Description</h3>

<p>This data set gives an example of composite NDVI data from the MEDOKADS data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avhrrcomp</code></pre>


<h3>Format</h3>

<p>A vector containing 36 NDVI values from satellite observations..</p>


<h3>Source</h3>

<p>MEDOKADS Data Set</p>


<h3>References</h3>

<p>Koslowsky, D., Billing, H. and Friedrich, K. (2005): MEDOKADS: A long-term data set for detection and monitoring for desertification risks in the mediterranean. In RGLDD Conference.
</p>

<hr>
<h2 id='bise'>Best index slope extraction</h2><span id='topic+bise'></span>

<h3>Description</h3>

<p>Reduces noise in NDVI time-series. Second interpretation of bise algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bise(x, slidingperiod, growthFactorThreshold, cycleValues)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bise_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing raw NDVI values.</p>
</td></tr>
<tr><td><code id="bise_+3A_slidingperiod">slidingperiod</code></td>
<td>
<p>Sliding Period of the BISE-algorithm, default value is 40.</p>
</td></tr>
<tr><td><code id="bise_+3A_growthfactorthreshold">growthFactorThreshold</code></td>
<td>
<p>Maximum allowed increase per day as factor, default value is 0.1 (increase of 10 percent).</p>
</td></tr>
<tr><td><code id="bise_+3A_cyclevalues">cycleValues</code></td>
<td>
<p>A boolean value determining whether the end of the ndvi timeserie 
is combined with its beginning or not (default value is true). If false, gaps or low ndvi 
values at the beginning of timeserie influence the resulting timeserie.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Knowledge regarding the phenological cycle in temperate climates and its temporal evolution 
is used to detect and eliminate cloud contaminated observations. As the algorithm is searching 
forward within daily NDVI observations over 1 year, decreases are only accepted if no higher 
value is found within a so called sliding period. A period of 40 days proved best for our 
study area but might have to be modified when study areas in different climates are 
investigated.</p>


<h3>Value</h3>

<p>An object of class &lsquo;NDVI&rsquo; containing raw and corrected NDVI values.</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>References</h3>

<p>Viovy, N., Arino, O. and Belward, A.S. (1992). The Best Index Slope Extraction (BISE) - a method for reducing noise in NDVI time-series. <em>International Journal of Remote Sensing</em>, <b>13</b>, 1585-1590.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelNDVI">modelNDVI</a></code>, <code><a href="#topic+NDVI-class">NDVI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object
	ndvi &lt;- new("NDVI", values=avhrr.ndvi/10000, year=as.integer(1995))

	# correct values (bise)
	ndvi.bise &lt;- bise(ndvi, slidingperiod=40, growthFactorThreshold=0.1)

	#plot
	plot(ndvi.bise)
</code></pre>

<hr>
<h2 id='correctedValues'>Corrected Value Accessor</h2><span id='topic+correctedValues'></span>

<h3>Description</h3>

<p>Access to corrected values of NDVI object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctedValues(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctedValues_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing raw and corrected NDVI values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing corrected NDVI values.</p>


<h3>Author(s)</h3>

<p>Lange, Maximilian and Doktor, Daniel</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code>, <code><a href="#topic+modelNDVI">modelNDVI</a></code>, <code><a href="#topic+bise">bise</a></code>, <code><a href="#topic+runningAvg">runningAvg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object, correct and model values
	ndvi.list &lt;- modelNDVI(ndvi.values=avhrr.ndvi/10000, year.int=1995, 
			correction="bise", method="LinIP", MARGIN=2, 
			doParallel=FALSE, slidingperiod=40)
	ndvi &lt;- ndvi.list[[1]]

	#get modelled values
	biseValues &lt;- correctedValues(ndvi)
</code></pre>

<hr>
<h2 id='date2doy'>Date to Julian Day Converter</h2><span id='topic+date2doy'></span>

<h3>Description</h3>

<p>Converts a date into a Julian day</p>


<h3>Usage</h3>

<pre><code class='language-R'>date2doy(date)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date2doy_+3A_date">date</code></td>
<td>
<p>Date YYMMDD as integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Julian Day (day of year) of the date</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>Examples</h3>

<pre><code class='language-R'>	date &lt;- 891208
	doy &lt;- 0
	doy &lt;- date2doy(date)
	doy
</code></pre>

<hr>
<h2 id='detectSeasons'>Season Detection</h2><span id='topic+detectSeasons'></span>

<h3>Description</h3>

<p>Detects seasons in timeseries.</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectSeasons(x, minValRange, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectSeasons_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing raw NDVI values.</p>
</td></tr>
<tr><td><code id="detectSeasons_+3A_minvalrange">minValRange</code></td>
<td>
<p>Range in which to search for lowest bise value around detected season start.</p>
</td></tr> 
<tr><td><code id="detectSeasons_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to internal bise call.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>An object of class &lsquo;NDVI&rsquo;, containing &ldquo;seasons&rdquo;.</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code>, <code><a href="#topic+seasons">seasons</a></code>, <code><a href="#topic+bise">bise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# generate ndvi object
	ndvi &lt;- new("NDVI", values=rep(avhrr.ndvi/10000,5), year=NA)

	# extract seasons
	ndvi &lt;- detectSeasons(ndvi)
	seasons(ndvi)
</code></pre>

<hr>
<h2 id='integrateTimeserie'>Integration of timeserie</h2><span id='topic+integrateTimeserie'></span>

<h3>Description</h3>

<p>Extracts the integral of the vegetation index between start and end date.</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateTimeserie(x, start, end, n)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateTimeserie_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing modelled NDVI values.</p>
</td></tr>
<tr><td><code id="integrateTimeserie_+3A_start">start</code></td>
<td>
<p>A list containing the starting date(s) for integration as &lsquo;mean&rsquo; and its standard deviation(s) as &lsquo;sd&rsquo;. 
Use a list with multiple entries (as vector) for &lsquo;mean&rsquo; and &lsquo;sd&rsquo; if the NDVI object contains multiple seasons. </p>
</td></tr> 
<tr><td><code id="integrateTimeserie_+3A_end">end</code></td>
<td>
<p>A list containing the end date(s) for integration as &lsquo;mean&rsquo; and its standard deviation(s) as &lsquo;sd&rsquo;. 
Use a list with multiple entries (as vector) for &lsquo;mean&rsquo; and &lsquo;sd&rsquo; if the NDVI object contains multiple seasons.</p>
</td></tr> 
<tr><td><code id="integrateTimeserie_+3A_n">n</code></td>
<td>
<p>The number &lsquo;n&rsquo; of normal distributed values to create around start and end date.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the integral(s) as &lsquo;mean&rsquo; and a standard devation(s) &lsquo;sd&rsquo;.</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object, correct and model NDVI values
	ndvi &lt;- modelNDVI(ndvi.values=avhrr.ndvi/10000, year.int=1995, 
				correction="bise", method="LinIP", MARGIN=2, 
				doParallel=FALSE, slidingperiod=40)[[1]]

	# extract greenup DOY
	greenup &lt;- phenoPhase(ndvi, phase="greenup", method="local", threshold=0.55, n=1000)
	senesc &lt;- phenoPhase(ndvi, phase="senescence", method="local", threshold=0.55, n=1000)

	# extract green season integrated vegetation index
	gsivi &lt;- integrateTimeserie(ndvi, start=greenup, end=senesc, n=1000)
</code></pre>

<hr>
<h2 id='leapYears'>Leap Year Check</h2><span id='topic+leapYears'></span>

<h3>Description</h3>

<p>Checks whether the given years are leap years.</p>


<h3>Usage</h3>

<pre><code class='language-R'>leapYears(year)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leapYears_+3A_year">year</code></td>
<td>
<p>A vector of years as integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of boolean values determining whether the given years are leap years.</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>Examples</h3>

<pre><code class='language-R'>	year &lt;- c(1995, 2000, 2005, 2010)
	leaps &lt;- leapYears(year)
	leaps
</code></pre>

<hr>
<h2 id='modelledValues'>Modelled Value Accessor</h2><span id='topic+modelledValues'></span>

<h3>Description</h3>

<p>Access to modelled values of NDVI object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelledValues(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelledValues_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing raw and modelled NDVI values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing modelled NDVI values.</p>


<h3>Author(s)</h3>

<p>Lange, Maximilian and Doktor, Daniel</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code>, <code><a href="#topic+modelNDVI">modelNDVI</a></code>, <code><a href="#topic+modelValues">modelValues</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object, correct and model values
	ndvi.list &lt;- modelNDVI(ndvi.values=avhrr.ndvi/10000, year.int=1995, 
			correction="bise", method="LinIP", MARGIN=2, 
			doParallel=FALSE, slidingperiod=40)
	ndvi &lt;- ndvi.list[[1]]

	#get modelled values
	model &lt;- modelledValues(ndvi)
</code></pre>

<hr>
<h2 id='modelNDVI'>Main function for NDVI correction and modelling</h2><span id='topic+modelNDVI'></span>

<h3>Description</h3>

<p>Fits a suite of functions/models to raw NDVI or selected NDVI observations (after BISE).</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelNDVI(ndvi.values, year.int, multipleSeasons=FALSE, correction="bise", 
	method="LinIP", MARGIN=2, doParallel=FALSE, silent=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelNDVI_+3A_ndvi.values">ndvi.values</code></td>
<td>
<p>A vector or matrix containing NDVI observations with values in the interval (-1,1).</p>
</td></tr>
<tr><td><code id="modelNDVI_+3A_year.int">year.int</code></td>
<td>
<p>Observation year</p>
</td></tr>
<tr><td><code id="modelNDVI_+3A_multipleseasons">multipleSeasons</code></td>
<td>
<p>Determines wether a season detection should be performed or not. 
Setting &lsquo;multipleSeasons&rsquo; to TRUE forces following algorithms modelling NDVI and extracting 				phenological phases to be performed once per detected season.</p>
</td></tr>
<tr><td><code id="modelNDVI_+3A_correction">correction</code></td>
<td>
<p>A character string determining which method will be used for correction of NDVI values. 
Should be either:
</p>
<p>&ldquo;<b>none</b>&rdquo;: no correction will be performed.
</p>
<p>&ldquo;<b>ravg</b>&rdquo;: Smoothing with running average. Default window size is 7 
and can be modified by parameter &lsquo;window.ravg&rsquo;. See also <code><a href="#topic+runningAvg">runningAvg</a></code>.
</p>
<p>&ldquo;<b>bise</b>&rdquo;: Best index slope extraction after <em>Viovy et. al</em> (1992).
Second interpretation of bise algorithm.
Can be modified with parameter &lsquo;slidingperiod&rsquo;. Default to 40, optimised for 
the area of Central Europe. This might has to be modified 
when vegetation dynamics of other climates/habitats are analysed. 
An maximum increase threshold is defined via parameter &lsquo;growthFactorThreshold&rsquo; with 
default to 0.1 (10 percent increase per day allowed).
The timeserie is cycled via parameter &lsquo;cycleValues&rsquo;, which is a 
boolean value determining whether the end of the ndvi timeserie 
is combined with its beginning or not (default value is true). If false, gaps or low ndvi 
values at the beginning of timeserie influence the result.
</p>
</td></tr>
<tr><td><code id="modelNDVI_+3A_method">method</code></td>
<td>
<p>Determines which model will be fitted to the corrected NDVI-timeserie (if the 
corrected timeserie is not available, the raw one out of &lsquo;values&rsquo; will be used). 
</p>
<p>&ldquo;<b>LinIP</b>&rdquo;: A linear interpolation is performed. For interpolation, the end of 
timeserie is connected to the beginning (e.g. after day 365 follows day 1). 
Applied in <em>Badeck et. al</em> (2004) and <em>Doktor et. al</em> (2009).
</p>
<p>&ldquo;<b>Spline</b>&rdquo;: A spline interpolation is performed. For interpolation, the end of 
timeserie is connected to the beginning (e.g. after day 365 follows day 1).
</p>
<p>&ldquo;<b>DSig</b>&rdquo;: Fits a double sigmoidal function to NDVI values (according to Zhang et. al (2003)).
</p>
<p>&ldquo;<b>DSigC</b>&rdquo;: Fits another double sigmoidal function (own C implementation) to NDVI values.
</p>
<p>&ldquo;<b>DLogistic</b>&rdquo;: Fits a double logistic function after <em>Fischer, Alberte</em> (1994) to NDVI values.
</p>
<p>&ldquo;<b>Gauss</b>&rdquo;: Fits a symmetric or asymmetric (determined by boolean parameter &lsquo;asym&rsquo;) gaussian 
function to NDVI values (own C implementation after <em>Press, W.H.</em> (1992)).
</p>
<p>&ldquo;<b>GaussMix</b>&rdquo;: Fits a mixture of gaussian functions to NDVI values (own C implementation after <em>Press, W.H.</em> (1992)).
The number of components is determined by parameter &lsquo;components&rsquo;. If multiple components are given, 
the algorithm checks which number performs best.
</p>
<p>&ldquo;<b>Growth</b>&rdquo;: Fits a plant growth model after <em>Richter et. al</em> (1991) to NDVI values.
</p>
<p>&ldquo;<b>FFT</b>&rdquo;: Smoothes the corrected or raw NDVI values with fast fourier transformation (implemented in R). 
The smoothing intensity can be controlled with parameter &lsquo;filter.threshold&rsquo; with default to 3.
</p>
<p>&ldquo;<b>SavGol</b>&rdquo;: Smoothes the corrected or raw NDVI values with a Savitzky-Golay 
filter (own C implementation after <em>Press, W.H.</em> (1992)). 
The smoothing algorithm can be modified with parameters 
&lsquo;window.sav&rsquo; (window size of filter, default to 7),
&lsquo;degree&rsquo; (degree of fitting polynomial, default to 2) 
and &lsquo;smoothing&rsquo; (repetition quantity, default to 10).</p>
</td></tr>
<tr><td><code id="modelNDVI_+3A_margin">MARGIN</code></td>
<td>
<p>A vector giving the subscripts which the function will be applied over.  
E.g., for a matrix &lsquo;1&rsquo; indicates rows, &lsquo;2&rsquo; indicates columns, 
&lsquo;c(1, 2)&rsquo; indicates rows and columns. Where &lsquo;X&rsquo; has named dimnames, 
it can be a character vector selecting dimension names.
</p>
<p>Should be &lsquo;2&rsquo; if &lsquo;ndvi.values&rsquo; is a vector instead of a matrix/array.</p>
</td></tr>
<tr><td><code id="modelNDVI_+3A_doparallel">doParallel</code></td>
<td>
<p>This method uses 'foreach'. If a parallel backend is registered, setting &lsquo;do.parallel&rsquo; to &lsquo;TRUE&rsquo; enables parallel processing.</p>
</td></tr>
<tr><td><code id="modelNDVI_+3A_silent">silent</code></td>
<td>
<p>A boolean flag determining whether debug information is shown.</p>
</td></tr>
<tr><td><code id="modelNDVI_+3A_...">...</code></td>
<td>
<p>Other parameters passed to correction or modelling function. 
These are: &lsquo;slidingperiod&rsquo; for correction &ldquo;bise&rdquo;,
&lsquo;window.ravg&rsquo; for correction &ldquo;ravg&rdquo;,
&lsquo;asym&rsquo; for method &ldquo;Gauss&rdquo;,
&lsquo;filter.threshold&rsquo; for method &ldquo;FFT&rdquo; and
&lsquo;degree&rsquo;, &lsquo;window.sav&rsquo; and &lsquo;smoothing&rsquo; for method &ldquo;SavGol&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of type &lsquo;NDVI&rsquo; containing raw data, corrected NDVI values and modelled NDVI values.</p>


<h3>Author(s)</h3>

<p>Lange, Maximilian and Doktor, Daniel</p>


<h3>References</h3>

<p>Badeck, F.W., Bondeau, A., Boettcher, K., Doktor, D., Lucht, W., Schaber, J. and Sitch, S. (2004). Responses of spring phenology to climate change. <em>New Phytologist</em>, <b>162</b>, 295-309. 
</p>
<p>Doktor, D., Bondeau, A., Koslowski, D. and Badeck, F.W. (2009). Influence of heterogeneous landscapes on computed green-up dates based on daily AVHRR NDVI observations. <em>Remote Sensing of Environment</em>, <b>113</b>, 2618-2632
</p>
<p>Fischer, Alberte (1994). A Model for the Seasonal Variations of Vegetation Indices in Coarse Resolution Data and Its Inversion to Extract Crop Parameters. <em>Remote Sensing of Environment</em>, <b>48</b>, 220-230.
</p>
<p>Press, W.H. (1992). Numerical recipes in C: The Art of Scientific Computing, vol. 1. Cambridge University Press, Cambridge, 2nd edn.
</p>
<p>Richter, O., Spickermann, U. and Lenz, F. (1991). A new model for plant-growth. <em>Gartenbauwissenschaft</em>, <b>56</b>, 99-106.
</p>
<p>Viovy, N., Arino, O. and Belward, A.S. (1992). The Best Index Slope Extraction (BISE) - a method for reducing noise in NDVI time-series. <em>International Journal of Remote Sensing</em>, <b>13</b>, 1585-1590.
</p>
<p>Zhang, X.Y., Friedl, M.A., Schaaf, C.B., Strahler, A.H., Hodges, J.C.F., Gao, F., Reed, B.C. and Huete, A. (2003). Monitoring vegetation phenology using MODIS. <em>Remote Sensing of Environment</em>, <b>84</b>, 471-475.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bise">bise</a></code>, <code><a href="#topic+runningAvg">runningAvg</a></code>,<code><a href="#topic+detectSeasons">detectSeasons</a></code>, <code><a href="#topic+NDVI-class">NDVI</a></code>, <code><a href="#topic+phenoPhase">phenoPhase</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(avhrr)
data(modis)

# create NDVI object, correct and model values
ndvi.list1 &lt;- modelNDVI(ndvi.values=cbind(avhrr.ndvi/10000, modis.ndvi/10000), 
			year.int=1995, multipleSeasons=FALSE, correction="bise", 
			method="LinIP", MARGIN=2, doParallel=FALSE, slidingperiod=40)
ndvi.list2 &lt;- modelNDVI(ndvi.values=cbind(avhrr.ndvi/10000, modis.ndvi/10000), 
			year.int=1995, multipleSeasons=FALSE, correction="ravg", 
			method="FFT", MARGIN=2, doParallel=FALSE, filter.threshold=7)

# plot Values
for (ndvi.ob in ndvi.list1){ plot(ndvi.ob) } 
for (ndvi.ob in ndvi.list2){ plot(ndvi.ob) }
</code></pre>

<hr>
<h2 id='modelValues'>NDVI modelling</h2><span id='topic+modelValues'></span>

<h3>Description</h3>

<p>Models NDVI values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelValues(x, method, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelValues_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing raw and/or corrected NDVI values.</p>
</td></tr>
<tr><td><code id="modelValues_+3A_method">method</code></td>
<td>
<p>Determines which model will be fitted to the corrected NDVI-timeserie (if the 
corrected timeserie is not available, the raw one out of &lsquo;values&rsquo; will be used). 
</p>
<p>&ldquo;<b>LinIP</b>&rdquo;: A linear interpolation is performed. For interpolation, the end of 
timeserie is connected to the beginning (e.g. after day 365 follows day 1).
Applied in <em>Badeck et. al</em> (2004) and <em>Doktor et. al</em> (2009).
</p>
<p>&ldquo;<b>Spline</b>&rdquo;: A spline interpolation is performed. For interpolation, the end of 
timeserie is connected to the beginning (e.g. after day 365 follows day 1).
</p>
<p>&ldquo;<b>DSig</b>&rdquo;: Fits a double sigmoidal function to NDVI values (according to <em>Zhang et. al</em> (2003)).
</p>
<p>&ldquo;<b>DSigC</b>&rdquo;: Fits another double sigmoidal function (own C implementation) to NDVI values.
</p>
<p>&ldquo;<b>DLogistic</b>&rdquo;: Fits a double logistic function after <em>Fischer, Alberte</em> (1994) to NDVI values.
</p>
<p>&ldquo;<b>Gauss</b>&rdquo;: Fits a symmetric or asymmetric (determined by boolean parameter &lsquo;asym&rsquo;) gaussian 
function (own C implementation after <em>Press, W.H.</em> (1992)) to NDVI values.
</p>
<p>&ldquo;<b>Growth</b>&rdquo;: Fits a growth model after <em>Richter et. al</em> (1991) to NDVI values.
</p>
<p>&ldquo;<b>FFT</b>&rdquo;: Smoothes the corrected or raw NDVI values with fast fourier transfusion (implemented in R). 
The smoothing intensity can be controlled with parameter &lsquo;filter.threshold&rsquo; with default to 3.
</p>
<p>&ldquo;<b>SavGol</b>&rdquo;: Smoothes the corrected or raw NDVI values with a Savitzky-Golay 
filter (own C implementation after <em>Press, W.H.</em> (1992)). 
The smoothing algorithm can be modified with parameters 
&lsquo;window&rsquo; (window size of filter, default to 7),
&lsquo;degree&rsquo; (degree of fitting polynomial, default to 2) 
and &lsquo;smoothing&rsquo; (repetition quantity, default to 10).</p>
</td></tr>
<tr><td><code id="modelValues_+3A_...">...</code></td>
<td>
<p>Other parameters passed to modelling function. 
&lsquo;asym&rsquo; for method &ldquo;Gauss&rdquo;,
&lsquo;filter.threshold&rsquo; for method &ldquo;FFT&rdquo; and
&lsquo;degree&rsquo;, &lsquo;window&rsquo; and &lsquo;smoothing&rsquo; for method &ldquo;SavGol&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an object of type &lsquo;NDVI&rsquo; containing raw data and/or corrected NDVI values and modelled NDVI values.</p>


<h3>Author(s)</h3>

<p>Lange, Maximilian and Doktor, Daniel</p>


<h3>References</h3>

<p>Badeck, F.W., Bondeau, A., Boettcher, K., Doktor, D., Lucht, W., Schaber, J. and Sitch, S. (2004). Responses of spring phenology to climate change. <em>New Phytologist</em>, <b>162</b>, 295-309. 
</p>
<p>Doktor, D., Bondeau, A., Koslowski, D. and Badeck, F.W. (2009). Influence of heterogeneous landscapes on computed green-up dates based on daily AVHRR NDVI observations. <em>Remote Sensing of Environment</em>, <b>113</b>, 2618-2632
</p>
<p>Fischer, Alberte (1994). A Model for the Seasonal Variations of Vegetation Indices in Coarse Resolution Data and Its Inversion to Extract Crop Parameters. <em>Remote Sensing of Environment</em>, <b>48</b>, 220-230.
</p>
<p>Press, W.H. (1992). Numerical recipes in C: The Art of Scientific Computing, vol. 1. Cambridge University Press, Cambridge, 2nd edn.
</p>
<p>Richter, O., Spickermann, U. and Lenz, F. (1991). A new model for plant-growth. <em>Gartenbauwissenschaft</em>, <b>56</b>, 99-106.
</p>
<p>Viovy, N., Arino, O. and Belward, A.S. (1992). The Best Index Slope Extraction (BISE) - a method for reducing noise in NDVI time-series. <em>International Journal of Remote Sensing</em>, <b>13</b>, 1585-1590.
</p>
<p>Zhang, X.Y., Friedl, M.A., Schaaf, C.B., Strahler, A.H., Hodges, J.C.F., Gao, F., Reed, B.C. and Huete, A. (2003). Monitoring vegetation phenology using MODIS. <em>Remote Sensing of Environment</em>, <b>84</b>, 471-475.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code>, <code><a href="#topic+modelNDVI">modelNDVI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object
	ndvi &lt;- new("NDVI", values=avhrr.ndvi/10000, year=as.integer(1995))

	# correct values (bise)
	ndvi &lt;- bise(ndvi, slidingperiod=40)

	#model values
	ndvi &lt;- modelValues(ndvi, method="LinIP")

	# plot
	plot(ndvi)
</code></pre>

<hr>
<h2 id='modis'>MODIS Daily Dataset</h2><span id='topic+modis'></span><span id='topic+modis.ndvi'></span>

<h3>Description</h3>

<p>This data set gives an example of daily NDVI data from the MOD09 data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modis</code></pre>


<h3>Format</h3>

<p>A vector containing 365 NDVI values based on daily observations of surface reflectances obtained from satellite &lsquo;MODIS Terra&rsquo; with a spatial resolution of 250m.</p>


<h3>Source</h3>

<p>MOD09GQ Data Set</p>


<h3>References</h3>

<p>Vermote, E. and Kotchenova, S. (2008): MOD09 (Surface Reflectance) User's Guide. MODIS Land Surface Reflectance Science Computing Facility, 1st Edition.
</p>

<hr>
<h2 id='modiscomp'>MODIS Composite Dataset</h2><span id='topic+modiscomp'></span><span id='topic+modis.ndvi.comp'></span>

<h3>Description</h3>

<p>This data set gives an example of composite NDVI data from the MOD13 data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modiscomp</code></pre>


<h3>Format</h3>

<p>A vector containing 365 NDVI values based on observations of surface reflectances with 250m spatial and 16 days temporal resoltion obtained from satellite &lsquo;MODIS Terra&rsquo;.</p>


<h3>Source</h3>

<p>MOD13Q1 Data Set</p>


<h3>References</h3>

<p>Didan, K., Huete, A., Jacobson, A. and Solano1, R. (2010): MODIS Vegetation Indices (MOD13) C5 User's Guide. Terrestrial Biophysics and Remote Sensing Lab, The University of Arizona. 1st Edition.
</p>

<hr>
<h2 id='NDVI-class'>Class <code>"NDVI"</code></h2><span id='topic+NDVI-class'></span><span id='topic+bise+2CNDVI-method'></span><span id='topic+checkLength+2CNDVI-method'></span><span id='topic+correctedValues+3C-+2CNDVI-method'></span><span id='topic+correctedValues+2CNDVI-method'></span><span id='topic+isLeapYear+2CNDVI-method'></span><span id='topic+seasons+3C-+2CNDVI-method'></span><span id='topic+seasons+2CNDVI-method'></span><span id='topic+modelledValues+3C-+2CNDVI-method'></span><span id='topic+modelledValues+2CNDVI-method'></span><span id='topic+modelValues+2CNDVI-method'></span><span id='topic+phenoPhase+2CNDVI-method'></span><span id='topic+plot+2CNDVI-method'></span><span id='topic+runningAvg+3C-+2CNDVI-method'></span><span id='topic+runningAvg+2CNDVI-method'></span><span id='topic+values+3C-+2CNDVI-method'></span><span id='topic+values+2CNDVI-method'></span><span id='topic+year+3C-+2CNDVI-method'></span><span id='topic+year+2CNDVI-method'></span><span id='topic+rsquare+2CNDVI-method'></span><span id='topic+integrateTimeserie+2CNDVI-method'></span>

<h3>Description</h3>

<p>Class &lsquo;NDVI&rsquo; provides functions to smooth NDVI (Normalized Difference Vegetation Index) 
timeseries obtained from satellite observations.
</p>


<h3>Objects from the Class</h3>

<p>NDVI-Objects can be created by calls of the form <code>modelNDVI(ndvi.values, ...)</code>.
These objects contain the timeserie as given by &lsquo;ndvi.values&rsquo;, smoothed values due 
to the performed correction (see also <code><a href="#topic+modelNDVI">modelNDVI</a></code>, parameter 'correction') 
and modelled values due to the chosen method (see also <code><a href="#topic+modelNDVI">modelNDVI</a></code>, parameter &lsquo;method&rsquo;).
Furthermore, the year of the timeserie can be stored as integer value.
</p>


<h3>Slots</h3>


<dl>
<dt><code>year</code>:</dt><dd><p>The year of the timeseries as integer value or &lsquo;NA&rsquo;.</p>
</dd>
<dt><code>seasons</code>:</dt><dd><p>Season start positions of the timeseries.</p>
</dd>
<dt><code>values</code>:</dt><dd><p>A vector of NDVI-values (between minus one and one as numeric) of length 365 or 
366 (respective to length of the year).</p>
</dd>
<dt><code>correctedValues</code>:</dt><dd><p>A vector of corrected NDVI-values. Is set after use of correction methods &lsquo;bise&rsquo; or &lsquo;runningAvg&rsquo;.</p>
</dd>
<dt><code>modelledValues</code>:</dt><dd><p>A vector of corrected NDVI-values. Is set after use of method &lsquo;modelValues&rsquo;.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>bise</dt><dd><p><code>signature(x = "NDVI")</code>: Best index slope extraction after <em>Viovy et. al</em> (1992). 
Second interpretation of algorithm.
</p>
<p>This routine tries to restore the temporal NDVI profile, 
i.e. separate true observations from noise. The sliding period default of BISE-algorithm 
is 40 days, optimised for the area of Central Europe. This might has to be modified 
when vegetation dynamics of other climates/habitats are analysed.
An maximum increase threshold is defined via parameter &lsquo;growthFactorThreshold&rsquo; with 
default to 0.1 (10 percent increase per day allowed).
The timeserie is cycled via parameter &lsquo;cycleValues&rsquo;, which is a 
boolean value determining whether the end of the ndvi timeserie 
is combined with its beginning or not (default value is true). If false, gaps or low ndvi 
values at the beginning of timeserie influence the result.
</p>
<p>This method is used by function <code><a href="#topic+modelNDVI">modelNDVI</a></code> if parameter correction is set to &ldquo;bise&rdquo;.</p>
</dd>
<dt>checkLength</dt><dd><p><code>signature(x = "NDVI")</code>: Checks the length of the timeserie respective 
to the length of the year (365 days or 366 for leap years).</p>
</dd>
<dt>correctedValues&lt;-</dt><dd><p><code>signature(x = "NDVI")</code>: Replacement method for slot <code>correctedValues</code>.</p>
</dd>
<dt>correctedValues</dt><dd><p><code>signature(x = "NDVI")</code>: Acessor method for slot <code>correctedValues</code>. </p>
</dd>
<dt>isLeapYear</dt><dd><p><code>signature(x = "NDVI")</code>: Checks whether the year of the NDVI-object is a leap year.</p>
</dd>
<dt>seasons&lt;-</dt><dd><p><code>signature(x = "NDVI")</code>: Replacement method for slot <code>seasons</code>. </p>
</dd>
<dt>seasons</dt><dd><p><code>signature(x = "NDVI")</code>: Acessor method for slot <code>seasons</code>. </p>
</dd>
<dt>modelledValues&lt;-</dt><dd><p><code>signature(x = "NDVI")</code>: Replacement method for slot <code>modelledValues</code>. </p>
</dd>
<dt>modelledValues</dt><dd><p><code>signature(x = "NDVI")</code>: Acessor method for slot <code>modelledValues</code>. </p>
</dd>
<dt>modelValues</dt><dd><p><code>signature(x = "NDVI")</code>: Fits a suite of functions/models to corrected NDVI-timeserie (if the 
corrected timeserie is not available, the raw one out of &lsquo;values&rsquo; will be used). 
Parameter &lsquo;method&rsquo; determines the used model:
</p>
<p>&ldquo;<b>LinIP</b>&rdquo;: A linear interpolation is performed. For interpolation, the end of 
timeserie is connected to the beginning (e.g. after day 365 follows day 1). 
Applied in <em>Badeck et. al</em> (2004) and <em>Doktor et. al</em> (2009).
</p>
<p>&ldquo;<b>Spline</b>&rdquo;: A spline interpolation is performed. For interpolation, the end of 
timeserie is connected to the beginning (e.g. after day 365 follows day 1).
</p>
<p>&ldquo;<b>DSig</b>&rdquo;: Fits a double sigmoidal function to NDVI values (according to <em>Zhang et. al</em> (2003)).
</p>
<p>&ldquo;<b>DSigC</b>&rdquo;: Fits another double sigmoidal function (own C implementation) to NDVI values.
</p>
<p>&ldquo;<b>DLogistic</b>&rdquo;: Fits a double logistic function after <em>Fischer, Alberte</em> (1994) to NDVI values.
</p>
<p>&ldquo;<b>Gauss</b>&rdquo;: Fits a symmetric or asymmetric (determined by boolean parameter &lsquo;asym&rsquo;) gaussian 
function to NDVI values (own C implementation after <em>Press, W.H.</em> (1992)).
</p>
<p>&ldquo;<b>GaussMix</b>&rdquo;: Fits a mixture of gaussian functions to NDVI values (own C implementation after <em>Press, W.H.</em> (1992)).
The number of components is determined by parameter &lsquo;components&rsquo;. If multiple components are given, 
the algorithm checks which number performs best.
</p>
<p>&ldquo;<b>Growth</b>&rdquo;: Fits a growth model after <em>Richter et. al</em> (1991) to NDVI values.
</p>
<p>&ldquo;<b>FFT</b>&rdquo;: Smoothes the corrected or raw NDVI values with fast fourier transfusion (implemented in R). 
The smoothing intensity can be controlled with parameter &lsquo;filter.threshold&rsquo; with default to 3.
</p>
<p>&ldquo;<b>SavGol</b>&rdquo;: Smoothes the corrected or raw NDVI values with a Savitzky-Golay 
filter (own C implementation after <em>Press, W.H.</em> (1992)). 
The smoothing algorithm can be modified with parameters 
&lsquo;window.sav&rsquo; (window size of filter, default to 7),
&lsquo;degree&rsquo; (degree of fitting polynomial, default to 2) 
and &lsquo;smoothing&rsquo; (repetition quantity, default to 10).
</p>
<p>This method is used by function <code><a href="#topic+modelNDVI">modelNDVI</a></code> with modelling method respective to parameter &lsquo;method&rsquo;.</p>
</dd>
<dt>phenoPhase</dt><dd><p><code>signature(x = "NDVI")</code>: Extracts the start of phenological phases out of the modelled NDVI values. 
Parameter &lsquo;phase&rsquo; determines which phase is extracted:
</p>
<p>&ldquo;<b>max</b>&rdquo;: Day of the year with highest NDVI value is returned.
</p>
<p>&ldquo;<b>min</b>&rdquo;: Day of the year with lowest NDVI value is returned. 
</p>
<p>&ldquo;<b>greenup</b>&rdquo;: Day of the year at which greenup takes place is returned. 
This day refers to the point where the function of modelled NDVI 
values exceeds a certain threshold.
</p>
<p>&ldquo;<b>senescence</b>&rdquo;: Day of the year at which senescence takes place is returned. 
This day refers to the point where the function of modelled NDVI 
values exceeds a certain threshold.
</p>
<p>Parameter &lsquo;method&rsquo; determines whether a global or local threshold is used for
greenup and senescence extraction:
</p>
<p>With &ldquo;<b>global</b>&rdquo; threshold, the day of the year is returned, 
where NDVI values are first equal or higher as the value of &lsquo;threshold&rsquo;. 
If the threshold is higher than the values of the timeseries, &lsquo;-1&rsquo; will be returned.
</p>
<p>With &ldquo;<b>local</b>&rdquo; threshold, the day of the year is returned, for which NDVI values first reach the value of
&lsquo;threshold&rsquo; (interpreted as percentage) between lowest and highest NDVI value of timeserie. 
The lowest NDVI value is chosen depending on phase selected. For &ldquo;greenup&rdquo;, 
the lowest value before day of maximum NDVI value is used. For &ldquo;senescence&rdquo;, 
the lowest value after day of maximum NDVI value is used.
</p>
<p>The &lsquo;threshold&rsquo; for local or global greenup/senescence-extraction method
should have numerical value between &lsquo;0&rsquo; and &lsquo;1&rsquo;. Global thresholds 
refer to a fix NDVI value independent of actual NDVI magnitudes. 
Local thresholds are based on (max - min) * e.g. 0.55. Hence, the respective 
NDVI value will vary dependent on e.g. land-cover.
</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "NDVI")</code>: Plots raw data as black dots (slot 'values'), 
corrected values as red dots (slot &lsquo;correctedValues&rsquo;) and 
modelled values as blue line (slot &lsquo;modelledValues&rsquo;).</p>
</dd>
<dt>runningAvg</dt><dd><p><code>signature(x = "NDVI")</code>: This routine performes an averaging with a 
running window on NDVI values. Default window size is 7 and can be modified by parameter &lsquo;window&rsquo;.
</p>
<p>This method is used by function <code><a href="#topic+modelNDVI">modelNDVI</a></code> if parameter correction is set to &ldquo;ravg&rdquo;.
See also <code><a href="#topic+runningAvg">runningAvg</a></code>.</p>
</dd>
<dt>values&lt;-</dt><dd><p><code>signature(x = "NDVI")</code>: Replacement method for slot <code>values</code>. </p>
</dd>
<dt>values</dt><dd><p><code>signature(x = "NDVI")</code>: Acessor method for slot <code>values</code>. </p>
</dd>
<dt>year&lt;-</dt><dd><p><code>signature(x = "NDVI")</code>: Replacement method for slot <code>year</code>. </p>
</dd>
<dt>year</dt><dd><p><code>signature(x = "NDVI")</code>: Acessor method for slot <code>year</code>. </p>
</dd>
<dt>rsquare</dt><dd><p><code>signature(x = "NDVI")</code>: Calculates the squared Pearson correlation coefficient out of 
corrected (if the corrected timeserie is not available, the raw one out of 
&lsquo;values&rsquo; will be used) and modelled timeserie. </p>
</dd>
<dt>integrateTimeserie</dt><dd><p><code>signature(x = "NDVI")</code>: Calculates the integral of the timeserie between the bounds &lsquo;start&rsquo; and &lsquo;end&rsquo;.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Lange, Maximilian and Doktor, Daniel</p>


<h3>References</h3>

<p>Badeck, F.W., Bondeau, A., Boettcher, K., Doktor, D., Lucht, W., Schaber, J. and Sitch, S. (2004). Responses of spring phenology to climate change. <em>New Phytologist</em>, <b>162</b>, 295-309. 
</p>
<p>Doktor, D., Bondeau, A., Koslowski, D. and Badeck, F.W. (2009). Influence of heterogeneous landscapes on computed green-up dates based on daily AVHRR NDVI observations. <em>Remote Sensing of Environment</em>, <b>113</b>, 2618-2632
</p>
<p>Fischer, Alberte (1994). A Model for the Seasonal Variations of Vegetation Indices in Coarse Resolution Data and Its Inversion to Extract Crop Parameters. <em>Remote Sensing of Environment</em>, <b>48</b>, 220-230.
</p>
<p>Press, W.H. (1992). Numerical recipes in C: The Art of Scientific Computing, vol. 1. Cambridge University Press, Cambridge, 2nd edn.
</p>
<p>Richter, O., Spickermann, U. and Lenz, F. (1991). A new model for plant-growth. <em>Gartenbauwissenschaft</em>, <b>56</b>, 99-106.
</p>
<p>Viovy, N., Arino, O. and Belward, A.S. (1992). The Best Index Slope Extraction (BISE) - a method for reducing noise in NDVI time-series. <em>International Journal of Remote Sensing</em>, <b>13</b>, 1585-1590.
</p>
<p>Zhang, X.Y., Friedl, M.A., Schaaf, C.B., Strahler, A.H., Hodges, J.C.F., Gao, F., Reed, B.C. and Huete, A. (2003). Monitoring vegetation phenology using MODIS. <em>Remote Sensing of Environment</em>, <b>84</b>, 471-475.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bise">bise</a></code>, <code><a href="#topic+runningAvg">runningAvg</a></code>, <code><a href="#topic+modelNDVI">modelNDVI</a></code>, <code><a href="#topic+phenoPhase">phenoPhase</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	 ##first example
	# load data
	data(avhrr)
	data(modis)

	# create NDVI object
	ndvi1 &lt;- new("NDVI", values=avhrr.ndvi/10000, year=as.integer(1995))
	ndvi2 &lt;- new("NDVI", values=modis.ndvi/10000, year=as.integer(1995))

	# correct values (bise)
	ndvi1.bise &lt;- bise(ndvi1)
	ndvi2.bise &lt;- bise(ndvi2)

	# or running Average
	ndvi1.ravg &lt;- runningAvg(ndvi1)
	ndvi2.ravg &lt;- runningAvg(ndvi2)

	# model Values
	res1 &lt;- modelValues(ndvi1.bise, method="LinIP")
	res2 &lt;- modelValues(ndvi1.ravg, method="FFT", filter.threshold=7)
	res3 &lt;- modelValues(ndvi2.bise, method="LinIP")
	res4 &lt;- modelValues(ndvi2.bise, method="FFT", filter.threshold=7)

	# plot Values
	plot(res1)
	plot(res2)
	plot(res3)
	plot(res4)

	# extract greenup date
	greenup &lt;- phenoPhase(res1, phase="greenup", method="local", threshold=0.55, n=1000)
	# extract date with highest ndvi
	max.ndvi &lt;- phenoPhase(res1, phase="max", n=1000)

	## or simpler
	data(avhrr)
	data(modis)
	
	# create NDVI objects, correct and model values
	ndvi.list1 &lt;- modelNDVI(ndvi.values=cbind(avhrr.ndvi/10000, modis.ndvi/10000),
			year.int=1995, correction="bise", method="LinIP", MARGIN=2,
			doParallel=FALSE, slidingperiod=40)
	ndvi.list2 &lt;- modelNDVI(ndvi.values=cbind(avhrr.ndvi/10000, modis.ndvi/10000),
			year.int=1995, correction="ravg", method="FFT", MARGIN=2,
			doParallel=FALSE, filter.threshold=7)

	# plot Values
	for (ndvi.ob in ndvi.list1){ plot(ndvi.ob) }
	for (ndvi.ob in ndvi.list2){ plot(ndvi.ob) }
	
	# extract greenup date
	greenup &lt;- phenoPhase(ndvi.list1[[1]], phase="greenup", 
			method="local", threshold=0.55, n=1000)
	# extract senescence date
	senescence &lt;- phenoPhase(ndvi.list1[[1]], phase="senescence", 
			method="local", threshold=0.55, n=1000)
	# extract date with highest NDVI
	max.ndvi &lt;- phenoPhase(ndvi.list1[[1]], phase="max", n=1000)

	# calculate green season integrated vegetation index
	gsivi &lt;- integrateTimeserie(ndvi.list1[[1]], start=greenup, end=senescence, n=1000)
</code></pre>

<hr>
<h2 id='phenoPhase'>Phenological Phase Extraction</h2><span id='topic+phenoPhase'></span>

<h3>Description</h3>

<p>Extracts phenological metrics based on modelled NDVI values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoPhase(x, phase, method, threshold, n)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoPhase_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing modelled NDVI values.</p>
</td></tr>
<tr><td><code id="phenoPhase_+3A_phase">phase</code></td>
<td>
<p>Determines which phase will be extracted:
</p>
<p>&ldquo;<b>max</b>&rdquo;: Day of the year with highest NDVI value is returned.
</p>
<p>&ldquo;<b>maxval</b>&rdquo;: The highest modelled NDVI value and its standard deviation is returned.
</p>
<p>&ldquo;<b>min</b>&rdquo;: Day of the year (before day with maximum NDVI value) 
with lowest NDVI value is returned. 
</p>
<p>&ldquo;<b>minval</b>&rdquo;: The lowest modelled NDVI value and its standard deviation is returned.
</p>
<p>&ldquo;<b>greenup</b>&rdquo;: Day of the year at which greenup takes place and its standard deviation is returned. 
This day refers to the point where the function of modelled NDVI values 
exceeds a certain threshold.
</p>
<p>&ldquo;<b>senescence</b>&rdquo;: Day of the year at which senescence takes place and its standard deviation is returned. 
This day refers to the point where the function of modelled NDVI values exceeds 
a certain threshold.</p>
</td></tr>
<tr><td><code id="phenoPhase_+3A_method">method</code></td>
<td>
<p>Determines whether a global or local threshold is used for
greenup and senescence extraction.
</p>
<p>&ldquo;<b>global</b>&rdquo; threshold: The day of the year is returned, 
where NDVI values are first equal or higher as the value of &lsquo;threshold&rsquo;.
If the threshold is higher than the values of the timeseries, &lsquo;-1&rsquo; will be returned.
</p>
<p>&ldquo;<b>local</b>&rdquo; threshold: The day of the year is returned, for which NDVI values first reach the value of
&lsquo;threshold&rsquo; (interpreted as percentage) between lowest and highest NDVI value of timeserie. 
The lowest NDVI value is chosen depending on phase selected. For &ldquo;greenup&rdquo;, 
the lowest value before day of maximum NDVI value is used. For &ldquo;senescence&rdquo;, 
the lowest value after day of maximum NDVI value is used.</p>
</td></tr>
<tr><td><code id="phenoPhase_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for local or global greenup/senescence-extraction method. 
Should have numerical value between &lsquo;0&rsquo; and &lsquo;1&rsquo;. Global thresholds 
refer to a fix NDVI value independent of actual NDVI magnitudes. 
Local thresholds are based on (max - min) * e.g. 0.55. Hence, the respective 
NDVI value will vary dependent on e.g. land-cover.</p>
</td></tr>
<tr><td><code id="phenoPhase_+3A_n">n</code></td>
<td>
<p>The number &lsquo;n&rsquo; of normal distributed values around the threshold for estimation of &lsquo;sd&rsquo;. The normal distribution uses the threshold as mean and a standaed deviation consisting of 			satellite error and standard deviation of fit residuals. The satellite error is considered as 0.02+0.02*value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the julian day of the year at which the phenologial phase occurs as list entry &lsquo;mean&rsquo; and its standard deviation as list entry &lsquo;sd&rsquo;. The list contains vectors in &lsquo;mean&rsquo; and &lsquo;sd&rsquo; if multiple seasons are available in &lsquo;NDVI&rsquo; object.</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code>, <code><a href="#topic+detectSeasons">detectSeasons</a></code>, <code><a href="#topic+seasons">seasons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object, correct and model NDVI values
	ndvi &lt;- modelNDVI(ndvi.values=avhrr.ndvi/10000, year.int=1995, 
				correction="bise", method="LinIP", MARGIN=2, 
				doParallel=FALSE, slidingperiod=40)[[1]]

	# extract greenup DOY
	greenup &lt;- phenoPhase(ndvi, phase="greenup", method="local", threshold=0.55, n=1000)
</code></pre>

<hr>
<h2 id='rsquare'>Squared Pearson correlation coefficient</h2><span id='topic+rsquare'></span>

<h3>Description</h3>

<p>Calculates the squared Pearson correlation coefficient of corrected and modelled timeserie.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsquare(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsquare_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing corrected and modelled values. 
If corrected timeserie is not available, the raw one out of &lsquo;values&rsquo; will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The squared Pearson correlation coefficient as numeric value.</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object, correct and model values
	ndvi.list &lt;- modelNDVI(ndvi.values=avhrr.ndvi/10000, 
			year.int=1995, correction="bise", method="Growth", MARGIN=2, 
			doParallel=FALSE, slidingperiod=40)

	#plot
	plot(ndvi.list[[1]])

	# squared Pearson correlation coefficient
	rsquare(ndvi.list[[1]])
</code></pre>

<hr>
<h2 id='runningAvg'>Running Average</h2><span id='topic+runningAvg'></span>

<h3>Description</h3>

<p>Reduces noise in NDVI time-series through running averaging.</p>


<h3>Usage</h3>

<pre><code class='language-R'>runningAvg(x, window)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runningAvg_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing raw NDVI values.</p>
</td></tr>
<tr><td><code id="runningAvg_+3A_window">window</code></td>
<td>
<p>Window size of the running averaging algorithm. Default is 7.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;NDVI&rsquo; containing raw and corrected NDVI values.</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelNDVI">modelNDVI</a></code>,<code><a href="#topic+NDVI-class">NDVI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object
	ndvi &lt;- new("NDVI", values=avhrr.ndvi/10000, year=as.integer(1995))

	# correct values (bise)
	ndvi.ravg &lt;- runningAvg(ndvi, window=7)

	#plot
	plot(ndvi.ravg)
</code></pre>

<hr>
<h2 id='seasons'>Seasons Accessor</h2><span id='topic+seasons'></span>

<h3>Description</h3>

<p>Access to detected seasons.</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasons(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasons_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing raw NDVI values and detected seasons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing position of seasons.</p>


<h3>Author(s)</h3>

<p>Lange, Maximilian and Doktor, Daniel</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code>, <code><a href="#topic+detectSeasons">detectSeasons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data
	data(avhrr)

	# create NDVI object, correct and model values
	ndvi.list &lt;- modelNDVI(ndvi.values=c(avhrr.ndvi/10000,avhrr.ndvi/10000), 
			year.int=1995, detectSeasons=TRUE,
			correction="bise", method="LinIP", MARGIN=2, 
			doParallel=FALSE, slidingperiod=40)
	ndvi &lt;- ndvi.list[[1]]

	#get seasons
	seasondates &lt;- seasons(ndvi)
</code></pre>

<hr>
<h2 id='values'>Raw Value Accessor</h2><span id='topic+values'></span>

<h3>Description</h3>

<p>Access to raw values of NDVI object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>values(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="values_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;NDVI&rsquo; containing raw NDVI values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing raw NDVI values.</p>


<h3>Author(s)</h3>

<p>Lange, Maximilian and Doktor, Daniel</p>


<h3>See Also</h3>

<p><code><a href="#topic+NDVI-class">NDVI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	# load data 
	data(avhrr)

	# create NDVI object
	ndvi &lt;- new("NDVI", values=avhrr.ndvi/10000, year=as.integer(1995))

	#extract raw values
	rawValues &lt;- values(ndvi)
</code></pre>

<hr>
<h2 id='yearlength'>Number of Days</h2><span id='topic+yearlength'></span>

<h3>Description</h3>

<p>Returns the number of days of the given year.</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearlength(year)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yearlength_+3A_year">year</code></td>
<td>
<p>A vector of years as integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of days of the year in the date</p>


<h3>Author(s)</h3>

<p>Daniel Doktor, Maximilian Lange</p>


<h3>Examples</h3>

<pre><code class='language-R'>	year &lt;- c(1995, 2000, 2005, 2010)
	days &lt;- yearlength(year)
	days
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
