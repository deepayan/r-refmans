<!DOCTYPE html><html><head><title>Help for package iNZightTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iNZightTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_suffix'><p>Add suffix to string</p></a></li>
<li><a href='#aggregate_data'><p>Aggregate data by categorical variables</p></a></li>
<li><a href='#append_rows'><p>Append rows to a dataset</p></a></li>
<li><a href='#as_tibble'><p>as_tibble</p></a></li>
<li><a href='#code'><p>Get Data's Code</p></a></li>
<li><a href='#collapse_cat'><p>Collapse data by values of a categorical variable</p></a></li>
<li><a href='#combine_vars'><p>Combine variables into one categorical variable</p></a></li>
<li><a href='#convert_to_cat'><p>Convert variables to categorical variables</p></a></li>
<li><a href='#convert_to_date'><p>Convert variables to dates</p></a></li>
<li><a href='#convert_to_datetime'><p>Convert variables to date-time</p></a></li>
<li><a href='#create_varname'><p>Create variable name</p></a></li>
<li><a href='#create_vars'><p>Create new variables</p></a></li>
<li><a href='#delete_vars'><p>Delete variables</p></a></li>
<li><a href='#extract_dt_comp'><p>Extract date component from a date-time variable</p></a></li>
<li><a href='#extract_part'><p>Extract part of a datetimes variable (DEPRECATED)</p></a></li>
<li><a href='#filter'><p>Filter</p></a></li>
<li><a href='#filter_cat'><p>Filter data by levels of categorical variables</p></a></li>
<li><a href='#filter_num'><p>Filter data by levels of numeric variables</p></a></li>
<li><a href='#fitDesign'><p>Fit a survey design</p></a></li>
<li><a href='#fitModel'><p>Fit models</p></a></li>
<li><a href='#form_class_intervals'><p>Form Class Intervals</p></a></li>
<li><a href='#inzdf'><p>iNZight data frame object</p></a></li>
<li><a href='#is_cat'><p>Is factor check</p></a></li>
<li><a href='#is_dt'><p>Is datetime check</p></a></li>
<li><a href='#is_num'><p>Is numeric check</p></a></li>
<li><a href='#is_preview'><p>Is Preview</p></a></li>
<li><a href='#is_survey'><p>Check if object is a survey object (either standard or replicate design)</p></a></li>
<li><a href='#is_svydesign'><p>Check if object is a survey object (created by svydesign())</p></a></li>
<li><a href='#is_svyrep'><p>Check if object is a replicate survey object (created by svrepdesign())</p></a></li>
<li><a href='#join_data'><p>Join data with another dataset</p></a></li>
<li><a href='#load_linked'><p>Import linked data into an <code>inzdf</code> object</p></a></li>
<li><a href='#load_rda'><p>Load object(s) from an Rdata file</p></a></li>
<li><a href='#make_names'><p>Make unique variable names</p></a></li>
<li><a href='#missing_to_cat'><p>Convert missing values to categorical variables</p></a></li>
<li><a href='#newdevice'><p>Open a New Graphics Device</p></a></li>
<li><a href='#Not In operator'><p>Anti value matching</p></a></li>
<li><a href='#Or NULL operator'><p>NULL or operator</p></a></li>
<li><a href='#print_code'><p>Tidy-printing of the code attached to an object</p></a></li>
<li><a href='#random_sample'><p>Random sampling without replacement</p></a></li>
<li><a href='#rank_vars'><p>Rank the data of numeric variables</p></a></li>
<li><a href='#read_dictionary'><p>Data Dictionaries</p></a></li>
<li><a href='#read_meta'><p>Read CSV with iNZight metadata</p></a></li>
<li><a href='#read_text'><p>Read text as data</p></a></li>
<li><a href='#remove_rows'><p>Remove rows from data by row numbers</p></a></li>
<li><a href='#rename_levels'><p>Rename the levels of a categorical variable</p></a></li>
<li><a href='#rename_vars'><p>Rename column names</p></a></li>
<li><a href='#reorder_levels'><p>Reorder the levels of a categorical variable</p></a></li>
<li><a href='#reshape_data'><p>Reshaping dataset from wide to long or from long to wide</p></a></li>
<li><a href='#save_rda'><p>Save an object with, optionally, a (valid) name</p></a></li>
<li><a href='#select'><p>Select</p></a></li>
<li><a href='#select_vars'><p>Select variables from a dataset</p></a></li>
<li><a href='#separate_var'><p>Separate columns</p></a></li>
<li><a href='#sheets'><p>List available sheets within a file</p></a></li>
<li><a href='#smart_read'><p>Read a data file</p></a></li>
<li><a href='#sort_vars'><p>Sort data by variables</p></a></li>
<li><a href='#standardize_vars'><p>Standardize the data of a numeric variable</p></a></li>
<li><a href='#str_c'><p>str_c operator</p></a></li>
<li><a href='#survey_IQR'><p>Interquartile range function for surveys</p></a></li>
<li><a href='#tidy_all_code'><p>iNZight Tidy Code</p></a></li>
<li><a href='#transform_vars'><p>Transform data of numeric variables</p></a></li>
<li><a href='#validation_details'><p>Details of Validation Rule Results</p></a></li>
<li><a href='#validation_summary'><p>Validation Confrontation Summary</p></a></li>
<li><a href='#vartype'><p>Get variable type name</p></a></li>
<li><a href='#vartypes'><p>Get all variable types from data object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for 'iNZight'</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.0), DBI, forcats, glue, grDevices, magrittr,
methods, purrr (&ge; 1.0.0), readr (&ge; 1.2.0), rlang (&ge; 0.4.9),
srvyr, stats, stringr, survey, tibble, tidyr (&ge; 1.3.0), tools,
units, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>chron, covr, dbplyr, expss, haven, jsonlite, knitr,
lubridate, RCurl, readxl, RSQLite, styler, surveyspec, testthat
(&ge; 3.0.0), tsibble, validate, yaml</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://r.docker.stat.auckland.ac.nz">https://r.docker.stat.auckland.ac.nz</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/iNZightVIT/iNZightTools/issues">https://github.com/iNZightVIT/iNZightTools/issues</a></td>
</tr>
<tr>
<td>Contact:</td>
<td>inzight_support@stat.auckland.ac.nz</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://inzight.nz">https://inzight.nz</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of wrapper functions for common variable and dataset manipulation workflows primarily used by 'iNZight', a graphical user interface providing easy exploration and visualisation of data for students of statistics, available in both desktop and online versions. Additionally, many of the functions return the 'tidyverse' code used to obtain the result in an effort to bridge the gap between GUI and coding.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-10 08:34:58 UTC; tom</td>
</tr>
<tr>
<td>Author:</td>
<td>Tom Elliott <a href="https://orcid.org/0000-0002-7815-6318"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Daniel Barnett [aut],
  Yiwen He [aut],
  Zhaoming Su [aut],
  Lushi Cai [ctb],
  Akshay Gupta [ctb],
  Owen Jin [ctb],
  Christoph Knopf [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tom Elliott &lt;tom.elliott@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-12 11:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_suffix'>Add suffix to string</h2><span id='topic+add_suffix'></span>

<h3>Description</h3>

<p>When creating new variables or modifying the data set, we often
add a suffix added to distinguish the new name from the original one.
However, if the same action is performed twice (for example, filtering a data set),
the suffix is duplicated (data.filtered.filtered). This function averts this
by adding the suffix if it doesn't exist, and otherwise appending
a counter (data.filtered2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_suffix(name, suffix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_suffix_+3A_name">name</code></td>
<td>
<p>a character vector containing (original) names</p>
</td></tr>
<tr><td><code id="add_suffix_+3A_suffix">suffix</code></td>
<td>
<p>the suffix to add, a length-one character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of names with suffix appended
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_suffix("data", "filtered")
add_suffix(c("data.filtered", "data.filtered.reshaped"), "filtered")
</code></pre>

<hr>
<h2 id='aggregate_data'>Aggregate data by categorical variables</h2><span id='topic+aggregate_data'></span><span id='topic+aggregate_dt'></span>

<h3>Description</h3>

<p>Summarizes non-categorical variables in a dataframe by grouping them
based on specified categorical variables and returns the aggregated result
along with the tidyverse code used to generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_data(
  data,
  group_vars,
  summaries,
  vars = NULL,
  names = NULL,
  quantiles = c(0.25, 0.75)
)

aggregate_dt(
  data,
  dt,
  dt_comp,
  group_vars = NULL,
  summaries,
  vars = NULL,
  names = NULL,
  quantiles = c(0.25, 0.75)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_data_+3A_data">data</code></td>
<td>
<p>A dataframe or survey design object to be aggregated.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_group_vars">group_vars</code></td>
<td>
<p>A character vector specifying the variables in <code>data</code> to '
be used as grouping factors.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_summaries">summaries</code></td>
<td>
<p>An unnamed character vector or named list of summary
functions to calculate for each group.
If unnamed, the vector elements should be names of variables in the
dataset for which summary statistics need to be calculated.
If named, the names should correspond to the summary functions
(e.g., &quot;mean&quot;, &quot;sd&quot;, &quot;iqr&quot;) to be applied to each variable.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_vars">vars</code></td>
<td>
<p>(Optional) A character vector specifying the names of variables
in the dataset for which summary statistics need to be calculated.
This argument is ignored if <code>summaries</code> is a named list.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_names">names</code></td>
<td>
<p>(Optional) A character vector or named list providing name
templates for the newly created variables. See details for more
information.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_quantiles">quantiles</code></td>
<td>
<p>(Optional) A numeric vector specifying the desired
quantiles (e.g., c(0.25, 0.5, 0.75)).
See details for more information.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_dt">dt</code></td>
<td>
<p>A character string representing the name of the date-time variable
in the dataset.</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_dt_comp">dt_comp</code></td>
<td>
<p>A character string specifying the component of the date-time
to use for grouping.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>aggregate_data()</code> function accepts any R function that returns a
single-value summary (e.g., <code>mean</code>, <code>var</code>, <code>sd</code>, <code>sum</code>, <code>IQR</code>). By default,
new variables are named <code style="white-space: pre;">&#8288;{var}_{fun}&#8288;</code>, where <code>{var}</code> is the variable name
and <code>{fun}</code> is the summary function used. The user can provide custom names
using the <code>names</code> argument, either as a vector of the same length as <code>vars</code>,
or as a named list where the names correspond to summary functions (e.g.,
&quot;mean&quot; or &quot;sd&quot;).
</p>
<p>The special summary &quot;missing&quot; can be included, which counts the number of
missing values in the variable. The default name for this summary is
<code style="white-space: pre;">&#8288;{var}_missing&#8288;</code>.
</p>
<p>If <code>quantiles</code> are requested, the function calculates the specified
quantiles (e.g., 25th, 50th, 75th percentiles), creating new variables for
each quantile. To customize the names of these variables, use <code>{p}</code> as a
placeholder in the <code>names</code> argument, where <code>{p}</code> represents the quantile
value. For example, using <code>names = "Q{p}_{var}"</code> will create variables like
&quot;Q0.25_Sepal.Length&quot; for the 25th percentile.
</p>


<h3>Value</h3>

<p>An aggregated dataframe containing the summary statistics for each
group, along with the tidyverse code used for the aggregation.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>aggregate_dt()</code>: Aggregate data by dates and times
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Tom Elliott, Owen Jin, Zhaoming Su
</p>
<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>
<p><code><a href="#topic+aggregate_data">aggregate_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aggregated &lt;-
    aggregate_data(iris,
        group_vars = c("Species"),
        summaries = c("mean", "sd", "iqr")
    )
code(aggregated)
head(aggregated)

</code></pre>

<hr>
<h2 id='append_rows'>Append rows to a dataset</h2><span id='topic+append_rows'></span>

<h3>Description</h3>

<p>Append rows to a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_rows(data, new_data, when_added = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_rows_+3A_data">data</code></td>
<td>
<p>The original dataset to which new rows will be appended.</p>
</td></tr>
<tr><td><code id="append_rows_+3A_new_data">new_data</code></td>
<td>
<p>The dataset containing the new rows.</p>
</td></tr>
<tr><td><code id="append_rows_+3A_when_added">when_added</code></td>
<td>
<p>Logical; indicates whether a <code>.when_added</code> column
is required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset with new rows appended below the original <code>data</code>.
</p>


<h3>Author(s)</h3>

<p>Yiwen He, Zhaoming Su
</p>

<hr>
<h2 id='as_tibble'>as_tibble</h2><span id='topic+as_tibble'></span><span id='topic+as_tibble.dictionary'></span>

<h3>Description</h3>

<p>as_tibble
</p>
<p>Convert dictionary object to a 'tibble'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dictionary'
as_tibble(
  x,
  n = length(x),
  include_other = TRUE,
  code_sep = ifelse(interactive(), "|", "\n"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble_+3A_x">x</code></td>
<td>
<p>A 'dictionary' object.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_n">n</code></td>
<td>
<p>Numeric, the number of rows to convert.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_include_other">include_other</code></td>
<td>
<p>If 'TRUE', other variables with be included in the
tibble.</p>
</td></tr>
<tr><td><code id="as_tibble_+3A_code_sep">code_sep</code></td>
<td>
<p>The separator used between codes and values.</p>
</td></tr>
</table>

<hr>
<h2 id='code'>Get Data's Code</h2><span id='topic+code'></span>

<h3>Description</h3>

<p>Used to grab code from a data.frame generated by this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code_+3A_data">data</code></td>
<td>
<p>dataset you want to extract the code from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply a helper function to grab the contents
of the 'code' attribute contained in the data object.
</p>


<h3>Value</h3>

<p>The code used to generate the data.frame, if available (else NULL)
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='collapse_cat'>Collapse data by values of a categorical variable</h2><span id='topic+collapse_cat'></span>

<h3>Description</h3>

<p>Collapse values in a categorical variable into one defined level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_cat(data, var, levels, new_level, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_cat_+3A_data">data</code></td>
<td>
<p>a dataframe to collapse</p>
</td></tr>
<tr><td><code id="collapse_cat_+3A_var">var</code></td>
<td>
<p>a string of the name of the categorical variable to collapse</p>
</td></tr>
<tr><td><code id="collapse_cat_+3A_levels">levels</code></td>
<td>
<p>a character vector of the levels to be collapsed</p>
</td></tr>
<tr><td><code id="collapse_cat_+3A_new_level">new_level</code></td>
<td>
<p>a string for the new level</p>
</td></tr>
<tr><td><code id="collapse_cat_+3A_name">name</code></td>
<td>
<p>a name for the new variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original dataframe containing a new column of the
collapsed variable with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collapsed &lt;- collapse_cat(iris,
    var = "Species",
    c("versicolor", "virginica"),
    new_level = "V"
)
cat(code(collapsed))
tail(collapsed)

</code></pre>

<hr>
<h2 id='combine_vars'>Combine variables into one categorical variable</h2><span id='topic+combine_vars'></span>

<h3>Description</h3>

<p>Combine chosen variables of any class by concatenating
them into one factor variable, and returns the result
along with tidyverse code used to generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_vars(
  data,
  vars,
  sep = ":",
  name = NULL,
  keep_empty = FALSE,
  keep_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_vars_+3A_data">data</code></td>
<td>
<p>a dataframe with the columns to be combined</p>
</td></tr>
<tr><td><code id="combine_vars_+3A_vars">vars</code></td>
<td>
<p>a character vector of the variables to be combined</p>
</td></tr>
<tr><td><code id="combine_vars_+3A_sep">sep</code></td>
<td>
<p>a character string to separate the levels</p>
</td></tr>
<tr><td><code id="combine_vars_+3A_name">name</code></td>
<td>
<p>a name for the new variable</p>
</td></tr>
<tr><td><code id="combine_vars_+3A_keep_empty">keep_empty</code></td>
<td>
<p>logical, if <code>FALSE</code> empty level combinations
are removed from the factor</p>
</td></tr>
<tr><td><code id="combine_vars_+3A_keep_na">keep_na</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>&lt;NA&gt;</code> in the factors or
<code>NA</code> in the characters will turn in a level <code>"(Missing)"</code>;
otherwise, the resulting entries will return <code>&lt;NA&gt;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing new columns of the new
categorical variable with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Owen Jin, Zhaoming Su
</p>


<h3>Examples</h3>

<pre><code class='language-R'>combined &lt;- combine_vars(warpbreaks, vars = c("wool", "tension"), sep = "_")
cat(code(combined))
head(combined)

</code></pre>

<hr>
<h2 id='convert_to_cat'>Convert variables to categorical variables</h2><span id='topic+convert_to_cat'></span>

<h3>Description</h3>

<p>Convert specified variables into factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_cat(data, vars, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_cat_+3A_data">data</code></td>
<td>
<p>a dataframe with the categorical column to convert</p>
</td></tr>
<tr><td><code id="convert_to_cat_+3A_vars">vars</code></td>
<td>
<p>a character vector of column names to convert</p>
</td></tr>
<tr><td><code id="convert_to_cat_+3A_names">names</code></td>
<td>
<p>a character vector of names for the created variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing new columns of the
converted variables with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>converted &lt;- convert_to_cat(iris, vars = c("Petal.Width"))
cat(code(converted))
head(converted)

</code></pre>

<hr>
<h2 id='convert_to_date'>Convert variables to dates</h2><span id='topic+convert_to_date'></span>

<h3>Description</h3>

<p>Convert variables to dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_date(data, vars, ord = NULL, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_date_+3A_data">data</code></td>
<td>
<p>a dataframe with the variables to convert</p>
</td></tr>
<tr><td><code id="convert_to_date_+3A_vars">vars</code></td>
<td>
<p>a character vector of column names to convert</p>
</td></tr>
<tr><td><code id="convert_to_date_+3A_ord">ord</code></td>
<td>
<p>a character vector of date-time formats</p>
</td></tr>
<tr><td><code id="convert_to_date_+3A_names">names</code></td>
<td>
<p>a character vector of names for the created variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing new columns of the
converted variables with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>

<hr>
<h2 id='convert_to_datetime'>Convert variables to date-time</h2><span id='topic+convert_to_datetime'></span>

<h3>Description</h3>

<p>Convert variables to date-time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_datetime(data, vars, ord = NULL, names = NULL, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_datetime_+3A_data">data</code></td>
<td>
<p>a dataframe with the variables to convert</p>
</td></tr>
<tr><td><code id="convert_to_datetime_+3A_vars">vars</code></td>
<td>
<p>a character vector of column names to convert</p>
</td></tr>
<tr><td><code id="convert_to_datetime_+3A_ord">ord</code></td>
<td>
<p>a character vector of date-time formats</p>
</td></tr>
<tr><td><code id="convert_to_datetime_+3A_names">names</code></td>
<td>
<p>a character vector of names for the created variables</p>
</td></tr>
<tr><td><code id="convert_to_datetime_+3A_tz">tz</code></td>
<td>
<p>a time zone name (default: local time zone). See
<code><a href="base.html#topic+OlsonNames">OlsonNames</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing new columns of the
converted variables with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>

<hr>
<h2 id='create_varname'>Create variable name</h2><span id='topic+create_varname'></span>

<h3>Description</h3>

<p>Convert a given string to a valid R variable name,
converting spaces to underscores (_) instead of dots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_varname(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_varname_+3A_x">x</code></td>
<td>
<p>a string to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string, which is also a valid variable name
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_varname("a new variable")
create_varname("8d4-2q5")
</code></pre>

<hr>
<h2 id='create_vars'>Create new variables</h2><span id='topic+create_vars'></span>

<h3>Description</h3>

<p>Create new variables by using valid R expressions and returns
the result along with tidyverse code used to generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_vars(data, vars = ".new_var", vars_expr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_vars_+3A_data">data</code></td>
<td>
<p>a dataframe to which to add new variables to</p>
</td></tr>
<tr><td><code id="create_vars_+3A_vars">vars</code></td>
<td>
<p>a character of the new variable names</p>
</td></tr>
<tr><td><code id="create_vars_+3A_vars_expr">vars_expr</code></td>
<td>
<p>a character of valid R expressions which can
generate vectors of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing the new columns
created from <code>vars_expr</code>
with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>created &lt;- create_vars(
    data = iris,
    vars = "Sepal.Length_less_Sepal.Width",
    "Sepal.Length - Sepal.Width"
)
cat(code(created))
head(created)
</code></pre>

<hr>
<h2 id='delete_vars'>Delete variables</h2><span id='topic+delete_vars'></span>

<h3>Description</h3>

<p>Delete variables from a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_vars(data, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_vars_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="delete_vars_+3A_vars">vars</code></td>
<td>
<p>variable names to delete</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset without chosen variables
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>

<hr>
<h2 id='extract_dt_comp'>Extract date component from a date-time variable</h2><span id='topic+extract_dt_comp'></span>

<h3>Description</h3>

<p>This function extracts a specific date component from a date-time variable
in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_dt_comp(data, var, comp, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_dt_comp_+3A_data">data</code></td>
<td>
<p>The dataframe containing the date-time variable.</p>
</td></tr>
<tr><td><code id="extract_dt_comp_+3A_var">var</code></td>
<td>
<p>The name of the date-time variable to extract the component.</p>
</td></tr>
<tr><td><code id="extract_dt_comp_+3A_comp">comp</code></td>
<td>
<p>The date component wanted from the variable. See
<code>iNZightTools:::inz_dt_comp</code> for the full list of components.</p>
</td></tr>
<tr><td><code id="extract_dt_comp_+3A_name">name</code></td>
<td>
<p>The name of the new column to store the extracted date
component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the new date component column.
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>

<hr>
<h2 id='extract_part'>Extract part of a datetimes variable (DEPRECATED)</h2><span id='topic+extract_part'></span>

<h3>Description</h3>

<p>This function has been replaced by 'extract_dt_comp' and will be removed in the next release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_part(.data, varname, part, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_part_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="extract_part_+3A_varname">varname</code></td>
<td>
<p>name of the variable</p>
</td></tr>
<tr><td><code id="extract_part_+3A_part">part</code></td>
<td>
<p>part of the variable wanted</p>
</td></tr>
<tr><td><code id="extract_part_+3A_name">name</code></td>
<td>
<p>name of the new column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see 'extract_dt_comp'
</p>

<hr>
<h2 id='filter'>Filter</h2><span id='topic+filter'></span><span id='topic+filter.inzdf_db'></span>

<h3>Description</h3>

<p>Filter
</p>
<p>Filter inzdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inzdf_db'
filter(.data, ..., table = NULL, .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>.data</code>. If multiple expressions are included, they are combined with the
<code>&amp;</code> operator. Only rows for which all conditions evaluate to <code>TRUE</code> are
kept.</p>
</td></tr>
<tr><td><code id="filter_+3A_table">table</code></td>
<td>
<p>name of the table to use, defaults to first in list</p>
</td></tr>
<tr><td><code id="filter_+3A_.preserve">.preserve</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='filter_cat'>Filter data by levels of categorical variables</h2><span id='topic+filter_cat'></span>

<h3>Description</h3>

<p>This function filters a dataframe or survey design object by keeping only
the rows where a specified categorical variable matches one of the given
levels. The resulting filtered dataframe is returned, along with the
tidyverse code used to generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_cat(data, var, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_cat_+3A_data">data</code></td>
<td>
<p>A dataframe or survey design object to be filtered.</p>
</td></tr>
<tr><td><code id="filter_cat_+3A_var">var</code></td>
<td>
<p>The name of the column in <code>data</code> to be filtered by.</p>
</td></tr>
<tr><td><code id="filter_cat_+3A_levels">levels</code></td>
<td>
<p>A character vector of levels in <code>var</code> to keep.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered dataframe with the tidyverse code attached.
</p>


<h3>Author(s)</h3>

<p>Owen Jin, Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filtered &lt;- filter_cat(iris,
    var = "Species",
    levels = c("versicolor", "virginica")
)
cat(code(filtered))
head(filtered)

</code></pre>

<hr>
<h2 id='filter_num'>Filter data by levels of numeric variables</h2><span id='topic+filter_num'></span>

<h3>Description</h3>

<p>This function filters a dataframe or survey design object by applying a
specified boolean condition to one of its numeric variables. The resulting
filtered dataframe is returned, along with the tidyverse code used to
generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_num(data, var, op = c("&lt;=", "&lt;", "&gt;=", "&gt;", "==", "!="), num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_num_+3A_data">data</code></td>
<td>
<p>A dataframe or survey design object to be filtered.</p>
</td></tr>
<tr><td><code id="filter_num_+3A_var">var</code></td>
<td>
<p>The name of the column in <code>data</code> to be filtered by.</p>
</td></tr>
<tr><td><code id="filter_num_+3A_op">op</code></td>
<td>
<p>A logical operator to apply for the filtering condition.
Valid options are: &quot;&lt;=&quot;, &quot;&lt;&quot;, &quot;&gt;=&quot;, &quot;&gt;&quot;, &quot;==&quot;, or &quot;!=&quot;.</p>
</td></tr>
<tr><td><code id="filter_num_+3A_num">num</code></td>
<td>
<p>The numeric value for which the specified <code>op</code> is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered dataframe with the tidyverse code attached.
</p>


<h3>Author(s)</h3>

<p>Owen Jin, Tom Elliott, Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filtered &lt;- filter_num(iris, var = "Sepal.Length", op = "&lt;=", num = 5)
cat(code(filtered))
head(filtered)

library(survey)
data(api)
svy &lt;- svydesign(~ dnum + snum,
    weights = ~pw, fpc = ~ fpc1 + fpc2,
    data = apiclus2
)
svy_filtered &lt;- filter_num(svy, var = "api00", op = "&lt;", num = 700)
cat(code(svy_filtered))

</code></pre>

<hr>
<h2 id='fitDesign'>Fit a survey design</h2><span id='topic+fitDesign'></span>

<h3>Description</h3>

<p>Fit a survey design to an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDesign(svydes, dataset.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitDesign_+3A_svydes">svydes</code></td>
<td>
<p>a design</p>
</td></tr>
<tr><td><code id="fitDesign_+3A_dataset.name">dataset.name</code></td>
<td>
<p>a dataset name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a survey object
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='fitModel'>Fit models</h2><span id='topic+fitModel'></span>

<h3>Description</h3>

<p>Wrapper function for 'lm', 'glm', and 'svyglm'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitModel(
  y,
  x,
  data,
  family = "gaussian",
  link = switch(family, gaussian = "gaussian", binomial = "logit", poisson = "log",
    negbin = "log"),
  design = "simple",
  svydes = NA,
  surv_params = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitModel_+3A_y">y</code></td>
<td>
<p>character string representing the response,</p>
</td></tr>
<tr><td><code id="fitModel_+3A_x">x</code></td>
<td>
<p>character string of the explanatory variables,</p>
</td></tr>
<tr><td><code id="fitModel_+3A_data">data</code></td>
<td>
<p>name of the object containing the data.</p>
</td></tr>
<tr><td><code id="fitModel_+3A_family">family</code></td>
<td>
<p>gaussian, binomial, poisson (so far, no others will be added)</p>
</td></tr>
<tr><td><code id="fitModel_+3A_link">link</code></td>
<td>
<p>the link function to use</p>
</td></tr>
<tr><td><code id="fitModel_+3A_design">design</code></td>
<td>
<p>data design specification.
one of 'simple', 'survey' or 'experiment'</p>
</td></tr>
<tr><td><code id="fitModel_+3A_svydes">svydes</code></td>
<td>
<p>a vector of arguments to be passed to the svydesign function,
excluding data (defined above)</p>
</td></tr>
<tr><td><code id="fitModel_+3A_surv_params">surv_params</code></td>
<td>
<p>a vector containing arguments for <code>survival::Surv()</code></p>
</td></tr>
<tr><td><code id="fitModel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to lm, glm, svyglm,
such as offset, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model call formula (using lm, glm, or svyglm)
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='form_class_intervals'>Form Class Intervals</h2><span id='topic+form_class_intervals'></span>

<h3>Description</h3>

<p>This function creates categorical intervals from a numeric variable in the given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_class_intervals(
  data,
  variable,
  method = c("equal", "width", "count", "manual"),
  n_intervals = 4L,
  interval_width,
  format = "(a,b]",
  range = NULL,
  format_lowest = ifelse(isinteger, "&lt; a", "&lt;= a"),
  format_highest = "&gt; b",
  break_points = NULL,
  name = sprintf("%s.f", variable)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="form_class_intervals_+3A_data">data</code></td>
<td>
<p>A dataset or a survey object.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_variable">variable</code></td>
<td>
<p>The name of the numeric variable to convert into intervals.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_method">method</code></td>
<td>
<p>The method used to create intervals:
</p>

<ul>
<li><p> 'equal' for equal-width intervals,
</p>
</li>
<li><p> 'width' for intervals of a specific width,
</p>
</li>
<li><p> 'count' for equal-count intervals, and
</p>
</li>
<li><p> 'manual' to specify break points manually.
</p>
</li></ul>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_n_intervals">n_intervals</code></td>
<td>
<p>For methods 'equal' and 'count', this specifies the
number of intervals to create.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_interval_width">interval_width</code></td>
<td>
<p>For method 'width', this sets the width of the
intervals.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_format">format</code></td>
<td>
<p>The format for interval labels; use 'a' and 'b' to represent
the min/max of each interval, respectively.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_range">range</code></td>
<td>
<p>The range of the data; use this to adjust the labels
(e.g., for continuous data, set this to the floor/ceiling
of the min/max of the data to get prettier intervals).
If range does not cover the range of the data, values outside will be
placed into 'less than a' and 'greater than b' categories.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_format_lowest">format_lowest</code></td>
<td>
<p>Label format for values lower than the min of range.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_format_highest">format_highest</code></td>
<td>
<p>Label format for values higher than the max of range.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_break_points">break_points</code></td>
<td>
<p>For method 'manual', specify breakpoints here as a
numeric vector.</p>
</td></tr>
<tr><td><code id="form_class_intervals_+3A_name">name</code></td>
<td>
<p>The name of the new variable in the resulting data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with an additional column containing categorical class
intervals.
</p>


<h3>Author(s)</h3>

<p>Tom Elliott, Zhaoming Su
</p>


<h3>Examples</h3>

<pre><code class='language-R'>form_class_intervals(iris, "Sepal.Length", "equal", 5L)
</code></pre>

<hr>
<h2 id='inzdf'>iNZight data frame object</h2><span id='topic+inzdf'></span><span id='topic+inzdf.tbl_df'></span><span id='topic+inzdf.data.frame'></span><span id='topic+inzdf.SQLiteConnection'></span>

<h3>Description</h3>

<p>This object allows the data to be either a standard R <code>data.frame</code> or
a connection to a database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inzdf(x, name, ...)

## S3 method for class 'tbl_df'
inzdf(x, name, ...)

## S3 method for class 'data.frame'
inzdf(x, name, ...)

## S3 method for class 'SQLiteConnection'
inzdf(
  x,
  name = deparse(substitute(x)),
  schema = NULL,
  var_attrs = list(),
  dictionary = NULL,
  keep_con = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inzdf_+3A_x">x</code></td>
<td>
<p>a data.frame or db connection</p>
</td></tr>
<tr><td><code id="inzdf_+3A_name">name</code></td>
<td>
<p>the name of the data</p>
</td></tr>
<tr><td><code id="inzdf_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="inzdf_+3A_schema">schema</code></td>
<td>
<p>a list specifying the schema of the database (used for linking)</p>
</td></tr>
<tr><td><code id="inzdf_+3A_var_attrs">var_attrs</code></td>
<td>
<p>nested list of variables attributes for each table &gt; variable</p>
</td></tr>
<tr><td><code id="inzdf_+3A_dictionary">dictionary</code></td>
<td>
<p>an inzdict object</p>
</td></tr>
<tr><td><code id="inzdf_+3A_keep_con">keep_con</code></td>
<td>
<p>if 'TRUE' data will remain in DB (use for very large data)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO:
It is possible to specify a linking structure between multiple datasets,
and when variables are selected the dataset will be linked 'on-the-fly'.
This, when used with databases, will significantly reduce the size of data in memory.
</p>


<h3>Value</h3>

<p>an <code>inzdf</code> object
</p>

<hr>
<h2 id='is_cat'>Is factor check</h2><span id='topic+is_cat'></span>

<h3>Description</h3>

<p>This function checks if a variable a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_cat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_cat_+3A_x">x</code></td>
<td>
<p>the variable to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, <code>TRUE</code> if the variable is a factor
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='is_dt'>Is datetime check</h2><span id='topic+is_dt'></span>

<h3>Description</h3>

<p>This function checks if a variable a date/time/datetime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dt_+3A_x">x</code></td>
<td>
<p>the variable to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, <code>TRUE</code> if the variable is a datetime
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='is_num'>Is numeric check</h2><span id='topic+is_num'></span>

<h3>Description</h3>

<p>This function checks if a variable is numeric,
or could be considered one.
For example, dates and times can be treated as numeric,
so return <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_num(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_num_+3A_x">x</code></td>
<td>
<p>the variable to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, <code>TRUE</code> if the variable is numeric
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='is_preview'>Is Preview</h2><span id='topic+is_preview'></span>

<h3>Description</h3>

<p>Checks if the complete file was read or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_preview(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_preview_+3A_df">df</code></td>
<td>
<p>data to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is_survey'>Check if object is a survey object (either standard or replicate design)</h2><span id='topic+is_survey'></span>

<h3>Description</h3>

<p>Check if object is a survey object (either standard or replicate design)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_survey(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_survey_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='is_svydesign'>Check if object is a survey object (created by svydesign())</h2><span id='topic+is_svydesign'></span>

<h3>Description</h3>

<p>Check if object is a survey object (created by svydesign())
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_svydesign(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_svydesign_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='is_svyrep'>Check if object is a replicate survey object (created by svrepdesign())</h2><span id='topic+is_svyrep'></span>

<h3>Description</h3>

<p>Check if object is a replicate survey object (created by svrepdesign())
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_svyrep(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_svyrep_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='join_data'>Join data with another dataset</h2><span id='topic+join_data'></span>

<h3>Description</h3>

<p>Join data with another dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_data(
  data_l,
  data_r,
  by = NULL,
  how = c("inner", "left", "right", "full", "anti", "semi"),
  suffix_l = ".x",
  suffix_r = ".y"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_data_+3A_data_l">data_l</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code id="join_data_+3A_data_r">data_r</code></td>
<td>
<p>imported dataset</p>
</td></tr>
<tr><td><code id="join_data_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by</p>
</td></tr>
<tr><td><code id="join_data_+3A_how">how</code></td>
<td>
<p>the method used to join the datasets</p>
</td></tr>
<tr><td><code id="join_data_+3A_suffix_l">suffix_l</code></td>
<td>
<p>suffix for the original dataset (ignored for filter-joins)</p>
</td></tr>
<tr><td><code id="join_data_+3A_suffix_r">suffix_r</code></td>
<td>
<p>suffix for the imported dataset (ignored for filter-joins)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>joined dataset
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>, <code><a href="dplyr.html#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>
</p>

<hr>
<h2 id='load_linked'>Import linked data into an <code>inzdf</code> object</h2><span id='topic+load_linked'></span>

<h3>Description</h3>

<p>Import linked data into an <code>inzdf</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_linked(
  x,
  schema,
  con,
  name = ifelse(missing(con), deparse(substitute(x)), deparse(substitute(con))),
  keep_con = FALSE,
  progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_linked_+3A_x">x</code></td>
<td>
<p>a linked specification file or vector of data set paths</p>
</td></tr>
<tr><td><code id="load_linked_+3A_schema">schema</code></td>
<td>
<p>a list describing the schema/relationships between the files</p>
</td></tr>
<tr><td><code id="load_linked_+3A_con">con</code></td>
<td>
<p>a database connection to load the linked data into</p>
</td></tr>
<tr><td><code id="load_linked_+3A_name">name</code></td>
<td>
<p>the name of the data set collection</p>
</td></tr>
<tr><td><code id="load_linked_+3A_keep_con">keep_con</code></td>
<td>
<p>if <code>TRUE</code> data will remain in DB (use for very large data)</p>
</td></tr>
<tr><td><code id="load_linked_+3A_progress">progress</code></td>
<td>
<p>either <code>TRUE</code> or <code>FALSE</code> to enable/disable the default progress bar, or a list of three functions to <code>x &lt;- create(from, to)</code>, <code>set(x, i)</code>, and <code>destroy(x)</code> a progress bar.</p>
</td></tr>
<tr><td><code id="load_linked_+3A_...">...</code></td>
<td>
<p>additional arguments passed to data reading function <code>smart_read()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>inzdf</code> object
</p>

<hr>
<h2 id='load_rda'>Load object(s) from an Rdata file</h2><span id='topic+load_rda'></span>

<h3>Description</h3>

<p>Load object(s) from an Rdata file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_rda(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_rda_+3A_file">file</code></td>
<td>
<p>path to an rdata file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data frames, plus code
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>


<h3>See Also</h3>

<p><code><a href="#topic+save_rda">save_rda</a></code>
</p>

<hr>
<h2 id='make_names'>Make unique variable names</h2><span id='topic+make_names'></span>

<h3>Description</h3>

<p>Helper function to create new variable names that are unique
given a set of existing names (in a data set, for example).
If a variable name already exists, a number will be appended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_names(new, existing = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_names_+3A_new">new</code></td>
<td>
<p>a vector of proposed new variable names</p>
</td></tr>
<tr><td><code id="make_names_+3A_existing">existing</code></td>
<td>
<p>a vector of existing variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of unique variable names
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_names(c("var_x", "var_y"), c("var_x", "var_z"))

</code></pre>

<hr>
<h2 id='missing_to_cat'>Convert missing values to categorical variables</h2><span id='topic+missing_to_cat'></span>

<h3>Description</h3>

<p>Turn <code>&lt;NA&gt;</code> in categorical variables into <code>"(Missing)"</code>;
numeric variables will be converted to categorical variables where numeric
values as <code>"(Observed)"</code> and <code>NA</code> as <code>"(Missing)"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_to_cat(data, vars, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_to_cat_+3A_data">data</code></td>
<td>
<p>a dataframe with the columns to convert
its missing values into categorical</p>
</td></tr>
<tr><td><code id="missing_to_cat_+3A_vars">vars</code></td>
<td>
<p>a character vector of the variables in <code>data</code>
for conversion of missing values</p>
</td></tr>
<tr><td><code id="missing_to_cat_+3A_names">names</code></td>
<td>
<p>a character vector of names for the new variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing new columns of the converted variables
for the missing values with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>missing &lt;- missing_to_cat(iris, vars = c("Species", "Sepal.Length"))
cat(code(missing))
head(missing)

</code></pre>

<hr>
<h2 id='newdevice'>Open a New Graphics Device</h2><span id='topic+newdevice'></span>

<h3>Description</h3>

<p>Opens a new graphics device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newdevice(width = 7, height = 7, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newdevice_+3A_width">width</code></td>
<td>
<p>the width (in inches) of the new device</p>
</td></tr>
<tr><td><code id="newdevice_+3A_height">height</code></td>
<td>
<p>the height (in inches) of the new device</p>
</td></tr>
<tr><td><code id="newdevice_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the new device function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the system, difference devices are better.
The windows device works fine (for now), only attempt to speed up
any other devices that we're going to be using.
We speed them up by getting rid of buffering.
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='Not+20In+20operator'>Anti value matching</h2><span id='topic+Not+20In+20operator'></span><span id='topic++25notin+25'></span>

<h3>Description</h3>

<p>Anti value matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %notin% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Not+2B20In+2B20operator_+3A_x">x</code></td>
<td>
<p>vector of values to be matched</p>
</td></tr>
<tr><td><code id="Not+2B20In+2B20operator_+3A_table">table</code></td>
<td>
<p>vector of values to match against</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of same length as 'x', indicating if each
element does <strong>not</strong> exist in the table.
</p>

<hr>
<h2 id='Or+20NULL+20operator'>NULL or operator</h2><span id='topic+Or+20NULL+20operator'></span><span id='topic++25+7C+7C+25'></span>

<h3>Description</h3>

<p>NULL or operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %||% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Or+2B20NULL+2B20operator_+3A_a">a</code></td>
<td>
<p>an object, potentially NULL</p>
</td></tr>
<tr><td><code id="Or+2B20NULL+2B20operator_+3A_b">b</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a if a is not NULL, otherwise b
</p>

<hr>
<h2 id='print_code'>Tidy-printing of the code attached to an object</h2><span id='topic+print_code'></span>

<h3>Description</h3>

<p>Tidy-printing of the code attached to an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_code(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_code_+3A_x">x</code></td>
<td>
<p>a dataframe with code attached</p>
</td></tr>
<tr><td><code id="print_code_+3A_...">...</code></td>
<td>
<p>additional arguments passed to tidy_all_code()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for side-effect of printing code to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_agg &lt;- aggregate_data(iris, group_vars = "Species", summaries = "mean")
print_code(iris_agg)
</code></pre>

<hr>
<h2 id='random_sample'>Random sampling without replacement</h2><span id='topic+random_sample'></span>

<h3>Description</h3>

<p>Take a specified number of groups of observations with fixed group size
by sampling without replacement
and returns the result along with tidyverse code used to generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_sample(data, n, sample_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_sample_+3A_data">data</code></td>
<td>
<p>a dataframe to sample from</p>
</td></tr>
<tr><td><code id="random_sample_+3A_n">n</code></td>
<td>
<p>the number of groups to generate</p>
</td></tr>
<tr><td><code id="random_sample_+3A_sample_size">sample_size</code></td>
<td>
<p>the size of each group specified in <code>n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the random samples with
tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Owen Jin, Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs &lt;- random_sample(iris, n = 5, sample_size = 3)
cat(code(rs))
head(rs)

</code></pre>

<hr>
<h2 id='rank_vars'>Rank the data of numeric variables</h2><span id='topic+rank_vars'></span>

<h3>Description</h3>

<p>Rank the values of numeric variables, for example, in descending order,
and then returns the result along with tidyverse code used to generate it.
See <code><a href="dplyr.html#topic+row_number">row_number</a></code> and <code><a href="dplyr.html#topic+percent_rank">percent_rank</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_vars(data, vars, rank_type = c("min", "dense", "percent"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_vars_+3A_data">data</code></td>
<td>
<p>a dataframe with the variables to rank</p>
</td></tr>
<tr><td><code id="rank_vars_+3A_vars">vars</code></td>
<td>
<p>a character vector of numeric variables in <code>data</code>
to rank</p>
</td></tr>
<tr><td><code id="rank_vars_+3A_rank_type">rank_type</code></td>
<td>
<p>either <code>"min"</code>, <code>"dense"</code> or <code>"percent"</code>,
see <code><a href="dplyr.html#topic+row_number">row_number</a></code>, <code><a href="dplyr.html#topic+percent_rank">percent_rank</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original dataframe containing new columns with the ranks of the
variables in <code>vars</code> with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranked &lt;- rank_vars(iris, vars = c("Sepal.Length", "Petal.Length"))
cat(code(ranked))
head(ranked)

</code></pre>

<hr>
<h2 id='read_dictionary'>Data Dictionaries</h2><span id='topic+read_dictionary'></span><span id='topic+print.dictionary'></span><span id='topic++5B.dictionary'></span><span id='topic+apply_dictionary'></span><span id='topic+has_dictionary'></span><span id='topic+get_dictionary'></span>

<h3>Description</h3>

<p>This function reads a data dictionary from a file and attaches it to a
dataset. The attached data dictionary provides utility functions that can be
used by other methods, such as plots, to automatically create axes and more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dictionary(
  file,
  name = "name",
  type = "type",
  title = "title",
  description = "description",
  units = "units",
  codes = "codes",
  values = "values",
  level_separator = "|",
  ...
)

## S3 method for class 'dictionary'
print(x, kable = FALSE, include_other = TRUE, ...)

## S3 method for class 'dictionary'
x[i, ...]

apply_dictionary(data, dict)

has_dictionary(data)

get_dictionary(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_dictionary_+3A_file">file</code></td>
<td>
<p>The path to the file containing the data dictionary.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_name">name</code></td>
<td>
<p>The name of the column containing the variable name.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_type">type</code></td>
<td>
<p>The name of the column containing the variable type.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_title">title</code></td>
<td>
<p>The name of the column containing a short, human-readable title
for the variable. If blank, the variable name will be used instead.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_description">description</code></td>
<td>
<p>The name of the column containing the variable
description.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_units">units</code></td>
<td>
<p>The name of the column containing units (for numeric
variables only).</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_codes">codes</code></td>
<td>
<p>The name of the column containing factor codes (for categorical
variables only).</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_values">values</code></td>
<td>
<p>The name of the column containing factor values
corresponding to the codes. These should be in the same order
as the codes.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_level_separator">level_separator</code></td>
<td>
<p>The separator used to separate levels in <code>codes</code> and
<code>values</code> columns. The default separator is &quot;|&quot;.
Alternatively, you can provide a vector of length 2, where the first
element is used for <code>codes</code> and the second element for <code>values</code>.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code>smart_read</code>.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_x">x</code></td>
<td>
<p>A <code>dictionary</code> object.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_kable">kable</code></td>
<td>
<p>If <code>TRUE</code>, the output will be formatted using kable.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_include_other">include_other</code></td>
<td>
<p>If <code>TRUE</code>, additional variables will be included in
the output.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_i">i</code></td>
<td>
<p>Subset index.</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_data">data</code></td>
<td>
<p>A dataset (dataframe, tibble).</p>
</td></tr>
<tr><td><code id="read_dictionary_+3A_dict">dict</code></td>
<td>
<p>A dictionary (created using <code>read_dictionary()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dataset with the attached data dictionary.
</p>

<hr>
<h2 id='read_meta'>Read CSV with iNZight metadata</h2><span id='topic+read_meta'></span>

<h3>Description</h3>

<p>This function will read a CSV file with iNZight metadata in the header.
This allows plain text CSV files to be supplied with additional comments
that describe the structure of the data to make import and
data handling easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_meta(file, preview = FALSE, column_types, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_meta_+3A_file">file</code></td>
<td>
<p>the plain text file with metadata</p>
</td></tr>
<tr><td><code id="read_meta_+3A_preview">preview</code></td>
<td>
<p>logical, if <code>TRUE</code> only the first 10 rows are returned</p>
</td></tr>
<tr><td><code id="read_meta_+3A_column_types">column_types</code></td>
<td>
<p>optional column types</p>
</td></tr>
<tr><td><code id="read_meta_+3A_...">...</code></td>
<td>
<p>more arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main example is to define factor levels for an integer variable
in large data sets.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='read_text'>Read text as data</h2><span id='topic+read_text'></span>

<h3>Description</h3>

<p>The text can also be the value '&quot;clipboard&quot;' which
will use 'readr::clipboard()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_text(txt, delim = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_text_+3A_txt">txt</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="read_text_+3A_delim">delim</code></td>
<td>
<p>the delimiter to use, passed to 'readr::read_delim()'</p>
</td></tr>
<tr><td><code id="read_text_+3A_...">...</code></td>
<td>
<p>additional arguments passed to 'readr::read_delim()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='remove_rows'>Remove rows from data by row numbers</h2><span id='topic+remove_rows'></span>

<h3>Description</h3>

<p>This function filters a dataframe or a survey design object by removing
specified rows based on the provided row numbers. The resulting filtered
dataframe is returned, along with the tidyverse code used to generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_rows(data, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_rows_+3A_data">data</code></td>
<td>
<p>A dataframe or a survey design object to be filtered.</p>
</td></tr>
<tr><td><code id="remove_rows_+3A_rows">rows</code></td>
<td>
<p>A numeric vector of row numbers to be sliced off.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered dataframe with the tidyverse code attached.
</p>


<h3>Author(s)</h3>

<p>Owen Jin, Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- remove_rows(iris, rows = c(1, 4, 5))
cat(code(data))
head(data)

</code></pre>

<hr>
<h2 id='rename_levels'>Rename the levels of a categorical variable</h2><span id='topic+rename_levels'></span>

<h3>Description</h3>

<p>Rename the levels of a categorical variables, and returns the result
along with tidyverse code used to generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_levels(data, var, tobe_asis, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_levels_+3A_data">data</code></td>
<td>
<p>a dataframe with the column to be renamed</p>
</td></tr>
<tr><td><code id="rename_levels_+3A_var">var</code></td>
<td>
<p>a character of the categorical variable to rename</p>
</td></tr>
<tr><td><code id="rename_levels_+3A_tobe_asis">tobe_asis</code></td>
<td>
<p>a named list of the old level names assigned
to the new level names
ie. list('new level names' = 'old level names')</p>
</td></tr>
<tr><td><code id="rename_levels_+3A_name">name</code></td>
<td>
<p>a name for the new variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing a new column of the renamed categorical
variable with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>renamed &lt;- rename_levels(iris,
    var = "Species",
    tobe_asis = list(set = "setosa", ver = "versicolor")
)
cat(code(renamed))
head(renamed)

</code></pre>

<hr>
<h2 id='rename_vars'>Rename column names</h2><span id='topic+rename_vars'></span>

<h3>Description</h3>

<p>Rename columns of a dataset with desired names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_vars(data, tobe_asis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_vars_+3A_data">data</code></td>
<td>
<p>a dataframe with columns to rename</p>
</td></tr>
<tr><td><code id="rename_vars_+3A_tobe_asis">tobe_asis</code></td>
<td>
<p>a named list of the old column names assigned
to the new column names
ie. list('new column names' = 'old column names')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing new columns of the renamed columns
with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>renamed &lt;- rename_vars(iris, list(
    sepal_length = "Sepal.Length",
    sepal_width = "Sepal.Width",
    petal_length = "Petal.Length",
    petal_width = "Petal.Width"
))
cat(code(renamed))
head(renamed)

</code></pre>

<hr>
<h2 id='reorder_levels'>Reorder the levels of a categorical variable</h2><span id='topic+reorder_levels'></span>

<h3>Description</h3>

<p>Reorder the levels of a categorical variable either manually or automatically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_levels(
  data,
  var,
  new_levels = NULL,
  auto = c("freq", "order", "seq"),
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder_levels_+3A_data">data</code></td>
<td>
<p>a dataframe to reorder</p>
</td></tr>
<tr><td><code id="reorder_levels_+3A_var">var</code></td>
<td>
<p>a categorical variable to reorder</p>
</td></tr>
<tr><td><code id="reorder_levels_+3A_new_levels">new_levels</code></td>
<td>
<p>a character vector of the new factor order;
overrides <code>auto</code> if not <code>NULL</code></p>
</td></tr>
<tr><td><code id="reorder_levels_+3A_auto">auto</code></td>
<td>
<p>only meaningful if <code>new_levels</code> is <code>NULL</code>: the method
to auto-reorder the levels, see <code><a href="forcats.html#topic+fct_inorder">fct_inorder</a></code></p>
</td></tr>
<tr><td><code id="reorder_levels_+3A_name">name</code></td>
<td>
<p>name for the new variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original dataframe containing a new column of the reordered
categorical variable with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reordered &lt;- reorder_levels(iris,
    var = "Species",
    new_levels = c("versicolor", "virginica", "setosa")
)
cat(code(reordered))
head(reordered)

reordered &lt;- reorder_levels(iris,
    var = "Species",
    auto = "freq"
)
cat(code(reordered))
head(reordered)

</code></pre>

<hr>
<h2 id='reshape_data'>Reshaping dataset from wide to long or from long to wide</h2><span id='topic+reshape_data'></span>

<h3>Description</h3>

<p>Reshaping dataset from wide to long or from long to wide
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_data(
  data,
  data_to = c("long", "wide"),
  cols,
  names_to = "name",
  values_to = "value",
  names_from = "name",
  values_from = "value"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_data_+3A_data">data</code></td>
<td>
<p>a dataset to reshape</p>
</td></tr>
<tr><td><code id="reshape_data_+3A_data_to">data_to</code></td>
<td>
<p>whether the target dataset is <code>long</code> or <code>wide</code></p>
</td></tr>
<tr><td><code id="reshape_data_+3A_cols">cols</code></td>
<td>
<p>columns to gather together (for wide to long)</p>
</td></tr>
<tr><td><code id="reshape_data_+3A_names_to">names_to</code></td>
<td>
<p>name for new column containing old names (for wide to long)</p>
</td></tr>
<tr><td><code id="reshape_data_+3A_values_to">values_to</code></td>
<td>
<p>name for new column containing old values (for wide to long)</p>
</td></tr>
<tr><td><code id="reshape_data_+3A_names_from">names_from</code></td>
<td>
<p>column to spread out (for long to wide)</p>
</td></tr>
<tr><td><code id="reshape_data_+3A_values_from">values_from</code></td>
<td>
<p>values to be put in the spread columns (for long to wide)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>reshaped dataset
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>

<hr>
<h2 id='save_rda'>Save an object with, optionally, a (valid) name</h2><span id='topic+save_rda'></span>

<h3>Description</h3>

<p>Save an object with, optionally, a (valid) name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_rda(data, file, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_rda_+3A_data">data</code></td>
<td>
<p>the data frame to save</p>
</td></tr>
<tr><td><code id="save_rda_+3A_file">file</code></td>
<td>
<p>where to save it</p>
</td></tr>
<tr><td><code id="save_rda_+3A_name">name</code></td>
<td>
<p>optional, the name the data will have in the rda file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, should be TRUE, along with code for the save
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load_rda">load_rda</a></code>
</p>

<hr>
<h2 id='select'>Select</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>Select
</p>

<hr>
<h2 id='select_vars'>Select variables from a dataset</h2><span id='topic+select_vars'></span>

<h3>Description</h3>

<p>Select a (reordered) subset of variables from a subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_vars(data, keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_vars_+3A_data">data</code></td>
<td>
<p>the dataset</p>
</td></tr>
<tr><td><code id="select_vars_+3A_keep">keep</code></td>
<td>
<p>vector of variable names to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with tidyverse code attribute
</p>


<h3>Author(s)</h3>

<p>Tom Elliott, Zhaoming Su
</p>


<h3>Examples</h3>

<pre><code class='language-R'>select_vars(iris, c("Sepal.Length", "Species", "Sepal.Width"))
</code></pre>

<hr>
<h2 id='separate_var'>Separate columns</h2><span id='topic+separate_var'></span>

<h3>Description</h3>

<p>Separate columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_var(data, var, by, names, into = c("cols", "rows"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_var_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="separate_var_+3A_var">var</code></td>
<td>
<p>name of variable to be separated</p>
</td></tr>
<tr><td><code id="separate_var_+3A_by">by</code></td>
<td>
<p>a string as delimiter between values (separate by delimiter) or
integer(s) as number of characters to split by (separate by position),
the length of <code>by</code> should be <code>1</code> unless <code>by</code> is integer
and <code>into = "cols"</code>; if <code>by</code> is a non-integer numeric vector
its values will be rounded down to the nearest integer</p>
</td></tr>
<tr><td><code id="separate_var_+3A_names">names</code></td>
<td>
<p>for <code>into = "cols"</code>, a character vector of output column
names; use <code>NA</code> if there are components that you don't want to
appear in the output; the number of non-<code>NA</code> elements determines
the number of new columns in the result</p>
</td></tr>
<tr><td><code id="separate_var_+3A_into">into</code></td>
<td>
<p>whether to split into new rows or columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Separated dataset
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>

<hr>
<h2 id='sheets'>List available sheets within a file</h2><span id='topic+sheets'></span>

<h3>Description</h3>

<p>Useful when reading an Excel file to quickly check what
other sheets are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sheets(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sheets_+3A_x">x</code></td>
<td>
<p>a dataframe, presumably returned by <code>smart_read</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sheet names, or NULL if the file was not an Excel workbook
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cas_file &lt;- system.file("extdata/cas500.xls", package = "iNZightTools")
cas &lt;- smart_read(cas_file)
sheets(cas)
</code></pre>

<hr>
<h2 id='smart_read'>Read a data file</h2><span id='topic+smart_read'></span>

<h3>Description</h3>

<p>A simple function that imports a file without the users needing to
specify information about the file type (see Details for more).
The <code>smart_read()</code> function uses the file's extension to determine
the appropriate function to read the data.
Additionally, characters are converted to factors by default,
mostly for compatibility with iNZight (https://inzight.nz).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_read(
  file,
  ext = tools::file_ext(file),
  preview = FALSE,
  column_types = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smart_read_+3A_file">file</code></td>
<td>
<p>the file path to read</p>
</td></tr>
<tr><td><code id="smart_read_+3A_ext">ext</code></td>
<td>
<p>file extension, namely &quot;csv&quot; or &quot;txt&quot;</p>
</td></tr>
<tr><td><code id="smart_read_+3A_preview">preview</code></td>
<td>
<p>logical, if <code>TRUE</code> only the first few rows of
the data will be returned</p>
</td></tr>
<tr><td><code id="smart_read_+3A_column_types">column_types</code></td>
<td>
<p>vector of column types (see ?readr::read_csv)</p>
</td></tr>
<tr><td><code id="smart_read_+3A_...">...</code></td>
<td>
<p>additional parameters passed to read_* functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code>smart_read()</code> understands the following file types:
</p>

<ul>
<li><p> delimited (.csv, .txt)
</p>
</li>
<li><p> Excel (.xls, .xlsx)
</p>
</li>
<li><p> SPSS (.sav)
</p>
</li>
<li><p> Stata (.dta)
</p>
</li>
<li><p> SAS (.sas7bdat, .xpt)
</p>
</li>
<li><p> R data (.rds)
</p>
</li>
<li><p> JSON (.json)
</p>
</li></ul>



<h3>Value</h3>

<p>A dataframe with some additional attributes:
</p>

<ul>
<li> <p><code>name</code> is the name of the file
</p>
</li>
<li> <p><code>code</code> contains the 'tidyverse' code used to read the data
</p>
</li>
<li> <p><code>sheets</code> contains names of sheets if 'file' is an Excel file (can be retrieved using the <code>sheets()</code> helper function)
</p>
</li></ul>



<h3>Reading delimited files</h3>

<p>By default, <code>smart_read()</code> will detect the delimiter used in the file
if the argument <code>delimiter = NULL</code> is passed in (the default).
If this does not work, you can override this argument:
</p>
<div class="sourceCode"><pre>smart_read('path/to/file', delimiter = '+')
</pre></div>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='sort_vars'>Sort data by variables</h2><span id='topic+sort_vars'></span>

<h3>Description</h3>

<p>Sorts a dataframe by one or more variables, and returns the result
along with tidyverse code used to generate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_vars(data, vars, asc = rep(TRUE, length(vars)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_vars_+3A_data">data</code></td>
<td>
<p>a dataframe to sort</p>
</td></tr>
<tr><td><code id="sort_vars_+3A_vars">vars</code></td>
<td>
<p>a character vector of variable names to sort by</p>
</td></tr>
<tr><td><code id="sort_vars_+3A_asc">asc</code></td>
<td>
<p>logical, length of 1 or same length as <code>vars</code>.
If <code>TRUE</code> (default), then sorted in ascending order,
otherwise descending.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Owen Jin, Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sorted &lt;- sort_vars(iris,
    vars = c("Sepal.Width", "Sepal.Length"),
    asc = c(TRUE, FALSE)
)
cat(code(sorted))
head(sorted)

</code></pre>

<hr>
<h2 id='standardize_vars'>Standardize the data of a numeric variable</h2><span id='topic+standardize_vars'></span>

<h3>Description</h3>

<p>Centre then divide by the standard error of the values in a numeric variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_vars(data, vars, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_vars_+3A_data">data</code></td>
<td>
<p>a dataframe with the columns to standardize</p>
</td></tr>
<tr><td><code id="standardize_vars_+3A_vars">vars</code></td>
<td>
<p>a character vector of the numeric variables in <code>data</code>
to standardize</p>
</td></tr>
<tr><td><code id="standardize_vars_+3A_names">names</code></td>
<td>
<p>names for the created variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original dataframe containing new columns of the standardized
variables with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>standardized &lt;- standardize_vars(iris, var = c("Sepal.Width", "Petal.Width"))
cat(code(standardized))
head(standardized)

</code></pre>

<hr>
<h2 id='str_c'>str_c operator</h2><span id='topic+str_c'></span>

<h3>Description</h3>

<p>str_c operator
</p>

<hr>
<h2 id='survey_IQR'>Interquartile range function for surveys</h2><span id='topic+survey_IQR'></span>

<h3>Description</h3>

<p>Calculates the interquartile range from complex survey data.
A wrapper for taking differences of <code>svyquantile</code> at 0.25 and 0.75 quantiles,
and meant to be called from within <code>summarize</code> (see <a href="srvyr.html#topic+srvyr">srvyr</a> package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_IQR(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_IQR_+3A_x">x</code></td>
<td>
<p>A variable or expression</p>
</td></tr>
<tr><td><code id="survey_IQR_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, if <code>TRUE</code> missing values are removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of interquartile ranges
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
library(srvyr)
data(api)

dstrata &lt;- apistrat %&gt;%
    as_survey(strata = stype, weights = pw)

dstrata %&gt;%
    summarise(api99_iqr = survey_IQR(api99))

</code></pre>

<hr>
<h2 id='tidy_all_code'>iNZight Tidy Code</h2><span id='topic+tidy_all_code'></span>

<h3>Description</h3>

<p>Tidy code with correct indents and limit the code to the specific width
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_all_code(x, width = 80, indent = 4, outfile, incl_library = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_all_code_+3A_x">x</code></td>
<td>
<p>character string or file name of the file containing messy code</p>
</td></tr>
<tr><td><code id="tidy_all_code_+3A_width">width</code></td>
<td>
<p>the width of a line</p>
</td></tr>
<tr><td><code id="tidy_all_code_+3A_indent">indent</code></td>
<td>
<p>how many spaces for one indent</p>
</td></tr>
<tr><td><code id="tidy_all_code_+3A_outfile">outfile</code></td>
<td>
<p>the file name of the file containing formatted code</p>
</td></tr>
<tr><td><code id="tidy_all_code_+3A_incl_library">incl_library</code></td>
<td>
<p>logical, if true, the output code will contain library name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formatted code, optionally written to 'outfile'
</p>


<h3>Author(s)</h3>

<p>Tom Elliott, Lushi Cai
</p>

<hr>
<h2 id='transform_vars'>Transform data of numeric variables</h2><span id='topic+transform_vars'></span>

<h3>Description</h3>

<p>Transform the values of numeric variables by applying
a mathematical function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_vars(data, vars, fn, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_vars_+3A_data">data</code></td>
<td>
<p>a dataframe with the variables to transform</p>
</td></tr>
<tr><td><code id="transform_vars_+3A_vars">vars</code></td>
<td>
<p>a character of the numeric variables in <code>data</code> to transform</p>
</td></tr>
<tr><td><code id="transform_vars_+3A_fn">fn</code></td>
<td>
<p>the name (a string) of a valid R function</p>
</td></tr>
<tr><td><code id="transform_vars_+3A_names">names</code></td>
<td>
<p>the names of the new variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original dataframe containing the new columns of the transformed
variable with tidyverse code attached
</p>


<h3>Author(s)</h3>

<p>Zhaoming Su
</p>


<h3>See Also</h3>

<p><code><a href="#topic+code">code</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transformed &lt;- transform_vars(iris,
    var = "Petal.Length",
    fn = "log"
)
cat(code(transformed))
head(transformed)

</code></pre>

<hr>
<h2 id='validation_details'>Details of Validation Rule Results</h2><span id='topic+validation_details'></span>

<h3>Description</h3>

<p>Generates the more detailed text required for the details section in
<code>iNZValidateWin</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation_details(cf, v, var, id.var, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validation_details_+3A_cf">cf</code></td>
<td>
<p>Confrontation object from <code>validate::confront()</code></p>
</td></tr>
<tr><td><code id="validation_details_+3A_v">v</code></td>
<td>
<p>Validator that generated <code>cf</code></p>
</td></tr>
<tr><td><code id="validation_details_+3A_var">var</code></td>
<td>
<p>Rule name to give details about</p>
</td></tr>
<tr><td><code id="validation_details_+3A_id.var">id.var</code></td>
<td>
<p>Variable name denoting a unique identifier
for each observation</p>
</td></tr>
<tr><td><code id="validation_details_+3A_df">df</code></td>
<td>
<p>The dataset that was confronted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector giving each line of the summary detail text
</p>


<h3>Author(s)</h3>

<p>Daniel Barnett
</p>

<hr>
<h2 id='validation_summary'>Validation Confrontation Summary</h2><span id='topic+validation_summary'></span>

<h3>Description</h3>

<p>Generates a summary of a confrontation which gives basic information about
each validation rule tested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validation_summary(cf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validation_summary_+3A_cf">cf</code></td>
<td>
<p>Confrontation object from <code>validate::confront()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with number of tests performed, number of
passes, number of failures, and failure percentage for each validation rule.
</p>


<h3>Author(s)</h3>

<p>Daniel Barnett
</p>

<hr>
<h2 id='vartype'>Get variable type name</h2><span id='topic+vartype'></span>

<h3>Description</h3>

<p>Get variable type name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vartype(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vartype_+3A_x">x</code></td>
<td>
<p>vector to be examined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of the variable's type
</p>


<h3>Author(s)</h3>

<p>Tom Elliott
</p>

<hr>
<h2 id='vartypes'>Get all variable types from data object</h2><span id='topic+vartypes'></span>

<h3>Description</h3>

<p>Get all variable types from data object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vartypes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vartypes_+3A_x">x</code></td>
<td>
<p>data object (data.frame or inzdf)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of variable types
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
