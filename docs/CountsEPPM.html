<!DOCTYPE html><html lang="en"><head><title>Help for package CountsEPPM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CountsEPPM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CountsEPPM-package'>
<p>Fitting of EPPM models to count and binary data.</p></a></li>
<li><a href='#ceriodaphnia.group'>
<p>Ceriodaphnia data</p></a></li>
<li><a href='#coef.CountsEPPM'>
<p>Extraction of model coefficients for CountsEPPM Objects</p></a></li>
<li><a href='#cooks.distance.CountsEPPM'>
<p>Cook's distance for CountsEPPM Objects</p></a></li>
<li><a href='#CountsEPPM'>
<p>Fitting of EPPM models to count data.</p></a></li>
<li><a href='#EPPMprob'>
<p>Calculation of vector of probabilities for a extended Poisson process model (EPPM).</p></a></li>
<li><a href='#Faddyprob.general'>
<p>Calculation of vector of probabilities for a Faddy distribution.</p></a></li>
<li><a href='#Faddyprob.limiting'>
<p>Calculation of vector of probabilities for the limiting form of the Faddy distribution.</p></a></li>
<li><a href='#fitted.CountsEPPM'>
<p>Extraction of fitted values from CountsEPPM Objects</p></a></li>
<li><a href='#hatvalues.CountsEPPM'>
<p>Extraction of hat matrix values from CountsEPPM Objects</p></a></li>
<li><a href='#herons.case'>
<p>Green-backed herons as two groups</p></a></li>
<li><a href='#herons.group'>
<p>Green-backed herons as two groups</p></a></li>
<li><a href='#LL.gradient'>
<p>Function used to calculate the first derivatives of the log likelihood with respect to the model parameters.</p></a></li>
<li><a href='#LL.Regression.Counts'>
<p>Function called by optim to calculate the log likelihood from the probabilities and hence perform the fitting of</p>
regression models to the binary data.</a></li>
<li><a href='#logLik.CountsEPPM'>
<p>Method for CountsEPPM object</p></a></li>
<li><a href='#LRTruncation'>
<p>Probabilities for distributions truncated on the left (lower) and/or right (upper).</p></a></li>
<li><a href='#Luningetal.litters'>
<p>Number of trials (implantations) in data of Luning, et al. (1966)</p></a></li>
<li><a href='#Model.Counts'>
<p>Function for obtaining output from distributional models.</p></a></li>
<li><a href='#Model.Faddy'>
<p>Function for Faddy distribution with log link.</p></a></li>
<li><a href='#Model.FaddyJMV.general'>
<p>Function for a general Faddy distribution modeled by means and scale-factors.</p></a></li>
<li><a href='#Model.FaddyJMV.limiting'>
<p>Function to fit the limiting form of a Faddy distribution for under-dispersed counts.</p></a></li>
<li><a href='#plot.CountsEPPM'>
<p>Diagnostic Plots for CountsEPPM Objects</p></a></li>
<li><a href='#predict.CountsEPPM'>
<p>Prediction Method for CountsEPPM Objects</p></a></li>
<li><a href='#print.CountsEPPM'>
<p>Printing of CountsEPPM Objects</p></a></li>
<li><a href='#print.summaryCountsEPPM'>
<p>Printing of summaryCountsEPPM Objects</p></a></li>
<li><a href='#residuals.CountsEPPM'>
<p>Residuals for CountsEPPM Objects</p></a></li>
<li><a href='#summary.CountsEPPM'>
<p>Method for CountsEPPM object</p></a></li>
<li><a href='#takeover.bids.case'>
<p>Takeover bids data.</p></a></li>
<li><a href='#Titanic.survivors.case'>
<p>Titanic survivors data</p></a></li>
<li><a href='#vcov.CountsEPPM'>
<p>Variance/Covariance Matrix for Coefficients</p></a></li>
<li><a href='#waldtest.CountsEPPM'>
<p>Wald Test of Nested Models for CountsEPPM Objects</p></a></li>
<li><a href='#Williams.litters'>
<p>Number of trials (implantations) of data of Williams (1996).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mean and Variance Modeling of Count Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula, expm, numDeriv, stats, lmtest, grDevices, graphics</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-09</td>
</tr>
<tr>
<td>Author:</td>
<td>David M Smith, Malcolm J Faddy</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David M. Smith &lt;dmccsmith@verizon.net&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Modeling under- and over-dispersed count data using extended Poisson process models as in the article Faddy and Smith (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v069.i06">doi:10.18637/jss.v069.i06</a>&gt; .</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 15:44:51 UTC; dmccs</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 12:03:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='CountsEPPM-package'>
Fitting of EPPM models to count and binary data.
</h2><span id='topic+CountsEPPM-package'></span>

<h3>Description</h3>

<p>Fits regression models to under- and over-dispersed count data using extended Poisson process models.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CountsEPPM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-03-04</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Using Generalized Linear Model (GLM) terminology, the functions utilize linear predictors for mean and variance with log link functions
to fit the regression models. Smith and Faddy (2016) gives further details about the package as well as examples of its use.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>
<p>Smith D, Faddy M. (2016). Mean and Variance Modeling of Under- and Overdispersed Count Data. 
<em>Journal of Statistical Software</em>, <b>69</b>(6), 1-23. <a href="https://doi.org/10.18637/jss.v069.i06">doi:10.18637/jss.v069.i06</a>.
</p>
<p>Zeileis A, Croissant Y. (2010). Extended Model Formulas in R: Multiple Parts and Multiple Responses.
<em>Journal of Statistical Software</em>, <b>34</b>(1), 1-13. <a href="https://doi.org/10.18637/jss.v034.i01">doi:10.18637/jss.v034.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(herons.group)
initial &lt;- c(1.9871533,1.9900881,3.6841305,0.4925816)
names(initial) &lt;- c("Adult mean","Immature mean", "Variance","log(b)")
output.fn  &lt;- CountsEPPM(number.attempts~0+group | 1, herons.group,initial=initial)
print(output.fn)
</code></pre>

<hr>
<h2 id='ceriodaphnia.group'>
Ceriodaphnia data
</h2><span id='topic+ceriodaphnia.group'></span>

<h3>Description</h3>

<p>Ceriodaphnia dubia are water fleas used to test the impact of effluents on water quality. The data are counts of young at varying effluent concentrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ceriodaphnia.group)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 5
$ vdose       : num [1:5] 0 1.56 3.12 6.25 12.5
$ vdose2      : num [1:5] 0 2.44 9.77 39.06 156.25
$ fdose       : Factor w/ 5 levels &quot;0&quot;,&quot;1.5625&quot;,&quot;3.125&quot;,..: 1 2 3 4 5
$ twofdose    : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 2 2 1
$ number.young:List of 5
..$ : num [1:32] 0 0 0 0 0 0 0 0 0 0 ...
..$ : num [1:36] 0 0 0 0 0 0 0 0 0 0 ...
..$ : num [1:45] 0 0 0 0 0 0 0 0 0 0 ...
..$ : num [1:37] 0 0 0 0 0 0 0 0 0 0 ...
..$ : num [1:17] 0 0 1 0 0 0 0 3 0 0 ...
</p>


<h3>Details</h3>

<p>The data is used in Faddy and Smith (2011) as an example. Faddy and Smith (2011) is the main reference for the methods implemented. The data are grouped into number of fleas for each count value.
</p>


<h3>Source</h3>

<p>Bailer, A., Oris, J. (1997). Estimating inhibition concentrations for different response scales using Generalized Linear Models. 
<em>Environmental Toxicology and Chemistry</em>, <b>16</b>, 1554-1559. <a href="https://doi.org/10.1002/etc.5620160732">doi:10.1002/etc.5620160732</a>.
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ceriodaphnia.group)
print(ceriodaphnia.group)
</code></pre>

<hr>
<h2 id='coef.CountsEPPM'>
Extraction of model coefficients for CountsEPPM Objects
</h2><span id='topic+coef.CountsEPPM'></span>

<h3>Description</h3>

<p>Extract the regression model coefficients from models of class &quot;BinaryEPMM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
coef(object, prtpar = c("full", "mean", "scale.factor"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.CountsEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="coef.CountsEPPM_+3A_prtpar">prtpar</code></td>
<td>

<p>character indicating coefficients of the fitted model to be output:
all coefficients (&quot;full&quot;),
coefficients of the model for probability of success (&quot;mean&quot;),
coefficients of the model for scale-factor (&quot;scale.factor&quot;)
</p>
</td></tr>
<tr><td><code id="coef.CountsEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of a set of standard extractor functions for fitted model objects of class
&quot;CountsEPPM.
</p>


<h3>Value</h3>

<p>Vector of coefficients of fitted regression model.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(herons.group)
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
coef(output.fn, prtpar = "full")
coef(output.fn, prtpar = "mean")
coef(output.fn, prtpar = "scale.factor")
</code></pre>

<hr>
<h2 id='cooks.distance.CountsEPPM'>
Cook's distance for CountsEPPM Objects
</h2><span id='topic+cooks.distance.CountsEPPM'></span>

<h3>Description</h3>

<p>Calculates Cook's distances for CountsEPPM objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
cooks.distance(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cooks.distance.CountsEPPM_+3A_model">model</code></td>
<td>

<p>fitted model object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="cooks.distance.CountsEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cook's distances as in GLMs.
</p>


<h3>Value</h3>

<p>A vector of Cook's distances.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("herons.group") 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
cooks.distance(output.fn)
</code></pre>

<hr>
<h2 id='CountsEPPM'>
Fitting of EPPM models to count data.
</h2><span id='topic+CountsEPPM'></span>

<h3>Description</h3>

<p>Fits regression models to under- and over-dispersed count data using extended Poisson process models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountsEPPM(formula, data, subset=NULL, na.action=NULL, weights=NULL,
model.type = "mean and scale-factor", model.name = "general", 
link="log", initial = NULL, ltvalue = NA, utvalue = NA, 
method = "Nelder-Mead", control = NULL, fixed.b = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountsEPPM_+3A_formula">formula</code></td>
<td>

<p>Formulae for the mean and variance. The package 'Formula' of Zeileis and Croissant (2010) which allows multiple parts and multiple responses is used. 'formula' should consist of a left hand side (lhs) of single response variable and a right hand side (rhs) of one or two sets of variables for the linear predictors for the mean and (if two sets) the variance. This is as used for the R function 'glm' and also, for example, as for the package 'betareg' (Cribari-Neto and Zeileis, 2010). The function identifies from the argument data whether a data frame (as for use of 'glm') or a list (as required in Version 1.0 of this function) has been input. The list should be exactly the same as for a data frame except that the response variable is a list of vectors of frequency distributions rather than a vector of single counts as for the data frame. As with version 1.0 of this function, the subordinate functions fit models where the response variables are 'mean.obs', 'variance.obs' or 'scalef.obs' according to the model type being fitted. The values for these response variables are not input as part of 'data', they are calculated within the function from a list of grouped count data input. If the 'model.type' is 'mean only' 'formula' consists of a lhs of the response variable and and a rhs of the terms of the linear predictor for the mean model. If the 'model.type' is 'mean and variance' and 'scale.factor.model'='no' there are two set of terms in the rhs of 'formula' i.e., 'mean.obs' and 'variance.obs' together with the two sets of terms for the linear predictors of mean and variance. If 'scale.factor.model'='yes' the second response variable used by the subordinate functions would be 'scalef.obs'.     
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_data">data</code></td>
<td>

<p>'data' should be either a data frame (as for use of 'glm') or a list (as required in Version 1.0 of this function). The list should be exactly the same as for a data frame except that the response variable is a list of vectors of frequency distributions rather than a vector of single counts as for the data frame. Within the function a working list 'listcounts' and data frames with components such as 'mean.obs', 'variance.obs', 'scalef.obs', 'covariates', 'offset.mean', 'offset.variance' are set up . The component 'covariates' is a data frame of vectors of covariates in the model. The component 'listcounts' is a list of vectors of the grouped counts, or the single counts in grouped form if 'data' is a data frame. 
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_subset">subset</code></td>
<td>

<p>Subsetting commands.
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_na.action">na.action</code></td>
<td>

<p>Action taken for NAs in data.
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_weights">weights</code></td>
<td>

<p>Vector of list of lists of weights.
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. 'mean only' or 'mean and variance'. The 'mean only' value fits a linear predictor function to the parameter 'a' in equation (3) of Faddy and Smith (2011). If the model type being fitted is Poisson modeling 'a' is the same as modeling the mean. For the negative binomial the mean is 'b'(exp('a')-1), 'b' also being as in equation (3) of Faddy and Smith (2011). The 'mean and variance' value fits linear predictor functions to both the mean and the variance. 
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_model.name">model.name</code></td>
<td>

<p>If model.type is 'mean only' the model being fitted is one of the three 'Poisson', 'negative binomial', 'Faddy distribution'. If model.type is 'mean and scale-factor' the model being fitted is either 'general' i.e. as equations (4) and (6) of Faddy and Smith (2011), or 'limiting' i.e. as equations (9) and (10) of Faddy and Smith (2011).
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_link">link</code></td>
<td>

<p>Takes one of one values i.e., 'log'. The default is 'log'. 
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_initial">initial</code></td>
<td>

<p>This is a vector of initial values for the parameters. If this vector is NULL then initial values based on a fitting Poisson models using 'glm' are calculated within the function.
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_ltvalue">ltvalue</code></td>
<td>

<p>Lower truncation value.
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_utvalue">utvalue</code></td>
<td>

<p>Upper truncation value.
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_method">method</code></td>
<td>

<p>Optimization method takes one of the two values 'Nelder-Mead' or 'BFGS' these being options for the <code>optim</code> function.
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_control">control</code></td>
<td>

<p>'control' is a list of control parameters as used in 'optim' or 'nlm'. If this list is NULL the defaults for 'optim' are set as 'control   &lt;- list(fnscale=-1,trace=0,maxit=1000)' and for 'nlm' are set as 'control &lt;- list(fscale=1,print.level=0,stepmax=1,gradtol=1e-8,steptol=1e-10,iterlim=500)'. For 'optim' the control parameters that can be changed by inputting a variable length list are 'fnscale, trace, maxit, abstol, reltol, alpha, beta, gamma'. For 'nlm' the parameters are 'fscale, print.level, stepmax, gradtol,steptol, iterlim'. Details of 'optim' and 'nlm' and their control parameters are available in the online R help manuals.
</p>
</td></tr>
<tr><td><code id="CountsEPPM_+3A_fixed.b">fixed.b</code></td>
<td>

<p>Set to the value of the parameter b if a fixed.b model is being used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Smith and Faddy (2016) gives further details as well as examples of use.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>model.type</code></td>
<td>
<p>The type of model being fitted</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model being fitted</p>
</td></tr>
<tr><td><code>covariates.matrix.mean</code></td>
<td>
<p>The design matrix for the means</p>
</td></tr>
<tr><td><code>covariates.matrix.variance</code></td>
<td>
<p>The design matrix for the variances</p>
</td></tr>
<tr><td><code>offset.mean</code></td>
<td>
<p>The offset vector for the means</p>
</td></tr>
<tr><td><code>offset.variance</code></td>
<td>
<p>The offset vector for the variances</p>
</td></tr>
<tr><td><code>ltvalue</code></td>
<td>
<p>The lower truncation value</p>
</td></tr>
<tr><td><code>utvalue</code></td>
<td>
<p>The upper truncation value</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>Estimates of model parameters</p>
</td></tr>
<tr><td><code>vnmax</code></td>
<td>
<p>Vector of maximums of grouped count data vectors in list.counts</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>
<p>Loglikelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>
<p>Grun B, Kosmidis I, Zeileis A. (2012). Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1-25. <a href="https://doi.org/10.18637/jss.v048.i11">doi:10.18637/jss.v048.i11</a>.
</p>
<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>
<p>Smith D, Faddy M. (2016). Mean and Variance Modeling of Under- and Overdispersed Count Data. 
<em>Journal of Statistical Software</em>, <b>69</b>(6), 1-23. <a href="https://doi.org/10.18637/jss.v069.i06">doi:10.18637/jss.v069.i06</a>.
</p>
<p>Zeileis A, Croissant Y. (2010). Extended Model Formulas in R: Multiple Parts and Multiple Responses.
<em>Journal of Statistical Software</em>, <b>34</b>(1), 1-13. <a href="https://doi.org/10.18637/jss.v034.i01">doi:10.18637/jss.v034.i01</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(herons.group)
initial &lt;- c(0.5623042, 0.4758576, 0.5082486)
names(initial) &lt;- c("Adult mean", "Immature mean", "log(b)")
output.fn &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model = 'negative binomial',
 initial = initial)
print(output.fn)
</code></pre>

<hr>
<h2 id='EPPMprob'>
Calculation of vector of probabilities for a extended Poisson process model (EPPM).
</h2><span id='topic+EPPMprob'></span>

<h3>Description</h3>

<p>Calculates a vector of probabilities given a vector of rates vlambda using the matrix exponential function from Bates and Maechler (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPPMprob(vlambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EPPMprob_+3A_vlambda">vlambda</code></td>
<td>

<p>vlambda is a vector of rates of an extended Poisson process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned is a vector of probabilities.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Bates D, Maechler M (2023). Matrix: Sparse and Dense Matrix Classes and Methods. 
R package version 1.6-4, <a href="https://CRAN.R-project.org/package=Matrix">https://CRAN.R-project.org/package=Matrix</a>. 
</p>

<hr>
<h2 id='Faddyprob.general'>
Calculation of vector of probabilities for a Faddy distribution.
</h2><span id='topic+Faddyprob.general'></span>

<h3>Description</h3>

<p>Given a vector of parameters and a scalar of the maximum count the function calculates the vector of lambdas for a Faddy distribution and returns a vector of probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Faddyprob.general(parameter, nmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Faddyprob.general_+3A_parameter">parameter</code></td>
<td>

<p>A vector of the parameters of the Faddy distribution.
</p>
</td></tr>
<tr><td><code id="Faddyprob.general_+3A_nmax">nmax</code></td>
<td>

<p>The value of the maximum count.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probabilities
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.counts=c(rep(0,5),352,479,530,291,101,17)
nmax   &lt;- length(all.counts) - 1
parameter &lt;- c(exp(53.047752),exp(3.801599),-13.205655)
names(parameter) &lt;- c("a","b","c") 
probability &lt;- Faddyprob.general(parameter,nmax) 
print(probability)
</code></pre>

<hr>
<h2 id='Faddyprob.limiting'>
Calculation of vector of probabilities for the limiting form of the Faddy distribution.
</h2><span id='topic+Faddyprob.limiting'></span>

<h3>Description</h3>

<p>Given a vector of parameters and a scalar of the maximum count the function calculates the vector of lambdas for the limiting form of a  Faddy distribution applicable to under-dispersed data and returns a vector of probabilities. This limiting form is described in Faddy and Smith (2011) and it is appropriate for use on count data displaying under dispersion with respect to the Poisson. If the general model of Faddyprob.general is fitted to such under-dispersed data and a large value of b results, possibly with the hessian at the apparent maximum being poorly conditioned, it is possible that the limiting model having one less parameter than the general model will fit better.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Faddyprob.limiting(parameter, nmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Faddyprob.limiting_+3A_parameter">parameter</code></td>
<td>

<p>A vector of the parameters of the limiting form of a Faddy distribution.
</p>
</td></tr>
<tr><td><code id="Faddyprob.limiting_+3A_nmax">nmax</code></td>
<td>

<p>The value of the maximum count.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probabilities
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.counts=c(rep(0,5),352,479,530,291,101,17)
nmax1  &lt;- length(all.counts)
nmax   &lt;- nmax1 - 1
parameter &lt;- c(1.8388023,0.6009881)
names(parameter) &lt;- c("beta0 log(mean)","beta0 log(variance)") 
probability &lt;- Faddyprob.limiting(parameter,nmax) 
print(probability)
</code></pre>

<hr>
<h2 id='fitted.CountsEPPM'>
Extraction of fitted values from CountsEPPM Objects
</h2><span id='topic+fitted.CountsEPPM'></span>

<h3>Description</h3>

<p>This function is generic. Extract the fitted values from models of class &quot;BinaryEPMM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.CountsEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="fitted.CountsEPPM_+3A_...">...</code></td>
<td>

<p>currently not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stats-package">fitted</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("herons.group") 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
cooks.distance(output.fn)
fitted(output.fn)
</code></pre>

<hr>
<h2 id='hatvalues.CountsEPPM'>
Extraction of hat matrix values from CountsEPPM Objects
</h2><span id='topic+hatvalues.CountsEPPM'></span>

<h3>Description</h3>

<p>Extract the values of the hat matrix from models of class &quot;CountsEPMM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
hatvalues(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hatvalues.CountsEPPM_+3A_model">model</code></td>
<td>

<p>fitted model object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="hatvalues.CountsEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The calculated hat values for the fitted model. These are used to calculate Cook's distances.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("herons.group") 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
cooks.distance(output.fn)
hatvalues(output.fn)
</code></pre>

<hr>
<h2 id='herons.case'>
Green-backed herons as two groups
</h2><span id='topic+herons.case'></span>

<h3>Description</h3>

<p>The data are the numbers of attempts at foraging by 20 adult and 20 immature green-backed herons. The data are listed as grouped (adult or immature) count data i.e. number of herons having a particular count value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("herons.case")</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 2 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>a factor with levels <code> Adult</code> <code> Immature</code></p>
</dd>
<dt><code>number.attempts</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Zhu J, Eickhoff J, Kaiser M (2003). Modelling the Dependence between Number of Trials and Success Probability in Beta-Binomial-Poisson Mixture Distributions. 
<em>Biometrics</em>, <b>59</b>, 955-961.
<a href="https://doi.org/10.1111/j.0006-341X.2003.00110.x">doi:10.1111/j.0006-341X.2003.00110.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(herons.case)
print(herons.case)
</code></pre>

<hr>
<h2 id='herons.group'>
Green-backed herons as two groups
</h2><span id='topic+herons.group'></span>

<h3>Description</h3>

<p>The data are the numbers of attempts at foraging by 20 adult and 20 immature green-backed herons. The data are listed as grouped (adult or immature) count data i.e. number of herons having a particular count value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(herons.group)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 2
$ group          : Factor w/ 2 levels &quot; Adult&quot;,&quot; Immature&quot;: 1 2
$ number.attempts:List of 2
..$ : num [1:25] 0 5 2 1 1 1 0 2 0 1 ...
..$ : num [1:26] 0 2 2 1 5 1 2 2 1 1 ...
</p>


<h3>Source</h3>

<p>Zhu J, Eickhoff J, Kaiser M (2003). Modelling the Dependence between Number of Trials and Success Probability in Beta-Binomial-Poisson Mixture Distributions. 
<em>Biometrics</em>, <b>59</b>, 955-961.
<a href="https://doi.org/10.1111/j.0006-341X.2003.00110.x">doi:10.1111/j.0006-341X.2003.00110.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(herons.group)
print(herons.group)
</code></pre>

<hr>
<h2 id='LL.gradient'>
Function used to calculate the first derivatives of the log likelihood with respect to the model parameters.
</h2><span id='topic+LL.gradient'></span>

<h3>Description</h3>

<p>Function used to calculate the first derivatives of the log likelihood with respect to the model parameters. 
These are numerical derivatives calculated using the numerical derivative functions of Gilbert and Varadhan (2015). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LL.gradient(parameter, model.type, model.name, link, list.data,
   covariates.matrix.mean, covariates.matrix.scalef, 
   offset.mean, offset.scalef, ltvalue, utvalue, fixed.b,
   weights, grad.method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LL.gradient_+3A_parameter">parameter</code></td>
<td>
 
<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. 'mean only' or 'mean and scale-factor'. The 'mean only' value fits linear predictor functions to the mean 
as in Faddy and Smith (2012). The 'mean and scale-factor' value fits linear predictor functions to both the 'mean' and the scale-factor. The default is 'mean and scale-factor'.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_model.name">model.name</code></td>
<td>

<p>If model.type is 'mean only' the model being fitted is one of the four 'binomial', 'generalized binomial', 'beta binomial' or 'correlated binomial'. If model.type is 'mean and scale-factor' the model being fitted is one of the three 'generalized binomial', 'beta binomial' or 'correlated binomial'. Information about these models is given in Faddy and Smith (2012). The default is 'generalized binomial'.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_link">link</code></td>
<td>
 
<p>Takes one of one values i.e., 'log'. The default is 'log'. 
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_list.data">list.data</code></td>
<td>

<p>A list of vectors of the counts as grouped data i.e. number of observations for each possible count value.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_covariates.matrix.mean">covariates.matrix.mean</code></td>
<td>

<p>A matrix of covariates for the mean where rows are the number of values in list.data and columns the covariates. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the variance where rows are the number of 
values in list.binary and columns the covariates. The default is a 
vector of ones. This matrix is extracted from the formulae in function 
CountsEPPM. However, in the accompanying example it is shown how it 
can be constructed independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_offset.mean">offset.mean</code></td>
<td>

<p>An offset vector for the probability of success p. The default 
is a vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a 
vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_ltvalue">ltvalue</code></td>
<td>

<p>Lower truncation value.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_utvalue">utvalue</code></td>
<td>

<p>Upper truncation value.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_fixed.b">fixed.b</code></td>
<td>

<p>Set to the value of the parameter b if a fixed.b model is being used.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_weights">weights</code></td>
<td>

<p>A vector or list of weights for the modeling of probability of success. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_grad.method">grad.method</code></td>
<td>

<p>Set to the method to be used to calculate the gradients either &quot;simple&quot; or &quot;Richardson&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numerical first derivatives.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Gilbert P, Varadhan R. (2016). numDeriv: Accurate Numerical Derivatives. R Package version 2016.8-1.1, 
<a href="https://CRAN.R-project.org/package=numDeriv">https://CRAN.R-project.org/package=numDeriv</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gradient &lt;- grad( LL.Regression.Binary, x = parameter,
 model.type = model.type, model.name = model.name, link = link,
 ntrials = ntrials, nsuccess = nsuccess,
 covariates.matrix.mean = covariates.matrix.mean, 
 covariates.matrix.scalef = covariates.matrix.scalef,
 offset.mean = offset.mean, offset.scalef = offset.scalef,
 weights = weights, grad.method = "Richardson")
 return(gradient)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='LL.Regression.Counts'>
Function called by optim to calculate the log likelihood from the probabilities and hence perform the fitting of 
regression models to the binary data.
</h2><span id='topic+LL.Regression.Counts'></span>

<h3>Description</h3>

<p>Fits specified regression models to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LL.Regression.Counts(parameter, model.type, model.name,
 link, list.data, covariates.matrix.mean,
 covariates.matrix.scalef, offset.mean, offset.scalef,
 ltvalue, utvalue, fixed.b, weights, grad.method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LL.Regression.Counts_+3A_parameter">parameter</code></td>
<td>
 
<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. 'mean only' or 'mean and scale-factor'. The 'mean only' value fits a linear predictor function to the parameter 'a' in equation (3) of of Faddy and Smith (2011). If the model type being fitted is Poisson modeling 'a' is the same as modeling the mean. The 'mean and scale-factor' value fits linear predictor functions to both the mean and the scale-factor.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_model.name">model.name</code></td>
<td>

<p>If model.type is 'mean only' the model being fitted is one of the three 'Poisson', 'negative binomial', 'Faddy distribution'. If model.type is 'mean and scale-factor' the model being fitted is either 'general' i.e. as equations (4) and (6) of Faddy and Smith (2011), 
or 'limiting' i.e. as equations (9) and (10) of of Faddy and Smith (2011).
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_link">link</code></td>
<td>
 
<p>Takes one of one values i.e., 'log'. The default is 'log'. 
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_list.data">list.data</code></td>
<td>

<p>A list of vectors of the counts as grouped data i.e. number of observations for each possible count value.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_covariates.matrix.mean">covariates.matrix.mean</code></td>
<td>

<p>A matrix of covariates for the mean where rows are the number of values in list.counts and columns the covariates. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed 
independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the scale-factor where rows are the number of values in list.counts and columns the covariates. The default is a vector of ones. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_offset.mean">offset.mean</code></td>
<td>

<p>An offset vector for the mean. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_ltvalue">ltvalue</code></td>
<td>

<p>Lower truncation value.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_utvalue">utvalue</code></td>
<td>

<p>Upper truncation value.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_fixed.b">fixed.b</code></td>
<td>

<p>Set to the value of the parameter b if a fixed.b model is being used.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_weights">weights</code></td>
<td>

<p>A vector or list of weights for the modeling of probability of success. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Counts_+3A_grad.method">grad.method</code></td>
<td>

<p>Set to the method to be used to calculate the gradients either &quot;simple&quot; or &quot;Richardson&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log likelihood with an attribute of the gradients produced by the function grad from the package numDerive is returned.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and scale-factor. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.counts=c(rep(0,5),352,479,530,291,101,17)
nmax1  &lt;- length(all.counts)
nmax   &lt;- nmax1 - 1
cnum   &lt;- 0:nmax
ncount &lt;- sum(all.counts)  
all.mean &lt;- sum(cnum*all.counts)/ncount 
all.scalef &lt;- ((sum(cnum*cnum*all.counts) - ncount*all.mean*all.mean)
 / (ncount - 1)) / all.mean
alldata &lt;- data.frame(all.mean, all.scalef)
mf  &lt;- model.frame(formula = all.mean~1, data = alldata)
covariates.matrix.mean &lt;- model.matrix(attr(mf, "terms"), data = mf)
mf  &lt;- model.frame(formula=all.scalef~1, data=alldata)
covariates.matrix.scalef &lt;- model.matrix(attr(mf, "terms"), data=mf)
list.data &lt;- list(all.counts)
parameter &lt;- c(1.8388023, 0.6009881)
names(parameter) &lt;- c("beta0 log(mean)", "beta0 log(scale-factor)") 
offset.mean &lt;- matrix(c(rep(0,nrow(covariates.matrix.mean))), ncol=1)
offset.scalef &lt;- matrix(c(rep(0,nrow(covariates.matrix.scalef))), ncol=1)
link &lt;- "log"
attr(link, which="mean") &lt;- make.link(link)
output &lt;- LL.Regression.Counts(parameter,
 model.type = "mean and scale-factor", model.name = "limiting",
 link, list.data, covariates.matrix.mean,
 covariates.matrix.scalef, offset.mean, offset.scalef, ltvalue=4, 
 utvalue=11, fixed.b=NA, weights = NULL, grad.method = "simple") 
print(output)</code></pre>

<hr>
<h2 id='logLik.CountsEPPM'>
Method for CountsEPPM object
</h2><span id='topic+logLik.CountsEPPM'></span>

<h3>Description</h3>

<p>This function is generic and enables the use of functions related to the model fitting involved with <code>lm</code> and <code>glm</code> objects such as <code>AIC</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.CountsEPPM_+3A_object">object</code></td>
<td>

<p>The object output from <code>CountsEPPM</code>. 
</p>
</td></tr>
<tr><td><code id="logLik.CountsEPPM_+3A_...">...</code></td>
<td>

<p>currently not used. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
output.fn &lt;- CountsEPPM(mean.obs ~1, Luningetal.all,
 model.type,model, initial, ltvalue = 4, utvalue = 11,
 optimization.method = "nlm")
logLik.CountsEPPM(object=output.fn)

## End(Not run)
</code></pre>

<hr>
<h2 id='LRTruncation'>
Probabilities for distributions truncated on the left (lower) and/or right (upper).
</h2><span id='topic+LRTruncation'></span>

<h3>Description</h3>

<p>Given left (lower) and/or right (upper) truncation values and probabilities for a distribution calculates and returns the probabilities for the truncated distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRTruncation(probability, ltvalue, utvalue)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRTruncation_+3A_probability">probability</code></td>
<td>

<p>Probabilities for untruncated distribution.
</p>
</td></tr>
<tr><td><code id="LRTruncation_+3A_ltvalue">ltvalue</code></td>
<td>

<p>Left (lower) truncation value.
</p>
</td></tr>
<tr><td><code id="LRTruncation_+3A_utvalue">utvalue</code></td>
<td>

<p>Right (upper) truncation value.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probabilities for truncated distribution.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probability &lt;- c(3.375659e-08, 1.023277e-05, 5.440752e-04,
 8.768246e-03, 5.663573e-02, 1.735599e-01, 2.819850e-01,
 2.625282e-01, 1.482712e-01, 5.305443e-02, 1.244452e-02)
probabilities &lt;- LRTruncation(probability, ltvalue=4, utvalue=11)
print(probabilities)
</code></pre>

<hr>
<h2 id='Luningetal.litters'>
Number of trials (implantations) in data of Luning, et al. (1966)
</h2><span id='topic+Luningetal.litters'></span>

<h3>Description</h3>

<p>The data are arranged as a list of grouped counts where the grouping is by dose where dose is included both as a variate (vdose) and as a factor (fdose).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Luningetal.litters)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
$ vdose        : num [1:3] 0 300 600
$ fdose        : Factor w/ 3 levels &quot;0&quot;,&quot;300&quot;,&quot;600&quot;: 1 2 3
$ number.trials:List of 3
..$ : num [1:11] 0 0 0 0 0 71 156 224 150 70 ...
..$ : num [1:11] 0 0 0 0 0 121 170 186 99 24 ...
..$ : num [1:11] 0 0 0 0 0 160 153 120 45 7 ...
</p>


<h3>Source</h3>

<p>Luning K, Sheridan W, Ytterborn K, Gullberg U (1966). The relationship between the number of implantations and the rate of intra-uterine death in mice. 
<em>Mutation Research</em>, <b>3</b>, 444-451. <a href="https://doi.org/10.1016/0027-5107%2866%2990054-6">doi:10.1016/0027-5107(66)90054-6</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Luningetal.litters)
print(Luningetal.litters)
</code></pre>

<hr>
<h2 id='Model.Counts'>
Function for obtaining output from distributional models.
</h2><span id='topic+Model.Counts'></span>

<h3>Description</h3>

<p>Produces output of model, parameters and probabilities from the various models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.Counts(parameter, model.type, model.name, link,
 covariates.matrix.mean, covariates.matrix.scalef,
 offset.mean, offset.scalef, fixed.b, vnmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.Counts_+3A_parameter">parameter</code></td>
<td>
 
<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. 'mean only' or 'mean and scale-factor'. The 'mean only' value fits a linear predictor function to the parameter 'a' in equation (3) of Faddy and Smith (2011). If the model type being fitted is Poisson modeling 'a' is the same as modeling the mean. The 'mean and scale-factor' value fits linear predictor functions to both the mean and the scale-factor.
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_model.name">model.name</code></td>
<td>

<p>If model.type is 'mean only' the model being fitted is one of the three 'Poisson', 'negative binomial', 'Faddy distribution'. If model.type is 'mean and scale-factor' the model being fitted is either 'general' i.e. as equations (4) and (6) of Faddy and Smith (2011), or 'limiting' i.e. as equations (9) and (10) of Faddy and Smith (2011).
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_link">link</code></td>
<td>
 
<p>Takes one of one values i.e., 'log'. The default is 'log'. 
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_covariates.matrix.mean">covariates.matrix.mean</code></td>
<td>

<p>A matrix of covariates for the mean where rows are the number of values in listcounts and columns the covariates. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed 
independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the scale-factor where rows are the number of values in listcounts and columns the covariates. The default is a vector of ones. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_offset.mean">offset.mean</code></td>
<td>

<p>An offset vector for the mean. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_fixed.b">fixed.b</code></td>
<td>

<p>Set to the value of the parameter b if a fixed.b model is being used.
</p>
</td></tr>
<tr><td><code id="Model.Counts_+3A_vnmax">vnmax</code></td>
<td>

<p>A vector of the maximum counts for each vector in list.counts i.e. the list of grouped counts.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output which is the output from either Model.Faddy, Model.Faddy.general, or Model.Faddy.limiting
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.counts=c(rep(0,5),352,479,530,291,101,17)
nmax1  &lt;- length(all.counts)
nmax   &lt;- nmax1 - 1
cnum   &lt;- 0:nmax
ncount &lt;- sum(all.counts)  
all.mean &lt;- sum(cnum*all.counts)/ncount 
all.scalef &lt;- ((sum(cnum*cnum*all.counts) - ncount*all.mean*all.mean) / (ncount - 1)) / all.mean
alldata &lt;- data.frame(all.mean, all.scalef)
mf  &lt;- model.frame(formula = all.mean~1 ,data=alldata)
covariates.matrix.mean &lt;- model.matrix(attr(mf,"terms"), data=mf)
mf  &lt;- model.frame(formula = all.scalef~1, data = alldata)
covariates.matrix.scalef &lt;- model.matrix(attr(mf,"terms"), data = mf)
list.counts &lt;- list(all.counts)
parameter &lt;- c(1.8388023, 0.6009881)
names(parameter) &lt;- c("beta0 log(mean)" ,"beta0 log(scale-factor)") 
offset.mean     &lt;- matrix(c(rep(0, nrow(covariates.matrix.mean))), ncol=1)
offset.scalef &lt;- matrix(c(rep(0, nrow(covariates.matrix.mean))), ncol=1)
link &lt;- "log"
attr(link, which="mean") &lt;- make.link(link)
output &lt;- Model.Counts(parameter, model.type = "mean and scale-factor",
 model.name = "limiting", link, covariates.matrix.mean,
 covariates.matrix.scalef, offset.mean, offset.scalef,
 fixed.b = NA, vnmax = c(10))
print(output)
</code></pre>

<hr>
<h2 id='Model.Faddy'>
Function for Faddy distribution with log link.
</h2><span id='topic+Model.Faddy'></span>

<h3>Description</h3>

<p>Returns probabilities for a Faddy distribution given inputs of model and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.Faddy(parameter, model.name, link, covariates.matrix.mean,
 offset.mean, fixed.b, vnmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.Faddy_+3A_parameter">parameter</code></td>
<td>
 
<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code id="Model.Faddy_+3A_model.name">model.name</code></td>
<td>

<p>The model being fitted is one of the five 'Poisson', 'negative binomial', 'negative binomial fixed b', 'Faddy distribution', 'Faddy distribution fixed b'. 
</p>
</td></tr>
<tr><td><code id="Model.Faddy_+3A_link">link</code></td>
<td>
 
<p>Takes one of one values i.e., 'log'. The default is 'log'. 
</p>
</td></tr>
<tr><td><code id="Model.Faddy_+3A_covariates.matrix.mean">covariates.matrix.mean</code></td>
<td>

<p>A matrix of covariates for the mean where rows are the number of values in listcounts and columns the covariates. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed 
independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.Faddy_+3A_offset.mean">offset.mean</code></td>
<td>

<p>An offset vector for the mean. The default is a vector of ones. This matrix is extracted from the formulae in function CountsEPPM.
</p>
</td></tr>
<tr><td><code id="Model.Faddy_+3A_fixed.b">fixed.b</code></td>
<td>

<p>Set to the value of the parameter b if a fixed.b model is being used.
</p>
</td></tr>
<tr><td><code id="Model.Faddy_+3A_vnmax">vnmax</code></td>
<td>

<p>A vector of the maximum counts for each vector in list.counts i.e. the list of grouped counts.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list output with elements
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>The model being fitted</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of parameters</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.counts=c(rep(0,5), 352, 479, 530, 291, 101, 17)
nmax1  &lt;- length(all.counts)
nmax   &lt;- nmax1 - 1
cnum   &lt;- 0:nmax
ncount &lt;- sum(all.counts)  
all.mean &lt;- t(cnum) 
alldata &lt;- data.frame(all.mean)
mf &lt;- model.frame(formula = all.mean ~ 1, data = alldata)
covariates.matrix.mean &lt;- model.matrix(attr(mf, "terms"), data = mf)
list.counts &lt;- list(all.counts)
parameter &lt;- c(53.047752, -13.205655, 3.801599)
names(parameter) &lt;- c('log(a)', 'c', 'log(b)') 
model.name &lt;- 'Faddy distribution'
link &lt;- "log"
attr(link, which="mean") &lt;- make.link(link)
offset.mean &lt;- matrix(c(rep(0, nrow(covariates.matrix.mean))), ncol=1)
output &lt;- Model.Faddy(parameter, model.name, link,
 covariates.matrix.mean, offset.mean, fixed.b = NA,
 vnmax = c(10))
print(output)
</code></pre>

<hr>
<h2 id='Model.FaddyJMV.general'>
Function for a general Faddy distribution modeled by means and scale-factors.
</h2><span id='topic+Model.FaddyJMV.general'></span>

<h3>Description</h3>

<p>Outputs probabilities for a general Faddy distribution modeled by means and scale-factors i.e. with the design matrices for mean and scale-factor input together with data and offsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.FaddyJMV.general(parameter, link, covariates.matrix.mean,
 covariates.matrix.scalef, offset.mean, offset.scalef,
 fixed.b, vnmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.FaddyJMV.general_+3A_parameter">parameter</code></td>
<td>
 
<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.general_+3A_link">link</code></td>
<td>

<p>Takes one of one values i.e., 'log'. The default is 'log'. 
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.general_+3A_covariates.matrix.mean">covariates.matrix.mean</code></td>
<td>

<p>A matrix of covariates for the mean where rows are the number of values in listcounts and columns the covariates. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed 
independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.general_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the scale factor where rows are the number of values in listcounts and columns the covariates. The default is a vector of ones. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.general_+3A_offset.mean">offset.mean</code></td>
<td>

<p>An offset vector for the mean. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.general_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.general_+3A_fixed.b">fixed.b</code></td>
<td>

<p>Set to the value of the parameter b if a fixed.b model is being used.
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.general_+3A_vnmax">vnmax</code></td>
<td>

<p>A vector of the maximum counts for each vector in list.counts i.e. the list of grouped counts.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list output with elements
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>The model being fitted</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of parameters</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.counts=c(rep(0,5),352,479,530,291,101,17)
nmax1  &lt;- length(all.counts)
nmax   &lt;- nmax1 - 1
cnum   &lt;- 0:nmax
ncount &lt;- sum(all.counts)  
all.mean &lt;- sum(cnum*all.counts)/ncount 
all.scalef &lt;- ((sum(cnum*cnum*all.counts) - ncount*all.mean*all.mean) / (ncount - 1)) / all.mean
alldata &lt;- data.frame(all.mean, all.scalef)
mf &lt;- model.frame(formula = all.mean~1, data=alldata)
covariates.matrix.mean &lt;- model.matrix(attr(mf, "terms"), data=mf)
mf &lt;- model.frame(formula = all.scalef~1, data = alldata)
covariates.matrix.scalef &lt;- model.matrix(attr(mf, "terms"), data = mf)
list.counts &lt;- list(all.counts)
parameter &lt;- c(1.8386079, 0.6021198, 6.0714071)
names(parameter) &lt;- c("beta0 log(mean)", "beta0 log(scale-factor)", "log(b)") 
link &lt;- "log"
attr(link, which = "mean") &lt;- make.link(link)
offset.mean &lt;- matrix(c(rep(0,nrow(covariates.matrix.mean))), ncol = 1)
offset.scalef &lt;- matrix(c(rep(0,nrow(covariates.matrix.mean))), ncol = 1)
output &lt;- Model.FaddyJMV.general(parameter, link,
 covariates.matrix.mean, covariates.matrix.scalef,
 offset.mean, offset.scalef, fixed.b = NA, vnmax = c(10))
print(output)
</code></pre>

<hr>
<h2 id='Model.FaddyJMV.limiting'>
Function to fit the limiting form of a Faddy distribution for under-dispersed counts.
</h2><span id='topic+Model.FaddyJMV.limiting'></span>

<h3>Description</h3>

<p>Outputs probabilities for the limiting form of a Faddy distribution modeled by means and scale-factors i.e. with the design matrices for mean and scale-factor input together with data and offsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.FaddyJMV.limiting(parameter, link, covariates.matrix.mean, 
covariates.matrix.scalef, offset.mean, offset.scalef, vnmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Model.FaddyJMV.limiting_+3A_parameter">parameter</code></td>
<td>
 
<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.limiting_+3A_link">link</code></td>
<td>
 
<p>Takes one of one values i.e., 'log'. The default is 'log'. 
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.limiting_+3A_covariates.matrix.mean">covariates.matrix.mean</code></td>
<td>

<p>A matrix of covariates for the mean where rows are the number of values in listcounts and columns the covariates. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed 
independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.limiting_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the scale factor where rows are the number of values in listcounts and columns the covariates. The default is a vector of ones. This matrix is extracted from the formulae in function CountsEPPM. However, in the accompanying example it is shown how it can be constructed independently of function CountsEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.limiting_+3A_offset.mean">offset.mean</code></td>
<td>

<p>An offset vector for the mean. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.limiting_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.FaddyJMV.limiting_+3A_vnmax">vnmax</code></td>
<td>

<p>A vector of the maximum counts for each vector in list.counts i.e. the list of grouped counts.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list output with elements
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>The model being fitted</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of parameters</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2011). Analysis of count data with covariate dependence in both mean and variance. 
<em>Journal of Applied Statistics</em>, <b>38</b>, 2683-2694. <a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.counts=c(rep(0,5),352,479,530,291,101,17)
nmax1  &lt;- length(all.counts)
nmax   &lt;- nmax1 - 1
cnum   &lt;- 0:nmax
ncount &lt;- sum(all.counts)  
all.mean &lt;- sum(cnum*all.counts)/ncount 
all.scalef &lt;- ((sum(cnum*cnum*all.counts) - ncount*all.mean*all.mean) / (ncount - 1)) / all.mean
alldata &lt;- data.frame(all.mean, all.scalef)
mf  &lt;- model.frame(formula = all.mean~1, data = alldata)
covariates.matrix.mean &lt;- model.matrix(attr(mf, "terms"), data = mf)
mf  &lt;- model.frame(formula = all.scalef~1, data = alldata)
covariates.matrix.scalef &lt;- model.matrix(attr(mf, "terms"), data = mf)
list.counts &lt;- list(all.counts)
parameter &lt;- c(1.8388023, 0.6009881)
names(parameter) &lt;- c("beta0 log(mean)", "beta0 log(scale-factor)") 
link &lt;- "log"
attr(link, which = "mean") &lt;- make.link(link)
offset.mean &lt;- matrix(c(rep(0, nrow(covariates.matrix.mean))), ncol=1)
offset.scalef &lt;- matrix(c(rep(0, nrow(covariates.matrix.mean))), ncol=1)
output &lt;- Model.FaddyJMV.limiting(parameter, link,
 covariates.matrix.mean, covariates.matrix.scalef,
 offset.mean, offset.scalef, vnmax = c(10))
print(output)
</code></pre>

<hr>
<h2 id='plot.CountsEPPM'>
Diagnostic Plots for CountsEPPM Objects
</h2><span id='topic+plot.CountsEPPM'></span>

<h3>Description</h3>

<p>Various types of standard diagnostic plots can be produced, involving various 
types of residuals, influence measures etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
plot(x, which = 1:4, caption = c("Residuals vs indices of obs.", "Cook's distance plot",
 "Leverage vs predicted values", "Residuals vs linear predictor",
 "Normal Q-Q plot of residuals", "Predicted vs observed values"),
 sub.caption = " ", main = "", ask = prod(par("mfcol"), 1) &lt;
 length(which) &amp;&amp; dev.interactive(), ..., type = "spearson")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.CountsEPPM_+3A_x">x</code></td>
<td>

<p>fitted model object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="plot.CountsEPPM_+3A_which">which</code></td>
<td>

<p>numeric. If a subset of plots is required, specify a subset of the numbers 1:6.
</p>
</td></tr>
<tr><td><code id="plot.CountsEPPM_+3A_caption">caption</code></td>
<td>

<p>character. Captions to appear above the plots.
</p>
</td></tr>
<tr><td><code id="plot.CountsEPPM_+3A_sub.caption">sub.caption</code></td>
<td>

<p>character. Common title-above figures if there are multiple.
</p>
</td></tr>
<tr><td><code id="plot.CountsEPPM_+3A_main">main</code></td>
<td>

<p>chaacter. Title to each plot in addition to the above caption.
</p>
</td></tr>
<tr><td><code id="plot.CountsEPPM_+3A_ask">ask</code></td>
<td>

<p>logical. If true, the user is asked before each plot.
</p>
</td></tr>
<tr><td><code id="plot.CountsEPPM_+3A_...">...</code></td>
<td>

<p>other parameters to be passed through to plotting functions.
</p>
</td></tr>
<tr><td><code id="plot.CountsEPPM_+3A_type">type</code></td>
<td>

<p>character indicating type of residual to be used, see residuals.CountsEPPM.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot method for CountsEPPM objects produces various plots of diagnostic plots similar to those produced by <span class="pkg">betareg</span>. See Ferrari and Cribari-Neto (2004) for further details of the displays of <span class="pkg">betareg</span>.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+plot.betareg">plot.betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("herons.group") 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
cooks.distance(output.fn)
plot(output.fn, which = 1, type= "sdeviance")

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.CountsEPPM'>
Prediction Method for CountsEPPM Objects
</h2><span id='topic+predict.CountsEPPM'></span>

<h3>Description</h3>

<p>Extract various types of predictions from CountsEPPM regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
predict(object, newdata = NULL,
 type = c("response", "linear.predictor.mean",
 "linear.predictor.scale.factor", "scale.factor",
 "mean", "variance", "distribution", "distribution.parameters"),
 na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.CountsEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="predict.CountsEPPM_+3A_newdata">newdata</code></td>
<td>

<p>optionally, a data frame in which to look for variables with which to predict. If omitted, the original observations are used.
</p>
</td></tr>
<tr><td><code id="predict.CountsEPPM_+3A_type">type</code></td>
<td>

<p>character indicating type of predictions: fitted means of responses
(&quot;response&quot;), linear predictors (&quot;linear.predictor.mean&quot;, &quot;linear.predictor.scale.factor&quot;), fitted value of mean (&quot;mean&quot;),
fitted value of scale-factor (&quot;scale.factor&quot;), fitted value of variance (&quot;variance&quot;), fitted probability distribution (&quot;distribution&quot;), parameters of fitted distributions (&quot;distribution.parameters&quot;)
</p>
</td></tr>
<tr><td><code id="predict.CountsEPPM_+3A_na.action">na.action</code></td>
<td>

<p>function determining what to do with missing values in <em>newdata</em>. The default is to predict NA.
</p>
</td></tr>
<tr><td><code id="predict.CountsEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or list of the predicted values from the fitted model object.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+predict.betareg">predict.betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("herons.group") 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
predict(output.fn, type = "response")
predict(output.fn, type = "linear.predictor.mean")
</code></pre>

<hr>
<h2 id='print.CountsEPPM'>
Printing of CountsEPPM Objects
</h2><span id='topic+print.CountsEPPM'></span>

<h3>Description</h3>

<p>Prints objects of class &quot;CountsEPPM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.CountsEPPM_+3A_x">x</code></td>
<td>

<p>fitted model object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="print.CountsEPPM_+3A_digits">digits</code></td>
<td>

<p>digits of printed output.
</p>
</td></tr>
<tr><td><code id="print.CountsEPPM_+3A_...">...</code></td>
<td>

<p>not currently used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("herons.group") 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
print(output.fn)
</code></pre>

<hr>
<h2 id='print.summaryCountsEPPM'>
Printing of summaryCountsEPPM Objects 
</h2><span id='topic+print.summaryCountsEPPM'></span>

<h3>Description</h3>

<p>Prints the objects of class &quot;summaryCountsEPPM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summaryCountsEPPM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summaryCountsEPPM_+3A_x">x</code></td>
<td>

<p>object output by <code>summary.CountsEPPM</code>.
</p>
</td></tr>
<tr><td><code id="print.summaryCountsEPPM_+3A_...">...</code></td>
<td>

<p>not currently used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("herons.group") 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
print(summary(output.fn))
</code></pre>

<hr>
<h2 id='residuals.CountsEPPM'>
Residuals for CountsEPPM Objects
</h2><span id='topic+residuals.CountsEPPM'></span>

<h3>Description</h3>

<p>This function is generic. Extract various types of residuals from objects of class &quot;CountsEPPM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
residuals(object, type = c("spearson",
 "deviance", "pearson", "response", "likelihood", "sdeviance"),
 ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.CountsEPPM_+3A_object">object</code></td>
<td>

<p>Fitted model object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="residuals.CountsEPPM_+3A_type">type</code></td>
<td>

<p>Type of residuals wanted i.e., standardized Pearson &quot;spearson&quot;, deviance &quot;deviance&quot;, Pearson &quot;pearson&quot;, response &quot;response&quot;, likelihood &quot;likelihood&quot;, standardized deviance &quot;sdeviance&quot;.
</p>
</td></tr>
<tr><td><code id="residuals.CountsEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this geneic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals as Cribari-Neto and Zeileis (2010).
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+residuals.betareg">residuals.betareg</a></code> 
</p>

<hr>
<h2 id='summary.CountsEPPM'>
Method for CountsEPPM object
</h2><span id='topic+summary.CountsEPPM'></span>

<h3>Description</h3>

<p>This function is generic and is for printing out a summary of the results of fitting EPPM models to count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CountsEPPM_+3A_object">object</code></td>
<td>

<p>The object output from <code>CountsEPPM</code>. This list includes a vector vnmax of the maximums of the grouped count vectors in list.counts. The vector vnmax can be changed before calling this function in order to give more complete probability vectors i.e.
closer to a total of 1.
</p>
</td></tr>
<tr><td><code id="summary.CountsEPPM_+3A_...">...</code></td>
<td>

<p>currently not used. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
output.fn &lt;- CountsEPPM(mean.obs ~ 1, Luningetal.all, model.type,
 model,initial, ltvalue = 4, utvalue = 11, optimization.method =  "nlm")
summary(object=output.fn)

## End(Not run)
</code></pre>

<hr>
<h2 id='takeover.bids.case'>
Takeover bids data.
</h2><span id='topic+takeover.bids.case'></span>

<h3>Description</h3>

<p>Data of the number of bids received by 126 U.S. firms that were targets of tender offers from 1978 to 1985.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("takeover.bids.case")</code></pre>


<h3>Format</h3>

<p>A data frame with 126 observations on the following 12 variables.
</p>

<dl>
<dt><code>DOCNO</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>WEEKS</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>NUMBIDS</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>BIDPREM</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>INSTHOLD</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SIZE</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>LEGLREST</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>REALREST</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>FINREST</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>REGULATN</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>WHTKNGHT</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SIZESQ</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data originally from Jaggia and Thosar (1993) and used as an example in Cameron and Trivedi (2013) and Saez-Castillo and Conde-Sanchez (2013). 
</p>


<h3>Source</h3>

<p>Stata data file obtained from A.C. Cameron's webpage 
<a href="https://cameron.econ.ucdavis.edu/">https://cameron.econ.ucdavis.edu/</a>.
</p>


<h3>References</h3>

<p>Cameron, A.C., Trivedi, P.K. (2013). Regression Analysis of Count Data. Cambridge University Press, second edition.
</p>
<p>Jaggia, S., Thosar, S. (1993). Multiple Bids as a Consequence of Target Management Resistance.
<em>Review of Quantitative Finance and Accounting</em>, 447-457.
</p>
<p>Saez-Castillo, A.J., Conde-Sanchez, A. (2013). A hyper-Poisson regression model for overdispersed and underdispersed count data.
<em>Computational Statistics and Data Analysis</em>, <b>61</b>, 148-157.<a href="https://doi.org/10.1016/j.csda.2012.12.009">doi:10.1016/j.csda.2012.12.009</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(takeover.bids.case)
print(takeover.bids.case)
</code></pre>

<hr>
<h2 id='Titanic.survivors.case'>
Titanic survivors data
</h2><span id='topic+Titanic.survivors.case'></span>

<h3>Description</h3>

<p>These data are from the survival log of the Titanic and consist of the number of survivors out of the number of passengers broken down into age, sex and class categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Titanic.survivors.case)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 5 variables.
</p>

<dl>
<dt><code>age</code></dt><dd><p>a factor with levels <code> child</code> <code> adult</code></p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code> female</code> <code> male</code></p>
</dd>
<dt><code>class</code></dt><dd><p>a factor with levels <code> 1st class</code> <code> 2nd class</code> <code> 3rd class</code></p>
</dd>
<dt><code>cases</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>survive</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Hilbe (2011) first models these data as a logistic model, then finding that they are overdispersed, modeling them as count data (number of survivors, survive) with offset (log of the number of passengers, cases).
</p>


<h3>Source</h3>

<p>Section 9.5, Example 3, pages 263-268, Hilbe, J. (2011). 
</p>


<h3>References</h3>

<p>Hilbe, J. (2011). Negative Binomial Regression. Cambridge University Press, second edition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Titanic.survivors.case)
print(Titanic.survivors.case)
</code></pre>

<hr>
<h2 id='vcov.CountsEPPM'>
Variance/Covariance Matrix for Coefficients
</h2><span id='topic+vcov.CountsEPPM'></span>

<h3>Description</h3>

<p>Variance/covariance matrix for coefficients of fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
vcov(object, model = c("full", "mean", "scale.factor"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.CountsEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;CountsEPPM&quot;
</p>
</td></tr>
<tr><td><code id="vcov.CountsEPPM_+3A_model">model</code></td>
<td>

<p>character indicating variance/covariance matrix for all coefficients to be output: all coefficients (&quot;full&quot;),
variance/covariance matrix for coefficients of probability of success (&quot;mean&quot;), variance/covariance matrix for coefficients of scale-factor (&quot;scale.factor&quot;)
</p>
</td></tr>
<tr><td><code id="vcov.CountsEPPM_+3A_...">...</code></td>
<td>

<p>other parameters to be passed through to function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance/covariance matrix of the parameters of the fitted model object.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("herons.group") 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
vcov(output.fn)
</code></pre>

<hr>
<h2 id='waldtest.CountsEPPM'>
Wald Test of Nested Models for CountsEPPM Objects
</h2><span id='topic+waldtest.CountsEPPM'></span>

<h3>Description</h3>

<p><code>waldtest</code> is a generic function for comparisons of nested (generalized) linear models via Wald tests. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CountsEPPM'
waldtest(object, ..., vcov = NULL,
   test = c("Chisq", "F"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="waldtest.CountsEPPM_+3A_object">object</code></td>
<td>

<p>an object of class &quot;CountsEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="waldtest.CountsEPPM_+3A_...">...</code></td>
<td>

<p>further object specifications passed to methods. See below for details.
</p>
</td></tr>
<tr><td><code id="waldtest.CountsEPPM_+3A_vcov">vcov</code></td>
<td>

<p>a function for estimating the covariance matrix of the regression coefficients. If only two models are compared it can also be the covariance matrix of the more general model. 
</p>
</td></tr>
<tr><td><code id="waldtest.CountsEPPM_+3A_test">test</code></td>
<td>

<p>character specifying whether to compute the large sample Chi-squared statistic (with asymptotic Chi-squared distribution) or the finite sample F statistic (with approximate F distribution).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>waldtest</code> is a generic function for comparisons of nested (generalized)linear models via Wald tests. It does not have the same functionality as the versions of <span class="pkg">betareg</span> and <span class="pkg">lmtest</span> with a reduced list of arguments. With these caveats, more details can be obtained from the <b>Details</b> pages of those packages.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> which contains the residual degrees of freedom, the difference in degrees of freedom, Wald statistic (either <code>"Chisq"</code> or <code>"F"</code>) and corresponding p value.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>
<p>Zeileis A, Hothorn T. (2002). Diagnostic Checking in Regression Relationships. <em>R News</em>, <b>2</b>(3), 7-10. <a href="https://CRAN.R-project.org/doc/Rnews/">https://CRAN.R-project.org/doc/Rnews/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="lmtest.html#topic+waldtest">waldtest</a></code> 
<code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("herons.group")
## Not run: 
output.fn  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only', model.name = 'Poisson')
output.fn.one  &lt;- CountsEPPM(number.attempts ~ 0 + group,
 herons.group, model.type = 'mean only',
 model.name = 'negative binomial')
waldtest(output.fn, output.fn.one, test = c("Chisq", "F"), vcov =  vcov) 

## End(Not run)       
</code></pre>

<hr>
<h2 id='Williams.litters'>
Number of trials (implantations) of data of Williams (1996).
</h2><span id='topic+Williams.litters'></span>

<h3>Description</h3>

<p>The data is arranged as a list of grouped counts where the grouping is by dose where dose is included both as a variate (vdose) and as a factor (fdose).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Williams.litters)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
$ vdose          : num [1:4] 0 0.75 1.5 3
$ fdose          : Factor w/ 4 levels &quot;0&quot;,&quot;0.75&quot;,&quot;1.5&quot;,..: 1 2 3 4
$ number.implants:List of 4
..$ : num [1:18] 0 0 0 0 0 0 0 0 0 2 ...
..$ : num [1:20] 0 0 0 0 0 0 0 1 0 1 ...
..$ : num [1:17] 0 0 0 0 0 0 0 1 1 2 ...
..$ : num [1:17] 0 0 0 0 0 0 0 0 0 3 ...
</p>


<h3>Source</h3>

<p>Williams D (1996). Overdispersion in logistic linear model. In B Morgan (ed.), Statistics in Toxicology, pp. 75-84, Oxford Science Publications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Williams.litters)
print(Williams.litters)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
