<!DOCTYPE html><html lang="en"><head><title>Help for package forecastSNSTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forecastSNSTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#forecastSNSTS-package'><p>Forecasting of Stationary and Non-Stationary Time Series</p></a></li>
<li><a href='#acfARp'><p>Compute autocovariances of an AR(p) process</p></a></li>
<li><a href='#computeMSPEcpp'><p>Mean Squared Prediction Errors, for a single <code class="reqn">h</code></p></a></li>
<li><a href='#f'><p>Compute <code class="reqn">f(\delta)</code> for a tvAR(p) process</p></a></li>
<li><a href='#measure-of-accuracy'><p>Mean squared or absolute <code class="reqn">h</code>-step ahead prediction errors</p></a></li>
<li><a href='#plot.measure-of-accuracy'><p>Plot a <code>MSPE</code> or <code>MAPE</code> object</p></a></li>
<li><a href='#predCoef'><p><code class="reqn">h</code>-step Prediction coefficients</p></a></li>
<li><a href='#ts-models-tvARMA'><p>Simulation of an tvARMA(p,q) time series.</p></a></li>
<li><a href='#tvARMAcpp'><p>Workhorse function for tvARMA time series generation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Forecasting for Stationary and Non-Stationary Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-0</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to compute linear h-step ahead prediction coefficients based
    on localised and iterated Yule-Walker estimates and empirical mean squared
    and absolute prediction errors for the resulting predictors. Also, functions
    to compute autocovariances for AR(p) processes, to simulate tvARMA(p,q) time
    series, and to verify an assumption from Kley et al. (2019), Electronic of Statistics,
    forthcoming. Preprint &lt;<a href="https://doi.org/10.48550/arXiv.1611.04460">doi:10.48550/arXiv.1611.04460</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/tobiaskley/forecastSNSTS">http://github.com/tobiaskley/forecastSNSTS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/tobiaskley/forecastSNSTS/issues">http://github.com/tobiaskley/forecastSNSTS/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'acfARp.R' 'f.R' 'forecastSNSTS-package.R'
'measure-of-accuracy.R' 'models.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-02 13:51:50 UTC; tk18582</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Kley [aut, cre],
  Philip Preuss [aut],
  Piotr Fryzlewicz [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Kley &lt;tobias.kley@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-02 15:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='forecastSNSTS-package'>Forecasting of Stationary and Non-Stationary Time Series</h2><span id='topic+forecastSNSTS-package'></span><span id='topic+forecastSNSTS'></span>

<h3>Description</h3>

<p>Methods to compute linear <code class="reqn">h</code>-step ahead prediction coefficients based
on localised and iterated Yule-Walker estimates and empirical mean squared
and absolute prediction errors for the resulting predictors. Also, functions
to compute autocovariances for AR(p) processes, to simulate tvARMA(p,q) time
series, and to verify an assumption from Kley et al. (2019).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> forecastSNSTS
   </td>
</tr>
<tr>
 <td style="text-align: left;"> Type:    </td><td style="text-align: left;"> Package
   </td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;"> 1.3-0
   </td>
</tr>
<tr>
 <td style="text-align: left;"> Date:    </td><td style="text-align: left;"> 2019-09-02
   </td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 2)
 </td>
</tr>

</table>



<h3>Contents</h3>

<p>The core functionality of this R package is accessable via the function
<code><a href="#topic+predCoef">predCoef</a></code>, which is used to compute the linear prediction
coefficients, and the functions <code><a href="#topic+MSPE">MSPE</a></code> and <code><a href="#topic+MAPE">MAPE</a></code>,
which are used to compute the empirical mean squared or absolute prediction
errors. Further, the function <code><a href="#topic+f">f</a></code> can be used to verify
condition (10) of Theorem 3.1 in Kley et al. (2019) for any given tvAR(p) model.
The function <code><a href="#topic+tvARMA">tvARMA</a></code> can be used to simulate time-varying
ARMA(p,q) time series.
The function <code><a href="#topic+acfARp">acfARp</a></code> computes the autocovariances of a AR(p)
process from the coefficients and innovations standard deviation.
</p>


<h3>Author(s)</h3>

<p>Tobias Kley
</p>


<h3>References</h3>

<p>Kley, T., Preuss, P. &amp; Fryzlewicz, P. (2019).
Predictive, finite-sample model choice for time series under stationarity
and non-stationarity. Electronic Journal of Statistics, forthcoming.
[cf. <a href="https://arxiv.org/abs/1611.04460">https://arxiv.org/abs/1611.04460</a>]
</p>

<hr>
<h2 id='acfARp'>Compute autocovariances of an AR(p) process</h2><span id='topic+acfARp'></span>

<h3>Description</h3>

<p>This functions returns the autocovariances <code class="reqn">Cov(X_{t-k}, X_t)</code> of a
stationary time series <code class="reqn">(Y_t)</code> that fulfills the following equation:
</p>
<p style="text-align: center;"><code class="reqn">Y_t = \sum_{j=1}^p a_j Y_{t-j} + \sigma \varepsilon_{t},</code>
</p>

<p>where <code class="reqn">\sigma &gt; 0</code>, <code class="reqn">\varepsilon_t</code> is white noise and
<code class="reqn">a_1, \ldots, a_p</code> are real numbers satisfying that the roots
<code class="reqn">z_0</code> of the polynomial <code class="reqn">1 - \sum_{j=1}^p a_j z^j</code>
lie strictly outside the unit circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfARp(a = NULL, sigma, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfARp_+3A_a">a</code></td>
<td>
<p>vector <code class="reqn">(a_1, \ldots, a_p)</code> of coefficients; default NULL,
corresponding to p = 0, white noise with variance <code class="reqn">\sigma^2</code>,</p>
</td></tr>
<tr><td><code id="acfARp_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of <code class="reqn">\varepsilon_t</code>; default 1,</p>
</td></tr>
<tr><td><code id="acfARp_+3A_k">k</code></td>
<td>
<p>lag for which to compute the autocovariances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns autocovariance at lag k of the AR(p) process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Taken from Section 6 in Dahlhaus (1997, AoS)
a1 &lt;- function(u) {1.8 * cos(1.5 - cos(4*pi*u))}
a2 &lt;- function(u) {-0.81}
# local autocovariance for u === 1/2: lag 1
acfARp(a = c(a1(1/2), a2(1/2)), sigma = 1, k = 1)
# local autocovariance for u === 1/2: lag -2
acfARp(a = c(a1(1/2), a2(1/2)), sigma = 1, k = -1)
# local autocovariance for u === 1/2: the variance
acfARp(a = c(a1(1/2), a2(1/2)), sigma = 1, k = 0)
</code></pre>

<hr>
<h2 id='computeMSPEcpp'>Mean Squared Prediction Errors, for a single <code class="reqn">h</code></h2><span id='topic+computeMSPEcpp'></span>

<h3>Description</h3>

<p>This function computes the estimated mean squared prediction errors from a
given time series and prediction coefficients
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeMSPEcpp_+3A_x">X</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="computeMSPEcpp_+3A_coef">coef</code></td>
<td>
<p>the array of coefficients.</p>
</td></tr>
<tr><td><code id="computeMSPEcpp_+3A_h">h</code></td>
<td>
<p>which lead time to compute the MSPE for</p>
</td></tr>
<tr><td><code id="computeMSPEcpp_+3A_t">t</code></td>
<td>
<p>a vector of times from which backward the forecasts are computed</p>
</td></tr>
<tr><td><code id="computeMSPEcpp_+3A_type">type</code></td>
<td>
<p>indicating what type of measure of accuracy is to be computed;
1: mspe, 2: msae</p>
</td></tr>
<tr><td><code id="computeMSPEcpp_+3A_trimlo">trimLo</code></td>
<td>
<p>percentage of lower observations to be trimmed away</p>
</td></tr>
<tr><td><code id="computeMSPEcpp_+3A_trimup">trimUp</code></td>
<td>
<p>percentage of upper observations to be trimmed away</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The array of prediction coefficients <code>coef</code> is expected to be of
dimension <code>P x P x H x length(N) x length(t)</code> and in the format as
it is returned by the function <code><a href="#topic+predCoef">predCoef</a></code>. More precisely, for
<code class="reqn">p=1,\ldots,P</code> and the <code>j.N</code>th element of <code>N</code> element of
<code>N</code> the coefficient of the
<code>h</code>-step ahead predictor for <code class="reqn">X_{i+h}</code> which is computed from
the observations <code class="reqn">X_i, \ldots, X_{i-p+1}</code> has to be available via
<code>coef[p, 1:p, h, j.N, t==i]</code>.
</p>
<p>Note that <code>t</code> have to be the indices corresponding to the coefficients.
</p>
<p>The resulting mean squared prediction error
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{|\mathcal{T}|} \sum_{t \in \mathcal{T}} (X_{t+h} - (X_t, \ldots, X_{t-p+1}) \hat v_{N[j.N],T}^{(p,h)}(t))^2</code>
</p>

<p>is then stored in the resulting matrix at position <code>(p, j.N)</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>P x length(N)</code> matrix with the results.
</p>

<hr>
<h2 id='f'>Compute <code class="reqn">f(\delta)</code> for a tvAR(p) process</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>This functions computes the quantity <code class="reqn">f(\delta)</code> defined in (24) of
Kley et al. (2019) when the underlying process follows an tvAR(p) process.
Recall that, to apply Theorem 3.1 in Kley et al. (2019), the function
<code class="reqn">f(\delta)</code> is required to be positive, which can be verified with the
numbers returned from this function.
The function returns a vector with elements <code class="reqn">f(\delta)</code> 
for each <code class="reqn">\delta</code> in <code>which.deltas</code>, with <code class="reqn">f(\delta)</code>
defined as  
</p>
<p style="text-align: center;"><code class="reqn">f(\delta) := \min_{p_1,p_2 = 0, \ldots, p_{\max}} \min_{N \in \mathcal{N}} \Big| {\rm MSPE}_{s_1/T,m/T}^{(p_1,h)}(\frac{s_1}{T}) - (1+\delta) \cdot {\rm MSPE}_{N/T,m/T}^{(p_2,h)}(\frac{s_1}{T}) \Big|, \quad \delta \geq 0</code>
</p>

<p>where <code class="reqn">T, m, p_{\max}, h</code> are positive integers,
<code class="reqn">\mathcal{N} \subset \{p_{\max}+1, \ldots, T-m-h\}</code>, and <code class="reqn">s_1 := T-m-h+1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(which.deltas, p_max, h, T, Ns, m, a, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_+3A_which.deltas">which.deltas</code></td>
<td>
<p>vector containing the <code class="reqn">\delta</code>'s for which to
to compute <code class="reqn">f(\delta)</code>,</p>
</td></tr>
<tr><td><code id="f_+3A_p_max">p_max</code></td>
<td>
<p>parameter <code class="reqn">p_{\max}</code>,</p>
</td></tr>
<tr><td><code id="f_+3A_h">h</code></td>
<td>
<p>parameter <code class="reqn">h</code>,</p>
</td></tr>
<tr><td><code id="f_+3A_t">T</code></td>
<td>
<p>parameter <code class="reqn">T</code>,</p>
</td></tr>
<tr><td><code id="f_+3A_ns">Ns</code></td>
<td>
<p>a vector containing the elements of the set
<code class="reqn">\mathcal{N}</code>,</p>
</td></tr>
<tr><td><code id="f_+3A_m">m</code></td>
<td>
<p>parameter <code class="reqn">m</code>,</p>
</td></tr>
<tr><td><code id="f_+3A_a">a</code></td>
<td>
<p>a list of real-valued functions, specifying the
coefficients of the tvAR(p) process,</p>
</td></tr>
<tr><td><code id="f_+3A_sigma">sigma</code></td>
<td>
<p>a positive-valued function, specifying the variance
of the innovations of the tvAR(p) process,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code class="reqn">{\rm MSPE}_{\Delta_1, \Delta_2}^{(p,h)}(u)</code> is defined, for real-valued <code class="reqn">u</code> and
<code class="reqn">\Delta_1, \Delta_2 \geq 0</code>, in terms of the second order properties of the process:
</p>
<p style="text-align: center;"><code class="reqn">{\rm MSPE}_{\Delta_1, \Delta_2}^{(p,h)}(u) := \int_0^1 g^{(p,h)}_{\Delta_1}\Big( u + \Delta_2 (1-x) \Big) {\rm d}x,</code>
</p>

<p>with <code class="reqn">g^{(0,h)}_{\Delta}(u) := \gamma_0(u)</code> and, for <code class="reqn">p = 1, 2, \ldots</code>,
</p>
<p style="text-align: center;"><code class="reqn">g^{(p,h)}_{\Delta}(u) := \gamma_0(u) - 2 \big( v_{\Delta}^{(p,h)}(u) \big)' \gamma_0^{(p,h)}(u) + \big( v_{\Delta}^{(p,h)}(u) \big)' \Gamma_0^{(p)}(u) v_{\Delta}^{(p,h)}(u)</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma_0^{(p,h)}(u) := \big( \gamma_h(u), \ldots, \gamma_{h+p-1}(u) \big)',</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">v^{(p,h)}_{\Delta}(u) := e'_1 \big( e_1 \big( a_{\Delta}^{(p)}(t) \big)' + H \big)^h,</code>
</p>

<p>with <code class="reqn">e_1</code> and <code class="reqn">H</code> defined in the documentation of <code><a href="#topic+predCoef">predCoef</a></code> and,
for every real-valued <code class="reqn">u</code> and <code class="reqn">\Delta \geq 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">a^{(p)}_{\Delta}(u) := \Gamma^{(p)}_{\Delta}(u)^{-1} \gamma^{(p)}_{\Delta}(u),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\gamma^{(p)}_{\Delta}(u) := \int_0^1 \gamma^{(p)}(u+\Delta (x-1)) {\rm d}x, \quad \gamma^{(p)}(u) := [\gamma_1(u)\;\ldots\;\gamma_p(u)]',</code>
</p>

<p style="text-align: center;"><code class="reqn">\Gamma^{(p)}_{\Delta}(u) := \int_0^1 \Gamma^{(p)}(u+\Delta (x-1)) {\rm d}x, \quad \Gamma^{(p)}(u) := (\gamma_{i-j}(u);\,i,j=1,\ldots,p).</code>
</p>

<p>The local autocovariances <code class="reqn">\gamma_k(u)</code> are defined as the lag-<code class="reqn">k</code>
autocovariances of an AR(p) process which has coefficients
<code class="reqn">a_1(u), \ldots, a_p(u)</code> and innovations with variance <code class="reqn">\sigma(u)^2</code>,
because the underlying model is assumed to be tvAR(p)  
</p>
<p style="text-align: center;"><code class="reqn">Y_{t,T} = \sum_{j=1}^p a_j(t/T) Y_{t-j,T} + \sigma(t/T) \varepsilon_{t},</code>
</p>

<p>where <code class="reqn">a_1, \ldots, a_p</code> are real valued functions (defined on <code class="reqn">[0,1]</code>) and <code class="reqn">\sigma</code> is a
positive function (defined on <code class="reqn">[0,1]</code>).
</p>


<h3>Value</h3>

<p>Returns     a vector with the values <code class="reqn">f(\delta)</code>, as defined in
(24) of Kley et al. (2019), where it is now denoted by <code class="reqn">q(\delta)</code>, for each <code class="reqn">\delta</code> in
<code>which.delta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## because computation is quite time-consuming.
n &lt;- 100
a &lt;- list( function(u) {return(0.8+0.19*sin(4*pi*u))} )
sigma &lt;- function (u) {return(1)}

Ns &lt;- seq( floor((n/2)^(4/5)), floor(n^(4/5)),
           ceiling((floor(n^(4/5)) - floor((n/2)^(4/5)))/25) )
which.deltas &lt;- c(0, 0.01, 0.05, 0.1, 0.15, 0.2, 0.4, 0.6)
P_max &lt;- 7
H &lt;- 1
m &lt;- floor(n^(.85)/4)

# now replicate some results from Table 4 in Kley et al. (2019)
f( which.deltas, P_max, h = 1, n - m, Ns, m, a, sigma )
f( which.deltas, P_max, h = 5, n - m, Ns, m, a, sigma )

## End(Not run)
</code></pre>

<hr>
<h2 id='measure-of-accuracy'>Mean squared or absolute <code class="reqn">h</code>-step ahead prediction errors</h2><span id='topic+measure-of-accuracy'></span><span id='topic+MSPE'></span><span id='topic+MAPE'></span>

<h3>Description</h3>

<p>The function <code>MSPE</code> computes the empirical mean squared prediction
errors for a collection of <code class="reqn">h</code>-step ahead, linear predictors
(<code class="reqn">h=1,\ldots,H</code>) of observations <code class="reqn">X_{t+h}</code>, where
<code class="reqn">m_1 \leq t+h \leq m_2</code>, for two indices <code class="reqn">m_1</code> and <code class="reqn">m_2</code>.
The resulting array provides
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{m_{\rm lo} - m_{\rm up} + 1} \sum_{t=m_{\rm lo}}^{m_{\rm up}} R_{(t)}^2,</code>
</p>

<p>with <code class="reqn">R_{(t)}</code> being the prediction errors
</p>
<p style="text-align: center;"><code class="reqn">R_t := | X_{t+h} - (X_t, \ldots, X_{t-p+1}) \hat v_{N,T}^{(p,h)}(t) |,</code>
</p>

<p>ordered by magnitude; i.e., they are such that <code class="reqn">R_{(t)} \leq R_{(t+1)}</code>.
The lower and upper limits of the indices are
<code class="reqn">m_{\rm lo} := m_1-h + \lfloor (m_2-m_1+1) \alpha_1 \rfloor</code> and
<code class="reqn">m_{\rm up} := m_2-h - \lfloor (m_2-m_1+1) \alpha_2 \rfloor</code>.
The function <code>MAPE</code> computes the empirical mean absolute prediction
errors
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{m_{\rm lo} - m_{\rm up} + 1} \sum_{t=m_{\rm lo}}^{m_{\rm up}} R_{(t)},</code>
</p>

<p>with <code class="reqn">m_{\rm lo}</code>, <code class="reqn">m_{\rm up}</code> and <code class="reqn">R_{(t)}</code> defined as before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSPE(X, predcoef, m1 = length(X)/10, m2 = length(X), P = 1, H = 1,
  N = c(0, seq(P + 1, m1 - H + 1)), trimLo = 0, trimUp = 0)

MAPE(X, predcoef, m1 = length(X)/10, m2 = length(X), P = 1, H = 1,
  N = c(0, seq(P + 1, m1 - H + 1)), trimLo = 0, trimUp = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure-of-accuracy_+3A_x">X</code></td>
<td>
<p>the data <code class="reqn">X_1, \ldots, X_T</code></p>
</td></tr>
<tr><td><code id="measure-of-accuracy_+3A_predcoef">predcoef</code></td>
<td>
<p>the prediction coefficients in form of a list of an array
<code>coef</code>, and two integer vectors <code>t</code>    and <code>N</code>. The two
integer vectors provide the information for which indices <code class="reqn">t</code> and
segment lengths <code class="reqn">N</code> the coefficients are to be interpreted;
<code>(m1-H):(m2-1)</code> has to be a subset of <code>predcoef$t</code>.
if not provided the necessary coefficients will be computed using
<code><a href="#topic+predCoef">predCoef</a></code>.</p>
</td></tr>
<tr><td><code id="measure-of-accuracy_+3A_m1">m1</code></td>
<td>
<p>first index from the set in which the indices <code class="reqn">t+h</code> shall lie</p>
</td></tr>
<tr><td><code id="measure-of-accuracy_+3A_m2">m2</code></td>
<td>
<p>last index from the set in which the indices <code class="reqn">t+h</code> shall lie</p>
</td></tr>
<tr><td><code id="measure-of-accuracy_+3A_p">P</code></td>
<td>
<p>maximum order of prediction coefficients to be used;
must not be larger than <code>dim(predcoef$coef)[1]</code>.</p>
</td></tr>
<tr><td><code id="measure-of-accuracy_+3A_h">H</code></td>
<td>
<p>maximum lead time to be used;
must not be larger than <code>dim(predcoef$coef)[3]</code>.</p>
</td></tr>
<tr><td><code id="measure-of-accuracy_+3A_n">N</code></td>
<td>
<p>vector with the segment sizes to be used, 0 corresponds to
using 1, ..., t;
has to be a subset of predcoef$N.</p>
</td></tr>
<tr><td><code id="measure-of-accuracy_+3A_trimlo">trimLo</code></td>
<td>
<p>percentage <code class="reqn">\alpha_1</code> of lower observations to be trimmed away</p>
</td></tr>
<tr><td><code id="measure-of-accuracy_+3A_trimup">trimUp</code></td>
<td>
<p>percentage <code class="reqn">\alpha_2</code> of upper observations to be trimmed away</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MSPE</code> returns an object of type <code>MSPE</code> that has <code>mspe</code>,
an array of size <code>H</code><code class="reqn">\times</code><code>P</code><code class="reqn">\times</code><code>length(N)</code>,
as an attribute, as well as the parameters <code>N</code>, <code>m1</code>,
<code>m2</code>, <code>P</code>, and <code>H</code>.
<code>MAPE</code> analogously returns an object of type <code>MAPE</code> that
has <code>mape</code> and the same parameters as attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- 1000
X &lt;- rnorm(T)
P &lt;- 5
H &lt;- 1
m &lt;- 20
Nmin &lt;- 20
pcoef &lt;- predCoef(X, P, H, (T - m - H + 1):T, c(0, seq(Nmin, T - m - H, 1)))

mspe &lt;- MSPE(X, pcoef, 991, 1000, 3, 1, c(0, Nmin:(T-m-H)))

plot(mspe, vr = 1, Nmin = Nmin)
</code></pre>

<hr>
<h2 id='plot.measure-of-accuracy'>Plot a <code>MSPE</code> or <code>MAPE</code> object</h2><span id='topic+plot.measure-of-accuracy'></span><span id='topic+plot.MSPE'></span><span id='topic+plot.MAPE'></span>

<h3>Description</h3>

<p>The function <code>plot.MSPE</code> plots a <code>MSPE</code> object that is returned by
the <code>MSPE</code> function.
The function <code>plot.MAPE</code> plots a <code>MAPE</code> object that is returned by
the <code>MAPE</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSPE'
plot(x, vr = NULL, h = 1, N_min = 1, legend = TRUE,
  display.mins = TRUE, add.for.legend = 0, ...)

## S3 method for class 'MAPE'
plot(x, vr = NULL, h = 1, N_min = 1, legend = TRUE,
  display.mins = TRUE, add.for.legend = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.measure-of-accuracy_+3A_x">x</code></td>
<td>
<p>The <code>MSPE</code> or <code>MAPE</code> object to be plotted.</p>
</td></tr>
<tr><td><code id="plot.measure-of-accuracy_+3A_vr">vr</code></td>
<td>
<p>parameter to plot a line at level <code>vr</code>.
Intended to be used to plot the mean squared prediction error
of the trivial, null predictor; optional.</p>
</td></tr>
<tr><td><code id="plot.measure-of-accuracy_+3A_h">h</code></td>
<td>
<p>Defines for which <code class="reqn">h</code>-step predictor the mean squared
prediction errors will be shown; default: 1.</p>
</td></tr>
<tr><td><code id="plot.measure-of-accuracy_+3A_n_min">N_min</code></td>
<td>
<p>If specified, the mean squared prediction errors with
<code class="reqn">N &lt; N_{\rm min}</code> will not be shown; integer and optional.</p>
</td></tr>
<tr><td><code id="plot.measure-of-accuracy_+3A_legend">legend</code></td>
<td>
<p>Flag to specify if a legend, indicating which colour of the
lines corresponds to which <code class="reqn">p</code>, will be shown;
default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.measure-of-accuracy_+3A_display.mins">display.mins</code></td>
<td>
<p>Flag to specify if the minima for each <code class="reqn">p</code>, and the
minimum accross <code class="reqn">N=0</code> will be highlighted.</p>
</td></tr>
<tr><td><code id="plot.measure-of-accuracy_+3A_add.for.legend">add.for.legend</code></td>
<td>
<p>add this much extra space for the legend, right of the
lines.</p>
</td></tr>
<tr><td><code id="plot.measure-of-accuracy_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the underlying plot method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the plot, as specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MSPE">MSPE</a></code>, <code><a href="#topic+MAPE">MAPE</a></code>
</p>

<hr>
<h2 id='predCoef'><code class="reqn">h</code>-step Prediction coefficients</h2><span id='topic+predCoef'></span>

<h3>Description</h3>

<p>This function computes the localised and iterated Yule-Walker coefficients
for h-step ahead forecasting of <code class="reqn">X_{t+h}</code> from <code class="reqn">X_{t}, ..., X_{t-p+1}</code>,
where <code class="reqn">h = 1, \ldots,</code> <code>H</code> and <code class="reqn">p = 1, \ldots,</code> <code>P</code>.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predCoef_+3A_x">X</code></td>
<td>
<p>the data <code class="reqn">X_1, \ldots, X_T</code></p>
</td></tr>
<tr><td><code id="predCoef_+3A_p">P</code></td>
<td>
<p>the maximum order of coefficients to be computed; has to be a positive integer</p>
</td></tr>
<tr><td><code id="predCoef_+3A_h">H</code></td>
<td>
<p>the maximum lead time; has to be a positive integer</p>
</td></tr>
<tr><td><code id="predCoef_+3A_t">t</code></td>
<td>
<p>a vector of values <code class="reqn">t</code>; the elements have to satisfy
<code>max(t) &lt;= length(X)</code> and  <code>min(t) &gt;= min(max(N[N != 0]),p)</code>.</p>
</td></tr>
<tr><td><code id="predCoef_+3A_n">N</code></td>
<td>
<p>a vector of values <code class="reqn">N</code>; the elements have to satisfy
<code>max(N[N != 0]) &lt;= min(t)</code> and <code>min(N[N != 0]) &gt;= 1 + P</code>.
<code class="reqn">N = 0</code> corresponds to the case where all data is taken into account.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every <code class="reqn">t \in</code> <code>t</code> and every <code class="reqn">N \in</code> <code>N</code> the (iterated) Yule-Walker
estimates <code class="reqn">\hat v_{N,T}^{(p,h)}(t)</code> are computed. They are defined as
</p>
<p style="text-align: center;"><code class="reqn">\hat v_{N,T}^{(p,h)}(t) :=  e'_1 \big( e_1 \big( \hat a_{N,T}^{(p)}(t) \big)' + H \big)^h, \quad N \geq 1,</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\hat v_{0,T}^{(p,h)}(t) :=  \hat v_{t,T}^{(p,h)}(t),</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn"> e_1 := \left(\begin{array}{c} 1 \\ 0 \\ \vdots \\ 0 \end{array} \right), \quad H := \left( \begin{array}{ccccc} 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 \\ \vdots &amp; \ddots &amp; \cdots &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0 \end{array} \right)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn"> \hat a_{N,T}^{(p)}(t) := \big( \hat\Gamma_{N,T}^{(p)}(t) \big)^{-1} \hat\gamma_{N,T}^{(p)}(t),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat\Gamma_{N,T}^{(p)}(t) := \big[ \hat \gamma_{i-j;N,T}(t) \big]_{i,j = 1, \ldots, p}, \quad \hat \gamma_{N,T}^{(p)}(t) := \big( \hat \gamma_{1;N,T}(t), \ldots, \hat \gamma_{p;N,T}(t) \big)'</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\hat \gamma_{k;N,T}(t) := \frac{1}{N} \sum_{\ell=t-N+|k|+1}^{t} X_{\ell-|k|,T} X_{\ell,T}</code>
</p>

<p>is the usual lag-<code class="reqn">k</code> autocovariance estimator (without mean adjustment),
computed from the observations <code class="reqn">X_{t-N+1}, \ldots, X_{t}</code>.
</p>
<p>The Durbin-Levinson Algorithm is used to successively compute the solutions to the
Yule-Walker equations (cf. Brockwell/Davis (1991), Proposition 5.2.1).
To compute the <code class="reqn">h</code>-step ahead coefficients we use the recursive relationship
</p>
<p style="text-align: center;"><code class="reqn">\hat v_{i,N,T}^{(p)}(t,h) = \hat a_{i,N,T}^{(p)}(t) \hat v_{1,N,T}^{(p,h-1)}(t) + \hat v_{i+1,N,T}^{(p,h-1)}(t) I\{i \leq p-1\},</code>
</p>

<p>(cf. Section 3.2, Step 3, in Kley et al. (2019)).
</p>


<h3>Value</h3>

<p>Returns a named list with elements <code>coef</code>, <code>t</code>, and <code>N</code>,
where <code>coef</code> is an array of dimension
<code>P</code> <code class="reqn">\times</code> <code>P</code> <code class="reqn">\times</code> <code>H</code> <code class="reqn">\times</code>
<code>length(t)</code> <code class="reqn">\times</code> <code>length(N)</code>, and
<code>t</code>, and <code>N</code> are the parameters provided on the call of the
function. See the example on how to access the vector
<code class="reqn">\hat v_{N,T}^{(p,h)}(t)</code>.
</p>


<h3>References</h3>

<p>Brockwell, P. J. &amp; Davis, R. A. (1991).
Time Series: Theory and Methods. Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- 100
X &lt;- rnorm(T)

P &lt;- 5
H &lt;- 1
m &lt;- 20

Nmin &lt;- 25
pcoef &lt;- predCoef(X, P, H, (T - m - H + 1):T, c(0, seq(Nmin, T - m - H, 1)))

## Access the prediction vector for p = 2, h = 1, t = 95, N = 25
p &lt;- 2
h &lt;- 1
t &lt;- 95
N &lt;- 35
res &lt;- pcoef$coef[p, 1:p, h, pcoef$t == t, pcoef$N == N]
</code></pre>

<hr>
<h2 id='ts-models-tvARMA'>Simulation of an tvARMA(p,q) time series.</h2><span id='topic+ts-models-tvARMA'></span><span id='topic+tvARMA'></span>

<h3>Description</h3>

<p>Returns a simulated time series <code class="reqn">Y_{1,T}, ..., Y_{T,T}</code> that fulfills
the following equation:
</p>
<p style="text-align: center;"><code class="reqn">Y_{t,T} = \sum_{j=1}^p a_j(t/T) Y_{t-j,T} + \sigma(t/T) \varepsilon_{t} + \sum_{k=1}^q \sigma((t-k)/T) b_k(t/T) \varepsilon_{t-k},</code>
</p>

<p>where <code class="reqn">a_1, \ldots, a_p, b_0, b_1, \ldots, b_q</code> are real-valued functions on <code class="reqn">[0,1]</code>,
<code class="reqn">\sigma</code> is a positive function on <code class="reqn">[0,1]</code> and <code class="reqn">\varepsilon_t</code>
is white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvARMA(T = 128, a = list(), b = list(), sigma = function(u) {    
  return(1) }, innov = function(n) {     rnorm(n, 0, 1) })
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts-models-tvARMA_+3A_t">T</code></td>
<td>
<p>length of the time series to be returned</p>
</td></tr>
<tr><td><code id="ts-models-tvARMA_+3A_a">a</code></td>
<td>
<p>list of p real-valued functions defined on <code class="reqn">[0,1]</code></p>
</td></tr>
<tr><td><code id="ts-models-tvARMA_+3A_b">b</code></td>
<td>
<p>list of q real-valued functions defined on <code class="reqn">[0,1]</code></p>
</td></tr>
<tr><td><code id="ts-models-tvARMA_+3A_sigma">sigma</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="ts-models-tvARMA_+3A_innov">innov</code></td>
<td>
<p>a function with one argument <code>n</code> that simulates a vector of
the <code>n</code> residuals <code class="reqn">\varepsilon_t</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tvARMA(p,q) time series with specified parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Taken from Section 6 in Dahlhaus (1997, AoS)
a1 &lt;- function(u) {1.8 * cos(1.5 - cos(4 * pi * u))}
a2 &lt;- function(u) {-0.81}
plot(tvARMA(128, a = list(a1, a2), b = list()), type = "l")
</code></pre>

<hr>
<h2 id='tvARMAcpp'>Workhorse function for tvARMA time series generation</h2><span id='topic+tvARMAcpp'></span>

<h3>Description</h3>

<p>More explanation!
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvARMAcpp_+3A_z">z</code></td>
<td>
<p>a ...</p>
</td></tr>
<tr><td><code id="tvARMAcpp_+3A_x_int">x_int</code></td>
<td>
<p>a ...</p>
</td></tr>
<tr><td><code id="tvARMAcpp_+3A_a">A</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="tvARMAcpp_+3A_b">B</code></td>
<td>
<p>a ...</p>
</td></tr>
<tr><td><code id="tvARMAcpp_+3A_sigma">Sigma</code></td>
<td>
<p>a ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ...
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
