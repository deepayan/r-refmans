<!DOCTYPE html><html><head><title>Help for package bigMap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigMap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bdm.boxp'><p>Clustering statistics box-plot.</p></a></li>
<li><a href='#bdm.cost'><p>ptSNE cost &amp; size plot.</p></a></li>
<li><a href='#bdm.dMap'><p>Class density maps</p></a></li>
<li><a href='#bdm.dMap.plot'><p>Class density maps plot.</p></a></li>
<li><a href='#bdm.example'><p>Example dataset</p></a></li>
<li><a href='#bdm.fName'><p>Default <var>bdm</var> file name</p></a></li>
<li><a href='#bdm.init'><p>Create <var>bdm</var> instance</p></a></li>
<li><a href='#bdm.labels'><p>Get data-point clustering labels.</p></a></li>
<li><a href='#bdm.local'><p>Set/get default local machine name or IP address</p></a></li>
<li><a href='#bdm.merge.s2nr'><p>Merging of clusters based on signal-to-noise-ratio.</p></a></li>
<li><a href='#bdm.mybdm'><p>Set/get default path for <var>mybdm</var></p></a></li>
<li><a href='#bdm.optk.plot'><p>Plots the signal-to-nois-ratio as a function of the number of clusters.</p></a></li>
<li><a href='#bdm.optk.s2nr'><p>Find optimal number of clusters based on signal-to-noise-ratio.</p></a></li>
<li><a href='#bdm.pakde'><p>Perplexity-adaptive kernel density estimation</p></a></li>
<li><a href='#bdm.pakde.plot'><p>Plot paKDE (density landscape)</p></a></li>
<li><a href='#bdm.ptsne'><p>Parallelized t-SNE</p></a></li>
<li><a href='#bdm.ptsne.plot'><p>Plot ptSNE (low-dimensional embedding)</p></a></li>
<li><a href='#bdm.qMap'><p>ptSNE quantile-maps</p></a></li>
<li><a href='#bdm.save'><p>Save <var>bdm</var> instance</p></a></li>
<li><a href='#bdm.scp'><p>Transfer <var>bdm</var> instance to a remote machine.</p></a></li>
<li><a href='#bdm.wtt'><p>Watertrack transform (WTT)</p></a></li>
<li><a href='#bdm.wtt.plot'><p>Plot WTT (clustering)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Big Data Mapping</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-06-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Unsupervised clustering protocol for large scale structured data, based on a low dimensional representation of the data. Dimensionality reduction is performed using a parallelized implementation of the t-Stochastic Neighboring Embedding algorithm (Garriga J. and Bartumeus F. (2018), &lt;<a href="https://doi.org/10.48550/arXiv.1812.09869">doi:10.48550/arXiv.1812.09869</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.0), bigmemory (&ge; 4.5.0), parallel (&ge; 3.5.0),
RColorBrewer, colorspace,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, BH, bigmemory</td>
</tr>
<tr>
<td>LazyData:</td>
<td>FALSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-30 14:03:24 UTC; jgarriga</td>
</tr>
<tr>
<td>Author:</td>
<td>Joan Garriga [aut, cre],
  Frederic Bartumeus [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joan Garriga &lt;jgarriga@ceab.csic.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-30 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bdm.boxp'>Clustering statistics box-plot.</h2><span id='topic+bdm.boxp'></span>

<h3>Description</h3>

<p>Clustering statistics box-plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.boxp(bdm, byVars = F, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.boxp_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.boxp_+3A_byvars">byVars</code></td>
<td>
<p>A logical value. By default (<code>byVars = FALSE</code>) box-plots are grouped by cluster. With <code>byVars = TRUE</code> box-plots are grouped by input feature.</p>
</td></tr>
<tr><td><code id="bdm.boxp_+3A_layer">layer</code></td>
<td>
<p>The number of a layer (1 by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the number of clusters is large, only the first 25 clusters will be plotted. Note that the WTT algorithm numbers the clusters based on density value at the peak cell of the cluster. Thus, the numbering of the clusters is highly correlated with their relevance in terms of partial density. Therefore, in case of more than 25 clusters, the most relevant should always be included in the plot.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
bdm.boxp(exMap)
bdm.boxp(exMap, byVars = TRUE)
</code></pre>

<hr>
<h2 id='bdm.cost'>ptSNE cost &amp; size plot.</h2><span id='topic+bdm.cost'></span>

<h3>Description</h3>

<p>ptSNE cost &amp; size plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.cost(bdm, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.cost_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code> or a list of them to make a comparative plot.</p>
</td></tr>
<tr><td><code id="bdm.cost_+3A_offset">offset</code></td>
<td>
<p>X-axis offset in number of epochs (0 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
bdm.cost(exMap)
</code></pre>

<hr>
<h2 id='bdm.dMap'>Class density maps</h2><span id='topic+bdm.dMap'></span>

<h3>Description</h3>

<p>Compute the class density maps of a set of classes on the embedding grid. This function returns a fuzzy mapping of the set of classes on the grid cells.  The classes can be whatever set of classes of interest and must be given as a vector of point-wise discrete labels (either numeric, string or factor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.dMap(bdm, threads = 2, type = "SOCK", data = NULL, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.dMap_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.dMap_+3A_threads">threads</code></td>
<td>
<p>The number of parallel threads (in principle only limited by hardware resources, <code>i.e.</code> number of cores and available memory)</p>
</td></tr>
<tr><td><code id="bdm.dMap_+3A_type">type</code></td>
<td>
<p>The type of cluster: 'SOCK' (default) for intra-node parallelization, 'MPI' for inter-node parallelization (<code>message passing interface</code> parallel environment).</p>
</td></tr>
<tr><td><code id="bdm.dMap_+3A_data">data</code></td>
<td>
<p>A vector of discret covariates or class labels. The covariate values can be of any factorizable type. By default (<code>data=NULL</code>) the function computes the density maps based on the clustering labels (i.e. equivalent to <code>data=bdm.labels(bdm)</code>)</p>
</td></tr>
<tr><td><code id="bdm.dMap_+3A_layer">layer</code></td>
<td>
<p>The number of the t-SNE layer (1 by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bdm.dMap()</code> computes the join distribution <code class="reqn">P(V=v_{i},C=c_{j})</code> where <code class="reqn">V={v_{1},\dots,v_{l}}</code> is the discrete covariate and <code class="reqn">C={c_{1},\dots, c_{g}}</code> are the grid cells of the paKDE raster. That is, this function recomputes the paKDE but keeping track of the covariate (or class) label of each data-point. This results in a fuzzy distribution of the covariate (class) at each cell.
</p>
<p>Usually, figuring out the join distribution <code class="reqn">P(V=v_{i},C=c_{j})</code> entails an intensive computation. Thus <code>bdm.dMap()</code> performs the computation and stores the result in a dedicated element named <var>$dMap</var>. Afterwards the class density maps can be visualized with the <code>bdm.dMap.plot()</code> function.
</p>


<h3>Value</h3>

<p>A copy of the input <var>bdm</var> instance with element <var>$dMap</var>, a matrix with a soft clustering of the grid cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- load example dataset
bdm.example()
## Not run: 
exMap &lt;- bdm.dMap(exMap, threads = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdm.dMap.plot'>Class density maps plot.</h2><span id='topic+bdm.dMap.plot'></span>

<h3>Description</h3>

<p>Class density maps plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.dMap.plot(bdm, classes = NULL, join = FALSE, class.pltt = NULL,
  pakde.pltt = NULL, pakde.lvls = 16, wtt.lwd = 1, plot.peaks = T,
  labels.cex = 1, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.dMap.plot_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_classes">classes</code></td>
<td>
<p>A vector with a subset of class names or covariate values. Default value is <code>classes=NULL</code>. If no classes are specified (default value) all classes are plotted.</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_join">join</code></td>
<td>
<p>Logical value. If FALSE (default value), class mapping is based on the class conditional distributions. If TRUE, class mapping is based on the overall classes join distribution.</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_class.pltt">class.pltt</code></td>
<td>
<p>A colour palette to show class labels in the hard mapping. By default (<code>class.pltt = NULL</code>) the default palette is used.</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_pakde.pltt">pakde.pltt</code></td>
<td>
<p>A palette of colours to indicate the levels of the class density maps. The length of the colour palette should be at least the number of levels specified in <var>pakde.lvls</var>.</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_pakde.lvls">pakde.lvls</code></td>
<td>
<p>The number of levels of the heat-map when plotting class density maps (16 by default).</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_wtt.lwd">wtt.lwd</code></td>
<td>
<p>The width of the watertrack lines (as set in <code>par()</code>).</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_plot.peaks">plot.peaks</code></td>
<td>
<p>Logical value (TRUE by default). If set to TRUE and the up-stream step <code>bdm$wtt()</code> is computed the peak of each cluster is depicted.</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_labels.cex">labels.cex</code></td>
<td>
<p>If <var>plot.peaks</var> is TRUE, the size of the labels of the clusters (as set in <code>par()</code>). By default <code>labels.cex=0.0</code> and the labels of the clusters are not depicted.</p>
</td></tr>
<tr><td><code id="bdm.dMap.plot_+3A_layer">layer</code></td>
<td>
<p>The number of the layer from which the class density maps are computed (1 by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bdm.dMap.plot()</code> yields a multi-plot layout where the first plot shows the dominating value of the covariate (or dominating class) in each cell, and the rest of the plots show the density map of each covariate value (or class).
</p>
<p>The join distribution <code class="reqn">P(V=v_{i},C=c_{j})</code> will be affected by the bias present in the marginal distribution of the covariate. Therefore, the join distribution <code class="reqn">P(V=v_{i},C=c_{j})</code> is transformed, by default, into a conditional distribution <code class="reqn">P(c_{j}|V=v_{i})</code> (where the <code class="reqn">c_{j}</code> are the grid cells of the embedding and V is the covariate (or class)). Thus, the first plot shows a hard classification of grid-cells, (cells are coloured based on the dominating value of the covariate (or dominating class), <em>i.e</em>. the <code class="reqn">v_{i}</code> for which <code class="reqn">P(c_{j}|V=v_{i})</code> is maximum), and the rest of the plots show the conditional distributions <code class="reqn">P(C=c_{j}|V=v_{i})</code>. This makes the plots of the different classes not directly comparable but the dominant areas of each class can be more easily identified.
</p>
<p>However, the same plots can be depicted based on the join distribution by setting <code>join = TRUE</code>. This makes sense when the bias in the covariate values (or classes) is not significant. In this case the hard clustering shows the real dominance of each covariate value (or class) over the embedding area and the density maps are comparable one to each other (although, individually, they are not real density functions as they do not add up to one).
</p>
<p>The multi-plot layout can be limited to a subset of the values of the covariate (or subset of classes) specified in parameter <code>classes</code>.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- load example dataset
bdm.example()
## Not run: 
exMap &lt;- bdm.dMap(exMap, threads = 4)
bdm.dMap.plot(exMap)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdm.example'>Example dataset</h2><span id='topic+bdm.example'></span>

<h3>Description</h3>

<p>Loads an example of a mapping of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.example()
</code></pre>


<h3>Details</h3>

<p>A <var>bdm</var> instance is a list with elements: <var>$dSet</var> a name identifying the dataset (<code>bdm.fName()</code> use this name to generate a default file name); <var>$data</var> a matrix with raw data; <var>$lbls</var> a vector of datapoint labels (in case they are known); <var>$N</var> the dataset size; <var>$is.distance</var> a logical value that is set to TRUE when the raw data is a distance matrix. Downstream steps of the mapping protocol will add more elements to the list.
</p>
<p>This example is based on a small synthetic dataset with <code>n = 5000</code> observations drawn from a 4-variate Gaussian Mixture Model (GMM) with 16 Gaussian components.
</p>


<h3>Value</h3>

<p>An example <var>bdm</var> instance named <var>exMap</var>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- load example dataset
bdm.example()
str(exMap)
</code></pre>

<hr>
<h2 id='bdm.fName'>Default <var>bdm</var> file name</h2><span id='topic+bdm.fName'></span>

<h3>Description</h3>

<p>Generates a default file name. The default file name is intended for functions <code>bdm.save()</code> and <code>bdm.scp()</code> to ease the task of working/organizing multiple runs on the same dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.fName(bdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.fName_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file name is generated based on <code>bdm$dSet</code> and main ptSNE parameters (threads, layers, rounds, boost and perplexity). In case that <code>bdm.wtt()</code> has been performed on any of the layers, the number of clusters in the first not null layer of bdm$wtt is also included.
</p>


<h3>Value</h3>

<p>A <var>*.RData</var> file name based on <var>bdm$dSet</var> and main <var>bdm</var> parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
str(exMap$dSet)
str(exMap$ptsne)
bdm.fName(exMap)
</code></pre>

<hr>
<h2 id='bdm.init'>Create <var>bdm</var> instance</h2><span id='topic+bdm.init'></span>

<h3>Description</h3>

<p>Creates a <var>bdm</var> instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.init(dSet.name, dSet.data, labels = NULL, is.distance = F,
  check.duplicates = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.init_+3A_dset.name">dSet.name</code></td>
<td>
<p>The name given to the input dataset. This name will be used to automatically generate a name to save the output as an <var>.Rdata</var> file.</p>
</td></tr>
<tr><td><code id="bdm.init_+3A_dset.data">dSet.data</code></td>
<td>
<p>A <var>data.frame</var> or <var>matrix</var> with raw input-data. The dataset must not have duplicated rows.</p>
</td></tr>
<tr><td><code id="bdm.init_+3A_labels">labels</code></td>
<td>
<p>If available, labels can be included as a separate vector of length equal to <code>nrow(dSet.data)</code>. Label values are factorized as <code>as.numeric(as.factor(labels))</code>.</p>
</td></tr>
<tr><td><code id="bdm.init_+3A_is.distance">is.distance</code></td>
<td>
<p>A logical value (FALSE by default). TRUE indicates that the raw data is indeed a distance matrix.</p>
</td></tr>
<tr><td><code id="bdm.init_+3A_check.duplicates">check.duplicates</code></td>
<td>
<p>If set to TRUE (default value) the dataset is checked for duplicated rows. Checking for duplicates in big datasets can take some time. If the dataset is known to have no duplicates disabling this option will save time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <var>bdm</var> instance. A <var>bdm</var> instance is initially a list with a few elements to which new elements are added at each step of the mapping protocol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- get a matrix with raw-data
mydata &lt;- matrix(rnorm(10000, mean = 0, sd = 3),  ncol = 2)
mylabels &lt;- apply(mydata, 1, function(row) round(sqrt(sum(row**2)), 0))
# --- create a \var{bdm} instance with our raw-data matrix
mybdm &lt;- bdm.init('mydataset', mydata, labels = mylabels)
str(mybdm)
</code></pre>

<hr>
<h2 id='bdm.labels'>Get data-point clustering labels.</h2><span id='topic+bdm.labels'></span>

<h3>Description</h3>

<p>Given that clusters are computed at grid-cell level, this function returns the clustering label for each data-point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.labels(bdm, merged = T, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.labels_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.labels_+3A_merged">merged</code></td>
<td>
<p>A logical value. If TRUE (default value) and the <var>bdm</var> has been merged, the data-point labelling indicate the number of the merged clusters. If <var>merged</var> is set to FALSE or the <var>bdm</var> has not been merged the data-point labels correspond to the top-level clustering.</p>
</td></tr>
<tr><td><code id="bdm.labels_+3A_layer">layer</code></td>
<td>
<p>The number of the t-SNE layer (1 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of data-point clustering labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
exMap.labels &lt;- bdm.labels(exMap)
</code></pre>

<hr>
<h2 id='bdm.local'>Set/get default local machine name or IP address</h2><span id='topic+bdm.local'></span>

<h3>Description</h3>

<p>Set/get default local machine name or IP address
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.local(dest = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.local_+3A_dest">dest</code></td>
<td>
<p>Name or IP address of the local machine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current value of <var>local</var>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- set default value of \var{local}
bdm.local('xxx.255.0.0')
bdm.local('mymachine.mydomain.cat')
</code></pre>

<hr>
<h2 id='bdm.merge.s2nr'>Merging of clusters based on signal-to-noise-ratio.</h2><span id='topic+bdm.merge.s2nr'></span>

<h3>Description</h3>

<p>Performs a recursive merging of clusters based on minimum loss of signal-to-noise-ratio (S2NR) until reaching the desired number of clusters. The S2NR is the explained/unexplained variance ratio measured in the high dimensional space based on the given low dimensional clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.merge.s2nr(bdm, k = 10, plot.merge = T, ret.merge = F,
  info = T, layer = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.merge.s2nr_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.merge.s2nr_+3A_k">k</code></td>
<td>
<p>The number of desired clusters. The clustering will be recursively merged until reaching this number of clusters (default value is <code>k = 10</code>). By setting <code>k &lt; 0</code> we can specify the number of clusters that we are willing to merge.</p>
</td></tr>
<tr><td><code id="bdm.merge.s2nr_+3A_plot.merge">plot.merge</code></td>
<td>
<p>Logical value. If TRUE, the merged clustering is plotted (default value is <code>plot.merge = TRUE</code>)</p>
</td></tr>
<tr><td><code id="bdm.merge.s2nr_+3A_ret.merge">ret.merge</code></td>
<td>
<p>Logical value. If TRUE, the function returns a copy of the input <var>bdm</var> instance with the merged clustering attached as <var>bdm$merge</var> (default value is <code>ret.merge = FALSE</code>)</p>
</td></tr>
<tr><td><code id="bdm.merge.s2nr_+3A_info">info</code></td>
<td>
<p>Logical value. If TRUE, all merging steps are shown (default value is <code>info = FALSE</code>).</p>
</td></tr>
<tr><td><code id="bdm.merge.s2nr_+3A_layer">layer</code></td>
<td>
<p>The <var>bdm$ptsne</var> layer to be used (default value is <code>layer = 1</code>).</p>
</td></tr>
<tr><td><code id="bdm.merge.s2nr_+3A_...">...</code></td>
<td>
<p>If <var>plot.merge</var> is TRUE, you can set the <code>bdm.wtt.plot()</code> parameters to control the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See details in <code>bdm.optk.s2nr()</code>.
</p>


<h3>Value</h3>

<p>None if <code>ret.merge = FALSE</code>. Else, a copy of the input <var>bdm</var> instance with new element <var>bdm$merge</var>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
exMap.labels &lt;- bdm.labels(exMap)
</code></pre>

<hr>
<h2 id='bdm.mybdm'>Set/get default path for <var>mybdm</var></h2><span id='topic+bdm.mybdm'></span>

<h3>Description</h3>

<p>Set/get default path for <var>mybdm</var>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.mybdm(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.mybdm_+3A_path">path</code></td>
<td>
<p>Path to <var>mybdm</var>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current path value to <var>mybdm</var>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- set default path for \var{mybdm}
bdm.mybdm('~/mybdm')
</code></pre>

<hr>
<h2 id='bdm.optk.plot'>Plots the signal-to-nois-ratio as a function of the number of clusters.</h2><span id='topic+bdm.optk.plot'></span>

<h3>Description</h3>

<p>The function <code>bdm.optk.sn2r()</code> computes the S2NR that results from recursively merging clusters and, by deafult, makes a plot of these values. For large datasets this computation can take a while, so we can save this result by setting <code>ret.optk = TRUE</code>. If this result is saved, we can plot it again at any time using this funcion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.optk.plot(bdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.optk.plot_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
exMap &lt;- bdm.optk.s2nr(exMap, ret.optk = TRUE)
bdm.optk.plot(exMap)
</code></pre>

<hr>
<h2 id='bdm.optk.s2nr'>Find optimal number of clusters based on signal-to-noise-ratio.</h2><span id='topic+bdm.optk.s2nr'></span>

<h3>Description</h3>

<p>Performs a recursive merging of clusters based on minimum loss of signal-to-noise-ratio (S2NR). The S2NR is the explained/unexplained variance ratio measured in the high dimensional space based on the given low dimensional clustering. Merging is applied recursively until reaching a configuration of only 2 clusters and the S2NR is measured at each step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.optk.s2nr(bdm, info = T, plot.optk = T, ret.optk = F,
  layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.optk.s2nr_+3A_bdm">bdm</code></td>
<td>
<p>A clustered <var>bdm</var> instance (<var>i.e.</var> all up-stream steps performed: <code>bdm.ptse(), bdm.pakde() and bdm.wtt()</code>.</p>
</td></tr>
<tr><td><code id="bdm.optk.s2nr_+3A_info">info</code></td>
<td>
<p>Logical value. If TRUE, all merging steps are shown (default value is <code>info = FALSE</code>).</p>
</td></tr>
<tr><td><code id="bdm.optk.s2nr_+3A_plot.optk">plot.optk</code></td>
<td>
<p>Logical value. If TRUE, this function plots the heuristic measure versus the number of clusters (default value is <code>plot.optk = TRUE</code>)</p>
</td></tr>
<tr><td><code id="bdm.optk.s2nr_+3A_ret.optk">ret.optk</code></td>
<td>
<p>Logical value. For large datasets this computation can take a while and it might be interesting to save it. If TRUE, the function returns a copy of the <var>bdm</var> instance with the values of S2NR attached as <var>bdm$optk</var> (default value is <code>ret.optk = FALSE</code>).</p>
</td></tr>
<tr><td><code id="bdm.optk.s2nr_+3A_layer">layer</code></td>
<td>
<p>The <var>bdm$ptsne</var> layer to be used (default value is <code>layer = 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logic under this heuristic is that neigbouring clusters in the embedding correspond to close clusters in the high dimensional space, <var>i.e.</var> it is a merging heuristic based on the spatial distribution of clusters. For each cluster (child cluster) we choose the neighboring cluster with steepest gradient along their common border (father cluster). Thus, we get a set of pairs of clusters (child/father) as potential mergings. Given this set of candidates, the merging is performed recursively choosing, at each step, the pair of child/father clusters that results in a minimum loss of S2NR.
A typical situation is that some clusters dominate over all of their neighboring clusters. This clusters have no <var>father</var>. Thus, once all candidate mergings have been performed we reach a <var>blocked</var> state where only the dominant clusters remain. This situation identifies a hierarchy level in the clustering. When this situation is reached, the algorithm starts a new merging round, identifying the child/father relations at that level of hierarchy. The process stops when only two clusters remain.
Usually, the clustering hierarchy is clearly depicted by singular points in the S2NR function. This is a hint that the low dimensional clustering configuration is an image of a hierarchycal spatial configuration in the high dimensional space. See <code>bdm.optk.plot()</code>.
</p>


<h3>Value</h3>

<p>None if <code>ret.optk = FALSE</code>. Else, a copy of the input <var>bdm</var> instance with new element <var>bdm$optk</var> (a matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- load mapped dataset
bdm.example()
# --- compute optimal number of clusters and attach the computation
bdm.optk.s2nr(exMap, plot.optk = TRUE, ret.optk = FALSE)
</code></pre>

<hr>
<h2 id='bdm.pakde'>Perplexity-adaptive kernel density estimation</h2><span id='topic+bdm.pakde'></span>

<h3>Description</h3>

<p>Starts the paKDE algorithm (second step of the mapping protocol).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.pakde(bdm, layer = 1, threads = 2, type = "SOCK", ppx = 100,
  itr = 100, tol = 1e-05, g = 200, g.exp = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.pakde_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.pakde_+3A_layer">layer</code></td>
<td>
<p>The number of the t-SNE layer (1 by default).</p>
</td></tr>
<tr><td><code id="bdm.pakde_+3A_threads">threads</code></td>
<td>
<p>The number of parallel threads (in principle only limited by hardware resources, <code>i.e.</code> number of cores and available memory)</p>
</td></tr>
<tr><td><code id="bdm.pakde_+3A_type">type</code></td>
<td>
<p>The type of cluster: 'SOCK' (default) for intra-node parallelization, 'MPI' (<code>message passing interface</code>) for inter-node parallelization.</p>
</td></tr>
<tr><td><code id="bdm.pakde_+3A_ppx">ppx</code></td>
<td>
<p>The value of perplexity to compute similarities in the low-dimensional embedding (100 by default).</p>
</td></tr>
<tr><td><code id="bdm.pakde_+3A_itr">itr</code></td>
<td>
<p>The number of iterations for computing input similarities (100 by default).</p>
</td></tr>
<tr><td><code id="bdm.pakde_+3A_tol">tol</code></td>
<td>
<p>The tolerance lower bound for computing input similarities (1e-05 by default).</p>
</td></tr>
<tr><td><code id="bdm.pakde_+3A_g">g</code></td>
<td>
<p>The resolution of the density space grid (<code class="reqn">g*g</code> cells, 200 by default).</p>
</td></tr>
<tr><td><code id="bdm.pakde_+3A_g.exp">g.exp</code></td>
<td>
<p>A numeric factor to avoid border effects. The grid limits will be expanded so as to enclose the density of the kernel of the most extreme embedded datapoints up to <code>g.exp</code> times <code class="reqn">\sigma</code>. By default, (<code>g.exp = 3</code>) the grid limits are expanded so as to enclose the 0.9986 of the probability mass of the most extreme kernels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When computing the <var>paKDE</var> the embedding area is discretized as a grid of size <code>g*g</code> cells. In order to avoid border effects, the limits of the grid are expanded by default so as to enclose at least the 0.9986 of the cumulative distribution function (<code class="reqn">3 \sigma</code>) of the kernels of the most extreme mapped points in each direction.
</p>
<p>The presence of outliers in the embedding can lead to undesired expansion of the grid limits. We can overcome this using lower values of <var>g.exp</var>. By setting <code>g.exp = 0</code> the grid limits will be equal to the range of the embedding.
</p>
<p>The values <var>g.exp = c(1, 2, 3, 4, 5, 6)</var> enclose cdf values of <var>0.8413, 0.9772, 0.9986, 0.99996, 0.99999, 1.0</var> respectively.
</p>


<h3>Value</h3>

<p>A copy of the input <var>bdm</var> instance with new element <var>bdm$pakde</var> (paKDE output). <code>bdm$pakde[[layer]]$layer = 'NC'</code> stands for not computed layers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- load mapped dataset
bdm.example()
# --- run paKDE
## Not run: 
exMap &lt;- bdm.pakde(exMap, threads = 4, ppx = 200, g = 200, g.exp = 3)

## End(Not run)
# --- plot paKDE output
bdm.pakde.plot(exMap)
</code></pre>

<hr>
<h2 id='bdm.pakde.plot'>Plot paKDE (density landscape)</h2><span id='topic+bdm.pakde.plot'></span>

<h3>Description</h3>

<p>Plot paKDE (density landscape)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.pakde.plot(bdm, pakde.pltt = NULL, pakde.lvls = 16, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.pakde.plot_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code> or a list of them to make a comparative plot.</p>
</td></tr>
<tr><td><code id="bdm.pakde.plot_+3A_pakde.pltt">pakde.pltt</code></td>
<td>
<p>A colour palette to show levels in the paKDE plot. By default (<code>pakde.pltt = NULL</code>) the default palette is used.</p>
</td></tr>
<tr><td><code id="bdm.pakde.plot_+3A_pakde.lvls">pakde.lvls</code></td>
<td>
<p>The number of levels of the density heat-map (16 by default).</p>
</td></tr>
<tr><td><code id="bdm.pakde.plot_+3A_layer">layer</code></td>
<td>
<p>The <var>bdm$ptsne</var> layer to be used (default value is <code>layer = 1</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
exMap &lt;- bdm.pakde.plot(exMap)
</code></pre>

<hr>
<h2 id='bdm.ptsne'>Parallelized t-SNE</h2><span id='topic+bdm.ptsne'></span>

<h3>Description</h3>

<p>Starts the ptSNE algorithm (first step of the mapping protocol).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.ptsne(bdm, threads = 3, type = "SOCK", layers = 2, rounds = 1,
  boost = 2, whiten = 4, input.dim = NULL, ppx = 100, itr = 100,
  tol = 1e-05, alpha = 0.5, Y.init = NULL, info = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.ptsne_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_threads">threads</code></td>
<td>
<p>The number of parallel threads (in principle only limited by hardware resources, <code>i.e.</code> number of cores and available memory)</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_type">type</code></td>
<td>
<p>The type of cluster: 'SOCK' (default) for intra-node parallelization, 'MPI' (<code>message passing interface</code>) for inter-node parallelization.</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_layers">layers</code></td>
<td>
<p>The number of layers (<code>minimum</code> 2, <code>maximum</code> the number of threads).</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_rounds">rounds</code></td>
<td>
<p>The number of rounds (2 by default).</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_boost">boost</code></td>
<td>
<p>A running time accelerator factor. By default (<code>boost == 1</code>). See details.</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_whiten">whiten</code></td>
<td>
<p>Preprocessing of raw data. If <code>whiten = 4</code> (default value) raw data is transformed to principal components (PCA) and whitened afterwards. If <code>whiten = 3</code> only PCA is performed with NO whitening. If <code>whiten = 2</code> raw data is only centered and scaled. If <code>whiten = 1</code> raw data is only centered. If <code>whiten = 0</code> no preprocessing is performed at all.</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_input.dim">input.dim</code></td>
<td>
<p>If raw data is given as (or is transformed to) principal components, <var>input.dim</var> sets the number of principal components to be used as input dimensions. Otherwise all data columns are used as input dimensions. By default <code>input.dim = ncol(bdm$data)</code>.</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_ppx">ppx</code></td>
<td>
<p>The value of perplexity to compute similarities (100 by default).</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_itr">itr</code></td>
<td>
<p>The number of iterations for computing input similarities (100 by default).</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_tol">tol</code></td>
<td>
<p>The tolerance lower bound for computing input similarities (1e-05 by default).</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_alpha">alpha</code></td>
<td>
<p>The momentum factor (0.5 by default).</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_y.init">Y.init</code></td>
<td>
<p>A <code>nx2</code> matrix with initial mapping positions. By default (<code>NULL</code>) will use random initial positions)</p>
</td></tr>
<tr><td><code id="bdm.ptsne_+3A_info">info</code></td>
<td>
<p>Progress output information: 1 yields inter-round results for progressive analytics, 0 disables intermediate results. Default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the algorithm is structured in <code class="reqn">\sqrt{n}</code> epochs of <code class="reqn">\sqrt{z}</code> iterations each, where <var>n</var> is the dataset size and <var>z</var> is the thread-size (<code class="reqn">z=n*layers/threads</code>). The running time of the algorithm is then determined by <code class="reqn">epochs*iters*t_i+ epochs*t_e</code> where <var>t_i</var> is the running time of a single iteration and <var>t_e</var> is the inter-epoch running time.
</p>
<p>The <var>boost</var> factor is meant to reduce the running time. With <code class="reqn">boost &gt; 1</code> the algorithm is structured in <code class="reqn">n/boost</code> epochs with <code class="reqn">z*boost</code> iterations each. This structure performs the same total number of iterations but arranged into a lower number of epochs, thus decreasing the total running time to <code class="reqn">epochs*iters*t_i + 1/boost*epochs*t_e</code>. When the number of threads is high, the inter-epoch time can be high, in particular when using 'MPI' parallelization, thus, reducing the number of epochs can result in a significant reduction of the total running time. The counterpart is that increasing the number of iterations per epoch might result in a lack of convergence, thus the <var>boost</var> factor must be used with caution. To the most of our knowledge using values up to <code class="reqn">boost=2.5</code> is generally safe.
</p>
<p>In case of extremely large datasets, we strongly recommend to initialize the <var>bdm</var> instance with already preprocessed data and use <code>whiten = 0</code>. Fast principal components approximations can be computed by means of <var>e.g.</var> <code>flashpcaR</code> or <code>scater</code> R packages.
</p>


<h3>Value</h3>

<p>A copy of the input <var>bdm</var> instance with new element <var>bdm$ptsne</var> (t-SNE output).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- load example dataset
bdm.example()
# --- perform ptSNE
## Not run: 
exMap &lt;- bdm.ptsne(exMap, threads = 10, layers = 2, rounds = 2, ppx = 200)

## End(Not run)
# --- plot the Cost function
bdm.cost(exMap)
# --- plot ptSNE output
bdm.ptsne.plot(exMap)
</code></pre>

<hr>
<h2 id='bdm.ptsne.plot'>Plot ptSNE (low-dimensional embedding)</h2><span id='topic+bdm.ptsne.plot'></span>

<h3>Description</h3>

<p>Plot ptSNE (low-dimensional embedding)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.ptsne.plot(bdm, ptsne.cex = 0.5, ptsne.bg = "#FFFFFF",
  class.pltt = NULL, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.ptsne.plot_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code> or a list of them to make a comparative plot.</p>
</td></tr>
<tr><td><code id="bdm.ptsne.plot_+3A_ptsne.cex">ptsne.cex</code></td>
<td>
<p>The size of the mapped data-points in the ptSNE plot. Default value is <code>ptsne.cex = 0.5</code>.</p>
</td></tr>
<tr><td><code id="bdm.ptsne.plot_+3A_ptsne.bg">ptsne.bg</code></td>
<td>
<p>The background colour of the ptSNE plot. Default value is <code>ptsne.bg = #FFFFFF</code> (white).</p>
</td></tr>
<tr><td><code id="bdm.ptsne.plot_+3A_class.pltt">class.pltt</code></td>
<td>
<p>A colour palette to show class labels in the ptSNE plot. If <code>!is.null(bdm$wtt)</code> cluster labels are used by default, else if <code>!is.null(bdm$lbls)</code> are used by default. If <code>ptsne.pltt = NULL</code> (default value) the default palette is used.</p>
</td></tr>
<tr><td><code id="bdm.ptsne.plot_+3A_layer">layer</code></td>
<td>
<p>The <var>bdm$ptsne</var> layer to be used (default value is <code>layer = 1</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
exMap &lt;- bdm.ptsne.plot(exMap)
</code></pre>

<hr>
<h2 id='bdm.qMap'>ptSNE quantile-maps</h2><span id='topic+bdm.qMap'></span>

<h3>Description</h3>

<p>Shows the mapping of quantitative variables into the embedding space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.qMap(bdm, data = NULL, labels = NULL, subset = NULL,
  qMap.levels = 8, qMap.cex = 0.3, qMap.bg = "#FFFFFF",
  class.pltt = NULL, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.qMap_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.qMap_+3A_data">data</code></td>
<td>
<p>A <code>matrix/data.frame</code> to be mapped. By default, the input data <var>bdm$data</var> is mapped.</p>
</td></tr>
<tr><td><code id="bdm.qMap_+3A_labels">labels</code></td>
<td>
<p>A vector of class labels of length equal to <code>nrow(bdm$data)</code>. Label values are factorized as <code>as.numeric(as.factor(labels))</code>. If <code>!is.null(bdm$lbls)</code>, these labels are used by default.</p>
</td></tr>
<tr><td><code id="bdm.qMap_+3A_subset">subset</code></td>
<td>
<p>A numeric vector with the indexes of a subset of data. Data-points in the subset are heat-mapped and the rest are shown in light grey. By default all data-points are heat-mapped.</p>
</td></tr>
<tr><td><code id="bdm.qMap_+3A_qmap.levels">qMap.levels</code></td>
<td>
<p>The number of levels of the quantile-map (8 by default).</p>
</td></tr>
<tr><td><code id="bdm.qMap_+3A_qmap.cex">qMap.cex</code></td>
<td>
<p>The size of the data-points (as in <code>par()</code>).</p>
</td></tr>
<tr><td><code id="bdm.qMap_+3A_qmap.bg">qMap.bg</code></td>
<td>
<p>The background colour of the qMap plot. Default value is <code>ptsne.bg = #FFFFFF</code> (white).</p>
</td></tr>
<tr><td><code id="bdm.qMap_+3A_class.pltt">class.pltt</code></td>
<td>
<p>If <code>!is.null(labels)</code> or <code>!is.null(bdm$lbls)</code>, a colour palette to show class labels with the qMap plots. By default (<code>qMap.pltt = NULL</code>) the default palette is used.</p>
</td></tr>
<tr><td><code id="bdm.qMap_+3A_layer">layer</code></td>
<td>
<p>The number of a layer (1 by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is not a heat-map but a quantile-map plot. This function splits the range of each variable into as many quantiles as specified by <var>levels</var> so that the color gradient will hardly ever correspond to a constant numeric gradient. Thus, the mapping will show more evenly distributed colors though at the expense of possibly exaggerating artifacts. For variables with very extrem distributions, it will be impossible to find as many quantiles as desired and the distribution of colors will not be so homogeneous.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
bdm.qMap(exMap)
# --- show only components (1, 2, 4, 8) of the GMM
bdm.qMap(exMap, subset = which(exMap$lbls %in% c(1, 4, 8, 16)))
</code></pre>

<hr>
<h2 id='bdm.save'>Save <var>bdm</var> instance</h2><span id='topic+bdm.save'></span>

<h3>Description</h3>

<p>Saves a <var>bdm</var> instance with default path/file names, as given by <code>bdm.mybdm()/bdm.fName(bdm)</code>. Default file name is generated based on <code>bdm$dSet</code> and ptSNE main parameters (threads, layers, boost, rounds, perplexity).  The purpose of functions <code>bdm.save()</code> and <code>bdm.scp()</code> used with <code>bdm.fName()</code> is to ease the task of working/organizing multiple runs on the same dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.save(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.save_+3A_...">...</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- get a matrix with raw-data
mydata &lt;- cbind(rnorm(10000, mean = 0, sd = 3),  ncol = 2)
mylabels &lt;- apply(mydata, 1, function(row) round(sqrt(sum(row**2)), 0))
# --- create a \var{bdm} instance with our raw-data matrix
mybdm &lt;- bdm.init('mydataset', mydata, labels = mylabels)
str(mybdm)
# --- save it
## Not run: 
bdm.save(mybdm)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdm.scp'>Transfer <var>bdm</var> instance to a remote machine.</h2><span id='topic+bdm.scp'></span>

<h3>Description</h3>

<p>Transfers a <var>bdm</var> instance to a remote machine. By default a file name is generated based on <code>bdm$dSet</code> and t-SNE main parameters (threads, layers, rounds, perplexity). The purpose of functions <code>bdm.save()</code> and <code>bdm.scp()</code> used with <code>bdm.fName()</code> is to ease the task of working/organizing multiple runs on the same dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.scp(..., dest = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.scp_+3A_...">...</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.scp_+3A_dest">dest</code></td>
<td>
<p>The name or IP address of a remote machine where to transfer the file of the <var>bdm</var> instance. By default is send to <var>bdm.local()</var> environment variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# --- load example
bdm.example()
# --- scp to \var{bdm.local()} with default file name
bdm.scp(exMap)
# --- scp to IP address 'xxx.xxx.0.0' with default file name
bdm.scp(exMap, dest = 'xxx.xxx.0.0')

## End(Not run)
</code></pre>

<hr>
<h2 id='bdm.wtt'>Watertrack transform (WTT)</h2><span id='topic+bdm.wtt'></span>

<h3>Description</h3>

<p>Starts the WTT algorithm (third setp of the mapping protocol).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.wtt(bdm, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.wtt_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code>.</p>
</td></tr>
<tr><td><code id="bdm.wtt_+3A_layer">layer</code></td>
<td>
<p>The number of the t-SNE layer (1 by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the up-stream step <code>bdm.pakde()</code>.
</p>


<h3>Value</h3>

<p>A copy of the input <var>bdm</var> instance with <var>bdm$wtt</var> (WTT output). <code>bdm$wtt[[layer]]$layer = 'NC'</code> stands for not computed layers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# --- load mapped dataset
bdm.example()
# --- perform WTT
exMap &lt;- bdm.wtt(exMap)
# --- plot WTT output
bdm.wtt.plot(exMap)
</code></pre>

<hr>
<h2 id='bdm.wtt.plot'>Plot WTT (clustering)</h2><span id='topic+bdm.wtt.plot'></span>

<h3>Description</h3>

<p>Plot WTT (clustering)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdm.wtt.plot(bdm, pakde.pltt = NULL, pakde.lvls = 16, wtt.lwd = 1,
  plot.peaks = T, labels.cex = 1, layer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdm.wtt.plot_+3A_bdm">bdm</code></td>
<td>
<p>A <var>bdm</var> instance as generated by <code>bdm.init()</code> or a list of them to make a comparative plot.</p>
</td></tr>
<tr><td><code id="bdm.wtt.plot_+3A_pakde.pltt">pakde.pltt</code></td>
<td>
<p>A colour palette to show levels in the paKDE plot. By default (<code>pakde.pltt = NULL</code>) the default palette is used.</p>
</td></tr>
<tr><td><code id="bdm.wtt.plot_+3A_pakde.lvls">pakde.lvls</code></td>
<td>
<p>The number of levels of the density heat-map (16 by default).</p>
</td></tr>
<tr><td><code id="bdm.wtt.plot_+3A_wtt.lwd">wtt.lwd</code></td>
<td>
<p>The width of the watertrack lines (as set in <code>par()</code>).</p>
</td></tr>
<tr><td><code id="bdm.wtt.plot_+3A_plot.peaks">plot.peaks</code></td>
<td>
<p>Logical value (TRUE by default). If set to TRUE and the up-stream step <code>bdm$wtt()</code> is computed marks the peak of each cluster.</p>
</td></tr>
<tr><td><code id="bdm.wtt.plot_+3A_labels.cex">labels.cex</code></td>
<td>
<p>If <var>plot.peaks</var> is TRUE, the size of the labels of the clusters (as set in <code>par()</code>). By default <code>labels.cex = 0.0</code> and the labels of the clusters are not depicted.</p>
</td></tr>
<tr><td><code id="bdm.wtt.plot_+3A_layer">layer</code></td>
<td>
<p>The <var>bdm$ptsne</var> layer to be used (default value is <code>layer = 1</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdm.example()
exMap &lt;- bdm.wtt.plot(exMap)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
