<!DOCTYPE html><html lang="en"><head><title>Help for package PoolBal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PoolBal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#altFrequencyMat'><p>Identify a region of plausible alternative hypotheses</p>
in the proportion, strength of non-null evidence space</a></li>
<li><a href='#betaDiv'><p>Compute the Kullback-Leibler divergence between the beta</p>
and uniform distributions</a></li>
<li><a href='#chiKappa'><p>Chi-squared kappa for a given centrality quotient</p></a></li>
<li><a href='#chiPc'><p>Chi-squared central rejection level</p></a></li>
<li><a href='#chiPool'><p>Chi-squared p-value pooling</p></a></li>
<li><a href='#chiPr'><p>Chi-squared marginal rejection level</p></a></li>
<li><a href='#chiQ'><p>Chi-squared centrality quotient</p></a></li>
<li><a href='#convertGeneticSigma'><p>Convert p-value correlation to chi-squared covariance</p></a></li>
<li><a href='#estimatePc'><p>Compute the central rejection level</p></a></li>
<li><a href='#estimatePrb'><p>Compute the marginal rejection level</p></a></li>
<li><a href='#estimateQ'><p>Compute the centrality quotient</p></a></li>
<li><a href='#findA'><p>Estimate parameter for a given beta KL divergence and UMP</p>
test</a></li>
<li><a href='#hrPc'><p>Empirical UMP beta central rejection level</p></a></li>
<li><a href='#hrPool'><p>Empirical UMP beta pooled p-value</p></a></li>
<li><a href='#hrPr'><p>Empirical UMP beta marginal rejection level</p></a></li>
<li><a href='#hrQ'><p>Empirical UMP beta centrality quotient</p></a></li>
<li><a href='#hrStat'><p>UMP beta p-value pooled statistic</p></a></li>
<li><a href='#klDiv'><p>Compute the Kullback-Leibler divergence</p></a></li>
<li><a href='#marHistHeatMap'><p>Heatmap with marginal histograms</p></a></li>
<li><a href='#rBetaH4'><p>Generate realizations of beta alternative distributions</p></a></li>
<li><a href='#satterApproxP'><p>Satterthwaite p-values</p></a></li>
<li><a href='#satterChiPool'><p>Pool p-values using the Satterthwaite approximation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1-0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Balancing Central and Marginal Rejection of Pooled p-Values</td>
</tr>
<tr>
<td>Description:</td>
<td>When using pooled p-values to adjust for multiple testing, there is an inherent balance that must be struck between rejection based on weak evidence spread among many tests and strong evidence in a few, explored in Salahub and Olford (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2310.16600">doi:10.48550/arXiv.2310.16600</a>&gt;. This package provides functionality to compute marginal and central rejection levels and the centrality quotient for p-value pooling functions and provides implementations of the chi-squared quantile pooled p-value (described in Salahub and Oldford (2023)) and a proposal from Heard and Rubin-Delanchy (2018) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasx076">doi:10.1093/biomet/asx076</a>&gt; to control the quotient's value.</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Salahub [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Salahub &lt;chris.salahub@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-21 22:30:01 UTC; Chris</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-22 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='altFrequencyMat'>Identify a region of plausible alternative hypotheses
in the proportion, strength of non-null evidence space</h2><span id='topic+altFrequencyMat'></span>

<h3>Description</h3>

<p>This function provides a convenient way to interact
with simulations performed over a grid of possible alternatives
spanning the proportion (eta) and strength (KL divergence) of
evidence against the null hypothesis under beta alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>altFrequencyMat(logKappaRange, logW = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="altFrequencyMat_+3A_logkapparange">logKappaRange</code></td>
<td>
<p>pair of numeric values</p>
</td></tr>
<tr><td><code id="altFrequencyMat_+3A_logw">logW</code></td>
<td>
<p>logical, should the log scale simulation be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation this function summarized used a range of
eta, w, and KL divergence values to generate thousands of
potential alternative distributions. The power of each
chi-squared pooled p-value for 161 kappa values ranging from
exp(-8) to exp(8) selected uniformly on the log scale was then
computed for each alternative using 10,000 simulated examples.
Every choice of kappa was compared to the maximum power across
all kappas for each setting using a binomial test of differences.
This same simulation was repeated twice: once for w values
selected uniformly from 0 to 1 and another where selection was
uniform on the log scale. The internal data summarizes the results
by reporting the count of instances in w (or logw) where a given
kappa value was most powerful for a given eta and KL divergence.
</p>
<p>Though the simulation data is not exported to users and so cannot
be accessed directly, this function allows a user to query the
data with a range of kappa values (corresponding to those where
a given sample seems most powerful) and returns the count of
cases in w where a kappa in the corresponding kappa range was most
powerful given the eta, KL-divergence combination with beta
alternatives. The simulations only spanned kappa values from
exp(-8) to exp(8), so providing values outside this range will
give very inaccurate results.
</p>


<h3>Value</h3>

<p>An 81 by 81 matrix giving summarized counts of cases.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>altFrequencyMat(c(-1, 1), logW = FALSE)
altFrequencyMat(c(-1, 1), logW = TRUE)
</code></pre>

<hr>
<h2 id='betaDiv'>Compute the Kullback-Leibler divergence between the beta
and uniform distributions</h2><span id='topic+betaDiv'></span>

<h3>Description</h3>

<p>Computes the Kullback-Leibler divergence for the
special case of the uniform density against the beta density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaDiv(a, w = (1 - a)/(b - a), b = 1/w + a * (1 - 1/w))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betaDiv_+3A_a">a</code></td>
<td>
<p>first shape parameter between 0 and infinity</p>
</td></tr>
<tr><td><code id="betaDiv_+3A_w">w</code></td>
<td>
<p>UMP parameter between 0 and 1</p>
</td></tr>
<tr><td><code id="betaDiv_+3A_b">b</code></td>
<td>
<p>second shape parameter between 0 and infinity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts either the a/b parameterization
(equivalent to shape1/shape2 in R), or the a/w parameterization
which links the divergence to the UMP test.
</p>


<h3>Value</h3>

<p>A real value.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>betaDiv(a = 0.5, w = 0.5)
betaDiv(a = 0.1, b = 1)
</code></pre>

<hr>
<h2 id='chiKappa'>Chi-squared kappa for a given centrality quotient</h2><span id='topic+chiKappa'></span>

<h3>Description</h3>

<p>Computes the kappa (degrees of freedom) required
to obtain a given centrality quotient using the chi-square pooled
p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiKappa(
  cq,
  M,
  alpha = 0.05,
  interval = c(0, 100),
  tol = .Machine$double.eps^0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chiKappa_+3A_cq">cq</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="chiKappa_+3A_m">M</code></td>
<td>
<p>integer sample size greater than 0</p>
</td></tr>
<tr><td><code id="chiKappa_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="chiKappa_+3A_interval">interval</code></td>
<td>
<p>numeric of length 2, where should roots be sought?</p>
</td></tr>
<tr><td><code id="chiKappa_+3A_tol">tol</code></td>
<td>
<p>numeric, how close do values need to be for equality?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially a wrapper for uniroot which
finds where chiCentQuot gives an output equal to the given
centrality quotient to provide an approximate kappa giving that
quotient.
</p>


<h3>Value</h3>

<p>A numeric within interval.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chiKappa(0.5, 10, 0.05)
chiKappa(0.5, 20, 0.05)
chiKappa(0.5, 100, 0.05, interval = c(0, 10))
</code></pre>

<hr>
<h2 id='chiPc'>Chi-squared central rejection level</h2><span id='topic+chiPc'></span>

<h3>Description</h3>

<p>Computes the central rejection level for the
chi-squared pooled p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiPc(kappa, M, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chiPc_+3A_kappa">kappa</code></td>
<td>
<p>numeric between 0 and infinity</p>
</td></tr>
<tr><td><code id="chiPc_+3A_m">M</code></td>
<td>
<p>integer sample size greater than 0</p>
</td></tr>
<tr><td><code id="chiPc_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The central rejection level is the maximum p-value
shared among all tests which still results in rejection of the
null using a pooled p-value. For the chi-squared pooled p-value,
this is an upper tail probability of the chi-squared distribution.
This function computes the upper tail probability for a given
sample size M, degrees of freedom kappa, and rejection level
alpha.
</p>


<h3>Value</h3>

<p>A numeric between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chiPc(2, 10, 0.05)
chiPc(2, 20, 0.05) # increases in sample size
</code></pre>

<hr>
<h2 id='chiPool'>Chi-squared p-value pooling</h2><span id='topic+chiPool'></span>

<h3>Description</h3>

<p>This implements the chi-squared pooled p-value
which can be used to control the centrality quotient when pooling
p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiPool(p, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chiPool_+3A_p">p</code></td>
<td>
<p>numeric vector of p-values between 0 and 1</p>
</td></tr>
<tr><td><code id="chiPool_+3A_kappa">kappa</code></td>
<td>
<p>numeric value between 0 and infinity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chi-squared pooled p-value is a quantile
transformation pooled p-value based on the chi-squared
distribution with degrees of freedom kappa. By setting kappa
between 0 and infinity, smooth interpolation is achieved between
Tippett's minimum pooled p-value and Stouffer's normal quantile
pooled p-value respectively. Choosing a kappa value of 2, Fisher's
pooling function is obtained. Tippett's pooled p-value is
maximally non-central and Stouffer's is maximally central, while
Fisher's presents a balance between marginal and central
rejection.
</p>


<h3>Value</h3>

<p>A pooled p-value between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(0.1, 0.5, 0.9)
chiPool(p, exp(-4))
chiPool(p, 2)
chiPool(p, exp(4))
</code></pre>

<hr>
<h2 id='chiPr'>Chi-squared marginal rejection level</h2><span id='topic+chiPr'></span>

<h3>Description</h3>

<p>Computes the marginal rejection level for the
chi-squared pooled p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiPr(kappa, M, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chiPr_+3A_kappa">kappa</code></td>
<td>
<p>numeric between 0 and infinity</p>
</td></tr>
<tr><td><code id="chiPr_+3A_m">M</code></td>
<td>
<p>integer sample size greater than 0</p>
</td></tr>
<tr><td><code id="chiPr_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal rejection level is the maximum p-value
in a single test which results in rejection when all other tests
produce p-values of one. For the chi-squared pooled p-value,
this is an upper tail probability of the chi-squared distribution.
This function computes the upper tail probability for a given
sample size M, degrees of freedom kappa, and rejection level
alpha.
</p>


<h3>Value</h3>

<p>A numeric between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chiPr(2, 10, 0.05)
chiPr(2, 20, 0.05)
</code></pre>

<hr>
<h2 id='chiQ'>Chi-squared centrality quotient</h2><span id='topic+chiQ'></span>

<h3>Description</h3>

<p>Computes the centrality quotient of the chi-square
pooled p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiQ(kappa, M, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chiQ_+3A_kappa">kappa</code></td>
<td>
<p>numeric between 0 and infinity</p>
</td></tr>
<tr><td><code id="chiQ_+3A_m">M</code></td>
<td>
<p>integer sample size greater than 0</p>
</td></tr>
<tr><td><code id="chiQ_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centrality quotient of a pooled p-value measures the
relative preference it gives to p-values all sharing the same
level of evidence over a single test with strong evidence relative
to others. For the chi-square pooled p-value, this is a
conditional probability which this function computes.
</p>


<h3>Value</h3>

<p>A numeric between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chiQ(2, 10, 0.05)
chiQ(2, 20, 0.05)
chiQ(0.5, 20, 0.05)
</code></pre>

<hr>
<h2 id='convertGeneticSigma'>Convert p-value correlation to chi-squared covariance</h2><span id='topic+convertGeneticSigma'></span>

<h3>Description</h3>

<p>Convert a matrix of correlations between p-values to
a matrix of covariances between their chi-squared transforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertGeneticSigma(sigma, kappa, models = chiCorMods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertGeneticSigma_+3A_sigma">sigma</code></td>
<td>
<p>M by M correlation matrix between markers</p>
</td></tr>
<tr><td><code id="convertGeneticSigma_+3A_kappa">kappa</code></td>
<td>
<p>numeric degrees of freedom</p>
</td></tr>
<tr><td><code id="convertGeneticSigma_+3A_models">models</code></td>
<td>
<p>model object with a predict method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses models fit to large simulated data
sets to convert a matrix of correlations between genetic markers
the covariance matrix of chi-squared random variables gained from
transforming p-values on these markers. The simulations used to
create data for these models assume the p-values for each marker
arise from tests of association with a common, normally
distributed trait independent of all markers. As a result, this
conversion function should be used only in analogous settings.
</p>
<p>Models were fit for degrees of freedom at increments of 0.1
between -8 and 8 on the log scale, and interpolation is applied
if the degrees of freedom given to the function does not fall
exactly on this grid (with a warning provided to the user).
</p>
<p>If a user wants to generalize this setting, the option to
provide a custom list of models which predict based on a named
argument 'zcor' is supported. Each model must have a name in the
list that can be converted to a numeric, and these are assumed
to be on the natural log scale.
</p>


<h3>Value</h3>

<p>M by M matrix of chi-squared covariances
</p>


<h3>Author(s)</h3>

<p>Chirs Salahub
</p>

<hr>
<h2 id='estimatePc'>Compute the central rejection level</h2><span id='topic+estimatePc'></span>

<h3>Description</h3>

<p>Estimates the central rejection level for an
arbitrary pooled p-value function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePc(
  poolFun,
  alpha = 0.05,
  M = 2,
  interval = c(0, 1),
  poolArgs = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimatePc_+3A_poolfun">poolFun</code></td>
<td>
<p>function accepting a vector of p-values</p>
</td></tr>
<tr><td><code id="estimatePc_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="estimatePc_+3A_m">M</code></td>
<td>
<p>integer, how many p-values are there?</p>
</td></tr>
<tr><td><code id="estimatePc_+3A_interval">interval</code></td>
<td>
<p>two numerics giving the bounds of root-searching</p>
</td></tr>
<tr><td><code id="estimatePc_+3A_poolargs">poolArgs</code></td>
<td>
<p>(optional) additional named arguments for poolFun</p>
</td></tr>
<tr><td><code id="estimatePc_+3A_...">...</code></td>
<td>
<p>additional arguments to uniroot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The central rejection level is the maximum p-value
shared among all tests which still results in rejection of the
null using a pooled p-value.
</p>
<p>This function is essentially a wrapper for uniroot, and accepts
a pooling function which takes a numeric vector as its first
argument and potentially other arguments given in poolArgs and
returns a single value. Using this pooling function, a specified
dimension M and a rejection level alpha, uniroot searches for the
root to poolFun - alpha along the line where all p-values are
equal.
</p>


<h3>Value</h3>

<p>The uniroot output.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tippool &lt;- function(p) 1 - (1 - min(p))^(length(p))
estimatePc(tippool, 0.05, M = 10, interval = c(0, 1))
</code></pre>

<hr>
<h2 id='estimatePrb'>Compute the marginal rejection level</h2><span id='topic+estimatePrb'></span>

<h3>Description</h3>

<p>Estimates the marginal rejection level for an
arbitrary pooled p-value function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePrb(
  poolFun,
  alpha = 0.05,
  b = 1,
  M = 2,
  interval = c(0, b),
  poolArgs = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimatePrb_+3A_poolfun">poolFun</code></td>
<td>
<p>function accepting a vector of p-values</p>
</td></tr>
<tr><td><code id="estimatePrb_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="estimatePrb_+3A_b">b</code></td>
<td>
<p>numeric, the value of the M - 1 repeated p-values</p>
</td></tr>
<tr><td><code id="estimatePrb_+3A_m">M</code></td>
<td>
<p>integer, how many p-values are there?</p>
</td></tr>
<tr><td><code id="estimatePrb_+3A_interval">interval</code></td>
<td>
<p>two numerics giving the bounds of root-searching</p>
</td></tr>
<tr><td><code id="estimatePrb_+3A_poolargs">poolArgs</code></td>
<td>
<p>(optional) additional named arguments for poolFun</p>
</td></tr>
<tr><td><code id="estimatePrb_+3A_...">...</code></td>
<td>
<p>additional arguments to uniroot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal rejection level is the maximum p-value
in a single test less than b which still results in rejection of
the null when all other tests have a p-value of b.
</p>
<p>This function is essentially a wrapper for uniroot, and accepts
a pooling function which takes a numeric vector as its first
argument and potentially other arguments given in poolArgs and
returns a single value. Using this pooling function, a specified
dimension M and a rejection level alpha, uniroot searches for the
root to poolFun - alpha along one margin when all other p-values
are equal to b.
</p>


<h3>Value</h3>

<p>The uniroot output.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopool &lt;- function(p) pnorm(sum(qnorm(p, lower.tail = FALSE))/ sqrt(length(p)), lower.tail = FALSE)
estimatePrb(stopool, 0.05, M = 10, interval = c(.Machine$double.eps, 1))
estimatePrb(stopool, 0.05, M = 10, b = 0.5, interval = c(.Machine$double.eps, 1))
</code></pre>

<hr>
<h2 id='estimateQ'>Compute the centrality quotient</h2><span id='topic+estimateQ'></span>

<h3>Description</h3>

<p>Estimates the centrality quotient for an arbitrary
pooled p-value function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateQ(
  poolFun,
  alpha = 0.05,
  M = 2,
  interval = c(0, 1),
  poolArgs = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateQ_+3A_poolfun">poolFun</code></td>
<td>
<p>function accepting a vector of p-values</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_m">M</code></td>
<td>
<p>integer, how many p-values are there?</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_interval">interval</code></td>
<td>
<p>two numerics giving the bounds of root-searching</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_poolargs">poolArgs</code></td>
<td>
<p>(optional) additional named arguments for poolFun</p>
</td></tr>
<tr><td><code id="estimateQ_+3A_...">...</code></td>
<td>
<p>additional arguments to uniroot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centrality quotient communicates the tendency for a
test to favour evidence shared among all tests over strong
evidence in a single test.
</p>
<p>This function uses the individual estimation functions for
central and marginal rejection levels to compute the centrality
quotient for an arbitrary pooled p-value function. The option to
specify b for marginal rejection is included in case the pooled p
-value has strange behaviour when p-values are equal to 1.
</p>


<h3>Value</h3>

<p>The uniroot output.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>estimateQ(chiPool, alpha = 0.05, M = 10, poolArgs = list(kappa = 10))
</code></pre>

<hr>
<h2 id='findA'>Estimate parameter for a given beta KL divergence and UMP
test</h2><span id='topic+findA'></span>

<h3>Description</h3>

<p>Computes the first parameter value for a given KL
divergence and UMP test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findA(w, logd = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findA_+3A_w">w</code></td>
<td>
<p>UMP parameter between 0 and 1</p>
</td></tr>
<tr><td><code id="findA_+3A_logd">logd</code></td>
<td>
<p>numeric value, the log KL divergence</p>
</td></tr>
<tr><td><code id="findA_+3A_...">...</code></td>
<td>
<p>additional arguments to uniroot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses uniroot to invert the beta divergence
for a given w and return the a value which gives that beta
divergence given the UMP parameter w. The search interval is
specified internally, so should not be passed in using additional
argument.
</p>


<h3>Value</h3>

<p>A real value.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findA(0.5, logd = 0)
</code></pre>

<hr>
<h2 id='hrPc'>Empirical UMP beta central rejection level</h2><span id='topic+hrPc'></span>

<h3>Description</h3>

<p>Uses simulation to estimate the central rejection
level for the UMP pooled p-value of a restricted beta family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrPc(w, alpha = 0.05, M = 2, nsim = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hrPc_+3A_w">w</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="hrPc_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="hrPc_+3A_m">M</code></td>
<td>
<p>integer sample size greater than 0</p>
</td></tr>
<tr><td><code id="hrPc_+3A_nsim">nsim</code></td>
<td>
<p>integer, the number of simulated null cases generated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The central rejection level is the maximum p-value
shared among all tests which still results in rejection of the
null using a pooled p-value.
</p>
<p>To test the null hypotheses that all p-values are uniform
against a restricted beta family 0 &lt; a &lt;= 1 &lt;= b, the most
powerful pooled p-value linearly combines upper and lower tail
probabilities of the chi-squared distribution with two degrees
of freedom with weights w and (1 - w) where w = (1 - a)/(b - a).
</p>
<p>This function estimates the central rejection level empirically
by simulating a specified number of null cases to give an empirical
pooled p-value for the rejection level alpha.
</p>


<h3>Value</h3>

<p>A numeric between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hrPc(w = 0.5, alpha = 0.05, M = 10)
hrPc(w = 0.5, alpha = 0.05, M = 20)
</code></pre>

<hr>
<h2 id='hrPool'>Empirical UMP beta pooled p-value</h2><span id='topic+hrPool'></span>

<h3>Description</h3>

<p>Uses simulation under the null to approximate the UMP
pooled p-value for a restricted beta family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrPool(w = 1, M = 10, nsim = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hrPool_+3A_w">w</code></td>
<td>
<p>numeric value between 0 and 1</p>
</td></tr>
<tr><td><code id="hrPool_+3A_m">M</code></td>
<td>
<p>integer, the number of tests to pool</p>
</td></tr>
<tr><td><code id="hrPool_+3A_nsim">nsim</code></td>
<td>
<p>integer, the number of simulated null cases generated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To test the null hypotheses that all p-values are uniform
against a restricted beta family 0 &lt; a &lt;= 1 &lt;= b, the most
powerful pooled p-value linearly combines upper and lower tail
probabilities of the chi-squared distribution with two degrees
of freedom with weights w and (1 - w) where w = (1 - a)/(b - a).
</p>
<p>This function computes the statistic given by this combination
for a collection of p-values, and then simulates a specified
number of null cases to give an empirical pooled p-value. It
produces a closure so that the time-intensive simulation step
doesn't need to be repeated.
</p>


<h3>Value</h3>

<p>A closure which accepts a vector of values between 0 and 1
and returns a single numeric between 0 and 1
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(0.1, 0.5, 0.9)
hr2 &lt;- hrPool(w = 0.2, M = 3)
hr2(p)
hr5 &lt;- hrPool(w = 0.5, M = 3, nsim = 100)
hr5(p)
</code></pre>

<hr>
<h2 id='hrPr'>Empirical UMP beta marginal rejection level</h2><span id='topic+hrPr'></span>

<h3>Description</h3>

<p>Uses simulation to estimate the marginal rejection
level for the UMP pooled p-value of a restricted beta family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrPr(w, alpha = 0.05, M = 2, nsim = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hrPr_+3A_w">w</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="hrPr_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="hrPr_+3A_m">M</code></td>
<td>
<p>integer sample size greater than 0</p>
</td></tr>
<tr><td><code id="hrPr_+3A_nsim">nsim</code></td>
<td>
<p>integer, the number of simulated null cases generated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal rejection level is the maximum p-value
in a single tests which still results in rejection of the null
when all other tests have a p-value of 1.
</p>
<p>To test the null hypotheses that all p-values are uniform
against a restricted beta family 0 &lt; a &lt;= 1 &lt;= b, the most
powerful pooled p-value linearly combines upper and lower tail
probabilities of the chi-squared distribution with two degrees
of freedom with weights w and (1 - w) where w = (1 - a)/(b - a).
</p>
<p>This function estimates the marginal rejection level empirically
by simulating a specified number of null cases to give an empirical
pooled p-value for the rejection level alpha.
</p>


<h3>Value</h3>

<p>A numeric between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hrPr(w = 0.5, alpha = 0.05, M = 10)
hrPr(w = 0.5, alpha = 0.05, M = 10) # decreases in sample size
</code></pre>

<hr>
<h2 id='hrQ'>Empirical UMP beta centrality quotient</h2><span id='topic+hrQ'></span>

<h3>Description</h3>

<p>Estimates the centrality quotient for the UMP
pooled p-value of a restricted beta family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrQ(w, alpha = 0.05, M = 2, nsim = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hrQ_+3A_w">w</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="hrQ_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1</p>
</td></tr>
<tr><td><code id="hrQ_+3A_m">M</code></td>
<td>
<p>integer sample size greater than 0</p>
</td></tr>
<tr><td><code id="hrQ_+3A_nsim">nsim</code></td>
<td>
<p>integer, the number of simulated null cases generated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centrality quotient communicates the tendency for a
test to favour evidence shared among all tests over strong
evidence in a single test.
</p>
<p>To test the null hypotheses that all p-values are uniform
against a restricted beta family 0 &lt; a &lt;= 1 &lt;= b, the most
powerful pooled p-value linearly combines upper and lower tail
probabilities of the chi-squared distribution with two degrees
of freedom with weights w and (1 - w) where w = (1 - a)/(b - a).
</p>
<p>This function uses the individual estimation functions for
central and marginal rejection levels to compute the centrality
quotient for the UMP pooled p-value.
</p>


<h3>Value</h3>

<p>An empirical estimate of the centrality quotient.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hrQ(0.8, alpha = 0.05, M = 10)
</code></pre>

<hr>
<h2 id='hrStat'>UMP beta p-value pooled statistic</h2><span id='topic+hrStat'></span>

<h3>Description</h3>

<p>Computes the UMP p-value pooling statistic for a
restricted beta family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrStat(p, w = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hrStat_+3A_p">p</code></td>
<td>
<p>numeric vector of p-values between 0 and 1</p>
</td></tr>
<tr><td><code id="hrStat_+3A_w">w</code></td>
<td>
<p>numeric value between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To test the null hypotheses that all p-values are uniform
against a restricted beta family 0 &lt; a &lt;= 1 &lt;= b, the most
powerful pooled p-value linearly combines upper and lower tail
probabilities of the chi-squared distribution with two degrees
of freedom with weights w and (1 - w) where w = (1 - a)/(b - a).
</p>
<p>This function computes the statistic given by this combination
for a collection of p-values, simulation or approximation is
required to convert this to a p-value.
</p>


<h3>Value</h3>

<p>A numeric value giving the pooled statistic.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(0.1, 0.5, 0.9)
hrStat(p, 0.2)
hrStat(p, 0.5)
hrStat(p, 0.9)
</code></pre>

<hr>
<h2 id='klDiv'>Compute the Kullback-Leibler divergence</h2><span id='topic+klDiv'></span>

<h3>Description</h3>

<p>Computes the Kullback-Leibler divergence for two
arbitrary densities f1 and f2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>klDiv(f1, f2, lower = 0, upper = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="klDiv_+3A_f1">f1</code></td>
<td>
<p>density function of a real-valued random variable</p>
</td></tr>
<tr><td><code id="klDiv_+3A_f2">f2</code></td>
<td>
<p>density function of a real-values random variable</p>
</td></tr>
<tr><td><code id="klDiv_+3A_lower">lower</code></td>
<td>
<p>real value, the lower bound of integration</p>
</td></tr>
<tr><td><code id="klDiv_+3A_upper">upper</code></td>
<td>
<p>real value, the upper bound of integration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given lower and upper bounds, this function integrates
the expression for the Kullback-Leibler divergence KL(f1|f2).
</p>


<h3>Value</h3>

<p>A real value.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>klDiv(dunif, function(x) dbeta(x, 0.5, 1))
</code></pre>

<hr>
<h2 id='marHistHeatMap'>Heatmap with marginal histograms</h2><span id='topic+marHistHeatMap'></span>

<h3>Description</h3>

<p>Display a matrix using a heatmap with marginal
histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marHistHeatMap(
  mat,
  main = "",
  ylab = expression(eta),
  xlab = "lnD(a,w)",
  pal = NULL,
  histFill = adjustcolor("firebrick", 0.5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marHistHeatMap_+3A_mat">mat</code></td>
<td>
<p>numeric matrix to be plotted</p>
</td></tr>
<tr><td><code id="marHistHeatMap_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id="marHistHeatMap_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="marHistHeatMap_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="marHistHeatMap_+3A_pal">pal</code></td>
<td>
<p>palette for heatmap</p>
</td></tr>
<tr><td><code id="marHistHeatMap_+3A_histfill">histFill</code></td>
<td>
<p>colour to fill histogram bars</p>
</td></tr>
<tr><td><code id="marHistHeatMap_+3A_...">...</code></td>
<td>
<p>additional arguments to image</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a matrix of values and plots the
matrix with saturation/hue determined by a provided palette
argument generated by colorRampPalette, for example. Marginal
histograms summarizing the relative frequencies along both
dimensions are also plotted to give a complete sense of the
individual distributions alongside their joint distribution.
This was designed to summarize the alternative distribution
space summarized by altFrequencyMat, and the defaults reflect
this.
</p>


<h3>Value</h3>

<p>Plot the data using a heatmap and marginal histograms and
return nothing.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marHistHeatMap(altFrequencyMat(c(0, 2)))
</code></pre>

<hr>
<h2 id='rBetaH4'>Generate realizations of beta alternative distributions</h2><span id='topic+rBetaH4'></span><span id='topic+rBetaH3'></span>

<h3>Description</h3>

<p>These functions can be used to generate samples of
p-values all following a beta distribution (H4) or following
either uniform or beta distributions according to proportion
eta (H3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rBetaH4(a, b = 1/w + a * (1 - 1/w), w = (1 - a)/(b - a), M = 2, N = 10)

rBetaH3(
  a,
  b = 1/w + a * (1 - 1/w),
  w = (1 - a)/(b - a),
  eta = 0.5,
  M = 2,
  N = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rBetaH4_+3A_a">a</code></td>
<td>
<p>first beta parameter, numeric between 0 and infinity</p>
</td></tr>
<tr><td><code id="rBetaH4_+3A_b">b</code></td>
<td>
<p>second beta parameter, numeric  between 0 and infinity</p>
</td></tr>
<tr><td><code id="rBetaH4_+3A_w">w</code></td>
<td>
<p>UMP parameter between 0 and 1</p>
</td></tr>
<tr><td><code id="rBetaH4_+3A_m">M</code></td>
<td>
<p>number of p-values per realization</p>
</td></tr>
<tr><td><code id="rBetaH4_+3A_n">N</code></td>
<td>
<p>number of realizations</p>
</td></tr>
<tr><td><code id="rBetaH4_+3A_eta">eta</code></td>
<td>
<p>numeric between 0 and 1, proportion of non-null
tests per sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternatives
</p>
<p>These functions are provided as a convenience, and
support a/b (shape1/shape2) or a/w specification of beta
parameters.
</p>


<h3>Value</h3>

<p>An N by M matrix of simulated p-values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rBetaH4()</code>: iid Beta(a,w) p-values
</p>
</li>
<li> <p><code>rBetaH3()</code>: M*eta iid Beta(a,w) p-values, others uniform
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rBetaH4(a = 0.5, b = 1.5, M = 10, N = 100)
rBetaH3(a = 0.5, b = 1.5, eta = 0.5, M = 10, N = 100)
</code></pre>

<hr>
<h2 id='satterApproxP'>Satterthwaite p-values</h2><span id='topic+satterApproxP'></span>

<h3>Description</h3>

<p>p-value of the sum of dependent chi-squared using
the Satterthwaite approximation for the degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>satterApproxP(qs, covmat, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="satterApproxP_+3A_qs">qs</code></td>
<td>
<p>M numeric values (observed chi-squared values)</p>
</td></tr>
<tr><td><code id="satterApproxP_+3A_covmat">covmat</code></td>
<td>
<p>M by M covariance matrix of qs</p>
</td></tr>
<tr><td><code id="satterApproxP_+3A_kappa">kappa</code></td>
<td>
<p>degrees of freedom of qs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the p-value of an observed vector of chi-squared
variables using the Satterthwaite approximation. This approximates
the sum of dependent chi-squared variables with a scaled
chi-squared distribution with degrees of freedom chosen to match
the first two moments of the dependent sum.
</p>


<h3>Value</h3>

<p>a numeric in [0,1], the p-value of the sum
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

<hr>
<h2 id='satterChiPool'>Pool p-values using the Satterthwaite approximation</h2><span id='topic+satterChiPool'></span>

<h3>Description</h3>

<p>Compute the pooled p-value of dependent p-values
based on the dependence present when they are all converted
to chi-squared random variables by the same chi-squared
quantile function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>satterChiPool(ps, covmat, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="satterChiPool_+3A_ps">ps</code></td>
<td>
<p>numeric vector of M p-values</p>
</td></tr>
<tr><td><code id="satterChiPool_+3A_covmat">covmat</code></td>
<td>
<p>M by M covariance matrix of chi-squared random
variables arising from quantile transformations of ps</p>
</td></tr>
<tr><td><code id="satterChiPool_+3A_kappa">kappa</code></td>
<td>
<p>numeric degrees of freedom</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Care must be taken in the arguments for this function, as
the covmat argument accepts the covariance of the transformed
variables rather than the covariance of the p-values, and so
passes the argument covmat directly to the function that computes
the Satterthwaite approximation. For the case of genetic markers,
the 'convertGeneticSigma' function provides the appropriate matrix
given a genetic correlation matrix.
</p>


<h3>Value</h3>

<p>A pooled p-value between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
