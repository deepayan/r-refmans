<!DOCTYPE html><html><head><title>Help for package sox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nested_structure'><p>Automatically generate objects used to describe the structure of the nested group lasso penalty.</p></a></li>
<li><a href='#overlap_structure'><p>Automatically generate objects used to describe the structure of the overlapping group lasso penalty</p></a></li>
<li><a href='#plot.sox'><p>Solution path plot for <code>sox()</code></p></a></li>
<li><a href='#plot.sox_cv'><p>Plots for <code>sox_cv</code></p></a></li>
<li><a href='#sim'><p>A simulated demo dataset <code>sim</code></p></a></li>
<li><a href='#sox'><p>(Time-dependent) Cox model with structured variable selection</p></a></li>
<li><a href='#sox_cv'><p>cross-validation for <code>sox</code></p></a></li>
<li><a href='#sox-package'><p>sox: Structured Learning in Time-Dependent Cox Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Structured Learning in Time-Dependent Cox Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient procedures for fitting and cross-validating the structurally-regularized time-dependent Cox models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), survival, glmnet</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file inst/COPYRIGHTS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 17:13:39 UTC; YLIAN</td>
</tr>
<tr>
<td>Author:</td>
<td>Yi Lian [aut, cre],
  Guanbo Wang [aut],
  Archer Y. Yang [aut],
  Mireille E. Schnitzer [aut],
  Robert W. Platt [aut],
  Rui Wang [aut],
  Marc Dorais [aut],
  Sylvie Perreault [aut],
  Julien Mairal [ctb],
  Yuansi Chen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yi Lian &lt;yi.lian@mail.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nested_structure'>Automatically generate objects used to describe the structure of the nested group lasso penalty.</h2><span id='topic+nested_structure'></span>

<h3>Description</h3>

<p>Automatically generate objects used to describe the structure of the nested group lasso penalty. The output is then used by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_structure(group_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_structure_+3A_group_list">group_list</code></td>
<td>
<p>A list containing the indices of the group members.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects describing the group structure.
</p>
<table>
<tr><td><code>groups</code></td>
<td>
<p>Required by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code> to describe the relationship between the <code class="reqn">G</code> <code>overlapping</code> groups. A <code class="reqn">G * G</code> integer matrix whose <code class="reqn">(i,j)</code> entry is <code>1</code> if and only if <code class="reqn">i\neq j</code> and <code class="reqn">g_i</code> is a child group (subset) of <code class="reqn">g_j</code>, and is <code>0</code> otherwise.</p>
</td></tr>
<tr><td><code>own_variables</code></td>
<td>
<p>Required by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code> to describe the relationship between the <code class="reqn">G</code> <code>overlapping</code> groups and the <code class="reqn">p</code> variables. The entries are the smallest variable indices in the groups (to achieve this, <code>group</code> is sorted. For any two groups <code class="reqn">i</code> and <code class="reqn">j</code>, if <code class="reqn">i</code> is the parent group of <code class="reqn">j</code>, then <code class="reqn">i</code> is before <code class="reqn">j</code> and vice versa, otherwise, the one with the smallest variable index is before the other.</p>
</td></tr>
<tr><td><code>N_own_variables</code></td>
<td>
<p>Required by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code> to describe the relationship between the <code class="reqn">G</code> <code>overlapping</code> groups and the <code class="reqn">p</code> variables. An integer vector of length <code class="reqn">G</code> indicating the number of variables that are in each group but not in any of its child groups.</p>
</td></tr>
<tr><td><code>group_weights</code></td>
<td>
<p>Required by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code> to specify the group-specific penalty weights. The weight is generated in a way such that, the penalty weights of all the groups that contain a given variable sum to 1 for all variables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># p = 9 Variables:
## 1: A1
## 2: A2
## 3: C1
## 4: C2
## 5: B
## 6: A1B
## 7: A2B
## 8: C1B
## 9: C2B

# G = 12 Nested groups (misspecified, for the demonstration of the software only.)
## g1: A1, A2, C1, C2, B, A1B, A2B, C1B, C2B
## g2: A1B, A2B, A1B, A2B
## g3: C1, C2, C1B, C2B
## g4: 1
## g5: 2
## ...
## G12: 9

nested.groups &lt;- list(1:9,
                      c(1, 2, 6, 7),
                      c(3, 4, 8, 9),
                      1, 2, 3, 4, 5, 6, 7, 8, 9)

pars.nested &lt;- nested_structure(nested.groups)

str(pars.nested)
                
</code></pre>

<hr>
<h2 id='overlap_structure'>Automatically generate objects used to describe the structure of the overlapping group lasso penalty</h2><span id='topic+overlap_structure'></span>

<h3>Description</h3>

<p>Automatically generate objects used to describe the structure of the overlapping group lasso penalty The output is then used by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap_structure(group_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_structure_+3A_group_list">group_list</code></td>
<td>
<p>A list containing the indices of the group members.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects describing the group structure.
</p>
<table>
<tr><td><code>groups</code></td>
<td>
<p>Required by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code> to describe the relationship between the <code class="reqn">G</code> <code>overlapping</code> groups. A <code class="reqn">G * G</code> integer matrix whose <code class="reqn">(i,j)</code> entry is <code>1</code> if and only if <code class="reqn">i\neq j</code> and <code class="reqn">g_i</code> is a child group (subset) of <code class="reqn">g_j</code>, and is <code>0</code> otherwise.</p>
</td></tr>
<tr><td><code>groups_var</code></td>
<td>
<p>Required by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code> to describe the relationship between the <code class="reqn">G</code> <code>overlapping</code> groups and the <code class="reqn">p</code> variables. A <code class="reqn">p * G</code> integer matrix whose <code class="reqn">(i,j)</code> entry is <code>1</code> if and only if variable <code class="reqn">i</code> is in group <code class="reqn">g_j</code>, but not in any child group of <code class="reqn">g_j</code>, and is <code>0</code> otherwise. </p>
</td></tr>
<tr><td><code>group_weights</code></td>
<td>
<p>Required by <code><a href="#topic+sox">sox</a>()</code> and <code><a href="#topic+sox_cv">sox_cv</a>()</code> to specify the group-specific penalty weights. The penalty weight for each group is equal to the square root of the group size.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># p = 9 Variables:
## 1: A1
## 2: A2
## 3: C1
## 4: C2
## 5: B
## 6: A1B
## 7: A2B
## 8: C1B
## 9: C2B

# G = 5 Overlapping groups:
## g1: A1, A2, A1B, A2B
## g2: B, A1B, A2B, C1B, C2B
## g3: A1B, A2B
## g4: C1, C2, C1B, C2B
## g5: C1B, C2B

overlapping.groups &lt;- list(c(1, 2, 6, 7),
                           c(5, 6, 7, 8, 9),
                           c(6, 7),
                           c(3, 4, 8, 9),
                           c(8, 9))
                           
pars.overlapping &lt;- overlap_structure(overlapping.groups)

str(pars.overlapping)
                
</code></pre>

<hr>
<h2 id='plot.sox'>Solution path plot for <code>sox()</code></h2><span id='topic+plot.sox'></span>

<h3>Description</h3>

<p>Plot the solution path generated by <code><a href="#topic+sox">sox</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sox'
plot(x, type = "l", log = "x", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sox_+3A_x">x</code></td>
<td>
<p>Fitted <code><a href="#topic+sox">sox</a></code> model.</p>
</td></tr>
<tr><td><code id="plot.sox_+3A_type">type</code></td>
<td>
<p>Graphical argument to be passed to <code><a href="graphics.html#topic+matplot">matplot</a>()</code>, a character string (length 1 vector) or vector of 1-character strings indicating the type of plot for each column of y, see <a href="graphics.html#topic+plot.default">plot.default</a> for all possible types. Default is &quot;l&quot; for lines.</p>
</td></tr>
<tr><td><code id="plot.sox_+3A_log">log</code></td>
<td>
<p>Graphical argument to be passed to <code><a href="graphics.html#topic+matplot">matplot</a>()</code>, a character string which contains &quot;x&quot; if the x axis is to be logarithmic, &quot;y&quot; if the y axis is to be logarithmic, &quot;&quot; if neither, &quot;xy&quot; or &quot;yx&quot; if both axes are to be logarithmic. Default is &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="plot.sox_+3A_...">...</code></td>
<td>
<p>Further arguments of <code><a href="graphics.html#topic+matplot">matplot</a>()</code> and ultimately of <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code> for some.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a coefficient profile plot of the coefficient paths for a fitted <code><a href="#topic+sox">sox</a></code> model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sox">sox</a></code>, <code><a href="#topic+sox_cv">sox_cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.matrix(sim[, c("A1","A2","C1","C2","B","A1B","A2B","C1B","C2B")])
lam.seq &lt;- exp(seq(log(1e0), log(1e-3), length.out = 20))

overlapping.groups &lt;- list(c(1, 2, 6, 7),
                           c(5, 6, 7, 8, 9),
                           c(6, 7),
                           c(3, 4, 8, 9),
                           c(8, 9))
                           
pars.overlapping &lt;- overlap_structure(overlapping.groups)

fit.overlapping &lt;- sox(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "overlapping",
  lambda = lam.seq,
  group = pars.overlapping$groups,
  group_variable = pars.overlapping$groups_var,
  penalty_weights = pars.overlapping$group_weights,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

plot(fit.overlapping)
              
cv.overlapping &lt;- sox_cv(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "overlapping",
  lambda = lam.seq,
  group = pars.overlapping$groups,
  group_variable = pars.overlapping$groups_var,
  penalty_weights = pars.overlapping$group_weights,
  nfolds = 5,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

plot(cv.overlapping$sox.fit)
          
</code></pre>

<hr>
<h2 id='plot.sox_cv'>Plots for <code>sox_cv</code></h2><span id='topic+plot.sox_cv'></span>

<h3>Description</h3>

<p>Plot the solution path or cross-validation curves produced by <code><a href="#topic+sox_cv">sox_cv</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sox_cv'
plot(x, type = "cv-curve", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sox_cv_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+sox_cv">sox_cv</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.sox_cv_+3A_type">type</code></td>
<td>
<p>Character string, &quot;<code>solution-path</code>&quot; to generate a solution path with marks at <code>lambda.min</code> and <code>lambda.1se</code>; &quot;<code>cv-curve</code>&quot; to generate a cross-validation curve.</p>
</td></tr>
<tr><td><code id="plot.sox_cv_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The &quot;<code>solution-path</code>&quot; plot produces a coefficient profile plot of the coefficient paths for a fitted <code><a href="#topic+sox">sox</a></code> model. The &quot;<code>cv-curve</code>&quot; plot is the <code>cvm</code> (red dot) for each lambda with its standard error (vertical bar). The two vertical dashed lines corresponds to the <code>lambda.min</code> and <code>lambda.1se</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sox">sox</a></code>, <code><a href="#topic+sox_cv">sox_cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.matrix(sim[, c("A1","A2","C1","C2","B","A1B","A2B","C1B","C2B")])
lam.seq &lt;- exp(seq(log(1e0), log(1e-3), length.out = 20))

overlapping.groups &lt;- list(c(1, 2, 6, 7),
                           c(5, 6, 7, 8, 9),
                           c(6, 7),
                           c(3, 4, 8, 9),
                           c(8, 9))
                           
pars.overlapping &lt;- overlap_structure(overlapping.groups)
              
cv.overlapping &lt;- sox_cv(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "overlapping",
  lambda = lam.seq,
  group = pars.overlapping$groups,
  group_variable = pars.overlapping$groups_var,
  penalty_weights = pars.overlapping$group_weights,
  nfolds = 5,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

plot(cv.overlapping)
plot(cv.overlapping, type = "solution-path")

</code></pre>

<hr>
<h2 id='sim'>A simulated demo dataset <code>sim</code></h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>A simulated demo dataset <code>sim</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim)
</code></pre>


<h3>Format</h3>

<p>A simulated data frame that is used to illustrate the use of the sox package. The max follow-up time for each subject is set to be 5. The total number of subject is 50.
</p>

<dl>
<dt>Id</dt><dd><p>The ID of each subject.</p>
</dd>
<dt>Event</dt><dd><p>During the time from <code>Start</code> to <code>Stop</code>, if the subject experience the event. We use the function <code>permalgorithm</code> in the <code>R</code> package <code>PermAlgo</code> to generate the Event.</p>
</dd>
<dt>Start</dt><dd><p>Start time.</p>
</dd>
<dt>Stop</dt><dd><p>Stop time.</p>
</dd>
<dt>Fup</dt><dd><p>The total follow-up time for the subject.</p>
</dd>
<dt>Covariates</dt><dd><p>A1, A2, C1, C2, B, A1B, A2B, C1B, C2B. The dataset contains 5 variables (9 columns after one-hot encoding). Variable A is a e 3-level categorical variable, which results in 2 binary variables (A1 and A2), the same with the variable C. B is a continuous variable. The interaction term AB and CB are also two 3-level categorical variables. The code for generating the covariates is given below.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>PermAlgo</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate B
gen_con=function(m){
 X=rnorm(m/5)
 XX=NULL
 for (i in 1:length(X)) {
   if (length(XX)&lt;m){
   X.rep=rep(X[i],round(runif(1,5,10),0))
   XX=c(XX,X.rep)
   }
 }
 return(XX[1:m])
}
# generate A and C
gen_cat=function(m){
 X=sample.int(3, m/5,replace = TRUE)
 XX=NULL
 for (i in 1:length(X)) {
   if (length(XX)&lt;m){
     X.rep=rep(X[i],round(runif(1,5,10),0))
     XX=c(XX,X.rep)
   }
 }
 return(XX[1:m])
}

# generate covariate for one subject
gen_X=function(m){
 A=gen_cat(m);B=gen_con(m);C=gen_cat(m)
 A1=ifelse(A==1,1,0);A2=ifelse(A==2,1,0)
 C1=ifelse(C==1,1,0);C2=ifelse(C==2,1,0)
 A1B=A1*B;A2B=A2*B
 C1B=C1*B;C2B=C2*B
 return(as.matrix(cbind(A1,A2,C1,C2,B,A1B,A2B,C1B,C2B)))
}

# generate covariate for all subject
gen_X_n=function(m,n){
 Xn=NULL
 for (i in 1:n) {
   X=gen_X(m)
   Xn=rbind(Xn,X)
 }
 return(Xn)
}

 n=50;m=5
 covariates=gen_X_n(m,n)
 # generate outcomes
 # library(PermAlgo)
 # data &lt;- permalgorithm(n, m, covariates, 
 #                       XmatNames = c("A1","A2","C1","C2","B","A1B","A2B","C1B","C2B"),
 #                       #change according to scenario 1/2
 #                       betas = c(rep(log(3),2),rep(0,2), log(4), rep(log(3),2),rep(0,2)),
 #                       groupByD=FALSE )
 # fit.original = coxph(Surv(Start, Stop, Event) ~ . ,data[,-c(1,3)])
</code></pre>

<hr>
<h2 id='sox'>(Time-dependent) Cox model with structured variable selection</h2><span id='topic+sox'></span>

<h3>Description</h3>

<p>Fit a (time-dependent) Cox model with overlapping (including nested) group lasso penalty. The regularization path is computed at a grid of values for the regularization parameter lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sox(
  x,
  ID,
  time,
  time2,
  event,
  penalty,
  lambda,
  group,
  group_variable,
  own_variable,
  no_own_variable,
  penalty_weights,
  par_init,
  stepsize_init = 1,
  stepsize_shrink = 0.8,
  tol = 1e-05,
  maxit = 1000L,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sox_+3A_x">x</code></td>
<td>
<p>Predictor matrix with dimension <code class="reqn">nm * p</code>, where <code class="reqn">n</code> is the number of subjects, <code class="reqn">m</code> is the maximum observation time, and <code class="reqn">p</code> is the number of predictors. See Details.</p>
</td></tr>
<tr><td><code id="sox_+3A_id">ID</code></td>
<td>
<p>The ID of each subjects, each subject has one ID (multiple rows in <code>x</code> can share one <code>ID</code>).</p>
</td></tr>
<tr><td><code id="sox_+3A_time">time</code></td>
<td>
<p>Represents the start of each time interval.</p>
</td></tr>
<tr><td><code id="sox_+3A_time2">time2</code></td>
<td>
<p>Represents the stop of each time interval.</p>
</td></tr>
<tr><td><code id="sox_+3A_event">event</code></td>
<td>
<p>Indicator of event. <code>event = 1</code> when event occurs and <code>event = 0</code> otherwise.</p>
</td></tr>
<tr><td><code id="sox_+3A_penalty">penalty</code></td>
<td>
<p>Character string, indicating whether &quot;<code>overlapping</code>&quot; or &quot;<code>nested</code>&quot; group lasso penalty is imposed.</p>
</td></tr>
<tr><td><code id="sox_+3A_lambda">lambda</code></td>
<td>
<p>Sequence of regularization coefficients <code class="reqn">\lambda</code>'s.</p>
</td></tr>
<tr><td><code id="sox_+3A_group">group</code></td>
<td>
<p>A <code class="reqn">G * G</code> integer matrix required to describe the structure of the <code>overlapping</code> and <code>nested</code> groups. We recommend that the users generate it automatically using <code><a href="#topic+overlap_structure">overlap_structure</a>()</code> and <code><a href="#topic+nested_structure">nested_structure</a>()</code>. See Examples and Details.</p>
</td></tr>
<tr><td><code id="sox_+3A_group_variable">group_variable</code></td>
<td>
<p>A <code class="reqn">p * G</code> integer matrix required to describe the structure of the <code>overlapping</code> groups. We recommend that the users generate it automatically using <code><a href="#topic+overlap_structure">overlap_structure</a>()</code>. See Examples and Details.</p>
</td></tr>
<tr><td><code id="sox_+3A_own_variable">own_variable</code></td>
<td>
<p>A non-decreasing integer vector of length <code class="reqn">G</code> required to describe the structure of the <code>nested</code> groups. We recommend that the users generate it automatically using <code><a href="#topic+nested_structure">nested_structure</a>()</code>. See Examples and Details.</p>
</td></tr>
<tr><td><code id="sox_+3A_no_own_variable">no_own_variable</code></td>
<td>
<p>An integer vector of length <code class="reqn">G</code> required to describe the structure of the <code>nested</code> groups. We recommend that the users generate it automatically using <code><a href="#topic+nested_structure">nested_structure</a>()</code>. See Examples and Details</p>
</td></tr>
<tr><td><code id="sox_+3A_penalty_weights">penalty_weights</code></td>
<td>
<p>Optional, vector of length <code class="reqn">G</code> specifying the group-specific penalty weights. We recommend that the users generate it automatically using <code><a href="#topic+overlap_structure">overlap_structure</a>()</code> or <code><a href="#topic+nested_structure">nested_structure</a>()</code>. If not specified, <code class="reqn">\mathbf{1}_G</code> is used.</p>
</td></tr>
<tr><td><code id="sox_+3A_par_init">par_init</code></td>
<td>
<p>Optional, vector of initial values of the optimization algorithm. Default initial value is zero for all <code class="reqn">p</code> variables.</p>
</td></tr>
<tr><td><code id="sox_+3A_stepsize_init">stepsize_init</code></td>
<td>
<p>Initial value of the stepsize of the optimization algorithm. Default is 1.0.</p>
</td></tr>
<tr><td><code id="sox_+3A_stepsize_shrink">stepsize_shrink</code></td>
<td>
<p>Factor in <code class="reqn">(0,1)</code> by which the stepsize shrinks in the backtracking linesearch. Default is 0.8.</p>
</td></tr>
<tr><td><code id="sox_+3A_tol">tol</code></td>
<td>
<p>Convergence criterion. Algorithm stops when the <code class="reqn">l_2</code> norm of the difference between two consecutive updates is smaller than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="sox_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="sox_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether progress is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictor matrix should be of dimension <code class="reqn">nm * p</code>. Each row records the values of covariates for one subject at one time, for example, the values at the day from <code>time</code> (Start) to <code>time2</code> (Stop). An example dataset <code><a href="#topic+sim">sim</a></code> is provided. The dataset has the format produced by the <code>R</code> package <span class="pkg">PermAlgo</span>. 
The specification of the arguments <code>group</code>, <code>group_variable</code>, <code>own_variable</code> and <code>no_own_variable</code> for the grouping structure can be found in <a href="https://thoth.inrialpes.fr/people/mairal/spams/doc-R/html/doc_spams006.html#sec26">https://thoth.inrialpes.fr/people/mairal/spams/doc-R/html/doc_spams006.html#sec26</a> and <a href="https://thoth.inrialpes.fr/people/mairal/spams/doc-R/html/doc_spams006.html#sec27">https://thoth.inrialpes.fr/people/mairal/spams/doc-R/html/doc_spams006.html#sec27</a>.
</p>
<p>In the Examples below, <code class="reqn">p=9,G=5</code>, the group structure is: </p>
<p style="text-align: center;"><code class="reqn">g_1 = \{A_{1}, A_{2}, A_{1}B, A_{2}B\},</code>
</p>
 <p style="text-align: center;"><code class="reqn">g_2  = \{B, A_{1}B, A_{2}B, C_{1}B, C_{2}B\},</code>
</p>
 <p style="text-align: center;"><code class="reqn">g_3  = \{A_{1}B, A_{2}B\},</code>
</p>
 <p style="text-align: center;"><code class="reqn">g_4  = \{C_1, C_2, C_{1}B, C_{2}B\},</code>
</p>
 <p style="text-align: center;"><code class="reqn">g_5  = \{C_{1}B, C_{2}B\}.</code>
</p>

<p>where <code class="reqn">g_3</code> is a subset of <code class="reqn">g_1</code> and <code class="reqn">g_2</code>, and <code class="reqn">g_5</code> is a subset of <code class="reqn">g_2</code> and <code class="reqn">g_4</code>.
</p>


<h3>Value</h3>

<p>A list with the following three elements.
</p>
<table>
<tr><td><code>lambdas</code></td>
<td>
<p>The user-specified regularization coefficients <code>lambda</code> sorted in decreasing order.</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>A matrix, with each column corresponding to the coefficient estimates at each <code class="reqn">\lambda</code> in <code>lambdas</code>.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>A vector of number of iterations it takes to converge at each <code class="reqn">\lambda</code> in <code>lambdas</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.matrix(sim[, c("A1","A2","C1","C2","B","A1B","A2B","C1B","C2B")])
lam.seq &lt;- exp(seq(log(1e0), log(1e-3), length.out = 20))

# Variables:
## 1: A1
## 2: A2
## 3: C1
## 4: C2
## 5: B
## 6: A1B
## 7: A2B
## 8: C1B
## 9: C2B

# Overlapping groups:
## g1: A1, A2, A1B, A2B
## g2: B, A1B, A2B, C1B, C2B
## g3: A1B, A2B
## g4: C1, C2, C1B, C2B
## g5: C1B, C2B

overlapping.groups &lt;- list(c(1, 2, 6, 7),
                           c(5, 6, 7, 8, 9),
                           c(6, 7),
                           c(3, 4, 8, 9),
                           c(8, 9))
                           
pars.overlapping &lt;- overlap_structure(overlapping.groups)

fit.overlapping &lt;- sox(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "overlapping",
  lambda = lam.seq,
  group = pars.overlapping$groups,
  group_variable = pars.overlapping$groups_var,
  penalty_weights = pars.overlapping$group_weights,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

str(fit.overlapping)

# Nested groups (misspecified, for the demonstration of the software only.)
## g1: A1, A2, C1, C2, B, A1B, A2B, C1B, C2B
## g2: A1B, A2B, A1B, A2B
## g3: C1, C2, C1B, C2B
## g4: 1
## g5: 2
## ...
## G12: 9

nested.groups &lt;- list(1:9,
                      c(1, 2, 6, 7),
                      c(3, 4, 8, 9),
                      1, 2, 3, 4, 5, 6, 7, 8, 9)

pars.nested &lt;- nested_structure(nested.groups)

fit.nested &lt;- sox(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "nested",
  lambda = lam.seq,
  group = pars.nested$groups,
  own_variable = pars.nested$own_variables,
  no_own_variable = pars.nested$N_own_variables,
  penalty_weights = pars.nested$group_weights,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

str(fit.nested)

</code></pre>

<hr>
<h2 id='sox_cv'>cross-validation for <code>sox</code></h2><span id='topic+sox_cv'></span>

<h3>Description</h3>

<p>Conduct cross-validation (cv) for <code>sox</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sox_cv(
  x,
  ID,
  time,
  time2,
  event,
  penalty,
  lambda,
  group,
  group_variable,
  own_variable,
  no_own_variable,
  penalty_weights,
  par_init,
  nfolds = 10,
  foldid = NULL,
  stepsize_init = 1,
  stepsize_shrink = 0.8,
  tol = 1e-05,
  maxit = 1000L,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sox_cv_+3A_x">x</code></td>
<td>
<p>Predictor matrix with dimension <code class="reqn">nm * p</code>, where <code class="reqn">n</code> is the number of subjects, <code class="reqn">m</code> is the maximum observation time, and <code class="reqn">p</code> is the number of predictors. See Details.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_id">ID</code></td>
<td>
<p>The ID of each subjects, each subject has one ID (multiple rows in <code>x</code> can share one <code>ID</code>).</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_time">time</code></td>
<td>
<p>Represents the start of each time interval.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_time2">time2</code></td>
<td>
<p>Represents the stop of each time interval.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_event">event</code></td>
<td>
<p>Indicator of event. <code>event = 1</code> when event occurs and <code>event = 0</code> otherwise.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_penalty">penalty</code></td>
<td>
<p>Character string, indicating whether &quot;<code>overlapping</code>&quot; or &quot;<code>nested</code>&quot; group lasso penalty is imposed.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_lambda">lambda</code></td>
<td>
<p>Sequence of regularization coefficients <code class="reqn">\lambda</code>'s.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_group">group</code></td>
<td>
<p>A <code class="reqn">G * G</code> integer matrix required to describe the structure of the <code>overlapping</code> and <code>nested</code> groups. We recommend that the users generate it automatically using <code><a href="#topic+overlap_structure">overlap_structure</a>()</code> and <code><a href="#topic+nested_structure">nested_structure</a>()</code>. See Examples and Details.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_group_variable">group_variable</code></td>
<td>
<p>A <code class="reqn">p * G</code> integer matrix required to describe the structure of the <code>overlapping</code> groups. We recommend that the users generate it automatically using <code><a href="#topic+overlap_structure">overlap_structure</a>()</code>. See Examples and Details.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_own_variable">own_variable</code></td>
<td>
<p>A non-decreasing integer vector of length <code class="reqn">G</code> required to describe the structure of the <code>nested</code> groups. We recommend that the users generate it automatically using <code><a href="#topic+nested_structure">nested_structure</a>()</code>. See Examples and Details.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_no_own_variable">no_own_variable</code></td>
<td>
<p>An integer vector of length <code class="reqn">G</code> required to describe the structure of the <code>nested</code> groups. We recommend that the users generate it automatically using <code><a href="#topic+nested_structure">nested_structure</a>()</code>. See Examples and Details</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_penalty_weights">penalty_weights</code></td>
<td>
<p>Optional, vector of length <code class="reqn">G</code> specifying the group-specific penalty weights. We recommend that the users generate it automatically using <code><a href="#topic+overlap_structure">overlap_structure</a>()</code> or <code><a href="#topic+nested_structure">nested_structure</a>()</code>. If not specified, <code class="reqn">\mathbf{1}_G</code> is used.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_par_init">par_init</code></td>
<td>
<p>Optional, vector of initial values of the optimization algorithm. Default initial value is zero for all <code class="reqn">p</code> variables.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_nfolds">nfolds</code></td>
<td>
<p>Optional, the folds of cross-validation. Default is 10.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_foldid">foldid</code></td>
<td>
<p>Optional, user-specified vector indicating the cross-validation fold in which each observation should be included. Values in this vector should range from 1 to <code>nfolds</code>. If left unspecified, <code>sox</code> will randomly assign observations to folds</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_stepsize_init">stepsize_init</code></td>
<td>
<p>Initial value of the stepsize of the optimization algorithm. Default is 1.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_stepsize_shrink">stepsize_shrink</code></td>
<td>
<p>Factor in <code class="reqn">(0,1)</code> by which the stepsize shrinks in the backtracking linesearch. Default is 0.8.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_tol">tol</code></td>
<td>
<p>Convergence criterion. Algorithm stops when the <code class="reqn">l_2</code> norm of the difference between two consecutive updates is smaller than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="sox_cv_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether progress is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each lambda, 10 folds cross-validation (by default) is performed. The cv error is defined as follows. Suppose we perform <code class="reqn">K</code>-fold cross-validation, denote <code class="reqn">\hat{\beta}^{-k}</code> by the estimate obtained from the rest of <code class="reqn">K-1</code> folds (training set). The error of the <code class="reqn">k</code>-th fold (test set) is defined as <code class="reqn">2(P-Q)</code> divided by <code class="reqn">R</code>, where <code class="reqn">P</code> is the log partial likelihood evaluated at  <code class="reqn">\hat{\beta}^{-k}</code> using the entire dataset, Q is the log partial likelihood evaluated at <code class="reqn">\hat{\beta}^{-k}</code> using the training set, and R is the number of events in the test set. We do not use the negative log partial likelihood evaluated at <code class="reqn">\hat{\beta}^{-k}</code> using the test set because the former definition can efficiently use the risk set, and thus it is more stable when the number of events in each test set is small (think of leave-one-out). The cv error is used in parameter tuning. To account for balance in outcomes among the randomly formed test set, we divide the deviance <code class="reqn">2(P-Q)</code> by R. 
To get the estimated coefficients that has the minimum cv error, use <code>sox_cv()$Estimates[, sox_cv$index["min",]]</code>. To apply the 1-se rule, use <code>sox_cv()$Estimates[, sox_cv$index["1se",]]</code>.
</p>


<h3>Value</h3>

<p>A list.
</p>
<table>
<tr><td><code>lambdas</code></td>
<td>
<p>A vector of lambda used for each cross-validation.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>The cv error averaged across all folds for each lambda.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>The standard error of the cv error for each lambda.</p>
</td></tr>
<tr><td><code>cvup</code></td>
<td>
<p>The cv error plus its standard error for each lambda.</p>
</td></tr>
<tr><td><code>cvlo</code></td>
<td>
<p>The cv error minus its standard error for each lambda.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>The number of non-zero coefficients at each lambda.</p>
</td></tr>
<tr><td><code>sox.fit</code></td>
<td>
<p>A fitted model for the full data at all lambdas of class &quot;<code>sox</code>&quot;.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The lambda such that the <code>cvm</code> reach its minimum.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The maximum of lambda such that the <code>cvm</code> is less than the minimum the <code>cvup</code> (the minmum of <code>cvm</code> plus its standard error).</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>The fold assignments used.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>A one column matrix with the indices of <code>lambda.min</code> and <code>lambda.1se</code>.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>A vector of number of iterations it takes to converge at each <code class="reqn">\lambda</code> in <code>lambdas</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sox">sox</a></code>, <code><a href="#topic+plot.sox_cv">plot.sox_cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.matrix(sim[, c("A1","A2","C1","C2","B","A1B","A2B","C1B","C2B")])
lam.seq &lt;- exp(seq(log(1e0), log(1e-3), length.out = 20))

# Variables:
## 1: A1
## 2: A2
## 3: C1
## 4: C2
## 5: B
## 6: A1B
## 7: A2B
## 8: C1B
## 9: C2B

# Overlapping groups:
## g1: A1, A2, A1B, A2B
## g2: B, A1B, A2B, C1B, C2B
## g3: A1B, A2B
## g4: C1, C2, C1B, C2B
## g5: C1B, C2B

overlapping.groups &lt;- list(c(1, 2, 6, 7),
                           c(5, 6, 7, 8, 9),
                           c(6, 7),
                           c(3, 4, 8, 9),
                           c(8, 9))
                           
pars.overlapping &lt;- overlap_structure(overlapping.groups)

cv.overlapping &lt;- sox_cv(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "overlapping",
  lambda = lam.seq,
  group = pars.overlapping$groups,
  group_variable = pars.overlapping$groups_var,
  penalty_weights = pars.overlapping$group_weights,
  nfolds = 5,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

str(cv.overlapping)

# Nested groups (misspecified, for the demonstration of the software only.)
## g1: A1, A2, C1, C2, B, A1B, A2B, C1B, C2B
## g2: A1B, A2B, A1B, A2B
## g3: C1, C2, C1B, C2B
## g4: 1
## g5: 2
## ...
## G12: 9

nested.groups &lt;- list(1:9,
                      c(1, 2, 6, 7),
                      c(3, 4, 8, 9),
                      1, 2, 3, 4, 5, 6, 7, 8, 9)

pars.nested &lt;- nested_structure(nested.groups)

cv.nested &lt;- sox_cv(
  x = x,
  ID = sim$Id,
  time = sim$Start,
  time2 = sim$Stop,
  event = sim$Event,
  penalty = "nested",
  lambda = lam.seq,
  group = pars.nested$groups,
  own_variable = pars.nested$own_variables,
  no_own_variable = pars.nested$N_own_variables,
  penalty_weights = pars.nested$group_weights,
  nfolds = 5,
  tol = 1e-4,
  maxit = 1e3,
  verbose = FALSE
)

str(cv.nested)
                
</code></pre>

<hr>
<h2 id='sox-package'>sox: Structured Learning in Time-Dependent Cox Models</h2><span id='topic+sox-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Efficient procedures for fitting and cross-validating the structurally-regularized time-dependent Cox models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yi Lian <a href="mailto:yi.lian@mail.mcgill.ca">yi.lian@mail.mcgill.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Guanbo Wang
</p>
</li>
<li><p> Archer Y. Yang
</p>
</li>
<li><p> Mireille E. Schnitzer
</p>
</li>
<li><p> Robert W. Platt
</p>
</li>
<li><p> Rui Wang
</p>
</li>
<li><p> Marc Dorais
</p>
</li>
<li><p> Sylvie Perreault
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Julien Mairal [contributor]
</p>
</li>
<li><p> Yuansi Chen [contributor]
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
