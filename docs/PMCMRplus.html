<!DOCTYPE html><html><head><title>Help for package PMCMRplus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PMCMRplus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adAllPairsTest'><p>Anderson-Darling All-Pairs Comparison Test</p></a></li>
<li><a href='#adKSampleTest'><p>Anderson-Darling k-Sample Test</p></a></li>
<li><a href='#adManyOneTest'><p>Anderson-Darling Many-To-One Comparison Test</p></a></li>
<li><a href='#algae'><p>Algae Growth Inhibition Data Set</p></a></li>
<li><a href='#barPlot'><p>Plotting PMCMR Objects</p></a></li>
<li><a href='#bwsAllPairsTest'><p>BWS All-Pairs Comparison Test</p></a></li>
<li><a href='#bwsKSampleTest'><p>Murakami's k-Sample BWS Test</p></a></li>
<li><a href='#bwsManyOneTest'><p>BWS Many-To-One Comparison Test</p></a></li>
<li><a href='#bwsTrendTest'><p>Testing against Ordered Alternatives (Murakami's BWS Trend Test)</p></a></li>
<li><a href='#chaAllPairsNashimotoTest'><p>All-Pairs Comparisons for Simply Ordered Mean Ranksums</p></a></li>
<li><a href='#chackoTest'><p>Testing against Ordered Alternatives (Chacko's Test)</p></a></li>
<li><a href='#chenJanTest'><p>Chen and Jan Many-to-One Comparisons Test</p></a></li>
<li><a href='#chenTest'><p>Chen's Many-to-One Comparisons Test</p></a></li>
<li><a href='#Cochran'><p>Cochran's distribution</p></a></li>
<li><a href='#cochranTest'><p>Cochran Test</p></a></li>
<li><a href='#cuzickTest'><p>Testing against Ordered Alternatives (Cuzick's Test)</p></a></li>
<li><a href='#Dgrubbs'><p>Grubbs D* distribution</p></a></li>
<li><a href='#doubleGrubbsTest'><p>Grubbs Double Outlier Test</p></a></li>
<li><a href='#dscfAllPairsTest'><p>Multiple Comparisons of Mean Rank Sums</p></a></li>
<li><a href='#duncanTest'><p>Duncan's Multiple Range Test</p></a></li>
<li><a href='#dunnettT3Test'><p>Dunnett's T3 Test</p></a></li>
<li><a href='#dunnettTest'><p>Dunnett's Many-to-One Comparisons Test</p></a></li>
<li><a href='#durbinAllPairsTest'><p>All-Pairs Comparisons Test for Balanced Incomplete Block Designs</p></a></li>
<li><a href='#durbinTest'><p>Durbin Test</p></a></li>
<li><a href='#flignerWolfeTest'><p>Testing Several Treatments With One Control</p></a></li>
<li><a href='#frdAllPairsConoverTest'><p>Conover's All-Pairs Comparisons Test for Unreplicated Blocked Data</p></a></li>
<li><a href='#frdAllPairsExactTest'><p>Exact All-Pairs Comparisons Test for Unreplicated Blocked Data</p></a></li>
<li><a href='#frdAllPairsMillerTest'><p>Millers's All-Pairs Comparisons Test for Unreplicated Blocked Data</p></a></li>
<li><a href='#frdAllPairsNemenyiTest'><p>Nemenyi's All-Pairs Comparisons Test for Unreplicated Blocked Data</p></a></li>
<li><a href='#frdAllPairsSiegelTest'><p>Siegel and Castellan's All-Pairs Comparisons Test for</p>
Unreplicated Blocked Data</a></li>
<li><a href='#frdHouseTest'><p>House Test</p></a></li>
<li><a href='#frdManyOneDemsarTest'><p>Demsar's Many-to-One Test</p>
for Unreplicated Blocked Data</a></li>
<li><a href='#frdManyOneExactTest'><p>Exact Many-to-One Test</p>
for Unreplicated Blocked Data</a></li>
<li><a href='#frdManyOneNemenyiTest'><p>Nemenyi's Many-to-One Test</p>
for Unreplicated Blocked Data</a></li>
<li><a href='#friedmanTest'><p>Friedman Rank Sum Test</p></a></li>
<li><a href='#gamesHowellTest'><p>Games-Howell Test</p></a></li>
<li><a href='#gesdTest'><p>Generalized Extreme Studentized Deviate Many-Outlier Test</p></a></li>
<li><a href='#goreTest'><p>Gore Test</p></a></li>
<li><a href='#Grubbs'><p>Grubbs distribution</p></a></li>
<li><a href='#grubbsTest'><p>Grubbs Outlier Test</p></a></li>
<li><a href='#GSTTest'><p>Generalized Siegel-Tukey Test of Homogeneity of</p>
Scales</a></li>
<li><a href='#hartleyTest'><p>Hartley's Maximum F-Ratio Test of Homogeneity of</p>
Variances</a></li>
<li><a href='#hayterStoneTest'><p>Hayter-Stone Test</p></a></li>
<li><a href='#hsAllPairsTest'><p>Hayter-Stone All-Pairs Comparison Test</p></a></li>
<li><a href='#johnsonTest'><p>Testing against Ordered Alternatives (Johnson-Mehrotra Test)</p></a></li>
<li><a href='#jonckheereTest'><p>Testing against Ordered Alternatives (Jonckheere-Terpstra Test)</p></a></li>
<li><a href='#kruskalTest'><p>Kruskal-Wallis Rank Sum Test</p></a></li>
<li><a href='#kwAllPairsConoverTest'><p>Conover's All-Pairs Rank Comparison Test</p></a></li>
<li><a href='#kwAllPairsDunnTest'><p>Dunn's All-Pairs Rank Comparison Test</p></a></li>
<li><a href='#kwAllPairsNemenyiTest'><p>Nemenyi's All-Pairs Rank Comparison Test</p></a></li>
<li><a href='#kwManyOneConoverTest'><p>Conover's Many-to-One Rank Comparison Test</p></a></li>
<li><a href='#kwManyOneDunnTest'><p>Dunn's Many-to-One Rank Comparison Test</p></a></li>
<li><a href='#kwManyOneNdwTest'><p>Nemenyi-Damico-Wolfe Many-to-One Rank Comparison Test</p></a></li>
<li><a href='#leTest'><p>Testing against Ordered Alternatives (Le's Test)</p></a></li>
<li><a href='#lsdTest'><p>Least Significant Difference Test</p></a></li>
<li><a href='#mackWolfeTest'><p>Mack-Wolfe Test for Umbrella Alternatives</p></a></li>
<li><a href='#Mandel-h'><p>Mandel's h Distribution</p></a></li>
<li><a href='#Mandel-k'><p>Mandel's k Distribution</p></a></li>
<li><a href='#mandelhTest'><p>Mandel's h Test According to E 691 ASTM</p></a></li>
<li><a href='#mandelkTest'><p>Mandel's k Test According to E 691 ASTM</p></a></li>
<li><a href='#manyOneUTest'><p>Multiple Comparisons with One Control (U-test)</p></a></li>
<li><a href='#mrrTest'><p>Madhava Rao-Raghunath Test for Testing Treatment vs. Control</p></a></li>
<li><a href='#MTest'><p>Extended One-Sided Studentised Range Test</p></a></li>
<li><a href='#normalScoresAllPairsTest'><p>Lu-Smith All-Pairs Comparison Normal Scores Test</p></a></li>
<li><a href='#normalScoresManyOneTest'><p>Lu-Smith Many-One Comparisons Normal Scores Test</p></a></li>
<li><a href='#normalScoresTest'><p>Lu-Smith Normal Scores Test</p></a></li>
<li><a href='#NPMTest'><p>All-Pairs Comparisons for Simply Ordered Mean Ranksums</p></a></li>
<li><a href='#osrtTest'><p>One-Sided Studentized Range Test</p></a></li>
<li><a href='#pageTest'><p>Page Rank Sum Test</p></a></li>
<li><a href='#Pentosan'><p>Pentosan Dataset</p></a></li>
<li><a href='#plot.mandel'><p>Plotting mandel Objects</p></a></li>
<li><a href='#plot.PMCMR'><p>Plotting PMCMR Objects</p></a></li>
<li><a href='#power.dunnett.test'><p>Power Calculations for Balanced Dunnett's</p>
Many-to-One Comparison Test</a></li>
<li><a href='#power.tukey.test'><p>Power Calculations for Balanced Tukey's</p>
Multiple Comparison Test</a></li>
<li><a href='#power.williams.test'><p>Power calculations for</p>
minimum detectable difference of the Williams' test</a></li>
<li><a href='#powerMCTests'><p>Power Simulation for One-Factorial All-Pairs and Many-To-One Comparison Tests</p></a></li>
<li><a href='#powerOneWayTests'><p>Power Simulation for One-Factorial Single Hypothesis Tests</p></a></li>
<li><a href='#print.gesdTest'><p>gesdTest Printing</p></a></li>
<li><a href='#print.mandel'><p>Mandel Printing</p></a></li>
<li><a href='#print.osrt'><p>osrt Printing</p></a></li>
<li><a href='#print.PMCMR'><p>PMCMR Printing</p></a></li>
<li><a href='#print.powerOneWayPMCMR'><p>PowerOneWayPMCMR Printing</p></a></li>
<li><a href='#print.powerPMCMR'><p>PowerPMCMR Printing</p></a></li>
<li><a href='#print.trendPMCMR'><p>trendPMCMR Printing</p></a></li>
<li><a href='#qDunnett'><p>Dunnett Distribution</p></a></li>
<li><a href='#qPCR'><p>qPCR Curve Analysis Methods</p></a></li>
<li><a href='#quadeAllPairsTest'><p>All-Pairs Comparisons for</p>
Unreplicated Blocked Data (Quade's All-Pairs Test)</a></li>
<li><a href='#reviewers'><p>Reviewers</p></a></li>
<li><a href='#scheffeTest'><p>Scheffe's Test</p></a></li>
<li><a href='#shanTest'><p>Testing against Ordered Alternatives (Shan-Young-Kang Test)</p></a></li>
<li><a href='#shirleyWilliamsTest'><p>Shirley-Williams Test</p></a></li>
<li><a href='#siegelTukeyTest'><p>Siegel-Tukey Rank Dispersion Test</p></a></li>
<li><a href='#skillingsMackTest'><p>Skillings-Mack Test</p></a></li>
<li><a href='#snkTest'><p>Student-Newman-Keuls Test</p></a></li>
<li><a href='#spearmanTest'><p>Testing against Ordered Alternatives (Spearman Test)</p></a></li>
<li><a href='#steelsKSampleTest'><p>Steel's k-Treatments vs. Control Test</p></a></li>
<li><a href='#steelTest'><p>Steel's Many-to-One Rank Test</p></a></li>
<li><a href='#stepDownTrendTest'><p>Step Down Trend Tests</p></a></li>
<li><a href='#summary.gesdTest'><p>Summarize an gesdTest Object</p></a></li>
<li><a href='#summary.mandel'><p>Object Summary for class <code>"mandel"</code></p></a></li>
<li><a href='#summary.osrt'><p>Summarize an osrt Object</p></a></li>
<li><a href='#summary.PMCMR'><p>Summarize an PMCMR Object</p></a></li>
<li><a href='#summary.trendPMCMR'><p>Summarize an trendPMCMR Object</p></a></li>
<li><a href='#summaryGroup'><p>Grouped Summary of an PMCMR Object</p></a></li>
<li><a href='#tamhaneDunnettTest'><p>Tamhane-Dunnett Many-to-One Comparison Test</p></a></li>
<li><a href='#tamhaneT2Test'><p>Tamhane's T2 Test</p></a></li>
<li><a href='#toTidy'><p>Convert a PMCMR or osrt Object to a Data.Frame</p></a></li>
<li><a href='#trout'><p>Data from a Dose-Response Experiment with Trouts</p></a></li>
<li><a href='#tukeyTest'><p>Tukey's Multiple Comparison Test</p></a></li>
<li><a href='#uryWigginsHochbergTest'><p>Ury, Wiggins, Hochberg Test</p></a></li>
<li><a href='#vanWaerdenAllPairsTest'><p>van-der-Waerden's All-Pairs Comparison Normal Scores Test</p></a></li>
<li><a href='#vanWaerdenManyOneTest'><p>van-der-Waerden's Many-One Comparisons Normal Scores Test</p></a></li>
<li><a href='#vanWaerdenTest'><p>van der Waerden's Normal Scores Test</p></a></li>
<li><a href='#welchManyOneTTest'><p>Welchs's Many-To-One Comparison Test</p></a></li>
<li><a href='#williamsTest'><p>Williams Trend Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculate Pairwise Multiple Comparisons of Mean Rank Sums
Extended</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-10</td>
</tr>
<tr>
<td>Description:</td>
<td>For one-way layout experiments the one-way ANOVA can
	     be performed as an omnibus test. All-pairs multiple comparisons 
	     tests (Tukey-Kramer test, Scheffe test, LSD-test) 
	     and many-to-one tests (Dunnett test) for normally distributed 
	     residuals and equal within variance are available. Furthermore,
	     all-pairs tests (Games-Howell test, Tamhane's T2 test, 
	     Dunnett T3 test, Ury-Wiggins-Hochberg test) and many-to-one
	     (Tamhane-Dunnett Test) for normally distributed residuals 
	     and heterogeneous variances are provided. Van der Waerden's normal
	     scores test for omnibus, all-pairs and many-to-one tests is
	     provided for non-normally distributed residuals and homogeneous
	     variances. The Kruskal-Wallis, BWS and Anderson-Darling
	     omnibus test and all-pairs tests
	     (Nemenyi test, Dunn test, Conover test, Dwass-Steele-Critchlow-
	     Fligner test) as well as many-to-one (Nemenyi test, Dunn test,
	     U-test) are given for the analysis of variance by ranks. 
             Non-parametric trend tests (Jonckheere test, Cuzick test,
	     Johnson-Mehrotra test, Spearman test) are included. 
	     In addition, a Friedman-test for one-way ANOVA with repeated 
	     measures on ranks (CRBD) and Skillings-Mack test for unbalanced 
	     CRBD is provided with consequent all-pairs tests (Nemenyi test, 
	     Siegel test, Miller test, Conover test, Exact test)
	     and many-to-one tests (Nemenyi test, Demsar test, Exact test). 
	     A trend can be tested with Pages's test. Durbin's test 
	     for a two-way balanced incomplete block design (BIBD) is given 
	     in this package as well as Gore's test for CRBD with multiple
	     observations per cell is given.  Outlier tests, Mandel's k- and
	     h statistic as well as functions for Type I error and Power 
	     analysis as well as generic summary, print and plot methods 
             are provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm (&ge; 1.0), multcompView, gmp, Rmpfr, SuppDists,
kSamples (&ge; 1.2.7), BWStest (&ge; 0.2.1), MASS, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable, graphics, knitr, rmarkdown, car, e1071, multcomp,
pwr, NSM3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gmp (&gt;= 4.2.3), mpfr (&gt;= 3.0.0) | file README.md</td>
</tr>
<tr>
<td>SystemRequirementsNote:</td>
<td>see &gt;&gt; README.md</td>
</tr>
<tr>
<td>SysDataCompression:</td>
<td>gzip</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Classification/MSC-2010:</td>
<td>62J15, 62J10, 62G10, 62F03, 62G30</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 14:49:27 UTC; thorsten</td>
</tr>
<tr>
<td>Author:</td>
<td>Thorsten Pohlert <a href="https://orcid.org/0000-0003-3855-3025"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thorsten Pohlert &lt;thorsten.pohlert@gmx.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adAllPairsTest'>Anderson-Darling All-Pairs Comparison Test</h2><span id='topic+adAllPairsTest'></span><span id='topic+adAllPairsTest.default'></span><span id='topic+adAllPairsTest.formula'></span>

<h3>Description</h3>

<p>Performs Anderson-Darling all-pairs comparison test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adAllPairsTest(x, ...)

## Default S3 method:
adAllPairsTest(x, g, p.adjust.method = p.adjust.methods, ...)

## S3 method for class 'formula'
adAllPairsTest(
  formula,
  data,
  subset,
  na.action,
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adAllPairsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="adAllPairsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="adAllPairsTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="adAllPairsTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="adAllPairsTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="adAllPairsTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="adAllPairsTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="adAllPairsTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with non-normally distributed residuals Anderson-Darling's
all-pairs comparison test can be used. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: F_i(x) = F_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: F_i(x) \ne F_j(x), ~~ i \ne j</code>.
</p>
<p>This function is a wrapper function that sequentially
calls <code>adKSampleTest</code> for each pair.
The calculated p-values for <code>Pr(&gt;|T2N|)</code>
can be adjusted to account for Type I error multiplicity
using any method as implemented in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Scholz, F.W., Stephens, M.A. (1987) K-Sample Anderson-Darling Tests.
<em>Journal of the American Statistical Association</em> <b>82</b>, 918&ndash;924.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adKSampleTest">adKSampleTest</a></code>, <code><a href="#topic+adManyOneTest">adManyOneTest</a></code>,
<code><a href="kSamples.html#topic+ad.pval">ad.pval</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adKSampleTest(count ~ spray, InsectSprays)

out &lt;- adAllPairsTest(count ~ spray, InsectSprays, p.adjust="holm")
summary(out)
summaryGroup(out)

</code></pre>

<hr>
<h2 id='adKSampleTest'>Anderson-Darling k-Sample Test</h2><span id='topic+adKSampleTest'></span><span id='topic+adKSampleTest.default'></span><span id='topic+adKSampleTest.formula'></span>

<h3>Description</h3>

<p>Performs Anderson-Darling k-sample test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adKSampleTest(x, ...)

## Default S3 method:
adKSampleTest(x, g, ...)

## S3 method for class 'formula'
adKSampleTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adKSampleTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="adKSampleTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="adKSampleTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="adKSampleTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="adKSampleTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="adKSampleTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="adKSampleTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis, H<code class="reqn">_0: F_1 = F_2 = \ldots = F_k</code>
is tested against the alternative,
H<code class="reqn">_\mathrm{A}: F_i \ne F_j ~~(i \ne j)</code>, with at least
one unequality beeing strict.
</p>
<p>This function only evaluates version 1 of the k-sample Anderson-Darling
test (i.e. Eq. 6) of Scholz and Stephens (1987).
The p-values are estimated with the extended empirical function
as implemented in <code><a href="kSamples.html#topic+ad.pval">ad.pval</a></code> of
the package <span class="pkg">kSamples</span>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Scholz, F.W., Stephens, M.A. (1987) K-Sample Anderson-Darling Tests.
<em>Journal of the American Statistical Association</em> <b>82</b>, 918&ndash;924.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adAllPairsTest">adAllPairsTest</a></code>, <code><a href="#topic+adManyOneTest">adManyOneTest</a></code>,
<code><a href="kSamples.html#topic+ad.pval">ad.pval</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hollander &amp; Wolfe (1973), 116.
## Mucociliary efficiency from the rate of removal of dust in normal
## subjects, subjects with obstructive airway disease, and subjects
## with asbestosis.
x &lt;- c(2.9, 3.0, 2.5, 2.6, 3.2) # normal subjects
y &lt;- c(3.8, 2.7, 4.0, 2.4)      # with obstructive airway disease
z &lt;- c(2.8, 3.4, 3.7, 2.2, 2.0) # with asbestosis
g &lt;- factor(x = c(rep(1, length(x)),
                   rep(2, length(y)),
                   rep(3, length(z))),
             labels = c("ns", "oad", "a"))
dat &lt;- data.frame(
   g = g,
   x = c(x, y, z))

## AD-Test
adKSampleTest(x ~ g, data = dat)

## BWS-Test
bwsKSampleTest(x ~ g, data = dat)

## Kruskal-Test
## Using incomplete beta approximation
kruskalTest(x ~ g, dat, dist="KruskalWallis")
## Using chisquare distribution
kruskalTest(x ~ g, dat, dist="Chisquare")

## Not run: 
## Check with kruskal.test from R stats
kruskal.test(x ~ g, dat)

## End(Not run)
## Using Conover's F
kruskalTest(x ~ g, dat, dist="FDist")

## Not run: 
## Check with aov on ranks
anova(aov(rank(x) ~ g, dat))
## Check with oneway.test
oneway.test(rank(x) ~ g, dat, var.equal = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='adManyOneTest'>Anderson-Darling Many-To-One Comparison Test</h2><span id='topic+adManyOneTest'></span><span id='topic+adManyOneTest.default'></span><span id='topic+adManyOneTest.formula'></span>

<h3>Description</h3>

<p>Performs Anderson-Darling many-to-one comparison test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adManyOneTest(x, ...)

## Default S3 method:
adManyOneTest(x, g, p.adjust.method = p.adjust.methods, ...)

## S3 method for class 'formula'
adManyOneTest(
  formula,
  data,
  subset,
  na.action,
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adManyOneTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="adManyOneTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="adManyOneTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="adManyOneTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting
p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="adManyOneTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="adManyOneTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="adManyOneTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="adManyOneTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in an one-factorial layout with non-normally distributed
residuals Anderson-Darling's non-parametric test can be performed.
Let there be <code class="reqn">k</code> groups including the control,
then the number of treatment levels is <code class="reqn">m = k - 1</code>.
Then <code class="reqn">m</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: F_0 = F_i</code> is tested in the two-tailed case against
A<code class="reqn">_i: F_0 \ne F_i, ~~ (1 \le i \le m)</code>.
</p>
<p>This function is a wrapper function that sequentially
calls <code>adKSampleTest</code> for each pair.
The calculated p-values for <code>Pr(&gt;|T2N|)</code>
can be adjusted to account for Type I error inflation
using any method as implemented in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Scholz, F.W., Stephens, M.A. (1987) K-Sample Anderson-Darling Tests.
<em>Journal of the American Statistical Association</em> <b>82</b>, 918&ndash;924.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adKSampleTest">adKSampleTest</a></code>, <code><a href="#topic+adAllPairsTest">adAllPairsTest</a></code>,
<code><a href="kSamples.html#topic+ad.pval">ad.pval</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set PlantGrowth
## Global test
adKSampleTest(weight ~ group, data = PlantGrowth)

##
ans &lt;- adManyOneTest(weight ~ group,
                             data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)
</code></pre>

<hr>
<h2 id='algae'>Algae Growth Inhibition Data Set</h2><span id='topic+algae'></span>

<h3>Description</h3>

<p>A dose-response experiment was conducted using Atrazine
at 9 different dose-levels including the zero-dose control
and the biomass of algae (<em>Selenastrum
capricornutum</em>) as the response variable. Three replicates
were measured at day 0, 1 and 2. The fluorescence method (Mayer et
al. 1997) was applied to measure biomass.
</p>


<h3>Format</h3>

<p>A data frame with 22 observations on the following 10 variables.
</p>

<dl>
<dt>concentration</dt><dd><p>a numeric vector of dose value in mg / L</p>
</dd>
<dt>Day.0</dt><dd><p>a numeric vector, total biomass</p>
</dd>
<dt>Day.0.1</dt><dd><p>a numeric vector, total biomass</p>
</dd>
<dt>Day.0.2</dt><dd><p>a numeric vector, total biomass</p>
</dd>
<dt>Day.1</dt><dd><p>a numeric vector, total biomass</p>
</dd>
<dt>Day.1.1</dt><dd><p>a numeric vector, total biomass</p>
</dd>
<dt>Day.1.2</dt><dd><p>a numeric vector, total biomass</p>
</dd>
<dt>Day.2</dt><dd><p>a numeric vector, total biomass</p>
</dd>
<dt>Day.2.1</dt><dd><p>a numeric vector, total biomass</p>
</dd>
<dt>Day.2.2</dt><dd><p>a numeric vector, total biomass</p>
</dd>
</dl>



<h3>Source</h3>

<p>ENV/JM/MONO(2006)18/ANN, page 24.
</p>


<h3>References</h3>

<p>OECD (ed. 2006) <em>Current approaches in the statistical analysis
of ecotoxicity data: A guidance to application - Annexes</em>, OECD Series
on testing and assessment, No. 54, (ENV/JM/MONO(2006)18/ANN).
</p>


<h3>See Also</h3>

<p><code>demo(algae)</code>
</p>

<hr>
<h2 id='barPlot'>Plotting PMCMR Objects</h2><span id='topic+barPlot'></span>

<h3>Description</h3>

<p>Plots a bar-plot for objects of class <code>"PMCMR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barPlot(x, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barPlot_+3A_x">x</code></td>
<td>
<p>an object of class <code>"PMCMR"</code>.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_alpha">alpha</code></td>
<td>
<p>the selected alpha-level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_...">...</code></td>
<td>
<p>further arguments for method <code>barplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A barplot where the height of the bars corresponds to the arithmetic
mean. The extend of the whiskers are <code class="reqn">\pm z_{(1-\alpha/2)}
\times s_{\mathrm{E},i}</code>, where the latter denotes the standard error
of the <code class="reqn">i</code>th group. Symbolic letters are depicted on top of the bars,
whereas different letters indicate significant differences between
groups for the selected level of alpha.
</p>


<h3>Note</h3>

<p>The barplot is strictly spoken only valid for normal data, as
the depicted significance intervall implies symetry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data set chickwts
ans &lt;- tukeyTest(weight ~ feed, data = chickwts)
barPlot(ans)
</code></pre>

<hr>
<h2 id='bwsAllPairsTest'>BWS All-Pairs Comparison Test</h2><span id='topic+bwsAllPairsTest'></span><span id='topic+bwsAllPairsTest.default'></span><span id='topic+bwsAllPairsTest.formula'></span>

<h3>Description</h3>

<p>Performs Baumgartner-Weiß-Schindler all-pairs comparison test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwsAllPairsTest(x, ...)

## Default S3 method:
bwsAllPairsTest(
  x,
  g,
  method = c("BWS", "Murakami"),
  p.adjust.method = p.adjust.methods,
  ...
)

## S3 method for class 'formula'
bwsAllPairsTest(
  formula,
  data,
  subset,
  na.action,
  method = c("BWS", "Murakami"),
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwsAllPairsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="bwsAllPairsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="bwsAllPairsTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="bwsAllPairsTest_+3A_method">method</code></td>
<td>
<p>a character string specifying the test statistic to use. Defaults to <code>BWS</code>.</p>
</td></tr>
<tr><td><code id="bwsAllPairsTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="bwsAllPairsTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="bwsAllPairsTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="bwsAllPairsTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="bwsAllPairsTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with non-normally distributed residuals Baumgartner-Weiß-Schindler
all-pairs comparison test can be used. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: F_i(x) = F_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: F_i(x) \ne F_j(x), ~~ i \ne j</code>.
</p>
<p>This function is a wrapper function that sequentially
calls <code><a href="BWStest.html#topic+bws_test">bws_test</a></code> for each pair.
The default test method (<code>"BWS"</code>) is the original
Baumgartner-Weiß-Schindler test statistic B. For
<code>method == "Murakami"</code> it is the modified BWS statistic
denoted B*. The calculated p-values for <code>Pr(&gt;|B|)</code>
or <code>Pr(&gt;|B*|)</code> can be adjusted to account for Type I error
inflation using any method as implemented in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Baumgartner, W., Weiss, P., Schindler, H. (1998) A nonparametric test for the
general two-sample problem, <em>Biometrics</em> <b>54</b>, 1129&ndash;1135.
</p>
<p>Murakami, H. (2006) K-sample rank test based on modified Baumgartner statistic and its power
comparison, <em>J. Jpn. Comp. Statist.</em> <b>19</b>, 1&ndash;13.
</p>


<h3>See Also</h3>

<p><code><a href="BWStest.html#topic+bws_test">bws_test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- bwsAllPairsTest(count ~ spray, InsectSprays, p.adjust="holm")
summary(out)
summaryGroup(out)

</code></pre>

<hr>
<h2 id='bwsKSampleTest'>Murakami's k-Sample BWS Test</h2><span id='topic+bwsKSampleTest'></span><span id='topic+bwsKSampleTest.default'></span><span id='topic+bwsKSampleTest.formula'></span>

<h3>Description</h3>

<p>Performs Murakami's k-Sample BWS Test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwsKSampleTest(x, ...)

## Default S3 method:
bwsKSampleTest(x, g, nperm = 1000, ...)

## S3 method for class 'formula'
bwsKSampleTest(formula, data, subset, na.action, nperm = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwsKSampleTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="bwsKSampleTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="bwsKSampleTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="bwsKSampleTest_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the assymptotic permutation test.
Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="bwsKSampleTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="bwsKSampleTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="bwsKSampleTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="bwsKSampleTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X_{ij} ~ (1 \le i \le k,~ 1 \le 1 \le n_i)</code> denote an
identically and independently distributed variable that is obtained
from an unknown continuous distribution <code class="reqn">F_i(x)</code>. Let <code class="reqn">R_{ij}</code>
be the rank of <code class="reqn">X_{ij}</code>, where <code class="reqn">X_{ij}</code> is jointly ranked
from <code class="reqn">1</code> to <code class="reqn">N, ~ N = \sum_{i=1}^k n_i</code>.
In the <code class="reqn">k</code>-sample test the null hypothesis, H: <code class="reqn">F_i = F_j</code>
is tested against the alternative,
A: <code class="reqn">F_i \ne F_j ~~(i \ne j)</code> with at least one inequality
beeing strict. Murakami (2006) has generalized
the two-sample Baumgartner-Weiß-Schindler test
(Baumgartner et al. 1998) and proposed a
modified statistic <code class="reqn">B_k^*</code> defined by
</p>
<p style="text-align: center;"><code class="reqn">
B_{k}^* = \frac{1}{k}\sum_{i=1}^k
\left\{\frac{1}{n_i} \sum_{j=1}^{n_i} \frac{(R_{ij} - \mathsf{E}[R_{ij}])^2}
   {\mathsf{Var}[R_{ij}]}\right\},
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
\mathsf{E}[R_{ij}] = \frac{N + 1}{n_i + 1} j
</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
\mathsf{Var}[R_{ij}] = \frac{j}{n_i + 1} \left(1 - \frac{j}{n_i + 1}\right)
\frac{\left(N-n_i\right)\left(N+1\right)}{n_i + 2}.
</code>
</p>

<p>The <code class="reqn">p</code>-values are estimated via an assymptotic boot-strap method.
It should be noted that the <code class="reqn">B_k^*</code> detects both differences in the
unknown location parameters and / or differences
in the unknown scale parameters of the <code class="reqn">k</code>-samples.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>One may increase the number of permutations to e.g. <code>nperm = 10000</code>
in order to get more precise p-values. However, this will be on
the expense of computational time.
</p>


<h3>References</h3>

<p>Baumgartner, W., Weiss, P., Schindler, H. (1998) A nonparametric test for the
general two-sample problem, <em>Biometrics</em> <b>54</b>, 1129&ndash;1135.
</p>
<p>Murakami, H. (2006) K-sample rank test based on modified Baumgartner statistic and its power
comparison, <em>J. Jpn. Comp. Statist.</em> <b>19</b>, 1&ndash;13.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>, <code><a href="#topic+bwsAllPairsTest">bwsAllPairsTest</a></code>,
<code><a href="#topic+bwsManyOneTest">bwsManyOneTest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hollander &amp; Wolfe (1973), 116.
## Mucociliary efficiency from the rate of removal of dust in normal
## subjects, subjects with obstructive airway disease, and subjects
## with asbestosis.
x &lt;- c(2.9, 3.0, 2.5, 2.6, 3.2) # normal subjects
y &lt;- c(3.8, 2.7, 4.0, 2.4)      # with obstructive airway disease
z &lt;- c(2.8, 3.4, 3.7, 2.2, 2.0) # with asbestosis
g &lt;- factor(x = c(rep(1, length(x)),
                   rep(2, length(y)),
                   rep(3, length(z))),
             labels = c("ns", "oad", "a"))
dat &lt;- data.frame(
   g = g,
   x = c(x, y, z))

## AD-Test
adKSampleTest(x ~ g, data = dat)

## BWS-Test
bwsKSampleTest(x ~ g, data = dat)

## Kruskal-Test
## Using incomplete beta approximation
kruskalTest(x ~ g, dat, dist="KruskalWallis")
## Using chisquare distribution
kruskalTest(x ~ g, dat, dist="Chisquare")

## Not run: 
## Check with kruskal.test from R stats
kruskal.test(x ~ g, dat)

## End(Not run)
## Using Conover's F
kruskalTest(x ~ g, dat, dist="FDist")

## Not run: 
## Check with aov on ranks
anova(aov(rank(x) ~ g, dat))
## Check with oneway.test
oneway.test(rank(x) ~ g, dat, var.equal = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='bwsManyOneTest'>BWS Many-To-One Comparison Test</h2><span id='topic+bwsManyOneTest'></span><span id='topic+bwsManyOneTest.default'></span><span id='topic+bwsManyOneTest.formula'></span>

<h3>Description</h3>

<p>Performs Baumgartner-Weiß-Schindler many-to-one comparison test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwsManyOneTest(x, ...)

## Default S3 method:
bwsManyOneTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  method = c("BWS", "Murakami", "Neuhauser"),
  p.adjust.method = p.adjust.methods,
  ...
)

## S3 method for class 'formula'
bwsManyOneTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  method = c("BWS", "Murakami", "Neuhauser"),
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwsManyOneTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_method">method</code></td>
<td>
<p>a character string specifying the test statistic to use. Defaults to <code>BWS</code>.</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="bwsManyOneTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in an one-factorial layout with non-normally distributed
residuals Baumgartner-Weiß-Schindler's non-parametric test can be performed.
Let there be <code class="reqn">k</code> groups including the control,
then the number of treatment levels is <code class="reqn">m = k - 1</code>.
Then <code class="reqn">m</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: F_0 = F_i</code> is tested in the two-tailed case against
A<code class="reqn">_i: F_0 \ne F_i, ~~ (1 \le i \le m)</code>.
</p>
<p>This function is a wrapper function that sequentially
calls <code><a href="BWStest.html#topic+bws_stat">bws_stat</a></code> and <code><a href="BWStest.html#topic+bws_cdf">bws_cdf</a></code>
for each pair. For the default test method (<code>"BWS"</code>) the original
Baumgartner-Weiß-Schindler test statistic B and its corresponding Pr(&gt;|B|)
is calculated. For <code>method == "BWS"</code> only a two-sided test is possible.
</p>
<p>For <code>method == "Murakami"</code> the modified BWS statistic
denoted B* and its corresponding Pr(&gt;|B*|) is computed by sequentially calling
<code><a href="BWStest.html#topic+murakami_stat">murakami_stat</a></code> and <code><a href="BWStest.html#topic+murakami_cdf">murakami_cdf</a></code>.
For <code>method == "Murakami"</code> only a two-sided test is possible.
</p>
<p>If <code>alternative == "greater"</code> then the alternative, if one
population is stochastically larger than the other is tested:
H<code class="reqn">_i: F_0 = F_i</code> against A<code class="reqn">_i: F_0 \ge F_i, ~~ (1 \le i \le m)</code>.
The modified test-statistic B* according to Neuhäuser (2001) and its
corresponding Pr(&gt;B*) or Pr(&lt;B*) is computed by sequentally calling
<code><a href="BWStest.html#topic+murakami_stat">murakami_stat</a></code> and <code><a href="BWStest.html#topic+murakami_cdf">murakami_cdf</a></code>
with <code>flavor = 2</code>.
</p>
<p>The p-values can be adjusted to account for Type I error
inflation using any method as implemented in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Baumgartner, W., Weiss, P., Schindler, H. (1998) A nonparametric test for the
general two-sample problem, <em>Biometrics</em> <b>54</b>, 1129&ndash;1135.
</p>
<p>Murakami, H. (2006) K-sample rank test based on modified Baumgartner statistic and its power
comparison, <em>J Jpn Comp Statist</em> <b>19</b>, 1&ndash;13.
</p>
<p>Neuhäuser, M. (2001) One-Side Two-Sample and Trend Tests Based on a Modified
Baumgartner-Weiss-Schindler Statistic. <em>J Nonparametric Stat</em> <b>13</b>, 729&ndash;739.
</p>


<h3>See Also</h3>

<p><code><a href="BWStest.html#topic+murakami_stat">murakami_stat</a></code>, <code><a href="BWStest.html#topic+murakami_cdf">murakami_cdf</a></code>,
<code><a href="BWStest.html#topic+bws_stat">bws_stat</a></code>, <code><a href="BWStest.html#topic+bws_cdf">bws_cdf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- bwsManyOneTest(weight ~ group, PlantGrowth, p.adjust="holm")
summary(out)

## A two-sample test
set.seed(1245)
x &lt;- c(rnorm(20), rnorm(20,0.3))
g &lt;- gl(2, 20)
summary(bwsManyOneTest(x ~ g, alternative = "less", p.adjust="none"))
summary(bwsManyOneTest(x ~ g, alternative = "greater", p.adjust="none"))

## Not run: 
## Check with the implementation in package BWStest
BWStest::bws_test(x=x[g==1], y=x[g==2], alternative = "less")
BWStest::bws_test(x=x[g==1], y=x[g==2], alternative = "greater")

## End(Not run)
</code></pre>

<hr>
<h2 id='bwsTrendTest'>Testing against Ordered Alternatives (Murakami's BWS Trend Test)</h2><span id='topic+bwsTrendTest'></span><span id='topic+bwsTrendTest.default'></span><span id='topic+bwsTrendTest.formula'></span>

<h3>Description</h3>

<p>Performs Murakami's modified Baumgartner-Weiß-Schindler
test for testing against ordered alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwsTrendTest(x, ...)

## Default S3 method:
bwsTrendTest(x, g, nperm = 1000, ...)

## S3 method for class 'formula'
bwsTrendTest(formula, data, subset, na.action, nperm = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwsTrendTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="bwsTrendTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="bwsTrendTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="bwsTrendTest_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the assymptotic permutation test.
Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="bwsTrendTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="bwsTrendTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="bwsTrendTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="bwsTrendTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis, H<code class="reqn">_0: F_1(u) = F_2(u) = \ldots = F_k(u) ~~ u \in R</code>
is tested against a simple order hypothesis,
H<code class="reqn">_\mathrm{A}: F_1(u) \le F_2(u) \le \ldots \le
F_k(u),~F_1(u) &lt; F_k(u), ~~ u \in R</code>.
</p>
<p>The p-values are estimated through an assymptotic boot-strap method
using the function <code><a href="base.html#topic+sample">sample</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>One may increase the number of permutations to e.g. <code>nperm = 10000</code>
in order to get more precise p-values. However, this will be on
the expense of computational time.
</p>
<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Baumgartner, W., Weiss, P., Schindler, H. (1998) A nonparametric test for the
general two-sample problem, <em>Biometrics</em> <b>54</b>, 1129&ndash;1135.
</p>
<p>Murakami, H. (2006) K-sample rank test based on modified Baumgartner statistic and its power
comparison, <em>J Jpn Comp Statist</em> <b>19</b>, 1&ndash;13.
</p>
<p>Neuhäuser, M. (2001) One-Side Two-Sample and Trend Tests Based on a Modified
Baumgartner-Weiss-Schindler Statistic. <em>J Nonparametric Stat</em> <b>13</b>, 729&ndash;739.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>, <code><a href="#topic+bwsAllPairsTest">bwsAllPairsTest</a></code>,
<code><a href="#topic+bwsManyOneTest">bwsManyOneTest</a></code>.
</p>
<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='chaAllPairsNashimotoTest'>All-Pairs Comparisons for Simply Ordered Mean Ranksums</h2><span id='topic+chaAllPairsNashimotoTest'></span><span id='topic+chaAllPairsNashimotoTest.default'></span><span id='topic+chaAllPairsNashimotoTest.formula'></span>

<h3>Description</h3>

<p>Performs Nashimoto and Wright's all-pairs comparison procedure
for simply ordered mean ranksums (NPT'-test and NPY'-test).
</p>
<p>According to the authors, the procedure shall only be
applied after Chacko's test (see <code><a href="#topic+chackoTest">chackoTest</a></code>) indicates
global significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chaAllPairsNashimotoTest(x, ...)

## Default S3 method:
chaAllPairsNashimotoTest(
  x,
  g,
  p.adjust.method = c(p.adjust.methods),
  alternative = c("greater", "less"),
  dist = c("Normal", "h"),
  ...
)

## S3 method for class 'formula'
chaAllPairsNashimotoTest(
  formula,
  data,
  subset,
  na.action,
  p.adjust.method = c(p.adjust.methods),
  alternative = c("greater", "less"),
  dist = c("Normal", "h"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values. Ignored if <code>dist = "h"</code>.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_dist">dist</code></td>
<td>
<p>the test distribution. Defaults to <code>Normal</code>.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="chaAllPairsNashimotoTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The modified procedure uses the property of a simple order,
<code class="reqn">\theta_m' - \theta_m \le \theta_j - \theta_i \le \theta_l' - \theta_l
\qquad (l \le i \le m~\mathrm{and}~ m' \le j \le l')</code>.
The null hypothesis H<code class="reqn">_{ij}: \theta_i = \theta_j</code> is tested against
the alternative A<code class="reqn">_{ij}: \theta_i &lt; \theta_j</code> for any
<code class="reqn">1 \le i &lt; j \le k</code>.
</p>
<p>Let <code class="reqn">R_{ij}</code> be the rank of <code class="reqn">X_{ij}</code>,
where <code class="reqn">X_{ij}</code> is jointly ranked
from <code class="reqn">\left\{1, 2, \ldots, N \right\}, ~~ N = \sum_{i=1}^k n_i</code>,
then the test statistics for all-pairs comparisons
and a balanced design is calculated as
</p>
<p style="text-align: center;"><code class="reqn">
 \hat{T}_{ij} = \max_{i \le m &lt; m' \le j}
 \frac{\left(\bar{R}_{m'} - \bar{R}_m \right)}
 {\sigma_a / \sqrt{n}},
</code>
</p>

<p>with <code class="reqn">n = n_i; ~ N = \sum_i^k n_i ~~ (1 \le i \le k)</code>, <code class="reqn">\bar{R}_i</code>
the mean rank for the <code class="reqn">i</code>th group,
and the expected variance (without ties) <code class="reqn">\sigma_a^2 = N \left(N + 1 \right) / 12</code>.
</p>
<p>For the NPY'-test (<code>dist = "h"</code>), if <code class="reqn">T_{ij} &gt; h_{k-1,\alpha,\infty}</code>.
</p>
<p>For the unbalanced case with moderate imbalance the test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
 \hat{T}_{ij} = \max_{i \le m &lt; m' \le j} \frac{\left(\bar{R}_{m'} - \bar{R}_m \right)}
 {\sigma_a \left(1/n_m + 1/n_{m'}\right)^{1/2}},
</code>
</p>

<p>For the NPY'-test (<code>dist="h"</code>) the null hypothesis is rejected in an unbalanced design,
if <code class="reqn">\hat{T}_{ij} &gt; h_{k,\alpha,\infty} / \sqrt{2}</code>.
In case of a NPY'-test, the function does not return p-values. Instead the critical h-values
as given in the tables of Hayter (1990) for <code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the number of groups (<code class="reqn">k-1</code>) and
the degree of freedoms (<code class="reqn">v = \infty</code>).
</p>
<p>For the NPT'-test (<code>dist = "Normal"</code>), the null hypothesis is rejected, if
<code class="reqn">T_{ij} &gt; \sqrt{2} t_{\alpha,\infty} = \sqrt{2} z_\alpha</code>. Although Nashimoto and Wright (2005) originally did not use any p-adjustment,
any method as available by <code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code> can
be selected for the adjustment of p-values estimated from
the standard normal distribution.
</p>


<h3>Value</h3>

<p>Either a list of class <code>"osrt"</code> if <code>dist = "h"</code>  or a list
of class <code>"PMCMR"</code> if <code>dist = "Normal"</code>.
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>
<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function will give a warning for the unbalanced case and returns the
critical value <code class="reqn">h_{k-1,\alpha,\infty} / \sqrt{2}</code> if applicable.
</p>


<h3>References</h3>

<p>Hayter, A. J.(1990) A One-Sided Studentised Range
Test for Testing Against a Simple Ordered Alternative,
<em>J Amer Stat Assoc</em> <b>85</b>, 778&ndash;785.
</p>
<p>Nashimoto, K., Wright, F.T. (2007)
Nonparametric Multiple-Comparison Methods for Simply Ordered Medians.
<em>Comput Stat Data Anal</em> <b>51</b>, 5068&ndash;5076.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code>, <code><a href="#topic+chackoTest">chackoTest</a></code>,
<code><a href="#topic+NPMTest">NPMTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Shirley (1977)
## Reaction times of mice to stimuli to their tails.
x &lt;- c(2.4, 3, 3, 2.2, 2.2, 2.2, 2.2, 2.8, 2, 3,
 2.8, 2.2, 3.8, 9.4, 8.4, 3, 3.2, 4.4, 3.2, 7.4, 9.8, 3.2, 5.8,
 7.8, 2.6, 2.2, 6.2, 9.4, 7.8, 3.4, 7, 9.8, 9.4, 8.8, 8.8, 3.4,
 9, 8.4, 2.4, 7.8)
g &lt;- gl(4, 10)

## Shirley's test
## one-sided test using look-up table
shirleyWilliamsTest(x ~ g, alternative = "greater")

## Chacko's global hypothesis test for 'greater'
chackoTest(x , g)

## post-hoc test, default is standard normal distribution (NPT'-test)
summary(chaAllPairsNashimotoTest(x, g, p.adjust.method = "none"))

## same but h-distribution (NPY'-test)
chaAllPairsNashimotoTest(x, g, dist = "h")

## NPM-test
NPMTest(x, g)

## Hayter-Stone test
hayterStoneTest(x, g)

## all-pairs comparisons
hsAllPairsTest(x, g)
</code></pre>

<hr>
<h2 id='chackoTest'>Testing against Ordered Alternatives (Chacko's Test)</h2><span id='topic+chackoTest'></span><span id='topic+chackoTest.default'></span><span id='topic+chackoTest.formula'></span>

<h3>Description</h3>

<p>Performs Chacko's test for testing against ordered alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chackoTest(x, ...)

## Default S3 method:
chackoTest(x, g, alternative = c("greater", "less"), ...)

## S3 method for class 'formula'
chackoTest(formula, data, subset, na.action, alternative = alternative, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chackoTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="chackoTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="chackoTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="chackoTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="chackoTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="chackoTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="chackoTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="chackoTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis, H<code class="reqn">_0: \theta_1 = \theta_2 = \ldots = \theta_k</code>
is tested against a simple order hypothesis,
H<code class="reqn">_\mathrm{A}: \theta_1 \le \theta_2 \le \ldots \le
\theta_k,~\theta_1 &lt; \theta_k</code>.
</p>
<p>Let <code class="reqn">R_{ij}</code> be the rank of <code class="reqn">X_{ij}</code>,
where <code class="reqn">X_{ij}</code> is jointly ranked
from <code class="reqn">\left\{1, 2, \ldots, N \right\}, ~~ N = \sum_{i=1}^k n_i</code>,
then the test statistic is calculated as
</p>
<p style="text-align: center;"><code class="reqn">
H = \frac{1}{\sigma_R^2} \sum_{i=1}^k n_i \left(\bar{R^*}_i - \bar{R}\right),
</code>
</p>

<p>where <code class="reqn">\bar{R^*}_i</code> is the isotonic mean of the <code class="reqn">i</code>-th group
and <code class="reqn">\sigma_R^2 = N \left(N + 1\right) / 12</code> the expected variance (without ties).
H<code class="reqn">_0</code> is rejected, if <code class="reqn">H &gt; \chi^2_{v,\alpha}</code> with
<code class="reqn">v = k -1</code> degree of freedom. The p-values are estimated
from the chi-square distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The source code for the application of the pool adjacent violators
theorem to calculate the isotonic means
was taken from the file <code>"pava.f"</code>, which is included in the
package <span class="pkg">Iso</span>:
</p>
<p>Rolf Turner (2015). Iso: Functions to Perform Isotonic Regression.
R package version 0.0-17.
<a href="https://CRAN.R-project.org/package=Iso">https://CRAN.R-project.org/package=Iso</a>.
</p>
<p>The file <code>"pava.f"</code> is a Ratfor modification of Algorithm AS 206.1:
</p>
<p>Bril, G., Dykstra, R., Pillers, C., Robertson, T. (1984)
Statistical Algorithms: Algorithm AS 206: Isotonic
Regression in Two Independent Variables, <em>Appl Statist</em>
<b>34</b>, 352&ndash;357.
</p>
<p>The Algorith AS 206 is available from StatLib
<a href="http://lib.stat.cmu.edu/apstat/">http://lib.stat.cmu.edu/apstat/</a>. The Royal Statistical Society
holds the copyright to these routines,
but has given its permission for their distribution provided that
no fee is charged.
</p>


<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>
<p>The function does neither check nor correct for ties.
</p>


<h3>References</h3>

<p>Chacko, V. J. (1963) Testing homogeneity against ordered alternatives,
<em>Ann Math Statist</em> <b>34</b>, 945&ndash;956.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='chenJanTest'>Chen and Jan Many-to-One Comparisons Test</h2><span id='topic+chenJanTest'></span><span id='topic+chenJanTest.default'></span>

<h3>Description</h3>

<p>Performs Chen and Jan nonparametric test for contrasting increasing
(decreasing) dose levels of a treatment in a randomized block design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chenJanTest(y, ...)

## Default S3 method:
chenJanTest(
  y,
  groups,
  blocks,
  alternative = c("greater", "less"),
  p.adjust.method = c("single-step", "SD1", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chenJanTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="chenJanTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="chenJanTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="chenJanTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="chenJanTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>)</p>
</td></tr>
<tr><td><code id="chenJanTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chen's test is a non-parametric step-down trend test for
testing several treatment levels with a zero control. Let
there be <code class="reqn">k</code> groups including the control and let
the zero dose level be indicated with <code class="reqn">i = 0</code> and the highest
dose level with <code class="reqn">i = m</code>, then the following <code>m = k - 1</code> hypotheses are tested:
</p>
<p style="text-align: center;"><code class="reqn">
\begin{array}{ll}
\mathrm{H}_{m}: \theta_0 = \theta_1 = \ldots = \theta_m, &amp; \mathrm{A}_{m} = \theta_0 \le \theta_1 \le \ldots \theta_m, \theta_0 &lt; \theta_m \\
\mathrm{H}_{m-1}: \theta_0 = \theta_1 = \ldots = \theta_{m-1}, &amp; \mathrm{A}_{m-1} = \theta_0 \le \theta_1 \le \ldots \theta_{m-1}, \theta_0 &lt; \theta_{m-1} \\
\vdots &amp; \vdots \\
\mathrm{H}_{1}: \theta_0 = \theta_1, &amp; \mathrm{A}_{1} = \theta_0 &lt; \theta_1\\
\end{array}
</code>
</p>

<p>Let <code class="reqn">Y_{ij1}, Y_{ij2}, \ldots, Y_{ijn_{ij}}</code>
<code class="reqn">(i = 1, 2, \dots, b, j = 0, 1, \ldots, k ~ \mathrm{and} ~ n_{ij} \geq 1)</code> be
a i.i.d. random variable of at least ordinal scale. Further,the zero dose
control is indicated with <code class="reqn">j = 0</code>.
</p>
<p>The Mann-Whittney statistic is
</p>
<p style="text-align: center;"><code class="reqn">
T_{ij} = \sum_{u=0}^{j-1} \sum_{s=1}^{n_{ij}}
\sum_{r=1}^{n_{iu}} I(Y_{ijs} - Y_{iur}),
\qquad i = 1, 2, \ldots, b, ~ j = 1, 2, \ldots, k,
</code>
</p>

<p>where where the indicator function returns <code class="reqn">I(a) = 1, ~ \mathrm{if}~ a &gt; 0, 0.5 ~ \mathrm{if} a = 0</code>
otherwise <code class="reqn">0</code>.
</p>
<p>Let
</p>
<p style="text-align: center;"><code class="reqn">
N_{ij} = \sum_{s=0}^j n_{is} \qquad  i = 1, 2, \ldots, b, ~ j = 1, 2, \ldots, k,
</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
T_j = \sum_{i=1}^b T_{ij} \qquad j = 1, 2, \ldots, k.
</code>
</p>

<p>The mean and variance of <code class="reqn">T_j</code> are
</p>
<p style="text-align: center;"><code class="reqn">
\mu(T_j) = \sum_{i=1}^b n_{ij} ~ N_{ij-1} / 2 \qquad \mathrm{and}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
 \sigma(T_j) = \sum_{i=1}^b n_{ij} ~ N_{ij-1} \left[
 \left(N_{ij} + 1\right) - \sum_{u=1}^{g_i}
 \left(t_u^3 - t_u \right) /
 \left\{N_{ij} \left(N_{ij} - 1\right) \right\} \right]/ 2,
</code>
</p>

<p>with <code class="reqn">g_i</code> the number of ties in the <code class="reqn">i</code>th block and
<code class="reqn">t_u</code> the size of the tied group <code class="reqn">u</code>.
</p>
<p>The test statistic <code class="reqn">T_j^*</code> is asymptotically multivariate normal
distributed.
</p>
<p style="text-align: center;"><code class="reqn">
T_j^* = \frac{T_j - \mu(T_j)}{\sigma(T_j)}
</code>
</p>

<p>If <code>p.adjust.method =  "single-step"</code> than the p-values
are calculated with the probability function of the multivariate
normal distribution with <code class="reqn">\Sigma = I_k</code>. Otherwise
the standard normal distribution is used to calculate
p-values and any method as available
by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> or by the step-down procedure as proposed
by Chen (1999), if <code>p.adjust.method = "SD1"</code> can be used
to account for <code class="reqn">\alpha</code>-error inflation.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chen, Y.I., Jan, S.L., 2002. Nonparametric Identification of
the Minimum Effective Dose for Randomized Block Designs.
<em>Commun Stat-Simul Comput</em> <strong>31</strong>, 301&ndash;312.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code> <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Chen and Jan (2002, p. 306)
## MED is at dose level 2 (0.5 ppm SO2)
y &lt;- c(0.2, 6.2, 0.3, 0.3, 4.9, 1.8, 3.9, 2, 0.3, 2.5, 5.4, 2.3, 12.7,
-0.2, 2.1, 6, 1.8, 3.9, 1.1, 3.8, 2.5, 1.3, -0.8, 13.1, 1.1,
12.8, 18.2, 3.4, 13.5, 4.4, 6.1, 2.8, 4, 10.6, 9, 4.2, 6.7, 35,
9, 12.9, 2, 7.1, 1.5, 10.6)
groups &lt;- gl(4,11, labels = c("0", "0.25", "0.5", "1.0"))
blocks &lt;- structure(rep(1:11, 4), class = "factor",
levels = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"))

summary(chenJanTest(y, groups, blocks, alternative = "greater"))
summary(chenJanTest(y, groups, blocks, alternative = "greater", p.adjust = "SD1"))

</code></pre>

<hr>
<h2 id='chenTest'>Chen's Many-to-One Comparisons Test</h2><span id='topic+chenTest'></span><span id='topic+chenTest.default'></span><span id='topic+chenTest.formula'></span>

<h3>Description</h3>

<p>Performs Chen's nonparametric test for contrasting increasing
(decreasing) dose levels of a treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chenTest(x, ...)

## Default S3 method:
chenTest(
  x,
  g,
  alternative = c("greater", "less"),
  p.adjust.method = c("SD1", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
chenTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  p.adjust.method = c("SD1", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chenTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="chenTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="chenTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="chenTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="chenTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>)</p>
</td></tr>
<tr><td><code id="chenTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="chenTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="chenTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="chenTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chen's test is a non-parametric step-down trend test for
testing several treatment levels with a zero control.
Let <code class="reqn">X_{0j}</code> denote a variable with the <code class="reqn">j</code>-th
realization of the control group (<code class="reqn">1 \le j \le n_0</code>)
and <code class="reqn">X_{ij}</code> the <code class="reqn">j</code>-the realization
in the <code class="reqn">i</code>-th treatment group (<code class="reqn">1 \le i \le k</code>).
The variables are i.i.d. of a least ordinal scale with
<code class="reqn">F(x) = F(x_0) = F(x_i), ~ (1 \le i \le k)</code>.
A total of <code class="reqn">m = k</code> hypotheses can be tested:
</p>
<p style="text-align: center;"><code class="reqn">
\begin{array}{ll}
\mathrm{H}_{m}: \theta_0 = \theta_1 = \ldots = \theta_m, &amp; \mathrm{A}_{m} = \theta_0 \le \theta_1 \le \ldots \theta_m, \theta_0 &lt; \theta_m \\
\mathrm{H}_{m-1}: \theta_0 = \theta_1 = \ldots = \theta_{m-1}, &amp; \mathrm{A}_{m-1} = \theta_0 \le \theta_1 \le \ldots \theta_{m-1}, \theta_0 &lt; \theta_{m-1} \\
\vdots &amp; \vdots \\
\mathrm{H}_{1}: \theta_0 = \theta_1, &amp; \mathrm{A}_{1} = \theta_0 &lt; \theta_1\\
\end{array}
</code>
</p>

<p>The statistics <code class="reqn">T_i</code> are based on a Wilcoxon-type ranking:
</p>
<p style="text-align: center;"><code class="reqn">
T_i = \sum_{j=0}^{i=1} \sum_{u=1}^{n_i} \sum_{v=1}^{n_j} I(x_{iu} - x_{jv}), \qquad (1 \leq i \leq k),
</code>
</p>

<p>where the indicator function returns <code class="reqn">I(a) = 1, ~ \mathrm{if}~ a &gt; 0, 0.5 ~ \mathrm{if} a = 0</code>
otherwise <code class="reqn">0</code>.
</p>
<p>The expected <code class="reqn">i</code>th mean is
</p>
<p style="text-align: center;"><code class="reqn">
\mu(T_i) = n_i N_{i-1} / 2,
</code>
</p>

<p>with <code class="reqn">N_j = \sum_{j =0}^i n_j</code> and the <code class="reqn">i</code>th variance:
</p>
<p style="text-align: center;"><code class="reqn">
\sigma^2(T_i) = n_i N_{i-1} / 12 ~ \left\{N_i + 1 -
\sum_{j=1}^g t_j \left(t_j^2 - 1 \right) /
\left[N_i \left( N_i - 1 \right)\right]\right\}.
</code>
</p>

<p>The test statistic <code class="reqn">T_i^*</code> is asymptotically standard normal
</p>
<p style="text-align: center;"><code class="reqn">
 T_i^* = \frac{T_i - \mu(T_i)}
 {\sqrt{\sigma^2(T_i)}}, \qquad (1 \leq i \leq k).
</code>
</p>

<p>The p-values are calculated from the standard normal distribution.
The p-values can be adjusted with any method as available
by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> or by the step-down procedure as proposed
by Chen (1999), if <code>p.adjust.method = "SD1"</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Chen, Y.-I., 1999, Nonparametric Identification of the
Minimum Effective Dose. <em>Biometrics</em> <strong>55</strong>, 1236&ndash;1240.
<a href="https://doi.org/10.1111/j.0006-341X.1999.01236.x">doi:10.1111/j.0006-341X.1999.01236.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>, <code><a href="stats.html#topic+Normal">Normal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Chen, 1999, p. 1237,
## Minimum effective dose (MED)
## is at 2nd dose level
df &lt;- data.frame(x = c(23, 22, 14,
27, 23, 21,
28, 37, 35,
41, 37, 43,
28, 21, 30,
16, 19, 13),
g = gl(6, 3))
levels(df$g) &lt;- 0:5
ans &lt;- chenTest(x ~ g, data = df, alternative = "greater",
                p.adjust.method = "SD1")
summary(ans)

</code></pre>

<hr>
<h2 id='Cochran'>Cochran's distribution</h2><span id='topic+Cochran'></span><span id='topic+qcochran'></span><span id='topic+pcochran'></span>

<h3>Description</h3>

<p>Distribution function and quantile function
for Cochran's distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcochran(p, k, n, lower.tail = TRUE, log.p = FALSE)

pcochran(q, k, n, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cochran_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Cochran_+3A_k">k</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code id="Cochran_+3A_n">n</code></td>
<td>
<p>(average) sample size of the k groups.</p>
</td></tr>
<tr><td><code id="Cochran_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default),
probabilities are <code class="reqn">P[X \leq x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Cochran_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Cochran_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pcochran</code> gives the distribution function and
<code>qcochran</code> gives the quantile function.
</p>


<h3>References</h3>

<p>Cochran, W.G. (1941) The distribution of the largest of a set of estimated
variances as a fraction of their total. <em>Ann. Eugen.</em> <b>11</b>, 47&ndash;52.
</p>
<p>Wilrich, P.-T. (2011) Critical values of Mandel's h and k,
Grubbs and the Cochran test statistic. <em>Adv. Stat. Anal.</em>.
<a href="https://doi.org/10.1007/s10182-011-0185-y">doi:10.1007/s10182-011-0185-y</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+FDist">FDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qcochran(0.05, 7, 3)
</code></pre>

<hr>
<h2 id='cochranTest'>Cochran Test</h2><span id='topic+cochranTest'></span><span id='topic+cochranTest.default'></span><span id='topic+cochranTest.formula'></span>

<h3>Description</h3>

<p>Performs Cochran's test for testing an outlying (or inlying)
variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cochranTest(x, ...)

## Default S3 method:
cochranTest(x, g, alternative = c("greater", "less"), ...)

## S3 method for class 'formula'
cochranTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cochranTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="cochranTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="cochranTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="cochranTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"greater"</code></p>
</td></tr>
<tr><td><code id="cochranTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="cochranTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="cochranTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="cochranTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For normally distributed data the null hypothesis,
H<code class="reqn">_0: \sigma_1^2 = \sigma_2^2 = \ldots = \sigma_k^2</code>
is tested against the alternative (greater)
H<code class="reqn">_{\mathrm{A}}: \sigma_p &gt; \sigma_i ~~ (i \le k, i \ne p)</code> with
at least one inequality being strict.
</p>
<p>The p-value is computed with the function <code><a href="#topic+pcochran">pcochran</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cochran, W.G. (1941) The distribution of the largest of a set of estimated
variances as a fraction of their total. <em>Ann. Eugen.</em> <b>11</b>, 47&ndash;52.
</p>
<p>Wilrich, P.-T. (2011) Critical values of Mandel's h and k,
Grubbs and the Cochran test statistic. <em>Adv. Stat. Anal.</em>.
<a href="https://doi.org/10.1007/s10182-011-0185-y">doi:10.1007/s10182-011-0185-y</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+bartlett.test">bartlett.test</a></code>, <code><a href="stats.html#topic+fligner.test">fligner.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pentosan)
cochranTest(value ~ lab, data = Pentosan, subset = (material == "A"))

</code></pre>

<hr>
<h2 id='cuzickTest'>Testing against Ordered Alternatives (Cuzick's Test)</h2><span id='topic+cuzickTest'></span><span id='topic+cuzickTest.default'></span><span id='topic+cuzickTest.formula'></span>

<h3>Description</h3>

<p>Performs Cuzick's test for testing against ordered alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cuzickTest(x, ...)

## Default S3 method:
cuzickTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  scores = NULL,
  continuity = FALSE,
  ...
)

## S3 method for class 'formula'
cuzickTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  scores = NULL,
  continuity = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cuzickTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_scores">scores</code></td>
<td>
<p>numeric vector of scores. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_continuity">continuity</code></td>
<td>
<p>logical indicator whether a continuity correction
shall be performed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="cuzickTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis, H<code class="reqn">_0: \theta_1 = \theta_2 = \ldots = \theta_k</code>
is tested against a simple order hypothesis,
H<code class="reqn">_\mathrm{A}: \theta_1 \le \theta_2 \le \ldots \le
\theta_k,~\theta_1 &lt; \theta_k</code>.
</p>
<p>The p-values are estimated from the standard normal distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Cuzick, J. (1995) A Wilcoxon-type test for trend, <em>Statistics in Medicine</em>
<b>4</b>, 87&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='Dgrubbs'>Grubbs D* distribution</h2><span id='topic+Dgrubbs'></span><span id='topic+pdgrubbs'></span>

<h3>Description</h3>

<p>Distribution function for Grubbs D* distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdgrubbs(q, n, m = 10000, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dgrubbs_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Dgrubbs_+3A_n">n</code></td>
<td>
<p>total sample size.</p>
</td></tr>
<tr><td><code id="Dgrubbs_+3A_m">m</code></td>
<td>
<p>number of Monte-Carlo replicates. Defaults to <code>10,000</code>.</p>
</td></tr>
<tr><td><code id="Dgrubbs_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default),
probabilities are <code class="reqn">P[X \leq x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Dgrubbs_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pgrubbs</code> gives the distribution function
</p>


<h3>References</h3>

<p>Grubbs, F.E. (1950) Sample criteria for testing outlying observations,
<em>Ann. Math. Stat.</em> <b>21</b>, 27&ndash;58.
</p>
<p>Wilrich, P.-T. (2011) Critical values of Mandel's h and k,
Grubbs and the Cochran test statistic, <em>Adv. Stat. Anal.</em>.
<a href="https://doi.org/10.1007/s10182-011-0185-y">doi:10.1007/s10182-011-0185-y</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Grubbs">Grubbs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdgrubbs(0.62, 7, 1E4)
</code></pre>

<hr>
<h2 id='doubleGrubbsTest'>Grubbs Double Outlier Test</h2><span id='topic+doubleGrubbsTest'></span>

<h3>Description</h3>

<p>Performs Grubbs double outlier test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleGrubbsTest(x, alternative = c("two.sided", "greater", "less"), m = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubleGrubbsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data.</p>
</td></tr>
<tr><td><code id="doubleGrubbsTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis.
Defaults to <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="doubleGrubbsTest_+3A_m">m</code></td>
<td>
<p>number of Monte-Carlo replicates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> denote an identically and independently distributed continuous
variate with realizations <code class="reqn">x_i ~~ (1 \le i \le k)</code>.
Further, let the increasingly ordered realizations
denote <code class="reqn">x_{(1)} \le x_{(2)} \le \ldots \le x_{(n)}</code>. Then
the following model for testing two maximum outliers can be proposed:
</p>
<p style="text-align: center;"><code class="reqn">
  x_{(i)} = \left\{
      \begin{array}{lcl}
       \mu + \epsilon_{(i)}, &amp; \qquad &amp; i = 1, \ldots, n - 2 \\
       \mu + \Delta + \epsilon_{(j)} &amp; \qquad &amp; j = n-1, n  \\
      \end{array} \right.</code>
</p>

<p>with <code class="reqn">\epsilon \approx N(0,\sigma)</code>. The null hypothesis,
H<code class="reqn">_0: \Delta = 0</code> is tested against the alternative,
H<code class="reqn">_{\mathrm{A}}: \Delta &gt; 0</code>.
</p>
<p>For testing two minimum outliers, the model can be proposed
as
</p>
<p style="text-align: center;"><code class="reqn">
  x_{(i)} = \left\{
      \begin{array}{lcl}
       \mu + \Delta + \epsilon_{(j)} &amp; \qquad &amp; j = 1, 2 \\
       \mu + \epsilon_{(i)}, &amp; \qquad &amp; i = 3, \ldots, n \\
      \end{array} \right.</code>
</p>

<p>The null hypothesis is tested against the alternative,
H<code class="reqn">_{\mathrm{A}}: \Delta &lt; 0</code>.
</p>
<p>The p-value is computed with the function <code><a href="#topic+pdgrubbs">pdgrubbs</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Grubbs, F. E. (1950) Sample criteria for testing outlying observations.
<em>Ann. Math. Stat.</em> <b>21</b>, 27&ndash;58.
</p>
<p>Wilrich, P.-T. (2011) Critical values of Mandel's h and k,
Grubbs and the Cochran test statistic. <em>Adv. Stat. Anal.</em>.
<a href="https://doi.org/10.1007/s10182-011-0185-y">doi:10.1007/s10182-011-0185-y</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pentosan)
dat &lt;- subset(Pentosan, subset = (material == "A"))
labMeans &lt;- tapply(dat$value, dat$lab, mean)
doubleGrubbsTest(x = labMeans, alternative = "less")
</code></pre>

<hr>
<h2 id='dscfAllPairsTest'>Multiple Comparisons of Mean Rank Sums</h2><span id='topic+dscfAllPairsTest'></span><span id='topic+dscfAllPairsTest.default'></span><span id='topic+dscfAllPairsTest.formula'></span>

<h3>Description</h3>

<p>Performs the all-pairs comparison test for different factor
levels according to Dwass, Steel, Critchlow and Fligner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dscfAllPairsTest(x, ...)

## Default S3 method:
dscfAllPairsTest(x, g, ...)

## S3 method for class 'formula'
dscfAllPairsTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dscfAllPairsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="dscfAllPairsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="dscfAllPairsTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="dscfAllPairsTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="dscfAllPairsTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="dscfAllPairsTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="dscfAllPairsTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with non-normally distributed residuals the DSCF
all-pairs comparison test can be used. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: F_i(x) = F_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: F_i(x) \ne F_j(x), ~~ i \ne j</code>.
As opposed to the all-pairs comparison procedures that depend
on Kruskal ranks, the DSCF test is basically an extension of
the U-test as re-ranking is conducted for each pairwise test.
</p>
<p>The p-values are estimated from the studentized range distriburtion.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Douglas, C. E., Fligner, A. M. (1991) On distribution-free multiple
comparisons in the one-way analysis of variance, <em>Communications in
Statistics - Theory and Methods</em> <b>20</b>, 127&ndash;139.
</p>
<p>Dwass, M. (1960) Some k-sample rank-order tests. In <em>Contributions to
Probability and Statistics</em>, Edited by: I. Olkin,
Stanford: Stanford University Press.
</p>
<p>Steel, R. G. D. (1960) A rank sum test for comparing all pairs of
treatments, <em>Technometrics</em> <b>2</b>, 197&ndash;207
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Tukey">Tukey</a></code>, <code><a href="stats.html#topic+pairwise.wilcox.test">pairwise.wilcox.test</a></code>
</p>

<hr>
<h2 id='duncanTest'>Duncan's Multiple Range Test</h2><span id='topic+duncanTest'></span><span id='topic+duncanTest.default'></span><span id='topic+duncanTest.formula'></span><span id='topic+duncanTest.aov'></span>

<h3>Description</h3>

<p>Performs Duncan's all-pairs comparisons test for normally distributed
data with equal group variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duncanTest(x, ...)

## Default S3 method:
duncanTest(x, g, ...)

## S3 method for class 'formula'
duncanTest(formula, data, subset, na.action, ...)

## S3 method for class 'aov'
duncanTest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duncanTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="duncanTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="duncanTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="duncanTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="duncanTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="duncanTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="duncanTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals and equal variances
Duncan's multiple range test can be performed.
Let <code class="reqn">X_{ij}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization (<code class="reqn">1 \le j \le n_i</code>)
in the <code class="reqn">i</code>-th group (<code class="reqn">1 \le i \le k</code>). Furthermore, the total
sample size is <code class="reqn">N = \sum_{i=1}^k n_i</code>. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{ij}: \mu_i = \mu_j ~~ (i \ne j)</code> is tested against the alternative
A<code class="reqn">_{ij}: \mu_i \ne \mu_j</code> (two-tailed). Duncan's all-pairs test
statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{(i)(j)} \frac{\bar{X}_{(i)} - \bar{X}_{(j)}}
 {s_{\mathrm{in}} \left(r\right)^{1/2}}, ~~
 (i &lt; j)
</code>
</p>

<p>with <code class="reqn">s^2_{\mathrm{in}}</code> the within-group ANOVA variance,
<code class="reqn">r = k / \sum_{i=1}^k n_i</code> and <code class="reqn">\bar{X}_{(i)}</code> the increasingly
ordered means <code class="reqn">1 \le i \le k</code>.
The null hypothesis is rejected if
</p>
<p style="text-align: center;"><code class="reqn">
 \mathrm{Pr} \left\{ |t_{(i)(j)}| \ge q_{vm'\alpha'} | \mathrm{H} \right\}_{(i)(j)} = \alpha' =
 \min \left\{1,~ 1 - (1 - \alpha)^{(1 / (m' - 1))} \right\},
</code>
</p>

<p>with <code class="reqn">v = N - k</code> degree of freedom, the range
<code class="reqn">m' = 1 + |i - j|</code> and <code class="reqn">\alpha'</code> the Bonferroni adjusted
alpha-error. The p-values are computed
from the <code><a href="stats.html#topic+Tukey">Tukey</a></code> distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Duncan, D. B. (1955) Multiple range and multiple F tests,
<em>Biometrics</em> <b>11</b>, 1&ndash;42.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Tukey">Tukey</a></code>, <code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code> <code><a href="#topic+tukeyTest">tukeyTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts)
anova(fit)

## also works with fitted objects of class aov
res &lt;- duncanTest(fit)
summary(res)
summaryGroup(res)
</code></pre>

<hr>
<h2 id='dunnettT3Test'>Dunnett's T3 Test</h2><span id='topic+dunnettT3Test'></span><span id='topic+dunnettT3Test.default'></span><span id='topic+dunnettT3Test.formula'></span><span id='topic+dunnettT3Test.aov'></span>

<h3>Description</h3>

<p>Performs Dunnett's all-pairs comparison test for normally distributed
data with unequal variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dunnettT3Test(x, ...)

## Default S3 method:
dunnettT3Test(x, g, ...)

## S3 method for class 'formula'
dunnettT3Test(formula, data, subset, na.action, ...)

## S3 method for class 'aov'
dunnettT3Test(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dunnettT3Test_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="dunnettT3Test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="dunnettT3Test_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="dunnettT3Test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="dunnettT3Test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="dunnettT3Test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="dunnettT3Test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals but unequal groups variances
the T3 test of Dunnett can be performed.
Let <code class="reqn">X_{ij}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization (<code class="reqn">1 \le j \le n_i</code>)
in the <code class="reqn">i</code>-th group (<code class="reqn">1 \le i \le k</code>). Furthermore, the total
sample size is <code class="reqn">N = \sum_{i=1}^k n_i</code>. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{ij}: \mu_i = \mu_j ~~ (i \ne j)</code> is tested against the alternative
A<code class="reqn">_{ij}: \mu_i \ne \mu_j</code> (two-tailed). Dunnett T3 all-pairs
test statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{ij} \frac{\bar{X}_i - \bar{X_j}}
 {\left( s^2_j / n_j + s^2_i / n_i \right)^{1/2}}, ~~
 (i \ne j)
</code>
</p>

<p>with <code class="reqn">s^2_i</code> the variance of the <code class="reqn">i</code>-th group.
The null hypothesis is rejected (two-tailed) if
</p>
<p style="text-align: center;"><code class="reqn">
 \mathrm{Pr} \left\{ |t_{ij}| \ge T_{v_{ij}\rho_{ij}\alpha'/2} | \mathrm{H} \right\}_{ij} =
 \alpha,
</code>
</p>

<p>with Welch's approximate solution for calculating the degree of freedom.
</p>
<p style="text-align: center;"><code class="reqn">
 v_{ij} = \frac{\left( s^2_i / n_i + s^2_j / n_j \right)^2}
 {s^4_i / n^2_i \left(n_i - 1\right) + s^4_j / n^2_j \left(n_j - 1\right)}.
</code>
</p>

<p>The <code class="reqn">p</code>-values are computed from the
studentized maximum modulus distribution
that is the equivalent of the multivariate t distribution
with <code class="reqn">\rho_{ii} = 1, ~ \rho_{ij} = 0 ~ (i \ne j)</code>.
The function <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code> is used to
calculate the <code class="reqn">p</code>-values.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>C. W. Dunnett (1980) Pair wise multiple comparisons in the unequal
variance case, <em>Journal of the American Statistical
Association</em> <b>75</b>, 796&ndash;800.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts)
anova(fit)

## also works with fitted objects of class aov
res &lt;- dunnettT3Test(fit)
summary(res)
summaryGroup(res)

</code></pre>

<hr>
<h2 id='dunnettTest'>Dunnett's Many-to-One Comparisons Test</h2><span id='topic+dunnettTest'></span><span id='topic+dunnettTest.default'></span><span id='topic+dunnettTest.formula'></span><span id='topic+dunnettTest.aov'></span>

<h3>Description</h3>

<p>Performs Dunnett's multiple comparisons test with one control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dunnettTest(x, ...)

## Default S3 method:
dunnettTest(x, g, alternative = c("two.sided", "greater", "less"), ...)

## S3 method for class 'formula'
dunnettTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  ...
)

## S3 method for class 'aov'
dunnettTest(x, alternative = c("two.sided", "greater", "less"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dunnettTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="dunnettTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="dunnettTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="dunnettTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="dunnettTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="dunnettTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="dunnettTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="dunnettTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons in an one-factorial layout
with normally distributed residuals Dunnett's test
can be used.
Let <code class="reqn">X_{0j}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization of the control group
(<code class="reqn">1 \le j \le n_0</code>) and <code class="reqn">X_{ij}</code> the <code class="reqn">j</code>-the realization
in the <code class="reqn">i</code>-th treatment group (<code class="reqn">1 \le i \le k</code>).
Furthermore, the total sample size is <code class="reqn">N = n_0 + \sum_{i=1}^k n_i</code>.
A total of <code class="reqn">m = k</code> hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{i}: \mu_i = \mu_0</code> is tested against the alternative
A<code class="reqn">_{i}: \mu_i \ne \mu_0</code> (two-tailed). Dunnett's test
statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{i} \frac{\bar{X}_i - \bar{X_0}}
 {s_{\mathrm{in}} \left(1/n_0 + 1/n_i\right)^{1/2}}, ~~
 (1 \le i \le k)
</code>
</p>

<p>with <code class="reqn">s^2_{\mathrm{in}}</code> the within-group ANOVA variance.
The null hypothesis is rejected if
<code class="reqn">|t_{ij}| &gt; |T_{kv\rho\alpha}|</code> (two-tailed),
with <code class="reqn">v = N - k</code> degree of freedom and <code class="reqn">rho</code> the correlation:
</p>
<p style="text-align: center;"><code class="reqn">
 \rho_{ij} = \sqrt{\frac{n_i n_j}
             {\left(n_i + n_0\right) \left(n_j+ n_0\right)}} ~~
             (i \ne j)
.</code>
</p>

<p>The p-values are computed with the function <code><a href="#topic+pDunnett">pDunnett</a></code>
that is a wrapper to the the multivariate-t distribution as implemented in the function
<code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Dunnett, C. W. (1955) A multiple comparison procedure for comparing several
treatments with a control. <em>Journal of the American Statistical Association</em>
<b>50</b>, 1096–1121.
</p>
<p>OECD (ed. 2006) <em>Current approaches in the statistical analysis
of ecotoxicity data: A guidance to application - Annexes</em>. OECD Series
on testing and assessment, No. 54.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code> <code><a href="#topic+pDunnett">pDunnett</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(Y ~ DOSE, data = trout)
shapiro.test(residuals(fit))
bartlett.test(Y ~ DOSE, data = trout)

## works with fitted object of class aov
summary(dunnettTest(fit, alternative = "less"))

</code></pre>

<hr>
<h2 id='durbinAllPairsTest'>All-Pairs Comparisons Test for Balanced Incomplete Block Designs</h2><span id='topic+durbinAllPairsTest'></span><span id='topic+durbinAllPairsTest.default'></span>

<h3>Description</h3>

<p>Performs Conover-Iman all-pairs comparison test for a balanced incomplete
block design (BIBD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>durbinAllPairsTest(y, ...)

## Default S3 method:
durbinAllPairsTest(y, groups, blocks, p.adjust.method = p.adjust.methods, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="durbinAllPairsTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="durbinAllPairsTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="durbinAllPairsTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="durbinAllPairsTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>)</p>
</td></tr>
<tr><td><code id="durbinAllPairsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in a balanced incomplete block design
the proposed test of Conover and Imam can be applied.
A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: \theta_i = \theta_j</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: \theta_i \ne \theta_j, ~~ i \ne j</code>.
</p>
<p>The p-values are computed from the t distribution. If no p-value adjustment
is performed (<code>p.adjust.method = "none"</code>),
than a simple protected test is recommended, i.e.
the all-pairs comparisons should only be applied after a significant
<code><a href="#topic+durbinTest">durbinTest</a></code>. However, any method as implemented in
<code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code> can be selected by the user.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Conover, W. J., Iman, R. L. (1979) <em>On multiple-comparisons
procedures</em>, Tech. Rep. LA-7677-MS, Los Alamos Scientific Laboratory.
</p>
<p>Conover, W. J. (1999) <em>Practical nonparametric Statistics</em>,
3rd. Edition, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+durbinTest">durbinTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for an incomplete block design:
## Data from Conover (1999, p. 391).
y &lt;- matrix(c(2,NA,NA,NA,3, NA,  3,  3,  3, NA, NA, NA,  3, NA, NA,
  1,  2, NA, NA, NA,  1,  1, NA,  1,  1,
NA, NA, NA, NA,  2, NA,  2,  1, NA, NA, NA, NA,
 3, NA,  2,  1, NA, NA, NA, NA,  3, NA,  2,  2),
ncol=7, nrow=7, byrow=FALSE, dimnames=list(1:7, LETTERS[1:7]))
durbinAllPairsTest(y)
</code></pre>

<hr>
<h2 id='durbinTest'>Durbin Test</h2><span id='topic+durbinTest'></span><span id='topic+durbinTest.default'></span>

<h3>Description</h3>

<p>Performs Durbin's tests whether k groups
(or treatments) in a two-way balanced incomplete block design (BIBD)
have identical effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>durbinTest(y, ...)

## Default S3 method:
durbinTest(y, groups, blocks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="durbinTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="durbinTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="durbinTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="durbinTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For testing a two factorial layout of a balanced incomplete
block design whether the <code class="reqn">k</code> groups have identical effects,
the Durbin test can be performed. The null hypothesis,
H<code class="reqn">_0: \theta_i = \theta_j ~ (1 \le i &lt; j \le k)</code>,
is tested against the alternative that at least
one <code class="reqn">\theta_i \ne \theta_j</code>.
</p>
<p>The p-values are computed from the chi-square distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function does not test, whether it is a true BIBD.
This function does not test for ties.
</p>


<h3>References</h3>

<p>Conover,W. J. (1999) <em>Practical nonparametric Statistics</em>,
3rd. Edition, Wiley.
</p>
<p>Heckert, N. A., Filliben, J. J. (2003) <em>NIST Handbook 148:
Dataplot Reference Manual</em>, Volume 2:
Let Subcommands and Library Functions.
National Institute of Standards and Technology Handbook Series, June 2003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for an incomplete block design:
## Data from Conover (1999, p. 391).
y &lt;- matrix(c(
2,NA,NA,NA,3, NA,  3,  3,  3, NA, NA, NA,  3, NA, NA,
  1,  2, NA, NA, NA,  1,  1, NA,  1,  1,
NA, NA, NA, NA,  2, NA,  2,  1, NA, NA, NA, NA,
 3, NA,  2,  1, NA, NA, NA, NA,  3, NA,  2,  2
), ncol=7, nrow=7, byrow=FALSE,
dimnames=list(1:7, LETTERS[1:7]))
durbinTest(y)
</code></pre>

<hr>
<h2 id='flignerWolfeTest'>Testing Several Treatments With One Control</h2><span id='topic+flignerWolfeTest'></span><span id='topic+flignerWolfeTest.default'></span><span id='topic+flignerWolfeTest.formula'></span>

<h3>Description</h3>

<p>Performs Fligner-Wolfe non-parametric test for
simultaneous testing of several locations of treatment groups
against the location of the control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flignerWolfeTest(x, ...)

## Default S3 method:
flignerWolfeTest(
  x,
  g,
  alternative = c("greater", "less"),
  dist = c("Wilcoxon", "Normal"),
  ...
)

## S3 method for class 'formula'
flignerWolfeTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  dist = c("Wilcoxon", "Normal"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flignerWolfeTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="flignerWolfeTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="flignerWolfeTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="flignerWolfeTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="flignerWolfeTest_+3A_dist">dist</code></td>
<td>
<p>the test distribution. Defaults to <code>"Wilcoxon"</code>.</p>
</td></tr>
<tr><td><code id="flignerWolfeTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="flignerWolfeTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="flignerWolfeTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="flignerWolfeTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a one-factorial layout with non-normally distributed residuals
the Fligner-Wolfe test can be used.
</p>
<p>Let there be <code class="reqn">k-1</code>-treatment groups and one control group, then
the null hypothesis, H<code class="reqn">_0: \theta_i - \theta_c = 0 ~ (1 \le i \le k-1)</code>
is tested against the alternative (greater),
A<code class="reqn">_1: \theta_i - \theta_c &gt; 0 ~ (1 \le i \le k-1)</code>,
with at least one inequality being strict.
</p>
<p>Let <code class="reqn">n_c</code> denote the sample size of the control group,
<code class="reqn">N^t = \sum_{i=1}^{k-1} n_i</code> the sum of all treatment
sample sizes and <code class="reqn">N = N^t + n_c</code>. The test statistic without taken
ties into account is
</p>
<p style="text-align: center;"><code class="reqn">
 W = \sum_{j=1}^{k-1} \sum_{i=1}^{n_i} r_{ij} -
 \frac{N^t \left(N^t + 1 \right) }{2}
</code>
</p>

<p>with <code class="reqn">r_{ij}</code> the rank of variable <code class="reqn">x_{ij}</code>.
The null hypothesis is rejected,
if <code class="reqn">W &gt; W_{\alpha,m,n}</code> with
<code class="reqn">m = N^t</code> and <code class="reqn">n = n_c</code>.
</p>
<p>In the presence of ties, the statistic is
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{z} = \frac{W - n_c N^t / 2}{s_W},
 </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn"> s_W =
  \frac{n_c N^t}{12 N \left(N - 1 \right)}
  \sum_{j=1}^g t_j \left(t_j^2 - 1\right),
</code>
</p>

<p>with <code class="reqn">g</code> the number of tied groups and <code class="reqn">t_j</code>
the number of tied values in the <code class="reqn">j</code>th group. The null hypothesis
is rejected, if <code class="reqn">\hat{z} &gt; z_\alpha</code> (as cited in EPA 2006).
</p>
<p>If <code>dist = Wilcoxon</code>, then the <code class="reqn">p</code>-values are estimated from the  <code><a href="stats.html#topic+Wilcoxon">Wilcoxon</a></code>
distribution, else the <code><a href="stats.html#topic+Normal">Normal</a></code> distribution is used. The latter can be used,
if ties are present.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>EPA (2006) <em>Data Quality Assessment:
Statistical Methods for Practitioners</em>
(Guideline No. EPA QA/G-9S), US-EPA.
</p>
<p>Fligner, M.A., Wolfe, D.A. (1982)
Distribution-free tests for comparing several
treatments with a control. <em>Stat Neerl</em> <b>36</b>,
119&ndash;127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='frdAllPairsConoverTest'>Conover's All-Pairs Comparisons Test for Unreplicated Blocked Data</h2><span id='topic+frdAllPairsConoverTest'></span><span id='topic+frdAllPairsConoverTest.default'></span>

<h3>Description</h3>

<p>Performs Conover's all-pairs comparisons tests of Friedman-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdAllPairsConoverTest(y, ...)

## Default S3 method:
frdAllPairsConoverTest(
  y,
  groups,
  blocks,
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdAllPairsConoverTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdAllPairsConoverTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsConoverTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsConoverTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="frdAllPairsConoverTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in a two factorial unreplicated
complete block design
with non-normally distributed residuals, Conover's test can be
performed on Friedman-type ranked data.
</p>
<p>A total of <code class="reqn">m = k ( k -1 )/2</code> hypotheses can be tested.
The null hypothesis, H<code class="reqn">_{ij}: \theta_i = \theta_j</code>, is tested
in the two-tailed case against the alternative,
A<code class="reqn">_{ij}: \theta_i \ne \theta_j, ~~ i \ne j</code>.
</p>
<p>If <code>p.adjust.method == "single-step"</code> the p-values are computed
from the studentized range distribution. Otherwise,
the p-values are computed from the t-distribution using
any of the p-adjustment methods as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Conover, W. J., Iman, R. L. (1979) <em>On multiple-comparisons
procedures</em>, Tech. Rep. LA-7677-MS, Los Alamos Scientific Laboratory.
</p>
<p>Conover, W. J. (1999) <em>Practical nonparametric Statistics</em>,
3rd. Edition, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdAllPairsExactTest">frdAllPairsExactTest</a></code>, <code><a href="#topic+frdAllPairsMillerTest">frdAllPairsMillerTest</a></code>,
<code><a href="#topic+frdAllPairsNemenyiTest">frdAllPairsNemenyiTest</a></code>, <code><a href="#topic+frdAllPairsSiegelTest">frdAllPairsSiegelTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ##
 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))
 print(y)
 friedmanTest(y)

 ## Eisinga et al. 2017
 frdAllPairsExactTest(y=y, p.adjust = "bonferroni")

 ## Conover's test
 frdAllPairsConoverTest(y=y, p.adjust = "bonferroni")

 ## Nemenyi's test
 frdAllPairsNemenyiTest(y=y)

 ## Miller et al.
 frdAllPairsMillerTest(y=y)

 ## Siegel-Castellan
 frdAllPairsSiegelTest(y=y, p.adjust = "bonferroni")

 ## Irrelevant of group order?
 x &lt;- as.vector(y)
 g &lt;- rep(colnames(y), each = length(x)/length(colnames(y)))
 b &lt;- rep(rownames(y), times = length(x)/length(rownames(y)))
 xDF &lt;- data.frame(x, g, b) # grouped by colnames

 frdAllPairsNemenyiTest(xDF$x, groups = xDF$g, blocks = xDF$b)
 o &lt;- order(xDF$b) # order per block increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])
 o &lt;- order(xDF$x) # order per value increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])

 ## formula method (only works for Nemenyi)
 frdAllPairsNemenyiTest(x ~ g | b, data = xDF)

</code></pre>

<hr>
<h2 id='frdAllPairsExactTest'>Exact All-Pairs Comparisons Test for Unreplicated Blocked Data</h2><span id='topic+frdAllPairsExactTest'></span><span id='topic+frdAllPairsExactTest.default'></span>

<h3>Description</h3>

<p>Performs exact all-pairs comparisons tests of Friedman-type ranked data
according to Eisinga et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdAllPairsExactTest(y, ...)

## Default S3 method:
frdAllPairsExactTest(
  y,
  groups,
  blocks,
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdAllPairsExactTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdAllPairsExactTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsExactTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsExactTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="frdAllPairsExactTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in a two factorial unreplicated
complete block design
with non-normally distributed residuals, an exact test can be
performed on Friedman-type ranked data.
</p>
<p>A total of <code class="reqn">m = k ( k -1 )/2</code> hypotheses can be tested.
The null hypothesis, H<code class="reqn">_{ij}: \theta_i = \theta_j</code>, is tested
in the two-tailed case against the alternative,
A<code class="reqn">_{ij}: \theta_i \ne \theta_j, ~~ i \ne j</code>.
</p>
<p>The exact <code class="reqn">p</code>-values
are computed using the code of <code>"pexactfrsd.R"</code>
that was a supplement to the publication of Eisinga et al. (2017).
Additionally, any of the <code class="reqn">p</code>-adjustment methods
as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> can be selected, for <code class="reqn">p</code>-value
adjustment.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The function <code>frdAllPairsExactTest</code> uses the code
of the file <code>pexactfrsd.R</code> that was a supplement to:<br />
</p>
<p>R. Eisinga, T. Heskes, B. Pelzer, M. Te Grotenhuis (2017),
Exact p-values for Pairwise Comparison of Friedman Rank Sums,
with Application to Comparing Classifiers, <em>BMC Bioinformatics</em>, 18:68.
</p>


<h3>References</h3>

<p>Eisinga, R., Heskes, T., Pelzer, B., Te Grotenhuis, M. (2017)
Exact p-values for Pairwise Comparison of Friedman Rank Sums,
with Application to Comparing Classifiers, <em>BMC Bioinformatics</em>, 18:68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdAllPairsConoverTest">frdAllPairsConoverTest</a></code>, <code><a href="#topic+frdAllPairsMillerTest">frdAllPairsMillerTest</a></code>,
<code><a href="#topic+frdAllPairsNemenyiTest">frdAllPairsNemenyiTest</a></code>, <code><a href="#topic+frdAllPairsSiegelTest">frdAllPairsSiegelTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ##
 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))
 print(y)
 friedmanTest(y)

 ## Eisinga et al. 2017
 frdAllPairsExactTest(y=y, p.adjust = "bonferroni")

 ## Conover's test
 frdAllPairsConoverTest(y=y, p.adjust = "bonferroni")

 ## Nemenyi's test
 frdAllPairsNemenyiTest(y=y)

 ## Miller et al.
 frdAllPairsMillerTest(y=y)

 ## Siegel-Castellan
 frdAllPairsSiegelTest(y=y, p.adjust = "bonferroni")

 ## Irrelevant of group order?
 x &lt;- as.vector(y)
 g &lt;- rep(colnames(y), each = length(x)/length(colnames(y)))
 b &lt;- rep(rownames(y), times = length(x)/length(rownames(y)))
 xDF &lt;- data.frame(x, g, b) # grouped by colnames

 frdAllPairsNemenyiTest(xDF$x, groups = xDF$g, blocks = xDF$b)
 o &lt;- order(xDF$b) # order per block increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])
 o &lt;- order(xDF$x) # order per value increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])

 ## formula method (only works for Nemenyi)
 frdAllPairsNemenyiTest(x ~ g | b, data = xDF)

</code></pre>

<hr>
<h2 id='frdAllPairsMillerTest'>Millers's All-Pairs Comparisons Test for Unreplicated Blocked Data</h2><span id='topic+frdAllPairsMillerTest'></span><span id='topic+frdAllPairsMillerTest.default'></span>

<h3>Description</h3>

<p>Performs Miller's all-pairs comparisons tests of Friedman-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdAllPairsMillerTest(y, ...)

## Default S3 method:
frdAllPairsMillerTest(y, groups, blocks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdAllPairsMillerTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdAllPairsMillerTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsMillerTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsMillerTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in a two factorial unreplicated
complete block design
with non-normally distributed residuals, Miller's test can be
performed on Friedman-type ranked data.
</p>
<p>A total of <code class="reqn">m = k ( k -1 )/2</code> hypotheses can be tested.
The null hypothesis, H<code class="reqn">_{ij}: \theta_i = \theta_j</code>, is tested
in the two-tailed case against the alternative,
A<code class="reqn">_{ij}: \theta_i \ne \theta_j, ~~ i \ne j</code>.
</p>
<p>The <code class="reqn">p</code>-values are computed from the chi-square distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Bortz J., Lienert, G. A., Boehnke, K. (1990) <em>Verteilungsfreie
Methoden in der Biostatistik</em>. Berlin: Springer.
</p>
<p>Miller Jr., R. G. (1996) <em>Simultaneous statistical inference</em>.
New York: McGraw-Hill.
</p>
<p>Wike, E. L. (2006), <em>Data Analysis. A Statistical Primer for
Psychology Students</em>. New Brunswick: Aldine Transaction.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdAllPairsExactTest">frdAllPairsExactTest</a></code>, <code><a href="#topic+frdAllPairsConoverTest">frdAllPairsConoverTest</a></code>,
<code><a href="#topic+frdAllPairsNemenyiTest">frdAllPairsNemenyiTest</a></code>, <code><a href="#topic+frdAllPairsSiegelTest">frdAllPairsSiegelTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ##
 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))
 print(y)
 friedmanTest(y)

 ## Eisinga et al. 2017
 frdAllPairsExactTest(y=y, p.adjust = "bonferroni")

 ## Conover's test
 frdAllPairsConoverTest(y=y, p.adjust = "bonferroni")

 ## Nemenyi's test
 frdAllPairsNemenyiTest(y=y)

 ## Miller et al.
 frdAllPairsMillerTest(y=y)

 ## Siegel-Castellan
 frdAllPairsSiegelTest(y=y, p.adjust = "bonferroni")

 ## Irrelevant of group order?
 x &lt;- as.vector(y)
 g &lt;- rep(colnames(y), each = length(x)/length(colnames(y)))
 b &lt;- rep(rownames(y), times = length(x)/length(rownames(y)))
 xDF &lt;- data.frame(x, g, b) # grouped by colnames

 frdAllPairsNemenyiTest(xDF$x, groups = xDF$g, blocks = xDF$b)
 o &lt;- order(xDF$b) # order per block increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])
 o &lt;- order(xDF$x) # order per value increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])

 ## formula method (only works for Nemenyi)
 frdAllPairsNemenyiTest(x ~ g | b, data = xDF)

</code></pre>

<hr>
<h2 id='frdAllPairsNemenyiTest'>Nemenyi's All-Pairs Comparisons Test for Unreplicated Blocked Data</h2><span id='topic+frdAllPairsNemenyiTest'></span><span id='topic+frdAllPairsNemenyiTest.default'></span><span id='topic+frdAllPairsNemenyiTest.formula'></span>

<h3>Description</h3>

<p>Performs Nemenyi's all-pairs comparisons tests of Friedman-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdAllPairsNemenyiTest(y, ...)

## Default S3 method:
frdAllPairsNemenyiTest(y, groups, blocks, ...)

## S3 method for class 'formula'
frdAllPairsNemenyiTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdAllPairsNemenyiTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdAllPairsNemenyiTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsNemenyiTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsNemenyiTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>a ~ b | c</code> where
<code>a, b</code> and <code>c</code> give the data values and
the corresponding groups and blocks, respectively.</p>
</td></tr>
<tr><td><code id="frdAllPairsNemenyiTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="frdAllPairsNemenyiTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="frdAllPairsNemenyiTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="frdAllPairsNemenyiTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in a two factorial unreplicated
complete block design
with non-normally distributed residuals, Nemenyi's test can be
performed on Friedman-type ranked data.
</p>
<p>A total of <code class="reqn">m = k ( k -1 )/2</code> hypotheses can be tested.
The null hypothesis, H<code class="reqn">_{ij}: \theta_i = \theta_j</code>, is tested
in the two-tailed case against the alternative,
A<code class="reqn">_{ij}: \theta_i \ne \theta_j, ~~ i \ne j</code>.
</p>
<p>The <code class="reqn">p</code>-values are computed from the studentized range distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Demsar, J. (2006) Statistical comparisons of classifiers over multiple
data sets, <em>Journal of Machine Learning Research</em> <b>7</b>, 1&ndash;30.
</p>
<p>Miller Jr., R. G. (1996) <em>Simultaneous statistical inference</em>.
New York: McGraw-Hill.
</p>
<p>Nemenyi, P. (1963), <em>Distribution-free Multiple Comparisons</em>.
Ph.D. thesis, Princeton University.
</p>
<p>Sachs, L. (1997) <em>Angewandte Statistik</em>. Berlin: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdAllPairsExactTest">frdAllPairsExactTest</a></code>, <code><a href="#topic+frdAllPairsConoverTest">frdAllPairsConoverTest</a></code>,
<code><a href="#topic+frdAllPairsMillerTest">frdAllPairsMillerTest</a></code>, <code><a href="#topic+frdAllPairsSiegelTest">frdAllPairsSiegelTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ##
 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))
 print(y)
 friedmanTest(y)

 ## Eisinga et al. 2017
 frdAllPairsExactTest(y=y, p.adjust = "bonferroni")

 ## Conover's test
 frdAllPairsConoverTest(y=y, p.adjust = "bonferroni")

 ## Nemenyi's test
 frdAllPairsNemenyiTest(y=y)

 ## Miller et al.
 frdAllPairsMillerTest(y=y)

 ## Siegel-Castellan
 frdAllPairsSiegelTest(y=y, p.adjust = "bonferroni")

 ## Irrelevant of group order?
 x &lt;- as.vector(y)
 g &lt;- rep(colnames(y), each = length(x)/length(colnames(y)))
 b &lt;- rep(rownames(y), times = length(x)/length(rownames(y)))
 xDF &lt;- data.frame(x, g, b) # grouped by colnames

 frdAllPairsNemenyiTest(xDF$x, groups = xDF$g, blocks = xDF$b)
 o &lt;- order(xDF$b) # order per block increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])
 o &lt;- order(xDF$x) # order per value increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])

 ## formula method (only works for Nemenyi)
 frdAllPairsNemenyiTest(x ~ g | b, data = xDF)

</code></pre>

<hr>
<h2 id='frdAllPairsSiegelTest'>Siegel and Castellan's All-Pairs Comparisons Test for
Unreplicated Blocked Data</h2><span id='topic+frdAllPairsSiegelTest'></span><span id='topic+frdAllPairsSiegelTest.default'></span>

<h3>Description</h3>

<p>Performs Siegel and Castellan's all-pairs comparisons tests
of Friedman-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdAllPairsSiegelTest(y, ...)

## Default S3 method:
frdAllPairsSiegelTest(
  y,
  groups,
  blocks,
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdAllPairsSiegelTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdAllPairsSiegelTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsSiegelTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdAllPairsSiegelTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="frdAllPairsSiegelTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in a two factorial unreplicated
complete block design
with non-normally distributed residuals, Siegel and Castellan's test can be
performed on Friedman-type ranked data.
</p>
<p>A total of <code class="reqn">m = k ( k -1 )/2</code> hypotheses can be tested.
The null hypothesis, H<code class="reqn">_{ij}: \theta_i = \theta_j</code>, is tested
in the two-tailed case against the alternative,
A<code class="reqn">_{ij}: \theta_i \ne \theta_j, ~~ i \ne j</code>.
</p>
<p>The <code class="reqn">p</code>-values are computed from the standard normal distribution.
Any method as implemented in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> can be used for
<code>p</code>-value adjustment.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Siegel, S., Castellan Jr., N. J. (1988) <em>Nonparametric
Statistics for the Behavioral Sciences</em>. 2nd ed. New York: McGraw-Hill.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdAllPairsExactTest">frdAllPairsExactTest</a></code>, <code><a href="#topic+frdAllPairsConoverTest">frdAllPairsConoverTest</a></code>,
<code><a href="#topic+frdAllPairsNemenyiTest">frdAllPairsNemenyiTest</a></code>, <code><a href="#topic+frdAllPairsMillerTest">frdAllPairsMillerTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ##
 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))
 print(y)
 friedmanTest(y)

 ## Eisinga et al. 2017
 frdAllPairsExactTest(y=y, p.adjust = "bonferroni")

 ## Conover's test
 frdAllPairsConoverTest(y=y, p.adjust = "bonferroni")

 ## Nemenyi's test
 frdAllPairsNemenyiTest(y=y)

 ## Miller et al.
 frdAllPairsMillerTest(y=y)

 ## Siegel-Castellan
 frdAllPairsSiegelTest(y=y, p.adjust = "bonferroni")

 ## Irrelevant of group order?
 x &lt;- as.vector(y)
 g &lt;- rep(colnames(y), each = length(x)/length(colnames(y)))
 b &lt;- rep(rownames(y), times = length(x)/length(rownames(y)))
 xDF &lt;- data.frame(x, g, b) # grouped by colnames

 frdAllPairsNemenyiTest(xDF$x, groups = xDF$g, blocks = xDF$b)
 o &lt;- order(xDF$b) # order per block increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])
 o &lt;- order(xDF$x) # order per value increasingly
 frdAllPairsNemenyiTest(xDF$x[o], groups = xDF$g[o], blocks = xDF$b[o])

 ## formula method (only works for Nemenyi)
 frdAllPairsNemenyiTest(x ~ g | b, data = xDF)

</code></pre>

<hr>
<h2 id='frdHouseTest'>House Test</h2><span id='topic+frdHouseTest'></span><span id='topic+frdHouseTest.default'></span>

<h3>Description</h3>

<p>Performs House nonparametric equivalent of William's test
for contrasting increasing dose levels of a treatment in
a complete randomized block design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdHouseTest(y, ...)

## Default S3 method:
frdHouseTest(y, groups, blocks, alternative = c("greater", "less"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdHouseTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdHouseTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdHouseTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdHouseTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="frdHouseTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>House test is a non-parametric step-down trend test for testing several treatment levels
with a zero control. Let there be <code class="reqn">k</code> groups including the control and let
the zero dose level be indicated with <code class="reqn">i = 0</code> and the highest
dose level with <code class="reqn">i = m</code>, then the following <code>m = k - 1</code> hypotheses are tested:
</p>
<p style="text-align: center;"><code class="reqn">
\begin{array}{ll}
\mathrm{H}_{m}: \theta_0 = \theta_1 = \ldots = \theta_m, &amp; \mathrm{A}_{m} = \theta_0 \le \theta_1 \le \ldots \theta_m, \theta_0 &lt; \theta_m \\
\mathrm{H}_{m-1}: \theta_0 = \theta_1 = \ldots = \theta_{m-1}, &amp; \mathrm{A}_{m-1} = \theta_0 \le \theta_1 \le \ldots \theta_{m-1}, \theta_0 &lt; \theta_{m-1} \\
\vdots &amp; \vdots \\
\mathrm{H}_{1}: \theta_0 = \theta_1, &amp; \mathrm{A}_{1} = \theta_0 &lt; \theta_1\\
\end{array}
</code>
</p>

<p>Let <code class="reqn">Y_{ij} ~ (1 \leq i \leq n, 0 \leq j \leq k)</code> be a i.i.d. random variable
of at least ordinal scale. Further, let <code class="reqn">\bar{R}_0,~\bar{R}_1, \ldots,~\bar{R}_k</code>
be Friedman's average ranks and set <code class="reqn">\bar{R}_0^*, \leq \ldots \leq \bar{R}_k^*</code>
to be its isotonic regression estimators under the order restriction
<code class="reqn">\theta_0 \leq \ldots \leq \theta_k</code>.
</p>
<p>The statistics is
</p>
<p style="text-align: center;"><code class="reqn">
T_j = \left(\bar{R}_j^* - \bar{R}_0 \right)~ \left[ \left(V_j - H_j \right)
\left(2 / n \right) \right]^{-1/2} \qquad (1 \leq j \leq k),
</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">
V_j = \left(j + 1\right) ~ \left(j + 2 \right) / 12
</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
H_j = \left(t^3 - t \right) / \left(12 j n \right),
</code>
</p>

<p>where <code class="reqn">t</code> is the number of tied ranks.
</p>
<p>The critical <code class="reqn">t'_{i,v,\alpha}</code>-values
as given in the tables of Williams (1972) for <code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the degree of freedoms (<code class="reqn">v = \infty</code>) and the order number of the
dose level (<code class="reqn">j</code>).
</p>
<p>For the comparison of the first dose level <code class="reqn">(j = 1)</code> with the control, the critical
z-value from the standard normal distribution is used (<code><a href="stats.html#topic+Normal">Normal</a></code>).
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chen, Y.-I., 1999. Rank-Based Tests for Dose Finding in
Nonmonotonic Dose–Response Settings.
<em>Biometrics</em> <strong>55</strong>, 1258&ndash;1262. <a href="https://doi.org/10.1111/j.0006-341X.1999.01258.x">doi:10.1111/j.0006-341X.1999.01258.x</a>
</p>
<p>House, D.E., 1986. A Nonparametric Version of Williams’ Test for
Randomized Block Design. <em>Biometrics</em> <strong>42</strong>, 187&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdManyOneExactTest">frdManyOneExactTest</a></code>, <code><a href="#topic+frdManyOneDemsarTest">frdManyOneDemsarTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ## Assume A is the control.

 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))

 ## Global Friedman test
 friedmanTest(y)

 ## Demsar's many-one test
 summary(frdManyOneDemsarTest(y=y, p.adjust = "bonferroni",
                      alternative = "greater"))

 ## Exact many-one test
 summary(frdManyOneExactTest(y=y, p.adjust = "bonferroni",
                     alternative = "greater"))

 ## Nemenyi's many-one test
 summary(frdManyOneNemenyiTest(y=y, alternative = "greater"))

 ## House test
 frdHouseTest(y, alternative = "greater")

</code></pre>

<hr>
<h2 id='frdManyOneDemsarTest'>Demsar's Many-to-One Test
for Unreplicated Blocked Data</h2><span id='topic+frdManyOneDemsarTest'></span><span id='topic+frdManyOneDemsarTest.default'></span>

<h3>Description</h3>

<p>Performs Demsar's non-parametric many-to-one comparison test
for Friedman-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdManyOneDemsarTest(y, ...)

## Default S3 method:
frdManyOneDemsarTest(
  y,
  groups,
  blocks,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdManyOneDemsarTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdManyOneDemsarTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdManyOneDemsarTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdManyOneDemsarTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="frdManyOneDemsarTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="frdManyOneDemsarTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in a two factorial unreplicated complete block design
with non-normally distributed residuals, Demsar's test can be
performed on Friedman-type ranked data.
</p>
<p>Let there be <code class="reqn">k</code> groups including the control,
then the number of treatment levels is <code class="reqn">m = k - 1</code>.
A total of <code class="reqn">m</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: \theta_0 = \theta_i</code> is tested in the two-tailed case against
A<code class="reqn">_i: \theta_0 \ne \theta_i, ~~ (1 \le i \le m)</code>.
</p>
<p>The <code class="reqn">p</code>-values are computed from the standard normal distribution.
Any of the <code class="reqn">p</code>-adjustment methods as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
can be used for the adjustment of <code class="reqn">p</code>-values.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Demsar, J. (2006) Statistical comparisons of classifiers over multiple
data sets, <em>Journal of Machine Learning Research</em> <b>7</b>, 1&ndash;30.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdManyOneExactTest">frdManyOneExactTest</a></code>, <code><a href="#topic+frdManyOneNemenyiTest">frdManyOneNemenyiTest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ## Assume A is the control.

 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))

 ## Global Friedman test
 friedmanTest(y)

 ## Demsar's many-one test
 summary(frdManyOneDemsarTest(y=y, p.adjust = "bonferroni",
                      alternative = "greater"))

 ## Exact many-one test
 summary(frdManyOneExactTest(y=y, p.adjust = "bonferroni",
                     alternative = "greater"))

 ## Nemenyi's many-one test
 summary(frdManyOneNemenyiTest(y=y, alternative = "greater"))

 ## House test
 frdHouseTest(y, alternative = "greater")

</code></pre>

<hr>
<h2 id='frdManyOneExactTest'>Exact Many-to-One Test
for Unreplicated Blocked Data</h2><span id='topic+frdManyOneExactTest'></span><span id='topic+frdManyOneExactTest.default'></span>

<h3>Description</h3>

<p>Performs an exact non-parametric many-to-one comparison test
for Friedman-type ranked data according to Eisinga et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdManyOneExactTest(y, ...)

## Default S3 method:
frdManyOneExactTest(y, groups, blocks, p.adjust.method = p.adjust.methods, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdManyOneExactTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdManyOneExactTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdManyOneExactTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdManyOneExactTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="frdManyOneExactTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in a two factorial unreplicated complete block design
with non-normally distributed residuals, an exact test can be
performed on Friedman-type ranked data.
</p>
<p>Let there be <code class="reqn">k</code> groups including the control,
then the number of treatment levels is <code class="reqn">m = k - 1</code>.
A total of <code class="reqn">m</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: \theta_0 = \theta_i</code> is tested in the two-tailed case against
A<code class="reqn">_i: \theta_0 \ne \theta_i, ~~ (1 \le i \le m)</code>.
</p>
<p>The exact <code class="reqn">p</code>-values
are computed using the code of <code>"pexactfrsd.R"</code>
that was a supplement to the publication of Eisinga et al. (2017).
Additionally, any of the <code class="reqn">p</code>-adjustment methods
as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> can be selected, for <code class="reqn">p</code>-value
adjustment.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Eisinga, R., Heskes, T., Pelzer, B., Te Grotenhuis, M. (2017)
Exact p-values for Pairwise Comparison of Friedman Rank Sums,
with Application to Comparing Classifiers, <em>BMC Bioinformatics</em>, 18:68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdManyOneDemsarTest">frdManyOneDemsarTest</a></code>, <code><a href="#topic+frdManyOneNemenyiTest">frdManyOneNemenyiTest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ## Assume A is the control.

 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))

 ## Global Friedman test
 friedmanTest(y)

 ## Demsar's many-one test
 summary(frdManyOneDemsarTest(y=y, p.adjust = "bonferroni",
                      alternative = "greater"))

 ## Exact many-one test
 summary(frdManyOneExactTest(y=y, p.adjust = "bonferroni",
                     alternative = "greater"))

 ## Nemenyi's many-one test
 summary(frdManyOneNemenyiTest(y=y, alternative = "greater"))

 ## House test
 frdHouseTest(y, alternative = "greater")

</code></pre>

<hr>
<h2 id='frdManyOneNemenyiTest'>Nemenyi's Many-to-One Test
for Unreplicated Blocked Data</h2><span id='topic+frdManyOneNemenyiTest'></span><span id='topic+frdManyOneNemenyiTest.default'></span>

<h3>Description</h3>

<p>Performs Nemenyi's non-parametric many-to-one comparison test
for Friedman-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frdManyOneNemenyiTest(y, ...)

## Default S3 method:
frdManyOneNemenyiTest(
  y,
  groups,
  blocks,
  alternative = c("two.sided", "greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frdManyOneNemenyiTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="frdManyOneNemenyiTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdManyOneNemenyiTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="frdManyOneNemenyiTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="frdManyOneNemenyiTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in a two factorial unreplicated complete block design
with non-normally distributed residuals, Nemenyi's test can be
performed on Friedman-type ranked data.
</p>
<p>Let there be <code class="reqn">k</code> groups including the control,
then the number of treatment levels is <code class="reqn">m = k - 1</code>.
A total of <code class="reqn">m</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: \theta_0 = \theta_i</code> is tested in the two-tailed case against
A<code class="reqn">_i: \theta_0 \ne \theta_i, ~~ (1 \le i \le m)</code>.
</p>
<p>The <code class="reqn">p</code>-values are computed from the multivariate normal distribution.
As <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> applies a numerical method, the estimated
<code class="reqn">p</code>-values are seet depended.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hollander, M., Wolfe, D. A., Chicken, E. (2014),
<em>Nonparametric Statistical Methods</em>. 3rd ed. New York: Wiley. 2014.
</p>
<p>Miller Jr., R. G. (1996), <em>Simultaneous Statistical Inference</em>.
New York: McGraw-Hill.
</p>
<p>Nemenyi, P. (1963), <em>Distribution-free Multiple Comparisons</em>.
Ph.D. thesis, Princeton University.
</p>
<p>Siegel, S., Castellan Jr., N. J. (1988), <em>Nonparametric
Statistics for the Behavioral Sciences</em>. 2nd ed.
New York: McGraw-Hill.
</p>
<p>Zarr, J. H. (1999), <em>Biostatistical Analysis</em>. 4th ed.
Upper Saddle River: Prentice-Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="stats.html#topic+friedman.test">friedman.test</a></code>,
<code><a href="#topic+frdManyOneExactTest">frdManyOneExactTest</a></code>, <code><a href="#topic+frdManyOneDemsarTest">frdManyOneDemsarTest</a></code>
<code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>, <code><a href="base.html#topic+set.seed">set.seed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Sachs, 1997, p. 675
 ## Six persons (block) received six different diuretics
 ## (A to F, treatment).
 ## The responses are the Na-concentration (mval)
 ## in the urine measured 2 hours after each treatment.
 ## Assume A is the control.

 y &lt;- matrix(c(
 3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
 23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
 26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
 32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
 26.65),nrow=6, ncol=6,
 dimnames=list(1:6, LETTERS[1:6]))

 ## Global Friedman test
 friedmanTest(y)

 ## Demsar's many-one test
 summary(frdManyOneDemsarTest(y=y, p.adjust = "bonferroni",
                      alternative = "greater"))

 ## Exact many-one test
 summary(frdManyOneExactTest(y=y, p.adjust = "bonferroni",
                     alternative = "greater"))

 ## Nemenyi's many-one test
 summary(frdManyOneNemenyiTest(y=y, alternative = "greater"))

 ## House test
 frdHouseTest(y, alternative = "greater")

</code></pre>

<hr>
<h2 id='friedmanTest'>Friedman Rank Sum Test</h2><span id='topic+friedmanTest'></span><span id='topic+friedmanTest.default'></span>

<h3>Description</h3>

<p>Performs a Friedman rank sum test. The null hypothesis
H<code class="reqn">_0: \theta_i = \theta_j~~(i \ne j)</code> is tested against the
alternative H<code class="reqn">_{\mathrm{A}}: \theta_i \ne \theta_j</code>, with at least
one inequality beeing strict.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>friedmanTest(y, ...)

## Default S3 method:
friedmanTest(y, groups, blocks, dist = c("Chisquare", "FDist"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="friedmanTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="friedmanTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="friedmanTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="friedmanTest_+3A_dist">dist</code></td>
<td>
<p>the test distribution. Defaults to <code>Chisquare</code>.</p>
</td></tr>
<tr><td><code id="friedmanTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has implemented Friedman's test as well as
the extension of Conover anf Iman (1981). Friedman's
test statistic is assymptotically chi-squared distributed.
Consequently, the default test distribution is <code>dist = "Chisquare"</code>.
</p>
<p>If <code>dist = "FDist"</code> is selected, than the approach of
Conover and Imam (1981) is performed.
The Friedman Test using the <code class="reqn">F</code>-distribution leads to
the same results as doing an two-way Analysis of Variance without
interaction on rank transformed data.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Conover, W.J., Iman, R.L. (1981) Rank Transformations as a Bridge
Between Parametric and Nonparametric Statistics.
<em>Am Stat</em> <b>35</b>, 124&ndash;129.
</p>
<p>Sachs, L. (1997) <em>Angewandte Statistik</em>. Berlin: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+friedman.test">friedman.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hollander &amp; Wolfe (1973), p. 140ff.
## Comparison of three methods ("round out", "narrow angle", and
##  "wide angle") for rounding first base.  For each of 18 players
##  and the three method, the average time of two runs from a point on
##  the first base line 35ft from home plate to a point 15ft short of
##  second base is recorded.
RoundingTimes &lt;-
matrix(c(5.40, 5.50, 5.55,
        5.85, 5.70, 5.75,
        5.20, 5.60, 5.50,
        5.55, 5.50, 5.40,
        5.90, 5.85, 5.70,
        5.45, 5.55, 5.60,
        5.40, 5.40, 5.35,
        5.45, 5.50, 5.35,
        5.25, 5.15, 5.00,
        5.85, 5.80, 5.70,
        5.25, 5.20, 5.10,
        5.65, 5.55, 5.45,
        5.60, 5.35, 5.45,
        5.05, 5.00, 4.95,
        5.50, 5.50, 5.40,
        5.45, 5.55, 5.50,
        5.55, 5.55, 5.35,
        5.45, 5.50, 5.55,
        5.50, 5.45, 5.25,
        5.65, 5.60, 5.40,
        5.70, 5.65, 5.55,
        6.30, 6.30, 6.25),
      nrow = 22,
      byrow = TRUE,
      dimnames = list(1 : 22,
                      c("Round Out", "Narrow Angle", "Wide Angle")))

## Chisquare distribution
friedmanTest(RoundingTimes)

## check with friedman.test from R stats
friedman.test(RoundingTimes)

## F-distribution
friedmanTest(RoundingTimes, dist = "FDist")

## Check with One-way repeated measure ANOVA
rmat &lt;- RoundingTimes
for (i in 1:length(RoundingTimes[,1])) rmat[i,] &lt;- rank(rmat[i,])
dataf &lt;- data.frame(
    y = y &lt;- as.vector(rmat),
    g = g &lt;- factor(c(col(RoundingTimes))),
    b = b &lt;- factor(c(row(RoundingTimes))))
summary(aov(y ~ g + Error(b), data = dataf))

</code></pre>

<hr>
<h2 id='gamesHowellTest'>Games-Howell Test</h2><span id='topic+gamesHowellTest'></span><span id='topic+gamesHowellTest.default'></span><span id='topic+gamesHowellTest.formula'></span><span id='topic+gamesHowellTest.aov'></span>

<h3>Description</h3>

<p>Performs Games-Howell all-pairs comparison test for normally distributed
data with unequal group variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamesHowellTest(x, ...)

## Default S3 method:
gamesHowellTest(x, g, ...)

## S3 method for class 'formula'
gamesHowellTest(formula, data, subset, na.action, ...)

## S3 method for class 'aov'
gamesHowellTest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamesHowellTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="gamesHowellTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="gamesHowellTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="gamesHowellTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="gamesHowellTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="gamesHowellTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="gamesHowellTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals but unequal between-groups variances
the Games-Howell Test can be performed.  Let <code class="reqn">X_{ij}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization (<code class="reqn">1 \le j \le n_i</code>)
in the <code class="reqn">i</code>-th group (<code class="reqn">1 \le i \le k</code>). Furthermore, the total
sample size is <code class="reqn">N = \sum_{i=1}^k n_i</code>. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{ij}: \mu_i = \mu_j ~~ (i \ne j)</code> is tested against the alternative
A<code class="reqn">_{ij}: \mu_i \ne \mu_j</code> (two-tailed). Games-Howell Test all-pairs
test statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{ij} \frac{\bar{X}_i - \bar{X_j}}
 {\left( s^2_j / n_j + s^2_i / n_i \right)^{1/2}}, ~~
 (i \ne j)
</code>
</p>

<p>with <code class="reqn">s^2_i</code> the variance of the <code class="reqn">i</code>-th group.
The null hypothesis is rejected (two-tailed) if
</p>
<p style="text-align: center;"><code class="reqn">
 \mathrm{Pr} \left\{ |t_{ij}| \sqrt{2} \ge q_{m v_{ij} \alpha} | \mathrm{H} \right\}_{ij} =
 \alpha,
</code>
</p>

<p>with Welch's approximate solution for calculating the degree of freedom.
</p>
<p style="text-align: center;"><code class="reqn">
 v_{ij} = \frac{\left( s^2_i / n_i + s^2_j / n_j \right)^2}
 {s^4_i / n^2_i \left(n_i - 1\right) + s^4_j / n^2_j \left(n_j - 1\right)}.
</code>
</p>

<p>The <code class="reqn">p</code>-values are computed from the
<code><a href="stats.html#topic+Tukey">Tukey</a></code> distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+Tukey">Tukey</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts) # var1 = varN
anova(fit)

## also works with fitted objects of class aov
res &lt;- gamesHowellTest(fit)
summary(res)
summaryGroup(res)

</code></pre>

<hr>
<h2 id='gesdTest'>Generalized Extreme Studentized Deviate Many-Outlier Test</h2><span id='topic+gesdTest'></span>

<h3>Description</h3>

<p>Performs Rosner's generalized extreme studentized deviate
procedure to detect up-to <code>maxr</code> outliers in a
univariate sample that follows an approximately normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gesdTest(x, maxr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gesdTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data.</p>
</td></tr>
<tr><td><code id="gesdTest_+3A_maxr">maxr</code></td>
<td>
<p>the maximum number of outliers to be tested.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rosner, B. (1983) Percentage Points for a Generalized ESD
Many-Outlier Procedure, <em>Technometrics</em> <b>25</b>, 165&ndash;172.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Taken from Rosner (1983):
x &lt;- c(-0.25,0.68,0.94,1.15,1.20,1.26,1.26,
1.34,1.38,1.43,1.49,1.49,1.55,1.56,
1.58,1.65,1.69,1.70,1.76,1.77,1.81,
1.91,1.94,1.96,1.99,2.06,2.09,2.10,
2.14,2.15,2.23,2.24,2.26,2.35,2.37,
2.40,2.47,2.54,2.62,2.64,2.90,2.92,
2.92,2.93,3.21,3.26,3.30,3.59,3.68,
4.30,4.64,5.34,5.42,6.01)

out &lt;- gesdTest(x, 10)

## print method
out

## summary method
summary(out)

</code></pre>

<hr>
<h2 id='goreTest'>Gore Test</h2><span id='topic+goreTest'></span>

<h3>Description</h3>

<p>Performs Gore's test. The null hypothesis
H<code class="reqn">_0: \theta_i = \theta_j~~(i \ne j)</code> is tested against the
alternative H<code class="reqn">_{\mathrm{A}}: \theta_i \ne \theta_j</code>, with at least
one inequality beeing strict.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goreTest(y, groups, blocks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goreTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="goreTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"y"</code>.</p>
</td></tr>
<tr><td><code id="goreTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"y"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has implemented Gore's test for testing
main effects in unbalanced CRB designs,
i.e. there are one ore more observations per cell.
The statistic is assymptotically chi-squared distributed.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gore, A. P. (1975) Some nonparametric tests and selection
procedures for main effects in two-way layouts.
<em>Ann. Inst. Stat. Math.</em> <b>27</b>, 487&ndash;500.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="#topic+skillingsMackTest">skillingsMackTest</a></code>,
<code><a href="#topic+durbinTest">durbinTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Crop Yield of 3 varieties on two
## soil classes
X &lt;-c("130,A,Light
115,A,Light
123,A,Light
142,A,Light
117,A,Heavy
125,A,Heavy
139,A,Heavy
108,B,Light
114,B,Light
124,B,Light
106,B,Light
91,B,Heavy
111,B,Heavy
110,B,Heavy
155,C,Light
146,C,Light
151,C,Light
165,C,Light
97,C,Heavy
108,C,Heavy")
con &lt;- textConnection(X)
x &lt;- read.table(con, header=FALSE, sep=",")
close(con)
colnames(x) &lt;- c("Yield", "Variety", "SoilType")
goreTest(y = x$Yield, groups = x$Variety, blocks = x$SoilType)
</code></pre>

<hr>
<h2 id='Grubbs'>Grubbs distribution</h2><span id='topic+Grubbs'></span><span id='topic+qgrubbs'></span><span id='topic+pgrubbs'></span>

<h3>Description</h3>

<p>Distribution function and quantile function
for Grubbs distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgrubbs(p, n)

pgrubbs(q, n, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Grubbs_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Grubbs_+3A_n">n</code></td>
<td>
<p>total sample size.</p>
</td></tr>
<tr><td><code id="Grubbs_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Grubbs_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default),
probabilities are <code class="reqn">P[X \leq x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pgrubbs</code> gives the distribution function and
<code>qgrubbs</code> gives the quantile function.
</p>


<h3>References</h3>

<p>Grubbs, F. E. (1950) Sample criteria for testing outlying observations.
<em>Ann. Math. Stat.</em> <b>21</b>, 27&ndash;58.
</p>
<p>Wilrich, P.-T. (2011) Critical values of Mandel's h and k,
Grubbs and the Cochran test statistic. <em>Adv. Stat. Anal.</em>.
<a href="https://doi.org/10.1007/s10182-011-0185-y">doi:10.1007/s10182-011-0185-y</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qgrubbs(0.05, 7)
</code></pre>

<hr>
<h2 id='grubbsTest'>Grubbs Outlier Test</h2><span id='topic+grubbsTest'></span>

<h3>Description</h3>

<p>Performs Grubbs single outlier test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grubbsTest(x, alternative = c("two.sided", "greater", "less"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grubbsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data.</p>
</td></tr>
<tr><td><code id="grubbsTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis.
Defaults to <code>"two.sided"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> denote an identically and independently distributed continuous
variate with realizations <code class="reqn">x_i ~~ (1 \le i \le k)</code>.
Further, let the increasingly ordered realizations
denote <code class="reqn">x_{(1)} \le x_{(2)} \le \ldots \le x_{(n)}</code>. Then
the following model for a single maximum outlier can be proposed:
</p>
<p style="text-align: center;"><code class="reqn">
  x_{(i)} = \left\{
      \begin{array}{lcl}
       \mu + \epsilon_{(i)}, &amp; \qquad &amp; i = 1, \ldots, n - 1 \\
       \mu + \Delta + \epsilon_{(n)} &amp; &amp; \\
      \end{array} \right.</code>
</p>

<p>with <code class="reqn">\epsilon \approx N(0,\sigma)</code>. The null hypothesis,
H<code class="reqn">_0: \Delta = 0</code> is tested against the alternative,
H<code class="reqn">_{\mathrm{A}}: \Delta &gt; 0</code>.
</p>
<p>For testing a single minimum outlier, the model can be proposed
as
</p>
<p style="text-align: center;"><code class="reqn">
  x_{(i)} = \left\{
      \begin{array}{lcl}
       \mu + \Delta + \epsilon_{(1)} &amp; &amp; \\
       \mu + \epsilon_{(i)}, &amp; \qquad &amp; i = 2, \ldots, n \\
      \end{array} \right.</code>
</p>

<p>The null hypothesis is tested against the alternative,
H<code class="reqn">_{\mathrm{A}}: \Delta &lt; 0</code>.
</p>
<p>The p-value is computed with the function <code><a href="#topic+pgrubbs">pgrubbs</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Grubbs, F. E. (1950) Sample criteria for testing outlying observations.
<em>Ann. Math. Stat.</em> <b>21</b>, 27&ndash;58.
</p>
<p>Wilrich, P.-T. (2011) Critical values of Mandel's h and k,
Grubbs and the Cochran test statistic. <em>Adv. Stat. Anal.</em>.
<a href="https://doi.org/10.1007/s10182-011-0185-y">doi:10.1007/s10182-011-0185-y</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pentosan)
dat &lt;- subset(Pentosan, subset = (material == "A"))
labMeans &lt;- tapply(dat$value, dat$lab, mean)
grubbsTest(x = labMeans, alternative = "two.sided")
</code></pre>

<hr>
<h2 id='GSTTest'>Generalized Siegel-Tukey Test of Homogeneity of
Scales</h2><span id='topic+GSTTest'></span><span id='topic+GSTTest.default'></span><span id='topic+GSTTest.formula'></span>

<h3>Description</h3>

<p>Performs a Siegel-Tukey k-sample rank dispersion test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSTTest(x, ...)

## Default S3 method:
GSTTest(x, g, dist = c("Chisquare", "KruskalWallis"), ...)

## S3 method for class 'formula'
GSTTest(
  formula,
  data,
  subset,
  na.action,
  dist = c("Chisquare", "KruskalWallis"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GSTTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="GSTTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="GSTTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="GSTTest_+3A_dist">dist</code></td>
<td>
<p>the test distribution. Defaults's to <code>"Chisquare"</code>.</p>
</td></tr>
<tr><td><code id="GSTTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="GSTTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="GSTTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="GSTTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meyer-Bahlburg (1970) has proposed a generalized Siegel-Tukey
rank dispersion test for the <code class="reqn">k</code>-sample case.
Likewise to the <code><a href="stats.html#topic+fligner.test">fligner.test</a></code>, this test
is a nonparametric test for testing the homogegeneity of
scales in several groups.
Let <code class="reqn">\theta_i</code>, and <code class="reqn">\lambda_i</code> denote
location and scale parameter of the <code class="reqn">i</code>th group,
then for the two-tailed case, the null hypothesis
H: <code class="reqn">\lambda_i / \lambda_j = 1 | \theta_i = \theta_j, ~ i \ne j</code> is
tested against the alternative,
A: <code class="reqn">\lambda_i / \lambda_j \ne 1</code>
with at least one inequality beeing strict.
</p>
<p>The data are combinedly ranked according to Siegel-Tukey.
The ranking is done by alternate extremes (rank 1 is lowest,
2 and 3 are the two highest, 4 and 5 are the two next lowest, etc.).
</p>
<p>Meyer-Bahlburg (1970) showed, that the Kruskal-Wallis H-test
can be employed on the Siegel-Tukey ranks.
The H-statistic is assymptotically
chi-squared distributed with <code class="reqn">v = k - 1</code> degree
of freedom, the default test distribution is consequently
<code>dist = "Chisquare"</code>. If <code>dist = "KruskalWallis"</code> is selected,
an incomplete beta approximation is used for the calculation
of p-values as implemented in the function
<code><a href="SuppDists.html#topic+pKruskalWallis">pKruskalWallis</a></code> of the package
<span class="pkg">SuppDists</span>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>If ties are present, a tie correction is performed and
a warning message is given. The GSTTest is sensitive to
median differences, likewise to the Siegel-Tukey test.
It is thus appropriate to apply this test on the residuals
of a one-way ANOVA, rather than on the original data
(see example).
</p>


<h3>References</h3>

<p>H.F.L. Meyer-Bahlburg (1970), A nonparametric test for relative
spread in k unpaired samples, <em>Metrika</em> <b>15</b>, 23&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fligner.test">fligner.test</a></code>, <code><a href="SuppDists.html#topic+pKruskalWallis">pKruskalWallis</a></code>,
<code><a href="stats.html#topic+Chisquare">Chisquare</a></code>, <code><a href="stats.html#topic+fligner.test">fligner.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GSTTest(count ~ spray, data = InsectSprays)

## as means/medians differ, apply the test to residuals
## of one-way ANOVA
ans &lt;- aov(count ~ spray, data = InsectSprays)
GSTTest( residuals( ans) ~ spray, data =InsectSprays)

</code></pre>

<hr>
<h2 id='hartleyTest'>Hartley's Maximum F-Ratio Test of Homogeneity of
Variances</h2><span id='topic+hartleyTest'></span><span id='topic+hartleyTest.default'></span><span id='topic+hartleyTest.formula'></span>

<h3>Description</h3>

<p>Performs Hartley's maximum F-ratio test of the null that
variances in each of the groups (samples) are the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hartleyTest(x, ...)

## Default S3 method:
hartleyTest(x, g, ...)

## S3 method for class 'formula'
hartleyTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hartleyTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="hartleyTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="hartleyTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="hartleyTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="hartleyTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="hartleyTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="hartleyTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a list, its elements are taken as the samples
to be compared for homogeneity of variances.  In this
case, the elements must all be numeric data vectors,
<code>g</code> is ignored, and one can simply use
<code>hartleyTest(x)</code> to perform the test.  If the samples are not
yet contained in a list, use <code>hartleyTest(list(x, ...))</code>.
</p>
<p>Otherwise, <code>x</code> must be a numeric data vector, and <code>g</code> must
be a vector or factor object of the same length as <code>x</code> giving the
group for the corresponding elements of <code>x</code>.
</p>
<p>Hartley's parametric test requires normality and
a nearly balanced design. The p-value of the test
is calculated with the function <code><a href="SuppDists.html#topic+pmaxFratio">pmaxFratio</a></code>
of the package <span class="pkg">SuppDists</span>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hartley, H.O. (1950) The maximum F-ratio
as a short cut test for heterogeneity of variance,
<em>Biometrika</em> <b>37</b>, 308&ndash;312.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+bartlett.test">bartlett.test</a></code>, <code><a href="SuppDists.html#topic+pmaxFratio">pmaxFratio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hartleyTest(count ~ spray, data = InsectSprays)

</code></pre>

<hr>
<h2 id='hayterStoneTest'>Hayter-Stone Test</h2><span id='topic+hayterStoneTest'></span><span id='topic+hayterStoneTest.default'></span><span id='topic+hayterStoneTest.formula'></span>

<h3>Description</h3>

<p>Performs the non-parametric Hayter-Stone procedure
to test against an monotonically increasing alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hayterStoneTest(x, ...)

## Default S3 method:
hayterStoneTest(
  x,
  g,
  alternative = c("greater", "less"),
  method = c("look-up", "boot", "asympt"),
  nperm = 10000,
  ...
)

## S3 method for class 'formula'
hayterStoneTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  method = c("look-up", "boot", "asympt"),
  nperm = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hayterStoneTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_method">method</code></td>
<td>
<p>a character string specifying the test statistic to use.
Defaults to <code>"look-up"</code> that uses published Table values.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the asymptotic permutation test.
Defaults to <code>1000</code>. Ignored, if <code>method = "look-up"</code>.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="hayterStoneTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> be an identically and idepentendly distributed variable
that was <code class="reqn">n</code> times observed at <code class="reqn">k</code> increasing treatment levels.
Hayter and Stone (1991) proposed a non-parametric procedure
to test the null hypothesis, H: <code class="reqn">\theta_i = \theta_j ~~ (i &lt; j \le k)</code>
against a simple order alternative, A: <code class="reqn">\theta_i &lt; \theta_j</code>, with at least
one inequality being strict.
</p>
<p>The statistic for a global test is calculated as,
</p>
<p style="text-align: center;"><code class="reqn">
 h = \max_{1 \le i &lt; j \le k} \frac{2 \sqrt{6} \left(U_{ij} - n_i n_j / 2 \right)}
 {\sqrt{n_i n_j \left(n_i + n_j + 1 \right)}},
</code>
</p>

<p>with the Mann-Whittney counts:
</p>
<p style="text-align: center;"><code class="reqn">
U_{ij} =  \sum_{a=1}^{n_i} \sum_{b=1}^{n_j} I\left\{x_{ia} &lt; x_{ja}\right\}.
</code>
</p>

<p>Under the large sample approximation, the test statistic <code class="reqn">h</code> is distributed
as <code class="reqn">h_{k,\alpha,v}</code>. Thus, the null hypothesis is rejected, if <code class="reqn">h &gt; h_{k,\alpha,v}</code>, with <code class="reqn">v = \infty</code>
degree of freedom.
</p>
<p>If <code>method = "look-up"</code> the function will not return
p-values. Instead the critical h-values
as given in the tables of Hayter (1990) for
<code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the number of groups (<code class="reqn">k</code>) and
the degree of freedoms (<code class="reqn">v = \infty</code>).
</p>
<p>If <code>method = "boot"</code> an asymptotic permutation test
is conducted and a <code class="reqn">p</code>-value is returned.
</p>
<p>If <code>method = "asympt"</code> is selected the asymptotic
<code class="reqn">p</code>-value is estimated as implemented in the
function <code>pHayStonLSA</code> of the package <span class="pkg">NSM3</span>.
</p>


<h3>Value</h3>

<p>Either a list of class <code>htest</code> or a
list with class <code>"osrt"</code> that contains the following
components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>


<h3>Source</h3>

<p>If <code>method = "asympt"</code> is selected, this function calls
an internal probability function <code>pHS</code>. The GPL-2 code for
this function was taken from <code>pHayStonLSA</code> of the
the package <span class="pkg">NSM3</span>:
</p>
<p>Grant Schneider, Eric Chicken and Rachel Becvarik (2020) NSM3:
Functions and Datasets to Accompany Hollander, Wolfe, and
Chicken - Nonparametric Statistical Methods, Third Edition. R
package version 1.15. <a href="https://CRAN.R-project.org/package=NSM3">https://CRAN.R-project.org/package=NSM3</a>
</p>


<h3>References</h3>

<p>Hayter, A. J.(1990) A One-Sided Studentised Range
Test for Testing Against a Simple Ordered Alternative,
<em>J Amer Stat Assoc</em>
<b>85</b>, 778&ndash;785.
</p>
<p>Hayter, A.J., Stone, G. (1991)
Distribution free multiple comparisons for monotonically ordered treatment effects.
<em>Austral J Statist</em> <b>33</b>, 335&ndash;346.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+osrtTest">osrtTest</a></code>, <code><a href="#topic+hsAllPairsTest">hsAllPairsTest</a></code>,
<code><a href="base.html#topic+sample">sample</a></code>, <code><a href="NSM3.html#topic+pHayStonLSA">pHayStonLSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Shirley (1977)
## Reaction times of mice to stimuli to their tails.
x &lt;- c(2.4, 3, 3, 2.2, 2.2, 2.2, 2.2, 2.8, 2, 3,
 2.8, 2.2, 3.8, 9.4, 8.4, 3, 3.2, 4.4, 3.2, 7.4, 9.8, 3.2, 5.8,
 7.8, 2.6, 2.2, 6.2, 9.4, 7.8, 3.4, 7, 9.8, 9.4, 8.8, 8.8, 3.4,
 9, 8.4, 2.4, 7.8)
g &lt;- gl(4, 10)

## Shirley's test
## one-sided test using look-up table
shirleyWilliamsTest(x ~ g, alternative = "greater")

## Chacko's global hypothesis test for 'greater'
chackoTest(x , g)

## post-hoc test, default is standard normal distribution (NPT'-test)
summary(chaAllPairsNashimotoTest(x, g, p.adjust.method = "none"))

## same but h-distribution (NPY'-test)
chaAllPairsNashimotoTest(x, g, dist = "h")

## NPM-test
NPMTest(x, g)

## Hayter-Stone test
hayterStoneTest(x, g)

## all-pairs comparisons
hsAllPairsTest(x, g)
</code></pre>

<hr>
<h2 id='hsAllPairsTest'>Hayter-Stone All-Pairs Comparison Test</h2><span id='topic+hsAllPairsTest'></span><span id='topic+hsAllPairsTest.default'></span><span id='topic+hsAllPairsTest.formula'></span>

<h3>Description</h3>

<p>Performs the non-parametric Hayter-Stone all-pairs procedure
to test against monotonically increasing alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsAllPairsTest(x, ...)

## Default S3 method:
hsAllPairsTest(
  x,
  g,
  alternative = c("greater", "less"),
  method = c("look-up", "boot", "asympt"),
  nperm = 10000,
  ...
)

## S3 method for class 'formula'
hsAllPairsTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  method = c("look-up", "boot", "asympt"),
  nperm = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsAllPairsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_method">method</code></td>
<td>
<p>a character string specifying the test statistic to use.
Defaults to <code>"look-up"</code> that uses published Table values of Williams (1972).</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the asymptotic permutation test.
Defaults to <code>1000</code>. Ignored, if <code>method = "look-up"</code>.</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="hsAllPairsTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> be an identically and idepentendly distributed variable
that was <code class="reqn">n</code> times observed at <code class="reqn">k</code> increasing treatment levels.
Hayter and Stone (1991) proposed a non-parametric procedure
to test the null hypothesis, H: <code class="reqn">\theta_i = \theta_j ~~ (i &lt; j \le k)</code>
against a simple order alternative, A: <code class="reqn">\theta_i &lt; \theta_j</code>.
</p>
<p>The statistic for all-pairs comparisons is calculated as,
</p>
<p style="text-align: center;"><code class="reqn">
 S_{ij} = \frac{2 \sqrt{6} \left(U_{ij} - n_i n_j / 2 \right)}
 {\sqrt{n_i n_j \left(n_i + n_j + 1 \right)}},
</code>
</p>

<p>with the Mann-Whittney counts:
</p>
<p style="text-align: center;"><code class="reqn">
U_{ij} =  \sum_{a=1}^{n_i} \sum_{b=1}^{n_j} I\left\{x_{ia} &lt; x_{ja}\right\}.
</code>
</p>

<p>Under the large sample approximation, the test statistic <code class="reqn">S_{ij}</code> is distributed
as <code class="reqn">h_{k,\alpha,v}</code>. Thus, the null hypothesis is rejected,
if <code class="reqn">S_{ij} &gt; h_{k,\alpha,v}</code>, with <code class="reqn">v = \infty</code> degree of freedom.
</p>
<p>If <code>method = "look-up"</code> the function will not return
p-values. Instead the critical h-values
as given in the tables of Hayter (1990) for
<code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the number of groups (<code class="reqn">k</code>) and
the degree of freedoms (<code class="reqn">v = \infty</code>).
</p>
<p>If <code>method = "boot"</code> an asymetric permutation test
is conducted and <code class="reqn">p</code>-values are returned.
</p>
<p>If <code>method = "asympt"</code> is selected the asymptotic
<code class="reqn">p</code>-value is estimated as implemented in the
function <code>pHayStonLSA</code> of the package <span class="pkg">NSM3</span>.
</p>


<h3>Value</h3>

<p>Either a list of class <code>"PMCMR"</code> or a
list with class <code>"osrt"</code> that contains the following
components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>
<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Source</h3>

<p>If <code>method = "asympt"</code> is selected, this function calls
an internal probability function <code>pHS</code>. The GPL-2 code for
this function was taken from <code>pHayStonLSA</code> of the
the package <span class="pkg">NSM3</span>:
</p>
<p>Grant Schneider, Eric Chicken and Rachel Becvarik (2020) NSM3:
Functions and Datasets to Accompany Hollander, Wolfe, and
Chicken - Nonparametric Statistical Methods, Third Edition. R
package version 1.15. <a href="https://CRAN.R-project.org/package=NSM3">https://CRAN.R-project.org/package=NSM3</a>
</p>


<h3>References</h3>

<p>Hayter, A. J.(1990) A One-Sided Studentised Range
Test for Testing Against a Simple Ordered Alternative,
<em>Journal of the American Statistical Association</em>
<b>85</b>, 778&ndash;785.
</p>
<p>Hayter, A.J., Stone, G. (1991)
Distribution free multiple comparisons for monotonically ordered treatment effects.
<em>Austral J Statist</em> <b>33</b>, 335&ndash;346.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hayterStoneTest">hayterStoneTest</a></code> <code><a href="base.html#topic+sample">sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Shirley (1977)
## Reaction times of mice to stimuli to their tails.
x &lt;- c(2.4, 3, 3, 2.2, 2.2, 2.2, 2.2, 2.8, 2, 3,
 2.8, 2.2, 3.8, 9.4, 8.4, 3, 3.2, 4.4, 3.2, 7.4, 9.8, 3.2, 5.8,
 7.8, 2.6, 2.2, 6.2, 9.4, 7.8, 3.4, 7, 9.8, 9.4, 8.8, 8.8, 3.4,
 9, 8.4, 2.4, 7.8)
g &lt;- gl(4, 10)

## Shirley's test
## one-sided test using look-up table
shirleyWilliamsTest(x ~ g, alternative = "greater")

## Chacko's global hypothesis test for 'greater'
chackoTest(x , g)

## post-hoc test, default is standard normal distribution (NPT'-test)
summary(chaAllPairsNashimotoTest(x, g, p.adjust.method = "none"))

## same but h-distribution (NPY'-test)
chaAllPairsNashimotoTest(x, g, dist = "h")

## NPM-test
NPMTest(x, g)

## Hayter-Stone test
hayterStoneTest(x, g)

## all-pairs comparisons
hsAllPairsTest(x, g)
</code></pre>

<hr>
<h2 id='johnsonTest'>Testing against Ordered Alternatives (Johnson-Mehrotra Test)</h2><span id='topic+johnsonTest'></span><span id='topic+johnsonTest.default'></span><span id='topic+johnsonTest.formula'></span>

<h3>Description</h3>

<p>Performs the Johnson-Mehrotra test for testing against ordered alternatives
in a balanced one-factorial sampling design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>johnsonTest(x, ...)

## Default S3 method:
johnsonTest(x, g, alternative = c("two.sided", "greater", "less"), ...)

## S3 method for class 'formula'
johnsonTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="johnsonTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="johnsonTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="johnsonTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="johnsonTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="johnsonTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="johnsonTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="johnsonTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="johnsonTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis, H<code class="reqn">_0: \theta_1 = \theta_2 = \ldots = \theta_k</code>
is tested against a simple order hypothesis,
H<code class="reqn">_\mathrm{A}: \theta_1 \le \theta_2 \le \ldots \le
\theta_k,~\theta_1 &lt; \theta_k</code>.
</p>
<p>The p-values are estimated from the standard normal distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Bortz, J. (1993). <em>Statistik für Sozialwissenschaftler</em> (4th ed.).
Berlin: Springer.
</p>
<p>Johnson, R. A., Mehrotra, K. G. (1972) Some c-sample
nonparametric tests for ordered alternatives.
<em>Journal of the Indian Statistical Association</em> <b>9</b>, 8&ndash;23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='jonckheereTest'>Testing against Ordered Alternatives (Jonckheere-Terpstra Test)</h2><span id='topic+jonckheereTest'></span><span id='topic+jonckheereTest.default'></span><span id='topic+jonckheereTest.formula'></span>

<h3>Description</h3>

<p>Performs the Jonckheere-Terpstra test for testing against ordered alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jonckheereTest(x, ...)

## Default S3 method:
jonckheereTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  continuity = FALSE,
  ...
)

## S3 method for class 'formula'
jonckheereTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  continuity = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jonckheereTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="jonckheereTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="jonckheereTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="jonckheereTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="jonckheereTest_+3A_continuity">continuity</code></td>
<td>
<p>logical indicator whether a continuity correction
shall be performed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="jonckheereTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="jonckheereTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="jonckheereTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="jonckheereTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis, H<code class="reqn">_0: \theta_1 = \theta_2 = \ldots = \theta_k</code>
is tested against a simple order hypothesis,
H<code class="reqn">_\mathrm{A}: \theta_1 \le \theta_2 \le \ldots \le
\theta_k,~\theta_1 &lt; \theta_k</code>.
</p>
<p>The p-values are estimated from the standard normal distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The code for the computation of the standard deviation
for the Jonckheere-Terpstra test in the presence of ties was taken from:<br />
</p>
<p>Kloke, J., McKean, J. (2016)
<a href="https://CRAN.R-project.org/package=npsm"><span class="pkg">npsm</span></a>: Package for Nonparametric Statistical Methods using R.
R package version 0.5. <a href="https://CRAN.R-project.org/package=npsm">https://CRAN.R-project.org/package=npsm</a>
</p>


<h3>Note</h3>

<p><code>jonckheereTest(x, g, alternative = "two.sided", continuity = TRUE)</code> is
equivalent to
</p>
<p><code>cor.test(x, as.numeric(g), method = "kendall", alternative = "two.sided", continuity = TRUE)</code>
</p>
<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Jonckheere, A. R. (1954) A distribution-free k-sample test
against ordered alternatives. <em>Biometrica</em> <b>41</b>, 133–145.
</p>
<p>Kloke, J., McKean, J. W. (2015) <em>Nonparametric statistical methods using R</em>.
Boca Raton, FL: Chapman &amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='kruskalTest'>Kruskal-Wallis Rank Sum Test</h2><span id='topic+kruskalTest'></span><span id='topic+kruskalTest.default'></span><span id='topic+kruskalTest.formula'></span>

<h3>Description</h3>

<p>Performs a Kruskal-Wallis rank sum test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kruskalTest(x, ...)

## Default S3 method:
kruskalTest(x, g, dist = c("Chisquare", "KruskalWallis", "FDist"), ...)

## S3 method for class 'formula'
kruskalTest(
  formula,
  data,
  subset,
  na.action,
  dist = c("Chisquare", "KruskalWallis", "FDist"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kruskalTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="kruskalTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="kruskalTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="kruskalTest_+3A_dist">dist</code></td>
<td>
<p>the test distribution. Defaults's to <code>"Chisquare"</code>.</p>
</td></tr>
<tr><td><code id="kruskalTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="kruskalTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="kruskalTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kruskalTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For one-factorial designs with non-normally distributed
residuals the Kruskal-Wallis rank sum test can be performed to test
the H<code class="reqn">_0: F_1(x) = F_2(x) = \ldots = F_k(x)</code> against
the H<code class="reqn">_\mathrm{A}: F_i (x) \ne F_j(x)~ (i \ne j)</code> with at least
one strict inequality.
</p>
<p>Let <code class="reqn">R_{ij}</code> be the joint rank of <code class="reqn">X_{ij}</code>,
with <code class="reqn">R_{(1)(1)} = 1, \ldots, R_{(n)(n)} = N, ~~ N = \sum_{i=1}^k n_i</code>,
The test statistic is calculated as
</p>
<p style="text-align: center;"><code class="reqn">
 H = \sum_{i=1}^k n_i \left(\bar{R}_i - \bar{R}\right) / \sigma_R,
</code>
</p>

<p>with the mean rank of the <code class="reqn">i</code>-th group
</p>
<p style="text-align: center;"><code class="reqn">
\bar{R}_i = \sum_{j = 1}^{n_{i}} R_{ij} / n_i,
</code>
</p>

<p>the expected value
</p>
<p style="text-align: center;"><code class="reqn">
 \bar{R} = \left(N +1\right) / 2
</code>
</p>

<p>and the expected variance as
</p>
<p style="text-align: center;"><code class="reqn">
 \sigma_R^2 = N \left(N + 1\right) / 12.
</code>
</p>

<p>In case of ties the statistic <code class="reqn">H</code> is divided by
<code class="reqn">\left(1 - \sum_{i=1}^r t_i^3 - t_i \right) / \left(N^3 - N\right)</code>
</p>
<p>According to Conover and Imam (1981), the statistic <code class="reqn">H</code> is related
to the <code class="reqn">F</code>-quantile as
</p>
<p style="text-align: center;"><code class="reqn">
 F = \frac{H / \left(k - 1\right)}
     {\left(N - 1 - H\right) / \left(N - k\right)}
</code>
</p>

<p>which is equivalent to a one-way ANOVA F-test using rank transformed data
(see examples).
</p>
<p>The function provides three different <code>dist</code> for <code class="reqn">p</code>-value estimation:
</p>

<dl>
<dt>Chisquare</dt><dd><p><code class="reqn">p</code>-values are computed from the <code><a href="stats.html#topic+Chisquare">Chisquare</a></code>
distribution with <code class="reqn">v = k - 1</code> degree of freedom.</p>
</dd>
<dt>KruskalWallis</dt><dd><p><code class="reqn">p</code>-values are computed from the
<code><a href="SuppDists.html#topic+pKruskalWallis">pKruskalWallis</a></code> of the package <span class="pkg">SuppDists</span>.</p>
</dd>
<dt>FDist</dt><dd><p><code class="reqn">p</code>-values are computed from the <code><a href="stats.html#topic+FDist">FDist</a></code> distribution
with <code class="reqn">v_1 = k-1, ~ v_2 = N -k</code> degree of freedom.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Conover, W.J., Iman, R.L. (1981) Rank Transformations as a Bridge
Between Parametric and Nonparametric Statistics.
<em>Am Stat</em> <b>35</b>, 124&ndash;129.
</p>
<p>Kruskal, W.H., Wallis, W.A. (1952) Use of Ranks in One-Criterion Variance Analysis.
<em>J Am Stat Assoc</em> <b>47</b>, 583&ndash;621.
</p>
<p>Sachs, L. (1997) <em>Angewandte Statistik</em>. Berlin: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code>, <code><a href="SuppDists.html#topic+pKruskalWallis">pKruskalWallis</a></code>,
<code><a href="stats.html#topic+Chisquare">Chisquare</a></code>, <code><a href="stats.html#topic+FDist">FDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hollander &amp; Wolfe (1973), 116.
## Mucociliary efficiency from the rate of removal of dust in normal
## subjects, subjects with obstructive airway disease, and subjects
## with asbestosis.
x &lt;- c(2.9, 3.0, 2.5, 2.6, 3.2) # normal subjects
y &lt;- c(3.8, 2.7, 4.0, 2.4)      # with obstructive airway disease
z &lt;- c(2.8, 3.4, 3.7, 2.2, 2.0) # with asbestosis
g &lt;- factor(x = c(rep(1, length(x)),
                   rep(2, length(y)),
                   rep(3, length(z))),
             labels = c("ns", "oad", "a"))
dat &lt;- data.frame(
   g = g,
   x = c(x, y, z))

## AD-Test
adKSampleTest(x ~ g, data = dat)

## BWS-Test
bwsKSampleTest(x ~ g, data = dat)

## Kruskal-Test
## Using incomplete beta approximation
kruskalTest(x ~ g, dat, dist="KruskalWallis")
## Using chisquare distribution
kruskalTest(x ~ g, dat, dist="Chisquare")

## Not run: 
## Check with kruskal.test from R stats
kruskal.test(x ~ g, dat)

## End(Not run)
## Using Conover's F
kruskalTest(x ~ g, dat, dist="FDist")

## Not run: 
## Check with aov on ranks
anova(aov(rank(x) ~ g, dat))
## Check with oneway.test
oneway.test(rank(x) ~ g, dat, var.equal = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='kwAllPairsConoverTest'>Conover's All-Pairs Rank Comparison Test</h2><span id='topic+kwAllPairsConoverTest'></span><span id='topic+kwAllPairsConoverTest.default'></span><span id='topic+kwAllPairsConoverTest.formula'></span>

<h3>Description</h3>

<p>Performs Conover's non-parametric all-pairs comparison test
for Kruskal-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwAllPairsConoverTest(x, ...)

## Default S3 method:
kwAllPairsConoverTest(
  x,
  g,
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
kwAllPairsConoverTest(
  formula,
  data,
  subset,
  na.action,
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwAllPairsConoverTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="kwAllPairsConoverTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="kwAllPairsConoverTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="kwAllPairsConoverTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="kwAllPairsConoverTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="kwAllPairsConoverTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="kwAllPairsConoverTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kwAllPairsConoverTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with non-normally distributed residuals Conover's non-parametric test
can be performed. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: \mu_i(x) = \mu_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: \mu_i(x) \ne \mu_j(x), ~~ i \ne j</code>.
</p>
<p>If <code>p.adjust.method == "single-step"</code> the p-values are computed
from the studentized range distribution. Otherwise,
the p-values are computed from the t-distribution using
any of the p-adjustment methods as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Conover, W. J, Iman,  R. L. (1979) <em>On multiple-comparisons
procedures</em>, Tech. Rep. LA-7677-MS, Los Alamos Scientific Laboratory.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Tukey">Tukey</a></code>, <code><a href="stats.html#topic+TDist">TDist</a></code>,
<code><a href="stats.html#topic+p.adjust">p.adjust</a></code>, <code><a href="#topic+kruskalTest">kruskalTest</a></code>,
<code><a href="#topic+kwAllPairsDunnTest">kwAllPairsDunnTest</a></code>, <code><a href="#topic+kwAllPairsNemenyiTest">kwAllPairsNemenyiTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set InsectSprays
## Global test
kruskalTest(count ~ spray, data = InsectSprays)

## Conover's all-pairs comparison test
## single-step means Tukey's p-adjustment
ans &lt;- kwAllPairsConoverTest(count ~ spray, data = InsectSprays,
                             p.adjust.method = "single-step")
summary(ans)

## Dunn's all-pairs comparison test
ans &lt;- kwAllPairsDunnTest(count ~ spray, data = InsectSprays,
                             p.adjust.method = "bonferroni")
summary(ans)

## Nemenyi's all-pairs comparison test
ans &lt;- kwAllPairsNemenyiTest(count ~ spray, data = InsectSprays)
summary(ans)
</code></pre>

<hr>
<h2 id='kwAllPairsDunnTest'>Dunn's All-Pairs Rank Comparison Test</h2><span id='topic+kwAllPairsDunnTest'></span><span id='topic+kwAllPairsDunnTest.default'></span><span id='topic+default'></span><span id='topic+kwAllPairsDunnTest.formula'></span>

<h3>Description</h3>

<p>Performs Dunn's non-parametric all-pairs comparison test
for Kruskal-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwAllPairsDunnTest(x, ...)

## Default S3 method:
kwAllPairsDunnTest(x, g, p.adjust.method = p.adjust.methods, ...)

## S3 method for class 'formula'
kwAllPairsDunnTest(
  formula,
  data,
  subset,
  na.action,
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwAllPairsDunnTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="kwAllPairsDunnTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="kwAllPairsDunnTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="kwAllPairsDunnTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="kwAllPairsDunnTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="kwAllPairsDunnTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="kwAllPairsDunnTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kwAllPairsDunnTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with non-normally distributed residuals Dunn's non-parametric test
can be performed. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: \mu_i(x) = \mu_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: \mu_i(x) \ne \mu_j(x), ~~ i \ne j</code>.
</p>
<p>The p-values are computed from the standard normal distribution using
any of the p-adjustment methods as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
Originally, Dunn (1964) proposed Bonferroni's p-adjustment method.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Dunn, O. J. (1964) Multiple comparisons using rank sums,
<em>Technometrics</em> <em>6</em>, 241&ndash;252.
</p>
<p>Siegel, S., Castellan Jr., N. J. (1988) <em>Nonparametric Statistics
for The Behavioral Sciences</em>. New York: McGraw-Hill.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>,
<code><a href="#topic+kruskalTest">kruskalTest</a></code>,
<code><a href="#topic+kwAllPairsConoverTest">kwAllPairsConoverTest</a></code>, <code><a href="#topic+kwAllPairsNemenyiTest">kwAllPairsNemenyiTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set InsectSprays
## Global test
kruskalTest(count ~ spray, data = InsectSprays)

## Conover's all-pairs comparison test
## single-step means Tukey's p-adjustment
ans &lt;- kwAllPairsConoverTest(count ~ spray, data = InsectSprays,
                             p.adjust.method = "single-step")
summary(ans)

## Dunn's all-pairs comparison test
ans &lt;- kwAllPairsDunnTest(count ~ spray, data = InsectSprays,
                             p.adjust.method = "bonferroni")
summary(ans)

## Nemenyi's all-pairs comparison test
ans &lt;- kwAllPairsNemenyiTest(count ~ spray, data = InsectSprays)
summary(ans)
</code></pre>

<hr>
<h2 id='kwAllPairsNemenyiTest'>Nemenyi's All-Pairs Rank Comparison Test</h2><span id='topic+kwAllPairsNemenyiTest'></span><span id='topic+kwAllPairsNemenyiTest.default'></span><span id='topic+kwAllPairsNemenyiTest.formula'></span>

<h3>Description</h3>

<p>Performs Nemenyi's non-parametric all-pairs comparison test
for Kruskal-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwAllPairsNemenyiTest(x, ...)

## Default S3 method:
kwAllPairsNemenyiTest(x, g, dist = c("Tukey", "Chisquare"), ...)

## S3 method for class 'formula'
kwAllPairsNemenyiTest(
  formula,
  data,
  subset,
  na.action,
  dist = c("Tukey", "Chisquare"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwAllPairsNemenyiTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="kwAllPairsNemenyiTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="kwAllPairsNemenyiTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="kwAllPairsNemenyiTest_+3A_dist">dist</code></td>
<td>
<p>the distribution for determining the p-value.
Defaults to <code>"Tukey"</code>.</p>
</td></tr>
<tr><td><code id="kwAllPairsNemenyiTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="kwAllPairsNemenyiTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="kwAllPairsNemenyiTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kwAllPairsNemenyiTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with non-normally distributed residuals Nemenyi's non-parametric test
can be performed. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: \theta_i(x) = \theta_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: \theta_i(x) \ne \theta_j(x), ~~ i \ne j</code>.
</p>
<p>Let <code class="reqn">R_{ij}</code> be the rank of <code class="reqn">X_{ij}</code>,
where <code class="reqn">X_{ij}</code> is jointly ranked
from <code class="reqn">\left\{1, 2, \ldots, N \right\}, ~~ N = \sum_{i=1}^k n_i</code>,
then the test statistic under the absence of ties is calculated as
</p>
<p style="text-align: center;"><code class="reqn">
t_{ij} = \frac{\bar{R}_j - \bar{R}_i}
{\sigma_R \left(1/n_i + 1/n_j\right)^{1/2}} \qquad \left(i \ne j\right),
</code>
</p>

<p>with <code class="reqn">\bar{R}_j, \bar{R}_i</code> the mean rank of the
<code class="reqn">i</code>-th and <code class="reqn">j</code>-th group and the expected variance as
</p>
<p style="text-align: center;"><code class="reqn">
 \sigma_R^2 = N \left(N + 1\right) / 12.
</code>
</p>

<p>A pairwise difference is significant, if <code class="reqn">|t_{ij}|/\sqrt{2} &gt; q_{kv}</code>,
with <code class="reqn">k</code> the number of groups and <code class="reqn">v = \infty</code>
the degree of freedom.
</p>
<p>Sachs(1997) has given a modified approach for
Nemenyi's test in the presence of ties for <code class="reqn">N &gt; 6, k &gt; 4</code>
provided that the <code><a href="#topic+kruskalTest">kruskalTest</a></code> indicates significance:
In the presence of ties, the test statistic is
corrected according to <code class="reqn">\hat{t}_{ij} = t_{ij} / C</code>, with
</p>
<p style="text-align: center;"><code class="reqn">
  C = 1 - \frac{\sum_{i=1}^r t_i^3 - t_i}{N^3 - N}.
</code>
</p>

<p>The function provides two different <code>dist</code>
for <code class="reqn">p</code>-value estimation:
</p>

<dl>
<dt>Tukey</dt><dd><p>The <code class="reqn">p</code>-values are computed from the studentized
range distribution (alias <code><a href="stats.html#topic+Tukey">Tukey</a></code>),
<code class="reqn">\mathrm{Pr} \left\{ t_{ij} \sqrt{2} \ge q_{k\infty\alpha} | mathrm{H} \right\} = \alpha</code>.</p>
</dd>
<dt>Chisquare</dt><dd><p>The <code class="reqn">p</code>-values are computed from the
<code><a href="stats.html#topic+Chisquare">Chisquare</a></code> distribution with <code class="reqn">v = k - 1</code> degree
of freedom.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Nemenyi, P. (1963) <em>Distribution-free Multiple Comparisons</em>.
Ph.D. thesis, Princeton University.
</p>
<p>Sachs, L. (1997) <em>Angewandte Statistik</em>. Berlin: Springer.
</p>
<p>Wilcoxon, F., Wilcox, R. A. (1964)
<em>Some rapid approximate statistical procedures</em>.
Pearl River: Lederle Laboratories.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Tukey">Tukey</a></code>, <code><a href="stats.html#topic+Chisquare">Chisquare</a></code>,
<code><a href="stats.html#topic+p.adjust">p.adjust</a></code>, <code><a href="#topic+kruskalTest">kruskalTest</a></code>,
<code><a href="#topic+kwAllPairsDunnTest">kwAllPairsDunnTest</a></code>, <code><a href="#topic+kwAllPairsConoverTest">kwAllPairsConoverTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set InsectSprays
## Global test
kruskalTest(count ~ spray, data = InsectSprays)

## Conover's all-pairs comparison test
## single-step means Tukey's p-adjustment
ans &lt;- kwAllPairsConoverTest(count ~ spray, data = InsectSprays,
                             p.adjust.method = "single-step")
summary(ans)

## Dunn's all-pairs comparison test
ans &lt;- kwAllPairsDunnTest(count ~ spray, data = InsectSprays,
                             p.adjust.method = "bonferroni")
summary(ans)

## Nemenyi's all-pairs comparison test
ans &lt;- kwAllPairsNemenyiTest(count ~ spray, data = InsectSprays)
summary(ans)
</code></pre>

<hr>
<h2 id='kwManyOneConoverTest'>Conover's Many-to-One Rank Comparison Test</h2><span id='topic+kwManyOneConoverTest'></span><span id='topic+kwManyOneConoverTest.default'></span><span id='topic+kwManyOneConoverTest.formula'></span>

<h3>Description</h3>

<p>Performs Conover's non-parametric many-to-one comparison
test for Kruskal-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwManyOneConoverTest(x, ...)

## Default S3 method:
kwManyOneConoverTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
kwManyOneConoverTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwManyOneConoverTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="kwManyOneConoverTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="kwManyOneConoverTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="kwManyOneConoverTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="kwManyOneConoverTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="kwManyOneConoverTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="kwManyOneConoverTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="kwManyOneConoverTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kwManyOneConoverTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in an one-factorial layout with non-normally distributed
residuals Conover's non-parametric test can be performed.
Let there be <code class="reqn">k</code> groups including the control,
then the number of treatment levels is <code class="reqn">m = k - 1</code>.
Then <code class="reqn">m</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: \theta_0 = \theta_i</code> is tested in the two-tailed case against
A<code class="reqn">_i: \theta_0 \ne \theta_i, ~~ (1 \le i \le m)</code>.
</p>
<p>If <code>p.adjust.method == "single-step"</code> is selected,
the <code class="reqn">p</code>-values will be computed
from the multivariate <code class="reqn">t</code> distribution. Otherwise,
the <code class="reqn">p</code>-values are computed from the <code class="reqn">t</code>-distribution using
any of the <code class="reqn">p</code>-adjustment methods as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Conover, W. J, Iman,  R. L. (1979) <em>On multiple-comparisons
procedures</em>, Tech. Rep. LA-7677-MS, Los Alamos Scientific Laboratory.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>, <code><a href="stats.html#topic+TDist">TDist</a></code>, <code><a href="#topic+kruskalTest">kruskalTest</a></code>,
<code><a href="#topic+kwManyOneDunnTest">kwManyOneDunnTest</a></code>, <code><a href="#topic+kwManyOneNdwTest">kwManyOneNdwTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set PlantGrowth
## Global test
kruskalTest(weight ~ group, data = PlantGrowth)

## Conover's many-one comparison test
## single-step means p-value from multivariate t distribution
ans &lt;- kwManyOneConoverTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "single-step")
summary(ans)

## Conover's many-one comparison test
ans &lt;- kwManyOneConoverTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)

## Dunn's many-one comparison test
ans &lt;- kwManyOneDunnTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)

## Nemenyi's many-one comparison test
ans &lt;- kwManyOneNdwTest(weight ~ group, data = PlantGrowth,
                        p.adjust.method = "holm")
summary(ans)

## Many one U test
ans &lt;- manyOneUTest(weight ~ group, data = PlantGrowth,
                        p.adjust.method = "holm")
summary(ans)

## Chen Test
ans &lt;- chenTest(weight ~ group, data = PlantGrowth,
                    p.adjust.method = "holm")
summary(ans)
</code></pre>

<hr>
<h2 id='kwManyOneDunnTest'>Dunn's Many-to-One Rank Comparison Test</h2><span id='topic+kwManyOneDunnTest'></span><span id='topic+kwManyOneDunnTest.default'></span><span id='topic+kwManyOneDunnTest.formula'></span>

<h3>Description</h3>

<p>Performs Dunn's non-parametric many-to-one comparison
test for Kruskal-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwManyOneDunnTest(x, ...)

## Default S3 method:
kwManyOneDunnTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
kwManyOneDunnTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwManyOneDunnTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="kwManyOneDunnTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="kwManyOneDunnTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="kwManyOneDunnTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="kwManyOneDunnTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="kwManyOneDunnTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="kwManyOneDunnTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="kwManyOneDunnTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kwManyOneDunnTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in an one-factorial layout with non-normally distributed
residuals Dunn's non-parametric test can be performed.
Let there be <code class="reqn">k</code> groups including the control,
then the number of treatment levels is <code class="reqn">m = k - 1</code>.
Then <code class="reqn">m</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: \theta_0 = \theta_i</code> is tested in the two-tailed case against
A<code class="reqn">_i: \theta_0 \ne \theta_i, ~~ (1 \le i \le m)</code>.
</p>
<p>If <code>p.adjust.method == "single-step"</code> is selected,
the <code class="reqn">p</code>-values will be computed
from the multivariate normal distribution. Otherwise,
the <code class="reqn">p</code>-values are computed from the standard normal distribution using
any of the <code class="reqn">p</code>-adjustment methods as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Dunn, O. J. (1964) Multiple comparisons using rank sums,
<em>Technometrics</em> <em>6</em>, 241&ndash;252.
</p>
<p>Siegel, S., Castellan Jr., N. J. (1988) <em>Nonparametric Statistics
for The Behavioral Sciences</em>. New York: McGraw-Hill.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>, <code><a href="stats.html#topic+TDist">TDist</a></code>, <code><a href="#topic+kruskalTest">kruskalTest</a></code>,
<code><a href="#topic+kwManyOneConoverTest">kwManyOneConoverTest</a></code>, <code><a href="#topic+kwManyOneNdwTest">kwManyOneNdwTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set PlantGrowth
## Global test
kruskalTest(weight ~ group, data = PlantGrowth)

## Conover's many-one comparison test
## single-step means p-value from multivariate t distribution
ans &lt;- kwManyOneConoverTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "single-step")
summary(ans)

## Conover's many-one comparison test
ans &lt;- kwManyOneConoverTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)

## Dunn's many-one comparison test
ans &lt;- kwManyOneDunnTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)

## Nemenyi's many-one comparison test
ans &lt;- kwManyOneNdwTest(weight ~ group, data = PlantGrowth,
                        p.adjust.method = "holm")
summary(ans)

## Many one U test
ans &lt;- manyOneUTest(weight ~ group, data = PlantGrowth,
                        p.adjust.method = "holm")
summary(ans)

## Chen Test
ans &lt;- chenTest(weight ~ group, data = PlantGrowth,
                    p.adjust.method = "holm")
summary(ans)
</code></pre>

<hr>
<h2 id='kwManyOneNdwTest'>Nemenyi-Damico-Wolfe Many-to-One Rank Comparison Test</h2><span id='topic+kwManyOneNdwTest'></span><span id='topic+kwManyOneNdwTest.default'></span><span id='topic+kwManyOneNdwTest.formula'></span>

<h3>Description</h3>

<p>Performs Nemenyi-Damico-Wolfe non-parametric many-to-one comparison
test for Kruskal-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwManyOneNdwTest(x, ...)

## Default S3 method:
kwManyOneNdwTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
kwManyOneNdwTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwManyOneNdwTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="kwManyOneNdwTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="kwManyOneNdwTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="kwManyOneNdwTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="kwManyOneNdwTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="kwManyOneNdwTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="kwManyOneNdwTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="kwManyOneNdwTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kwManyOneNdwTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in an one-factorial layout with non-normally distributed
residuals the Nemenyi-Damico-Wolfe non-parametric test can be performed.
Let there be <code class="reqn">k</code> groups including the control,
then the number of treatment levels is <code class="reqn">m = k - 1</code>.
Then <code class="reqn">m</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: \theta_0 = \theta_i</code> is tested in the two-tailed case against
A<code class="reqn">_i: \theta_0 \ne \theta_i, ~~ (1 \le i \le m)</code>.
</p>
<p>If <code>p.adjust.method == "single-step"</code> is selected,
the <code class="reqn">p</code>-values will be computed
from the multivariate normal distribution. Otherwise,
the <code class="reqn">p</code>-values are computed from the standard normal distribution using
any of the <code class="reqn">p</code>-adjustment methods as included in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This function is essentially the same as <code><a href="#topic+kwManyOneDunnTest">kwManyOneDunnTest</a></code>, but
there is no tie correction included. Therefore, the implementation of
Dunn's test is superior, when ties are present.
</p>


<h3>References</h3>

<p>Damico, J. A., Wolfe, D. A. (1989) Extended tables of the exact distribution of
a rank statistic for treatments versus control multiple comparisons in one-way
layout designs, <em>Communications in Statistics - Theory and Methods</em> <b>18</b>,
3327&ndash;3353.
</p>
<p>Nemenyi, P. (1963) <em>Distribution-free Multiple Comparisons</em>,
Ph.D. thesis, Princeton University.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>, <code><a href="stats.html#topic+TDist">TDist</a></code>, <code><a href="#topic+kruskalTest">kruskalTest</a></code>,
<code><a href="#topic+kwManyOneDunnTest">kwManyOneDunnTest</a></code>, <code><a href="#topic+kwManyOneConoverTest">kwManyOneConoverTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set PlantGrowth
## Global test
kruskalTest(weight ~ group, data = PlantGrowth)

## Conover's many-one comparison test
## single-step means p-value from multivariate t distribution
ans &lt;- kwManyOneConoverTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "single-step")
summary(ans)

## Conover's many-one comparison test
ans &lt;- kwManyOneConoverTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)

## Dunn's many-one comparison test
ans &lt;- kwManyOneDunnTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)

## Nemenyi's many-one comparison test
ans &lt;- kwManyOneNdwTest(weight ~ group, data = PlantGrowth,
                        p.adjust.method = "holm")
summary(ans)

## Many one U test
ans &lt;- manyOneUTest(weight ~ group, data = PlantGrowth,
                        p.adjust.method = "holm")
summary(ans)

## Chen Test
ans &lt;- chenTest(weight ~ group, data = PlantGrowth,
                    p.adjust.method = "holm")
summary(ans)
</code></pre>

<hr>
<h2 id='leTest'>Testing against Ordered Alternatives (Le's Test)</h2><span id='topic+leTest'></span><span id='topic+leTest.default'></span><span id='topic+leTest.formula'></span>

<h3>Description</h3>

<p>Performs Le's test for testing against ordered alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leTest(x, ...)

## Default S3 method:
leTest(x, g, alternative = c("two.sided", "greater", "less"), ...)

## S3 method for class 'formula'
leTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="leTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="leTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="leTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="leTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="leTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="leTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="leTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis, H<code class="reqn">_0: \theta_1 = \theta_2 = \ldots = \theta_k</code>
is tested against a simple order hypothesis,
H<code class="reqn">_\mathrm{A}: \theta_1 \le \theta_2 \le \ldots \le
\theta_k,~\theta_1 &lt; \theta_k</code>.
</p>
<p>The p-values are estimated from the standard normal distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Le, C. T. (1988) A new rank test against ordered alternatives
in k-sample problems, <em>Biometrical Journal</em> <b>30</b>, 87&ndash;92.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='lsdTest'>Least Significant Difference Test</h2><span id='topic+lsdTest'></span><span id='topic+lsdTest.default'></span><span id='topic+lsdTest.formula'></span><span id='topic+lsdTest.aov'></span>

<h3>Description</h3>

<p>Performs the least significant difference all-pairs comparisons
test for normally distributed data with equal group variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsdTest(x, ...)

## Default S3 method:
lsdTest(x, g, ...)

## S3 method for class 'formula'
lsdTest(formula, data, subset, na.action, ...)

## S3 method for class 'aov'
lsdTest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsdTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="lsdTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="lsdTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="lsdTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="lsdTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="lsdTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="lsdTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals and equal variances
the least signifiant difference test can be performed
after a significant ANOVA F-test.
Let <code class="reqn">X_{ij}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization (<code class="reqn">1 \le j \le n_i</code>)
in the <code class="reqn">i</code>-th group (<code class="reqn">1 \le i \le k</code>). Furthermore, the total
sample size is <code class="reqn">N = \sum_{i=1}^k n_i</code>. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{ij}: \mu_i = \mu_j ~~ (i \ne j)</code> is tested against the alternative
A<code class="reqn">_{ij}: \mu_i \ne \mu_j</code> (two-tailed). Fisher's LSD all-pairs test
statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{ij} \frac{\bar{X}_i - \bar{X_j}}
 {s_{\mathrm{in}} \left(1/n_j + 1/n_i\right)^{1/2}}, ~~
 (i \ne j)
</code>
</p>

<p>with <code class="reqn">s^2_{\mathrm{in}}</code> the within-group ANOVA variance.
The null hypothesis is rejected if <code class="reqn">|t_{ij}| &gt; t_{v\alpha/2}</code>,
with <code class="reqn">v = N - k</code> degree of freedom. The p-values (two-tailed)
are computed from the <code><a href="stats.html#topic+TDist">TDist</a></code> distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>As there is no p-value adjustment included, this function is equivalent
to Fisher's protected LSD test, provided that the LSD test is
only applied after a significant one-way ANOVA F-test.
If one is interested in other types of LSD test (i.e.
with p-value adustment) see function <code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>.
</p>


<h3>References</h3>

<p>Sachs, L. (1997) <em>Angewandte Statistik</em>, New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code>, <code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts)
anova(fit)

## also works with fitted objects of class aov
res &lt;- lsdTest(fit)
summary(res)
summaryGroup(res)

</code></pre>

<hr>
<h2 id='mackWolfeTest'>Mack-Wolfe Test for Umbrella Alternatives</h2><span id='topic+mackWolfeTest'></span><span id='topic+mackWolfeTest.default'></span><span id='topic+mackWolfeTest.formula'></span>

<h3>Description</h3>

<p>Performs Mack-Wolfe non-parametric test for umbrella alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mackWolfeTest(x, ...)

## Default S3 method:
mackWolfeTest(x, g, p = NULL, nperm = 1000, ...)

## S3 method for class 'formula'
mackWolfeTest(formula, data, subset, na.action, p = NULL, nperm = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mackWolfeTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="mackWolfeTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="mackWolfeTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="mackWolfeTest_+3A_p">p</code></td>
<td>
<p>the a-priori known peak as an ordinal number of the treatment
group including the zero dose level, i.e. <code class="reqn">p = \{1, \ldots, k\}</code>.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mackWolfeTest_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the assymptotic permutation test.
Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="mackWolfeTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="mackWolfeTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="mackWolfeTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="mackWolfeTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In dose-finding studies one may assume an increasing treatment
effect with increasing dose level. However, the test
subject may actually succumb to toxic effects at high doses,
which leads to decresing treatment effects.
</p>
<p>The scope of the Mack-Wolfe Test is to test for umbrella alternatives
for either a known or unknown point <code class="reqn">p</code> (i.e. dose-level),
where the peak (umbrella point) is present.
</p>
<p>H<code class="reqn">_i: \theta_0 = \theta_i = \ldots = \theta_k</code> is tested
against the alternative A<code class="reqn">_i: \theta_1 \le \ldots \theta_p \ge
\theta_k</code> for some <code class="reqn">p</code>, with at least one strict inequality.
</p>
<p>If <code>p = NULL</code> (peak unknown), the upper-tail <code class="reqn">p</code>-value is computed
via an asymptotic bootstrap permutation test.
</p>
<p>If an integer value for <code>p</code> is given (peak known), the
upper-tail <code class="reqn">p</code>-value is computed from the standard normal
distribution (<code><a href="stats.html#topic+pnorm">pnorm</a></code>).
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>One may increase the number of permutations to e.g. <code>nperm = 10000</code>
in order to get more precise p-values. However, this will be on
the expense of computational time.
</p>


<h3>References</h3>

<p>Chen, I. Y. (1991) Notes on the Mack-Wolfe and Chen-Wolfe
Tests for Umbrella Alternatives, <em>Biom. J.</em> <b>33</b>, 281&ndash;290.
</p>
<p>Mack, G. A., Wolfe, D. A. (1981) K-sample rank tests for
umbrella alternatives, <em>J. Amer. Statist. Assoc.</em> <b>76</b>, 175&ndash;181.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pnorm">pnorm</a></code>, <code><a href="base.html#topic+sample">sample</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Table 6.10 of Hollander and Wolfe (1999).
## Plates with Salmonella bacteria of strain TA98 were exposed to
## various doses of Acid Red 114 (in mu g / ml).
## The data are the numbers of visible revertant colonies on 12 plates.
## Assume a peak at D333 (i.e. p = 3).
x &lt;- c(22, 23, 35, 60, 59, 54, 98, 78, 50, 60, 82, 59, 22, 44,
  33, 23, 21, 25)
g &lt;- as.ordered(rep(c(0, 100, 333, 1000, 3333, 10000), each=3))
plot(x ~ g)
mackWolfeTest(x=x, g=g, p=3)

</code></pre>

<hr>
<h2 id='Mandel-h'>Mandel's h Distribution</h2><span id='topic+Mandel-h'></span><span id='topic+qmandelh'></span><span id='topic+pmandelh'></span>

<h3>Description</h3>

<p>Distribution function and quantile function
for Mandel's h distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmandelh(p, k, lower.tail = TRUE, log.p = FALSE)

pmandelh(q, k, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mandel-h_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_k">k</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default),
probabilities are <code class="reqn">P[X \leq x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
are given as log(p).</p>
</td></tr>
<tr><td><code id="Mandel-h_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pmandelh</code> gives the distribution function and
<code>qmandelh</code> gives the quantile function.
</p>


<h3>Source</h3>

<p>The code for <code>pmandelh</code> was taken from:<br />
Stephen L R Ellison. (2017). metRology: Support for Metrological
Applications. R package version 0.9-26-2.
<a href="https://CRAN.R-project.org/package=metRology">https://CRAN.R-project.org/package=metRology</a>
</p>


<h3>References</h3>

<p>Practice E 691 (2005) <em>Standard Practice for
Conducting an Interlaboratory Study to Determine the
Precision of a Test Method</em>, ASTM International.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mandelhTest">mandelhTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## We need a two-sided upper-tail quantile
qmandelh(p = 0.005/2, k = 7, lower.tail=FALSE)
</code></pre>

<hr>
<h2 id='Mandel-k'>Mandel's k Distribution</h2><span id='topic+Mandel-k'></span><span id='topic+qmandelk'></span><span id='topic+pmandelk'></span>

<h3>Description</h3>

<p>Distribution function and quantile function
for Mandel's k distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmandelk(p, k, n, lower.tail = TRUE, log.p = FALSE)

pmandelk(q, k, n, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mandel-k_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_k">k</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_n">n</code></td>
<td>
<p>number of replicates per group.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default),
probabilities are <code class="reqn">P[X \leq x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities
are given as log(p).</p>
</td></tr>
<tr><td><code id="Mandel-k_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pmandelk</code> gives the distribution function and
<code>qmandelk</code> gives the quantile function.
</p>


<h3>Source</h3>

<p>The code for <code>pmandelk</code> was taken from:<br />
Stephen L R Ellison. (2017). metRology: Support for Metrological
Applications. R package version 0.9-26-2.
<a href="https://CRAN.R-project.org/package=metRology">https://CRAN.R-project.org/package=metRology</a>
</p>


<h3>Note</h3>

<p>The functions are only appropriate for balanced designs.
</p>


<h3>References</h3>

<p>Practice E 691 (2005) <em>Standard Practice for
Conducting an Interlaboratory Study to Determine the
Precision of a Test Method</em>, ASTM International.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mandelkTest">mandelkTest</a></code>
</p>
<p><code><a href="#topic+pmandelh">pmandelh</a></code>, <code><a href="#topic+qmandelh">qmandelh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qmandelk(0.005, 7, 3, lower.tail=FALSE)
</code></pre>

<hr>
<h2 id='mandelhTest'>Mandel's h Test According to E 691 ASTM</h2><span id='topic+mandelhTest'></span><span id='topic+mandelhTest.default'></span><span id='topic+mandelhTest.formula'></span>

<h3>Description</h3>

<p>The function calculates the
consistency statistics h and corresponding
p-values for each group (lab) according to
Practice E 691 ASTM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mandelhTest(x, ...)

## Default S3 method:
mandelhTest(x, g, ...)

## S3 method for class 'formula'
mandelhTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mandelhTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="mandelhTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="mandelhTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="mandelhTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="mandelhTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="mandelhTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="mandelhTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>"mandel"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string
indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantiles of Mandel's statistic.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing
the alternative hypothesis.</p>
</dd>
<dt>grouplev</dt><dd><p>a character vector describing the
levels of the groups.</p>
</dd>
<dt>nrofrepl</dt><dd><p>the number of replicates for each group.</p>
</dd>
</dl>



<h3>References</h3>

<p>Practice E 691 (2005) <em>Standard Practice for
Conducting an Interlaboratory Study to Determine the
Precision of a Test Method</em>, ASTM International.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmandelh">qmandelh</a></code> <code><a href="#topic+pmandelh">pmandelh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pentosan)
mandelhTest(value ~ lab, data=Pentosan, subset=(material == "A"))
</code></pre>

<hr>
<h2 id='mandelkTest'>Mandel's k Test According to E 691 ASTM</h2><span id='topic+mandelkTest'></span><span id='topic+mandelkTest.default'></span><span id='topic+mandelkTest.formula'></span>

<h3>Description</h3>

<p>The function calculates the
consistency statistics k and corresponding
p-values for each group (lab) according to Practice E 691 ASTM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mandelkTest(x, ...)

## Default S3 method:
mandelkTest(x, g, ...)

## S3 method for class 'formula'
mandelkTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mandelkTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="mandelkTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="mandelkTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="mandelkTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="mandelkTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="mandelkTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="mandelkTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>"mandel"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string
indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantiles of Mandel's statistic.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing
the alternative hypothesis.</p>
</dd>
<dt>grouplev</dt><dd><p>a character vector describing the
levels of the groups.</p>
</dd>
<dt>nrofrepl</dt><dd><p>the number of replicates for each group.</p>
</dd>
</dl>



<h3>References</h3>

<p>Practice E 691 (2005) <em>Standard Practice for
Conducting an Interlaboratory Study to Determine the
Precision of a Test Method</em>, ASTM International.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmandelk">qmandelk</a></code> <code><a href="#topic+pmandelk">pmandelk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pentosan)
mandelkTest(value ~ lab, data=Pentosan, subset=(material == "A"))
</code></pre>

<hr>
<h2 id='manyOneUTest'>Multiple Comparisons with One Control (U-test)</h2><span id='topic+manyOneUTest'></span><span id='topic+manyOneUTest.default'></span><span id='topic+manyOneUTest.formula'></span>

<h3>Description</h3>

<p>Performs pairwise comparisons of multiple group levels with
one control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manyOneUTest(x, ...)

## Default S3 method:
manyOneUTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
manyOneUTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manyOneUTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="manyOneUTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="manyOneUTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="manyOneUTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="manyOneUTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>)</p>
</td></tr>
<tr><td><code id="manyOneUTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="manyOneUTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="manyOneUTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="manyOneUTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions performs Wilcoxon, Mann and Whitney's U-test
for a one factorial design where each factor level is tested against
one control (<code class="reqn">m = k -1</code> tests). As the data are re-ranked
for each comparison, this test is only suitable for
balanced (or almost balanced) experimental designs.
</p>
<p>For the two-tailed test and <code>p.adjust.method = "single-step"</code>
the multivariate normal distribution is used for controlling
Type 1 error and to calculate p-values. Otherwise,
the p-values are calculated from the standard normal distribution
with any latter p-adjustment as available by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>OECD (ed. 2006) <em>Current approaches in the statistical analysis
of ecotoxicity data: A guidance to application</em>, OECD Series
on testing and assessment, No. 54.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>, <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>, <code><a href="stats.html#topic+Normal">Normal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set PlantGrowth
## Global test
kruskalTest(weight ~ group, data = PlantGrowth)

## Conover's many-one comparison test
## single-step means p-value from multivariate t distribution
ans &lt;- kwManyOneConoverTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "single-step")
summary(ans)

## Conover's many-one comparison test
ans &lt;- kwManyOneConoverTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)

## Dunn's many-one comparison test
ans &lt;- kwManyOneDunnTest(weight ~ group, data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)

## Nemenyi's many-one comparison test
ans &lt;- kwManyOneNdwTest(weight ~ group, data = PlantGrowth,
                        p.adjust.method = "holm")
summary(ans)

## Many one U test
ans &lt;- manyOneUTest(weight ~ group, data = PlantGrowth,
                        p.adjust.method = "holm")
summary(ans)

## Chen Test
ans &lt;- chenTest(weight ~ group, data = PlantGrowth,
                    p.adjust.method = "holm")
summary(ans)
</code></pre>

<hr>
<h2 id='mrrTest'>Madhava Rao-Raghunath Test for Testing Treatment vs. Control</h2><span id='topic+mrrTest'></span><span id='topic+mrrTest.default'></span><span id='topic+mrrTest.formula'></span>

<h3>Description</h3>

<p>The function has implemented the nonparametric test of
Madhava Rao and Raghunath (2016) for testing paired two-samples
for symmetry. The null hypothesis <code class="reqn">H: F(x,y) = F(y,x)</code>
is tested against the alternative <code class="reqn">A: F(x,y) \ne F(y,x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrrTest(x, ...)

## Default S3 method:
mrrTest(x, y = NULL, m = NULL, ...)

## S3 method for class 'formula'
mrrTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrrTest_+3A_x">x</code></td>
<td>
<p>numeric vector of data values. Non-finite (e.g., infinite or missing) values will be omitted.</p>
</td></tr>
<tr><td><code id="mrrTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="mrrTest_+3A_y">y</code></td>
<td>
<p>an optional numeric vector of data values:
as with x non-finite values will be omitted.</p>
</td></tr>
<tr><td><code id="mrrTest_+3A_m">m</code></td>
<td>
<p>numeric, optional integer number, whereas <code class="reqn">n = k m</code> needs to be
full filled.</p>
</td></tr>
<tr><td><code id="mrrTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="mrrTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="mrrTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="mrrTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X_i</code> and <code class="reqn">Y_i, ~ i \le n</code> denote
continuous variables that were observed
on the same <code class="reqn">i</code>th test item (e.g. patient)
with <code class="reqn">i = 1, \ldots n</code>. Let
</p>
<p style="text-align: center;"><code class="reqn">
  U_i = X_i + Y_i \qquad V_i = X_i - Y_i
</code>
</p>

<p>Let <code class="reqn">U_{(i)}</code> be the <code class="reqn">i</code>th order statistic,
<code class="reqn">U_{(1)} \le U_{(2)} \le \ldots U_{(n)}</code> and <code class="reqn">k</code> the
number of clusters, with the condition:
</p>
<p style="text-align: center;"><code class="reqn">
 n = k ~ m.
</code>
</p>

<p>Further, let the divider denote <code class="reqn">d_0 = -\infty</code>, <code class="reqn">d_k = \infty</code>, and else
</p>
<p style="text-align: center;"><code class="reqn">
 d_j = \frac{ U_{(jm)} +  U_{(jm+1)} }{2}, ~ 1 \le j \le k -1
</code>
</p>

<p>The two counts are
</p>
<p style="text-align: center;"><code class="reqn">
 n_j^{+} = \left\{
           \begin{array}{lr}
           1 &amp; \mathrm{if}~ d_{j-1} &lt; u_i &lt; d_j, v_i &gt; 0 \\
           0 &amp;
           \end{array}
           \right.
</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
 n_j^{-} = \left\{
           \begin{array}{lr}
           1 &amp; \mathrm{if}~ d_{j-1} &lt; u_i &lt; d_j, v_i \le 0 \\
           0 &amp;
           \end{array}
           \right.
</code>
</p>

<p>The test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
 M = \sum_{j = 1}^k \frac{\left(n_j^{+} - n_j^{-}\right)^2}
                         {m}
</code>
</p>

<p>The exact p-values for <code class="reqn">5 \le n \le 30</code> are taken from an
internal look-up table. The exact p-values were taken
from Table 7, Appendix B  of Madhava Rao and Raghunath (2016).
</p>
<p>If <code>m = NULL</code> the function uses <code class="reqn">n = m</code> for
all prime numbers, otherwise it tries to find an value for
m in such a way, that for <code class="reqn">k = n / m</code> all variables
are integer.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function returns an error code if a value for <code>m</code>
is provided  that does not lead to an integer of the ratio
<code class="reqn">k = n /m</code>.
</p>
<p>The function also returns an error code, if a tabulated
value for given <code class="reqn">n</code>, <code class="reqn">m</code> and calculated <code class="reqn">M</code>
can not be found in the look-up table.
</p>


<h3>References</h3>

<p>Madhava Rao, K.S., Ragunath, M. (2016) A Simple Nonparametric Test
for Testing Treatment Versus Control. <em>J Stat Adv Theory Appl</em> <b>16</b>,
133–162. <a href="https://doi.org/10.18642/jsata_7100121717">doi:10.18642/jsata_7100121717</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Madhava Rao and Raghunath (2016), p. 151
## Inulin clearance of living donors
## and recipients of their kidneys
x &lt;- c(61.4, 63.3, 63.7, 80.0, 77.3, 84.0, 105.0)
y &lt;- c(70.8, 89.2, 65.8, 67.1, 87.3, 85.1, 88.1)
mrrTest(x, y)

## formula method
## Student's Sleep Data
mrrTest(extra ~ group, data = sleep)

</code></pre>

<hr>
<h2 id='MTest'>Extended One-Sided Studentised Range Test</h2><span id='topic+MTest'></span><span id='topic+MTest.default'></span><span id='topic+MTest.formula'></span><span id='topic+MTest.aov'></span>

<h3>Description</h3>

<p>Performs Nashimoto-Wright's extended
one-sided studentised range
test against an ordered alternative for normal data
with equal variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTest(x, ...)

## Default S3 method:
MTest(x, g, alternative = c("greater", "less"), ...)

## S3 method for class 'formula'
MTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  ...
)

## S3 method for class 'aov'
MTest(x, alternative = c("greater", "less"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="MTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="MTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="MTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="MTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="MTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="MTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="MTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure uses the property of a simple order,
<code class="reqn">\theta_m' - \mu_m \le \mu_j - \mu_i \le \mu_l' - \mu_l
\qquad (l \le i \le m~\mathrm{and}~ m' \le j \le l')</code>.
The null hypothesis H<code class="reqn">_{ij}: \mu_i = \mu_j</code> is tested against
the alternative A<code class="reqn">_{ij}: \mu_i &lt; \mu_j</code> for any
<code class="reqn">1 \le i &lt; j \le k</code>.
</p>
<p>The all-pairs comparisons test statistics for a balanced design are
</p>
<p style="text-align: center;"><code class="reqn">
 \hat{h}_{ij} = \max_{i \le m &lt; m' \le j} \frac{\left(\bar{x}_{m'} - \bar{x}_m \right)}
 {s_{\mathrm{in}} / \sqrt{n}},
</code>
</p>

<p>with <code class="reqn">n = n_i; ~ N = \sum_i^k n_i ~~ (1 \le i \le k)</code>, <code class="reqn">\bar{x}_i</code> the arithmetic mean of the <code class="reqn">i</code>th group,
and <code class="reqn">s_{\mathrm{in}}^2</code> the within ANOVA variance. The null hypothesis is rejected,
if <code class="reqn">\hat{h} &gt; h_{k,\alpha,v}</code>, with <code class="reqn">v = N - k</code>
degree of freedom.
</p>
<p>For the unbalanced case with moderate imbalance the test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
 \hat{h}_{ij} = \max_{i \le m &lt; m' \le j} \frac{\left(\bar{x}_{m'} - \bar{x}_m \right)}
 {s_{\mathrm{in}} \left(1/n_m + 1/n_{m'}\right)^{1/2}},
</code>
</p>

<p>The null hypothesis is rejected, if <code class="reqn">\hat{h}_{ij} &gt; h_{k,\alpha,v} / \sqrt{2}</code>.
</p>
<p>The function does not return p-values. Instead the critical h-values
as given in the tables of Hayter (1990) for <code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the number of groups (<code class="reqn">k</code>) and
the degree of freedoms (<code class="reqn">v</code>).
</p>


<h3>Value</h3>


<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>


<h3>Note</h3>

<p>The function will give a warning for the unbalanced case and returns the
critical value <code class="reqn">h_{k,\alpha,\infty} / \sqrt{2}</code>.
</p>


<h3>References</h3>

<p>Hayter, A. J.(1990) A One-Sided Studentised Range
Test for Testing Against a Simple Ordered Alternative,
<em>Journal of the American Statistical Association</em>
<b>85</b>, 778&ndash;785.
</p>
<p>Nashimoto, K., Wright, F.T., (2005) Multiple comparison procedures
for detecting differences in simply ordered means.
<em>Comput. Statist. Data Anal.</em> <b>48</b>, 291&ndash;306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+osrtTest">osrtTest</a></code>, <code><a href="#topic+NPMTest">NPMTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
md &lt;- aov(weight ~ group, PlantGrowth)
anova(md)
osrtTest(md)
MTest(md)
</code></pre>

<hr>
<h2 id='normalScoresAllPairsTest'>Lu-Smith All-Pairs Comparison Normal Scores Test</h2><span id='topic+normalScoresAllPairsTest'></span><span id='topic+normalScoresAllPairsTest.default'></span><span id='topic+normalScoresAllPairsTest.formula'></span>

<h3>Description</h3>

<p>Performs Lu-Smith all-pairs comparison
normal scores test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalScoresAllPairsTest(x, ...)

## Default S3 method:
normalScoresAllPairsTest(
  x,
  g,
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
normalScoresAllPairsTest(
  formula,
  data,
  subset,
  na.action,
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalScoresAllPairsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="normalScoresAllPairsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="normalScoresAllPairsTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="normalScoresAllPairsTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="normalScoresAllPairsTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="normalScoresAllPairsTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="normalScoresAllPairsTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="normalScoresAllPairsTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with non-normally distributed residuals Lu and Smith's
normal scores transformation can be used prior to
an all-pairs comparison test. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: F_i(x) = F_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: F_i(x) \ne F_j(x), ~~ i \ne j</code>.
For <code>p.adjust.method = "single-step"</code> the
Tukey's studentized range distribution is used to calculate
p-values (see <code><a href="stats.html#topic+Tukey">Tukey</a></code>). Otherwise, the
t-distribution is used for the calculation of p-values
with a latter p-value adjustment as
performed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Lu, H., Smith, P. (1979) Distribution of normal scores statistic
for nonparametric one-way analysis of variance.
<em>Journal of the American Statistical Association</em> <b>74</b>, 715&ndash;722.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalScoresTest">normalScoresTest</a></code>, <code><a href="#topic+normalScoresManyOneTest">normalScoresManyOneTest</a></code>, <code><a href="SuppDists.html#topic+normOrder">normOrder</a></code>.
</p>

<hr>
<h2 id='normalScoresManyOneTest'>Lu-Smith Many-One Comparisons Normal Scores Test</h2><span id='topic+normalScoresManyOneTest'></span><span id='topic+normalScoresManyOneTest.default'></span><span id='topic+normalScoresManyOneTest.formula'></span>

<h3>Description</h3>

<p>Performs Lu-Smith multiple comparison
normal scores test with one control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalScoresManyOneTest(x, ...)

## Default S3 method:
normalScoresManyOneTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
normalScoresManyOneTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalScoresManyOneTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="normalScoresManyOneTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="normalScoresManyOneTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="normalScoresManyOneTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="normalScoresManyOneTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="normalScoresManyOneTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="normalScoresManyOneTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="normalScoresManyOneTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="normalScoresManyOneTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons in an one-factorial layout
with non-normally distributed residuals Lu and Smith's
normal scores transformation can be used prior to
a many-to-one comparison test. A total of <code class="reqn">m = k-1</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{i}: F_0(x) = F_i(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{i}: F_0(x) \ne F_i(x), ~~ 1 \le i \le k-1</code>.
For <code>p.adjust.method = "single-step"</code> the
multivariate t distribution is used to calculate
p-values (see <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>). Otherwise, the
t-distribution is used for the calculation of p-values
with a latter p-value adjustment as
performed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Lu, H., Smith, P. (1979) Distribution of normal scores statistic
for nonparametric one-way analysis of variance.
<em>Journal of the American Statistical Association</em> <b>74</b>, 715&ndash;722.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalScoresTest">normalScoresTest</a></code>, <code><a href="#topic+normalScoresAllPairsTest">normalScoresAllPairsTest</a></code>, <code><a href="SuppDists.html#topic+normOrder">normOrder</a></code>, <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set PlantGrowth
## Global test
normalScoresTest(weight ~ group, data = PlantGrowth)

## Lu-Smith's many-one comparison test
ans &lt;- normalScoresManyOneTest(weight ~ group, data = PlantGrowth, p.adjust.method = "holm")
summary(ans)
</code></pre>

<hr>
<h2 id='normalScoresTest'>Lu-Smith Normal Scores Test</h2><span id='topic+normalScoresTest'></span><span id='topic+normalScoresTest.default'></span><span id='topic+normalScoresTest.formula'></span>

<h3>Description</h3>

<p>Performs the Lu-Smith normal score test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalScoresTest(x, ...)

## Default S3 method:
normalScoresTest(x, g, ...)

## S3 method for class 'formula'
normalScoresTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalScoresTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="normalScoresTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="normalScoresTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="normalScoresTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="normalScoresTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="normalScoresTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="normalScoresTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For one-factorial designs with non-normally distributed
residuals the Lu-Smith normal score test can be performed to test
the H<code class="reqn">_0: F_1(x) = F_2(x) = \ldots = F_k(x)</code> against
the H<code class="reqn">_\mathrm{A}: F_i (x) \ne F_j(x) ~ (i \ne j)</code> with at least
one strict inequality. This function is basically a wrapper function to
<code><a href="SuppDists.html#topic+pNormScore">pNormScore</a></code> of the package <span class="pkg">SuppDists</span>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Lu, H., Smith, P. (1979) Distribution of normal scores statistic
for nonparametric one-way analysis of variance.
<em>Journal of the American Statistical Association</em> <b>74</b>, 715&ndash;722.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vanWaerdenTest">vanWaerdenTest</a></code>, <code><a href="#topic+kruskalTest">kruskalTest</a></code>,
<code><a href="SuppDists.html#topic+pNormScore">pNormScore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalScoresTest(count ~ spray, data = InsectSprays)
</code></pre>

<hr>
<h2 id='NPMTest'>All-Pairs Comparisons for Simply Ordered Mean Ranksums</h2><span id='topic+NPMTest'></span><span id='topic+NPMTest.default'></span><span id='topic+NPMTest.formula'></span>

<h3>Description</h3>

<p>Performs Nashimoto and Wright's all-pairs comparison procedure
for simply ordered mean ranksums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPMTest(x, ...)

## Default S3 method:
NPMTest(
  x,
  g,
  alternative = c("greater", "less"),
  method = c("look-up", "boot", "asympt"),
  nperm = 10000,
  ...
)

## S3 method for class 'formula'
NPMTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  method = c("look-up", "boot", "asympt"),
  nperm = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPMTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_method">method</code></td>
<td>
<p>a character string specifying the test statistic to use.
Defaults to <code>"look-up"</code> that uses published Table values of Williams (1972).</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the asymptotic permutation test.
Defaults to <code>1000</code>. Ignored, if <code>method = "look-up"</code>.</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="NPMTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure uses the property of a simple order,
<code class="reqn">\theta_m' - \theta_m \le \theta_j - \theta_i \le \theta_l' - \theta_l
\qquad (l \le i \le m~\mathrm{and}~ m' \le j \le l')</code>.
The null hypothesis H<code class="reqn">_{ij}: \theta_i = \theta_j</code> is tested against
the alternative A<code class="reqn">_{ij}: \theta_i &lt; \theta_j</code> for any
<code class="reqn">1 \le i &lt; j \le k</code>.
</p>
<p>The all-pairs comparisons test statistics for a balanced design are
</p>
<p style="text-align: center;"><code class="reqn">
 \hat{h}_{ij} = \max_{i \le m &lt; m' \le j} \frac{\left(\bar{R}_{m'} - \bar{R}_m \right)}{\sigma_a / \sqrt{n}},
</code>
</p>

<p>with <code class="reqn">n = n_i; ~ N = \sum_i^k n_i ~~ (1 \le i \le k)</code>, <code class="reqn">\bar{R}_i</code> the mean rank for the <code class="reqn">i</code>th group,
and <code class="reqn">\sigma_a = \sqrt{N \left(N + 1 \right) / 12}</code>. The null hypothesis is rejected,
if <code class="reqn">h_{ij} &gt; h_{k,\alpha,\infty}</code>.
</p>
<p>For the unbalanced case with moderate imbalance the test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
 \hat{h}_{ij} = \max_{i \le m &lt; m' \le j} \frac{\left(\bar{R}_{m'} - \bar{R}_m \right)}
 {\sigma_a \left(1/n_m + 1/n_{m'}\right)^{1/2}},
</code>
</p>

<p>The null hypothesis is rejected, if <code class="reqn">\hat{h}_{ij} &gt; h_{k,\alpha,\infty} / \sqrt{2}</code>.
</p>
<p>If <code>method = "look-up"</code> the function will not return
p-values. Instead the critical h-values
as given in the tables of Hayter (1990) for
<code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the number of groups (<code class="reqn">k</code>) and
the degree of freedoms (<code class="reqn">v = \infty</code>).
</p>
<p>If <code>method = "boot"</code> an asymetric permutation test
is conducted and <code class="reqn">p</code>-values is returned.
</p>
<p>If <code>method = "asympt"</code> is selected the asymptotic
<code class="reqn">p</code>-value is estimated as implemented in the
function <code>pHayStonLSA</code> of the package <span class="pkg">NSM3</span>.
</p>


<h3>Value</h3>


<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>
<p>Either a list of class <code>"PMCMR"</code> or a
list with class <code>"osrt"</code> that contains the following
components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>
<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function will give a warning for the unbalanced case and returns the
critical value <code class="reqn">h_{k,\alpha,\infty} / \sqrt{2}</code>.
</p>


<h3>Source</h3>

<p>If <code>method = "asympt"</code> is selected, this function calls
an internal probability function <code>pHS</code>. The GPL-2 code for
this function was taken from <code>pHayStonLSA</code> of the
the package <span class="pkg">NSM3</span>:
</p>
<p>Grant Schneider, Eric Chicken and Rachel Becvarik (2020) NSM3:
Functions and Datasets to Accompany Hollander, Wolfe, and
Chicken - Nonparametric Statistical Methods, Third Edition. R
package version 1.15. <a href="https://CRAN.R-project.org/package=NSM3">https://CRAN.R-project.org/package=NSM3</a>
</p>


<h3>References</h3>

<p>Hayter, A. J.(1990) A One-Sided Studentised Range
Test for Testing Against a Simple Ordered Alternative,
<em>Journal of the American Statistical Association</em>
<b>85</b>, 778&ndash;785.
</p>
<p>Nashimoto, K., Wright, F.T. (2007)
Nonparametric Multiple-Comparison Methods for Simply
Ordered Medians.
<em>Comput Stat Data Anal</em> <b>51</b>, 5068–5076.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MTest">MTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Shirley (1977)
## Reaction times of mice to stimuli to their tails.
x &lt;- c(2.4, 3, 3, 2.2, 2.2, 2.2, 2.2, 2.8, 2, 3,
 2.8, 2.2, 3.8, 9.4, 8.4, 3, 3.2, 4.4, 3.2, 7.4, 9.8, 3.2, 5.8,
 7.8, 2.6, 2.2, 6.2, 9.4, 7.8, 3.4, 7, 9.8, 9.4, 8.8, 8.8, 3.4,
 9, 8.4, 2.4, 7.8)
g &lt;- gl(4, 10)

## Shirley's test
## one-sided test using look-up table
shirleyWilliamsTest(x ~ g, alternative = "greater")

## Chacko's global hypothesis test for 'greater'
chackoTest(x , g)

## post-hoc test, default is standard normal distribution (NPT'-test)
summary(chaAllPairsNashimotoTest(x, g, p.adjust.method = "none"))

## same but h-distribution (NPY'-test)
chaAllPairsNashimotoTest(x, g, dist = "h")

## NPM-test
NPMTest(x, g)

## Hayter-Stone test
hayterStoneTest(x, g)

## all-pairs comparisons
hsAllPairsTest(x, g)
</code></pre>

<hr>
<h2 id='osrtTest'>One-Sided Studentized Range Test</h2><span id='topic+osrtTest'></span><span id='topic+osrtTest.default'></span><span id='topic+osrtTest.formula'></span><span id='topic+osrtTest.aov'></span>

<h3>Description</h3>

<p>Performs Hayter's one-sided studentized range
test against an ordered alternative for normal data
with equal variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osrtTest(x, ...)

## Default S3 method:
osrtTest(x, g, alternative = c("greater", "less"), ...)

## S3 method for class 'formula'
osrtTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  ...
)

## S3 method for class 'aov'
osrtTest(x, alternative = c("greater", "less"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osrtTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="osrtTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="osrtTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="osrtTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code>.</p>
</td></tr>
<tr><td><code id="osrtTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="osrtTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="osrtTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="osrtTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hayter's one-sided studentized range test (OSRT) can be used
for testing several treatment levels with a zero control in a balanced
one-factorial design with normally distributed variables that have a
common variance. The null hypothesis, H: <code class="reqn">\mu_i = \mu_j ~~ (i &lt; j)</code>
is tested against a simple order alternative,
A: <code class="reqn">\mu_i &lt; \mu_j</code>, with at least one inequality being strict.
</p>
<p>The test statistic is calculated as,
</p>
<p style="text-align: center;"><code class="reqn">
 \hat{h} = \max_{1 \le i &lt; j \le k} \frac{ \left(\bar{x}_j - \bar{x}_i \right)}
 {s_{\mathrm{in}} / \sqrt{n}},
</code>
</p>

<p>with <code class="reqn">k</code> the number of groups, <code class="reqn">n = n_1, n_2, \ldots, n_k</code> and
<code class="reqn">s_{\mathrm{in}}^2</code> the within ANOVA variance. The null hypothesis
is rejected, if <code class="reqn">\hat{h} &gt; h_{k,\alpha,v}</code>, with <code class="reqn">v = N - k</code>
degree of freedom.
</p>
<p>For the unbalanced case with moderate imbalance the test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
 \hat{h} = \max_{1 \le i &lt; j \le k} \frac{ \left(\bar{x}_j - \bar{x}_i \right)}
 {s_{\mathrm{in}} \sqrt{1/n_j + 1/n_i}},
</code>
</p>

<p>The function does not return p-values. Instead the critical h-values
as given in the tables of Hayter (1990) for <code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the number of groups (<code class="reqn">k</code>) and
the degree of freedoms (<code class="reqn">v</code>).
Non tabulated values are linearly interpolated with the function
<code><a href="stats.html#topic+approx">approx</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"osrt"</code> that contains the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>


<h3>Note</h3>

<p>Hayter (1990) has tabulated critical h-values for balanced designs only.
For some unbalanced designs some <code class="reqn">k = 3</code> critical h-values
can be found in Hayter et al. 2001. ' The function will give
a warning for the unbalanced case and returns the
critical value <code class="reqn">h_{k,\alpha,v} / \sqrt{2}</code>.
</p>


<h3>References</h3>

<p>Hayter, A. J.(1990) A One-Sided Studentised Range
Test for Testing Against a Simple Ordered Alternative,
<em>Journal of the American Statistical Association</em>
<b>85</b>, 778&ndash;785.
</p>
<p>Hayter, A.J., Miwa, T., Liu, W. (2001)
Efficient Directional Inference Methodologies for the
Comparisons of Three Ordered Treatment Effects.
<em>J Japan Statist Soc</em> <b>31</b>, 153–174.
</p>


<h3>See Also</h3>

<p><code>link{hayterStoneTest}</code> <code><a href="#topic+MTest">MTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
md &lt;- aov(weight ~ group, PlantGrowth)
anova(md)
osrtTest(md)
MTest(md)
</code></pre>

<hr>
<h2 id='pageTest'>Page Rank Sum Test</h2><span id='topic+pageTest'></span><span id='topic+pageTest.default'></span>

<h3>Description</h3>

<p>Performs Page's ordered aligned rank sum test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pageTest(y, ...)

## Default S3 method:
pageTest(
  y,
  groups,
  blocks,
  alternative = c("two.sided", "greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pageTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="pageTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="pageTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="pageTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis.
Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="pageTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Page, E. B. (1963) Ordered hypotheses for multiple treatments: A
significance test for linear ranks, <em>Journal of the
American Statistical Association</em> <b>58</b>, 216&ndash;230.
</p>
<p>Sachs, L. (1997) <em>Angewandte Statistik</em>. Berlin: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sachs (1997), pp. 671 ff.
## 9 reviewers (blocks)
## assigned ranks to 4 objects (groups).
data(reviewers)
## See Sachs (1997) p. 677
pageTest(reviewers, alternative = "greater")

</code></pre>

<hr>
<h2 id='Pentosan'>Pentosan Dataset</h2><span id='topic+Pentosan'></span>

<h3>Description</h3>

<p>A benchmark dataset of an interlaboratory study for
determining the precision of a test method
on several levels of the material Pentosan.
</p>


<h3>Format</h3>

<p>A data frame with 189 obs. of  3 variables:
</p>

<dl>
<dt>value</dt><dd><p>numeric, test result (no unit specified)</p>
</dd>
<dt>lab</dt><dd><p>factor, identifier of the lab (1&ndash;7)</p>
</dd>
<dt>material</dt><dd><p>factor, identifier of the level of the material (A&ndash;I)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Tab. 8, Practice E 691, 2005, <em>Standard Practice for
Conducting an Interlaboratory Study to Determine the
Precision of a Test Method</em>, ASTM International.
</p>

<hr>
<h2 id='plot.mandel'>Plotting mandel Objects</h2><span id='topic+plot.mandel'></span>

<h3>Description</h3>

<p>Plotting method for objects inheriting from class <code>"mandel"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mandel'
plot(x, alpha = 0.005, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mandel_+3A_x">x</code></td>
<td>
<p>an object with class <code>"mandel"</code>.</p>
</td></tr>
<tr><td><code id="plot.mandel_+3A_alpha">alpha</code></td>
<td>
<p>level of significance. Defaults to <code>0.005</code>.</p>
</td></tr>
<tr><td><code id="plot.mandel_+3A_...">...</code></td>
<td>
<p>further arguments, currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>demo(Pentosan)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Not run: 
data(Pentosan)
md &lt;- mandelkTest(value ~ lab, Pentosan, subset = (material == "B"))
plot(md)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.PMCMR'>Plotting PMCMR Objects</h2><span id='topic+plot.PMCMR'></span>

<h3>Description</h3>

<p>Plotting method for objects inheriting from class <code>"PMCMR"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PMCMR'
plot(x, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PMCMR_+3A_x">x</code></td>
<td>
<p>an object of class <code>"PMCMR"</code>.</p>
</td></tr>
<tr><td><code id="plot.PMCMR_+3A_alpha">alpha</code></td>
<td>
<p>the selected alpha-level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="plot.PMCMR_+3A_...">...</code></td>
<td>
<p>further arguments for method <code>boxplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A box-whisker plot for each factor level. The range of the whiskers indicate
the extremes (<code>boxplot = x, ..., range=0</code>). Letter symbols are depicted on top of each box.
Different letters indicate significant
differences between groups on the selected level of alpha.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data set InsectSprays
ans &lt;- kwAllPairsNemenyiTest(count ~ spray, data = InsectSprays)
plot(ans)
plot(ans, col="red",main="My title", xlab="Spray", "Count")
</code></pre>

<hr>
<h2 id='power.dunnett.test'>Power Calculations for Balanced Dunnett's
Many-to-One Comparison Test</h2><span id='topic+power.dunnett.test'></span>

<h3>Description</h3>

<p>Compute average per-pair power of Dunnetts's multiple comparison
test with one control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.dunnett.test(n, groups, delta, within.var, sig.level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.dunnett.test_+3A_n">n</code></td>
<td>
<p>Number of observations (per group)</p>
</td></tr>
<tr><td><code id="power.dunnett.test_+3A_groups">groups</code></td>
<td>
<p>Number of groups (including control)</p>
</td></tr>
<tr><td><code id="power.dunnett.test_+3A_delta">delta</code></td>
<td>
<p>true difference in means</p>
</td></tr>
<tr><td><code id="power.dunnett.test_+3A_within.var">within.var</code></td>
<td>
<p>Within group variance</p>
</td></tr>
<tr><td><code id="power.dunnett.test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has implemented the following Eq.
to estimate average per-pair power for two-sided tests:
</p>
<p style="text-align: center;"><code class="reqn">
 1 - \beta = 1 - t( T_{\alpha \rho v}, v, \mathrm{ncp}) +
  t(-T_{\alpha \rho v}, v, \mathrm{ncp}),
</code>
</p>

<p>with <code class="reqn">T_{\alpha \rho v}</code> the two-sided
<code class="reqn">\alpha</code> quantile of
the multivariate t-distribution, with <code class="reqn">v = k (n - 1)</code>
degree of freedom, <code class="reqn">k</code> the number of groups
and correlation matrix <code class="reqn">\rho_{ij} = 0.5 ~ (i \neq j)</code>.
</p>
<p>The non-centrality parameter for the non-central student t-distribution
is
</p>
<p style="text-align: center;"><code class="reqn">
 \mathrm{ncp} = |\Delta| / \sqrt{s_{\mathrm{in}}^2 ~ 2 / n }.
</code>
</p>



<h3>Value</h3>

<p>Object of class &lsquo;<code>power.htest</code>&rsquo;,
a list of the arguments
(including the computed one) augmented with
<code>method</code> and <code>note</code> elements.
</p>


<h3>Note</h3>

<p>The results for power are seed depending.
</p>


<h3>Source</h3>

<p>The Eqs. were taken from Lecture 5, <em>Determining Sample Size</em>,
Statistics 514, Fall 2015, Purdue University, IN, USA.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code> <code><a href="mvtnorm.html#topic+qmvt">qmvt</a></code>
<code><a href="#topic+powerMCTests">powerMCTests</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(113)
power.dunnett.test(n = 9, groups = 5, delta = 30,
 within.var = 333.7)

## compare with t-test, bonferroni corrected
power.t.test(n = 9, delta = 30, sd = sqrt(333.7),
sig.level = 0.05 / 4)

## Not run: 
## asymptotic Monte-Carlo power analysis
 set.seed(113)
 powerMCTests(mu = c(rep(0,4), 30), n = 9,
 parms = list(mean = 0, sd = sqrt(333.7)),
 test = "dunnettTest", alternative = "two.sided")

## End(Not run)
</code></pre>

<hr>
<h2 id='power.tukey.test'>Power Calculations for Balanced Tukey's
Multiple Comparison Test</h2><span id='topic+power.tukey.test'></span>

<h3>Description</h3>

<p>Compute average per-pair power of Tukey's test for
multiple comparison of means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.tukey.test(n, groups, delta, within.var, sig.level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.tukey.test_+3A_n">n</code></td>
<td>
<p>number of observations (per group)</p>
</td></tr>
<tr><td><code id="power.tukey.test_+3A_groups">groups</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="power.tukey.test_+3A_delta">delta</code></td>
<td>
<p>true difference in means</p>
</td></tr>
<tr><td><code id="power.tukey.test_+3A_within.var">within.var</code></td>
<td>
<p>within group variance</p>
</td></tr>
<tr><td><code id="power.tukey.test_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has implemented the following Eq.
to estimate average per-pair power for two-sided tests:
</p>
<p style="text-align: center;"><code class="reqn">
 1 - \beta = 1 - t(q_{\alpha v k}/\sqrt{2}, v, \mathrm{ncp}) +
  t(-q_{\alpha v k}/\sqrt{2}, v, \mathrm{ncp}),
</code>
</p>

<p>with <code class="reqn">q_{\alpha v k}</code> the upper <code class="reqn">\alpha</code> quantile of
the studentised range distribution, with <code class="reqn">v = k (n - 1)</code>
degree of freedom and <code class="reqn">k</code> the number of groups;
and <code class="reqn">t(. ~\mathrm{ncp})</code>
the probability function of the non-central student t-distribution
with non-centrality parameter
</p>
<p style="text-align: center;"><code class="reqn">
 \mathrm{ncp} = |\Delta| / \sqrt{s_{\mathrm{in}}^2 ~ 2 / n }.
</code>
</p>



<h3>Value</h3>

<p>Object of class &lsquo;<code>power.htest</code>&rsquo;,
a list of the arguments
(including the computed one) augmented with
<code>method</code> and <code>note</code> elements.
</p>


<h3>Source</h3>

<p>The Eqs. were taken from Lecture 5, <em>Determining Sample Size</em>,
Statistics 514, Fall 2015, Purdue University, IN, USA.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code> <code><a href="stats.html#topic+Tukey">Tukey</a></code>
<code><a href="#topic+powerMCTests">powerMCTests</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>power.tukey.test(n = 11, groups = 5, delta = 30,
 within.var = 333.7)

## compare with t-test, Bonferroni-correction
power.t.test(n = 11, delta = 30, sd = sqrt(333.7),
sig.level = 0.05 / 10)

## Not run: 
powerMCTests(mu = c(rep(0,4), 30), n = 11,
 parms = list(mean = 0,sd = sqrt(333.7)),
 test = "tukeyTest")

## End(Not run)
</code></pre>

<hr>
<h2 id='power.williams.test'>Power calculations for
minimum detectable difference of the Williams' test</h2><span id='topic+power.williams.test'></span>

<h3>Description</h3>

<p>Compute the power of a Williams' test,
or determine parameters to obtain a target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.williams.test(n = NULL, k, delta, sd = 1, power = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.williams.test_+3A_n">n</code></td>
<td>
<p>number of observations (per group).</p>
</td></tr>
<tr><td><code id="power.williams.test_+3A_k">k</code></td>
<td>
<p>number of treatment groups.</p>
</td></tr>
<tr><td><code id="power.williams.test_+3A_delta">delta</code></td>
<td>
<p>clinically meaningful minimal difference
(between a treatment group and control).</p>
</td></tr>
<tr><td><code id="power.williams.test_+3A_sd">sd</code></td>
<td>
<p>common standard deviation.</p>
</td></tr>
<tr><td><code id="power.williams.test_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability).</p>
</td></tr>
<tr><td><code id="power.williams.test_+3A_...">...</code></td>
<td>
<p>further arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code> or <code>power</code>
must be passed as <code>NULL</code>, and that
parameter is determined from the others.
</p>
<p>The function has implemented the following Eq. in order to
estimate power (Chow et  al. 2008):
</p>
<p style="text-align: center;"><code class="reqn">
 1 - \beta = 1 - \Phi \left(T_{K \alpha v} -
 |\Delta| / \sigma \sqrt{2/n}\right)
</code>
</p>

<p>with <code class="reqn">|\Delta|</code> the clinically meaningful minimal difference,
<code class="reqn">T_{K \alpha v}</code> the critical Williams' t-statistic
for <code class="reqn">\alpha = 0.05</code>, <code class="reqn">v = \infty</code> degree of freedom
and <code class="reqn">\Phi</code> the probability function of the standard normal function.
</p>
<p>The required sample size (balanced design) is estimated
based on the expression as given by the PASS manual, p. 595-2:
</p>
<p style="text-align: center;"><code class="reqn">
n = 2 \sigma^2 ~ \left(T_{K \alpha v} + z_{\beta} \right)^2 ~ / ~ \Delta^2
</code>
</p>



<h3>Value</h3>

<p>Object of class &lsquo;<code>power.htest</code>&rsquo;, a list of the arguments
(including the
computed one) augmented with method and note elements.
</p>


<h3>Note</h3>

<p>The current function calculates power for <code>sig.level = 0.05</code>
significance level (Type I error probability) only (one-sided test).
</p>


<h3>References</h3>

<p>Chow, S.-C., Shao, J., Wan, H., 2008,
<em>Sample Size Calculations in Clinical Research</em>, 2nd ed,
Chapman &amp; Hall/CRC: Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optimise">optimise</a></code> <code><a href="#topic+williamsTest">williamsTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Chow et al. 2008, p. 288 depicts 53 (rounded),
## better use ceiling for rounding
power.williams.test(power = 0.8, k = 3, delta = 11, sd = 22)
power.williams.test(n = 54, k = 3, delta = 11, sd = 22)

## PASS manual example:
## up-rounded n values are:
## 116, 52, 29, 14, 8 and 5
## according to PASS manual, p. 595-5
D &lt;- c(10, 15, 20, 30, 40, 50)
y &lt;- sapply(D, function(delta) {
 power.williams.test(power = 0.9, k = 4, delta = delta, sd = 25)$n
 })
ceiling(y)

## Not run: 
 ## compare with power.t.test
 ## and bonferroni correction
 power.t.test(power = 0.9, delta = 50, sd = 25,
 sig.level = 0.05 / 4, alternative = "one.sided")

## End(Not run)

</code></pre>

<hr>
<h2 id='powerMCTests'>Power Simulation for One-Factorial All-Pairs and Many-To-One Comparison Tests</h2><span id='topic+powerMCTests'></span>

<h3>Description</h3>

<p>Performs power simulation for one-factorial all-pairs and Many-To-One comparison tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerMCTests(
  mu,
  n = 10,
  errfn = c("Normal", "Lognormal", "Exponential", "Chisquare", "TDist", "Cauchy",
    "Weibull"),
  parms = list(mean = 0, sd = 1),
  test = c("kwManyOneConoverTest", "kwManyOneDunnTest", "kwManyOneNdwTest",
    "vanWaerdenManyOneTest", "normalScoresManyOneTest", "dunnettTest",
    "tamhaneDunnettTest", "ManyOneUTest", "chenTest", "kwAllPairsNemenyiTest",
    "kwAllPairsDunnTest", "kwAllPairsConoverTest", "normalScoresAllPairsTest",
    "vanWaerdenAllPairsTest", "dscfAllPairsTest", "gamesHowellTest", "lsdTest",
    "scheffeTest", "tamhaneT2Test", "tukeyTest", "dunnettT3Test", "pairwise.t.test",
    "pairwise.wilcox.test", "adManyOneTest", "adAllPairsTest", "bwsManyOneTest", 
    
    "bwsAllPairsTest", "welchManyOneTTest"),
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  alpha = 0.05,
  FWER = TRUE,
  replicates = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerMCTests_+3A_mu">mu</code></td>
<td>
<p>numeric vector of group means.</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_n">n</code></td>
<td>
<p>number of replicates per group. If <code>n</code> is a scalar, then
a balanced design is assumed. Otherwise, <code>n</code> must be a vector of same
length as <code>mu</code>.</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_errfn">errfn</code></td>
<td>
<p>the error function. Defaults to <code>"Normal"</code>.</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_parms">parms</code></td>
<td>
<p>a list that denotes the arguments for the error function.
Defaults to <code>list(mean=0, sd=1)</code>.</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_test">test</code></td>
<td>
<p>the multiple comparison test for which the power analysis is
to be performed. Defaults to <code>"kwManyOneConoverTest"</code>.</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"two.sided"</code>,
ignored if the selected error function does not use this argument.</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_alpha">alpha</code></td>
<td>
<p>the nominal level of Type I Error.</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_fwer">FWER</code></td>
<td>
<p>logical, indicates whether the family-wise error should be computed.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="powerMCTests_+3A_replicates">replicates</code></td>
<td>
<p>the number of Monte Carlo replicates or runs. Defaults to <code>1000</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear model of a one-way ANOVA can be written as:
</p>
<p style="text-align: center;"><code class="reqn">
X_{ij} = \mu_i + \epsilon_{ij}
</code>
</p>

<p>For each Monte Carlo run, the function simulates <code class="reqn">\epsilon_{ij}</code> based on the given error function and
the corresponding parameters. Then the specified all-pairs
or many-to-one comparison test is performed.
Finally, several effect sizes (Cohen's f ans R-squared),
error rates (per comparison error rate,
false discovery rate and familywise error rate)
and test powers (any-pair power, average per-pair power
and all-pairs power) are calculated.
</p>


<h3>Value</h3>

<p>An object with class <code>powerPMCMR</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mu &lt;- c(0, 0, 1, 2)
n &lt;- c(5, 4, 5, 5)
set.seed(100)
powerMCTests(mu, n, errfn="Normal",
 parms=list(mean=0, sd=1),
 test="dunnettTest", replicates=1E4)

powerMCTests(mu, n, errfn="Normal",
 parms=list(mean=0, sd=1),
 test="kwManyOneDunnTest", p.adjust.method = "bonferroni",
 replicates=1E4)


## End(Not run)

</code></pre>

<hr>
<h2 id='powerOneWayTests'>Power Simulation for One-Factorial Single Hypothesis Tests</h2><span id='topic+powerOneWayTests'></span>

<h3>Description</h3>

<p>Performs power simulation for one-factorial
single hypothesis tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerOneWayTests(
  mu,
  n = 10,
  errfn = c("Normal", "Lognormal", "Exponential", "Chisquare", "TDist", "Cauchy",
    "Weibull"),
  parms = list(mean = 0, sd = 1),
  test = c("kruskalTest", "leTest", "vanWaerdenTest", "normalScoresTest", "spearmanTest",
    "cuzickTest", "jonckheereTest", "johnsonTest", "oneway.test", "adKSampleTest",
    "bwsKSampleTest", "bwsTrendTest", "mackWolfeTest", "chackoTest", "flignerWolfeTest"),
  alternative = c("two.sided", "greater", "less"),
  var.equal = TRUE,
  dist = NULL,
  alpha = 0.05,
  FWER = TRUE,
  replicates = 1000,
  p = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerOneWayTests_+3A_mu">mu</code></td>
<td>
<p>numeric vector of group means.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_n">n</code></td>
<td>
<p>number of replicates per group. If <code>n</code> is a scalar, then
a balanced design is assumed. Otherwise, <code>n</code> must be a vector of same
length as <code>mu</code>.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_errfn">errfn</code></td>
<td>
<p>the error function. Defaults to <code>"Normal"</code>.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_parms">parms</code></td>
<td>
<p>a list that denotes the arguments for the error function.
Defaults to <code>list(mean=0, sd=1)</code>.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_test">test</code></td>
<td>
<p>the test for which the power analysis is
to be performed. Defaults to <code>"kwManyOneConoverTest"</code>.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"two.sided"</code>,
ignored if the selected error function does not use this argument.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the variances
in the samples as equal.  <code>"TRUE"</code>, then a simple F test for
the equality of means in a one-way analysis of variance is
performed.  If <code>"FALSE"</code>, an approximate method of Welch (1951)
is used, which generalizes the commonly known 2-sample Welch
test to the case of arbitrarily many samples. Defaults to <code>"TRUE"</code>; only relevant,
if <code>test = "oneway.test"</code>, otherwise ignored.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_dist">dist</code></td>
<td>
<p>the test distribution. Only relevant for
<code><a href="#topic+kruskalTest">kruskalTest</a></code>. Defaults's to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_alpha">alpha</code></td>
<td>
<p>the nominal level of Type I Error.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_fwer">FWER</code></td>
<td>
<p>logical, indicates whether the family-wise error should be computed.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_replicates">replicates</code></td>
<td>
<p>the number of Monte Carlo replicates or runs. Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="powerOneWayTests_+3A_p">p</code></td>
<td>
<p>the a-priori known peak as an ordinal number of the treatment
group including the zero dose level, i.e. <code class="reqn">p = \{1, \ldots, k\}</code>.
Defaults to <code>NULL</code>. Only relevant, if <code>"mackWolfeTest"</code> is selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear model of a one-way ANOVA can be written as:
</p>
<p style="text-align: center;"><code class="reqn">
X_{ij} = \mu_i + \epsilon_{ij}
</code>
</p>

<p>For each Monte Carlo run, the function simulates <code class="reqn">\epsilon_{ij}</code> based on the given error function and
the corresponding parameters. Then the specified test is performed.
Finally, Type I and Type II error rates are calculated.
</p>


<h3>Value</h3>

<p>An object with class <code>powerOneWayPMCMR</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+powerMCTests">powerMCTests</a></code>,
<code><a href="pwr.html#topic+pwr.anova.test">pwr.anova.test</a></code>,
<code><a href="stats.html#topic+power.anova.test">power.anova.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(12)
mu &lt;- c(0, 0, 1, 2)
n &lt;- c(5, 4, 5, 5)
parms &lt;- list(mean=0, sd=1)
powerOneWayTests(mu, n, parms, test = "cuzickTest",
alternative = "two.sided", replicates = 1E4)

## Compare power estimation for
## one-way ANOVA with balanced design
## as given by functions
## power.anova.test, pwr.anova.test
## and powerOneWayTest

groupmeans &lt;- c(120, 130, 140, 150)
SEsq &lt;- 500  # within-variance
n &lt;- 10
k &lt;- length(groupmeans)
df &lt;- n * k - k
SSQ.E &lt;- SEsq * df
SSQ.A &lt;- n * var(groupmeans) * (k - 1)
sd.errfn &lt;- sqrt(SSQ.E / (n * k - 1))
R2 &lt;- c("R-squared" = SSQ.A / (SSQ.A + SSQ.E))
cohensf &lt;- sqrt(R2 / (1 - R2))
names(cohensf) &lt;- "Cohens f"

## R stats power function
power.anova.test(groups = k,
                 between.var = var(groupmeans),
                 within.var = SEsq,
                 n = n)

## pwr power function
pwr.anova.test(k = k, n = n, f = cohensf, sig.level=0.05)

## this Monte-Carlo based estimation
set.seed(200)
powerOneWayTests(mu = groupmeans,
                 n = n,
                 parms = list(mean=0, sd=sd.errfn),
                 test = "oneway.test",
                 var.equal = TRUE,
                 replicates = 5E3)

## Compare with effect sizes
R2
cohensf


## End(Not run)

</code></pre>

<hr>
<h2 id='print.gesdTest'>gesdTest Printing</h2><span id='topic+print.gesdTest'></span>

<h3>Description</h3>

<p><code>print.gesdTest</code> is the <em>gesdTest</em> method of the generic
<code><a href="#topic+print">print</a></code> function which prints its argument
and returns it <em>invisibly</em> (via <code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gesdTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gesdTest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.gesdTest_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.mandel'>Mandel Printing</h2><span id='topic+print.mandel'></span><span id='topic+print'></span>

<h3>Description</h3>

<p><code>print.mandel</code> is the <em>mandel</em> method of the generic
<code><a href="#topic+print">print</a></code> function which prints its argument
and returns it <em>invisibly</em> (via <code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mandel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mandel_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.mandel_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mandelhTest">mandelhTest</a></code>, <code><a href="#topic+mandelkTest">mandelkTest</a></code>
</p>

<hr>
<h2 id='print.osrt'>osrt Printing</h2><span id='topic+print.osrt'></span>

<h3>Description</h3>

<p><code>print.osrt</code> is the <em>osrt</em> method of the generic
<code><a href="#topic+print">print</a></code> function which prints its argument
and returns it <em>invisibly</em> (via <code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'osrt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.osrt_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.osrt_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>summary.osrt
</p>

<hr>
<h2 id='print.PMCMR'>PMCMR Printing</h2><span id='topic+print.PMCMR'></span>

<h3>Description</h3>

<p><code>print.PMCMR</code> is the <em>PMCMR</em> method of the generic
<code><a href="#topic+print">print</a></code> function which prints its argument
and returns it <em>invisibly</em> (via <code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PMCMR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PMCMR_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.PMCMR_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.powerOneWayPMCMR'>PowerOneWayPMCMR Printing</h2><span id='topic+print.powerOneWayPMCMR'></span>

<h3>Description</h3>

<p><code>print.powerOneWayPMCMR</code> is the
<em>powerOneWayPMCMR</em> method of the generic
<code><a href="#topic+print">print</a></code> function which prints its argument
and returns it <em>invisibly</em> (via <code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powerOneWayPMCMR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.powerOneWayPMCMR_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.powerOneWayPMCMR_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.powerPMCMR'>PowerPMCMR Printing</h2><span id='topic+print.powerPMCMR'></span>

<h3>Description</h3>

<p><code>print.powerPMCMR</code> is the <em>powerPMCMR</em> method of the generic
<code><a href="#topic+print">print</a></code> function which prints its argument
and returns it <em>invisibly</em> (via <code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powerPMCMR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.powerPMCMR_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.powerPMCMR_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+powerMCTests">powerMCTests</a></code>, <code><a href="#topic+powerOneWayTests">powerOneWayTests</a></code>
</p>

<hr>
<h2 id='print.trendPMCMR'>trendPMCMR Printing</h2><span id='topic+print.trendPMCMR'></span>

<h3>Description</h3>

<p><code>print.trendPMCMR</code> is the <em>trendPMCMR</em> method of the generic
<code><a href="#topic+print">print</a></code> function which prints its argument
and returns it <em>invisibly</em> (via <code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trendPMCMR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.trendPMCMR_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.trendPMCMR_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='qDunnett'>Dunnett Distribution</h2><span id='topic+qDunnett'></span><span id='topic+Dunnett'></span><span id='topic+pDunnett'></span>

<h3>Description</h3>

<p>Distribution function and quantile function
for the distribution of Dunnett's many-to-one
comparisons test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qDunnett(p, n0, n)

pDunnett(q, n0, n, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qDunnett_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="qDunnett_+3A_n0">n0</code></td>
<td>
<p>sample size for control group.</p>
</td></tr>
<tr><td><code id="qDunnett_+3A_n">n</code></td>
<td>
<p>vector of sample sizes for treatment groups.</p>
</td></tr>
<tr><td><code id="qDunnett_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="qDunnett_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default),
probabilities are <code class="reqn">P[X \leq x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dunnett's distribution is a special case of the
multivariate t distribution.
</p>
<p>Let the total sample size be <code class="reqn">N = n_0 + \sum_i^m n_i</code>, with <code class="reqn">m</code> the
number of treatment groups, than the quantile <code class="reqn">T_{m v \rho \alpha}</code>
is calculated with <code class="reqn">v = N - k</code> degree of freedom and
the correlation <code class="reqn">\rho</code>
</p>
<p style="text-align: center;"><code class="reqn">
 \rho_{ij} = \sqrt{\frac{n_i n_j}
             {\left(n_i + n_0\right) \left(n_j+ n_0\right)}} ~~
             (i \ne j).
</code>
</p>

<p>The functions determines <code class="reqn">m</code> via the length of the input
vector <code>n</code>.
</p>
<p>Quantiles and p-values are computed with the functions
of the package <strong>mvtnorm</strong>.
</p>


<h3>Value</h3>

<p><code>pDunnett</code> gives the distribution function and
<code>qDunnett</code> gives its inverse, the quantile function.
</p>


<h3>Note</h3>

<p>The results are seed depending.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+qmvt">qmvt</a></code> <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code> <code><a href="#topic+dunnettTest">dunnettTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Table gives 2.34 for df = 6, m = 2, one-sided
set.seed(112)
qval &lt;- qDunnett(p = 0.05, n0 = 3, n = rep(3,2))
round(qval, 2)
set.seed(112)
pDunnett(qval, n0=3, n = rep(3,2), lower.tail = FALSE)

## Table gives 2.65 for df = 20, m = 4, two-sided
set.seed(112)
qval &lt;- qDunnett(p = 0.05/2, n0 = 5, n = rep(5,4))
round(qval, 2)
set.seed(112)
2 * pDunnett(qval, n0= 5, n = rep(5,4), lower.tail= FALSE)
</code></pre>

<hr>
<h2 id='qPCR'>qPCR Curve Analysis Methods</h2><span id='topic+qPCR'></span>

<h3>Description</h3>

<p>The data set contains 4 classifiers (blocks), i.e.
bias, linearity, precision and resolution, for 11
different qPCR analysis methods. The null hypothesis
is that there is no preferred ranking of the method results
per gene for the performance parameters analyzed.
The rank scores were obtained by averaging results
across a large set of 69 genes in a biomarker data file.
</p>


<h3>Format</h3>

<p>A data frame with 4 observations on the following 11 variables.
</p>

<dl>
<dt>Cy0</dt><dd><p>a numeric vector</p>
</dd>
<dt>LinRegPCR</dt><dd><p>a numeric vector</p>
</dd>
<dt>Standard_Cq</dt><dd><p>a numeric vector</p>
</dd>
<dt>PCR_Miner</dt><dd><p>a numeric vector</p>
</dd>
<dt>MAK2</dt><dd><p>a numeric vector</p>
</dd>
<dt>LRE_E100</dt><dd><p>a numeric vector</p>
</dd>
<dt>5PSM</dt><dd><p>a numeric vector</p>
</dd>
<dt>DART</dt><dd><p>a numeric vector</p>
</dd>
<dt>FPLM</dt><dd><p>a numeric vector</p>
</dd>
<dt>LRE_Emax</dt><dd><p>a numeric vector</p>
</dd>
<dt>FPK_PCR</dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data were taken from Table 2 of Ruijter et al. (2013, p. 38).
See also Eisinga et al. (2017, pp. 14&ndash;15).
</p>


<h3>References</h3>

<p>Eisinga, R., Heskes, T., Pelzer, B., Te Grotenhuis, M. (2017)
Exact p-values for pairwise comparison of Friedman rank sums,
with application to comparing classifiers.
<em>BMC Bioinformatics</em>, 18:68.
</p>
<p>Ruijter, J. M. et al. (2013) Evaluation of qPCR curve analysis
methods for reliable biomarker discovery: Bias, resolution,
precision, and implications, <em>Methods</em> <b>59</b>, 32&ndash;46.
</p>

<hr>
<h2 id='quadeAllPairsTest'>All-Pairs Comparisons for
Unreplicated Blocked Data (Quade's All-Pairs Test)</h2><span id='topic+quadeAllPairsTest'></span><span id='topic+quadeAllPairsTest.default'></span>

<h3>Description</h3>

<p>Performs Quade multiple-comparison test for unreplicated
blocked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadeAllPairsTest(y, ...)

## Default S3 method:
quadeAllPairsTest(
  y,
  groups,
  blocks,
  dist = c("TDist", "Normal"),
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadeAllPairsTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="quadeAllPairsTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="quadeAllPairsTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="quadeAllPairsTest_+3A_dist">dist</code></td>
<td>
<p>the test distribution. Defaults to <code>"TDist"</code>.</p>
</td></tr>
<tr><td><code id="quadeAllPairsTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="quadeAllPairsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons of unreplicated blocked data
Quade's test can be applied.
A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: \theta_i = \theta_j</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: \theta_i \ne \theta_j, ~~ i \ne j</code>.
</p>
<p>The function has included two methods for approximate p-value estimation:
</p>

<dl>
<dt>TDist</dt><dd><p>p-values are computed from the t distribution</p>
</dd>
<dt>Normal</dt><dd><p>p-values are computed from the standard normal distribution</p>
</dd>
</dl>

<p>If no p-value adjustment is performed (<code>p.adjust.method = "none"</code>),
than a simple protected test is recommended, i.e.
all-pairs comparisons should only be applied after a significant
<code><a href="stats.html#topic+quade.test">quade.test</a></code>. However, any method as implemented in
<code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code> can be selected by the user.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>W. J. Conover (1999), <em>Practical nonparametric Statistics</em>,
3rd. Edition, Wiley.
</p>
<p>N. A. Heckert and J. J. Filliben (2003). NIST Handbook 148:
Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions.
National Institute of Standards and Technology Handbook Series, June 2003.
</p>
<p>D. Quade (1979), Using weighted rankings in the analysis of complete
blocks with additive block effects. <em>Journal of the American
Statistical Association</em>, 74, 680-683.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quade.test">quade.test</a></code>, <code><a href="#topic+friedmanTest">friedmanTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sachs, 1997, p. 675
## Six persons (block) received six different diuretics
## (A to F, treatment).
## The responses are the Na-concentration (mval)
## in the urine measured 2 hours after each treatment.
##
y &lt;- matrix(c(
3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
26.65),nrow=6, ncol=6,
dimnames=list(1:6, LETTERS[1:6]))
print(y)

## Global test
quade.test(y)

## All-pairs comparisons
quadeAllPairsTest(y, dist="TDist", p.adjust.method="holm")

</code></pre>

<hr>
<h2 id='reviewers'>Reviewers</h2><span id='topic+reviewers'></span>

<h3>Description</h3>

<p>9 reviewers (blocks) assigned ranks to 4 objects (groups).
</p>


<h3>Format</h3>

<p>The format is a 9 x 4 Matrix with Friedman type rankings:
</p>

<dl>
<dt>rows</dt><dd><p>reviewers, 1, 2, ..., 9</p>
</dd>
<dt>columns</dt><dd><p>groups, A, B, ..., D</p>
</dd>
</dl>



<h3>Source</h3>

<p>Sachs (1997), p. 671 ff.
</p>


<h3>References</h3>

<p>Sachs, L. (1997) <em>Angewandte Statistik</em>, New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(reviewers)
friedmanTest(reviewers)
pageTest(reviewers)
frdAllPairsExactTest(reviewers, p.adjust = "bonferroni")

</code></pre>

<hr>
<h2 id='scheffeTest'>Scheffe's Test</h2><span id='topic+scheffeTest'></span><span id='topic+scheffeTest.default'></span><span id='topic+scheffeTest.formula'></span><span id='topic+scheffeTest.aov'></span>

<h3>Description</h3>

<p>Performs Scheffe's all-pairs comparisons test for normally distributed
data with equal group variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scheffeTest(x, ...)

## Default S3 method:
scheffeTest(x, g, ...)

## S3 method for class 'formula'
scheffeTest(formula, data, subset, na.action, ...)

## S3 method for class 'aov'
scheffeTest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scheffeTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="scheffeTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="scheffeTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="scheffeTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="scheffeTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="scheffeTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="scheffeTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals and equal variances
Scheffe's test can be performed.
Let <code class="reqn">X_{ij}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization (<code class="reqn">1 \le j \le n_i</code>)
in the <code class="reqn">i</code>-th group (<code class="reqn">1 \le i \le k</code>). Furthermore, the total
sample size is <code class="reqn">N = \sum_{i=1}^k n_i</code>. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{ij}: \mu_i = \mu_j ~~ (i \ne j)</code> is tested against the alternative
A<code class="reqn">_{ij}: \mu_i \ne \mu_j</code> (two-tailed). Scheffe's all-pairs test
statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{ij} \frac{\bar{X}_i - \bar{X_j}}
 {s_{\mathrm{in}} \left(1/n_j + 1/n_i\right)^{1/2}}, ~~
 (i \ne j)
</code>
</p>

<p>with <code class="reqn">s^2_{\mathrm{in}}</code> the within-group ANOVA variance.
The null hypothesis is rejected if <code class="reqn">t^2_{ij} &gt; F_{v_{1}v_{2}\alpha}</code>,
with <code class="reqn">v_1 = k - 1, ~ v_2 = N - k</code> degree of freedom. The p-values
are computed from the <code><a href="stats.html#topic+FDist">FDist</a></code> distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Bortz, J. (1993) <em>Statistik für Sozialwissenschaftler</em>. 4. Aufl.,
Berlin: Springer.
</p>
<p>Sachs, L. (1997) <em>Angewandte Statistik</em>, New York: Springer.
</p>
<p>Scheffe, H. (1953) A Method for Judging all Contrasts in the Analysis
of Variance, <em>Biometrika</em> <b>40</b>, 87&ndash;110.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+FDist">FDist</a></code>, <code><a href="#topic+tukeyTest">tukeyTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts)
anova(fit)

## also works with fitted objects of class aov
res &lt;- scheffeTest(fit)
summary(res)
summaryGroup(res)
</code></pre>

<hr>
<h2 id='shanTest'>Testing against Ordered Alternatives (Shan-Young-Kang Test)</h2><span id='topic+shanTest'></span><span id='topic+shanTest.default'></span><span id='topic+shanTest.formula'></span>

<h3>Description</h3>

<p>Performs the Shan-Young-Kang test for testing against ordered alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shanTest(x, ...)

## Default S3 method:
shanTest(x, g, alternative = c("greater", "less"), ...)

## S3 method for class 'formula'
shanTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shanTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="shanTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="shanTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="shanTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis.
Defaults to <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="shanTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="shanTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="shanTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="shanTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis, H<code class="reqn">_0: \theta_1 = \theta_2 = \ldots = \theta_k</code>
is tested against a simple order hypothesis,
H<code class="reqn">_\mathrm{A}: \theta_1 \le \theta_2 \le \ldots \le
\theta_k,~\theta_1 &lt; \theta_k</code>.
</p>
<p>Let <code class="reqn">R_{ij}</code> be the rank of <code class="reqn">X_{ij}</code>,
where <code class="reqn">X_{ij}</code> is jointly ranked
from <code class="reqn">\left\{1, 2, \ldots, N \right\}, ~~ N = \sum_{i=1}^k n_i</code>,
the the test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
 S = \sum_{i = 1}^{k-1} \sum_{j = i + 1}^k D_{ij},
</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">
 D_{ij} = \sum_{l = 1}^{n_i} \sum_{m=1}^{n_j}  \left(R_{jm} - R_{il} \right)~ \mathrm{I}\left(X_{jm} &gt; X_{il} \right),
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
 \mathrm{I}(u) = \left\{
 \begin{array}{c}
     1, \qquad \forall~ u &gt; 0 \\
     0, \qquad \forall~ u \le 0
  \end{array}
  \right.
.</code>
</p>

<p>The test statistic is asymptotically normal distributed:
</p>
<p style="text-align: center;"><code class="reqn">
 z = \frac{S - \mu_{\mathrm{S}}}{\sqrt{s^2_{\mathrm{S}}}}
</code>
</p>

<p>The p-values are estimated from the standard normal distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The variance estimation (see Theorem 2.1, Shan et al. 2014)
can become negative for certain combinations of <code class="reqn">N,~n_i,~k
\qquad (1 \le i \le k)</code>. In these cases the function will return
a warning and the returned p-value will be <code>NaN</code>.
</p>
<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Shan, G., Young, D., Kang, L. (2014) A New Powerful Nonparametric
Rank Test for Ordered Alternative Problem. PLOS ONE 9, e112924.
https://doi.org/10.1371/journal.pone.0112924
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='shirleyWilliamsTest'>Shirley-Williams Test</h2><span id='topic+shirleyWilliamsTest'></span><span id='topic+shirleyWilliamsTest.default'></span><span id='topic+shirleyWilliamsTest.formula'></span>

<h3>Description</h3>

<p>Performs Shirley's nonparametric equivalent of William's test
for contrasting increasing dose levels of a treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shirleyWilliamsTest(x, ...)

## Default S3 method:
shirleyWilliamsTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  method = c("look-up", "boot"),
  nperm = 10000,
  ...
)

## S3 method for class 'formula'
shirleyWilliamsTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  method = c("look-up", "boot"),
  nperm = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shirleyWilliamsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code></p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_method">method</code></td>
<td>
<p>a character string specifying the test statistic to use.
Defaults to <code>"look-up"</code> that uses published Table values of Williams (1972).</p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the asymptotic permutation test.
Defaults to <code>1000</code>. Ignored, if <code>method = "look-up"</code>.</p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="shirleyWilliamsTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Shirley-William test is a non-parametric step-down trend test for testing several treatment levels
with a zero control. Let there be <code class="reqn">k</code> groups including the control and let
the zero dose level be indicated with <code class="reqn">i = 0</code> and the highest
dose level with <code class="reqn">i = m</code>, then the following <code>m = k - 1</code> hypotheses are tested:
</p>
<p style="text-align: center;"><code class="reqn">
\begin{array}{ll}
\mathrm{H}_{m}: \theta_0 = \theta_1 = \ldots = \theta_m, &amp; \mathrm{A}_{m} = \theta_0 \le \theta_1 \le \ldots \theta_m, \theta_0 &lt; \theta_m \\
\mathrm{H}_{m-1}: \theta_0 = \theta_1 = \ldots = \theta_{m-1}, &amp; \mathrm{A}_{m-1} = \theta_0 \le \theta_1 \le \ldots \theta_{m-1}, \theta_0 &lt; \theta_{m-1} \\
\vdots &amp; \vdots \\
\mathrm{H}_{1}: \theta_0 = \theta_1, &amp; \mathrm{A}_{1} = \theta_0 &lt; \theta_1\\
\end{array}
</code>
</p>

<p>Let <code class="reqn">R_{ij}</code> be the rank of <code class="reqn">X_{ij}</code>,
where <code class="reqn">X_{ij}</code> is jointly ranked
from <code class="reqn">\left\{1, 2, \ldots, N \right\}, ~~ N = \sum_{i=1}^k n_i</code>,
then the test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
  t_{i} = \frac{\max_{1 \le u \le i} \left(\sum_{j=u}^i n_j \bar{R}_j / \sum_{j=u}^i n_j \right) - \bar{R}_0}
{\sigma_{R_i} \sqrt{1/n_i + 1/n_0}},
</code>
</p>

<p>with expected variance of
</p>
<p style="text-align: center;"><code class="reqn">
\sigma_{R_i}^2 = N_i \left(N_i + 1 \right) / 12 - T_i,
</code>
</p>

<p>where <code class="reqn">N_i = n_0 + n_1 + n_2 + \ldots + n_i</code> and
<code class="reqn">T_i</code> the ties for the <code class="reqn">i</code>-th comparison is given by
</p>
<p style="text-align: center;"><code class="reqn">
 T_i = \sum_{j=1}^i \frac{t_j^3 - t_j}{12 \left(N_i - 1\right)}.
</code>
</p>

<p>The procedure starts from the highest dose level (<code class="reqn">m</code>) to the the lowest dose level (<code class="reqn">1</code>) and
stops at the first non-significant test. The consequent lowest effect dose
is the treatment level of the previous test number. This function has
included the modifications as recommended by Williams (1986), i.e.
the data are re-ranked for each of the <code class="reqn">i</code>-th comparison.
</p>
<p>If <code>method = "look-up"</code> is selected, the function does not return p-values.
Instead the critical <code class="reqn">t'_{i,v,\alpha}</code>-values
as given in the tables of Williams (1972) for <code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the degree of freedoms (<code class="reqn">v = \infty</code>) and the order number of the
dose level (<code class="reqn">i</code>) and (potentially) modified according to the given extrapolation
coefficient <code class="reqn">\beta</code>.
</p>
<p>Non tabulated values are linearly interpolated with the function
<code><a href="stats.html#topic+approx">approx</a></code>.
</p>
<p>For the comparison of the first dose level (i = 1) with the control, the critical
z-value from the standard normal distribution is used (<code><a href="stats.html#topic+Normal">Normal</a></code>).
</p>
<p>If <code>method = "boot"</code>, the p-values are estimated through an assymptotic
boot-strap method. The p-values for H<code class="reqn">_1</code>
are calculated from the t distribution with infinite degree of freedom.
</p>


<h3>Value</h3>

<p>Either a list with class <code>"osrt"</code> or a list with class <code>"PMCMR"</code>.
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>
<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>For <code>method = "look-up"</code>, only tests on the level of <code class="reqn">\alpha = 0.05</code>
can be performed for alternative hypotheses less or greater.
</p>
<p>For <code>method = "boot"</code> only the alternative <code>"two.sided"</code> can be calculated.
One may increase the number of permutations to e.g. <code>nperm = 10000</code>
in order to get more precise p-values. However, this will be on the expense of
computational time.
</p>


<h3>References</h3>

<p>Shirley, E., (1977) Nonparametric Equivalent of Williams Test for Contrasting Increasing
Dose Levels of a Treatment, <em>Biometrics</em> <b>33</b>, 386&ndash;389.
</p>
<p>Williams, D. A. (1986) Note on Shirley's nonparametric test for comparing
several dose levels with a zero-dose control, <em>Biometrics</em> <b>42</b>, 183&ndash;186.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+williamsTest">williamsTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Shirley (1977)
## Reaction times of mice to stimuli to their tails.
x &lt;- c(2.4, 3, 3, 2.2, 2.2, 2.2, 2.2, 2.8, 2, 3,
 2.8, 2.2, 3.8, 9.4, 8.4, 3, 3.2, 4.4, 3.2, 7.4, 9.8, 3.2, 5.8,
 7.8, 2.6, 2.2, 6.2, 9.4, 7.8, 3.4, 7, 9.8, 9.4, 8.8, 8.8, 3.4,
 9, 8.4, 2.4, 7.8)
g &lt;- gl(4, 10)

## Shirley's test
## one-sided test using look-up table
shirleyWilliamsTest(x ~ g, alternative = "greater")

## Chacko's global hypothesis test for 'greater'
chackoTest(x , g)

## post-hoc test, default is standard normal distribution (NPT'-test)
summary(chaAllPairsNashimotoTest(x, g, p.adjust.method = "none"))

## same but h-distribution (NPY'-test)
chaAllPairsNashimotoTest(x, g, dist = "h")

## NPM-test
NPMTest(x, g)

## Hayter-Stone test
hayterStoneTest(x, g)

## all-pairs comparisons
hsAllPairsTest(x, g)
</code></pre>

<hr>
<h2 id='siegelTukeyTest'>Siegel-Tukey Rank Dispersion Test</h2><span id='topic+siegelTukeyTest'></span><span id='topic+siegelTukeyTest.default'></span><span id='topic+siegelTukeyTest.formula'></span>

<h3>Description</h3>

<p>Performs Siegel-Tukey non-parametric
rank dispersion test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siegelTukeyTest(x, ...)

## Default S3 method:
siegelTukeyTest(
  x,
  y,
  alternative = c("two.sided", "greater", "less"),
  median.corr = FALSE,
  ...
)

## S3 method for class 'formula'
siegelTukeyTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siegelTukeyTest_+3A_x">x</code>, <code id="siegelTukeyTest_+3A_y">y</code></td>
<td>
<p>numeric vectors of data values.</p>
</td></tr>
<tr><td><code id="siegelTukeyTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="siegelTukeyTest_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the
alternative hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.
You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="siegelTukeyTest_+3A_median.corr">median.corr</code></td>
<td>
<p>logical indicator, whether median correction
should be performed prior testing. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="siegelTukeyTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="siegelTukeyTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="siegelTukeyTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="siegelTukeyTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">x</code> and <code class="reqn">y</code> denote two identically and independently
distributed variables of at least ordinal scale.
Further, let
<code class="reqn">\theta</code>, and <code class="reqn">\lambda</code> denote
location and scale parameter of the common, but unknown distribution.
Then for the two-tailed case, the null hypothesis
H: <code class="reqn">\lambda_x / \lambda_y = 1 | \theta_x = \theta_y</code> is
tested against the alternative,
A: <code class="reqn">\lambda_x / \lambda_y \ne 1</code>.
</p>
<p>The data are combinedly ranked according to Siegel-Tukey.
The ranking is done by alternate extremes (rank 1 is lowest,
2 and 3 are the two highest, 4 and 5 are the two next lowest, etc.).
If no ties are present, the p-values are computed from
the Wilcoxon distribution (see <code><a href="stats.html#topic+Wilcoxon">Wilcoxon</a></code>).
In the case of ties, a tie correction is done according
to Sachs (1997) and approximate p-values are computed
from the standard normal distribution (see <code><a href="stats.html#topic+Normal">Normal</a></code>).
</p>
<p>If both medians differ, one can correct for medians to
increase the specificity of the test.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The algorithm for the Siegel-Tukey ranks was
taken from the code of Daniel Malter. See also the
blog from Tal Galili (02/2010, <a href="https://www.r-statistics.com/2010/02/siegel-tukey-a-non-parametric-test-for-equality-in-variability-r-code/">https://www.r-statistics.com/2010/02/siegel-tukey-a-non-parametric-test-for-equality-in-variability-r-code/</a>,
accessed 2018-08-05).
</p>


<h3>References</h3>

<p>Sachs, L. (1997), <em>Angewandte Statistik</em>. Berlin: Springer.
</p>
<p>Siegel, S., Tukey, J. W. (1960), A nonparametric sum of ranks
procedure for relative spread in unpaired samples,
<em>Journal of the American Statistical Association</em> <b>55</b>, 429&ndash;455.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sachs, 1997, p. 376
A &lt;- c(10.1, 7.3, 12.6, 2.4, 6.1, 8.5, 8.8, 9.4, 10.1, 9.8)
B &lt;- c(15.3, 3.6, 16.5, 2.9, 3.3, 4.2, 4.9, 7.3, 11.7, 13.7)
siegelTukeyTest(A, B)

## from example var.test
x &lt;- rnorm(50, mean = 0, sd = 2)
y &lt;- rnorm(30, mean = 1, sd = 1)
siegelTukeyTest(x, y, median.corr = TRUE)

## directional hypothesis
A &lt;- c(33, 62, 84, 85, 88, 93, 97)
B &lt;- c(4, 16, 48, 51, 66, 98)
siegelTukeyTest(A, B, alternative = "greater")

</code></pre>

<hr>
<h2 id='skillingsMackTest'>Skillings-Mack Test</h2><span id='topic+skillingsMackTest'></span><span id='topic+skillingsMackTest.default'></span>

<h3>Description</h3>

<p>Performs Skillings-Mack rank sum test for partially balanced
incomplete block designs or partially balanced random block designs.
The null hypothesis
H<code class="reqn">_0: \theta_i = \theta_j~~(i \ne j)</code> is tested against the
alternative H<code class="reqn">_{\mathrm{A}}: \theta_i \ne \theta_j</code>, with at least
one inequality beeing strict.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skillingsMackTest(y, ...)

## Default S3 method:
skillingsMackTest(y, groups, blocks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skillingsMackTest_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="skillingsMackTest_+3A_groups">groups</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>. Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="skillingsMackTest_+3A_blocks">blocks</code></td>
<td>
<p>a vector or factor object giving the block for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="skillingsMackTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has implemented the test of Skillings and Mack (1981).
The test statistic is assymptotically chi-squared distributed with
df = k - 1 degrees of freedom.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The input vector/matrix <code>'y'</code> must contain <code>NA</code>.
</p>


<h3>References</h3>

<p>Skillings, J. H., Mack, G.A. (1981) On the use of a Friedman-type
statistic in balanced and unbalanced block designs,
<em>Technometrics</em> <b>23</b>, 171&ndash;177.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+friedmanTest">friedmanTest</a></code>, <code><a href="#topic+durbinTest">durbinTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Hollander and Wolfe 1999,
## originally appeared in Brady 1969.
x &lt;- cbind(c(3,1,5,2,0,0,0,0),
           c(5,3,4,NA,2,2,3,2),
           c(15,18,21,6,17,10,8,13))
colnames(x) &lt;- c("R", "A", "B")
rownames(x) &lt;- 1:8
skillingsMackTest(x)

## Compare with Friedman Test for CRB
## Sachs, 1997, p. 675
## Six persons (block) received six different diuretics
## (A to F, treatment).
## The responses are the Na-concentration (mval)
## in the urine measured 2 hours after each treatment.
 y &lt;- matrix(c(
3.88, 5.64, 5.76, 4.25, 5.91, 4.33, 30.58, 30.14, 16.92,
23.19, 26.74, 10.91, 25.24, 33.52, 25.45, 18.85, 20.45,
26.67, 4.44, 7.94, 4.04, 4.4, 4.23, 4.36, 29.41, 30.72,
32.92, 28.23, 23.35, 12, 38.87, 33.12, 39.15, 28.06, 38.23,
26.65),nrow=6, ncol=6,
dimnames=list(1:6, LETTERS[1:6]))
print(y)
friedmanTest(y)
skillingsMackTest(y)
</code></pre>

<hr>
<h2 id='snkTest'>Student-Newman-Keuls Test</h2><span id='topic+snkTest'></span><span id='topic+snkTest.default'></span><span id='topic+snkTest.formula'></span><span id='topic+snkTest.aov'></span>

<h3>Description</h3>

<p>Performs Student-Newman-Keuls all-pairs comparisons test for normally distributed
data with equal group variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snkTest(x, ...)

## Default S3 method:
snkTest(x, g, ...)

## S3 method for class 'formula'
snkTest(formula, data, subset, na.action, ...)

## S3 method for class 'aov'
snkTest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snkTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="snkTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="snkTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="snkTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="snkTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="snkTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="snkTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals and equal variances
Student-Newman-Keuls test can be performed. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: \mu_i(x) = \mu_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: \mu_i(x) \ne \mu_j(x), ~~ i \ne j</code>.
</p>
<p>The p-values are computed from the Tukey-distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Keuls, M. (1952) The use of the &quot;studentized range&quot;
in connection with an analysis of variance,
<em>Euphytica</em> <b>1</b>, 112&ndash;122.
</p>
<p>Newman, D. (1939) The distribution of range in
samples from a normal population, expressed in
terms of an independent estimate of standard
deviation, <em>Biometrika</em> <b>31</b>, 20&ndash;30.
</p>
<p>Student (1927) Errors of routine analysis,
<em>Biometrika</em> <b>19</b>, 151&ndash;164.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Tukey">Tukey</a></code>, <code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code> <code><a href="#topic+tukeyTest">tukeyTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts)
anova(fit)

## also works with fitted objects of class aov
res &lt;- snkTest(fit)
summary(res)
summaryGroup(res)
</code></pre>

<hr>
<h2 id='spearmanTest'>Testing against Ordered Alternatives (Spearman Test)</h2><span id='topic+spearmanTest'></span><span id='topic+spearmanTest.default'></span><span id='topic+spearmanTest.formula'></span>

<h3>Description</h3>

<p>Performs a Spearman type test for testing against ordered alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spearmanTest(x, ...)

## Default S3 method:
spearmanTest(x, g, alternative = c("two.sided", "greater", "less"), ...)

## S3 method for class 'formula'
spearmanTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spearmanTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="spearmanTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="spearmanTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="spearmanTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="spearmanTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="spearmanTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="spearmanTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="spearmanTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A one factorial design for dose finding comprises an ordered factor,
.e. treatment with increasing treatment levels.
The basic idea is to correlate the ranks <code class="reqn">R_{ij}</code> with the increasing
order number <code class="reqn">1 \le i \le k</code> of the treatment levels (Kloke and McKean 2015).
More precisely, <code class="reqn">R_{ij}</code> is correlated with the expected mid-value ranks
under the assumption of strictly increasing median responses.
Let the expected mid-value rank of the first group denote <code class="reqn">E_1 = \left(n_1 + 1\right)/2</code>.
The following expected mid-value ranks are
<code class="reqn">E_j = n_{j-1} + \left(n_j + 1 \right)/2</code> for <code class="reqn">2 \le j \le k</code>.
The corresponding number of tied values for the <code class="reqn">i</code>th group is <code class="reqn">n_i</code>. #
The sum of squared residuals is
<code class="reqn">D^2 = \sum_{i=1}^k \sum_{j=1}^{n_i} \left(R_{ij} - E_i \right)^2</code>.
Consequently, Spearman's rank correlation coefficient can be calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
r_\mathrm{S} = \frac{6  D^2}
   {\left(N^3 - N\right)- C},
</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">
C = 1/2 - \sum_{c=1}^r \left(t_c^3 - t_c\right) +
1/2 - \sum_{i=1}^k \left(n_i^3 - n_i \right)
</code>
</p>

<p>and <code class="reqn">t_c</code> the number of ties of the <code class="reqn">c</code>th group of ties.
Spearman's rank correlation coefficient can be tested for
significance with a <code class="reqn">t</code>-test.
For a one-tailed test the null hypothesis of <code class="reqn">r_\mathrm{S} \le 0</code>
is rejected and the alternative <code class="reqn">r_\mathrm{S} &gt; 0</code> is accepted if
</p>
<p style="text-align: center;"><code class="reqn">
r_\mathrm{S} \sqrt{\frac{\left(n-2\right)}{\left(1 - r_\mathrm{S}\right)}} &gt; t_{v,1-\alpha},
</code>
</p>

<p>with <code class="reqn">v = n - 2</code> degree of freedom.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers
{0, 1, 2, ..., k} or letters {a, b, c, ...}.
Otherwise the function may not select the correct values
for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>Kloke, J., McKean, J. W. (2015) <em>Nonparametric statistical methods using R</em>.
Boca Raton, FL: Chapman &amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code> and <code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>
of the package <span class="pkg">PMCMRplus</span>,
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> of the library <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
       110, 125, 143, 148, 151,
       136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("A", "B", "C")

## Chacko's test
chackoTest(x, g)

## Cuzick's test
cuzickTest(x, g)

## Johnson-Mehrotra test
johnsonTest(x, g)

## Jonckheere-Terpstra test
jonckheereTest(x, g)

## Le's test
leTest(x, g)

## Spearman type test
spearmanTest(x, g)

## Murakami's BWS trend test
bwsTrendTest(x, g)

## Fligner-Wolfe test
flignerWolfeTest(x, g)

## Shan-Young-Kang test
shanTest(x, g)

</code></pre>

<hr>
<h2 id='steelsKSampleTest'>Steel's k-Treatments vs. Control Test</h2><span id='topic+steelsKSampleTest'></span><span id='topic+steelsKSampleTest.default'></span><span id='topic+steelsKSampleTest.formula'></span>

<h3>Description</h3>

<p>Performs the non-parametric Steel's test
for simultaneously testing k-treatments vs. one control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steelsKSampleTest(x, ...)

## Default S3 method:
steelsKSampleTest(x, g, alternative = c("two.sided", "greater", "less"), ...)

## S3 method for class 'formula'
steelsKSampleTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steelsKSampleTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="steelsKSampleTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="steelsKSampleTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="steelsKSampleTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="steelsKSampleTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="steelsKSampleTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="steelsKSampleTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="steelsKSampleTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It tests <code class="reqn">H: F(i) = F(0), ~ i \le k</code>, against
<code class="reqn">A: F(i) &gt; F(0)</code> (greater) with at least one inequality being strict.
</p>
<p>The function is a wrapper function that calls <code>Steel.test</code> of
the package <span class="pkg">kSamples</span> with argument <code>method = "asymptotic"</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated quantile of the test statistic.</p>
</dd>
<dt>p.value</dt><dd><p>the p-value for the test.</p>
</dd>
<dt>parameter</dt><dd><p>the parameters of the test statistic, if any.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>estimates</dt><dd><p>the estimates, if any.</p>
</dd>
<dt>null.value</dt><dd><p>the estimate under the null hypothesis, if any.</p>
</dd>
</dl>



<h3>References</h3>

<p>Scholz, F. and Zhu, A. (2019). kSamples: K-Sample Rank Tests and
their Combinations. R package version 1.2-9.
<a href="https://CRAN.R-project.org/package=kSamples">https://CRAN.R-project.org/package=kSamples</a>
</p>
<p>Steel, R. G. D. (1959) A Multiple Comparison Rank Sum Test:
Treatments Versus Control, <em>Biometrics</em> <b>15</b>, 560&ndash;572.
</p>


<h3>See Also</h3>

<p><code><a href="kSamples.html#topic+Steel.test">Steel.test</a></code>, <code><a href="#topic+flignerWolfeTest">flignerWolfeTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
110, 125, 143, 148, 151,
136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("0", "I", "II")

## Steel's Test
steelsKSampleTest(x ~ g, alternative = "greater")


## Example from USEPA (2002):
## Reproduction data from a Ceriodaphnia dubia
## 7-day chronic test to several concentrations
## of effluent. Dose level 50% is excluded.
x &lt;- c(20, 26, 26, 23, 24, 27, 26, 23, 27, 24,
13, 15, 14, 13, 23, 26, 0, 25, 26, 27,
18, 22, 13, 13, 23, 22, 20, 22, 23, 22,
14, 22, 20, 23, 20, 23, 25, 24, 25, 21,
9, 0, 9, 7, 6, 10, 12, 14, 9, 13,
rep(0,10))
g &lt;- gl(6, 10)
levels(g) &lt;- c("Control", "3%", "6%", "12%", "25%", "50%")

## NOEC at 3%, LOEC at 6%
steelsKSampleTest(x ~ g, subset = g != "50%", alternative = "less")

</code></pre>

<hr>
<h2 id='steelTest'>Steel's Many-to-One Rank Test</h2><span id='topic+steelTest'></span><span id='topic+steelTest.default'></span><span id='topic+steelTest.formula'></span>

<h3>Description</h3>

<p>Performs Steel's non-parametric many-to-one comparison
test for Wilcox-type ranked data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steelTest(x, ...)

## Default S3 method:
steelTest(x, g, alternative = c("greater", "less"), ...)

## S3 method for class 'formula'
steelTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steelTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="steelTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="steelTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="steelTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code></p>
</td></tr>
<tr><td><code id="steelTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="steelTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="steelTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="steelTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons (pairwise comparisons with one control)
in an one-factorial balanced layout with non-normally distributed
residuals Steels's non-parametric single-step test can be performed.
Let there be <code class="reqn">k</code> treatment levels (excluding the control),
then <code class="reqn">k</code> pairwise comparisons can be performed between
the <code class="reqn">i</code>-th treatment level and the control.
H<code class="reqn">_i: \theta_0 = \theta_i</code> is tested in the one-tailed case (less) against
A<code class="reqn">_i: \theta_0 &gt; \theta_i, ~~ (1 \le i \le k)</code>.
</p>
<p>For each control - treatment level the data are ranked in increasing order.
The ranksum <code class="reqn">R_i</code> for the <code class="reqn">i</code>-th treatment level is compared
to a critical <code class="reqn">R</code> value and is significantly(<code class="reqn">p = 0.05</code>) less,
if <code class="reqn">R_i \le R</code>. For the <code>alternative = "greater"</code> the sign is changed.
</p>
<p>The function does not return p-values. Instead the critical <code class="reqn">R</code>-values
as given in the tables of USEPA (2002) for <code class="reqn">\alpha = 0.05</code> (one-sided, less)
are looked up according to the balanced sample sizes (<code class="reqn">n</code>) and the order number of the
dose level (<code class="reqn">i</code>).
</p>


<h3>Value</h3>

<p>A list with class <code>"osrt"</code> that contains the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>


<h3>Source</h3>

<p>The critical rank sum values were taken from Table E.5 of USEPA (2002).
</p>
<p>USEPA (2002) <em>Short-term Methods for Estimating the
Chronic Toxicity of Effluents and Receiving
Waters to Freshwater Organisms</em>, 4th edition, EPA-821-R-02-013.
</p>


<h3>Note</h3>

<p>Steel's Many-to-One Rank test is only applicable for balanced designs and
directional hypotheses. An error message will occur, if the design is unbalanced.
In the current implementation, only one-sided tests on
the level of <code class="reqn">\alpha = 0.05</code> can be performed.
</p>


<h3>References</h3>

<p>Steel, R. G. D. (1959) A multiple comparison rank sum test:
treatments versus control, <em>Biometrics</em> <b>15</b>, 560&ndash;572.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>, <code><a href="stats.html#topic+pairwise.wilcox.test">pairwise.wilcox.test</a></code>,
<code><a href="#topic+manyOneUTest">manyOneUTest</a></code>, <code><a href="#topic+flignerWolfeTest">flignerWolfeTest</a></code>,
<code><a href="#topic+shirleyWilliamsTest">shirleyWilliamsTest</a></code>, <code><a href="#topic+kwManyOneDunnTest">kwManyOneDunnTest</a></code>,
<code><a href="#topic+kwManyOneNdwTest">kwManyOneNdwTest</a></code>, <code><a href="#topic+kwManyOneConoverTest">kwManyOneConoverTest</a></code>,
<code><a href="#topic+print.osrt">print.osrt</a></code>, <code><a href="#topic+summary.osrt">summary.osrt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
110, 125, 143, 148, 151,
136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("0", "I", "II")

## Steel's Test
steelTest(x ~ g)


## Example from USEPA (2002):
## Reproduction data from a Ceriodaphnia dubia
## 7-day chronic test to several concentrations
## of effluent. Dose level 50% is excluded.
x &lt;- c(20, 26, 26, 23, 24, 27, 26, 23, 27, 24,
13, 15, 14, 13, 23, 26, 0, 25, 26, 27,
18, 22, 13, 13, 23, 22, 20, 22, 23, 22,
14, 22, 20, 23, 20, 23, 25, 24, 25, 21,
9, 0, 9, 7, 6, 10, 12, 14, 9, 13,
rep(0,10))
g &lt;- gl(6, 10)
levels(g) &lt;- c("Control", "3%", "6%", "12%", "25%", "50%")

## NOEC at 3%, LOEC at 6%
steelTest(x ~ g, subset = g != "50%", alternative = "less")



</code></pre>

<hr>
<h2 id='stepDownTrendTest'>Step Down Trend Tests</h2><span id='topic+stepDownTrendTest'></span><span id='topic+stepDownTrendTest.default'></span><span id='topic+stepDownTrendTest.formula'></span>

<h3>Description</h3>

<p>Performs step-down trend test procedures for monotone responses
to detect NOEC (LOEC) according to OECD (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepDownTrendTest(x, ...)

## Default S3 method:
stepDownTrendTest(
  x,
  g,
  test = c("leTest", "spearmanTest", "jonckheereTest", "cuzickTest", "chackoTest",
    "johnsonTest"),
  alternative = c("two.sided", "greater", "less"),
  continuity = FALSE,
  ...
)

## S3 method for class 'formula'
stepDownTrendTest(
  formula,
  data,
  subset,
  na.action,
  test = c("leTest", "spearmanTest", "jonckheereTest", "cuzickTest", "chackoTest",
    "johnsonTest"),
  alternative = c("two.sided", "greater", "less"),
  continuity = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepDownTrendTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_test">test</code></td>
<td>
<p>the trend test that shall be performed. Defaults to <code>"leTest"</code>.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_continuity">continuity</code></td>
<td>
<p>logical indicator whether a continuity correction
shall be performed. Only relevant for <code>"jonckheereTest"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="stepDownTrendTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to OECD 2006 one can perform a test for trend
on responses from all dose groups including the control.
If the trend test is significant at the 0.05 level, the
high dose group is omitted, and the trend
statistic with the remaining dose groups is re-compute
The procedure is continued until the trend test is
first non-significant at the 0.05 level, then stop.
</p>
<p>The NOEC is the highest dose
remaining at this stage. If this test is significant
when only the lowest dose and control remain,
then a NOEC cannot be established from the data.
</p>


<h3>Value</h3>

<p>A list with class <code>"trendPMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Factor labels for <code>g</code> must be assigned in such a way,
that they can be increasingly ordered from zero-dose
control to the highest dose level, e.g. integers {0, 1, 2, ..., k} or
letters {a, b, c, ...}. Otherwise the function may not
select the correct values for intended zero-dose control.
</p>
<p>It is safer, to i) label the factor levels as given above,
and to ii) sort the data according to increasing dose-levels
prior to call the function (see <code><a href="base.html#topic+order">order</a></code>, <code><a href="base.html#topic+factor">factor</a></code>).
</p>


<h3>References</h3>

<p>OECD (2006) <em>Current Approaches in the Statistical
Analysis of Ecotoxicity Data: A Guidance to Application</em>,
OECD Series on Testing and Assessment <b>52</b>,
Paris: Organisation for Econonomic Co-operation and Development.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leTest">leTest</a></code>, <code><a href="#topic+jonckheereTest">jonckheereTest</a></code>,
<code><a href="#topic+spearmanTest">spearmanTest</a></code>, <code><a href="#topic+cuzickTest">cuzickTest</a></code>,
<code><a href="#topic+chackoTest">chackoTest</a></code>, <code><a href="#topic+johnsonTest">johnsonTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- stepDownTrendTest(Y ~ DOSE, data = trout,
                         test = "jonckheereTest",
                         alternative = "less")
## print method
res
## summary method
summary(res)
</code></pre>

<hr>
<h2 id='summary.gesdTest'>Summarize an gesdTest Object</h2><span id='topic+summary.gesdTest'></span>

<h3>Description</h3>

<p>Summarize an object of class <em>gesdTest</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gesdTest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gesdTest_+3A_object">object</code></td>
<td>
<p>an object of class <code>"gesdTest"</code>.</p>
</td></tr>
<tr><td><code id="summary.gesdTest_+3A_...">...</code></td>
<td>
<p>further arguments. Currenly ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.mandel'>Object Summary for class <code>"mandel"</code></h2><span id='topic+summary.mandel'></span>

<h3>Description</h3>

<p><code>summary.mandel</code> is a function
used to produce result summaries of the results of
the functions <code><a href="#topic+mandelhTest">mandelhTest</a></code> or <code><a href="#topic+mandelkTest">mandelkTest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mandel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mandel_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mandel"</code> for
which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.mandel_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mandelhTest">mandelhTest</a></code>, <code><a href="#topic+mandelkTest">mandelkTest</a></code>
</p>

<hr>
<h2 id='summary.osrt'>Summarize an osrt Object</h2><span id='topic+summary.osrt'></span>

<h3>Description</h3>

<p>Summarize an object of class <em>osrt</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'osrt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.osrt_+3A_object">object</code></td>
<td>
<p>an object of class <code>"osrt"</code>.</p>
</td></tr>
<tr><td><code id="summary.osrt_+3A_...">...</code></td>
<td>
<p>further arguments. Currenly ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+print.osrt">print.osrt</a></code>.
</p>

<hr>
<h2 id='summary.PMCMR'>Summarize an PMCMR Object</h2><span id='topic+summary.PMCMR'></span>

<h3>Description</h3>

<p>Summarize an object of class <em>PMCMR</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PMCMR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PMCMR_+3A_object">object</code></td>
<td>
<p>an object of class <code>"PMCMR"</code>.</p>
</td></tr>
<tr><td><code id="summary.PMCMR_+3A_...">...</code></td>
<td>
<p>further arguments. Currenly ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A detailed output of all pairwise hypotheses,
the test statistics, the corresponding p-values and
symbols that indicates the level of significance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.PMCMR">print.PMCMR</a></code>, <code><a href="#topic+summaryGroup">summaryGroup</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ans &lt;- vanWaerdenAllPairsTest(count ~ spray, InsectSprays)
summary(ans)
</code></pre>

<hr>
<h2 id='summary.trendPMCMR'>Summarize an trendPMCMR Object</h2><span id='topic+summary.trendPMCMR'></span>

<h3>Description</h3>

<p>Summarize an object of class <em>trendPMCMR</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trendPMCMR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.trendPMCMR_+3A_object">object</code></td>
<td>
<p>an object of class <code>"trendPMCMR"</code>.</p>
</td></tr>
<tr><td><code id="summary.trendPMCMR_+3A_...">...</code></td>
<td>
<p>further arguments. Currenly ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A detailed output of all pairwise hypotheses,
the test statistics, the corresponding p-values and
symbols that indicates the level of significance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.trendPMCMR">print.trendPMCMR</a></code>
</p>

<hr>
<h2 id='summaryGroup'>Grouped Summary of an PMCMR Object</h2><span id='topic+summaryGroup'></span>

<h3>Description</h3>

<p>Performes a grouped summary on an PMCMR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryGroup(x, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryGroup_+3A_x">x</code></td>
<td>
<p>an object of class <code>"PMCMR"</code>.</p>
</td></tr>
<tr><td><code id="summaryGroup_+3A_alpha">alpha</code></td>
<td>
<p>the selected alpha-level. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="summaryGroup_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provides summary statistics for each factor level
and a letter symbol, whereas different letters indicate
significant differences between factor levels based on the
selected level of alpha.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.PMCMR">summary.PMCMR</a></code>
</p>

<hr>
<h2 id='tamhaneDunnettTest'>Tamhane-Dunnett Many-to-One Comparison Test</h2><span id='topic+tamhaneDunnettTest'></span><span id='topic+tamhaneDunnettTest.default'></span><span id='topic+tamhaneDunnettTest.formula'></span><span id='topic+tamhaneDunnettTest.aov'></span>

<h3>Description</h3>

<p>Performs Tamhane-Dunnett's multiple comparisons test with one control.
For many-to-one comparisons in an one-factorial layout
with normally distributed residuals and unequal variances
Tamhane-Dunnett's test can be used.
Let <code class="reqn">X_{0j}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization of the control group
(<code class="reqn">1 \le j \le n_0</code>) and <code class="reqn">X_{ij}</code> the <code class="reqn">j</code>-the realization
in the <code class="reqn">i</code>-th treatment group (<code class="reqn">1 \le i \le k</code>).
Furthermore, the total sample size is <code class="reqn">N = n_0 + \sum_{i=1}^k n_i</code>.
A total of <code class="reqn">m = k</code> hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{i}: \mu_i = \mu_0</code> is tested against the alternative
A<code class="reqn">_{i}: \mu_i \ne \mu_0</code> (two-tailed). Tamhane-Dunnett's test
statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{i} \frac{\bar{X}_i - \bar{X_0}}
 {\left( s^2_0 / n_0 + s^2_i / n_i \right)^{1/2} } ~~
 (1 \le i \le k)
</code>
</p>

<p>The null hypothesis is rejected if
<code class="reqn">|t_{i}| &gt; T_{kv_{i}\rho_{ij}\alpha}</code> (two-tailed),
with
</p>
<p style="text-align: center;"><code class="reqn">
 v_i = n_0 + n_i - 2
</code>
</p>

<p>degree of freedom and the correlation
</p>
<p style="text-align: center;"><code class="reqn">
 \rho_{ii} = 1, ~ \rho_{ij} = 0 ~ (i \ne j).
</code>
</p>

<p>The p-values are computed from the multivariate-t
distribution as implemented in the function
<code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code> distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tamhaneDunnettTest(x, ...)

## Default S3 method:
tamhaneDunnettTest(x, g, alternative = c("two.sided", "greater", "less"), ...)

## S3 method for class 'formula'
tamhaneDunnettTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  ...
)

## S3 method for class 'aov'
tamhaneDunnettTest(x, alternative = c("two.sided", "greater", "less"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tamhaneDunnettTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="tamhaneDunnettTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="tamhaneDunnettTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="tamhaneDunnettTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis.
Defaults to <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="tamhaneDunnettTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="tamhaneDunnettTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="tamhaneDunnettTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="tamhaneDunnettTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>OECD (ed. 2006) <em>Current approaches in the statistical analysis
of ecotoxicity data: A guidance to application - Annexes</em>. OECD Series
on testing and assessment, No. 54.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>, <code><a href="#topic+welchManyOneTTest">welchManyOneTTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(245)
mn &lt;- c(1, 2, 2^2, 2^3, 2^4)
x &lt;- rep(mn, each=5) + rnorm(25)
g &lt;- factor(rep(1:5, each=5))

fit &lt;- aov(x ~ g - 1)
shapiro.test(residuals(fit))
bartlett.test(x ~ g - 1)
anova(fit)
## works with object of class aov
summary(tamhaneDunnettTest(fit, alternative = "greater"))

</code></pre>

<hr>
<h2 id='tamhaneT2Test'>Tamhane's T2 Test</h2><span id='topic+tamhaneT2Test'></span><span id='topic+tamhaneT2Test.default'></span><span id='topic+tamhaneT2Test.formula'></span><span id='topic+tamhaneT2Test.aov'></span>

<h3>Description</h3>

<p>Performs Tamhane's T2 (or T2') all-pairs comparison test for normally distributed
data with unequal variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tamhaneT2Test(x, ...)

## Default S3 method:
tamhaneT2Test(x, g, welch = TRUE, ...)

## S3 method for class 'formula'
tamhaneT2Test(formula, data, subset, na.action, welch = TRUE, ...)

## S3 method for class 'aov'
tamhaneT2Test(x, welch = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tamhaneT2Test_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="tamhaneT2Test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="tamhaneT2Test_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="tamhaneT2Test_+3A_welch">welch</code></td>
<td>
<p>indicates, whether Welch's approximate solution for
calculating the degree of freedom shall be used or, as usually,
<code class="reqn">df = N - 2</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tamhaneT2Test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="tamhaneT2Test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="tamhaneT2Test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="tamhaneT2Test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals but unequal groups variances
the T2 test (or T2' test) of Tamhane can be performed.
Let <code class="reqn">X_{ij}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization (<code class="reqn">1 \le j \le n_i</code>)
in the <code class="reqn">i</code>-th group (<code class="reqn">1 \le i \le k</code>). Furthermore, the total
sample size is <code class="reqn">N = \sum_{i=1}^k n_i</code>. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{ij}: \mu_i = \mu_j ~~ (i \ne j)</code> is tested against the alternative
A<code class="reqn">_{ij}: \mu_i \ne \mu_j</code> (two-tailed). Tamhane T2 all-pairs
test statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{ij} \frac{\bar{X}_i - \bar{X_j}}
 {\left( s^2_j / n_j + s^2_i / n_i \right)^{1/2}}, ~~
 (i \ne j)
</code>
</p>

<p>with <code class="reqn">s^2_i</code> the variance of the <code class="reqn">i</code>-th group.
The null hypothesis is rejected (two-tailed) if
</p>
<p style="text-align: center;"><code class="reqn">
 \mathrm{Pr} \left\{ |t_{ij}| \ge t_{v_{ij}\alpha'/2} | \mathrm{H} \right\}_{ij} =
 \alpha.
</code>
</p>

<p>T2 test uses Welch's approximate solution for
calculating the degree of freedom.
</p>
<p style="text-align: center;"><code class="reqn">
 v_{ij} = \frac{\left( s^2_i / n_i + s^2_j / n_j \right)^2}
 {s^4_i / n^2_i \left(n_i - 1\right) + s^4_j / n^2_j \left(n_j - 1\right)}.
</code>
</p>

<p>T2' test applies the following approximation for the degree of freedom
</p>
<p style="text-align: center;"><code class="reqn">
 v_{ij} = n_i + n_j - 2
</code>
</p>

<p>The p-values are computed from the <code><a href="stats.html#topic+TDist">TDist</a></code>-distribution
and adjusted according to Dunn-Sidak.
</p>
<p style="text-align: center;"><code class="reqn">
 p'_{ij} = \min \left\{1, ~ (1 - (1 - p_{ij})^m)\right\}
</code>
</p>



<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>Note</h3>

<p>T2 test is basically an all-pairs pairwise-t-test. Similar results
can be obtained with <code>pairwise.t.test(..., var.equal=FALSE, p.adjust.mehod = FALSE)</code>.
</p>
<p>A warning message appears
in the modified T2' test, if none of in Tamhane (1979) given conditions
for nearly balanced
sample sizes and nearly balanced standard errors is true.
</p>
<p>Thanks to Sirio Bolaños for his kind suggestion for adding T2' test
into this function.
</p>


<h3>References</h3>

<p>Tamhane, A. C. (1979) A Comparison of Procedures for Multiple Comparisons
of Means with Unequal Variances, <em>Journal of the American
Statistical Association</em> <b>74</b>, 471&ndash;480.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dunnettT3Test">dunnettT3Test</a></code> <code><a href="#topic+uryWigginsHochbergTest">uryWigginsHochbergTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts) # var1 = varN
anova(fit)

## also works with fitted objects of class aov
res &lt;- tamhaneT2Test(fit)
summary(res)
summaryGroup(res)
res

## compare with pairwise.t.test
WT &lt;- pairwise.t.test(chickwts$weight,
                      chickwts$feed,
                      pool.sd = FALSE,
                      p.adjust.method = "none")
p.adj.sidak &lt;- function(p, m) sapply(p, function(p) min(1, 1 - (1 - p)^m))
p.raw &lt;- as.vector(WT$p.value)
m &lt;- length(p.raw[!is.na(p.raw)])
PADJ &lt;- matrix(ans &lt;- p.adj.sidak(p.raw, m),
               nrow = 5, ncol = 5)
colnames(PADJ) &lt;- colnames(WT$p.value)
rownames(PADJ) &lt;- rownames(WT$p.value)
PADJ

## same without Welch's approximate solution
summary(T2b &lt;- tamhaneT2Test(fit, welch = FALSE))

</code></pre>

<hr>
<h2 id='toTidy'>Convert a PMCMR or osrt Object to a Data.Frame</h2><span id='topic+toTidy'></span>

<h3>Description</h3>

<p>The functions converts a list object of class <code>"PMCMR"</code>
or <code>"osrt"</code> into a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toTidy(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toTidy_+3A_mod">mod</code></td>
<td>
<p>an object of class <code>"PMCMR"</code>, <code>"trendPMCMR"</code> or <code>"osrt"</code>.</p>
</td></tr>
<tr><td><code id="toTidy_+3A_...">...</code></td>
<td>
<p>further arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>Author(s)</h3>

<p>Indrajeet Patil (via email, 2020-1022),
modified by Thorsten Pohlert
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- tukeyTest(weight ~ Diet, data = ChickWeight, subset = Time == 21)
toTidy(res)

</code></pre>

<hr>
<h2 id='trout'>Data from a Dose-Response Experiment with Trouts</h2><span id='topic+trout'></span>

<h3>Description</h3>

<p>This data set contains results from a dose-response experiment with trouts.
The experiment was conducted with five doses of 10, 25, 60, 150 and
1000 ppm, respectively, plus a zero-dose control. The response is
trout weight in mg.
</p>


<h3>Format</h3>

<p>A data frame with 65 observations on the following 5 variables.
</p>

<dl>
<dt>CONC</dt><dd><p>a numeric vector of dose concentration in ppm</p>
</dd>
<dt>DOSE</dt><dd><p>a factor with levels <code>1</code> <code>2</code>
<code>3</code> <code>4</code> <code>5</code> <code>6</code></p>
</dd>
<dt>REPA</dt><dd><p>a factor with levels <code>1</code> <code>2</code></p>
</dd>
<dt>REPC</dt><dd><p>a factor with levels <code>1</code> <code>2</code></p>
</dd>
<dt>Y</dt><dd><p>a numeric vector of trout weight in mg</p>
</dd>
</dl>



<h3>Source</h3>

<p>ENV/JM/MONO(2006)18/ANN, page 113.
</p>


<h3>References</h3>

<p>OECD (ed. 2006) <em>Current approaches in the statistical analysis
of ecotoxicity data: A guidance to application - Annexes</em>. OECD Series
on testing and assessment, No. 54, (ENV/JM/MONO(2006)18/ANN).
</p>

<hr>
<h2 id='tukeyTest'>Tukey's Multiple Comparison Test</h2><span id='topic+tukeyTest'></span><span id='topic+tukeyTest.default'></span><span id='topic+tukeyTest.formula'></span><span id='topic+tukeyTest.aov'></span>

<h3>Description</h3>

<p>Performs Tukey's all-pairs comparisons test for normally distributed
data with equal group variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukeyTest(x, ...)

## Default S3 method:
tukeyTest(x, g, ...)

## S3 method for class 'formula'
tukeyTest(formula, data, subset, na.action, ...)

## S3 method for class 'aov'
tukeyTest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukeyTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="tukeyTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="tukeyTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="tukeyTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="tukeyTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="tukeyTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="tukeyTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals and equal variances
Tukey's test can be performed.
Let <code class="reqn">X_{ij}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization (<code class="reqn">1 \le j \le n_i</code>)
in the <code class="reqn">i</code>-th group (<code class="reqn">1 \le i \le k</code>). Furthermore, the total
sample size is <code class="reqn">N = \sum_{i=1}^k n_i</code>. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{ij}: \mu_i = \mu_j ~~ (i \ne j)</code> is tested against the alternative
A<code class="reqn">_{ij}: \mu_i \ne \mu_j</code> (two-tailed). Tukey's all-pairs test
statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{ij} \frac{\bar{X}_i - \bar{X_j}}
 {s_{\mathrm{in}} \left(1/n_j + 1/n_i\right)^{1/2}}, ~~
 (i \ne j)
</code>
</p>

<p>with <code class="reqn">s^2_{\mathrm{in}}</code> the within-group ANOVA variance.
The null hypothesis is rejected if <code class="reqn">|t_{ij}| &gt; q_{vm\alpha} / \sqrt{2}</code>,
with <code class="reqn">v = N - k</code> degree of freedom. The p-values are computed
from the <code><a href="stats.html#topic+Tukey">Tukey</a></code> distribution.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Sachs, L. (1997) <em>Angewandte Statistik</em>, New York: Springer.
</p>
<p>Tukey, J. (1949) Comparing Individual Means in the Analysis of Variance,
<em>Biometrics</em> <b>5</b>, 99&ndash;114.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Tukey">Tukey</a></code>, <code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts)
anova(fit)

## also works with fitted objects of class aov
res &lt;- tukeyTest(fit)
summary(res)
summaryGroup(res)
</code></pre>

<hr>
<h2 id='uryWigginsHochbergTest'>Ury, Wiggins, Hochberg Test</h2><span id='topic+uryWigginsHochbergTest'></span><span id='topic+uryWigginsHochbergTest.default'></span><span id='topic+uryWigginsHochbergTest.formula'></span><span id='topic+uryWigginsHochbergTest.aov'></span>

<h3>Description</h3>

<p>Performs Ury-Wiggins and Hochberg's all-pairs comparison test
for normally distributed data with unequal variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uryWigginsHochbergTest(x, ...)

## Default S3 method:
uryWigginsHochbergTest(x, g, p.adjust.method = p.adjust.methods, ...)

## S3 method for class 'formula'
uryWigginsHochbergTest(
  formula,
  data,
  subset,
  na.action,
  p.adjust.method = p.adjust.methods,
  ...
)

## S3 method for class 'aov'
uryWigginsHochbergTest(x, p.adjust.method = p.adjust.methods, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uryWigginsHochbergTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="uryWigginsHochbergTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="uryWigginsHochbergTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="uryWigginsHochbergTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="uryWigginsHochbergTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="uryWigginsHochbergTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="uryWigginsHochbergTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="uryWigginsHochbergTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with normally distributed residuals but unequal groups variances
the tests of Ury-Wiggins and Hochberg can be performed.
Let <code class="reqn">X_{ij}</code> denote a continuous random variable
with the <code class="reqn">j</code>-the realization (<code class="reqn">1 \le j \le n_i</code>)
in the <code class="reqn">i</code>-th group (<code class="reqn">1 \le i \le k</code>). Furthermore, the total
sample size is <code class="reqn">N = \sum_{i=1}^k n_i</code>. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested: The null hypothesis is
H<code class="reqn">_{ij}: \mu_i = \mu_j ~~ (i \ne j)</code> is tested against the alternative
A<code class="reqn">_{ij}: \mu_i \ne \mu_j</code> (two-tailed). Ury-Wiggins and Hochberg
all-pairs test statistics are given by
</p>
<p style="text-align: center;"><code class="reqn">
 t_{ij} \frac{\bar{X}_i - \bar{X_j}}
 {\left( s^2_j / n_j + s^2_i / n_i \right)^{1/2}}, ~~
 (i \ne j)
</code>
</p>

<p>with <code class="reqn">s^2_i</code> the variance of the <code class="reqn">i</code>-th group.
The null hypothesis is rejected (two-tailed) if
</p>
<p style="text-align: center;"><code class="reqn">
 \mathrm{Pr} \left\{ |t_{ij}| \ge t_{v_{ij}\alpha'/2} | \mathrm{H} \right\}_{ij} =
 \alpha,
</code>
</p>

<p>with Welch's approximate equation for degree of freedom as
</p>
<p style="text-align: center;"><code class="reqn">
 v_{ij} = \frac{\left( s^2_i / n_i + s^2_j / n_j \right)^2}
 {s^4_i / n^2_i \left(n_i - 1\right) + s^4_j / n^2_j \left(n_j - 1\right)}.
</code>
</p>

<p>The p-values are computed from the <code><a href="stats.html#topic+TDist">TDist</a></code>-distribution.
The type of test depends
on the selected p-value adjustment method (see also <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>):
</p>

<dl>
<dt>bonferroni</dt><dd><p>the Ury-Wiggins test is performed with Bonferroni adjusted
p-values.</p>
</dd>
<dt>hochberg</dt><dd><p>the Hochberg test is performed with Hochberg's adjusted
p-values</p>
</dd></dl>
<p>.

</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hochberg, Y. (1976) A Modification of the T-Method of Multiple
Comparisons for a One-Way Layout With Unequal Variances,
<em>Journal of the American Statistical Association</em> <b>71</b>, 200&ndash;203.
</p>
<p>Ury, H. and Wiggins, A. D. (1971) Large Sample and Other
Multiple Comparisons Among Means, <em>British Journal of
Mathematical and Statistical Psychology</em> <b>24</b>, 174&ndash;194.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dunnettT3Test">dunnettT3Test</a></code> <code><a href="#topic+tamhaneT2Test">tamhaneT2Test</a></code> <code><a href="stats.html#topic+TDist">TDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- aov(weight ~ feed, chickwts)
shapiro.test(residuals(fit))
bartlett.test(weight ~ feed, chickwts) # var1 = varN
anova(fit)

## also works with fitted objects of class aov
res &lt;- uryWigginsHochbergTest(fit)
summary(res)
summaryGroup(res)

</code></pre>

<hr>
<h2 id='vanWaerdenAllPairsTest'>van-der-Waerden's All-Pairs Comparison Normal Scores Test</h2><span id='topic+vanWaerdenAllPairsTest'></span><span id='topic+vanWaerdenAllPairsTest.default'></span><span id='topic+vanWaerdenAllPairsTest.formula'></span>

<h3>Description</h3>

<p>Performs van-der-Waerden all-pairs comparison
normal scores test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanWaerdenAllPairsTest(x, ...)

## Default S3 method:
vanWaerdenAllPairsTest(
  x,
  g,
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
vanWaerdenAllPairsTest(
  formula,
  data,
  subset,
  na.action,
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vanWaerdenAllPairsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="vanWaerdenAllPairsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="vanWaerdenAllPairsTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="vanWaerdenAllPairsTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="vanWaerdenAllPairsTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="vanWaerdenAllPairsTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="vanWaerdenAllPairsTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="vanWaerdenAllPairsTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all-pairs comparisons in an one-factorial layout
with non-normally distributed residuals van-der-Waerden's
normal scores transformation can be used prior to
an all-pairs comparison test. A total of <code class="reqn">m = k(k-1)/2</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{ij}: F_i(x) = F_j(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{ij}: F_i(x) \ne F_j(x), ~~ i \ne j</code>.
For <code>p.adjust.method = "single-step"</code> the
Tukey's studentized range distribution is used to calculate
p-values (see <code><a href="stats.html#topic+Tukey">Tukey</a></code>). Otherwise, the
t-distribution is used for the calculation of p-values
with a latter p-value adjustment as
performed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Conover, W. J., Iman, R. L. (1979) <em>On multiple-comparisons procedures</em>,
Tech. Rep. LA-7677-MS, Los Alamos Scientific Laboratory.
</p>
<p>van der Waerden, B. L. (1952) Order tests for the two-sample
problem and their power, <em>Indagationes Mathematicae</em> <b>14</b>, 453&ndash;458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vanWaerdenTest">vanWaerdenTest</a></code>, <code><a href="#topic+vanWaerdenManyOneTest">vanWaerdenManyOneTest</a></code>,
<code><a href="SuppDists.html#topic+normOrder">normOrder</a></code>.
</p>

<hr>
<h2 id='vanWaerdenManyOneTest'>van-der-Waerden's Many-One Comparisons Normal Scores Test</h2><span id='topic+vanWaerdenManyOneTest'></span><span id='topic+vanWaerdenManyOneTest.default'></span><span id='topic+vanWaerdenManyOneTest.formula'></span>

<h3>Description</h3>

<p>Performs van-der-Waerden's multiple comparison
normal scores test with one control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanWaerdenManyOneTest(x, ...)

## Default S3 method:
vanWaerdenManyOneTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)

## S3 method for class 'formula'
vanWaerdenManyOneTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = c("single-step", p.adjust.methods),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vanWaerdenManyOneTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="vanWaerdenManyOneTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="vanWaerdenManyOneTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="vanWaerdenManyOneTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="vanWaerdenManyOneTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="vanWaerdenManyOneTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="vanWaerdenManyOneTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="vanWaerdenManyOneTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="vanWaerdenManyOneTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons in an one-factorial layout
with non-normally distributed residuals van-der-Waerden's
normal scores transformation can be used prior to
a many-to-one comparison test. A total of <code class="reqn">m = k-1</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{i}: F_0(x) = F_i(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{i}: F_0(x) \ne F_i(x), ~~ 1 \le i \le k-1</code>.
For <code>p.adjust.method = "single-step"</code> the
multivariate t distribution is used to calculate
p-values (see <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>). Otherwise, the
t-distribution is used for the calculation of p-values
with a latter p-value adjustment as
performed by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Conover, W. J., Iman, R. L. (1979) <em>On multiple-comparisons procedures</em>,
Tech. Rep. LA-7677-MS, Los Alamos Scientific Laboratory.
</p>
<p>van der Waerden, B. L. (1952) Order tests for the two-sample
problem and their power, <em>Indagationes Mathematicae</em> <b>14</b>, 453&ndash;458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vanWaerdenTest">vanWaerdenTest</a></code>, <code><a href="#topic+vanWaerdenAllPairsTest">vanWaerdenAllPairsTest</a></code>,
<code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data set PlantGrowth
## Global test
vanWaerdenTest(weight ~ group, data = PlantGrowth)

## van-der-Waerden's many-one comparison test
ans &lt;- vanWaerdenManyOneTest(weight ~ group,
                             data = PlantGrowth,
                             p.adjust.method = "holm")
summary(ans)
</code></pre>

<hr>
<h2 id='vanWaerdenTest'>van der Waerden's Normal Scores Test</h2><span id='topic+vanWaerdenTest'></span><span id='topic+vanWaerdenTest.default'></span><span id='topic+vanWeardenTest.default'></span><span id='topic+vanWaerdenTest.formula'></span>

<h3>Description</h3>

<p>Performs van der Waerden's normal scores test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanWaerdenTest(x, ...)

## Default S3 method:
vanWaerdenTest(x, g, ...)

## S3 method for class 'formula'
vanWaerdenTest(formula, data, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vanWaerdenTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="vanWaerdenTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="vanWaerdenTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="vanWaerdenTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="vanWaerdenTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="vanWaerdenTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="vanWaerdenTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For one-factorial designs with non-normally distributed
residuals van der Waerden's normal scores test can be performed to test
the H<code class="reqn">_0: F_1(x) = F_2(x) = \ldots = F_k(x)</code> against
the H<code class="reqn">_\mathrm{A}: F_i (x) \ne F_j(x)~ (i \ne j)</code> with at least
one strict inequality.
</p>


<h3>Note</h3>

<p>A tie correction is not applied in this function.
</p>


<h3>References</h3>

<p>Conover, W. J., Iman, R. L. (1979) <em>On multiple-comparisons procedures</em>,
Tech. Rep. LA-7677-MS, Los Alamos Scientific Laboratory.
</p>
<p>van der Waerden, B. L. (1952) Order tests for the two-sample
problem and their power, <em>Indagationes Mathematicae</em> <b>14</b>, 453&ndash;458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kruskalTest">kruskalTest</a></code>, <code><a href="#topic+normalScoresTest">normalScoresTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vanWaerdenTest(count ~ spray, data = InsectSprays)

</code></pre>

<hr>
<h2 id='welchManyOneTTest'>Welchs's Many-To-One Comparison Test</h2><span id='topic+welchManyOneTTest'></span><span id='topic+welchManyOneTTest.default'></span><span id='topic+welchManyOneTTest.formula'></span><span id='topic+welchManyOneTTest.aov'></span>

<h3>Description</h3>

<p>Performs Welchs's t-test for multiple comparisons with one control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>welchManyOneTTest(x, ...)

## Default S3 method:
welchManyOneTTest(
  x,
  g,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = p.adjust.methods,
  ...
)

## S3 method for class 'formula'
welchManyOneTTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = p.adjust.methods,
  ...
)

## S3 method for class 'aov'
welchManyOneTTest(
  x,
  alternative = c("two.sided", "greater", "less"),
  p.adjust.method = p.adjust.methods,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="welchManyOneTTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, a list of numeric data
vectors or a fitted model object, usually an <a href="stats.html#topic+aov">aov</a> fit.</p>
</td></tr>
<tr><td><code id="welchManyOneTTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="welchManyOneTTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="welchManyOneTTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis.
Defaults to <code>two.sided</code>.</p>
</td></tr>
<tr><td><code id="welchManyOneTTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values
(see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).</p>
</td></tr>
<tr><td><code id="welchManyOneTTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="welchManyOneTTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="welchManyOneTTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="welchManyOneTTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many-to-one comparisons in an one-factorial layout
with normally distributed residuals and unequal variances
Welch's t-test can be used. A total of <code class="reqn">m = k-1</code>
hypotheses can be tested. The null hypothesis
H<code class="reqn">_{i}: \mu_0(x) = \mu_i(x)</code> is tested in the two-tailed test
against the alternative
A<code class="reqn">_{i}: \mu_0(x) \ne \mu_i(x), ~~ 1 \le i \le k-1</code>.
</p>
<p>This function is basically a wrapper function for
<code><a href="stats.html#topic+t.test">t.test</a>(..., var.equal = FALSE)</code>. The p-values for the test
are calculated from the t distribution
and can be adusted with any method that is implemented in
<code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"PMCMR"</code> containing the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>lower-triangle matrix of the estimated
quantiles of the pairwise test statistics.</p>
</dd>
<dt>p.value</dt><dd><p>lower-triangle matrix of the p-values for the pairwise tests.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>p.adjust.method</dt><dd><p>a character string describing the method for p-value
adjustment.</p>
</dd>
<dt>model</dt><dd><p>a data frame of the input data.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>



<h3>References</h3>

<p>Welch, B. L. (1947) The generalization of &quot;Student's&quot; problem
when several different population variances are involved,
<em>Biometrika</em> <b>34</b>, 28&ndash;35.
</p>
<p>Welch, B. L. (1951) On the comparison of several mean values:
An alternative approach, <em>Biometrika</em> <b>38</b>, 330&ndash;336.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>, <code><a href="stats.html#topic+t.test">t.test</a></code>,
<code><a href="stats.html#topic+p.adjust">p.adjust</a></code>, <code><a href="#topic+tamhaneDunnettTest">tamhaneDunnettTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(245)
mn &lt;- rep(c(1, 2^(1:4)), each=5)
sd &lt;- rep(1:5, each=5)
x &lt;- mn + rnorm(25, sd = sd)
g &lt;- factor(rep(1:5, each=5))

fit &lt;- aov(x ~ g)
shapiro.test(residuals(fit))
bartlett.test(x ~ g)
anova(fit)
summary(welchManyOneTTest(fit, alternative = "greater", p.adjust="holm"))

</code></pre>

<hr>
<h2 id='williamsTest'>Williams Trend Test</h2><span id='topic+williamsTest'></span><span id='topic+williamsTest.default'></span><span id='topic+williamsTest.formula'></span><span id='topic+williamsTest.aov'></span>

<h3>Description</h3>

<p>Performs Williams' test for contrasting increasing (decreasing) dose levels of a treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>williamsTest(x, ...)

## Default S3 method:
williamsTest(x, g, alternative = c("greater", "less"), ...)

## S3 method for class 'formula'
williamsTest(
  formula,
  data,
  subset,
  na.action,
  alternative = c("greater", "less"),
  ...
)

## S3 method for class 'aov'
williamsTest(x, alternative = c("greater", "less"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="williamsTest_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values, or a list of numeric data
vectors.</p>
</td></tr>
<tr><td><code id="williamsTest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="williamsTest_+3A_g">g</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of <code>"x"</code>.
Ignored with a warning if <code>"x"</code> is a list.</p>
</td></tr>
<tr><td><code id="williamsTest_+3A_alternative">alternative</code></td>
<td>
<p>the alternative hypothesis. Defaults to <code>greater</code></p>
</td></tr>
<tr><td><code id="williamsTest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>response ~ group</code> where
<code>response</code> gives the data values and <code>group</code> a vector or
factor of the corresponding groups.</p>
</td></tr>
<tr><td><code id="williamsTest_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="williamsTest_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a
subset of observations to be used.</p>
</td></tr>
<tr><td><code id="williamsTest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to <code>getOption("na.action")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Williams' test is a step-down trend test for testing several treatment levels
with a zero control in a one-factorial design with normally distributed
errors of homogeneous variance. Let there be <code class="reqn">k</code> groups including the control and let
the zero dose level be indicated with <code class="reqn">i = 0</code> and the treatment
levels indicated as <code class="reqn">1 \le i \le m</code>, then the following <code class="reqn">m = k - 1</code> hypotheses are tested:
</p>
<p style="text-align: center;"><code class="reqn">
\begin{array}{ll}
\mathrm{H}_{m}: \bar{x}_0 = m_1 = \ldots = m_m, &amp; \mathrm{A}_{m}: \bar{x}_0 \le m_1 \le \ldots m_m, \bar{x}_0 &lt; m_m \\
\mathrm{H}_{m-1}: \bar{x}_0 = m_1 = \ldots = m_{m-1}, &amp; \mathrm{A}_{m-1}: \bar{x}_0 \le m_1 \le \ldots m_{m-1}, \bar{x}_0 &lt; m_{m-1} \\
\vdots &amp; \vdots \\
\mathrm{H}_{1}: \bar{x}_0 = m_1, &amp; \mathrm{A}_{1}: \bar{x}_0 &lt; m_1,\\
\end{array}
</code>
</p>

<p>where <code class="reqn">m_i</code> denotes the isotonic mean of the <code class="reqn">i</code>th dose level group.
</p>
<p>William's test bases on a order restriction:
</p>
<p style="text-align: center;"><code class="reqn">
\mu_i^{*} = \max_{1\le u \le i}~\min_{i \le v \le m}~ \sum_{j=u}^v n_j \bar{x}_j^{*} ~/~ \sum_{j=u}^v n_j \qquad (1 \le i \le m),
</code>
</p>

<p>where <code class="reqn">\bar{x}_j^*</code> denotes the <code class="reqn">j</code>-th isotonic
mean estimated with isotonic regression using the
pool adjacent violators algorithm (PAVA) with the vector
of means <code class="reqn">\left\{\bar{x}_1, \bar{x}_2, \ldots, \bar{x}_m\right\}^T</code>
and the vector of weights
<code class="reqn">\left\{n_1, n_2, \ldots, n_m\right\}^T</code>.
</p>
<p>For the alternative hypothesis of decreasing trend,
max and min are interchanged in the above Equation.
</p>
<p>The <code class="reqn">i</code>-the test statistic is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
\bar{t}_i = \frac{\mu_m^* - \bar{x}_0}{s_{\mathrm{E}} \sqrt{1/n_m - 1/n_0}}
</code>
</p>

<p>The procedure starts from the highest dose level (<code class="reqn">m</code>) to the the lowest dose level (<code class="reqn">1</code>) and
stops at the first non-significant test. The consequent lowest effect dose
is the treatment level of the previous test number.
</p>
<p>The function does not return p-values. Instead the critical t-values
as given in the tables of Williams (1972) for <code class="reqn">\alpha = 0.05</code> (one-sided)
are looked up according to the degree of freedoms (<code class="reqn">v</code>) and the order number of the
dose level (<code class="reqn">i</code>) and (potentially) modified according to the given extrapolation
coefficient <code class="reqn">\beta</code>.
</p>
<p>Non tabulated values are linearly interpolated as recommended by Williams (1972).
The function <code><a href="stats.html#topic+approx">approx</a></code> is used.
</p>
<p>For the comparison of the first dose level (i = 1) with the control, the critical t-value
from the Student t distribution is used (<code><a href="stats.html#topic+TDist">TDist</a></code>).
</p>


<h3>Value</h3>

<p>A list with class <code>"osrt"</code> that contains the following components:
</p>

<dl>
<dt>method</dt><dd><p>a character string indicating what type of test was performed.</p>
</dd>
<dt>data.name</dt><dd><p>a character string giving the name(s) of the data.</p>
</dd>
<dt>statistic</dt><dd><p>the estimated statistic(s)</p>
</dd>
<dt>crit.value</dt><dd><p>critical values for <code class="reqn">\alpha = 0.05</code>.</p>
</dd>
<dt>alternative</dt><dd><p>a character string describing the alternative hypothesis.</p>
</dd>
<dt>parameter</dt><dd><p>the parameter(s) of the test distribution.</p>
</dd>
<dt>dist</dt><dd><p>a string that denotes the test distribution.</p>
</dd>
</dl>

<p>There are print and summary methods available.
</p>


<h3>Source</h3>

<p>The source code for the application of the pool adjacent violators
theorem to calculate the isotonic means
was taken from the file <code>"pava.f"</code>, which is included in the
package <span class="pkg">Iso</span>:
</p>
<p>Rolf Turner (2015). Iso: Functions to Perform Isotonic Regression. R
package version 0.0-17. <a href="https://CRAN.R-project.org/package=Iso">https://CRAN.R-project.org/package=Iso</a>.
</p>
<p>The file <code>pava.f</code> is a Ratfor modification of Algorithm AS 206.1:
</p>
<p>Bril, G., Dykstra, R., Pillers, C., Robertson, T. (1984)
Statistical Algorithms: Algorithm AS 206: Isotonic
Regression in Two Independent Variables, <em>Appl. Statist.</em>,
34, 352&ndash;357.
</p>
<p>The Algorith AS 206 is available from StatLib
<a href="http://lib.stat.cmu.edu/apstat/">http://lib.stat.cmu.edu/apstat/</a>. The Royal Statistical Society
holds the copyright to these routines,
but has given its permission for their distribution provided that
no fee is charged.
</p>


<h3>Note</h3>

<p>In the current implementation, only tests on the level of <code class="reqn">\alpha = 0.05</code>
can be performed. The included extrapolation function assumes either
a balanced design, or designs, where the number of replicates in the control excdeeds the number of replicates
in the treatment levels. A warning message appears, if the following
condition is not met, <code class="reqn">1 \le n_0 / n_i \le 6</code> for <code class="reqn">1 \le i \le m</code>.
</p>


<h3>References</h3>

<p>Williams, D. A. (1971) A test for differences between treatment means
when several dose levels are compared with a zero dose control,
<em>Biometrics</em> <b>27</b>, 103&ndash;117.
</p>
<p>Williams, D. A. (1972) The comparison of several dose levels with a zero
dose control, <em>Biometrics</em> <b>28</b>, 519&ndash;531.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code>, <code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="#topic+print.osrt">print.osrt</a></code>,
<code><a href="#topic+summary.osrt">summary.osrt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Sachs (1997, p. 402)
x &lt;- c(106, 114, 116, 127, 145,
110, 125, 143, 148, 151,
136, 139, 149, 160, 174)
g &lt;- gl(3,5)
levels(g) &lt;- c("0", "I", "II")

## Williams Test
williamsTest(x ~ g)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
