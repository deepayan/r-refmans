<!DOCTYPE html><html><head><title>Help for package CNVScope</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CNVScope}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#averageMatrixEdges'><p>Average edges of a matrix to facilitate downsampling.</p></a></li>
<li><a href='#calcCNVKernelProbDist'><p>Calculate the probability distribution of CNV concordance events with a fast kernel</p></a></li>
<li><a href='#calcVecLMs'><p>Create a linear regression matrix.</p></a></li>
<li><a href='#CNVScopeserver'><p>Server component of the CNVScope plotly shiny application.</p></a></li>
<li><a href='#createChromosomalMatrixSet'><p>Create chromosomal interaction matrices for CNVScope shiny application.</p></a></li>
<li><a href='#divisors'><p>List of Divisors</p></a></li>
<li><a href='#downsample_genomic_matrix'><p>Rescale positive and negative data, preserving sign information.</p></a></li>
<li><a href='#extractNegLogPval'><p>Find the negative log p-value of a pair of vectors.</p></a></li>
<li><a href='#formSampleMatrixFromRawGDCData'><p>Form sample matrix from GDC copy number data files.</p></a></li>
<li><a href='#freadGDCfile'><p>Read GDC segmentation datafile for low-pass sequencing data.</p></a></li>
<li><a href='#getAnnotationMatrix'><p>Get the genes in the genomic ranges indicated by the row and column labels.</p></a></li>
<li><a href='#getAsymmetricBlockIndices'><p>Get Block Indices from an asymmetric (or symmetric) matrix.</p></a></li>
<li><a href='#getBlockAverageMatrixFromBreakpoints'><p>Calculate block averages and areas in a matrix given breakpoints.</p></a></li>
<li><a href='#getGlobalRescalingStats'><p>Calculate several base statistics for color rescaling.</p></a></li>
<li><a href='#getInterchromosomalInteractivePlot'><p>Create an HTML widget for use in shiny or webshot for a given pair of chromosomes.</p></a></li>
<li><a href='#GRanges_to_underscored_pos'><p>Convert GRanges object to underscord positions.</p></a></li>
<li><a href='#importBreakpointBed'><p>Import a breakpoint BED file.</p></a></li>
<li><a href='#mathead'><p>Gets a small piece of a matrix (top left corner) for viewing, rather than pulling the first n rows.</p></a></li>
<li><a href='#nbl_result_matrix_sign_small'><p>Neuroblastoma sample CNV relationship matrix</p></a></li>
<li><a href='#postProcessLinRegMatrix'><p>Postprocess linear regression matrix.</p></a></li>
<li><a href='#rebinGenomicInteractions'><p>Assign GenomicInteractions to a predefined series of bins for row and column, corresponding to a genomic matrix.</p></a></li>
<li><a href='#runCNVScopeLocal'><p>Runs the CNVScope plotly shiny application.</p></a></li>
<li><a href='#runCNVScopeShiny'><p>Runs the CNVScope plotly shiny application.</p></a></li>
<li><a href='#signedRescale'><p>Rescale positive and negative data, preserving sign information.</p></a></li>
<li><a href='#underscored_pos_to_GRanges'><p>Convert coordinates in underscored format to a GRanges object.</p></a></li>
<li><a href='#writeAsymmetricMeltedChromosomalMatrixToDisk'><p>Write a matrix, with genes, of a submatrix of a whole genome interaction matrix to disk.</p></a></li>
<li><a href='#writeMeltedChromosomalMatrixToDisk'><p>Write a matrix, with genes, of a submatrix of a whole genome interaction matrix to disk.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Versatile Toolkit for Copy Number Variation Relationship Data
Analysis and Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>3.7.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-30</td>
</tr>
<tr>
<td>Author:</td>
<td>James Dalgeish, Yonghong Wang, Jack Zhu, Paul Meltzer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Dalgleish &lt;james.dalgleish@nih.gov&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jamesdalg/CNVScope/issues/">https://github.com/jamesdalg/CNVScope/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0),ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>tidyr,reshape2,magrittr, jointseg,shiny,RCurl,foreach,
GenomicInteractions,Matrix,OpenImageR,biomaRt,matrixStats,
plyr,data.table,dplyr, doParallel,stringr,rtracklayer,Hmisc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, remotes,pwr,ComplexHeatmap,rmarkdown,
HiCseg,igraph,visNetwork,circlize,plotly,
InteractionSet,GenomicRanges,GenomicFeatures,IRanges,rslurm,
shinythemes,shinycssloaders,DT,logging,heatmaply,
S4Vectors,BiocManager,shinyjs,htmltools,htmlwidgets,
GenomeInfoDb,BSgenome.Hsapiens.UCSC.hg19,tibble,smoothie</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jamesdalg/CNVScope/">https://github.com/jamesdalg/CNVScope/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the ability to create interaction maps, discover CNV map domains (edges), gene annotate interactions, and create interactive visualizations of these CNV interaction maps.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-30 23:09:29 UTC; dalgleishjl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-30 23:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='averageMatrixEdges'>Average edges of a matrix to facilitate downsampling.</h2><span id='topic+averageMatrixEdges'></span>

<h3>Description</h3>

<p>Averages the columns and rows of a matrix by a certain amount.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>averageMatrixEdges(unchangedmatrix, nedges = 1, dimension = c("row", "column"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="averageMatrixEdges_+3A_unchangedmatrix">unchangedmatrix</code></td>
<td>
<p>A matrix to have edges averaged with genomic coordinates in the form chr1_50_100 set as the column and row names.</p>
</td></tr>
<tr><td><code id="averageMatrixEdges_+3A_nedges">nedges</code></td>
<td>
<p>The number of edges to be averaged</p>
</td></tr>
<tr><td><code id="averageMatrixEdges_+3A_dimension">dimension</code></td>
<td>
<p>Selectively averages edges in one dimension. Performs symmetric edge averaging by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>averaged_matrix A matrix with edges averaged, which may be more amenable to downsampling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
dim(nbl_result_matrix_sign_small)
nbl_result_matrix_sign_small_avg&lt;-averageMatrixEdges(nbl_result_matrix_sign_small,
nedges=1,dimension="row")
dim(nbl_result_matrix_sign_small_avg)
nbl_result_matrix_sign_small_avg&lt;-averageMatrixEdges(nbl_result_matrix_sign_small,
nedges=1,dimension="column")
dim(nbl_result_matrix_sign_small_avg)
</code></pre>

<hr>
<h2 id='calcCNVKernelProbDist'>Calculate the probability distribution of CNV concordance events with a fast kernel</h2><span id='topic+calcCNVKernelProbDist'></span>

<h3>Description</h3>

<p>This function produces several matrices, including a Z-score matrix
from a matrix of the same size
and a percentile matrix of these Z-scores
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcCNVKernelProbDist_+3A_submatrix">submatrix</code></td>
<td>
<p>A matrix of CNV data in an intrachromosomal region (e.g. chr1 vs chr1 or chr5 vs chr5)</p>
</td></tr>
<tr><td><code id="calcCNVKernelProbDist_+3A_win">win</code></td>
<td>
<p>a window size for the matrix that calculates the windowed average using the kernel function</p>
</td></tr>
<tr><td><code id="calcCNVKernelProbDist_+3A_debug">debug</code></td>
<td>
<p>extra output for debugging.</p>
</td></tr>
<tr><td><code id="calcCNVKernelProbDist_+3A_parallel">parallel</code></td>
<td>
<p>use parallelization using mcmapply and doParallel?</p>
</td></tr>
<tr><td><code id="calcCNVKernelProbDist_+3A_mcmcores">mcmcores</code></td>
<td>
<p>The number of cores used for parallelization.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
mat_prob_dist&lt;-calcCNVKernelProbDist(nbl_result_matrix_sign_small,parallel=FALSE)
mat_prob_dist
</code></pre>

<hr>
<h2 id='calcVecLMs'>Create a linear regression matrix.</h2><span id='topic+calcVecLMs'></span>

<h3>Description</h3>

<p>Creates a matrix of linear regression p-values, log transformed from every combination of columns in the parent matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVecLMs(
  bin_data,
  use_slurm = F,
  job_finished = F,
  slurmjob = NULL,
  n_nodes = NULL,
  cpus_on_each_node = 2,
  memory_per_node = "2g",
  walltime = "4:00:00",
  partitions = "ccr,quick"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVecLMs_+3A_bin_data">bin_data</code></td>
<td>
<p>The parent matrix, with columns to have linear regression performed on them.</p>
</td></tr>
<tr><td><code id="calcVecLMs_+3A_use_slurm">use_slurm</code></td>
<td>
<p>Paralleize over a number of slurm HPC jobs? If false, the program will simply run locally.</p>
</td></tr>
<tr><td><code id="calcVecLMs_+3A_job_finished">job_finished</code></td>
<td>
<p>Are all the slurm jobs finished and the results need retrieving?</p>
</td></tr>
<tr><td><code id="calcVecLMs_+3A_slurmjob">slurmjob</code></td>
<td>
<p>the slurm job object produced by rslurm::slurm_apply(), after running the function initially.</p>
</td></tr>
<tr><td><code id="calcVecLMs_+3A_n_nodes">n_nodes</code></td>
<td>
<p>the number of nodes used in your slurm job.</p>
</td></tr>
<tr><td><code id="calcVecLMs_+3A_cpus_on_each_node">cpus_on_each_node</code></td>
<td>
<p>The number of cpus used on each node</p>
</td></tr>
<tr><td><code id="calcVecLMs_+3A_memory_per_node">memory_per_node</code></td>
<td>
<p>the amount of ram per node (e.g. &quot;32g&quot; or &quot;2g&quot;)</p>
</td></tr>
<tr><td><code id="calcVecLMs_+3A_walltime">walltime</code></td>
<td>
<p>Time for job to be completed for SLURM scheduler in hh:mm:ss format. Defaults to 4h.</p>
</td></tr>
<tr><td><code id="calcVecLMs_+3A_partitions">partitions</code></td>
<td>
<p>the partitions to which the jobs are to be scheduled, in
order of priority.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output matrix, or if using slurm, the slurm job object (which should be saved as an rds file and reloaded when creating the output matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#small example
#bin_data&lt;-matrix(runif(5*5),ncol=5)
foreach::registerDoSEQ()
#full_matrix&lt;-suppressWarnings(calcVecLMs(bin_data))
#Please note that lm() will make a warning when there are two vectors that are too close 
#numerically (this will always happen along the diagonal).
#This is normal behavior and is controlled &amp; accounted for using this function as well as
#the postProcessLinRegMatrix function (which converts the infinite values to a maximum).

</code></pre>

<hr>
<h2 id='CNVScopeserver'>Server component of the CNVScope plotly shiny application.</h2><span id='topic+CNVScopeserver'></span>

<h3>Description</h3>

<p>Server function of the CNVScope shiny application. run with runCNVScopeShiny
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="CNVScopeserver_+3A_session">session</code></td>
<td>
<p>The shiny session object for the application.</p>
</td></tr>
<tr><td><code id="CNVScopeserver_+3A_input">input</code></td>
<td>
<p>shiny server input</p>
</td></tr>
<tr><td><code id="CNVScopeserver_+3A_output">output</code></td>
<td>
<p>shiny server output</p>
</td></tr>
<tr><td><code id="CNVScopeserver_+3A_debug">debug</code></td>
<td>
<p>enable debugging mode</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runCNVScopeShiny()

## End(Not run)
</code></pre>

<hr>
<h2 id='createChromosomalMatrixSet'>Create chromosomal interaction matrices for CNVScope shiny application.</h2><span id='topic+createChromosomalMatrixSet'></span>

<h3>Description</h3>

<p>Takes a linear regression matrix and sets infinites to a finite value, and changes the sign to match the sign of the correlation for each value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createChromosomalMatrixSet(
  whole_genome_mat,
  output_dir = NULL,
  prefix = "nbl_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createChromosomalMatrixSet_+3A_whole_genome_mat">whole_genome_mat</code></td>
<td>
<p>The matrix containing all of the data, from which the individual matrices will be split.</p>
</td></tr>
<tr><td><code id="createChromosomalMatrixSet_+3A_output_dir">output_dir</code></td>
<td>
<p>the folder where the matrices in RData format, will be written.</p>
</td></tr>
<tr><td><code id="createChromosomalMatrixSet_+3A_prefix">prefix</code></td>
<td>
<p>filename prefix for individual matrices. Default: &quot;nbl_&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of files already written to disk, with full filenames and paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#examples for this function would be too large to 
#include and should be run on an HPC machine node.
#illustration of this process is shown clearly in 
#the vignette and can be done if a user properly
#follows the instructions.
# The function is intended to be run on a whole interactome matrix (chr1-X).
</code></pre>

<hr>
<h2 id='divisors'>List of Divisors</h2><span id='topic+divisors'></span>

<h3>Description</h3>

<p>Generates a list of divisors of an integer number.
Identical to the same function within the numbers package.
The code has been modified from the numbers package,
following GPL 3.0 guidelines on 3/30/2022, section 5.
Reference for GPL v3.0 LICENSE:
https://www.gnu.org/licenses/gpl-3.0.en.html.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisors_+3A_n">n</code></td>
<td>
<p>an integer whose divisors will be generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector integers.
</p>


<h3>See Also</h3>

<p>[numbers::divisors()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>divisors(1)          # 1
divisors(2)          # 1 2
divisors(3)          # 1 2 3
divisors(2^5)        # 1  2  4  8 16 32
divisors(1000)       # 1  2  4  5  8 10 ... 100 125 200 250 500 1000
divisors(1001)       # 1  7 11 13 77 91 143 1001
</code></pre>

<hr>
<h2 id='downsample_genomic_matrix'>Rescale positive and negative data, preserving sign information.</h2><span id='topic+downsample_genomic_matrix'></span>

<h3>Description</h3>

<p>Downsamples a matrix by a specified factor.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_genomic_matrix_+3A_whole_matrix">whole_matrix</code></td>
<td>
<p>A matrix to be downsampled, on a single chromosome</p>
</td></tr>
<tr><td><code id="downsample_genomic_matrix_+3A_downsamplefactor">downsamplefactor</code></td>
<td>
<p>A factor by which to reduce the matrix. Must be something that both the row and columns can be divisible by.</p>
</td></tr>
<tr><td><code id="downsample_genomic_matrix_+3A_singlechromosome">singlechromosome</code></td>
<td>
<p>Single chromosome mode; Multi-chromosome not yet implemented (leave T)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>whole_matrix_dsamp A downsampled matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
downsample_genomic_matrix(whole_matrix=nbl_result_matrix_sign_small,
downsamplefactor=5,singlechromosome=TRUE)
</code></pre>

<hr>
<h2 id='extractNegLogPval'>Find the negative log p-value of a pair of vectors.</h2><span id='topic+extractNegLogPval'></span>

<h3>Description</h3>

<p>Finds the negative log p-value of a matrix, if it exists.
Checks first to see if there is a p-value to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractNegLogPval(x, y, repval = 300, lowrepval = 0, signed = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractNegLogPval_+3A_x">x</code></td>
<td>
<p>a vector that is regressed in the fashion y~x.</p>
</td></tr>
<tr><td><code id="extractNegLogPval_+3A_y">y</code></td>
<td>
<p>a vector that is regressed in the fashion y~x.</p>
</td></tr>
<tr><td><code id="extractNegLogPval_+3A_repval">repval</code></td>
<td>
<p>the replacement value if the regression cannot be performed, default 300 (the vectors are identical if this is used).</p>
</td></tr>
<tr><td><code id="extractNegLogPval_+3A_lowrepval">lowrepval</code></td>
<td>
<p>The low replacement value in the case that a regression p-value is undefined.</p>
</td></tr>
<tr><td><code id="extractNegLogPval_+3A_signed">signed</code></td>
<td>
<p>change the sign of the negative log p-value based on the sign of beta?
e.g. if the line has a negative slope, so will the returned value.
If there is a positive slope, there will be a positive negative log p-value.
if this option is disabled, then no sign changes will happen based on the sign of the slope.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The negative log p-value or replacement value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#small example
xval&lt;-c(1,1,1,1,1)
yval&lt;-c(1,2,3,4,5)
a&lt;-c(3,4,5,6,7)
extractNegLogPval(x=xval,y=yval) #no possible p-value if one vector is constant.
#Some edge cases this may not be correct (if the data lies near a constant),
# but the indiviual sample data should reveal true trends.
suppressWarnings(cor(xval,yval)) #you can't get a correlation value either.
cor(a,a) #gives correlation of 1.
extractNegLogPval(a,a) 
#gives replacement value.
suppressWarnings(extractNegLogPval(x=a,y=yval))
#gives 107.3909 and warns about a nearly perfect fit.
</code></pre>

<hr>
<h2 id='formSampleMatrixFromRawGDCData'>Form sample matrix from GDC copy number data files.</h2><span id='topic+formSampleMatrixFromRawGDCData'></span>

<h3>Description</h3>

<p>Reads a GDC segmetnation files, adds sample information, and forms a data matrix of samples and bins of a specified size.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_tcga_files">tcga_files</code></td>
<td>
<p>GDC files to be read</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_format">format</code></td>
<td>
<p>file format, TCGA or TARGET.</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_binsize">binsize</code></td>
<td>
<p>the binsize, in base pairs (default 1Mb or 1e6).  This value provides a good balance of resolution and speed with memory sensitive applications.</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_freadskip">freadskip</code></td>
<td>
<p>the number of lines to skip in the GDC files, typically 14 (the first 13 lines are metadata and the first is a blank line in NBL data). Adjust as needed.</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_debug">debug</code></td>
<td>
<p>debug mode enable (allows specific breakpoints to be checked).</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_chromosomes">chromosomes</code></td>
<td>
<p>A vector of chromosomes to be used. Defaults to chr1-chrX,
but others can be added e.g. chrY or chrM for Y chromosome or mitochondrial DNA.
Format expected is a character vector, e.g. c(&quot;chr1&quot;, &quot;chr2&quot;, &quot;chr3&quot;).</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_sample_pat">sample_pat</code></td>
<td>
<p>Pattern used to extract sample name from filename.
Use &quot;&quot; to use the filename.</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_sample_col">sample_col</code></td>
<td>
<p>The name of the sample column (for custom format input).</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_chrlabel">chrlabel</code></td>
<td>
<p>The name of the chromosome column (for custom format input).</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_startlabel">startlabel</code></td>
<td>
<p>The name of the start column (for custom format input).</p>
</td></tr>
<tr><td><code id="formSampleMatrixFromRawGDCData_+3A_endlabel">endlabel</code></td>
<td>
<p>The name of the end column (for custom format input).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the aggregated copy number values,
based on the parameters provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Pipeline examples would be too large to include in package checks.
#please see browseVignettes("CNVScope") for a demonstration.

</code></pre>

<hr>
<h2 id='freadGDCfile'>Read GDC segmentation datafile for low-pass sequencing data.</h2><span id='topic+freadGDCfile'></span>

<h3>Description</h3>

<p>Reads a GDC segmetnation file and extract the segmetnation data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freadGDCfile(
  file,
  fread_skip = NULL,
  format = "TARGET",
  CN_colname = "log2",
  sample_pattern = "[^_]+",
  sample_colname = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freadGDCfile_+3A_file">file</code></td>
<td>
<p>GDC file to be read</p>
</td></tr>
<tr><td><code id="freadGDCfile_+3A_fread_skip">fread_skip</code></td>
<td>
<p>The number of metadata lines to be skipped(typically 14)</p>
</td></tr>
<tr><td><code id="freadGDCfile_+3A_format">format</code></td>
<td>
<p>The format of the files (TCGA,TARGET, or custom).</p>
</td></tr>
<tr><td><code id="freadGDCfile_+3A_cn_colname">CN_colname</code></td>
<td>
<p>The name of the column containing the copy number values.</p>
</td></tr>
<tr><td><code id="freadGDCfile_+3A_sample_pattern">sample_pattern</code></td>
<td>
<p>Regex pattern to obtain the sample ID from the filename.</p>
</td></tr>
<tr><td><code id="freadGDCfile_+3A_sample_colname">sample_colname</code></td>
<td>
<p>Alternatively, a column can be specified with the sample ID on each line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>input_tsv_with_sample_info A data frame containing the sample information extracted
from the filename, including sample name &amp; comparison type.
</p>


<h3>References</h3>

<p>https://docs.gdc.cancer.gov/Encyclopedia/pages/TCGA_Barcode/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freadGDCfile(file =
system.file("extdata","somaticCnvSegmentsDiploidBeta_TARGET-30-PANRVJ_NormalVsPrimary.tsv",
package = "CNVScope"))
</code></pre>

<hr>
<h2 id='getAnnotationMatrix'>Get the genes in the genomic ranges indicated by the row and column labels.</h2><span id='topic+getAnnotationMatrix'></span>

<h3>Description</h3>

<p>Gets the genes in the ranges within each cell of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnnotationMatrix(
  genomic_matrix,
  prot_only = T,
  sequential = F,
  flip_row_col = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAnnotationMatrix_+3A_genomic_matrix">genomic_matrix</code></td>
<td>
<p>A matrix with row and column names of the format chr1_100_200 (chr,start,end)</p>
</td></tr>
<tr><td><code id="getAnnotationMatrix_+3A_prot_only">prot_only</code></td>
<td>
<p>Inlcude only the protein coding genes from ensembl?</p>
</td></tr>
<tr><td><code id="getAnnotationMatrix_+3A_sequential">sequential</code></td>
<td>
<p>Turn off parallelism with doParallel?</p>
</td></tr>
<tr><td><code id="getAnnotationMatrix_+3A_flip_row_col">flip_row_col</code></td>
<td>
<p>Give column genes along the rows and row genes down columns?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>concatenated_gene_matrix A matrix with row and column genes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope")) 
load(system.file("extdata","ensembl_gene_tx_table_prot.rda",package = "CNVScope"))
load(system.file("extdata","grch37.rda",package = "CNVScope"))
getAnnotationMatrix(genomic_matrix=nbl_result_matrix_sign_small[1:5,1:5],sequential=TRUE,
prot_only=TRUE)
</code></pre>

<hr>
<h2 id='getAsymmetricBlockIndices'>Get Block Indices from an asymmetric (or symmetric) matrix.</h2><span id='topic+getAsymmetricBlockIndices'></span>

<h3>Description</h3>

<p>This function segments a matrix, including asymmetric matrices using multiple imputation (MI) techniques and a segmentation algorithm to generate breakpoints for column and row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAsymmetricBlockIndices(
  genomicmatrix = NULL,
  algorithm = "HiCseg",
  nb_change_max = 100,
  distrib = "G",
  model = "D",
  MI_strategy = "average",
  transpose = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAsymmetricBlockIndices_+3A_genomicmatrix">genomicmatrix</code></td>
<td>
<p>the large, whole matrix from which blocks are taken</p>
</td></tr>
<tr><td><code id="getAsymmetricBlockIndices_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm to be used: HiCseg or jointSeg.</p>
</td></tr>
<tr><td><code id="getAsymmetricBlockIndices_+3A_nb_change_max">nb_change_max</code></td>
<td>
<p>the maximal number of changepoints, passed to HiCseg (if this algorithm is used). Note: HiCseg doesn't actually obey this limit. Rather, use it as a parameter to increase/decrease segmentation extent.</p>
</td></tr>
<tr><td><code id="getAsymmetricBlockIndices_+3A_distrib">distrib</code></td>
<td>
<p>Passed to Hicseg_linkC_R, from their documentation: Distribution of the data: &quot;B&quot; is for Negative Binomial distribution, &quot;P&quot; is for the Poisson distribution and &quot;G&quot; is for the Gaussian distribution.&quot;</p>
</td></tr>
<tr><td><code id="getAsymmetricBlockIndices_+3A_model">model</code></td>
<td>
<p>Passed on to HiCseg_linkC_R: &quot;Type of model: &quot;D&quot; for block-diagonal and &quot;Dplus&quot; for the extended block-diagonal model.&quot;</p>
</td></tr>
<tr><td><code id="getAsymmetricBlockIndices_+3A_mi_strategy">MI_strategy</code></td>
<td>
<p>strategy to make the matrix temporarily symmetric. &quot;average&quot; adds a number of values equal to the average of the matrix, while copy copies part of the matrix to the shorter side, making a square matrix.</p>
</td></tr>
<tr><td><code id="getAsymmetricBlockIndices_+3A_transpose">transpose</code></td>
<td>
<p>transpose the matrix and output the breakpoints? Some segmentation algorithms (e.g. HiCseg) produces different results when used against the transposed version of the matrix, as it expects symmetry. This allows the output of additional breakpoints Users can choose to take intersect() or union() on the results to get conserved changepoints or additional changepoints, depending on need.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output list of the following:
</p>
<p>breakpoints_col A vector of breakpoints for the columns.
</p>
<p>breakpoints_row A vector of breakpoints for the rows.
</p>
<p>breakpoints_col A vector of breakpoints for columns on the transposed genomic matrix.
</p>
<p>breakpoints_row A vector of breakpoints for the rows on the transposed genomic matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope")) 
submatrix_tiny&lt;-nbl_result_matrix_sign_small
tiny_test&lt;-getAsymmetricBlockIndices(submatrix_tiny,nb_change_max=10,algorithm="jointSeg")
## Not run: 
submatrix_wide&lt;-submatrix_tiny[1:5,]
submatrix_narrow&lt;-submatrix_tiny[,1:5]
wide_test&lt;-getAsymmetricBlockIndices(submatrix_wide,distrib = "G",model = "Dplus",
 nb_change_max = 1e4)
 #the below work, but the time to run all of these would be greater than 10 seconds..
random_wide&lt;-matrix(runif(n = 400*200),ncol=400,nrow=200)
random_narrow&lt;-matrix(runif(n = 400*200),ncol=200,nrow=400)
random_wide_test_avg&lt;-getAsymmetricBlockIndices(random_wide,
 distrib = "G",model = "Dplus",nb_change_max = 1e4)
random_narrow_test_avg&lt;-getAsymmetricBlockIndices(random_narrow,
 distrib = "G",model = "Dplus",nb_change_max = 1e4)
random_wide_test_copy&lt;-getAsymmetricBlockIndices(random_wide,
 distrib = "G",model = "Dplus",nb_change_max = 1e4,MI_strategy = "copy")
random_narrow_test_copy&lt;-getAsymmetricBlockIndices(random_narrow,
 distrib = "G",model = "Dplus",nb_change_max = 1e4,MI_strategy = "copy")
genomicmatrix=random_narrow
nb_change_max=100
model = "D"
distrib = "G"
MI_strategy="copy"
#question-- does it pick different breakpoints if transposed first?
#Answer: yes, at least in Dplus model.
rm(genomicmatrix)
rm(model)
rm(distrib)
rm(MI_strategy)
random_wide_test_copy&lt;-getAsymmetricBlockIndices(genomicmatrix = random_wide,
                                                 distrib = "G",
                                     model = "Dplus",nb_change_max = 1e2,MI_strategy = "copy")
random_narrow_test_copy&lt;-getAsymmetricBlockIndices(random_narrow,distrib = "G",
                                                   model = "Dplus",
                                                   nb_change_max = 1e2,MI_strategy = "copy")
random_wide_test_copy_t&lt;-getAsymmetricBlockIndices(genomicmatrix = t(random_wide),
                                                  distrib = "G",model = "Dplus",
                                                  nb_change_max = 1e2,MI_strategy = "copy")
random_narrow_test_copy_t&lt;-getAsymmetricBlockIndices(genomicmatrix = t(random_narrow),
                                                    distrib = "G",model = "Dplus",
                                                    nb_change_max = 1e2,MI_strategy = "copy")
length(intersect(random_wide_test_copy$breakpoints_col,
random_wide_test_copy_t$breakpoints_row))/length(unique(c(random_wide_test_copy$breakpoints_col,
random_wide_test_copy_t$breakpoints_row)))
random_wide_test_copy_with_transpose&lt;-getAsymmetricBlockIndices(genomicmatrix = random_wide,
 distrib = "G",model = "Dplus",nb_change_max = 1e2,MI_strategy = "copy",transpose = T)
random_narrow_test_copy_with_transpose&lt;-getAsymmetricBlockIndices(genomicmatrix = random_narrow,
 distrib = "G",model = "Dplus",nb_change_max = 1e2,MI_strategy = "copy",transpose = T)
random_narrow_test_copy_with_transpose&lt;-getAsymmetricBlockIndices(genomicmatrix = random_narrow,
 distrib = "G",model = "Dplus",nb_change_max = 1e2,MI_strategy = "copy",transpose = T)
conserved_breakpoints_col&lt;-intersect(random_narrow_test_copy_with_transpose$breakpoints_col,
 random_narrow_test_copy_with_transpose$t_breakpoints_row)
conserved_breakpoints_row&lt;-intersect(random_narrow_test_copy_with_transpose$breakpoints_row,
 random_narrow_test_copy_with_transpose$t_breakpoints_col)
random_wide_test_copy_with_transpose&lt;-getAsymmetricBlockIndices(genomicmatrix = random_wide,
 distrib = "G",model = "Dplus",nb_change_max = 1e2,MI_strategy = "copy",transpose = T)
conserved_breakpoints_col&lt;-intersect(random_wide_test_copy_with_transpose$breakpoints_col,
 random_wide_test_copy_with_transpose$t_breakpoints_row)
conserved_breakpoints_row&lt;-intersect(random_wide_test_copy_with_transpose$breakpoints_row,
 random_wide_test_copy_with_transpose$t_breakpoints_col)

## End(Not run)
</code></pre>

<hr>
<h2 id='getBlockAverageMatrixFromBreakpoints'>Calculate block averages and areas in a matrix given breakpoints.</h2><span id='topic+getBlockAverageMatrixFromBreakpoints'></span>

<h3>Description</h3>

<p>This function produces several matrix outputs of averages and areas of matrix blocks, given a pair of vectors for breakpoints.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBlockAverageMatrixFromBreakpoints_+3A_whole_matrix">whole_matrix</code></td>
<td>
<p>the large, whole matrix from which blocks are taken</p>
</td></tr>
<tr><td><code id="getBlockAverageMatrixFromBreakpoints_+3A_breakpoints_col">breakpoints_col</code></td>
<td>
<p>An integer list of column breakpoints, including 1 and the number of columns in the whole matrix.</p>
</td></tr>
<tr><td><code id="getBlockAverageMatrixFromBreakpoints_+3A_breakpoints_row">breakpoints_row</code></td>
<td>
<p>An integer list of row breakpoints, including 1 and the number of rows in the whole matrix.</p>
</td></tr>
<tr><td><code id="getBlockAverageMatrixFromBreakpoints_+3A_outputs">outputs</code></td>
<td>
<p>A list of the following possible outputs (default all): &quot;blockaverages_reformatted_by_index&quot;,&quot;blockaverages_reformatted_by_label&quot;,&quot;blockaverages_matrix_idx_area&quot;,&quot;blockaverages_matrix_idx_avg&quot;,&quot;blockaverages_matrix_label_avg&quot;, or &quot;blockaverages_matrix_label_area&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output list of the following:
</p>
<p>blockaverages_reformatted_by_index  a matrix of the block averages and areas, in long format, with indexes used to generate the averages.
</p>
<p>blockaverages_reformatted_by_label a matrix of the block averages and areas, in long format, with labels of the indexes used to generate the averages.
</p>
<p>blockaverages_matrix_idx_area a matrix of the block areas, with indexes based on the original row/col index used to generate the data.
</p>
<p>blockaverages_matrix_idx_avg a matrix of the block averages, with indexes based on the original row/col index used to generate the data.
</p>
<p>blockaverages_matrix_label_area a matrix of the block areas, with indexes based on the original row/col label used to generate the data.
</p>
<p>blockaverages_matrix_label_avg a matrix of the block averages, with indexes based on the original row/col label used to generate the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
set.seed(303)
mat&lt;-matrix(data=runif(n = 25),nrow=5,ncol=5,dimnames = list(c("chr1_0_5000",
"chr1_5000_10000","chr1_10000_15000","chr1_15000_20000","chr1_20000_25000"),
c("chr1_0_5000","chr1_5000_10000","chr1_10000_15000","chr1_15000_20000","chr1_20000_25000")))
breakpoints_col&lt;-c(1,2,4,5)
breakpoints_row&lt;-c(1,2,4,5)
foreach::registerDoSEQ()
getBlockAverageMatrixFromBreakpoints(whole_matrix=mat,breakpoints_col=breakpoints_col,
breakpoints_row=breakpoints_row)
## Not run:  #extra examples
mat&lt;-matrix(data=round(runif(min = 0,max=100,n = 25)),nrow=5,ncol=5,
dimnames = list(c("chr1_0_5000","chr1_5000_10000","chr1_10000_15000","chr1_15000_20000",
"chr1_20000_25000"),c("chr2_0_50000","chr2_50000_100000",
"chr2_100000_150000","chr2_150000_200000","chr2_200000_250000")))
breakpoints_col&lt;-c(1,2,4,5)
breakpoints_row&lt;-c(1,2,4,5)
avg_results&lt;-getBlockAverageMatrixFromBreakpoints(whole_matrix=mat,
breakpoints_col=breakpoints_col,breakpoints_row=breakpoints_row)
avg_results$blockaverages_reformatted_by_label
avg_results$blockaverages_reformatted_by_index
whole_matrix=mat
mat&lt;-matrix(data=round(runif(min = 0,max=100,n = 25)),nrow=5,ncol=5,
dimnames = list(c("chr1_0_5000","chr1_5000_10000","chr1_10000_15000",
"chr1_15000_20000","chr1_20000_25000"),c("chr2_0_50000",
"chr2_50000_100000","chr2_100000_150000",
"chr2_150000_200000","chr2_200000_250000")))
breakpoints_col&lt;-c(1,2,4,5)
breakpoints_row&lt;-c(1,2,4,5)
avg_results&lt;-getBlockAverageMatrixFromBreakpoints(whole_matrix=mat,
breakpoints_col=breakpoints_col,breakpoints_row=breakpoints_row)
avg_results$blockaverages_reformatted_by_label
avg_results$blockaverages_reformatted_by_index
whole_matrix=mat
submatrix&lt;-nbl_result_matrix_sign_small
breakpoints_row_jointseg&lt;-jointseg::jointSeg(submatrix,K=5)$bestBkp
breakpoints_col_jointseg&lt;-jointseg::jointSeg(t(submatrix),K=5)$bestBkp
submatrix_avg_results&lt;-getBlockAverageMatrixFromBreakpoints(whole_matrix=submatrix,
breakpoints_col=breakpoints_col_jointseg,breakpoints_row=breakpoints_row_jointseg)

## End(Not run)
</code></pre>

<hr>
<h2 id='getGlobalRescalingStats'>Calculate several base statistics for color rescaling.</h2><span id='topic+getGlobalRescalingStats'></span>

<h3>Description</h3>

<p>calculates several statistics from a large matrix that can then be applied to smaller submatrices without needing to load the entire matrix into memmory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGlobalRescalingStats(whole_matrix, saveToDisk = F, output_fn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGlobalRescalingStats_+3A_whole_matrix">whole_matrix</code></td>
<td>
<p>the whole matrix to get stats for.</p>
</td></tr>
<tr><td><code id="getGlobalRescalingStats_+3A_savetodisk">saveToDisk</code></td>
<td>
<p>Save the statistics to disk as an RDS file in the local directory?</p>
</td></tr>
<tr><td><code id="getGlobalRescalingStats_+3A_output_fn">output_fn</code></td>
<td>
<p>the name of the output file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the output statistics, including:
the global min, max, length, sigma (matrix variance), pos_sigma (variance of the positive values), neg_sigma(variance of the negative values), global mean (global_mu),
est_max_cap (global_mu+global_sigma_pos*2), as well as the number of rows and columns of the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
getGlobalRescalingStats(nbl_result_matrix_sign_small)
</code></pre>

<hr>
<h2 id='getInterchromosomalInteractivePlot'>Create an HTML widget for use in shiny or webshot for a given pair of chromosomes.</h2><span id='topic+getInterchromosomalInteractivePlot'></span>

<h3>Description</h3>

<p>This function requires a matrix with genomic coordinates in the row and column names, and produces a heatmap with a tooltip
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInterchromosomalInteractivePlot_+3A_whole_matrix">whole_matrix</code></td>
<td>
<p>the large, whole genomic matrix from which the submatrix is taken (rows)</p>
</td></tr>
<tr><td><code id="getInterchromosomalInteractivePlot_+3A_chrom1">chrom1</code></td>
<td>
<p>The first chromsome used for the map (columns).</p>
</td></tr>
<tr><td><code id="getInterchromosomalInteractivePlot_+3A_chrom2">chrom2</code></td>
<td>
<p>The second chromsome used for a map axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An HTML widget.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope")) 
getInterchromosomalInteractivePlot(whole_matrix=nbl_result_matrix_sign_small,chrom1=1,
chrom2=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='GRanges_to_underscored_pos'>Convert GRanges object to underscord positions.</h2><span id='topic+GRanges_to_underscored_pos'></span>

<h3>Description</h3>

<p>This function converts row or column names (or any character vector of the format) into a GenomicRanges object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRanges_to_underscored_pos(input_gr, minusOneToEnd = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRanges_to_underscored_pos_+3A_input_gr">input_gr</code></td>
<td>
<p>A GenomicRanges object</p>
</td></tr>
<tr><td><code id="GRanges_to_underscored_pos_+3A_minusonetoend">minusOneToEnd</code></td>
<td>
<p>Minus one position to end of each Genomic Range?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope")) 
col_gr&lt;-underscored_pos_to_GRanges(colnames(nbl_result_matrix_sign_small))
GRanges_to_underscored_pos(col_gr)
</code></pre>

<hr>
<h2 id='importBreakpointBed'>Import a breakpoint BED file.</h2><span id='topic+importBreakpointBed'></span>

<h3>Description</h3>

<p>Imports a BED file with breakpoints or other interactions, in a dual position format.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="importBreakpointBed_+3A_breakpoint_fn">breakpoint_fn</code></td>
<td>
<p>the filename of the breakpoint bed file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Genomic Interactions Object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>importBreakpointBed(breakpoint_fn = system.file("extdata",
"sample_breakpoints.bed",package = "CNVScope"))
</code></pre>

<hr>
<h2 id='mathead'>Gets a small piece of a matrix (top left corner) for viewing, rather than pulling the first n rows.</h2><span id='topic+mathead'></span>

<h3>Description</h3>

<p>Gives a small square of a matrix to get an idea of content rather than grabbing the entire row.
When this row is thousands of numbers long, this can be a problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mathead(mat, n = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mathead_+3A_mat">mat</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="mathead_+3A_n">n</code></td>
<td>
<p>The length and width of the piece to view.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>averaged_matrix a small matrix of size n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
mathead(nbl_result_matrix_sign_small)
</code></pre>

<hr>
<h2 id='nbl_result_matrix_sign_small'>Neuroblastoma sample CNV relationship matrix</h2><span id='topic+nbl_result_matrix_sign_small'></span>

<h3>Description</h3>

<p>The first 25 Mb of chromosome 1,
neuroblastoma copy number signed relation matrix.
</p>


<h3>Format</h3>

<p>A matrix with 25 rows and 25 variables
</p>


<h3>Source</h3>

<p><a href="https://gdc.cancer.gov/">https://gdc.cancer.gov/</a>
</p>

<hr>
<h2 id='postProcessLinRegMatrix'>Postprocess linear regression matrix.</h2><span id='topic+postProcessLinRegMatrix'></span>

<h3>Description</h3>

<p>Takes a linear regression matrix and sets infinites to a finite value, and changes the sign to match the sign of the correlation for each value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postProcessLinRegMatrix(
  input_matrix,
  LM_mat,
  cor_type = "pearson",
  inf_replacement_val = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postProcessLinRegMatrix_+3A_input_matrix">input_matrix</code></td>
<td>
<p>The input matrix, which consists of bins and samples (no LM or correlation has been done on the segmentation values)</p>
</td></tr>
<tr><td><code id="postProcessLinRegMatrix_+3A_lm_mat">LM_mat</code></td>
<td>
<p>The linear regression matrix, with rows and columns consisting of bins and the values being the negative log p-value between them.</p>
</td></tr>
<tr><td><code id="postProcessLinRegMatrix_+3A_cor_type">cor_type</code></td>
<td>
<p>The correlation type (&quot;pearson&quot; (linear), &quot;spearman&quot; (rank), &quot;kendall&quot;(also rank-based)).
Rank correlations capture nonlinear relationships as well as linear. Passed to stats::cor's method parameter.</p>
</td></tr>
<tr><td><code id="postProcessLinRegMatrix_+3A_inf_replacement_val">inf_replacement_val</code></td>
<td>
<p>the value for which infinites are replaced, by default 300.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output matrix, or if using slurm, the slurm job object (which should be saved as an rds file and reloaded when creating the output matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inputmat&lt;-matrix(runif(15),nrow=3)
colnames(inputmat)&lt;-c("chr2_1_1000","chr2_1001_2000","chr2_2001_3000","chr2_3001_4000",
"chr2_4001_5000")
rownames(inputmat)&lt;-c("PAFPJK","PAKKAT","PUFFUM")
outputmat&lt;-matrix(runif(15),nrow=3)
outputmat&lt;-cor(inputmat)*matrix(runif(25,-30,500),nrow=5)
diag(outputmat)&lt;-Inf
postProcessLinRegMatrix(input_matrix=t(inputmat),LM_mat=outputmat,cor_type="pearson",
inf_replacement_val=300)
</code></pre>

<hr>
<h2 id='rebinGenomicInteractions'>Assign GenomicInteractions to a predefined series of bins for row and column, corresponding to a genomic matrix.</h2><span id='topic+rebinGenomicInteractions'></span>

<h3>Description</h3>

<p>This function allows the user to assign a set of genomicinteractions to a pre-existing matrix with known dimensions and column/row names. It finds the row/column index of each point and produces a merged dataframe with the original annotation columns that correspond to each bin in the matrix, with appropriate labels &amp; indexes.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="rebinGenomicInteractions_+3A_gint">gint</code></td>
<td>
<p>A GenomicInteractions object needing to be binned.</p>
</td></tr>
<tr><td><code id="rebinGenomicInteractions_+3A_whole_genome_matrix">whole_genome_matrix</code></td>
<td>
<p>A matrix with underscored positions for column and rownames e.g. chr1_1_5000,chr1_5001_10000.  If this is provided, it will override rown/column names and GRanges objects.</p>
</td></tr>
<tr><td><code id="rebinGenomicInteractions_+3A_rownames_gr">rownames_gr</code></td>
<td>
<p>A Genomic Ranges object created from the whole genome matrix row names in chr_start_end format, e.g. chr1_1_5000. No effect if whole_genome_mattrix is specified.</p>
</td></tr>
<tr><td><code id="rebinGenomicInteractions_+3A_colnames_gr">colnames_gr</code></td>
<td>
<p>A Genomic Ranges object created from the whole genome matrix column names in chr_start_end format. No effect if whole_genome_mattrix is specified.</p>
</td></tr>
<tr><td><code id="rebinGenomicInteractions_+3A_rownames_mat">rownames_mat</code></td>
<td>
<p>The row names of the whole_genome_matrix in chr_start_end format.</p>
</td></tr>
<tr><td><code id="rebinGenomicInteractions_+3A_colnames_mat">colnames_mat</code></td>
<td>
<p>The column names of the whole_genome_matrix in chr_start_end format.</p>
</td></tr>
<tr><td><code id="rebinGenomicInteractions_+3A_method">method</code></td>
<td>
<p>Method to rebin with&ndash; can use overlap and nearest methods.Default: nearest.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>foreach::registerDoSEQ()
gint_small_chr1&lt;-importBreakpointBed(breakpoint_fn = system.file("extdata",
"sample_breakpoints_chr1.bed",package = "CNVScope"))
load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope")) 
rebinGenomicInteractions(gint=gint_small_chr1,whole_genome_matrix=NULL,
rownames_gr=underscored_pos_to_GRanges(rownames(nbl_result_matrix_sign_small)),
colnames_gr=underscored_pos_to_GRanges(colnames(nbl_result_matrix_sign_small)),
rownames_mat = rownames(nbl_result_matrix_sign_small),
colnames_mat = colnames(nbl_result_matrix_sign_small),
method="nearest")
</code></pre>

<hr>
<h2 id='runCNVScopeLocal'>Runs the CNVScope plotly shiny application.</h2><span id='topic+runCNVScopeLocal'></span>

<h3>Description</h3>

<p>Runs the interactive suite of tools locally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runCNVScopeLocal()
</code></pre>


<h3>Value</h3>

<p>none. Runs the application if the correct files are present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
CNVScope::runCNVScopeLocal()

## End(Not run)
</code></pre>

<hr>
<h2 id='runCNVScopeShiny'>Runs the CNVScope plotly shiny application.</h2><span id='topic+runCNVScopeShiny'></span>

<h3>Description</h3>

<p>Runs the interactive suite of tools locally or on a server if called in a script file (e.g. App.R).
Data sources are required.
For a simple installation, please use the runCNVScopeLocal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runCNVScopeShiny(
  baseurl = NULL,
  basefn = NULL,
  osteofn = NULL,
  debug = F,
  useCNVScopePublicData = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runCNVScopeShiny_+3A_baseurl">baseurl</code></td>
<td>
<p>the url of the source files for the application (e.g. the contents of plotly_dashboard_ext). This will be pulled from remotely.</p>
</td></tr>
<tr><td><code id="runCNVScopeShiny_+3A_basefn">basefn</code></td>
<td>
<p>the linux file path of the same source files.</p>
</td></tr>
<tr><td><code id="runCNVScopeShiny_+3A_osteofn">osteofn</code></td>
<td>
<p>the linux file path of the OS files.</p>
</td></tr>
<tr><td><code id="runCNVScopeShiny_+3A_debug">debug</code></td>
<td>
<p>Enable debugging output.</p>
</td></tr>
<tr><td><code id="runCNVScopeShiny_+3A_usecnvscopepublicdata">useCNVScopePublicData</code></td>
<td>
<p>Use files from the CNVScopePublicData package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none. Runs the application if the correct files are present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#see runCNVScopeLocal(useCNVScopePublicData=T).
## Not run: 
runCNVScopeShiny(useCNVScopePublicData=T)

## End(Not run)
</code></pre>

<hr>
<h2 id='signedRescale'>Rescale positive and negative data, preserving sign information.</h2><span id='topic+signedRescale'></span>

<h3>Description</h3>

<p>Performs a signed rescale on the data, shrinking the negative and positive ranges into the [0,1] space, such that negative is always less than 0.5 and positive is always greater.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signedRescale(
  matrix,
  global_max = NULL,
  global_min = NULL,
  global_sigma = NULL,
  global_mu = NULL,
  max_cap = NULL,
  method = "minmax",
  tan_transform = F,
  global_sigma_pos = NULL,
  global_sigma_neg = NULL,
  asymptotic_max = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signedRescale_+3A_matrix">matrix</code></td>
<td>
<p>A matrix to be transformed</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_global_max">global_max</code></td>
<td>
<p>the global maximum (used if scaling using statistics from a large matrix upon a submatrix).</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_global_min">global_min</code></td>
<td>
<p>the global minimum</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_global_sigma">global_sigma</code></td>
<td>
<p>the global signma</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_global_mu">global_mu</code></td>
<td>
<p>the global mu</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_max_cap">max_cap</code></td>
<td>
<p>the maximum saturation&ndash; decreases the ceiling considered for the scaling function.
Useful to see greater differences if an image is too white, increase it if there is too much color to tell apart domains.</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_method">method</code></td>
<td>
<p>method to perform the rescaling.
Options are &quot;minmax&quot; (default), &quot;tan&quot; for tangent, and &quot;sd&quot; for standard devation</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_tan_transform">tan_transform</code></td>
<td>
<p>apply a tangent transformation?</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_global_sigma_pos">global_sigma_pos</code></td>
<td>
<p>The positive global sigma. See getGlobalRescalingStats.</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_global_sigma_neg">global_sigma_neg</code></td>
<td>
<p>The negative global sigma. See getGlobalRescalingStats.</p>
</td></tr>
<tr><td><code id="signedRescale_+3A_asymptotic_max">asymptotic_max</code></td>
<td>
<p>make the maximum value in the matrix not 1, but rather something slightly below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transformedmatrix A transformed matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat&lt;-matrix(c(5,10,15,20,0,40,-45,300,-50),byrow=TRUE,nrow=3)
rescaled_mat&lt;-signedRescale(mat)
mat
rescaled_mat&lt;-signedRescale(abs(mat))
</code></pre>

<hr>
<h2 id='underscored_pos_to_GRanges'>Convert coordinates in underscored format to a GRanges object.</h2><span id='topic+underscored_pos_to_GRanges'></span>

<h3>Description</h3>

<p>This function creates a new GRanges object from a character vector of coordinates in the form &quot;chr1_0_5000&quot; and creates a GRanges object from them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>underscored_pos_to_GRanges(
  underscored_positions = NULL,
  extended_data = NULL,
  zeroToOneBasedStart = T,
  zeroToOneBasedEnd = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="underscored_pos_to_GRanges_+3A_underscored_positions">underscored_positions</code></td>
<td>
<p>A vector of positions of the form c(&quot;chr1_0_5000&quot;,&quot;chr1_7500_10000&quot;,&quot;chr1_10000_15000&quot;)</p>
</td></tr>
<tr><td><code id="underscored_pos_to_GRanges_+3A_extended_data">extended_data</code></td>
<td>
<p>Optional metadata columns. These columns cannot be named &quot;start&quot;, &quot;end&quot;, &quot;width&quot;, or &quot;element&quot;. Passed to GRanges object as ...</p>
</td></tr>
<tr><td><code id="underscored_pos_to_GRanges_+3A_zerotoonebasedstart">zeroToOneBasedStart</code></td>
<td>
<p>Converts a set of underscored positions that begin with zero to GRanges where the lowest positional value on a chromosome is 1. Essentially adds 1 to start</p>
</td></tr>
<tr><td><code id="underscored_pos_to_GRanges_+3A_zerotoonebasedend">zeroToOneBasedEnd</code></td>
<td>
<p>Adds 1 to the end of the underscored positions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A GRanges object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
underscored_pos_to_GRanges(colnames(nbl_result_matrix_sign_small))
</code></pre>

<hr>
<h2 id='writeAsymmetricMeltedChromosomalMatrixToDisk'>Write a matrix, with genes, of a submatrix of a whole genome interaction matrix to disk.</h2><span id='topic+writeAsymmetricMeltedChromosomalMatrixToDisk'></span>

<h3>Description</h3>

<p>Writes an RData file with a ggplot2 object within.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeAsymmetricMeltedChromosomalMatrixToDisk(
  whole_genome_matrix,
  chrom1,
  chrom2,
  extra_data_matrix = NULL,
  transpose = F,
  sequential = T,
  debug = T,
  desired_range_start = 50,
  desired_range_end = 300,
  saveToDisk = T,
  max_cap = NULL,
  rescale = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_whole_genome_matrix">whole_genome_matrix</code></td>
<td>
<p>A matrix to have edges averaged with genomic coordinates in the form chr1_50_100 set as the column and row names.</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_chrom1">chrom1</code></td>
<td>
<p>first chromosome of the two which will subset the matrix. (this is done in row-column fasion).</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_chrom2">chrom2</code></td>
<td>
<p>second chromosome of the two which will subset the matrix. (this is done in row-column fasion).</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_extra_data_matrix">extra_data_matrix</code></td>
<td>
<p>A matrix with additional variables about each point, one position per row with as many variables as remaining columns.</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_transpose">transpose</code></td>
<td>
<p>transpose the matrix?</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_sequential">sequential</code></td>
<td>
<p>disable parallelization with registerDoSEQ()?</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_debug">debug</code></td>
<td>
<p>extra output</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_desired_range_start">desired_range_start</code></td>
<td>
<p>start of range for width and height of matrix for downsampling</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_desired_range_end">desired_range_end</code></td>
<td>
<p>end of range for width and height of matrix for downsampling</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_savetodisk">saveToDisk</code></td>
<td>
<p>saves the matrix to disk</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_max_cap">max_cap</code></td>
<td>
<p>maximum saturation cap, passed to signedRescale</p>
</td></tr>
<tr><td><code id="writeAsymmetricMeltedChromosomalMatrixToDisk_+3A_rescale">rescale</code></td>
<td>
<p>perform signedRescale() on matrix?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplotmatrix a matrix with values sufficient to create a ggplot2 heatmap with geom_tile() or with ggiraph's geom_tile_interactive()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","grch37.rda",package = "CNVScope"))
load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
load(system.file("extdata","ensembl_gene_tx_table_prot.rda",package = "CNVScope"))
writeAsymmetricMeltedChromosomalMatrixToDisk(whole_genome_matrix = 
nbl_result_matrix_sign_small,
chrom1 = 1,chrom2 = 1,desired_range_start = 25, desired_range_end = 25)
file.remove("chr1_chr1_melted.RData")
</code></pre>

<hr>
<h2 id='writeMeltedChromosomalMatrixToDisk'>Write a matrix, with genes, of a submatrix of a whole genome interaction matrix to disk.</h2><span id='topic+writeMeltedChromosomalMatrixToDisk'></span>

<h3>Description</h3>

<p>Writes an RData file with a ggplot2 object within the current directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeMeltedChromosomalMatrixToDisk(
  whole_genome_matrix,
  chrom1,
  chrom2,
  filename,
  extra_data_matrix = NULL,
  transpose = F,
  sequential = T,
  debug = T,
  desired_range_start = 50,
  desired_range_end = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_whole_genome_matrix">whole_genome_matrix</code></td>
<td>
<p>A matrix to have edges averaged with genomic coordinates in the form chr1_50_100 set as the column and row names.</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_chrom1">chrom1</code></td>
<td>
<p>first chromosome of the two which will subset the matrix. (this is done in row-column fasion).</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_chrom2">chrom2</code></td>
<td>
<p>second chromosome of the two which will subset the matrix. (this is done in row-column fasion).</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_filename">filename</code></td>
<td>
<p>the filename to be written</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_extra_data_matrix">extra_data_matrix</code></td>
<td>
<p>A matrix with additional variables about each point, one position per row with as many variables as remaining columns.</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_transpose">transpose</code></td>
<td>
<p>transpose the matrix?</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_sequential">sequential</code></td>
<td>
<p>Disable paralleization with doParallel? registerDoSEQ() is used for this.</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_debug">debug</code></td>
<td>
<p>verbose output for debugging</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_desired_range_start">desired_range_start</code></td>
<td>
<p>the downsampled matrix must be of this size (rows &amp; cols) at minimum</p>
</td></tr>
<tr><td><code id="writeMeltedChromosomalMatrixToDisk_+3A_desired_range_end">desired_range_end</code></td>
<td>
<p>the downsampled matrix must be of this size (rows &amp; cols) at maximum</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplotmatrix a matrix with values sufficient to create a ggplot2 heatmap with geom_tile() or with ggiraph's geom_tile_interactive()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>load(system.file("extdata","grch37.rda",package = "CNVScope"))
load(system.file("extdata","nbl_result_matrix_sign_small.rda",package = "CNVScope"))
load(system.file("extdata","ensembl_gene_tx_table_prot.rda",package = "CNVScope"))
writeMeltedChromosomalMatrixToDisk(whole_genome_matrix = nbl_result_matrix_sign_small,
chrom1 = 1,chrom2 = 1,desired_range_start = 25, desired_range_end = 25)
file.remove("chr1_chr1_melted.RData")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
