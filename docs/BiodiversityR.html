<!DOCTYPE html><html lang="en"><head><title>Help for package BiodiversityR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BiodiversityR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BiodiversityR-package'>
<p>GUI for biodiversity, suitability and community ecology analysis</p></a></li>
<li><a href='#accumresult'><p>Alternative Species Accumulation Curve Results</p></a></li>
<li><a href='#add.spec.scores'><p>Add Species Scores to Unconstrained Ordination Results</p></a></li>
<li><a href='#balanced.specaccum'><p>Balanced Species Accumulation Curves</p></a></li>
<li><a href='#BCI.env'><p>Barro Colorado Island Quadrat Descriptions</p></a></li>
<li><a href='#BiodiversityR.changeLog'>
<p>changeLog file for BiodiversityR</p></a></li>
<li><a href='#BiodiversityRGUI'><p>GUI for Biodiversity, Community Ecology and Ensemble Suitability Analysis</p></a></li>
<li><a href='#CAPdiscrim'><p>Canonical Analysis of Principal Coordinates based on Discriminant Analysis</p></a></li>
<li><a href='#caprescale'><p>Rescaling of Capscale Results to Reflect Total Sums of Squares Of Distance Matrix</p></a></li>
<li><a href='#crosstabanalysis'><p>Presence-absence Analysis by Cross Tabulation</p></a></li>
<li><a href='#CucurbitaClim'><p>Baseline and Future WorldClim 2.1 Climatic Data for Cucurbita Species</p></a></li>
<li><a href='#deviancepercentage'><p>Calculate Percentage and Significance of Deviance Explained by a GLM</p></a></li>
<li><a href='#dist.eval'><p>Distance Matrix Evaluation</p></a></li>
<li><a href='#dist.zeroes'><p>Distance Matrix Transformation</p></a></li>
<li><a href='#distdisplayed'><p>Compare Distance Displayed in Ordination Diagram with Distances of Distance Matrix</p></a></li>
<li><a href='#disttransform'><p>Community Matrix Transformation</p></a></li>
<li><a href='#diversityresult'><p>Alternative Diversity Results</p></a></li>
<li><a href='#ensemble.analogue'>
<p>Climate analogues from climatic distance raster layers.</p></a></li>
<li><a href='#ensemble.batch'>
<p>Suitability mapping based on ensembles of modelling algorithms: batch processing</p></a></li>
<li><a href='#ensemble.bioclim'>
<p>Suitability mapping based on the BIOCLIM algorithm</p></a></li>
<li><a href='#ensemble.bioclim.graph'><p>Graphs of bioclimatic ranges of species and climates</p></a></li>
<li><a href='#ensemble.calibrate.models'>
<p>Suitability mapping based on ensembles of modelling algorithms: calibration of models and weights</p></a></li>
<li><a href='#ensemble.concave.hull'>
<p>Analysis of Niche Overlap in Environmental Space for Changed Climates via Concave Hulls</p></a></li>
<li><a href='#ensemble.dummy.variables'>
<p>Suitability mapping based on ensembles of modelling algorithms: handling of categorical data</p></a></li>
<li><a href='#ensemble.ecocrop'>
<p>Suitability mapping via absolute and optimal precipitation and temperature limits as in the ECOCROP model.</p></a></li>
<li><a href='#ensemble.envirem.masterstack'>
<p>Calculate bioclimatic variables via the <code>envirem</code> package for data.frames.</p></a></li>
<li><a href='#ensemble.evaluate'>
<p>Model evaluation including True Skill Statistic (TSS), AUCdiff and Symmetric Extremal Dependence Index (SEDI).</p></a></li>
<li><a href='#ensemble.novel'>
<p>Mapping of novel environmental conditions (areas where some of the environmental conditions are outside the range of environmental conditions of a reference area).</p></a></li>
<li><a href='#ensemble.PET.season'>
<p>Calculate the balance between precipitation and potential evapotranspiration for the dry season with the largest balance (maximum climatological water deficit, accumulated aridity).</p></a></li>
<li><a href='#ensemble.PET.seasons'>
<p>Raster calculations of beginnings and lengths of growing seasons from the difference between precipitation (P) and potential evapotranspiration (PET), defining dry months with 2 * P &lt; PET.</p></a></li>
<li><a href='#ensemble.raster'>
<p>Suitability mapping based on ensembles of modelling algorithms: consensus mapping</p></a></li>
<li><a href='#ensemble.red'>
<p>Area of Occupancy (AOO) and Extent of Occurrence (EOO) via the <span class="pkg">red</span> library.</p></a></li>
<li><a href='#ensemble.spatialBlock'>
<p>Spatially or environmentally separated folds for cross-validation via blockCV::spatialBlock or blockCV::envBlock</p></a></li>
<li><a href='#ensemble.spatialThin'>
<p>Thinning of presence point coordinates in geographical or environmental space</p></a></li>
<li><a href='#ensemble.terra'>
<p>Suitability mapping based on ensembles of modelling algorithms: consensus mapping via the terra package</p></a></li>
<li><a href='#ensemble.zones'>
<p>Mapping of environmental zones based on the Mahalanobis distance from centroids in environmental space.</p></a></li>
<li><a href='#evaluation.strip.data'><p>Evaluation strips for ensemble suitability mapping</p></a></li>
<li><a href='#faramea'><p>Faramea occidentalis abundance in Panama</p></a></li>
<li><a href='#ifri'><p>Example data from the International Forestry Resources and Institutions (IFRI) research network</p></a></li>
<li><a href='#importancevalue'><p>Importance Value</p></a></li>
<li><a href='#loaded.citations'><p>Give Citation Information for all Loaded Packages</p></a></li>
<li><a href='#makecommunitydataset'><p>Make a Community Dataset from a Stacked Dataset</p></a></li>
<li><a href='#multiconstrained'><p>Pairwise Comparisons for All Levels of a Categorical Variable by RDA, CCA or Capscale</p></a></li>
<li><a href='#nested.anova.dbrda'><p>Nested Analysis of Variance via Distance-based Redundancy Analysis or Non-parametric Multivariate Analysis of Variance</p></a></li>
<li><a href='#NMSrandom'><p>Calculate the NMS Result with the Smallest Stress from Various Random Starts</p></a></li>
<li><a href='#nnetrandom'><p>Calculate the NNET Result with the Smallest Value from Various Random Starts</p></a></li>
<li><a href='#ordicoeno'><p>Coenoclines for an Ordination Axis</p></a></li>
<li><a href='#ordisymbol'><p>Add Other Graphical Items to Ordination Diagrams</p></a></li>
<li><a href='#PCAsignificance'><p>PCA Significance</p></a></li>
<li><a href='#radfitresult'><p>Alternative Rank Abundance Fitting Results</p></a></li>
<li><a href='#rankabundance'><p>Rank Abundance Curves</p></a></li>
<li><a href='#removeNAcomm'><p>Synchronize Community and Environmental Datasets</p></a></li>
<li><a href='#renyiresult'><p>Alternative Renyi Diversity Results</p></a></li>
<li><a href='#sites.long'><p>Helper Functions to Prepare Plotting of Accumulation, Diversity Profile and Ordiplot Results via ggplot2</p></a></li>
<li><a href='#spatialsample'><p>Spatial Sampling within a Polygon</p></a></li>
<li><a href='#transfgradient'><p>Gradient for Hypothetical Example of Turover of Species Composition</p></a></li>
<li><a href='#transfspecies'><p>Hypothetical Example of Turover of Species Composition</p></a></li>
<li><a href='#treegoer.score'>
<p>Calculate climate scores with the Tree Globally Observed Environmental Ranges (TreeGOER) database.</p></a></li>
<li><a href='#warcom'><p>Warburgia ugandensis AFLP Scores</p></a></li>
<li><a href='#warenv'><p>Warburgia ugandensis Population Structure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Package for Community Ecology and Suitability Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.17-1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-1-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Roeland Kindt <a href="https://orcid.org/0000-0002-7672-0712"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roeland Kindt &lt;RoelandCEKindt@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Graphical User Interface (via the R-Commander) and utility functions (often based on the vegan package) for statistical analysis of biodiversity and ecological communities, including species accumulation curves, diversity indices, Renyi profiles, GLMs for analysis of species abundance and presence-absence, distance matrices, Mantel tests, and cluster, constrained and unconstrained ordination analysis. A book on biodiversity and community ecology analysis is available for free download from the website. In 2012, methods for (ensemble) suitability modelling and mapping were expanded in the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.worldagroforestry.org/output/tree-diversity-analysis">http://www.worldagroforestry.org/output/tree-diversity-analysis</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2), tcltk, vegan (&ge; 2.6-8)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcmdr (&ge; 2.9-5), ggplot2 (&ge; 3.3.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>vegan3d, rgl, permute, lattice, MASS, mgcv, cluster, car,
RODBC, rpart, effects, multcomp, ellipse, sp, splancs, spatial,
nnet, dismo, raster (&ge; 3.6-11), terra (&ge; 1.6-47), maxlike,
gbm, randomForest, gam (&ge; 1.15), earth, mda, kernlab, e1071,
glmnet, tools, methods, bootstrap, PresenceAbsence, geosphere,
ENMeval, red, igraph, Rlof, maxnet, party, readxl, colorspace,
dplyr, rlang, sf, blockCV, envirem (&ge; 3.0), concaveman,
pvclust</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-21 08:29:21 UTC; RKINDT</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-21 09:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='BiodiversityR-package'>
GUI for biodiversity, suitability and community ecology analysis
</h2><span id='topic+BiodiversityR-package'></span><span id='topic+BiodiversityR'></span>

<h3>Description</h3>

<p>This package provides a GUI (Graphical User Interface, via the R-Commander; <code><a href="#topic+BiodiversityRGUI">BiodiversityRGUI</a></code>) and some utility functions (often based on the vegan package) for statistical analysis of biodiversity and ecological communities, including species accumulation curves, diversity indices, Renyi profiles, GLMs for analysis of species abundance and presence-absence, distance matrices, Mantel tests, and cluster, constrained and unconstrained ordination analysis. A book on biodiversity and community ecology analysis is available for free download from the website.
</p>


<h3>Details</h3>

<p>We warmly thank all that provided inputs that lead to improvement of the Tree Diversity Analysis manual that describes common methods for biodiversity and community ecology analysis and its accompanying software. We especially appreciate the comments received during training sessions with draft versions of this manual and the accompanying software in Kenya, Uganda and Mali. We are equally grateful to the thoughtful reviews by Dr Simoneta Negrete-Yankelevich (Instituto de Ecologia, Mexico) and Dr Robert Burn (Reading University, UK) of the draft version of this manual, and to Hillary Kipruto for help in editing of this manual. We also want to specifically thank Mikkel Grum, Jane Poole and Paulo van Breugel for helping in testing the packaged version of the software. We also want to give special thanks for all the support that was given by Jan Beniest, Tony Simons and Kris Vanhoutte in realizing the book and software. 
</p>
<p>We highly appreciate the support of the Programme for Cooperation with International Institutes (SII), Education and Development Division of the Netherlands Ministry of Foreign Affairs, and VVOB (The Flemish Association for Development Cooperation and Technical Assistance, Flanders, Belgium) for funding the development for this manual. We also thank VVOB for seconding Roeland Kindt to the World Agroforestry Centre (ICRAF). The tree diversity analysis manual was inspired by research, development and extension activities that were initiated by ICRAF on tree and landscape diversification. We want to acknowledge the various donor agencies that have funded these activities, especially VVOB, DFID, USAID and EU.
</p>
<p>We are grateful for the developers of the R Software for providing a free and powerful statistical package that allowed development of BiodiversityR. We also want to give special thanks to Jari Oksanen for developing the vegan package and John Fox for developing the Rcmdr package, which are key packages that are used by BiodiversityR.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Roeland Kindt (World Agroforestry Centre)
</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005) Tree diversity analysis: A manual and software for common statistical methods for ecological and biodiversity studies. 
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> 
</p>
<p>We suggest to use this citation for this software as well (together with citations of all other packages that were used)  
</p>

<hr>
<h2 id='accumresult'>Alternative Species Accumulation Curve Results</h2><span id='topic+accumresult'></span><span id='topic+accumplot'></span><span id='topic+accumcomp'></span>

<h3>Description</h3>

<p>Provides alternative methods of obtaining species accumulation results than provided by functions <code><a href="vegan.html#topic+specaccum">specaccum</a></code> and <code><a href="vegan.html#topic+specaccum">plot.specaccum</a></code> (<span class="pkg">vegan</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accumresult(x, y="", factor="", level, scale="", method="exact", permutations=100,
    conditioned=T, gamma="boot", ...)

accumplot(xr, addit=F, labels="", col=1, ci=2, pch=1, type="p", cex=1, 
    xlim=c(1, xmax), ylim=c(1, rich),
    xlab="sites", ylab="species richness", cex.lab=1, cex.axis=1, ...)

accumcomp(x, y="", factor, scale="", method="exact", permutations=100,
    conditioned=T, gamma="boot", plotit=T, labelit=T, legend=T, rainbow=T,
    xlim=c(1, max), ylim=c(0, rich),type="p", xlab="sites",
    ylab="species richness", cex.lab=1, cex.axis=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accumresult_+3A_x">x</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_y">y</code></td>
<td>
<p> Environmental data frame. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_factor">factor</code></td>
<td>
<p> Variable of the environmental data frame that defines subsets to calculate species accumulation curves for. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_level">level</code></td>
<td>
<p> Level of the variable to create the subset to calculate species accumulation curves. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_scale">scale</code></td>
<td>
<p> Continuous variable of the environmental data frame that defines the variable that scales the horizontal axis of the species accumulation curves. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_method">method</code></td>
<td>
<p> Method of calculating the species accumulation curve (as in function <code><a href="vegan.html#topic+specaccum">specaccum</a></code>). Method &quot;collector&quot; adds sites in the order they happen to be in the data, &quot;random&quot; adds sites in random order, &quot;exact&quot; finds the expected (mean) species richness, &quot;coleman&quot; finds the expected richness following Coleman et al. 1982, and &quot;rarefaction&quot; finds the mean when accumulating individuals instead of sites.  </p>
</td></tr>
<tr><td><code id="accumresult_+3A_permutations">permutations</code></td>
<td>
<p> Number of permutations to calculate the species accumulation curve (as in function <code><a href="vegan.html#topic+specaccum">specaccum</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_conditioned">conditioned</code></td>
<td>
<p> Estimation of standard deviation is conditional on the empirical dataset for the exact SAC (as in function <code><a href="vegan.html#topic+specaccum">specaccum</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_gamma">gamma</code></td>
<td>
<p> Method for estimating the total extrapolated number of species in the survey area (as in <code><a href="vegan.html#topic+specaccum">specaccum</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_addit">addit</code></td>
<td>
<p> Add species accumulation curve to an existing graph. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_xr">xr</code></td>
<td>
<p> Result from <code><a href="vegan.html#topic+specaccum">specaccum</a></code> or <code>accumresult</code>. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_col">col</code></td>
<td>
<p> Colour for drawing lines of the species accumulation curve (as in function <code><a href="vegan.html#topic+specaccum">plot.specaccum</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_labels">labels</code></td>
<td>
<p> Labels to plot at left and right of the species accumulation curves. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_ci">ci</code></td>
<td>
<p> Multiplier used to get confidence intervals from standard deviatione (as in function <code><a href="vegan.html#topic+specaccum">plot.specaccum</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_pch">pch</code></td>
<td>
<p> Symbol used for drawing the species accumulation curve (as in function <code><a href="graphics.html#topic+points">points</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_type">type</code></td>
<td>
<p> Type of plot (as in function <code><a href="graphics.html#topic+plot">plot</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_cex">cex</code></td>
<td>
<p> Character expansion factor (as in function <code><a href="graphics.html#topic+plot">plot</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_xlim">xlim</code></td>
<td>
<p> Limits for the X = horizontal axis. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_ylim">ylim</code></td>
<td>
<p> Limits for the Y = vertical axis. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_xlab">xlab</code></td>
<td>
<p> Label for the X = horizontal axis (as in function <code><a href="graphics.html#topic+title">title</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_ylab">ylab</code></td>
<td>
<p> Label for the Y = vertical axis (as in function <code><a href="graphics.html#topic+title">title</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_cex.lab">cex.lab</code></td>
<td>
<p> The magnification to be used for X and Y labels relative to the current setting of <code>cex</code>. (as in function <code><a href="graphics.html#topic+par">par</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_cex.axis">cex.axis</code></td>
<td>
<p> The magnification to be used for axis annotation relative to the current setting of <code>cex</code> (as in function <code><a href="graphics.html#topic+par">par</a></code>). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_plotit">plotit</code></td>
<td>
<p> Plot the results. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_labelit">labelit</code></td>
<td>
<p> Label the species accumulation curves with the levels of the categorical variable. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_legend">legend</code></td>
<td>
<p> Add the legend (you need to click in the graph where the legend needs to be plotted). </p>
</td></tr>
<tr><td><code id="accumresult_+3A_rainbow">rainbow</code></td>
<td>
<p> Use rainbow colouring for the different curves. </p>
</td></tr>
<tr><td><code id="accumresult_+3A_...">...</code></td>
<td>
<p> Other items passed to function <code><a href="vegan.html#topic+specaccum">specaccum</a></code> or <code><a href="vegan.html#topic+specaccum">plot.specaccum</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide some alternative methods of obtaining species accumulation results, although function <code><a href="vegan.html#topic+specaccum">specaccum</a></code> is called by these functions to calculate the actual species accumulation curve.
</p>
<p>Functions <code>accumresult</code> and <code>accumcomp</code> allow to calculate species accumulation curves for subsets of the community and environmental data sets. Function <code>accumresult</code> calculates the species accumulation curve for the specified level of a selected environmental variable. Method <code>accumcomp</code> calculates the species accumulation curve for all levels of a selected environmental variable separatedly. Both methods allow to scale the horizontal axis by multiples of the average of a selected continuous variable from the environmental dataset (hint: add the abundance of each site to the environmental data frame to scale accumulation results by mean abundance).
</p>
<p>Functions <code>accumcomp</code> and <code>accumplot</code> provide alternative methods of plotting species accumulation curve results,  although function <code><a href="vegan.html#topic+specaccum">plot.specaccum</a></code> is called by these functions. When you choose to add a legend, make sure that you click in the graph on the spot where you want to put the legend. 
</p>


<h3>Value</h3>

<p>The functions provide alternative methods of obtaining species accumulation curve results, although results are similar as obtained by functions <code><a href="vegan.html#topic+specaccum">specaccum</a></code> and <code><a href="vegan.html#topic+specaccum">plot.specaccum</a></code>.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> 
</p>
<p><a href="https://rpubs.com/Roeland-KINDT">https://rpubs.com/Roeland-KINDT</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+accumcomp.long">accumcomp.long</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune.env)
data(dune)
dune.env$site.totals &lt;- apply(dune,1,sum)
Accum.1 &lt;- accumresult(dune, y=dune.env, scale='site.totals', method='exact', conditioned=TRUE)
Accum.1
accumplot(Accum.1)

Accum.2 &lt;- accumcomp(dune, y=dune.env, factor='Management', method='exact', 
    legend=FALSE, conditioned=TRUE, scale='site.totals')
## CLICK IN THE GRAPH TO INDICATE WHERE THE LEGEND NEEDS TO BE PLACED FOR
## OPTION WHERE LEGEND=TRUE (DEFAULT).

## Not run: 
# ggplot2 plotting method

data(warcom)
data(warenv)

Accum.3 &lt;- accumcomp(warcom, y=warenv, factor='population', 
    method='exact', conditioned=F, plotit=F)

library(ggplot2)

# possibly need for extrafont::loadfonts(device="win") to have Arial
# as alternative, use library(ggThemeAssist)
BioR.theme &lt;- theme(
        panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.line = element_line("gray25"),
        text = element_text(size = 12, family="Arial"),
        axis.text = element_text(size = 10, colour = "gray25"),
        axis.title = element_text(size = 14, colour = "gray25"),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.key = element_blank())

accum.long3 &lt;- accumcomp.long(Accum.3, ci=NA, label.freq=5)

plotgg1 &lt;- ggplot(data=accum.long3, aes(x = Sites, y = Richness, ymax =  UPR, ymin= LWR)) + 
    scale_x_continuous(expand=c(0, 1), sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    geom_line(aes(colour=Grouping), size=2) +
    geom_point(data=subset(accum.long3, labelit==TRUE), 
        aes(colour=Grouping, shape=Grouping), size=5) +
    geom_ribbon(aes(colour=Grouping), alpha=0.2, show.legend=FALSE) + 
    BioR.theme +
    scale_color_brewer(palette = "Set1") +
    labs(x = "Trees", y = "Loci", colour = "Population", shape = "Population")

plotgg1

## End(Not run) # dontrun
</code></pre>

<hr>
<h2 id='add.spec.scores'>Add Species Scores to Unconstrained Ordination Results</h2><span id='topic+add.spec.scores'></span>

<h3>Description</h3>

<p>Calculates scores (coordinates) to plot species for PCoA or NMS results that do not naturally provide species scores. The function can also rescale PCA results to use the choice of rescaling used in <span class="pkg">vegan</span> for the <code><a href="vegan.html#topic+cca">rda</a></code> function (after calculating PCA results via PCoA with the euclidean distance first).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.spec.scores(ordi, comm, method="cor.scores", multi=1, Rscale=F, scaling="1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.spec.scores_+3A_ordi">ordi</code></td>
<td>
<p> Ordination result as calculated by <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>,  <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code>,  <code><a href="MASS.html#topic+sammon">sammon</a></code>,  <code><a href="vegan.html#topic+metaMDS">postMDS</a></code>,  <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code> or  <code><a href="#topic+NMSrandom">NMSrandom</a></code>. </p>
</td></tr>
<tr><td><code id="add.spec.scores_+3A_comm">comm</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="add.spec.scores_+3A_method">method</code></td>
<td>
<p> Method for calculating species scores. Method &quot;cor.scores&quot; calculates the scores by the correlation between site scores and species vectors (via function <code><a href="stats.html#topic+cor">cor</a></code>), method &quot;wa.scores&quot; calculates the weighted average scores (via function <code><a href="vegan.html#topic+wascores">wascores</a></code>) and method &quot;pcoa.scores&quot; calculates the scores by weighing the correlation between site scores and species vectors by variance explained by the ordination axes. </p>
</td></tr>
<tr><td><code id="add.spec.scores_+3A_multi">multi</code></td>
<td>
<p> Multiplier for the species scores. </p>
</td></tr>
<tr><td><code id="add.spec.scores_+3A_rscale">Rscale</code></td>
<td>
<p> Use the same scaling method used by <span class="pkg">vegan</span> for <code><a href="vegan.html#topic+cca">rda</a></code>. </p>
</td></tr>
<tr><td><code id="add.spec.scores_+3A_scaling">scaling</code></td>
<td>
<p> Scaling method as used by <code><a href="vegan.html#topic+cca">rda</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a new ordination result with new information on species scores. For PCoA results, the function calculates eigenvalues (not sums-of-squares as provided in results from function <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>), the percentage of explained variance per axis and the sum of all eigenvalues. PCA results (obtained by PCoA obtained by function <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> with the Euclidean distance) can be scaled as in function <code><a href="vegan.html#topic+cca">rda</a></code>, or be left at the original scale.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune)
distmatrix &lt;- vegdist(dune, method="euc")
# Principal coordinates analysis with 19 axes to estimate total variance
Ordination.model1 &lt;- cmdscale (distmatrix, k=19, eig=TRUE, add=FALSE)
# Change scores for second axis
Ordination.model1$points[,2] &lt;- -1.0 * Ordination.model1$points[,2]
Ordination.model1 &lt;- add.spec.scores(Ordination.model1, dune, 
    method='pcoa.scores', Rscale=TRUE, scaling=1, multi=1)
# Compare Ordination.model1 with PCA
Ordination.model2 &lt;- rda(dune, scale=FALSE)
#
par(mfrow=c(1,2))
ordiplot(Ordination.model1, type="text")
abline(h = 0, lty = 3)
abline(v = 0, lty = 3)
plot(Ordination.model2, type="text", scaling=1)
</code></pre>

<hr>
<h2 id='balanced.specaccum'>Balanced Species Accumulation Curves</h2><span id='topic+balanced.specaccum'></span>

<h3>Description</h3>

<p>Provides species accumulation results calculated from balanced (equal subsample sizes) subsampling from each stratum. Sites can be accumulated in a randomized way, or alternatively sites belonging to the same stratum can be kept together Results are in the same format as <code><a href="vegan.html#topic+specaccum">specaccum</a></code> and can be plotted with <code><a href="vegan.html#topic+specaccum">plot.specaccum</a></code> (<span class="pkg">vegan</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanced.specaccum(comm, permutations=100, strata=strata, grouped=TRUE, 
    reps=0, scale=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balanced.specaccum_+3A_comm">comm</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="balanced.specaccum_+3A_permutations">permutations</code></td>
<td>
<p> Number of permutations to calculate the species accumulation curve. </p>
</td></tr>
<tr><td><code id="balanced.specaccum_+3A_strata">strata</code></td>
<td>
<p> Categorical variable used to specify strata. </p>
</td></tr>
<tr><td><code id="balanced.specaccum_+3A_grouped">grouped</code></td>
<td>
<p> Should sites from the same stratum be kept together (TRUE) or not. </p>
</td></tr>
<tr><td><code id="balanced.specaccum_+3A_reps">reps</code></td>
<td>
<p> Number of subsamples to be taken from each stratum (see details). </p>
</td></tr>
<tr><td><code id="balanced.specaccum_+3A_scale">scale</code></td>
<td>
<p> Quantitative variable used to scale the sampling effort (see details). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an alternative method of obtaining species accumulation results as provided by <code><a href="vegan.html#topic+specaccum">specaccum</a></code> and <code><a href="#topic+accumresult">accumresult</a></code>.
</p>
<p>Balanced sampling is achieved by randomly selecting the same number of sites from each stratum. The number of sites selected from each stratum is determined by <code>reps</code>. Sites are selected from strata with sample sizes larger or equal than <code>reps</code>. In case that <code>reps</code> is smaller than 1 (default: 0), then the number of sites selected from each stratum is equal to the smallest sample size of all strata. Sites from the same stratum can be kept together (grouped=TRUE) or the order of sites can be randomized (grouped=FALSE).
</p>
<p>The results can be scaled by the average accumulation of a quantitative variable (default is number of sites), as in <code>accumresult</code> (hint: add the abundance of each site to the environmental data frame to scale accumulation results by mean abundance). When sites are not selected from all strata, then the average is calculated only for the strata that provided sites.
</p>


<h3>Value</h3>

<p>The functions provide alternative methods of obtaining species accumulation curve results, although results are similar as obtained by functions <code><a href="vegan.html#topic+specaccum">specaccum</a></code> and <code><a href="#topic+accumresult">accumresult</a></code>.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R., Kalinganire, A., Larwanou, M., Belem, M., Dakouo, J.M., Bayala, J. &amp; Kaire, M. (2008)
Species accumulation within landuse and tree diameter categories in Burkina Faso, Mali, Niger and Senegal.
Biodiversity and Conservation. 17: 1883-1905.
</p>
<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune.env)
data(dune)

# not balancing species accumulation
Accum.orig &lt;- specaccum(dune)
Accum.orig

# randomly sample 3 quadrats from each stratum of Management
Accum.1 &lt;- balanced.specaccum(dune, strata=dune.env$Management, reps=3)
Accum.1

# scale results by number of trees per quadrat
dune.env$site.totals &lt;- apply(dune,1,sum)
Accum.2 &lt;- balanced.specaccum(dune, strata=dune.env$Management, reps=3, scale=dune.env$site.totals)
Accum.2
</code></pre>

<hr>
<h2 id='BCI.env'>Barro Colorado Island Quadrat Descriptions</h2><span id='topic+BCI.env'></span>

<h3>Description</h3>

<p>Topography-derived variables and UTM coordinates and UTM coordinates of a 50 ha sample plot (consisting of 50 1-ha quadrats) from Barro Colorado Island of Panama. Dataset <code><a href="vegan.html#topic+BCI">BCI</a></code> provides the tree species composition (trees with diameter at breast height equal or larger than 10 cm) of the same plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BCI.env)</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 6 variables.
</p>

<dl>
<dt><code>UTM.EW</code></dt><dd><p>UTM easting</p>
</dd>
<dt><code>UTM.NS</code></dt><dd><p>UTM northing</p>
</dd>
<dt><code>elevation</code></dt><dd><p>mean of the elevation values of the four cell corners</p>
</dd>
<dt><code>convex</code></dt><dd><p>mean elevation of the target cell minus the mean elevation of the eight surrounding cells</p>
</dd>
<dt><code>slope</code></dt><dd><p>mean angular deviation from horizontal of each of the four triangular planes formed by connecting three of its corners</p>
</dd>
<dt><code>aspectEW</code></dt><dd><p>the sine of aspect</p>
</dd>
<dt><code>aspectNS</code></dt><dd><p>the cosine of aspect</p>
</dd>
</dl>



<h3>References</h3>

<p>Pyke C.R., Condit R., Aguilar S. and Lao S. (2001). Floristic composition across a climatic gradient in a neotropical lowland forest. Journal of Vegetation Science 12: 553-566.
</p>
<p>Condit R., Pitman N., Leigh E.G., Chave J., Terborgh J., Foster R.B., Nunez P., Aguilar S., Valencia R., Villa G., Muller-Landau H.C., Losos E. and Hubbell, S.P. (2002). Beta-diversity in tropical forest trees. Science 295: 666-669.
</p>
<p>De Caceres M., P. Legendre, R. Valencia, M. Cao, L.-W. Chang, G. Chuyong, R. Condit, Z. Hao, C.-F. Hsieh, S. Hubbell, D. Kenfack, K. Ma, X. Mi, N. Supardi Noor, A. R. Kassim, H. Ren, S.-H. Su, I-F. Sun, D. Thomas, W. Ye and F. He. (2012). The variation of tree beta diversity across a global network of forest plots. Global Ecology and Biogeography 21: 1191-1202
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCI.env)
</code></pre>

<hr>
<h2 id='BiodiversityR.changeLog'>
changeLog file for BiodiversityR
</h2><span id='topic+BiodiversityR.changeLog'></span>

<h3>Description</h3>

<p>ChangeLog file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiodiversityR.changeLog()</code></pre>

<hr>
<h2 id='BiodiversityRGUI'>GUI for Biodiversity, Community Ecology and Ensemble Suitability Analysis </h2><span id='topic+BiodiversityRGUI'></span>

<h3>Description</h3>

<p>This function provides a GUI (Graphical User Interface) for some of the functions 
of <span class="pkg">vegan</span>, some other packages and some new functions to run biodiversity 
analysis, including species accumulation curves, diversity indices, Renyi 
profiles, rank-abundance curves, GLMs for analysis of species abundance and
presence-absence, distance matrices, Mantel tests, cluster and ordination 
analysis (including constrained ordination methods such as RDA, CCA, db-RDA and
CAP). In 2012 methods for ensemble suitability 
The function depends and builds on <span class="pkg">Rcmdr</span>, performing all analyses
on the community and environmental datasets that the user selects. A thorough
description of the package and the biodiversity and ecological methods that it
accomodates (including examples) is provided in the freely available 
Tree Diversity Analysis manual (Kindt and Coe, 2005) that is accessible via the 
help menu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiodiversityRGUI(changeLog = FALSE, backward.compatibility.messages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiodiversityRGUI_+3A_changelog">changeLog</code></td>
<td>
<p> Show the changeLog file </p>
</td></tr>
<tr><td><code id="BiodiversityRGUI_+3A_backward.compatibility.messages">backward.compatibility.messages</code></td>
<td>
<p> Some notes on backward compatiblity </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function launches the R-Commander GUI with an extra menu for common statistical methods for biodiversity and community ecology analysis as described in the Tree Diversity Analysis manual of Roeland Kindt and Richard Coe (available via <a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a>]) and expanded systematically with new functions that became available from the vegan community ecology package.
</p>
<p>Since 2012, functions for ensemble suitability modelling were included in BiodiversityR. In 2016, a GUI was created for ensemble suitabilty modelling.
</p>
<p>The R-Commander is launched by changing the location of the Rcmdr &quot;etc&quot; folder to the &quot;etc&quot; folder of BiodiversityR. As the files of the &quot;etc&quot; folder of BiodiversityR are copied from the Rcmdr, it is possible that newest versions of the R-Commander will not be launched properly. In such situations, it is possible that copying all files from the Rcmdr &quot;etc&quot; folder again and adding the BiodiversityR menu options to the Rcmdr-menus.txt is all that is needed to launch the R-Commander again. However, please alert Roeland Kindt about the issue.
</p>
<p>BiodiversityR uses two data sets for biodiversity and community ecology analysis: the community dataset (or community matrix or species matrix) and the environmental dataset (or environmental matrix). The environmental dataset is the same dataset that is used as the &quot;active dataset&quot; of The R-Commander. (Note that you could sometimes use the same dataset as both the community and environmental dataset. For example, you could use the community dataset as environmental dataset as well to add information about specific species to ordination diagrams. As another example, you could use the environmental dataset as community dataset if you first calculated species richness of each site, saved this information in the environmental dataset, and then use species richness as response variable in a regression analysis.) Some options of analysis of ecological distance allow the community matrix to be a distance matrix (the community data set will be interpreted as distance matrix via <code><a href="stats.html#topic+dist">as.dist</a></code> prior to further analysis). 
</p>
<p>For ensemble suitability modelling, different data sets should be created and declared such as the calibration stack, the presence data set and the absence data set. The ensemble suitability modelling menu gives some guidelines on getting started with ensemble suitability modelling.
</p>


<h3>Value</h3>

<p>Besides launching the graphical user interface, the function gives some notes on backward compatibility.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (with some help from Jari Oksanen) </p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> 
</p>

<hr>
<h2 id='CAPdiscrim'>Canonical Analysis of Principal Coordinates based on Discriminant Analysis</h2><span id='topic+CAPdiscrim'></span>

<h3>Description</h3>

<p>This function provides a method for CAP that follows the procedure as described by the authors of the ordination method (Anderson &amp; Willis 2003). The CAP method implemented in <span class="pkg">vegan</span> through <code><a href="vegan.html#topic+capscale">capscale</a></code> conforms more to distance-based Redundancy Analysis (Legendre &amp; Anderson, 1999) than to the original description for CAP (Anderson &amp; Willis, 2003 ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAPdiscrim(formula, data, dist="bray", axes=4, 
    m=0, mmax=10, add=FALSE, 
    permutations=0,
    aitchison_pseudocount=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAPdiscrim_+3A_formula">formula</code></td>
<td>
<p> Formula with a community data frame (with sites as rows, species as columns and species abundance as cell values) or distance matrix on the left-hand side and a categorical variable on the right-hand side (only the first explanatory variable will be used). </p>
</td></tr>
<tr><td><code id="CAPdiscrim_+3A_data">data</code></td>
<td>
<p> Environmental data set. </p>
</td></tr>
<tr><td><code id="CAPdiscrim_+3A_dist">dist</code></td>
<td>
<p> Method for calculating ecological distance with function <code><a href="vegan.html#topic+vegdist">vegdist</a></code>: partial match to &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;aitchison&quot; and &quot;robust.aitchison&quot;. This argument is ignored in case that the left-hand side of the formula already is a distance matrix. </p>
</td></tr>
<tr><td><code id="CAPdiscrim_+3A_axes">axes</code></td>
<td>
<p> Number of PCoA axes (<code><a href="stats.html#topic+cmdscale">cmdscale</a></code>) to provide in the result. </p>
</td></tr>
<tr><td><code id="CAPdiscrim_+3A_m">m</code></td>
<td>
<p> Number of PCoA axes to be investigated by discriminant analysis (<code><a href="MASS.html#topic+lda">lda</a></code>). If m=0 then the number of axes that provides the best distinction between the groups is calculated (following the method of Anderson and Willis).  </p>
</td></tr>
<tr><td><code id="CAPdiscrim_+3A_mmax">mmax</code></td>
<td>
<p> The maximum number of PCoA axes considered when searching (m=0) for the number of axes that provide the best classification success.  </p>
</td></tr>
<tr><td><code id="CAPdiscrim_+3A_add">add</code></td>
<td>
<p> Add a constant to the non-diagonal dissimilarities such that the modified dissimilarities are Euclidean; see also <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>.  </p>
</td></tr>
<tr><td><code id="CAPdiscrim_+3A_permutations">permutations</code></td>
<td>
<p> The number of permutations for significance testing.  </p>
</td></tr>
<tr><td><code id="CAPdiscrim_+3A_aitchison_pseudocount">aitchison_pseudocount</code></td>
<td>
<p> Pseudocount setting as in <code><a href="vegan.html#topic+vegdist">vegdist</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a method of Constrained Analysis of Principal Coordinates (CAP) that follows the description of the method by the developers of the method, Anderson and Willis. The method investigates the results of a Principal Coordinates Analysis (function <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>) with linear discriminant analysis (<code><a href="MASS.html#topic+lda">lda</a></code>). Anderson and Willis advocate to use the number of principal coordinate axes that result in the best prediction of group identities of the sites.
</p>
<p>Results may be different than those obtained in the PRIMER-e package because PRIMER-e does not consider prior probabilities, does not standardize PCOA axes by their eigenvalues and applies an additional spherical standardization to a common within-group variance/covariance matrix.
</p>
<p>For permutations &gt; 0, the analysis is repeated by randomising the observations of the environmental data set. The significance is estimated by dividing the number of times the randomisation generated a larger percentage of correct predictions.
</p>


<h3>Value</h3>

<p>The function returns an object with information on CAP based on discriminant analysis. The object contains following elements:  
</p>
<table role = "presentation">
<tr><td><code>PCoA</code></td>
<td>
<p> the positions of the sites as fitted by PCoA</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p> the number of axes analysed by discriminant analysis</p>
</td></tr>
<tr><td><code>tot</code></td>
<td>
<p> the total variance (sum of all eigenvalues of PCoA)</p>
</td></tr>
<tr><td><code>varm</code></td>
<td>
<p> the variance of the m axes that were investigated</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p> the original group of the sites</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p> the predicted group for the sites by discriminant analysis</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p> the percentage of correct predictions</p>
</td></tr> 
<tr><td><code>percent.level</code></td>
<td>
<p> the percentage of correct predictions for different factor levels</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p> the positions of the sites provided by the discriminant analysis</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p> the squares of the singulare values of the discriminant analysis</p>
</td></tr>
<tr><td><code>manova</code></td>
<td>
<p> the results for MANOVA with the same grouping variable</p>
</td></tr>
<tr><td><code>signi</code></td>
<td>
<p> the significance of the percentage of correct predictions</p>
</td></tr>
<tr><td><code>manova</code></td>
<td>
<p> a summary of the observed randomised prediction percentages</p>
</td></tr>
</table>
<p>The object can be plotted with <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code>, and species scores can be added by <code><a href="#topic+add.spec.scores">add.spec.scores</a></code> .
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Legendre, P. &amp; Anderson, M.J. (1999). Distance-based redundancy analysis:  
testing multispecies responses in multifactorial ecological experiments. 
Ecological Monographs 69: 1-24.
</p>
<p>Anderson, M.J. &amp; Willis, T.J. (2003). Canonical analysis of principal coordinates: a useful method of constrained ordination for ecology. 
Ecology 84: 511-525.
</p>
<p>Kindt, R. &amp; Coe, R. (2005) 
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(vegan)
library(MASS)
data(dune)
data(dune.env)
# categorical variables should not be ordered
dune$Management &lt;- factor(dune$Management, ordered=FALSE)
Ordination.model1 &lt;- CAPdiscrim(dune~Management, data=dune.env,
    dist="bray", axes=2, m=0, add=FALSE)
Ordination.model1
plot1 &lt;- ordiplot(Ordination.model1, type="none")
ordisymbol(plot1, dune.env, "Management", legend=TRUE)

# plot change in classification success against m
plot(seq(1:14), rep(-1000, 14), xlim=c(1, 14), ylim=c(0, 100), xlab="m", 
    ylab="classification success (percent)", type="n")
for (mseq in 1:14) {
    CAPdiscrim.result &lt;- CAPdiscrim(dune~Management, data=dune.env, 
        dist="bray", axes=2, m=mseq)
    points(mseq, CAPdiscrim.result$percent)
}



## End(Not run)
</code></pre>

<hr>
<h2 id='caprescale'>Rescaling of Capscale Results to Reflect Total Sums of Squares Of Distance Matrix</h2><span id='topic+caprescale'></span>

<h3>Description</h3>

<p>This is a simple function that rescales the ordination coordinates obtained from the distance-based redundancy analysis method implemented in <span class="pkg">vegan</span> through <code><a href="vegan.html#topic+capscale">capscale</a></code>. The rescaling of the ordination coordinates results in the distances between fitted site scores in ordination results (scaling=1 obtained via <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code> to be equal to the distances between sites on the axes corresponding to positive eigenvalues obtained from principal coordinates analysis (<code><a href="stats.html#topic+cmdscale">cmdscale</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caprescale(x,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caprescale_+3A_x">x</code></td>
<td>
<p> Ordination result obtained with <code><a href="vegan.html#topic+capscale">capscale</a></code>. </p>
</td></tr>
<tr><td><code id="caprescale_+3A_verbose">verbose</code></td>
<td>
<p> Give some information on the pairwise distances among sites (TRUE) or not. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first step of distance-based redundancy analysis involves principal coordinates analysis whereby the distances among sites from a distance matrix are approximated by distances among sites in a multidimensional configuration (ordination). In case that the principal coordinates analysis does not result in negative eigenvalues, then the distances from the distance matrix are the same as the distances among the sites in the ordination. In case that the principal coordinates analysis results in negative eigenvalues, then the distances among the sites on all ordination axes are related to the sum of positive eigenvalues, a sum which is larger than the sum of squared distances of the distance matrix.
</p>
<p>The distance-based redundancy analysis method implemented in <span class="pkg">vegan</span> through <code><a href="vegan.html#topic+capscale">capscale</a></code> uses a specific rescaling method for ordination results. Function <code>caprescale</code> modifies the results of  <code><a href="vegan.html#topic+capscale">capscale</a></code> so that an ordination with scaling=1 (a distance biplot) obtained via<code><a href="vegan.html#topic+ordiplot">ordiplot</a></code> preserves the distances reflected in the principal coordinates analysis implemented as the first step of the analysis. See Legendre and Legendre (1998) about the relationship between fitted site scores and eigenvalues.
</p>


<h3>Value</h3>

<p>The function modifies and returns an object obtained via  <code><a href="vegan.html#topic+capscale">capscale</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Legendre, P. &amp; Legendre, L. (1998). Numerical Ecology. Amsterdam: Elsevier. 853 pp.
</p>
<p>Legendre, P. &amp; Anderson, M.J. (1999). Distance-based redundancy analysis:  
testing multispecies responses in multifactorial ecological experiments. 
Ecological Monographs 69: 1-24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
library(MASS)
data(dune)
data(dune.env)
Distmatrix.1 &lt;- vegdist(dune,method='bray')
Ordination.model1 &lt;- cmdscale(Distmatrix.1, k=19, eig=TRUE, add=FALSE)
# Sum of all eigenvalues
sum(Ordination.model1$eig)
# [1] 4.395807541512926
sum(Ordination.model1$eig[1:14])
# [1] 4.593946896588808
Distmatrix.2 &lt;- as.matrix(vegdist(Ordination.model1$points[,1:14],method='euc'))
totalsumsquares1 &lt;- sum(Distmatrix.2^2)/(2*20)
# Sum of distances among sites in principal coordinates analysis on axes
# corresponding to positive eigenvalues
totalsumsquares1
# [1] 4.593946896588808
Ordination.model2 &lt;- capscale(dune ~ Management,dune.env,dist='bray', add=FALSE)
# Total sums of positive eigenvalues of the distance-based redundancy analysis
Ordination.model2$CA$tot.chi+Ordination.model2$CCA$tot.chi
# [1] 4.593946896588808
Ordination.model3 &lt;- caprescale(Ordination.model2, verbose=TRUE)
sum1 &lt;- summary(Ordination.model3,axes=17,scaling=1)$constraints
Distmatrix.3 &lt;- as.matrix(vegdist(sum1 ,method='euc'))
totalsumsquares2 &lt;- sum((Distmatrix.3)^2)/(2*20)/19
totalsumsquares2
# [1] 4.593946896588808

</code></pre>

<hr>
<h2 id='crosstabanalysis'>Presence-absence Analysis by Cross Tabulation</h2><span id='topic+crosstabanalysis'></span>

<h3>Description</h3>

<p>This function makes a cross-tabulation of two variables after transforming the first variable to presence-absence and then returns results of <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosstabanalysis(x,variable,factor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crosstabanalysis_+3A_x">x</code></td>
<td>
<p> Data set that contains the variables &quot;variable&quot; and &quot;factor&quot;. </p>
</td></tr>
<tr><td><code id="crosstabanalysis_+3A_variable">variable</code></td>
<td>
<p> Variable to be transformed in presence-absence in the resulting cross-tabulation. </p>
</td></tr>
<tr><td><code id="crosstabanalysis_+3A_factor">factor</code></td>
<td>
<p> Variable to be used for the cross-tabulation together with the transformed variable. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the results of <code><a href="stats.html#topic+chisq.test">chisq.test</a></code> on a crosstabulation of two variables, after transforming the first variable to presence-absence first.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune.env)
crosstabanalysis(dune.env,"Manure","Management")
</code></pre>

<hr>
<h2 id='CucurbitaClim'>Baseline and Future WorldClim 2.1 Climatic Data for Cucurbita Species</h2><span id='topic+CucurbitaClim'></span>

<h3>Description</h3>

<p>This data set provides WorldClim 2.1 bioclimatic data extracted for the baseline (WorldClim 2.1 at 2.5 minutes resolution) and one future (wc2.1_2.5m_bioc_EC-Earth3-Veg_ssp245_2041-2060) climate for presence observations of Cucurbita cordata, C. digitata and C. palmata provided via the CucurbitaData data set of the <code>GapAnalysis</code> package. This data set is used for examples of the <code><a href="#topic+ensemble.concave.hull">ensemble.concave.hull</a></code> and <code><a href="#topic+ensemble.concave.venn">ensemble.concave.venn</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CucurbitaClim)
</code></pre>


<h3>References</h3>

<p>Fick SE and Hijmans RJ. 2017. WorldClim 2: new 1km spatial resolution climate surfaces for global land areas. International Journal of Climatology 37: 4302-4315. 
</p>
<p>Carver et al. 2021. GapAnalysis: an R package to calculate conservation indicators using spatial information. Ecography 44: 1000-1009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CucurbitaClim)
</code></pre>

<hr>
<h2 id='deviancepercentage'>Calculate Percentage and Significance of Deviance Explained by a GLM</h2><span id='topic+deviancepercentage'></span>

<h3>Description</h3>

<p>This function calculates the percentage of deviance explained by a GLM model and calculates the significance of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviancepercentage(x,data,test="F",digits=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviancepercentage_+3A_x">x</code></td>
<td>
<p> Result of GLM as calculated by <code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>. </p>
</td></tr>
<tr><td><code id="deviancepercentage_+3A_data">data</code></td>
<td>
<p> Data set to be used for the null model (preferably the same data set used by the 'full' model). </p>
</td></tr>
<tr><td><code id="deviancepercentage_+3A_test">test</code></td>
<td>
<p> Test statistic to be used for the comparison between the null model and the 'full' model as estimated by <code><a href="stats.html#topic+anova.glm">anova.glm</a></code> or <code><a href="MASS.html#topic+anova.negbin">anova.negbin</a></code>: partial match of one of &quot;Chisq&quot;, &quot;F&quot; or &quot;Cp&quot;. </p>
</td></tr>
<tr><td><code id="deviancepercentage_+3A_digits">digits</code></td>
<td>
<p> Number of digits in the calculation of the percentage. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the percentage of explained deviance and the significance of the 'full' model by contrasting it with the null model.
</p>
<p>For the null model, the data is subjected to <code><a href="stats.html#topic+na.fail">na.omit</a></code>. You should check whether the same data are used for the null and 'full' models.
</p>


<h3>Value</h3>

<p>The function calculates the percentage of explained deviance and the significance of the 'full' model by contrasting it with the null model by ANOVA. The results of the ANOVA are also provided.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune)
data(dune.env)
dune.env$Agrostol &lt;- dune$Agrostol
Count.model1 &lt;- glm(Agrostol ~ Management + A1, family=quasipoisson(link=log), 
    data=dune.env, na.action=na.omit)
summary(Count.model1)
deviancepercentage(Count.model1, dune.env, digits=3)
</code></pre>

<hr>
<h2 id='dist.eval'>Distance Matrix Evaluation</h2><span id='topic+dist.eval'></span><span id='topic+prepare.bioenv'></span>

<h3>Description</h3>

<p>Function <code>dist.eval</code> provides one test of a distance matrix, and then continues with <code><a href="vegan.html#topic+distconnected">distconnected</a></code> (<span class="pkg">vegan</span>). Function <code>prepare.bioenv</code> converts selected variables to numeric variables and then excludes all categorical variables in preparation of applying <code><a href="vegan.html#topic+bioenv">bioenv</a></code> (<span class="pkg">vegan</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.eval(x, dist)
prepare.bioenv(env, as.numeric = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.eval_+3A_x">x</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="dist.eval_+3A_env">env</code></td>
<td>
<p> Environmental data frame with sites as rows and variables as columns. </p>
</td></tr>
<tr><td><code id="dist.eval_+3A_dist">dist</code></td>
<td>
<p> Method for calculating ecological distance with function <code><a href="vegan.html#topic+vegdist">vegdist</a></code>: partial match to &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;clark&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;cao&quot;, &quot;mahalanobis&quot;, &quot;hellinger&quot;. </p>
</td></tr>
<tr><td><code id="dist.eval_+3A_as.numeric">as.numeric</code></td>
<td>
<p> Vector with names of variables in the environmental data set to be converted to numeric variables. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>dist.eval</code> provides two tests of a distance matrix: 
</p>
<p>(i) The first test checks whether any pair of sites that share some species have a larger distance than any other pair of sites that do not share any species. In case that cases are found, then a warning message is given. 
</p>
<p>(ii) The second test is the one implemented by the <code><a href="vegan.html#topic+distconnected">distconnected</a></code> function (<span class="pkg">vegan</span>). The  distconnected test is only calculated for distances that calculate a value of 1 if sites share no species (i.e. not manhattan or euclidean), using the threshold of 1 as an indication that the sites do not share any species. Interpretation of analysis of distance matrices that provided these warnings should be cautious.
</p>
<p>Function <code>prepare.bioenv</code> provides some simple methods of dealing with categorical variables prior to applying <code><a href="vegan.html#topic+bioenv">bioenv</a></code>.
</p>


<h3>Value</h3>

<p>The function tests whether distance matrices have some desirable properties and provide warnings if this is not the case.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune)
dist.eval(dune,"euclidean")
dist.eval(dune,"bray")

## Not run: 
data(dune.env)
dune.env2 &lt;- dune.env[,c('A1', 'Moisture', 'Manure')]
dune.env2$Moisture &lt;- as.numeric(dune.env2$Moisture)
dune.env2$Manure &lt;- as.numeric(dune.env2$Manure)
sol &lt;- bioenv(dune ~ A1 + Moisture + Manure, dune.env2)
sol
summary(sol)
dune.env3 &lt;- prepare.bioenv(dune.env, as.numeric=c('Moisture', 'Manure'))
bioenv(dune, dune.env3)

## End(Not run)


</code></pre>

<hr>
<h2 id='dist.zeroes'>Distance Matrix Transformation</h2><span id='topic+dist.zeroes'></span>

<h3>Description</h3>

<p>Sample units without any species result in &quot;NaN&quot; values in the distance matrix for some of the methods of <code><a href="vegan.html#topic+vegdist">vegdist</a></code> (<span class="pkg">vegan</span>). The function replaces &quot;NA&quot; by &quot;0&quot; if both sample units do not contain any species and &quot;NA&quot; by &quot;1&quot; if only one sample unit does not have any species.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.zeroes(comm, dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.zeroes_+3A_comm">comm</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="dist.zeroes_+3A_dist">dist</code></td>
<td>
<p> Distance matrix as calculated with function <code><a href="vegan.html#topic+vegdist">vegdist</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions changes a distance matrix by replacing &quot;NaN&quot; values by &quot;0&quot; if both sample units do not contain any species and by &quot;1&quot; if only one sample unit does not contain any species. 
</p>
<p>Please note that there is a valid reason (deliberate removal of zero abundance values from calculations) that the original distance matrix contains &quot;NaN&quot;, so you may not wish to do this transformation and remove sample units with zero abundances from further analysis.
</p>


<h3>Value</h3>

<p>The function provides a new distance matrix where &quot;NaN&quot; values have been replaced by &quot;0&quot; or &quot;1&quot;.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
matrix &lt;- array(0, dim=c(5,3))
matrix[4,] &lt;- c(1, 2, 3)
matrix[5,] &lt;- c(1, 0, 0)
dist1 &lt;- vegdist(matrix, method="kulc")
dist1
dist2 &lt;- dist.zeroes(matrix, dist1)
dist2
</code></pre>

<hr>
<h2 id='distdisplayed'>Compare Distance Displayed in Ordination Diagram with Distances of Distance Matrix</h2><span id='topic+distdisplayed'></span>

<h3>Description</h3>

<p>This function compares the distance among sites as displayed in an ordination diagram (generated by <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code>) with the actual distances among sites as available from a distance matrix (as generated by <code><a href="vegan.html#topic+vegdist">vegdist</a></code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distdisplayed(x, ordiplot, distx = "bray", plotit = T, addit = F, 
    method = "spearman", permutations = 100, abline = F, gam = T, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distdisplayed_+3A_x">x</code></td>
<td>
<p> Community data frame (with sites as rows, species as columns and species abundance as cell values) or distance matrix. </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_ordiplot">ordiplot</code></td>
<td>
<p> Ordination diagram generated by <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code> or distance matrix. </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_distx">distx</code></td>
<td>
<p> Ecological distance used to calculated the distance matrix (theoretically the same distance as displayed in the ordination diagram); passed to <code><a href="vegan.html#topic+vegdist">vegdist</a></code> and partial match to &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot;, &quot;binomial&quot;, &quot;chao&quot;, &quot;aitchison&quot; or &quot;robust.aitchison&quot;. This argument is ignored in case that &quot;x&quot; is already a distance matrix. </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_plotit">plotit</code></td>
<td>
<p> Should a plot comparing the distance in ordination diagram (or the distance matrix) with the distance from the distance matrix be generated (or not). </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_addit">addit</code></td>
<td>
<p> Should the GAM regression result be added to an existing plot (or not). </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_method">method</code></td>
<td>
<p> Method for calculating the correlation between the ordination distance and the complete distance; from function <code><a href="vegan.html#topic+mantel">mantel</a></code> passed to function <code><a href="stats.html#topic+cor">cor</a></code>: &quot;pearson&quot;, &quot;spearman&quot; or &quot;kendall&quot;. </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_permutations">permutations</code></td>
<td>
<p> Number of permutations to assess the significance of the Mantel test; passed to <code><a href="vegan.html#topic+mantel">mantel</a></code>. </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_abline">abline</code></td>
<td>
<p> Should a reference line (y=x) be added to the graph (or not). </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_gam">gam</code></td>
<td>
<p> Evaluate the correspondence between the original distance and the distance from the ordination diagram with GAMas estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>. </p>
</td></tr>
<tr><td><code id="distdisplayed_+3A_...">...</code></td>
<td>
<p> Other arguments passed to <code><a href="vegan.html#topic+mantel">mantel</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compares the Euclidean distances (between sites) displayed in an ordination diagram with the distances of a distance matrix. Alternatively, the distances of one distance matrix are compared against the distances of another distance matrix.
</p>
<p>These distances are compared by a Mantel test (<code><a href="vegan.html#topic+mantel">mantel</a></code>) and (optionally) a GAM regression (<code><a href="mgcv.html#topic+gam">gam</a></code>). Optionally, a graph is provided compairing the distances and adding GAM results.
.
</p>


<h3>Value</h3>

<p>The function returns the results of a Mantel test and (optionally) the results of a GAM analysis.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
library(mgcv)
data(dune)
# pseudocount used by aitchison distance
distmatrix &lt;- vegdist(dune, method="kulc", pseudocount=1)
ordination.model1 &lt;- cmdscale(distmatrix,k=2)
ordiplot1 &lt;- ordiplot(ordination.model1)
distdisplayed(dune, ordiplot=ordiplot1, distx="kulc", plotit=TRUE,
    method="spearman", permutations=100, gam=TRUE)
</code></pre>

<hr>
<h2 id='disttransform'>Community Matrix Transformation</h2><span id='topic+disttransform'></span>

<h3>Description</h3>

<p>Transforms a community matrix. Some transformation methods are described by distances for the original community matrix that result in the same distance matrix as calculated with the euclidean distance from the transformed community matrix.
In several cases (methods of &quot;hellinger&quot;, &quot;chord&quot;, &quot;profiles&quot; and &quot;chi.square), the method makes use of function <code><a href="vegan.html#topic+decostand">decostand</a></code>. In several other cases (&quot;Braun.Blanquet&quot;, &quot;Domin&quot;, &quot;Hult&quot;, &quot;Hill&quot;, &quot;fix&quot; and &quot;coverscale.log&quot;), the method makes use of function <code><a href="vegan.html#topic+coverscale">coverscale</a></code>. For method &quot;dispweight&quot; a call is made to function <code><a href="vegan.html#topic+dispweight">dispweight</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disttransform(x, method="hellinger")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disttransform_+3A_x">x</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="disttransform_+3A_method">method</code></td>
<td>
<p> Distance measure for the original community matrix that the euclidean distance will calculate for the transformed community matrix: partial match to &quot;hellinger&quot;, &quot;chord&quot;, &quot;profiles&quot;, &quot;chi.square&quot;, &quot;log&quot;, &quot;square&quot;, &quot;pa&quot;, &quot;Braun.Blanquet&quot;, &quot;Domin&quot;, &quot;Hult&quot;, &quot;Hill&quot;, &quot;fix&quot;, &quot;coverscale.log&quot; and &quot;dispweight&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions transforms a community matrix.
</p>
<p>Some transformation methods (&quot;hellinger&quot;, &quot;chord&quot;, &quot;profiles&quot; and &quot;chi.square&quot;) have the behaviour that the euclidean distance from the transformed matrix will equal a distance of choice for the original matrix. For example, using method &quot;hellinger&quot; and calculating the euclidean distance will result in the same distance matrix as by calculating the Hellinger distance from the original community matrix.
</p>
<p>Transformation methods (&quot;Braun.Blanquet&quot;, &quot;Domin&quot;, &quot;Hult&quot;, &quot;Hill&quot;, &quot;fix&quot; and &quot;coverscale.log&quot;) call function <code><a href="vegan.html#topic+coverscale">coverscale</a></code>.
</p>
<p>Method &quot;dispweight&quot; uses function <code><a href="vegan.html#topic+dispweight">dispweight</a></code> without specifying a grouping structure.
</p>


<h3>Value</h3>

<p>The function returns a transformed community matrix.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Legendre, P. &amp; Gallagher, E.D. (2001). Ecologically meaningful transformations 
for ordination of species data. Oecologia 129: 271-280.
</p>
<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(vegan)
data(dune)
Community.1 &lt;- disttransform(dune, method='hellinger')
Distmatrix.1 &lt;- vegdist(Community.1, method='euclidean')
Distmatrix.1

## End(Not run)
</code></pre>

<hr>
<h2 id='diversityresult'>Alternative Diversity Results</h2><span id='topic+diversityresult'></span><span id='topic+diversitycomp'></span><span id='topic+diversityvariables'></span>

<h3>Description</h3>

<p>Provides alternative methods of obtaining results on diversity statistics than provided directly by functions <code><a href="vegan.html#topic+diversity">diversity</a></code>, <code><a href="vegan.html#topic+diversity">fisher.alpha</a></code>, <code><a href="vegan.html#topic+specpool">specpool</a></code> and <code><a href="vegan.html#topic+diversity">specnumber</a></code> (all from <span class="pkg">vegan</span>), although these same functions are called. Some other statistics are also calculated such as the reciprocal Berger-Parker diversity index and abundance (not a diversity statistic). The statistics can be calculated for the entire community, for each site separately, the mean of the sites can be calculated or a jackknife estimate can be calculated for the community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversityresult(x, y = NULL, factor = NULL, level = NULL, 
    index=c("Shannon", "Simpson", "inverseSimpson", "Logalpha", "Berger",
        "simpson.unb", "simpson.unb.inverse", 
        "richness", "abundance", "Jevenness", "Eevenness", 
        "jack1", "jack2", "chao", "boot"),
    method=c("pooled", "each site", "mean", "sd", "max", "jackknife"), 
    sortit = FALSE, digits = 8)

diversityvariables(x, y, digits=8)

diversitycomp(x, y = NULL, 
    factor1 = NULL ,factor2 = NULL,
    index=c("Shannon", "Simpson", "inverseSimpson", "Logalpha", "Berger", 
        "simpson.unb", "simpson.unb.inverse",
        "richness", "abundance", "Jevenness", "Eevenness", 
        "jack1", "jack2", "chao", "boot"),
    method=c("pooled", "mean", "sd", "max", "jackknife"),
    sortit=FALSE, digits=8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diversityresult_+3A_x">x</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_y">y</code></td>
<td>
<p> Environmental data frame. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_factor">factor</code></td>
<td>
<p> Variable of the environmental data frame that defines subsets to calculate diversity statistics for. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_level">level</code></td>
<td>
<p> Level of the variable to create the subset to calculate diversity statistics. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_index">index</code></td>
<td>
<p> Type of diversity statistic with &quot;richness&quot; to calculate species richness, &quot;abundance&quot; to calculate abundance, &quot;Shannon&quot; to calculate the Shannon diversity index, &quot;Simpson&quot; to calculate 1-Simpson concentration index, &quot;inverseSimpson&quot; to calculate the reciprocal Simpson diversity index, &quot;simpson.unb&quot; to calculate the unbiased Simpson index, &quot;simpson.unb.inverse&quot; to calculate the unbiased inverse simpson index, &quot;Logalpha&quot; to calculate the log series alpha diversity index, &quot;Berger&quot; to calculate the reciprocal Berger-Parker diversity index, &quot;Jevenness&quot; to calculate one Shannon evenness index, &quot;Eevenness&quot; to calculate another Shannon evenness index, &quot;jack1&quot; to calculate the first-order jackknife gamma diversity estimator, &quot;jack2&quot; to calculate the second-order jackknife gamma diversity estimator, &quot;chao&quot; to calculate the Chao gamma diversity estimator and &quot;boot&quot; to calculate the bootstrap gamma diversity estimator. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_method">method</code></td>
<td>
<p> Method of calculating the diversity statistics: &quot;pooled&quot; calculates the diversity of the entire community (all sites pooled), &quot;each site&quot; calculates diversity for each site separetly, &quot;mean&quot; calculates the average diversity of the sites, &quot;sd&quot; calculates the standard deviation of the diversity of the sites, &quot;max&quot; calculates the maximum diversity of the sites, whereas &quot;jackknife&quot; calculates the jackknifed diversity for the entire data frame. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_sortit">sortit</code></td>
<td>
<p> Sort the sites by increasing values of the diversity statistic. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_digits">digits</code></td>
<td>
<p> Number of digits in the results. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_factor1">factor1</code></td>
<td>
<p> Variable of the environmental data frame that defines subsets to calculate diversity statistics for. </p>
</td></tr>
<tr><td><code id="diversityresult_+3A_factor2">factor2</code></td>
<td>
<p> Optional second variable of the environmental data frame that defines subsets to calculate diversity statistics for in a crosstabulation with the other variable of the environmental data frame. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide some alternative methods of obtaining results with diversity statistics, although functions <code><a href="vegan.html#topic+diversity">diversity</a></code>, <code><a href="vegan.html#topic+diversity">fisher.alpha</a></code>, <code><a href="vegan.html#topic+specpool">specpool</a></code>, <code><a href="vegan.html#topic+specpool">estimateR</a></code> and <code><a href="vegan.html#topic+diversity">specnumber</a></code> (all from <span class="pkg">vegan</span>) are called to calculate the various statistics.
</p>
<p>Function <code>diversityvariables</code> adds variables to the environmental dataset (richness, Shannon, Simpson, inverseSimpson, Logalpha, Berger, Jevenness, Eevenness).
</p>
<p>The reciprocal Berger-Parker diversity index is the reciprocal of the proportional abundance of the most dominant species.
</p>
<p>J-evenness is calculated as: H / ln(S) where H is the Shannon diversity index and S the species richness.
</p>
<p>E-evenness is calculated as: exp(H) / S where H is the Shannon diversity index and S the species richness.
</p>
<p>The method of calculating the diversity statistics include following options: &quot;all&quot; calculates the diversity of the entire community (all sites pooled together), &quot;s&quot; calculates the diversity of each site separatedly, &quot;mean&quot; calculates the average diversity of the sites, whereas &quot;Jackknife&quot; calculates the jackknifed diversity for the entire data frame. Methods &quot;s&quot; and &quot;mean&quot; are not available for function diversitycomp. Gamma diversity estimators assume that the method is &quot;all&quot;.
</p>
<p>Functions <code>diversityresult</code> and <code>diversitycomp</code> allow to calculate diversity statistics for subsets of the community and environmental data sets. Function <code>diversityresult</code> calculates the diversity statistics for the specified level of a selected environmental variable. Function <code>diversitycomp</code> calculates the diversity statistics for all  levels of a selected environmental variable separatedly. When a second environmental variable is provided, function <code>diversitycomp</code> calculates diversity statistics as a crosstabulation of both variables.
</p>


<h3>Value</h3>

<p>The functions provide alternative methods of obtaining diversity results. For function <code>diversitycomp</code>, the number of sites is provided as &quot;n&quot;.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(vegan)
data(dune.env)
data(dune)

diversityresult(dune, y=NULL, index="Shannon", method="each site", 
    sortit=TRUE, digits=5)
diversityresult(dune, y=dune.env, factor="Management", level="NM", 
    index="Shannon", method="each site", 
    sortit=TRUE, digits=5)
diversityresult(dune, y=NULL, index="Shannon", method="pooled", digits=5)
diversityresult(dune, y=dune.env, factor="Management", level="NM", 
    index="Shannon", method="pooled", digits=5)
diversityresult(dune, y=NULL, index="Shannon", method="mean", 
    digits=5)
diversityresult(dune, y=NULL, index="Shannon", method="sd", 
    digits=5)
diversityresult(dune, y=NULL, index="Shannon", method="jackknife", 
    digits=5)
diversityresult(dune, y=dune.env, factor="Management", level="NM", 
    index="Shannon", method="jackknife", digits=5)

diversitycomp(dune, y=dune.env, factor1="Moisture", index="Shannon",
    method="pooled", sortit=TRUE)
diversitycomp(dune, y=dune.env, factor1="Moisture", index="Shannon",
    method="mean", sortit=TRUE)
diversitycomp(dune, y=dune.env, factor1="Management", index="Shannon",
    method="jackknife", sortit=TRUE)

diversitycomp(dune, y=dune.env, factor1="Management", factor2="Moisture", 
    index="Shannon", method="pooled", digits=6)
diversitycomp(dune, y=dune.env, factor1="Management", factor2="Moisture", 
    index="Shannon", method="mean", digits=6)


## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.analogue'>
Climate analogues from climatic distance raster layers.
</h2><span id='topic+ensemble.analogue'></span><span id='topic+ensemble.analogue.object'></span>

<h3>Description</h3>

<p>Function <code>ensemble.analogue</code> creates the map with climatic distance and provides the locations of the climate analogues (defined as locations with smallest climatic distance to a reference climate). Function <code>ensemble.analogue.object</code> provides the reference values used by the prediction function used by <code><a href="raster.html#topic+predict">predict</a></code> . 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.analogue(x = NULL, analogue.object = NULL, analogues = 1,
    RASTER.object.name = analogue.object$name, RASTER.stack.name = x@title,
    RASTER.format = "GTiff", RASTER.datatype = "INT2S", RASTER.NAflag = -32767,
    limits = c(1, 5, 20, 50), limit.colours = c('red', 'orange', 'blue', 'grey'),
    CATCH.OFF = FALSE)

ensemble.analogue.object(ref.location, future.stack, current.stack, name = "reference1", 
    method = "mahal", an = 10000, probs = c(0.025, 0.975), weights = NULL, z = 2)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.analogue_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all environmental layers (climatic variables) for which climatic distance should be calculated. </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_analogue.object">analogue.object</code></td>
<td>
<p> Object listing reference values for the environmental layers and additional parameters (covariance matrix for <code>method = "mahal"</code> or normalization parameters for <code>method = "quantile"</code>) that are used by the prediction function that is used internally by <code><a href="raster.html#topic+predict">predict</a></code>. This object is created with <code><a href="#topic+ensemble.analogue.object">ensemble.analogue.object</a></code>. </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_analogues">analogues</code></td>
<td>
<p> Number of analogue locations to be provided </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_raster.object.name">RASTER.object.name</code></td>
<td>
<p> First part of the names of the raster file that will be generated, expected to identify the area and time period for which ranges were calculated </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_raster.stack.name">RASTER.stack.name</code></td>
<td>
<p> Last part of the names of the raster file that will be generated, expected to identify the predictor stack used </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_raster.format">RASTER.format</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_raster.datatype">RASTER.datatype</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+dataType">dataType</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_raster.naflag">RASTER.NAflag</code></td>
<td>
<p> Value that is used to store missing data. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_limits">limits</code></td>
<td>
<p> Limits indicating the accumulated number of closest analogue sites. These limits will correspond to different colours in the KML map. In the default setting, the closest analogue will be coloured red and the second to fifth closest analogues will be coloured orange.  </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_limit.colours">limit.colours</code></td>
<td>
<p> Colours for the different limits based on number of analogues.  </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_ref.location">ref.location</code></td>
<td>
<p> Location of the reference location for which analogues are searched for and from which climatic distance will be calculated, typically available in 2-column (lon, lat) dataframe; see also <code><a href="raster.html#topic+extract">extract</a></code>. </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_future.stack">future.stack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing the environmental layers (climatic variables) to obtain the conditions of the reference location. For climate change research, this RasterStack object corresponds to the future climatic conditions of the reference location. </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_current.stack">current.stack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all environmental layers (climatic variables) for which climatic distance should be calculated. For climate change research, this RasterStack object corresponds to the current climatic conditions and range where climate analogues are searched for. </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_name">name</code></td>
<td>
<p> Name of the object, expect to expected to identify the area and time period for which ranges were calculated and where no novel conditions will be detected </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_method">method</code></td>
<td>
<p> Method used to calculate climatic distance: <code>method = "mahal"</code> results in using the Mahalanobis distance (<code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>); <code>method = "quantile"</code> results in dividing the differences between reference climatic values and climatic values in the 'current' raster by a quantile range obtained from the 'current' raster; <code>method = "sd"</code> results in dividing the differences between reference climatic values and climatic values in the 'current' raster by standard deviations obtained from the 'current' raster; and <code>method = "none"</code> results in not dividing these differences. </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_an">an</code></td>
<td>
<p> Number of randomly selected locations points to calculate the covariance matrix (<code><a href="stats.html#topic+cov">cov</a></code>) to be used with <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>, therefore only used for <code>method = "mahal"</code>. See also <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.analogue_+3A_probs">probs</code></td>
<td>
<p> Numeric vector of probabilities [0,1] as used by <code><a href="stats.html#topic+quantile">quantile</a></code>). Only used for <code>method = "quantile"</code>.  </p>
</td></tr> 
<tr><td><code id="ensemble.analogue_+3A_weights">weights</code></td>
<td>
<p> Numeric vector of weights by which each variable (difference) should be multiplied by (can be used to give equal weight to 12 monthly rainfall values and 24 minimum and maximum monthly temperature values). Not used for <code>method = "mahal"</code>.  </p>
</td></tr> 
<tr><td><code id="ensemble.analogue_+3A_z">z</code></td>
<td>
<p> Parameter used as exponent for differences calculated between reference climatic variables and variables in the 'current' raster and reciprocal exponent for the sum of all differences. Default value of 2 corresponds to the Euclidean distance. Not used for <code>method = "mahal"</code>.  </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Function <code>ensemble.analogues</code> maps the climatic distance from reference values determined by <code>ensemble.analogues.object</code> and provides the locations of the <code>analogues</code> closest analogues.
</p>
<p>The <code>method = "mahal"</code> uses the Mahalanobis distance as environmental (climatic) distance: <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>.
</p>
<p>Other methods use a normalization method to handle scale differences between environmental (climatic) variables:
</p>
<p><code class="reqn">ClimaticDistance = (\sum_i(weight_{i}*(|T_{i}-C_{i}| / norm_{i})^z))^(1/z)</code>
</p>
<p>where <code class="reqn">T_{i}</code> are the target values for environmental (climatic) variable i,
<code class="reqn">C_{i}</code> are the values in the current environmental layers where analogues are searched for,
<code class="reqn">weight_{i}</code> are the weights for environmental variable i, and
<code class="reqn">norm_{i}</code> are the normalization parameters for environmental variable i
</p>


<h3>Value</h3>

<p>Function <code>ensemble.analogue.object</code> returns a list with following objects:
</p>
<table role = "presentation">
<tr><td><code>name</code></td>
<td>
<p> name for the reference location </p>
</td></tr>
<tr><td><code>ref.location</code></td>
<td>
<p> coordinates of the reference location </p>
</td></tr>
<tr><td><code>stack.name</code></td>
<td>
<p> name for time period for which values are extracted from the <code>future.stack</code> </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> method used for calculating climatic distance </p>
</td></tr>
<tr><td><code>target.values</code></td>
<td>
<p> target environmental values to select analogues for through minimum climatic distance </p>
</td></tr>
<tr><td><code>cov.mahal</code></td>
<td>
<p> covariance matrix </p>
</td></tr>
<tr><td><code>norm.values</code></td>
<td>
<p> parameters by which each difference between target and 'current' value will be divided </p>
</td></tr>
<tr><td><code>weight.values</code></td>
<td>
<p> weights by which each difference between target and 'current' value will be multiplied </p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p> parameter to be used as exponent for differences between target and 'current' values </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) and Eike Luedeling (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Bos, Swen PM, et al. &quot;Climate analogs for agricultural impact projection and adaptation-a reliability test.&quot; Frontiers in Environmental Science 3 (2015): 65.
Luedeling, Eike, and Henry Neufeldt. &quot;Carbon sequestration potential of parkland agroforestry in the Sahel.&quot; Climatic Change 115.3-4 (2012): 443-461.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.novel">ensemble.novel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
predictors &lt;- subset(predictors, subset=c("bio1", "bio5", "bio6", "bio7", "bio8", 
    "bio12", "bio16", "bio17"))
predictors
predictors@title &lt;- "base"

# instead of searching for current analogue of future climate conditions,
# search for analogue in southern hemisphere
future.stack &lt;- stack(crop(predictors, y=extent(-125, -32, 0, 40)))
future.stack@title &lt;- "north"
current.stack &lt;- stack(crop(predictors, y=extent(-125, -32, -56, 0)))
current.stack@title &lt;- "south"

# reference location in Florida
# in this case future.stack and current.stack are both current
ref.loc &lt;- data.frame(t(c(-80.19, 25.76)))
names(ref.loc) &lt;- c("lon", "lat")

# climate analogue analysis based on the Mahalanobis distance
Florida.object.mahal &lt;- ensemble.analogue.object(ref.location=ref.loc, 
    future.stack=future.stack, current.stack=current.stack, 
    name="FloridaMahal", method="mahal", an=10000)
Florida.object.mahal

Florida.analogue.mahal &lt;- ensemble.analogue(x=current.stack, 
    analogue.object=Florida.object.mahal, analogues=50)
Florida.analogue.mahal

# climate analogue analysis based on the Euclidean distance and dividing each variable by the sd
Florida.object.sd &lt;- ensemble.analogue.object(ref.location=ref.loc, 
    future.stack=future.stack, current.stack=current.stack, 
    name="FloridaSD", method="sd", z=2)
Florida.object.sd

Florida.analogue.sd &lt;- ensemble.analogue(x=current.stack, 
    analogue.object=Florida.object.sd, analogues=50)
Florida.analogue.sd

# plot analogues on climatic distance maps
par(mfrow=c(1,2))
analogue.file &lt;- paste(getwd(), "//ensembles//analogue//FloridaMahal_south_analogue.tif", sep="")
plot(raster(analogue.file), main="Mahalanobis climatic distance")
points(Florida.analogue.sd[3:50, "lat"] ~ Florida.analogue.sd[3:50, "lon"], 
    pch=1, col="red", cex=1)
points(Florida.analogue.mahal[3:50, "lat"] ~ Florida.analogue.mahal[3:50, "lon"], 
    pch=3, col="black", cex=1)
points(Florida.analogue.mahal[2, "lat"] ~ Florida.analogue.mahal[2, "lon"], 
    pch=22, col="blue", cex=2)
legend(x="topright", legend=c("closest", "Mahalanobis", "SD"), pch=c(22, 3 , 1), 
    col=c("blue" , "black", "red"))

analogue.file &lt;- paste(getwd(), "//ensembles//analogue//FloridaSD_south_analogue.tif", sep="")
plot(raster(analogue.file), main="Climatic distance normalized by standard deviation")
points(Florida.analogue.mahal[3:50, "lat"] ~ Florida.analogue.mahal[3:50, "lon"], 
    pch=3, col="black", cex=1)
points(Florida.analogue.sd[3:50, "lat"] ~ Florida.analogue.sd[3:50, "lon"], 
    pch=1, col="red", cex=1)
points(Florida.analogue.sd[2, "lat"] ~ Florida.analogue.sd[2, "lon"], 
    pch=22, col="blue", cex=2)
legend(x="topright", legend=c("closest", "Mahalanobis", "SD"), pch=c(22, 3 , 1), 
    col=c("blue" , "black", "red"))
par(mfrow=c(1,1))

## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.batch'>
Suitability mapping based on ensembles of modelling algorithms: batch processing
</h2><span id='topic+ensemble.batch'></span><span id='topic+ensemble.mean'></span><span id='topic+ensemble.plot'></span>

<h3>Description</h3>

<p>The main function allows for batch processing of different species and different environmental RasterStacks. The function makes internal calls to <code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code>, <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code> and <code><a href="#topic+ensemble.raster">ensemble.raster</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.batch(x = NULL, xn = c(x), 
    species.presence = NULL, species.absence = NULL, 
    presence.min = 20, thin.km = 0.1,
    an = 1000, excludep = FALSE, target.groups = FALSE,
    get.block = FALSE, block.default = runif(1) &gt; 0.5, get.subblocks = FALSE,
    SSB.reduce = FALSE, CIRCLES.d = 250000, 
    k.splits = 4, k.test = 0, 
    n.ensembles = 1,
    VIF.max = 10, VIF.keep = NULL, 
    SINK = FALSE, CATCH.OFF = FALSE, 
    RASTER.datatype = "INT2S", RASTER.NAflag = -32767, 
    models.save = FALSE,
    threshold.method = "spec_sens", threshold.sensitivity = 0.9, 
    threshold.PresenceAbsence = FALSE,
    ENSEMBLE.best = 0, ENSEMBLE.min = 0.7, ENSEMBLE.exponent = 1,
    ENSEMBLE.weight.min = 0.05,
    input.weights = NULL, 
    MAXENT = 1, MAXNET = 1, MAXLIKE = 1, GBM = 1, GBMSTEP = 0, RF = 1, CF = 1,
    GLM = 1, GLMSTEP = 1, GAM = 1, GAMSTEP = 1, MGCV = 1, MGCVFIX = 0, 
    EARTH = 1, RPART = 1, NNET = 1, FDA = 1, SVM = 1 , SVME = 1, GLMNET = 1,
    BIOCLIM.O = 0, BIOCLIM = 1, DOMAIN = 1, MAHAL = 1, MAHAL01 = 1,
    PROBIT = FALSE,
    Yweights = "BIOMOD", 
    layer.drops = NULL, factors = NULL, dummy.vars = NULL,
    formulae.defaults = TRUE, maxit = 100,
    MAXENT.a = NULL, MAXENT.an = 10000, 
    MAXENT.path = paste(getwd(), "/models/maxent", sep=""),
    MAXNET.classes = "default", MAXNET.clamp = FALSE, MAXNET.type = "cloglog",
    MAXLIKE.formula = NULL, MAXLIKE.method = "BFGS",
    GBM.formula = NULL, GBM.n.trees = 2001, 
    GBMSTEP.tree.complexity = 5, GBMSTEP.learning.rate = 0.005, 
    GBMSTEP.bag.fraction = 0.5, GBMSTEP.step.size = 100,
    RF.formula = NULL, RF.ntree = 751, RF.mtry = floor(sqrt(raster::nlayers(x))),
    CF.formula = NULL, CF.ntree = 751, CF.mtry = floor(sqrt(raster::nlayers(x))), 
    GLM.formula = NULL, GLM.family = binomial(link = "logit"), 
    GLMSTEP.steps = 1000, STEP.formula = NULL, GLMSTEP.scope = NULL, GLMSTEP.k = 2, 
    GAM.formula = NULL, GAM.family = binomial(link = "logit"), 
    GAMSTEP.steps = 1000, GAMSTEP.scope = NULL, GAMSTEP.pos = 1,
    MGCV.formula = NULL, MGCV.select = FALSE, 
    MGCVFIX.formula = NULL, 
    EARTH.formula = NULL, 
    EARTH.glm = list(family = binomial(link = "logit"), maxit = maxit), 
    RPART.formula = NULL, RPART.xval = 50, 
    NNET.formula = NULL, NNET.size = 8, NNET.decay = 0.01, 
    FDA.formula = NULL, 
    SVM.formula = NULL, SVME.formula = NULL,
    GLMNET.nlambda = 100, GLMNET.class = FALSE,
    BIOCLIM.O.fraction = 0.9,
    MAHAL.shape = 1)

ensemble.mean(RASTER.species.name = "Species001", RASTER.stack.name = "base",
    positive.filters = c("tif", "_ENSEMBLE_"), negative.filters = c("xml"), 
    RASTER.format = "GTiff", RASTER.datatype = "INT2S", RASTER.NAflag = -32767,
    abs.breaks = 6, pres.breaks = 6, sd.breaks = 9,
    p = NULL, a = NULL,
    pt = NULL, at = NULL,
    threshold = -1,
    threshold.method = "spec_sens", threshold.sensitivity = 0.9, 
    threshold.PresenceAbsence = FALSE)

ensemble.plot(RASTER.species.name = "Species001", RASTER.stack.name = "base",
    plot.method=c("suitability", "presence", "count", 
        "consensussuitability", "consensuspresence", "consensuscount", "consensussd"),  
    dev.new.width = 7, dev.new.height = 7,
    main = paste(RASTER.species.name, " ", plot.method, 
        " for ", RASTER.stack.name, sep=""),
    positive.filters = c("tif"), negative.filters = c("xml"), 
    p=NULL, a=NULL,
    threshold = -1,
    threshold.method = "spec_sens", threshold.sensitivity = 0.9, 
    threshold.PresenceAbsence = FALSE,
    abs.breaks = 6, abs.col = NULL,
    pres.breaks = 6, pres.col = NULL,
    sd.breaks = 9, sd.col = NULL,
    absencePresence.col = NULL,
    count.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.batch_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all layers to calibrate an ensemble.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_xn">xn</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all layers that correspond to explanatory variables of an ensemble calibrated earlier with <code>x</code>. Several RasterStack objects can be provided in a format as c(stack1, stack2, stack3); these will be used sequentially. See also <code><a href="raster.html#topic+predict">predict</a></code>.   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_species.presence">species.presence</code></td>
<td>
<p> presence points used for calibrating the suitability models, available in 3-column (species, x, y) or (species, lon, lat) dataframe  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_species.absence">species.absence</code></td>
<td>
<p> background points used for calibrating the suitability models, either available in a 3-column (species, x, y) or (species, lon, lat), or available in a 2-column (x, y) or (lon, lat) dataframe. In case of a 2-column dataframe, the same background locations will be used for all species.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_presence.min">presence.min</code></td>
<td>
<p> minimum number of presence locations for the organism (if smaller, no models are fitted).  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_thin.km">thin.km</code></td>
<td>
<p> Threshold for minimum distance (km) between presence point locations for focal species for model calibrations in each run. A new data set is randomly selected via <code><a href="#topic+ensemble.spatialThin">ensemble.spatialThin</a></code> in each of ensemble run.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_an">an</code></td>
<td>
<p> number of background points for calibration to be selected with <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> in case argument <code>a</code> or <code>species.absence</code> is missing  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_excludep">excludep</code></td>
<td>
<p> parameter that indicates (if <code>TRUE</code>) that presence points will be excluded from the background points; see also <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_target.groups">target.groups</code></td>
<td>
<p> Parameter that indicates (if <code>TRUE</code>) that the provided background points (argument <code>a</code>) represent presence points from a target group sensu Phillips et al. 2009 (these are species that are all collected or observed using the same methods or equipment). Setting the parameter to <code>TRUE</code> results in selecting the centres of cells of the target groups as background points, while avoiding to select the same cells twice. Via argument <code>excludep</code>, it is possible to filter out cells with presence observations (argument <code>p</code>).  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_get.block">get.block</code></td>
<td>
<p> if <code>TRUE</code>, instead of creating k-fold cross-validation subsets randomly (<code><a href="dismo.html#topic+kfold">kfold</a></code>), create 4 subsets of presence and background locations with <code><a href="ENMeval.html#topic+get.block">get.block</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_block.default">block.default</code></td>
<td>
<p> if <code>FALSE</code>, instead of making the first division of presence point locations along the y-coordinates (latitude) as in <code><a href="ENMeval.html#topic+get.block">get.block</a></code>, make the first division along the x-coordinates (longitude).  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_get.subblocks">get.subblocks</code></td>
<td>
<p> if <code>TRUE</code>, then 4 subsets of presence and background locations are generated in a checkerboard configuration by applying <code><a href="ENMeval.html#topic+get.block">get.block</a></code> to each of the 4 blocks generated by <code><a href="ENMeval.html#topic+get.block">get.block</a></code> in a first step. </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_ssb.reduce">SSB.reduce</code></td>
<td>
<p> If <code>TRUE</code>, then new background points that will be used for evaluationg the suitability models will be selected (<code><a href="dismo.html#topic+randomPoints">randomPoints</a></code>) in circular neighbourhoods (created with <code><a href="dismo.html#topic+circles">circles</a></code>) around presence locations (p and pt). The abbreviation of SSB refers to spatial sorting bias; see also <code><a href="dismo.html#topic+ssb">ssb</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_circles.d">CIRCLES.d</code></td>
<td>
<p> Radius in m of circular neighbourhoods (created with <code><a href="dismo.html#topic+circles">circles</a></code>) around presence locations (p and pt).  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_k">k</code></td>
<td>
<p> If larger than 1, the mumber of groups to split between calibration (k-1) and evaluation (1) data sets (for example, <code>k=5</code> results in 4/5 of presence and background points to be used for calibrating the models, and 1/5 of presence and background points to be used for evaluating the models). See also <code><a href="dismo.html#topic+kfold">kfold</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_k.splits">k.splits</code></td>
<td>
<p> If larger than 1, the number of splits for the <code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code> step in batch processing. See also <code><a href="dismo.html#topic+kfold">kfold</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_k.test">k.test</code></td>
<td>
<p> If larger than 1, the mumber of groups to split between calibration (k-1) and evaluation (1) data sets when calibrating the final models (for example, <code>k=5</code> results in 4/5 of presence and background points to be used for calibrating the models, and 1/5 of presence and background points to be used for evaluating the models). See also <code><a href="dismo.html#topic+kfold">kfold</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_n.ensembles">n.ensembles</code></td>
<td>
<p> If larger than 1, the number of different ensembles generated per species in batch processing. </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_vif.max">VIF.max</code></td>
<td>
<p> Maximum Variance Inflation Factor of variables; see <code><a href="#topic+ensemble.VIF">ensemble.VIF</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_vif.keep">VIF.keep</code></td>
<td>
<p> character vector with names of the variables to be kept; see <code><a href="#topic+ensemble.VIF">ensemble.VIF</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_sink">SINK</code></td>
<td>
<p> Append the results to a text file in subfolder 'outputs' (if <code>TRUE</code>). The name of file is based on species names. In case a file already exists, then results are appended. See also <code><a href="base.html#topic+sink">sink</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_raster.format">RASTER.format</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_raster.datatype">RASTER.datatype</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+dataType">dataType</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_raster.naflag">RASTER.NAflag</code></td>
<td>
<p> Value that is used to store missing data. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_models.save">models.save</code></td>
<td>
<p> Save the list with model details to a file (if <code>TRUE</code>). The filename will be <code>species.name</code> with extension <code>.models</code>; this file will be saved in subfolder of <code>models</code>. When loading this file, model results will be available as <code>ensemble.models</code>. </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_threshold.method">threshold.method</code></td>
<td>
<p> Method to calculate the threshold between predicted absence and presence; possibilities include <code>spec_sens</code> (highest sum of the true positive rate and the true negative rate), <code>kappa</code> (highest kappa value), <code>no_omission</code> (highest threshold that corresponds to no omission), <code>prevalence</code> (modeled prevalence is closest to observed prevalence) and <code>equal_sens_spec</code> (equal true positive rate and true negative rate). See <code><a href="dismo.html#topic+threshold">threshold</a></code>. Options specific to the BiodiversityR implementation are: <code>threshold.mean</code> (resulting in calculating the mean value of <code>spec_sens</code>, <code>equal_sens_spec</code> and <code>prevalence</code>) and <code>threshold.min</code> (resulting in calculating the minimum value of <code>spec_sens</code>, <code>equal_sens_spec</code> and <code>prevalence</code>).   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_threshold.sensitivity">threshold.sensitivity</code></td>
<td>
<p> Sensitivity value for <code>threshold.method = 'sensitivity'</code>. See <code><a href="dismo.html#topic+threshold">threshold</a></code>.   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_threshold.presenceabsence">threshold.PresenceAbsence</code></td>
<td>
<p> If <code>TRUE</code> calculate thresholds with the PresenceAbsence package. See <code><a href="PresenceAbsence.html#topic+optimal.thresholds">optimal.thresholds</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_ensemble.best">ENSEMBLE.best</code></td>
<td>
<p> The number of individual suitability models to be used in the consensus suitability map (based on a weighted average). In case this parameter is smaller than 1 or larger than the number of positive input weights of individual models, then all individual suitability models with positive input weights are included in the consensus suitability map. In case a vector is provided, <code>ensemble.strategy</code> is called internally to determine weights for the ensemble model. </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_ensemble.min">ENSEMBLE.min</code></td>
<td>
<p> The minimum input weight (typically corresponding to AUC values) for a model to be included in the ensemble. In case a vector is provided, function <code>ensemble.strategy</code> is called internally to determine weights for the ensemble model.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_ensemble.exponent">ENSEMBLE.exponent</code></td>
<td>
<p> Exponent applied to AUC values to convert AUC values into weights (for example, an exponent of 2 converts input weights of 0.7, 0.8 and 0.9 into 0.7^2=0.49, 0.8^2=0.64 and 0.9^2=0.81). See details. </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_ensemble.weight.min">ENSEMBLE.weight.min</code></td>
<td>
<p> The minimum output weight for models included in the ensemble, applying to weights that sum to one. Note that <code>ENSEMBLE.min</code> typically refers to input AUC values.   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_input.weights">input.weights</code></td>
<td>
<p> array with numeric values for the different modelling algorithms; if <code>NULL</code> then values provided by parameters such as <code>MAXENT</code> and <code>GBM</code> will be used. As an alternative, the output from <code>ensemble.calibrate.weights</code> can be used. </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxent">MAXENT</code></td>
<td>
<p> Input weight for a maximum entropy model (<code><a href="dismo.html#topic+maxent">maxent</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxnet">MAXNET</code></td>
<td>
<p> number: if larger than 0, then a maximum entropy model (<code><a href="maxnet.html#topic+maxnet">maxnet</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxlike">MAXLIKE</code></td>
<td>
<p> Input weight for a maxlike model (<code><a href="maxlike.html#topic+maxlike">maxlike</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gbm">GBM</code></td>
<td>
<p> Input weight for a boosted regression trees model (<code><a href="gbm.html#topic+gbm">gbm</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gbmstep">GBMSTEP</code></td>
<td>
<p> Input weight for a stepwise boosted regression trees model (<code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_rf">RF</code></td>
<td>
<p> Input weight for a random forest model (<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_cf">CF</code></td>
<td>
<p> number: if larger than 0, then a random forest model (<code><a href="party.html#topic+cforest">cforest</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glm">GLM</code></td>
<td>
<p> Input weight for a generalized linear model (<code><a href="stats.html#topic+glm">glm</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glmstep">GLMSTEP</code></td>
<td>
<p> Input weight for a stepwise generalized linear model (<code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gam">GAM</code></td>
<td>
<p> Input weight for a generalized additive model (<code><a href="gam.html#topic+gam">gam</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gamstep">GAMSTEP</code></td>
<td>
<p> Input weight for a stepwise generalized additive model (<code><a href="gam.html#topic+step.gam">step.gam</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_mgcv">MGCV</code></td>
<td>
<p> Input weight for a generalized additive model (<code><a href="mgcv.html#topic+gam">gam</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_mgcvfix">MGCVFIX</code></td>
<td>
<p> number: if larger than 0, then a generalized additive model with fixed d.f. regression splines (<code><a href="mgcv.html#topic+gam">gam</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_earth">EARTH</code></td>
<td>
<p> Input weight for a multivariate adaptive regression spline model (<code><a href="earth.html#topic+earth">earth</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_rpart">RPART</code></td>
<td>
<p> Input weight for a recursive partioning and regression tree model (<code><a href="rpart.html#topic+rpart">rpart</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_nnet">NNET</code></td>
<td>
<p> Input weight for an artificial neural network model (<code><a href="nnet.html#topic+nnet">nnet</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_fda">FDA</code></td>
<td>
<p> Input weight for a flexible discriminant analysis model (<code><a href="mda.html#topic+fda">fda</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_svm">SVM</code></td>
<td>
<p> Input weight for a support vector machine model (<code><a href="kernlab.html#topic+ksvm">ksvm</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_svme">SVME</code></td>
<td>
<p> Input weight for a support vector machine model (<code><a href="e1071.html#topic+svm">svm</a></code>). (Only weights &gt; 0 will be used.) </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glmnet">GLMNET</code></td>
<td>
<p> Input weight for a GLM with lasso or elasticnet regularization (<code><a href="glmnet.html#topic+glmnet">glmnet</a></code>). (Only weights &gt; 0 will be used.) </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_bioclim.o">BIOCLIM.O</code></td>
<td>
<p> Input weight for the original BIOCLIM algorithm (<code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>). (Only weights &gt; 0 will be used.) </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_bioclim">BIOCLIM</code></td>
<td>
<p> Input weight for the BIOCLIM algorithm (<code><a href="dismo.html#topic+bioclim">bioclim</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_domain">DOMAIN</code></td>
<td>
<p> Input weight for the DOMAIN algorithm (<code><a href="dismo.html#topic+domain">domain</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_mahal">MAHAL</code></td>
<td>
<p> Input weight for the Mahalonobis algorithm (<code><a href="dismo.html#topic+mahal">mahal</a></code>). (Only weights &gt; 0 will be used.)  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_mahal01">MAHAL01</code></td>
<td>
<p> Input weight for the Mahalanobis algorithm (<code><a href="dismo.html#topic+mahal">mahal</a></code>), using a transformation method afterwards whereby output is within the range between 0 and 1. (Only weights &gt; 0 will be used.) </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_probit">PROBIT</code></td>
<td>
<p> If <code>TRUE</code>, then subsequently to the fitting of the individual algorithm (e.g. maximum entropy or GAM) a generalized linear model (<code><a href="stats.html#topic+glm">glm</a></code>) with probit link <code>family=binomial(link="probit")</code> will be fitted to transform the predictions, using the previous predictions as explanatory variable. This transformation results in all model predictions to be probability estimates.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_yweights">Yweights</code></td>
<td>
<p> chooses how cases of presence and background (absence) are weighted; <code>"BIOMOD"</code> results in equal weighting of all presence and all background cases, <code>"equal"</code> results in equal weighting of all cases. The user can supply a vector of weights similar to the number of cases in the calibration data set. </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_layer.drops">layer.drops</code></td>
<td>
<p> vector that indicates which layers should be removed from RasterStack <code>x</code>. See also <code><a href="raster.html#topic+addLayer">addLayer</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_factors">factors</code></td>
<td>
<p> vector that indicates which variables are factors; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_dummy.vars">dummy.vars</code></td>
<td>
<p> vector that indicates which variables are dummy variables (influences formulae suggestions) </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_formulae.defaults">formulae.defaults</code></td>
<td>
<p> Suggest formulae for most of the models (if <code>TRUE</code>). See also <code><a href="#topic+ensemble.formulae">ensemble.formulae</a></code>.   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxit">maxit</code></td>
<td>
<p> Maximum number of iterations for some of the models. See also <code><a href="stats.html#topic+glm.control">glm.control</a></code>, <code><a href="gam.html#topic+gam.control">gam.control</a></code>, <code><a href="mgcv.html#topic+gam.control">gam.control</a></code> and <code><a href="nnet.html#topic+nnet">nnet</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxent.a">MAXENT.a</code></td>
<td>
<p> background points used for calibrating the maximum entropy model (<code><a href="dismo.html#topic+maxent">maxent</a></code>), typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxent.an">MAXENT.an</code></td>
<td>
<p> number of background points for calibration to be selected with <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> in case argument <code>MAXENT.a</code> is missing. When used with the <code>ensemble.batch</code> function, the same background locations will be used for each of the species runs; this implies that for each species, presence locations are not excluded from the background data for this function.   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxent.path">MAXENT.path</code></td>
<td>
<p> path to the directory where output files of the maximum entropy model are stored; see also <code><a href="dismo.html#topic+maxent">maxent</a></code>   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxnet.classes">MAXNET.classes</code></td>
<td>
<p> continuous feature classes, either &quot;default&quot; or any subset of &quot;lqpht&quot; (linear, quadratic, product, hinge, threshold). Note that the &quot;default&quot; option chooses feature classes based on the number of presence locations as &quot;l&quot; (&lt; 10 locations), &quot;lq&quot; (10 - 14 locations), &quot;lqh&quot; (15 - 79 locations) or &quot;lqph&quot; (&gt; 79 locations). See also <code><a href="maxnet.html#topic+maxnet">maxnet</a></code>.   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxnet.clamp">MAXNET.clamp</code></td>
<td>
<p> restrict predictors and features to the range seen during model training; see also <code><a href="maxnet.html#topic+predict.maxnet">predict.maxnet</a></code>   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxnet.type">MAXNET.type</code></td>
<td>
<p> type of response required; see also <code><a href="maxnet.html#topic+predict.maxnet">predict.maxnet</a></code>   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxlike.formula">MAXLIKE.formula</code></td>
<td>
<p> formula for the maxlike algorithm; see also <code><a href="maxlike.html#topic+maxlike">maxlike</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_maxlike.method">MAXLIKE.method</code></td>
<td>
<p> method for the maxlike algorithm; see also <code><a href="stats.html#topic+optim">optim</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gbm.formula">GBM.formula</code></td>
<td>
<p> formula for the boosted regression trees algorithm; see also <code><a href="gbm.html#topic+gbm">gbm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gbm.n.trees">GBM.n.trees</code></td>
<td>
<p> total number of trees to fit for the boosted regression trees model; see also <code><a href="gbm.html#topic+gbm">gbm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gbmstep.tree.complexity">GBMSTEP.tree.complexity</code></td>
<td>
<p> complexity of individual trees for stepwise boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gbmstep.learning.rate">GBMSTEP.learning.rate</code></td>
<td>
<p> weight applied to individual trees for stepwise boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code> </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gbmstep.bag.fraction">GBMSTEP.bag.fraction</code></td>
<td>
<p> proportion of observations used in selecting variables for stepwise boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gbmstep.step.size">GBMSTEP.step.size</code></td>
<td>
<p> number of trees to add at each cycle for stepwise boosted regression trees (should be small enough to result in a smaller holdout deviance than the initial number of trees [50]); see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_rf.formula">RF.formula</code></td>
<td>
<p> formula for the random forest algorithm; see also <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_rf.ntree">RF.ntree</code></td>
<td>
<p> number of trees to grow for random forest algorithm; see also <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_rf.mtry">RF.mtry</code></td>
<td>
<p> number of variables randomly sampled as candidates at each split for random forest algorithm; see also <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_cf.formula">CF.formula</code></td>
<td>
<p> formula for random forest algorithm; see also <code><a href="party.html#topic+cforest">cforest</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_cf.ntree">CF.ntree</code></td>
<td>
<p> number of trees to grow in a forest; see also <code><a href="party.html#topic+cforest_control">cforest_control</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_cf.mtry">CF.mtry</code></td>
<td>
<p> number of input variables randomly sampled as candidates at each node for random forest like algorithms; see also <code><a href="party.html#topic+cforest_control">cforest_control</a></code>   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glm.formula">GLM.formula</code></td>
<td>
<p> formula for the generalized linear model; see also <code><a href="stats.html#topic+glm">glm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glm.family">GLM.family</code></td>
<td>
<p> description of the error distribution and link function for the generalized linear model; see also <code><a href="stats.html#topic+glm">glm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glmstep.steps">GLMSTEP.steps</code></td>
<td>
<p> maximum number of steps to be considered for stepwise generalized linear model; see also <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_step.formula">STEP.formula</code></td>
<td>
<p> formula for the &quot;starting model&quot; to be considered for stepwise generalized linear model; see also <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glmstep.scope">GLMSTEP.scope</code></td>
<td>
<p> range of models examined in the stepwise search; see also <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glmstep.k">GLMSTEP.k</code></td>
<td>
<p> multiple of the number of degrees of freedom used for the penalty (only k = 2 gives the genuine AIC); see also <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gam.formula">GAM.formula</code></td>
<td>
<p> formula for the generalized additive model; see also <code><a href="gam.html#topic+gam">gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gam.family">GAM.family</code></td>
<td>
<p> description of the error distribution and link function for the generalized additive model; see also <code><a href="gam.html#topic+gam">gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gamstep.steps">GAMSTEP.steps</code></td>
<td>
<p> maximum number of steps to be considered in the stepwise generalized additive model; see also <code><a href="gam.html#topic+step.gam">step.gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gamstep.scope">GAMSTEP.scope</code></td>
<td>
<p> range of models examined in the step-wise search n the stepwise generalized additive model; see also <code><a href="gam.html#topic+step.gam">step.gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_gamstep.pos">GAMSTEP.pos</code></td>
<td>
<p> parameter expected to be set to 1 to allow for fitting of the stepwise generalized additive model  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_mgcv.formula">MGCV.formula</code></td>
<td>
<p> formula for the generalized additive model; see also <code><a href="mgcv.html#topic+gam">gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_mgcv.select">MGCV.select</code></td>
<td>
<p> if <code>TRUE</code>, then the smoothing parameter estimation that is part of fitting can completely remove terms from the model; see also <code><a href="mgcv.html#topic+gam">gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_mgcvfix.formula">MGCVFIX.formula</code></td>
<td>
<p> formula for the generalized additive model with fixed d.f. regression splines; see also <code><a href="mgcv.html#topic+gam">gam</a></code> (the default formulae sets &quot;s(..., fx=TRUE, ...)&quot;; see also <code><a href="mgcv.html#topic+s">s</a></code>) </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_earth.formula">EARTH.formula</code></td>
<td>
<p> formula for the multivariate adaptive regression spline model; see also <code><a href="earth.html#topic+earth">earth</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_earth.glm">EARTH.glm</code></td>
<td>
<p> list of arguments to pass on to <code><a href="stats.html#topic+glm">glm</a></code>; see also <code><a href="earth.html#topic+earth">earth</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_rpart.formula">RPART.formula</code></td>
<td>
<p> formula for the recursive partioning and regression tree model; see also <code><a href="rpart.html#topic+rpart">rpart</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_rpart.xval">RPART.xval</code></td>
<td>
<p> number of cross-validations for the recursive partioning and regression tree model; see also <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_nnet.formula">NNET.formula</code></td>
<td>
<p> formula for the artificial neural network model; see also <code><a href="nnet.html#topic+nnet">nnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_nnet.size">NNET.size</code></td>
<td>
<p> number of units in the hidden layer for the artificial neural network model; see also <code><a href="nnet.html#topic+nnet">nnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_nnet.decay">NNET.decay</code></td>
<td>
<p> parameter of weight decay for the artificial neural network model; see also <code><a href="nnet.html#topic+nnet">nnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_fda.formula">FDA.formula</code></td>
<td>
<p> formula for the flexible discriminant analysis model; see also <code><a href="mda.html#topic+fda">fda</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_svm.formula">SVM.formula</code></td>
<td>
<p> formula for the support vector machine model; see also <code><a href="kernlab.html#topic+ksvm">ksvm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_svme.formula">SVME.formula</code></td>
<td>
<p> formula for the support vector machine model; see also <code><a href="e1071.html#topic+svm">svm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glmnet.nlambda">GLMNET.nlambda</code></td>
<td>
<p> The number of <code>lambda</code> values; see also <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_glmnet.class">GLMNET.class</code></td>
<td>
<p> Use the predicted class to calculate the mean predictions of GLMNET; see also <code><a href="glmnet.html#topic+predict.glmnet">predict.glmnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_bioclim.o.fraction">BIOCLIM.O.fraction</code></td>
<td>
<p> Fraction of range representing the optimal limits, default value of 0.9 as in the original BIOCLIM software (<code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>).  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_mahal.shape">MAHAL.shape</code></td>
<td>
<p> parameter that influences the transformation of output values of <code><a href="dismo.html#topic+mahal">mahal</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_raster.species.name">RASTER.species.name</code></td>
<td>
<p> First part of the names of the raster files, expected to identify the modelled species (or organism). </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_raster.stack.name">RASTER.stack.name</code></td>
<td>
<p> Last part of the names of the raster files, expected to identify the predictor stack used. </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_positive.filters">positive.filters</code></td>
<td>
<p> vector that indicates parts of filenames for files that will be included in the calculation of the mean probability values  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_negative.filters">negative.filters</code></td>
<td>
<p> vector that indicates parts of filenames for files that will not be included in the calculation of the mean probability values  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_abs.breaks">abs.breaks</code></td>
<td>
<p> Number of breaks in the colouring scheme for absence (only applies to <code>suitability</code> mapping).   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_pres.breaks">pres.breaks</code></td>
<td>
<p> Number of breaks in the colouring scheme for presence (only applies to <code>suitability</code> mapping).  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_sd.breaks">sd.breaks</code></td>
<td>
<p> Number of breaks in the colouring scheme for standard deviation (only applies to <code>sd</code> mapping).  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_p">p</code></td>
<td>
<p> presence points used for calibrating the suitability models, typically available in 2-column (x, y) or (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_a">a</code></td>
<td>
<p> background points used for calibrating the suitability models, typically available in 2-column (x, y) or (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_pt">pt</code></td>
<td>
<p> presence points used for evaluating the suitability models, typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_at">at</code></td>
<td>
<p> background points used for calibrating the suitability models, typicall available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_threshold">threshold</code></td>
<td>
<p> Threshold value that will be used to distinguish between presence and absence. If &lt; 0, then a threshold value will be calculated from the provided presence <code>p</code> and absence <code>a</code> locations.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_plot.method">plot.method</code></td>
<td>
<p> Choice of maps to be plotted: <code>suitability</code> plots suitability maps, <code>presence</code> plots presence-absence maps, <code>count</code> plots count maps (count of number of algorithms or number of ensembles predicting presence) and <code>sd</code> plots standard deviation maps.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_dev.new.width">dev.new.width</code></td>
<td>
<p> Width for new graphics device (<code><a href="grDevices.html#topic+dev.new">dev.new</a></code>). If &lt; 0, then no new graphics device is opened.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_dev.new.height">dev.new.height</code></td>
<td>
<p> Heigth for new graphics device (<code><a href="grDevices.html#topic+dev.new">dev.new</a></code>). If &lt; 0, then no new graphics device is opened.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_main">main</code></td>
<td>
<p> main title for the plots.  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_abs.col">abs.col</code></td>
<td>
<p> specify colours for absence (see examples on how not to plot areas where the species is predicted absent)   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_pres.col">pres.col</code></td>
<td>
<p> specify colours for presence  </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_sd.col">sd.col</code></td>
<td>
<p> specify colours for standard deviation   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_absencepresence.col">absencePresence.col</code></td>
<td>
<p> specify colours for absence - presence maps (see examples on how not to plot areas where the species is predicted absent)   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_count.col">count.col</code></td>
<td>
<p> specify colours for number of algorithms or ensembles (see examples on how not to plot areas where the species is predicted absent)   </p>
</td></tr>
<tr><td><code id="ensemble.batch_+3A_...">...</code></td>
<td>
<p> Other items passed to function <code><a href="raster.html#topic+plot">plot</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for batch processing of different species and different environmental RasterStacks. The function makes internal calls to <code><a href="#topic+ensemble.spatialThin">ensemble.spatialThin</a></code>, <code><a href="#topic+ensemble.VIF">ensemble.VIF</a></code>, <code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code>, <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code> and <code><a href="#topic+ensemble.raster">ensemble.raster</a></code>. 
</p>
<p>Different ensemble runs allow for different random selection of k-fold subsets, background locations or spatial thinning of presence locations.
</p>
<p><code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code> results in a cross-validation procedure whereby the data set is split in calibration and testing subsets and the best weights for the ensemble model are determined (including the possibility for weights = 0).
</p>
<p><code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code> is the step whereby models are calibrated using all the available presence data.
</p>
<p><code><a href="#topic+ensemble.raster">ensemble.raster</a></code> is the final step whereby raster layers are produced for the ensemble model.
</p>
<p>Function <code>ensemble.mean</code> results in raster layers that are based on the summary of several ensemble layers: the new ensemble has probability values that are the mean of the probabilities of the different raster layers, the presence-absence threshold is derived for this new ensemble layer, whereas the count reflects the number of ensemble layers where presence was predicted. Note the assumption that input probabilities are scaled between 0 and 1000 (as the output from <code><a href="#topic+ensemble.raster">ensemble.raster</a></code>), whereas thresholds are based on actual probabilities (scaled between 0 and 1). After the mean probability has been calculated, the niche overlap (<code><a href="dismo.html#topic+nicheOverlap">nicheOverlap</a></code>) with the different input layers is calculated. 
</p>
<p>Function <code>ensemble.plot</code> plots suitability, presence-absence or count maps. In the case of suitability maps, the presence-absence threshold needs to be provide as suitabilities smaller than the threshold will be coloured red to orange, whereas suitabilities larger than the threshold will be coloured light blue to dark blue.
</p>


<h3>Value</h3>

<p>The function finally results in ensemble raster layers for each species, including the fitted values for the ensemble model, the estimated presence-absence and the count of the number of submodels prediction presence and absence. 
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre), Eike Luedeling (World Agroforestry Centre) and Evert Thomas (Bioversity International) </p>


<h3>References</h3>

<p>Kindt R. 2018. Ensemble species distribution modelling with transformed suitability values. Environmental Modelling &amp; Software 100: 136-145. <a href="https://doi.org/10.1016/j.envsoft.2017.11.009">doi:10.1016/j.envsoft.2017.11.009</a>
</p>
<p>Buisson L, Thuiller W, Casajus N, Lek S and Grenouillet G. 2010. Uncertainty in ensemble forecasting of species distribution. Global Change Biology 16: 1145-1157
</p>
<p>Phillips SJ, Dudik M, Elith J et al. 2009. Sample selection bias and presence-only distribution models: implications for background and pseudo-absence data. Ecological Applications 19: 181-197.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code>, <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code>, <code><a href="#topic+ensemble.raster">ensemble.raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# based on examples in the dismo package

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17", "biome"))
predictors
predictors@title &lt;- "base"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')
pres[,1] &lt;- rep("Bradypus", nrow(pres))

# choose background points
background &lt;- randomPoints(predictors, n=1000, extf = 1.00)

# north and south for new predictions (as if new climates)
ext2 &lt;- extent(-90, -32, 0, 23)
predictors2 &lt;- crop(predictors, y=ext2)
predictors2 &lt;- stack(predictors2)
predictors2@title &lt;- "north"

ext3 &lt;- extent(-90, -32, -33, 0)
predictors3 &lt;- crop(predictors, y=ext3)
predictors3 &lt;- stack(predictors3)
predictors3@title &lt;- "south"

# fit 3 ensembles with batch processing, choosing the best ensemble model based on the 
# average weights of 4-fold split of calibration and testing data
# final models use all available presence data and average weights determined by the 
# ensemble.calibrate.weights function (called internally)
# batch processing can handle several species by using 3-column species.presence and 
# species.absence data sets
# note that these calculations can take a while

ensemble.nofactors &lt;- ensemble.batch(x=predictors, 
    xn=c(predictors, predictors2, predictors3),
    species.presence=pres, 
    species.absence=background, 
    k.splits=4, k.test=0, 
    n.ensembles=3, 
    SINK=TRUE, 
    layer.drops=c("biome"),
    ENSEMBLE.best=0, ENSEMBLE.exponent=c(1, 2, 3), 
    ENSEMBLE.min=0.7,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=1, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, GLMNET=1,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    PROBIT=TRUE,
    Yweights="BIOMOD",
    formulae.defaults=TRUE)

# summaries for the 3 ensembles for the species
# summaries are based on files in folders ensemble/suitability, 
# ensemble/presence and ensemble/count
# ensemble.mean is used internally in ensemble.batch

ensemble.mean(RASTER.species.name="Bradypus", RASTER.stack.name="base",
    p=pres, a=background)

# plot mean suitability without specifying colours
plot1 &lt;- ensemble.plot(RASTER.species.name="Bradypus", RASTER.stack.name="base",
    plot.method="consensussuitability",
    p=pres, a=background, abs.breaks=4, pres.breaks=9)
plot1

# only colour the areas where species is predicted to be present
# option is invoked by having no absence breaks
# same colourscheme as \url{http://www.worldagroforestry.org/atlas-central-america}
LAatlascols &lt;- grDevices::colorRampPalette(c("#FFFF80", "#38E009","#1A93AB", "#0C1078"))
plot2 &lt;- ensemble.plot(RASTER.species.name="Bradypus", RASTER.stack.name="base",
    plot.method="consensussuitability",
    p=pres, a=background, abs.breaks=0, pres.breaks=9, pres.col=LAatlascols(8))
plot2

# only colour the areas where species is predicted to be present
# option is invoked by only setting one colour for absence-presence
plot3 &lt;- ensemble.plot(RASTER.species.name="Bradypus", RASTER.stack.name="base",
    plot.method="consensuspresence",
    absencePresence.col=c("#90EE90"))

# only colour presence area by specifying colours &gt; 0
plot4 &lt;- ensemble.plot(RASTER.species.name="Bradypus", RASTER.stack.name="base",
    plot.method="consensuscount",
    count.col=LAatlascols(3))




## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.bioclim'>
Suitability mapping based on the BIOCLIM algorithm
</h2><span id='topic+ensemble.bioclim'></span><span id='topic+ensemble.bioclim.object'></span>

<h3>Description</h3>

<p>Implementation of the BIOCLIM algorithm more similar to the original BIOCLIM algorithm and software than the implementation through <code><a href="dismo.html#topic+bioclim">bioclim</a></code>. Function <code>ensemble.bioclim</code> creates the suitability map. Function <code>ensemble.bioclim.object</code> provides the reference values used by the prediction function used by <code><a href="raster.html#topic+predict">predict</a></code> . 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.bioclim(x = NULL, bioclim.object = NULL, 
    RASTER.object.name = bioclim.object$species.name, RASTER.stack.name = x@title,
    RASTER.format = "GTiff",
    CATCH.OFF = FALSE)

ensemble.bioclim.object(x = NULL, p = NULL, fraction = 0.9,
    quantiles = TRUE, 
    species.name = "Species001", 
    factors = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.bioclim_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all environmental layers for which suitability should be calculated, or alternatively a data.frame containing the bioclimatic variables.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_bioclim.object">bioclim.object</code></td>
<td>
<p> Object listing optimal and absolute minima and maxima for bioclimatic variables, used by the prediction function that is used internally by <code><a href="raster.html#topic+predict">predict</a></code>. This object is created with <code><a href="#topic+ensemble.bioclim.object">ensemble.bioclim.object</a></code>. </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_raster.object.name">RASTER.object.name</code></td>
<td>
<p> First part of the names of the raster file that will be generated, expected to identify the species or crop for which ranges were calculated </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_raster.stack.name">RASTER.stack.name</code></td>
<td>
<p> Last part of the names of the raster file that will be generated, expected to identify the predictor stack used </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_raster.format">RASTER.format</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_p">p</code></td>
<td>
<p> presence points used for calibrating the suitability models, typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_fraction">fraction</code></td>
<td>
<p> Fraction of range representing the optimal limits, default value of 0.9 as in the original BIOCLIM software.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_quantiles">quantiles</code></td>
<td>
<p> If <code>TRUE</code> then optimal limits are calculated as quantiles corresponding to <code>0.5-fraction/2</code> and <code>0.5+fraction/2</code> percentiles. If <code>FALSE</code> then optimal limits are calculated from the normal distribution with <code>mean - cutoff*sd</code> and <code>mean + cutoff*sd</code> with <code>cutoff</code> calculated as <code>qnorm(0.5+fraction/2)</code>. </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_species.name">species.name</code></td>
<td>
<p> Name by which the model results will be saved.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim_+3A_factors">factors</code></td>
<td>
<p> vector that indicates which variables are factors; these variables will be ignored by the BIOCLIM algorithm   </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Function <code>ensemble.bioclim</code> maps suitability for a species based on optimal (percentiles, typically 5 and 95 percent) and absolute (minimum to maximum) limits for bioclimatic variables. If all values at a given location are within the optimal limits, suitability values are mapped as 1 (suitable). If not all values are within the optimal limits, but all values are within the absolute limits, suitability values are mapped as 0.5 (marginal). If not all values are within the absolute limits, suitability values are mapped as 0 (unsuitable).
</p>
<p>Function <code>ensemble.bioclim.object</code> calculates the optimal and absolute limits. Optimal limits are calculated based on the parameter <code>fraction</code>, resulting in optimal limits that correspond to 0.5-fraction/2 and 0.5+fraction/2 (the default value of 0.9 therefore gives a lower limit of 0.05 and a upper limit of 0.95). Two methods are implemented to obtain optimal limits for the lower and upper limits. One method (<code>quantiles = FALSE</code>) uses mean, standard deviation and a cutoff parameter calculated with <code><a href="stats.html#topic+qnorm">qnorm</a></code>. The other method (<code>quantiles = TRUE</code>) calculates optimal limits via the <code><a href="stats.html#topic+quantile">quantile</a></code> function. To handle possible asymmetrical distributions better, the second method is used as default.
</p>
<p>When <code>x</code> is a RasterStack and point locations are provided, then optimal and absolute limits correspond to the bioclimatic values observed for the locations. When <code>x</code> is RasterStack and point locations are not provided, then optimal and absolute limits correspond to the bioclimatic values of the RasterStack. 
</p>
<p>Applying to algorithm without providing point locations will provide results that are similar to the <code><a href="#topic+ensemble.novel">ensemble.novel</a></code> function, whereby areas plotted as not suitable will be the same areas that are novel.
</p>


<h3>Value</h3>

<p>Function <code>ensemble.bioclim.object</code> returns a list with following objects:
</p>
<table role = "presentation">
<tr><td><code>lower.limits</code></td>
<td>
<p> vector with lower limits for each bioclimatic variable </p>
</td></tr>
<tr><td><code>upper.limits</code></td>
<td>
<p> vector with upper limits for each bioclimatic variable </p>
</td></tr>
<tr><td><code>minima</code></td>
<td>
<p> vector with minima for each bioclimatic variable </p>
</td></tr>
<tr><td><code>maxima</code></td>
<td>
<p> vector with maxima for each bioclimatic variable </p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p> vector with mean values for each bioclimatic variable </p>
</td></tr>
<tr><td><code>medians</code></td>
<td>
<p> vector with median values for each bioclimatic variable </p>
</td></tr>
<tr><td><code>sds</code></td>
<td>
<p> vector with standard deviation values for each bioclimatic variable </p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p> cutoff value for the normal distribution </p>
</td></tr>
<tr><td><code>fraction</code></td>
<td>
<p> fraction of values within the optimal limits </p>
</td></tr>
<tr><td><code>species.name</code></td>
<td>
<p> name for the species </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) with inputs from Trevor Booth (CSIRO)</p>


<h3>References</h3>

<p>Nix HA. 1986. A biogeographic analysis of Australian elapid snakes. In: Atlas of Elapid Snakes of Australia. (Ed.) R. Longmore, pp. 4-15. Australian Flora and Fauna Series Number 7. Australian Government Publishing Service: Canberra.
</p>
<p>Booth TH, Nix HA, Busby JR and Hutchinson MF. 2014. BIOCLIM: the first species distribution modelling package, its early applications and relevance to most current MAXENT studies. Diversity and Distributions 20: 1-9
</p>


<h3>See Also</h3>

<p><code><a href="dismo.html#topic+bioclim">bioclim</a></code>, <code><a href="#topic+ensemble.bioclim.graph">ensemble.bioclim.graph</a></code> and <code><a href="#topic+ensemble.novel">ensemble.novel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17", "biome"))
predictors
predictors@title &lt;- "base"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]

background &lt;- dismo::randomPoints(predictors, n=100)
colnames(background)=c('lon', 'lat')

pres.dataset &lt;- data.frame(extract(predictors, y=pres))
names(pres.dataset) &lt;- names(predictors)
pres.dataset$biome &lt;- as.factor(pres.dataset$biome)

Bradypus.bioclim &lt;- ensemble.bioclim.object(predictors, quantiles=T, 
    p=pres, factors="biome", species.name="Bradypus")
Bradypus.bioclim
# obtain the same results with a data.frame
Bradypus.bioclim2 &lt;- ensemble.bioclim.object(pres.dataset, quantiles=T, 
    species.name="Bradypus")
Bradypus.bioclim2
# obtain results for entire rasterStack
Bradypus.bioclim3 &lt;- ensemble.bioclim.object(predictors, p=NULL, quantiles=T, 
    factors="biome", species.name="America")
Bradypus.bioclim3

ensemble.bioclim(x=predictors, bioclim.object=Bradypus.bioclim)
ensemble.bioclim(x=predictors, bioclim.object=Bradypus.bioclim3)

par.old &lt;- graphics::par(no.readonly=T)
graphics::par(mfrow=c(1,2))

rasterfull1 &lt;- paste("ensembles//Bradypus_base_BIOCLIM_orig.tif", sep="")
raster::plot(raster(rasterfull1), breaks=c(-0.1, 0, 0.5, 1), 
    col=c("grey", "blue", "green"), main="original method")
rasterfull2 &lt;- paste("ensembles//America_base_BIOCLIM_orig.tif", sep="")
raster::plot(raster(rasterfull2), breaks=c(-0.1, 0, 0.5, 1), 
    col=c("grey", "blue", "green"), main="America")

graphics::par(par.old)

# compare with implementation bioclim in dismo
bioclim.dismo &lt;- bioclim(predictors, p=pres)
rasterfull2 &lt;- paste("ensembles//Bradypus_base_BIOCLIM_dismo.tif", sep="")
raster::predict(object=predictors, model=bioclim.dismo, na.rm=TRUE, 
    filename=rasterfull2, progress='text', overwrite=TRUE)

par.old &lt;- graphics::par(no.readonly=T)
graphics::par(mfrow=c(1,2))

raster::plot(raster(rasterfull1), breaks=c(-0.1, 0, 0.5, 1), 
    col=c("grey", "blue", "green"), main="original method")
raster::plot(raster(rasterfull2), main="dismo method")

graphics::par(par.old)

# use dummy variables to deal with factors
predictors &lt;- stack(predictor.files)
biome.layer &lt;- predictors[["biome"]]
biome.layer
ensemble.dummy.variables(xcat=biome.layer, most.frequent=0, freq.min=1,
    overwrite=TRUE)

predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
predictors.dummy &lt;- subset(predictors, subset=c("biome_1", "biome_2",  "biome_3",  
    "biome_4", "biome_5", "biome_7",  "biome_8",  "biome_9", "biome_10", 
    "biome_12", "biome_13", "biome_14"))
predictors.dummy
predictors.dummy@title &lt;- "base_dummy"

Bradypus.dummy &lt;- ensemble.bioclim.object(predictors.dummy, quantiles=T, 
    p=pres, species.name="Bradypus")
Bradypus.dummy
ensemble.bioclim(x=predictors.dummy, bioclim.object=Bradypus.dummy)

par.old &lt;- graphics::par(no.readonly=T)
graphics::par(mfrow=c(1,2))

rasterfull3 &lt;- paste("ensembles//Bradypus_base_dummy_BIOCLIM_orig.tif", sep="")
raster::plot(raster(rasterfull1), breaks=c(-0.1, 0, 0.5, 1), col=c("grey", "blue", "green"), 
    main="numeric predictors")
raster::plot(raster(rasterfull3), breaks=c(-0.1, 0, 0.5, 1), col=c("grey", "blue", "green"), 
    main="dummy predictors")

graphics::par(par.old)

## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.bioclim.graph'>Graphs of bioclimatic ranges of species and climates</h2><span id='topic+ensemble.bioclim.graph'></span><span id='topic+ensemble.bioclim.graph.data'></span>

<h3>Description</h3>

<p>The main graph function makes graphs that show mean, median, minimum, maximum and lower and upper limits for species or climates. The <code>ensemble.bioclim.graph.data</code> function creates input data, using <code><a href="#topic+ensemble.bioclim.object">ensemble.bioclim.object</a></code> internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.bioclim.graph(graph.data = NULL, focal.var = NULL, 
    species.climates.subset = NULL, cols = NULL,
    var.multiply = 1.0, ref.lines = TRUE)

ensemble.bioclim.graph.data(
    x=NULL, p=NULL, fraction = 0.9, 
    species.climate.name="Species001_base", factors = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.bioclim.graph_+3A_graph.data">graph.data</code></td>
<td>
<p> Input data with same variables as created by <code><a href="#topic+ensemble.bioclim.graph">ensemble.bioclim.graph</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_focal.var">focal.var</code></td>
<td>
<p> Bioclimatic variable to be plotted in the graph </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_species.climates.subset">species.climates.subset</code></td>
<td>
<p> Character vector with subset of names of species and climates to be plotted in the graph (if not provided, then all species and climates will be plotted).  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_cols">cols</code></td>
<td>
<p> colours for the different species and climates </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_var.multiply">var.multiply</code></td>
<td>
<p> multiplier for the values to be plotted; 0.1 should be used if the bioclimatic variable was multiplied by 10 in the raster layers as in WorldClim and AFRICLIM </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_ref.lines">ref.lines</code></td>
<td>
<p> If <code>TRUE</code>, then horizontal reference lines will be added for the minimum and maximum values of the species or climate plotted on the extreme left in the graph </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all environmental layers for which statistics should be calculated; see also <code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_p">p</code></td>
<td>
<p> presence points used for calibrating the suitability models, typically available in 2-column (lon, lat) dataframe; see also <code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_fraction">fraction</code></td>
<td>
<p> Fraction of range representing the optimal limits, default value of 0.9 as in the original BIOCLIM software; see also <code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_species.climate.name">species.climate.name</code></td>
<td>
<p> Name for the species or climate that will be used as label in the graph.  </p>
</td></tr>
<tr><td><code id="ensemble.bioclim.graph_+3A_factors">factors</code></td>
<td>
<p> vector that indicates which variables are factors; these variables will be ignored by the BIOCLIM algorithm; see also <code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>.   </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function creates a graph that shows mean, median, minimum, maximum and upper and lower limits for a range of species and climates. The graph can be useful in interpreting results of <code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code> or <code><a href="#topic+ensemble.novel">ensemble.novel</a></code>.
</p>
<p>In the graphs, means are indicated by an asterisk (<code>pch=8</code> and medians as larger circles (<code>pch=1</code>)).
</p>


<h3>Value</h3>

<p>function <code>ensemble.bioclim.graph.data</code> creates a data frame, function <code>ensemble.bioclim.graph</code> allows for plotting. 
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) </p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17", "biome"))
predictors
predictors@title &lt;- "base"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]

# climates for north and south (use same process for future climates)
ext2 &lt;- extent(-90, -32, 0, 23)
predictors2 &lt;- crop(predictors, y=ext2)
predictors2 &lt;- stack(predictors2)
predictors2@title &lt;- "north"

ext3 &lt;- extent(-90, -32, -33, 0)
predictors3 &lt;- crop(predictors, y=ext3)
predictors3 &lt;- stack(predictors3)
predictors3@title &lt;- "south"

graph.data1 &lt;- ensemble.bioclim.graph.data(predictors, p=pres, 
    factors="biome", species.climate.name="Bradypus")
graph.data2 &lt;- ensemble.bioclim.graph.data(predictors, p=NULL, 
    factors="biome", species.climate.name="baseline")
graph.data3 &lt;- ensemble.bioclim.graph.data(predictors2, p=NULL, 
    factors="biome", species.climate.name="north")
graph.data4 &lt;- ensemble.bioclim.graph.data(predictors3, p=NULL, 
    factors="biome", species.climate.name="south")
graph.data.all &lt;- rbind(graph.data1, graph.data2, graph.data3, graph.data4)

par.old &lt;- graphics::par(no.readonly=T)
graphics::par(mfrow=c(2, 2))

ensemble.bioclim.graph(graph.data.all, focal.var="bio5", 
    var.multiply=0.1, cols=c("black", rep("blue", 3)))
ensemble.bioclim.graph(graph.data.all, focal.var="bio6", 
    var.multiply=0.1, cols=c("black", rep("blue", 3)))
ensemble.bioclim.graph(graph.data.all, focal.var="bio16", 
    var.multiply=1.0, cols=c("black", rep("blue", 3)))
ensemble.bioclim.graph(graph.data.all, focal.var="bio17", 
    var.multiply=1.0, cols=c("black", rep("blue", 3)))

graphics::par(par.old)


## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.calibrate.models'>
Suitability mapping based on ensembles of modelling algorithms: calibration of models and weights
</h2><span id='topic+ensemble.calibrate.models'></span><span id='topic+ensemble.calibrate.weights'></span><span id='topic+ensemble.calibrate.models.gbm'></span><span id='topic+ensemble.calibrate.models.nnet'></span><span id='topic+ensemble.drop1'></span><span id='topic+ensemble.formulae'></span><span id='topic+ensemble.weights'></span><span id='topic+ensemble.strategy'></span><span id='topic+ensemble.threshold'></span><span id='topic+ensemble.VIF'></span><span id='topic+ensemble.VIF.dataframe'></span><span id='topic+ensemble.pairs'></span>

<h3>Description</h3>

<p>The basic function <code>ensemble.calibrate.models</code> allows to evaluate different algorithms for (species) suitability modelling, including maximum entropy (MAXENT), boosted regression trees, random forests, generalized linear models (including stepwise selection of explanatory variables), generalized additive models (including stepwise selection of explanatory variables), multivariate adaptive regression splines, regression trees, artificial neural networks, flexible discriminant analysis, support vector machines, the BIOCLIM algorithm, the DOMAIN algorithm and the Mahalanobis algorithm. These sets of functions were developed in parallel with the <code>biomod2</code> package, especially for inclusion of the maximum entropy algorithm, but also to allow for a more direct integration with the BiodiversityR package, more direct handling of model formulae and greater focus on mapping. Researchers and students of species distribution are strongly encouraged to familiarize themselves with all the options of the BIOMOD and dismo packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.calibrate.models(x = NULL, p = NULL, 
    a = NULL, an = 1000, excludep = FALSE, target.groups = FALSE,
    k = 0, pt = NULL, at = NULL, SSB.reduce = FALSE, CIRCLES.d = 250000, 
    TrainData = NULL, TestData = NULL, 
    VIF = FALSE, COR = FALSE,
    SINK = FALSE, PLOTS = FALSE, CATCH.OFF = FALSE, 
    threshold.method = "spec_sens", threshold.sensitivity = 0.9, 
    threshold.PresenceAbsence = FALSE,
    evaluations.keep = FALSE, 
    models.list = NULL, models.keep = FALSE, 
    models.save = FALSE, species.name = "Species001",
    ENSEMBLE.tune = FALSE, 
    ENSEMBLE.best = 0, ENSEMBLE.min = 0.7, ENSEMBLE.exponent = 1, 
    ENSEMBLE.weight.min = 0.05,
    input.weights = NULL, 
    MAXENT = 1, MAXNET = 1, MAXLIKE = 1, GBM = 1, GBMSTEP = 1, RF = 1, CF = 1,
    GLM = 1, GLMSTEP = 1, GAM = 1, GAMSTEP = 1, MGCV = 1, MGCVFIX = 0, 
    EARTH = 1, RPART = 1, NNET = 1, FDA = 1, SVM = 1 , SVME = 1, GLMNET = 1,
    BIOCLIM.O = 0, BIOCLIM = 1, DOMAIN = 1, MAHAL = 1, MAHAL01 = 1,
    PROBIT = FALSE,
    Yweights = "BIOMOD", 
    layer.drops = NULL, factors = NULL, dummy.vars = NULL,
    formulae.defaults = TRUE, maxit = 100,
    MAXENT.a = NULL, MAXENT.an = 10000, 
    MAXENT.path = paste(getwd(), "/models/maxent_", species.name,  sep=""), 
    MAXNET.classes = "default", MAXNET.clamp = FALSE, MAXNET.type = "cloglog",
    MAXLIKE.formula = NULL, MAXLIKE.method = "BFGS",
    GBM.formula = NULL, GBM.n.trees = 2001, 
    GBMSTEP.gbm.x = 2:(ncol(TrainData.orig)), GBMSTEP.tree.complexity = 5, 
    GBMSTEP.learning.rate = 0.005, GBMSTEP.bag.fraction = 0.5, 
    GBMSTEP.step.size = 100, 
    RF.formula = NULL, RF.ntree = 751, RF.mtry = floor(sqrt(ncol(TrainData.vars))), 
    CF.formula = NULL, CF.ntree = 751, CF.mtry = floor(sqrt(ncol(TrainData.vars))),
    GLM.formula = NULL, GLM.family = binomial(link = "logit"), 
    GLMSTEP.steps = 1000, STEP.formula = NULL, GLMSTEP.scope = NULL, 
    GLMSTEP.k = 2, 
    GAM.formula = NULL, GAM.family = binomial(link = "logit"), 
    GAMSTEP.steps = 1000, GAMSTEP.scope = NULL, GAMSTEP.pos = 1, 
    MGCV.formula = NULL, MGCV.select = FALSE, 
    MGCVFIX.formula = NULL, 
    EARTH.formula = NULL, 
    EARTH.glm = list(family = binomial(link = "logit"), maxit = maxit), 
    RPART.formula = NULL, RPART.xval = 50, 
    NNET.formula = NULL, NNET.size = 8, NNET.decay = 0.01, 
    FDA.formula = NULL, 
    SVM.formula = NULL, 
    SVME.formula = NULL, 
    GLMNET.nlambda = 100, GLMNET.class = FALSE,
    BIOCLIM.O.fraction = 0.9,
    MAHAL.shape = 1)

ensemble.calibrate.weights(x = NULL, p = NULL, TrainTestData=NULL,
    a = NULL, an = 1000, 
    get.block = FALSE, block.default = TRUE, get.subblocks = FALSE,
    SSB.reduce = FALSE, CIRCLES.d = 100000, 
    excludep = FALSE, target.groups = FALSE,
    k = 4, 
    VIF = FALSE, COR = FALSE,
    SINK = FALSE, PLOTS = FALSE, CATCH.OFF = FALSE, 
    data.keep = FALSE,
    species.name = "Species001",
    threshold.method = "spec_sens", threshold.sensitivity = 0.9, 
    threshold.PresenceAbsence = FALSE,
    ENSEMBLE.tune = FALSE, 
    ENSEMBLE.best = 0, ENSEMBLE.min = 0.7, ENSEMBLE.exponent = 1,
    ENSEMBLE.weight.min = 0.05,
    input.weights = NULL,
    MAXENT = 1, MAXNET = 1, MAXLIKE = 1, GBM = 1, GBMSTEP = 1, RF = 1, CF = 1, 
    GLM = 1, GLMSTEP = 1, GAM = 1, GAMSTEP = 1, MGCV = 1, MGCVFIX = 0, 
    EARTH = 1, RPART = 1, NNET = 1, FDA = 1, SVM = 1 , SVME = 1, GLMNET = 1,
    BIOCLIM.O = 0, BIOCLIM = 1, DOMAIN = 1, MAHAL = 1, MAHAL01 = 1,
    PROBIT = FALSE,
    Yweights = "BIOMOD", 
    layer.drops = NULL, factors = NULL, dummy.vars = NULL,
    formulae.defaults = TRUE, maxit = 100,
    MAXENT.a = NULL, MAXENT.an = 10000, 
    MAXENT.path = paste(getwd(), "/models/maxent_", species.name,  sep=""), 
    MAXNET.classes = "default", MAXNET.clamp = FALSE, MAXNET.type = "cloglog",
    MAXLIKE.formula = NULL, MAXLIKE.method = "BFGS",
    GBM.formula = NULL, GBM.n.trees = 2001, 
    GBMSTEP.gbm.x = 2:(length(var.names)+1), GBMSTEP.tree.complexity = 5, 
    GBMSTEP.learning.rate = 0.005, 
    GBMSTEP.bag.fraction = 0.5, GBMSTEP.step.size = 100, 
    RF.formula = NULL, RF.ntree = 751, RF.mtry = floor(sqrt(length(var.names))), 
    CF.formula = NULL, CF.ntree = 751, CF.mtry = floor(sqrt(length(var.names))),
    GLM.formula = NULL, GLM.family = binomial(link = "logit"), 
    GLMSTEP.steps = 1000, STEP.formula = NULL, GLMSTEP.scope = NULL, GLMSTEP.k = 2, 
    GAM.formula = NULL, GAM.family = binomial(link = "logit"), 
    GAMSTEP.steps = 1000, GAMSTEP.scope = NULL, GAMSTEP.pos = 1, 
    MGCV.formula = NULL, MGCV.select = FALSE, 
    MGCVFIX.formula = NULL, 
    EARTH.formula = NULL, 
    EARTH.glm = list(family = binomial(link = "logit"), maxit = maxit), 
    RPART.formula = NULL, RPART.xval = 50, 
    NNET.formula = NULL, NNET.size = 8, NNET.decay = 0.01, 
    FDA.formula = NULL, 
    SVM.formula = NULL, 
    SVME.formula = NULL, 
    GLMNET.nlambda = 100, GLMNET.class = FALSE,
    BIOCLIM.O.fraction = 0.9,
    MAHAL.shape = 1)

ensemble.calibrate.models.gbm(x = NULL, p = NULL, a = NULL, an = 1000, excludep = FALSE, 
    k = 4, 
    TrainData = NULL,
    VIF = FALSE, COR = FALSE,
    SINK = FALSE, PLOTS = FALSE, 
    species.name = "Species001",
    Yweights = "BIOMOD", 
    layer.drops = NULL, factors = NULL, 
    GBMSTEP.gbm.x = 2:(ncol(TrainData.orig)), 
    complexity = c(3:6), learning = c(0.005, 0.002, 0.001), 
    GBMSTEP.bag.fraction = 0.5, GBMSTEP.step.size = 100)

ensemble.calibrate.models.nnet(x = NULL, p = NULL, a = NULL, an = 1000, excludep = FALSE, 
    k = 4, 
    TrainData = NULL,
    VIF = FALSE, COR = FALSE,
    SINK = FALSE, PLOTS = FALSE, 
    species.name = "Species001",
    Yweights = "BIOMOD", 
    layer.drops = NULL, factors = NULL, 
    formulae.defaults = TRUE, maxit = 100, 
    NNET.formula = NULL, 
    sizes = c(2, 4, 6, 8), decays = c(0.1, 0.05, 0.01, 0.001) )

ensemble.drop1(x = NULL, p = NULL, 
    a = NULL, an = 1000, excludep = FALSE, target.groups = FALSE,
    k = 0, pt = NULL, at = NULL, SSB.reduce = FALSE, CIRCLES.d = 100000, 
    TrainData = NULL, TestData = NULL,
    VIF = FALSE, COR = FALSE,
    SINK = FALSE, 
    species.name = "Species001",
    difference = FALSE, variables.alone = FALSE,
    ENSEMBLE.tune = FALSE,
    ENSEMBLE.best = 0, ENSEMBLE.min = 0.7, ENSEMBLE.exponent = 1,
    input.weights = NULL, 
    MAXENT = 1, MAXNET = 1, MAXLIKE = 1, GBM = 1, GBMSTEP = 0, RF = 1, CF = 1, 
    GLM = 1, GLMSTEP = 1, GAM = 1, GAMSTEP = 1, MGCV = 1, MGCVFIX = 0, 
    EARTH = 1, RPART = 1, NNET = 1, FDA = 1, SVM = 1, SVME = 1, GLMNET = 1,
    BIOCLIM.O = 0, BIOCLIM = 1, DOMAIN = 1, MAHAL = 1, MAHAL01 = 1,
    PROBIT = FALSE,
    Yweights = "BIOMOD", 
    layer.drops = NULL, factors = NULL, dummy.vars = NULL, 
    maxit = 100,
    MAXENT.a = NULL, MAXENT.an = 10000, 
    MAXENT.path = paste(getwd(), "/models/maxent_", species.name,  sep=""), 
    MAXNET.classes = "default", MAXNET.clamp = FALSE, MAXNET.type = "cloglog",
    MAXLIKE.method = "BFGS",
    GBM.n.trees = 2001, 
    GBMSTEP.tree.complexity = 5, GBMSTEP.learning.rate = 0.005, 
    GBMSTEP.bag.fraction = 0.5, GBMSTEP.step.size = 100, 
    RF.ntree = 751, 
    CF.ntree = 751,
    GLM.family = binomial(link = "logit"), 
    GLMSTEP.steps = 1000, GLMSTEP.scope = NULL, GLMSTEP.k = 2, 
    GAM.family = binomial(link = "logit"), 
    GAMSTEP.steps = 1000, GAMSTEP.scope = NULL, GAMSTEP.pos = 1, 
    MGCV.select = FALSE, 
    EARTH.glm = list(family = binomial(link = "logit"), maxit = maxit), 
    RPART.xval = 50, 
    NNET.size = 8, NNET.decay = 0.01, 
    GLMNET.nlambda = 100, GLMNET.class = FALSE,
    BIOCLIM.O.fraction = 0.9,
    MAHAL.shape = 1)

ensemble.weights(weights = c(0.9, 0.8, 0.7, 0.5), 
    best = 0, min.weight = 0, 
    exponent = 1, digits = 6)

ensemble.strategy(TrainData = NULL, TestData = NULL, 
    verbose = FALSE,
    ENSEMBLE.best = c(4:10), ENSEMBLE.min = c(0.7),
    ENSEMBLE.exponent = c(1, 2, 3) )

ensemble.formulae(x, 
    layer.drops = NULL, factors = NULL, dummy.vars = NULL, weights = NULL)

ensemble.threshold(eval, threshold.method = "spec_sens", threshold.sensitivity = 0.9, 
    threshold.PresenceAbsence = FALSE, Pres, Abs) 

ensemble.VIF(x = NULL, a = NULL, an = 10000, 
    VIF.max = 10, keep = NULL,
    layer.drops = NULL, factors = NULL, dummy.vars = NULL)

ensemble.VIF.dataframe(x=NULL, 
    VIF.max=10, keep=NULL,
    car=TRUE, silent=F)

ensemble.pairs(x = NULL, a = NULL, an = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.calibrate.models_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all layers that correspond to explanatory variables  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_p">p</code></td>
<td>
<p> presence points used for calibrating the suitability models, typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_a">a</code></td>
<td>
<p> background points used for calibrating the suitability models (except for <code><a href="dismo.html#topic+maxent">maxent</a></code>), typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_an">an</code></td>
<td>
<p> number of background points for calibration to be selected with <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> in case argument <code>a</code> is missing</p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_excludep">excludep</code></td>
<td>
<p> parameter that indicates (if <code>TRUE</code>) that presence points will be excluded from the background points; see also <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_target.groups">target.groups</code></td>
<td>
<p> Parameter that indicates (if <code>TRUE</code>) that the provided background points (argument <code>a</code>) represent presence points from a target group sensu Phillips et al. 2009 (these are species that are all collected or observed using the same methods or equipment). Setting the parameter to <code>TRUE</code> results in selecting the centres of cells of the target groups as background points, while avoiding to select the same cells twice. Via argument <code>excludep</code>, it is possible to filter out cells with presence observations (argument <code>p</code>).  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_k">k</code></td>
<td>
<p> If larger than 1, the number of groups to split between calibration (k-1) and evaluation (1) data sets (for example, <code>k = 4</code> results in 3/4 of presence and background points to be used for calibrating the models, and 1/4 of presence and background points to be used for evaluating the models). For <code>ensemble.calibrate.weights</code>, <code>ensemble.calibrate.models.gbm</code> and <code>ensemble.calibrate.models.nnet</code>, this procedure is repeated <code>k</code> times (k-fold cross-validation). See also <code><a href="dismo.html#topic+kfold">kfold</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_pt">pt</code></td>
<td>
<p> presence points used for evaluating the suitability models, available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_at">at</code></td>
<td>
<p> background points used for evaluating the suitability models, available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_ssb.reduce">SSB.reduce</code></td>
<td>
<p> If <code>TRUE</code>, then new background points that will be used for evaluationg the suitability models will be selected (<code><a href="dismo.html#topic+randomPoints">randomPoints</a></code>) in circular neighbourhoods (created with <code><a href="dismo.html#topic+circles">circles</a></code>) around presence locations (p and pt). The abbreviation of SSB refers to spatial sorting bias; see also <code><a href="dismo.html#topic+ssb">ssb</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_circles.d">CIRCLES.d</code></td>
<td>
<p> Radius in m of circular neighbourhoods (created with <code><a href="dismo.html#topic+circles">circles</a></code>) around presence locations (p and pt).  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_traindata">TrainData</code></td>
<td>
<p> dataframe with first column 'pb' describing presence (1) and absence (0) and other columns containing explanatory variables; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>. In case that this dataframe is provided, then locations p and a are not used. For the maximum entropy model (<code><a href="dismo.html#topic+maxent">maxent</a></code>), a different dataframe is used for calibration; see parameter <code>MAXENT.TrainData</code>. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_testdata">TestData</code></td>
<td>
<p> dataframe with first column 'pb' describing presence (1) and absence (0) and other columns containing explanatory variables; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>. In case that this dataframe is provided, then locations pt and at are not used. For <code>ensemble.strategy</code>, this dataframe should be a dataframe that contains predictions for various models - such dataframe can be provided by the <code>ensemble.calibrate.models</code> or <code><a href="#topic+ensemble.raster">ensemble.raster</a></code> functions.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_vif">VIF</code></td>
<td>
<p> Estimate the variance inflation factors based on a linear model calibrated on the training data  (if <code>TRUE</code>). Only background locations will be used and the response variable 'pb' will be replaced by a random variable. See also <code><a href="car.html#topic+vif">vif</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_cor">COR</code></td>
<td>
<p> Provide information on the correlation between the numeric explanatory variables  (if <code>TRUE</code>). See also <code><a href="stats.html#topic+cor">cor</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_sink">SINK</code></td>
<td>
<p> Append the results to a text file in subfolder 'outputs' (if <code>TRUE</code>). The name of file is based on argument <code>species.name</code>. In case the file already exists, then results are appended. See also <code><a href="base.html#topic+sink">sink</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_plots">PLOTS</code></td>
<td>
<p> Disabled option of plotting evaluation results(BiodiversityR version 2.9-1) - see examples how to plot results afterwards and also <code><a href="dismo.html#topic+evaluate">evaluate</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_threshold.method">threshold.method</code></td>
<td>
<p> Method to calculate the threshold between predicted absence and presence; possibilities include <code>spec_sens</code> (highest sum of the true positive rate and the true negative rate), <code>kappa</code> (highest kappa value), <code>no_omission</code> (highest threshold that corresponds to no omission), <code>prevalence</code> (modeled prevalence is closest to observed prevalence) and <code>equal_sens_spec</code> (equal true positive rate and true negative rate). See <code><a href="dismo.html#topic+threshold">threshold</a></code>. Options specific to the BiodiversityR implementation are: <code>threshold2005.mean</code>, <code>threshold2005.min</code>, <code>threshold2013.mean</code> and <code>threshold2013.min</code> (resulting in calculating the mean or minimum value of recommended threshold values by studies published in 2005 and 2013; see details below).   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_threshold.sensitivity">threshold.sensitivity</code></td>
<td>
<p> Sensitivity value for <code>threshold.method = 'sensitivity'</code>. See <code><a href="dismo.html#topic+threshold">threshold</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_threshold.presenceabsence">threshold.PresenceAbsence</code></td>
<td>
<p> If <code>TRUE</code> calculate thresholds with the PresenceAbsence package. See <code><a href="PresenceAbsence.html#topic+optimal.thresholds">optimal.thresholds</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_evaluations.keep">evaluations.keep</code></td>
<td>
<p> Keep the results of evaluations (if <code>TRUE</code>). See also <code><a href="dismo.html#topic+evaluate">evaluate</a></code>. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_models.list">models.list</code></td>
<td>
<p> list with 'old' model objects such as <code>MAXENT</code> or <code>RF</code>. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_models.keep">models.keep</code></td>
<td>
<p> store the details for each suitability modelling algorithm (if <code>TRUE</code>). (This may be particularly useful when projecting to different possible future climates.)  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_models.save">models.save</code></td>
<td>
<p> Save the list with model details to a file (if <code>TRUE</code>). The filename will be <code>species.name</code> with extension <code>.models</code>; this file will be saved in subfolder of <code>models</code>. When loading this file, model results will be available as <code>ensemble.models</code>. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_species.name">species.name</code></td>
<td>
<p> Name by which the model details will be saved to a file; see also argument <code>models.save</code> </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_data.keep">data.keep</code></td>
<td>
<p> Keep the data for each k-fold cross-validation run (if <code>TRUE</code>). </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_ensemble.tune">ENSEMBLE.tune</code></td>
<td>
<p> Determine weights for the ensemble model based on AUC values (if <code>TRUE</code>). See details. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_ensemble.best">ENSEMBLE.best</code></td>
<td>
<p> The number of individual suitability models to be used in the consensus suitability map (based on a weighted average). In case this parameter is smaller than 1 or larger than the number of positive input weights of individual models, then all individual suitability models with positive input weights are included in the consensus suitability map. In case a vector is provided, <code>ensemble.strategy</code> is called internally to determine weights for the ensemble model. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_ensemble.min">ENSEMBLE.min</code></td>
<td>
<p> The minimum input weight (typically corresponding to AUC values) for a model to be included in the ensemble. In case a vector is provided, function <code>ensemble.strategy</code> is called internally to determine weights for the ensemble model.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_ensemble.exponent">ENSEMBLE.exponent</code></td>
<td>
<p> Exponent applied to AUC values to convert AUC values into weights (for example, an exponent of 2 converts input weights of 0.7, 0.8 and 0.9 into 0.7^2=0.49, 0.8^2=0.64 and 0.9^2=0.81). See details. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_ensemble.weight.min">ENSEMBLE.weight.min</code></td>
<td>
<p> The minimum output weight for models included in the ensemble, applying to weights that sum to one. Note that <code>ENSEMBLE.min</code> typically refers to input AUC values.   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_input.weights">input.weights</code></td>
<td>
<p> array with numeric values for the different modelling algorithms; if <code>NULL</code> then values provided by parameters such as <code>MAXENT</code> and <code>GBM</code> will be used. As an alternative, the output from <code>ensemble.calibrate.weights</code> can be used. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxent">MAXENT</code></td>
<td>
<p> number: if larger than 0, then a maximum entropy model (<code><a href="dismo.html#topic+maxent">maxent</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxnet">MAXNET</code></td>
<td>
<p> number: if larger than 0, then a maximum entropy model (<code><a href="maxnet.html#topic+maxnet">maxnet</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxlike">MAXLIKE</code></td>
<td>
<p> number: if larger than 0, then a maxlike model (<code><a href="maxlike.html#topic+maxlike">maxlike</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbm">GBM</code></td>
<td>
<p> number: if larger than 0, then a boosted regression trees model (<code><a href="gbm.html#topic+gbm">gbm</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbmstep">GBMSTEP</code></td>
<td>
<p> number: if larger than 0, then a stepwise boosted regression trees model (<code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_rf">RF</code></td>
<td>
<p> number: if larger than 0, then a random forest model (<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_cf">CF</code></td>
<td>
<p> number: if larger than 0, then a random forest model (<code><a href="party.html#topic+cforest">cforest</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glm">GLM</code></td>
<td>
<p> number: if larger than 0, then a generalized linear model (<code><a href="stats.html#topic+glm">glm</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glmstep">GLMSTEP</code></td>
<td>
<p> number: if larger than 0, then a stepwise generalized linear model (<code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gam">GAM</code></td>
<td>
<p> number: if larger than 0, then a generalized additive model (<code><a href="gam.html#topic+gam">gam</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gamstep">GAMSTEP</code></td>
<td>
<p> number: if larger than 0, then a stepwise generalized additive model (<code><a href="gam.html#topic+step.gam">step.gam</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_mgcv">MGCV</code></td>
<td>
<p> number: if larger than 0, then a generalized additive model (<code><a href="mgcv.html#topic+gam">gam</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_mgcvfix">MGCVFIX</code></td>
<td>
<p> number: if larger than 0, then a generalized additive model with fixed d.f. regression splines (<code><a href="mgcv.html#topic+gam">gam</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_earth">EARTH</code></td>
<td>
<p> number: if larger than 0, then a multivariate adaptive regression spline model (<code><a href="earth.html#topic+earth">earth</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_rpart">RPART</code></td>
<td>
<p> number: if larger than 0, then a recursive partioning and regression tree model (<code><a href="rpart.html#topic+rpart">rpart</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_nnet">NNET</code></td>
<td>
<p> number: if larger than 0, then an artificial neural network model (<code><a href="nnet.html#topic+nnet">nnet</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_fda">FDA</code></td>
<td>
<p> number: if larger than 0, then a flexible discriminant analysis model (<code><a href="mda.html#topic+fda">fda</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_svm">SVM</code></td>
<td>
<p> number: if larger than 0, then a support vector machine model (<code><a href="kernlab.html#topic+ksvm">ksvm</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_svme">SVME</code></td>
<td>
<p> number: if larger than 0, then a support vector machine model (<code><a href="e1071.html#topic+svm">svm</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glmnet">GLMNET</code></td>
<td>
<p> number: if larger than 0, then a GLM with lasso or elasticnet regularization (<code><a href="glmnet.html#topic+glmnet">glmnet</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_bioclim.o">BIOCLIM.O</code></td>
<td>
<p> number: if larger than 0, then the original BIOCLIM algorithm (<code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_bioclim">BIOCLIM</code></td>
<td>
<p> number: if larger than 0, then the BIOCLIM algorithm (<code><a href="dismo.html#topic+bioclim">bioclim</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_domain">DOMAIN</code></td>
<td>
<p> number: if larger than 0, then the DOMAIN algorithm (<code><a href="dismo.html#topic+domain">domain</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_mahal">MAHAL</code></td>
<td>
<p> number: if larger than 0, then the Mahalanobis algorithm (<code><a href="dismo.html#topic+mahal">mahal</a></code>) will be fitted among ensemble </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_mahal01">MAHAL01</code></td>
<td>
<p> number: if larger than 0, then the Mahalanobis algorithm (<code><a href="dismo.html#topic+mahal">mahal</a></code>) will be fitted among ensemble, using a transformation method afterwards whereby output is within the range between 0 and 1 (see details) </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_probit">PROBIT</code></td>
<td>
<p> If <code>TRUE</code>, then subsequently to the fitting of the individual algorithm (e.g. maximum entropy or GAM) a generalized linear model (<code><a href="stats.html#topic+glm">glm</a></code>) with probit link <code>family=binomial(link="probit")</code> will be fitted to transform the predictions, using the previous predictions as explanatory variable. This transformation results in all model predictions to be probability estimates.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_yweights">Yweights</code></td>
<td>
<p> chooses how cases of presence and background (absence) are weighted; <code>"BIOMOD"</code> results in equal weighting of all presence and all background cases, <code>"equal"</code> results in equal weighting of all cases. The user can supply a vector of weights similar to the number of cases in the calibration data set. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_layer.drops">layer.drops</code></td>
<td>
<p> vector that indicates which layers should be removed from RasterStack <code>x</code>. This argument is especially useful for the <code>ensemble.drop1</code> function. See also <code><a href="raster.html#topic+addLayer">addLayer</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_factors">factors</code></td>
<td>
<p> vector that indicates which variables are factors; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_dummy.vars">dummy.vars</code></td>
<td>
<p> vector that indicates which variables are dummy variables (influences formulae suggestions) </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_formulae.defaults">formulae.defaults</code></td>
<td>
<p> Suggest formulae for most of the models (if <code>TRUE</code>). See also <code><a href="#topic+ensemble.formulae">ensemble.formulae</a></code>.   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxit">maxit</code></td>
<td>
<p> Maximum number of iterations for some of the models. See also <code><a href="stats.html#topic+glm.control">glm.control</a></code>, <code><a href="gam.html#topic+gam.control">gam.control</a></code>, <code><a href="mgcv.html#topic+gam.control">gam.control</a></code> and <code><a href="nnet.html#topic+nnet">nnet</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxent.a">MAXENT.a</code></td>
<td>
<p> background points used for calibrating the maximum entropy model (<code><a href="dismo.html#topic+maxent">maxent</a></code>), typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxent.an">MAXENT.an</code></td>
<td>
<p> number of background points for calibration to be selected with <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> in case argument <code>MAXENT.a</code> is missing</p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxent.path">MAXENT.path</code></td>
<td>
<p> path to the directory where output files of the maximum entropy model are stored; see also <code><a href="dismo.html#topic+maxent">maxent</a></code>   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxnet.classes">MAXNET.classes</code></td>
<td>
<p> continuous feature classes, either &quot;default&quot; or any subset of &quot;lqpht&quot; (linear, quadratic, product, hinge, threshold). Note that the &quot;default&quot; option chooses feature classes based on the number of presence locations as &quot;l&quot; (&lt; 10 locations), &quot;lq&quot; (10 - 14 locations), &quot;lqh&quot; (15 - 79 locations) or &quot;lqph&quot; (&gt; 79 locations). See also <code><a href="maxnet.html#topic+maxnet">maxnet</a></code>.   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxnet.clamp">MAXNET.clamp</code></td>
<td>
<p> restrict predictors and features to the range seen during model training; see also <code><a href="maxnet.html#topic+predict.maxnet">predict.maxnet</a></code>   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxnet.type">MAXNET.type</code></td>
<td>
<p> type of response required; see also <code><a href="maxnet.html#topic+predict.maxnet">predict.maxnet</a></code>   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxlike.formula">MAXLIKE.formula</code></td>
<td>
<p> formula for the maxlike algorithm; see also <code><a href="maxlike.html#topic+maxlike">maxlike</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_maxlike.method">MAXLIKE.method</code></td>
<td>
<p> method for the maxlike algorithm; see also <code><a href="stats.html#topic+optim">optim</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbm.formula">GBM.formula</code></td>
<td>
<p> formula for the boosted regression trees algorithm; see also <code><a href="gbm.html#topic+gbm">gbm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbm.n.trees">GBM.n.trees</code></td>
<td>
<p> total number of trees to fit for the boosted regression trees model; see also <code><a href="gbm.html#topic+gbm">gbm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbmstep.gbm.x">GBMSTEP.gbm.x</code></td>
<td>
<p> indices of column numbers with explanatory variables for stepwise boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbmstep.tree.complexity">GBMSTEP.tree.complexity</code></td>
<td>
<p> complexity of individual trees for stepwise boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbmstep.learning.rate">GBMSTEP.learning.rate</code></td>
<td>
<p> weight applied to individual trees for stepwise boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code> </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbmstep.bag.fraction">GBMSTEP.bag.fraction</code></td>
<td>
<p> proportion of observations used in selecting variables for stepwise boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gbmstep.step.size">GBMSTEP.step.size</code></td>
<td>
<p> number of trees to add at each cycle for stepwise boosted regression trees (should be small enough to result in a smaller holdout deviance than the initial number of trees [50]); see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_rf.formula">RF.formula</code></td>
<td>
<p> formula for random forest algorithm; see also <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_rf.ntree">RF.ntree</code></td>
<td>
<p> number of trees to grow for random forest algorithm; see also <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_rf.mtry">RF.mtry</code></td>
<td>
<p> number of variables randomly sampled as candidates at each split for random forest algorithm; see also <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_cf.formula">CF.formula</code></td>
<td>
<p> formula for random forest algorithm; see also <code><a href="party.html#topic+cforest">cforest</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_cf.ntree">CF.ntree</code></td>
<td>
<p> number of trees to grow in a forest; see also <code><a href="party.html#topic+cforest_control">cforest_control</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_cf.mtry">CF.mtry</code></td>
<td>
<p> number of input variables randomly sampled as candidates at each node for random forest like algorithms; see also <code><a href="party.html#topic+cforest_control">cforest_control</a></code>   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glm.formula">GLM.formula</code></td>
<td>
<p> formula for the generalized linear model; see also <code><a href="stats.html#topic+glm">glm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glm.family">GLM.family</code></td>
<td>
<p> description of the error distribution and link function for the generalized linear model; see also <code><a href="stats.html#topic+glm">glm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glmstep.steps">GLMSTEP.steps</code></td>
<td>
<p> maximum number of steps to be considered for stepwise generalized linear model; see also <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_step.formula">STEP.formula</code></td>
<td>
<p> formula for the &quot;starting model&quot; to be considered for stepwise generalized linear model; see also <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glmstep.scope">GLMSTEP.scope</code></td>
<td>
<p> range of models examined in the stepwise search; see also <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glmstep.k">GLMSTEP.k</code></td>
<td>
<p> multiple of the number of degrees of freedom used for the penalty (only k = 2 gives the genuine AIC); see also <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gam.formula">GAM.formula</code></td>
<td>
<p> formula for the generalized additive model; see also <code><a href="gam.html#topic+gam">gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gam.family">GAM.family</code></td>
<td>
<p> description of the error distribution and link function for the generalized additive model; see also <code><a href="gam.html#topic+gam">gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gamstep.steps">GAMSTEP.steps</code></td>
<td>
<p> maximum number of steps to be considered in the stepwise generalized additive model; see also <code><a href="gam.html#topic+step.gam">step.gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gamstep.scope">GAMSTEP.scope</code></td>
<td>
<p> range of models examined in the step-wise search n the stepwise generalized additive model; see also <code><a href="gam.html#topic+step.gam">step.gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_gamstep.pos">GAMSTEP.pos</code></td>
<td>
<p> parameter expected to be set to 1 to allow for fitting of the stepwise generalized additive model  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_mgcv.formula">MGCV.formula</code></td>
<td>
<p> formula for the generalized additive model; see also <code><a href="mgcv.html#topic+gam">gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_mgcv.select">MGCV.select</code></td>
<td>
<p> if <code>TRUE</code>, then the smoothing parameter estimation that is part of fitting can completely remove terms from the model; see also <code><a href="mgcv.html#topic+gam">gam</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_mgcvfix.formula">MGCVFIX.formula</code></td>
<td>
<p> formula for the generalized additive model with fixed d.f. regression splines; see also <code><a href="mgcv.html#topic+gam">gam</a></code> (the default formulae sets &quot;s(..., fx = TRUE, ...)&quot;; see also <code><a href="mgcv.html#topic+s">s</a></code>) </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_earth.formula">EARTH.formula</code></td>
<td>
<p> formula for the multivariate adaptive regression spline model; see also <code><a href="earth.html#topic+earth">earth</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_earth.glm">EARTH.glm</code></td>
<td>
<p> list of arguments to pass on to <code><a href="stats.html#topic+glm">glm</a></code>; see also <code><a href="earth.html#topic+earth">earth</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_rpart.formula">RPART.formula</code></td>
<td>
<p> formula for the recursive partioning and regression tree model; see also <code><a href="rpart.html#topic+rpart">rpart</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_rpart.xval">RPART.xval</code></td>
<td>
<p> number of cross-validations for the recursive partioning and regression tree model; see also <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_nnet.formula">NNET.formula</code></td>
<td>
<p> formula for the artificial neural network model; see also <code><a href="nnet.html#topic+nnet">nnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_nnet.size">NNET.size</code></td>
<td>
<p> number of units in the hidden layer for the artificial neural network model; see also <code><a href="nnet.html#topic+nnet">nnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_nnet.decay">NNET.decay</code></td>
<td>
<p> parameter of weight decay for the artificial neural network model; see also <code><a href="nnet.html#topic+nnet">nnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_fda.formula">FDA.formula</code></td>
<td>
<p> formula for the flexible discriminant analysis model; see also <code><a href="mda.html#topic+fda">fda</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_svm.formula">SVM.formula</code></td>
<td>
<p> formula for the support vector machine model; see also <code><a href="kernlab.html#topic+ksvm">ksvm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_svme.formula">SVME.formula</code></td>
<td>
<p> formula for the support vector machine model; see also <code><a href="e1071.html#topic+svm">svm</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glmnet.nlambda">GLMNET.nlambda</code></td>
<td>
<p> The number of <code>lambda</code> values; see also <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_glmnet.class">GLMNET.class</code></td>
<td>
<p> Use the predicted class to calculate the mean predictions of GLMNET; see <code><a href="glmnet.html#topic+predict.glmnet">predict.glmnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_bioclim.o.fraction">BIOCLIM.O.fraction</code></td>
<td>
<p> Fraction of range representing the optimal limits, default value of 0.9 as in the original BIOCLIM software (<code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code>).  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_mahal.shape">MAHAL.shape</code></td>
<td>
<p> parameter that influences the transformation of output values of <code><a href="dismo.html#topic+mahal">mahal</a></code>. See details section.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_traintestdata">TrainTestData</code></td>
<td>
<p> dataframe with first column 'pb' describing presence (1) and absence (0) and other columns containing explanatory variables; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>. In case that this dataframe is provided, then locations p and a are not used. This data set will also be used for the maximum entropy and maximum likelihood models. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_get.block">get.block</code></td>
<td>
<p> if <code>TRUE</code>, instead of creating k-fold cross-validation subsets randomly (<code><a href="dismo.html#topic+kfold">kfold</a></code>), create 4 subsets of presence and background locations with <code><a href="ENMeval.html#topic+get.block">get.block</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_block.default">block.default</code></td>
<td>
<p> if <code>FALSE</code>, instead of making the first division of presence point locations along the y-coordinates (latitude) as in <code><a href="ENMeval.html#topic+get.block">get.block</a></code>, make the first division along the x-coordinates (longitude).  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_get.subblocks">get.subblocks</code></td>
<td>
<p> if <code>TRUE</code>, then 4 subsets of presence and background locations are generated in a checkerboard configuration by applying <code><a href="ENMeval.html#topic+get.block">get.block</a></code> to each of the 4 blocks generated by <code><a href="ENMeval.html#topic+get.block">get.block</a></code> in a first step. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_complexity">complexity</code></td>
<td>
<p> vector with values of complexity of individual trees (<code>tree.complexity</code>) for boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_learning">learning</code></td>
<td>
<p> vector with values of weights applied to individual trees (<code>learning.rate</code>) for boosted regression trees; see also <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_sizes">sizes</code></td>
<td>
<p> vector with values of number of units in the hidden layer for the artificial neural network model; see also <code><a href="nnet.html#topic+nnet">nnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_decays">decays</code></td>
<td>
<p> vector with values of weight decay for the artificial neural network model; see also <code><a href="nnet.html#topic+nnet">nnet</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_difference">difference</code></td>
<td>
<p> if <code>TRUE</code>, then AUC values of the models with all variables are subtracted from the models where one explanatory variable was excluded. After subtraction, positive values indicate that the model without the explanatory variable has a higher AUC than the model with all variables.   </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_variables.alone">variables.alone</code></td>
<td>
<p> if <code>TRUE</code>, then models are also fitted using each explanatory variable as single explanatory variable  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_weights">weights</code></td>
<td>
<p> input weights for the <code>ensemble.weights</code> function </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_best">best</code></td>
<td>
<p> The number of final weights. In case this parameter is smaller than 1 or larger than the number of positive input weights of individual models, then this parameter is ignored. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_min.weight">min.weight</code></td>
<td>
<p> The minimum input weight to be included in the output.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_exponent">exponent</code></td>
<td>
<p> Exponent applied to AUC values to convert AUC values into weights (for example, an exponent of 2 converts input weights of 0.7, 0.8 and 0.9 into 0.7^2=0.49, 0.8^2=0.64 and 0.9^2=0.81). See details. </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_digits">digits</code></td>
<td>
<p> Number of number of decimal places in the output weights; see also <code><a href="base.html#topic+round">round</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, then provide intermediate results for <code>ensemble.strategy</code>) </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_eval">eval</code></td>
<td>
<p> ModelEvaluation object obtained by <code><a href="dismo.html#topic+evaluate">evaluate</a></code> </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_pres">Pres</code></td>
<td>
<p> Suitabilities (probabilities) at presence locations </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_abs">Abs</code></td>
<td>
<p> Suitabilities (probabilities) at background locations </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_vif.max">VIF.max</code></td>
<td>
<p> Maximum Variance Inflation Factor of the selected subset of variables. In case that at least one of the variables has VIF larger than VIF.max, then the variable with the highest VIF will be removed in the next step.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_keep">keep</code></td>
<td>
<p> character vector with names of the variables to be kept.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_car">car</code></td>
<td>
<p> Also provide results from <code><a href="car.html#topic+vif">vif</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.calibrate.models_+3A_silent">silent</code></td>
<td>
<p> Limit textual output.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic function <code>ensemble.calibrate.models</code> first calibrates individual suitability models based on presence locations <code>p</code> and background locations <code>a</code>, then evaluates these suitability models based on presence locations <code>pt</code> and background locations <code>at</code>. While calibrating and testing individual models, results obtained via the <code><a href="dismo.html#topic+evaluate">evaluate</a></code> function can be saved (<code>evaluations.keep</code>).
</p>
<p>As an alternative to providing presence locations <code>p</code>, models can be calibrated with data provided in <code>TrainData</code>. In case that both <code>p</code> and <code>TrainData</code> are provided, then models will be calibrated with <code>TrainData</code>.
</p>
<p>Calibration of the maximum entropy (MAXENT) algorithm is not based on background locations <code>a</code>, but based on background locations <code>MAXENT.a</code> instead. However, to compare evaluations with evaluations of other algorithms, during evaluations of the MAXENT algorithm, presence locations <code>p</code> and background locations <code>a</code> are used (and not background locations <code>MAXENT.a</code>). 
</p>
<p>Output from the GLMNET algorithm is calculated as the mean of the output from <code><a href="glmnet.html#topic+predict.glmnet">predict.glmnet</a></code>. With option <code>GLMNET.class = TRUE</code>, the mean output is the mean prediction of class 1. With option <code>GLMNET.class = FALSE</code>, the mean output is the mean of the responses. 
</p>
<p>As the Mahalanobis function (<code><a href="dismo.html#topic+mahal">mahal</a></code>) does not always provide values within the range of 0 - 1, the output values are rescaled with option <code>MAHAL01</code> by first subtracting the value of <code>1 - MAHAL.shape</code> from each prediction, followed by calculating the absolute value, followed by calculating the reciprocal value and finally multiplying this reciprocal value with <code>MAHAL.shape</code>. As this rescaling method does not estimate probabilities, inclusion in the calculation of a (weighted) average of ensemble probabilities may be problematic and the <code>PROBIT</code> transformation may help here (the same applies to other distance-based methods). 
</p>
<p>With parameter <code>ENSEMBLE.best</code>, the subset of best models (evaluated by the individual AUC values) can be selected and only those models will be used for calculating the ensemble model (in other words, weights for models not included in the ensemble will be set to zero). It is possible to further increase the contribution to the ensemble model for models with higher AUC values through parameter <code>ENSEMBLE.exponent</code>. With <code>ENSEMBLE.exponent = 2</code>, AUC values of 0.7, 0.8 and 0.9 are converted into weights of 0.7^2=0.49, 0.8^2=0.64 and 0.9^2=0.81). With <code>ENSEMBLE.exponent = 4</code>, AUC values of 0.7, 0.8 and 0.9 are converted into weights of 0.7^4=0.2401, 0.8^4=0.4096 and 0.9^2=0.6561). 
</p>
<p><code>ENSEMBLE.tune</code> will result in an internal procedure whereby the best selection of parameter values for <code>ENSEMBLE.min</code>, <code>ENSEMBLE.best</code> or <code>ENSEMBLE.exponent</code> can be identified. Through a factorial procedure, the ensemble model with best AUC for a specific combination of parameter values is identified. The procedure also provides the weights that correspond to the best ensemble. In case that <code>ENSEMBLE.tune</code> is set to <code>FALSE</code>, then the ensemble is calculated based on the input weights.
</p>
<p>Function <code>ensemble.calibrate.weights</code> splits the presence and background locations in a user-defined (<code>k</code>) number of subsets (i.e. k-fold cross-validation), then sequentially calibrates individual suitability models with (<code>k-1</code>) combined subsets and evaluates those with the remaining one subset, whereby each subset is used once for evaluation in the user-defined number (<code>k</code>) of runs. For example, <code>k = 4</code> results in splitting the locations in 4 subsets, then using one of these subsets in turn for evaluations (see also <code><a href="dismo.html#topic+kfold">kfold</a></code>). Note that for the maximum entropy (MAXENT) algorithm, the same background data will be used in each cross-validation run (this is based on the assumption that a large number (~10000) of background locations are used).
</p>
<p>Among the output from function <code>ensemble.calibrate.weights</code> are suggested weights for an ensemble model (<code>output.weights</code> and <code>output.weights.AUC</code>), and information on the respective AUC values of the ensemble model with the suggested weights for each of the (<code>k</code>) subsets. Suggested weights <code>output.weights</code> are calculated as the average of the weights of the different algorithms (submodels) of the <code>k</code> ensembles. Suggested weights <code>output.weights.AUC</code> are calculated as the average of the AUC of the different algorithms of the for the <code>k</code> runs. 
</p>
<p>Function <code>ensemble.calibrate.models.gbm</code> allows to test various combinations of parameters <code>tree.complexity</code> and <code>learning.rate</code> for the <code><a href="dismo.html#topic+gbm.step">gbm.step</a></code> model.
</p>
<p>Function <code>ensemble.calibrate.models.nnet</code> allows to test various combinations of parameters <code>size</code> and <code>decay</code> for the <code><a href="nnet.html#topic+nnet">nnet</a></code> model.
</p>
<p>Function <code>ensemble.drop1</code> allows to test the effects of leaving out each of the explanatory variables, and comparing these results with the &quot;full&quot; model. Note that option of <code>difference = TRUE</code> may result in positive values, indicating that the model without the explanatory variable having larger AUC than the &quot;full&quot; model. A procedure is included to estimate the deviance of a model based on the fitted values, using -2 * (sum(x*log(x)) + sum((1-x)*log(1-x))) where x is a vector of the fitted values for a respective model. (It was checked that this procedure results in similar deviance estimates for the null and 'full' models for glm, but note that it is not certain whether deviance can be calculated in a similar way for other submodels.)
</p>
<p>Function <code>ensemble.formulae</code> provides suggestions for formulae that can be used for <code>ensemble.calibrate.models</code> and <code><a href="#topic+ensemble.raster">ensemble.raster</a></code>. This function is always used internally by the <code>ensemble.drop1</code> function.
</p>
<p>The <code>ensemble.weights</code> function is used internally by the <code>ensemble.calibrate.models</code> and <code><a href="#topic+ensemble.raster">ensemble.raster</a></code> functions, using the input weights for the different suitability modelling algorithms. Ties between input weights result in the same output weights.
</p>
<p>The <code>ensemble.strategy</code> function is used internally by the <code>ensemble.calibrate.models</code> function, using the train and test data sets with predictions of the different suitability modelling algorithms and different combinations of parameters <code>ENSEMBLE.best</code>, <code>ENSEMBLE.min</code> and <code>ENSEMBLE.exponent</code>. The final ensemble model is based on the parameters that generate the best AUC.
</p>
<p>The <code>ensemble.threshold</code> function is used internally by the <code>ensemble.calibrate.models</code>, <code>ensemble.mean</code> and <code>ensemble.plot</code> functions. <code>threshold2005.mean</code> results in calculating the mean value of threshold methods that resulted in better results (calculated by <code><a href="PresenceAbsence.html#topic+optimal.thresholds">optimal.thresholds</a></code> with methods of <code>ObsPrev</code>, <code>MeanProb</code>, <code>MaxSens+Spec</code>, <code>Sens=Spec</code> and <code>MinROCdist</code>) in a study by Liu et al. (Ecography 28: 385-393. 2005). <code>threshold2005.min</code> results in calculating the mean value of threshold methods that resulted in better results (calculated by <code><a href="PresenceAbsence.html#topic+optimal.thresholds">optimal.thresholds</a></code> with methods of <code>ObsPrev</code>, <code>MeanProb</code> and <code>MaxSens+Spec</code>) in a study by Liu et al. (Ecography 28: 385-393. 2005). <code>threshold2013.mean</code> results in calculating the mean value of threshold methods that resulted in better results (calculated by <code><a href="PresenceAbsence.html#topic+optimal.thresholds">optimal.thresholds</a></code> with methods of <code>ObsPrev</code>, <code>MeanProb</code>, <code>MaxSens+Spec</code>, <code>Sens=Spec</code> and <code>MinROCdist</code>) in a study by Liu et al. (J. Biogeogr. 40: 778-789. 2013). <code>threshold2013.min</code> results in calculating the minimum value of threshold methods that resulted in better results (calculated by <code><a href="PresenceAbsence.html#topic+optimal.thresholds">optimal.thresholds</a></code> with methods of <code>ObsPrev</code>, <code>MeanProb</code>, <code>MaxSens+Spec</code>, <code>Sens=Spec</code> and <code>MinROCdist</code>) in a study by Liu et al. (J. Biogeogr. 40: 778-789. 2013).
</p>
<p>Function <code>ensemble.VIF</code> implements a stepwise procedure whereby the explanatory variable with highest Variance Inflation Factor is removed from the list of variables. The procedure ends when no variable has VIF larger than parameter <code>VIF.max</code>.
</p>
<p>Function <code>ensemble.pairs</code> provides a matrix of scatterplots similar to the example of <code><a href="graphics.html#topic+pairs">pairs</a></code> for version 3.4.3 of that package.
</p>


<h3>Value</h3>

<p>Function <code>ensemble.calibrate.models</code> (potentially) returns a list with results from evaluations (via <code><a href="dismo.html#topic+evaluate">evaluate</a></code>) of calibration and test runs of individual suitability models.
</p>
<p>Function <code>ensemble.calibrate.weights</code> returns a matrix with, for each individual suitability model, the AUC of each run and the average AUC over the runs. Models are sorted by the average AUC. The average AUC for each model can be used as input weights for the <code><a href="#topic+ensemble.raster">ensemble.raster</a></code> function.
</p>
<p>Functions <code>ensemble.calibrate.models.gbm</code> and <code>ensemble.calibrate.models.nnet</code> return a matrix with, for each combination of model parameters, the AUC of each run and the average AUC. Models are sorted by the average AUC.
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) </p>


<h3>References</h3>

<p>Kindt R. 2018. Ensemble species distribution modelling with transformed suitability values. Environmental Modelling &amp; Software 100: 136-145. <a href="https://doi.org/10.1016/j.envsoft.2017.11.009">doi:10.1016/j.envsoft.2017.11.009</a>
</p>
<p>Buisson L, Thuiller W, Casajus N, Lek S and Grenouillet G. 2010. Uncertainty in ensemble forecasting of species distribution. Global Change Biology 16: 1145-1157
</p>
<p>Liu C, Berry PM, Dawson TP and Pearson RC. 2005. Selecting thresholds of occurrence in the prediction of species distributions. Ecography 28: 385-393
</p>
<p>Liu C, White M and Newell G. 2013. Selecting thresholds for the prediction of species occurrence with presence-only data. Journal of Biogeography 40: 778-789
</p>
<p>Phillips SJ, Dudik M, Elith J et al. 2009. Sample selection bias and presence-only distribution models: implications for background and pseudo-absence data. Ecological Applications 19: 181-197.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.raster">ensemble.raster</a></code>, <code><a href="#topic+ensemble.batch">ensemble.batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# based on examples in the dismo package

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17", "biome"))
predictors
predictors@title &lt;- "predictors"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]

# the kfold function randomly assigns data to groups; 
# groups are used as calibration (1/4) and training (3/4) data
groupp &lt;- kfold(pres, 4)
pres_train &lt;- pres[groupp !=  1, ]
pres_test &lt;- pres[groupp ==  1, ]

# choose background points
background &lt;- randomPoints(predictors, n=1000, extf=1.00)
colnames(background)=c('lon', 'lat')
groupa &lt;- kfold(background, 4)
backg_train &lt;- background[groupa != 1, ]
backg_test &lt;- background[groupa == 1, ]

# formulae for random forest and generalized linear model
# compare with: ensemble.formulae(predictors, factors=c("biome"))

rfformula &lt;- as.formula(pb ~ bio5+bio6+bio16+bio17)

glmformula &lt;- as.formula(pb ~ bio5 + I(bio5^2) + I(bio5^3) + 
    bio6 + I(bio6^2) + I(bio6^3) + bio16 + I(bio16^2) + I(bio16^3) + 
    bio17 + I(bio17^2) + I(bio17^3) )

# fit four ensemble models (RF, GLM, BIOCLIM, DOMAIN)
# factors removed for BIOCLIM, DOMAIN, MAHAL
ensemble.nofactors &lt;- ensemble.calibrate.models(x=predictors, p=pres_train, a=backg_train, 
    pt=pres_test, at=backg_test,
    species.name="Bradypus",
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.min = 0.65,
    MAXENT=0, MAXNET=0, MAXLIKE=0, GBM=0, GBMSTEP=0, RF=1, CF=0, 
    GLM=1, GLMSTEP=0, GAM=0, GAMSTEP=0, MGCV=0, MGCVFIX=0, 
    EARTH=0, RPART=0, NNET=0, FDA=0, SVM=0, SVME=0, GLMNET=0,
    BIOCLIM.O=0, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=0,
    Yweights="BIOMOD",
    factors="biome",
    evaluations.keep=TRUE, models.keep=TRUE,
    RF.formula=rfformula,
    GLM.formula=glmformula)

# with option models.keep, all model objects are saved in ensemble object
# the same slots can be used to replace model objects with new calibrations
ensemble.nofactors$models$RF
summary(ensemble.nofactors$models$GLM)
ensemble.nofactors$models$BIOCLIM
ensemble.nofactors$models$DOMAIN
ensemble.nofactors$models$formulae

# evaluations are kept in different slot
attributes(ensemble.nofactors$evaluations)
plot(ensemble.nofactors$evaluations$RF.T, "ROC")

# fit four ensemble models (RF, GLM, BIOCLIM, DOMAIN) using default formulae
# variable 'biome' is not included as explanatory variable
# results are provided in a file in the 'outputs' subfolder of the working
# directory
ensemble.nofactors &lt;- ensemble.calibrate.models(x=predictors,
    p=pres_train, a=backg_train, 
    pt=pres_test, at=backg_test,
    layer.drops="biome",
    species.name="Bradypus",
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.min=0.65,
    SINK=TRUE,
    MAXENT=0, MAXNET=0, MAXLIKE=0, GBM=0, GBMSTEP=0, RF=1, CF=0, 
    GLM=1, GLMSTEP=0, GAM=0, 
    GAMSTEP=0, MGCV=0, MGCVFIX=0, EARTH=0, RPART=0, NNET=0, FDA=0, 
    SVM=0, SVME=0, GLMNET=0,
    BIOCLIM.O=0, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=0,
    Yweights="BIOMOD", 
    evaluations.keep=TRUE,
    formulae.defaults=TRUE)    

# after fitting the individual algorithms (submodels),
# transform predictions with a probit link.
ensemble.nofactors &lt;- ensemble.calibrate.models(x=predictors,
    p=pres_train, a=backg_train, 
    pt=pres_test, at=backg_test,
    layer.drops="biome",
    species.name="Bradypus",
    SINK=TRUE,
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.min=0.65,
    MAXENT=0, MAXNET=0, MAXLIKE=0, GBM=0, GBMSTEP=0, RF=1, CF=0,
    GLM=1, GLMSTEP=0, GAM=0, GAMSTEP=0, MGCV=0, MGCVFIX=0, 
    EARTH=0, RPART=0, NNET=0, FDA=0, SVM=0, SVME=0, GLMNET=0,
    BIOCLIM.O=0, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=0,
    PROBIT=TRUE,
    Yweights="BIOMOD", factors="biome",
    evaluations.keep=TRUE,
    formulae.defaults=TRUE)    

# Instead of providing presence and background locations, provide data.frames.
# Because 'biome' is a factor, RasterStack needs to be provided
# to check for levels in the Training and Testing data set.
TrainData1 &lt;- prepareData(x=predictors, p=pres_train, b=backg_train, 
    factors=c("biome"), xy=FALSE)
TestData1 &lt;- prepareData(x=predictors, p=pres_test, b=backg_test, 
    factors=c("biome"), xy=FALSE)
ensemble.factors1 &lt;- ensemble.calibrate.models(x=predictors, 
    TrainData=TrainData1, TestData=TestData1,
    p=pres_train, a=backg_train, 
    pt=pres_test, at=backg_test,
    species.name="Bradypus",
    SINK=TRUE,
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.min=0.65,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=0, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, GLMNET=1,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    Yweights="BIOMOD", factors="biome",
    evaluations.keep=TRUE)

# compare different methods of calculating ensembles
ensemble.factors2 &lt;- ensemble.calibrate.models(x=predictors, 
    TrainData=TrainData1, TestData=TestData1,
    p=pres_train, a=backg_train, 
    pt=pres_test, at=backg_test,
    species.name="Bradypus",
    SINK=TRUE,
    ENSEMBLE.tune=TRUE,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=1, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, GLMNET=1,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    ENSEMBLE.best=c(4:10), ENSEMBLE.exponent=c(1, 2, 3),
    Yweights="BIOMOD", factors="biome",
    evaluations.keep=TRUE)

# test performance of different suitability models
# data are split in 4 subsets, each used once for evaluation
ensemble.nofactors2 &lt;- ensemble.calibrate.weights(x=predictors, 
    p=pres, a=background, k=4, 
    species.name="Bradypus",
    SINK=TRUE, PROBIT=TRUE,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=1, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, GLMNET=1,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.best=0, ENSEMBLE.exponent=c(1, 2, 3),
    ENSEMBLE.min=0.7,
    Yweights="BIOMOD", 
    formulae.defaults=TRUE)
ensemble.nofactors2$AUC.table
ensemble.nofactors2$eval.table.all

# test the result of leaving out one of the variables from the model
# note that positive differences indicate that the model without the variable 
# has higher AUC than the full model
ensemble.variables &lt;- ensemble.drop1(x=predictors, 
    p=pres, a=background, k=4,
    species.name="Bradypus",
    SINK=TRUE,
    difference=TRUE,
    VIF=TRUE, PROBIT=TRUE,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=1, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, GLMNET=1,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.best=0, ENSEMBLE.exponent=c(1, 2, 3),
    ENSEMBLE.min=0.7,
    Yweights="BIOMOD", factors="biome")
ensemble.variables

# use function ensemble.VIF to select a subset of variables
# factor variables are not handled well by the function
# and therefore factors are removed
# however, one can check for factors with car::vif through
# the ensemble.calibrate.models function
# VIF.analysis$var.drops can be used as input for ensemble.calibrate.models or
# ensemble.calibrate.weights

predictors &lt;- stack(predictor.files)
predictors &lt;- subset(predictors, subset=c("bio1", "bio5", "bio6", "bio8", 
    "bio12", "bio16", "bio17", "biome"))

ensemble.pairs(predictors)

VIF.analysis &lt;- ensemble.VIF(predictors, factors="biome")
VIF.analysis
# alternative solution where bio1 and bio12 are kept
VIF.analysis &lt;- ensemble.VIF(predictors, factors="biome", 
    keep=c("bio1", "bio12"))
VIF.analysis

## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.concave.hull'>
Analysis of Niche Overlap in Environmental Space for Changed Climates via Concave Hulls
</h2><span id='topic+ensemble.concave.hull'></span><span id='topic+ensemble.concave.venn'></span><span id='topic+ensemble.concave.union'></span><span id='topic+ensemble.outliers'></span>

<h3>Description</h3>

<p>Building on methodologies described by Pironon et al. (<a href="https://doi.org/10.1038/s41558-019-0585-7">doi:10.1038/s41558-019-0585-7</a>), function <code><a href="#topic+ensemble.concave.hull">ensemble.concave.hull</a></code> constructs two hulls in environmental space for the baseline and a changed (typically a future climate, but possibly also a historical or paleo-climate) for a focal species. Functions <code><a href="#topic+ensemble.concave.venn">ensemble.concave.venn</a></code> and <code><a href="#topic+ensemble.concave.union">ensemble.concave.union</a></code> create a third hull for candidate accessions that represent different geographies and/or different species. Subsequently overlaps between hulls are investigated. Information is also provided for each accession of the focal species in the novel climate if these are included within the hull of the candidate accessions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.concave.hull(
    baseline.data,
    change.data,
    complete.cases = TRUE,
    VIF = TRUE, VIF.max = 20, VIF.silent = TRUE,
    method = c("rda", "pca", "prcomp"),
    ax1 = 1, ax2 = 2,
    concavity = 2.5,
    buffer.dist = NA,
    ggplot = TRUE)

ensemble.concave.venn(
    x,
    candidate.data,
    concavity = x$concavity,
    buffer.dist = x$buffer.dist,
    ggplot = TRUE,
    show.candidate.points = TRUE)

ensemble.concave.union(
    x,
    candidate.venns,
    buffer.dist = x$buffer.dist,
    ggplot = TRUE,
    show.candidate.points = TRUE)

ensemble.outliers(
    x,
    ID.var = NULL, bioc.vars = NULL,
    fence.k = 2.5, n_min = 5) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.concave.hull_+3A_baseline.data">baseline.data</code></td>
<td>
<p> data.frame with climatic variables for the accessions in the baseline climate.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_change.data">change.data</code></td>
<td>
<p> data.frame with climatic variables for the accessions in the changed (potentially future) climate.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_complete.cases">complete.cases</code></td>
<td>
<p> Reduce cases with those without missing data via <code><a href="stats.html#topic+complete.cases">complete.cases</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_vif">VIF</code></td>
<td>
<p> Select a subset of climatic variables via <code><a href="#topic+ensemble.VIF.dataframe">ensemble.VIF.dataframe</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_vif.max">VIF.max</code></td>
<td>
<p> Argument setting for <code><a href="#topic+ensemble.VIF.dataframe">ensemble.VIF.dataframe</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_vif.silent">VIF.silent</code></td>
<td>
<p> Argument setting for <code><a href="#topic+ensemble.VIF.dataframe">ensemble.VIF.dataframe</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_method">method</code></td>
<td>
<p> Method of constructing the hulls; see details.  </p>
</td></tr>  
<tr><td><code id="ensemble.concave.hull_+3A_ax1">ax1</code></td>
<td>
<p> Idex for the first ordination axis to be analyzed; see also <code><a href="vegan.html#topic+scores">scores</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_ax2">ax2</code></td>
<td>
<p> Index for second ordination axis to be analyzed; see also <code><a href="vegan.html#topic+scores">scores</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_concavity">concavity</code></td>
<td>
<p> A relative measure of concavity used by <code><a href="concaveman.html#topic+concaveman">concaveman</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_buffer.dist">buffer.dist</code></td>
<td>
<p> Buffer width used internally by <code><a href="sf.html#topic+st_buffer">st_buffer</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_ggplot">ggplot</code></td>
<td>
<p> Should a ggplot object be included in the output?  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_x">x</code></td>
<td>
<p> Output similar to those of <code><a href="#topic+ensemble.concave.hull">ensemble.concave.hull</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_candidate.data">candidate.data</code></td>
<td>
<p> data.frame with climatic variables for candidate accessions such as accessions from other geographical areas or other species.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_show.candidate.points">show.candidate.points</code></td>
<td>
<p> Should the ggplot object show the locations of the candidate accessions?  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_candidate.venns">candidate.venns</code></td>
<td>
<p> list with outputs from the <code><a href="#topic+ensemble.concave.venn">ensemble.concave.venn</a></code> function.  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_id.var">ID.var</code></td>
<td>
<p> Variable name used as identifier  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_bioc.vars">bioc.vars</code></td>
<td>
<p> Variables included in the analysis of outliers </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_fence.k">fence.k</code></td>
<td>
<p> Multiplier to calculate distance of observation from Interquartile lower and upper limits as used by Tukey's Fences method to detect outliers  </p>
</td></tr>
<tr><td><code id="ensemble.concave.hull_+3A_n_min">n_min</code></td>
<td>
<p> Minimum number of variables for identifying outliers </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas the metholology of Pironon et al. (2019) uses convex hulls, concave hulls can also be used in the methodology provided here. Convex hulls will be obtained by using large values for the <code>concavity</code> argument (see the description for the <code><a href="concaveman.html#topic+concaveman">concaveman</a></code> function). By using more concave hulls, the influence of outliers on measures of niche overlap can be reduced.
</p>
<p>Three methods are available for mapping accessions in environmental space. Methods <code>pca</code> and <code>prcomp</code> use principal components analysis, respectively via the <code><a href="vegan.html#topic+rda">rda</a></code> and <code><a href="stats.html#topic+prcomp">prcomp</a></code> functions. In both the methods, climatic variables are scaled. As results with <code>pca</code> are also rescaled via <code><a href="#topic+caprescale">caprescale</a></code>, both methods of <code>pca</code> and <code>prcomp</code> should theoretically result in the same configurations.
</p>
<p>Method <code>rda</code> internally uses <code><a href="vegan.html#topic+envfit">envfit</a></code> to select a subset of climatic variables that are significantly correlated (P &lt;= 0.05, R2 &gt;= 0.50) with the first two axes of a redundancy analysis that uses the climate (baseline vs. changed) as predictor variable.
</p>
<p>Candidate accessions are mapped in the environmental space created by <code><a href="#topic+ensemble.concave.hull">ensemble.concave.hull</a></code> via prediction methods available from <code><a href="vegan.html#topic+predict.cca">predict.cca</a></code> and <code><a href="stats.html#topic+predict.prcomp">predict.prcomp</a></code>.
</p>
<p>Function <code><a href="#topic+ensemble.concave.union">ensemble.concave.union</a></code> combines candidate hulls obtained from <code><a href="#topic+ensemble.concave.venn">ensemble.concave.venn</a></code>, using <code><a href="sf.html#topic+st_union">st_union</a></code> internally.
</p>
<p>Both <code><a href="#topic+ensemble.concave.venn">ensemble.concave.venn</a></code> and <code><a href="#topic+ensemble.concave.union">ensemble.concave.union</a></code> return measures of niche overlap based on areas of overlap between the candidate hull and the part of hull for the changed climate that is not covered by the hull for the baseline climate. These functions also indicate for each of the accessions of the focal species in the changed climate whether they occur in a novel climate (novel == TRUE; this information was obtained by <code><a href="#topic+ensemble.concave.hull">ensemble.concave.hull</a></code>) and whether they are inside the hull of the candidate accessions (candidate.in == TRUE).
</p>
<p>The optional plot shows the locations of accessions for the changed climate. For <code><a href="#topic+ensemble.concave.hull">ensemble.concave.hull</a></code>, colouring is based on having novel climates (not occurring in the overlap between the two hulls) or not. For the other functions, locations are only shown for accessions with novel climates. Colouring is based on being inside the hull for the candidate accessions or not.
</p>
<p>Function <code><a href="#topic+ensemble.outliers">ensemble.outliers</a></code> generalizes Tukey's fences method to require that a multivariate outlier is a univariate outlier for a minimum number of <code>n_min</code> variables (see )
</p>


<h3>Value</h3>

<p>Function <code>ensemble.concave.hull</code> returns a list with following elements:
</p>
<p>- rda.object: result of the ordination method used; 
- method: method used in the function; 
- baseline.hull: polygon for the hull for the baseline climate; 
- baseline.area: area of the baseline hull; 
- change.hull: polygon for the hull for the changed climate; 
- change.area: area of the hull for the changed climate; 
- overlap.hull: polygon for the overlap (intersection) of the baseline and changed hull; 
- overlap.area: area of the overlap hull;  
- novel.hull: polygon for the part of the changed hull that does not cover the baseline hull;  
- change.area: area of the novel hull; 
- buffer.dist: distance used in checking whether accessions are in novel conditions;
- change.points: plotting coordinates and details on novel conditions for accessions of the changed climate;
- baseline.points: plotting coordinates for accessions of the baseline climate
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) and Maarten van Zonneveld (World Vegetable Center)</p>


<h3>References</h3>

<p>Pironon et al. (2019). Potential adaptive strategies for 29 sub-Saharan crops under future climate change. Nat. Clim. Chang. 9: 758-736. <a href="https://doi.org/10.1038/s41558-019-0585-7">doi:10.1038/s41558-019-0585-7</a>
</p>
<p>van Zonneveld et al. (2018). Tree genetic resources at risk in South America: a  spatial threat assessment to prioritize populations for conservation. Diversity and Distributions 24: 718-729
</p>
<p>van Zonneveld et al. (2023). Forgotten food crops in sub-Saharan Africa for healthy diets in a changing climate. Proceedings of the National Academy of Sciences (PNAS) 120 (14) e2205794120. <a href="https://doi.org/10.1073/pnas.2205794120">doi:10.1073/pnas.2205794120</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(ggplot2)
library(sf)
library(concaveman)

data(CucurbitaClim)

alata.data &lt;- CucurbitaClim[CucurbitaClim$species == "Cucurbita_palmata", ]

bioc.names &lt;- paste0("bioc", 1:19)

alata.data2 &lt;- alata.data[alata.data$ADM0_A3 == "USA", ]
alata.base &lt;- alata.data2[alata.data2$climate == "baseline", bioc.names]
alata.fut  &lt;- alata.data2[alata.data2$climate == "future", bioc.names]

conc2.res &lt;- ensemble.concave.hull(baseline.data=alata.base,
                                  change.data=alata.fut,
                                  method="pca",
                                  VIF.max=40,
                                  concavity=2)

plot(conc2.res$ggplot.out)
conc2.res$baseline.area
conc2.res$change.area
conc2.res$novel.area
conc2.res$novel.area / conc2.res$change.area

# Which accessions have novel climates?
summary(conc2.res$change.points)
change.points &lt;- conc2.res$change.points
rownames(change.points[change.points$novel == TRUE, ])
nrow(change.points[change.points$novel == TRUE, ]) / nrow(change.points)

# Analysis via convex hulls
conc100.res &lt;- ensemble.concave.hull(baseline.data=alata.base,
                                  change.data=alata.fut,
                                  method="pca",
                                  concavity=100)

plot(conc100.res$ggplot.out)
conc100.res$baseline.area
conc100.res$change.area
conc100.res$novel.area
conc100.res$novel.area / conc100.res$change.area

# Which accessions have novel climates?
summary(conc100.res$change.points)
change.points &lt;- conc100.res$change.points
rownames(change.points[change.points$novel == TRUE, ])
nrow(change.points[change.points$novel == TRUE, ]) / nrow(change.points)

# Checking niche overlaps with other accessions
# Alternative 1: niche overlap with accessions from Mexico
alata.data2 &lt;- alata.data[alata.data$ADM0_A3 == "MEX", ]
alata.MEX &lt;- alata.data2[alata.data2$climate == "baseline", bioc.names]

venn2.res &lt;- ensemble.concave.venn(conc2.res,
                                   candidate.data=alata.MEX,
                                   concavity=2)
plot(venn2.res$ggplot.out)
table(venn2.res$change.points[ , c("novel", "candidate.in")])


# alternative 1 for convex hulls
venn100.res &lt;- ensemble.concave.venn(conc100.res,
                                   candidate.data=alata.MEX,
                                   concavity=100)
plot(venn100.res$ggplot.out)
table(venn100.res$change.points[ , c("novel", "candidate.in")])

# alternative 2: niche overlap with other species
cucurbita2 &lt;- CucurbitaClim[CucurbitaClim$climate == "baseline", ]
cordata.data &lt;- cucurbita2[cucurbita2$species == "Cucurbita_cordata", bioc.names]
digitata.data &lt;- cucurbita2[cucurbita2$species == "Cucurbita_digitata", bioc.names]

venn.cordata &lt;- ensemble.concave.venn(conc2.res,
                                      candidate.data=cordata.data,
                                      concavity=2)
plot(venn.cordata$ggplot.out)

venn.digitata &lt;- ensemble.concave.venn(conc2.res,
                                      candidate.data=digitata.data,
                                      concavity=2)
plot(venn.digitata$ggplot.out)

# check the union of the two species
spec.res &lt;- vector("list", 2)
spec.res[[1]] &lt;- venn.cordata
spec.res[[2]] &lt;- venn.digitata
union2.res &lt;- ensemble.concave.union(conc2.res,
                                     candidate.venns=spec.res)
table(union2.res$change.points[ , c("novel", "candidate.in")])

# Analysis via convex hulls
venn.digitata &lt;- ensemble.concave.venn(conc100.res,
                                      candidate.data=digitata.data,
                                      concavity=100)

venn.cordata &lt;- ensemble.concave.venn(conc100.res,
                                      candidate.data=cordata.data,
                                      concavity=100)
spec.res &lt;- vector("list", 2)
spec.res[[1]] &lt;- venn.cordata
spec.res[[2]] &lt;- venn.digitata

union100.res &lt;- ensemble.concave.union(conc100.res,
                                     candidate.venns=spec.res)
plot(union100.res$ggplot.out)
table(union100.res$change.points[ , c("novel", "candidate.in")])

# Identify outliers
baseline.outliers &lt;- ensemble.outliers(alata.base,
    bioc.vars=paste0("bioc", 1:19))
baseline.outliers[baseline.outliers$outlier == TRUE, ]


## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.dummy.variables'>
Suitability mapping based on ensembles of modelling algorithms: handling of categorical data
</h2><span id='topic+ensemble.dummy.variables'></span><span id='topic+ensemble.accepted.categories'></span><span id='topic+ensemble.simplified.categories'></span>

<h3>Description</h3>

<p>The basic function <code>ensemble.dummy.variables</code> creates new raster layers representing dummy variables (coded 0 or 1) for all or the most frequent levels of a caterogical variable. Sometimes the creation of dummy variables is needed for proper handling of categorical data for some of the suitability modelling algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.dummy.variables(xcat = NULL, 
    freq.min = 50, most.frequent = 5,
    new.levels = NULL, overwrite = TRUE, ...)

ensemble.accepted.categories(xcat = NULL, categories = NULL, 
    filename = NULL, overwrite = TRUE, ...)

ensemble.simplified.categories(xcat = NULL, p = NULL, 
    filename = NULL, overwrite = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.dummy.variables_+3A_xcat">xcat</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>) containing values for a categorical explanatory variable.  </p>
</td></tr>
<tr><td><code id="ensemble.dummy.variables_+3A_freq.min">freq.min</code></td>
<td>
<p> Minimum frequency for a dummy raster layer to be created for the corresponding factor level. See also <code><a href="raster.html#topic+freq">freq</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.dummy.variables_+3A_most.frequent">most.frequent</code></td>
<td>
<p> Number of dummy raster layers to be created (if larger than 0), corresponding to the same number of most frequent factor levels  See also <code><a href="raster.html#topic+freq">freq</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.dummy.variables_+3A_new.levels">new.levels</code></td>
<td>
<p> character vector giving factor levels that are not encountered in <code>xcat</code> and for which dummy layers should be created (this could be useful in dealing with novel conditions)  </p>
</td></tr>
<tr><td><code id="ensemble.dummy.variables_+3A_overwrite">overwrite</code></td>
<td>
<p> overwrite an existing file name with the same name (if <code>TRUE</code>). See also <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.dummy.variables_+3A_...">...</code></td>
<td>
<p> additional arguments for <code><a href="raster.html#topic+writeRaster">writeRaster</a></code> or (for <code>ensemble.dummy.variables</code>, <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>).  </p>
</td></tr>
<tr><td><code id="ensemble.dummy.variables_+3A_categories">categories</code></td>
<td>
<p> numeric vector providing the accepted levels of a categorical raster layer; expected to correspond to the levels encountered during calibration </p>
</td></tr>
<tr><td><code id="ensemble.dummy.variables_+3A_filename">filename</code></td>
<td>
<p> name for the output file. See also <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.dummy.variables_+3A_p">p</code></td>
<td>
<p> presence points that will be used for calibrating the suitability models, typically available in 2-column (x, y) or (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic function <code>ensemble.dummy.variables</code> creates dummy variables from a <code>RasterLayer</code> object (see <code><a href="raster.html#topic+raster">raster</a></code>) that represents a categorical variable. With <code>freq.min</code> and <code>most.frequent</code> it is possible to limit the number of dummy variables that will be created. For example, <code>most.frequent = 5</code> results in five dummy variables to be created.  
</p>
<p>Function <code>ensemble.accepted.categories</code> modifies the <code>RasterLayer</code> object (see <code><a href="raster.html#topic+raster">raster</a></code>) by replacing cell values for categories (levels) that are not accepted with missing values.
</p>
<p>Function <code>ensemble.simplified.categories</code> modifies the <code>RasterLayer</code> object (see <code><a href="raster.html#topic+raster">raster</a></code>) by replacing cell values for categories (levels) where none of the presence points occur with the same level. This new level is coded by the maximum coding level for these 'outside categories'. 
</p>


<h3>Value</h3>

<p>The basic function <code>ensemble.dummy.variables</code> mainly results in the creation of raster layers that correspond to dummy variables.
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) and Evert Thomas (Bioversity International) </p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code>, <code><a href="#topic+ensemble.raster">ensemble.raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
biome.layer &lt;- predictors[["biome"]]
biome.layer

# create dummy layers for the 5 most frequent factor levels

ensemble.dummy.variables(xcat=biome.layer, most.frequent=5,
    overwrite=TRUE)

# check whether dummy variables were created
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
predictors
names(predictors)

# once dummy variables were created, avoid using the original categorical data layer
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", "bio16", "bio17", 
    "biome_1", "biome_2", "biome_7", "biome_8", "biome_13"))
predictors
predictors@title &lt;- "base"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]

# the kfold function randomly assigns data to groups; 
# groups are used as calibration (1/5) and training (4/5) data
groupp &lt;- kfold(pres, 5)
pres_train &lt;- pres[groupp !=  1, ]
pres_test &lt;- pres[groupp ==  1, ]

# choose background points
background &lt;- randomPoints(predictors, n=1000, extf=1.00)
colnames(background)=c('lon', 'lat')
groupa &lt;- kfold(background, 5)
backg_train &lt;- background[groupa != 1, ]
backg_test &lt;- background[groupa == 1, ]

# note that dummy variables with no variation are not used by DOMAIN
# note that dummy variables are not used by MAHAL and MAHAL01
# (neither are categorical variables)
ensemble.nofactors &lt;- ensemble.calibrate.models(x=predictors, p=pres_train, a=backg_train, 
    pt=pres_test, at=backg_test,
    species.name="Bradypus",
    VIF=T,
    MAXENT=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, GLM=1, GLMSTEP=0, GAM=1, 
    GAMSTEP=0, MGCV=1, MGCVFIX=0, EARTH=1, RPART=1, NNET=1, FDA=1, 
    SVM=1, SVME=1, BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    Yweights="BIOMOD", 
    dummy.vars=c("biome_1", "biome_2", "biome_7", "biome_8", "biome_13"),
    PLOTS=FALSE, evaluations.keep=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.ecocrop'>
Suitability mapping via absolute and optimal precipitation and temperature limits as in the ECOCROP model.
</h2><span id='topic+ensemble.ecocrop'></span><span id='topic+ensemble.ecocrop.object'></span>

<h3>Description</h3>

<p>Function <code>ensemble.ecocrop</code> creates the map with novel conditions. Function <code>ensemble.novel.object</code> provides the reference values used by the prediction function used by <code><a href="raster.html#topic+predict">predict</a></code> . 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.ecocrop(x = NULL, ecocrop.object = NULL, 
    RASTER.object.name = ecocrop.object$name, 
    RASTER.stack.name = "xTitle",
    RASTER.format = "GTiff", RASTER.datatype = "INT2S", RASTER.NAflag = -32767,
    CATCH.OFF = FALSE)

ensemble.ecocrop.object(temp.thresholds, rain.thresholds, name = "crop01", 
    temp.multiply = 1, annual.temps = TRUE, transform = 1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.ecocrop_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all environmental layers for which suitability should be calculated.  </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_ecocrop.object">ecocrop.object</code></td>
<td>
<p> Object listing optimal and absolute minima and maxima for the rainfall and temperature values, used by the prediction function that is used internally by <code><a href="raster.html#topic+predict">predict</a></code>. This object is created with <code><a href="#topic+ensemble.ecocrop.object">ensemble.ecocrop.object</a></code>. </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_raster.object.name">RASTER.object.name</code></td>
<td>
<p> First part of the names of the raster file that will be generated, expected to identify the species or crop for which ranges were calculated </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_raster.stack.name">RASTER.stack.name</code></td>
<td>
<p> Last part of the names of the raster file that will be generated, expected to identify the predictor stack used </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_raster.format">RASTER.format</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_raster.datatype">RASTER.datatype</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+dataType">dataType</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_raster.naflag">RASTER.NAflag</code></td>
<td>
<p> Value that is used to store missing data. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_temp.thresholds">temp.thresholds</code></td>
<td>
<p> Optimal and absolute thresholds for temperatures. These will be sorted as: absolute minimum temperature, optimal minimum temperature, optimal maximum temperature and absolute maximum temperature.  </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_rain.thresholds">rain.thresholds</code></td>
<td>
<p> Optimal and absolute thresholds for annual rainfall. These will be sorted as: absolute minimum rainfall, optimal minimum rainfall, optimal maximum rainfall and absolute maximum rainfall.  </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_name">name</code></td>
<td>
<p> Name of the object, expect to expected to identify the species or crop </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_temp.multiply">temp.multiply</code></td>
<td>
<p> Multiplier for temperature values. The value of 10 is to be used with raster layers where temperature was multiplied by 10 such as Worldclim version 1 or AFRICLIM.   </p>
</td></tr>
<tr><td><code id="ensemble.ecocrop_+3A_annual.temps">annual.temps</code></td>
<td>
<p> If <code>TRUE</code> then temperature limits are assumed to apply to mean annual temperature (bioclimatic variable bio1). If <code>FALSE</code> then minimum temperature limits are assumed to apply to the temperature of the coldest month (bioclimatic variable bio6) and maximum temperature limits are assumed to apply to the temperature of the hottest month (bioclimatic variable bio5). See also <code><a href="dismo.html#topic+biovars">biovars</a></code>.   </p>
</td></tr> 
<tr><td><code id="ensemble.ecocrop_+3A_transform">transform</code></td>
<td>
<p> Exponent used to transform probability values obtained from interpolating between optimal and absolute limits. Exponent of 2 results in squaring probabilities, for example input probabilities of 0.5 transformed to 0.5^2 = 0.25.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ensemble.ecocrop</code> maps suitability for a species or crop based on optimal and absolute temperature and rainfall limits. Where both temperature and rainfall are within the optimal limits, suitability of 1000 is calculated. Where both temperature and rainfall are outside the absolute limits, suitability of 0 is calculated. In situations where temperature or rainfall is in between the optimal and absolute limits, then suitability is interpolated between 0 and 1000, and the lowest suitability from temperature and rainfall is calculated. Setting very wide rainfall limits will simulate the effect of irrigation, i.e. where suitability only depends on temperature limits. 
</p>
<p>For a large range of crop and plant species, optimal and absolute limits are available from the FAO ecocrop database (<a href="https://gaez.fao.org/pages/ecocrop-search">https://gaez.fao.org/pages/ecocrop-search</a>), hence the name of the function. A different implementation of suitability mapping based on ecocrop limits is available from <code><a href="dismo.html#topic+ecocrop">ecocrop</a></code>. Ecocrop thresholds for several species are available from: <code><a href="dismo.html#topic+getCrop">getCrop</a></code>
</p>


<h3>Value</h3>

<p>Function <code>ensemble.ecocrop.object</code> returns a list with following objects:
</p>
<table role = "presentation">
<tr><td><code>name</code></td>
<td>
<p> name for the crop or species </p>
</td></tr>
<tr><td><code>temp.thresholds</code></td>
<td>
<p> optimal and absolute minimum and maximum temperature limits </p>
</td></tr>
<tr><td><code>rain.thresholds</code></td>
<td>
<p> optimal and absolute minimum and maximum annual rainfall limits </p>
</td></tr>
<tr><td><code>annual.temps</code></td>
<td>
<p> logical indicating whether temperature limits apply to annual temperatures </p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p> exponent to transform suitability values </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>See Also</h3>

<p><code><a href="dismo.html#topic+biovars">biovars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# test with Brazil nut (limits from FAO ecocrop)
# temperature: (12) 20-36 (40)
# annnual rainfall: (1400) 2400-2800 (3500)

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", "bio12"))
predictors
predictors@title &lt;- "base"

# As the raster data correspond to WorldClim version 1,
# the temperatures need to be multiplied by 10
Brazil.ecocrop &lt;- ensemble.ecocrop.object(temp.thresholds=c(20, 36, 12, 40), 
    rain.thresholds=c(2400, 2800, 1400, 3500),
    temp.multiply=10,
    annual.temps=FALSE, name="Bertholletia_excelsa")
Brazil.ecocrop
ensemble.ecocrop(predictors, 
                 ecocrop.object=Brazil.ecocrop,
                 RASTER.stack.name="base")

dev.new()
par.old &lt;- graphics::par(no.readonly=T)
graphics::par(mfrow=c(1,2))

rasterfull1 &lt;- paste("ensembles//ecocrop//Bertholletia_excelsa_base.tif", sep="")
rasterfull1 &lt;- raster(rasterfull1)
# raster file saved probabilities as integer values between 0 and 1000
rasterfull1 &lt;- rasterfull1/1000
raster::plot(rasterfull1, main="Ecocrop suitability")

GBIFloc &lt;- gbif(genus="Bertholletia", species="excelsa", geo=TRUE)
GBIFpres &lt;- GBIFloc[, c("lon", "lat")]
GBIFpres &lt;- GBIFpres[complete.cases(GBIFpres), ]
GBIFpres &lt;- GBIFpres[duplicated(GBIFpres) == FALSE, ]
point.suitability &lt;- extract(rasterfull1, y=GBIFpres)
point.suitability[is.na(point.suitability)] &lt;- -1

GBIFpres.optimal &lt;- GBIFpres[point.suitability == 1, ]
GBIFpres.suboptimal &lt;- GBIFpres[point.suitability &lt; 1 &amp; point.suitability &gt; 0, ]
GBIFpres.not &lt;- GBIFpres[point.suitability == 0, ]

raster::plot(rasterfull1, main="GBIF locations", 
    sub="blue: optimal, cyan: suboptimal, red: not suitable")
bg.legend &lt;- c("blue", "cyan", "red")

points(GBIFpres.suboptimal, pch=21, cex=1.2, bg=bg.legend[2])
points(GBIFpres.optimal, pch=21, cex=1.2, bg=bg.legend[1])
points(GBIFpres.not, pch=21, cex=1.2, bg=bg.legend[3])

graphics::par(par.old)

## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.envirem.masterstack'>
Calculate bioclimatic variables via the <code>envirem</code> package for data.frames.
</h2><span id='topic+ensemble.envirem.masterstack'></span><span id='topic+ensemble.envirem.solradstack'></span><span id='topic+ensemble.envirem.run'></span>

<h3>Description</h3>

<p>Function <code><a href="envirem.html#topic+generateEnvirem">generateEnvirem</a></code> uses RasterStack (<code><a href="raster.html#topic+stack">stack</a></code>) objects as input and also generates outputs in the same format. The functions described here can be used to generate the bioclimatic variables for <code>data.frames</code> while using <code>envirem</code> functions internally. This feature can be useful in situations where models are calibrated with higher resolution data, but where maps will only be generated in lower resolutions, thus avoiding the need to generate the higher resolution envirem layers first.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.envirem.masterstack(
    x,
    precipstack, 
    tmaxstack, tminstack, 
    tmeanstack = NULL,
    envirem3 = TRUE)

ensemble.envirem.solradstack(
    x, solrad,
    envirem3 = TRUE)

ensemble.envirem.run(
    masterstack, solradstack,
    var = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.envirem.masterstack_+3A_x">x</code></td>
<td>
<p> Point locations provided in 2-column (eg, LON-LAT) format.</p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_precipstack">precipstack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) or SpatRaster object (<code><a href="terra.html#topic+rast">rast</a></code>) containing monthly precipitation data.  </p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_tmaxstack">tmaxstack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) or SpatRaster object (<code><a href="terra.html#topic+rast">rast</a></code>) containing monthly maximum temperature data.  </p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_tminstack">tminstack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) or SpatRaster object (<code><a href="terra.html#topic+rast">rast</a></code>) containing monthly minimum temperature data.  </p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_tmeanstack">tmeanstack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) or SpatRaster object (<code><a href="terra.html#topic+rast">rast</a></code>) containing monthly average temperature data.  </p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_envirem3">envirem3</code></td>
<td>
<p> generate a SpatRaster object (<code><a href="terra.html#topic+rast">rast</a></code>) as used by envirem 3.  </p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_solrad">solrad</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) or SpatRaster object (<code><a href="terra.html#topic+rast">rast</a></code>) containing monthly extrasolar radiation data.  </p>
</td></tr>  
<tr><td><code id="ensemble.envirem.masterstack_+3A_masterstack">masterstack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) expected to have been created via <code><a href="#topic+ensemble.envirem.masterstack">ensemble.envirem.masterstack</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_solradstack">solradstack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) expected to have been created via <code><a href="#topic+ensemble.envirem.solradstack">ensemble.envirem.solradstack</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_var">var</code></td>
<td>
<p> Names of bioclimatic variables to be created; see: <code><a href="envirem.html#topic+generateEnvirem">generateEnvirem</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.envirem.masterstack_+3A_...">...</code></td>
<td>
<p> Other arguments for <code><a href="envirem.html#topic+generateEnvirem">generateEnvirem</a></code>, dealing with the scale of temperature or precipitation data.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The objective of these functions is to expand a data.frame of explanatory variables that will be used for calibrating species distribution models with bioclimatic variables that are generated by the envirem package (See details in <code><a href="envirem.html#topic+generateEnvirem">generateEnvirem</a></code>).
</p>
<p>It is important that monthly values are sorted sequentially (January - December) as the <code>ensemble.envirem.masterstack</code> and <code>ensemble.envirem.solradstack</code> functions expect the inputs to be sorted in this order.
</p>
<p>Function <code>ensemble.envirem.solradstack</code> requires monthly extraterrestrial solar radiation layers at the same resolution as the climatic layers. It is possible, however, to also calculate these values directly for point observation data as shown below in the examples.
</p>


<h3>Value</h3>

<p>Function <code>ensemble.envirem.run</code> returns a data.frame with bioclimatic variables for each point location. 
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Title P.O., Bemmels J.B. 2018. ENVIREM: An expanded set of bioclimatic and topographic variables increases flexibility and improves performance of ecological niche modeling. Ecography 41: 291-307.
</p>
<p>Kindt R. 2023. TreeGOER: A database with globally observed environmental ranges for 48,129 tree species. Global Change Biology. 
<a href="https://doi.org/10.1111/gcb.16914">doi:10.1111/gcb.16914</a>
</p>


<h3>See Also</h3>

<p><code><a href="envirem.html#topic+generateEnvirem">generateEnvirem</a></code>, <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code>, <code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Based on examples in envirem package for envirem::generateEnvirem
# Modified Sep-2023 due to change in function name in envirem

library(terra)
library(envirem)

# Find example rasters
rasterFiles &lt;- list.files(system.file('extdata', package='envirem'), 
                          full.names=TRUE)

precip.files &lt;- rasterFiles[grepl(pattern="prec_", 
                                x=rasterFiles)]
precip.files &lt;- precip.files[c(1, 5:12, 2:4)]
precip.stack &lt;- terra::rast(precip.files)
precip.stack
names(precip.stack)

tmin.files &lt;- rasterFiles[grepl(pattern="tmin_", 
                                x=rasterFiles)]
tmin.files &lt;- tmin.files[c(1, 5:12, 2:4)]
tmin.stack &lt;- terra::rast(tmin.files)
tmin.stack
names(tmin.stack)

tmax.files &lt;- rasterFiles[grepl(pattern="tmax_", 
                                x=rasterFiles)]
tmax.files &lt;- tmax.files[c(1, 5:12, 2:4)]
tmax.stack &lt;- terra::rast(tmax.files)
tmax.stack
names(tmax.stack)

tmean.files &lt;- rasterFiles[grepl(pattern="tmean_", 
                                x=rasterFiles)]
tmean.files &lt;- tmean.files[c(1, 5:12, 2:4)]
tmean.stack &lt;- terra::rast(tmean.files)
tmean.stack
names(tmean.stack)

# Random locations
locs &lt;- dismo::randomPoints(raster::stack(precip.stack[[1]]), n=50)

# Climatic data
master.input &lt;- ensemble.envirem.masterstack(x=locs,
                             precipstack=precip.stack,
                             tmaxstack=tmax.stack,
                             tminstack=tmin.stack,
                             tmeanstack=tmean.stack)

# Calculate solar radiation for 1975
# (Use other midpoint for the 1970-2000 WorldClim 2.1 baseline)
solrad.stack &lt;- ETsolradRasters(precip.stack[[1]], 
                             year = 1975-1950, 
                             outputDir = NULL)

solrad.input &lt;- ensemble.envirem.solradstack(x=locs,
                             solrad=solrad.stack)

# Obtain the envirem bioclimatic data

envirem.data1 &lt;- ensemble.envirem.run(masterstack=master.input,
                             solradstack=solrad.input,
                             tempScale=10)

# Generate all the envirem layers, then extract
# See envirem package for envirem::generateEnvirem

worldclim &lt;- rast(c(precip.files, tmax.files, tmin.files, tmean.files))
names(worldclim)

assignNames(precip = 'prec_##')

# generate all possible envirem variables
envirem.stack &lt;- generateEnvirem(worldclim, solrad.stack, var='all', tempScale = 10)

# set back to defaults
assignNames(reset = TRUE)

envirem.data2 &lt;- extract(envirem.stack, y=locs)

# compare
envirem.data1 - envirem.data2

# Calculate extraterrestrial solar radiation for point observations
solrad1 &lt;- extract(solrad.stack, y=locs)
solrad2 &lt;- array(dim=c(nrow(locs), 12))
for (i in 1:nrow(locs)) {
  lat.i &lt;- locs[i, 2]
  for (m in 1:12) {
    solrad2[i, m] &lt;- envirem:::calcSolRad(year=1975-1950,
                                          lat=lat.i,
                                          month=m)
  }
}

solrad1 - solrad2


## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.evaluate'>
Model evaluation including True Skill Statistic (TSS), AUCdiff and Symmetric Extremal Dependence Index (SEDI).
</h2><span id='topic+ensemble.evaluate'></span><span id='topic+ensemble.SEDI'></span><span id='topic+ensemble.Tjur'></span>

<h3>Description</h3>

<p>The main function of <code>ensemble.evaluate</code> calculates various model evaluation statistics. Function <code>ENSEMBLE.SEDI</code> calculates the Symmetric Extremal Dependence Index (SEDI) from the True Positive Rate (TPR = Sensitivity = Hit Rate) and the False Positive Rate (FPR = False Alarm Rate = 1 - Specificity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ensemble.evaluate(eval, fixed.threshold = NULL, eval.train = NULL) 

ensemble.SEDI(TPR, FPR, small = 1e-9) 

ensemble.Tjur(eval)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.evaluate_+3A_eval">eval</code></td>
<td>
<p> ModelEvaluation object (<code><a href="dismo.html#topic+evaluate">evaluate</a></code>), ideally obtained via model testing data that were not used for calibrating the model. </p>
</td></tr>
<tr><td><code id="ensemble.evaluate_+3A_fixed.threshold">fixed.threshold</code></td>
<td>
<p> Absence-presence threshold to create the confusion matrix. See also (<code><a href="dismo.html#topic+threshold">threshold</a></code> and <code><a href="#topic+ensemble.threshold">ensemble.threshold</a></code>). </p>
</td></tr>
<tr><td><code id="ensemble.evaluate_+3A_eval.train">eval.train</code></td>
<td>
<p> ModelEvaluation object (<code><a href="dismo.html#topic+evaluate">evaluate</a></code>), ideally obtained via model calibration data that were used for calibrating the model. </p>
</td></tr>
<tr><td><code id="ensemble.evaluate_+3A_tpr">TPR</code></td>
<td>
<p> True Presence Rate, equal to correctly predicted presence observations divided by total number of presence observations. Also known as Sensitivity or Hit Rate. </p>
</td></tr>
<tr><td><code id="ensemble.evaluate_+3A_fpr">FPR</code></td>
<td>
<p> False Presence Rate, equal to wrongly predicted absence observations divided by total number of absence observations. Also known as False Alarm Rate. </p>
</td></tr>
<tr><td><code id="ensemble.evaluate_+3A_small">small</code></td>
<td>
<p> small amount that replaces zeroes in calculations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details for the True Skill Statistic (TSS = TPR + TNR - 1 = TPR - FPR), Symmetric Extremal Dependence Index (SEDI), False Negative Rate (omission or miss rate) and AUCdiff (AUCtrain - AUCtest) are available from Ferro and Stephenson (2011), Wunderlich et al. (2019) and Castellanos et al. (2019). 
</p>
<p>Tjur's (2009) coefficient of discrimination is calculated as the differences between the averages of fitted values for successes and failures (see also Erikson &amp; Smith 2023).
</p>
<p>Values for TSS and SEDI are given for the fixed absence-presence threshold, as well as their maximal values across the entire range of candidate threshold values calculate by <code><a href="dismo.html#topic+evaluate">evaluate</a></code>.
</p>
<p>In case that <code>fixed.threshold</code> is not provided, it is calculated from the calibration ModelEvaluation as the threshold that maximizes the sum of TPR (sensitivity) and TNR (specificity) (and thus also maximizes the TSS for the calibration). 
</p>


<h3>Value</h3>

<p>A numeric vector with following values.
</p>
<p>- AUC: Area Under The Curve for the testing ModelEvaluation
</p>
<p>- TSS: maximum value of the True Skill Statistic over range of threshold values
</p>
<p>- SEDI: maximum value of the Symmetric Extremal Dependence Index over range of threshold values
</p>
<p>- TSS.fixed: True Skill Statistic at the fixed threshold value
</p>
<p>- SEDI.fixed: SEDI at the fixed threshold value
</p>
<p>- FNR.fixed: False Negative Rate (= omission rate) at the fixed threshold value
</p>
<p>- MCR.fixed: Missclassification Rate at the fixed threshold value
</p>
<p>- AUCdiff: Difference between AUC for calibration and the testing data
</p>
<p>- Tjur: Coefficient of Discrimination proposed by Tjur (2009)
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Ferro CA, Stephenson DB. 2011. Extremal Dependence Indices: Improved Verification Measures for Deterministic Forecasts of Rare Binary Events. Wea. Forecasting 26: 699-713. 
</p>
<p>Wunderlich RF, Lin Y-P, Anthony J, Petway JR. 2019. Two alternative evaluation metrics to replace the true skill statistic in the assessment of species distribution models. Nature Conservation 35: 97-116. <a href="https://doi.org/10.3897/natureconservation.35.33918">doi:10.3897/natureconservation.35.33918</a>
</p>
<p>Castellanos AA, Huntley JW, Voelker G, Lawing AM. 2019. Environmental filtering improves ecological niche models across multiple scales. Methods in Ecology and Evolution 10: 481-492.
</p>
<p>Kindt R. 2018. Ensemble species distribution modelling with transformed suitability values. Environmental Modelling &amp; Software 100: 136-145. <a href="https://doi.org/10.1016/j.envsoft.2017.11.009">doi:10.1016/j.envsoft.2017.11.009</a>
</p>
<p>Tjur T. 2009. Coefficient of determination in logistic regression models - a new proposal: the coefficient of discrimination. The American Statistician 63: 366-372. <a href="https://doi.org/10.1198/tast.2009.08210">doi:10.1198/tast.2009.08210</a>
</p>
<p>Erickson KD, Smith AB. 2023. Modelling the rarest of the rare: a comparison between multi-species distribution models, ensembles of small models, and single-species models at extremely low sample sizes. Ecography e06500 <a href="https://doi.org/10.1111/ecog.06500">doi:10.1111/ecog.06500</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.batch">ensemble.batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## check examples from Ferro and Stephenson (2011)
## see their Tables 2 - 5

TPR.Table2 &lt;- 55/100
FPR.Table2 &lt;- 45/900
ensemble.SEDI(TPR=TPR.Table2, FPR=FPR.Table2)

TPR.Table4 &lt;- 195/300
FPR.Table4 &lt;- 105/700
ensemble.SEDI(TPR=TPR.Table4, FPR=FPR.Table4)

## Not run: 
## Not run: 
# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17", "biome"))
predictors
predictors@title &lt;- "predictors"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]

# the kfold function randomly assigns data to groups; 
# groups are used as calibration (1/4) and training (3/4) data
groupp &lt;- kfold(pres, 4)
pres_train &lt;- pres[groupp !=  1, ]
pres_test &lt;- pres[groupp ==  1, ]

# choose background points
background &lt;- randomPoints(predictors, n=1000, extf=1.00)
colnames(background)=c('lon', 'lat')
groupa &lt;- kfold(background, 4)
backg_train &lt;- background[groupa != 1, ]
backg_test &lt;- background[groupa == 1, ]

# formulae for random forest and generalized linear model
# compare with: ensemble.formulae(predictors, factors=c("biome"))

rfformula &lt;- as.formula(pb ~ bio5+bio6+bio16+bio17)

glmformula &lt;- as.formula(pb ~ bio5 + I(bio5^2) + I(bio5^3) + 
    bio6 + I(bio6^2) + I(bio6^3) + bio16 + I(bio16^2) + I(bio16^3) + 
    bio17 + I(bio17^2) + I(bio17^3) )

# fit four ensemble models (RF, GLM, BIOCLIM, DOMAIN)
# factors removed for BIOCLIM, DOMAIN, MAHAL
ensemble.nofactors &lt;- ensemble.calibrate.models(x=predictors, p=pres_train, a=backg_train, 
    pt=pres_test, at=backg_test,
    species.name="Bradypus",
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.min = 0.65,
    MAXENT=0, MAXNET=0, MAXLIKE=0, GBM=0, GBMSTEP=0, RF=1, CF=0, 
    GLM=1, GLMSTEP=0, GAM=0, GAMSTEP=0, MGCV=0, MGCVFIX=0, 
    EARTH=0, RPART=0, NNET=0, FDA=0, SVM=0, SVME=0, GLMNET=0,
    BIOCLIM.O=0, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=0,
    Yweights="BIOMOD",
    factors="biome",
    evaluations.keep=TRUE, models.keep=FALSE,
    RF.formula=rfformula,
    GLM.formula=glmformula)

# with option evaluations.keep, all model evaluations are saved in the ensemble object
attributes(ensemble.nofactors$evaluations)

# Get evaluation statistics for the ENSEMBLE model
eval.ENSEMBLE &lt;- ensemble.nofactors$evaluations$ENSEMBLE.T
eval.calibrate.ENSEMBLE &lt;- ensemble.nofactors$evaluations$ENSEMBLE.C
ensemble.evaluate(eval=eval.ENSEMBLE, eval.train=eval.calibrate.ENSEMBLE)

# TSS is maximum where specificity + sensitivity is maximum
threshold.specsens &lt;- threshold(eval.ENSEMBLE, stat="spec_sens")
ensemble.evaluate(eval=eval.ENSEMBLE, fixed.threshold=threshold.specsens,
    eval.train=eval.calibrate.ENSEMBLE)

# usual practice to calculate threshold from calibration data
ensemble.evaluate(eval=eval.ENSEMBLE, eval.train=eval.calibrate.ENSEMBLE)


## End(Not run)


</code></pre>

<hr>
<h2 id='ensemble.novel'>
Mapping of novel environmental conditions (areas where some of the environmental conditions are outside the range of environmental conditions of a reference area).
</h2><span id='topic+ensemble.novel'></span><span id='topic+ensemble.novel.object'></span>

<h3>Description</h3>

<p>Function <code>ensemble.novel</code> creates the map with novel conditions. Function <code>ensemble.novel.object</code> provides the reference values used by the prediction function used by <code><a href="raster.html#topic+predict">predict</a></code> . 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.novel(x = NULL, novel.object = NULL,
    RASTER.object.name = novel.object$name, RASTER.stack.name = x@title,
    RASTER.format = "GTiff", RASTER.datatype = "INT2S", RASTER.NAflag = -32767, 
    CATCH.OFF = FALSE)

ensemble.novel.object(x = NULL, name = "reference1", mask.raster = NULL,
    quantiles = FALSE, probs = c(0.05, 0.95), factors = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.novel_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all environmental layers for which novel conditions should be calculated. With <code><a href="#topic+ensemble.novel.object">ensemble.novel.object</a></code>, x can also be a data.frame.  </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_novel.object">novel.object</code></td>
<td>
<p> Object listing minima and maxima for the environmental layers, used by the prediction function that is used internally by <code><a href="raster.html#topic+predict">predict</a></code>. This object is created with <code><a href="#topic+ensemble.novel.object">ensemble.novel.object</a></code>. </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_raster.object.name">RASTER.object.name</code></td>
<td>
<p> First part of the names of the raster file that will be generated, expected to identify the area and time period for which ranges were calculated </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_raster.stack.name">RASTER.stack.name</code></td>
<td>
<p> Last part of the names of the raster file that will be generated, expected to identify the predictor stack used </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_raster.format">RASTER.format</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_raster.datatype">RASTER.datatype</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+dataType">dataType</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_raster.naflag">RASTER.NAflag</code></td>
<td>
<p> Value that is used to store missing data. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_name">name</code></td>
<td>
<p> Name of the object, expect to expected to identify the area and time period for which ranges were calculated and where no novel conditions will be detected </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_mask.raster">mask.raster</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>) that can be used to select the area for which reference values are obtained (see <code><a href="raster.html#topic+mask">mask</a></code>)  </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_quantiles">quantiles</code></td>
<td>
<p> If <code>TRUE</code>, then replace minima and maxima with quantile values. See also <code><a href="stats.html#topic+quantile">quantile</a></code> and <code><a href="raster.html#topic+quantile">quantile</a></code>)  </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_probs">probs</code></td>
<td>
<p> Numeric vector of probabilities [0, 1] as used by <code><a href="stats.html#topic+quantile">quantile</a></code> and <code><a href="raster.html#topic+quantile">quantile</a></code>)  </p>
</td></tr>
<tr><td><code id="ensemble.novel_+3A_factors">factors</code></td>
<td>
<p> vector that indicates which variables are factors; these variables will be ignored for novel conditions </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Function <code>ensemble.novel</code> maps zones (coded '1') that are novel (outside the minimum-maximum range) relative to the range provided by function <code>ensemble.novel.object</code>. Values that are not novel (inside the range of minimum-maximum values) are coded '0'. In theory, the maps show the same areas that have negative Multivariate Environmental Similarity Surface (MESS) values ((<code><a href="dismo.html#topic+mess">mess</a></code>))
</p>


<h3>Value</h3>

<p>Function <code>ensemble.novel.object</code> returns a list with following objects:
</p>
<table role = "presentation">
<tr><td><code>minima</code></td>
<td>
<p> minima of the reference environmental conditions </p>
</td></tr>
<tr><td><code>maxima</code></td>
<td>
<p> maxima of the reference environmental conditions </p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p> name for the reference area and time period </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.raster">ensemble.raster</a></code>, <code><a href="#topic+ensemble.bioclim">ensemble.bioclim</a></code> and <code><a href="#topic+ensemble.bioclim.graph">ensemble.bioclim.graph</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
predictors &lt;- subset(predictors, subset=c("bio1", "bio5", "bio6", "bio7", "bio8", 
    "bio12", "bio16", "bio17"))
predictors
predictors@title &lt;- "base"

# reference area to calculate environmental ranges
ext &lt;- extent(-70, -50, -10, 10)
extent.values2 &lt;- c(-70, -50, -10, 10)
predictors.current &lt;- crop(predictors, y=ext)
predictors.current &lt;- stack(predictors.current)

novel.test &lt;- ensemble.novel.object(predictors.current, name="noveltest")
novel.test
novel.raster &lt;- ensemble.novel(x=predictors, novel.object=novel.test)
novel.raster

plot(novel.raster)
# no novel conditions within reference area
rect(extent.values2[1], extent.values2[3], extent.values2[2], extent.values2[4])

# use novel conditions as a simple species suitability mapping method
# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]
pres.data &lt;- data.frame(extract(predictors, y=pres))

# ranges and maps
Bradypus.ranges1 &lt;- ensemble.novel.object(pres.data, name="Bradypus", quantiles=F)
Bradypus.ranges1
Bradypus.novel1 &lt;- ensemble.novel(x=predictors, novel.object=Bradypus.ranges1)
Bradypus.novel1

par.old &lt;- graphics::par(no.readonly=T)
graphics::par(mfrow=c(1,2))

# suitable where there are no novel conditions
raster::plot(Bradypus.novel1, breaks=c(-0.1, 0, 1), col=c("green", "grey"), 
    main="Suitability mapping using minimum to maximum range")
points(pres[, 2] ~ pres[, 1], pch=1, col="red", cex=0.8)

# use 90 percent intervals similar to BIOCLIM methodology
Bradypus.ranges2 &lt;- ensemble.novel.object(pres.data, name="BradypusQuantiles", quantiles=T)
Bradypus.ranges2
Bradypus.novel2 &lt;- ensemble.novel(x=predictors, novel.object=Bradypus.ranges2)
Bradypus.novel2
raster::plot(Bradypus.novel2, breaks=c(-0.1, 0, 1), col=c("green", "grey"), 
    main="Suitability mapping using quantile range")
points(pres[, 2] ~ pres[, 1], pch=1, col="red", cex=0.8)

graphics::par(par.old)

# deal with novel factor levels through dummy variables
predictors &lt;- stack(predictor.files)
biome.layer &lt;- predictors[["biome"]]
biome.layer
ensemble.dummy.variables(xcat=biome.layer, most.frequent=0, freq.min=1,
    overwrite=TRUE)

predictors.dummy &lt;- stack(predictor.files)
predictors.dummy &lt;- subset(predictors.dummy, subset=c("biome_1", "biome_2",  "biome_3",  
    "biome_4", "biome_5", "biome_7",  "biome_8",  "biome_9", 
    "biome_10", "biome_12", "biome_13", "biome_14"))
predictors.dummy
predictors.dummy@title &lt;- "base_dummy"

predictors.dummy.current &lt;- crop(predictors.dummy, y=ext)
predictors.dummy.current &lt;- stack(predictors.dummy.current)

novel.levels &lt;- ensemble.novel.object(predictors.dummy.current, name="novellevels")
novel.levels
novel.levels.raster &lt;- ensemble.novel(x=predictors.dummy, novel.object=novel.levels)
novel.levels.raster

novel.levels.quantiles &lt;- ensemble.novel.object(predictors.dummy.current, quantiles=TRUE,
    name="novellevels_quantiles")
novel.levels.quantiles
novel.levels.quantiles.raster &lt;- ensemble.novel(x=predictors.dummy, 
    novel.object=novel.levels.quantiles)
novel.levels.quantiles.raster

# difference in ranges for variables with low frequencies
background &lt;- dismo::randomPoints(predictors.dummy.current, n=10000, p=NULL, excludep=F)
extract.data &lt;- extract(predictors.dummy.current, y=background)
colSums(extract.data)/sum(extract.data)*100
novel.levels
novel.levels.quantiles

par.old &lt;- graphics::par(no.readonly=T)
graphics::par(mfrow=c(1,2))
raster::plot(novel.levels.raster, breaks=c(-0.1, 0, 1), col=c("grey", "green"), 
    main="novel outside minimum to maximum range")
rect(extent.values2[1], extent.values2[3], extent.values2[2], extent.values2[4])
raster::plot(novel.levels.quantiles.raster, breaks=c(-0.1, 0, 1), col=c("grey", "green"), 
    main="novel outside quantile range")
rect(extent.values2[1], extent.values2[3], extent.values2[2], extent.values2[4])
graphics::par(par.old)


## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.PET.season'>
Calculate the balance between precipitation and potential evapotranspiration for the dry season with the largest balance (maximum climatological water deficit, accumulated aridity).
</h2><span id='topic+ensemble.PET.season'></span>

<h3>Description</h3>

<p>Internally, the function first determines different dry seasons, defined by consecutive months where precipitation is smaller than potential evapotranspiration. The function then returns the summation of monthly balances of precipitation minus potential evapotranspiration that is largest (most negative) of the different dry seasons. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ensemble.PET.season(PREC.stack = NULL, PET.stack = NULL, 
    filename = NULL, overwrite = TRUE,
    CATCH.OFF = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.PET.season_+3A_prec.stack">PREC.stack</code></td>
<td>
<p> stack object (<code><a href="raster.html#topic+stack">stack</a></code>) with monthly precipitation values.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.season_+3A_pet.stack">PET.stack</code></td>
<td>
<p> stack object (<code><a href="raster.html#topic+stack">stack</a></code>) with monthly potential evapotranspiration values.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.season_+3A_filename">filename</code></td>
<td>
<p> Name for writing the resulting raster layer (as in <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>). </p>
</td></tr>
<tr><td><code id="ensemble.PET.season_+3A_overwrite">overwrite</code></td>
<td>
<p> Replace a previous version of the same file.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.season_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.season_+3A_...">...</code></td>
<td>
<p> Additional arguments for <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the methodology described by Chave et al. (2014), the assumption is not made that there is a single drought season. Internally, the function first identifies dry months as months where the balance of precipitation minus potential evapotranspiration is negative. Then dry seasons are identified as consecutive dry months. For each dry season, the total sum of balances is calculated. The function finally identifies and returns the largest of these balances.
</p>
<p>The algorithm of the function should obtain the same values of the Maximum Cumulative Water Deficit as from rules described by Aragao et al. 2007 (section 2.2), when using fixed monthly PET values of 100 mm instead of calculated monthly PET values (calculated, for example, from monthly mean temperatures and extraterrestrial solar radiation through the Hargreaves method).
</p>
<p>Note that calculation may take a while for larger raster data sets.
</p>


<h3>Value</h3>

<p>The function returns and writes a raster layer
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Chave J et al. 2014. Improved allometric models to estimate the aboveground biomass of tropical trees. Global Change Biology 20: 3177-3190.
</p>
<p>Aragao LZ et al. 2007. Spatial patterns and fire response of recent Amazonian droughts. Geophysical Research Letters 34 L07701
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.batch">ensemble.batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Not run: 

library(raster)
stack1 &lt;- stack(monthly.prec.files)
stack2 &lt;- stack(monthly.PET.files)
# note that the stacks should be of the same extend and resolution
ensemble.PET.season(PREC.stack=stack1, PET.stack=stack2,
    filename=paste(getwd(), '//Aridity.deficit.tif', sep=""))


## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.PET.seasons'>
Raster calculations of beginnings and lengths of growing seasons from the difference between precipitation (P) and potential evapotranspiration (PET), defining dry months with 2 * P &lt; PET.
</h2><span id='topic+ensemble.PET.seasons'></span><span id='topic+ensemble.prec.season'></span><span id='topic+ensemble.tmean.season'></span><span id='topic+ensemble.season.suitability'></span>

<h3>Description</h3>

<p>The main function of <code>ensemble.PET.seasons</code> calculates the number of growing seasons and their starts and lengths from the dry period criterion of 2 * P &lt; PET (<a href="https://www.fao.org/4/w2962e/w2962e-03.htm">https://www.fao.org/4/w2962e/w2962e-03.htm</a>). Functions <code>ensemble.PREC.season</code> and <code>ensemble.TMEAN.season</code> calculate the total precipitation and average temperature for provided starts and lengths of a growing season. Together with data on optimal and absolute precipitation and temperature limits for a selected crop (as available from FAO's ECOCROP database), these layers enable the calculation of crop suitability using methods detailed in Chapman et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ensemble.PET.seasons(PREC.stack=NULL, PET.stack=NULL, 
    index=c("seasons", "start1", "length1", "start2", "length2", "start3", "length3"),
    filename=NULL, overwrite=TRUE,
    CATCH.OFF=FALSE, ...)

ensemble.prec.season(PREC.stack=NULL, 
    start.layer=NULL, length.layer=NULL,
    filename=NULL, overwrite=TRUE,
    CATCH.OFF=FALSE, ...)

ensemble.tmean.season(TMEAN.stack=NULL, 
    start.layer=NULL, length.layer=NULL,
    filename=NULL, overwrite=TRUE,
    CATCH.OFF=FALSE, ...)

ensemble.season.suitability(season.raster=NULL, 
    thresholds=NULL,
    filename=NULL, overwrite=TRUE,
    CATCH.OFF=FALSE, ...)
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.PET.seasons_+3A_prec.stack">PREC.stack</code></td>
<td>
<p> stack object (<code><a href="raster.html#topic+stack">stack</a></code>) with monthly precipitation values.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_pet.stack">PET.stack</code></td>
<td>
<p> stack object (<code><a href="raster.html#topic+stack">stack</a></code>) with monthly potential evapotranspiration values.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_tmean.stack">TMEAN.stack</code></td>
<td>
<p> stack object (<code><a href="raster.html#topic+stack">stack</a></code>) with monthly average temperature values.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_index">index</code></td>
<td>
<p> selection of type of output - see details.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_start.layer">start.layer</code></td>
<td>
<p> raster layer with index of the month of the start of the growing season.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_length.layer">length.layer</code></td>
<td>
<p> raster layer with index of the length of the growing season.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_season.raster">season.raster</code></td>
<td>
<p> raster layer with seasonal precipitation or mean temperature.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_thresholds">thresholds</code></td>
<td>
<p> optimal and absolute thresholds of crop suitability, defined similarly as by ECOCROP.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_filename">filename</code></td>
<td>
<p> Name for writing the resulting raster layer (as in <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>). </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_overwrite">overwrite</code></td>
<td>
<p> Replace a previous version of the same file.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.PET.seasons_+3A_...">...</code></td>
<td>
<p> Additional arguments for <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ensemble.PET.seasons</code> calculates the number, starts and lengths of growing seasons after first internally determining dry periods from the criterion of 2 * P &lt; PET. The function was developed with data sets with monthly precipitatin and PET values, but probably can also work with data sets of other temporal resolution. Where there are multiple gaps between dry seasons, different growing periods are identified.
</p>
<p>The definition of dry periods is less strict than the definition of P &lt; PET used in <code>ensemble.PET.season</code>, following the methodologies for this function. 
</p>
<p>Argument <code>index</code> determines the contents of the output rasters:
- <code>seasons</code> selects the number of growing periods to be returned;
- <code>start1</code> selects the index of the start of the first or only growing period to be returned;
- <code>length1</code> selects the index of the end of the first or only growing period to be returned;
- <code>start2</code> selects the index of the start of the second growing period to be returned;
- <code>length2</code> selects the index of the end of the second growing period to be returned;
- <code>start3</code> selects the index of the start of the third growing period to be returned; and
- <code>length3</code> selects the index of the end of the third growing period to be returned.
</p>
<p>The methodology of calculating crop suitability is directly based on Chapman et al. (2020), following their equations 2 (temperature suitability, based on the mean temperature of the growing season) and 3 (precipitation suitability, based on the total precipitation of the growing season). The methods of Chapman et al. (2020) are based on Ramirez-Villegas et al. (2013), including the calculation of crop suitability as the product of temperature suitability and crop suitability (their respective equations 1 and 3).
</p>
<p>Crop thresholds are available from the FAO ECOCROP database, which are also available via function <code><a href="dismo.html#topic+getCrop">getCrop</a></code>.
</p>
<p>Note that calculations can take a while for larger data sets.
</p>


<h3>Value</h3>

<p>The function returns and writes raster layers.
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Ramirez-Villegas J, Jarvis A and Laderach P. 2013. Empirical approaches for assessing impacts of climate change on agriculture: The EcoCrop model and a case study with grain sorghum. Agricultural and Forest Meteorology <a href="https://doi.org/10.1016/j.agrformet.2011.09.005">doi:10.1016/j.agrformet.2011.09.005</a>
</p>
<p>Chapman et al. 2020. Impact of climate change on crop suitability in sub-Saharan Africa in parameterized and convection-permitting regional climate models. Environmental Research Letters 15:094086.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.PET.season">ensemble.PET.season</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Not run: 

library(raster)
P.stack &lt;- stack(monthly.prec.files)
PE.stack &lt;- stack(monthly.PET.files)

# Calculate average monthly values similarly as in 
TMIN.stack &lt;- stack(monthly.tmin.files)
TMAX.stack &lt;- stack(monthly.tmax.files)
T.stack &lt;- stack(0.5*(TMIN.stack + TMAX.stack))

# step 1: determine number of seasons, start and length of season 1

seasons.raster &lt;- ensemble.PET.seasons(PREC.stack=P.stack, PET.stack=PE.stack, 
    index="seasons", filename="seasons.tif", CATCH.OFF=TRUE)

start1.raster &lt;- ensemble.PET.seasons(PREC.stack=P.stack, PET.stack=PE.stack, 
    index="start1", filename="start1.tif", CATCH.OFF=TRUE)

length1.raster &lt;- ensemble.PET.seasons(PREC.stack=P.stack, PET.stack=PE.stack, 
    index="length1", filename="length1.tif", CATCH.OFF=TRUE)

start2.raster &lt;- ensemble.PET.seasons(PREC.stack=P.stack, PET.stack=PE.stack, 
    index="start2", filename="start2.tif", CATCH.OFF=TRUE)

length2.raster &lt;- ensemble.PET.seasons(PREC.stack=P.stack, PET.stack=PE.stack, 
    index="length2", filename="length2.tif", CATCH.OFF=TRUE)

# step 2: calculate total precipitation in first rainy season,
# then use this value to calculate precipitation suitability

prec.season &lt;- ensemble.prec.season(PREC.stack=P.stack, 
    start.layer=start1.raster, length.layer=length1.raster, 
    filename="precSeason.tif", CATCH.OFF=FALSE)  

dismo::getCrop("Sorghum (med. altitude)")

prec.suit &lt;- ensemble.season.suitability(season.raster=prec.season, 
    thresholds=c(300, 500, 1000, 3000), 
    filename="precSuitability.tif", CATCH.OFF=FALSE)  

# step 3: calculate average temperature in first rainy season,
# then use this value to calculate temperature suitability

tmean.season &lt;- ensemble.tmean.season(TMEAN.stack=T.stack, 
    start.layer=start1.raster, length.layer=length1.raster, 
    filename="tmeanSeason.tif", CATCH.OFF=FALSE) 

temp.suit &lt;- ensemble.season.suitability(season.raster=tmean.season, 
    thresholds=c(10, 24, 35, 40), 
    filename="tempSuitability.tif", CATCH.OFF=FALSE) 
    
# step 4: seasonal crop suitability is product of precipitation suitability
# and temperature suitability
    
sorghum.suit &lt;- prec.suit * temp.suit
plot(sorghum.suit)


## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.raster'>
Suitability mapping based on ensembles of modelling algorithms: consensus mapping
</h2><span id='topic+ensemble.raster'></span><span id='topic+ensemble.habitat.change'></span><span id='topic+ensemble.area'></span>

<h3>Description</h3>

<p>The basic function <code>ensemble.raster</code> creates two consensus raster layers, one based on a (weighted) average of different suitability modelling algorithms, and a second one documenting the number of modelling algorithms that predict presence of the focal organisms. Modelling algorithms include maximum entropy (MAXENT), boosted regression trees, random forests, generalized linear models (including stepwise selection of explanatory variables), generalized additive models (including stepwise selection of explanatory variables), multivariate adaptive regression splines, regression trees, artificial neural networks, flexible discriminant analysis, support vector machines, the BIOCLIM algorithm, the DOMAIN algorithm and the Mahalonobis algorithm. These sets of functions were developed in parallel with the <code>biomod2</code> package, especially for inclusion of the maximum entropy algorithm, but also to allow for a more direct integration with the BiodiversityR package, more direct handling of model formulae and greater focus on mapping. Researchers and students of species distribution are strongly encouraged to familiarize themselves with all the options of the <code>biomod2</code> and <code>dismo</code> packages. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.raster(xn = NULL, 
    models.list = NULL, 
    input.weights = models.list$output.weights,
    thresholds = models.list$thresholds,
    RASTER.species.name = models.list$species.name, 
    RASTER.stack.name = xn@title, 
    RASTER.format = "GTiff", RASTER.datatype = "INT2S", RASTER.NAflag = -32767,
    RASTER.models.overwrite = TRUE,
    evaluate = FALSE, SINK = FALSE,
    p = models.list$p, a = models.list$a,
    pt = models.list$pt, at = models.list$at,
    CATCH.OFF = FALSE)

ensemble.habitat.change(base.map = file.choose(), 
    other.maps = utils::choose.files(),
    change.folder = "ensembles/change",
    RASTER.names = "changes",
    RASTER.format = "GTiff", RASTER.datatype = "INT1U", RASTER.NAflag = 255)

ensemble.area(x=NULL, km2=TRUE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.raster_+3A_xn">xn</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all layers that correspond to explanatory variables of an ensemble calibrated earlier with <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code>. See also <code><a href="raster.html#topic+predict">predict</a></code>.   </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_models.list">models.list</code></td>
<td>
<p> list with 'old' model objects such as <code>MAXENT</code> or <code>RF</code>. </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_input.weights">input.weights</code></td>
<td>
<p> array with numeric values for the different modelling algorithms; if <code>NULL</code> then values provided by parameters such as <code>MAXENT</code> and <code>GBM</code> will be used. As an alternative, the output from <code>ensemble.calibrate.weights</code> can be used. </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_thresholds">thresholds</code></td>
<td>
<p> array with the threshold values separating predicted presence for each of the algorithms. </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_raster.species.name">RASTER.species.name</code></td>
<td>
<p> First part of the names of the raster files that will be generated, expected to identify the modelled species (or organism). </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_raster.stack.name">RASTER.stack.name</code></td>
<td>
<p> Last part of the names of the raster files that will be generated, expected to identify the predictor stack used. </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_raster.format">RASTER.format</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_raster.datatype">RASTER.datatype</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+dataType">dataType</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_raster.naflag">RASTER.NAflag</code></td>
<td>
<p> Value that is used to store missing data. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_raster.models.overwrite">RASTER.models.overwrite</code></td>
<td>
<p> Overwrite the raster files that correspond to each suitability modelling algorithm (if <code>TRUE</code>). (Overwriting actually implies that raster files are created or overwritten that start with &quot;working_&quot;).  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_evaluate">evaluate</code></td>
<td>
<p> if <code>TRUE</code>, then evaluate the created raster layers at locations <code>p</code>, <code>a</code>, <code>pt</code> and <code>at</code> (if provided). See also <code><a href="dismo.html#topic+evaluate">evaluate</a></code> </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_sink">SINK</code></td>
<td>
<p> Append the results to a text file in subfolder 'outputs' (if <code>TRUE</code>). The name of file is based on argument <code>RASTER.species.name</code>. In case the file already exists, then results are appended. See also <code><a href="base.html#topic+sink">sink</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_p">p</code></td>
<td>
<p> presence points used for calibrating the suitability models, typically available in 2-column (x, y) or (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_a">a</code></td>
<td>
<p> background points used for calibrating the suitability models, typically available in 2-column (x, y) or (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_pt">pt</code></td>
<td>
<p> presence points used for evaluating the suitability models, typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_at">at</code></td>
<td>
<p> background points used for calibrating the suitability models, typicall available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_base.map">base.map</code></td>
<td>
<p> filename with baseline map used to produce maps that show changes in suitable habitat </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_other.maps">other.maps</code></td>
<td>
<p> files with other maps used to produce maps that show changes in suitable habitat from a defined base.map  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_change.folder">change.folder</code></td>
<td>
<p> folder where new maps documenting changes in suitable habitat will be stored. NOTE: please ensure that the base folder (eg: ../ensembles) exists already.  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_raster.names">RASTER.names</code></td>
<td>
<p> names for the files in the change.folder (previously set as names of the other maps).  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_x">x</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>) in a longitude-latitude coordinate system  </p>
</td></tr>
<tr><td><code id="ensemble.raster_+3A_km2">km2</code></td>
<td>
<p> Provide results in square km rather than square m. See also <code><a href="geosphere.html#topic+areaPolygon">areaPolygon</a></code>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic function <code>ensemble.raster</code> fits individual suitability models for all models with positive input weights. In subfolder &quot;models&quot; of the working directory, suitability maps for the individual suitability modelling algorithms are stored. In subfolder &quot;ensembles&quot;, a consensus suitability map based on a weighted average of individual suitability models is stored. In subfolder &quot;ensembles/presence&quot;, a presence-absence (1-0) map will be provided. In subfolder &quot;ensembles/count&quot;, a consensus suitability map based on the number of individual suitability models that predict presence of the focal organism is stored.
</p>
<p>Note that values in suitability maps are integer values that were calculated by multiplying probabilities by 1000 (see also <code><a href="base.html#topic+trunc">trunc</a></code>).
</p>
<p>The <code>ensemble.habitat.change</code> function produces new raster layers that show changes in suitable and not suitable habitat between a base raster and a list of other rasters. The output uses the following coding: 0 = areas that remain unsuitable, 11 = areas that remain suitable, 10 = areas of lost habitat, 1 = areas of new habitat. (Codes are inspired on a binary classification of habitat suitability in base [1- or 0-] and other layer [-1 or -0], eg new habitat is coded 01 = 1).
</p>
<p>The <code>ensemble.area</code> function calculates the area of different categories with <code><a href="geosphere.html#topic+areaPolygon">areaPolygon</a></code>
</p>


<h3>Value</h3>

<p>The basic function <code>ensemble.raster</code> mainly results in the creation of raster layers that correspond to fitted probabilities of presence of individual suitability models (in folder &quot;models&quot;) and consensus models (in folder &quot;ensembles&quot;), and the number of suitability models that predict presence (in folder &quot;ensembles&quot;). Prediction of presence is based on a threshold usually defined by maximizing the sum of the true presence and true absence rates (see <code>threshold.method</code> and also <code><a href="dismo.html#topic+ModelEvaluation">ModelEvaluation</a></code>).
</p>
<p>If desired by the user, the <code>ensemble.raster</code> function also saves details of fitted suitability models or data that can be plotted with the <code><a href="#topic+evaluation.strip.plot">evaluation.strip.plot</a></code> function.
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre), Eike Luedeling (World Agroforestry Centre) and Evert Thomas (Bioversity International) </p>


<h3>References</h3>

<p>Kindt R. 2018. Ensemble species distribution modelling with transformed suitability values. Environmental Modelling &amp; Software 100: 136-145. <a href="https://doi.org/10.1016/j.envsoft.2017.11.009">doi:10.1016/j.envsoft.2017.11.009</a>
</p>
<p>Buisson L, Thuiller W, Casajus N, Lek S and Grenouillet G. 2010. Uncertainty in ensemble forecasting of species distribution. Global Change Biology 16: 1145-1157
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluation.strip.plot">evaluation.strip.plot</a></code>, <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code>, <code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code>, <code><a href="#topic+ensemble.batch">ensemble.batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# based on examples in the dismo package

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17"))
predictors
predictors@title &lt;- "base"

# presence points
# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]

# choose background points
background &lt;- randomPoints(predictors, n=1000, extf = 1.00)

# if desired, change working directory where subfolders of "models" and 
# "ensembles" will be created
# raster layers will be saved in subfolders of /models and /ensembles:
getwd()

# first calibrate the ensemble
# calibration is done in two steps
# in step 1, a k-fold procedure is used to determine the weights
# in step 2, models are calibrated for all presence and background locations
# factor is not used as it is not certain whether correct levels will be used
# it may therefore be better to use dummy variables

# step 1: determine weights through 4-fold cross-validation
ensemble.calibrate.step1 &lt;- ensemble.calibrate.weights(
    x=predictors, p=pres, a=background, k=4, 
    SINK=TRUE, species.name="Bradypus",
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=1, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, GLMNET=1,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    ENSEMBLE.tune=TRUE, PROBIT=TRUE,
    ENSEMBLE.best=0, ENSEMBLE.exponent=c(1, 2, 3),
    ENSEMBLE.min=c(0.65, 0.7),
    Yweights="BIOMOD",
    PLOTS=FALSE, formulae.defaults=TRUE)

# step 1 generated the weights for each algorithm
model.weights &lt;- ensemble.calibrate.step1$output.weights
x.batch &lt;- ensemble.calibrate.step1$x
p.batch &lt;- ensemble.calibrate.step1$p
a.batch &lt;- ensemble.calibrate.step1$a
MAXENT.a.batch &lt;- ensemble.calibrate.step1$MAXENT.a
factors.batch &lt;- ensemble.calibrate.step1$factors
dummy.vars.batch &lt;- ensemble.calibrate.step1$dummy.vars

# step 2: calibrate models with all available presence locations
# weights determined in step 1 calculate ensemble in step 2
ensemble.calibrate.step2 &lt;- ensemble.calibrate.models(
    x=x.batch, p=p.batch, a=a.batch, MAXENT.a=MAXENT.a.batch, 
    factors=factors.batch, dummy.vars=dummy.vars.batch, 
    SINK=TRUE, species.name="Bradypus",
    models.keep=TRUE,
    input.weights=model.weights,
    ENSEMBLE.tune=FALSE, PROBIT=TRUE,
    Yweights="BIOMOD",
    PLOTS=FALSE, formulae.defaults=TRUE)

# step 3: use previously calibrated models to create ensemble raster layers
# re-evaluate the created maps at presence and background locations
# (note that re-evaluation will be different due to truncation of raster layers
# as they wered saved as integer values ranged 0 to 1000)
ensemble.raster.results &lt;- ensemble.raster(xn=predictors, 
    models.list=ensemble.calibrate.step2$models, 
    input.weights=model.weights,
    SINK=TRUE, evaluate=TRUE,
    RASTER.species.name="Bradypus", RASTER.stack.name="base")

# use the base map to check for changes in suitable habitat
# this type of analysis is typically done with different predictor layers
# (for example, predictor layers representing different possible future climates)
# In this example, changes from a previous model (ensemble.raster.results)
# are contrasted with a newly calibrated model (ensemble.raster.results2)
# step 1: 4-fold cross-validation
ensemble.calibrate2.step1 &lt;- ensemble.calibrate.weights(
    x=x.batch, p=p.batch, a=a.batch, MAXENT.a=MAXENT.a.batch, 
    factors=factors.batch, dummy.vars=dummy.vars.batch, 
    k=4, 
    SINK=TRUE, species.name="Bradypus",
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=1, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, GLMNET=1,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    ENSEMBLE.tune=TRUE, PROBIT=TRUE,
    ENSEMBLE.best=0, ENSEMBLE.exponent=c(1, 2, 3),
    ENSEMBLE.min=c(0.65, 0.7),
    Yweights="BIOMOD",
    PLOTS=FALSE, formulae.defaults=TRUE)

model.weights2 &lt;- ensemble.calibrate2.step1$output.weights

ensemble.calibrate2.step2 &lt;- ensemble.calibrate.models(
    x=x.batch, p=p.batch, a=a.batch, MAXENT.a=MAXENT.a.batch, 
    factors=factors.batch, dummy.vars=dummy.vars.batch, 
    SINK=TRUE, species.name="Bradypus",
    models.keep=TRUE,
    input.weights=model.weights2,
    ENSEMBLE.tune=FALSE, PROBIT=TRUE,
    Yweights="BIOMOD",
    PLOTS=FALSE, formulae.defaults=TRUE)

ensemble.raster.results2 &lt;- ensemble.raster(
    xn=predictors, 
    models.list=ensemble.calibrate2.step2$models, 
    input.weights=model.weights2,
    SINK=TRUE, evaluate=TRUE,
    RASTER.species.name="Bradypus", RASTER.stack.name="recalibrated")

base.file &lt;- paste(getwd(), "/ensembles/presence/Bradypus_base.tif", sep="")
other.file &lt;- paste(getwd(), "/ensembles/presence/Bradypus_recalibrated.tif", sep="")

changed.habitat &lt;- ensemble.habitat.change(base.map=base.file, 
    other.maps=c(other.file),
    change.folder="ensembles/change",
    RASTER.names="Bradypus_recalibrated")

change.file &lt;- paste(getwd(), "/ensembles/change/Bradypus_recalibrated.tif", sep="")

par.old &lt;- graphics::par(no.readonly=T)
dev.new()
par(mfrow=c(2,2))
raster::plot(raster(base.file), breaks=c(-1, 0, 1), col=c("grey", "green"), 
    legend.shrink=0.8, main="base presence")
raster::plot(raster(other.file), breaks=c(-1, 0, 1), col=c("grey", "green"), 
    legend.shrink=0.8, main="other presence")
raster::plot(raster(change.file), breaks=c(-1, 0, 1, 10, 11), 
    col=c("grey", "blue", "red", "green"), 
    legend.shrink=0.8, main="habitat change", sub="11 remaining, 10 lost, 1 new")
graphics::par(par.old)

areas &lt;- ensemble.area(raster(change.file))
areas

## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.red'>
Area of Occupancy (AOO) and Extent of Occurrence (EOO) via the <span class="pkg">red</span> library.
</h2><span id='topic+ensemble.red'></span><span id='topic+ensemble.chull.create'></span><span id='topic+ensemble.chull.apply'></span><span id='topic+ensemble.chull.buffer.distances'></span><span id='topic+ensemble.chull.MSDM'></span>

<h3>Description</h3>

<p>Function <code>ensemble.red</code> is a wrapper function for estimation of AOO and EOO computed for redlisting of species based on IUCN criteria (<a href="https://www.iucnredlist.org/about/regional">https://www.iucnredlist.org/about/regional</a>). Function <code>ensemble.chull.create</code> creates a mask layer based on a convex hull around known presence locations, inspired by <code>mcp</code> argument of the <code><a href="red.html#topic+map.sdm">map.sdm</a></code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ensemble.red(x)

ensemble.chull.create(x.pres = NULL, p = NULL, buffer.width = 0.2,
    buffer.maxmins = FALSE, lonlat.dist = FALSE,
    poly.only = FALSE,
    RASTER.format = "GTiff", RASTER.datatype = "INT1U", RASTER.NAflag = 255,
    overwrite = TRUE, ...)

ensemble.chull.apply(x.spec = NULL, mask.layer=NULL, keep.old=T,
    RASTER.format="GTiff", RASTER.datatype="INT1U", RASTER.NAflag = 255,
    overwrite=TRUE, ...)

ensemble.chull.buffer.distances(p = NULL, 
    buffer.maxmins = FALSE, lonlat.dist = FALSE)

ensemble.chull.MSDM(p = NULL, a = NULL, species.name = NULL,
    suit.file = NULL, suit.divide = 1000, MSDM.dir = NULL,
    method = "BMCP", threshold = "spec_sens", 
    buffer = "species_specific")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.red_+3A_x">x</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>), representing 'count' suitability layers (available from the 'count' and 'consensuscount' subdirectories of the 'ensembles' directory)  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_x.pres">x.pres</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>), representing 'presence' suitability layers (available from the 'presence' and 'consensuspresence' subdirectories of the 'ensembles' directory)  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_p">p</code></td>
<td>
<p> known presence locations, available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_buffer.width">buffer.width</code></td>
<td>
<p> multiplier to create buffer (via <code><a href="sf.html#topic+st_buffer">st_buffer</a></code>) by multiplying the maximum distance among the presence locations (calculated via <code><a href="raster.html#topic+pointDistance">pointDistance</a></code>)  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_buffer.maxmins">buffer.maxmins</code></td>
<td>
<p> Calculate the buffer width based on the two neighbouring locations that are furthest apart (maximum of minimum distances from each location).  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_lonlat.dist">lonlat.dist</code></td>
<td>
<p> Estimate the distance in km for longitude latitude data.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_poly.only">poly.only</code></td>
<td>
<p> Only return the polygon with the convex hull, but do not create the mask layer.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_raster.format">RASTER.format</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_raster.datatype">RASTER.datatype</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+dataType">dataType</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_raster.naflag">RASTER.NAflag</code></td>
<td>
<p> Value that is used to store missing data. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_overwrite">overwrite</code></td>
<td>
<p> Overwrite existing raster files. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_...">...</code></td>
<td>
<p> Additional arguments for <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_x.spec">x.spec</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>), representing any suitability layer for the species under investigation)  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_mask.layer">mask.layer</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>), representing the mask based on the convex hull around known presence locations. The function will replace all values in <code>x.spec</code> to zero where corresponding values in the mask.layer are zero.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_keep.old">keep.old</code></td>
<td>
<p> keep a copy of the RasterLayer before the mask is applied.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_a">a</code></td>
<td>
<p> absence of background locations, available in 2-column (lon, lat) dataframe.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_species.name">species.name</code></td>
<td>
<p> name of the species, ideally without spaces.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_suit.file">suit.file</code></td>
<td>
<p> file with raster data corresponding to suitability values of the focal species.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_suit.divide">suit.divide</code></td>
<td>
<p> number by which values in the suitability raster should be divided to result in probabilities (BiodiversityR saves data as 1000 * suitability, hence these values need to be divided by 1000).  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_msdm.dir">MSDM.dir</code></td>
<td>
<p> name of the directory where input and processed raster files will be saved.  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_method">method</code></td>
<td>
<p> method for MSDM_Posteriori function from c(&quot;OBR&quot;, &quot;PRES&quot;, &quot;LQ&quot;, &quot;MCP&quot;, &quot;BMCP&quot;).  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_threshold">threshold</code></td>
<td>
<p> threshold for MSDM_Posteriori function from c(&quot;kappa&quot;, &quot;spec_sens&quot;, &quot;no_omission&quot;, &quot;prevalence&quot;, &quot;equal_sens_spec&quot;,
&quot;sensitivty&quot;).  </p>
</td></tr>
<tr><td><code id="ensemble.red_+3A_buffer">buffer</code></td>
<td>
<p> buffer for MSDM_Posteriori function.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ensemble.red</code> calculates AOO (<code><a href="red.html#topic+aoo">aoo</a></code>) and EOO (<code><a href="red.html#topic+aoo">aoo</a></code>) statistics calculated for areas with different consensus levels on species presence (1 model predicting presence, 2 models predicting presence, ...). In case that these statistics are within IUCN criteria for Critically Endangered (CR), Endangered (EN) or Vulnerable (VU), then this information is added in columns documenting the types of AOO and EOO.
</p>
<p>Function <code>ensemble.chull.create</code> first creates a convex hull around known presence locations. Next, a buffer is created around the convex hull where the width of this buffer is calculated as the maximum distance among presence locations (<code><a href="raster.html#topic+pointDistance">pointDistance</a></code>) multiplied by argument <code>buffer.width</code>. Finally, the mask is created by including all polygons of predicted species presence that are partially covered by the convex hull and its buffer.
</p>


<h3>Value</h3>

<p>Function <code>ensemble.red</code> returns an array with AOO and EOO 
Function <code>ensemble.chull.create</code> creates a mask layer based on a convex hull around known presence locations.
Function <code>ensemble.chull.MSDM</code> prepares the input data and script for the MSDM_Posteriori function of the MSDM package.
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Cardoso P. 2017. red - an R package to facilitate species red list assessments according to the IUCN criteria. Biodiversity Data Journal 5:e20530. <a href="https://doi.org/10.3897/BDJ.5.e20530">doi:10.3897/BDJ.5.e20530</a>
</p>
<p>Mendes, P.; Velazco S.J.E.; Andrade, A.F.A.; De Marco, P. (2020) Dealing with overprediction in species distribution models: how adding distance constraints can improve model accuracy, Ecological Modelling, in press. <a href="https://doi.org/10.1016/j.ecolmodel.2020.109180">doi:10.1016/j.ecolmodel.2020.109180</a>
</p>
<p>Kindt R. 2018. Ensemble species distribution modelling with transformed suitability values. Environmental Modelling &amp; Software 100: 136-145. <a href="https://doi.org/10.1016/j.envsoft.2017.11.009">doi:10.1016/j.envsoft.2017.11.009</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.batch">ensemble.batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Not run: 
# based on examples in the dismo package

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17"))
predictors
predictors@title &lt;- "red"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')

# fit 4 ensemble models (could take some time!)
# (examples for the red package use 100 models)
ensembles &lt;- ensemble.batch(x=predictors, 
    xn=c(predictors),
    species.presence=pres, 
    thin.km=100,
    k.splits=4, k.test=0, 
    n.ensembles=4, 
    SINK=TRUE, 
    ENSEMBLE.best=10, ENSEMBLE.exponent=c(1, 2, 3), 
    ENSEMBLE.min=0.6,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=0,
    GLM=0, GLMSTEP=1, GAM=1, GAMSTEP=0, MGCV=1, MGCVFIX=0, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, 
    BIOCLIM.O=0, BIOCLIM=1, DOMAIN=0, MAHAL=0, MAHAL01=0,
    PROBIT=TRUE,
    Yweights="BIOMOD",
    formulae.defaults=TRUE)

# first application of ensemble.red before applying the convex hull mask
# AOO and EOO are determined for each count level
library(red)
count.file &lt;- paste(getwd(), 
    "/ensembles/consensuscount/Bradypus variegatus_red.tif", sep="")
count.raster &lt;- raster(count.file)
ensemble.red(count.raster)

# do not predict presence in polygons completely outside convex hull
# of known presence locations
pres.file &lt;- paste(getwd(), 
    "/ensembles/consensuspresence/Bradypus variegatus_red.tif", sep="")
pres.raster &lt;- raster(pres.file)
pres1 &lt;- pres[, -1]
chull.created &lt;- ensemble.chull.create(x.pres=pres.raster, p=pres1)

mask.raster &lt;- chull.created$mask.layer
plot(mask.raster, col=c("black", "green"))
mask.poly &lt;- chull.created$convex.hull

pres.chull &lt;- ensemble.chull.apply(pres.raster, mask=mask.raster, keep.old=T)

par.old &lt;- graphics::par(no.readonly=T)
par(mfrow=c(1,2))
plot(pres.raster, breaks=c(-1, 0, 1), col=c("grey", "green"),
    main="before convex hull")
points(pres1, col="blue")

# load new
pres.file.new &lt;- paste(getwd(), 
    "/ensembles/chull/Bradypus variegatus_red.tif", sep="")
pres.raster.new &lt;- raster(pres.file.new)
plot(pres.raster.new, breaks=c(-1, 0, 1), col=c("grey", "green"),
    main="after convex hull")
plot(mask.poly, add=T, border="blue")

# create a smaller hull (0.05 * largest distance)
chull.created &lt;- ensemble.chull.create(x.pres=pres.raster, p=pres1, 
    buffer.width=0.05, lonlat.dist=TRUE)
mask.raster &lt;- chull.created$mask.layer
mask.poly &lt;- chull.created$convex.hull
pres.chull &lt;- ensemble.chull.apply(pres.raster, mask=mask.raster, keep.old=T)

par(mfrow=c(1,2))
plot(pres.raster, breaks=c(-1, 0, 1), col=c("grey", "green"),
    main="before convex hull")
points(pres1, col="blue")
pres.raster.new &lt;- raster(pres.file.new)
plot(pres.raster.new, breaks=c(-1, 0, 1), col=c("grey", "green"),
    main="after convex hull")
plot(mask.poly, add=T, border="blue")

# create a hull based on the distance to the location with the farthest neighbour
chull.created &lt;- ensemble.chull.create(x.pres=pres.raster, p=pres1, 
    buffer.maxmins=TRUE, buffer.width=0.9, lonlat.dist=TRUE)
mask.raster &lt;- chull.created$mask.layer
mask.poly &lt;- chull.created$convex.hull
pres.chull &lt;- ensemble.chull.apply(pres.raster, mask=mask.raster, keep.old=T)

par(mfrow=c(1,2))
plot(pres.raster, breaks=c(-1, 0, 1), col=c("grey", "green"),
    main="before convex hull")
points(pres1, col="blue")
pres.raster.new &lt;- raster(pres.file.new)
plot(pres.raster.new, breaks=c(-1, 0, 1), col=c("grey", "green"),
    main="after convex hull")
plot(mask.poly, add=T, border="blue")

par.old &lt;- graphics::par(no.readonly=T)

# how distances were derived
# maximum distance between observations
ensemble.chull.buffer.distances(pres1, lonlat.dist=TRUE)   
# the closest neigbhour that is farthest away from each observation
# this is the distance calculated by MSDM_posteriori for buffer="species_specific"
ensemble.chull.buffer.distances(pres1, buffer.maxmins=TRUE, lonlat.dist=TRUE) 


## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.spatialBlock'>
Spatially or environmentally separated folds for cross-validation via blockCV::spatialBlock or blockCV::envBlock
</h2><span id='topic+ensemble.spatialBlock'></span><span id='topic+ensemble.envBlock'></span>

<h3>Description</h3>

<p>The functions internally calls blockCV::spatialBlock and blockCV::envBlock. Syntax is very similar to that of BiodiversityR::ensemble.calibrate.weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.spatialBlock(x = NULL, p = NULL, 
    a = NULL, an = 1000, EPSG=NULL,
    excludep = FALSE, target.groups = FALSE, k = 4,
    factors = NULL,
    theRange = NULL, return.object = FALSE, ...)

ensemble.envBlock(x = NULL, p = NULL, 
    a = NULL, an = 1000, EPSG=NULL,
    excludep = FALSE, target.groups = FALSE, k = 4,
    factors = NULL,
    return.object = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.spatialBlock_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all layers that correspond to explanatory variables  </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_p">p</code></td>
<td>
<p> presence points used for calibrating the suitability models, typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_a">a</code></td>
<td>
<p> background points used for calibrating the suitability models, typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_an">an</code></td>
<td>
<p> number of background points for calibration to be selected with <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> in case argument <code>a</code> is missing</p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_epsg">EPSG</code></td>
<td>
<p> EPSG number (see https://spatialreference.org/) to be assigned internally to the coordinate reference system of the locations via <code><a href="sf.html#topic+st_crs">st_crs</a></code>. Although the function internally first assigns the coordinate reference from the RasterStack <code>x</code> via <code><a href="raster.html#topic+crs">crs</a></code>, this method fails in some situations as in the example shown below. In such cases, manually assigning the EPSG could resolve this problem. </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_excludep">excludep</code></td>
<td>
<p> parameter that indicates (if <code>TRUE</code>) that presence points will be excluded from the background points; see also <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_target.groups">target.groups</code></td>
<td>
<p> Parameter that indicates (if <code>TRUE</code>) that the provided background points (argument <code>a</code>) represent presence points from a target group sensu Phillips et al. 2009 (these are species that are all collected or observed using the same methods or equipment). Setting the parameter to <code>TRUE</code> results in selecting the centres of cells of the target groups as background points, while avoiding to select the same cells twice. Via argument <code>excludep</code>, it is possible to filter out cells with presence observations (argument <code>p</code>).  </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_k">k</code></td>
<td>
<p> Integer value. The number of desired folds for cross-validation. The default is <code>k = 4</code>. The interpretation of the argument is exactly the same as in <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code> and <code><a href="dismo.html#topic+kfold">kfold</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_factors">factors</code></td>
<td>
<p> vector that indicates which variables are factors; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_therange">theRange</code></td>
<td>
<p> Numeric value of the specified range by which blocks are created and training/testing data are separated. This distance should be in metres. See also <code><a href="blockCV.html#topic+spatialBlock">spatialBlock</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_return.object">return.object</code></td>
<td>
<p> If <code>TRUE</code>, then also return ('block.object') the complete result of <code><a href="blockCV.html#topic+spatialBlock">spatialBlock</a></code> or <code><a href="blockCV.html#topic+envBlock">envBlock</a></code>. In addtion (if <code>TRUE</code>), return the species data ('speciesData') that was created for <code>blockCV</code>. To visualize these results, see below or from <code><a href="blockCV.html#topic+foldExplorer">foldExplorer</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialBlock_+3A_...">...</code></td>
<td>
<p> Other arguments to pass to <code><a href="blockCV.html#topic+spatialBlock">spatialBlock</a></code> or <code><a href="blockCV.html#topic+envBlock">envBlock</a></code>, such <code>numLimit</code> (The minimum number of points in each fold for training-presence, training-absence, testing-presence and testing-absence) and <code>iteration</code> (The number of attempts to create folds that fulfil the <code>numLimit</code> requirement).   </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions internally call <code><a href="blockCV.html#topic+spatialBlock">spatialBlock</a></code> or <code><a href="blockCV.html#topic+envBlock">envBlock</a></code>. 
</p>
<p>The result of the function includes a list (<code>k</code>) with following elements. This list can be directly imported into <code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code>, but only elements <code>groupp</code> and <code>groupa</code> will be used.
</p>
<p>- <code>p</code> : Presence locations, created by <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code> where points with missing data were excluded and possibly points were added for missing factor levels 
</p>
<p>- <code>a</code> : Background locations, created by <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code> where points with missing data were excluded and possibly points were added for missing factor levels 
</p>
<p>- <code>groupp</code> : k-fold identities for the presence locations
</p>
<p>- <code>groupa</code> : k-fold identities for the background locations
</p>
<p>Optionally the function also returns elements <code>block.object</code> and <code>speciesData</code>. These can be used to visualize data with <code><a href="blockCV.html#topic+foldExplorer">foldExplorer</a></code>.
</p>


<h3>Value</h3>

<p>The function returns a list with the following elements:. 
</p>
<table role = "presentation">
<tr><td><code>k</code></td>
<td>
<p> A list with data on folds that can be directly used by <code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code>. </p>
</td></tr>
<tr><td><code>block.object</code></td>
<td>
<p> the results of <code><a href="blockCV.html#topic+spatialBlock">spatialBlock</a></code> or <code><a href="blockCV.html#topic+envBlock">envBlock</a></code> </p>
</td></tr>
<tr><td><code>speciesData</code></td>
<td>
<p> a <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> with species data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) </p>


<h3>References</h3>

<p>Roberts et al., 2017. Cross-validation strategies for data with temporal, spatial, hierarchical, or phylogenetic structure. Ecography. 40: 913-929. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(blockCV)
library(sf)

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17"))
predictors
predictors@title &lt;- "base"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[, -1]

# choose background points
background &lt;- randomPoints(predictors, n=1000, p=pres, excludep=T, extf=1.00)
background &lt;- data.frame(background)
colnames(background)=c('lon', 'lat')

# spatial blocking with square blocks of 1000 km and minimum 20 points in each categor
# fails if EPSG is not assigned
block.data &lt;- ensemble.spatialBlock(x=predictors, p=pres, a=background, 
    EPSG=NULL,
    showBlocks=F, theRange=1000000, k=4, numLimit=20, iteration=1000, return.object=T)

block.data &lt;- ensemble.spatialBlock(x=predictors, p=pres, a=background, 
    EPSG=4326,
    showBlocks=F, theRange=1000000, k=4, numLimit=20, iteration=1000, return.object=T)

# explore the results
foldExplorer(blocks=block.data$block.object, rasterLayer=predictors, 
    speciesData=block.data$speciesData)

# apply in calibration of ensemble weights
# make sure that folds apply to subset of points
p.spatial &lt;- block.data$k$p 
a.spatial &lt;- block.data$k$a
k.spatial &lt;- block.data$k

ensemble.w1 &lt;- ensemble.calibrate.weights(x=predictors, 
    p=p.spatial, a=a.spatial, k=k.spatial, 
    species.name="Bradypus",
    SINK=FALSE, PROBIT=TRUE,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=0, CF=1,
    GLM=1, GLMSTEP=0, GAM=1, GAMSTEP=0, MGCV=0, MGCVFIX=0, 
    EARTH=0, RPART=0, NNET=1, FDA=0, SVM=0, SVME=0, GLMNET=0,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=0, MAHAL=0, MAHAL01=0,
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.best=0, ENSEMBLE.exponent=c(1, 2, 3),
    ENSEMBLE.min=0.7,
    Yweights="BIOMOD", 
    formulae.defaults=TRUE)

# confirm that correct folds were used
all.equal(ensemble.w1$groupp, block.data$k$groupp)
all.equal(ensemble.w1$groupa, block.data$k$groupa)

# environmental blocking with minimum 5 points in each category
block.data2 &lt;- ensemble.envBlock(x=predictors, p=pres, a=background, 
    factors="biome",
    k=4, numLimit=5, return.object=T)

# explore the results
foldExplorer(blocks=block.data2$block.object, rasterLayer=predictors, 
    speciesData=block.data2$speciesData)

# apply in calibration of ensemble weights
# make sure that folds apply to subset of points
p.env &lt;- block.data2$k$p 
a.env &lt;- block.data2$k$a
k.env &lt;- block.data2$k

ensemble.w2 &lt;- ensemble.calibrate.weights(x=predictors, 
    p=p.env, a=a.env, k=k.env, 
    species.name="Bradypus",
    SINK=FALSE, PROBIT=TRUE,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=0, CF=1,
    GLM=1, GLMSTEP=0, GAM=1, GAMSTEP=0, MGCV=0, MGCVFIX=0, 
    EARTH=0, RPART=0, NNET=1, FDA=0, SVM=0, SVME=0, GLMNET=0,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=0, MAHAL=0, MAHAL01=0,
    ENSEMBLE.tune=TRUE,
    ENSEMBLE.best=0, ENSEMBLE.exponent=c(1, 2, 3),
    ENSEMBLE.min=0.7,
    factors="biome",
    Yweights="BIOMOD", 
    formulae.defaults=TRUE)

# confirm that correct folds were used
all.equal(ensemble.w2$groupp, block.data2$k$groupp)
all.equal(ensemble.w2$groupa, block.data2$k$groupa)


## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.spatialThin'>
Thinning of presence point coordinates in geographical or environmental space
</h2><span id='topic+ensemble.spatialThin'></span><span id='topic+ensemble.spatialThin.quant'></span><span id='topic+ensemble.environmentalThin'></span><span id='topic+ensemble.environmentalThin.clara'></span><span id='topic+ensemble.outlierThin'></span>

<h3>Description</h3>

<p>Function <code>ensemble.spatialThin</code> creates a randomly selected subset of point coordinates where the shortest distance (geodesic) is above a predefined minimum. The geodesic is calculated more accurately (via <code><a href="geosphere.html#topic+distGeo">distGeo</a></code>) than in the <code>spThin</code> or <code>red</code> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.spatialThin(x, thin.km = 0.1, 
    runs = 100, silent = FALSE, verbose = FALSE, 
    return.notRetained = FALSE)

ensemble.spatialThin.quant(x, thin.km = 0.1, 
    runs = 100, silent = FALSE, verbose = FALSE, 
    LON.length = 21, LAT.length = 21)

ensemble.environmentalThin(x, predictors.stack = NULL, 
    extracted.data=NULL, thin.n = 50,
    runs = 100, pca.var = 0.95, silent = FALSE, verbose = FALSE,
    return.notRetained = FALSE)

ensemble.environmentalThin.clara(x, predictors.stack = NULL, thin.n = 20,
    runs = 100, pca.var = 0.95, silent = FALSE, verbose = FALSE,
    clara.k = 100)

ensemble.outlierThin(x, predictors.stack = NULL, k = 10,
    quant = 0.95, pca.var = 0.95, 
    return.outliers = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.spatialThin_+3A_x">x</code></td>
<td>
<p> Point locations provided in 2-column (lon, lat) format.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_thin.km">thin.km</code></td>
<td>
<p> Threshold for minimum distance (km) in final point location data set.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_runs">runs</code></td>
<td>
<p> Number of runs to maximize the retained number of point coordinates.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_silent">silent</code></td>
<td>
<p> Do not provide any details on the process.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_verbose">verbose</code></td>
<td>
<p> Provide some details on each run.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_return.notretained">return.notRetained</code></td>
<td>
<p> Return in an additional data set the point coordinates that were thinned out.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_lon.length">LON.length</code></td>
<td>
<p> Number of quantile limits to be calculated from longitudes; see also <code><a href="stats.html#topic+quantile">quantile</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_lat.length">LAT.length</code></td>
<td>
<p> Number of quantile limits to be calculated from latitudes; see also <code><a href="stats.html#topic+quantile">quantile</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_predictors.stack">predictors.stack</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing environmental layers that define the environmental space of point observations.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_extracted.data">extracted.data</code></td>
<td>
<p> Data set with the environmental data at the point locations. If this data is provided, then this data will be used in the analysis and data will not be extracted from the predictors.stack.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_thin.n">thin.n</code></td>
<td>
<p> Target number of environmentally thinned points.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_pca.var">pca.var</code></td>
<td>
<p> Minimum number of axes based on the fraction of variance explained (default value of 0.95 indicates that at least 95 percent of variance will be explained on the selected number of axes). Axes and coordinates are obtained from Principal Components Analysis (<code><a href="vegan.html#topic+scores">scores</a></code>).  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_clara.k">clara.k</code></td>
<td>
<p> The number of clusters in which the point coordinates will be divided by <code><a href="cluster.html#topic+clara">clara</a></code>. Clustering is done in environmental space with point coordinates determined from Principal Components Analysis.  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_k">k</code></td>
<td>
<p> The number of neighbours for the Local Outlier Factor analysis; see <code><a href="Rlof.html#topic+lof">lof</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_quant">quant</code></td>
<td>
<p> The quantile probability above with local outlier factors are classified as outliers; see also <code><a href="stats.html#topic+quantile">quantile</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.spatialThin_+3A_return.outliers">return.outliers</code></td>
<td>
<p> Return in an additional data set the point coordinates that were flagged as outliers.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locations with distances smaller than the threshold distance are randomly removed from the data set until no distance is smaller than the threshold. The function uses a similar algorithm as functions in the <code>spThin</code> or <code>red</code> packages, but the geodesic is more accurately calculated via <code><a href="geosphere.html#topic+distGeo">distGeo</a></code>.
</p>
<p>With several runs (default of 100 as in the <code>red</code> package or some <code>spThin</code> examples), the (first) data set with the maximum number of records is retained.
</p>
<p>Function <code>ensemble.spatialThin.quant</code> was designed to be used with large data sets where the size of the object with pairwise geographical distances could create memory problems. With this function, spatial thinning is only done within geographical areas defined by quantile limits of geographical coordinates.
</p>
<p>Function <code>ensemble.environmentalThin</code> performs an analysis in environmental space similar to the analysis in geographical space by <code>ensemble.spatialThin</code>. However, the target number of retained point coordinates needs to be defined by the user. Coordinates are obtained in environmental space by a principal components analysis (function <code><a href="vegan.html#topic+rda">rda</a></code>). Internally, first points are randomly selected from the pair with the smallest environmental distance until the selected target number of retained point coordinates is reached. From the retained point coordinates, the minimum environmental distance is determined. In a second step (more similar to spatial thinning), locations are randomly removed from all pairs that have a distance larger than the minimum distance calculated in step 1.
</p>
<p>Function <code>ensemble.environmentalThin.clara</code> was designed to be used with large data sets where the size of the object with pairwise environmental distances could create memory problems. With this function, environmental thinning is done sequentially for each of the clusters defined by <code><a href="cluster.html#topic+clara">clara</a></code>. Environmental space is obtained by by a principal components analysis (function <code><a href="vegan.html#topic+rda">rda</a></code>). Environmental distances are calculated as the pairwise Euclidean distances between the point locations in the environmental space.
</p>
<p>Function <code>ensemble.outlierThin</code> selects point coordinates that are less likely to be local outliers based on a Local Outlier Factor analysis (<code><a href="Rlof.html#topic+lof">lof</a></code>). Since LOF does not result in strict classification of outliers, a user-defined quantile probability is used to identify outliers.
</p>


<h3>Value</h3>

<p>The function returns a spatially or environmentally thinned point location data set. 
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) </p>


<h3>References</h3>

<p>Aiello-Lammens ME, Boria RA, Radosavljevic A, Vilela B and Anderson RP. 2015. spThin: an R package for spatial thinning of species occurrence records for use in ecological niche models. Ecography 38: 541-545
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.batch">ensemble.batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get predictor variables, only needed for plotting
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17", "biome"))
predictors
predictors@title &lt;- "base"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[, -1]

# number of locations
nrow(pres)

par.old &lt;- graphics::par(no.readonly=T)
par(mfrow=c(2,2))

pres.thin1 &lt;- ensemble.spatialThin(pres, thin.km=100, runs=10, verbose=T)
plot(predictors[[1]], main="5 runs", ext=extent(SpatialPoints(pres.thin1)))
points(pres, pch=20, col="black")
points(pres.thin1, pch=20, col="red")

pres.thin2 &lt;- ensemble.spatialThin(pres, thin.km=100, runs=10, verbose=T)
plot(predictors[[1]], main="5 runs (after fresh start)", ext=extent(SpatialPoints(pres.thin2)))
points(pres, pch=20, col="black")
points(pres.thin2, pch=20, col="red")

pres.thin3 &lt;- ensemble.spatialThin(pres, thin.km=100, runs=100, verbose=T)
plot(predictors[[1]], main="100 runs", ext=extent(SpatialPoints(pres.thin3)))
points(pres, pch=20, col="black")
points(pres.thin3, pch=20, col="red")

pres.thin4 &lt;- ensemble.spatialThin(pres, thin.km=100, runs=100, verbose=T)
plot(predictors[[1]], main="100 runs (after fresh start)", ext=extent(SpatialPoints(pres.thin4)))
points(pres, pch=20, col="black")
points(pres.thin4, pch=20, col="red")

graphics::par(par.old)

## thinning in environmental space

env.thin &lt;- ensemble.environmentalThin(pres, predictors.stack=predictors, thin.n=60,
    return.notRetained=T)
pres.env1 &lt;- env.thin$retained
pres.env2 &lt;- env.thin$not.retained

# plot in geographical space
par.old &lt;- graphics::par(no.readonly=T)
par(mfrow=c(1, 2))

plot(predictors[[1]], main="black = not retained", ext=extent(SpatialPoints(pres.thin3)))
points(pres.env2, pch=20, col="black")
points(pres.env1, pch=20, col="red")

# plot in environmental space
background.data &lt;- data.frame(raster::extract(predictors, pres))
rda.result &lt;- vegan::rda(X=background.data, scale=T)
# select number of axes
ax &lt;- 2
while ( (sum(vegan::eigenvals(rda.result)[c(1:ax)])/
    sum(vegan::eigenvals(rda.result))) &lt; 0.95 ) {ax &lt;- ax+1}
rda.scores &lt;- data.frame(vegan::scores(rda.result, display="sites", scaling=1, choices=c(1:ax)))
rownames(rda.scores) &lt;- rownames(pres)
points.in &lt;- rda.scores[which(rownames(rda.scores) %in% rownames(pres.env1)), c(1:2)]
points.out &lt;- rda.scores[which(rownames(rda.scores) %in% rownames(pres.env2)), c(1:2)]
plot(points.out, main="black = not retained", pch=20, col="black", 
    xlim=range(rda.scores[, 1]), ylim=range(rda.scores[, 2]))
points(points.in, pch=20, col="red")

graphics::par(par.old)

## removing outliers
out.thin &lt;- ensemble.outlierThin(pres, predictors.stack=predictors, k=10,
    return.outliers=T)
pres.out1 &lt;- out.thin$inliers
pres.out2 &lt;- out.thin$outliers

# plot in geographical space
par.old &lt;- graphics::par(no.readonly=T)
par(mfrow=c(1, 2))

plot(predictors[[1]], main="black = outliers", ext=extent(SpatialPoints(pres.thin3)))
points(pres.out2, pch=20, col="black")
points(pres.out1, pch=20, col="red")

# plot in environmental space
background.data &lt;- data.frame(raster::extract(predictors, pres))
rda.result &lt;- vegan::rda(X=background.data, scale=T)
# select number of axes
ax &lt;- 2
while ( (sum(vegan::eigenvals(rda.result)[c(1:ax)])/
    sum(vegan::eigenvals(rda.result))) &lt; 0.95 ) {ax &lt;- ax+1}
rda.scores &lt;- data.frame(vegan::scores(rda.result, display="sites", scaling=1, choices=c(1:ax)))
rownames(rda.scores) &lt;- rownames(pres)
points.in &lt;- rda.scores[which(rownames(rda.scores) %in% rownames(pres.out1)), c(1:2)]
points.out &lt;- rda.scores[which(rownames(rda.scores) %in% rownames(pres.out2)), c(1:2)]
plot(points.out, main="black = outliers", pch=20, col="black", 
    xlim=range(rda.scores[, 1]), ylim=range(rda.scores[, 2]))
points(points.in, pch=20, col="red")

graphics::par(par.old)


## End(Not run)

</code></pre>

<hr>
<h2 id='ensemble.terra'>
Suitability mapping based on ensembles of modelling algorithms: consensus mapping via the terra package
</h2><span id='topic+ensemble.terra'></span>

<h3>Description</h3>

<p>The function <code>ensemble.terra</code> creates two consensus raster layers, one based on a (weighted) average of different suitability modelling algorithms, and a second one documenting the number of modelling algorithms that predict presence of the focal organisms. This function has the same behaviour as <code><a href="#topic+ensemble.raster">ensemble.raster</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.terra(xn = NULL, 
    models.list = NULL, 
    input.weights = models.list$output.weights,
    thresholds = models.list$thresholds,
    RASTER.species.name = models.list$species.name, 
    RASTER.stack.name = "xnTitle", 
    RASTER.filetype = "GTiff", RASTER.datatype = "INT2S", RASTER.NAflag = -32767,
    RASTER.models.overwrite = TRUE,
    evaluate = FALSE, SINK = FALSE,
    p = models.list$p, a = models.list$a,
    pt = models.list$pt, at = models.list$at,
    CATCH.OFF = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.terra_+3A_xn">xn</code></td>
<td>
<p> SpatRaster object (<code><a href="terra.html#topic+rast">rast</a></code>) containing all layers that correspond to explanatory variables of an ensemble calibrated earlier with <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code>. See also <code><a href="terra.html#topic+predict">predict</a></code>.   </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_models.list">models.list</code></td>
<td>
<p> list with 'old' model objects such as <code>MAXENT</code> or <code>RF</code>. </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_input.weights">input.weights</code></td>
<td>
<p> array with numeric values for the different modelling algorithms; if <code>NULL</code> then values provided by parameters such as <code>MAXENT</code> and <code>GBM</code> will be used. As an alternative, the output from <code>ensemble.calibrate.weights</code> can be used. </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_thresholds">thresholds</code></td>
<td>
<p> array with the threshold values separating predicted presence for each of the algorithms. </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_raster.species.name">RASTER.species.name</code></td>
<td>
<p> First part of the names of the raster files that will be generated, expected to identify the modelled species (or organism). </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_raster.stack.name">RASTER.stack.name</code></td>
<td>
<p> Last part of the names of the raster files that will be generated, expected to identify the predictor stack used. </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_raster.filetype">RASTER.filetype</code></td>
<td>
<p> Format of the raster files that will be generated. See  <code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_raster.datatype">RASTER.datatype</code></td>
<td>
<p> Format of the raster files that will be generated. See  <code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_raster.naflag">RASTER.NAflag</code></td>
<td>
<p> Value that is used to store missing data. See <code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_raster.models.overwrite">RASTER.models.overwrite</code></td>
<td>
<p> Overwrite the raster files that correspond to each suitability modelling algorithm (if <code>TRUE</code>). (Overwriting actually implies that raster files are created or overwritten that start with &quot;working_&quot;).  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_evaluate">evaluate</code></td>
<td>
<p> if <code>TRUE</code>, then evaluate the created raster layers at locations <code>p</code>, <code>a</code>, <code>pt</code> and <code>at</code> (if provided). See also <code><a href="dismo.html#topic+evaluate">evaluate</a></code> </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_sink">SINK</code></td>
<td>
<p> Append the results to a text file in subfolder 'outputs' (if <code>TRUE</code>). The name of file is based on argument <code>RASTER.species.name</code>. In case the file already exists, then results are appended. See also <code><a href="base.html#topic+sink">sink</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_p">p</code></td>
<td>
<p> presence points used for calibrating the suitability models, typically available in 2-column (x, y) or (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_a">a</code></td>
<td>
<p> background points used for calibrating the suitability models, typically available in 2-column (x, y) or (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_pt">pt</code></td>
<td>
<p> presence points used for evaluating the suitability models, typically available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_at">at</code></td>
<td>
<p> background points used for calibrating the suitability models, typicall available in 2-column (lon, lat) dataframe; see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.terra_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic function <code>ensemble.terra</code> fits individual suitability models for all models with positive input weights. In subfolder &quot;models&quot; of the working directory, suitability maps for the individual suitability modelling algorithms are stored. In subfolder &quot;ensembles&quot;, a consensus suitability map based on a weighted average of individual suitability models is stored. In subfolder &quot;ensembles/presence&quot;, a presence-absence (1-0) map will be provided. In subfolder &quot;ensembles/count&quot;, a consensus suitability map based on the number of individual suitability models that predict presence of the focal organism is stored.
</p>
<p>Note that values in suitability maps are integer values that were calculated by multiplying probabilities by 1000 (see also <code><a href="base.html#topic+trunc">trunc</a></code>).
</p>


<h3>Value</h3>

<p>The basic function <code>ensemble.terra</code> mainly results in the creation of raster layers that correspond to fitted probabilities of presence of individual suitability models (in folder &quot;models&quot;) and consensus models (in folder &quot;ensembles&quot;), and the number of suitability models that predict presence (in folder &quot;ensembles&quot;). Prediction of presence is based on a threshold usually defined by maximizing the sum of the true presence and true absence rates (see <code>threshold.method</code> and also <code><a href="dismo.html#topic+ModelEvaluation">ModelEvaluation</a></code>).
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt R. 2018. Ensemble species distribution modelling with transformed suitability values. Environmental Modelling &amp; Software 100: 136-145. <a href="https://doi.org/10.1016/j.envsoft.2017.11.009">doi:10.1016/j.envsoft.2017.11.009</a>
</p>
<p>Buisson L, Thuiller W, Casajus N, Lek S and Grenouillet G. 2010. Uncertainty in ensemble forecasting of species distribution. Global Change Biology 16: 1145-1157
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.raster">ensemble.raster</a></code>,
<code><a href="#topic+evaluation.strip.plot">evaluation.strip.plot</a></code>, <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code>, <code><a href="#topic+ensemble.calibrate.weights">ensemble.calibrate.weights</a></code>, <code><a href="#topic+ensemble.batch">ensemble.batch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# based on examples in the dismo package

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17"))
predictors
predictors@title &lt;- "base"

# make a SpatRaster object
# Ideally this should not be created from files in the 'raster' grd format
# (so a better method would be to create instead from 'tif' files).

predictors.terra &lt;- terra::rast(predictors)
# predictors@title &lt;- "base"
crs(predictors.terra) &lt;- c("+proj=longlat +datum=WGS84")
predictors.terra

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]

# choose background points
background &lt;- dismo::randomPoints(predictors, n=1000, extf = 1.00)

# if desired, change working directory where subfolders of "models" and 
# "ensembles" will be created
# raster layers will be saved in subfolders of /models and /ensembles:
getwd()

# first calibrate the ensemble
# calibration is done in two steps
# in step 1, a k-fold procedure is used to determine the weights
# in step 2, models are calibrated for all presence and background locations

# Although a spatRaster (predictors.terra) object is used as input for 
# ensemble.calibrate.weights and ensemble.calibrate.models,
# internally the spatRaster will be converted to a rasterStack for these
# functions (among other things, to allow for dismo::prepareData)

# step 1: determine weights through 4-fold cross-validation
ensemble.calibrate.step1 &lt;- ensemble.calibrate.weights(
    x=predictors.terra, p=pres, a=background, k=4, 
    SINK=TRUE, species.name="Bradypus",
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=1, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, GLMNET=1,
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    ENSEMBLE.tune=TRUE, PROBIT=TRUE,
    ENSEMBLE.best=0, ENSEMBLE.exponent=c(1, 2, 3),
    ENSEMBLE.min=c(0.65, 0.7),
    Yweights="BIOMOD",
    PLOTS=FALSE, formulae.defaults=TRUE)

# step 1 generated the weights for each algorithm
model.weights &lt;- ensemble.calibrate.step1$output.weights
x.batch &lt;- ensemble.calibrate.step1$x
p.batch &lt;- ensemble.calibrate.step1$p
a.batch &lt;- ensemble.calibrate.step1$a
MAXENT.a.batch &lt;- ensemble.calibrate.step1$MAXENT.a
factors.batch &lt;- ensemble.calibrate.step1$factors
dummy.vars.batch &lt;- ensemble.calibrate.step1$dummy.vars

# step 2: calibrate models with all available presence locations
# weights determined in step 1 calculate ensemble in step 2
ensemble.calibrate.step2 &lt;- ensemble.calibrate.models(
    x=x.batch, p=p.batch, a=a.batch, MAXENT.a=MAXENT.a.batch, 
    factors=factors.batch, dummy.vars=dummy.vars.batch, 
    SINK=TRUE, species.name="Bradypus",
    models.keep=TRUE,
    input.weights=model.weights,
    ENSEMBLE.tune=FALSE, PROBIT=TRUE,
    Yweights="BIOMOD",
    PLOTS=FALSE, formulae.defaults=TRUE)

# step 3: use previously calibrated models to create ensemble raster layers
# re-evaluate the created maps at presence and background locations
# (note that re-evaluation will be different due to truncation of raster layers
# as they wered saved as integer values ranged 0 to 1000)
ensemble.terra.results &lt;- ensemble.terra(xn=predictors.terra, 
    models.list=ensemble.calibrate.step2$models, 
    input.weights=model.weights,
    SINK=TRUE, evaluate=TRUE,
    RASTER.species.name="Bradypus", RASTER.stack.name="base")


## End(Not run)
</code></pre>

<hr>
<h2 id='ensemble.zones'>
Mapping of environmental zones based on the Mahalanobis distance from centroids in environmental space.
</h2><span id='topic+ensemble.zones'></span><span id='topic+ensemble.centroids'></span>

<h3>Description</h3>

<p>Function <code>ensemble.zones</code> maps the zone of each raster cell within a presence map based on the minimum Mahalanobis distance (via <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>) to different centroids. Function <code>ensemble.centroids</code> defines centroids within a presence map based on Principal Components Analysis (via <code><a href="vegan.html#topic+rda">rda</a></code>) and K-means clustering (via <code><a href="stats.html#topic+kmeans">kmeans</a></code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble.zones(presence.raster = NULL, centroid.object = NULL, 
    x = NULL, ext = NULL,
    RASTER.species.name = centroid.object$name, RASTER.stack.name = x@title, 
    RASTER.format = "GTiff", RASTER.datatype = "INT2S", RASTER.NAflag = -32767, 
    CATCH.OFF = FALSE)

ensemble.centroids(presence.raster = NULL, x = NULL, categories.raster = NULL,
    an = 10000, ext = NULL, name = "Species001", 
    pca.var = 0.95, centers = 0, use.silhouette = TRUE, 
    plotit = FALSE, dev.new.width = 7, dev.new.height = 7)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.zones_+3A_presence.raster">presence.raster</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>) documenting presence (coded 1) of an organism </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_centroid.object">centroid.object</code></td>
<td>
<p> Object listing values for centroids and covariance to be used with the <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code> distance (used internally by the prediction function called from <code><a href="raster.html#topic+predict">predict</a></code>). </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_x">x</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all environmental layers that correspond to explanatory variables </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_ext">ext</code></td>
<td>
<p> an Extent object to limit the predictions and selection of background points to a sub-region of <code>presence.raster</code> and <code>x</code>, typically provided as c(lonmin, lonmax, latmin, latmax). See also <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> and <code><a href="raster.html#topic+extent">extent</a></code>. </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_raster.species.name">RASTER.species.name</code></td>
<td>
<p> First part of the names of the raster file that will be generated, expected to identify the modelled species (or organism) </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_raster.stack.name">RASTER.stack.name</code></td>
<td>
<p> Last part of the names of the raster file that will be generated, expected to identify the predictor stack used </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_raster.format">RASTER.format</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+writeFormats">writeFormats</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_raster.datatype">RASTER.datatype</code></td>
<td>
<p> Format of the raster files that will be generated. See <code><a href="raster.html#topic+dataType">dataType</a></code> and <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_raster.naflag">RASTER.NAflag</code></td>
<td>
<p> Value that is used to store missing data. See <code><a href="raster.html#topic+writeRaster">writeRaster</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_categories.raster">categories.raster</code></td>
<td>
<p> RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>) documenting predefined zones such as vegetation types. In case this object is provided, then centroids will be calculated for each zone. </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_an">an</code></td>
<td>
<p> Number of presence points to be used for Principal Components Analysis (via <code><a href="vegan.html#topic+rda">rda</a></code>); see also <code><a href="dismo.html#topic+prepareData">prepareData</a></code> and <code><a href="raster.html#topic+extract">extract</a></code>  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_name">name</code></td>
<td>
<p> Name for the centroid object, for example identifying the species and area for which centroids are calculated </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_pca.var">pca.var</code></td>
<td>
<p> Minimum number of axes based on the fraction of variance explained (default value of 0.95 indicates that at least 95 percent of variance will be explained on the selected number of axes). Axes and coordinates are obtained from Principal Components Analysis (<code><a href="vegan.html#topic+scores">scores</a></code>).  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_centers">centers</code></td>
<td>
<p> Number of centers (clusters) to be used for K-means clustering (<code><a href="stats.html#topic+kmeans">kmeans</a></code>). In case a value smaller than 1 is provided, function <code><a href="vegan.html#topic+cascadeKM">cascadeKM</a></code> is called to determine the optimal number of centers via the Calinski-Harabasz criterion.  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_use.silhouette">use.silhouette</code></td>
<td>
<p> If <code>TRUE</code>, then centroid values are only based on presence points that have silhouette values (<code><a href="cluster.html#topic+silhouette">silhouette</a></code>) larger than 0.  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_plotit">plotit</code></td>
<td>
<p> If <code>TRUE</code>, then a plot is provided that shows the locations of centroids in geographical and environmental space. Plotting in geographical space is based on determination of the presence location (analogue) with smallest Mahalanobis distance to the centroid in environmental space.  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_dev.new.width">dev.new.width</code></td>
<td>
<p> Width for new graphics device (<code><a href="grDevices.html#topic+dev.new">dev.new</a></code>). If &lt; 0, then no new graphics device is opened.  </p>
</td></tr>
<tr><td><code id="ensemble.zones_+3A_dev.new.height">dev.new.height</code></td>
<td>
<p> Heigth for new graphics device (<code><a href="grDevices.html#topic+dev.new">dev.new</a></code>). If &lt; 0, then no new graphics device is opened.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ensemble.zones</code> maps the zone of each raster cell of a predefined presence map, whereby the zone is defined as the centroid with the smallest Mahalanobis distance. The function returns a RasterLayer object (<code><a href="raster.html#topic+raster">raster</a></code>) and possibly a KML layer.
</p>
<p>Function <code>ensemble.centroid</code> provides the centroid locations in environmental space and a covariance matrix (<code><a href="stats.html#topic+cov">cov</a></code>) to be used with <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>. Also provided is information on the analogue presence location that is closest to the centroid in environmental space. 
</p>


<h3>Value</h3>

<p>Function <code>ensemble.centroid</code> returns a list with following objects:
</p>
<table role = "presentation">
<tr><td><code>centroids</code></td>
<td>
<p> Location of centroids in environmental space </p>
</td></tr>
<tr><td><code>centroid.analogs</code></td>
<td>
<p> Location of best analogs to centroids in environmental space </p>
</td></tr>
<tr><td><code>cov.mahal</code></td>
<td>
<p> Covariance matrix </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre)</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.raster">ensemble.raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
predictors &lt;- subset(predictors, subset=c("bio1", "bio5", "bio6", "bio7", "bio8", 
    "bio12", "bio16", "bio17"))
predictors
predictors@title &lt;- "base"

# choose background points
background &lt;- randomPoints(predictors, n=1000, extf=1.00)

# predicted presence from GLM
ensemble.calibrate.step1 &lt;- ensemble.calibrate.models(
    x=predictors, p=pres, a=background,
    species.name="Bradypus",
    MAXENT=0, MAXLIKE=0, MAXNET=0, CF=0, 
    GBM=0, GBMSTEP=0, RF=0, GLM=1, GLMSTEP=0, 
    GAM=0, GAMSTEP=0, MGCV=0, MGCVFIX=0,
    EARTH=0, RPART=0, NNET=0, FDA=0, SVM=0, SVME=0, GLMNET=0,
    BIOCLIM.O=0, BIOCLIM=0, DOMAIN=0, MAHAL=0, MAHAL01=0,
    Yweights="BIOMOD",
    models.keep=TRUE)

ensemble.raster.results &lt;- ensemble.raster(xn=predictors, 
    models.list=ensemble.calibrate.step1$models, 
    RASTER.species.name="Bradypus", RASTER.stack.name="base")

# get presence map as for example created with ensemble.raster in subfolder 'ensemble/presence'
# presence values are values equal to 1
presence.file &lt;- paste("ensembles//presence//Bradypus_base.tif", sep="")
presence.raster &lt;- raster(presence.file)

# let cascadeKM decide on the number of clusters
dev.new()
centroids &lt;- ensemble.centroids(presence.raster=presence.raster, 
    x=predictors, an=1000, plotit=T)
ensemble.zones(presence.raster=presence.raster, centroid.object=centroids, 
    x=predictors, RASTER.species.name="Bradypus")

dev.new()
zones.file &lt;- paste("ensembles//zones//Bradypus_base.tif", sep="")
zones.raster &lt;- raster(zones.file)
max.zones &lt;- maxValue(zones.raster)
plot(zones.raster, breaks=c(0, c(1:max.zones)), 
    col = grDevices::rainbow(n=max.zones), main="zones")
ensemble.zones(presence.raster=presence.raster, centroid.object=centroids, 
    x=predictors, RASTER.species.name="Bradypus")

# manually choose 6 zones
dev.new()
centroids6 &lt;- ensemble.centroids(presence.raster=presence.raster, 
    x=predictors, an=1000, plotit=T, centers=6)
ensemble.zones(presence.raster=presence.raster, centroid.object=centroids6, 
    x=predictors, RASTER.species.name="Bradypus6")

dev.new()
zones.file &lt;- paste("ensembles//zones//Bradypus6_base.tif", sep="")
zones.raster &lt;- raster(zones.file)
max.zones &lt;- maxValue(zones.raster)
plot(zones.raster, breaks=c(0, c(1:max.zones)), 
    col = grDevices::rainbow(n=max.zones), main="six zones")


## End(Not run)
</code></pre>

<hr>
<h2 id='evaluation.strip.data'>Evaluation strips for ensemble suitability mapping</h2><span id='topic+evaluation.strip.data'></span><span id='topic+evaluation.strip.plot'></span>

<h3>Description</h3>

<p>These functions provide a dataframe which can subsequently be used to evaluate the relationship between environmental variables and the fitted probability of occurrence of individual or ensemble suitability modelling algorithms. The <code>biomod2</code> package provides an alternative implementation of this approach (<code>response.plot2</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluation.strip.data(xn = NULL, ext = NULL,
    models.list = NULL, 
    input.weights = models.list$output.weights,
    steps=200, CATCH.OFF = FALSE
)

evaluation.strip.plot(data, TrainData=NULL,
    variable.focal = NULL, model.focal = NULL,
    ylim=c(0, 1.25),  
    dev.new.width = 7, dev.new.height = 7, ...
)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluation.strip.data_+3A_xn">xn</code></td>
<td>
<p> RasterStack object (<code><a href="raster.html#topic+stack">stack</a></code>) containing all layers that correspond to explanatory variables of an ensemble calibrated earlier with <code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code>. See also <code><a href="raster.html#topic+predict">predict</a></code>.   </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_ext">ext</code></td>
<td>
<p> an Extent object to limit the prediction to a sub-region of <code>xn</code> and the selection of background points to a sub-region of <code>x</code>, typically provided as c(lonmin, lonmax, latmin, latmax); see also <code><a href="raster.html#topic+predict">predict</a></code>, <code><a href="dismo.html#topic+randomPoints">randomPoints</a></code> and <code><a href="raster.html#topic+extent">extent</a></code> </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_models.list">models.list</code></td>
<td>
<p> list with 'old' model objects such as <code>MAXENT</code> or <code>RF</code>. </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_input.weights">input.weights</code></td>
<td>
<p> array with numeric values for the different modelling algorithms; if <code>NULL</code> then values provided by parameters such as <code>MAXENT</code> and <code>GBM</code> will be used. As an alternative, the output from <code>ensemble.calibrate.weights</code> can be used. </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_steps">steps</code></td>
<td>
<p> number of steps within the range of a continuous explanatory variable </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_catch.off">CATCH.OFF</code></td>
<td>
<p> Disable calls to function <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.  </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_data">data</code></td>
<td>
<p> data set with ranges of environmental variables and fitted suitability models, typically returned by <code>evaluation.strip.data</code> </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_traindata">TrainData</code></td>
<td>
<p> Data set representing the calibration data set. If provided, then a boxplot will be added for presence locations via <code><a href="graphics.html#topic+boxplot">boxplot</a></code> </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_variable.focal">variable.focal</code></td>
<td>
<p> focal explanatory variable for plots with evaluation strips </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_model.focal">model.focal</code></td>
<td>
<p> focal model for plots with evaluation strips </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_ylim">ylim</code></td>
<td>
<p> range of Y-axis </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_dev.new.width">dev.new.width</code></td>
<td>
<p> Width for new graphics device (<code><a href="grDevices.html#topic+dev.new">dev.new</a></code>). If &lt; 0, then no new graphics device is opened.  </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_dev.new.height">dev.new.height</code></td>
<td>
<p> Heigth for new graphics device (<code><a href="grDevices.html#topic+dev.new">dev.new</a></code>). If &lt; 0, then no new graphics device is opened.  </p>
</td></tr>
<tr><td><code id="evaluation.strip.data_+3A_...">...</code></td>
<td>
<p> Other arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are mainly intended to be used internally by the ensemble.raster function.
</p>
<p><code>evaluation.strip.data</code> creates a data frame with variables (columns) corresponding to the environmental variables encountered in the RasterStack object (<code>x</code>) and the suitability modelling approaches that were defined. The variable of <code>focal.var</code> is an index of the variable for which values are ranged. The variable of <code>categorical</code> is an index for categorical (factor) variables.
</p>
<p>A continuous (numeric) variable is ranged between its minimum and maximum values in the number of steps defined by argument <code>steps</code>. When a continuous variable is not the focal variable, then the average (<code><a href="base.html#topic+mean">mean</a></code>) is used.
</p>
<p>A categorical (factor) variable is ranged for all the encountered levels (<code><a href="base.html#topic+levels">levels</a></code>) for this variable. When a categorical variable is not the focal variable, then the most frequent level is used.
</p>


<h3>Value</h3>

<p>function <code>evaluation.strip.data</code> creates a data frame, function <code>evaluation.strip.data</code> allows for plotting. 
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry Centre) </p>


<h3>References</h3>

<p>Kindt R. 2018. Ensemble species distribution modelling with transformed suitability values. Environmental Modelling &amp; Software 100: 136-145. <a href="https://doi.org/10.1016/j.envsoft.2017.11.009">doi:10.1016/j.envsoft.2017.11.009</a>
</p>
<p>Elith J, Ferrier S, Huettmann F &amp; Leathwick J. 2005. The evaluation strip: A new and robust method for plotting predicted responses from species distribution models. Ecological Modelling 186: 280-289 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble.calibrate.models">ensemble.calibrate.models</a></code> and <code><a href="#topic+ensemble.raster">ensemble.raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# get predictor variables
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- stack(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17"))
predictors &lt;- stack(predictors)
predictors
predictors@title &lt;- "base"

# presence points
presence_file &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
pres &lt;- read.table(presence_file, header=TRUE, sep=',')[,-1]

# the kfold function randomly assigns data to groups; 
# groups are used as calibration (1/5) and training (4/5) data
groupp &lt;- kfold(pres, 5)
pres_train &lt;- pres[groupp !=  1, ]
pres_test &lt;- pres[groupp ==  1, ]

# choose background points
background &lt;- randomPoints(predictors, n=1000, extf=1.00)
colnames(background)=c('lon', 'lat')
groupa &lt;- kfold(background, 5)
backg_train &lt;- background[groupa != 1, ]
backg_test &lt;- background[groupa == 1, ]

# calibrate the models
# MAXLIKE not included as does not allow predictions for data.frames
# ENSEMBLE.min and ENSEMBLE.weight.min set very low to explore all
# algorithms.
# If focus is on actual ensemble, then set ENSEMBLE.min and 
# ENSEMBLE.weight.min to more usual values
ensemble.calibrate &lt;- ensemble.calibrate.models(x=predictors, 
    p=pres_train, a=backg_train, 
    pt=pres_test, at=backg_test,
    ENSEMBLE.min=0.5, ENSEMBLE.weight.min = 0.001,
    MAXENT=0, MAXNET=1, MAXLIKE=1, GBM=1, GBMSTEP=0, RF=1, CF=1,
    GLM=1, GLMSTEP=1, GAM=1, GAMSTEP=1, MGCV=1, MGCVFIX=1, 
    EARTH=1, RPART=1, NNET=1, FDA=1, SVM=1, SVME=1, 
    BIOCLIM.O=1, BIOCLIM=1, DOMAIN=1, MAHAL=0, MAHAL01=1,
    Yweights="BIOMOD", 
    PLOTS=FALSE, models.keep=TRUE)

# obtain data for plotting the evaluation strip
strip.data &lt;- evaluation.strip.data(xn=predictors, steps=500,
    models.list=ensemble.calibrate$models)

# in case predictions for DOMAIN failed
# however, ENSEMBLE should also be recalculated
DOMAIN.model &lt;- ensemble.calibrate$models$DOMAIN
strip.data$plot.data[, "DOMAIN"] &lt;- dismo::predict(object=DOMAIN.model, 
    x=strip.data$plot.data)

# in case predictions for MAHAL01 failed
predict.MAHAL01 &lt;- function(model, newdata, MAHAL.shape) {
    p &lt;- dismo::predict(object=model, x=newdata)
    p &lt;- p - 1 - MAHAL.shape
    p &lt;- abs(p)
    p &lt;- MAHAL.shape / p
    return(as.numeric(p))
}

MAHAL01.model &lt;- ensemble.calibrate$models$MAHAL01
MAHAL.shape1 &lt;- ensemble.calibrate$models$formulae$MAHAL.shape
strip.data$plot.data[, "MAHAL01"] &lt;- predict.MAHAL01(model=MAHAL01.model, 
    newdata=strip.data$plot.data, MAHAL.shape=MAHAL.shape1)

# create graphs
evaluation.strip.plot(data=strip.data$plot.data, variable.focal="bio6",
    TrainData=strip.data$TrainData,
    type="o", col="red")
evaluation.strip.plot(data=strip.data$plot.data, model.focal="ENSEMBLE",
    TrainData=strip.data$TrainData,
    type="o", col="red")


## End(Not run)
</code></pre>

<hr>
<h2 id='faramea'>Faramea occidentalis abundance in Panama</h2><span id='topic+faramea'></span>

<h3>Description</h3>

<p>This dataset describes the abundance (number of trees with diameter at breast height equal or larger than 10 cm) of the tree species Faramea occidentalis as observed in a 1-ha quadrat survey from the Barro Colorada Island of Panama. For each quadrat, some environmental characteristics are also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(faramea)</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 8 variables.
</p>

<dl>
<dt><code>UTM.EW</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>UTM.NS</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Precipitation</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Elevation</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Age</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Age.cat</code></dt><dd><p>a factor with levels <code>c1</code> <code>c2</code> <code>c3</code></p>
</dd>
<dt><code>Geology</code></dt><dd><p>a factor with levels <code>pT</code> <code>Tb</code> <code>Tbo</code> <code>Tc</code> <code>Tcm</code> <code>Tgo</code> <code>Tl</code></p>
</dd>
<dt><code>Faramea.occidentalis</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Although the original survey documented tree species composition of all 1-ha subplots of larger (over 1 ha) sample plot, only the first (and sometimes the last) quadrats of the larger plots were included. This selection was made to avoid that larger sample plots dominated the analysis. This selection of sites is therefore different from the selection of the 50 1-ha quadrats of the largest sample plot of the same survey (<code><a href="vegan.html#topic+BCI">BCI</a></code> and <code><a href="#topic+BCI.env">BCI.env</a></code>)
</p>
<p>This dataset is the main dataset used for the examples provided in chapters 6 and 7 of the Tree Diversity Analysis manual (Kindt &amp; Coe, 2005). 
</p>


<h3>References</h3>

<p>Pyke CR, Condit R, Aguilar S and Lao S. (2001). Floristic composition across a climatic gradient in a neotropical lowland forest. Journal of Vegetation Science 12: 553-566.
</p>
<p>Condit, R, Pitman, N, Leigh, E.G., Chave, J., Terborgh, J., Foster, R.B., Nunez, P., Aguilar, S., Valencia, R., Villa, G., Muller-Landau, H.C., Losos, E. &amp; Hubbell, S.P. (2002). Beta-diversity in tropical forest trees. <em>Science</em> 295: 666-669.
</p>
<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(faramea)
</code></pre>

<hr>
<h2 id='ifri'>Example data from the International Forestry Resources and Institutions (IFRI) research network</h2><span id='topic+ifri'></span>

<h3>Description</h3>

<p>This data set contains information on the number of stems (individuals) and basal areas for 34 vegetation plots inventoried in February 1997 in Lothlorien forest, 37 vegetation plots inventoried in February 1996 in May Creek Forest and 36 vegetation plots inventoried in May 1995 in Yellowwood State Forest. All three sites are in Indiana, USA. Data were gathered through IFRI inventory protocols to record any tree, palm and woody climber with diameter at breast height greater than or equal to 10 cm in 10-m radius circular plots; only tree species data were kept in the example data sets (IFRI research instruments and IFRI manual section P: Forest Plot Form, section D1: Tree, Palm and Woody Climber Information). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ifri)</code></pre>


<h3>Format</h3>

<p>A data frame with 486 observations on the following 5 variables.
</p>

<dl>
<dt><code>forest</code></dt><dd><p>a factor with 3 levels: &quot;LOT&quot; (Lothlorien forest), &quot;MCF&quot; (May Creek Forest) and &quot;YSF&quot; (Yellowwood State Forest) </p>
</dd>
<dt><code>plotID</code></dt><dd><p>a factor with 107 levels providing an identification code for a 314.16 square metres (10 m radius) vegetation plot </p>
</dd>
<dt><code>species</code></dt><dd><p>a factor with 50 levels providing an 8 character code for a tree species </p>
</dd>
<dt><code>count</code></dt><dd><p>a numeric vector providing the number of stems (individuals) for each species in each vegetation plot </p>
</dd>
<dt><code>basal</code></dt><dd><p>a numeric vector providing the basal area (calculated from the diameter at breast height) in square cm for each species in each vegetation plot </p>
</dd>
</dl>



<h3>Source</h3>

<p>IFRI (2014) Data from the International Forestry Resources and Institutions (IFRI) research network. <a href="http://ifri.forgov.org/">http://ifri.forgov.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ifri)
</code></pre>

<hr>
<h2 id='importancevalue'>Importance Value</h2><span id='topic+importancevalue'></span><span id='topic+importancevalue.comp'></span>

<h3>Description</h3>

<p>Calculates the importance values of tree species based on frequency (calculated from number of plots), density (calculated from number of individuals) and dominance (calculated from basal area). See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importancevalue(x, site="plotID", species="species", 
    count="count", basal="basal", 
    factor="forest", level="") 

importancevalue.comp(x, site="plotID", species="species", 
    count="count", basal="basal",
    factor="forest")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importancevalue_+3A_x">x</code></td>
<td>
<p> data frame with information on plot identities, species identities, number of individuals and basal areas </p>
</td></tr>
<tr><td><code id="importancevalue_+3A_site">site</code></td>
<td>
<p> factor variable providing the identities of survey plots </p>
</td></tr>
<tr><td><code id="importancevalue_+3A_species">species</code></td>
<td>
<p> factor variable providing the identities of tree species </p>
</td></tr>
<tr><td><code id="importancevalue_+3A_count">count</code></td>
<td>
<p> number of individuals for each tree species in each survey plot </p>
</td></tr>
<tr><td><code id="importancevalue_+3A_basal">basal</code></td>
<td>
<p> basal area for each tree species in each survey plot </p>
</td></tr>
<tr><td><code id="importancevalue_+3A_factor">factor</code></td>
<td>
<p> factor variable used to define subsets (typically different forest reserves) </p>
</td></tr>
<tr><td><code id="importancevalue_+3A_level">level</code></td>
<td>
<p> level of the factor variable used to create a subset from the original data </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The importance value is calculated as the sum from (i) the relative frequency; (ii) the relative density; and (iii) the relative dominance. The importance value ranges between 0 and 300.
</p>
<p>Frequency is calculated as the number of plots where a species is observed divided by the total number of survey plots. Relative frequency is calculated by dividing the frequency by the sum of the frequencies of all species, multiplied by 100 (to obtain a percentage). 
</p>
<p>Density is calculated as the total number of individuals of a species. Relative density is calculated by dividing the density by the sum of the densities of all species, multiplied by 100 (to obtain a percentage). 
</p>
<p>Dominance is calculated as the total basal area of a species. Relative dominance is calculated by dividing the dominance by the sum of the dominance of all species, multiplied by 100 (to obtain a percentage). 
</p>
<p>Functions <code>importancevalue.comp</code> applies function <code>importancevalue</code> to all available levels of a factor variable.
</p>


<h3>Value</h3>

<p>Provides information on the importance value for all tree species
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre), Peter Newton (University of Michigan)</p>


<h3>References</h3>

<p>Curtis, J.T. &amp; McIntosh, R. P. (1951) An Upland Forest Continuum in the Prairie-Forest Border Region of Wisconsin. Ecology 32: 476-496.
</p>
<p>Kent, M. (2011) Vegetation Description and Data Analysis: A Practical Approach. Second edition. 428 pages.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifri">ifri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ifri)
importancevalue(ifri, site='plotID', species='species', count='count', 
    basal='basal', factor='forest', level='YSF')
importancevalue.comp(ifri, site='plotID', species='species', count='count', 
    basal='basal', factor='forest')

# When all survey plots are the same size, importance value
# is not affected. Counts and basal areas now calculated per square metre
ifri$count &lt;- ifri$count/314.16
ifri$basal &lt;- ifri$basal/314.16

importancevalue(ifri, site='plotID', species='species', count='count', 
    basal='basal', factor='forest', level='YSF')
importancevalue.comp(ifri, site='plotID', species='species', count='count', 
    basal='basal', factor='forest')

# Calculate diversity profiles from importance values
imp &lt;- importancevalue.comp(ifri, site='plotID', species='species', 
    count='count', basal='basal', factor='forest')
vals &lt;- imp[["values"]]
for (i in 1:length(vals)) {
    imp.i &lt;- data.frame(imp[[vals[i]]])
    name.i &lt;- paste(vals[[i]], ".Renyi", sep="")
    imp[[name.i]] &lt;- renyi(imp.i$importance.value)
}

# LOT more diverse
imp$LOT.Renyi - imp$MCF.Renyi
imp$LOT.Renyi - imp$YSF.Renyi

# YSF and MCF different richness and evenness
imp$YSF.Renyi - imp$MCF.Renyi


</code></pre>

<hr>
<h2 id='loaded.citations'>Give Citation Information for all Loaded Packages</h2><span id='topic+loaded.citations'></span>

<h3>Description</h3>

<p>This function provides citation information for all loaded packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loaded.citations()
</code></pre>


<h3>Details</h3>

<p>The function checks for the loaded packages via <code><a href="base.html#topic+zpackages">.packages</a></code>. Citation information is provided for the base package and for all the non-standard packages via <code><a href="utils.html#topic+citation">citation</a></code>.
</p>


<h3>Value</h3>

<p>The function provides a list of all loaded packages and the relevant citation information.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre) </p>

<hr>
<h2 id='makecommunitydataset'>Make a Community Dataset from a Stacked Dataset</h2><span id='topic+makecommunitydataset'></span><span id='topic+stackcommunitydataset'></span>

<h3>Description</h3>

<p>Makes a community data set from a stacked dataset (with separate variables for the site identities, the species identities and the abundance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makecommunitydataset(x, row, column, value, factor="", level="", drop=F)
stackcommunitydataset(comm, remove.zeroes=FALSE, order.sites=FALSE, order.species=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makecommunitydataset_+3A_x">x</code></td>
<td>
<p> Data frame. </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_row">row</code></td>
<td>
<p> Name of the categorical variable for the rows of the crosstabulation (typically indicating sites) </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_column">column</code></td>
<td>
<p> Name of the categorical variable for the columns of the crosstabulation (typically indicating species) </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_value">value</code></td>
<td>
<p> Name of numerical variable for the cells of the crosstabulation (typically indicating abundance). The cells provide the sum of all values in the data frame. </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_factor">factor</code></td>
<td>
<p> Name of the variable to calculate a subset of the data frame. </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_level">level</code></td>
<td>
<p> Value of the subset of the factor variable to calculate a subset of the data frame. </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_drop">drop</code></td>
<td>
<p> Drop rows without species (species with total abundance of zero are always dropped) </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_comm">comm</code></td>
<td>
<p> Community data set </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_remove.zeroes">remove.zeroes</code></td>
<td>
<p> Should rows with zero abundance be removed? </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_order.sites">order.sites</code></td>
<td>
<p> Should sites be ordered alphabetically? </p>
</td></tr>
<tr><td><code id="makecommunitydataset_+3A_order.species">order.species</code></td>
<td>
<p> Should species be ordered alphabetically? </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>makecommunitydataset</code> calculates a cross-tabulation from a data frame, summing up all the values of the numerical variable identified as variable for the cell values. If factor=&quot;&quot;, then no subset is calculated from the data frame in the first step.
</p>
<p><code>stackcommunitydataset</code> reverses the actions of <code>makecommunitydataset</code> and recreates the data in stacked format. 
</p>


<h3>Value</h3>

<p>The function provides a community dataset from another data frame.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005) 
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
dune.file &lt;- normalizePath(paste(system.file(package="BiodiversityR"), 
    '/etc/dunestacked.csv', sep=''))
dune.stacked &lt;- read.csv(dune.file)

# dune.stacked has different variables for sites, species and abundance
head(dune.stacked)
dune.comm2 &lt;- makecommunitydataset(dune.stacked, row='sites', column='species', 
    value='abundance')

# recreate the original stack
dune.stacked2 &lt;- stackcommunitydataset(dune.comm2, remove.zeroes=T)


## End(Not run)

</code></pre>

<hr>
<h2 id='multiconstrained'>Pairwise Comparisons for All Levels of a Categorical Variable by RDA, CCA or Capscale</h2><span id='topic+multiconstrained'></span>

<h3>Description</h3>

<p>This function implements pairwise comparisons for categorical variable through <code><a href="vegan.html#topic+capscale">capscale</a></code>, <code><a href="vegan.html#topic+cca">cca</a></code>, <code><a href="vegan.html#topic+dbrda">dbrda</a></code> or <code><a href="vegan.html#topic+cca">rda</a></code> followed by <code><a href="vegan.html#topic+anova.cca">anova.cca</a></code>. The function simply repeats constrained ordination analysis by selecting subsets of data that correspond to two factor levels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiconstrained(method="capscale", formula, data, distance = "bray"
    , comm = NULL, add = FALSE, multicomp="", contrast=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiconstrained_+3A_method">method</code></td>
<td>
<p> Method for constrained ordination analysis; one of &quot;rda&quot;, &quot;cca&quot;, &quot;dbrda&quot; or &quot;capscale&quot;. </p>
</td></tr>
<tr><td><code id="multiconstrained_+3A_formula">formula</code></td>
<td>
<p> Model formula as in <code><a href="vegan.html#topic+capscale">capscale</a></code>,  <code><a href="vegan.html#topic+cca">cca</a></code> or  <code><a href="vegan.html#topic+cca">rda</a></code>. The LHS can be a community data matrix or a distance matrix for <code><a href="vegan.html#topic+capscale">capscale</a></code>. </p>
</td></tr>
<tr><td><code id="multiconstrained_+3A_data">data</code></td>
<td>
<p> Data frame containing the variables on the right hand side of the model formula as in <code><a href="vegan.html#topic+capscale">capscale</a></code>, <code><a href="vegan.html#topic+cca">cca</a></code> or  <code><a href="vegan.html#topic+cca">rda</a></code>. </p>
</td></tr>
<tr><td><code id="multiconstrained_+3A_distance">distance</code></td>
<td>
<p> Dissimilarity (or distance) index in vegdist used if the LHS of the formula is a data frame instead of dissimilarity matrix; used only with function <code><a href="vegan.html#topic+vegdist">vegdist</a></code> and partial match to &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;morisita&quot;, &quot;horn&quot; or &quot;mountford&quot;. This argument is only used for <code><a href="vegan.html#topic+capscale">capscale</a></code> in case that the LHS of the formula is a community matrix.  </p>
</td></tr>
<tr><td><code id="multiconstrained_+3A_comm">comm</code></td>
<td>
<p> Community data frame which will be used for finding species scores when the LHS of the formula was a dissimilarity matrix as only allowed for <code><a href="vegan.html#topic+capscale">capscale</a></code>. This is not used if the LHS is a data frame.  </p>
</td></tr>
<tr><td><code id="multiconstrained_+3A_add">add</code></td>
<td>
<p> Logical indicating if an additive constant should be computed, and added to the non-diagonal dissimilarities such that all eigenvalues are non-negative in underlying Principal Co-ordinates Analysis; only applicable in <code><a href="vegan.html#topic+capscale">capscale</a></code>.  </p>
</td></tr>
<tr><td><code id="multiconstrained_+3A_multicomp">multicomp</code></td>
<td>
<p> Categorical variable used to construct the contrasts from. In case that this variable is missing, then the first explanatory variable of the formula will be used.  </p>
</td></tr>
<tr><td><code id="multiconstrained_+3A_contrast">contrast</code></td>
<td>
<p> Return the ordination results for the particular contrast indicated by this number (e.g. with 5 levels, one can choose in between contrast 1-10). In case=0, then the first row of the <code><a href="vegan.html#topic+anova.cca">anova.cca</a></code> results for all contrasts is provided.  </p>
</td></tr>
<tr><td><code id="multiconstrained_+3A_...">...</code></td>
<td>
<p> Other parameters passed to <code><a href="vegan.html#topic+anova.cca">anova.cca</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a simple expansion of <code><a href="vegan.html#topic+capscale">capscale</a></code>, <code><a href="vegan.html#topic+cca">cca</a></code> and <code><a href="vegan.html#topic+cca">rda</a></code> by conducting the analysis for subsets of the community and environmental datasets that only contain two levels of a categoricl variable. 
</p>
<p>When the choice is made to return results from all contrasts (contrast=0), then the first row of the <code><a href="vegan.html#topic+anova.cca">anova.cca</a></code> tables for each contrast are provided. It is therefore possible to compare differences in results by modifying the &quot;by&quot; argument of this function (i.e. obtain the total of explained variance, the variance explained on the first axis or the variance explained by the variable alone). 
</p>
<p>When the choice is made to return results from a particular contrast (contrast&gt;0), then the ordination result is returned and two new datasets (&quot;newcommunity&quot; and &quot;newenvdata&quot;) are created that only contain data for the two selected contrasts.
</p>


<h3>Value</h3>

<p>The function returns an ANOVA table that contains the first rows of the ANOVA tables obtained for all possible combinations of levels of the first variable. Alternatively, it returns an ordination result for the selected contrast and creates two new datasets (&quot;newcommunity&quot; and &quot;newenvdata&quot;)
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Legendre, P. &amp; Anderson, M.J. (1999). Distance-based redundancy analysis:  
testing multispecies responses in multifactorial ecological experiments. 
Ecological Monographs 69: 1-24.
</p>
<p>Anderson, M.J. &amp; Willis, T.J. (2003). Canonical analysis of principal coordinates: a useful method of constrained ordination for ecology. 
Ecology 84: 511-525.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(vegan)
library(MASS)
data(dune)
data(dune.env)
multiconstrained(method="capscale", dune~Management, data=dune.env,
    distance="bray",add=TRUE)
multiconstrained(method="capscale", dune~Management, data=dune.env, 
    distance="bray", add=TRUE, contrast=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='nested.anova.dbrda'>Nested Analysis of Variance via Distance-based Redundancy Analysis or Non-parametric Multivariate Analysis of Variance</h2><span id='topic+nested.anova.dbrda'></span><span id='topic+nested.npmanova'></span>

<h3>Description</h3>

<p>The functions provide nested analysis of variance for a two-level hierarchical model. The functions are implemented by estimating the correct F-ratio for the main and nested factors (assuming the nested factor is random) and using the recommended permutation procedures to test the significance of these F-ratios. F-ratios are estimated from variance estimates that are provided by distance-based redundancy analysis (<code><a href="vegan.html#topic+capscale">capscale</a></code>) or non-parametric multivariate analysis of variance (<code><a href="vegan.html#topic+adonis2">adonis2</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested.anova.dbrda(formula, data, method="euc", add=FALSE,
    permutations=100, warnings=FALSE)
nested.npmanova(formula, data, method="euc", 
    permutations=100, warnings=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested.anova.dbrda_+3A_formula">formula</code></td>
<td>
<p> Formula with a community data frame (with sites as rows, species as columns and species abundance as cell values) or (for <code>nested.anova.dbrda</code> only) distance matrix on the left-hand side and two categorical variables on the right-hand side (with the second variable assumed to be nested within the first). </p>
</td></tr>
<tr><td><code id="nested.anova.dbrda_+3A_data">data</code></td>
<td>
<p> Environmental data set. </p>
</td></tr>
<tr><td><code id="nested.anova.dbrda_+3A_method">method</code></td>
<td>
<p> Method for calculating ecological distance with function <code><a href="vegan.html#topic+vegdist">vegdist</a></code>: partial match to &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;, &quot;morisita&quot;, &quot;horn&quot; or &quot;mountford&quot;. This argument is ignored in case that the left-hand side of the formula already is a distance matrix. </p>
</td></tr>
<tr><td><code id="nested.anova.dbrda_+3A_add">add</code></td>
<td>
<p> Should a constant be added to the off-diagonal elements of the distance-matrix (TRUE) or not. </p>
</td></tr>
<tr><td><code id="nested.anova.dbrda_+3A_permutations">permutations</code></td>
<td>
<p> The number of permutations for significance testing.  </p>
</td></tr>
<tr><td><code id="nested.anova.dbrda_+3A_warnings">warnings</code></td>
<td>
<p> Should warnings be suppressed (TRUE) or not. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions provide two alternative procedures for multivariate analysis of variance on the basis of any distance measure. Function <code>nested.anova.dbrda</code> proceeds via <code><a href="vegan.html#topic+capscale">capscale</a></code>, whereas <code>nested.npmanova</code> proceeds via <code><a href="vegan.html#topic+adonis2">adonis2</a></code>. Both methods are complementary to each other as <code>nested.npmanova</code> always provides correct F-ratios and estimations of significance, whereas <code>nested.anova.dbrda</code> does not provide correct F-ratios and estimations of significance when negative eigenvalues are encountered or constants are added to the distance matrix, but always provides an ordination diagram. 
</p>
<p>The F-ratio for the main factor is estimated as the mean square of the main factor divided by the mean square of the nested factor. The significance of the F-ratio of the main factor is tested by permuting entire blocks belonging to levels of the nested factor. The significance of the F-ratio of the nested factor is tested by permuting sample units within strata defined by levels of the main factor.
</p>


<h3>Value</h3>

<p>The functions provide an ANOVA table.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Legendre, P. &amp; Anderson, M. J. (1999). Distance-based redundancy analysis: testing multispecies responses in multifactorial ecological experiments. Ecological Monographs 69, 1-24.
</p>
<p>Anderson, M.J. (2001). A new method for non-parametric multivariate analysis of variance. Austral Ecology, 26: 32-46.
</p>
<p>McArdle, B.H. and M.J. Anderson. (2001). Fitting multivariate models to community data: A comment on distance-based redundancy analysis. Ecology, 82: 290-297.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(vegan)
data(warcom)
data(warenv)
# use larger number of permutations for real studies
nested.npmanova(warcom~rift.valley+popshort, data=warenv, method="jac", 
    permutations=5)
nested.anova.dbrda(warcom~rift.valley+popshort, data=warenv, method="jac", 
    permutations=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='NMSrandom'>Calculate the NMS Result with the Smallest Stress from Various Random Starts </h2><span id='topic+NMSrandom'></span>

<h3>Description</h3>

<p>This function provides a simplified version of the method of calculating NMS results implemented by the function <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code> (<span class="pkg">vegan</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMSrandom(x,perm=100,k=2,stressresult=F,method="isoMDS")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMSrandom_+3A_x">x</code></td>
<td>
<p> Distance matrix. </p>
</td></tr>
<tr><td><code id="NMSrandom_+3A_perm">perm</code></td>
<td>
<p> Number of permutations to select the configuration with the lowest stress. </p>
</td></tr>
<tr><td><code id="NMSrandom_+3A_k">k</code></td>
<td>
<p> Number of dimensions for the non metric scaling result; passed to <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code> or <code><a href="MASS.html#topic+sammon">sammon</a></code>. </p>
</td></tr>
<tr><td><code id="NMSrandom_+3A_stressresult">stressresult</code></td>
<td>
<p> Provide the calculated stress for each permutation. </p>
</td></tr>
<tr><td><code id="NMSrandom_+3A_method">method</code></td>
<td>
<p> Method for calculating the NMS:  <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code> or <code><a href="MASS.html#topic+sammon">sammon</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an easier method of calculating the best NMS configuration after various random starts than implemented in the <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code> function (<span class="pkg">vegan</span>). The function uses a distance matrix (as calculated for example by function <code><a href="vegan.html#topic+vegdist">vegdist</a></code> from a community data set) and calculates random starting positions by function <code><a href="vegan.html#topic+metaMDS">initMDS</a></code> (<span class="pkg">vegan</span>) analogous to <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code>.
</p>


<h3>Value</h3>

<p>The function returns the NMS ordination result with the lowest stress (calculated by <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code> or <code><a href="MASS.html#topic+sammon">sammon</a></code>.), or the stress of each NMS ordination.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
library(MASS)
data(dune)
distmatrix &lt;- vegdist(dune)
Ordination.model1 &lt;- NMSrandom(distmatrix, perm=100, k=2)
Ordination.model1 &lt;- add.spec.scores(Ordination.model1, dune, 
    method='wa.scores')
Ordination.model1
</code></pre>

<hr>
<h2 id='nnetrandom'>Calculate the NNET Result with the Smallest Value from Various Random Starts</h2><span id='topic+nnetrandom'></span>

<h3>Description</h3>

<p>This function provides the best solution from various calls to the <code><a href="nnet.html#topic+nnet">nnet</a></code> feed-forward artificial neural networks function (<span class="pkg">nnet</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnetrandom(formula,data,tries=10,leave.one.out=F,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnetrandom_+3A_formula">formula</code></td>
<td>
<p> Formula as passed to <code><a href="nnet.html#topic+nnet">nnet</a></code>. </p>
</td></tr>
<tr><td><code id="nnetrandom_+3A_data">data</code></td>
<td>
<p> Data as passed to <code><a href="nnet.html#topic+nnet">nnet</a></code>. </p>
</td></tr>
<tr><td><code id="nnetrandom_+3A_tries">tries</code></td>
<td>
<p> Number of calls to <code><a href="nnet.html#topic+nnet">nnet</a></code> to obtain the best solution. </p>
</td></tr>
<tr><td><code id="nnetrandom_+3A_leave.one.out">leave.one.out</code></td>
<td>
<p> Calculate leave-one-out predictions. </p>
</td></tr>
<tr><td><code id="nnetrandom_+3A_...">...</code></td>
<td>
<p> Other arguments passed to <code><a href="nnet.html#topic+nnet">nnet</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes various calls to <code><a href="nnet.html#topic+nnet">nnet</a></code>. If desired by the user, leave-one-out statistics are provided that report the prediction if one particular sample unit was not used for iterating the networks.
</p>


<h3>Value</h3>

<p>The function returns the same components as <code><a href="nnet.html#topic+nnet">nnet</a></code>, but adds the following components:
</p>
<table role = "presentation">
<tr><td><code>range</code></td>
<td>
<p> Summary of the observed &quot;values&quot;. </p>
</td></tr>
<tr><td><code>tries</code></td>
<td>
<p> Number of different attempts to iterate an ANN. </p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p> Predicted class when not using the respective sample unit for iterating ANN. </p>
</td></tr>
<tr><td><code>succesful</code></td>
<td>
<p> Test whether leave-one-out statistics provided the same class as the original class. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(faramea)
faramea &lt;- na.omit(faramea)
faramea$presence &lt;- as.numeric(faramea$Faramea.occidentalis &gt; 0)
attach(faramea)
library(nnet)
result &lt;- nnetrandom(presence ~ Elevation, data=faramea, size=2, 
    skip=FALSE, entropy=TRUE, trace=FALSE, maxit=1000, tries=100, 
    leave.one.out=FALSE)
summary(result)
result$fitted.values
result$value
result2 &lt;- nnetrandom(presence ~ Elevation, data=faramea, size=2, 
    skip=FALSE, entropy=TRUE, trace=FALSE, maxit=1000, tries=50, 
    leave.one.out=TRUE)
result2$range
result2$CV
result2$successful

## End(Not run)
</code></pre>

<hr>
<h2 id='ordicoeno'>Coenoclines for an Ordination Axis</h2><span id='topic+ordicoeno'></span>

<h3>Description</h3>

<p>A graph is produced that summarizes (through GAM as implemented by <code><a href="mgcv.html#topic+gam">gam</a></code>) how the abundance of all species of the community data set change along an ordination axis (based on the position of sites along the axis and the information from the community data set).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordicoeno(x, ordiplot, axis = 1, legend = FALSE, cex = 0.8, ncol = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordicoeno_+3A_x">x</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="ordicoeno_+3A_ordiplot">ordiplot</code></td>
<td>
<p> Ordination plot created by <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code>. </p>
</td></tr>
<tr><td><code id="ordicoeno_+3A_axis">axis</code></td>
<td>
<p> Axis of the ordination graph (1: horizontal, 2: vertical). </p>
</td></tr>
<tr><td><code id="ordicoeno_+3A_legend">legend</code></td>
<td>
<p> if <code>TRUE</code>, then add a legend to the plot. </p>
</td></tr>
<tr><td><code id="ordicoeno_+3A_cex">cex</code></td>
<td>
<p> the amount by which plotting text and symbols should be magnified relative to the default; see also <code><a href="graphics.html#topic+par">par</a></code> </p>
</td></tr>
<tr><td><code id="ordicoeno_+3A_ncol">ncol</code></td>
<td>
<p> the number of columns in which to set the legend items; see also <code><a href="graphics.html#topic+legend">legend</a></code>  </p>
</td></tr>
<tr><td><code id="ordicoeno_+3A_...">...</code></td>
<td>
<p> Other arguments passed to functions <code><a href="graphics.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+points">points</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions investigates the relationship between the species vectors and the position of sites on an ordination axis. A GAM (<code><a href="mgcv.html#topic+gam">gam</a></code>) investigates the relationship by using the species abundances of each species as response variable, and the site position as the explanatory variable. The graph shows how the abundance of each species changes over the gradient of the ordination axis.
</p>


<h3>Value</h3>

<p>The function plots coenoclines and provides the expected degrees of freedom (complexity of the relationship) estimated for each species by GAM.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005) 
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
library(mgcv)
data(dune)
Ordination.model1 &lt;- rda(dune)
plot1 &lt;- ordiplot(Ordination.model1, choices=c(1,2), scaling=1)
ordicoeno(dune, ordiplot=plot1, legend=TRUE)
</code></pre>

<hr>
<h2 id='ordisymbol'>Add Other Graphical Items to Ordination Diagrams</h2><span id='topic+ordisymbol'></span><span id='topic+ordibubble'></span><span id='topic+ordicluster2'></span><span id='topic+ordinearest'></span><span id='topic+ordivector'></span>

<h3>Description</h3>

<p>Functions to add some other graphical itmes to ordination diagrams than provided within <span class="pkg">vegan</span> by <code><a href="vegan.html#topic+ordihull">ordihull</a></code>, <code><a href="vegan.html#topic+ordihull">ordispider</a></code>, <code><a href="vegan.html#topic+ordihull">ordiarrows</a></code>, <code><a href="vegan.html#topic+ordihull">ordisegments</a></code>, <code><a href="vegan.html#topic+ordihull">ordigrid</a></code>, <code><a href="vegan.html#topic+ordihull">ordiellipse</a></code>, <code><a href="vegan.html#topic+ordihull">ordicluster</a></code> and <code><a href="vegan.html#topic+spantree">lines.spantree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordisymbol(ordiplot, y, factor, col = 1, colors = TRUE, pchs = TRUE,
    rainbow_hcl = TRUE, rainbow_hcl.c = 90, rainbow_hcl.l = 50, 
    rainbow = TRUE, heat.colors = FALSE, terrain.colors = FALSE,
    topo.colors = FALSE, cm.colors = FALSE,
    legend = TRUE, legend.x = "topleft", legend.ncol = 1, ...)
ordibubble(ordiplot,var,...)
ordicluster2(ordiplot, cluster, mingroups = 1, maxgroups = nrow(ordiplot$sites), ...)
ordinearest(ordiplot, dist,...)
ordivector(ordiplot, spec, lty=2,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordisymbol_+3A_ordiplot">ordiplot</code></td>
<td>
<p> An ordination graph created by <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code> (<span class="pkg">vegan</span>). </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_y">y</code></td>
<td>
<p> Environmental data frame. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_factor">factor</code></td>
<td>
<p> Variable of the environmental data frame that defines subsets to be given different symbols. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_var">var</code></td>
<td>
<p> Continous variable of the environmental dataset or species from the community dataset. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_col">col</code></td>
<td>
<p> Colour (as <code><a href="graphics.html#topic+points">points</a></code>). </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_colors">colors</code></td>
<td>
<p> Apply different colours to different factor levels </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_pchs">pchs</code></td>
<td>
<p> Apply different symbols (plotting characters) to different factor levels (as in <code><a href="graphics.html#topic+points">points</a></code>)) </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_rainbow_hcl">rainbow_hcl</code></td>
<td>
<p> Use rainbow_hcl colours (<code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code>)  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_rainbow_hcl.c">rainbow_hcl.c</code></td>
<td>
<p> Set the chroma value  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_rainbow_hcl.l">rainbow_hcl.l</code></td>
<td>
<p> Set the luminance value  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_rainbow">rainbow</code></td>
<td>
<p> Use rainbow colours  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_heat.colors">heat.colors</code></td>
<td>
<p> Use heat colours  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_terrain.colors">terrain.colors</code></td>
<td>
<p> Use terrain colours  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_topo.colors">topo.colors</code></td>
<td>
<p> Use topo colours  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_cm.colors">cm.colors</code></td>
<td>
<p> Use cm colours  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_legend">legend</code></td>
<td>
<p> Add the legend. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_legend.x">legend.x</code></td>
<td>
<p> Location of the legend; see also <code><a href="graphics.html#topic+legend">legend</a></code>. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_legend.ncol">legend.ncol</code></td>
<td>
<p> the number of columns in which to set the legend items; see also <code><a href="graphics.html#topic+legend">legend</a></code>  </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_cluster">cluster</code></td>
<td>
<p> Cluster object. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_mingroups">mingroups</code></td>
<td>
<p> Minimum of clusters to be plotted. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_maxgroups">maxgroups</code></td>
<td>
<p> Maximum of clusters to be plotted.. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_dist">dist</code></td>
<td>
<p> Distance matrix. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_spec">spec</code></td>
<td>
<p> Species name from the community dataset. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_lty">lty</code></td>
<td>
<p> Line type as specified for <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="ordisymbol_+3A_...">...</code></td>
<td>
<p> Other arguments passed to functions <code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+symbols">symbols</a></code>, <code><a href="vegan.html#topic+ordihull">ordihull</a></code> or <code><a href="graphics.html#topic+arrows">arrows</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ordisymbol</code> plots different levels of the specified variable in different symbols and different colours. In case more than one colour palettes are selected, the last palette selected will be used. 
</p>
<p>Function <code>ordibubble</code> draws bubble diagrams indicating the value of the specified continuous variable. Circles indicate positive values, squares indicate negative values.
</p>
<p>Function <code>ordicluster2</code> provides an alternative method of overlaying information from hierarchical clustering on an ordination diagram than provided by function <code><a href="vegan.html#topic+ordihull">ordicluster</a></code>. The method draws convex hulls around sites that are grouped into the same cluster. You can select the minimum and maximum number of clusters that are plotted (i.e. the range of clustering steps to be shown).
</p>
<p>Function <code>ordinearest</code> draws a vector from each site to the site that is nearest to it as determined from a distance matrix. When you combine the method with <code><a href="vegan.html#topic+spantree">lines.spantree</a></code> using the same distance measure, then you can evaluate in part how the minimum spanning tree was constructed. 
</p>
<p>Function <code>ordivector</code> draws a vector for the specified species on the ordination diagramme and draws perpendicular lines from each site to a line that connects the origin and the head of species vector. This method helps in the biplot interpretation of a species vector as described by Jongman, ter Braak and van Tongeren (1995).  
</p>


<h3>Value</h3>

<p>These functions add graphical items to an existing ordination diagram.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre) and Jari Oksanen (<code>ordinearest</code>)</p>


<h3>References</h3>

<p>Jongman, R.H.G, ter Braak, C.J.F &amp; van Tongeren, O.F.R. (1987). 
Data Analysis in Community and Landscape Ecology. Pudog, Wageningen.
</p>
<p>Kindt, R. &amp; Coe, R. (2005). 
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune)
data(dune.env)
Ordination.model1 &lt;- rda(dune)
plot1 &lt;- ordiplot(Ordination.model1, choices=c(1,2), scaling=2)
ordisymbol(plot1, dune.env, "Management", legend=TRUE, 
    legend.x="topleft", legend.ncol=1)
plot2 &lt;- ordiplot(Ordination.model1, choices=c(1,2), scaling=1)
distmatrix &lt;- vegdist(dune, method='bray')
cluster &lt;- hclust(distmatrix, method='single')
ordicluster2(plot2, cluster)
ordinearest(plot2, distmatrix, col=2)
ordivector(plot2, "Agrostol", lty=2)
</code></pre>

<hr>
<h2 id='PCAsignificance'>PCA Significance</h2><span id='topic+PCAsignificance'></span><span id='topic+ordiequilibriumcircle'></span>

<h3>Description</h3>

<p>Calculates the number of significant axes from a Principal Components Analysis based on the broken-stick criterion, or adds an equilibrium circle to an ordination diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCAsignificance(pca,axes=8)
ordiequilibriumcircle(pca,ordiplot,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCAsignificance_+3A_pca">pca</code></td>
<td>
<p> Principal Components Analysis result as calculated by <code><a href="vegan.html#topic+cca">rda</a></code> (<span class="pkg">vegan</span>). </p>
</td></tr>
<tr><td><code id="PCAsignificance_+3A_axes">axes</code></td>
<td>
<p> Number of axes to calculate results for. </p>
</td></tr>
<tr><td><code id="PCAsignificance_+3A_ordiplot">ordiplot</code></td>
<td>
<p> Ordination plot created by <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code> (<span class="pkg">vegan</span>) </p>
</td></tr>
<tr><td><code id="PCAsignificance_+3A_...">...</code></td>
<td>
<p> Other arguments passed to function <code><a href="graphics.html#topic+arrows">arrows</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide two methods of providing some information on significance for a Principal Components Analysis (PCA).
</p>
<p>Function <code>PCAsignificance</code> uses the broken-stick distribution to evaluate how many PCA axes are significant. This criterion is one of the most reliable to check how many axes are significant. PCA axes with larger percentages of (accumulated) variance than the broken-stick variances are significant (Legendre and Legendre, 1998).
</p>
<p>Function <code>ordiequilibriumcircle</code> draws an equilibirum circle to a PCA ordination diagram. Only species vectors with heads outside of the equilibrium circle significantly contribute to the ordination diagram (Legendre and Legendre, 1998). Vectors are drawn for these species. The function considers the scaling methods used by <code><a href="vegan.html#topic+cca">rda</a></code> for <code>scaling=1</code>. The method should only be used for <code>scaling=1</code> and PCA calculated by function <code><a href="vegan.html#topic+cca">rda</a></code>. 
</p>


<h3>Value</h3>

<p>Function <code>PCAsignificance</code> returns a matrix with the variances that are explained by the PCA axes and by the broken-stick criterion.
</p>
<p>Function <code>ordiequilibriumcircle</code> plots an equilibirum circle and returns a list with the radius and the scaling constant used by <code><a href="vegan.html#topic+cca">rda</a></code>.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Legendre, P. &amp; Legendre, L. (1998). Numerical Ecology. 2nd English Edition. Elsevier. 
</p>
<p>Kindt, R. &amp; Coe, R. (2005). 
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune)
Ordination.model1 &lt;- rda(dune)
PCAsignificance(Ordination.model1)
plot1 &lt;- ordiplot(Ordination.model1, choices=c(1,2), scaling=1)
ordiequilibriumcircle(Ordination.model1,plot1)
</code></pre>

<hr>
<h2 id='radfitresult'>Alternative Rank Abundance Fitting Results</h2><span id='topic+radfitresult'></span>

<h3>Description</h3>

<p>Provides alternative methods of obtaining rank abundance curves than provided by functions <code><a href="vegan.html#topic+radfit">radfit</a></code>, <code><a href="vegan.html#topic+fisherfit">fisherfit</a></code> and <code><a href="vegan.html#topic+fisherfit">prestonfit</a></code> (<span class="pkg">vegan</span>), although these same functions are called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radfitresult(x,y="",factor="",level,plotit=T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="radfitresult_+3A_x">x</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="radfitresult_+3A_y">y</code></td>
<td>
<p> Environmental data frame. </p>
</td></tr>
<tr><td><code id="radfitresult_+3A_factor">factor</code></td>
<td>
<p> Variable of the environmental data frame that defines subsets to calculate fitted rank-abundance curves for. </p>
</td></tr>
<tr><td><code id="radfitresult_+3A_level">level</code></td>
<td>
<p> Level of the variable to create the subset to calculate fitted rank-abundance curves. </p>
</td></tr>
<tr><td><code id="radfitresult_+3A_plotit">plotit</code></td>
<td>
<p> Plot the results obtained by <code><a href="vegan.html#topic+radfit">plot.radfit</a></code> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide some alternative methods of obtaining fitted rank-abundance curves, although functions <code><a href="vegan.html#topic+radfit">radfit</a></code>, <code><a href="vegan.html#topic+fisherfit">fisherfit</a></code> and <code><a href="vegan.html#topic+fisherfit">prestonfit</a></code> (<span class="pkg">vegan</span>) are called to calculate the actual results.
</p>


<h3>Value</h3>

<p>The function returns the results from three methods of fitting rank-abundance curves:
</p>
<table role = "presentation">
<tr><td><code>radfit</code></td>
<td>
<p> results of <code><a href="vegan.html#topic+radfit">radfit</a></code>. </p>
</td></tr>
<tr><td><code>fisherfit</code></td>
<td>
<p> results of <code><a href="vegan.html#topic+fisherfit">fisherfit</a></code>. </p>
</td></tr>
<tr><td><code>prestonfit</code></td>
<td>
<p> results of <code><a href="vegan.html#topic+prestonfit">prestonfit</a></code>. </p>
</td></tr>
</table>
<p>Optionally, a plot is provided of the <code><a href="vegan.html#topic+radfit">radfit</a></code> results by <code><a href="vegan.html#topic+radfit">plot.radfit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(BCI)
BCIall &lt;- t(as.matrix(colSums(BCI)))
radfitresult(BCIall)
</code></pre>

<hr>
<h2 id='rankabundance'>Rank Abundance Curves</h2><span id='topic+rankabundance'></span><span id='topic+rankabunplot'></span><span id='topic+rankabuncomp'></span>

<h3>Description</h3>

<p>Provides methods of calculating rank-abundance curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankabundance(x, y="", factor="", level, digits=1, t=qt(0.975, df=n-1))

rankabunplot(xr, addit=F, labels="", scale="abundance", scaledx=F, type="o",
    xlim=c(min(xpos), max(xpos)),
    ylim=c(0, max(x[,scale])),
    specnames=c(1:5), srt=0, ...)

rankabuncomp(x, y="", factor, return.data=T, specnames=c(1:3),
    scale="abundance", scaledx=F, type="o", rainbow=T,
    legend=T, xlim=c(1, max1), ylim=c(0, max2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankabundance_+3A_x">x</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_y">y</code></td>
<td>
<p> Environmental data frame. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_factor">factor</code></td>
<td>
<p> Variable of the environmental data frame that defines subsets to calculate rank abundance curves for. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_level">level</code></td>
<td>
<p> Level of the variable to create the subset to calculate rank abundance curves. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_digits">digits</code></td>
<td>
<p> Number of digits in the results. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_t">t</code></td>
<td>
<p> t-value to calculate confidence interval limits for the species proportion for cluster sampling (following Hayek and Buzas 1997).  </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_xr">xr</code></td>
<td>
<p> Result from <code>rankabundance</code>. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_addit">addit</code></td>
<td>
<p> Add rank abundance curve to an existing graph. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_labels">labels</code></td>
<td>
<p> Labels to plot at left of the rank abundance curves. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_scale">scale</code></td>
<td>
<p> Method of scaling the vertical axis. Method &quot;abundance&quot; uses abundance, &quot;proportion&quot; uses proportional abundance (species abundance / total abundance), &quot;logabun&quot; calculates the logarithm of abundance using base 10 and &quot;accumfreq&quot; accumulates the proportional abundance. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_scaledx">scaledx</code></td>
<td>
<p> Scale the horizontal axis to 100 percent of total number of species. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_type">type</code></td>
<td>
<p> Type of plot (as in function <code><a href="graphics.html#topic+plot">plot</a></code>) </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_xlim">xlim</code></td>
<td>
<p> Limits for the horizontal axis. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_ylim">ylim</code></td>
<td>
<p> Limits for the vertical axis. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_specnames">specnames</code></td>
<td>
<p> Vector positions of species names to add to the rank-abundance curve. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_srt">srt</code></td>
<td>
<p> The string rotation in degrees of the species names (as in <code><a href="graphics.html#topic+par">par</a></code>). </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_return.data">return.data</code></td>
<td>
<p> Return the data used for plotting. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_rainbow">rainbow</code></td>
<td>
<p> Use rainbow colouring for the different curves. </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_legend">legend</code></td>
<td>
<p> Add the legend (you need to click in the graph where the legend needs to be plotted). </p>
</td></tr>
<tr><td><code id="rankabundance_+3A_...">...</code></td>
<td>
<p> Other arguments to be passed to functions <code><a href="graphics.html#topic+plot">plot</a></code> or <code><a href="graphics.html#topic+points">points</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide methods of calculating and plotting rank-abundance curves.
</p>
<p>The vertical axis can be scaled by various methods. Method &quot;abundance&quot; uses abundance, &quot;proportion&quot; uses proportional abundance (species abundance / total abundance), &quot;logabun&quot; calculates the logarithm of abundance using base 10 and &quot;accumfreq&quot; accumulates the proportional abundance.
</p>
<p>The horizontal axis can be scaled by the total number of species, or by 100 percent of all species by option &quot;scaledx&quot;.
</p>
<p>The method of calculating the  confidence interval for species proportion is described in Hayek and Buzas (1997).
</p>
<p>Functions <code>rankabundance</code> and <code>rankabuncomp</code> allow to calculate rank abundance curves for subsets of the community and environmental data sets. Function <code>rankabundance</code> calculates the rank abundance curve for the specified level of a selected environmental variable. Method <code>rankabuncomp</code> calculates the rank abundance curve for all levels of a selected environmental variable separatedly.
</p>


<h3>Value</h3>

<p>The functions provide information on rankabundance curves. Function <code>rankabundance</code> provides information on abundance, proportional abundance, logarithmic abundance and accumulated proportional abundance. The function also provides confidence interval limits for the proportion of each species (plower, pupper) and the proportion of species ranks (in percentage).
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Hayek, L.-A. C. &amp; Buzas, M.A. (1997). Surveying Natural Populations. Columbia University Press.
</p>
<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune.env)
data(dune)
RankAbun.1 &lt;- rankabundance(dune)
RankAbun.1
rankabunplot(RankAbun.1, scale='abundance', addit=FALSE, specnames=c(1,2,3))
rankabunplot(RankAbun.1, scale='logabun', addit=FALSE, specnames=c(1:30), 
    srt=45, ylim=c(1,100))
rankabuncomp(dune, y=dune.env, factor='Management', 
    scale='proportion', legend=FALSE)
## CLICK IN THE GRAPH TO INDICATE WHERE THE LEGEND NEEDS TO BE PLACED
## IF YOU OPT FOR LEGEND=TRUE.

## Not run: 
# ggplot2 plotting method

# Only label the two most abundant species
RA.data &lt;- rankabuncomp(dune, y=dune.env, factor='Management', 
    return.data=TRUE, specnames=c(1:2), legend=FALSE)

library(ggplot2)
library(ggrepel)

# possibly need for extrafont::loadfonts(device="win") to have Arial
# as alternative, use library(ggThemeAssist)
BioR.theme &lt;- theme(
        panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.line = element_line("gray25"),
        text = element_text(size = 12, family="Arial"),
        axis.text = element_text(size = 10, colour = "gray25"),
        axis.title = element_text(size = 14, colour = "gray25"),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.key = element_blank())

plotgg1 &lt;- ggplot(data=RA.data, aes(x = rank, y = abundance)) + 
    scale_x_continuous(expand=c(0, 1), sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(expand=c(0, 1), sec.axis = dup_axis(labels=NULL, name=NULL)) +
    geom_line(aes(colour=Grouping), size=1) +
    geom_point(aes(colour=Grouping, shape=Grouping), size=5, alpha=0.7) +
    geom_text_repel(data=subset(RA.data, labelit == TRUE), 
        aes(colour=Grouping, label=species), 
        angle=45, nudge_x=1, nudge_y=1, show.legend=FALSE) +
    BioR.theme +
    scale_color_brewer(palette = "Set1") +
    labs(x = "rank", y = "abundance", colour = "Management", shape = "Management")

plotgg1

# use different facets
# now label first 10 species
RA.data &lt;- rankabuncomp(dune, y=dune.env, factor='Management', 
    return.data=TRUE, specnames=c(1:10), legend=FALSE)

plotgg2 &lt;- ggplot(data=RA.data, aes(x = rank, y = abundance)) + 
    scale_x_continuous(expand=c(0, 1), sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(expand=c(0, 1), sec.axis = dup_axis(labels=NULL, name=NULL)) +
    geom_line(aes(colour=Grouping), size=1) +
    geom_point(aes(colour=Grouping), size=5, alpha=0.7) +
    geom_text_repel(data=subset(RA.data, labelit == TRUE), 
        aes(label=species), 
        angle=45, nudge_x=1, nudge_y=1, show.legend=FALSE) +
    BioR.theme +
    scale_color_brewer(palette = "Set1") +
    facet_wrap(~ Grouping) +
    labs(x = "rank", y = "abundance", colour = "Management")

plotgg2



## End(Not run) # dontrun
</code></pre>

<hr>
<h2 id='removeNAcomm'>Synchronize Community and Environmental Datasets</h2><span id='topic+removeNAcomm'></span><span id='topic+removeNAenv'></span><span id='topic+same.sites'></span><span id='topic+check.datasets'></span><span id='topic+check.ordiscores'></span><span id='topic+replaceNAcomm'></span><span id='topic+removezerospecies'></span><span id='topic+subsetcomm'></span><span id='topic+import.with.readxl'></span>

<h3>Description</h3>

<p>These functions may assist to ensure that the sites of the community dataset are the same sites as those from the environmental dataset, something that is assumed to be the case for the <span class="pkg">BiodiversityR</span> and <span class="pkg">vegan</span> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same.sites(x, y)
check.datasets(x, y)
check.ordiscores(x, ord, check.species = TRUE)
removeNAcomm(x, y, variable)
removeNAenv(x, variable)
removezerospecies(x)
subsetcomm(x, y, factor, level, returncomm = TRUE)

import.with.readxl(file = file.choose(), data.type = "community", sheet = NULL, 
    sitenames = "sites", column = "species", value = "abundance", 
    factor = "", level = "", cepnames = FALSE,
    write.csv = FALSE, csv.file = paste(data.type, ".csv", sep=""))


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeNAcomm_+3A_x">x</code></td>
<td>
<p> Data frame assumed to be the community dataset with variables corresponding to species. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_y">y</code></td>
<td>
<p> Data frame assumed to be the environmental dataset with variables corresponding to descriptors of sites. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_ord">ord</code></td>
<td>
<p> Ordination result. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_check.species">check.species</code></td>
<td>
<p> Should the species scores be checked (TRUE) or not. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_variable">variable</code></td>
<td>
<p> Name of the variable from the environmental dataset with NA values that indicate those sites that should be removed. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_factor">factor</code></td>
<td>
<p> Variable of the environmental data frame that defines subsets for the data frame. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_level">level</code></td>
<td>
<p> Level of the variable to create the subsets for the data frame. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_returncomm">returncomm</code></td>
<td>
<p> For the selected sites, return the community dataset (TRUE) or the environmental dataset. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_file">file</code></td>
<td>
<p> Location of the Excel (or Access) file. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_data.type">data.type</code></td>
<td>
<p> Type of the data set to be imported: one of &quot;community&quot;, &quot;environmental&quot; or &quot;stacked&quot;. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_sheet">sheet</code></td>
<td>
<p> Name of the sheet of the Excel file to import from (if missing, then <code>data.type</code> is used) </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_sitenames">sitenames</code></td>
<td>
<p> Name of categorical variable that provides the names for the sites. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_column">column</code></td>
<td>
<p> Name of the categorical variable for the columns of the crosstabulation (typically indicating species); passed to <code><a href="#topic+makecommunitydataset">makecommunitydataset</a></code>. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_value">value</code></td>
<td>
<p> Name of numerical variable for the cells of the crosstabulation (typically indicating abundance). The cells provide the sum of all values in the data frame; passed to <code><a href="#topic+makecommunitydataset">makecommunitydataset</a></code>. </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_cepnames">cepnames</code></td>
<td>
<p> Should the names of columns be abbreviated via <code><a href="vegan.html#topic+make.cepnames">make.cepnames</a></code> (TRUE) or not (FALSE). </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_write.csv">write.csv</code></td>
<td>
<p> Create a comma-delimited text file in the working directory (if <code>TRUE</code>). </p>
</td></tr>
<tr><td><code id="removeNAcomm_+3A_csv.file">csv.file</code></td>
<td>
<p> Name of the comma-delimited text file to be created. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>same.sites</code> provides a new data frame that has the same row names as the row names of the environmental data set and the same (species) variables as the original community data set. Sites from the original community data set that have no corresponding sites in the environmental data set are not included in the new community data set. (Hint: this function can be especially useful when some sites do not contain any species and where a community dataset was generated by the <code><a href="#topic+makecommunitydataset">makecommunitydataset</a></code> function.) 
</p>
<p>Function <code>check.datasets</code> checks whether the community and environmental data sets have the same number of rows, and (if this was the case) whether the rownames of both data sets are the same. The function also returns the dimensions of both data sets.
</p>
<p>Function <code>check.ordiscores</code> checks whether the community data set and the ordination result have the same number of rows (sites) and columns (species, optional for <code>check.species==TRUE</code>), and (if this was the case) whether the row and column names of both data sets are the same. Site and species scores for the ordination result are obtained via function <code><a href="vegan.html#topic+scores">scores</a></code> (<span class="pkg">vegan</span>).
</p>
<p>Functions <code>removeNAcomm</code> and <code>removeNAenv</code> provide a new data frame that does not contain <code>NA</code> for the specified variable. The specifed variable is part of the environmental data set. These functions are particularly useful when using community and environmental datasets, as new community and environmental datasets can be calculated that contain information from the same sample plots (sites). An additional result of <code>removeNAenv</code> is that factor levels of any categorical variable that do not occur any longer in the new data set are removed from the levels of the categorical variable.
</p>
<p>Function <code>replaceNAcomm</code> substitutes cells containing NA with 0 in the community data set.
</p>
<p>Function <code>removezerospecies</code> removes species from a community dataset that have total abundance that is smaller or equal to zero.
</p>
<p>Function <code>subsetcomm</code> makes a subset of sites that contain a specified level of a categorical variable from the environmental data set. The same functionality of selecting subsets of the community or environmental data sets are implemented in various functions of <span class="pkg">BiodiversityR</span> (for example <code><a href="#topic+diversityresult">diversityresult</a></code>, <code><a href="#topic+renyiresult">renyiresult</a></code> and <code><a href="#topic+accumresult">accumresult</a></code>) and have the advantage that it is not necessary to create a new data set. If a community dataset is returned, species that did not contain any individuals were removed from the data set. If an environmental dataset is returned, factor levels that did not occur were removed from the data set.
</p>
<p>Function <code>import.with.readxl</code> provides methods of importing community or environmental datasets through <code><a href="readxl.html#topic+read_excel">read_excel</a></code>.
</p>
<p>For stacked datasets, a community data set is created with function <code><a href="#topic+makecommunitydataset">makecommunitydataset</a></code>. For community data with more species than the limited number of columns in Excel, this may be the only option of importing a community dataset.
</p>
<p>An additional advantage of the function is that the community and environmental data can be stored in the same file. 
</p>
<p>You may want to check compatibility of the community and environmental datasets with functions <code><a href="#topic+check.datasets">check.datasets</a></code> and modify the community dataset through <code><a href="#topic+same.sites">same.sites</a></code>.
</p>


<h3>Value</h3>

<p>The functions return a data frame or results of tests on the correspondence between community and environmental data sets.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005) 
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune.env)
data(dune)
dune.env2 &lt;- dune.env
dune.env2[1:4,"Moisture"] &lt;- NA
dune2 &lt;- removeNAcomm(dune,dune.env2,"Moisture")
dune.env2 &lt;- removeNAenv(dune.env2,"Moisture")
dune3 &lt;- same.sites(dune,dune.env2)
check.datasets(dune,dune.env2)
check.datasets(dune2,dune.env2)
check.datasets(dune3,dune.env2)
dune4 &lt;- subsetcomm(dune,dune.env,"Management","NM",returncomm=TRUE)
dune.env4 &lt;- subsetcomm(dune,dune.env,"Management","NM",returncomm=FALSE)
dune5 &lt;- same.sites(dune,dune.env4)
check.datasets(dune4,dune5)
</code></pre>

<hr>
<h2 id='renyiresult'>Alternative Renyi Diversity Results</h2><span id='topic+renyiresult'></span><span id='topic+renyiplot'></span><span id='topic+renyiaccumresult'></span><span id='topic+renyicomp'></span>

<h3>Description</h3>

<p>Provides some alternative methods of obtaining results on Renyi diversity profile values than provided by <code><a href="vegan.html#topic+renyi">renyi</a></code> (<span class="pkg">vegan</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renyiresult(x, y=NULL, factor, level, method = "all",
    scales = c(0, 0.25, 0.5, 1, 2, 4, 8, Inf), evenness = FALSE ,...)

renyiplot(xr, addit=FALSE, pch = 1, 
    xlab = "alpha", ylab = "H-alpha", ylim = NULL,
    labelit = TRUE, legend = TRUE, legend.x="topleft", legend.ncol = 8, 
    col = 1, cex = 1, rainbow = TRUE, evenness = FALSE, ...)

renyiaccumresult(x, y=NULL, factor, level,
    scales=c(0, 0.25, 0.5, 1, 2, 4, 8, Inf), permutations = 100,...)

renyicomp(x, y, factor, sites=Inf,
    scales = c(0, 0.25, 0.5, 1, 2, 4, 8, Inf), permutations = 100, plotit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="renyiresult_+3A_x">x</code></td>
<td>
<p> Community data frame with sites as rows, species as columns and species abundance as cell values. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_y">y</code></td>
<td>
<p> Environmental data frame. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_factor">factor</code></td>
<td>
<p> Variable of the environmental data frame that defines subsets to calculate diversity profiles for. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_level">level</code></td>
<td>
<p> Level of the variable to create the subset to calculate diversity profiles. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_method">method</code></td>
<td>
<p> Method of calculating the diversity profiles: &quot;all&quot; calculates the diversity of the entire community (all sites pooled together), &quot;s&quot; calculates the diversity of each site separatedly. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_scales">scales</code></td>
<td>
<p> Scale parameter values as in function <code><a href="vegan.html#topic+renyi">renyi</a></code> (<span class="pkg">vegan</span>). </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_evenness">evenness</code></td>
<td>
<p> Calculate or plot the evenness profile. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_xr">xr</code></td>
<td>
<p> Result from <code><a href="vegan.html#topic+renyi">renyi</a></code> or <code>renyiresult</code>. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_addit">addit</code></td>
<td>
<p> Add diversity profile to an existing graph. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_pch">pch</code></td>
<td>
<p> Symbol used for drawing the diversity profiles (as in function <code><a href="graphics.html#topic+points">points</a></code>). </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_xlab">xlab</code></td>
<td>
<p> Label for the horizontal axis. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_ylab">ylab</code></td>
<td>
<p> Label for the vertical axis. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_ylim">ylim</code></td>
<td>
<p> Limits of the vertical axis. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_labelit">labelit</code></td>
<td>
<p> Provide site labels (site names) at beginning and end of the diversity profiles. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_legend">legend</code></td>
<td>
<p> Add the legend (you need to click in the graph where the legend needs to be plotted). </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_legend.x">legend.x</code></td>
<td>
<p> Location of the legend; see also <code><a href="graphics.html#topic+legend">legend</a></code>. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_legend.ncol">legend.ncol</code></td>
<td>
<p> number of columns for the legend (as in function <code><a href="graphics.html#topic+legend">legend</a></code>). </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_col">col</code></td>
<td>
<p> Colour for the diversity profile (as in function <code><a href="graphics.html#topic+points">points</a></code>). </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_cex">cex</code></td>
<td>
<p> Character expansion factor (as in function <code><a href="graphics.html#topic+points">points</a></code>).  </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_rainbow">rainbow</code></td>
<td>
<p> Use rainbow colours for the diversity profiles. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_sites">sites</code></td>
<td>
<p> Number of accumulated sites to provide profile values. </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_permutations">permutations</code></td>
<td>
<p> Number of permutations for the Monte-Carlo simulations for accumulated renyi diversity profiles (estimated by <code><a href="vegan.html#topic+renyi">renyiaccum</a></code>). </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_plotit">plotit</code></td>
<td>
<p> Plot the results (you need to click in the graph where the legend should be plotted). </p>
</td></tr>
<tr><td><code id="renyiresult_+3A_...">...</code></td>
<td>
<p> Other arguments to be passed to functions <code><a href="vegan.html#topic+renyi">renyi</a></code> or <code><a href="graphics.html#topic+plot">plot</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide some alternative methods of obtaining results with diversity profiles, although function <code><a href="vegan.html#topic+renyi">renyi</a></code> is always used to calculate the diversity profiles.
</p>
<p>The method of calculating the diversity profiles: &quot;all&quot; calculates the diversity profile of the entire community (all sites pooled together), whereas &quot;s&quot; calculates the diversity profile of each site separatedly. The evenness profile is calculated by subtracting the profile value at scale 0 from all the profile values.
</p>
<p>Functions <code>renyiresult</code>, <code>renyiaccumresult</code> and <code>renyicomp</code> allow to calculate diversity profiles for subsets of the community and environmental data sets. functions <code>renyiresult</code> and <code>renyiaccumresult</code> calculate the diversity profiles for the specified level of a selected environmental variable. Method <code>renyicomp</code> calculates the diversity profile for all levels of a selected environmental variable separatedly.
</p>
<p>Functions <code>renyicomp</code> and <code>renyiaccumresult</code> calculate accumulation curves for the Renyi diversity profile by randomised pooling of sites and calculating diversity profiles for the pooled sites as implemented in <code><a href="vegan.html#topic+renyi">renyiaccum</a></code>. The method is similar to the random method of species accumulation (<code><a href="vegan.html#topic+specaccum">specaccum</a></code>). If the number of &quot;sites&quot; is not changed from the default, it is replaced by the sample size of the level with the fewest number of sites.
</p>


<h3>Value</h3>

<p>The functions provide alternative methods of obtaining Renyi diversity profiles.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt R., Degrande A., Turyomurugyendo L., Mbosso C., Van Damme P., Simons A.J. (2001). Comparing species richness and evenness contributions to on-farm tree diversity for data sets with varying sample sizes from Kenya, Uganda, Cameroon and Nigeria with randomised diversity profiles. Paper presented at IUFRO conference on forest biometry, modeling and information science, 26-29 June, University of Greenwich, UK
</p>
<p>Kindt R. (2002). Methodology for tree species diversification planning for African agroecosystems. Thesis submitted in fulfilment of the requirement of the degree of doctor (PhD) in applied biological sciences. Faculty of agricultural and applied biological sciences, Ghent University, Ghent (Belgium), 332+xi pp.
</p>
<p>Kindt R., Van Damme P. &amp; Simons A.J. (2006). Tree diversity in western Kenya: using diversity profiles to characterise richness and evenness. Biodiversity and Conservation 15: 1253-1270.
</p>
<p>Kindt, R. &amp; Coe, R. (2005) 
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> 
</p>
<p><a href="https://rpubs.com/Roeland-KINDT">https://rpubs.com/Roeland-KINDT</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renyi.long">renyi.long</a></code>, <code><a href="#topic+renyicomp.long">renyicomp.long</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan)
data(dune.env)
data(dune)
Renyi.1 &lt;- renyiresult(dune, y=dune.env, factor='Management', level='NM', 
    method='s')
Renyi.1
renyiplot(Renyi.1, evenness=FALSE, addit=FALSE, pch=1,col='1', cex=1, 
    legend=FALSE)
## CLICK IN THE GRAPH TO INDICATE WHERE THE LEGEND NEEDS TO BE PLACED
## IN CASE THAT YOU OPT FOR LEGEND=TRUE

## Not run: 
# ggplot2 plotting method

Renyi.2 &lt;- renyicomp(dune, y=dune.env, factor='Management', 
  scales=c(0, 0.25, 0.5, 1, 2, 4, 8, Inf), permutations=100, plotit=F)
Renyi.2

library(ggplot2)

# change the theme
# possibly need for extrafont::loadfonts(device="win") to have Arial
# as alternative, use library(ggThemeAssist)
BioR.theme &lt;- theme(
        panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.line = element_line("gray25"),
        text = element_text(size = 12, family="Arial"),
        axis.text = element_text(size = 10, colour = "gray25"),
        axis.title = element_text(size = 14, colour = "gray25"),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.key = element_blank())

renyi.long2 &lt;- renyicomp.long(Renyi.2, label.freq=1)

plotgg1 &lt;- ggplot(data=renyi.long2, aes(x=Scales, y=Diversity, ymax=UPR, ymin=LWR)) + 
    scale_x_discrete() +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    geom_line(data=renyi.long2, aes(x=Obs, colour=Grouping), size=2) +
    geom_point(data=subset(renyi.long2, labelit==TRUE), 
        aes(colour=Grouping, shape=Grouping), size=5) +
    geom_ribbon(data=renyi.long2, aes(x=Obs, colour=Grouping), alpha=0.2, show.legend=FALSE) + 
    BioR.theme +
    scale_color_brewer(palette = "Set1") +
    labs(x=expression(alpha), y = "Diversity", colour = "Management", shape = "Management")

plotgg1

# calculate a separate diversity profile for each site
Renyi.3 &lt;- renyiresult(dune, evenness=FALSE, method="s", 
  scales=c(0, 0.25, 0.5, 1, 2, 4, 8, Inf))
Renyi.3

renyi.long3 &lt;- renyi.long(Renyi.3, env.data=dune.env, label.freq=2)

plotgg2 &lt;- ggplot(data=renyi.long3, aes(x=Scales, y=Diversity, group=Grouping)) + 
    scale_x_discrete() +
    scale_y_continuous(sec.axis = dup_axis(name=NULL)) +
    geom_line(aes(colour=Management), size=2) +
    geom_point(data=subset(renyi.long3, labelit==TRUE), 
        aes(colour=Management, shape=Management), size=5) +
    BioR.theme +
    scale_color_brewer(palette = "Set1") +
    labs(x=expression(alpha), y="Diversity", colour="Management")

plotgg2

plotgg3 &lt;- ggplot(data=renyi.long3, aes(x=Scales, y=Diversity, group=Grouping)) + 
    scale_x_discrete() +
    scale_y_continuous(sec.axis = dup_axis(name=NULL)) +
    geom_line(aes(colour=Management), size=1) +
    geom_point(data=subset(renyi.long3, labelit==TRUE), 
        aes(colour=Management, shape=Management), size=2) +
    BioR.theme +
    scale_color_brewer(palette = "Set1") +
    facet_wrap(~ Management) +
    labs(x=expression(alpha), y="Diversity", colour="Management")

plotgg3


## End(Not run) # dontrun
</code></pre>

<hr>
<h2 id='sites.long'>Helper Functions to Prepare Plotting of Accumulation, Diversity Profile and Ordiplot Results via ggplot2</h2><span id='topic+sites.long'></span><span id='topic+species.long'></span><span id='topic+centroids.long'></span><span id='topic+vectorfit.long'></span><span id='topic+ordisurfgrid.long'></span><span id='topic+ordiellipse.long'></span><span id='topic+pvclust.long'></span><span id='topic+axis.long'></span><span id='topic+accumcomp.long'></span><span id='topic+renyicomp.long'></span><span id='topic+renyi.long'></span>

<h3>Description</h3>

<p>These functions organize outputs from <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code>, <code><a href="#topic+accumcomp">accumcomp</a></code> and <code><a href="#topic+renyicomp">renyicomp</a></code> so these can be plotted with <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sites.long(x, env.data = NULL)

species.long(x, spec.data = NULL)

centroids.long(y, grouping, FUN = mean, centroids.only = FALSE)

vectorfit.long(z)

ordisurfgrid.long(z)

ordiellipse.long(z, grouping.name = "Grouping")

pvclust.long(cl, cl.data)

axis.long(w, choices = c(1, 2), cmdscale.model=FALSE, CAPdiscrim.model=FALSE)

accumcomp.long(x, ci = 2, label.freq = 1)

renyicomp.long(x, label.freq = 1)

renyi.long(x, env.data=NULL, label.freq = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sites.long_+3A_x">x</code></td>
<td>
<p> Result of <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code>, <code><a href="#topic+accumcomp">accumcomp</a></code> or <code><a href="#topic+renyicomp">renyicomp</a></code> </p>
</td></tr>
<tr><td><code id="sites.long_+3A_env.data">env.data</code></td>
<td>
<p> Environmental descriptors for each site. </p>
</td></tr>
<tr><td><code id="sites.long_+3A_spec.data">spec.data</code></td>
<td>
<p> Descriptors for each species. </p>
</td></tr>
<tr><td><code id="sites.long_+3A_y">y</code></td>
<td>
<p> Result of function <a href="#topic+sites.long">sites.long</a>. </p>
</td></tr>
<tr><td><code id="sites.long_+3A_grouping">grouping</code></td>
<td>
<p> Variable defining the centroids </p>
</td></tr>
<tr><td><code id="sites.long_+3A_fun">FUN</code></td>
<td>
<p> A function to compute the summary statistics which can be applied to all data subsets, as in <code><a href="stats.html#topic+aggregate">aggregate</a></code> </p>
</td></tr>
<tr><td><code id="sites.long_+3A_centroids.only">centroids.only</code></td>
<td>
<p> Return the coordinates for the centroids </p>
</td></tr>
<tr><td><code id="sites.long_+3A_z">z</code></td>
<td>
<p> Result of <code><a href="vegan.html#topic+envfit">envfit</a></code>, <code><a href="vegan.html#topic+ordisurf">ordisurf</a></code> or <code><a href="vegan.html#topic+ordiellipse">ordiellipse</a></code>  </p>
</td></tr>
<tr><td><code id="sites.long_+3A_grouping.name">grouping.name</code></td>
<td>
<p> Name for the categorical variable, expected as the factor used in the earlier ordiellipse call. </p>
</td></tr>
<tr><td><code id="sites.long_+3A_cl">cl</code></td>
<td>
<p> Result of <code><a href="pvclust.html#topic+pvclust">pvclust</a></code>  </p>
</td></tr>
<tr><td><code id="sites.long_+3A_cl.data">cl.data</code></td>
<td>
<p> Result of <code><a href="vegan.html#topic+ordicluster">ordicluster</a></code>  </p>
</td></tr>  
<tr><td><code id="sites.long_+3A_w">w</code></td>
<td>
<p> Ordination object from which the <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code> was obtained, expected to be fitted in vegan.  </p>
</td></tr>
<tr><td><code id="sites.long_+3A_choices">choices</code></td>
<td>
<p> Ordination axes selected, as in <code><a href="vegan.html#topic+ordiplot">ordiplot</a></code> </p>
</td></tr>
<tr><td><code id="sites.long_+3A_cmdscale.model">cmdscale.model</code></td>
<td>
<p> Use <code>TRUE</code> is the model was fitted via <code><a href="stats.html#topic+cmdscale">cmdscale</a></code> </p>
</td></tr>
<tr><td><code id="sites.long_+3A_capdiscrim.model">CAPdiscrim.model</code></td>
<td>
<p> Use <code>TRUE</code> is the model was fitted via <code><a href="#topic+CAPdiscrim">CAPdiscrim</a></code> </p>
</td></tr>
<tr><td><code id="sites.long_+3A_ci">ci</code></td>
<td>
<p> Multiplier for confidence intervals as in <code><a href="vegan.html#topic+specaccum">specaccum</a></code>. In case 'NA' is provided, then the multiplier is calculated via <code><a href="stats.html#topic+qt">qt</a></code>. </p>
</td></tr>
<tr><td><code id="sites.long_+3A_label.freq">label.freq</code></td>
<td>
<p> Frequency of labels along the x-axis (count between labels). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Examples for ordiplot results are shown below.
</p>
<p>Function <code>pvclust.long</code> combines data from <code><a href="pvclust.html#topic+pvclust">pvclust</a></code> with coordinates of nodes and branches from <code><a href="vegan.html#topic+ordicluster">ordicluster</a></code>. The variable of <code>prune</code> allows to remove higher levels of nodes and branches in the clustering hierarchy in a similar way as argument <code>prune</code> for <code><a href="vegan.html#topic+ordicluster">ordicluster</a></code> - see examples.
</p>
<p>See also section: see examples for species accumulation curves and Renyi diversity profiles
</p>


<h3>Value</h3>

<p>These functions produce data.frames that can subsequentially be plotted via <code>ggplot</code> methods.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005)
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> 
</p>
<p><a href="https://rpubs.com/Roeland-KINDT">https://rpubs.com/Roeland-KINDT</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+accumcomp">accumcomp</a></code>, <code><a href="#topic+renyicomp">renyicomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# ggplot2 plotting method
library(ggplot2)
library(ggforce)
library(concaveman)
library(ggrepel)
library(ggsci)
library(dplyr)

library(vegan)
data(dune)
data(dune.env)

attach(dune)
attach(dune.env)

Ordination.model1 &lt;- capscale(dune ~ Management, data=dune.env, 
  distance='kulczynski', sqrt.dist=F, add='cailliez')

plot1 &lt;- ordiplot(Ordination.model1, choices=c(1,2), scaling='species')

# obtain 'long' data from the ordiplot object
sites1 &lt;- sites.long(plot1, env.data=dune.env)
species1 &lt;- species.long(plot1)
centroids1 &lt;- centroids.long(sites1, Management, FUN=median)
centroids2 &lt;- centroids.long(sites1, Management, FUN=median, centroids.only=TRUE)

# information on percentage variation from the fitted ordination
axislabs &lt;- axis.long(Ordination.model1, choices=c(1 , 2))

# change the theme
# possibly need for extrafont::loadfonts(device="win") to have Arial
# as alternative, use library(ggThemeAssist)
BioR.theme &lt;- theme(
        panel.background = element_blank(),
        panel.border = element_blank(),
        panel.grid = element_blank(),
        axis.line = element_line("gray25"),
        text = element_text(size = 12, family="Arial"),
        axis.text = element_text(size = 10, colour = "gray25"),
        axis.title = element_text(size = 14, colour = "gray25"),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 14),
        legend.key = element_blank())

# no species scores
# centroids calculated directly via the centroids.long function 
plotgg1 &lt;- ggplot() + 
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axislabs[1, "label"]) +
    ylab(axislabs[2, "label"]) +  
    scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +    
    geom_mark_hull(data=sites1, aes(x=axis1, y=axis2, colour = Management), 
        concavity = 0.1, alpha=0.8, size=0.2, show.legend=FALSE) +
    geom_point(data=sites1, aes(x=axis1, y=axis2, colour=Management, shape=Management), 
        size=5) +
#    geom_segment(data=species1, aes(x=0, y=0, xend=axis1*2, yend=axis2*2), 
#        size=1.2, arrow=arrow()) +
#    geom_label_repel(data=species1, aes(x=axis1*2, y=axis2*2, label=labels)) +
    geom_point(data=centroids.long(sites1, grouping=Management, centroids.only=TRUE), 
        aes(x=axis1c, y=axis2c, colour=Centroid, shape=Centroid), size=10, show.legend=FALSE) +
    geom_segment(data=centroids.long(sites1, grouping=Management), 
        aes(x=axis1c, y=axis2c, xend=axis1, yend=axis2, colour=Management), 
        size=1, show.legend=FALSE) +
    BioR.theme +
    ggsci::scale_colour_npg() +
    coord_fixed(ratio=1)

plotgg1

# select species to plot based on goodness of fit
spec.envfit &lt;- envfit(plot1, env=dune)
spec.data1 &lt;- data.frame(r=spec.envfit$vectors$r, p=spec.envfit$vectors$pvals)
species2 &lt;- species.long(plot1, spec.data=spec.data1)
species2 &lt;- species2[species2$r &gt; 0.6, ]

# after_scale introduced in ggplot2 3.3.0
plotgg2 &lt;- ggplot() + 
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axislabs[1, "label"]) +
    ylab(axislabs[2, "label"]) +   
    scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +    
    geom_mark_ellipse(data=sites1, aes(x=axis1, y=axis2, 
        colour=Management, fill=after_scale(alpha(colour, 0.2))), 
        expand=0, size=0.2, show.legend=TRUE) +
    geom_point(data=sites1, aes(x=axis1, y=axis2, colour=Management, shape=Management), 
        size=5) +
    geom_segment(data=centroids.long(sites1, grouping=Management), 
        aes(x=axis1c, y=axis2c, xend=axis1, yend=axis2, colour=Management), 
        size=1, show.legend=FALSE) +
    geom_segment(data=species2, aes(x=0, y=0, xend=axis1*2, yend=axis2*2), 
        size=1.2, arrow=arrow()) +
    geom_label_repel(data=species2, aes(x=axis1*2, y=axis2*2, label=labels)) +
    BioR.theme +
    ggsci::scale_colour_npg() +
    coord_fixed(ratio=1)

plotgg2

# Add contour and vector for a continuous explanatory variable
Ordination.model2 &lt;- capscale(dune ~ Management, data=dune.env, 
  distance='kulczynski', sqrt.dist=F, add='cailliez')

plot2 &lt;- ordiplot(Ordination.model2, choices=c(1,2), scaling='species')

sites2 &lt;- sites.long(plot2, env.data=dune.env)
axislabs &lt;- axis.long(Ordination.model2, choices=c(1 , 2))

dune.envfit &lt;- envfit(plot2, dune.env)
vectors2 &lt;- vectorfit.long(dune.envfit)

A1.surface &lt;- ordisurf(plot2, y=A1)
A1.surface
A1.grid &lt;- ordisurfgrid.long(A1.surface)

plotgg3 &lt;- ggplot() + 
    geom_contour_filled(data=A1.grid, aes(x=x, y=y, z=z)) +
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axislabs[1, "label"]) +
    ylab(axislabs[2, "label"]) +  
    scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +    
    geom_point(data=sites2, aes(x=axis1, y=axis2, size=A1), shape=21, colour="black", fill="red") +
    geom_segment(data=subset(vectors2, vector=A1), aes(x=0, y=0, xend=axis1*2, yend=axis2*2), 
        size=1.2, arrow=arrow()) +
    geom_label_repel(data=subset(vectors2, vector=A1), aes(x=axis1*2, y=axis2*2, 
        label=vector), size=5) +
    BioR.theme +
    scale_fill_viridis_d() +
    scale_size(range=c(1, 20)) +
    labs(fill="A1") +
    coord_fixed(ratio=1)

plotgg3

# after_stat introduced in ggplot2 3.3.0
plotgg4 &lt;- ggplot() + 
    geom_contour(data=A1.grid, aes(x=x, y=y, z=z, colour=factor(after_stat(level))), size=2) +
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axislabs[1, "label"]) +
    ylab(axislabs[2, "label"]) +  
    scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +    
    geom_point(data=sites2, aes(x=axis1, y=axis2, size=A1), shape=21, colour="black", fill="red") +
    geom_label_repel(data=sites2, aes(x=axis1, y=axis2, label=labels), 
        colour='black', size=4) +
    BioR.theme +
    scale_colour_viridis_d() +
    scale_size(range=c(1, 20)) +
    labs(colour="A1") +
    coord_fixed(ratio=1)

plotgg4

# example of Voronoi segmentation
plotgg5 &lt;- ggplot(data=sites2, aes(x=axis1, y=axis2)) +
    geom_voronoi_tile(aes(fill = Management, group=-1L), max.radius=0.2) +
    geom_voronoi_segment(colour="grey50") +
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axislabs[1, "label"]) +
    ylab(axislabs[2, "label"]) +  
    scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +    
    geom_point() +
    BioR.theme +
    ggsci::scale_colour_npg() +
    coord_fixed(ratio=1)

plotgg5

# adding ellipse via ordiellipse

plot3 &lt;- ordiplot(Ordination.model1, choices=c(1,2), scaling='species')
axislabs &lt;- axis.long(Ordination.model1, choices=c(1 , 2))

Management.ellipses &lt;- ordiellipse(plot3, groups=Management, display="sites", kind="sd")
Management.ellipses.long2 &lt;- ordiellipse.long(Management.ellipses, grouping.name="Management")

plotgg6 &lt;- ggplot() + 
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axislabs[1, "label"]) +
    ylab(axislabs[2, "label"]) +  
    scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    geom_polygon(data=Management.ellipses.long2, 
                   aes(x=axis1, y=axis2, colour=Management, 
                       fill=after_scale(alpha(colour, 0.2))), 
              size=0.2, show.legend=FALSE) +
    geom_point(data=sites1, aes(x=axis1, y=axis2, colour=Management, shape=Management), 
        size=5) +
    geom_segment(data=centroids.long(sites1, grouping=Management), 
        aes(x=axis1c, y=axis2c, xend=axis1, yend=axis2, colour=Management), 
        size=1, show.legend=FALSE) +
    BioR.theme +
    ggsci::scale_colour_npg() +
    coord_fixed(ratio=1)

plotgg6

# adding cluster results via pvclust.long

library(pvclust)
# transformation as pvclust works with Euclidean distance
dune.Hellinger &lt;- disttransform(dune, method='hellinger')
dune.pv &lt;- pvclust(t(dune.Hellinger), 
                   method.hclust="mcquitty",
                   method.dist="euclidean",
                   nboot=1000)

plot(dune.pv)
pvrect(dune.pv, alpha=0.89, pv="au")

# Model fitted earlier
plot1 &lt;- ordiplot(Ordination.model1, choices=c(1,2), scaling='species')
cl.data1 &lt;- ordicluster(plot1, cluster=as.hclust(dune.pv$hclust))

sites1 &lt;- sites.long(plot1, env.data=dune.env)
axislabs &lt;- axis.long(Ordination.model1, choices=c(1 , 2))

cl.data1 &lt;- ordicluster(plot2, cluster=as.hclust(dune.pv$hclust))
pvlong &lt;- pvclust.long(dune.pv, cl.data1)

# as in example for ordicluster, prune higher level hierarchies
plotgg7 &lt;- ggplot() + 
    geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
    geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +  
    xlab(axislabs[1, "label"]) +
    ylab(axislabs[2, "label"]) +  
    scale_x_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +
    scale_y_continuous(sec.axis = dup_axis(labels=NULL, name=NULL)) +   
    geom_segment(data=subset(pvlong$segments, pvlong$segments$prune &gt; 3),
               aes(x=x1, y=y1, xend=x2, yend=y2, colour=au&gt;=0.89, 
                   size=au),
               show.legend=TRUE) +
    geom_point(data=subset(pvlong$nodes, pvlong$nodes$prune &gt; 3), 
               aes(x=x, y=y, fill=au&gt;=0.89), 
               shape=21, size=2, colour="black") +
    geom_point(data=sites1, 
               aes(x=axis1, y=axis2, shape=Management), 
               colour="darkolivegreen4", alpha=0.9, size=5) +
    geom_text(data=sites1,
              aes(x=axis1, y=axis2, label=labels)) +
    BioR.theme +
    ggsci::scale_colour_npg() +
    scale_size(range=c(0.3, 2)) +
    scale_shape_manual(values=c(15, 16, 17, 18)) +
    guides(shape = guide_legend(override.aes = list(linetype = 0))) +
    coord_fixed(ratio=1)

plotgg7


## End(Not run) # dontrun
</code></pre>

<hr>
<h2 id='spatialsample'>Spatial Sampling within a Polygon</h2><span id='topic+spatialsample'></span>

<h3>Description</h3>

<p>Spatial sampling within a polygon provides several methods of selecting rectangular sample plots within a polygon. Using a GIS package may be preferred for actual survey design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialsample(x,method="random",n=5,xwidth=0.5,ywidth=0.5,xleft=0,
    ylower=0,xdist=0,ydist=0,plotit=T,plothull=F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatialsample_+3A_x">x</code></td>
<td>
<p> 2-column matrix with the coordinates of the vertices of the polygon. The first column contains the horizontal (x) position, the second column contains the vertical (y) position. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_method">method</code></td>
<td>
<p> Method of sampling, any of &quot;random&quot;, &quot;grid&quot; or &quot;random grid&quot;. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_n">n</code></td>
<td>
<p> Number of sample plots to be selected, or number of horizontal and vertical grid positions. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_xwidth">xwidth</code></td>
<td>
<p> Horizontal width of the sample plots. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_ywidth">ywidth</code></td>
<td>
<p> Vertical width of the sample plots. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_xleft">xleft</code></td>
<td>
<p> Horizontal starting position of the grid. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_ylower">ylower</code></td>
<td>
<p> Vertical starting position of the grid. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_xdist">xdist</code></td>
<td>
<p> Horizontal distance between grid locations. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_ydist">ydist</code></td>
<td>
<p> Vertical distance between grid locations. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_plotit">plotit</code></td>
<td>
<p> Plot the sample plots on the current graph. </p>
</td></tr>
<tr><td><code id="spatialsample_+3A_plothull">plothull</code></td>
<td>
<p> Plot a convex hull around the sample plots. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial sampling within a polygon provides several methods of selecting the position of sample plots.
</p>
<p>Method &quot;random&quot; selects random positions of the sample plots using simple random sampling.
</p>
<p>Method &quot;grid&quot; selects sample plots from a grid defined by &quot;xleft&quot;, &quot;ylower&quot;, &quot;xdist&quot; and &quot;ydist&quot;. In case <code>xdist=0</code> or <code>ydist=0</code>, then the number of grid positions are defined by &quot;n&quot;. In case &quot;xleft&quot; or &quot;ylower&quot; are below the minimum  position of any vertix of the polygon, then a random starting position is selected for the grid.
</p>
<p>Method &quot;random grid&quot; selects sample plots at random from the sampling grid using the same methods of defining the grid as for method &quot;grid&quot;.
</p>


<h3>Value</h3>

<p>The function returns a list of centres of rectangular sample plots.
</p>


<h3>Author(s)</h3>

<p>Roeland Kindt (World Agroforestry Centre)</p>


<h3>References</h3>

<p>Kindt, R. &amp; Coe, R. (2005) 
Tree diversity analysis: A manual and
software for common statistical methods for ecological and
biodiversity studies.
</p>
<p><a href="https://www.worldagroforestry.org/output/tree-diversity-analysis">https://www.worldagroforestry.org/output/tree-diversity-analysis</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splancs)
area &lt;- array(c(10,10,15,35,40,35,5,35,35,30,30,10), dim=c(6,2))
landuse1 &lt;- array(c(10,10,15,15,30,35,35,30), dim=c(4,2))
landuse2 &lt;- array(c(10,10,15,15,35,30,10,30,30,35,30,15), dim=c(6,2))
landuse3 &lt;- array(c(10,10,30,35,40,35,5,10,15,30,30,10), dim=c(6,2))
plot(area[,1], area[,2], type="n", xlab="horizontal position", 
    ylab="vertical position", lwd=2, bty="l")
polygon(landuse1)
polygon(landuse2)
polygon(landuse3)
spatialsample(area, method="random", n=20, xwidth=1, ywidth=1, plotit=TRUE, 
    plothull=FALSE)
spatialsample(area, method="grid", xwidth=1, ywidth=1, plotit=TRUE, xleft=12, 
    ylower=7, xdist=4, ydist=4)
spatialsample(area, method="random grid", n=20, xwidth=1, ywidth=1, 
    plotit=TRUE, xleft=12, ylower=7, xdist=4, ydist=4)
</code></pre>

<hr>
<h2 id='transfgradient'>Gradient for Hypothetical Example of Turover of Species Composition</h2><span id='topic+transfgradient'></span>

<h3>Description</h3>

<p>This dataset documents the site sequence of 19 sites on a gradient determined from unimodal species distributions. The dataset is accompanied by <code><a href="#topic+transfspecies">transfspecies</a></code> that documents the species composition of the sites. This is a hypothetical example that allows to investigate how well ecological distance measures or ordination methods recover the expected best sequence of sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(transfgradient)</code></pre>


<h3>Format</h3>

<p>A data frame with 19 observations on the following variable.
</p>

<dl>
<dt><code>gradient</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Legendre, P. &amp; Gallagher, E.D. (2001) Ecologically meaningful transformations for ordination of species data. Oecologia 129: 271-280. 
</p>


<h3>References</h3>

<p>Figure 3a.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(transfspecies)
data(transfgradient)
plot(transfspecies[,1]~transfgradient[,1],xlab="gradient",
    ylab="species abundance",type="n",ylim=c(0.5,8.5))
for (i in 1:9) {points(transfgradient[,1],transfspecies[,i],type="o",pch=i)}
</code></pre>

<hr>
<h2 id='transfspecies'>Hypothetical Example of Turover of Species Composition</h2><span id='topic+transfspecies'></span>

<h3>Description</h3>

<p>This dataset documents the species composition of 19 sites that follow a specific sequence of sites as determined from unimodal species distributions. The dataset is accompanied by <code><a href="#topic+transfgradient">transfgradient</a></code> that documents the gradient in species turnover. This is a hypothetical example that allows to investigate how well ecological distance measures or ordination methods recover the expected best sequence of sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(transfspecies)</code></pre>


<h3>Format</h3>

<p>A data frame with 19 observations on the following 9 variables.
</p>

<dl>
<dt><code>species1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>species2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>species3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>species4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>species5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>species6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>species7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>species8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>species9</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The example in the Tree Diversity Analysis manual only looks at the ecological distance from the first site. Hence, only the first 10 sites that share some species with this site should be selected.
</p>
<p>This dataset enables investigations of how well ecological distance measures and ordination diagrams reconstruct the gradient (sequence of sites). The gradient expresses how the sites would be arranged based on their species composition.
</p>


<h3>Source</h3>

<p>Legendre, P. &amp; Gallagher, E.D. (2001) Ecologically meaningful transformations for ordination of species data. Oecologia 129: 271-280. 
</p>


<h3>References</h3>

<p>Figure 3a.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(transfspecies)
data(transfgradient)
plot(transfspecies[,1]~transfgradient[,1],xlab="gradient",
    ylab="species abundance",type="n",ylim=c(0.5,8.5))
for (i in 1:9) {points(transfgradient[,1],transfspecies[,i],type="o",pch=i)}
</code></pre>

<hr>
<h2 id='treegoer.score'>
Calculate climate scores with the Tree Globally Observed Environmental Ranges (TreeGOER) database.
</h2><span id='topic+treegoer.score'></span><span id='topic+treegoer.widen'></span><span id='topic+treegoer.filter'></span><span id='topic+treegoer.position'></span><span id='topic+treegoer.map'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+treegoer.score">treegoer.score</a></code> calculates a climate score via a similar algorithm that is used internally in the GlobalUsefulNativeTrees (GlobUNT) database (Kindt et al. 2023, <a href="https://doi.org/10.1038/s41598-023-39552-1">doi:10.1038/s41598-023-39552-1</a>). The function depends on <code><a href="#topic+treegoer.filter">treegoer.filter</a></code> and requires a data set (argument <code>treegoer.wide</code>) as created from the Tree Globally Observed Environmental Ranges (TreeGOER) database (Kindt 2023, <a href="https://doi.org/10.1111/gcb.16914">doi:10.1111/gcb.16914</a>) via <code><a href="#topic+treegoer.widen">treegoer.widen</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
treegoer.score(site.data, 
  site.species = treegoer.wide$species,
  treegoer.wide, 
  filter.vars = c("bio05", "bio14", "climaticMoistureIndex"),
  upper.only.vars = NULL,
  lower.only.vars = NULL)

treegoer.filter(site.data,
  treegoer.wide, 
  filter.vars = c("bio05", "bio14", "climaticMoistureIndex"),
  upper.only.vars = NULL,
  lower.only.vars = NULL,
  limit.vars = c("Q05", "Q95")) 

treegoer.widen(treegoer,
  species = unique(treegoer$species)[1:100],
  filter.vars = c("bio05", "bio14", "climaticMoistureIndex"))
  
treegoer.position(site.data, 
  treegoer.wide, 
  focal.var  = "bio01")

treegoer.map(map.rast, 
  map.species=treegoer[1, "species"],
  treegoer, 
  filter.vars=c("bio05", "bio14", "climaticMoistureIndex"),
  upper.only.vars = NULL,
  lower.only.vars = NULL,
  verbose=FALSE)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treegoer.score_+3A_site.data">site.data</code></td>
<td>
<p> Data set with 1 row, containing the environmental conditions at the planting site for the selected environmental variables of the TreeGOER database. This data set can be set by selecting a city from the CitiesGOER datase (<a href="https://zenodo.org/records/10004594">https://zenodo.org/records/10004594</a>) or a weather station  from the ClimateForecasts database (<a href="https://zenodo.org/records/10726088">https://zenodo.org/records/10726088</a>). </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_site.species">site.species</code></td>
<td>
<p> Species for which the climate score will be calculated.  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_treegoer.wide">treegoer.wide</code></td>
<td>
<p> Data set created by <code><a href="#topic+treegoer.widen">treegoer.widen</a></code> from the TreeGOER database, or another data set with the same variables.  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_filter.vars">filter.vars</code></td>
<td>
<p> Environmental variables for which ranges (minimum, maximum and 0.05, 0.25, 0.75 and 0.95 quantile) are documented in the treegoer.wide data set.  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_limit.vars">limit.vars</code></td>
<td>
<p> Selection of the lower and upper limits for the environmental ranges, typically set as <code>c("MIN", "MAX")</code> (marginal bioclimatic species domain as in the BIOCLIM algorithm; see Booth 2018, <a href="https://doi.org/10.1111/aec.12628">doi:10.1111/aec.12628</a>), <code>c("Q05", "Q95")</code> (core of the domain) or <code>c("QRT1", "QRT3")</code> (middle of the domain).  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_upper.only.vars">upper.only.vars</code></td>
<td>
<p> Selection of variables that will only be checked at the upper limits.  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_lower.only.vars">lower.only.vars</code></td>
<td>
<p> Selection of variables that will only be checked at the lower limits.  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_treegoer">treegoer</code></td>
<td>
<p> Data set with environmental limits that was locally downloaded file (<code>TreeGOER_2023.txt</code>) that was downloaded from the archive (<a href="https://zenodo.org/records/10008994">https://zenodo.org/records/10008994</a>).  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_species">species</code></td>
<td>
<p> Selection of species to document in the wide format.  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_focal.var">focal.var</code></td>
<td>
<p> Selection of variable to calculate the position of planting site in environmental space.  </p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_map.rast">map.rast</code></td>
<td>
<p> SpatRaster object (<code><a href="terra.html#topic+rast">rast</a></code>) with layers showing the environmental conditions of planting sites.</p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_map.species">map.species</code></td>
<td>
<p> Species selected for mapping.</p>
</td></tr>
<tr><td><code id="treegoer.score_+3A_verbose">verbose</code></td>
<td>
<p> Report progress on the creation of the suitability map (when <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the climate score uses an expanded version of the algorithms used by BIOCLIM (Booth 2018, <a href="https://doi.org/10.1111/aec.12628">doi:10.1111/aec.12628</a>).
</p>
<p>- A score of 3 indicates that for all selected variables, the planting site has environmental conditions that are within the middle (0.25 to 0.75 quantiles) of the species range.
</p>
<p>- A score of 2 indicates that for all selected variables, the planting site has environmental conditions that are within the core (0.05 to 0.95 quantiles) of the species range. For some variables, the planting conditions are outside the middle of the species range.
</p>
<p>- A score of 1 indicates that for all selected variables, the planting site has environmental conditions that are within the documented limits (minimum to maximum) of the species range. For some variables, the planting conditions are outside the core of the species range; the BIOCLIM algorithm defines this domain as the 'marginal domain'.
</p>
<p>- A score of 0 indicates that for some of the selected variables, the planting site has environmental conditions that are outside the documented limits (&lt; minimum or &gt; maximum) of the species range. 
</p>
<p>- A score of 0.5 indicates that for some of the selected variables, the planting site has environmental conditions that are outside the documented limits (&lt; minimum or &gt; maximum) of the species range. However, for none of the selected variables the planting has environmental conditions larger than those for variables that are checked only at the lower side, or smaller than those for variables that are checked only at the upper side.
</p>
<p>- A score of -1 indicates that there was no information on the environmental ranges of the species. 
</p>
<p>The calculation of the position of the planting site via <code>treegoer.position</code> is done as follows:
</p>
<p>- For sites where the conditions of the planting location (PL) are above the median, the position is calculated as:
</p>
<p>(PL - MEDIAN) / (MAX - MEDIAN)
</p>
<p>- For sites where the conditions of the planting location (PL) are below the median, the position is calculated as:
</p>
<p>(PL - MEDIAN) / (MEDIAN - MIN)
</p>
<p>The sign (positive or negative) will therefore indicate the position (respectively, lower or higher) of the planting site with respect to the median of the species.
</p>
<p>The magnitude of the metric will indicate the relative distance of the planting site with respect to the difference between median and extremes. Values that are lower than -1 will indicate novel conditions below the minimum. Values that are above +1 will indicate novel conditions above the maximum.
</p>
<p>The same algorithms and similar scripts are used internally in the GlobalUsefulNativeTrees database (see Kindt et al. 2023). The internal scripts also resemble scripts provided here: <a href="https://rpubs.com/Roeland-KINDT/1114902">https://rpubs.com/Roeland-KINDT/1114902</a>.
</p>
<p>Function <code>treegoer.map</code> creates a raster layer with the climate scores.
</p>


<h3>Value</h3>

<p>Function <code>treegoer.score</code> returns a data set that includes a climate score representing the position of the planting site within the environmental range of species documented by the Tree Globally Observed Environmental Ranges database. 
</p>


<h3>Author(s)</h3>

<p> Roeland Kindt (World Agroforestry, CIFOR-ICRAF)</p>


<h3>References</h3>

<p>Booth TH. 2018. Why understanding the pioneering and continuing contributions of BIOCLIM to species distribution modelling is important. Austral Ecology 43: 852-860.
<a href="https://doi.org/10.1111/aec.12628">doi:10.1111/aec.12628</a>
</p>
<p>Kindt R. 2023. TreeGOER: A database with globally observed environmental ranges for 48,129 tree species. Global Change Biology. 
<a href="https://doi.org/10.1111/gcb.16914">doi:10.1111/gcb.16914</a>
</p>
<p>Kindt R., Graudal L, Lilleso J.P.-B. et al. 2023. GlobalUsefulNativeTrees, a database documenting 14,014 tree species, supports synergies between biodiversity recovery and local livelihoods in landscape restoration. Scientific Reports. 
<a href="https://doi.org/10.1038/s41598-023-39552-1">doi:10.1038/s41598-023-39552-1</a>
</p>
<p>Kindt R. 2023. Using the Tree Globally Observed Environmental Ranges and CitiesGOER databases to Filter GlobalUsefulNativeTrees Species lists.
<a href="https://rpubs.com/Roeland-KINDT/1114902">https://rpubs.com/Roeland-KINDT/1114902</a>
</p>
<p>Kindt R. 2023. CitiesGOER: Globally Observed Environmental Data for 52,602 Cities with a Population &gt;= 5000 (version 2023.10).
<a href="https://doi.org/10.5281/zenodo.10004594">doi:10.5281/zenodo.10004594</a>
</p>
<p>Kindt R. 2024. ClimateForecasts: Globally Observed Environmental Data for 15,504 Weather Station Locations (version 2024.03).
<a href="https://doi.org/10.5281/zenodo.10776414">doi:10.5281/zenodo.10776414</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Example adapted from https://rpubs.com/Roeland-KINDT/1114902

# treegoer.file &lt;- choose.files() 
# Provide the location where the TreeGOER file was downloaded locally
# (https://zenodo.org/records/10008994: TreeGOER_2023.txt)
treegoer &lt;- fread(treegoer.file, sep="|", encoding="UTF-8")
nrow(treegoer)
length(unique(treegoer$species)) # 48129

# A data set of tree species
# Example has useful tree species filtered 
# for Kenya and human food from the GlobalUsefulNativeTrees database
# (https://worldagroforestry.org/output/globalusefulnativetrees)
# globunt.file &lt;- choose.files()
globunt &lt;- fread(globunt.file, sep="|", encoding="UTF-8")
nrow(globunt) # 461

# Environmental variables used for filtering or scoring species
focal.vars &lt;- c("bio01", "bio12",
                "climaticMoistureIndex", "monthCountByTemp10", 
                "growingDegDays5",
                "bio05", "bio06", "bio16", "bio17",
                "MCWD")

# Use treegoer.widen()
treegoer.wide &lt;- treegoer.widen(treegoer=treegoer,
                                species=globunt$Switchboard,
                                filter.vars=focal.vars)
names(treegoer.wide)

# Environmental conditions at the planting site
# Provide the locations where the CitiesGOER files were downloaded locally 
# (https://zenodo.org/records/10004594: CitiesGOER_baseline.xlsx). 
# Alternatively, the ClimateForecasts database can be used
# (https://zenodo.org/records/10726088: ClimateForecasts_baseline.xlsx)
# baseline.file &lt;- choose.files()
site.baseline &lt;- data.frame(read_excel(baseline.file,
                            sheet="Cities data",
                            skip=6))
# Set the planting location in Nairobi
site.planting &lt;- site.baseline[site.baseline$Name == "Nairobi", ]
site.planting

# Calculate the climate scores
treegoer.scores &lt;- treegoer.score(site.species=globunt$Switchboard,
                                  treegoer.wide=treegoer.wide,
                                  filter.vars=focal.vars, 
                                  site.data=site.planting)

# Calculate the climate score for a single environmental variable
treegoer.score &lt;- treegoer.score(site.species=globunt$Switchboard,
                                  treegoer.wide=treegoer.wide,
                                  filter.vars="bio01", 
                                  site.data=site.planting)
                                  
                                  
library(dismo)
predictor.files &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''),
    pattern='grd', full.names=TRUE)
predictors &lt;- rast(predictor.files)
# subset based on Variance Inflation Factors
predictors &lt;- subset(predictors, subset=c("bio5", "bio6", 
    "bio16", "bio17"))
predictors

names(predictors)[1:2] &lt;- c("bio05", "bio06")
# WorldClim1 had temperature values multiplied by 10
if(t(minmax(predictors[["bio05"]]))[1] &gt; 25) {
  predictors[["bio05"]] &lt;- predictors[["bio05"]]/10
  predictors[["bio06"]] &lt;- predictors[["bio06"]]/10
}

map.test2 &lt;- treegoer.map(map.rast=predictors,
              map.species="Bertholletia excelsa",
             treegoer=treegoer,
             filter.vars=c("bio05", "bio06", "bio16", "bio17"),
             upper.only.vars=c("bio05", "bio06"),
             lower.only.vars=c("bio16", "bio17"))

map.test2
plot(map.test2)
                                  

## End(Not run)

</code></pre>

<hr>
<h2 id='warcom'>Warburgia ugandensis AFLP Scores</h2><span id='topic+warcom'></span>

<h3>Description</h3>

<p>This data set contains scores for 185 loci for 100 individuals of the Warburgia ugandensis tree species (a medicinal tree species native to Eastern Africa). Since the data set is a subset of a larger data set that originated from a study of several Warburgia species, some of the loci did not produce bands for W. ugandensis (i.e. some loci only contain zeroes). This data set is accompanied by <code>warenv</code> that describes population and regional structure of the 100 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(warcom)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 185 variables.
</p>

<dl>
<dt><code>locus001</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus002</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus003</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus004</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus005</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus006</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus007</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus008</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus009</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus010</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus011</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus012</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus013</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus014</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus015</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus016</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus017</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus018</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus019</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus020</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus021</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus022</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus023</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus024</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus025</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus026</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus027</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus028</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus029</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus030</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus031</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus032</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus033</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus034</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus035</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus036</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus037</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus038</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus039</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus040</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus041</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus042</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus043</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus044</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus045</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus046</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus047</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus048</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus049</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus050</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus051</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus052</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus053</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus054</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus055</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus056</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus057</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus058</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus059</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus060</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus061</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus062</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus063</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus064</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus065</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus066</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus067</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus068</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus069</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus070</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus071</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus072</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus073</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus074</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus075</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus076</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus077</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus078</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus079</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus080</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus081</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus082</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus083</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus084</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus085</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus086</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus087</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus088</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus089</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus090</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus091</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus092</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus093</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus094</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus095</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus096</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus097</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus098</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus099</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus100</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus101</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus102</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus103</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus104</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus105</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus106</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus107</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus108</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus109</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus110</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus111</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus112</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus113</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus114</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus115</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus116</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus117</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus118</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus119</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus120</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus121</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus122</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus123</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus124</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus125</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus126</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus127</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus128</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus129</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus130</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus131</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus132</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus133</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus134</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus135</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus136</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus137</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus138</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus139</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus140</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus141</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus142</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus143</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus144</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus145</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus146</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus147</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus148</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus149</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus150</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus151</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus152</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus153</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus154</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus155</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus156</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus157</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus158</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus159</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus160</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus161</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus162</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus163</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus164</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus165</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus166</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus167</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus168</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus169</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus170</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus171</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus172</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus173</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus174</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus175</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus176</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus177</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus178</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus179</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus180</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus181</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus182</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus183</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus184</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>locus185</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Muchugi, A.N. (2007) Population genetics and taxonomy of important medicinal tree species of the genus Warburgia. PhD Thesis. Kenyatta University, Kenya.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(warcom)
</code></pre>

<hr>
<h2 id='warenv'>Warburgia ugandensis Population Structure</h2><span id='topic+warenv'></span>

<h3>Description</h3>

<p>This data set contains population and regional locations for 100 individuals of the Warburgia ugandensis tree species (a medicinal tree species native to Eastern Africa). This data set is associated with <code>warcom</code> that contains scores for 185 AFLP loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(warenv)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 4 variables.
</p>

<dl>
<dt><code>population</code></dt><dd><p>a factor with levels <code>Kibale</code> <code>Kitale</code> <code>Laikipia</code> <code>Lushoto</code> <code>Mara</code></p>
</dd>
<dt><code>popshort</code></dt><dd><p>a factor with levels <code>KKIT</code> <code>KLAI</code> <code>KMAR</code> <code>TLUS</code> <code>UKIB</code></p>
</dd>
<dt><code>country</code></dt><dd><p>a factor with levels <code>Kenya</code> <code>Tanzania</code> <code>Uganda</code></p>
</dd>
<dt><code>rift.valley</code></dt><dd><p>a factor with levels <code>east</code> <code>west</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Muchugi, A.N. (2007) Population genetics and taxonomy of important medicinal tree species of the genus Warburgia. PhD Thesis. Kenyatta University, Kenya.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(warenv)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
