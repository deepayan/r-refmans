<!DOCTYPE html><html><head><title>Help for package kDGLM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kDGLM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+2A.dlm_block'><p>*.fitted_dlm</p></a></li>
<li><a href='#+2B.dlm_block'><p>+.fitted_dlm</p></a></li>
<li><a href='#analytic_filter'><p>analytic_filter</p></a></li>
<li><a href='#array_collapse_left'><p>array_collapse_left</p></a></li>
<li><a href='#array_collapse_right'><p>array_collapse_right</p></a></li>
<li><a href='#array_mult_left'><p>array_mult_left</p></a></li>
<li><a href='#array_mult_right'><p>array_mult_right</p></a></li>
<li><a href='#array_transp'><p>array_transp</p></a></li>
<li><a href='#base_block'><p>Basic structural blocks</p></a></li>
<li><a href='#base_ribbon'><p>base_ribbon</p></a></li>
<li><a href='#bdiag'><p>bdiag</p></a></li>
<li><a href='#block_mult'><p>Auxiliary function to replicate blocks</p></a></li>
<li><a href='#block_rename'><p>block_rename</p></a></li>
<li><a href='#block_superpos'><p>Auxiliary function for block superposition</p></a></li>
<li><a href='#CAR_prior'><p>CAR prior</p></a></li>
<li><a href='#check.block.status'><p>check.block.status</p></a></li>
<li><a href='#chickenPox'><p>Hospital admissions by chicken pox in Brazil</p></a></li>
<li><a href='#coef.fitted_dlm'><p>coef.fitted_dlm</p></a></li>
<li><a href='#coefficients.fitted_dlm'><p>coefficients.fitted_dlm</p></a></li>
<li><a href='#colQuantile'><p>colQuantile</p></a></li>
<li><a href='#convert_Gamma_Normal'><p>convert_Gamma_Normal</p></a></li>
<li><a href='#convert_multi_NG_Normal'><p>convert_multi_NG_Normal</p></a></li>
<li><a href='#convert_Multinom_Normal'><p>convert_Multinom_Normal</p></a></li>
<li><a href='#convert_Normal_Gamma'><p>convert_Normal_Gamma</p></a></li>
<li><a href='#convert_Normal_Multinom'><p>convert_Normal_Multinom</p></a></li>
<li><a href='#convert_Normal_Poisson'><p>convert_Normal_Poisson</p></a></li>
<li><a href='#convert_Poisson_Normal'><p>convert_Poisson_Normal</p></a></li>
<li><a href='#cornWheat'><p>Corn and wheat prices from 1986 to 2014</p></a></li>
<li><a href='#create_G'><p>create_G</p></a></li>
<li><a href='#dmvnorm'><p>dmvnorm</p></a></li>
<li><a href='#eval_dlm_log_like'><p>Auxiliary function for evaluating the prior density of a DLM</p></a></li>
<li><a href='#eval_dlm_norm_const'><p>Auxiliary function for evaluating normalizing constant for the posterior of a fitted DLM.</p></a></li>
<li><a href='#eval_dlm_post'><p>Auxiliary function for evaluating the posterior density of a DLM</p></a></li>
<li><a href='#eval_dlm_prior'><p>Auxiliary function for evaluating the prior density of a DLM</p></a></li>
<li><a href='#evaluate_max'><p>evaluate_max</p></a></li>
<li><a href='#f_joint_root'><p>f_joint_root</p></a></li>
<li><a href='#f_root'><p>f_root</p></a></li>
<li><a href='#fit_model'><p>Fitting kDGLM models</p></a></li>
<li><a href='#fit_model_single'><p>Fitting one kDGLM models</p></a></li>
<li><a href='#forecast.fitted_dlm'><p>Auxiliary function for forecasting</p></a></li>
<li><a href='#Gamma'><p>Gamma outcome for kDGLM models</p></a></li>
<li><a href='#gamma_pred'><p>gamma_pred</p></a></li>
<li><a href='#gastroBR'><p>Hospital admissions from gastroenteritis in Brazil</p></a></li>
<li><a href='#generic_smoother'><p>generic_smoother</p></a></li>
<li><a href='#ginv'><p>ginv</p></a></li>
<li><a href='#harmonic_block'><p>Structural blocks for seasonal trends and regressions</p></a></li>
<li><a href='#if.na'><p>if.na</p></a></li>
<li><a href='#if.nan'><p>if.nan</p></a></li>
<li><a href='#if.null'><p>if.null</p></a></li>
<li><a href='#intervention'><p>An auxiliary function for model intervention</p></a></li>
<li><a href='#joint_prior'><p>Joint prior</p></a></li>
<li><a href='#lcm'><p>lcm</p></a></li>
<li><a href='#multi_normal_gamma_pred'><p>update_multi_NG_chol</p>
multi_normal_gamma_pred</a></li>
<li><a href='#Multinom'><p>Multinom outcome for kDGLM models</p></a></li>
<li><a href='#multnom_pred'><p>multnom_pred</p></a></li>
<li><a href='#noise_block'><p>noise_block</p></a></li>
<li><a href='#Normal'><p>Normal outcome for kDGLM models</p></a></li>
<li><a href='#normal_pred'><p>normal_pred</p></a></li>
<li><a href='#noticeSARI'><p>SARI data from Belo Horizonte</p></a></li>
<li><a href='#plot.dlm_coef'><p>Visualizing latent states in a fitted kDGLM model</p></a></li>
<li><a href='#plot.fitted_dlm'><p>Visualizing a fitted kDGLM model</p></a></li>
<li><a href='#Poisson'><p>Poisson outcome for kDGLM models</p></a></li>
<li><a href='#poisson_pred'><p>poisson_pred</p></a></li>
<li><a href='#polynomial_block'><p>Structural blocks for polynomial trends and regressions</p></a></li>
<li><a href='#print.dlm_block'><p>print.dlm_block</p></a></li>
<li><a href='#print.dlm_distr'><p>print.dlm_distr</p></a></li>
<li><a href='#print.fitted_dlm'><p>print.fitted_dlm</p></a></li>
<li><a href='#print.searched_dlm'><p>print.searched_dlm</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#regression_block'><p>Structural blocks for regressions</p></a></li>
<li><a href='#rmvnorm'><p>rmvnorm</p></a></li>
<li><a href='#rowQuantile'><p>rowQuantile</p></a></li>
<li><a href='#simulate.fitted_dlm'><p>Draw samples from the distribution of the latent states</p></a></li>
<li><a href='#smoothing'><p>Auxiliary function for model smoothing</p></a></li>
<li><a href='#specify.dlm_block'><p>Specify method for dlm blocks</p></a></li>
<li><a href='#summary.dlm_block'><p>Summary for a kDGLM structure</p></a></li>
<li><a href='#summary.dlm_distr'><p>Summary for a kDGLM outcome</p></a></li>
<li><a href='#summary.fitted_dlm'><p>Summary for a fitted kDGLM model</p></a></li>
<li><a href='#summary.searched_dlm'><p>Summary for a searched_dlm object</p></a></li>
<li><a href='#TF_block'><p>Structural blocks for auto regressive trends and regressions</p></a></li>
<li><a href='#update_Gamma'><p>update_Gamma</p></a></li>
<li><a href='#update_multi_NG_correl'><p>update_multi_NG_correl</p></a></li>
<li><a href='#update_Multinom'><p>update_Multinom</p></a></li>
<li><a href='#update_NG'><p>update_NG</p></a></li>
<li><a href='#update_NG2'><p>update_NG</p></a></li>
<li><a href='#update_Normal'><p>update_Normal</p></a></li>
<li><a href='#update_Poisson'><p>update_Poisson</p></a></li>
<li><a href='#update.fitted_dlm'><p>update.fitted_dlm</p></a></li>
<li><a href='#var_decomp'><p>var_decomp</p></a></li>
<li><a href='#zero_sum_prior'><p>Zero sum prior</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Analysis of Dynamic Generalized Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide routines for filtering and smoothing, forecasting, sampling and Bayesian analysis of Dynamic Generalized Linear Models using the methodology described in Alves et al. (2024)&lt;<a href="https://doi.org/10.48550%2FarXiv.2201.05387">doi:10.48550/arXiv.2201.05387</a>&gt; and dos Santos Jr. et al. (2024)&lt;<a href="https://doi.org/10.48550%2FarXiv.2403.13069">doi:10.48550/arXiv.2403.13069</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>extraDistr (&ge; 1.9.1), Rfast (&ge; 2.0.8), generics (&ge; 0.1.3),
Rdpack</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, plotly, tidyverse, spdep, sf,
geobr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://silvaneojunior.github.io/kDGLM/">https://silvaneojunior.github.io/kDGLM/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/silvaneojunior/kDGLM/issues">https://github.com/silvaneojunior/kDGLM/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-23 14:39:24 UTC; Silvaneo</td>
</tr>
<tr>
<td>Author:</td>
<td>Silvaneo Vieira dos Santos Junior [aut, cre],
  Mariane Branco Alves [aut],
  Hélio dos Santos Migon [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Silvaneo Vieira dos Santos Junior &lt;silvaneo@dme.ufrj.br&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-25 09:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2A.dlm_block'>*.fitted_dlm</h2><span id='topic++2A.dlm_block'></span>

<h3>Description</h3>

<p>Define product operator for class dlm_block.
This method is wrapper for the block_mult function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm_block'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.dlm_block_+3A_e1">e1</code></td>
<td>
<p>A dlm_block (if e2 is an integer) or an integer (if e2 is a dlm_block).</p>
</td></tr>
<tr><td><code id="+2B2A.dlm_block_+3A_e2">e2</code></td>
<td>
<p>An integer (if e1 is an dlm_block) or a dlm_block (if e1 is an integer).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The combined replicated blocks as a dlm_block.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+block_mult">block_mult</a></code>
</p>

<hr>
<h2 id='+2B.dlm_block'>+.fitted_dlm</h2><span id='topic++2B.dlm_block'></span>

<h3>Description</h3>

<p>Define add operator for class dlm_block.
This method is wrapper for the block_superpos function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm_block'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.dlm_block_+3A_e1">e1</code></td>
<td>
<p>A dlm_block.</p>
</td></tr>
<tr><td><code id="+2B2B.dlm_block_+3A_e2">e2</code></td>
<td>
<p>A dlm_block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The combined blocks as a dlm_block.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+block_superpos">block_superpos</a></code>
</p>

<hr>
<h2 id='analytic_filter'>analytic_filter</h2><span id='topic+analytic_filter'></span>

<h3>Description</h3>

<p>Fit a model given the observed value and the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analytic_filter(
  outcomes,
  a1 = 0,
  R1 = 1,
  FF,
  FF.labs,
  G,
  G.labs,
  D,
  h,
  H,
  p.monit = NA,
  monitoring = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analytic_filter_+3A_outcomes">outcomes</code></td>
<td>
<p>list: The observed data. It should contain objects of the class dlm_distr.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_a1">a1</code></td>
<td>
<p>numeric: The prior mean at the latent vector.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_r1">R1</code></td>
<td>
<p>matrix: The prior covariance matrix at the latent vector.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_ff">FF</code></td>
<td>
<p>array: A 3D-array containing the planning matrix at each time. Its dimension should be n x k x t, where n is the number of latent states, k is the number of linear predictors in the model and t is the time series length.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_ff.labs">FF.labs</code></td>
<td>
<p>matrix: A character matrix containing the label associated with each value in FF.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_g">G</code></td>
<td>
<p>array: A 3D-array containing the evolution matrix at each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_g.labs">G.labs</code></td>
<td>
<p>matrix: A character matrix containing the label associated with each value in G.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_d">D</code></td>
<td>
<p>array: A 3D-array containing the discount factor matrix at each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_h">h</code></td>
<td>
<p>matrix: A drift to be added after the temporal evolution (can be interpreted as the mean of the random noise at each time). Its dimension should be n x t, where t is the length of the series and n is the number of latent states.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_h">H</code></td>
<td>
<p>array: A 3D-array containing the covariance matrix of the noise at each time. Its dimension should be the same as D.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_p.monit">p.monit</code></td>
<td>
<p>numeric (optional): The prior probability of changes in the latent space variables that are not part of its dynamic.</p>
</td></tr>
<tr><td><code id="analytic_filter_+3A_monitoring">monitoring</code></td>
<td>
<p>numeric: A vector of flags indicating which latent states should be monitored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the models covered in this package, we always use the approach described in Alves et al. (2024), including, in particular, the filtering algorithm presented in that work.
</p>
<p>For the details about the implementation see dos Santos et al. (2024).
</p>
<p>For the details about the algorithm implemented see Alves et al. (2024), Petris et al. (2009), chapter 2, West and Harrison (1997), chapter 4, and Kalman (1960).
</p>


<h3>Value</h3>

<p>A list containing the following values:
</p>

<ul>
<li><p> mt matrix: The filtered mean of the latent states for each time. Dimensions are n x t.
</p>
</li>
<li><p> Ct array: A 3D-array containing the filtered covariance matrix of the latent states for each time. Dimensions are n x n x t.
</p>
</li>
<li><p> at matrix: The one-step-ahead mean of the latent states at each time. Dimensions are n x t.
</p>
</li>
<li><p> Rt array: A 3D-array containing the one-step-ahead covariance matrix for latent states at each time. Dimensions are n x n x t.
</p>
</li>
<li><p> ft matrix: The one-step-ahead mean of the linear predictors at each time. Dimensions are k x t.
</p>
</li>
<li><p> Qt array: A 3D-array containing the one-step-ahead covariance matrix for linear predictors at each time. Dimensions are k x k x t.
</p>
</li>
<li><p> ft.star matrix: The filtered mean of the linear predictors for each time. Dimensions are k x t.
</p>
</li>
<li><p> Qt.star array: A 3D-array containing the linear predictors matrix of the latent state for each time. Dimensions are k x k x t.
</p>
</li>
<li><p> FF array: The same as the argument (same values).
</p>
</li>
<li><p> G matrix: The same as the argument (same values).
</p>
</li>
<li><p> G.labs matrix: The same as the argument (same values).
</p>
</li>
<li><p> D array: The same as the argument (same values).
</p>
</li>
<li><p> h array: The same as the argument (same values).
</p>
</li>
<li><p> H array: The same as the argument (same values).
</p>
</li>
<li><p> W array: A 3D-array containing the effective covariance matrix of the noise for each time, i.e., considering both H and D. Its dimension are the same as H and D.
</p>
</li>
<li><p> monitoring numeric: The same as the argument (same values).
</p>
</li>
<li><p> outcomes list: The same as the argument outcomes (same values).
</p>
</li>
<li><p> pred.names numeric: The names of the linear predictors.
</p>
</li></ul>



<h3>References</h3>

<p>Mariane
Branco Alves, Helio
S. Migon, Raíra Marotta, Junior,
Silvaneo
Vieira dos Santos (2024).
&ldquo;k-parametric Dynamic Generalized Linear Models: a sequential approach via Information Geometry.&rdquo;
2201.05387.<br /><br /> Rudolph
Emil Kalman (1960).
&ldquo;A New Approach to Linear Filtering and Prediction Problems.&rdquo;
<em>Transactions of the ASME&ndash;Journal of Basic Engineering</em>, <b>82</b>(Series D), 35&ndash;45.<br /><br /> Giovanni Petris, Sonia Petrone, Patrizia Campagnoli (2009).
<em>Dynamic Linear Models with R</em>,  useR!
Springer-Verlag, New York.<br /><br /> Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p><code><a href="#topic+generic_smoother">generic_smoother</a></code>
</p>

<hr>
<h2 id='array_collapse_left'>array_collapse_left</h2><span id='topic+array_collapse_left'></span>

<h3>Description</h3>

<p>Calculates the matrix product between an array and a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_collapse_left(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_collapse_left_+3A_a">A</code></td>
<td>
<p>A 3-D array with shapes n x m x k.</p>
</td></tr>
<tr><td><code id="array_collapse_left_+3A_b">B</code></td>
<td>
<p>A matrix with shapes m x 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an array A with shapes n x m x k and a vector B with shape m, this operations returns a matrix C, with shapes n x k, so that C[,i] = A[,,i] 
</p>

<hr>
<h2 id='array_collapse_right'>array_collapse_right</h2><span id='topic+array_collapse_right'></span>

<h3>Description</h3>

<p>Calculates the matrix product between an array and a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_collapse_right(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_collapse_right_+3A_a">A</code></td>
<td>
<p>A 3-D array with shapes n x m x k.</p>
</td></tr>
<tr><td><code id="array_collapse_right_+3A_b">B</code></td>
<td>
<p>A matrix with shapes 1 x n.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an array A with shapes m x n x k and a vector B with shape m, this operations returns a matrix C, with shapes n x k, so that C[,i] = B 
</p>

<hr>
<h2 id='array_mult_left'>array_mult_left</h2><span id='topic+array_mult_left'></span>

<h3>Description</h3>

<p>Calculates the matrix product between an array and a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_mult_left(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_mult_left_+3A_a">A</code></td>
<td>
<p>A 3-D array with shapes n x m x k.</p>
</td></tr>
<tr><td><code id="array_mult_left_+3A_b">B</code></td>
<td>
<p>A matrix with shapes m x l.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an array A with shapes n x m x k and a matrix B with shape m x l, this operations returns an array C, with shapes n x l x k, so that C[,,i] = A[,,i] 
</p>

<hr>
<h2 id='array_mult_right'>array_mult_right</h2><span id='topic+array_mult_right'></span>

<h3>Description</h3>

<p>Calculates the matrix product between an array and a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_mult_right(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_mult_right_+3A_a">A</code></td>
<td>
<p>A 3-D array with shapes n x m x k.</p>
</td></tr>
<tr><td><code id="array_mult_right_+3A_b">B</code></td>
<td>
<p>A matrix with shapes l x n.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an array A with shapes m x n x k and a matrix B with shape l x m, this operations returns an array C, with shapes l x n x k, so that C[,,i] = B 
</p>

<hr>
<h2 id='array_transp'>array_transp</h2><span id='topic+array_transp'></span>

<h3>Description</h3>

<p>Calculates the element-wise transposition of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_transp(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_transp_+3A_a">A</code></td>
<td>
<p>A 3-D array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an array A with shapes n x m x k, this operations returns an array C, with shapes m x n x k, so that C[,,i] = t(A[,,i]).
</p>

<hr>
<h2 id='base_block'>Basic structural blocks</h2><span id='topic+base_block'></span>

<h3>Description</h3>

<p>Creates the basic structure for a dlm block with desired order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_block(..., order, name, D, h, H, a1, R1, monitoring)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_block_+3A_...">...</code></td>
<td>
<p>Named values for the planning matrix.</p>
</td></tr>
<tr><td><code id="base_block_+3A_order">order</code></td>
<td>
<p>integer: The order of the structure. Must be positive</p>
</td></tr>
<tr><td><code id="base_block_+3A_name">name</code></td>
<td>
<p>character: An optional argument providing the name for this block. Can be useful to identify the models with meaningful labels, also, the name used will be used in some auxiliary functions.</p>
</td></tr>
<tr><td><code id="base_block_+3A_d">D</code></td>
<td>
<p>array, matrix, vector or scalar: The values for the discount factors associated with the latent states at each time. If D is an array, its dimensions should be n x n x t, where n is the order of the polynomial block and t is the length of the outcomes. If D is a matrix, its dimensions should be n x n and the same discount matrix will be used in all observations. If D is a vector, it should have size t and it is interpreted as the discount factor at each observed time (same discount for all variable). If D is a scalar, the same discount will be used for all latent states at all times.</p>
</td></tr>
<tr><td><code id="base_block_+3A_h">h</code></td>
<td>
<p>matrix, vector or scalar: A drift to be add after the temporal evolution (can be interpreted as the mean of the random noise at each time). If a matrix, its dimension should be n x t, where n is the number of latent states (i.e., the order) and t is the length of the series. If a vector, it should have size t, and each value will be applied to the first latent state (the one which affects the linear predictors) in their respective time. If a scalar, the passed value will be used for the first latent state at each time.</p>
</td></tr>
<tr><td><code id="base_block_+3A_h">H</code></td>
<td>
<p>array, matrix, vector or scalar: The values for the covariance matrix for the noise factor at each time. If H is an array, its dimensions should be n x n x t, where n is the order of the polynomial block and t is the length of the series. If H is a matrix, its dimensions should be n x n and its values will be used for each time. If H is a vector or scalar, a discount factor matrix will be created as a diagonal matrix with the values of H in the diagonal.</p>
</td></tr>
<tr><td><code id="base_block_+3A_a1">a1</code></td>
<td>
<p>vector or scalar: The prior mean for the latent states associated with this block at time 1. If a1 is a vector, its dimension should be equal to the order of the polynomial block. If a1 is a scalar, its value will be used for all latent states.</p>
</td></tr>
<tr><td><code id="base_block_+3A_r1">R1</code></td>
<td>
<p>matrix, vector or scalar: The prior covariance matrix for the latent states associated with this block at time 1. If R1 is a matrix, its dimensions should be n x n. If R1 is a vector or scalar, a covariance matrix will be created as a diagonal matrix with the values of R1 in the diagonal.</p>
</td></tr>
<tr><td><code id="base_block_+3A_monitoring">monitoring</code></td>
<td>
<p>vector: A vector of flags indicating which variables should be monitored (if automated monitoring is used). Its size should be n. The default is that only the first order component of this structure should be monitored.</p>
</td></tr>
</table>

<hr>
<h2 id='base_ribbon'>base_ribbon</h2><span id='topic+base_ribbon'></span>

<h3>Description</h3>

<p>Makes a ribbon plot using R base functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_ribbon(x, ymin, ymax, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_ribbon_+3A_x">x</code></td>
<td>
<p>numeric: A sequence of values for the x-axis.</p>
</td></tr>
<tr><td><code id="base_ribbon_+3A_ymin">ymin</code></td>
<td>
<p>numeric: A sequence of values for lower bound of the ribbon.</p>
</td></tr>
<tr><td><code id="base_ribbon_+3A_ymax">ymax</code></td>
<td>
<p>numeric: A sequence of values for upper bound of the ribbon.</p>
</td></tr>
<tr><td><code id="base_ribbon_+3A_...">...</code></td>
<td>
<p>Extra arguments for the polygon function.</p>
</td></tr>
</table>

<hr>
<h2 id='bdiag'>bdiag</h2><span id='topic+bdiag'></span>

<h3>Description</h3>

<p>Creates a block diagonal matrix with the matrix passed as argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiag(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdiag_+3A_...">...</code></td>
<td>
<p>A list of matrices to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A block diagonal matrix whose diagonal elements are equal to the matrices passed as arguments.
</p>

<hr>
<h2 id='block_mult'>Auxiliary function to replicate blocks</h2><span id='topic+block_mult'></span>

<h3>Description</h3>

<p>An auxiliary function to replicate blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_mult(block, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_mult_+3A_block">block</code></td>
<td>
<p>dlm_block: A block to be replicated</p>
</td></tr>
<tr><td><code id="block_mult_+3A_k">k</code></td>
<td>
<p>Integer: The number of blocks to generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The combined replicated blocks as a dlm_block.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Long way
level &lt;- polynomial_block(alpha = 1, order = 1)

final.block &lt;- block_mult(level, 5)

# Short way
final.block &lt;- 5 * polynomial_block(alpha = 1, order = 1)

</code></pre>

<hr>
<h2 id='block_rename'>block_rename</h2><span id='topic+block_rename'></span>

<h3>Description</h3>

<p>block_rename
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_rename(block, pred.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_rename_+3A_block">block</code></td>
<td>
<p>A dlm_block object.</p>
</td></tr>
<tr><td><code id="block_rename_+3A_pred.names">pred.names</code></td>
<td>
<p>A vector of string with names for each linear predictor in block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dlm_block with the linear predictors renamed to the values passed in names.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base.block &lt;- polynomial_block(
  eta = 1,
  order = 1,
  name = "Poly",
  D = 0.95
)

final.block &lt;- block_rename(2 * base.block, c("mu", "sigma"))

</code></pre>

<hr>
<h2 id='block_superpos'>Auxiliary function for block superposition</h2><span id='topic+block_superpos'></span>

<h3>Description</h3>

<p>An auxiliary function for block superposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_superpos(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_superpos_+3A_...">...</code></td>
<td>
<p>dlm_block: A sequence of block to be combine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional details can be found in West and Harrison (1997), section 6.2.
</p>


<h3>Value</h3>

<p>The combined blocks as a dlm_block.
</p>


<h3>References</h3>

<p>Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Long way
level.1 &lt;- polynomial_block(alpha1 = 1, order = 1)
level.2 &lt;- polynomial_block(alpha2 = 1, order = 2)
season.2 &lt;- harmonic_block(alpha2 = 1, period = 20)

final.block &lt;- block_superpos(level.1, level.2, season.2)

# Short way
final.block &lt;- polynomial_block(alpha1 = 1, order = 1) +
  polynomial_block(alpha2 = 1, order = 2) +
  harmonic_block(alpha2 = 1, period = 20)

</code></pre>

<hr>
<h2 id='CAR_prior'>CAR prior</h2><span id='topic+CAR_prior'></span>

<h3>Description</h3>

<p>Defines the prior of a structural block as a Conditional Autoregressive (CAR) prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAR_prior(block, adj.matrix, scale, rho, var.index = 1:block$n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAR_prior_+3A_block">block</code></td>
<td>
<p>dlm_block object: The structural block.</p>
</td></tr>
<tr><td><code id="CAR_prior_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>matrix: The adjacency matrix.</p>
</td></tr>
<tr><td><code id="CAR_prior_+3A_scale">scale</code></td>
<td>
<p>numeric: The tau parameter for the CAR model (see references).</p>
</td></tr>
<tr><td><code id="CAR_prior_+3A_rho">rho</code></td>
<td>
<p>numeric: The rho parameter for the CAR model (see references).</p>
</td></tr>
<tr><td><code id="CAR_prior_+3A_var.index">var.index</code></td>
<td>
<p>integer: The index of the variables from which to set the prior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filtering algorithm used in this package requires a proper prior for the latent space. As such, this implementation of the CAR prior imposes a zero-sum constraint in the regional effects.
The discount factor must be the same for all variables whose prior is being modified.
</p>
<p>For a revision of the CAR prior, see Schmidt and Nobre (2018).
</p>
<p>For the details about the implementation see dos Santos et al. (2024).
</p>


<h3>Value</h3>

<p>A dlm_block object with the desired prior.
</p>


<h3>References</h3>

<p>Alexandra
M. Schmidt, Widemberg
S. Nobre (2018).
&ldquo;Conditional Autoregressive (CAR) Model.&rdquo;
In <em>Wiley StatsRef: Statistics Reference Online</em>, chapter Conditional Autoregressive (CAR) Model, 1-11.
John Wiley &amp; Sons, Ltd.
ISBN 9781118445112, <a href="https://doi.org/10.1002/9781118445112.stat08048">doi:10.1002/9781118445112.stat08048</a>, https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118445112.stat08048, <a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/9781118445112.stat08048">https://onlinelibrary.wiley.com/doi/abs/10.1002/9781118445112.stat08048</a>.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p>Auxiliary functions for creating structural blocks <code><a href="#topic+polynomial_block">polynomial_block</a></code>, <code><a href="#topic+regression_block">regression_block</a></code>, <code><a href="#topic+harmonic_block">harmonic_block</a></code>, <code><a href="#topic+TF_block">TF_block</a></code>.
</p>
<p>Other auxiliary functions for defining priors.: 
<code><a href="#topic+joint_prior">joint_prior</a>()</code>,
<code><a href="#topic+zero_sum_prior">zero_sum_prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creating an arbitrary adjacency matrix
adj.matrix &lt;- matrix(
  c(
    0, 1, 1, 0, 0,
    1, 0, 1, 0, 0,
    1, 1, 0, 0, 0,
    0, 0, 0, 0, 1,
    0, 0, 0, 1, 0
  ),
  5, 5,
  byrow = TRUE
)

polynomial_block(mu = 1, D = 0.95) |&gt;
  block_mult(5) |&gt;
  CAR_prior(scale = 9, rho = 1, adj.matrix = adj.matrix)

</code></pre>

<hr>
<h2 id='check.block.status'>check.block.status</h2><span id='topic+check.block.status'></span>

<h3>Description</h3>

<p>Checks if a block is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.block.status(block)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.block.status_+3A_block">block</code></td>
<td>
<p>A dlm_block object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character (&quot;defined&quot; or &quot;undefined&quot;) indicating if all parameters in the block are defined.
</p>

<hr>
<h2 id='chickenPox'>Hospital admissions by chicken pox in Brazil</h2><span id='topic+chickenPox'></span>

<h3>Description</h3>

<p>Monthly hospital admissions by chicken pox in Brazil from January 2010 to December 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chickenPox
</code></pre>


<h3>Format</h3>

<p>A data frame with 120 rows and 6 columns:
</p>

<dl>
<dt>date</dt><dd><p>The date of the observations.</p>
</dd>
<dt>&lt; 5 year, 5 to 9 years, 10 to 14 years, 15 to 49 years, 50 years or more</dt><dd><p>The number of admissions for each age group.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://datasus.saude.gov.br/informacoes-de-saude-tabnet/">https://datasus.saude.gov.br/informacoes-de-saude-tabnet/</a>
</p>

<hr>
<h2 id='coef.fitted_dlm'>coef.fitted_dlm</h2><span id='topic+coef.fitted_dlm'></span>

<h3>Description</h3>

<p>Evaluates the predictive values for the observed values used to fit the model and its latent states.
Predictions can be made with smoothed values, with filtered values or h-steps ahead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_dlm'
coef(
  object,
  t.eval = seq_len(object$t),
  lag = -1,
  pred.cred = 0.95,
  eval.pred = FALSE,
  eval.metric = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.fitted_dlm_+3A_object">object</code></td>
<td>
<p>fitted_dlm: The fitted model to be use for evaluation.</p>
</td></tr>
<tr><td><code id="coef.fitted_dlm_+3A_t.eval">t.eval</code></td>
<td>
<p>numeric: A vector of positive integers indicating the time index from which to extract predictions. The default is to extract to evaluate the model at all observed times.</p>
</td></tr>
<tr><td><code id="coef.fitted_dlm_+3A_lag">lag</code></td>
<td>
<p>integer: The relative offset for forecast. Values for time t will be calculated based on the filtered values of time t-h. If lag is negative, then the smoothed distribution for the latent states will be used.</p>
</td></tr>
<tr><td><code id="coef.fitted_dlm_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: The credibility level for the C.I..</p>
</td></tr>
<tr><td><code id="coef.fitted_dlm_+3A_eval.pred">eval.pred</code></td>
<td>
<p>boolean: A flag indicating if the predictions should be calculated.</p>
</td></tr>
<tr><td><code id="coef.fitted_dlm_+3A_eval.metric">eval.metric</code></td>
<td>
<p>boolean: A flag indicating if the model density (f(M|y)) should be calculated. Only used when lag&lt;0.</p>
</td></tr>
<tr><td><code id="coef.fitted_dlm_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the coef method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> data data.frame: A table with the model evaluated at each observed time.
</p>
</li>
<li><p> theta.mean matrix: The mean of the latent states at each time. Dimensions are n x t, where t is the size of t.eval and n is the number of latent states.
</p>
</li>
<li><p> theta.cov array: A 3D-array containing the covariance matrix of the latent states at each time. Dimensions are n x n x t, where t is the size of t.eval and n is the number of latent states.
</p>
</li>
<li><p> lambda.mean matrix: The mean of the linear predictor at each time. Dimensions are k x t, where t is the size of t.eval and k is the number of linear predictors.
</p>
</li>
<li><p> lambda.cov array: A 3D-array containing the covariance matrix for the linear predictor at each time. Dimensions are k x k x t, where t is the size of t.eval and k is the number of linear predictors.
</p>
</li>
<li><p> log.like, mae, mase, rae, mse, interval.score: The metric value at each time.
</p>
</li>
<li><p> conj.param list: A list containing, for each outcome, a data.frame with the parameter of the conjugated distribution at each time.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auxiliary functions for fitted_dlm objects: 
<code><a href="#topic+eval_dlm_norm_const">eval_dlm_norm_const</a>()</code>,
<code><a href="#topic+fit_model">fit_model</a>()</code>,
<code><a href="#topic+forecast.fitted_dlm">forecast.fitted_dlm</a>()</code>,
<code><a href="#topic+simulate.fitted_dlm">simulate.fitted_dlm</a>()</code>,
<code><a href="#topic+smoothing">smoothing</a>()</code>,
<code><a href="#topic+update.fitted_dlm">update.fitted_dlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Poisson case
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data = data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)

var.vals &lt;- coef(fitted.data)

</code></pre>

<hr>
<h2 id='coefficients.fitted_dlm'>coefficients.fitted_dlm</h2><span id='topic+coefficients.fitted_dlm'></span>

<h3>Description</h3>

<p>This method is wrapper for the coef method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_dlm'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficients.fitted_dlm_+3A_object">object</code></td>
<td>
<p>A fitted_dlm object.</p>
</td></tr>
<tr><td><code id="coefficients.fitted_dlm_+3A_...">...</code></td>
<td>
<p>Arguments passed to coef.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> data data.frame: A table with the model evaluated at each observed time.
</p>
</li>
<li><p> theta.mean matrix: The mean of the latent states at each time. Dimensions are n x t, where t is the size of t.eval and n is the number of latent states.
</p>
</li>
<li><p> theta.cov array: A 3D-array containing the covariance matrix of the latent states at each time. Dimensions are n x n x t, where t is the size of t.eval and n is the number of latent states.
</p>
</li>
<li><p> lambda.mean matrix: The mean of the linear predictor at each time. Dimensions are k x t, where t is the size of t.eval and k is the number of linear predictors.
</p>
</li>
<li><p> lambda.cov array: A 3D-array containing the covariance matrix for the linear predictor at each time. Dimensions are k x k x t, where t is the size of t.eval and k is the number of linear predictors.
</p>
</li>
<li><p> log.like, mae, mase, rae, mse, interval.score: The metric value at each time.
</p>
</li>
<li><p> conj.param list: A list containing, for each outcome, a data.frame with the parameter of the conjugated distribution at each time.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+coef.fitted_dlm">coef.fitted_dlm</a></code>
</p>

<hr>
<h2 id='colQuantile'>colQuantile</h2><span id='topic+colQuantile'></span>

<h3>Description</h3>

<p>A function that calculates the column-wise quantile of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colQuantile(X, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colQuantile_+3A_x">X</code></td>
<td>
<p>matrix.</p>
</td></tr>
<tr><td><code id="colQuantile_+3A_q">q</code></td>
<td>
<p>numeric: A number between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: The chosen quantile for each column of X.
</p>

<hr>
<h2 id='convert_Gamma_Normal'>convert_Gamma_Normal</h2><span id='topic+convert_Gamma_Normal'></span>

<h3>Description</h3>

<p>Calculate the parameters of the Inverse-Gamma that best approximates the given log-Normal distribution.
The approximation is the best in the sense that it minimizes the KL divergence from the log-Normal to the Inverse-Gamma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_Gamma_Normal(ft, Qt, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_Gamma_Normal_+3A_ft">ft</code></td>
<td>
<p>vector: A vector representing the means from the normal distribution.</p>
</td></tr>
<tr><td><code id="convert_Gamma_Normal_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution.</p>
</td></tr>
<tr><td><code id="convert_Gamma_Normal_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the conjugated distribution of the linear predictor.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Gamma outcome with known shape: 
<code><a href="#topic+convert_Normal_Gamma">convert_Normal_Gamma</a>()</code>,
<code><a href="#topic+gamma_pred">gamma_pred</a>()</code>,
<code><a href="#topic+update_Gamma">update_Gamma</a>()</code>
</p>

<hr>
<h2 id='convert_multi_NG_Normal'>convert_multi_NG_Normal</h2><span id='topic+convert_multi_NG_Normal'></span>

<h3>Description</h3>

<p>Calculate the parameters of the Normal-Gamma that best approximates the given Multivariate Normal distribution. The distribution obtained for each outcome is marginal.
The approximation is the best in the sense that it minimizes the KL divergence from the Normal to the Normal-Gamma.
In this approach, we suppose that the first entry of the multivariate normal represents the mean of the observed data and the second represent the log variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_multi_NG_Normal(ft, Qt, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_multi_NG_Normal_+3A_ft">ft</code></td>
<td>
<p>numeric: A vector representing the means from the normal distribution.</p>
</td></tr>
<tr><td><code id="convert_multi_NG_Normal_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution.</p>
</td></tr>
<tr><td><code id="convert_multi_NG_Normal_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the conjugated distribution of the linear predictor.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Normal outcome: 
<code><a href="#topic+multi_normal_gamma_pred">multi_normal_gamma_pred</a>()</code>,
<code><a href="#topic+normal_pred">normal_pred</a>()</code>,
<code><a href="#topic+update_Normal">update_Normal</a>()</code>
</p>

<hr>
<h2 id='convert_Multinom_Normal'>convert_Multinom_Normal</h2><span id='topic+convert_Multinom_Normal'></span>

<h3>Description</h3>

<p>Calculate the parameters of the Dirichlet that best approximates the given log-Normal distribution.
The approximation is the best in the sense that it minimizes the KL divergence from the log-Normal to the Dirichlet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_Multinom_Normal(ft, Qt, parms = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_Multinom_Normal_+3A_ft">ft</code></td>
<td>
<p>vector: A vector representing the means from the normal distribution.</p>
</td></tr>
<tr><td><code id="convert_Multinom_Normal_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution.</p>
</td></tr>
<tr><td><code id="convert_Multinom_Normal_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the conjugated distribution of the linear predictor.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Multinomial outcome: 
<code><a href="#topic+convert_Normal_Multinom">convert_Normal_Multinom</a>()</code>,
<code><a href="#topic+multnom_pred">multnom_pred</a>()</code>,
<code><a href="#topic+update_Multinom">update_Multinom</a>()</code>
</p>

<hr>
<h2 id='convert_Normal_Gamma'>convert_Normal_Gamma</h2><span id='topic+convert_Normal_Gamma'></span>

<h3>Description</h3>

<p>Calculates the parameters of the log-Normal that best approximates the given Inverse-Gamma distribution.
The approximation is the best in the sense that it minimizes the KL divergence from the Inverse-Gamma to the log-Normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_Normal_Gamma(conj.param, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_Normal_Gamma_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the parameters of the Inverse-Gamma (alpha,beta).</p>
</td></tr>
<tr><td><code id="convert_Normal_Gamma_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the Normal distribution of the linear predictor.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Gamma outcome with known shape: 
<code><a href="#topic+convert_Gamma_Normal">convert_Gamma_Normal</a>()</code>,
<code><a href="#topic+gamma_pred">gamma_pred</a>()</code>,
<code><a href="#topic+update_Gamma">update_Gamma</a>()</code>
</p>

<hr>
<h2 id='convert_Normal_Multinom'>convert_Normal_Multinom</h2><span id='topic+convert_Normal_Multinom'></span>

<h3>Description</h3>

<p>Calculate the parameters of the log-Normal that best approximates the given Dirichlet distribution.
The approximation is the best in the sense that it minimizes the KL divergence from the Dirichlet to the log-Normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_Normal_Multinom(conj.param, parms = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_Normal_Multinom_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the concentration parameters of the Dirichlet.</p>
</td></tr>
<tr><td><code id="convert_Normal_Multinom_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the Normal distribution of the linear predictor.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Multinomial outcome: 
<code><a href="#topic+convert_Multinom_Normal">convert_Multinom_Normal</a>()</code>,
<code><a href="#topic+multnom_pred">multnom_pred</a>()</code>,
<code><a href="#topic+update_Multinom">update_Multinom</a>()</code>
</p>

<hr>
<h2 id='convert_Normal_Poisson'>convert_Normal_Poisson</h2><span id='topic+convert_Normal_Poisson'></span>

<h3>Description</h3>

<p>Calculate the parameters of the log-Normal that best approximates the given Gamma distribution.
The approximation is the best in the sense that it minimizes the KL divergence from the Gamma to the log-Normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_Normal_Poisson(conj.param, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_Normal_Poisson_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the parameters of the Gamma (alpha,beta).</p>
</td></tr>
<tr><td><code id="convert_Normal_Poisson_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the Normal distribution of the linear predictor.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Poisson outcome: 
<code><a href="#topic+convert_Poisson_Normal">convert_Poisson_Normal</a>()</code>,
<code><a href="#topic+poisson_pred">poisson_pred</a>()</code>,
<code><a href="#topic+update_Poisson">update_Poisson</a>()</code>
</p>

<hr>
<h2 id='convert_Poisson_Normal'>convert_Poisson_Normal</h2><span id='topic+convert_Poisson_Normal'></span>

<h3>Description</h3>

<p>Calculate the parameters of the Gamma that best approximates the given log-Normal distribution.
The approximation is the best in the sense that it minimizes the KL divergence from the log-Normal to the Gamma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_Poisson_Normal(ft, Qt, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_Poisson_Normal_+3A_ft">ft</code></td>
<td>
<p>numeric: A vector representing the means from the normal distribution.</p>
</td></tr>
<tr><td><code id="convert_Poisson_Normal_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution.</p>
</td></tr>
<tr><td><code id="convert_Poisson_Normal_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the conjugated distribution of the linear predictor.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Poisson outcome: 
<code><a href="#topic+convert_Normal_Poisson">convert_Normal_Poisson</a>()</code>,
<code><a href="#topic+poisson_pred">poisson_pred</a>()</code>,
<code><a href="#topic+update_Poisson">update_Poisson</a>()</code>
</p>

<hr>
<h2 id='cornWheat'>Corn and wheat prices from 1986 to 2014</h2><span id='topic+cornWheat'></span>

<h3>Description</h3>

<p>The to prices (in U.S. Dollars) per bushel and the log returns of corn and wheat from 1986-01-03 to 2014-10-10.
Each observation corresponds to the price on that day, but not all days are present in this dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cornWheat
</code></pre>


<h3>Format</h3>

<p>A data frame with 7,253 rows and 5 columns:
</p>

<dl>
<dt>date</dt><dd><p>The date of the observation.</p>
</dd>
<dt>corn.price, wheat.price</dt><dd><p> The price (in U.S. Dollars) per bushel of corn and wheat, respectively.</p>
</dd>
<dt>corn.log.return, wheat.log.return </dt><dd><p>The log returns for corn and wheat, respectively.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.macrotrends.net/charts/commodities">https://www.macrotrends.net/charts/commodities</a>
</p>

<hr>
<h2 id='create_G'>create_G</h2><span id='topic+create_G'></span>

<h3>Description</h3>

<p>Creates a matrix G such that G 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_G(S0, S1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_G_+3A_s0">S0</code></td>
<td>
<p>A covariance matrix</p>
</td></tr>
<tr><td><code id="create_G_+3A_s1">S1</code></td>
<td>
<p>Another covariance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='dmvnorm'>dmvnorm</h2><span id='topic+dmvnorm'></span>

<h3>Description</h3>

<p>Calculates the log density of a multivariate normal distribution with mean mu and covariance matrix Sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnorm(x, mu, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmvnorm_+3A_x">x</code></td>
<td>
<p>Vector: The value from to which calculate the density.</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_mu">mu</code></td>
<td>
<p>Vector: The mean vector</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_sigma">Sigma</code></td>
<td>
<p>Matrix: The Covariance matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='eval_dlm_log_like'>Auxiliary function for evaluating the prior density of a DLM</h2><span id='topic+eval_dlm_log_like'></span>

<h3>Description</h3>

<p>Evaluates the prior density for a set of parameters theta in a DLM. The structure of the DLM is taken to be that of the fitted_dlm object passed as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_dlm_log_like(theta, model, lin.pred = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_dlm_log_like_+3A_theta">theta</code></td>
<td>
<p>Matrix: A matrix representing the set of parameter for which to evaluate the density. Its size should be n x t, where n is the number of latent states and t is the length of the time series;</p>
</td></tr>
<tr><td><code id="eval_dlm_log_like_+3A_model">model</code></td>
<td>
<p>fitted_dlm: A fitted_dlm object.</p>
</td></tr>
<tr><td><code id="eval_dlm_log_like_+3A_lin.pred">lin.pred</code></td>
<td>
<p>boolean: A flag indicating if theta represents the linear predictors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the log likelihood evaluated at theta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data = data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)
eval_dlm_log_like(fitted.data$mts, fitted.data)
</code></pre>

<hr>
<h2 id='eval_dlm_norm_const'>Auxiliary function for evaluating normalizing constant for the posterior of a fitted DLM.</h2><span id='topic+eval_dlm_norm_const'></span>

<h3>Description</h3>

<p>Evaluates the normalizing constant for the posterior of a fitted DLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_dlm_norm_const(model, lin.pred = model$n &gt; 2 * model$k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_dlm_norm_const_+3A_model">model</code></td>
<td>
<p>fitted_dlm: A fitted_dlm object.</p>
</td></tr>
<tr><td><code id="eval_dlm_norm_const_+3A_lin.pred">lin.pred</code></td>
<td>
<p>boolean: A flag indicating if the normalizing constant should be calculated using the linear predictors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the normalizing constant for the posterior of a fitted DLM.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for fitted_dlm objects: 
<code><a href="#topic+coef.fitted_dlm">coef.fitted_dlm</a>()</code>,
<code><a href="#topic+fit_model">fit_model</a>()</code>,
<code><a href="#topic+forecast.fitted_dlm">forecast.fitted_dlm</a>()</code>,
<code><a href="#topic+simulate.fitted_dlm">simulate.fitted_dlm</a>()</code>,
<code><a href="#topic+smoothing">smoothing</a>()</code>,
<code><a href="#topic+update.fitted_dlm">update.fitted_dlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data = data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)
eval_dlm_norm_const(fitted.data)

</code></pre>

<hr>
<h2 id='eval_dlm_post'>Auxiliary function for evaluating the posterior density of a DLM</h2><span id='topic+eval_dlm_post'></span>

<h3>Description</h3>

<p>Evaluates the density for a set of parameters theta in a DLM. The structure of the DLM is taken to be that of the fitted_dlm object passed as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_dlm_post(theta, model, lin.pred = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_dlm_post_+3A_theta">theta</code></td>
<td>
<p>Matrix: A matrix representing the set of parameter for which to evaluate the density. Its size should be n x t, where n is the number of latent states and t is the length of the time series;</p>
</td></tr>
<tr><td><code id="eval_dlm_post_+3A_model">model</code></td>
<td>
<p>fitted_dlm: A fitted_dlm object.</p>
</td></tr>
<tr><td><code id="eval_dlm_post_+3A_lin.pred">lin.pred</code></td>
<td>
<p>boolean: A flag indicating if theta represents the linear predictors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the log density evaluated at theta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data = data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)
eval_dlm_post(fitted.data$mts, fitted.data)
</code></pre>

<hr>
<h2 id='eval_dlm_prior'>Auxiliary function for evaluating the prior density of a DLM</h2><span id='topic+eval_dlm_prior'></span>

<h3>Description</h3>

<p>Evaluates the prior density for a set of parameters theta in a DLM. The structure of the DLM is taken to be that of the fitted_dlm object passed as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_dlm_prior(theta, model, lin.pred = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_dlm_prior_+3A_theta">theta</code></td>
<td>
<p>matrix: A matrix representing the set of parameter for which to evaluate the density. Its size should be n x t, where n is the number of latent states and t is the length of the time series;</p>
</td></tr>
<tr><td><code id="eval_dlm_prior_+3A_model">model</code></td>
<td>
<p>fitted_dlm object: A fitted_dlm object.</p>
</td></tr>
<tr><td><code id="eval_dlm_prior_+3A_lin.pred">lin.pred</code></td>
<td>
<p>boolean: A flag indicating if theta represents the linear predictors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the log density evaluated at theta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data = data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)
eval_dlm_prior(fitted.data$mts, fitted.data)
</code></pre>

<hr>
<h2 id='evaluate_max'>evaluate_max</h2><span id='topic+evaluate_max'></span>

<h3>Description</h3>

<p>Auxiliary function to calculate the axis limits and gradation for plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_max(pre.max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_max_+3A_pre.max">pre.max</code></td>
<td>
<p>numeric: A vector/matrix from which to calculate the axis limits and gradation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the gradation for the axis, the number of ticks in the axis and the maximum value.
</p>

<hr>
<h2 id='f_joint_root'>f_joint_root</h2><span id='topic+f_joint_root'></span>

<h3>Description</h3>

<p>Calculates the root of a function given an initial value and a function to calculate its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_joint_root(f, start, tol = 1e-08, n.max = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_joint_root_+3A_f">f</code></td>
<td>
<p>function: A function that receives a vector and return a vector of the same size and a matrix representing its derivatives.</p>
</td></tr>
<tr><td><code id="f_joint_root_+3A_start">start</code></td>
<td>
<p>vector: The initial value to start the algorithm.</p>
</td></tr>
<tr><td><code id="f_joint_root_+3A_tol">tol</code></td>
<td>
<p>numeric: The tolerance for the solution.</p>
</td></tr>
<tr><td><code id="f_joint_root_+3A_n.max">n.max</code></td>
<td>
<p>numeric: The maximum number of iterations allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> root vector: The solution for the system f(x)=0.
</p>
</li>
<li><p> f.root vector: The function f evaluated at the root.
</p>
</li>
<li><p> iter numeric: The number of steps taken.
</p>
</li></ul>


<hr>
<h2 id='f_root'>f_root</h2><span id='topic+f_root'></span>

<h3>Description</h3>

<p>Calculates the root of a function given an initial value and a function to calculate its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_root(f, df, start, tol = 1e-08, n.max = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_root_+3A_f">f</code></td>
<td>
<p>function: A function that receives a vector and return a vector of the same size.</p>
</td></tr>
<tr><td><code id="f_root_+3A_df">df</code></td>
<td>
<p>function: A function that receives a vector and return the derivatives of f with respect to its arguments (if f returns a vector, it must be a matrix).</p>
</td></tr>
<tr><td><code id="f_root_+3A_start">start</code></td>
<td>
<p>vector: The initial value to start the algorithm.</p>
</td></tr>
<tr><td><code id="f_root_+3A_tol">tol</code></td>
<td>
<p>numeric: The tolerance for the solution.</p>
</td></tr>
<tr><td><code id="f_root_+3A_n.max">n.max</code></td>
<td>
<p>numeric: The maximum number of iterations allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> root vector: The solution for the system f(x)=0.
</p>
</li>
<li><p> f.root vector: The function f evaluated at the root.
</p>
</li>
<li><p> iter numeric: The number of steps taken.
</p>
</li></ul>


<hr>
<h2 id='fit_model'>Fitting kDGLM models</h2><span id='topic+fit_model'></span>

<h3>Description</h3>

<p>Fit a model given its structure and the observed data. This function can be used for any supported family (see vignette).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model(
  ...,
  smooth = TRUE,
  p.monit = NA,
  condition = "TRUE",
  metric = "log.like",
  lag = 1,
  pred.cred = 0.95,
  metric.cutoff = NA,
  save.models = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_model_+3A_...">...</code></td>
<td>
<p>dlm_block or dlm_distr objects or named values: The structural blocks of the model (dlm_block objects), alongside the model outcomes (dlm_distr object). If at least one block is undefined, the user must also provide its value in this argument (see last example).</p>
</td></tr>
<tr><td><code id="fit_model_+3A_smooth">smooth</code></td>
<td>
<p>boolean: A flag indicating if the smoothed distribution for the latent states should be calculated.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_p.monit">p.monit</code></td>
<td>
<p>numeric (optional): The prior probability of changes in the latent space variables that are not part of its dynamic. Only used when performing sensitivity analysis.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_condition">condition</code></td>
<td>
<p>character: A character defining which combinations of undefined hyper parameter should be tested. See example for details. Only used when performing sensitivity analysis.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_metric">metric</code></td>
<td>
<p>character: The name of the metric to use for model selection. One of log-likelihood for the one-step-ahead prediction (&quot;log.like&quot;), Mean Absolute Scaled Error (&quot;mase&quot;) (Hyndman and Koehler 2006) or Interval Score (&quot;interval.score&quot;) (Bracher et al. 2021).  Only used when performing sensitivity analysis.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_lag">lag</code></td>
<td>
<p>integer: The number of steps ahead used for the prediction when calculating the metrics. If lag&lt;0, predictions are made using the smoothed distribution of the latent states.  Only used when performing sensitivity analysis.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: A number between 0 and 1 (not included) indicating the credibility interval for predictions. If not within the valid range of values, 0.95 will be used. Only used when performing sensitivity analysis.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_metric.cutoff">metric.cutoff</code></td>
<td>
<p>integer: The number of observations to ignore when calculating the metrics. Default is 1/10 of the number of observations (rounded down). Only used when performing sensitivity analysis.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_save.models">save.models</code></td>
<td>
<p>boolean: A flag indicating if all evaluated models should be saved. If FALSE, only the best model (according to the chosen metric) will be saved. Only used when performing sensitivity analysis.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_silent">silent</code></td>
<td>
<p>boolean: A flag indicating if a progress bar should be printed. Only used when performing sensitivity analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function of the kDGLM package, as it is used to fit all models.
</p>
<p>For the details about the implementation see  dos Santos et al. (2024).
</p>
<p>For the details about the methodology see  Alves et al. (2024).
</p>
<p>For the details about the Dynamic Linear Models see  West and Harrison (1997) and Petris et al. (2009).
</p>


<h3>Value</h3>

<p>A fitted_dlm object.
</p>


<h3>See Also</h3>

<p>auxiliary functions for creating outcomes <code><a href="#topic+Poisson">Poisson</a></code>, <code><a href="#topic+Multinom">Multinom</a></code>, <code><a href="#topic+Normal">Normal</a></code>, <code><a href="#topic+Gamma">Gamma</a></code>, <code><a href="extraDistr.html#topic+Dirichlet">Dirichlet</a></code>
</p>
<p>auxiliary functions for creating structural blocks <code><a href="#topic+polynomial_block">polynomial_block</a></code>, <code><a href="#topic+regression_block">regression_block</a></code>, <code><a href="#topic+harmonic_block">harmonic_block</a></code>, <code><a href="#topic+TF_block">TF_block</a></code>
</p>
<p>auxiliary functions for defining priors <code><a href="#topic+zero_sum_prior">zero_sum_prior</a></code>, <code><a href="#topic+CAR_prior">CAR_prior</a></code>
</p>
<p>Other auxiliary functions for fitted_dlm objects: 
<code><a href="#topic+coef.fitted_dlm">coef.fitted_dlm</a>()</code>,
<code><a href="#topic+eval_dlm_norm_const">eval_dlm_norm_const</a>()</code>,
<code><a href="#topic+forecast.fitted_dlm">forecast.fitted_dlm</a>()</code>,
<code><a href="#topic+simulate.fitted_dlm">simulate.fitted_dlm</a>()</code>,
<code><a href="#topic+smoothing">smoothing</a>()</code>,
<code><a href="#topic+update.fitted_dlm">update.fitted_dlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Poisson case
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data = data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)
summary(fitted.data)

plot(fitted.data, plot.pkg = "base")

##################################################################

# Multinomial case
structure &lt;- (
  polynomial_block(p = 1, order = 2, D = 0.95) +
    harmonic_block(p = 1, period = 12, D = 0.975) +
    noise_block(p = 1, R1 = 0.1) +
    regression_block(p = chickenPox$date &gt;= as.Date("2013-09-01"))
  # Vaccine was introduced in September of 2013
) * 4

outcome &lt;- Multinom(p = structure$pred.names, data = chickenPox[, c(2, 3, 4, 6, 5)])
fitted.data &lt;- fit_model(structure, chickenPox = outcome)
summary(fitted.data)
plot(fitted.data, plot.pkg = "base")

##################################################################

# Univariate Normal case
structure &lt;- polynomial_block(mu = 1, D = 0.95) +
  polynomial_block(V = 1, D = 0.95)

outcome &lt;- Normal(mu = "mu", V = "V", data = cornWheat$corn.log.return[1:500])
fitted.data &lt;- fit_model(structure, corn = outcome)
summary(fitted.data)
plot(fitted.data, plot.pkg = "base")

##################################################################

# Bivariate Normal case
structure &lt;- (polynomial_block(mu = 1, D = 0.95) +
  polynomial_block(V = 1, D = 0.95)) * 2 +
  polynomial_block(rho = 1, D = 0.95)

outcome &lt;- Normal(
  mu = c("mu.1", "mu.2"),
  V = matrix(c("V.1", "rho", "rho", "V.2"), 2, 2),
  data = cornWheat[1:500, c(4, 5)]
)
fitted.data &lt;- fit_model(structure, cornWheat = outcome)
summary(fitted.data)
plot(fitted.data, plot.pkg = "base")

##################################################################

# Gamma case
structure &lt;- polynomial_block(mu = 1, D = 0.95)

outcome &lt;- Gamma(phi = 0.5, mu = "mu", data = cornWheat$corn.log.return[1:500]**2)
fitted.data &lt;- fit_model(structure, corn = outcome)
summary(fitted.data)
plot(fitted.data, plot.pkg = "base")

##################################################################

# Sensitivity analysis
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = "D.level")
season &lt;- harmonic_block(rate = "sazo.effect", order = 2, period = 12, D = "D.sazo")

outcome &lt;- Poisson(lambda = "rate", data = data)

fit_model(level, season, outcome,
  sazo.effect = c(0, 1),
  D.level = c(seq.int(0.8, 1, l = 11)),
  D.sazo = c(seq.int(0.95, 1, l = 11)),
  condition = "sazo.effect==1 | D.sazo==1"
)


</code></pre>

<hr>
<h2 id='fit_model_single'>Fitting one kDGLM models</h2><span id='topic+fit_model_single'></span>

<h3>Description</h3>

<p>Fits one model given its structure and the observed data. This function can be used for any supported family (see vignette).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model_single(structure, outcomes, smooth = TRUE, p.monit = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_model_single_+3A_structure">structure</code></td>
<td>
<p>dlm_block: The structural blocks of the model. All block must be completely defined.</p>
</td></tr>
<tr><td><code id="fit_model_single_+3A_outcomes">outcomes</code></td>
<td>
<p>dlm_distr or list of dlm_distr objects: The model outcomes.</p>
</td></tr>
<tr><td><code id="fit_model_single_+3A_smooth">smooth</code></td>
<td>
<p>boolean: A flag indicating if the smoothed distribution for the latent states should be calculated.</p>
</td></tr>
<tr><td><code id="fit_model_single_+3A_p.monit">p.monit</code></td>
<td>
<p>numeric (optional): The prior probability of changes in the latent space variables that are not part of its dynamic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted_dlm object.
</p>

<hr>
<h2 id='forecast.fitted_dlm'>Auxiliary function for forecasting</h2><span id='topic+forecast.fitted_dlm'></span>

<h3>Description</h3>

<p>Auxiliary function for forecasting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_dlm'
forecast(
  object,
  t = 1,
  plot = ifelse(requireNamespace("plotly", quietly = TRUE), "plotly",
    ifelse(requireNamespace("ggplot2", quietly = TRUE), "ggplot2", "base")),
  pred.cred = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.fitted_dlm_+3A_object">object</code></td>
<td>
<p>fitted_dlm object: The fitted model to be use for predictions.</p>
</td></tr>
<tr><td><code id="forecast.fitted_dlm_+3A_t">t</code></td>
<td>
<p>numeric: Time window for prediction.</p>
</td></tr>
<tr><td><code id="forecast.fitted_dlm_+3A_plot">plot</code></td>
<td>
<p>boolean or character: A flag indicating if a plot should be produced. Should be one of FALSE, TRUE, 'base', 'ggplot2' or 'plotly'.</p>
</td></tr>
<tr><td><code id="forecast.fitted_dlm_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: The credibility level for the C.I..</p>
</td></tr>
<tr><td><code id="forecast.fitted_dlm_+3A_...">...</code></td>
<td>
<p>Extra variables necessary for prediction (covariates, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an a covariate is necessary for forecasting, it should be passed as a named argument. Its name must follow this structure: &lt;block name&gt;.Covariate&lt;.index&gt;. If there is only one covariate in the associated block the index is omitted.
If an a pulse is necessary for forecasting, it should be passed as a named argument. Its name must follow this structure: &lt;block name&gt;.Pulse&lt;.index&gt;. If there is only one pulse in the associated block the index is omitted.
The user may pass the observed values at the prediction windows (optional). See example.
As an special case, if the model has an Multinomial outcome, the user may pass the N parameter instead of the observations.
If an offset is necessary for forecasting, it should be passed with the same syntax as the observed data. See example.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> data data.frame: A data frame contain the mean, variance and credibility intervals for the outcomes, including both the observed data and the predictions for future observations.
</p>
</li>
<li><p> forecast data.frame: Same as data, but restricted to predictions for future observations.
</p>
</li>
<li><p> outcomes list: A named list containing predictions for each outcome. Each element of this list is a list containing predictions (mean, variance and credibility intervals), the distribution of the linear predictor for the parameter of the observational model and the parameters of the predictive distribution (if available).
</p>
</li>
<li><p> theta.mean matrix: A matrix with the values for the latent states at each time. Dimensions are n x t, where n is the number of latent states
</p>
</li>
<li><p> theta.cov array: A 3D-array with the covariance of the latent states at each time. Dimensions are n x n x t, where n is the number of latent predictors.
</p>
</li>
<li><p> lambda.mean matrix: A matrix with the values for the linear predictors at each time. Dimensions are k x t, where k is the number of linear predictors
</p>
</li>
<li><p> lambda.cov array: A 3D-array with the covariance of the linear predictors at each time. Dimensions are k x k x t, where k is the number of linear predictors.
</p>
</li>
<li><p> plot (if so chosen): A plotly or ggplot object.
</p>
</li></ul>

<p>A list containing:
</p>

<ul>
<li><p> data data.frame: A table with the model evaluated at each observed time, plus the forecasted period.
</p>
</li>
<li><p> forecast data.frame: A table with the model evaluated at the forecasted period.
</p>
</li>
<li><p> outcomes list: A list containing the parameters of the predictive distribution for each outcome at the forecasted period.
</p>
</li>
<li><p> theta.mean matrix: The mean of the latent states at each forecasted time. Dimensions are n x t.forecast, where t.forecast is the size of the forecast windows and n is the number of latent states.
</p>
</li>
<li><p> theta.cov array: A 3D-array containing the covariance matrix of the latent states  at each forecasted time. Dimensions are n x n x t.forecast, where t.forecast is the size of the forecast windows and n is the number of latent states.
</p>
</li>
<li><p> lambda.mean matrix: The mean of the linear predictor at each forecasted time. Dimensions are k x t.forecast, where t.forecast is the size of the forecast windows and k is the number of linear predictors.
</p>
</li>
<li><p> lambda.cov array: A 3D-array containing the covariance matrix for the linear predictor at each forecasted time. Dimensions are k x k x t.forecast, where t.forecast is the size of the forecast windows and k is the number of linear predictors.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auxiliary functions for fitted_dlm objects: 
<code><a href="#topic+coef.fitted_dlm">coef.fitted_dlm</a>()</code>,
<code><a href="#topic+eval_dlm_norm_const">eval_dlm_norm_const</a>()</code>,
<code><a href="#topic+fit_model">fit_model</a>()</code>,
<code><a href="#topic+simulate.fitted_dlm">simulate.fitted_dlm</a>()</code>,
<code><a href="#topic+smoothing">smoothing</a>()</code>,
<code><a href="#topic+update.fitted_dlm">update.fitted_dlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
structure &lt;-
  polynomial_block(p = 1, order = 2, D = 0.95) +
  harmonic_block(p = 1, period = 12, D = 0.975) +
  noise_block(p = 1, R1 = 0.1) +
  regression_block(
    p = chickenPox$date &gt;= as.Date("2013-09-1"),
    # Vaccine was introduced in September of 2013
    name = "Vaccine"
  )

outcome &lt;- Multinom(p = c("p.1", "p.2"), data = chickenPox[, c(2, 3, 5)])
fitted.data &lt;- fit_model(structure * 2,
  chickenPox = outcome
)

forecast(fitted.data, 24,
  chickenPox = list(Total = rep(175, 24)), # Optional
  Vaccine.1.Covariate = rep(TRUE, 24),
  Vaccine.2.Covariate = rep(TRUE, 24)
)

</code></pre>

<hr>
<h2 id='Gamma'>Gamma outcome for kDGLM models</h2><span id='topic+Gamma'></span>

<h3>Description</h3>

<p>Creates an outcome with gamma distribution with the chosen parameters (can only specify 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gamma(
  phi = NA,
  mu = NA,
  alpha = NA,
  beta = NA,
  sigma = NA,
  data,
  offset = as.matrix(data)^0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma_+3A_phi">phi</code></td>
<td>
<p>character or numeric: Name of the linear predictor associated with the shape parameter of the gamma distribution. If numeric, this parameter is treated as known and equal to the value passed. If a character, the parameter is treated as unknown and equal to the exponential of the associated linear predictor. It cannot be specified with alpha.</p>
</td></tr>
<tr><td><code id="Gamma_+3A_mu">mu</code></td>
<td>
<p>character: Name of the linear predictor associated with the mean parameter of the gamma distribution. The parameter is treated as unknown and equal to the exponential of the associated linear predictor.</p>
</td></tr>
<tr><td><code id="Gamma_+3A_alpha">alpha</code></td>
<td>
<p>character: Name of the linear predictor associated with the shape parameter of the gamma distribution. The parameter is treated as unknown and equal to the exponential of the associated linear predictor. It cannot be specified with phi.</p>
</td></tr>
<tr><td><code id="Gamma_+3A_beta">beta</code></td>
<td>
<p>character: Name of the linear predictor associated with the rate parameter of the gamma distribution. The parameter is treated as unknown and equal to the exponential of the associated linear predictor. It cannot be specified with sigma.</p>
</td></tr>
<tr><td><code id="Gamma_+3A_sigma">sigma</code></td>
<td>
<p>character: Name of the linear predictor associated with the scale parameter of the gamma distribution. The parameter is treated as unknown and equal to the exponential of the associated linear predictor. It cannot be specified with beta.</p>
</td></tr>
<tr><td><code id="Gamma_+3A_data">data</code></td>
<td>
<p>numeric: Values of the observed data.</p>
</td></tr>
<tr><td><code id="Gamma_+3A_offset">offset</code></td>
<td>
<p>numeric: The offset at each observation. Must have the same shape as data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For evaluating the posterior parameters, we use the method proposed in Alves et al. (2024).
</p>
<p>For the details about the implementation see  dos Santos et al. (2024).
</p>


<h3>Value</h3>

<p>An object of the class dlm_distr
</p>


<h3>References</h3>

<p>Mariane
Branco Alves, Helio
S. Migon, Raíra Marotta, Junior,
Silvaneo
Vieira dos Santos (2024).
&ldquo;k-parametric Dynamic Generalized Linear Models: a sequential approach via Information Geometry.&rdquo;
2201.05387.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for a creating outcomes: 
<code><a href="#topic+Multinom">Multinom</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+summary.dlm_distr">summary.dlm_distr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
structure &lt;- polynomial_block(mu = 1, D = 0.95)

outcome &lt;- Gamma(phi = 0.5, mu = "mu", data = cornWheat$corn.log.return[1:500]**2)
fitted.data &lt;- fit_model(structure, corn = outcome)
summary(fitted.data)
plot(fitted.data, plot.pkg = "base")

</code></pre>

<hr>
<h2 id='gamma_pred'>gamma_pred</h2><span id='topic+gamma_pred'></span>

<h3>Description</h3>

<p>Calculate the values for the predictive distribution given the values of the parameter of the conjugated distribution of the linear predictor.
The data is assumed to have Gamma distribution with known shape parameter phi and its mean having distribution Inverse-Gamma with shape parameter a e rate parameter b.
In this scenario, the marginal distribution of the data is Beta prime with parameters phi, alpha, beta / phi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_pred(conj.param, outcome = NULL, parms = list(), pred.cred = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_pred_+3A_conj.param">conj.param</code></td>
<td>
<p>list or data.frame: The parameters of the conjugated distributions of the linear predictor.</p>
</td></tr>
<tr><td><code id="gamma_pred_+3A_outcome">outcome</code></td>
<td>
<p>numeric or matrix (optional): The observed values at the current time. Not used in this function.</p>
</td></tr>
<tr><td><code id="gamma_pred_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra parameters for the model. For this function, it must contain the shape parameter phi of the observational model.</p>
</td></tr>
<tr><td><code id="gamma_pred_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: the desired credibility for the credibility interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following values:
</p>

<ul>
<li><p> pred numeric/matrix: the mean of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> var.pred numeric/matrix: the variance of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> icl.pred numeric/matrix: the percentile of 100*((1-pred.cred)/2)
</p>
</li>
<li><p> icu.pred numeric/matrix: the percentile of 100*(1-(1-pred.cred)/2)
</p>
</li>
<li><p> log.like numeric: the The log likelihood for the outcome given the conjugated parameters.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auxiliary functions for a Gamma outcome with known shape: 
<code><a href="#topic+convert_Gamma_Normal">convert_Gamma_Normal</a>()</code>,
<code><a href="#topic+convert_Normal_Gamma">convert_Normal_Gamma</a>()</code>,
<code><a href="#topic+update_Gamma">update_Gamma</a>()</code>
</p>

<hr>
<h2 id='gastroBR'>Hospital admissions from gastroenteritis in Brazil</h2><span id='topic+gastroBR'></span>

<h3>Description</h3>

<p>A dataset containing the number of Hospital admissions from gastroenteritis in Brazil, per state, from 2010 to 2022 by month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gastroBR
</code></pre>


<h3>Format</h3>

<p>A data frame with 4212 rows and 4 variables:
</p>

<dl>
<dt>UF</dt><dd><p>The abbreviated state name.</p>
</dd>
<dt>Date</dt><dd><p>The date of the observation. Note that the day is only a placeholder and is just a placeholder.</p>
</dd>
<dt>Admissions</dt><dd><p>The number hospital admissions.</p>
</dd>
<dt>Population</dt><dd><p>The estimated population.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Admissions: <a href="https://datasus.saude.gov.br/informacoes-de-saude-tabnet/">https://datasus.saude.gov.br/informacoes-de-saude-tabnet/</a>
</p>
<p>Population: <a href="https://www.ibge.gov.br/estatisticas/sociais/populacao.html">https://www.ibge.gov.br/estatisticas/sociais/populacao.html</a>
</p>

<hr>
<h2 id='generic_smoother'>generic_smoother</h2><span id='topic+generic_smoother'></span>

<h3>Description</h3>

<p>Generic smoother for all models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generic_smoother(mt, Ct, at, Rt, G, G.labs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generic_smoother_+3A_mt">mt</code></td>
<td>
<p>matrix: A matrix containing the filtered mean of the latent states at each time. Each row should represent one variable.</p>
</td></tr>
<tr><td><code id="generic_smoother_+3A_ct">Ct</code></td>
<td>
<p>array: A 3D-array representing the filtered covariance matrix of the latent states at each time. The third dimension should represent the time index.</p>
</td></tr>
<tr><td><code id="generic_smoother_+3A_at">at</code></td>
<td>
<p>matrix: A matrix containing the one-step-ahead mean of the latent states at each time based upon the filtered mean. Each row should represent one variable.</p>
</td></tr>
<tr><td><code id="generic_smoother_+3A_rt">Rt</code></td>
<td>
<p>array: A 3D-array representing the one-step-ahead covariance matrix of the latent states at each time based upon the filtered covariance matrix. The third dimension should represent the time index.</p>
</td></tr>
<tr><td><code id="generic_smoother_+3A_g">G</code></td>
<td>
<p>array: A 3D-array representing the transition matrix of the model at each time.</p>
</td></tr>
<tr><td><code id="generic_smoother_+3A_g.labs">G.labs</code></td>
<td>
<p>matrix: A character matrix containing the type associated with each value in G.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the models covered in this package, we always assume that the latent states have Multivariate Normal distribution. With that assumption, we can use Kalman Smoother algorithm to calculate the posterior of the states at each time, given everything that has been observed (assuming that we already know the filtered distribution of the states).
</p>
<p>For the details about the implementation see dos Santos et al. (2024).
</p>
<p>For the details about the algorithm implemented see Alves et al. (2024), Petris et al. (2009), chapter 2, West and Harrison (1997), chapter 4, and Kalman (1960).
</p>


<h3>Value</h3>

<p>A list containing the smoothed mean (mts) and covariance (Cts) of the latent states at each time. Their dimension follows, respectively, the dimensions of mt and Ct.
</p>


<h3>References</h3>

<p>Mariane
Branco Alves, Helio
S. Migon, Raíra Marotta, Junior,
Silvaneo
Vieira dos Santos (2024).
&ldquo;k-parametric Dynamic Generalized Linear Models: a sequential approach via Information Geometry.&rdquo;
2201.05387.<br /><br /> Rudolph
Emil Kalman (1960).
&ldquo;A New Approach to Linear Filtering and Prediction Problems.&rdquo;
<em>Transactions of the ASME&ndash;Journal of Basic Engineering</em>, <b>82</b>(Series D), 35&ndash;45.<br /><br /> Giovanni Petris, Sonia Petrone, Patrizia Campagnoli (2009).
<em>Dynamic Linear Models with R</em>,  useR!
Springer-Verlag, New York.<br /><br /> Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p><code><a href="#topic+analytic_filter">analytic_filter</a></code>
</p>

<hr>
<h2 id='ginv'>ginv</h2><span id='topic+ginv'></span>

<h3>Description</h3>

<p>This function receives a covariance matrix S and calculates the generalized inverse of S.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ginv(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ginv_+3A_s">S</code></td>
<td>
<p>A covariance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='harmonic_block'>Structural blocks for seasonal trends and regressions</h2><span id='topic+harmonic_block'></span>

<h3>Description</h3>

<p>Creates the structure for a harmonic block with desired periodicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonic_block(
  ...,
  period,
  order = 1,
  name = "Var.Sazo",
  D = 1,
  h = 0,
  H = 0,
  a1 = 0,
  R1 = 4,
  monitoring = rep(FALSE, order * 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonic_block_+3A_...">...</code></td>
<td>
<p>Named values for the planning matrix.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_period">period</code></td>
<td>
<p>Positive integer: The size of the harmonic cycle.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_order">order</code></td>
<td>
<p>Positive integer: The order of the harmonic structure.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_name">name</code></td>
<td>
<p>String: An optional argument providing the name for this block. Can be useful to identify the models with meaningful labels, also, the name used will be used in some auxiliary functions.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_d">D</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the discount factors associated with the latent states at each time. If D is an array, its dimensions should be (2n) x (2n) x t, where n is the order of the harmonic block and t is the length of the outcomes. If D is a matrix, its dimensions should be (2n) x (2n) and the same discount matrix will be used in all observations. If D is a vector, it should have size t and it is interpreted as the discount factor at each observed time (same discount for all variable). If D is a scalar, the same discount will be used for all latent states at all times.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_h">h</code></td>
<td>
<p>Matrix, vector or scalar: A drift to be add after the temporal evolution (can be interpreted as the mean of the random noise at each time). If a matrix, its dimension should be (2n) x t, where n is the order of the harmonic_block and t is the length of the series. If a vector, it should have size t, and each value will be applied to the first latent state (the one which affects the linear predictors) in their respective time. If a scalar, the passed value will be used for the first latent state at each time.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_h">H</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the covariance matrix for the noise factor at each time. If H is an array, its dimensions should be (2n) x (2n) x t, where n is the order of the harmonic block and t is the length of the series. If H is a matrix, its dimensions should be (2n) x (2n) and its values will be used for each time. If H is a vector or scalar, a discount factor matrix will be created as a diagonal matrix with the values of H in the diagonal.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_a1">a1</code></td>
<td>
<p>Vector or scalar: The prior mean for the latent states associated with this block at time 1. If a1 is a vector, its dimension should be equal to two times the order of the harmonic block. If a1 is a scalar, its value will be used for all latent states.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_r1">R1</code></td>
<td>
<p>Matrix, vector or scalar: The prior covariance matrix for the latent states associated with this block at time 1. If R1 is a matrix, its dimensions should be (2n) x (2n). If R1 is a vector or scalar, a covariance matrix will be created as a diagonal matrix with the values of R1 in the diagonal.</p>
</td></tr>
<tr><td><code id="harmonic_block_+3A_monitoring">monitoring</code></td>
<td>
<p>Vector: A vector of flags indicating which variables should be monitored (if automated monitoring is used). Its size should be 2n. The default is that only the first order component of this structure should be monitored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the ..., D, H, a1 and R1 arguments, the user may set one or more of its values as a string.
By doing so, the user will leave the block partially undefined.
The user must then pass the undefined parameter values as named arguments to the <code><a href="#topic+fit_model">fit_model</a></code> function. Also, multiple values can be passed, allowing for a sensitivity analysis for the value of this parameter.
</p>
<p>For the details about the implementation see dos Santos et al. (2024).
</p>
<p>For the details about the modelling of seasonal trends using harmonics in the context of DLM's, see West and Harrison (1997), chapter 8.
</p>
<p>For the details about dynamic regression models in the context of DLM's, see West and Harrison (1997), chapters 6 and 9.
</p>


<h3>Value</h3>

<p>A dlm_block object containing the following values:
</p>

<ul>
<li><p> FF Array: A 3D-array containing the regression matrix for each time. Its dimension should be n x k x t, where n is the number of latent states, k is the number of linear predictors in the model and t is the time series length.
</p>
</li>
<li><p> FF.labs Matrix: A n x k character matrix describing the type of value of each element of FF.
</p>
</li>
<li><p> G Matrix: A 3D-array containing the evolution matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> G.labs Matrix: A n x n character matrix describing the type of value of each element of G.
</p>
</li>
<li><p> D Array: A 3D-array containing the discount factor matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> h Matrix: The mean for the random noise of the temporal evolution. Its dimension should be n x t.
</p>
</li>
<li><p> H Array: A 3D-array containing the covariance matrix of the noise for each time. Its dimension should be the same as D.
</p>
</li>
<li><p> a1 Vector: The prior mean for the latent vector.
</p>
</li>
<li><p> R1 Matrix: The prior covariance matrix for the latent vector.
</p>
</li>
<li><p> var.names list: A list containing the variables indexes by their name.
</p>
</li>
<li><p> period Positive integer: Same as argument.
</p>
</li>
<li><p> n Positive integer: The number of latent states associated with this block (2).
</p>
</li>
<li><p> t Positive integer: The number of time steps associated with this block. If 1, the block is compatible with blocks of any time length, but if t is greater than 1, this block can only be used with blocks of the same time length.
</p>
</li>
<li><p> k Positive integer: The number of outcomes associated with this block. This block can only be used with blocks with the same outcome length.
</p>
</li>
<li><p> pred.names Vector: The name of the linear predictors associated with this block.
</p>
</li>
<li><p> monitoring Vector: Same as argument.
</p>
</li>
<li><p> type Character: The type of block (Harmonic).
</p>
</li></ul>



<h3>References</h3>

<p>Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating seasonal structure for a model with 2 outcomes.
# One block is created for each outcome
# with each block being associated with only one of the outcomes.
season.1 &lt;- harmonic_block(alpha1 = 1, period = 3)
season.2 &lt;- harmonic_block(alpha2 = 1, period = 6)

# Creating a block with shared effect between the outcomes
season.3 &lt;- harmonic_block(alpha = 1, alpha2 = 1, period = 12)

</code></pre>

<hr>
<h2 id='if.na'>if.na</h2><span id='topic+if.na'></span>

<h3>Description</h3>

<p>This function is wrapper for ifelse(is.na(vec),vec,val)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if.na(vec, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if.na_+3A_vec">vec</code></td>
<td>
<p>A vector or matrix.</p>
</td></tr>
<tr><td><code id="if.na_+3A_val">val</code></td>
<td>
<p>The value to replace NA with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix with the same dimensions as the input, where any NA values have been replaced by the specified val argument.
</p>

<hr>
<h2 id='if.nan'>if.nan</h2><span id='topic+if.nan'></span>

<h3>Description</h3>

<p>This function is wrapper for ifelse(is.nan(vec),vec,val)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if.nan(vec, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if.nan_+3A_vec">vec</code></td>
<td>
<p>A vector or matrix.</p>
</td></tr>
<tr><td><code id="if.nan_+3A_val">val</code></td>
<td>
<p>The value to replace NaN with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix with the same dimensions as the input, where any NaN values have been replaced by the specified val argument.
</p>

<hr>
<h2 id='if.null'>if.null</h2><span id='topic+if.null'></span>

<h3>Description</h3>

<p>This function is wrapper for ifelse(is.null(.),.,.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if.null(vec, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if.null_+3A_vec">vec</code></td>
<td>
<p>A vector or matrix.</p>
</td></tr>
<tr><td><code id="if.null_+3A_val">val</code></td>
<td>
<p>The value to replace NULL with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix with the same dimensions as the input, where any NULL values have been replaced by the specified val argument.
</p>

<hr>
<h2 id='intervention'>An auxiliary function for model intervention</h2><span id='topic+intervention'></span>

<h3>Description</h3>

<p>This function adds timely modifications to a dlm_block, such that in the specified time the model will override the usual value of the each variable to the value chosen by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervention(
  block,
  time,
  var.index = 1:block$n,
  FF = NULL,
  D = NULL,
  h = NULL,
  H = NULL,
  G = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervention_+3A_block">block</code></td>
<td>
<p>dlm_block: The block to add the intervention.</p>
</td></tr>
<tr><td><code id="intervention_+3A_time">time</code></td>
<td>
<p>Vector: A sequence of integers indicating the time of the intervention.</p>
</td></tr>
<tr><td><code id="intervention_+3A_var.index">var.index</code></td>
<td>
<p>Vector: A sequence of integers indicating which variables should be modified in the intervention.</p>
</td></tr>
<tr><td><code id="intervention_+3A_ff">FF</code></td>
<td>
<p>Array: A n x k x t array with the modified FF to be used during the intervention, where n is the length of var.index, k is the number of linear predictors in the block and t is the size of time (can be omitted if time is a scalar).</p>
</td></tr>
<tr><td><code id="intervention_+3A_d">D</code></td>
<td>
<p>Array: A n x n x t array with the modified D to be used during the intervention, where n is the length of var.index and t is the size of time (can be omitted if time is a scalar).</p>
</td></tr>
<tr><td><code id="intervention_+3A_h">h</code></td>
<td>
<p>matrix: A n x t matrix with the modified h to be used during the intervention, where n is the length of var.index and t is the size of time (can be omitted if time is a scalar).</p>
</td></tr>
<tr><td><code id="intervention_+3A_h">H</code></td>
<td>
<p>Array: A n x n x t array with the modified H to be used during the intervention, where n is the length of var.index and t is the size of time (can be omitted if time is a scalar).</p>
</td></tr>
<tr><td><code id="intervention_+3A_g">G</code></td>
<td>
<p>Array: A n x n x t array with the modified G to be used during the intervention, where n is the length of var.index and t is the size of time (can be omitted if time is a scalar).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dlm_block with the added intervention.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- c(AirPassengers)
# Adding an artificial change, so that we can make an intervention on the data at that point
# Obviously, one should NOT change their own data.
data[60:144] &lt;- data[60:144] + 500

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

# Reducing the discount factor so that the model can capture the expected change.
level &lt;- level |&gt; intervention(time = 60, H = 1, var.index = 1)
# Comment the line above to see the fit without the intervention

outcome &lt;- Poisson(lambda = "rate", data = data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)

plot(fitted.data, plot.pkg = "base")

</code></pre>

<hr>
<h2 id='joint_prior'>Joint prior</h2><span id='topic+joint_prior'></span>

<h3>Description</h3>

<p>Defines the joint prior of a structural block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_prior(
  block,
  var.index = 1:block$n,
  a1 = block$a1[var.index],
  R1 = block$R1[var.index, var.index]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joint_prior_+3A_block">block</code></td>
<td>
<p>dlm_block object: The structural block.</p>
</td></tr>
<tr><td><code id="joint_prior_+3A_var.index">var.index</code></td>
<td>
<p>Integer: The index of the variables from which to set the prior.</p>
</td></tr>
<tr><td><code id="joint_prior_+3A_a1">a1</code></td>
<td>
<p>Numeric: The prior mean.</p>
</td></tr>
<tr><td><code id="joint_prior_+3A_r1">R1</code></td>
<td>
<p>Matrix: The prior covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discount factor must be the same for all variables whose prior is being modified.
For the details about the implementation see dos Santos et al. (2024).
</p>


<h3>Value</h3>

<p>A dlm_block object with the desired prior.
</p>


<h3>References</h3>

<p>Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for defining priors.: 
<code><a href="#topic+CAR_prior">CAR_prior</a>()</code>,
<code><a href="#topic+zero_sum_prior">zero_sum_prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
polynomial_block(mu = 1, D = 0.95) |&gt;
  block_mult(5) |&gt;
  joint_prior(var.index = 1:2, R1 = matrix(c(1, 0.5, 0.5, 1), 2, 2))

</code></pre>

<hr>
<h2 id='lcm'>lcm</h2><span id='topic+lcm'></span>

<h3>Description</h3>

<p>Calculates the least common multiple of a set of integer. Internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcm_+3A_x">x</code></td>
<td>
<p>numeric: A sequence of integers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The least common multiple.
</p>

<hr>
<h2 id='multi_normal_gamma_pred'>update_multi_NG_chol
multi_normal_gamma_pred</h2><span id='topic+multi_normal_gamma_pred'></span>

<h3>Description</h3>

<p>update_multi_NG_chol
multi_normal_gamma_pred
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_normal_gamma_pred(
  conj.param,
  outcome = NULL,
  parms = list(),
  pred.cred = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_normal_gamma_pred_+3A_conj.param">conj.param</code></td>
<td>
<p>list or data.frame: The parameters of the conjugated distribution (Normal-Gamma) of the linear predictor.</p>
</td></tr>
<tr><td><code id="multi_normal_gamma_pred_+3A_outcome">outcome</code></td>
<td>
<p>numeric or matrix (optional): The observed values at the current time.</p>
</td></tr>
<tr><td><code id="multi_normal_gamma_pred_+3A_parms">parms</code></td>
<td>
<p>list (optional): A list of extra parameters for the model. Not used in this function.</p>
</td></tr>
<tr><td><code id="multi_normal_gamma_pred_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: the desired credibility for the credibility interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following values:
</p>

<ul>
<li><p> pred numeric/matrix: the mean of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> var.pred numeric/matrix: the variance of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> icl.pred numeric/matrix: the percentile of 100*((1-pred.cred)/2)
</p>
</li>
<li><p> icu.pred numeric/matrix: the percentile of 100*(1-(1-pred.cred)/2)
</p>
</li>
<li><p> log.like numeric: the The log likelihood for the outcome given the conjugated parameters.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auxiliary functions for a Normal outcome: 
<code><a href="#topic+convert_multi_NG_Normal">convert_multi_NG_Normal</a>()</code>,
<code><a href="#topic+normal_pred">normal_pred</a>()</code>,
<code><a href="#topic+update_Normal">update_Normal</a>()</code>
</p>

<hr>
<h2 id='Multinom'>Multinom outcome for kDGLM models</h2><span id='topic+Multinom'></span>

<h3>Description</h3>

<p>Creates an outcome with Multinomial distribution with the chosen parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Multinom(p, data, offset = as.matrix(data)^0, base.class = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multinom_+3A_p">p</code></td>
<td>
<p>character: a vector with the name of the linear predictor associated with the probability of each category (except the base one, which is assumed to be the last).</p>
</td></tr>
<tr><td><code id="Multinom_+3A_data">data</code></td>
<td>
<p>vector: Values of the observed data.</p>
</td></tr>
<tr><td><code id="Multinom_+3A_offset">offset</code></td>
<td>
<p>vector: The offset at each observation. Must have the same shape as data.</p>
</td></tr>
<tr><td><code id="Multinom_+3A_base.class">base.class</code></td>
<td>
<p>character or integer: The name or index of the base class. Default is to use the last column of data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For evaluating the posterior parameters, we use the method proposed in Alves et al. (2024).
</p>
<p>For the details about the implementation see  dos Santos et al. (2024).
</p>


<h3>Value</h3>

<p>A object of the class dlm_distr
</p>


<h3>References</h3>

<p>Mariane
Branco Alves, Helio
S. Migon, Raíra Marotta, Junior,
Silvaneo
Vieira dos Santos (2024).
&ldquo;k-parametric Dynamic Generalized Linear Models: a sequential approach via Information Geometry.&rdquo;
2201.05387.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for a creating outcomes: 
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+summary.dlm_distr">summary.dlm_distr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
structure &lt;- (
  polynomial_block(p = 1, order = 2, D = 0.95) +
    harmonic_block(p = 1, period = 12, D = 0.975) +
    noise_block(p = 1, R1 = 0.1) +
    regression_block(p = chickenPox$date &gt;= as.Date("2013-09-01"))
  # Vaccine was introduced in September of 2013
) * 4

outcome &lt;- Multinom(p = structure$pred.names, data = chickenPox[, c(2, 3, 4, 6, 5)])
fitted.data &lt;- fit_model(structure, chickenPox = outcome)
summary(fitted.data)
plot(fitted.data, plot.pkg = "base")

</code></pre>

<hr>
<h2 id='multnom_pred'>multnom_pred</h2><span id='topic+multnom_pred'></span>

<h3>Description</h3>

<p>Calculate the values for the predictive distribution given the values of the parameter of the conjugated distribution of the linear predictor.
The data is assumed to have Multinomial distribution with known number of trial N and the probability vector having distribution Dirichlet with parameters alpha_i.
In this scenario, the marginal distribution of the data is Dirichlet-Multinomial with parameters N and alpha_i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multnom_pred(conj.param, outcome, parms = list(), pred.cred = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multnom_pred_+3A_conj.param">conj.param</code></td>
<td>
<p>List or data.frame: The parameters of the conjugated distributions of the linear predictor.</p>
</td></tr>
<tr><td><code id="multnom_pred_+3A_outcome">outcome</code></td>
<td>
<p>Vector or matrix: The observed values at the current time. The value passed is used to compute N.</p>
</td></tr>
<tr><td><code id="multnom_pred_+3A_parms">parms</code></td>
<td>
<p>List (optional): A list of extra parameters for the model. Not used in this function.</p>
</td></tr>
<tr><td><code id="multnom_pred_+3A_pred.cred">pred.cred</code></td>
<td>
<p>Numeric: the desired credibility for the credibility interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following values:
</p>

<ul>
<li><p> pred vector/matrix: the mean of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> var.pred vector/matrix: the variance of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> icl.pred vector/matrix: the percentile of 100*((1-pred.cred)/2)
</p>
</li>
<li><p> icu.pred vector/matrix: the percentile of 100*(1-(1-pred.cred)/2)
</p>
</li>
<li><p> log.like vector: the The log likelihood for the outcome given the conjugated parameters.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auxiliary functions for a Multinomial outcome: 
<code><a href="#topic+convert_Multinom_Normal">convert_Multinom_Normal</a>()</code>,
<code><a href="#topic+convert_Normal_Multinom">convert_Normal_Multinom</a>()</code>,
<code><a href="#topic+update_Multinom">update_Multinom</a>()</code>
</p>

<hr>
<h2 id='noise_block'>noise_block</h2><span id='topic+noise_block'></span>

<h3>Description</h3>

<p>Creates the structure for a Noise block. This block represents an independent random noise that should be added to the linear predictor.
The variance of the noise cannot be formally estimated, as such we use a discount strategy similar to that of West and Harrison (1997) to specify it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_block(..., name = "Noise", D = 0.99, R1 = 0.1, H = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noise_block_+3A_...">...</code></td>
<td>
<p>Named values for the planning matrix.</p>
</td></tr>
<tr><td><code id="noise_block_+3A_name">name</code></td>
<td>
<p>String: An optional argument providing the name for this block. Can be useful to identify the models with meaningful labels, also, the name used will be used in some auxiliary functions.</p>
</td></tr>
<tr><td><code id="noise_block_+3A_d">D</code></td>
<td>
<p>scalar or vector: A sequence of values specifying the desired discount factor for each time. It should have length 1 or t, where t is the size of the series. If both D and H are specified, the value of D is ignored.</p>
</td></tr>
<tr><td><code id="noise_block_+3A_r1">R1</code></td>
<td>
<p>scalar: The prior variance of the noise.</p>
</td></tr>
<tr><td><code id="noise_block_+3A_h">H</code></td>
<td>
<p>scalar: The variance of the noise. If both D and H are specified, the value of D is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the details about the implementation see dos Santos et al. (2024).
</p>
<p>For the details about dynamic regression models in the context of DLMs, see West and Harrison (1997), chapters 6 and 9.
</p>


<h3>Value</h3>

<p>A dlm_block object containing the following values:
</p>

<ul>
<li><p> FF Array: A 3D-array containing the regression matrix for each time. Its dimension should be n x k x t, where n is the number of latent states, k is the number of linear predictors in the model and t is the time series length.
</p>
</li>
<li><p> FF.labs Matrix: A n x k character matrix describing the type of value of each element of FF.
</p>
</li>
<li><p> G Matrix: A 3D-array containing the evolution matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> G.labs Matrix: A n x n character matrix describing the type of value of each element of G.
</p>
</li>
<li><p> D Array: A 3D-array containing the discount factor matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> H Array: A 3D-array containing the covariance matrix of the noise for each time. Its dimension should be the same as D.
</p>
</li>
<li><p> a1 Vector: The prior mean for the latent vector.
</p>
</li>
<li><p> R1 Matrix: The prior covariance matrix for the latent vector.
</p>
</li>
<li><p> var.names list: A list containing the variables indexes by their name.
</p>
</li>
<li><p> order Positive integer: Same as argument.
</p>
</li>
<li><p> n Positive integer: The number of latent states associated with this block (2).
</p>
</li>
<li><p> t Positive integer: The number of time steps associated with this block. If 1, the block is compatible with blocks of any time length, but if t is greater than 1, this block can only be used with blocks of the same time length.
</p>
</li>
<li><p> k Positive integer: The number of outcomes associated with this block. This block can only be used with blocks with the same outcome length.
</p>
</li>
<li><p> pred.names Vector: The name of the linear predictors associated with this block.
</p>
</li>
<li><p> monitoring Vector: The combination of monitoring, monitoring and monitoring.pulse.
</p>
</li>
<li><p> type Character: The type of block (Noise).
</p>
</li></ul>



<h3>References</h3>

<p>Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
noise_block(mu = 1, D = 0.99, R1 = 1e-2)

</code></pre>

<hr>
<h2 id='Normal'>Normal outcome for kDGLM models</h2><span id='topic+Normal'></span>

<h3>Description</h3>

<p>Creates an outcome with Normal distribution with the chosen parameters (can only specify 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normal(mu, V = NA, Tau = NA, Sd = NA, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normal_+3A_mu">mu</code></td>
<td>
<p>character: Name of the linear predictor associated with the mean parameter of the Normal distribution. The parameter is treated as unknown and equal to the associated linear predictor.</p>
</td></tr>
<tr><td><code id="Normal_+3A_v">V</code></td>
<td>
<p>character or numeric: If V is a character, it is interpreted as the names of the linear predictors associated with the variance parameter of the Normal distribution. If V is numeric, the variance is considered known and equal to the value of V, otherwise, the variance is considered unknown and equal to the exponential of the linear predictor informed in V. If the outcome is a Multivariate Normal, then V must be a matrix and, if the variance is unknown, the elements outside its main diagonal are treated as the linear predictor associated with the correlation between each coordinate of the outcome, otherwise V is treated as the covariance matrix. The user cannot specify V with Tau or Sd.</p>
</td></tr>
<tr><td><code id="Normal_+3A_tau">Tau</code></td>
<td>
<p>character or numeric: If Tau is a character, it is interpreted as the names of the linear predictors associated with the precisions parameter of the Normal distribution. If Tau is numeric, the precision is considered known and equal to the value of Tau, otherwise, the precision is considered unknown and equal to the exponential of the linear predictor informed in Tau. If the outcome is a Multivariate Normal, then Tau must be a matrix and, if the precision is unknown, the elements outside its main diagonal are treated as the linear predictor associated with the correlation between each coordinate of the outcome, otherwise Tau is treated as the precision matrix. The user cannot specify Tau with V or Sd.</p>
</td></tr>
<tr><td><code id="Normal_+3A_sd">Sd</code></td>
<td>
<p>character or numeric: If Sd is a character, it is interpreted as the names of the linear predictors associated with the standard deviation parameter of the Normal distribution. If Sd is numeric, the standard deviation is considered known and equal to the value of Sd, otherwise, the precision is considered unknown and equal to the exponential of the linear predictor informed by in Sd. If the outcome is a Multivariate Normal, then Tau must be a matrix and the elements outside its main diagonal are treated as the correlation (or the name of the linear predictor associated) between each coordinate of the outcome. The user cannot specify Sd with V or Tau.</p>
</td></tr>
<tr><td><code id="Normal_+3A_data">data</code></td>
<td>
<p>numeric: Values of the observed data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If V/Sigma/Tau/Sd is a string, we use the method proposed in Alves et al. (2024).
Otherwise, if V/Sigma/Tau/Sd is numeric, we follow the theory presented in West and Harrison (1997).
</p>
<p>For the details about the implementation see  dos Santos et al. (2024).
</p>


<h3>Value</h3>

<p>A object of the class dlm_distr
</p>


<h3>References</h3>

<p>Mariane
Branco Alves, Helio
S. Migon, Raíra Marotta, Junior,
Silvaneo
Vieira dos Santos (2024).
&ldquo;k-parametric Dynamic Generalized Linear Models: a sequential approach via Information Geometry.&rdquo;
2201.05387.<br /><br /> Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for a creating outcomes: 
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Multinom">Multinom</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>,
<code><a href="#topic+summary.dlm_distr">summary.dlm_distr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Univariate Normal case
structure &lt;- polynomial_block(mu = 1, D = 0.95) +
  polynomial_block(V = 1, D = 0.95)

outcome &lt;- Normal(mu = "mu", V = "V", data = cornWheat$corn.log.return[1:500])
fitted.data &lt;- fit_model(structure, corn = outcome)
summary(fitted.data)
plot(fitted.data, plot.pkg = "base")

# Bivariate Normal case
structure &lt;- (polynomial_block(mu = 1, D = 0.95) +
  polynomial_block(V = 1, D = 0.95)) * 2 +
  polynomial_block(rho = 1, D = 0.95)

outcome &lt;- Normal(
  mu = c("mu.1", "mu.2"),
  V = matrix(c("V.1", "rho", "rho", "V.2"), 2, 2),
  data = cornWheat[1:500, c(4, 5)]
)
fitted.data &lt;- fit_model(structure, cornWheat = outcome)
summary(fitted.data)
plot(fitted.data, plot.pkg = "base")

</code></pre>

<hr>
<h2 id='normal_pred'>normal_pred</h2><span id='topic+normal_pred'></span>

<h3>Description</h3>

<p>Calculate the values for the predictive distribution given the values of the parameter of the conjugated distribution of the linear predictor.
The data is assumed to have Normal distribution with known variance and its mean having distribution Normal.
In this scenario, the marginal distribution of the data is also Normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_pred(conj.param, outcome = NULL, parms = list(), pred.cred = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_pred_+3A_conj.param">conj.param</code></td>
<td>
<p>list or data.frame: The parameters of the conjugated distributions of the linear predictor.</p>
</td></tr>
<tr><td><code id="normal_pred_+3A_outcome">outcome</code></td>
<td>
<p>numeric or matrix (optional): The observed values at the current time. Not used in this function.</p>
</td></tr>
<tr><td><code id="normal_pred_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra parameters for the model. For this function, it must contain the observational covariance matrix, V</p>
</td></tr>
<tr><td><code id="normal_pred_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: the desired credibility for the credibility interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following values:
</p>

<ul>
<li><p> pred numeric/matrix: the mean of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> var.pred numeric/matrix: the variance of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> icl.pred numeric/matrix: the percentile of 100*((1-pred.cred)/2)
</p>
</li>
<li><p> icu.pred numeric/matrix: the percentile of 100*(1-(1-pred.cred)/2)
</p>
</li>
<li><p> log.like numeric: the The log likelihood for the outcome given the conjugated parameters.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auxiliary functions for a Normal outcome: 
<code><a href="#topic+convert_multi_NG_Normal">convert_multi_NG_Normal</a>()</code>,
<code><a href="#topic+multi_normal_gamma_pred">multi_normal_gamma_pred</a>()</code>,
<code><a href="#topic+update_Normal">update_Normal</a>()</code>
</p>

<hr>
<h2 id='noticeSARI'>SARI data from Belo Horizonte</h2><span id='topic+noticeSARI'></span>

<h3>Description</h3>

<p>A dataset containing reports from Severe Acute Respiratory Illness (SARI) from 2020 to April 2022 by week.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noticeSARI
</code></pre>


<h3>Format</h3>

<p>A data frame with 65404 rows and 7 variables:
</p>

<dl>
<dt>ref.week</dt><dd><p>The reference week, counting since the monitoring begun.</p>
</dd>
<dt>reported.1.week</dt><dd><p>The number of cases occurred in the period and reported until the 1 week after the reference week.</p>
</dd>
<dt>reported.2.week</dt><dd><p>The number of cases occurred in the period and reported until the 2 weeks after the reference week.</p>
</dd>
<dt>reported.4.week</dt><dd><p>The number of cases occurred in the period and reported until the 4 weeks after the reference week.</p>
</dd>
<dt>reported.6.week</dt><dd><p>The number of cases occurred in the period and reported until the 6 weeks after the reference week.</p>
</dd>
<dt>reported.8.week</dt><dd><p>The number of cases occurred in the period and reported until the 8 weeks after the reference week.</p>
</dd>
<dt>reported.12.week</dt><dd><p>The number of cases occurred in the period and reported until the 12 weeks after the reference week.</p>
</dd>
<dt>occured</dt><dd><p>The total number of cases reported (at any time).</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://datasus.saude.gov.br/informacoes-de-saude-tabnet/">https://datasus.saude.gov.br/informacoes-de-saude-tabnet/</a>
</p>

<hr>
<h2 id='plot.dlm_coef'>Visualizing latent states in a fitted kDGLM model</h2><span id='topic+plot.dlm_coef'></span>

<h3>Description</h3>

<p>Visualizing latent states in a fitted kDGLM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm_coef'
plot(
  x,
  var = rownames(x$theta.mean)[x$dynamic],
  cutoff = floor(t/10),
  pred.cred = 0.95,
  plot.pkg = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dlm_coef_+3A_x">x</code></td>
<td>
<p>dlm_coef object: The coefficients of a fitted DGLM model.</p>
</td></tr>
<tr><td><code id="plot.dlm_coef_+3A_var">var</code></td>
<td>
<p>character: The name of the variables to plot (same value passed while creating the structure). Any variable whose name partially match this variable will be plotted.</p>
</td></tr>
<tr><td><code id="plot.dlm_coef_+3A_cutoff">cutoff</code></td>
<td>
<p>integer: The number of initial steps that should be skipped in the plot. Usually, the model is still learning in the initial steps, so the estimated values are not reliable.</p>
</td></tr>
<tr><td><code id="plot.dlm_coef_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: The credibility value for the credibility interval.</p>
</td></tr>
<tr><td><code id="plot.dlm_coef_+3A_plot.pkg">plot.pkg</code></td>
<td>
<p>character: A flag indicating if a plot should be produced. Should be one of 'auto', 'base', 'ggplot2' or 'plotly'.</p>
</td></tr>
<tr><td><code id="plot.dlm_coef_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the plot method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or plotly object: A plot showing the predictive mean and credibility interval with the observed data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>,<code><a href="stats.html#topic+coef">coef</a></code>
</p>
<p>Other auxiliary visualization functions for the fitted_dlm class: 
<code><a href="#topic+plot.fitted_dlm">plot.fitted_dlm</a>()</code>,
<code><a href="#topic+summary.fitted_dlm">summary.fitted_dlm</a>()</code>,
<code><a href="#topic+summary.searched_dlm">summary.searched_dlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)

model.coef &lt;- coef(fitted.data)

plot(model.coef)$plot

</code></pre>

<hr>
<h2 id='plot.fitted_dlm'>Visualizing a fitted kDGLM model</h2><span id='topic+plot.fitted_dlm'></span>

<h3>Description</h3>

<p>Calculate the predictive mean and some quantile for the observed data and show a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_dlm'
plot(
  x,
  outcomes = NULL,
  latent.states = NULL,
  linear.predictors = NULL,
  pred.cred = 0.95,
  lag = NA,
  cutoff = floor(x$t/10),
  plot.pkg = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fitted_dlm_+3A_x">x</code></td>
<td>
<p>fitted_dlm object: A fitted DGLM.</p>
</td></tr>
<tr><td><code id="plot.fitted_dlm_+3A_outcomes">outcomes</code></td>
<td>
<p>character: The name of the outcomes to plot.</p>
</td></tr>
<tr><td><code id="plot.fitted_dlm_+3A_latent.states">latent.states</code></td>
<td>
<p>character: The name of the latent states to plot.</p>
</td></tr>
<tr><td><code id="plot.fitted_dlm_+3A_linear.predictors">linear.predictors</code></td>
<td>
<p>character: The name of the linear predictors to plot.</p>
</td></tr>
<tr><td><code id="plot.fitted_dlm_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: The credibility value for the credibility interval.</p>
</td></tr>
<tr><td><code id="plot.fitted_dlm_+3A_lag">lag</code></td>
<td>
<p>integer: The number of steps ahead to be used for prediction. If lag&lt;0, the smoothed distribution is used and, if lag==0, the filtered interval.score is used.</p>
</td></tr>
<tr><td><code id="plot.fitted_dlm_+3A_cutoff">cutoff</code></td>
<td>
<p>integer: The number of initial steps that should be skipped in the plot. Usually, the model is still learning in the initial steps, so the predictions are not reliable.</p>
</td></tr>
<tr><td><code id="plot.fitted_dlm_+3A_plot.pkg">plot.pkg</code></td>
<td>
<p>character: A flag indicating if a plot should be produced. Should be one of 'auto', 'base', 'ggplot2' or 'plotly'.</p>
</td></tr>
<tr><td><code id="plot.fitted_dlm_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the plot method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or plotly object: A plot showing the predictive mean and credibility interval with the observed data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary visualization functions for the fitted_dlm class: 
<code><a href="#topic+plot.dlm_coef">plot.dlm_coef</a>()</code>,
<code><a href="#topic+summary.fitted_dlm">summary.fitted_dlm</a>()</code>,
<code><a href="#topic+summary.searched_dlm">summary.searched_dlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)

plot(fitted.data, plot.pkg = "base")

</code></pre>

<hr>
<h2 id='Poisson'>Poisson outcome for kDGLM models</h2><span id='topic+Poisson'></span>

<h3>Description</h3>

<p>Creates an outcome with Poisson distribution with the chosen parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Poisson(lambda, data, offset = as.matrix(data)^0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Poisson_+3A_lambda">lambda</code></td>
<td>
<p>character: The name of the linear predictor associated with the rate (mean) parameter of the Poisson distribution. The parameter is treated as unknown and equal to the exponential of the associated linear predictor.</p>
</td></tr>
<tr><td><code id="Poisson_+3A_data">data</code></td>
<td>
<p>numeric: The values of the observed data.</p>
</td></tr>
<tr><td><code id="Poisson_+3A_offset">offset</code></td>
<td>
<p>numeric: The offset at each observation. Must have the same shape as data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For evaluating the posterior parameters, we use the method proposed in Alves et al. (2024).
</p>
<p>For the details about the implementation see  dos Santos et al. (2024).
</p>


<h3>Value</h3>

<p>A object of the class dlm_distr
</p>


<h3>References</h3>

<p>Mariane
Branco Alves, Helio
S. Migon, Raíra Marotta, Junior,
Silvaneo
Vieira dos Santos (2024).
&ldquo;k-parametric Dynamic Generalized Linear Models: a sequential approach via Information Geometry.&rdquo;
2201.05387.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for a creating outcomes: 
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Multinom">Multinom</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+summary.dlm_distr">summary.dlm_distr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, D = 0.95, order = 2)
season &lt;- harmonic_block(rate = 1, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data = data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)
summary(fitted.data)

plot(fitted.data, plot.pkg = "base")

</code></pre>

<hr>
<h2 id='poisson_pred'>poisson_pred</h2><span id='topic+poisson_pred'></span>

<h3>Description</h3>

<p>Calculate the values for the predictive distribution given the values of the parameter of the conjugated distribution of the linear predictor.
The data is assumed to have Poisson distribution with its mean having distribution Gamma with shape parameter a e rate parameter b.
In this scenario, the marginal distribution of the data is Negative Binomial with a as the dispersion parameter and b/(b+1) as the probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson_pred(conj.param, outcome = NULL, parms = list(), pred.cred = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poisson_pred_+3A_conj.param">conj.param</code></td>
<td>
<p>list or data.frame: The parameters of the conjugated distributions of the linear predictor.</p>
</td></tr>
<tr><td><code id="poisson_pred_+3A_outcome">outcome</code></td>
<td>
<p>numeric or matrix (optional): The observed values at the current time. Not used in this function.</p>
</td></tr>
<tr><td><code id="poisson_pred_+3A_parms">parms</code></td>
<td>
<p>list (optional): A list of extra parameters for the model. Not used in this function.</p>
</td></tr>
<tr><td><code id="poisson_pred_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: the desired credibility for the credibility interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following values:
</p>

<ul>
<li><p> pred numeric/matrix: the mean of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> var.pred numeric/matrix: the variance of the predictive distribution of a next observation. Same type and shape as the parameter in model.
</p>
</li>
<li><p> icl.pred numeric/matrix: the percentile of 100*((1-pred.cred)/2)
</p>
</li>
<li><p> icu.pred numeric/matrix: the percentile of 100*(1-(1-pred.cred)/2)
</p>
</li>
<li><p> log.like numeric: the The log likelihood for the outcome given the conjugated parameters.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auxiliary functions for a Poisson outcome: 
<code><a href="#topic+convert_Normal_Poisson">convert_Normal_Poisson</a>()</code>,
<code><a href="#topic+convert_Poisson_Normal">convert_Poisson_Normal</a>()</code>,
<code><a href="#topic+update_Poisson">update_Poisson</a>()</code>
</p>

<hr>
<h2 id='polynomial_block'>Structural blocks for polynomial trends and regressions</h2><span id='topic+polynomial_block'></span>

<h3>Description</h3>

<p>Creates the structure for a polynomial block with desired order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polynomial_block(
  ...,
  order = 1,
  name = "Var.Poly",
  D = 1,
  h = 0,
  H = 0,
  a1 = 0,
  R1 = c(9, rep(1, order - 1)),
  monitoring = c(TRUE, rep(FALSE, order - 1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polynomial_block_+3A_...">...</code></td>
<td>
<p>Named values for the planning matrix.</p>
</td></tr>
<tr><td><code id="polynomial_block_+3A_order">order</code></td>
<td>
<p>Positive integer: The order of the polynomial structure.</p>
</td></tr>
<tr><td><code id="polynomial_block_+3A_name">name</code></td>
<td>
<p>String: An optional argument providing the name for this block. Can be useful to identify the models with meaningful labels, also, the name used will be used in some auxiliary functions.</p>
</td></tr>
<tr><td><code id="polynomial_block_+3A_d">D</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the discount factors associated with the latent states at each time. If D is an array, its dimensions should be n x n x t, where n is the order of the polynomial block and t is the length of the outcomes. If D is a matrix, its dimensions should be n x n and the same discount matrix will be used in all observations. If D is a vector, it should have size t and it is interpreted as the discount factor at each observed time (same discount for all variable). If D is a scalar, the same discount will be used for all latent states at all times.</p>
</td></tr>
<tr><td><code id="polynomial_block_+3A_h">h</code></td>
<td>
<p>Matrix, vector or scalar: A drift to be add after the temporal evolution (can be interpreted as the mean of the random noise at each time). If a matrix, its dimension should be n x t, where n is the number of latent states (i.e., the order) and t is the length of the series. If a vector, it should have size t, and each value will be applied to the first latent state (the one which affects the linear predictors) in their respective time. If a scalar, the passed value will be used for the first latent state at each time.</p>
</td></tr>
<tr><td><code id="polynomial_block_+3A_h">H</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the covariance matrix for the noise factor at each time. If H is an array, its dimensions should be n x n x t, where n is the order of the polynomial block and t is the length of the series. If H is a matrix, its dimensions should be n x n and its values will be used for each time. If H is a vector or scalar, a discount factor matrix will be created as a diagonal matrix with the values of H in the diagonal.</p>
</td></tr>
<tr><td><code id="polynomial_block_+3A_a1">a1</code></td>
<td>
<p>Vector or scalar: The prior mean for the latent states associated with this block at time 1. If a1 is a vector, its dimension should be equal to the order of the polynomial block. If a1 is a scalar, its value will be used for all latent states.</p>
</td></tr>
<tr><td><code id="polynomial_block_+3A_r1">R1</code></td>
<td>
<p>Matrix, vector or scalar: The prior covariance matrix for the latent states associated with this block at time 1. If R1 is a matrix, its dimensions should be n x n. If R1 is a vector or scalar, a covariance matrix will be created as a diagonal matrix with the values of R1 in the diagonal.</p>
</td></tr>
<tr><td><code id="polynomial_block_+3A_monitoring">monitoring</code></td>
<td>
<p>Vector: A vector of flags indicating which variables should be monitored (if automated monitoring is used). Its size should be n. The default is that only the first order component of this structure should be monitored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the ..., D, H, a1 and R1 arguments, the user may set one or more of its values as a string.
By doing so, the user will leave the block partially undefined.
The user must then pass the undefined parameter values as named arguments to the <code><a href="#topic+fit_model">fit_model</a></code> function. Also, multiple values can be passed, allowing for a sensitivity analysis for the value of this parameter.
</p>
<p>For the details about the implementation see dos Santos et al. (2024).
</p>
<p>For the details about polynomial trend in the context of DLM's, see West and Harrison (1997), chapter 7.
</p>
<p>For the details about dynamic regression models in the context of DLM's, see West and Harrison (1997), chapters 6 and 9.
</p>


<h3>Value</h3>

<p>A dlm_block object containing the following values:
</p>

<ul>
<li><p> FF Array: A 3D-array containing the regression matrix for each time. Its dimension should be n x k x t, where n is the number of latent states, k is the number of linear predictors in the model and t is the time series length.
</p>
</li>
<li><p> FF.labs Matrix: A n x k character matrix describing the type of value of each element of FF.
</p>
</li>
<li><p> G Matrix: A 3D-array containing the evolution matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> G.labs Matrix: A n x n character matrix describing the type of value of each element of G.
</p>
</li>
<li><p> D Array: A 3D-array containing the discount factor matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> h Matrix: The mean for the random noise of the temporal evolution. Its dimension should be n x t.
</p>
</li>
<li><p> H Array: A 3D-array containing the covariance matrix of the noise for each time. Its dimension should be the same as D.
</p>
</li>
<li><p> a1 Vector: The prior mean for the latent vector.
</p>
</li>
<li><p> R1 Matrix: The prior covariance matrix for the latent vector.
</p>
</li>
<li><p> var.names list: A list containing the variables indexes by their name.
</p>
</li>
<li><p> order Positive integer: Same as argument.
</p>
</li>
<li><p> n Positive integer: The number of latent states associated with this block (same value as order).
</p>
</li>
<li><p> t Positive integer: The number of time steps associated with this block. If 1, the block is compatible with blocks of any time length, but if t is greater than 1, this block can only be used with blocks of the same time length.
</p>
</li>
<li><p> k Positive integer: The number of outcomes associated with this block. This block can only be used with blocks with the same outcome length.
</p>
</li>
<li><p> pred.names Vector: The name of the linear predictors associated with this block.
</p>
</li>
<li><p> monitoring Vector: Same as argument.
</p>
</li>
<li><p> type Character: The type of block (polynomial).
</p>
</li></ul>



<h3>References</h3>

<p>Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a first order structure for a model with 2 outcomes.
# One block is created for each outcome
# with each block being associated with only one of the outcomes.
level.1 &lt;- polynomial_block(alpha1 = 1, order = 1)
level.2 &lt;- polynomial_block(alpha2 = 1, order = 1)

# Creating a block with shared effect between the outcomes
level.3 &lt;- polynomial_block(alpha1 = 1, alpha2 = 1, order = 2)

</code></pre>

<hr>
<h2 id='print.dlm_block'>print.dlm_block</h2><span id='topic+print.dlm_block'></span>

<h3>Description</h3>

<p>This method is wrapper for the summary.dlm_block function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm_block'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dlm_block_+3A_x">x</code></td>
<td>
<p>A dlm_block object.</p>
</td></tr>
<tr><td><code id="print.dlm_block_+3A_...">...</code></td>
<td>
<p>Arguments passed to summary.dlm_block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print a summary of a kDGLM structure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dlm_block">summary.dlm_block</a></code>
</p>

<hr>
<h2 id='print.dlm_distr'>print.dlm_distr</h2><span id='topic+print.dlm_distr'></span>

<h3>Description</h3>

<p>This method is wrapper for the summary.dlm_distr function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm_distr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dlm_distr_+3A_x">x</code></td>
<td>
<p>A dlm_distr object.</p>
</td></tr>
<tr><td><code id="print.dlm_distr_+3A_...">...</code></td>
<td>
<p>Arguments passed to summary.dlm_distr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print a summary of a kDGLM outcome.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dlm_distr">summary.dlm_distr</a></code>
</p>

<hr>
<h2 id='print.fitted_dlm'>print.fitted_dlm</h2><span id='topic+print.fitted_dlm'></span>

<h3>Description</h3>

<p>This method is wrapper for the summary.fitted_dlm methdd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_dlm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fitted_dlm_+3A_x">x</code></td>
<td>
<p>A fitted_dlm object.</p>
</td></tr>
<tr><td><code id="print.fitted_dlm_+3A_...">...</code></td>
<td>
<p>Arguments passed to summary.fitted_dlm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print a summary of the fitted kDGLM model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fitted_dlm">summary.fitted_dlm</a></code>
</p>

<hr>
<h2 id='print.searched_dlm'>print.searched_dlm</h2><span id='topic+print.searched_dlm'></span>

<h3>Description</h3>

<p>This method is wrapper for the block_superpos function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'searched_dlm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.searched_dlm_+3A_x">x</code></td>
<td>
<p>A searched_dlm object.</p>
</td></tr>
<tr><td><code id="print.searched_dlm_+3A_...">...</code></td>
<td>
<p>Arguments passed to summary.searched_dlm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print a summary of a searched_dlm object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.searched_dlm">summary.searched_dlm</a></code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+specify'></span><span id='topic+simulate'></span><span id='topic+forecast'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+forecast">forecast</a></code>, <code><a href="generics.html#topic+specify">specify</a></code></p>
</dd>
<dt>stats</dt><dd><p><code><a href="stats.html#topic+simulate">simulate</a></code></p>
</dd>
</dl>

<hr>
<h2 id='regression_block'>Structural blocks for regressions</h2><span id='topic+regression_block'></span>

<h3>Description</h3>

<p>Creates a block for a (dynamic) regression for a covariate X_t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regression_block(
  ...,
  max.lag = 0,
  zero.fill = TRUE,
  name = "Var.Reg",
  D = 1,
  h = 0,
  H = 0,
  a1 = 0,
  R1 = 9,
  monitoring = rep(FALSE, max.lag + 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regression_block_+3A_...">...</code></td>
<td>
<p>Named values for the planning matrix.</p>
</td></tr>
<tr><td><code id="regression_block_+3A_max.lag">max.lag</code></td>
<td>
<p>Non-negative integer: An optional argument providing the maximum lag for the explanatory variables. If a positive value is provided, this block will create additional latent states to measure the lagged effect of X_t up until the given value. See West and Harrison (1997), subsection 9.2.2 item (3).</p>
</td></tr>
<tr><td><code id="regression_block_+3A_zero.fill">zero.fill</code></td>
<td>
<p>boolean: A Boolean indicating if the block should fill the initial delay values with 0's. If TRUE and max.lag is positive, the block assumes that X_t=0 for all t&lt;1. If FALSE, the block assumes the user will provide X_t for all t, such that X_t will have size t+propagation_size</p>
</td></tr>
<tr><td><code id="regression_block_+3A_name">name</code></td>
<td>
<p>String: An optional argument providing the name for this block. Can be useful to identify the models with meaningful labels, also, the name used will be used in some auxiliary functions.</p>
</td></tr>
<tr><td><code id="regression_block_+3A_d">D</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the discount factors at each time. If D is a array, its dimensions should be n x n x t, where n is the order of the polynomial block and t is the length of the outcomes. If D is a matrix, its dimensions should be n x n and its values will be used for each time. If D is a vector or scalar, a discount factor matrix will be created as a diagonal matrix with the values of D in the diagonal.</p>
</td></tr>
<tr><td><code id="regression_block_+3A_h">h</code></td>
<td>
<p>Matrix, vector or scalar: A drift to be add after the temporal evolution (can be interpreted as the mean of the random noise at each time). If a matrix, its dimension should be 2 x t, where t is the length of the series. If a vector, it should have size t, and each value will be applied to the first latent state (the one which affects the linear predictors) in their respective time. If a scalar, the passed value will be used for the first latent state at each time.</p>
</td></tr>
<tr><td><code id="regression_block_+3A_h">H</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the covariance matrix for the noise factor at each time. If H is a array, its dimensions should be n x n x t, where n is the order of the polynomial block and t is the length of the outcomes. If H is a matrix, its dimensions should be n x n and its values will be used for each time. If H is a vector or scalar, a discount factor matrix will be created as a diagonal matrix with the values of H in the diagonal.</p>
</td></tr>
<tr><td><code id="regression_block_+3A_a1">a1</code></td>
<td>
<p>Vector or scalar: The prior mean for the latent states associated with this block at time 1. If a1 is a vector, its dimension should be equal to the order of the polynomial block. If a1 is a scalar, its value will be used for all latent states.</p>
</td></tr>
<tr><td><code id="regression_block_+3A_r1">R1</code></td>
<td>
<p>Matrix, vector or scalar: The prior covariance matrix for the latent states associated with this block at time 1. If R1 is a matrix, its dimensions should be n x n. If R1 is a vector or scalar, a covariance matrix will be created as a diagonal matrix with the values of R1 in the diagonal.</p>
</td></tr>
<tr><td><code id="regression_block_+3A_monitoring">monitoring</code></td>
<td>
<p>Vector: A vector of flags indicating which variables should be monitored (if automated monitoring is used). Its size should be n. The default is that no variable should be monitored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the ..., D, H, a1 and R1 arguments, the user may set one or more of its values as a string.
By doing so, the user will leave the block partially undefined.
The user must then pass the undefined parameter values as named arguments to the <code><a href="#topic+fit_model">fit_model</a></code> function. Also, multiple values can be passed, allowing for a sensitivity analysis for the value of this parameter.
</p>
<p>For the details about the implementation see dos Santos et al. (2024).
</p>
<p>For the details about dynamic regression models in the context of DLM's, see West and Harrison (1997), chapters 6 and 9.
</p>


<h3>Value</h3>

<p>A dlm_block object containing the following values:
</p>

<ul>
<li><p> FF Array: A 3D-array containing the regression matrix for each time. Its dimension should be n x k x t, where n is the number of latent states, k is the number of linear predictors in the model and t is the time series length.
</p>
</li>
<li><p> FF.labs Matrix: A n x k character matrix describing the type of value of each element of FF.
</p>
</li>
<li><p> G Matrix: A 3D-array containing the evolution matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> G.labs Matrix: A n x n character matrix describing the type of value of each element of G.
</p>
</li>
<li><p> D Array: A 3D-array containing the discount factor matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> h Matrix: The mean for the random noise of the temporal evolution. Its dimension should be n x t.
</p>
</li>
<li><p> H Array: A 3D-array containing the covariance matrix of the noise for each time. Its dimension should be the same as D.
</p>
</li>
<li><p> a1 Vector: The prior mean for the latent vector.
</p>
</li>
<li><p> R1 Matrix: The prior covariance matrix for the latent vector.
</p>
</li>
<li><p> var.names list: A list containing the variables indexes by their name.
</p>
</li>
<li><p> max.lag Positive integer: Same as argument.
</p>
</li>
<li><p> n Positive integer: The number of latent states associated with this block (2).
</p>
</li>
<li><p> t Positive integer: The number of time steps associated with this block. If 1, the block is compatible with blocks of any time length, but if t is greater than 1, this block can only be used with blocks of the same time length.
</p>
</li>
<li><p> k Positive integer: The number of outcomes associated with this block. This block can only be used with blocks with the same outcome length.
</p>
</li>
<li><p> pred.names Vector: The name of the linear predictors associated with this block.
</p>
</li>
<li><p> monitoring Vector: Same as argument.
</p>
</li>
<li><p> type Character: The type of block (Harmonic).
</p>
</li></ul>



<h3>References</h3>

<p>Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
structure &lt;- (
  polynomial_block(p = 1, order = 2, D = 0.95) +
    harmonic_block(p = 1, period = 12, D = 0.95) +
    regression_block(p = chickenPox$date &gt;= as.Date("2013-09-01"))
  # Vaccine was introduced in September of 2013
) * 4

outcome &lt;- Multinom(p = structure$pred.names, data = chickenPox[, c(2, 3, 4, 6, 5)])
fitted.data &lt;- fit_model(structure, chickenPox = outcome)
summary(fitted.data)
plot(coef(fitted.data), plot.pkg = "base")

</code></pre>

<hr>
<h2 id='rmvnorm'>rmvnorm</h2><span id='topic+rmvnorm'></span>

<h3>Description</h3>

<p>Obtains a sample from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm(n, mu, Sigma, norm.x = matrnorm(k, n, seed = round(runif(1) * 1e+15)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm_+3A_n">n</code></td>
<td>
<p>integer: The sample size.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_mu">mu</code></td>
<td>
<p>numeric: The mean vector</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_sigma">Sigma</code></td>
<td>
<p>matrix: The Covariance matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='rowQuantile'>rowQuantile</h2><span id='topic+rowQuantile'></span>

<h3>Description</h3>

<p>A function that calculates the row-wise quantile of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowQuantile(X, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowQuantile_+3A_x">X</code></td>
<td>
<p>matrix.</p>
</td></tr>
<tr><td><code id="rowQuantile_+3A_q">q</code></td>
<td>
<p>numeric: A number between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: The chosen quantile for each row of X.
</p>

<hr>
<h2 id='simulate.fitted_dlm'>Draw samples from the distribution of the latent states</h2><span id='topic+simulate.fitted_dlm'></span>

<h3>Description</h3>

<p>This is function draws samples from the latent states using the backward sampling algorithm. See West and Harrison (1997), chapter 15, for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_dlm'
simulate(object, nsim, seed = NULL, lag = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.fitted_dlm_+3A_object">object</code></td>
<td>
<p>fitted_dlm: A fitted model from which to sample.</p>
</td></tr>
<tr><td><code id="simulate.fitted_dlm_+3A_nsim">nsim</code></td>
<td>
<p>integer: The number of samples to draw.</p>
</td></tr>
<tr><td><code id="simulate.fitted_dlm_+3A_seed">seed</code></td>
<td>
<p>integer: An object specifying if and how the random number generator should be initialized.</p>
</td></tr>
<tr><td><code id="simulate.fitted_dlm_+3A_lag">lag</code></td>
<td>
<p>integer: The relative offset for forecast. Values for time t will be calculated based on the filtered values of time t-h. If lag is negative, then the smoothed distribution for the latent states will be used.</p>
</td></tr>
<tr><td><code id="simulate.fitted_dlm_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the plot method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following values:
</p>

<ul>
<li><p> theta array: An array containing a sample of the latent states. Dimensions are n x t x nsim, where n is the number of latent states in the model and t is the number of observed values.
</p>
</li>
<li><p> lambda array: An array containing a sample of the linear predictors. Dimensions are k x t x nsim, where k is the number of linear predictors in the model and t is the number of observed values.
</p>
</li>
<li><p> param list: A named list containing, for each model outcome, an array with the samples of the parameters of the observational model. Each array will have dimensions l x t x nsim, where l is the number of parameters in the observational model and t is the number of observed values.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other auxiliary functions for fitted_dlm objects: 
<code><a href="#topic+coef.fitted_dlm">coef.fitted_dlm</a>()</code>,
<code><a href="#topic+eval_dlm_norm_const">eval_dlm_norm_const</a>()</code>,
<code><a href="#topic+fit_model">fit_model</a>()</code>,
<code><a href="#topic+forecast.fitted_dlm">forecast.fitted_dlm</a>()</code>,
<code><a href="#topic+smoothing">smoothing</a>()</code>,
<code><a href="#topic+update.fitted_dlm">update.fitted_dlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
structure &lt;- polynomial_block(mu = 1, D = 0.95) +
  polynomial_block(V = 1, D = 0.95)

outcome &lt;- Normal(mu = "mu", V = "V", data = cornWheat$corn.log.return[1:500])
fitted.data &lt;- fit_model(structure, corn = outcome)

sample &lt;- simulate(fitted.data, 5000)

</code></pre>

<hr>
<h2 id='smoothing'>Auxiliary function for model smoothing</h2><span id='topic+smoothing'></span>

<h3>Description</h3>

<p>Auxiliary function for model smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothing(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothing_+3A_model">model</code></td>
<td>
<p>A fitted_dlm object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted_dlm object with smoothed means (mts) and covariance matrix (Cts) for each observation.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for fitted_dlm objects: 
<code><a href="#topic+coef.fitted_dlm">coef.fitted_dlm</a>()</code>,
<code><a href="#topic+eval_dlm_norm_const">eval_dlm_norm_const</a>()</code>,
<code><a href="#topic+fit_model">fit_model</a>()</code>,
<code><a href="#topic+forecast.fitted_dlm">forecast.fitted_dlm</a>()</code>,
<code><a href="#topic+simulate.fitted_dlm">simulate.fitted_dlm</a>()</code>,
<code><a href="#topic+update.fitted_dlm">update.fitted_dlm</a>()</code>
</p>

<hr>
<h2 id='specify.dlm_block'>Specify method for dlm blocks</h2><span id='topic+specify.dlm_block'></span>

<h3>Description</h3>

<p>Sets the values of undefined parameters in a block to those passed by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm_block'
specify(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specify.dlm_block_+3A_x">x</code></td>
<td>
<p>dlm_block: A undefined dlm_block object from which the undefined parameters shall be substituted.</p>
</td></tr>
<tr><td><code id="specify.dlm_block_+3A_...">...</code></td>
<td>
<p>A set of named values for each unknown parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The initual block, but with the undefined parameters set to the chosen values.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
season &lt;- harmonic_block(rate = 1, period = 12, D = "D.sazo") |&gt;
  specify(D.sazo = 0.975)

</code></pre>

<hr>
<h2 id='summary.dlm_block'>Summary for a kDGLM structure</h2><span id='topic+summary.dlm_block'></span>

<h3>Description</h3>

<p>Prints a report for a dlm_block object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm_block'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dlm_block_+3A_object">object</code></td>
<td>
<p>A dlm_block object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print a summary of a kDGLM structure.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+TF_block">TF_block</a>()</code>,
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>
</p>

<hr>
<h2 id='summary.dlm_distr'>Summary for a kDGLM outcome</h2><span id='topic+summary.dlm_distr'></span>

<h3>Description</h3>

<p>Prints a report for a dlm_distr object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlm_distr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dlm_distr_+3A_object">object</code></td>
<td>
<p>A dlm_distr object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print a summary of a kDGLM outcome.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a creating outcomes: 
<code><a href="#topic+Gamma">Gamma</a>()</code>,
<code><a href="#topic+Multinom">Multinom</a>()</code>,
<code><a href="#topic+Normal">Normal</a>()</code>,
<code><a href="#topic+Poisson">Poisson</a>()</code>
</p>

<hr>
<h2 id='summary.fitted_dlm'>Summary for a fitted kDGLM model</h2><span id='topic+summary.fitted_dlm'></span>

<h3>Description</h3>

<p>Prints a report for a fitted_dlm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_dlm'
summary(
  object,
  t = object$t,
  lag = -1,
  metric.lag = 1,
  metric.cutoff = floor(object$t/10),
  pred.cred = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fitted_dlm_+3A_object">object</code></td>
<td>
<p>A fitted_dlm object.</p>
</td></tr>
<tr><td><code id="summary.fitted_dlm_+3A_t">t</code></td>
<td>
<p>Integer: The time index for the latent states.</p>
</td></tr>
<tr><td><code id="summary.fitted_dlm_+3A_lag">lag</code></td>
<td>
<p>Integer: The number of steps ahead used for the evaluating the latent states. Use lag&lt;0 for the smoothed distribution, If lag==0 for the filtered distribution and lag=h for the h-step-ahead prediction.</p>
</td></tr>
<tr><td><code id="summary.fitted_dlm_+3A_metric.lag">metric.lag</code></td>
<td>
<p>Integer: The number of steps ahead used for the evaluating the predictions used when calculating metrics. Use metric.lag&lt;0 for the smoothed distribution, If metric.lag==0 for the filtered distribution and metric.lag=h for the h-step-ahead prediction.</p>
</td></tr>
<tr><td><code id="summary.fitted_dlm_+3A_metric.cutoff">metric.cutoff</code></td>
<td>
<p>Integer: The cutoff time index for the metric calculation. Values before that time will be ignored.</p>
</td></tr>
<tr><td><code id="summary.fitted_dlm_+3A_pred.cred">pred.cred</code></td>
<td>
<p>numeric: The credibility interval to be used for the interval score.</p>
</td></tr>
<tr><td><code id="summary.fitted_dlm_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the coef method.#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print a summary of the fitted kDGLM model.
</p>


<h3>See Also</h3>

<p>Other auxiliary visualization functions for the fitted_dlm class: 
<code><a href="#topic+plot.dlm_coef">plot.dlm_coef</a>()</code>,
<code><a href="#topic+plot.fitted_dlm">plot.fitted_dlm</a>()</code>,
<code><a href="#topic+summary.searched_dlm">summary.searched_dlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- c(AirPassengers)

level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

outcome &lt;- Poisson(lambda = "rate", data)

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)
summary(fitted.data)

</code></pre>

<hr>
<h2 id='summary.searched_dlm'>Summary for a searched_dlm object</h2><span id='topic+summary.searched_dlm'></span>

<h3>Description</h3>

<p>Prints a report for a searched_dlm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'searched_dlm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.searched_dlm_+3A_object">object</code></td>
<td>
<p>A searched_dlm object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print a summary of a searched_dlm object.
</p>


<h3>See Also</h3>

<p>Other auxiliary visualization functions for the fitted_dlm class: 
<code><a href="#topic+plot.dlm_coef">plot.dlm_coef</a>()</code>,
<code><a href="#topic+plot.fitted_dlm">plot.fitted_dlm</a>()</code>,
<code><a href="#topic+summary.fitted_dlm">summary.fitted_dlm</a>()</code>
</p>

<hr>
<h2 id='TF_block'>Structural blocks for auto regressive trends and regressions</h2><span id='topic+TF_block'></span>

<h3>Description</h3>

<p>Creates the structure for a Auto Regressive (AR) block (see West and Harrison (1997), chapter 9) with desired order.
As the package suppose that the structure of the model is linear, a linearization is applied to the evolution equation, as described in West and Harrison (1997), chapter 13.
This block also supports Transfer Functions, being necessary to specify the associated pulse when calling the TF_block function (see arg.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF_block(
  ...,
  order,
  noise.var = NULL,
  noise.disc = NULL,
  pulse = 0,
  name = "Var.AR",
  AR.support = "free",
  h = 0,
  a1 = 0,
  R1 = 4,
  monitoring = TRUE,
  D.coef = 1,
  h.coef = 0,
  H.coef = 0,
  a1.coef = c(1, rep(0, order - 1)),
  R1.coef = c(1, rep(0.25, order - 1)),
  monitoring.coef = rep(FALSE, order),
  D.pulse = 1,
  h.pulse = 0,
  H.pulse = 0,
  a1.pulse = 0,
  R1.pulse = 4,
  monitoring.pulse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TF_block_+3A_...">...</code></td>
<td>
<p>Named values for the planning matrix.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_order">order</code></td>
<td>
<p>Positive integer: The order of the AR block.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_noise.var">noise.var</code></td>
<td>
<p>Non-negative scalar: The variance of the white noise added to the latent state.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_noise.disc">noise.disc</code></td>
<td>
<p>Vector or scalar: The value for the discount factor associated with the current latent state. If noise.disc is a vector, it should have size t and it is interpreted as the discount factor at each observed time. If D is a scalar, the same discount will be used for all observation.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_pulse">pulse</code></td>
<td>
<p>Vector or scalar: An optional argument providing the values for the pulse for a Transfer Function. Default is 0 (no Transfer Function).</p>
</td></tr>
<tr><td><code id="TF_block_+3A_name">name</code></td>
<td>
<p>String: An optional argument providing the name for this block. Can be useful to identify the models with meaningful labels, also, the name used will be used in some auxiliary functions.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_ar.support">AR.support</code></td>
<td>
<p>String: Either &quot;constrained&quot; or &quot;free&quot; (default). If AR.support is &quot;constrained&quot;, then the AR coefficients will be forced to be on the interval (-1,1), otherwise, the coefficients will be unrestricted. Beware that, under no restriction on the coefficients, there is no guarantee that the estimated coefficients will imply in a stationary process, furthermore, if the order of the AR block is greater than 1. As such the restriction of the coefficients support is only available for AR blocks with order equal to 1.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_h">h</code></td>
<td>
<p>Vector or scalar: A drift to be add in the states after the temporal evolution (can be interpreted as the mean of the random noise at each time). If a vector, it should have size t, and each value will be applied in their respective time. If a scalar, the passed value will be used for all observations.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_a1">a1</code></td>
<td>
<p>Vector or scalar: The prior mean for the states associated with this block at time 1. If a1 is a vector, its dimension should be equal to the order of the AR block. If a1 is a scalar, its value will be used for all coefficients.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_r1">R1</code></td>
<td>
<p>Matrix, vector or scalar: The prior covariance matrix for the states associated with this block at time 1. If R1 is a matrix, its dimensions should be n x n, where n is the order of the AR block. If R1 is a vector or scalar, a covariance matrix will be created as a diagonal matrix with the values of R1 in the diagonal.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_monitoring">monitoring</code></td>
<td>
<p>bool: A flag indicating if the latent state should be monitored (if automated monitoring is used). The default is TRUE.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_d.coef">D.coef</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the discount factors associated with the AR coefficients at each time. If D.coef is an array, its dimensions should be n x n x t, where n is the order of the AR block and t is the length of the outcomes. If D.coef is a matrix, its dimensions should be n x n and the same discount matrix will be used in all observations. If D.coef is a vector, it should have size t and it is interpreted as the discount factor at each observed time (same discount for all variable). If D.coef is a scalar, the same discount will be used for all AR coefficients at all times.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_h.coef">h.coef</code></td>
<td>
<p>Matrix, vector or scalar: A drift to be add in the AR coefficients after the temporal evolution (can be interpreted as the mean of the random noise at each time). If a matrix, its dimension should be n x t, where n is the order of the AR block and t is the length of the series. If a scalar, the passed value will be used for all coefficients at each time.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_h.coef">H.coef</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the covariance matrix for the noise factor associated with the AR coefficients at each time. If H.coef is a array, its dimensions should be n x n x t, where n is the order of the AR block and t is the length of the outcomes. If H.coef is a matrix, its dimensions should be n x n and its values will be used for each time. If H.coef is a vector or scalar, a discount factor matrix will be created as a diagonal matrix with the values of H.coef in the diagonal.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_a1.coef">a1.coef</code></td>
<td>
<p>Vector or scalar: The prior mean for the AR coefficients associated with this block at time 1. If a1.coef is a vector, its dimension should be equal to the order of the AR block. If a1.coef is a scalar, its value will be used for all coefficients. If the coefficients are restricted to the interval (-1,1), the a1.coef is interpreted as the mean for atanh(rho), where rho is the AR coefficient.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_r1.coef">R1.coef</code></td>
<td>
<p>Matrix, vector or scalar: The prior covariance matrix for the coefficients associated with this block at time 1. If R1.coef is a matrix, its dimensions should be n x n, where n is the order of the AR block. If R1.coef is a vector or scalar, a covariance matrix will be created as a diagonal matrix with the values of R1.coef in the diagonal. If the coefficients are restricted to the interval (-1,1), the R1.coef is interpreted as the covariance matrix for atanh(rho), where rho is the AR coefficient.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_monitoring.coef">monitoring.coef</code></td>
<td>
<p>Vector: A vector of flags indicating which AR coefficients should be monitored (if automated monitoring is used). Its size should be n, where n is the order of the AR block. The default is that no coefficient should be monitored.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_d.pulse">D.pulse</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the discount factors associated with the pulse coefficients at each time. If D.pulse is an array, its dimensions should be n x n x t, where n is the number of pulses and t is the length of the outcomes. If D.pulse is a matrix, its dimensions should be n x n and the same discount matrix will be used in all observations. If D.pulse is a vector, it should have size t and it is interpreted as the discount factor at each observed time (same discount for all variable). If D is a scalar, the same discount will be used for all pulse coefficients at all times.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_h.pulse">h.pulse</code></td>
<td>
<p>Matrix, vector or scalar: A drift to be add in the pulse effect after the temporal evolution (can be interpreted as the mean of the random noise at each time). If a matrix, its dimension should be n x t, where n is the number of pulses and t is the length of the series. If a scalar, the passed value will be used for all latent state at each time.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_h.pulse">H.pulse</code></td>
<td>
<p>Array, Matrix, vector or scalar: The values for the covariance matrix for the noise factor associated with pulse coefficients at each time. If H.pulse is an array, its dimensions should be n x n x t, where n is the number of pulses and t is the length of the outcomes. If H.pulse is a matrix, its dimensions should be n x n and its values will be used for each time. If H.pulse is a vector or scalar, a covariance matrix will be created as a diagonal matrix with the values of H.pulse in the diagonal.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_a1.pulse">a1.pulse</code></td>
<td>
<p>Vector or scalar: The prior mean for the coefficients associated with the pulses at time 1. If a1.pulse is a vector, its dimension should be equal to the number of pulses. If a1.pulse is a scalar, its value will be used for all coefficients.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_r1.pulse">R1.pulse</code></td>
<td>
<p>Matrix, vector or scalar: The prior covariance matrix for the coefficients associated with the pulses at time 1. If R1.pulse is a matrix, its dimensions should be n x n, where n is the number of pulses. If R1.pulse is a vector or scalar, a covariance matrix will be created as a diagonal matrix with the values of R1.pulse in the diagonal.</p>
</td></tr>
<tr><td><code id="TF_block_+3A_monitoring.pulse">monitoring.pulse</code></td>
<td>
<p>Vector: A vector of flags indicating which pulse coefficients should be monitored (if automated monitoring is used). Its size should be n, where n is the number of pulses. The default is that no pulse coefficient should be monitored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the ..., noise.var, noise.disc, D, H, a1, R1, a1, R1, a1.pulse, R1.pulse, D.pulse, h.pulse, H.pulse arguments, the user may set one or more of its values as a string.
By doing so, the user will leave the block partially undefined.
The user must then pass the undefined parameter values as named arguments to the <code><a href="#topic+fit_model">fit_model</a></code> function. Also, multiple values can be passed, allowing for a sensitivity analysis for the value of this parameter.
</p>
<p>For the details about the implementation see dos Santos et al. (2024).
</p>
<p>For the details about Auto regressive models in the context of DLM's, see West and Harrison (1997), chapter 9.
</p>
<p>For the details about the linearization of non-linear evolution equations in the context of DLM's, see West and Harrison (1997), chapter 13.
</p>
<p>For the details about dynamic regression models in the context of DLM's, see West and Harrison (1997), chapters 6 and 9.
</p>


<h3>Value</h3>

<p>A dlm_block object containing the following values:
</p>

<ul>
<li><p> FF Array: A 3D-array containing the regression matrix for each time. Its dimension should be n x k x t, where n is the number of latent states, k is the number of linear predictors in the model and t is the time series length.
</p>
</li>
<li><p> FF.labs Matrix: A n x k character matrix describing the type of value of each element of FF.
</p>
</li>
<li><p> G Matrix: A 3D-array containing the evolution matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> G.labs Matrix: A n x n character matrix describing the type of value of each element of G.
</p>
</li>
<li><p> D Array: A 3D-array containing the discount factor matrix for each time. Its dimension should be n x n x t, where n is the number of latent states and t is the time series length.
</p>
</li>
<li><p> H Array: A 3D-array containing the covariance matrix of the noise for each time. Its dimension should be the same as D.
</p>
</li>
<li><p> a1 Vector: The prior mean for the latent vector.
</p>
</li>
<li><p> R1 Matrix: The prior covariance matrix for the latent vector.
</p>
</li>
<li><p> var.names list: A list containing the variables indexes by their name.
</p>
</li>
<li><p> order Positive integer: Same as argument.
</p>
</li>
<li><p> n Positive integer: The number of latent states associated with this block (2).
</p>
</li>
<li><p> t Positive integer: The number of time steps associated with this block. If 1, the block is compatible with blocks of any time length, but if t is greater than 1, this block can only be used with blocks of the same time length.
</p>
</li>
<li><p> k Positive integer: The number of outcomes associated with this block. This block can only be used with blocks with the same outcome length.
</p>
</li>
<li><p> pred.names Vector: The name of the linear predictors associated with this block.
</p>
</li>
<li><p> monitoring Vector: The combination of monitoring, monitoring and monitoring.pulse.
</p>
</li>
<li><p> type Character: The type of block (AR).
</p>
</li>
<li><p> AR.support Character: Same as argument.
</p>
</li></ul>



<h3>References</h3>

<p>Mike West, Jeff Harrison (1997).
<em>Bayesian Forecasting and Dynamic Models (Springer Series in Statistics)</em>.
Springer-Verlag.
ISBN 0387947256.<br /><br /> Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>
<p>Other auxiliary functions for structural blocks: 
<code><a href="#topic+block_mult">block_mult</a>()</code>,
<code><a href="#topic+block_rename">block_rename</a>()</code>,
<code><a href="#topic+block_superpos">block_superpos</a>()</code>,
<code><a href="#topic+harmonic_block">harmonic_block</a>()</code>,
<code><a href="#topic+intervention">intervention</a>()</code>,
<code><a href="#topic+noise_block">noise_block</a>()</code>,
<code><a href="#topic+polynomial_block">polynomial_block</a>()</code>,
<code><a href="#topic+regression_block">regression_block</a>()</code>,
<code><a href="#topic+specify.dlm_block">specify.dlm_block</a>()</code>,
<code><a href="#topic+summary.dlm_block">summary.dlm_block</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### AR block ####
TF_block(mu = 1, order = 2, noise.disc = 0.9)

#### Transfer function ####
TF_block(mu = 1, pulse = beaver1$activ, order = 1, noise.disc = 0.9)

</code></pre>

<hr>
<h2 id='update_Gamma'>update_Gamma</h2><span id='topic+update_Gamma'></span>

<h3>Description</h3>

<p>Calculate posterior parameter for the Inverse-Gamma, assuming that the observed values came from a Gamma model from which the shape parameter (phi) is known and the mean (mu) have prior distribution Inverse-Gamma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_Gamma(conj.param, ft, Qt, y, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_Gamma_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the parameters of the Inverse-Gamma (alpha,beta).</p>
</td></tr>
<tr><td><code id="update_Gamma_+3A_ft">ft</code></td>
<td>
<p>numeric: A vector representing the means from the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_Gamma_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_Gamma_+3A_y">y</code></td>
<td>
<p>numeric: A vector containing the observations.</p>
</td></tr>
<tr><td><code id="update_Gamma_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. For this kernel, parms should containing the shape parameter (phi) for the observational gamma model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the posterior distribution.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Gamma outcome with known shape: 
<code><a href="#topic+convert_Gamma_Normal">convert_Gamma_Normal</a>()</code>,
<code><a href="#topic+convert_Normal_Gamma">convert_Normal_Gamma</a>()</code>,
<code><a href="#topic+gamma_pred">gamma_pred</a>()</code>
</p>

<hr>
<h2 id='update_multi_NG_correl'>update_multi_NG_correl</h2><span id='topic+update_multi_NG_correl'></span>

<h3>Description</h3>

<p>update_multi_NG_correl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_multi_NG_correl(conj.param, ft, Qt, y, parms)
</code></pre>


<h3>Value</h3>

<p>The parameters of the posterior distribution.
</p>

<hr>
<h2 id='update_Multinom'>update_Multinom</h2><span id='topic+update_Multinom'></span>

<h3>Description</h3>

<p>Calculate posterior parameter for the Dirichlet, assuming that the observed values came from a Multinomial model from which the number of trials is known and the prior distribution for the probabilities of each category have joint distribution Dirichlet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_Multinom(conj.param, ft, Qt, y, parms = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_Multinom_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the concentration parameters of the Dirichlet.</p>
</td></tr>
<tr><td><code id="update_Multinom_+3A_ft">ft</code></td>
<td>
<p>vector: A vector representing the means from the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_Multinom_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_Multinom_+3A_y">y</code></td>
<td>
<p>vector: A vector containing the observations.</p>
</td></tr>
<tr><td><code id="update_Multinom_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the posterior distribution.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Multinomial outcome: 
<code><a href="#topic+convert_Multinom_Normal">convert_Multinom_Normal</a>()</code>,
<code><a href="#topic+convert_Normal_Multinom">convert_Normal_Multinom</a>()</code>,
<code><a href="#topic+multnom_pred">multnom_pred</a>()</code>
</p>

<hr>
<h2 id='update_NG'>update_NG</h2><span id='topic+update_NG'></span>

<h3>Description</h3>

<p>Calculate posterior parameter for the Normal-Gamma, assuming that the observed values came from a Normal model from which the prior distribution for the mean and the precision have joint distribution Normal-Gamma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_NG(conj.param, ft, Qt, y, parms = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_NG_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the parameters of the Normal-Gamma (mu0,c0,alpha,beta).</p>
</td></tr>
<tr><td><code id="update_NG_+3A_ft">ft</code></td>
<td>
<p>numeric: A vector representing the means from the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_NG_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_NG_+3A_y">y</code></td>
<td>
<p>numeric: A vector containing the observations.</p>
</td></tr>
<tr><td><code id="update_NG_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the posterior distribution.
</p>

<hr>
<h2 id='update_NG2'>update_NG</h2><span id='topic+update_NG2'></span>

<h3>Description</h3>

<p>Calculate posterior parameter for the Normal-Gamma, assuming that the observed values came from a Normal model from which the prior distribution for the mean and the precision have joint distribution Normal-Gamma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_NG2(conj.param, ft, Qt, y, parms = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_NG2_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the parameters of the Normal-Gamma (mu0,c0,alpha,beta).</p>
</td></tr>
<tr><td><code id="update_NG2_+3A_ft">ft</code></td>
<td>
<p>numeric: A vector representing the means from the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_NG2_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_NG2_+3A_y">y</code></td>
<td>
<p>numeric: A vector containing the observations.</p>
</td></tr>
<tr><td><code id="update_NG2_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the posterior distribution.
</p>

<hr>
<h2 id='update_Normal'>update_Normal</h2><span id='topic+update_Normal'></span>

<h3>Description</h3>

<p>Calculate posterior parameter for the Normal, assuming that the observed values came from a Normal model from which the covariance is known and the prior distribution for the mean vector have Normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_Normal(conj.param, ft, Qt, y, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_Normal_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the concentration parameters of the Normal.</p>
</td></tr>
<tr><td><code id="update_Normal_+3A_ft">ft</code></td>
<td>
<p>numeric: A vector representing the means from the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_Normal_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_Normal_+3A_y">y</code></td>
<td>
<p>numeric: A vector containing the observations.</p>
</td></tr>
<tr><td><code id="update_Normal_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. For this kernel, parms should containing the covariance matrix parameter (V) for the observational Normal model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the posterior distribution.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Normal outcome: 
<code><a href="#topic+convert_multi_NG_Normal">convert_multi_NG_Normal</a>()</code>,
<code><a href="#topic+multi_normal_gamma_pred">multi_normal_gamma_pred</a>()</code>,
<code><a href="#topic+normal_pred">normal_pred</a>()</code>
</p>

<hr>
<h2 id='update_Poisson'>update_Poisson</h2><span id='topic+update_Poisson'></span>

<h3>Description</h3>

<p>Calculate posterior parameter for the Gamma, assuming that the observed values came from a Poisson model from which the rate parameter (lambda) have prior distribution Gamma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_Poisson(conj.param, ft, Qt, y, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_Poisson_+3A_conj.param">conj.param</code></td>
<td>
<p>list: A vector containing the parameters of the Gamma (alpha,beta).</p>
</td></tr>
<tr><td><code id="update_Poisson_+3A_ft">ft</code></td>
<td>
<p>numeric: A vector representing the means from the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_Poisson_+3A_qt">Qt</code></td>
<td>
<p>matrix: A matrix representing the covariance matrix of the normal distribution. Not used in the default method.</p>
</td></tr>
<tr><td><code id="update_Poisson_+3A_y">y</code></td>
<td>
<p>numeric: A vector containing the observations.</p>
</td></tr>
<tr><td><code id="update_Poisson_+3A_parms">parms</code></td>
<td>
<p>list: A list of extra known parameters of the distribution. Not used in this kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameters of the posterior distribution.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for a Poisson outcome: 
<code><a href="#topic+convert_Normal_Poisson">convert_Normal_Poisson</a>()</code>,
<code><a href="#topic+convert_Poisson_Normal">convert_Poisson_Normal</a>()</code>,
<code><a href="#topic+poisson_pred">poisson_pred</a>()</code>
</p>

<hr>
<h2 id='update.fitted_dlm'>update.fitted_dlm</h2><span id='topic+update.fitted_dlm'></span>

<h3>Description</h3>

<p>update.fitted_dlm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted_dlm'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.fitted_dlm_+3A_object">object</code></td>
<td>
<p>fitted_dlm: The fitted model to be updated.</p>
</td></tr>
<tr><td><code id="update.fitted_dlm_+3A_...">...</code></td>
<td>
<p>Extra variables necessary for updating (covariates, observed values, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an a covariate is necessary for updating, it should be passed as a named argument. Its name must follow this structure: &lt;block name&gt;.Covariate&lt;.index&gt;. If there is only one pulse in the associated block the index is omitted.
If an a pulse is necessary for updating, it should be passed as a named argument. Its name must follow this structure: &lt;block name&gt;.Pulse&lt;.index&gt;. If there is only one pulse in the associated block the index is omitted.
If an offset is necessary for updating, it should be passed along with the observed data. See example.
</p>


<h3>Value</h3>

<p>A fitted_dlm object.
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for fitted_dlm objects: 
<code><a href="#topic+coef.fitted_dlm">coef.fitted_dlm</a>()</code>,
<code><a href="#topic+eval_dlm_norm_const">eval_dlm_norm_const</a>()</code>,
<code><a href="#topic+fit_model">fit_model</a>()</code>,
<code><a href="#topic+forecast.fitted_dlm">forecast.fitted_dlm</a>()</code>,
<code><a href="#topic+simulate.fitted_dlm">simulate.fitted_dlm</a>()</code>,
<code><a href="#topic+smoothing">smoothing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
level &lt;- polynomial_block(rate = 1, order = 2, D = 0.95)
season &lt;- harmonic_block(rate = 1, order = 2, period = 12, D = 0.975)

# Only first 100 observations (for the sake of the example)
outcome &lt;- Poisson(lambda = "rate", data = c(AirPassengers)[1:100])

fitted.data &lt;- fit_model(level, season,
  AirPassengers = outcome
)

updated.fit &lt;- update(fitted.data, AirPassengers = list(data = c(AirPassengers)[101:144]))
# If a offset was present, the user should pass its value when updating
# updated.fit=update(fitted.data,
#                     AirPassengers=list(
#                      data=c(AirPassengers)[101:144],
#                      offset= ... ))

</code></pre>

<hr>
<h2 id='var_decomp'>var_decomp</h2><span id='topic+var_decomp'></span>

<h3>Description</h3>

<p>This function receives a covariance matrix S and creates a matrix Q, so that t(Q) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_decomp(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_decomp_+3A_s">S</code></td>
<td>
<p>A covariance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='zero_sum_prior'>Zero sum prior</h2><span id='topic+zero_sum_prior'></span>

<h3>Description</h3>

<p>Defines the prior of a structural block to be such that the latent states sum zero with probability one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_sum_prior(
  block,
  var.index = 1:block$n,
  weights = rep(1, length(var.index))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_sum_prior_+3A_block">block</code></td>
<td>
<p>dlm_block object: The structural block.</p>
</td></tr>
<tr><td><code id="zero_sum_prior_+3A_var.index">var.index</code></td>
<td>
<p>integer: The index of the variables from which to set the prior.</p>
</td></tr>
<tr><td><code id="zero_sum_prior_+3A_weights">weights</code></td>
<td>
<p>numeric: A vector indicating which linear transformation of the data is 0 with probability 1. Default is equivalent to a zero-sum restriction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance matrix of the evolution and the drift parameter are also altered to guarantee that the zero sum condition will always hold.
The discount factor must be the same for all variables whose prior is being modified.
For the details about the implementation see dos Santos et al. (2024).
</p>


<h3>Value</h3>

<p>A dlm_block object with the desired prior.
</p>


<h3>References</h3>

<p>Junior,
Silvaneo
Vieira dos Santos, Mariane
Branco Alves, Helio
S. Migon (2024).
&ldquo;kDGLM: an R package for Bayesian analysis of Dynamic Generialized Linear Models.&rdquo;
</p>


<h3>See Also</h3>

<p>Other auxiliary functions for defining priors.: 
<code><a href="#topic+CAR_prior">CAR_prior</a>()</code>,
<code><a href="#topic+joint_prior">joint_prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
polynomial_block(mu = 1, D = 0.95) |&gt;
  block_mult(5) |&gt;
  zero_sum_prior()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
