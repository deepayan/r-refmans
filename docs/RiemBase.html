<!DOCTYPE html><html><head><title>Help for package RiemBase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RiemBase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rbase.curvedist'><p>Distance between Two Curves with Finite Difference Approximation</p></a></li>
<li><a href='#rbase.mean'><p>Fréchet Mean of Manifold-valued Data</p></a></li>
<li><a href='#rbase.median'><p>Geometric Median of Manifold-valued Data</p></a></li>
<li><a href='#rbase.pdist'><p>Pairwise Geodesic Distances of a Data Set</p></a></li>
<li><a href='#rbase.pdist2'><p>Pairwise Geodesic Distances Between Two Sets of Data</p></a></li>
<li><a href='#rbase.robust'><p>Robust Fréchet Mean of Manifold-valued Data</p></a></li>
<li><a href='#RiemBase-package'><p>Functions and C++ Header Files for Computation on Manifolds</p></a></li>
<li><a href='#riemfactory'><p>Prepare a S3 Class Object 'riemdata'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions and C++ Header Files for Computation on Manifolds</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a number of algorithms to estimate fundamental statistics including Fréchet mean and geometric median for manifold-valued data. Also, C++ header files are contained that implement elementary operations on manifolds such as Sphere, Grassmann, and others. See Bhattacharya and Bhattacharya (2012) &lt;<a href="https://doi.org/10.1017%2FCBO9781139094764">doi:10.1017/CBO9781139094764</a>&gt; if you are interested in statistics on manifolds, and Absil et al (2007, ISBN:9780691132983) on computational aspects of optimization on matrix manifolds.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, utils, Rdpack, parallel, stats, pracma</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kisungyou/RiemBase">https://github.com/kisungyou/RiemBase</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kisungyou/RiemBase/issues">https://github.com/kisungyou/RiemBase/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-21 04:19:07 UTC; kisung</td>
</tr>
<tr>
<td>Author:</td>
<td>Kisung You <a href="https://orcid.org/0000-0002-8584-459X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kisung You &lt;kisungyou@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-21 15:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='rbase.curvedist'>Distance between Two Curves with Finite Difference Approximation</h2><span id='topic+rbase.curvedist'></span>

<h3>Description</h3>

<p>Suppose we have to two curves <code class="reqn">f,g:I\subset \mathbf{R} \rightarrow \mathcal{M}</code> evaluated at finite locations <code class="reqn">t_0 \le \ldots \le t_N</code>,
<code>rbase.curvedist</code> computes distance between two curves <code class="reqn">f</code> and <code class="reqn">g</code> using finite difference approximation with trapezoidal rule.
In order to induce no interpolation, two curves should be of same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbase.curvedist(curve1, curve2, t = NULL, type = c("intrinsic", "extrinsic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbase.curvedist_+3A_curve1">curve1</code></td>
<td>
<p>a S3 object of <code>riemdata</code> class, whose <code>$data</code> element is of length <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="rbase.curvedist_+3A_curve2">curve2</code></td>
<td>
<p>a S3 object of <code>riemdata</code> class, whose <code>$data</code> element is of length <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="rbase.curvedist_+3A_t">t</code></td>
<td>
<p>a length-<code class="reqn">N</code> vector of locations. If <code>NULL</code> is given, it uses a equidistanct sequence from 1 to <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="rbase.curvedist_+3A_type">type</code></td>
<td>
<p>type of Riemannian distance (<code>"intrinsic"</code> or <code>"extrnisic"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>computed distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Generate two sets of 10 2-frames in R^4 : as grassmann points
ndata = 10
data1 = array(0,c(4,2,ndata))
data2 = array(0,c(4,2,ndata))
for (i in 1:ndata){
  tgt = matrix(rnorm(4*4),nrow=4)
  data1[,,i] = qr.Q(qr(tgt))[,1:2]
}
for (i in 1:ndata){
  tgt = matrix(rnorm(4*5, sd=2),nrow=4)
  data2[,,i] = qr.Q(qr(tgt))[,1:2]
}

gdata1 = riemfactory(data1, name="grassmann") # wrap as 'riemdata' class.
gdata2 = riemfactory(data2, name="grassmann")

rbase.curvedist(gdata1, gdata2)

## End(Not run)

</code></pre>

<hr>
<h2 id='rbase.mean'>Fréchet Mean of Manifold-valued Data</h2><span id='topic+rbase.mean'></span>

<h3>Description</h3>

<p>For manifold-valued data, Fréchet mean is the solution of following cost function,
</p>
<p style="text-align: center;"><code class="reqn">\textrm{min}_x \sum_{i=1}^n \rho^2 (x, x_i),\quad x\in\mathcal{M}</code>
</p>

<p>for a given data <code class="reqn">\{x_i\}_{i=1}^n</code> and <code class="reqn">\rho(x,y)</code> is the geodesic distance 
between two points on manifold <code class="reqn">\mathcal{M}</code>. It uses a gradient descent method 
with a backtracking search rule for updating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbase.mean(input, maxiter = 496, eps = 1e-06, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbase.mean_+3A_input">input</code></td>
<td>
<p>a S3 object of <code>riemdata</code> class. See <code><a href="#topic+riemfactory">riemfactory</a></code> for more details.</p>
</td></tr>
<tr><td><code id="rbase.mean_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations for gradient descent algorithm.</p>
</td></tr>
<tr><td><code id="rbase.mean_+3A_eps">eps</code></td>
<td>
<p>stopping criterion for the norm of gradient.</p>
</td></tr>
<tr><td><code id="rbase.mean_+3A_parallel">parallel</code></td>
<td>
<p>a flag for enabling parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing
</p>

<dl>
<dt>x</dt><dd><p>an estimate Fréchet mean.</p>
</dd>
<dt>iteration</dt><dd><p>number of iterations until convergence.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kisung You
</p>


<h3>References</h3>

<p>Karcher H (1977).
&ldquo;Riemannian center of mass and mollifier smoothing.&rdquo;
<em>Communications on Pure and Applied Mathematics</em>, <b>30</b>(5), 509&ndash;541.
ISSN 00103640, 10970312.
</p>
<p>Kendall WS (1990).
&ldquo;Probability, Convexity, and Harmonic Maps with Small Image I: Uniqueness and Fine Existence.&rdquo;
<em>Proceedings of the London Mathematical Society</em>, <b>s3-61</b>(2), 371&ndash;406.
ISSN 00246115.
</p>
<p>Afsari B, Tron R, Vidal R (2013).
&ldquo;On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass.&rdquo;
<em>SIAM Journal on Control and Optimization</em>, <b>51</b>(3), 2230&ndash;2260.
ISSN 0363-0129, 1095-7138.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Generate 100 data points on Sphere S^2 near (0,0,1).
ndata = 100
theta = seq(from=-0.99,to=0.99,length.out=ndata)*pi
tmpx  = cos(theta) + rnorm(ndata,sd=0.1)
tmpy  = sin(theta) + rnorm(ndata,sd=0.1)

### Wrap it as 'riemdata' class
data  = list()
for (i in 1:ndata){
  tgt = c(tmpx[i],tmpy[i],1)
  data[[i]] = tgt/sqrt(sum(tgt^2)) # project onto Sphere
}
data = riemfactory(data, name="sphere")

### Compute Fréchet Mean
out1 = rbase.mean(data)
out2 = rbase.mean(data,parallel=TRUE) # test parallel implementation


</code></pre>

<hr>
<h2 id='rbase.median'>Geometric Median of Manifold-valued Data</h2><span id='topic+rbase.median'></span>

<h3>Description</h3>

<p>For manifold-valued data, geometric median is the solution of following cost function,
</p>
<p style="text-align: center;"><code class="reqn">\textrm{min}_x \sum_{i=1}^n \rho (x, x_i) = \sum_{i=1}^n \| \log_x (x_i) \|,\quad x\in\mathcal{M}</code>
</p>

<p>for a given data <code class="reqn">\{x_i\}_{i=1}^n</code>, <code class="reqn">\rho(x,y)</code> the geodesic distance 
between two points on manifold <code class="reqn">\mathcal{M}</code>, and <code class="reqn">\| \log_x (y) \|</code> a logarithmic mapping onto the 
tangent space <code class="reqn">T_x \mathcal{M}</code>. Weiszfeld's algorithms is employed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbase.median(input, maxiter = 496, eps = 1e-06, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbase.median_+3A_input">input</code></td>
<td>
<p>a S3 object of <code>riemdata</code> class. See <code><a href="#topic+riemfactory">riemfactory</a></code> for more details.</p>
</td></tr>
<tr><td><code id="rbase.median_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations for gradient descent algorithm.</p>
</td></tr>
<tr><td><code id="rbase.median_+3A_eps">eps</code></td>
<td>
<p>stopping criterion for the norm of gradient.</p>
</td></tr>
<tr><td><code id="rbase.median_+3A_parallel">parallel</code></td>
<td>
<p>a flag for enabling parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing
</p>

<dl>
<dt>x</dt><dd><p>an estimate geometric median.</p>
</dd>
<dt>iteration</dt><dd><p>number of iterations until convergence.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kisung You
</p>


<h3>References</h3>

<p>Fletcher PT, Venkatasubramanian S, Joshi S (2009).
&ldquo;The geometric median on Riemannian manifolds with application to robust atlas estimation.&rdquo;
<em>NeuroImage</em>, <b>45</b>(1), S143&ndash;S152.
ISSN 10538119.
</p>
<p>Aftab K, Hartley R, Trumpf J (2015).
&ldquo;Generalized Weiszfeld Algorithms for Lq Optimization.&rdquo;
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, <b>37</b>(4), 728&ndash;745.
ISSN 0162-8828, 2160-9292.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Generate 100 data points on Sphere S^2 near (0,0,1).
ndata = 100
theta = seq(from=-0.99,to=0.99,length.out=ndata)*pi
tmpx  = cos(theta) + rnorm(ndata,sd=0.1)
tmpy  = sin(theta) + rnorm(ndata,sd=0.1)

### Wrap it as 'riemdata' class
data  = list()
for (i in 1:ndata){
  tgt = c(tmpx[i],tmpy[i],1)
  data[[i]] = tgt/sqrt(sum(tgt^2)) # project onto Sphere
}
data = riemfactory(data, name="sphere")

### Compute Geodesic Median
out1 = rbase.median(data)
out2 = rbase.median(data,parallel=TRUE) # test parallel implementation



</code></pre>

<hr>
<h2 id='rbase.pdist'>Pairwise Geodesic Distances of a Data Set</h2><span id='topic+rbase.pdist'></span>

<h3>Description</h3>

<p>Geodesic distance <code class="reqn">\rho(x,y)</code> is the length of (locally) shortest path 
connecting two points <code class="reqn">x,y\in\mathcal{M}</code>. Some manifolds have closed-form expression, while 
others need numerical approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbase.pdist(input, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbase.pdist_+3A_input">input</code></td>
<td>
<p>a S3 object of <code>riemdata</code> class, whose <code>$data</code> element is of length <code class="reqn">n</code>. See <code><a href="#topic+riemfactory">riemfactory</a></code> for more details.</p>
</td></tr>
<tr><td><code id="rbase.pdist_+3A_parallel">parallel</code></td>
<td>
<p>a flag for enabling parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(n\times n)</code> matrix of pairwise distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Generate 10 2-frames in R^4
ndata = 10
data = array(0,c(4,2,ndata))
for (i in 1:ndata){
  tgt = matrix(rnorm(4*4),nrow=4)
  data[,,i] = qr.Q(qr(tgt))[,1:2]
}

## Compute Pairwise Distances as if for Grassmann and Stiefel Manifold
A = rbase.pdist(riemfactory(data,name="grassmann"))
B = rbase.pdist(riemfactory(data,name="stiefel"))

## Visual Comparison in Two Cases
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2))
image(A, col=gray((0:100)/100), main="Grassmann")
image(B, col=gray((0:100)/100), main="Stiefel")
par(opar)


</code></pre>

<hr>
<h2 id='rbase.pdist2'>Pairwise Geodesic Distances Between Two Sets of Data</h2><span id='topic+rbase.pdist2'></span>

<h3>Description</h3>

<p>Unlike <code><a href="#topic+rbase.pdist">rbase.pdist</a></code>, <code>rbase.pdist2</code> takes two sets of data <code class="reqn">X=\{ x_i \}_{i=1}^m</code> and <code class="reqn">Y=\{ y_j \}_{j=1}^m</code> 
and compute <code class="reqn">mn</code> number of pairwise distances for all <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbase.pdist2(input1, input2, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbase.pdist2_+3A_input1">input1</code></td>
<td>
<p>a S3 object of <code>riemdata</code> class, whose <code>$data</code> element is of length <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="rbase.pdist2_+3A_input2">input2</code></td>
<td>
<p>a S3 object of <code>riemdata</code> class, whose <code>$data</code> element is of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="rbase.pdist2_+3A_parallel">parallel</code></td>
<td>
<p>a flag for enabling parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(m\times n)</code> matrix of pairwise distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Generate 10 2-frames in R^4 : as grassmann points
ndata = 10
data = array(0,c(4,2,ndata))
for (i in 1:ndata){
  tgt = matrix(rnorm(4*4),nrow=4)
  data[,,i] = qr.Q(qr(tgt))[,1:2]
}

gdata = riemfactory(data, name="grassmann")

## Compute Pairwise Distances using pdist and pdist2
A = rbase.pdist(gdata)
B = rbase.pdist2(gdata,gdata)

## Visual Comparison in Two Cases
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(A, col=gray((0:100)/100), main="pdist")
image(B, col=gray((0:100)/100), main="pdist2")
par(opar)

</code></pre>

<hr>
<h2 id='rbase.robust'>Robust Fréchet Mean of Manifold-valued Data</h2><span id='topic+rbase.robust'></span>

<h3>Description</h3>

<p>Robust estimator for mean starts from dividing the data <code class="reqn">\{x_i\}_{i=1}^n</code> into <code class="reqn">k</code> equally sized 
sets. For each subset, it first estimates Fréchet mean. It then follows a step to aggregate 
<code class="reqn">k</code> sample means by finding a geometric median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbase.robust(input, k = 5, maxiter = 496, eps = 1e-06, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbase.robust_+3A_input">input</code></td>
<td>
<p>a S3 object of <code>riemdata</code> class. See <code><a href="#topic+riemfactory">riemfactory</a></code> for more details.</p>
</td></tr>
<tr><td><code id="rbase.robust_+3A_k">k</code></td>
<td>
<p>number of subsets for which the data be divided into.</p>
</td></tr>
<tr><td><code id="rbase.robust_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations for gradient descent algorithm and Weiszfeld algorithm.</p>
</td></tr>
<tr><td><code id="rbase.robust_+3A_eps">eps</code></td>
<td>
<p>stopping criterion for the norm of gradient.</p>
</td></tr>
<tr><td><code id="rbase.robust_+3A_parallel">parallel</code></td>
<td>
<p>a flag for enabling parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing
</p>

<dl>
<dt>x</dt><dd><p>an estimate geometric median.</p>
</dd>
<dt>iteration</dt><dd><p>number of iterations until convergence.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kisung You
</p>


<h3>References</h3>

<p>Lerasle M, Oliveira R~I (2011).
&ldquo;Robust empirical mean Estimators.&rdquo;
<em>ArXiv e-prints</em>.
1112.3914.
</p>
<p>Minsker S (2013).
&ldquo;Geometric median and robust estimation in Banach spaces.&rdquo;
<em>ArXiv e-prints</em>.
1308.1334.
</p>
<p>Feng J, Xu H, Mannor S (2014).
&ldquo;Distributed Robust Learning.&rdquo;
<em>ArXiv e-prints</em>.
1409.5937.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbase.mean">rbase.mean</a></code>, <code><a href="#topic+rbase.median">rbase.median</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Generate 100 data points on Sphere S^2 near (0,0,1).
ndata = 100
theta = seq(from=-0.99,to=0.99,length.out=ndata)*pi
tmpx  = cos(theta) + rnorm(ndata,sd=0.1)
tmpy  = sin(theta) + rnorm(ndata,sd=0.1)

### Wrap it as 'riemdata' class
data  = list()
for (i in 1:ndata){
  tgt = c(tmpx[i],tmpy[i],1)
  data[[i]] = tgt/sqrt(sum(tgt^2)) # project onto Sphere
}
data = riemfactory(data, name="sphere")

### Compute Robust Fréchet Mean
out1 = rbase.robust(data)
out2 = rbase.robust(data,parallel=TRUE) # test parallel implementation


</code></pre>

<hr>
<h2 id='RiemBase-package'>Functions and C++ Header Files for Computation on Manifolds</h2><span id='topic+RiemBase-package'></span>

<h3>Description</h3>

<p>We provide a number of algorithms to estimate fundamental statistics including 
Fréchet mean and geometric median for manifold-valued data. Also, C++ header files are contained that implement elementary operations 
on manifolds such as Sphere, Grassmann, and others. See Bhattacharya and Bhattacharya (2012) &lt;doi:10.1017/CBO9781139094764&gt; 
if you are interested in statistics on manifolds, and Absil et al (2007) &lt;isbn:978-0-691-13298-3&gt; on computational 
aspects of optimization on matrix manifolds.
</p>

<hr>
<h2 id='riemfactory'>Prepare a S3 Class Object 'riemdata'</h2><span id='topic+riemfactory'></span>

<h3>Description</h3>

<p>Most of the functions for <code>RiemBase</code> package require data to be wrapped as a <code>riemdata</code> class. 
Since manifolds of interests endow data points with specific constraints, the function <code>riemfactory</code>
first checks the requirements to characterize the manifold and then wraps the data into 
<code>riemdata</code> class, which is simply a list of manifold-valued data and the name of manifold. 
Manifold name input is, fortunately, <em>case-insensitive</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riemfactory(
  data,
  name = c("euclidean", "grassmann", "spd", "sphere", "stiefel")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riemfactory_+3A_data">data</code></td>
<td>
<p>data to be wrapped as <code>riemdata</code> class. Following input formats are considered,
</p>

<dl>
<dt>2D array</dt><dd><p>an <code class="reqn">(m\times p)</code> matrix where data are stacked in columns over 2nd dimension. Appropriate for vector-valued <code>Euclidean</code> or <code>Sphere</code> manifold case.</p>
</dd>
<dt>3D array</dt><dd><p>an <code class="reqn">(m\times n\times p)</code> matrix where data are stacked in slices over 3rd dimension.</p>
</dd>
<dt>list</dt><dd><p>unnamed list where each element of the list is a single data point. Sizes of all elements must match.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="riemfactory_+3A_name">name</code></td>
<td>
<p>the name of Riemmanian manifold for data to which data belong.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named <code>riemdata</code> S3 object containing
</p>

<dl>
<dt>data</dt><dd><p>a list of manifold-valued data points.</p>
</dd>
<dt>size</dt><dd><p>size of each data matrix.</p>
</dd>
<dt>name</dt><dd><p>name of the manifold of interests.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# Test with Sphere S^2 in R^3 example
## Prepare a matrix and list of 20 samples on S^2
sp.mat  = array(0,c(3,20)) # each vector will be recorded as a column
sp.list = list()
for (i in 1:20){
  tgt = rnorm(3)               # sample random numbers
  tgt = tgt/sqrt(sum(tgt*tgt)) # normalize
  
  sp.mat[,i]   = tgt   # record it as column vector
  sp.list[[i]] = tgt   # record it as an element in a list
}

## wrap it using 'riemfactory'
rsp1 = riemfactory(sp.mat, name="Sphere")
rsp2 = riemfactory(sp.list, name="spHeRe")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
