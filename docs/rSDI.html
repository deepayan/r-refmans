<!DOCTYPE html><html lang="en"><head><title>Help for package rSDI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rSDI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rSDI-package'><p>rSDI: Spatial Dispersion Index (SDI) Family of Metrics for Spatial/Geographic Networks</p></a></li>
<li><a href='#dist_calc'><p>Distance Calculation for Graph Nodes</p></a></li>
<li><a href='#euclidean'><p>Calculate Euclidean Distance Between Two Points</p></a></li>
<li><a href='#haversine'><p>Calculate Haversine Distance Between Two Points on Earth</p></a></li>
<li><a href='#plotSDI'><p>plotSDI generates a plot of the network and SDI metrics on a geographic map.</p></a></li>
<li><a href='#SDI'><p>Computes graph or vertex level Spatial Dispersion Index(ces).</p></a></li>
<li><a href='#SDIcomputer'><p>SDIcomputer() is a helper function to compute given SDI variant for the given graph object.</p>
Not intended for explicit use. Called automatically by the 'SDI()' function.</a></li>
<li><a href='#TurkiyeMigration.flows'><p>Türkiye migration network flows data</p></a></li>
<li><a href='#TurkiyeMigration.nodes'><p>Türkiye migration network provinces/nodes data</p></a></li>
<li><a href='#unweightedAllVerticesSDI'><p>Not for explicit use.</p></a></li>
<li><a href='#unweightedNetworkSDI'><p>Not for explicit use.</p></a></li>
<li><a href='#unweightedSingleVertexSDI'><p>Not for explicit use.</p></a></li>
<li><a href='#variantParser'><p>variantParser for SDI variant short-codes.</p>
This is a helper function and not intended for explicit use.</a></li>
<li><a href='#weightedAllVerticesSDI'><p>Not for explicit use.</p></a></li>
<li><a href='#weightedNetworkSDI'><p>Not for explicit use.</p></a></li>
<li><a href='#weightedSingleVertexSDI'><p>Not for explicit use.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Dispersion Index (SDI) Family of Metrics for
Spatial/Geographic Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ehengirmen/rSDI">https://github.com/ehengirmen/rSDI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ehengirmen/rSDI/issues">https://github.com/ehengirmen/rSDI/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mehmet Gençer &lt;mehmetgencer@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial Dispersion Index (SDI) is a generalized measurement index, or rather a family of indices to evaluate spatial dispersion of movements/flows in a network in a problem neutral way as described in: Gencer (2023) &lt;<a href="https://doi.org/10.1007%2Fs12061-023-09545-8">doi:10.1007/s12061-023-09545-8</a>&gt;. This package computes and optionally visualizes this index with minimal hassle.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>maps, ggplot2, ggraph, ggimage, knitr, rmarkdown, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-29 05:38:18 UTC; mgencer</td>
</tr>
<tr>
<td>Author:</td>
<td>Mehmet Gençer <a href="https://orcid.org/0000-0003-1717-8668"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Mücahit Zor [aut],
  Engin Hengirmen [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-30 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rSDI-package'>rSDI: Spatial Dispersion Index (SDI) Family of Metrics for Spatial/Geographic Networks</h2><span id='topic+rSDI'></span><span id='topic+rSDI-package'></span>

<h3>Description</h3>

<p>Spatial Dispersion Index (SDI) is a generalized measurement index, or rather a family of indices to evaluate spatial dispersion of movements/flows in a network in a problem neutral way as described in: Gencer (2023) <a href="https://doi.org/10.1007/s12061-023-09545-8">doi:10.1007/s12061-023-09545-8</a>. This package computes and optionally visualizes this index with minimal hassle.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mehmet Gençer <a href="mailto:mehmetgencer@yahoo.com">mehmetgencer@yahoo.com</a> (<a href="https://orcid.org/0000-0003-1717-8668">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Mücahit Zor <a href="mailto:mucahit.zor01@gmail.com">mucahit.zor01@gmail.com</a>
</p>
</li>
<li><p> Engin Hengirmen <a href="mailto:ehengirmen@gmail.com">ehengirmen@gmail.com</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ehengirmen/rSDI">https://github.com/ehengirmen/rSDI</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ehengirmen/rSDI/issues">https://github.com/ehengirmen/rSDI/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dist_calc'>Distance Calculation for Graph Nodes</h2><span id='topic+dist_calc'></span>

<h3>Description</h3>

<p>This function calculates distances between each pair of nodes in the graph.
It supports both Haversine and Euclidean formula. The function automatically selects the formula based on the availabe vertex attributes: 'x' and 'y' for Euclidean distances, 'latitude' and 'longitude' for Haversine distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_calc(g, formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_calc_+3A_g">g</code></td>
<td>
<p>An igraph object, with nodes that have a combination of 'latitude' and 'longitude', or 'x' and 'y' vertices attributes.</p>
</td></tr>
<tr><td><code id="dist_calc_+3A_formula">formula</code></td>
<td>
<p>Optional parameter to specify the distance calculation formula to use, either 'Haversine' or 'Euclidean'. By default 'formula = NULL' and if not specified the otherwise, the function automatically determines the formula based on the available vertex attributes. [x, y] =&gt; Euclidean, [latitude,longitude] =&gt; Haversine. Note that the 'g' must have one of this set of vertex attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object with an additional edge attribute 'distance' that contains the calculated distances between each pair of nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assuming 'g' is a graph object with latitude and longitude or x and y attributes for each node.
# an overall example
flows&lt;-data.frame(from=c("A","B","A"), to=c("B","A","C"), weight=c(10,20,5))

# user provides x and y vertices
nodes&lt;-data.frame(id=c("A","B","C","D"),x=c(0,4,0,4),y=c(3,0,0,3))

g&lt;-igraph::graph_from_data_frame(flows, directed=TRUE, vertices=nodes)


dist_calc(g) # eucl. dist. calculated
dist_calc(g, formula = 'Euclidean') # calculates euc when asked
#dist_calc(g, formula = 'Haversine') # error

# user provides latitude and longitude vertices instead of x&amp;y
nodes&lt;-data.frame(id=c("A","B","C","D"),latitude=c(0,4,0,4),longitude=c(3,0,0,3))

g&lt;-igraph::graph_from_data_frame(flows, directed=TRUE, vertices=nodes)

dist_calc(g) # haversine dist calculated
dist_calc(g, formula = 'Haversine') # calculated hav when asked specificallly
#dist_calc(g, formula = 'Euclidean') # error

</code></pre>

<hr>
<h2 id='euclidean'>Calculate Euclidean Distance Between Two Points</h2><span id='topic+euclidean'></span>

<h3>Description</h3>

<p>This function calculates the Euclidean distance between two points. The Euclidean is the 'straight line' distance
between two points in a two-dimensional space. This function takes the coordinates of two points (longitude and latitude)
and calculates the straight distance between them, assuming flat Earth approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean(x1, y1, x2, y2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euclidean_+3A_x1">x1</code></td>
<td>
<p>X-coordinate of the first point.</p>
</td></tr>
<tr><td><code id="euclidean_+3A_y1">y1</code></td>
<td>
<p>Y-coordinate of the first point.</p>
</td></tr>
<tr><td><code id="euclidean_+3A_x2">x2</code></td>
<td>
<p>X-coordinate of the second point.</p>
</td></tr>
<tr><td><code id="euclidean_+3A_y2">y2</code></td>
<td>
<p>Y-coordinate of the second point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Euclidean distance between the two points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euclidean(1, 2, 4, 6)
# Euclidean distance between points (1, 2) and (4, 6).

</code></pre>

<hr>
<h2 id='haversine'>Calculate Haversine Distance Between Two Points on Earth</h2><span id='topic+haversine'></span>

<h3>Description</h3>

<p>This function calculates the great-circle distance between two points on the Earth's surface,
given their longitude and latitude in decimal degrees.
It uses the Haversine formula, which accounts for the Earth's curvature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haversine(lon1, lat1, lon2, lat2, R = 6371)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haversine_+3A_lon1">lon1</code></td>
<td>
<p>Longitude of the first point in decimal degrees.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lat1">lat1</code></td>
<td>
<p>Latitude of the first point in decimal degrees.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lon2">lon2</code></td>
<td>
<p>Longitude of the second point in decimal degrees.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lat2">lat2</code></td>
<td>
<p>Latitude of the second point in decimal degrees.</p>
</td></tr>
<tr><td><code id="haversine_+3A_r">R</code></td>
<td>
<p>The radius of the Earth in kilometers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between the two points in kilometers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>haversine(-73.9851, 40.7580, -0.1278, 51.5074)
# Distance between NY City and London.

</code></pre>

<hr>
<h2 id='plotSDI'>plotSDI generates a plot of the network and SDI metrics on a geographic map.</h2><span id='topic+plotSDI'></span>

<h3>Description</h3>

<p>plotSDI generates a plot of the network and SDI metrics on a geographic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSDI(
  g,
  variant = "",
  circle.size.scale = 1,
  circle.color = "red",
  edges = FALSE,
  edge.width.range = c(0.01, 0.5)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSDI_+3A_g">g</code></td>
<td>
<p>The igraph object to be plotted, whose vertices have attributes corresponding to SDI metrices.</p>
</td></tr>
<tr><td><code id="plotSDI_+3A_variant">variant</code></td>
<td>
<p>The SDI variant with a prefix, such as &quot;SDI_vuw&quot;, etc.</p>
</td></tr>
<tr><td><code id="plotSDI_+3A_circle.size.scale">circle.size.scale</code></td>
<td>
<p>Increase of decrease the size of circles drawn on nodes to represent SDI metric</p>
</td></tr>
<tr><td><code id="plotSDI_+3A_circle.color">circle.color</code></td>
<td>
<p>Change color of circles</p>
</td></tr>
<tr><td><code id="plotSDI_+3A_edges">edges</code></td>
<td>
<p>Whether to draw edges or not</p>
</td></tr>
<tr><td><code id="plotSDI_+3A_edge.width.range">edge.width.range</code></td>
<td>
<p>If edges are to be drawn give a custom range of edge widths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a ggplot2 plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TMSDI &lt;- SDI(TurkiyeMigration.flows, TurkiyeMigration.nodes, variant="vuw")
plotSDI(TMSDI, variant="vuw", circle.size.scale=1)

</code></pre>

<hr>
<h2 id='SDI'>Computes graph or vertex level Spatial Dispersion Index(ces).</h2><span id='topic+SDI'></span>

<h3>Description</h3>

<p>If 'flows' is an igraph object then one can avoid supplying the nodes parameter.
Alternatively one can supply flows as a data frame and nodes as another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDI(
  flows,
  nodes = NULL,
  distance.calculation = NULL,
  level = "vertex",
  weight.use = "weighted",
  directionality = "undirected",
  variant = NULL,
  alpha = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SDI_+3A_flows">flows</code></td>
<td>
<p>A data frame or an igraph object</p>
</td></tr>
<tr><td><code id="SDI_+3A_nodes">nodes</code></td>
<td>
<p>if flows are data frame, nodes must be supplied as a data frame. If flows are igraph object then not required</p>
</td></tr>
<tr><td><code id="SDI_+3A_distance.calculation">distance.calculation</code></td>
<td>
<p>optional method for distance calculation. 'Haversine' or 'Euclidean'. If not provided and edge distances are not available, distances are calculated by the SDI function.</p>
</td></tr>
<tr><td><code id="SDI_+3A_level">level</code></td>
<td>
<p>The level to calculate the SDI. 'network' or 'vertex'</p>
</td></tr>
<tr><td><code id="SDI_+3A_weight.use">weight.use</code></td>
<td>
<p>'weighted', 'unweighted', or 'generalized'</p>
</td></tr>
<tr><td><code id="SDI_+3A_directionality">directionality</code></td>
<td>
<p>'undirected', 'in', 'out', or 'all'</p>
</td></tr>
<tr><td><code id="SDI_+3A_variant">variant</code></td>
<td>
<p>Optional. Instead of specifying the level, directionality, and weight separately, the user can just supply a short-code of initial letters of each in that order to this argument, e.g. &quot;vuw&quot; for vertex level, undirected and weighted SDI. If it is a vector each value is treated separetely and multiple indices are computed.</p>
</td></tr>
<tr><td><code id="SDI_+3A_alpha">alpha</code></td>
<td>
<p>Optional parameter used for generalized SDI calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To have an SDI computed you can must provide level, weight.use, and directionality parameters.
Alternatively the 'variant' parameter can be specified which allows short-codes to indicate all of these three parameters.
For example a value of &quot;vui&quot; for variant means a **v**ertex level, **u**ndirected, and **i**nward directed SDI calculation.
See the description of these three parameters to figure out possible short codes in a similar fashion.
</p>
<p>The function returns an igraph object. If a network level calculation is requested the object will have an
'SDI_...' attribute whose name follows the short codes explained above. If a vertex level calculation is requested
each vertex will have a similarly named attribute. For example the graph will have an 'SDI_nuw' attribute if variant is
&quot;nuw&quot; (network level, undirected, and weighted). If variant is &quot;vwu&quot; each vertex will have an &quot;SDI_vwu&quot; attribute containing
weighted undirected SDI for the vertex. If variant is a vector each value indicates a separate variant to be computed.
</p>


<h3>Value</h3>

<p>An igraph object with SDI attributes added. The class of the object includes 'SDI'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SDI(TurkiyeMigration.flows, TurkiyeMigration.nodes, variant="vuw")

</code></pre>

<hr>
<h2 id='SDIcomputer'>SDIcomputer() is a helper function to compute given SDI variant for the given graph object.
Not intended for explicit use. Called automatically by the 'SDI()' function.</h2><span id='topic+SDIcomputer'></span>

<h3>Description</h3>

<p>SDIcomputer() is a helper function to compute given SDI variant for the given graph object.
Not intended for explicit use. Called automatically by the 'SDI()' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDIcomputer(g, level, weight.use, directionality, return.value = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SDIcomputer_+3A_g">g</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="SDIcomputer_+3A_level">level</code></td>
<td>
<p>The level to calculate the SDI. 'network' or 'vertex'.</p>
</td></tr>
<tr><td><code id="SDIcomputer_+3A_weight.use">weight.use</code></td>
<td>
<p>'weighted' or 'unweighted'.</p>
</td></tr>
<tr><td><code id="SDIcomputer_+3A_directionality">directionality</code></td>
<td>
<p>'undirected', 'in', 'out', or 'all'.</p>
</td></tr>
<tr><td><code id="SDIcomputer_+3A_return.value">return.value</code></td>
<td>
<p>Logical. If TRUE, return the computed SDI value instead of modifying the graph object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return.value is TRUE, returns the computed SDI value. Otherwise, returns the modified graph object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TMgraph &lt;- igraph::graph_from_data_frame(TurkiyeMigration.flows,
      directed=TRUE, TurkiyeMigration.nodes)
SDIcomputer(TMgraph,"vertex","weighted","in")
</code></pre>

<hr>
<h2 id='TurkiyeMigration.flows'>Türkiye migration network flows data</h2><span id='topic+TurkiyeMigration.flows'></span>

<h3>Description</h3>

<p>This data frame contains the data on migration of people between Türkiye's provinces
in the period 2016-2017-2018.
This is a consolidated version of raw data from Turkish Statistical Institute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TurkiyeMigration.flows
</code></pre>


<h3>Format</h3>

<p>## 'TurkiyeMigration.flows'
A data frame with 6480 rows and 3 columns:
</p>

<dl>
<dt>from, to</dt><dd><p>codes of origin and arrival province</p>
</dd>
<dt>weight</dt><dd><p>number of people migrated</p>
</dd>
</dl>



<h3>Details</h3>

<p>Each row contains the number of people migrated in the &quot;weight&quot; column. 'from' and 'to'
columns include the codes of provinces as used in the Türkiye statistical coding system.
</p>
<p>The familiar names of provinces and their locations are to be found in a separate data frame
named TurkiyeMigration.nodes
</p>


<h3>Source</h3>

<p>&lt;https://data.tuik.gov.tr/Kategori/GetKategori?p=Nufus-ve-Demografi-109&gt;
</p>

<hr>
<h2 id='TurkiyeMigration.nodes'>Türkiye migration network provinces/nodes data</h2><span id='topic+TurkiyeMigration.nodes'></span>

<h3>Description</h3>

<p>This data frame contains the data on Türkiye's provinces as used in the migration flows
data frame (TurkiyeMigration.flow)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TurkiyeMigration.nodes
</code></pre>


<h3>Format</h3>

<p>## 'TurkiyeMigration.nodes'
A data frame with 6480 rows and 3 columns:
</p>

<dl>
<dt>id</dt><dd><p>codes of province as used in the TurkiyeMigration.flows data frame</p>
</dd>
<dt>label</dt><dd><p>Name of the province capital city</p>
</dd>
<dt>longitude, latitude</dt><dd><p>spatial coordinates of the province capital</p>
</dd>
</dl>



<h3>Details</h3>

<p>Each row contains the code of the province as used in TurkiyeMigration.flows data frame,
it is known name/label, and latitude/longitude of the province central.
</p>


<h3>Source</h3>

<p>The latitude/longitude of Turkish province capitals was shared as a courtesy of Başarsoft LLC
</p>

<hr>
<h2 id='unweightedAllVerticesSDI'>Not for explicit use.</h2><span id='topic+unweightedAllVerticesSDI'></span>

<h3>Description</h3>

<p>Not for explicit use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unweightedAllVerticesSDI(g, mode = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unweightedAllVerticesSDI_+3A_g">g</code></td>
<td>
<p>the graph</p>
</td></tr>
<tr><td><code id="unweightedAllVerticesSDI_+3A_mode">mode</code></td>
<td>
<p>directionality 'undirected', 'in', 'out', or 'all'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of vertex SDI values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flows&lt;-data.frame(from=c("A","B","A"), to=c("B","A","C"), weight=c(10,20,5))
nodes&lt;-data.frame(id=c("A","B","C","D"),x=c(0,4,0,4),y=c(3,0,0,3))
toyGraph &lt;- igraph::graph_from_data_frame(flows, directed=TRUE, vertices=nodes)
toyGraphWithSDI &lt;- unweightedAllVerticesSDI(toyGraph)
</code></pre>

<hr>
<h2 id='unweightedNetworkSDI'>Not for explicit use.</h2><span id='topic+unweightedNetworkSDI'></span>

<h3>Description</h3>

<p>Not for explicit use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unweightedNetworkSDI(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unweightedNetworkSDI_+3A_g">g</code></td>
<td>
<p>the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical SDI value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flows&lt;-data.frame(from=c("A","B","A"), to=c("B","A","C"), weight=c(10,20,5))
nodes&lt;-data.frame(id=c("A","B","C","D"),x=c(0,4,0,4),y=c(3,0,0,3))
toyGraph &lt;- igraph::graph_from_data_frame(flows, directed=TRUE, vertices=nodes)
toyGraphWithSDI &lt;- unweightedNetworkSDI(toyGraph)
</code></pre>

<hr>
<h2 id='unweightedSingleVertexSDI'>Not for explicit use.</h2><span id='topic+unweightedSingleVertexSDI'></span>

<h3>Description</h3>

<p>Not for explicit use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unweightedSingleVertexSDI(g, v, mode = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unweightedSingleVertexSDI_+3A_g">g</code></td>
<td>
<p>the graph</p>
</td></tr>
<tr><td><code id="unweightedSingleVertexSDI_+3A_v">v</code></td>
<td>
<p>the vertex</p>
</td></tr>
<tr><td><code id="unweightedSingleVertexSDI_+3A_mode">mode</code></td>
<td>
<p>directionality 'undirected', 'in', 'out', or 'all'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical SDI value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flows&lt;-data.frame(from=c("A","B","A"), to=c("B","A","C"), weight=c(10,20,5))
nodes&lt;-data.frame(id=c("A","B","C","D"),x=c(0,4,0,4),y=c(3,0,0,3))
toyGraph &lt;- igraph::graph_from_data_frame(flows, directed=TRUE, vertices=nodes)
toyGraph &lt;- dist_calc(toyGraph)
toyGraphWithSDI &lt;- unweightedSingleVertexSDI(toyGraph,igraph::V(toyGraph)[1])
</code></pre>

<hr>
<h2 id='variantParser'>variantParser for SDI variant short-codes.
This is a helper function and not intended for explicit use.</h2><span id='topic+variantParser'></span>

<h3>Description</h3>

<p>variantParser for SDI variant short-codes.
This is a helper function and not intended for explicit use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variantParser(variant)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variantParser_+3A_variant">variant</code></td>
<td>
<p>a three letter short code for level, weight, and direction of SDI calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of explicit level, weight.use and directionality parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>variantParser("vuw")
</code></pre>

<hr>
<h2 id='weightedAllVerticesSDI'>Not for explicit use.</h2><span id='topic+weightedAllVerticesSDI'></span>

<h3>Description</h3>

<p>Not for explicit use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedAllVerticesSDI(g, mode = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedAllVerticesSDI_+3A_g">g</code></td>
<td>
<p>the graph</p>
</td></tr>
<tr><td><code id="weightedAllVerticesSDI_+3A_mode">mode</code></td>
<td>
<p>directionality 'undirected', 'in', 'out', or 'all'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of vertex SDI values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flows&lt;-data.frame(from=c("A","B","A"), to=c("B","A","C"), weight=c(10,20,5))
nodes&lt;-data.frame(id=c("A","B","C","D"),x=c(0,4,0,4),y=c(3,0,0,3))
toyGraph &lt;- igraph::graph_from_data_frame(flows, directed=TRUE, vertices=nodes)
toyGraphWithSDI &lt;- weightedAllVerticesSDI(toyGraph)
</code></pre>

<hr>
<h2 id='weightedNetworkSDI'>Not for explicit use.</h2><span id='topic+weightedNetworkSDI'></span>

<h3>Description</h3>

<p>Not for explicit use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedNetworkSDI(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedNetworkSDI_+3A_g">g</code></td>
<td>
<p>the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical SDI value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flows&lt;-data.frame(from=c("A","B","A"), to=c("B","A","C"), weight=c(10,20,5))
nodes&lt;-data.frame(id=c("A","B","C","D"),x=c(0,4,0,4),y=c(3,0,0,3))
toyGraph &lt;- igraph::graph_from_data_frame(flows, directed=TRUE, vertices=nodes)
toyGraphWithSDI &lt;- weightedNetworkSDI(toyGraph)
</code></pre>

<hr>
<h2 id='weightedSingleVertexSDI'>Not for explicit use.</h2><span id='topic+weightedSingleVertexSDI'></span>

<h3>Description</h3>

<p>Not for explicit use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedSingleVertexSDI(g, v, mode = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightedSingleVertexSDI_+3A_g">g</code></td>
<td>
<p>the graph</p>
</td></tr>
<tr><td><code id="weightedSingleVertexSDI_+3A_v">v</code></td>
<td>
<p>the vertex</p>
</td></tr>
<tr><td><code id="weightedSingleVertexSDI_+3A_mode">mode</code></td>
<td>
<p>directionality 'undirected', 'in', 'out', or 'all'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical SDI value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flows&lt;-data.frame(from=c("A","B","A"), to=c("B","A","C"), weight=c(10,20,5))
nodes&lt;-data.frame(id=c("A","B","C","D"),x=c(0,4,0,4),y=c(3,0,0,3))
toyGraph &lt;- igraph::graph_from_data_frame(flows, directed=TRUE, vertices=nodes)
toyGraphWithSDI &lt;- weightedSingleVertexSDI(toyGraph,igraph::V(toyGraph)[1])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
