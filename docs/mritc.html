<!DOCTYPE html><html><head><title>Help for package mritc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mritc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#emnormmix'><p>Estimate the Parameters of a Normal Mixture Model Using the EM Algorithm</p></a></li>
<li><a href='#initNormMix'><p>Get the Initial Estimate of the Parameters of a Normal Mixture Model</p></a></li>
<li><a href='#makeMRIspatial'><p>Obtain Spatial Features of a Mask of an MR Image</p></a></li>
<li><a href='#measureMRI'><p>Compare the Predicted Classsification Results with the Truth</p></a></li>
<li><a href='#mritc'><p>MRI Tissue Classification Using Various Methods</p></a></li>
<li><a href='#mritc-package'><p>MRI Tissue Classification Package</p></a></li>
<li><a href='#plot.mritc'><p>Plot Method for Class &quot;mritc&quot;</p></a></li>
<li><a href='#print.mritc'><p>Print Method for Class &quot;mritc&quot;</p></a></li>
<li><a href='#readMRI'><p>Read an MR Image into an Array</p></a></li>
<li><a href='#rnormmix'><p>Generate Random Samples from a Normal Mixture Model</p></a></li>
<li><a href='#summary.mritc'><p>Summary Method for Class &quot;mritc&quot;</p></a></li>
<li><a href='#writeMRI'><p>Write an MR Image</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>MRI Tissue Classification</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-26</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various methods for tissue classification in magnetic
        resonance (MR) images of the brain, including normal mixture models
        and hidden Markov normal mixture models, as outlined in Feng &amp;
        Tierney (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v044.i07">doi:10.18637/jss.v044.i07</a>&gt;. These methods allow a
        structural MR image to be classified into gray matter, white matter
        and cerebrospinal fluid tissue types.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), lattice (&ge; 0.18-8), misc3d (&ge; 0.8-1),
oro.nifti (&ge; 0.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tkrplot (&ge; 0.0-23)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jonclayden/mritc">https://github.com/jonclayden/mritc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jonclayden/mritc/issues">https://github.com/jonclayden/mritc/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-27 12:28:18 UTC; jon</td>
</tr>
<tr>
<td>Author:</td>
<td>Dai Feng [aut],
  Luke Tierney [aut],
  Jon Clayden <a href="https://orcid.org/0000-0002-6608-0619"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Clayden &lt;code@clayden.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-27 14:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='emnormmix'>Estimate the Parameters of a Normal Mixture Model Using the EM Algorithm </h2><span id='topic+emnormmix'></span>

<h3>Description</h3>

<p>Use the EM Algorithm to estimate the parameters of a normal mixture model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   emnormmix(y, prop, mu, sigma, err, maxit, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emnormmix_+3A_y">y</code></td>
<td>
<p>vector of observations.</p>
</td></tr>
<tr><td><code id="emnormmix_+3A_prop">prop</code></td>
<td>
<p>vector of initial estimate of the proportions of
different components of a normal mixture model.
</p>
</td></tr>
<tr><td><code id="emnormmix_+3A_mu">mu</code></td>
<td>
<p>vector of initial estimate of the means of different
components of a normal mixture model.
</p>
</td></tr>
<tr><td><code id="emnormmix_+3A_sigma">sigma</code></td>
<td>
<p>vector of initial estimate of the standard deviations of
different components of a normal mixture model.</p>
</td></tr>
<tr><td><code id="emnormmix_+3A_err">err</code></td>
<td>
<p>relative maximum error(s) used to decide when to stop the
iteration. It could be a vector of length three corresponding to
the relative maximum errors of the means, standard deviations, and
proportions of all components of a normal mixture model. When it is
a scalar, all have the same relative maximum error.</p>
</td></tr>
<tr><td><code id="emnormmix_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="emnormmix_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, then indicate
the level of output as the algorithm runs after every 10 iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is tailor-made for the case when observations are from
a finite set (MRI data for example). The table lookup method is used to speed up the
computation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>prop</code></td>
<td>
<p>a vector of estimated proportions of different components of a
normal mixture model.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a vector of estimated means of different components of a
normal mixture model.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector of estimated standard deviations of different components of a
normal mixture model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  prop &lt;- c(0.3, 0.3, 0.4)
  mu &lt;- c(-10, 0, 10)
  sigma &lt;- rep(1, 3)
  y&lt;- floor(rnormmix(n=100000, prop, mu, sigma)[,1])
  initial &lt;- initOtsu(y, 2)
  emnormmix(y=y, prop=initial$prop, mu=initial$mu, sigma=initial$sigma,
            err=1e-7, maxit=100, verbose=TRUE)
</code></pre>

<hr>
<h2 id='initNormMix'>Get the Initial Estimate of the Parameters of a Normal Mixture Model</h2><span id='topic+initOtsu'></span><span id='topic+initProp'></span>

<h3>Description</h3>

<p>Obtain initial estimation of proportions, means, and
standard deviations of different components (tissue types for MRI)
based on threshold values generated by Otsu's method implemented by
a fast algorithm, or proportion of different components.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   initOtsu(y, m)
   initProp(y, prop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initNormMix_+3A_y">y</code></td>
<td>
<p>a vector of intensity values of an image.</p>
</td></tr>
<tr><td><code id="initNormMix_+3A_m">m</code></td>
<td>
<p>number of classes (tissue types for MRI) minus 1.</p>
</td></tr>
<tr><td><code id="initNormMix_+3A_prop">prop</code></td>
<td>
<p>the initial estimate of proportion of different components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exhaustive search part of the function for Otsu's algorithm
is adapted from <code><a href="utils.html#topic+combn">combn</a></code>.  For
<code><a href="#topic+initProp">initProp</a></code>, the threshold values are
quantiles based on the initial estimate of proportion of different
components.
</p>


<h3>Value</h3>

<table>
<tr><td><code>prop</code></td>
<td>
<p>a vector of initial estimate of the proportions of
different components (tissue types for MRI).</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a vector of initial estimate of the means of different
components (tissue types for MRI).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector of initial estimates of the standard
deviations of different components (tissue types for MRI).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For <code><a href="#topic+initOtsu">initOtsu</a></code>, it supports any number of
<code>m</code>. However, for MRI data, it can be slow if <code>m</code> is bigger
than 3 even with the fast algorithm implemented, since
the Otsu's algorithm uses an exhaustive search. But it should be
fine with <code>m</code> equal to 2, which corresponds to the
typical case in MRI classification with three major tissue types CSF, GM,
and WM.</p>


<h3>References</h3>

<p>Nobuyuki Otsu (1979).
A threshold selection method from gray-level histograms
<em>IEEE Transactions on Systems, Man and Cybernetics</em> <b>vol. 9</b>, 62-66
</p>
<p>Ping-Sung Liao, Tse-Sheng Chen and Pau-Choo Chung (2001)  
A Fast Algorithm for Multilevel Thresholding 
<em>Journal of Information Science and Engineering</em> <b>vol. 17</b>, 713-727
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example 1
  prop &lt;- c(.3, .4, .3)
  mu &lt;- c(40,  90, 130)
  sigma &lt;- c(4, 8, 4)
  y &lt;- floor(rnormmix(n=100000, prop, mu, sigma)[,1])
  initOtsu(y, 2)
  initProp(y, prop)

  #Example 2
  T1 &lt;- readMRI(system.file("extdata/t1.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  mask &lt;-readMRI(system.file("extdata/mask.rawb.gz", package="mritc"),
                 c(91,109,91), format="rawb.gz")
  initOtsu(T1[mask==1], 2)
  initProp(T1[mask==1], c(0.17, 0.48, 0.35))
</code></pre>

<hr>
<h2 id='makeMRIspatial'>Obtain Spatial Features of a Mask of an MR Image</h2><span id='topic+makeMRIspatial'></span>

<h3>Description</h3>

<p>Obtain various spatial features of an MR image, which are
used in tissue classification.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   makeMRIspatial(mask, nnei, sub, bias)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMRIspatial_+3A_mask">mask</code></td>
<td>
<p>three dimensional array. The voxels with value 1 are
inside the mask; with value 0 are outside. We just focus on voxels
inside the mask.</p>
</td></tr>
<tr><td><code id="makeMRIspatial_+3A_nnei">nnei</code></td>
<td>
<p>the number of neighbors. Right now only 6, 18,
and 26 neighbors are supported. For a 3D image,
besides defining 6 neighbors in the x, y, and z directions,
one can add 12 diagonal neighbors in the x-y, x-z, and y-z
planes, and another 8 on the 3D diagonals. This leads to a
six neighbor structure, an eighteen neighbor structure, and
a twenty-six neighbor structure.</p>
</td></tr>
<tr><td><code id="makeMRIspatial_+3A_sub">sub</code></td>
<td>
<p>logical; if <code>TRUE</code>, a new <code>mask</code>
which splits each voxel into
eight subvoxels is generated, and then obtain the neighbors and blocks
of subvoxels; otherwise obtain the neighbors and blocks at
the voxel level. The default if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="makeMRIspatial_+3A_bias">bias</code></td>
<td>
<p>logical; if <code>TRUE</code>, the spatial parameters for biased
field correction are calculated. The default if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>neighbors</code></td>
<td>
<p>a matrix, each row of which giving the neighbors of a
voxel or subvoxel. The number of rows is equal to the number of
(sub)voxels within the <code>mask</code> and the number of columns is the
number of neighbors of each (sub)voxel. For the (sub)voxels on the
boundaries, when one or more of their
neighbors are missing, the missing are represented by the total
number of (sub)voxels within the <code>mask</code> plus 1.</p>
</td></tr>	
<tr><td><code>blocks</code></td>
<td>
<p>the (sub)voxels within each block are mutually
independent given the (sub)voxels in other blocks.</p>
</td></tr>
<tr><td><code>sub</code></td>
<td>
<p>logical; the same as the input <code>sub</code>.</p>
</td></tr>
<tr><td><code>subvox</code></td>
<td>
<p>if <code>sub</code> is <code>TRUE</code>, it is a matrix,
with each row giving the eight subvoxels of a voxel;
otherwise it is equal to <code>NULL</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>if <code>bias</code> is <code>TRUE</code>, it is a vector
of weights of neighbors of every voxel for bias field correction;
otherwise it is equal to <code>NULL</code>. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>weineighbors</code></td>
<td>
<p>if <code>bias</code> is <code>TRUE</code>, it is a vector
of sum of weights of neighbors for bias field correction, one
element per voxel;
otherwise it is equal to <code>NULL</code>. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Dai Feng, Dong Liang, and Luke Tierney (2013)
An unified Bayesian hierarchical model for MRI tissue classification
<em>Statistics in Medicine</em>
</p>
<p>Dai Feng (2008)
Bayesian Hidden Markov Normal Mixture Models with Application to MRI
Tissue Classification
<em>Ph. D. Dissertation, The University of Iowa</em> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mask &lt;- array(1, dim=c(2,2,2))
  spa &lt;- makeMRIspatial(mask, nnei=6, sub=FALSE)
  spa &lt;- makeMRIspatial(mask, nnei=6, sub=TRUE)
  spa &lt;- makeMRIspatial(mask, nnei=26, sub=TRUE, bias=TRUE)
</code></pre>

<hr>
<h2 id='measureMRI'>Compare the Predicted Classsification Results with the Truth</h2><span id='topic+measureMRI'></span>

<h3>Description</h3>

<p>Calculate and demonstrate different measures for
classification results based on the truth.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   measureMRI(intvec, actual, pre)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measureMRI_+3A_intvec">intvec</code></td>
<td>
<p>a vector of intensity values. If it is not <code>NULL</code>,
the density plots of each component corresponding to the actual and
predicted classification results are shown. The default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="measureMRI_+3A_actual">actual</code></td>
<td>
<p>matrix of the true classification result. Each row
corresponds to one voxel. Column <code class="reqn">i</code> represents the
probabilities that all voxels are allocated to tissue type <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code id="measureMRI_+3A_pre">pre</code></td>
<td>
<p>matrix of the predicted classification result. Each row
corresponds to one voxel. Column <code class="reqn">i</code> represents the
probabilities that all voxels are allocated to tissue type <code class="reqn">i</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mse</code></td>
<td>
<p>mean square error.</p>
</td></tr>
<tr><td><code>misclass</code></td>
<td>
<p>mis-classification rate.</p>
</td></tr>
<tr><td><code>rseVolume</code></td>
<td>
<p>root square error of volume
with respect to reference tissue volume.</p>
</td></tr>
<tr><td><code>DSM</code></td>
<td>
<p>Dice Similary Measure of each tissue type.
</p>
<p style="text-align: center;"><code class="reqn">
  DSM_{a,b}^{t}=\frac{2 \times N_{a \cap b}^t}{N_a^t+N_b^t}  
    </code>
</p>

<p>where <code class="reqn">N_a^t</code> and <code class="reqn">N_b^t</code> are the number of voxels classified as
tissue type <code class="reqn">t</code> by
method <code class="reqn">a</code> and <code class="reqn">b</code> respectively, and <code class="reqn">N_{a \cap b}^t</code> is the number of voxels
classified as tissue type <code class="reqn">t</code> by both methods <code class="reqn">a</code> and <code class="reqn">b</code>.  The larger the
DSM, the more
similar the results from the two methods.
</p>
</td></tr>
<tr><td><code>conTable</code></td>
<td>
<p>confusion table. Each column of the table represents
the instances in an actual class, while each row represents the
instances in a predicted class.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example 1
  prop &lt;- c(.3, .4, .3)
  mu &lt;- c(-4, 0, 4)
  sigma &lt;- rep(1, 3)
  y &lt;- rnormmix(n=1e4, prop, mu, sigma)
  intvec &lt;- y[,1]
  actual &lt;- y[,2]
  pre &lt;- actual
  pre[sample(1:1e4, 100, replace=FALSE)]  &lt;- sample(1:3, 100, replace=TRUE)
  actual &lt;- do.call(cbind, lapply(1:3, function(i) ifelse(actual==i, 1, 0)))
  pre &lt;- do.call(cbind, lapply(1:3, function(i) ifelse(pre==i, 1, 0)))
  measureMRI(intvec, actual, pre)

   
  #Example 2
  T1 &lt;- readMRI(system.file("extdata/t1.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  mask &lt;-readMRI(system.file("extdata/mask.rawb.gz", package="mritc"),
                 c(91,109,91), format="rawb.gz")
  tc.icm &lt;- mritc(T1, mask, method="ICM")

  csf &lt;- readMRI(system.file("extdata/csf.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  gm &lt;- readMRI(system.file("extdata/gm.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  wm &lt;- readMRI(system.file("extdata/wm.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  truth &lt;- cbind(csf[mask==1], gm[mask==1], wm[mask==1])
  truth &lt;- truth/255
  measureMRI(T1[mask==1], truth, tc.icm$prob)
  
</code></pre>

<hr>
<h2 id='mritc'>MRI Tissue Classification Using Various Methods</h2><span id='topic+mritc.em'></span><span id='topic+mritc.icm'></span><span id='topic+mritc.hmrfem'></span><span id='topic+mritc.pvhmrfem'></span><span id='topic+mritc.bayes'></span><span id='topic+mritc'></span>

<h3>Description</h3>

<p>Conduct the MRI tissue classification using different methods including:
the normal mixture model (NMM) fitted by the Expectation-Maximization (EM)
algorithm;
the hidden Markov normal mixture model (HMNMM) fitted by the Iterated
Conditional Mode (ICM) algorithm, the Hidden Markov
Random Field EM (HMRFEM) algorithm, or the Bayesian Markov chain Monte
Carlo method (MCMC); 
the partial volume HMNMM fitted by the modified EM (PVHMRFEM)
algorithm or the higher resolution HMNMM fitted by the MCMC method (MCMCsub);
the HMNMM with both PV and intensity non-uniformity addressed (MCMCsubbias).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   mritc.em(y, prop, mu, sigma, err, maxit, verbose)
   mritc.icm(y, neighbors, blocks, spatialMat, beta, mu, sigma,
             err, maxit, verbose)
   mritc.hmrfem(y, neighbors, blocks, spatialMat, beta, mu, sigma,
                err, maxit, verbose)
   mritc.pvhmrfem(y, neighbors, blocks, spatialMat, beta, mu, sigma,
              err, maxit, verbose)
   mritc.bayes(y, neighbors, blocks, sub, subvox,
               subbias, neighbors.bias, blocks.bias, weineighbors.bias, weights.bias,
               spatialMat, beta, mu, sigma, niter, verbose)
   mritc(intarr, mask, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mritc_+3A_y">y</code></td>
<td>
<p>a vector of intensity values of voxels.</p>
</td></tr>
<tr><td><code id="mritc_+3A_prop">prop</code></td>
<td>
<p>a vector of initial estimate of the proportions of
different components of a normal mixture model. It can be obtained using
the function <code><a href="#topic+initOtsu">initOtsu</a></code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_mu">mu</code></td>
<td>
<p>a vector of initial estimate of the means of different
components of a normal mixture model. It can be obtained using
the function <code><a href="#topic+initOtsu">initOtsu</a></code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_sigma">sigma</code></td>
<td>
<p>a vector of initial estimates of the standard
deviations of different components of a normal mixture model.
It can be obtained using the function <code><a href="#topic+initOtsu">initOtsu</a></code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_err">err</code></td>
<td>
<p>relative maximum error(s) used to decide when to stop the
iteration. It could be a vector corresponding to
the relative maximum errors of the means, standard deviations (for
<code><a href="#topic+mritc.em">mritc.em</a></code>, <code><a href="#topic+mritc.icm">mritc.icm</a></code>,
<code><a href="#topic+mritc.hmrfem">mritc.hmrfem</a></code>,
and <code><a href="#topic+mritc.pvhmrfem">mritc.pvhmrfem</a></code>), and
proportions (for <code><a href="#topic+mritc.em">mritc.em</a></code>)
of all components of a normal mixture model. When it is
a scalar, all have the same relative maximum error. The default
value is 1e-4.
</p>
</td></tr>
<tr><td><code id="mritc_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations to perform. The default is
200 for <code><a href="#topic+mritc.em">mritc.em</a></code>, 20 for
<code><a href="#topic+mritc.icm">mritc.icm</a></code>, <code><a href="#topic+mritc.hmrfem">mritc.hmrfem</a></code>,
and <code><a href="#topic+mritc.pvhmrfem">mritc.pvhmrfem</a></code>.</p>
</td></tr> 
<tr><td><code id="mritc_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, then indicate
the level of output as the algorithm runs.</p>
</td></tr>
<tr><td><code id="mritc_+3A_neighbors">neighbors</code></td>
<td>
<p>a matrix of neighbors of voxels. One row per voxel.
It can be obtained 
using the function <code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_blocks">blocks</code></td>
<td>
<p>split voxels into different blocks to use the
checker-board idea. It can be obtained using the function
<code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_spatialmat">spatialMat</code></td>
<td>
<p>a matrix defining the spatial relationship
in a Potts model. The default value is <code>diag(1,3)</code>
for three components models for <code><a href="#topic+mritc.icm">mritc.icm</a></code>,
<code><a href="#topic+mritc.hmrfem">mritc.hmrfem</a></code> and
<code><a href="#topic+mritc.bayes">mritc.bayes</a></code> when <code>sub</code> is <code>FALSE</code>
and <code>matrix(c(2,0,-1,0,2,0,-1,0,2), nrow=3)</code>
when <code>sub</code> is <code>TRUE</code>.
For <code><a href="#topic+mritc.pvhmrfem">mritc.pvhmrfem</a></code> the default is
<code>matrix(c(2, 1, -1, -1, -1, 1, 2, 1, -1, -1, -1, 1,
	  2, 1, -1, -1, -1, 1, 2, 1, -1, -1, -1, 1, 2), ncol=5)</code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_beta">beta</code></td>
<td>
<p>the parameter 'inverse temperature' of the Potts
model. The default value is 0.4 for <code><a href="#topic+mritc.icm">mritc.icm</a></code>,
0.5 for <code><a href="#topic+mritc.hmrfem">mritc.hmrfem</a></code>, 0.6 for
<code><a href="#topic+mritc.pvhmrfem">mritc.pvhmrfem</a></code>.
For <code><a href="#topic+mritc.bayes">mritc.bayes</a></code>, the default is 0.7
when <code>sub</code> is <code>FALSE</code> and 0.3 when <code>sub</code> is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_sub">sub</code></td>
<td>
<p>logical; if <code>TRUE</code>, use the higher resolution model;
otherwise, use the whole voxel method.</p>
</td></tr>
<tr><td><code id="mritc_+3A_subvox">subvox</code></td>
<td>
<p>for <code><a href="#topic+mritc.bayes">mritc.bayes</a></code>,
the match up tabel of voxels and their corresponding
subvoxels for the higher resolution model. It can be
obtained using the function <code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>.
For the whole voxel method, <code>subvox</code>=<code>NULL</code></p>
</td></tr>
<tr><td><code id="mritc_+3A_subbias">subbias</code></td>
<td>
<p>logical; if <code>TRUE</code>, use the model that addresses
both the PV and intensity non-uniformity. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_neighbors.bias">neighbors.bias</code></td>
<td>
<p>a matrix of neighbors of bias field. One row per voxel.
It can be obtained using the function
<code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_blocks.bias">blocks.bias</code></td>
<td>
<p>blocks for bias field. It can be obtained using the function
<code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_weineighbors.bias">weineighbors.bias</code></td>
<td>
<p>a vector of sum of weights of neighbors of bias
field. One element per voxel. It can be obtained using the function
<code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_weights.bias">weights.bias</code></td>
<td>
<p>a vector of weights of different neighbors of
every voxel. It can be obtained using the function
<code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mritc_+3A_niter">niter</code></td>
<td>
<p>the number of iterations for
<code><a href="#topic+mritc.bayes">mritc.bayes</a></code>. The default values are 1000 and
100 for with and without bias field correction, respectively.
The default values seem to be adequate in many cases.</p>
</td></tr>
<tr><td><code id="mritc_+3A_intarr">intarr</code></td>
<td>
<p>a three dimensional array of an MR image.</p>
</td></tr>
<tr><td><code id="mritc_+3A_mask">mask</code></td>
<td>
<p>a mask of the MR image. Voxels with value 1 are
inside the	brain and value 0 are outside. Focus on voxels
within the brain.</p>
</td></tr>
<tr><td><code id="mritc_+3A_method">method</code></td>
<td>
<p>a string giving the method for MRI tissue
classification. It must be one of &quot;EM&quot;, &quot;ICM&quot;, &quot;HMRFEM&quot;, 
&quot;MCMC&quot;, &quot;PVHMRFEM&quot;, &quot;MCMCsub&quot;, or &quot;MCMCsubbias&quot; corresponding to using the
NMM fitted by the EM algorithm;
the HMNMM fitted by the ICM algorithm, the HMRFEM algorithm,
or the MCMC; the partial volume HMNMM fitted by the PVHMRFEM algorithm;
the higher resolution HMNMM fitted by the MCMC; the HMNMN addressing
both the PV and intensity non-uniformity.
It can be abbreviated. The default is &quot;EM&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+mritc">mritc</a></code> integrates functions
<code><a href="#topic+mritc.em">mritc.em</a></code>,
<code><a href="#topic+mritc.icm">mritc.icm</a></code>, <code><a href="#topic+mritc.hmrfem">mritc.hmrfem</a></code>, 
<code><a href="#topic+mritc.pvhmrfem">mritc.pvhmrfem</a></code>, and <code><a href="#topic+mritc.bayes">mritc.bayes</a></code>.
It provides a uniform platform with easier
usage. The user just need to specify the input MR image, the
<code>mask</code> of the image, and the <code>method</code> used.
The other parameters are specified automatically as follows.
The parameters for the initial estimates of the proportions,
means, and standard deviations of the normal mixture model are
obtained using the function <code><a href="#topic+initOtsu">initOtsu</a></code>.
As to the parameters related to the Potts model,
the six neighbor structure is used and then the <code>neighbors</code>,
<code>blocks</code>, and <code>subvox</code> are
obtained using the function <code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>.
For the bias field correction, the twenty-six neighbor structure is
used and then the <code>neighbors.bias</code>, <code>blocks.bias</code>,
<code>weineighbors.bias</code> and <code>weights.bias</code> are
obtained using the function <code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>.
The other parameters are taken as the default values
for each method. The process is reported during iterations.
</p>


<h3>Value</h3>

<p>For <code><a href="#topic+mritc">mritc</a></code>, it generates
an object of class &quot;mritc&quot; which is a list containing the
following components:
</p>
<table>
<tr><td><code>prob</code></td>
<td>
<p>a matrix, one row per voxel and each column
corresponding to the probabilities of being allocated to each
component of a normal mixture model.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>a vector of estimated means of the normal mixture model.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector of estimated standard deviations of the
normal mixture model.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used for computation.</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>mask of an brain. Voxels inside it are classified.</p>
</td></tr>
</table>
<p>Generic functions <code><a href="#topic+print.mritc">print.mritc</a></code>, 
<code><a href="#topic+summary.mritc">summary.mritc</a></code>, and
<code><a href="#topic+plot.mritc">plot.mritc</a></code> are provided.
</p>
<p>For others, only <code>prob</code>, <code>mu</code>, and <code>sigma</code> are
generated.
</p>


<h3>Note</h3>

<p>The functions support the various normal mixture models with
at most eight components.
</p>


<h3>References</h3>

<p>Julian Besag (1986)
On the statistical analysis of dirty pictures (with discussion)
<em>Journal of the Royal Statistical Society. Series B
(Methodological)</em>
<b>vol. 48</b> 259-302
</p>
<p>Meritxell Bach Cuadra, Leila Cammoun, Torsten Butz, Olivier Cuisenaire,
and Jean-Philippe Thiran (2005)
Comparison and validation of tissue modelization and statistical
classification methods in T1-weighted MR brain images
<em>IEEE Transactions on Medical Imaging</em>, <b>vol.24</b> 1548-1565
</p>
<p>Dai Feng, Dong Liang, and Luke Tierney (2014)
An unified Bayesian hierarchical model for MRI tissue classification
<em>Statistics in Medicine</em>
<b>vol.33, issue 8</b> 1349-1368
</p>
<p>Dai Feng, Luke Tierney, and Vincent Magnotta (2012)
MRI tissue classification using high resolution
Bayesian hidden Markov normal mixture models
<em>Journal of the American Statistical Association</em>,
<b>vol.107, no.497</b> 102-119
</p>
<p>Dai Feng and Luke Tierney (2011)
mritc: A package for MRI tissue classification
<em>Journal of Statistical Software</em>, <b>vol.44, no.7</b> 1-20
<a href="https://www.jstatsoft.org/v44/i07/">https://www.jstatsoft.org/v44/i07/</a>
</p>
<p>Dai Feng (2008)
Bayesian hidden Markov normal mixture models with application to MRI
tissue classification
<em>Ph. D. Dissertation, The University of Iowa</em>
</p>
<p>Yongyue Zhang, Michael Brady, and Stephen Smith (2001)
Segmentation of brain MR images through a hidden Markov random field
model and the expectation-maximization algorithm
<em>IEEE Transactions on Medical Imaging</em> <b>vol. 20</b> 45-57
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example 1
  T1 &lt;- readMRI(system.file("extdata/t1.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  mask &lt;- readMRI(system.file("extdata/mask.rawb.gz", package="mritc"),
                  c(91,109,91), format="rawb.gz")
  y &lt;- T1[mask==1]
  initial &lt;- initOtsu(y, 2)
  prop &lt;- initial$prop
  mu &lt;- initial$mu
  sigma &lt;- initial$sigma
  tc.em &lt;- mritc.em(y, prop, mu, sigma, verbose=TRUE)
 
  
  mrispatial &lt;- makeMRIspatial(mask, nnei=6, sub=FALSE)
  tc.icm &lt;- mritc.icm(y, mrispatial$neighbors, mrispatial$blocks,
                      mu=mu, sigma=sigma, verbose=TRUE)
  tc.hmrfem &lt;- mritc.hmrfem(y, mrispatial$neighbors, mrispatial$blocks,
                            mu=mu, sigma=sigma, verbose=TRUE)
  tc.pvhmrfem &lt;- mritc.pvhmrfem(y, mrispatial$neighbors, mrispatial$blocks,
                                mu=mu, sigma=sigma, verbose=TRUE)
  tc.mcmc &lt;- mritc.bayes(y, mrispatial$neighbors, mrispatial$blocks,
                         mrispatial$sub, mrispatial$subvox,
                         mu=mu, sigma=sigma, verbose=TRUE)

  mrispatial &lt;- makeMRIspatial(mask, nnei=6, sub=TRUE)
  tc.mcmcsub &lt;- mritc.bayes(y, mrispatial$neighbors, mrispatial$blocks,
                         mrispatial$sub, mrispatial$subvox,
                         mu=mu, sigma=sigma, verbose=TRUE)

  mrispatial26 &lt;- makeMRIspatial(mask, nnei=26, sub=TRUE, bias=TRUE)
  tc.mcmcsubbias &lt;- mritc.bayes(y, mrispatial$neighbors, mrispatial$blocks,
                                mrispatial$sub, mrispatial$subvox,
                                subbias=TRUE, mrispatial26$neighbors,
                                mrispatial26$blocks,mrispatial26$weineighbors,
                                mrispatial26$weights, mu=mu, sigma=sigma, verbose=TRUE)

  
  #Example 2
  T1 &lt;- readMRI(system.file("extdata/t1.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  mask &lt;-readMRI(system.file("extdata/mask.rawb.gz", package="mritc"),
                 c(91,109,91), format="rawb.gz")
  tc.icm &lt;- mritc(T1, mask, method="ICM")
</code></pre>

<hr>
<h2 id='mritc-package'>MRI Tissue Classification Package</h2><span id='topic+mritc-package'></span>

<h3>Description</h3>

<p>Use various methods to do MRI tissue classification.
</p>


<h3>Introduction</h3>

<p>This package provides tools for MRI tissue
classification using normal mixture models and hidden Markov normal
mixture models (with the partial volume effect and intensity non-uniformity
addressed) fitted by various methods.
</p>
<p>Magnetic resonance imaging (MRI) is used to
identify the major tissues within a subject's brain. 
Classification is usually based on a single image providing one
measurement for each volume element, or voxel, in a discretization of
the brain.  A simple model for MRI tissue classification views each voxel
as homogeneous, belonging entirely to one of the three major tissue
types (cerebrospinal fluid (CSF), gray matter (GM), and white matter
(WM));  the intensity of voxels are thus normally
distributed with means and variances depending on the tissue types
of their voxels.
The tissue types are not known and need to be identified from the
image. The assumption that all tissue types are independent leads to
a simple normal mixture model with parameters estimated by the EM
algorithm and tissue types assigned using the Bayes classifier.
</p>
<p>Since nearby voxels tend to be of the same tissue type, a Markov
random field model (a model from the Potts model family is used
in this case) can be used to capture the spatial similarity of
voxels by assigning homogeneity relationship among tissue types of
neighboring voxels.
Again, given the tissue types, the intensity of voxels are
independently and normally distributed with means and
variances depending on their tissue types.
Furthermore, the Markov random field model defined on finite space
is referred to as the hidden Markov model. Therefore the model
combine the normal mixture part and the Potts model part is called
the hidden Markov normal mixture model.
This model can be fitted by the Iterated Conditional Mode algorithm,
the Hidden Markov Random Field EM algorithm, or a Markov chain Monte
Carlo approach. 
</p>
<p>A more realistic model than the one just described would take into
account the fact that the volume elements are not homogeneous;
while some may contain only one tissue type, others on the interface
will contain two or possibly three different tissue types. This
phenomenon is called the partial volume (PV) effect.
One approach to address the PV effect is to introduce
intermediate classes. Usually this is
done by introducing two more classes: the combination of the CSF and
the GM and the combination of the GM and the WM.
Voxels containing WM and CSF are very rare and are ignored.
This helps reduce confounding in estimation and a number of studies
have used this approach.  Among these methods, the Gaussian partial volume
hidden Markov random field models fitted by the modified EM algorithm
appears to be more competitive in performance.
A new approach to this problem is to construct a higher resolution
image in which each voxel is divided into eight subvoxels.
For each voxel
the measured value is the sum of the unobserved measurements for the
subvoxels. The subvoxels are in turn assumed to be homogeneous and
follow the simpler model described above. 
</p>
<p>Intensity non-uniformity is an artifact that the signal intensity
varies smoothly across an image. It is caused by combination
and interaction of effects from the device, pulse sequence, and
object. A commonly used approach to tackle it is to assume the 
the measured signal is equal to true signal multiplied by bias field
associated with the intensity non-uniformity plus some noise. 
The bias field needs to be spatially smoothly varying and is modeled
as either jointly normally distributed, or a linear combination of
smooth spline or polynomial basis functions. Instead, we propose using
a locally smoothed prior on the bias field.
</p>
<p>A Bayesian hierarchical model aiming at modeling the partial volume
effect and intensity non-uniformity simultaneously was proposed.
Instead of splitting the task into different steps, the framework
harmoniously integrates several sub-models addressing different issues
in the MRI classification, through specification of the likelihood function
and prior distributions. This approach could provide more accurate
tissue classification and also allow more effective estimation of the
proportion of each voxel that belongs to each of the major tissue
types.
</p>
<p>Besides brain image segmentation, the methods provided in this package can be used for 
classification of other spatial data as well.
</p>


<h3>Usage</h3>

<p>The function <code><a href="#topic+readMRI">readMRI</a></code> and
<code><a href="#topic+writeMRI">writeMRI</a></code> are I/O
functions for MRI data. Right now, the &quot;Analyze&quot;, &quot;NIfTI&quot;, and raw
byte (unsigned with 1 byte per element in the byte stream) gzip
formats are supported.
</p>
<p>For each MR image, there has to be a corresponding array, <code>mask</code>,
with values 1 and 0. Voxels with value 1 are inside the brain and 0
are outside.
Tissue classification is conducted on voxels inside the brain.
</p>
<p>The functions <code><a href="#topic+mritc.em">mritc.em</a></code>, <code><a href="#topic+mritc.icm">mritc.icm</a></code>,
<code><a href="#topic+mritc.hmrfem">mritc.hmrfem</a></code>, and
<code><a href="#topic+mritc.bayes">mritc.bayes</a></code>
are used
to conduct the MRI tissue classification using the normal mixture
model fitted by the EM algorithm, the hidden Markov normal
mixture model at the voxel level fitted by the Iterated
Conditional Mode algorithm, the Hidden Markov Random Field EM
algorithm,
or the Bayesian method (with or without the PV 
or bias field correction).  The function
<code><a href="#topic+mritc.pvhmrfem">mritc.pvhmrfem</a></code> is for classification using Gaussian
partial volume hidden Markov random field models fitted by the
modified EM algorithm.
Different components of the normal mixture model correspond to
different tissue types. The number of components is flexible,
say using five components model to address the PV effect by
<code><a href="#topic+mritc.em">mritc.em</a></code>, <code><a href="#topic+mritc.icm">mritc.icm</a></code>,
<code><a href="#topic+mritc.hmrfem">mritc.hmrfem</a></code>, or <code><a href="#topic+mritc.bayes">mritc.bayes</a></code>.
</p>
<p>In order to use the previous functions, the parameters of the
normal mixture model and the Potts model have to be specified.
Some parameters can be obtained using the functions
<code><a href="#topic+initOtsu">initOtsu</a></code> and <code><a href="#topic+makeMRIspatial">makeMRIspatial</a></code>.
There are default values for other parameters.
</p>
<p>The function <code><a href="#topic+mritc">mritc</a></code> integrates all methods together,
provides a uniform platform with easier usage, and generates an object
of class &quot;mritc&quot; , for which generic functions
<code><a href="#topic+print.mritc">print.mritc</a></code>, <code><a href="#topic+summary.mritc">summary.mritc</a></code>,
and <code><a href="#topic+plot.mritc">plot.mritc</a></code> are provided. 
</p>


<h3>Computation Issues</h3>

<p>To improve the speed, the table lookup method was used in various
places; vectorized computation was used to take advantage of
conditional independence. 
Some computations are performed by <b>C</b>
code, and the <b>OpenMP</b> is used to parallelize key loops in
the <b>C</b> code. Sparse matrix multiplication is adopted as well.
</p>

<hr>
<h2 id='plot.mritc'>Plot Method for Class &quot;mritc&quot;</h2><span id='topic+plot.mritc'></span>

<h3>Description</h3>

<p>Visualize MRI tissue classification results. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mritc'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mritc_+3A_x">x</code></td>
<td>
<p>an object of class &quot;mritc&quot;</p>
</td></tr>
<tr><td><code id="plot.mritc_+3A_...">...</code></td>
<td>
<p>any additional arguments for function <code><a href="misc3d.html#topic+slices3d">slices3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allocate a voxel to the tissue type with the highest probability and
then use <code><a href="misc3d.html#topic+slices3d">slices3d</a></code> to show the result.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="misc3d.html#topic+slices3d">slices3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  T1 &lt;- readMRI(system.file("extdata/t1.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  mask &lt;-readMRI(system.file("extdata/mask.rawb.gz", package="mritc"),
                 c(91,109,91), format="rawb.gz")
  tc.icm &lt;- mritc(T1, mask, method="ICM")
  plot(tc.icm)
</code></pre>

<hr>
<h2 id='print.mritc'>Print Method for Class &quot;mritc&quot;</h2><span id='topic+print.mritc'></span>

<h3>Description</h3>

<p>Print out some information of an object of class &quot;mritc&quot;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mritc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mritc_+3A_x">x</code></td>
<td>
<p>an object of class &quot;mritc&quot;.</p>
</td></tr>
<tr><td><code id="print.mritc_+3A_...">...</code></td>
<td>
<p>any additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function computes and returns some summary statistics of the
object obtained from running the function <code><a href="#topic+mritc">mritc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  T1 &lt;- readMRI(system.file("extdata/t1.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  mask &lt;-readMRI(system.file("extdata/mask.rawb.gz", package="mritc"),
                 c(91,109,91), format="rawb.gz")
  tc.icm &lt;- mritc(T1, mask, method="ICM")
  tc.icm
</code></pre>

<hr>
<h2 id='readMRI'>Read an MR Image into an Array</h2><span id='topic+readMRI'></span>

<h3>Description</h3>

<p>Read an MR image of different formats into an array. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   readMRI(file, dim, format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMRI_+3A_file">file</code></td>
<td>
<p>the name of the image file to be read in.</p>
</td></tr>
<tr><td><code id="readMRI_+3A_dim">dim</code></td>
<td>
<p>the dimensions of the image. It is required for the
image of type <code>raw.gz</code>, in which <code>dim</code> is a vector
of length three specifying dimensions in x, y, and z directions.
The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="readMRI_+3A_format">format</code></td>
<td>
<p>the format of the image file. Right now only the
&quot;Analyze&quot;, &quot;NIfTI&quot;, and raw byte (unsigned with 1 byte per
element in the byte stream) gzip formats are supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The files of &quot;Analyze&quot; format are read in through the
function <code><a href="oro.nifti.html#topic+readANALYZE">readANALYZE</a></code>.
The files of &quot;NIfTI&quot; format are read in through
the function<code><a href="oro.nifti.html#topic+readNIfTI">readNIfTI</a></code>. 
</p>


<h3>Value</h3>

<p>An array with the appropriate dimensions containing the image
volume. 
</p>


<h3>See Also</h3>

<p><code><a href="oro.nifti.html#topic+readANALYZE">readANALYZE</a></code>,
<code><a href="oro.nifti.html#topic+readNIfTI">readNIfTI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  vol1 &lt;- readMRI("t1.rawb.gz", c(91,109,91), "rawb.gz")
  
  vol2 &lt;- readMRI("t1.nii.gz", format="nifti")

  vol3  &lt;- readMRI("t1.nii", format="nifti")

  vol4 &lt;- readMRI("t1-analyze.img", format="analyze")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='rnormmix'>Generate Random Samples from a Normal Mixture Model</h2><span id='topic+rnormmix'></span>

<h3>Description</h3>

<p>Generate random samples from a normal mixture model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rnormmix(n, prop, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnormmix_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="rnormmix_+3A_prop">prop</code></td>
<td>
<p>a vector of proportions of different components.</p>
</td></tr>
<tr><td><code id="rnormmix_+3A_mu">mu</code></td>
<td>
<p>a vector of means of different components.</p>
</td></tr>
<tr><td><code id="rnormmix_+3A_sigma">sigma</code></td>
<td>
<p>a vector of standard deviations of different components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with each row corresponding to one sample. The first column are
sample values from a normal mixture model; the second column are the
components from which observations come.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  prop &lt;- c(.17, .48, .35)
  mu &lt;- c(-4, 0, 4)
  sigma &lt;- rep(1, 3)
  y &lt;- rnormmix(n=10000, prop, mu, sigma)
  densityplot(~ y[,1], groups = y[,2],
              plot.points = FALSE, ref = TRUE,
              xlab="sample values",
              auto.key = list(columns = 3))
</code></pre>

<hr>
<h2 id='summary.mritc'>Summary Method for Class &quot;mritc&quot;</h2><span id='topic+summary.mritc'></span>

<h3>Description</h3>

<p>Summarize some information of an object of class &quot;mritc&quot;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mritc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mritc_+3A_object">object</code></td>
<td>
<p>an object of class &quot;mritc&quot;.</p>
</td></tr>
<tr><td><code id="summary.mritc_+3A_...">...</code></td>
<td>
<p>any additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function computes and returns some
summary statistics of the object obtained from running the
function <code><a href="#topic+mritc">mritc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  T1 &lt;- readMRI(system.file("extdata/t1.rawb.gz", package="mritc"),
                c(91,109,91), format="rawb.gz")
  mask &lt;-readMRI(system.file("extdata/mask.rawb.gz", package="mritc"),
                 c(91,109,91), format="rawb.gz")
  tc.icm &lt;- mritc(T1, mask, method="ICM")
  summary(tc.icm)
</code></pre>

<hr>
<h2 id='writeMRI'>Write an MR Image</h2><span id='topic+writeMRI'></span>

<h3>Description</h3>

<p>Write an MR image into a file of different formats. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   writeMRI(data, file, header, format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeMRI_+3A_data">data</code></td>
<td>
<p>MRI data in a three dimensional array or four
dimensional array with the forth dimension equal to 1.
It could be also an object of class &quot;nifti&quot; or &quot;anlz&quot; as
defined in the package
<code>oro.nifti</code>.</p>
</td></tr>
<tr><td><code id="writeMRI_+3A_file">file</code></td>
<td>
<p>the name of the image file to be written out.</p>
</td></tr>
<tr><td><code id="writeMRI_+3A_header">header</code></td>
<td>
<p>the header file. <code>header</code> is set as <code>NULL</code>
for backward compatibility.</p>
</td></tr>
<tr><td><code id="writeMRI_+3A_format">format</code></td>
<td>
<p>the format of the image file. Right now only the
&quot;Analyze&quot;, &quot;NIfTI&quot;, and raw byte (unsigned with 1 byte per
element in the byte stream) gzip formats are supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Header file is not needed for the file of &quot;Analyze&quot; or &quot;NIfTI&quot;
format anymore. 
</p>
<p>Files of &quot;Analyze&quot; format are written out through
the function <code><a href="oro.nifti.html#topic+writeANALYZE">writeANALYZE</a></code>.
Files of &quot;NIfTI&quot; format are written out through
the function <code><a href="oro.nifti.html#topic+writeNIfTI">writeNIfTI</a></code>.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>See Also</h3>

<p><code><a href="oro.nifti.html#topic+writeANALYZE">writeANALYZE</a></code>,
<code><a href="oro.nifti.html#topic+writeNIfTI">writeNIfTI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  writeMRI(vol, file="vol.rawb.gz", header=NULL, format="rawb.gz")
  
  writeMRI(vol, file="vol", header=NULL, format="nifti")

  writeMRI(vol, file="vol", header=NULL, format="analyze")
  
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
