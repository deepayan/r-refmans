<!DOCTYPE html><html><head><title>Help for package nevada</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nevada}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nevada-package'><p>nevada: Network-Valued Data Analysis</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#as_nvd'><p>Coercion to Network-Valued Data Object</p></a></li>
<li><a href='#as_vertex_partition'><p>Coercion to Vertex Partition</p></a></li>
<li><a href='#dist_nvd'><p>Pairwise Distance Matrix Between Two Samples of Networks</p></a></li>
<li><a href='#distances'><p>Distances Between Networks</p></a></li>
<li><a href='#edge_count_global_variables'><p>Transform distance matrix in edge properties of minimal spanning tree</p></a></li>
<li><a href='#generate_sigma_algebra'><p>Sigma-Algebra generated by a Partition</p></a></li>
<li><a href='#inner-products'><p>Inner-Products Between Networks</p></a></li>
<li><a href='#mean.nvd'><p>Fréchet Mean of Network-Valued Data</p></a></li>
<li><a href='#nvd'><p>Network-Valued Data Constructor</p></a></li>
<li><a href='#nvd-plot'><p>MDS Visualization of Network Distributions</p></a></li>
<li><a href='#power2'><p>Power Simulations for Permutation Tests</p></a></li>
<li><a href='#repr_nvd'><p>Network-Valued to Matrix-Valued Data</p></a></li>
<li><a href='#representations'><p>Network Representation Functions</p></a></li>
<li><a href='#sample2_sbm'><p>Two-Sample Stochastic Block Model Generator</p></a></li>
<li><a href='#samplers'><p>Graph samplers using edge distributions</p></a></li>
<li><a href='#statistics'><p>Test Statistics for Network Populations</p></a></li>
<li><a href='#subgraphs'><p>Full, intra and inter subgraph generators</p></a></li>
<li><a href='#test2_global'><p>Global Two-Sample Test for Network-Valued Data</p></a></li>
<li><a href='#test2_local'><p>Local Two-Sample Test for Network-Valued Data</p></a></li>
<li><a href='#var_nvd'><p>Fréchet Variance of Network-Valued Data Around a Given Network</p></a></li>
<li><a href='#var2_nvd'><p>Fréchet Variance of Network-Valued Data from Inter-Point Distances</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network-Valued Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A flexible statistical framework for network-valued data analysis. 
    It leverages the complexity of the space of distributions on graphs by using 
    the permutation framework for inference as implemented in the 'flipr' package. 
    Currently, only the two-sample testing problem is covered and generalization 
    to k samples and regression will be added in the future as well. It is a 
    4-step procedure where the user chooses a suitable representation of the 
    networks, a suitable metric to embed the representation into a metric space, 
    one or more test statistics to target specific aspects of the distributions 
    to be compared and a formula to compute the permutation p-value. Two types 
    of inference are provided: a global test answering whether there is a 
    difference between the distributions that generated the two samples and a 
    local test for localizing differences on the network structure. The latter 
    is assumed to be shared by all networks of both samples. References: Lovato, 
    I., Pini, A., Stamm, A., Vantini, S. (2020) "Model-free two-sample test for 
    network-valued data" &lt;<a href="https://doi.org/10.1016%2Fj.csda.2019.106896">doi:10.1016/j.csda.2019.106896</a>&gt;; Lovato, I., Pini, A., 
    Stamm, A., Taquet, M., Vantini, S. (2021) "Multiscale null hypothesis 
    testing for network-valued data: Analysis of brain networks of patients with 
    autism" &lt;<a href="https://doi.org/10.1111%2Frssc.12463">doi:10.1111/rssc.12463</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, Rcpp, tidyr, dplyr, purrr, tibble, forcats, ggplot2,
rlang, magrittr, flipr, cli, withr, tsne, umap, furrr,
rgeomstats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://astamm.github.io/nevada/">https://astamm.github.io/nevada/</a>,
<a href="https://github.com/astamm/nevada/">https://github.com/astamm/nevada/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/astamm/nevada/issues/">https://github.com/astamm/nevada/issues/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-03 14:51:26 UTC; stamm-a</td>
</tr>
<tr>
<td>Author:</td>
<td>Ilenia Lovato [aut],
  Alessia Pini [aut],
  Aymeric Stamm <a href="https://orcid.org/0000-0002-8725-3654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Simone Vantini [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aymeric Stamm &lt;aymeric.stamm@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-03 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nevada-package'>nevada: Network-Valued Data Analysis</h2><span id='topic+nevada'></span><span id='topic+nevada-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A flexible statistical framework for network-valued data analysis. It leverages the complexity of the space of distributions on graphs by using the permutation framework for inference as implemented in the 'flipr' package. Currently, only the two-sample testing problem is covered and generalization to k samples and regression will be added in the future as well. It is a 4-step procedure where the user chooses a suitable representation of the networks, a suitable metric to embed the representation into a metric space, one or more test statistics to target specific aspects of the distributions to be compared and a formula to compute the permutation p-value. Two types of inference are provided: a global test answering whether there is a difference between the distributions that generated the two samples and a local test for localizing differences on the network structure. The latter is assumed to be shared by all networks of both samples. References: Lovato, I., Pini, A., Stamm, A., Vantini, S. (2020) &quot;Model-free two-sample test for network-valued data&quot; <a href="https://doi.org/10.1016/j.csda.2019.106896">doi:10.1016/j.csda.2019.106896</a>; Lovato, I., Pini, A., Stamm, A., Taquet, M., Vantini, S. (2021) &quot;Multiscale null hypothesis testing for network-valued data: Analysis of brain networks of patients with autism&quot; <a href="https://doi.org/10.1111/rssc.12463">doi:10.1111/rssc.12463</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aymeric Stamm <a href="mailto:aymeric.stamm@cnrs.fr">aymeric.stamm@cnrs.fr</a> (<a href="https://orcid.org/0000-0002-8725-3654">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Ilenia Lovato <a href="mailto:ilenia.lovato01@universitadipavia.it">ilenia.lovato01@universitadipavia.it</a>
</p>
</li>
<li><p> Alessia Pini <a href="mailto:alessia.pini@unicatt.it">alessia.pini@unicatt.it</a>
</p>
</li>
<li><p> Simone Vantini <a href="mailto:simone.vantini@polimi.it">simone.vantini@polimi.it</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://astamm.github.io/nevada/">https://astamm.github.io/nevada/</a>
</p>
</li>
<li> <p><a href="https://github.com/astamm/nevada/">https://github.com/astamm/nevada/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/astamm/nevada/issues/">https://github.com/astamm/nevada/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='as_nvd'>Coercion to Network-Valued Data Object</h2><span id='topic+as_nvd'></span>

<h3>Description</h3>

<p>This function flags a list of <code><a href="igraph.html#topic+igraph">igraph</a></code> objects as an
<code><a href="#topic+nvd">nvd</a></code> object as defined in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_nvd(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_nvd_+3A_obj">obj</code></td>
<td>
<p>A list of <code><a href="igraph.html#topic+igraph">igraph</a></code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+nvd">nvd</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnp_params &lt;- list(p = 1/3)
as_nvd(nvd(model = "gnp", n = 10L, model_params = gnp_params))
</code></pre>

<hr>
<h2 id='as_vertex_partition'>Coercion to Vertex Partition</h2><span id='topic+as_vertex_partition'></span>

<h3>Description</h3>

<p>This function converts a vector of memberships into a proper vertex partition
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_vertex_partition(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_vertex_partition_+3A_x">x</code></td>
<td>
<p>A list grouping the vertices by partition element or an integer or
character vector of vertex memberships.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vertex_partition</code> object storing the corresponding vertex
partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- c("P1", "P3", "P4", "P1", "P2", "P2", "P3", "P1", "P4", "P3")
V1 &lt;- as_vertex_partition(m1)
m2 &lt;- as.integer(c(1, 3, 4, 1, 2, 2, 3, 1, 4, 3))
V2 &lt;- as_vertex_partition(m2)
</code></pre>

<hr>
<h2 id='dist_nvd'>Pairwise Distance Matrix Between Two Samples of Networks</h2><span id='topic+dist_nvd'></span>

<h3>Description</h3>

<p>This function computes the matrix of pairwise distances between all the
elements of the two samples put together. The cardinality of the fist sample
is denoted by <code class="reqn">n_1</code> and that of the second one is denoted by <code class="reqn">n_2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_nvd(
  x,
  y = NULL,
  representation = "adjacency",
  distance = "frobenius",
  matching_iterations = 0,
  target_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_nvd_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+list">base::list</a></code> of <code><a href="igraph.html#topic+aaa-igraph-package">igraph::igraph</a></code> objects or matrix
representations of underlying networks from a given first population.</p>
</td></tr>
<tr><td><code id="dist_nvd_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+list">base::list</a></code> of <code><a href="igraph.html#topic+aaa-igraph-package">igraph::igraph</a></code> objects or matrix
representations of underlying networks from a given second population.</p>
</td></tr>
<tr><td><code id="dist_nvd_+3A_representation">representation</code></td>
<td>
<p>A string specifying the desired type of representation,
among: <code>"adjacency"</code>, <code>"laplacian"</code>, <code>"modularity"</code> or
<code>"graphon"</code>. Default is <code>"laplacian"</code>.</p>
</td></tr>
<tr><td><code id="dist_nvd_+3A_distance">distance</code></td>
<td>
<p>A string specifying the chosen distance for calculating the
test statistic, among: <code>"hamming"</code>, <code>"frobenius"</code>,
<code>"spectral"</code> and <code>"root-euclidean"</code>. Default is
<code>"frobenius"</code>.</p>
</td></tr>
<tr><td><code id="dist_nvd_+3A_matching_iterations">matching_iterations</code></td>
<td>
<p>An integer value specifying the maximum number of
runs when looking for the optimal permutation for graph matching. Defaults
to <code>0L</code> in which case no matching is done.</p>
</td></tr>
<tr><td><code id="dist_nvd_+3A_target_matrix">target_matrix</code></td>
<td>
<p>A square numeric matrix of size <code>n</code> equal to the order
of the graphs specifying a target matrix towards which the initial doubly
stochastic matrix is shrunk each time the graph matching algorithm fails to
provide a good minimum. Defaults to <code>NULL</code> in which case the target matrix
is automatically chosen between the identity matrix or the uniform matrix
on the n-simplex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code class="reqn">(n_1+n_2) \times (n_1+n_2)</code> containing the
distances between all the elements of the two samples put together.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnp_params &lt;- list(p = 1/3)
k_regular_params &lt;- list(k = 8L)
x &lt;- nvd(model = "gnp", n = 10L, model_params = gnp_params)
y &lt;- nvd(model = "k_regular", n = 10L, model_params = k_regular_params)
dist_nvd(x, y, "adjacency", "spectral")
</code></pre>

<hr>
<h2 id='distances'>Distances Between Networks</h2><span id='topic+distances'></span><span id='topic+dist_hamming'></span><span id='topic+dist_frobenius'></span><span id='topic+dist_spectral'></span><span id='topic+dist_root_euclidean'></span>

<h3>Description</h3>

<p>This is a collection of functions computing the distance between two
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_hamming(x, y, representation = "laplacian")

dist_frobenius(
  x,
  y,
  representation = "laplacian",
  matching_iterations = 0,
  target_matrix = NULL
)

dist_spectral(x, y, representation = "laplacian")

dist_root_euclidean(x, y, representation = "laplacian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distances_+3A_x">x</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph::igraph</a></code> object or a matrix representing an underlying
network.</p>
</td></tr>
<tr><td><code id="distances_+3A_y">y</code></td>
<td>
<p>An <code><a href="igraph.html#topic+aaa-igraph-package">igraph::igraph</a></code> object or a matrix representing an underlying
network. Should have the same number of vertices as <code>x</code>.</p>
</td></tr>
<tr><td><code id="distances_+3A_representation">representation</code></td>
<td>
<p>A string specifying the desired type of representation,
among: <code>"adjacency"</code>, <code>"laplacian"</code>, <code>"modularity"</code> or
<code>"graphon"</code>. Default is <code>"laplacian"</code>.</p>
</td></tr>
<tr><td><code id="distances_+3A_matching_iterations">matching_iterations</code></td>
<td>
<p>An integer value specifying the maximum number of
runs when looking for the optimal permutation for graph matching. Defaults
to <code>0L</code> in which case no matching is done.</p>
</td></tr>
<tr><td><code id="distances_+3A_target_matrix">target_matrix</code></td>
<td>
<p>A square numeric matrix of size <code>n</code> equal to the order
of the graphs specifying a target matrix towards which the initial doubly
stochastic matrix is shrunk each time the graph matching algorithm fails to
provide a good minimum. Defaults to <code>NULL</code> in which case the target matrix
is automatically chosen between the identity matrix or the uniform matrix
on the n-simplex.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> be the matrix representation of network <code class="reqn">x</code> and <code class="reqn">Y</code> be
the matrix representation of network <code class="reqn">y</code>. The Hamming distance between
<code class="reqn">x</code> and <code class="reqn">y</code> is given by </p>
<p style="text-align: center;"><code class="reqn">\frac{1}{N(N-1)} \sum_{i,j} |X_{ij} -
Y_{ij}|,</code>
</p>
<p> where <code class="reqn">N</code> is the number of vertices in networks <code class="reqn">x</code> and
<code class="reqn">y</code>. The Frobenius distance between <code class="reqn">x</code> and <code class="reqn">y</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\sum_{i,j} (X_{ij} - Y_{ij})^2}.</code>
</p>
<p> The spectral distance between
<code class="reqn">x</code> and <code class="reqn">y</code> is given by </p>
<p style="text-align: center;"><code class="reqn">\sqrt{\sum_i (a_i - b_i)^2},</code>
</p>
<p> where
<code class="reqn">a</code> and <code class="reqn">b</code> of the eigenvalues of <code class="reqn">X</code> and <code class="reqn">Y</code>, respectively.
This distance gives rise to classes of equivalence. Consider the spectral
decomposition of <code class="reqn">X</code> and <code class="reqn">Y</code>: </p>
<p style="text-align: center;"><code class="reqn">X=VAV^{-1}</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">Y =
UBU^{-1},</code>
</p>
<p> where <code class="reqn">V</code> and <code class="reqn">U</code> are the matrices whose columns are the
eigenvectors of <code class="reqn">X</code> and <code class="reqn">Y</code>, respectively and <code class="reqn">A</code> and <code class="reqn">B</code> are
the diagonal matrices with elements the eigenvalues of <code class="reqn">X</code> and <code class="reqn">Y</code>,
respectively. The root-Euclidean distance between <code class="reqn">x</code> and <code class="reqn">y</code> is
given by </p>
<p style="text-align: center;"><code class="reqn">\sqrt{\sum_i (V \sqrt{A} V^{-1} - U \sqrt{B} U^{-1})^2}.</code>
</p>

<p>Root-Euclidean distance can used only with the laplacian matrix
representation.
</p>


<h3>Value</h3>

<p>A scalar measuring the distance between the two input networks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- igraph::sample_gnp(20, 0.1)
g2 &lt;- igraph::sample_gnp(20, 0.2)
dist_hamming(g1, g2, "adjacency")
dist_frobenius(g1, g2, "adjacency")
dist_spectral(g1, g2, "laplacian")
dist_root_euclidean(g1, g2, "laplacian")
</code></pre>

<hr>
<h2 id='edge_count_global_variables'>Transform distance matrix in edge properties of minimal spanning tree</h2><span id='topic+edge_count_global_variables'></span>

<h3>Description</h3>

<p>Transform distance matrix in edge properties of minimal spanning tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_count_global_variables(d, n1, k = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_count_global_variables_+3A_d">d</code></td>
<td>
<p>A matrix of dimension <code class="reqn">(n1+n2)x(n1+n2)</code> containing the distances
between all the elements of the two samples put together.</p>
</td></tr>
<tr><td><code id="edge_count_global_variables_+3A_n1">n1</code></td>
<td>
<p>An integer giving the size of the first sample.</p>
</td></tr>
<tr><td><code id="edge_count_global_variables_+3A_k">k</code></td>
<td>
<p>An integer specifying the density of the minimal spanning tree to
generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of edge properties of the minimal spanning tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 30L
n2 &lt;- 10L
gnp_params &lt;- list(p = 1/3)
k_regular_params &lt;- list(k = 8L)
x &lt;- nvd(model = "gnp", n = n1, model_params = gnp_params)
y &lt;- nvd(model = "k_regular", n = n2, model_params = k_regular_params)
d &lt;- dist_nvd(x, y, representation = "laplacian", distance = "frobenius")
e &lt;- edge_count_global_variables(d, n1, k = 5L)
</code></pre>

<hr>
<h2 id='generate_sigma_algebra'>Sigma-Algebra generated by a Partition</h2><span id='topic+generate_sigma_algebra'></span>

<h3>Description</h3>

<p>Sigma-Algebra generated by a Partition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_sigma_algebra(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_sigma_algebra_+3A_x">x</code></td>
<td>
<p>Input partition stored as a <code>vertex_partition</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sigma-algebra
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- igraph::make_ring(7)
m &lt;- as.integer(c(1, 2, 1, 3, 4, 4, 3))
p &lt;- as_vertex_partition(m)
sa &lt;- generate_sigma_algebra(p)
all_full  &lt;- purrr::modify_depth(sa, 2, ~ subgraph_full (g, .x))
all_intra &lt;- purrr::modify_depth(sa, 2, ~ subgraph_intra(g, .x))
all_inter &lt;- purrr::modify_depth(sa, 2, ~ subgraph_inter(g, .x))
</code></pre>

<hr>
<h2 id='inner-products'>Inner-Products Between Networks</h2><span id='topic+inner-products'></span><span id='topic+ipro_frobenius'></span>

<h3>Description</h3>

<p>This is a collection of functions computing the inner product between two
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipro_frobenius(x, y, representation = "laplacian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner-products_+3A_x">x</code></td>
<td>
<p>An <code><a href="igraph.html#topic+igraph">igraph</a></code> object or a matrix representing an
underlying network.</p>
</td></tr>
<tr><td><code id="inner-products_+3A_y">y</code></td>
<td>
<p>An <code><a href="igraph.html#topic+igraph">igraph</a></code> object or a matrix representing an
underlying network. Should have the same number of vertices as <code>x</code>.</p>
</td></tr>
<tr><td><code id="inner-products_+3A_representation">representation</code></td>
<td>
<p>A string specifying the desired type of representation,
among: <code>"adjacency"</code>, <code>"laplacian"</code>, <code>"modularity"</code> or
<code>"graphon"</code>. Default is <code>"laplacian"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar measuring the angle between the two input networks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- igraph::sample_gnp(20, 0.1)
g2 &lt;- igraph::sample_gnp(20, 0.2)
ipro_frobenius(g1, g2, "adjacency")
</code></pre>

<hr>
<h2 id='mean.nvd'>Fréchet Mean of Network-Valued Data</h2><span id='topic+mean.nvd'></span>

<h3>Description</h3>

<p>This function computes the sample Fréchet mean from an observed sample of
network-valued random variables according to a specified matrix
representation. It currently only supports the Euclidean geometry i.e. the
sample Fréchet mean is obtained as the argmin of the sum of squared Frobenius
distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nvd'
mean(x, weights = rep(1, length(x)), representation = "adjacency", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.nvd_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+nvd">nvd</a></code> object.</p>
</td></tr>
<tr><td><code id="mean.nvd_+3A_weights">weights</code></td>
<td>
<p>A numeric vector specifying weights for each observation
(default: equally weighted).</p>
</td></tr>
<tr><td><code id="mean.nvd_+3A_representation">representation</code></td>
<td>
<p>A string specifying the graph representation to be
used. Choices are adjacency, laplacian, modularity, graphon. Default is
adjacency.</p>
</td></tr>
<tr><td><code id="mean.nvd_+3A_...">...</code></td>
<td>
<p>Other argument to be parsed to the <code><a href="base.html#topic+mean">mean</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean network in the chosen matrix representation assuming
Euclidean geometry for now.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnp_params &lt;- list(p = 1/3)
x &lt;- nvd(model = "gnp", n = 10L, model_params = gnp_params)
mean(x)
</code></pre>

<hr>
<h2 id='nvd'>Network-Valued Data Constructor</h2><span id='topic+nvd'></span>

<h3>Description</h3>

<p>This is the constructor for objects of class <code>nvd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvd(
  model = "smallworld",
  n = 1L,
  num_vertices = 25L,
  model_params = list(dim = 1L, nei = 4L, p = 0.15),
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nvd_+3A_model">model</code></td>
<td>
<p>A string specifying the model to be used for sampling networks
(current choices are: <code>"sbm"</code>, <code>"k_regular"</code>, <code>"gnp"</code>, <code>"smallworld"</code>,
<code>"pa"</code>, <code>"poisson"</code> and <code>"binomial"</code>). Defaults to <code>"smallworld"</code>.</p>
</td></tr>
<tr><td><code id="nvd_+3A_n">n</code></td>
<td>
<p>An integer specifying the sample size. Defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="nvd_+3A_num_vertices">num_vertices</code></td>
<td>
<p>An integer specifying the order of the graphs to be
generated (i.e. the number of nodes). Defaults to <code>25L</code>.</p>
</td></tr>
<tr><td><code id="nvd_+3A_model_params">model_params</code></td>
<td>
<p>A named list setting the parameters of the model you are
considering. Defaults to <code>list(dim = 1L, nei = 4L, p = 0.15)</code> which sets
defaults parameters for the Watts-Strogatz small-world model generator.</p>
</td></tr>
<tr><td><code id="nvd_+3A_seed">seed</code></td>
<td>
<p>An integer specifying the random generator seed. Defaults to
<code>1234</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>nvd</code> object which is a list of <code><a href="igraph.html#topic+igraph">igraph</a></code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smallworld_params &lt;- list(dim = 1L, nei = 4L, p = 0.15)
nvd(model_params = smallworld_params)
</code></pre>

<hr>
<h2 id='nvd-plot'>MDS Visualization of Network Distributions</h2><span id='topic+nvd-plot'></span><span id='topic+autoplot.nvd'></span><span id='topic+plot.nvd'></span>

<h3>Description</h3>

<p>This function generates 2-dimensional plots of samples of networks via
multi-dimensional scaling using all representations and distances included in
the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nvd'
autoplot(object, memberships = rep(1, length(object)), method = "mds", ...)

## S3 method for class 'nvd'
plot(x, method = "mds", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nvd-plot_+3A_object">object</code>, <code id="nvd-plot_+3A_x">x</code></td>
<td>
<p>A list containing two samples of network-valued data stored
as objects of class <code><a href="#topic+nvd">nvd</a></code>.</p>
</td></tr>
<tr><td><code id="nvd-plot_+3A_memberships">memberships</code></td>
<td>
<p>An integer vector specifying the membership of each
network to a specific sample. Defaults to <code>rep(1, length(nvd))</code> which
assumes that all networks in the input <code><a href="#topic+nvd">nvd</a></code> object belong to a single
group.</p>
</td></tr>
<tr><td><code id="nvd-plot_+3A_method">method</code></td>
<td>
<p>A string specifying which dimensionality reduction method to
use for projecting the samples into the cartesian plane. Choices are
<code>"mds"</code>, <code>"tsne"</code> or <code>"umap"</code>. Defaults to <code>"mds"</code>.</p>
</td></tr>
<tr><td><code id="nvd-plot_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object. In
particular, the data set computed to generate the plot can be retrieved via
<code style="white-space: pre;">&#8288;$data&#8288;</code>. This is a <code><a href="tibble.html#topic+tibble">tibble</a></code> containing the following
variables:
</p>

<ul>
<li> <p><code>V1</code>: the x-coordinate of each observation in the plane,
</p>
</li>
<li> <p><code>V2</code>: the y-coordinate of each observation in the plane,
</p>
</li>
<li> <p><code>Label</code>: the sample membership of each observation,
</p>
</li>
<li> <p><code>Representation</code>: the type of matrix representation used to manipulate each
observation,
</p>
</li>
<li> <p><code>Distance</code>: the distance used to measure how far each observation is from
the others.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>gnp_params &lt;- list(p = 1/3)
k_regular_params &lt;- list(k = 8L)
x &lt;- nvd(model = "gnp", n = 10L, model_params = gnp_params)
y &lt;- nvd(model = "k_regular", n = 10L, model_params = k_regular_params)
mb &lt;- c(rep(1, length(x)), rep(2, length(y)))
z &lt;- as_nvd(c(x, y))
ggplot2::autoplot(z, memberships = mb)
plot(z, memberships = mb)
</code></pre>

<hr>
<h2 id='power2'>Power Simulations for Permutation Tests</h2><span id='topic+power2'></span>

<h3>Description</h3>

<p>This function provides a Monte-Carlo estimate of the power of the permutation
tests proposed in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power2(
  model1 = "gnp",
  model2 = "k_regular",
  n1 = 20L,
  n2 = 20L,
  num_vertices = 25L,
  model1_params = NULL,
  model2_params = NULL,
  representation = "adjacency",
  distance = "frobenius",
  stats = c("flipr:t_ip", "flipr:f_ip"),
  B = 1000L,
  alpha = 0.05,
  test = "exact",
  k = 5L,
  R = 1000L,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power2_+3A_model1">model1</code></td>
<td>
<p>A string specifying the model to be used for generating the
first sample. Choices are <code>"sbm"</code>, <code>"k_regular"</code>, <code>"gnp"</code>, <code>"smallworld"</code>,
<code>"pa"</code>, <code>"poisson"</code> and <code>"binomial"</code>. Defaults to <code>"gnp"</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_model2">model2</code></td>
<td>
<p>A string specifying the model to be used for generating the
second sample. Choices are <code>"sbm"</code>, <code>"k_regular"</code>, <code>"gnp"</code>, <code>"smallworld"</code>,
<code>"pa"</code>, <code>"poisson"</code> and <code>"binomial"</code>. Defaults to <code>"k_regular"</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_n1">n1</code></td>
<td>
<p>The size of the first sample. Defaults to <code>20L</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_n2">n2</code></td>
<td>
<p>The size of the second sample. Defaults to <code>20L</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_num_vertices">num_vertices</code></td>
<td>
<p>The number of nodes in the generated graphs. Defaults to
<code>25L</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_model1_params">model1_params</code></td>
<td>
<p>A named list setting the parameters of the first chosen
model. Defaults to <code>list(p = 1/3)</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_model2_params">model2_params</code></td>
<td>
<p>A named list setting the parameters of the second chosen
model. Defaults to <code>list(k = 8L)</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_representation">representation</code></td>
<td>
<p>A string specifying the desired type of representation,
among: <code>"adjacency"</code>, <code>"laplacian"</code> and <code>"modularity"</code>.
Defaults to <code>"adjacency"</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_distance">distance</code></td>
<td>
<p>A string specifying the chosen distance for calculating the
test statistic, among: <code>"hamming"</code>, <code>"frobenius"</code>,
<code>"spectral"</code> and <code>"root-euclidean"</code>. Defaults to
<code>"frobenius"</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_stats">stats</code></td>
<td>
<p>A character vector specifying the chosen test statistic(s),
among: <code>"original_edge_count"</code>, <code>"generalized_edge_count"</code>,
<code>"weighted_edge_count"</code>, <code>"student_euclidean"</code>, <code>"welch_euclidean"</code> or any
statistics based on inter-point distances available in the <strong>flipr</strong>
package: <code>"flipr:student_ip"</code>, <code>"flipr:fisher_ip"</code>, <code>"flipr:bg_ip"</code>,
<code>"flipr:energy_ip"</code>, <code>"flipr:cq_ip"</code>. Defaults to <code>c("flipr:student_ip", "flipr:fisher_ip")</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_b">B</code></td>
<td>
<p>The number of permutation or the tolerance. If this number is lower
than <code>1</code>, it is intended as a tolerance. Otherwise, it is intended as
the number of required permutations. Defaults to <code>1000L</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for hypothesis testing. Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_test">test</code></td>
<td>
<p>A character string specifying the formula to be used to compute
the permutation p-value. Choices are <code>"estimate"</code>, <code>"upper_bound"</code> and
<code>"exact"</code>. Defaults to <code>"exact"</code> which provides exact tests.</p>
</td></tr>
<tr><td><code id="power2_+3A_k">k</code></td>
<td>
<p>An integer specifying the density of the minimum spanning tree used
for the edge count statistics. Defaults to <code>5L</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_r">R</code></td>
<td>
<p>Number of Monte-Carlo trials used to estimate the power. Defaults to
<code>1000L</code>.</p>
</td></tr>
<tr><td><code id="power2_+3A_seed">seed</code></td>
<td>
<p>An integer specifying the random generator seed. Defaults to
'1234.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, six scenarios of pairs of populations are implemented. Scenario 0
allows to make sure that all our permutation tests are exact.
</p>


<h3>Value</h3>

<p>A numeric value estimating the power of the test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnp_params &lt;- list(p = 1/3)
k_regular_params &lt;- list(k = 8L)
power2(
  model1_params = gnp_params,
  model2_params = k_regular_params,
  R = 10,
  B = 100,
  seed = 1234
)
</code></pre>

<hr>
<h2 id='repr_nvd'>Network-Valued to Matrix-Valued Data</h2><span id='topic+repr_nvd'></span>

<h3>Description</h3>

<p>Network-Valued to Matrix-Valued Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_nvd(x, y = NULL, representation = "adjacency")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repr_nvd_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+nvd">nvd</a></code> object.</p>
</td></tr>
<tr><td><code id="repr_nvd_+3A_y">y</code></td>
<td>
<p>An <code><a href="#topic+nvd">nvd</a></code> object. If <code>NULL</code> (default), it is not
taken into account.</p>
</td></tr>
<tr><td><code id="repr_nvd_+3A_representation">representation</code></td>
<td>
<p>A string specifying the requested matrix
representation. Choices are: <code>"adjacency"</code>, <code>"laplacian"</code> or
<code>"modularity"</code>. Default is <code>"adjacency"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnp_params &lt;- list(p = 1/3)
x &lt;- nvd(model = "gnp", n = 10L, model_params = gnp_params)
xm &lt;- repr_nvd(x)
</code></pre>

<hr>
<h2 id='representations'>Network Representation Functions</h2><span id='topic+representations'></span><span id='topic+repr_adjacency'></span><span id='topic+repr_laplacian'></span><span id='topic+repr_modularity'></span><span id='topic+repr_graphon'></span>

<h3>Description</h3>

<p>This is a collection of functions that convert a graph stored as an
<code><a href="igraph.html#topic+igraph">igraph</a></code> object into a desired matrix representation
among adjacency matrix, graph laplacian, modularity matrix or graphon (edge
probability matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_adjacency(network, validate = TRUE)

repr_laplacian(network, validate = TRUE)

repr_modularity(network, validate = TRUE)

repr_graphon(network, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="representations_+3A_network">network</code></td>
<td>
<p>An <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="representations_+3A_validate">validate</code></td>
<td>
<p>A boolean specifying whether the function should check the
class of its input (default: <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric square matrix giving the desired network representation
recorded in the object's class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- igraph::sample_smallworld(1, 25, 3, 0.05)
repr_adjacency(g)
repr_laplacian(g)
repr_modularity(g)
repr_graphon(g)
</code></pre>

<hr>
<h2 id='sample2_sbm'>Two-Sample Stochastic Block Model Generator</h2><span id='topic+sample2_sbm'></span>

<h3>Description</h3>

<p>This function generates two samples of networks according to the stochastic
block model (SBM). This is essentially a wrapper around
<code><a href="igraph.html#topic+sample_sbm">sample_sbm</a></code> which allows to sample a single network from
the SBM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample2_sbm(n, nv, p1, b1, p2 = p1, b2 = b1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample2_sbm_+3A_n">n</code></td>
<td>
<p>Integer scalar giving the sample size.</p>
</td></tr>
<tr><td><code id="sample2_sbm_+3A_nv">nv</code></td>
<td>
<p>Integer scalar giving the number of vertices of the generated
networks, common to all networks in both samples.</p>
</td></tr>
<tr><td><code id="sample2_sbm_+3A_p1">p1</code></td>
<td>
<p>The matrix giving the Bernoulli rates for the 1st sample. This is a
KxK matrix, where K is the number of groups. The probability of creating an
edge between vertices from groups i and j is given by element (i,j). For
undirected graphs, this matrix must be symmetric.</p>
</td></tr>
<tr><td><code id="sample2_sbm_+3A_b1">b1</code></td>
<td>
<p>Numeric vector giving the number of vertices in each group for the
first sample. The sum of the vector must match the number of vertices.</p>
</td></tr>
<tr><td><code id="sample2_sbm_+3A_p2">p2</code></td>
<td>
<p>The matrix giving the Bernoulli rates for the 2nd sample (default:
same as 1st sample). This is a KxK matrix, where K is the number of groups.
The probability of creating an edge between vertices from groups i and j is
given by element (i,j). For undirected graphs, this matrix must be
symmetric.</p>
</td></tr>
<tr><td><code id="sample2_sbm_+3A_b2">b2</code></td>
<td>
<p>Numeric vector giving the number of vertices in each group for the
second sample (default: same as 1st sample). The sum of the vector must
match the number of vertices.</p>
</td></tr>
<tr><td><code id="sample2_sbm_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator (default: <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-2 list containing the two samples stored as
<code><a href="#topic+nvd">nvd</a></code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
p1 &lt;- matrix(
  data = c(0.1, 0.4, 0.1, 0.4,
           0.4, 0.4, 0.1, 0.4,
           0.1, 0.1, 0.4, 0.4,
           0.4, 0.4, 0.4, 0.4),
  nrow = 4,
  ncol = 4,
  byrow = TRUE
)
p2 &lt;- matrix(
  data = c(0.1, 0.4, 0.4, 0.4,
           0.4, 0.4, 0.4, 0.4,
           0.4, 0.4, 0.1, 0.1,
           0.4, 0.4, 0.1, 0.4),
  nrow = 4,
  ncol = 4,
  byrow = TRUE
)
sim &lt;- sample2_sbm(n, 68, p1, c(17, 17, 17, 17), p2, seed = 1234)
</code></pre>

<hr>
<h2 id='samplers'>Graph samplers using edge distributions</h2><span id='topic+samplers'></span><span id='topic+rpois_network'></span><span id='topic+rexp_network'></span><span id='topic+rbinom_network'></span><span id='topic+rsbm'></span>

<h3>Description</h3>

<p>A collection of functions to generate random graphs with specified edge
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpois_network(n, num_vertices, lambda = 1)

rexp_network(n, num_vertices, rate = 1)

rbinom_network(n, num_vertices, size = 1, prob = 0.5)

rsbm(n, num_vertices, pref_matrix, block_sizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samplers_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="samplers_+3A_num_vertices">num_vertices</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="samplers_+3A_lambda">lambda</code></td>
<td>
<p>The mean parameter for the Poisson distribution (default: 1).</p>
</td></tr>
<tr><td><code id="samplers_+3A_rate">rate</code></td>
<td>
<p>The rate parameter for the exponential distribution (default: 1).</p>
</td></tr>
<tr><td><code id="samplers_+3A_size">size</code></td>
<td>
<p>The number of trials for the binomial distribution (default: 1).</p>
</td></tr>
<tr><td><code id="samplers_+3A_prob">prob</code></td>
<td>
<p>The probability of success on each trial for the binomial
distribution (default: 0.5).</p>
</td></tr>
<tr><td><code id="samplers_+3A_pref_matrix">pref_matrix</code></td>
<td>
<p>The matrix giving the Bernoulli rates. This is a KxK
matrix, where K is the number of groups. The probability of creating an
edge between vertices from groups i and j is given by element (i,j). For
undirected graphs, this matrix must be symmetric. See
<code><a href="igraph.html#topic+sample_sbm">sample_sbm</a></code>.</p>
</td></tr>
<tr><td><code id="samplers_+3A_block_sizes">block_sizes</code></td>
<td>
<p>Numeric vector giving the number of vertices in each
group. The sum of the vector must match the number of vertices. See
<code><a href="igraph.html#topic+sample_sbm">sample_sbm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of class <code><a href="#topic+nvd">nvd</a></code> containing the sample of graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nvd &lt;- rexp_network(10, 68)
</code></pre>

<hr>
<h2 id='statistics'>Test Statistics for Network Populations</h2><span id='topic+statistics'></span><span id='topic+stat_student_euclidean'></span><span id='topic+stat_welch_euclidean'></span><span id='topic+stat_original_edge_count'></span><span id='topic+stat_generalized_edge_count'></span><span id='topic+stat_weighted_edge_count'></span>

<h3>Description</h3>

<p>This is a collection of functions that provide statistics for testing
equality in distribution between samples of networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_student_euclidean(d, indices, ...)

stat_welch_euclidean(d, indices, ...)

stat_original_edge_count(d, indices, edge_count_prep, ...)

stat_generalized_edge_count(d, indices, edge_count_prep, ...)

stat_weighted_edge_count(d, indices, edge_count_prep, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statistics_+3A_d">d</code></td>
<td>
<p>Either a matrix of dimension <code class="reqn">(n1+n2)x(n1+n2)</code> containing the
distances between all the elements of the two samples put together (for
distance-based statistics) or the concatenation of the lists of matrix
representations of networks in samples 1 and 2 for Euclidean t-Statistics.</p>
</td></tr>
<tr><td><code id="statistics_+3A_indices">indices</code></td>
<td>
<p>A vector of dimension <code class="reqn">n1</code> containing the indices of the
elements of the first sample.</p>
</td></tr>
<tr><td><code id="statistics_+3A_...">...</code></td>
<td>
<p>Extra parameters specific to some statistics.</p>
</td></tr>
<tr><td><code id="statistics_+3A_edge_count_prep">edge_count_prep</code></td>
<td>
<p>A list of preprocessed data information used by edge
count statistics and produced by <code><a href="#topic+edge_count_global_variables">edge_count_global_variables</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In details, there are three main categories of statistics:
</p>

<ul>
<li> <p><em>Euclidean t-Statistics</em>: both Student <code>stat_student_euclidean</code> version for
equal variances and Welch <code>stat_welch_euclidean</code> version for unequal
variances,
</p>
</li>
<li> <p><em>Statistics based on similarity graphs</em>: 3 types of edge count statistics.
</p>
</li></ul>



<h3>Value</h3>

<p>A scalar giving the value of the desired test statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 30L
n2 &lt;- 10L
gnp_params &lt;- list(p = 1/3)
k_regular_params &lt;- list(k = 8L)
x &lt;- nvd(model = "gnp", n = n1, model_params = gnp_params)
y &lt;- nvd(model = "k_regular", n = n2, model_params = k_regular_params)
r &lt;- repr_nvd(x, y, representation = "laplacian")
stat_student_euclidean(r, 1:n1)
stat_welch_euclidean(r, 1:n1)
d &lt;- dist_nvd(x, y, representation = "laplacian", distance = "frobenius")
ecp &lt;- edge_count_global_variables(d, n1, k = 5L)
stat_original_edge_count(d, 1:n1, edge_count_prep = ecp)
stat_generalized_edge_count(d, 1:n1, edge_count_prep = ecp)
stat_weighted_edge_count(d, 1:n1, edge_count_prep = ecp)
</code></pre>

<hr>
<h2 id='subgraphs'>Full, intra and inter subgraph generators</h2><span id='topic+subgraphs'></span><span id='topic+subgraph_full'></span><span id='topic+subgraph_intra'></span><span id='topic+subgraph_inter'></span>

<h3>Description</h3>

<p>This is a collection of functions for extracting full, intra and inter
subgraphs of a graph given a list of vertex subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph_full(g, vids)

subgraph_intra(g, vids)

subgraph_inter(g, vids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraphs_+3A_g">g</code></td>
<td>
<p>An <code><a href="igraph.html#topic+igraph">igraph</a></code> object.</p>
</td></tr>
<tr><td><code id="subgraphs_+3A_vids">vids</code></td>
<td>
<p>A list of integer vectors identifying vertex subsets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="igraph.html#topic+igraph">igraph</a></code> object storing a subgraph of type
full, intra or inter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- igraph::make_ring(10)
g_full  &lt;- subgraph_full (g, list(1:3, 4:5, 8:10))
g_intra &lt;- subgraph_intra(g, list(1:3, 4:5, 8:10))
g_inter &lt;- subgraph_inter(g, list(1:3, 4:5, 8:10))

</code></pre>

<hr>
<h2 id='test2_global'>Global Two-Sample Test for Network-Valued Data</h2><span id='topic+test2_global'></span>

<h3>Description</h3>

<p>This function carries out an hypothesis test where the null hypothesis is
that the two populations of networks share the same underlying probabilistic
distribution against the alternative hypothesis that the two populations come
from different distributions. The test is performed in a non-parametric
fashion using a permutational framework in which several statistics can be
used, together with several choices of network matrix representations and
distances between networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test2_global(
  x,
  y,
  representation = c("adjacency", "laplacian", "modularity", "transitivity"),
  distance = c("frobenius", "hamming", "spectral", "root-euclidean"),
  stats = c("flipr:t_ip", "flipr:f_ip"),
  B = 1000L,
  test = "exact",
  k = 5L,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test2_global_+3A_x">x</code></td>
<td>
<p>Either an object of class <a href="#topic+nvd">nvd</a> listing networks in sample 1 or a
distance matrix of size <code class="reqn">n_1 + n_2</code>.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_y">y</code></td>
<td>
<p>Either an object of class <a href="#topic+nvd">nvd</a> listing networks in sample 2 or an
integer value specifying the size of sample 1 or an integer vector
specifying the indices of the observations belonging to sample 1.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_representation">representation</code></td>
<td>
<p>A string specifying the desired type of representation,
among: <code>"adjacency"</code>, <code>"laplacian"</code> and <code>"modularity"</code>.
Defaults to <code>"adjacency"</code>.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_distance">distance</code></td>
<td>
<p>A string specifying the chosen distance for calculating the
test statistic, among: <code>"hamming"</code>, <code>"frobenius"</code>,
<code>"spectral"</code> and <code>"root-euclidean"</code>. Defaults to
<code>"frobenius"</code>.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_stats">stats</code></td>
<td>
<p>A character vector specifying the chosen test statistic(s),
among: <code>"original_edge_count"</code>, <code>"generalized_edge_count"</code>,
<code>"weighted_edge_count"</code>, <code>"student_euclidean"</code>, <code>"welch_euclidean"</code> or any
statistics based on inter-point distances available in the <strong>flipr</strong>
package: <code>"flipr:student_ip"</code>, <code>"flipr:fisher_ip"</code>, <code>"flipr:bg_ip"</code>,
<code>"flipr:energy_ip"</code>, <code>"flipr:cq_ip"</code>. Defaults to <code>c("flipr:student_ip", "flipr:fisher_ip")</code>.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_b">B</code></td>
<td>
<p>The number of permutation or the tolerance. If this number is lower
than <code>1</code>, it is intended as a tolerance. Otherwise, it is intended as
the number of required permutations. Defaults to <code>1000L</code>.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_test">test</code></td>
<td>
<p>A character string specifying the formula to be used to compute
the permutation p-value. Choices are <code>"estimate"</code>, <code>"upper_bound"</code> and
<code>"exact"</code>. Defaults to <code>"exact"</code> which provides exact tests.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_k">k</code></td>
<td>
<p>An integer specifying the density of the minimum spanning tree used
for the edge count statistics. Defaults to <code>5L</code>.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_seed">seed</code></td>
<td>
<p>An integer for specifying the seed of the random generator for
result reproducibility. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="test2_global_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to the distance function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with three components: the value of the
statistic for the original two samples, the p-value of the resulting
permutation test and a numeric vector storing the values of the permuted
statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5L
gnp_params &lt;- list(p = 1/3)
k_regular_params &lt;- list(k = 8L)

# Two different models for the two populations
x &lt;- nvd(model = "gnp", n = n, model_params = gnp_params)
y &lt;- nvd(model = "k_regular", n = n, model_params = k_regular_params)
t1 &lt;- test2_global(x, y, representation = "modularity")
t1$pvalue

# Same model for the two populations
x &lt;- nvd(model = "gnp", n = 10L, model_params = gnp_params)
y &lt;- nvd(model = "gnp", n = 10L, model_params = gnp_params)
t2 &lt;- test2_global(x, y, representation = "modularity")
t2$pvalue
</code></pre>

<hr>
<h2 id='test2_local'>Local Two-Sample Test for Network-Valued Data</h2><span id='topic+test2_local'></span>

<h3>Description</h3>

<p>Local Two-Sample Test for Network-Valued Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test2_local(
  x,
  y,
  partition,
  representation = "adjacency",
  distance = "frobenius",
  stats = c("flipr:t_ip", "flipr:f_ip"),
  B = 1000L,
  alpha = 0.05,
  test = "exact",
  k = 5L,
  seed = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test2_local_+3A_x">x</code></td>
<td>
<p>Either an object of class <a href="#topic+nvd">nvd</a> listing networks in sample 1 or a
distance matrix of size <code class="reqn">n_1 + n_2</code>.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_y">y</code></td>
<td>
<p>Either an object of class <a href="#topic+nvd">nvd</a> listing networks in sample 2 or an
integer value specifying the size of sample 1 or an integer vector
specifying the indices of the observations belonging to sample 1.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_partition">partition</code></td>
<td>
<p>Either a list or an integer vector specifying vertex
memberships into partition elements.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_representation">representation</code></td>
<td>
<p>A string specifying the desired type of representation,
among: <code>"adjacency"</code>, <code>"laplacian"</code> and <code>"modularity"</code>.
Defaults to <code>"adjacency"</code>.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_distance">distance</code></td>
<td>
<p>A string specifying the chosen distance for calculating the
test statistic, among: <code>"hamming"</code>, <code>"frobenius"</code>,
<code>"spectral"</code> and <code>"root-euclidean"</code>. Defaults to
<code>"frobenius"</code>.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_stats">stats</code></td>
<td>
<p>A character vector specifying the chosen test statistic(s),
among: <code>"original_edge_count"</code>, <code>"generalized_edge_count"</code>,
<code>"weighted_edge_count"</code>, <code>"student_euclidean"</code>, <code>"welch_euclidean"</code> or any
statistics based on inter-point distances available in the <strong>flipr</strong>
package: <code>"flipr:student_ip"</code>, <code>"flipr:fisher_ip"</code>, <code>"flipr:bg_ip"</code>,
<code>"flipr:energy_ip"</code>, <code>"flipr:cq_ip"</code>. Defaults to <code>c("flipr:student_ip", "flipr:fisher_ip")</code>.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_b">B</code></td>
<td>
<p>The number of permutation or the tolerance. If this number is lower
than <code>1</code>, it is intended as a tolerance. Otherwise, it is intended as
the number of required permutations. Defaults to <code>1000L</code>.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for hypothesis testing. If set to 1, the
function outputs properly adjusted p-values. If lower than 1, then only
p-values lower than alpha are properly adjusted. Defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_test">test</code></td>
<td>
<p>A character string specifying the formula to be used to compute
the permutation p-value. Choices are <code>"estimate"</code>, <code>"upper_bound"</code> and
<code>"exact"</code>. Defaults to <code>"exact"</code> which provides exact tests.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_k">k</code></td>
<td>
<p>An integer specifying the density of the minimum spanning tree used
for the edge count statistics. Defaults to <code>5L</code>.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_seed">seed</code></td>
<td>
<p>An integer for specifying the seed of the random generator for
result reproducibility. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="test2_local_+3A_verbose">verbose</code></td>
<td>
<p>Boolean specifying whether information on intermediate tests
should be printed in the process (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-2 list reporting the adjusted p-values of each element of
the partition for the intra- and inter-tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5L
p1 &lt;- matrix(
  data = c(0.1, 0.4, 0.1, 0.4,
           0.4, 0.4, 0.1, 0.4,
           0.1, 0.1, 0.4, 0.4,
           0.4, 0.4, 0.4, 0.4),
  nrow = 4,
  ncol = 4,
  byrow = TRUE
)
p2 &lt;- matrix(
  data = c(0.1, 0.4, 0.4, 0.4,
           0.4, 0.4, 0.4, 0.4,
           0.4, 0.4, 0.1, 0.1,
           0.4, 0.4, 0.1, 0.4),
  nrow = 4,
  ncol = 4,
  byrow = TRUE
)
sim &lt;- sample2_sbm(n, 68, p1, c(17, 17, 17, 17), p2, seed = 1234)
m &lt;- as.integer(c(rep(1, 17), rep(2, 17), rep(3, 17), rep(4, 17)))
test2_local(sim$x, sim$y, m,
            seed = 1234,
            alpha = 0.05,
            B = 19)
</code></pre>

<hr>
<h2 id='var_nvd'>Fréchet Variance of Network-Valued Data Around a Given Network</h2><span id='topic+var_nvd'></span>

<h3>Description</h3>

<p>This function computes the Fréchet variance around a specified network from
an observed sample of network-valued random variables according to a
specified distance. In most cases, the user is willing to compute the sample
variance, in which case the Fréchet variance has to be evaluated w.r.t. the
sample Fréchet mean. In this case, it is important that the user indicates
the same distance as the one (s)he used to separately compute the sample
Fréchet mean. This function can also be used as is as the function to be
minimized in order to find the Fréchet mean for a given distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_nvd(x, x0, weights = rep(1, length(x)), distance = "frobenius")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_nvd_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+nvd">nvd</a></code> object listing a sample of networks.</p>
</td></tr>
<tr><td><code id="var_nvd_+3A_x0">x0</code></td>
<td>
<p>A network already in matrix representation around which to
calculate variance (usually the Fréchet mean but not necessarily). Note
that the chosen matrix representation is extracted from this parameter.</p>
</td></tr>
<tr><td><code id="var_nvd_+3A_weights">weights</code></td>
<td>
<p>A numeric vector specifying weights for each observation
(default: equally weighted).</p>
</td></tr>
<tr><td><code id="var_nvd_+3A_distance">distance</code></td>
<td>
<p>A string specifying the distance to be used. Possible choices
are: hamming, frobenius, spectral or root-euclidean. Default is frobenius.
When the Fréchet mean is used as <code>x0</code> parameter, the distance should
match the one used to compute the mean. This is not currently checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive scalar value evaluating the amount of variability of the
sample around the specified network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnp_params &lt;- list(p = 1/3)
x &lt;- nvd(model = "gnp", n = 10L, model_params = gnp_params)
m &lt;- mean(x)
var_nvd(x = x, x0 = m, distance = "frobenius")
</code></pre>

<hr>
<h2 id='var2_nvd'>Fréchet Variance of Network-Valued Data from Inter-Point Distances</h2><span id='topic+var2_nvd'></span>

<h3>Description</h3>

<p>This function computes the Fréchet variance using exclusively inter-point
distances. As such, it can accommodate any pair of representation and
distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var2_nvd(x, representation = "adjacency", distance = "frobenius")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var2_nvd_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+nvd">nvd</a></code> object listing a sample of networks.</p>
</td></tr>
<tr><td><code id="var2_nvd_+3A_representation">representation</code></td>
<td>
<p>A string specifying the graph representation to be
used. Choices are adjacency, laplacian, modularity, graphon. Default is
adjacency.</p>
</td></tr>
<tr><td><code id="var2_nvd_+3A_distance">distance</code></td>
<td>
<p>A string specifying the distance to be used. Possible choices
are: hamming, frobenius, spectral or root-euclidean. Default is frobenius.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive scalar value evaluating the variance based on inter-point
distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnp_params &lt;- list(p = 1/3)
x &lt;- nvd(model = "gnp", n = 10L, model_params = gnp_params)
var2_nvd(x = x, representation = "graphon", distance = "frobenius")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
