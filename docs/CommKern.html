<!DOCTYPE html><html lang="en-us"><head><title>Help for package CommKern</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CommKern}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj_RI'><p>Adjusted Rand Index (ARI)</p></a></li>
<li><a href='#CommKern'><p>CommKern</p></a></li>
<li><a href='#community_allegiance'><p>Community Allegiance</p></a></li>
<li><a href='#community_plot'><p>Communities by layer plot</p></a></li>
<li><a href='#compute_modularity_matrix'><p>Compute modularity matrix</p></a></li>
<li><a href='#compute_multimodal_mod'><p>Compute multimodal modularity matrix</p></a></li>
<li><a href='#consensus_similarity'><p>Consensus Similarity</p></a></li>
<li><a href='#count_pairs'><p>Count pairs</p></a></li>
<li><a href='#degree'><p>Node degree calculation</p></a></li>
<li><a href='#entropy'><p>Entropy</p></a></li>
<li><a href='#ext_distance'><p>Extrinsic evaluation distance matrix creation</p></a></li>
<li><a href='#find_start_temp'><p>Starting temperature</p></a></li>
<li><a href='#get_weights'><p>Simulated network edge weights</p></a></li>
<li><a href='#group_adj_perturb'><p>Group adjacency matrices</p></a></li>
<li><a href='#group_network_perturb'><p>Simulated group networks</p></a></li>
<li><a href='#ham_distance'><p>Hamiltonian distance matrix creation</p></a></li>
<li><a href='#heatbath_multimodal'><p>Multimodal heatbath algorithm</p></a></li>
<li><a href='#hms'><p>Hierarchical multimodal spinglass algorithm</p></a></li>
<li><a href='#kernel'><p>Distance-based kernel</p></a></li>
<li><a href='#matrix_plot'><p>Functional and Structural Matrix Plot</p></a></li>
<li><a href='#matrix_to_df'><p>Convert matrices to dataframe list for network</p></a></li>
<li><a href='#NMI'><p>Normalized mutual information (NMI)</p></a></li>
<li><a href='#purity'><p>Purity</p></a></li>
<li><a href='#SBM_net'><p>Simulated functional and structural connectivity with nested</p>
hierarchical community structure</a></li>
<li><a href='#score_cont_nonparam'><p>Nonparametric score function for distance-based kernel and continuous outcome.</p></a></li>
<li><a href='#score_cont_semiparam'><p>Semiparametric score function for distance-based kernel and continuous outcome.</p></a></li>
<li><a href='#score_log_nonparam'><p>Nonparametric score function for distance-based kernel and binary outcome</p></a></li>
<li><a href='#score_log_semiparam'><p>Semiparametric score function for distance-based kernel</p></a></li>
<li><a href='#simasd_array'><p>Simulated Array</p></a></li>
<li><a href='#simasd_comm_df'><p>Simulated partitions of nodes to communities from HMS algorithm</p></a></li>
<li><a href='#simasd_covars'><p>Simulated demographics dataset modeled of a subset of the preprocessed</p>
ABIDE database</a></li>
<li><a href='#simasd_hamil_df'><p>Simulated Hamiltonian values from HMS algorithm</p></a></li>
<li><a href='#simnet_df_perturb'><p>Simulated network data frame</p></a></li>
<li><a href='#sort_pairs'><p>Sort pairs</p></a></li>
<li><a href='#subset_matrix_to_df'><p>Convert matrices to list of data frames for subnetworks</p></a></li>
<li><a href='#tr'><p>Trace</p></a></li>
<li><a href='#up_low'><p>Bounds of grid search function</p></a></li>
<li><a href='#zrand'><p>Rand z-score</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Network-Based Communities and Kernel Machine Methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of network community objects with applications to neuroimaging data. There are two main components to this package. The first is the hierarchical multimodal spinglass (HMS) algorithm, which is a novel community detection algorithm specifically tailored to the unique issues within brain connectivity. The other is a suite of semiparametric kernel machine methods that allow for statistical inference to be performed to test for potential associations between these community structures and an outcome of interest (binary or continuous).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/aljensen89/CommKern">https://github.com/aljensen89/CommKern</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-us</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggnewscale, ggplot2, gridExtra, Matrix, RColorBrewer, reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, matrixcalc, pheatmap, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-22 18:30:47 UTC; jenseale</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandria Jensen <a href="https://orcid.org/0000-0001-6337-9079"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Peter DeWitt <a href="https://orcid.org/0000-0002-6391-0795"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Debashis Ghosh <a href="https://orcid.org/0000-0001-6618-1316"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandria Jensen &lt;alexandria.jensen@cuanschutz.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-23 10:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj_RI'>Adjusted Rand Index (ARI)</h2><span id='topic+adj_RI'></span>

<h3>Description</h3>

<p>Description of the adjusted Rand Index function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_RI(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adj_RI_+3A_a">a</code></td>
<td>
<p>a vector of classifications; this must be a vector of characters,
integers, numerics, or a factor, but not a list.</p>
</td></tr>
<tr><td><code id="adj_RI_+3A_b">b</code></td>
<td>
<p>a vector of classifications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In information theory, the Rand Index (also called the Rand Measure) is a
measure of the similarity between two data clusterings or classifications. If
N is the set of elements and X and Y are the partition of N into n subsets,
then the Rand Index is composed of four subsets: (a) the number of pairs of
elements in N that are in the same subset in in X and the same subset in Y;
(b) the number of pairs of elements in N that are in different subsets in X
and different subsets in Y; (c) the number of pairs of elements in N that
are in the same subset in X but different subsets in Y; and (d) the number of
pairs of elements in N that are in different subsets in X but the same subset
in Y. The adjusted Rand Index is the corrected-for-chance version of the Rand
Index, which establishes a baseline by using the expected similarity of all
pairwise comparisons between clusterings specified by a random model. The ARI
can yield negative results if the index is less than the expected index.
</p>


<h3>Value</h3>

<p>a scalar with the adjusted Rand Index (ARI)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMI">NMI</a></code>, <code><a href="#topic+purity">purity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7)
x &lt;- sample(x = rep(1:3, 4), 12)

set.seed(18)
y &lt;- sample(x = rep(1:3, 4), 12)

adj_RI(x,y)

</code></pre>

<hr>
<h2 id='CommKern'>CommKern</h2><span id='topic+CommKern'></span>

<h3>Description</h3>

<p>The CommKern package provides a streamlined implementation in the design and
analysis of network community structures with specific applications to
neuroimaging data. The hierarchical multimodal spinglass (HMS) algorithm has
been developed as a novel community detection algorithm, while the
semiparametric kernel machine methods allow for statistical inference to be
performed to test for potential associations between these community
structures and an outcome of interest, whether binary or continuous.
</p>
<p>This package was part of Alexandria Jensen's Ph.D. dissertation which was
overseen by her advisor Debashis Ghosh. Peter DeWitt provided extensive
mentorship on the creation of this package.
</p>

<hr>
<h2 id='community_allegiance'>Community Allegiance</h2><span id='topic+community_allegiance'></span>

<h3>Description</h3>

<p>Description of the community allegiance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community_allegiance(comm_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="community_allegiance_+3A_comm_matrix">comm_matrix</code></td>
<td>
<p>a matrix whose first column is the node label/id and all
subsequent columns are different partitions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the community allegiance of each node in a network.
For node i, the stability of its allegiance to community A is calculated as
the number of times where node i belongs to community A, divided by the total
number of runs. This measure is bounded in [0,1], where higher values of
stability indicate that a node belong to a single community across a greater
number of runs.
</p>
<p>The function returns a square matrix whose values are bounded in [0,1],
where higher values in the off diagonal indicate that the two nodes belong
to the same community over a higher proportion of partitions.
</p>


<h3>Value</h3>

<p>a matrix whose values are bounded in [0,1], where higher values 
in the off diagonal indicate that the two nodes belong to the same 
community over a higher proportion of runs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(7)
x &lt;- sample(x = rep(1:3, 4), 12)

set.seed(18)
y &lt;- sample(x = rep(1:3, 4), 12)

set.seed(3)
z &lt;- sample(x = rep(1:3, 4), 12)

xyz_comms &lt;- data.frame(id=seq(1:length(x)),x_comm=x,y_comm=y,z_comm=z)
xyz_alleg &lt;- community_allegiance(xyz_comms)

xyz_melt &lt;- reshape2::melt(xyz_alleg)

ggplot2::ggplot(data = xyz_melt) +
 ggplot2::theme_minimal() +
 ggplot2::aes(x = as.factor(Var1), y = as.factor(Var2), fill = value) +
 ggplot2::geom_tile() +
 ggplot2::xlab('Node') + ggplot2::ylab('Node') +
 ggplot2::ggtitle('Community Allegiance Example') +
 ggplot2::scale_fill_gradient2(
   low  = 'navy',
   high = 'goldenrod1',
   mid  = 'darkturquoise', 
   midpoint = 0.5,
   limit = c(0, 1),
   space = 'Lab', 
   name='')

</code></pre>

<hr>
<h2 id='community_plot'>Communities by layer plot</h2><span id='topic+community_plot'></span>

<h3>Description</h3>

<p>Generate a graphical representation of the communities and layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community_plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="community_plot_+3A_x">x</code></td>
<td>
<p>a <code>spinglass_net</code> object created by <code><a href="#topic+hms">hms</a></code></p>
</td></tr>
<tr><td><code id="community_plot_+3A_...">...</code></td>
<td>
<p>additional arguments from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ancillary function that creates the plots seen in the manuscript,
with a heatmap-style plot on the top panel, derived from a network adjacency
matrix, and a community assignment plot on the bottom panel, separated by
layer.
</p>


<h3>Value</h3>

<p>a <code>gtable</code> object
</p>


<h3>See Also</h3>

<p><code>link{hms}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SBM_net)


# plot with max of two layers
SBM_netcomm &lt;- hms(
  input_net  = SBM_net,
  spins      = 4,
  alpha      = 0,
  coolfact   = 0.90,
  tol  = 0.05,
  max_layers = 2
  )

community_plot(SBM_netcomm)



# plot with three layers
# don't run automatically on CRAN; &gt; 5 seconds
SBM_netcomm &lt;- hms(
  input_net  = SBM_net,
  spins      = 4,
  alpha      = 0,
  coolfact   = 0.90,
  tol  = 0.05,
  max_layers = 3
  )

community_plot(SBM_netcomm)


</code></pre>

<hr>
<h2 id='compute_modularity_matrix'>Compute modularity matrix</h2><span id='topic+compute_modularity_matrix'></span>

<h3>Description</h3>

<p>Description of the compute modularity matrix function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_modularity_matrix(net)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_modularity_matrix_+3A_net">net</code></td>
<td>
<p>a <code>spinglass_net</code> object (see <code><a href="#topic+matrix_to_df">matrix_to_df</a></code> for
more details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the modularity matrix, which is the difference between the
observed adjacency matrix and the expected adjacency matrix (from a null
model). This is only computed for the main component of network information,
not accounting for the guidance. For neuroimaging application, this function
would be computing the modularity matrix for the functional connectivity
aspect of the network object. The function takes in a network object and
returns the modularity matrix.
</p>


<h3>Value</h3>

<p>mod_matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrix_to_df">matrix_to_df</a></code>
</p>

<hr>
<h2 id='compute_multimodal_mod'>Compute multimodal modularity matrix</h2><span id='topic+compute_multimodal_mod'></span>

<h3>Description</h3>

<p>Description of the compute multimodal modularity matrix function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_multimodal_mod(mod_matrix, net, communities, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_multimodal_mod_+3A_mod_matrix">mod_matrix</code></td>
<td>
<p>the modularity matrix output from the
<code><a href="#topic+compute_modularity_matrix">compute_modularity_matrix</a></code> function</p>
</td></tr>
<tr><td><code id="compute_multimodal_mod_+3A_net">net</code></td>
<td>
<p>a network object in list form (see the <code><a href="#topic+matrix_to_df">matrix_to_df</a></code> function for more details)</p>
</td></tr>
<tr><td><code id="compute_multimodal_mod_+3A_communities">communities</code></td>
<td>
<p>the vector of node assignments to communities</p>
</td></tr>
<tr><td><code id="compute_multimodal_mod_+3A_alpha">alpha</code></td>
<td>
<p>a double parameter balancing the use of the guidance matrix in modularity calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the multimodal version of the modularity matrix, which is detailed in the accompanying
manuscript as the following:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i \neq j} M_{ij} \delta(C_i,C_j) - \alpha \sum_{i \neq j} S_{ij} \delta(C_i,C_j).</code>
</p>

<p>This function incorporates both the modularity matrix calculated from the <code><a href="#topic+compute_modularity_matrix">compute_modularity_matrix</a></code>
function and adds the additional component of a guidance matrix. The alpha parameter controls
the extent to which the guidance matrix influences the modularity, where alpha=0 means the
function reverts to the typical modularity calculation and alpha &gt; 0 allows for some influence
of the guidance matrix. The guidance matrix will not penalize the modularity if two nodes are not
connected within it; it will only decrease the modularity if the two nodes have guidance information.
The function takes in a network object, the mod_matrix output from
<code><a href="#topic+compute_modularity_matrix">compute_modularity_matrix</a></code>, a vector of communities, and a parameter
alpha and returns the multimodal modularity matrix.
</p>


<h3>Value</h3>

<p>multimodal modularity matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrix_to_df">matrix_to_df</a></code>, <code><a href="#topic+compute_modularity_matrix">compute_modularity_matrix</a></code>
</p>

<hr>
<h2 id='consensus_similarity'>Consensus Similarity</h2><span id='topic+consensus_similarity'></span>

<h3>Description</h3>

<p>Description of the consensus similarity function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_similarity(comm_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consensus_similarity_+3A_comm_matrix">comm_matrix</code></td>
<td>
<p>a matrix whose columns are different partition and whose
rows are nodes within a network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies a single representative partition from a set of
partitions that is the most similar to the all others. Here, similarity is
taken to be the z-score of the Rand coefficient.
</p>


<h3>Value</h3>

<p>the consensus partition determined by the maximum
average pairwise similarity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(7183)
x &lt;- sample(x = rep(1:3, 4), 12)

y &lt;- sample(x = rep(1:3, 4), 12)

z &lt;- sample(x = rep(1:3, 4), 12)

xyz_comms_mat &lt;- matrix(c(x,y,z),nrow=length(x),ncol=3)
consensus_similarity(xyz_comms_mat)

</code></pre>

<hr>
<h2 id='count_pairs'>Count pairs</h2><span id='topic+count_pairs'></span>

<h3>Description</h3>

<p>Description of the count pairs function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_pairs(a, b, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_pairs_+3A_a">a</code></td>
<td>
<p>a vector of classifications</p>
</td></tr>
<tr><td><code id="count_pairs_+3A_b">b</code></td>
<td>
<p>a vector of classifications</p>
</td></tr>
<tr><td><code id="count_pairs_+3A_order">order</code></td>
<td>
<p>a vector of permutations (coming from the order() function in base R)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to count pairs of integers or factors and identify the pair counts
</p>


<h3>Value</h3>

<p>a list of five different vectors:
</p>

<ul>
<li><p><code>pair_nb</code>: a vector containing counts of nodes within all possible
classification pairs from partitions a and b
</p>
</li>
<li><p><code>pair_a</code>: a vector of the same length as pair_nb, specifying the order
of classifications in pair_nb from partition a
</p>
</li>
<li><p><code>pair_b</code>: a vector of the same length as pair_nb, specifying the order
of classifications in pair_nb from partition b
</p>
</li>
<li><p><code>a_nb</code>: a vector containing counts of nodes within each class for
partition a
</p>
</li>
<li><p><code>b_nb</code>: a vector containing counts of nodes within each class for
partition b
</p>
</li></ul>


<hr>
<h2 id='degree'>Node degree calculation</h2><span id='topic+degree'></span>

<h3>Description</h3>

<p>Description of the node degree calculation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree(adj_matrix_func, adj_matrix_str, vertex_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="degree_+3A_adj_matrix_func">adj_matrix_func</code></td>
<td>
<p>the adjacency matrix for functional connectivity</p>
</td></tr>
<tr><td><code id="degree_+3A_adj_matrix_str">adj_matrix_str</code></td>
<td>
<p>the adjacency matrix for structural connectivity</p>
</td></tr>
<tr><td><code id="degree_+3A_vertex_df">vertex_df</code></td>
<td>
<p>a data frame of node (or vertex) information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ancillary function that calculates the functional and structural degree of each network
node using the functional and structural adjacency matrices, respectively.
</p>


<h3>Value</h3>

<p>a data frame to be incorporated into the network object
</p>

<hr>
<h2 id='entropy'>Entropy</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>Description of the entropy function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entropy_+3A_a">a</code></td>
<td>
<p>a vector of classifications; this must be a vector of characters,
integers, numerics, or a factor, but not a list.</p>
</td></tr>
<tr><td><code id="entropy_+3A_b">b</code></td>
<td>
<p>a vector of classifications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to compute the empirical entropy for two vectors of classifications and the joint entropy
</p>


<h3>Value</h3>

<p>a list of four objects:
</p>

<ul>
<li><p><code>uv</code> the joint entropy
</p>
</li>
<li><p><code>u</code> the conditional entropy of partition <code>a</code>
</p>
</li>
<li><p><code>v</code> the conditional entropy of partition <code>b</code>
</p>
</li>
<li><p><code>sort_pairs</code> the output from the sort_pairs function
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sort_pairs">sort_pairs</a></code>
</p>

<hr>
<h2 id='ext_distance'>Extrinsic evaluation distance matrix creation</h2><span id='topic+ext_distance'></span>

<h3>Description</h3>

<p>Description of the extrinsic evaluation distance matrix creation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ext_distance(comm_df, variant = c("NMI", "adj_RI", "purity"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ext_distance_+3A_comm_df">comm_df</code></td>
<td>
<p>a data frame whose columns are different partitions. All
partitions must have the same set of nodes in order for this function to work
and this data frame should exclude a node ID column for ease of computation.</p>
</td></tr>
<tr><td><code id="ext_distance_+3A_variant">variant</code></td>
<td>
<p>a string in ('NMI', 'Adj_RI', 'purity') that calculates different
extrinsic cluster evaluation metrics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a distance matrix using the community output values
from any community detection algorithm, such as the hierarchical multimodal
spinglass algorithm. Because extrinsic evaluation metrics for clustering
algorithms use the underlying idea of similarity, distance is calculated as
(1-similarity). The use of distance ensures that the distance matrix will be
positive and semi-definite, a requirement for its use in the kernel function.
</p>


<h3>Value</h3>

<p>A m x m (m is the number of partitions) extrinsic evaluation distance
matrix to be used as input for the kernel function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adj_RI">adj_RI</a></code>, <code><a href="#topic+NMI">NMI</a></code>, and <code><a href="#topic+purity">purity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2,2,3,1,3,1,3,3,2,2,1,1)
y &lt;- c(3,3,2,1,1,1,1,2,2,3,2,3)
z &lt;- c(1,1,2,3,2,3,2,1,1,2,3,3)

xyz_comms &lt;- data.frame(x_comm = x, y_comm = y, z_comm = z)
ext_distance(xyz_comms, variant = 'NMI')
ext_distance(xyz_comms, variant = 'adj_RI')
ext_distance(xyz_comms, variant = 'purity')

</code></pre>

<hr>
<h2 id='find_start_temp'>Starting temperature</h2><span id='topic+find_start_temp'></span>

<h3>Description</h3>

<p>Description of the starting temperature function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_start_temp(net, mod_matrix, spins, alpha, ts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_start_temp_+3A_net">net</code></td>
<td>
<p>a <code>spinglass_net</code> object</p>
</td></tr>
<tr><td><code id="find_start_temp_+3A_mod_matrix">mod_matrix</code></td>
<td>
<p>mod_matrix</p>
</td></tr>
<tr><td><code id="find_start_temp_+3A_spins">spins</code></td>
<td>
<p>spins</p>
</td></tr>
<tr><td><code id="find_start_temp_+3A_alpha">alpha</code></td>
<td>
<p>a double parameter balancing the use of the guidance matrix in modularity calculation</p>
</td></tr>
<tr><td><code id="find_start_temp_+3A_ts">ts</code></td>
<td>
<p>the starting temperature for the search, set to 1 within the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within the spinglass algorithm, we would like to start from a temperature
with at least 95 of all proposed spin changes accepted in 50 sweeps over the network.
The function returns the temperature found.
</p>


<h3>Value</h3>

<p>the starting temperature that meets the criteria specified above
</p>

<hr>
<h2 id='get_weights'>Simulated network edge weights</h2><span id='topic+get_weights'></span>

<h3>Description</h3>

<p>Description of the simulated network edge weights function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_weights(network_df, wcr, bcr, bfcr = NA, fuzzy_comms = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_weights_+3A_network_df">network_df</code></td>
<td>
<p>a data frame containing information about network nodes,
their community assignment, and all node dyads, coming from
<code><a href="#topic+simnet_df_perturb">simnet_df_perturb</a></code></p>
</td></tr>
<tr><td><code id="get_weights_+3A_wcr">wcr</code></td>
<td>
<p>within community edge weights, sampled from a beta distribution;
for example, c(8,8) will ask for the within community edge weights to be
sampled from a Beta(8,8) distribution</p>
</td></tr>
<tr><td><code id="get_weights_+3A_bcr">bcr</code></td>
<td>
<p>between community edge weights, sampled from a beta distribution;
for example, c(1,8) will ask for the between community edge weights to be
sampled from a Beta(1,8) distribution</p>
</td></tr>
<tr><td><code id="get_weights_+3A_bfcr">bfcr</code></td>
<td>
<p>fuzzy community edge weights, sampled from a beta distribution;
for example, c(4,8) will ask for the fuzzy community edge weights to be
sampled from a Beta (4,8) distribution</p>
</td></tr>
<tr><td><code id="get_weights_+3A_fuzzy_comms">fuzzy_comms</code></td>
<td>
<p>the communities for which their distinction is 'fuzzy,' or
not as distinct; fuzzy communities tend to have higher between community edge
weights; for example, c('comm_a','comm_c') will create a fuzzy distinction
between communities a and c</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ancillary function that creates a vector of edge weights sampled
from Beta distributions. Within and between community edge weights are each
sampled from a distinct Beta distribution. If 'fuzzy' communities wish to be
created, a third Beta distribution is specified and the communities for which
their distinction is 'fuzzy' also needs to be specified. This vector of edge
weights is then passed to <code><a href="#topic+group_network_perturb">group_network_perturb</a></code> to create the
final simulated network object.
</p>


<h3>Value</h3>

<p>a vector of edge weights associated with the node dyads from the
network data frame
</p>

<hr>
<h2 id='group_adj_perturb'>Group adjacency matrices</h2><span id='topic+group_adj_perturb'></span>

<h3>Description</h3>

<p>Description of the simulated group adjacency matrices function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_adj_perturb(group_network_list, n_nets, n_nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_adj_perturb_+3A_group_network_list">group_network_list</code></td>
<td>
<p>the output from
<code><a href="#topic+group_network_perturb">group_network_perturb</a></code>, which is a list of data frames detailing
nodes, community assignments of each node, and edge weights between each dyad
of nodes</p>
</td></tr>
<tr><td><code id="group_adj_perturb_+3A_n_nets">n_nets</code></td>
<td>
<p>the number of networks simulated</p>
</td></tr>
<tr><td><code id="group_adj_perturb_+3A_n_nodes">n_nodes</code></td>
<td>
<p>the number of nodes in each simulated network (will be the
same across all networks)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the output from the <code><a href="#topic+group_network_perturb">group_network_perturb</a></code>
function, which is a list of data frames summarizing each simulated network,
and creates an array of adjacency matrices. These adjacency matrices can then
be used as input to any community detection algorithm (such as the
hierarchical multimodal spinglass algorithm, <code><a href="#topic+hms">hms</a></code>).
</p>


<h3>Value</h3>

<p>an array of adjacency matrices of dimension (n_nets x n_nodes x n_nodes)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_network_perturb">group_network_perturb</a></code>, <code><a href="#topic+hms">hms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
sim_nofuzzy &lt;-
  group_network_perturb(
    n_nodes = 45,
    n_comm = 3,
    n_nets = 3,
    perturb_prop = 0.1,
    wcr = c(8, 8),
    bcr = c(1.5, 8)
  )

nofuzzy_adj &lt;-
  group_adj_perturb(sim_nofuzzy, n_nets = 3, n_nodes = 45)

if (require(pheatmap)) {
  pheatmap::pheatmap(
    nofuzzy_adj[1,,],
    treeheight_row = FALSE,
    treeheight_col = FALSE
  )
}

# Example 2
sim_fuzzy &lt;-
  group_network_perturb(
    n_nodes = 45,
    n_comm = 3,
    n_nets = 3,
    perturb_prop = 0.1,
    wcr = c(8, 8),
    bcr = c(1.5, 8),
    bfcr = c(3, 8),
    fuzzy_comms = c('comm_b','comm_c')
  )

fuzzy_adj &lt;-
  group_adj_perturb(sim_fuzzy, n_nets = 3, n_nodes = 45)

if (require(pheatmap)) {
  pheatmap::pheatmap(
    fuzzy_adj[2,,],
    treeheight_row = FALSE,
    treeheight_col = FALSE
  )
}

</code></pre>

<hr>
<h2 id='group_network_perturb'>Simulated group networks</h2><span id='topic+group_network_perturb'></span>

<h3>Description</h3>

<p>Description of the simulated group networks function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_network_perturb(
  n_nodes,
  n_comm,
  n_nets,
  perturb_prop,
  wcr,
  bcr,
  bfcr = NA,
  fuzzy_comms = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_network_perturb_+3A_n_nodes">n_nodes</code></td>
<td>
<p>the number of nodes in each simulated network (will be the
same across all networks)</p>
</td></tr>
<tr><td><code id="group_network_perturb_+3A_n_comm">n_comm</code></td>
<td>
<p>the number of communities to be simulated in each network (will
be the same across all networks)</p>
</td></tr>
<tr><td><code id="group_network_perturb_+3A_n_nets">n_nets</code></td>
<td>
<p>the number of networks to simulate</p>
</td></tr>
<tr><td><code id="group_network_perturb_+3A_perturb_prop">perturb_prop</code></td>
<td>
<p>the proportion of network nodes to randomly alter their
community assignment within each network</p>
</td></tr>
<tr><td><code id="group_network_perturb_+3A_wcr">wcr</code></td>
<td>
<p>within community edge weights, sampled from a beta distribution;
for example, c(8,8) will ask for the within
community edge weights to be sampled from a Beta(8,8) distribution</p>
</td></tr>
<tr><td><code id="group_network_perturb_+3A_bcr">bcr</code></td>
<td>
<p>between community edge weights, sampled from a beta distribution;
for example, c(1,8) will ask for the between community edge weights to be
sampled from a Beta(1,8) distribution</p>
</td></tr>
<tr><td><code id="group_network_perturb_+3A_bfcr">bfcr</code></td>
<td>
<p>fuzzy community edge weights, sampled from a beta distribution;
for example, c(4,8) will ask for the fuzzy community edge weights to be
sampled from a Beta (4,8) distribution</p>
</td></tr>
<tr><td><code id="group_network_perturb_+3A_fuzzy_comms">fuzzy_comms</code></td>
<td>
<p>the communities for which their distinction is 'fuzzy,' or
not as distinct; fuzzy communities tend to have higher between community edge
weights; for example, c('comm_a','comm_c') will create a fuzzy distinction
between communities a and c</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a list of simulated networks, of which each network is
in a data.frame format, which describes describes the community assignment
for each node in the network, and simulates the edge weights based on whether
the node dyad is: (a) within the same community; (b) between different
communities, or (c) between different communities, but designated as 'fuzzy'
in their distinction from one another.
</p>
<p>The function returns a list of data.frames detailing the nodes, node dyads,
community assignments, and edge weights for all dyads in each simulated
network.
</p>


<h3>Value</h3>

<p>a list of network data.frames containing nodes, their community
assignment, node dyads, and edge weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_nofuzzy &lt;-
  group_network_perturb(
    n_nodes = 45,
    n_comm = 3,
    n_nets = 3,
    perturb_prop = 0.1,
    wcr = c(8, 8),
    bcr = c(1.5, 8)
  )
head(sim_nofuzzy[[1]])

sim_fuzzy &lt;-
  group_network_perturb(
    n_nodes = 45,
    n_comm = 3,
    n_nets = 3,
    perturb_prop = 0.1,
    wcr = c(8, 8),
    bcr = c(1.5, 8),
    bfcr = c(3, 8),
    fuzzy_comms = c('comm_b', 'comm_c')
  )
head(sim_fuzzy[[2]])

</code></pre>

<hr>
<h2 id='ham_distance'>Hamiltonian distance matrix creation</h2><span id='topic+ham_distance'></span>

<h3>Description</h3>

<p>Description of the Hamiltonian distance matrix creation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ham_distance(hamil_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ham_distance_+3A_hamil_df">hamil_df</code></td>
<td>
<p>a data frame containing two columns, one for network ID and
another containing Hamiltonian values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a distance matrix using the Hamiltonian output values
from a community detection algorithm that implements a Hamiltonian value,
such as the hierarchical multimodal spinglass algorithm. To ensure a
positive, semi-definite matrix (as required for the kernel function), the
absolute difference between Hamiltonian values is calculated.
</p>
<p>The function returns an m x m matrix (where m is the number of networks) to
be used as input for the kernel function.
</p>


<h3>Value</h3>

<p>the Hamiltonian distance matrix to be used as input for the kernel function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hms">hms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hamil_df &lt;- data.frame(id  = seq(1:8),
                       ham = c(-160.5375, -167.8426, -121.7128, -155.7245,
                               -113.9834, -112.5262, -117.9724, -171.374))

ham_distance(hamil_df)

</code></pre>

<hr>
<h2 id='heatbath_multimodal'>Multimodal heatbath algorithm</h2><span id='topic+heatbath_multimodal'></span>

<h3>Description</h3>

<p>Description of the multimodal heatbath algorithm function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatbath_multimodal(net, mod_matrix, spins, alpha, temp, max_sweeps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatbath_multimodal_+3A_net">net</code></td>
<td>
<p>a <code>hms_network</code> object</p>
</td></tr>
<tr><td><code id="heatbath_multimodal_+3A_mod_matrix">mod_matrix</code></td>
<td>
<p>mod_matrix</p>
</td></tr>
<tr><td><code id="heatbath_multimodal_+3A_spins">spins</code></td>
<td>
<p>spins</p>
</td></tr>
<tr><td><code id="heatbath_multimodal_+3A_alpha">alpha</code></td>
<td>
<p>a double parameter balancing the use of the guidance matrix in
modularity calculation</p>
</td></tr>
<tr><td><code id="heatbath_multimodal_+3A_temp">temp</code></td>
<td>
<p>a double parameter found using the find_start_temp() function</p>
</td></tr>
<tr><td><code id="heatbath_multimodal_+3A_max_sweeps">max_sweeps</code></td>
<td>
<p>an integer parameter of the maximum number of sweeps
allowed at each temperature</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is one of the two workhorse functions for the algorithm. The heatbath
algorithm selects a network node at random, calculates the multimodal
modularity for the current configuration, and then switches its community
assignment to each possible community. If the modularity of this iterated
configuration is less than the current configuration, the new configuration
is accepted and the algorithm moves on to the next randomly chosen node. If
this is not the case, the node is moved to the new community assignment with
some probability, which is a function of the current modularity value, the
iterated value, and the system's temperature. Once the algorithm finishes
with the randomly chosen node, this counts as a sweep. A new sweep occurs,
with the same steps taken as above, until the sweep number maxes out (usually
set to 50 to balance computation time with robustness).
</p>


<h3>Value</h3>

<p>acceptance value of the algorithm for the given temperature
</p>

<hr>
<h2 id='hms'>Hierarchical multimodal spinglass algorithm</h2><span id='topic+hms'></span>

<h3>Description</h3>

<p>Description of the hierarchical multimodal spinglass algorithm function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hms(input_net, spins, alpha, coolfact, tol, max_layers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hms_+3A_input_net">input_net</code></td>
<td>
<p>a <code>spinglass_net</code> object (see
<code><a href="#topic+matrix_to_df">matrix_to_df</a></code> for more details)</p>
</td></tr>
<tr><td><code id="hms_+3A_spins">spins</code></td>
<td>
<p>an integer indicating the maximum number of spins, or
communities, that can be used</p>
</td></tr>
<tr><td><code id="hms_+3A_alpha">alpha</code></td>
<td>
<p>a double parameter balancing the use of the guidance matrix in
modularity calculation</p>
</td></tr>
<tr><td><code id="hms_+3A_coolfact">coolfact</code></td>
<td>
<p>a double parameter that indicates how quickly (or slowly) to
cool the heatbath algorithm, typically set to be 0.95-0.99</p>
</td></tr>
<tr><td><code id="hms_+3A_tol">tol</code></td>
<td>
<p>a double parameter that indicates the tolerance level of accepting
the proposed changes within a temperature; at the end of each sweep, the number
of proposed changes to the partition is assessed to see if it exceeds a threshold
determined as a function of tol and spins, typically set to be 0.01-0.05</p>
</td></tr>
<tr><td><code id="hms_+3A_max_layers">max_layers</code></td>
<td>
<p>an integer parameter that specifies the maximum number of
layers of communities within the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function of the algorithm. After running checks on the input
parameters, the algorithm begins on the first layer of the network, finding
the optimal configuration of nodes to communities using the heatbath
algorithm. Once the community assignments have been finalized, the set of
nodes within each of these communities is broken up and become their own
subnetworks, on which the algorithm is applied again to get further
subnetwork community assignments. This continues until the maximum number of
layers is reached.
</p>


<h3>Value</h3>

<p>a list of two components: comm_layers_tree, a dataframe whose first
column is the node id and all subsequent columns are the partitioning of the
nodes to communities across the number of pre-specified layers; and
best_hamiltonian, a vector of the optimized Hamiltonian values for each
run of the algorithm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrix_to_df">matrix_to_df</a></code>, <code><a href="#topic+community_plot">community_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hms_object &lt;-
  hms(input_net = SBM_net, 
      spins = 4,
      alpha = 0,
      coolfact = 0.90,
      tol = 0.05,
      max_layers = 1)

str(hms_object)
str(hms_object$comm_layers_tree)
str(hms_object$net)

identical(SBM_net, hms_object$net)
hms_object$net$vertexes

community_plot(hms_object)
  
</code></pre>

<hr>
<h2 id='kernel'>Distance-based kernel</h2><span id='topic+kernel'></span>

<h3>Description</h3>

<p>Description of the distance-based kernel function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel(mat, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_+3A_mat">mat</code></td>
<td>
<p>a distance-based matrix</p>
</td></tr>
<tr><td><code id="kernel_+3A_rho">rho</code></td>
<td>
<p>a bandwidth/scaling parameter whose optimal value is solved for
within the larger score function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ancillary function that is passed into the score function, used
for calculating the distance-based kernel.
</p>
<p>The function returns an m x m matrix (where m is the number of networks) to
be used as input for the kernel function.
</p>


<h3>Value</h3>

<p>the value of the kernel
</p>

<hr>
<h2 id='matrix_plot'>Functional and Structural Matrix Plot</h2><span id='topic+matrix_plot'></span>

<h3>Description</h3>

<p>Provide a graphical representation of the functional and structural matrices
within a <code>spinglass_net</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_plot_+3A_x">x</code></td>
<td>
<p>a <code>spinglass_net</code> object</p>
</td></tr>
<tr><td><code id="matrix_plot_+3A_...">...</code></td>
<td>
<p>additional arguments from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>gtable</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SBM_net)

matrix_plot(SBM_net)

</code></pre>

<hr>
<h2 id='matrix_to_df'>Convert matrices to dataframe list for network</h2><span id='topic+matrix_to_df'></span>

<h3>Description</h3>

<p>Description of the convert matrices to data frame list for network function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_df(func_mat, str_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_to_df_+3A_func_mat">func_mat</code></td>
<td>
<p>a square, symmetric matrix to be used as the main input
for the <code><a href="#topic+hms">hms</a></code> algorithm. For brain connectivity, this will be
a representation of functional (e.g., BOLD) connectivity.</p>
</td></tr>
<tr><td><code id="matrix_to_df_+3A_str_mat">str_mat</code></td>
<td>
<p>a square, symmetric matrix to be used as the guidance
input for the <code><a href="#topic+hms">hms</a></code> algorithm. For brain connectivity, this 
will be a representation of structural (e.g., white matter) connectivity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ancillary function that creates a data frame list for the initial
network. This is the form of the network used for the spinglass algorithm
</p>


<h3>Value</h3>

<p>A list containing the functional matrix, structural matrix, a data
frame of the functional edge weights, a data frame of the structural edge
weights, and nodal information (functional degree, structural degree,
community assignment, and label information)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the example data SBM_net$func_matrix and SBM_net$str_mat
net &lt;- matrix_to_df(SBM_net$func_mat, SBM_net$str_mat)
str(net)
identical(net, SBM_net)

</code></pre>

<hr>
<h2 id='NMI'>Normalized mutual information (NMI)</h2><span id='topic+NMI'></span>

<h3>Description</h3>

<p>Description of the normalized mutual information function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMI(a, b, variant = c("max", "min", "sqrt", "sum", "joint"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NMI_+3A_a">a</code></td>
<td>
<p>a vector of classifications; this must be a vector of characters,
integers, numerics, or a factor, but not a list.</p>
</td></tr>
<tr><td><code id="NMI_+3A_b">b</code></td>
<td>
<p>a vector of classifications</p>
</td></tr>
<tr><td><code id="NMI_+3A_variant">variant</code></td>
<td>
<p>a string in ('max', 'min', 'sqrt', 'sum', 'joint') that
calculates different variants of the NMI. The default use is 'max'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In information theory, the mutual information (MI) of two random variables is
a measure of the mutual dependence between two variables, or the
quantification of the 'amount of information' obtained about one random
variable by observing the other random variable. The normalization of the MI
score scales the results between 0 (no mutual information) and 1 (perfect
correlation). The five options for the variant - max, min, square root, sum,
and joint - all relate to the denominator of the NMI = MI / D.
</p>


<h3>Value</h3>

<p>a scalar with the normalized mutual information (NMI).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adj_RI">adj_RI</a></code>, <code><a href="#topic+purity">purity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 3, 1, 2, 3, 3, 3, 2, 1, 2, 1, 2)
y &lt;- c(1, 1, 2, 3, 2, 1, 3, 1, 2, 3, 3, 2)

NMI(x, y, variant = 'max')
NMI(x, y, variant = 'min')
NMI(x, y, variant = 'sqrt')
NMI(x, y, variant = 'sum')
NMI(x, y, variant = 'joint')

x &lt;- c("A", "A", "A", "A", "B", "C", "A", "B", "B", "C")
y &lt;- c("B", "A", "A", "A", "C", "C", "B", "C", "D", "D")
NMI(x, y, variant = 'max')
NMI(x, y, variant = 'min')
NMI(x, y, variant = 'sqrt')
NMI(x, y, variant = 'sum')
NMI(x, y, variant = 'joint')

</code></pre>

<hr>
<h2 id='purity'>Purity</h2><span id='topic+purity'></span>

<h3>Description</h3>

<p>Description of the purity function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purity(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="purity_+3A_a">a</code></td>
<td>
<p>a vector of classifications; this must be a vector of characters,
integers, numerics, or a factor, but not a list.</p>
</td></tr>
<tr><td><code id="purity_+3A_b">b</code></td>
<td>
<p>a vector of classifications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In information theory, purity is an external evaluation criterion of cluster
quality. It is the percent of the total number of objects (data points) that
were classified in the range of [0,1]. Because we lack a ground truth
partition, a harmonic mean is calculated, where we consider partition a to be
the ground truth and then consider partition b to be the ground truth.
</p>


<h3>Value</h3>

<p>a scalar with the harmonic mean of the purity
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adj_RI">adj_RI</a></code>, <code><a href="#topic+NMI">NMI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7)
x &lt;- sample(x = rep(1:3, 4), 12)

set.seed(18)
y &lt;- sample(x = rep(1:3, 4), 12)

purity(x,y)

</code></pre>

<hr>
<h2 id='SBM_net'>Simulated functional and structural connectivity with nested 
hierarchical community structure</h2><span id='topic+SBM_net'></span>

<h3>Description</h3>

<p>A dataset containing multimodal network information simulated to emulate 
functional and structural brain connectivity data with a nested hierarchical
community structure. This dataset is a list containing five components in a
format used as an input to the <code><a href="#topic+hms">hms</a></code> function. The components,
and their associated variables, are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SBM_net
</code></pre>


<h3>Format</h3>

<p>A list containing five components:
</p>

<dl>
<dt>func_edges</dt><dd><p>a dataframe containing 1233 rows and 3 columns: func_start_node,
func_end_node, and func_weight. This dataframe describes the pairwise functional
edge weights between nodes.</p>
</dd>
<dt>str_edges</dt><dd><p>a dataframe containing 453 rows and 3 columns: str_start_node,
str_end_node, and str_weight. This dataframe describes the pairwise structural
edge weights between nodes. There are fewer rows to this dataframe than func_edges
as structural connectivity tends to be sparser than functional connectivity.</p>
</dd>
<dt>vertexes</dt><dd><p>a dataframe containing 80 rows and 5 columns: node_id, node_label,
func_degree, str_degree, and community. The degree of a node is the sum of all edge
weights connected to the node. In this simulated network, node_label is left as NA
but, for other networks, a specific label may be used to denote additional information
about the node. The community variable is left blank but is used by the <code><a href="#topic+hms">hms</a></code>
algorithm.</p>
</dd>
<dt>func_matrix</dt><dd><p>an 80 x 80 matrix in the style of a network adjacency matrix. It
contains the same information as func_edges, just in a wide, rather than long, format.</p>
</dd>
<dt>str_matrix</dt><dd><p>an 80 x 80 matrix in the style of a network adjacency matrix. It
contains the same information as str_edges, just in a wide, rather than long, format.</p>
</dd>
</dl>


<hr>
<h2 id='score_cont_nonparam'>Nonparametric score function for distance-based kernel and continuous outcome.</h2><span id='topic+score_cont_nonparam'></span>

<h3>Description</h3>

<p>Description of the nonparametric score function for distance-based kernel
function and continuous outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_cont_nonparam(outcome, dist_mat, grid_gran = 5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_cont_nonparam_+3A_outcome">outcome</code></td>
<td>
<p>a numeric vector containing the continuous outcome variable (in the same ID order as dist_mat)</p>
</td></tr>
<tr><td><code id="score_cont_nonparam_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a square distance matrix</p>
</td></tr>
<tr><td><code id="score_cont_nonparam_+3A_grid_gran">grid_gran</code></td>
<td>
<p>a numeric value specifying the grid search length, preset to 5000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function that calculates the p-value associated with a
nonparametric kernel test of association between the kernel and continuous
outcome variable. A null model (where the kernel is not associated with the
outcome) is initially fit. Then, the variance of
<code class="reqn">Y_{i}|X_{i}</code> is used as the basis for the
score test,
</p>
<p style="text-align: center;"><code class="reqn">S\left(\rho\right) = \frac{Q_{\tau}\left(\hat{\beta_0},\rho\right)-\mu_Q}{\sigma_Q}.</code>
</p>

<p>However,
because <code class="reqn">\rho</code> disappears under the null hypothesis, we run a grid search over a range of values of <code class="reqn">\rho</code> (the bounds
of which were derived by Liu et al. in 2008). This grid search gets the upper bound for the score test's p-value.
This function is tailored for the underlying model
</p>
<p style="text-align: center;"><code class="reqn">y_{i} = h\left(z_{i}\right) + e_{i},</code>
</p>

<p>where
<code class="reqn">h\left(\cdot\right)</code> is
the kernel function, <code class="reqn">z_{i}</code> is a multidimensional array of variables, and <code class="reqn">y_{i}</code> is a continuous outcome taking values in
in the real numbers.
</p>
<p>The function returns an numeric p-value for the kernel score test of association.
</p>


<h3>Value</h3>

<p>the score function p-value
</p>


<h3>References</h3>

<p>Liu D, Ghosh D, and Lin X (2008) &quot;Estimation and testing for the effect of a
genetic pathway on a disease outcome using logistic kernel machine regression via
logistic mixed models.&quot; BMC Bioinformatics, 9(1), 292. ISSN 1471-2105.
<a href="https://doi.org/10.1186/1471-2105-9-292">doi:10.1186/1471-2105-9-292</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hms">hms</a></code>, <code><a href="#topic+ext_distance">ext_distance</a></code>, <code><a href="#topic+ham_distance">ham_distance</a></code>
<code><a href="#topic+score_log_semiparam">score_log_semiparam</a></code> for semiparametric score function of distance-based kernel functions and binary outcome.
<code><a href="#topic+score_log_nonparam">score_log_nonparam</a></code> for nonparametric score function of distance-based kernel functions and binary outcome.
<code><a href="#topic+score_cont_semiparam">score_cont_semiparam</a></code> for semiparametric score function of distance-based kernel function and continuous outcome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simasd_hamil_df)
data(simasd_covars)

hamil_matrix &lt;- ham_distance(simasd_hamil_df)


score_cont_nonparam(
  dist_mat = hamil_matrix,
  outcome = simasd_covars$verbal_IQ,
  grid_gran = 5000
)


</code></pre>

<hr>
<h2 id='score_cont_semiparam'>Semiparametric score function for distance-based kernel and continuous outcome.</h2><span id='topic+score_cont_semiparam'></span>

<h3>Description</h3>

<p>Description of the semiparametric score function for distance-based kernel function and continuous outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_cont_semiparam(outcome, covars, dist_mat, grid_gran = 5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_cont_semiparam_+3A_outcome">outcome</code></td>
<td>
<p>a numeric vector containing the continuous outcome variable (in the same ID order as dist_mat)</p>
</td></tr>
<tr><td><code id="score_cont_semiparam_+3A_covars">covars</code></td>
<td>
<p>a data frame containing the covariates to be modeled parametrically (should NOT include an ID variable)</p>
</td></tr>
<tr><td><code id="score_cont_semiparam_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a square distance matrix</p>
</td></tr>
<tr><td><code id="score_cont_semiparam_+3A_grid_gran">grid_gran</code></td>
<td>
<p>a numeric value specifying the grid search length, preset to 5000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function that calculates the p-value associated with a semiparametric kernel test
of association between the kernel and continuous outcome variable. A null model (where the kernel is not
associated with the outcome) is initially fit. Then, the variance of
<code class="reqn">Y_{i}|X_{i}</code> is used as the basis for the
score test,
</p>
<p style="text-align: center;"><code class="reqn">S\left(\rho\right) = \frac{Q_{\tau}\left(\hat{\beta_0},\rho\right)-\mu_Q}{\sigma_Q}.</code>
</p>

<p>However,
because <code class="reqn">\rho</code> disappears under the null hypothesis, we run a grid search over a range of values of <code class="reqn">\rho</code> (the bounds
of which were derived by Liu et al. in 2008). This grid search gets the upper bound for the score test's p-value.
This function is tailored for the underlying model
</p>
<p style="text-align: center;"><code class="reqn">y_{i} = x_{i}^{T}\beta + h\left(z_{i}\right) + e_{i},</code>
</p>

<p>where <code class="reqn">h\left(\cdot\right)</code> is
the kernel function, <code class="reqn">z_{i}</code> is a multidimensional array of variables, <code class="reqn">x_{i}</code> is a vector or matrix of covariates, <code class="reqn">\beta</code> is a vector
of regression coefficients, and <code class="reqn">y_{i}</code> is a continuous outcome taking values in the real numbers.
</p>


<h3>Value</h3>

<p>the score function p-value for the kernel score test of association.
</p>


<h3>References</h3>

<p>Liu D, Ghosh D, and Lin X (2008) &quot;Estimation and testing for the effect of a
genetic pathway on a disease outcome using logistic kernel machine regression via
logistic mixed models.&quot; BMC Bioinformatics, 9(1), 292. ISSN 1471-2105.
<a href="https://doi.org/10.1186/1471-2105-9-292">doi:10.1186/1471-2105-9-292</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hms">hms</a></code>, <code><a href="#topic+ext_distance">ext_distance</a></code>, <code><a href="#topic+ham_distance">ham_distance</a></code>
<code><a href="#topic+score_log_semiparam">score_log_semiparam</a></code> for semiparametric score function of distance-based kernel functions and binary outcome.
<code><a href="#topic+score_log_nonparam">score_log_nonparam</a></code> for nonparametric score function of distance-based kernel functions and binary outcome.
<code><a href="#topic+score_cont_nonparam">score_cont_nonparam</a></code> for nonparametric score function of distance-based kernel function and continuous outcome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simasd_hamil_df)
data(simasd_covars)

hamil_matrix &lt;- ham_distance(simasd_hamil_df)
covars_df &lt;- simasd_covars[,3:4]


score_cont_semiparam(
  outcome   = simasd_covars$verbal_IQ,
  covars    = covars_df,
  dist_mat  = hamil_matrix,
  grid_gran = 5000
  )


</code></pre>

<hr>
<h2 id='score_log_nonparam'>Nonparametric score function for distance-based kernel and binary outcome</h2><span id='topic+score_log_nonparam'></span>

<h3>Description</h3>

<p>Description of the nonparametric score function for distance-based kernel function and a binary outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_log_nonparam(outcome, dist_mat, grid_gran = 5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_log_nonparam_+3A_outcome">outcome</code></td>
<td>
<p>a numeric vector containing the binary outcome variable, 0/1 (in the same ID order as dist_mat)</p>
</td></tr>
<tr><td><code id="score_log_nonparam_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a square distance matrix</p>
</td></tr>
<tr><td><code id="score_log_nonparam_+3A_grid_gran">grid_gran</code></td>
<td>
<p>a numeric value specifying the grid search length, preset to 5000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function that calculates the p-value associated with a nonparametric kernel test
of association between the kernel and binary outcome variable. A null model (where the kernel is not
associated with the outcome) is initially fit. Then, the variance of
<code class="reqn">Y_{i}|X_{i}</code>
is used as the basis for the score test,
</p>
<p style="text-align: center;"><code class="reqn">S\left(\rho\right) = \frac{Q_{\tau}\left(\hat{\beta_0},\rho\right)-\mu_Q}{\sigma_Q}.</code>
</p>

<p>However, because <code class="reqn">\rho</code> disappears under the null hypothesis, we run a
grid search over a range of values of <code class="reqn">\rho</code> (the bounds
of which were derived by Liu et al. in 2008). This grid search gets the upper bound for the score test's p-value.
This function is tailored for the underlying model
</p>
<p style="text-align: center;"><code class="reqn">y_{i} = h\left(z_{i}\right) + e_{i},</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">h\left(\cdot\right)</code>
</p>
<p> is
the kernel function, <code class="reqn">z_{i}</code> is a multidimensional array of variables, and <code class="reqn">y_{i}</code> is a binary outcome taking values in
0, 1.
</p>
<p>The function returns an numeric p-value for the kernel score test of association.
</p>


<h3>Value</h3>

<p>the score function p-value
</p>


<h3>References</h3>

<p>Liu D, Ghosh D, and Lin X (2008) &quot;Estimation and testing for the effect of a
genetic pathway on a disease outcome using logistic kernel machine regression via
logistic mixed models.&quot; BMC Bioinformatics, 9(1), 292. ISSN 1471-2105.
<a href="https://doi.org/10.1186/1471-2105-9-292">doi:10.1186/1471-2105-9-292</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hms">hms</a></code>, <code><a href="#topic+ext_distance">ext_distance</a></code>, <code><a href="#topic+ham_distance">ham_distance</a></code>
<code><a href="#topic+score_log_semiparam">score_log_semiparam</a></code> for semiparametric score function of distance-based kernel functions and binary outcome.
<code><a href="#topic+score_cont_nonparam">score_cont_nonparam</a></code> for nonparametric score function of distance-based kernel function and continuous outcome.
<code><a href="#topic+score_cont_semiparam">score_cont_semiparam</a></code> for semiparametric score function of distance-based kernel function and continuous outcome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simasd_hamil_df)
data(simasd_covars)

hamil_matrix &lt;- ham_distance(simasd_hamil_df)


score_log_nonparam(
  outcome   = simasd_covars$dx_group,
  dist_mat  = hamil_matrix,
  grid_gran = 5000
  )


</code></pre>

<hr>
<h2 id='score_log_semiparam'>Semiparametric score function for distance-based kernel</h2><span id='topic+score_log_semiparam'></span>

<h3>Description</h3>

<p>Description of the semiparametric score function for distance-based kernel function and binary outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_log_semiparam(outcome, covars, dist_mat, grid_gran = 5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_log_semiparam_+3A_outcome">outcome</code></td>
<td>
<p>a numeric vector containing the binary outcome variable, 0/1 (in the same ID order as dist_mat)</p>
</td></tr>
<tr><td><code id="score_log_semiparam_+3A_covars">covars</code></td>
<td>
<p>a dataframe containing the covariates to be modeled parametrically (should NOT include an ID variable)</p>
</td></tr>
<tr><td><code id="score_log_semiparam_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a square distance matrix</p>
</td></tr>
<tr><td><code id="score_log_semiparam_+3A_grid_gran">grid_gran</code></td>
<td>
<p>a numeric value specifying the grid search length, preset to 5000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function that calculates the p-value associated with a semiparametric kernel test
of association between the kernel and binary outcome variable. A null model (where the kernel is not
associated with the outcome) is initially fit. Then, the variance of
<code class="reqn">Y_{i}|X_{i}</code>
is used as the basis for the score test,
</p>
<p style="text-align: center;"><code class="reqn">S\left(\rho\right) = \frac{Q_{\tau}\left(\hat{\beta_0},\rho\right)-\mu_Q}{\sigma_Q}</code>
</p>
<p>.
However, because <code class="reqn">\rho</code> disappears under the null hypothesis, we
run a grid search over a range of values of <code class="reqn">\rho</code> (the bounds
of which were derived by Liu et al. in 2008). This grid search gets the upper bound for the score test's p-value.
This function is tailored for the underlying model
</p>
<p style="text-align: center;"><code class="reqn">y_{i} = x_{i}^{T}\beta + h\left(z_{i}\right) + e_{i},</code>
</p>

<p>where <code class="reqn">h\left(\cdot\right)</code> is
the kernel function, <code class="reqn">z_{i}</code> is a multidimensional array of variables,
<code class="reqn">x_{i}</code> is a vector or matrix of covariates, <code class="reqn">\beta</code> is a vector
of regression coefficients, and <code class="reqn">y_{i}</code> is a binary outcome taking
values in 0, 1.
</p>
<p>The function returns an numeric p-value for the kernel score test of association.
</p>


<h3>Value</h3>

<p>the score function p-value
</p>


<h3>References</h3>

<p>Liu D, Ghosh D, and Lin X (2008) &quot;Estimation and testing for the effect of a
genetic pathway on a disease outcome using logistic kernel machine regression via
logistic mixed models.&quot; BMC Bioinformatics, 9(1), 292. ISSN 1471-2105.
<a href="https://doi.org/10.1186/1471-2105-9-292">doi:10.1186/1471-2105-9-292</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hms">hms</a></code>, <code><a href="#topic+ext_distance">ext_distance</a></code>, <code><a href="#topic+ham_distance">ham_distance</a></code>
<code><a href="#topic+score_log_nonparam">score_log_nonparam</a></code> for nonparametric score function of distance-based kernel functions and binary outcome.
<code><a href="#topic+score_cont_nonparam">score_cont_nonparam</a></code> for nonparametric score function of distance-based kernel function and continuous outcome.
<code><a href="#topic+score_cont_semiparam">score_cont_semiparam</a></code> for semiparametric score function of distance-based kernel function and continuous outcome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(simasd_hamil_df)
data(simasd_covars)

hamil_matrix &lt;- ham_distance(simasd_hamil_df)
covars_df &lt;- simasd_covars[,3:4]


score_log_semiparam(
  outcome   = simasd_covars$dx_group,
  covars    = covars_df,
  dist_mat  = hamil_matrix,
  grid_gran = 5000
  )


</code></pre>

<hr>
<h2 id='simasd_array'>Simulated Array</h2><span id='topic+simasd_array'></span>

<h3>Description</h3>

<p>A dataset containing an array of simulated adjacency matrices. The dimensions of
each matrix is 80 x 80, for a total of 49 simulated networks. This simulated array
is the basis of the simasd_hamil_df and simasd_comm_df datasets and is 
complementary to the simasd_covars dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simasd_array
</code></pre>


<h3>Format</h3>

<p>An array of dimensions 49 x 80 x 80, denoting matrices for 49 simulated
networks, with each network's matrix corresponding to an adjacency matrix for 
an 80 node network.
</p>

<hr>
<h2 id='simasd_comm_df'>Simulated partitions of nodes to communities from HMS algorithm</h2><span id='topic+simasd_comm_df'></span>

<h3>Description</h3>

<p>A dataset of partitions of nodes to communities from simulated group-level
networks with community structures. This dataset is complementary to the
simasd_covars dataset, which contains the demographic information related
to this dataset. For more information on how these group-level networks 
were simulated, please refer to the example script titled &quot;beta_simulation_data.set.R&quot;.
The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simasd_comm_df
</code></pre>


<h3>Format</h3>

<p>A dataframe with 80 rows and 49 columns, where rows correspond to
nodes within the simulated networks and columns correspond to the subject ID.
</p>

<hr>
<h2 id='simasd_covars'>Simulated demographics dataset modeled of a subset of the preprocessed 
ABIDE database</h2><span id='topic+simasd_covars'></span>

<h3>Description</h3>

<p>A dataset of demographics generated based on summary statistics for a subset
of the ABIDE preprocessed database (http://preprocessed-connectomes-project.org/abide/).
The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simasd_covars
</code></pre>


<h3>Format</h3>

<p>A dataframe with 49 rows and 8 columns:
</p>

<dl>
<dt>id</dt><dd><p>a generic ID, an integer value</p>
</dd>
<dt>dx_group</dt><dd><p>diagnostic group (0=control, 1=Autism Spectrum Disorder (ASD)</p>
</dd>
<dt>sex</dt><dd><p>subject sex (0=male, 1=female)</p>
</dd>
<dt>age</dt><dd><p>subject age in years</p>
</dd>
<dt>handedness</dt><dd><p>subject handedness category, a factor with three level
(0=right, 1=left, 2=ambidextrous)</p>
</dd>
<dt>fullscale_IQ</dt><dd><p>fullscale IQ score, simulated as if administered from the
Wechsler Abbreviated Scales of Intelligence (WASI), an integer value in (50,160)</p>
</dd>
<dt>verbal_IQ</dt><dd><p>verbal IQ component, simulated as if administered from the
Wechsler Abbreviated Scales of Intelligence (WASI), an integer value in (55,160)</p>
</dd>
<dt>nonverbal_IQ</dt><dd><p>nonverbal IQ component, simulated as if administered from the
Wechsler Abbreviated Scales of Intelligence (WASI), an integer value in (53,160)</p>
</dd>
</dl>


<hr>
<h2 id='simasd_hamil_df'>Simulated Hamiltonian values from HMS algorithm</h2><span id='topic+simasd_hamil_df'></span>

<h3>Description</h3>

<p>A dataset of Hamiltonian values from simulated group-level networks with
community structure. This dataset is complementary to the simasd_covars
dataset, which contains the demographic information related to this dataset.
For more information on how these group-level networks were simulated, please
refer to the example script titled &quot;beta_simulation_data.set.R&quot;.
The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simasd_hamil_df
</code></pre>


<h3>Format</h3>

<p>A dataframe with 49 rows and 2 columns:
</p>

<dl>
<dt>id</dt><dd><p>a generic ID, corresponding to the id variable in simasd_covars</p>
</dd>
<dt>hamil</dt><dd><p>Hamiltonian value calculated from running the simulated network through the
HMS algorithm, a numeric value</p>
</dd>
</dl>


<hr>
<h2 id='simnet_df_perturb'>Simulated network data frame</h2><span id='topic+simnet_df_perturb'></span>

<h3>Description</h3>

<p>Description of the simulated network data frame function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simnet_df_perturb(n_nodes, n_comm, n_nets, perturb_prop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simnet_df_perturb_+3A_n_nodes">n_nodes</code></td>
<td>
<p>the number of nodes in each simulated network (will be the
same across all networks)</p>
</td></tr>
<tr><td><code id="simnet_df_perturb_+3A_n_comm">n_comm</code></td>
<td>
<p>the number of communities to be simulated in each network (will
be the same across all networks)</p>
</td></tr>
<tr><td><code id="simnet_df_perturb_+3A_n_nets">n_nets</code></td>
<td>
<p>the number of networks to simulate</p>
</td></tr>
<tr><td><code id="simnet_df_perturb_+3A_perturb_prop">perturb_prop</code></td>
<td>
<p>the proportion of network nodes to randomly alter their
community assignment within each network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ancillary function that creates a list of data frames, of which
each data frame describes the community assignment for each node in the
network. These data frames are used as a starting point for the edge weights
to be added between nodes (see <code><a href="#topic+group_network_perturb">group_network_perturb</a></code> and
<code><a href="#topic+get_weights">get_weights</a></code> for more information).
</p>


<h3>Value</h3>

<p>a list of network data frames containing nodes, their community
assignment, and node dyads
</p>

<hr>
<h2 id='sort_pairs'>Sort pairs</h2><span id='topic+sort_pairs'></span>

<h3>Description</h3>

<p>Description of the sort pairs function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_pairs(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_pairs_+3A_a">a</code></td>
<td>
<p>a vector of classifications</p>
</td></tr>
<tr><td><code id="sort_pairs_+3A_b">b</code></td>
<td>
<p>a vector of classifications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to sort pairs of integers or factors and identify the pairs
</p>


<h3>Value</h3>

<p>a list of six objects used as the basis to calculate many cluster evaluation metrics,
like NMI, ARI, and the Rand z-score.
</p>

<ul>
<li><p>levelsa list of the classes within each of the partitions a and b
</p>
</li>
<li><p>n_ija vector containing counts of nodes within all possible classification pairs from partitions a and b
</p>
</li>
<li><p>n_i.a vector of the same length as pair_nb, specifying the order of classifications in pair_nb from partition a
</p>
</li>
<li><p>n_.ja vector of the same length as pair_nb, specifying the order of classifications in pair_nb from partition b
</p>
</li>
<li><p>pair_aa vector containing counts of nodes within each class for partition a
</p>
</li>
<li><p>pair_ba vector containing counts of nodes within each class for partition b
</p>
</li></ul>


<hr>
<h2 id='subset_matrix_to_df'>Convert matrices to list of data frames for subnetworks</h2><span id='topic+subset_matrix_to_df'></span>

<h3>Description</h3>

<p>Description of the convert matrices to data frame list for subnetworks function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_matrix_to_df(func_matrix, str_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_matrix_to_df_+3A_func_matrix">func_matrix</code></td>
<td>
<p>a square, symmetric matrix to be used as the main input for
the <code><a href="#topic+hms">hms</a></code> algorithm. For brain connectivity, this will be a
representation of functional (e.g., BOLD) connectivity.</p>
</td></tr>
<tr><td><code id="subset_matrix_to_df_+3A_str_matrix">str_matrix</code></td>
<td>
<p>a square, symmetric matrix to be used as the guidance input
for the <code><a href="#topic+hms">hms</a></code> algorithm. For brain connectivity, this will be a
representation of structural (e.g., white matter) connectivity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ancillary function that creates a data frame list for the
subnetworks created using the multimodal hierarchical spinglass algorithm.
</p>


<h3>Value</h3>

<p>A list of data frame containing the functional matrix,
structural matrix, a data frame of the functional edge weights, a data frame
of the structural edge weights, and nodal information (functional degree,
structural degree, community assignment, and label information)
</p>

<hr>
<h2 id='tr'>Trace</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Return the trace of a square matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tr_+3A_x">x</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="tr_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+sum">sum</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The trace, the sum of the diagonal elements, of the square matrix
<code>x</code>
</p>

<hr>
<h2 id='up_low'>Bounds of grid search function</h2><span id='topic+up_low'></span>

<h3>Description</h3>

<p>Description of the bounds of grid search function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>up_low(dist_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="up_low_+3A_dist_mat">dist_mat</code></td>
<td>
<p>a square distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This ancillary function finds the upper and lower bounds of the grid search
implemented in the kernel score test.
</p>
<p>The function returns an m x m matrix (where m is the number of networks) to
be used as input for the kernel function.
</p>


<h3>Value</h3>

<p>a square matrix of the same dimensions of the input matrix, comprised
of the sum square differences.
</p>

<hr>
<h2 id='zrand'>Rand z-score</h2><span id='topic+zrand'></span>

<h3>Description</h3>

<p>Description of the Rand z-score function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zrand(part1, part2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zrand_+3A_part1">part1</code></td>
<td>
<p>a partition of nodes to communities or clusters</p>
</td></tr>
<tr><td><code id="zrand_+3A_part2">part2</code></td>
<td>
<p>a partition of nodes to communities or clusters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an ancillary function that calculates the Rand z-score between two
partitions, which is used in the consensus similarity function
</p>


<h3>Value</h3>

<p>the Rand z-score between two partitions
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
