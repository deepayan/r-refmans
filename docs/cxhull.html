<!DOCTYPE html><html lang="en"><head><title>Help for package cxhull</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cxhull}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cxhull'><p>Convex hull</p></a></li>
<li><a href='#cxhullEdges'><p>Vertices and edges of convex hull</p></a></li>
<li><a href='#daVinciSphere'><p>Leonardo da Vinci's 72-sided sphere</p></a></li>
<li><a href='#dihedralAngles'><p>Dihedral angles</p></a></li>
<li><a href='#EdgesAB'><p>Edges of a triangulated 3D convex hull</p></a></li>
<li><a href='#EdgesXYZ'><p>Edges coordinates</p></a></li>
<li><a href='#hexacosichoron'><p>Vertices of the 600-cell</p></a></li>
<li><a href='#hullMesh'><p>Mesh of a 3d convex hull</p></a></li>
<li><a href='#hullSummary'><p>Summary of 3D convex hull</p></a></li>
<li><a href='#plotConvexHull3d'><p>Plot triangulated 3d convex hull</p></a></li>
<li><a href='#TrianglesXYZ'><p>Triangles of a triangulated 3D convex hull</p></a></li>
<li><a href='#VerticesXYZ'><p>Convex hull vertices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Convex Hull</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-23</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Laurent &lt;laurent_step@outlook.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the convex hull in arbitrary dimension, based on the
    Qhull library (<a href="http://www.qhull.org">http://www.qhull.org</a>). The package provides a
    complete description of the convex hull: edges, ridges, facets,
    adjacencies. Triangulation is optional.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stla/cxhull">https://github.com/stla/cxhull</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stla/cxhull/issues">https://github.com/stla/cxhull/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, grDevices, rgl, Rvcg</td>
</tr>
<tr>
<td>Suggests:</td>
<td>colorspace</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 02:57:38 UTC; SDL96354</td>
</tr>
<tr>
<td>Author:</td>
<td>C. B. Barber [cph] (author of the Qhull library),
  The Geometry Center [cph],
  Stéphane Laurent [cph, aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-24 04:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='cxhull'>Convex hull</h2><span id='topic+cxhull'></span>

<h3>Description</h3>

<p>Computes the convex hull of a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxhull(points, triangulate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cxhull_+3A_points">points</code></td>
<td>
<p>numeric matrix, one point per row</p>
</td></tr>
<tr><td><code id="cxhull_+3A_triangulate">triangulate</code></td>
<td>
<p>logical, whether to triangulate the convex hull</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list providing a lot of information about the convex hull. See 
the <strong>README</strong> file for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cxhull)
points &lt;- rbind(
 c(0.5,0.5,0.5),
 c(0,0,0),
 c(0,0,1),
 c(0,1,0),
 c(0,1,1),
 c(1,0,0),
 c(1,0,1),
 c(1,1,0),
 c(1,1,1)
)
cxhull(points)
</code></pre>

<hr>
<h2 id='cxhullEdges'>Vertices and edges of convex hull</h2><span id='topic+cxhullEdges'></span>

<h3>Description</h3>

<p>Computes the vertices and the edges of the convex hull of a set 
of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxhullEdges(points, adjacencies = FALSE, orderEdges = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cxhullEdges_+3A_points">points</code></td>
<td>
<p>numeric matrix, one point per row; it must contain at least 
three columns (the two-dimensional case is not implemented yet)</p>
</td></tr>
<tr><td><code id="cxhullEdges_+3A_adjacencies">adjacencies</code></td>
<td>
<p>Boolean, whether to return the vertex adjacencies</p>
</td></tr>
<tr><td><code id="cxhullEdges_+3A_orderedges">orderEdges</code></td>
<td>
<p>Boolean, whether to order the edges in the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two fields: <code>vertices</code> and <code>edges</code>. The 
<code>vertices</code> field is a list which provides an id for each vertex and 
its coordinates. If <code>adjacencies=TRUE</code>, it provides in addition the 
ids of the adjacent vertices for each vertex. The <code>edges</code> fields is 
an integer matrix with two columns. Each row provides the two ids of the 
vertices of the corresponding edge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cxhull)
# let's try with the hexacosichoron (see `?hexacosichoron`)
#   it is convex so its convex hull is itself
VE &lt;- cxhullEdges(hexacosichoron)
edges &lt;- VE[["edges"]]
random_edge &lt;- edges[sample.int(720L, 1L), ]
A &lt;- hexacosichoron[random_edge[1L], ]
B &lt;- hexacosichoron[random_edge[2L], ]
sqrt(c(crossprod(A - B))) # this is 2/phi
# Now let's project the polytope to the H4 Coxeter plane 
phi &lt;- (1 + sqrt(5)) / 2
u1 &lt;- c(
  0, 
  2*phi*sin(pi/30), 
  0, 
  1
)
u2 &lt;- c(
  2*phi*sin(pi/15), 
  0, 
  2*sin(2*pi/15), 
  0
)
u1 &lt;- u1 / sqrt(c(crossprod(u1)))
u2 &lt;- u2 / sqrt(c(crossprod(u2)))
# projections to the Coxeter plane
proj &lt;- function(v){
  c(c(crossprod(v, u1)), c(crossprod(v, u2)))
}
points &lt;- t(apply(hexacosichoron, 1L, proj))
# we will assign a color to each edge  
#   according to the norms of its two vertices
norms2 &lt;- round(apply(points, 1L, crossprod), 1L)
( tbl &lt;- table(norms2) )
#&gt; 0.4 1.6 2.4 3.6 
#&gt;  30  30  30  30 
values &lt;- as.numeric(names(tbl))
grd &lt;- as.matrix(expand.grid(values, values)) 
grd &lt;- grd[grd[, 1L] &lt;= grd[, 2L], ]
pairs &lt;- apply(grd, 1L, paste0, collapse = "-")
colors &lt;- hcl.colors(nrow(grd), palette = "Hawaii", rev = TRUE)
if(require("colorspace")) {
  colors &lt;- colorspace::darken(colors, amount = 0.3)
}
names(colors) &lt;- pairs
# plot ####
opar &lt;- par(mar = c(0, 0, 0, 0))
plot(
  points[!duplicated(points), ], pch = 19, cex = 0.3, asp = 1, 
  axes = FALSE, xlab = NA, ylab = NA
)
for(i in 1L:nrow(edges)){
  twopoints &lt;- points[edges[i, ], ]
  nrms2 &lt;- round(sort(apply(twopoints, 1L, crossprod)), 1L)
  pair &lt;- paste0(nrms2, collapse = "-")
  lines(twopoints, lwd = 0.5, col = colors[pair])
}
par(opar)
</code></pre>

<hr>
<h2 id='daVinciSphere'>Leonardo da Vinci's 72-sided sphere</h2><span id='topic+daVinciSphere'></span>

<h3>Description</h3>

<p>A matrix giving the 62 vertices of da Vinci's 72-sided sphere, 
a convex polyhedra with 72 faces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daVinciSphere
</code></pre>


<h3>Format</h3>

<p>A matrix with 62 rows and 3 columns.
</p>


<h3>Source</h3>

<p><a href="http://www.matematicasvisuales.com/english/html/geometry/space/sphereCampanus.html">http://www.matematicasvisuales.com/english/html/geometry/space/sphereCampanus.html</a>
</p>

<hr>
<h2 id='dihedralAngles'>Dihedral angles</h2><span id='topic+dihedralAngles'></span>

<h3>Description</h3>

<p>Dihedral angles of a convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dihedralAngles(hull)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dihedralAngles_+3A_hull">hull</code></td>
<td>
<p>an output of <code><a href="#topic+cxhull">cxhull</a></code> applied to 3D points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with three columns. The two first columns represent 
the edges, given as a pair of vertex indices. The third column provides 
the dihedral angle in degrees corresponding to the edge, that is the 
angle between the two faces incident to this edge. This is useful to find 
edges between two coplanar faces: if the faces are exactly coplanar then 
the dihedral angle is 180, but because of numerical approximation one can 
consider that there is coplanarity when the dihedral angle is greater 
than 179, for example. This function is used in 
<code><a href="#topic+plotConvexHull3d">plotConvexHull3d</a></code> to get rid of such edges (if the user 
sets a value to the argument <code>angleThreshold</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a cube ####
library(cxhull)
points &lt;- rbind(
 c(0.5,0.5,0.5),
 c(0,0,0),
 c(0,0,1),
 c(0,1,0),
 c(0,1,1),
 c(1,0,0),
 c(1,0,1),
 c(1,1,0),
 c(1,1,1)
)
hull &lt;- cxhull(points)
dihedralAngles(hull)
</code></pre>

<hr>
<h2 id='EdgesAB'>Edges of a triangulated 3D convex hull</h2><span id='topic+EdgesAB'></span>

<h3>Description</h3>

<p>Edges of a triangulated 3D convex hull given by the ids of 
the vertices in a matrix, plus a column indicating the border edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EdgesAB(hull)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EdgesAB_+3A_hull">hull</code></td>
<td>
<p>an output of <code><a href="#topic+cxhull">cxhull</a></code> applied to 3D points and 
with the option <code>triangulate=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character matrix with three columns. Each row provides the ids of 
the two vertices of an edge, and a yes/no indicator of whether the edge 
is a border edge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cxhull)
library(rgl)
dodecahedron &lt;- t(dodecahedron3d()$vb[-4L, ])
hull &lt;- cxhull(dodecahedron, triangulate = TRUE)
triangles &lt;- TrianglesXYZ(hull)
triangles3d(triangles, color = "yellow")
edges &lt;- EdgesAB(hull)
trueEdges &lt;- edges[edges[, 3L] == "yes", c(1L, 2L)]
otherEdges &lt;- edges[edges[, 3L] == "no", c(1L, 2L)]
vertices &lt;- VerticesXYZ(hull)
for(i in 1:nrow(trueEdges)){
  lines3d(vertices[trueEdges[i, ], ], color = "blue", lwd = 3)
}
for(i in 1:nrow(otherEdges)){
  lines3d(vertices[otherEdges[i, ], ], color = "red", lwd = 3)
}
</code></pre>

<hr>
<h2 id='EdgesXYZ'>Edges coordinates</h2><span id='topic+EdgesXYZ'></span>

<h3>Description</h3>

<p>The coordinates of the extremities of the edges in a matrix, 
plus a column indicating which edges are border edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EdgesXYZ(hull)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EdgesXYZ_+3A_hull">hull</code></td>
<td>
<p>an output of <code><a href="#topic+cxhull">cxhull</a></code> applied to 3D points and 
with the option <code>triangulate=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with four columns. The first three values of a row 
are the coordinates of a vertex at the extremity of an edge, and the 
fourth column indicates whether the edge is a border edge.
</p>

<hr>
<h2 id='hexacosichoron'>Vertices of the 600-cell</h2><span id='topic+hexacosichoron'></span>

<h3>Description</h3>

<p>A matrix giving the 120 vertices of the hexacosichoron, a 
regular convex 4D polytope also known as the &quot;600-cell&quot;, with edge length 
<code>2/phi</code>, where <code>phi</code> is the golden number. It has 720 edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexacosichoron
</code></pre>


<h3>Format</h3>

<p>A matrix with 120 rows and 4 columns.
</p>


<h3>Source</h3>

<p><a href="https://www.qfbox.info/4d/600-cell">https://www.qfbox.info/4d/600-cell</a>
</p>

<hr>
<h2 id='hullMesh'>Mesh of a 3d convex hull</h2><span id='topic+hullMesh'></span>

<h3>Description</h3>

<p>Extract the vertices and the faces from a 3d convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hullMesh(hull, simplify = TRUE, rgl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hullMesh_+3A_hull">hull</code></td>
<td>
<p>a 3d convex hull, output of <code><a href="#topic+cxhull">cxhull</a></code></p>
</td></tr>
<tr><td><code id="hullMesh_+3A_simplify">simplify</code></td>
<td>
<p>Boolean, whether to return the faces as a matrix instead 
of a list if possible, i.e. if all faces have the same number of edges;
this argument is possibly ignored if <code>rgl=TRUE</code>, see below</p>
</td></tr>
<tr><td><code id="hullMesh_+3A_rgl">rgl</code></td>
<td>
<p>Boolean, whether to return a <strong>rgl</strong> mesh (class 
<code>mesh3d</code>) if possible, i.e. if each face has three or four edges; 
if <code>TRUE</code> and the <strong>rgl</strong> mesh is possible, then the 
<code>simplify</code> argument has no effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list giving the vertices and the faces, or a <strong>rgl</strong> mesh.
</p>


<h3>Note</h3>

<p>Unless all faces are triangular, the output does not define a mesh 
with coherently oriented faces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cxhull)
hull &lt;- cxhull(daVinciSphere)
septuaginta &lt;- hullMesh(hull, rgl = TRUE)
library(rgl)
open3d(windowRect = c(50, 50, 562, 562))
shade3d(septuaginta, color = "darkred")
# some quad faces are misoriented:
open3d(windowRect = c(50, 50, 562, 562))
shade3d(septuaginta, color = "tomato", back = "culled")
</code></pre>

<hr>
<h2 id='hullSummary'>Summary of 3D convex hull</h2><span id='topic+hullSummary'></span>

<h3>Description</h3>

<p>Summary of a triangulated 3D convex hull
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hullSummary(hull)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hullSummary_+3A_hull">hull</code></td>
<td>
<p>an output of <code><a href="#topic+cxhull">cxhull</a></code> applied to 3D points and 
with the option <code>triangulate=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the vertices and the facets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cxhull)
# pyramid
pts &lt;- rbind(
  c(0, 0, 0), 
  c(1, 0, 0), 
  c(1, 1, 0), 
  c(0.5, 0.5, 1), 
  c(0.5, 0.5, 0.9),
  c(0, 1, 0)
)
hull &lt;- cxhull(pts, triangulate = TRUE)
hullSummary(hull)
</code></pre>

<hr>
<h2 id='plotConvexHull3d'>Plot triangulated 3d convex hull</h2><span id='topic+plotConvexHull3d'></span>

<h3>Description</h3>

<p>Plot a triangulated 3d convex hull with <strong>rgl</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConvexHull3d(
  hull,
  angleThreshold = NULL,
  edgesAsTubes = TRUE,
  verticesAsSpheres = TRUE,
  palette = NULL,
  bias = 1,
  interpolate = "linear",
  g = identity,
  facesColor = "navy",
  edgesColor = "gold",
  tubesRadius = 0.03,
  spheresRadius = 0.05,
  spheresColor = edgesColor,
  alpha = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotConvexHull3d_+3A_hull">hull</code></td>
<td>
<p>an output of <code><a href="#topic+cxhull">cxhull</a></code> applied to 3d points and 
with the option <code>triangulate=TRUE</code></p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_anglethreshold">angleThreshold</code></td>
<td>
<p>a threshold angle in degrees, typically <code>179</code>, 
to get rid of edges between coplanar faces: edges whose corresponding 
dihedral angle is greater than this threshold are removed; <code>NULL</code> 
to use another method (see the Leonardo example)</p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_edgesastubes">edgesAsTubes</code></td>
<td>
<p>Boolean, whether to draw the edges as tubes</p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_verticesasspheres">verticesAsSpheres</code></td>
<td>
<p>Boolean, whether to draw the vertices as spheres</p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_palette">palette</code></td>
<td>
<p>a vector of colors to make a color gradient for the faces; 
if <code>NULL</code>, the colors of the faces are controlled by the 
<code>facesColor</code> argument</p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_bias">bias</code>, <code id="plotConvexHull3d_+3A_interpolate">interpolate</code></td>
<td>
<p>if <code>palette</code> is not <code>NULL</code>, these arguments are 
passed to <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code></p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_g">g</code></td>
<td>
<p>a function defined on [0, 1] and taking its values in [0, 1]; it is 
composed with the function created by <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>, 
based on <code>palette</code></p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_facescolor">facesColor</code></td>
<td>
<p>the color(s) for the faces; this argument is ignored if 
the argument <code>palette</code> is not <code>NULL</code>; otherwise there are three 
possibilities for <code>facesColor</code>: 
a single color, a vector of colors with length the number of triangles, 
in which case one color is assigned per triangle, or a vector of colors 
with length the number of faces, after merging the triangles, in 
which case one color is assigned per face; use <code><a href="#topic+hullSummary">hullSummary</a></code> 
to know the number of faces</p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_edgescolor">edgesColor</code></td>
<td>
<p>the color for the edges</p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_tubesradius">tubesRadius</code></td>
<td>
<p>the radius of the tubes when <code>edgesAsTubes=TRUE</code></p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_spheresradius">spheresRadius</code></td>
<td>
<p>the radius of the spheres when 
<code>verticesAsSpheres=TRUE</code></p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_spherescolor">spheresColor</code></td>
<td>
<p>the color of the spheres when 
<code>verticesAsSpheres=TRUE</code></p>
</td></tr>
<tr><td><code id="plotConvexHull3d_+3A_alpha">alpha</code></td>
<td>
<p>number between 0 and 1 controlling the opacity of the faces</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cxhull)
library(rgl)
cuboctahedron &lt;- t(cuboctahedron3d()$vb[-4L, ])
hull &lt;- cxhull(cuboctahedron, triangulate = TRUE)
# single color ####
open3d(windowRect = c(50, 50, 562, 562))
plotConvexHull3d(hull)
# gradient ####
open3d(windowRect = c(50, 50, 562, 562))
if(getRversion() &lt; "4.1.0"){
  palette &lt;- "Viridis"
}else{
  palette &lt;- "Rocket"
}
plotConvexHull3d(hull, palette = hcl.colors(256, palette), bias = 0.5)


library(cxhull)
library(rgl)
# Leonardo da Vinci's 72-sided sphere ####
hull &lt;- cxhull(daVinciSphere, triangulate = TRUE)
# there are some undesirable edges:
plotConvexHull3d(
  hull, tubesRadius = 0.07, spheresRadius = 0.1
)
# =&gt; use `angleThreshold` to get rid of these edges:
plotConvexHull3d(
  hull, angleThreshold = 179,
  tubesRadius = 0.07, spheresRadius = 0.1
)

</code></pre>

<hr>
<h2 id='TrianglesXYZ'>Triangles of a triangulated 3D convex hull</h2><span id='topic+TrianglesXYZ'></span>

<h3>Description</h3>

<p>Coordinates of the vertices of the triangles of a 
triangulated 3D convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrianglesXYZ(hull)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TrianglesXYZ_+3A_hull">hull</code></td>
<td>
<p>an output of <code><a href="#topic+cxhull">cxhull</a></code> applied to 3D points and 
with the option <code>triangulate=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with three columns. Each row represents the coordinates of 
a vertex of a triangle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cxhull)
library(rgl)
dodecahedron &lt;- t(dodecahedron3d()$vb[-4L, ])
hull &lt;- cxhull(dodecahedron, triangulate = TRUE)
triangles &lt;- TrianglesXYZ(hull)
triangles3d(triangles, color = "firebrick")
</code></pre>

<hr>
<h2 id='VerticesXYZ'>Convex hull vertices</h2><span id='topic+VerticesXYZ'></span>

<h3>Description</h3>

<p>The coordinates of the vertices of a 3D convex hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VerticesXYZ(hull)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VerticesXYZ_+3A_hull">hull</code></td>
<td>
<p>an output of <code><a href="#topic+cxhull">cxhull</a></code> applied to 3D points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with three columns. Each row represents the coordinates of 
a vertex and the row names are the ids of the vertices.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
