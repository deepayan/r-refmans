<!DOCTYPE html><html><head><title>Help for package EMAtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EMAtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ema.powercurve'><p>Create power curves for EMA data</p></a></li>
<li><a href='#eventmerge'><p>Merge Mobile EMA (mEMA) event-level data into momentary data</p></a></li>
<li><a href='#gcenter'><p>Centering on grand-means</p></a></li>
<li><a href='#lm_slopes_compare'><p>Compare the slopes of two lme models</p></a></li>
<li><a href='#lme.dscore'><p>Calculate d scores from an lme4 or nlme object</p></a></li>
<li><a href='#ObsNumbs'><p>Create observation numbers in your data</p></a></li>
<li><a href='#pcenter'><p>Centering on person-means</p></a></li>
<li><a href='#pmean'><p>Centering on person-means</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Management Tools for Real-Time Monitoring/Ecological
Momentary Assessment Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Do data management functions common in real-time monitoring (also called: ecological momentary assessment, experience sampling, micro-longitudinal) data, including creating power curves for multilevel data, centering on participant means and merging event-level data into momentary data sets where you need the events to correspond to the nearest data point in the momentary data. This is VERY early release software, and more features will be added over time. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>DataCombine,ggplot2,lmerTest, sjstats (&ge; 0.10.2), anytime,
plyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-31 12:59:29 UTC; evankleiman</td>
</tr>
<tr>
<td>Author:</td>
<td>Evan Kleiman [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Kleiman &lt;evan.kleiman@rutgers.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-31 21:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ema.powercurve'>Create power curves for EMA data</h2><span id='topic+ema.powercurve'></span>

<h3>Description</h3>

<p>This allows you to estimate power to detect an effect at three standard effect sizes (d = 0.2, 0.5, and 0.8). It uses the smpsize_lmm function from sjstats to generate data for the curves and ggplot2 to plot them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ema.powercurve(
  NumbPart,
  NumbResp,
  days,
  respday,
  Est_ICC = 0.05,
  COL.8 = "red",
  COL.5 = "blue",
  COL.2 = "green"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ema.powercurve_+3A_numbpart">NumbPart</code></td>
<td>
<p>Total number of participants (i.e., level-2 unit)</p>
</td></tr>
<tr><td><code id="ema.powercurve_+3A_numbresp">NumbResp</code></td>
<td>
<p>Total max number of responses per participant (e.g., number of days * number of responses per day). You can either enter this OR enter number of days and number of responses per day manually. If all are entered, it will default to NumbResp.</p>
</td></tr>
<tr><td><code id="ema.powercurve_+3A_days">days</code></td>
<td>
<p>Maximum number of days in study.</p>
</td></tr>
<tr><td><code id="ema.powercurve_+3A_respday">respday</code></td>
<td>
<p>Maximum number of responses per day.</p>
</td></tr>
<tr><td><code id="ema.powercurve_+3A_est_icc">Est_ICC</code></td>
<td>
<p>Estimated model ICC. Defaults to .05, but you should use a priori information from prior studies.</p>
</td></tr>
<tr><td><code id="ema.powercurve_+3A_col.8">COL.8</code></td>
<td>
<p>Color of line for large (d=.8) effect size. Defualt is red, but you can specify colors by name or by hex code (make sure to put colors in quotation marks).</p>
</td></tr>
<tr><td><code id="ema.powercurve_+3A_col.5">COL.5</code></td>
<td>
<p>Color of line for medium (d=.5) effect size. Defualt is blue, but you can specify colors by name or by hex code (make sure to put colors in quotation marks).</p>
</td></tr>
<tr><td><code id="ema.powercurve_+3A_col.2">COL.2</code></td>
<td>
<p>Color of line for small (d=.2) effect size. Defualt is green, but you can specify colors by name or by hex code (make sure to put colors in quotation marks).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that displays power curves at three effect sizes (d=.2,.5,.8). You can use this like any other ggplot object (e.g., by adding other ggplot objects to it)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ema.powercurve(NumbPart=80,days=30,respday=3)
 ## Not run: ema.powercurve(NumbPart=80,NumbResp=200)
  ## Not run: ema.powercurve(NumbPart=80,NumbResp=200,COL.8="orange")
  ## Not run: ema.powercurve(NumbPart=80,NumbResp=200,COL.8="orange",COL.5="#FF5733",COL.3="#8E44AD")
</code></pre>

<hr>
<h2 id='eventmerge'>Merge Mobile EMA (mEMA) event-level data into momentary data</h2><span id='topic+eventmerge'></span>

<h3>Description</h3>

<p>This allows you to merge event-level data (e.g., yes/no to an event) into momentary data, placing the event with the most recent momentary datapoint before the event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventmerge(MOMENTARY, EVENT, eventNAME = "eventYN")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventmerge_+3A_momentary">MOMENTARY</code></td>
<td>
<p>a dataframe with momentary (i.e., level-1) data exported from mEMA, should have the following columns (all mEMA default names): KEY, instance_key, subject_id,timestamp</p>
</td></tr>
<tr><td><code id="eventmerge_+3A_event">EVENT</code></td>
<td>
<p>a dataframe with event data (i.e., level-2) that should have the following columns (all mEMA default): instance_key    subject_id    respondent_id    timestamp    local_date    survey_id    timezone_offset    as well as an &quot;event&quot; column in the last column of the dataframe (can be any name)</p>
</td></tr>
<tr><td><code id="eventmerge_+3A_eventname">eventNAME</code></td>
<td>
<p>variable name for your event in the final merged dataset (does not have to match last column in EVENT dataset, but can). Defaults to &quot;eventYN&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe that contains event data merged into your momentary data. It will have N rows = N rows in the momentary dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: newDATA&lt;-eventmerge(MOMENTARYdata,EVENTdata,eventNAME="eventYN")
</code></pre>

<hr>
<h2 id='gcenter'>Centering on grand-means</h2><span id='topic+gcenter'></span>

<h3>Description</h3>

<p>This function allows you to center on grand-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcenter(var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcenter_+3A_var">var</code></td>
<td>
<p>name of variable to be centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column in your dataframe (with grand-mean centered data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data$centeredVAR&lt;-gcenter(data$var)
</code></pre>

<hr>
<h2 id='lm_slopes_compare'>Compare the slopes of two lme models</h2><span id='topic+lm_slopes_compare'></span>

<h3>Description</h3>

<p>This allows you to compare two lme4 models that have the same fixed predictors but differ in other ways (e.g., from different datasets, different random effects). It will produce a Z score a p-value for each effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_slopes_compare(VAR1, VAR2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_slopes_compare_+3A_var1">VAR1</code></td>
<td>
<p>An lme4 object</p>
</td></tr>
<tr><td><code id="lm_slopes_compare_+3A_var2">VAR2</code></td>
<td>
<p>An lme4 object that has the same variables, in the same order as VAR1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Z-tests comapring slopes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: model1&lt;-lmer(DV~IV1+IV2+IV3+(1|subject),data=DATA_1)
## Not run: model2&lt;-lmer(DV~IV1+IV2+IV3+(1|subject),data=DATA_2)
 ## Not run: lm_slopes_compare(model1,model2)
</code></pre>

<hr>
<h2 id='lme.dscore'>Calculate d scores from an lme4 or nlme object</h2><span id='topic+lme.dscore'></span>

<h3>Description</h3>

<p>This will calculate Cohen's D for each effect in an lme4 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lme.dscore(mod, data, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lme.dscore_+3A_mod">mod</code></td>
<td>
<p>An lme4 or nlme object</p>
</td></tr>
<tr><td><code id="lme.dscore_+3A_data">data</code></td>
<td>
<p>The dataset the lme4 or nlme object was drawn from</p>
</td></tr>
<tr><td><code id="lme.dscore_+3A_type">type</code></td>
<td>
<p>Either &quot;lme4&quot; or &quot;nlme&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of d-scores.
</p>


<h3>Note</h3>

<p>lme4 and nlme models will produce slightly different estimates. This is because when using type=&quot;lme4&quot;, the numerator DF will be calculated using the Satterthwaite approximations to degrees of freedom (via the lmerTest package), whereas nlme includes Kenward-Roger numerator degress of freedom. If you have sufficent level-1 samples, the difference between models will be miniscule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: model1&lt;-lmer(DV~IV1+IV2+IV3+(1|subject),data=DATA_1)
 ## Not run: lme.dscore(model1,data=DATA_1,type="lme4")
</code></pre>

<hr>
<h2 id='ObsNumbs'>Create observation numbers in your data</h2><span id='topic+ObsNumbs'></span>

<h3>Description</h3>

<p>This function allows you number your observations by participant (P), by day (D) or by participant and day (PD) using a unix (numeric) timestamp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ObsNumbs(ID, TS, BY = c("P", "D", "PD"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ObsNumbs_+3A_id">ID</code></td>
<td>
<p>name of ID variable</p>
</td></tr>
<tr><td><code id="ObsNumbs_+3A_ts">TS</code></td>
<td>
<p>name unix (numeric) timestamp (if you have a date-time object, try converting it with as.numeric(as.POSIXct()))</p>
</td></tr>
<tr><td><code id="ObsNumbs_+3A_by">BY</code></td>
<td>
<p>participant (P), by day (D), or by participant and day (PD). P will create a column of just 1 through n responses for each participant. D will create a day-level sequential value. PD will create an observation within each day. This might be most useful by first using the BY=D option, which will give you day number to use in tandem with observation #.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column in your dataframe (with person-centered data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data$ObsNumb&lt;-ObsNumbs(data$ID,data$TS, BY="P")
## Not run: data$DayNumb&lt;-ObsNumbs(data$ID,data$TS,BY="D")
## Not run: data$ObsNumb_D&lt;-ObsNumbs(data$ID,data$TS,BY="PD")
</code></pre>

<hr>
<h2 id='pcenter'>Centering on person-means</h2><span id='topic+pcenter'></span>

<h3>Description</h3>

<p>This function allows you to center on person-means (also called &quot;centering within clusters&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcenter(ID, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcenter_+3A_id">ID</code></td>
<td>
<p>name of ID variable</p>
</td></tr>
<tr><td><code id="pcenter_+3A_var">var</code></td>
<td>
<p>name of variable to be centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column in your dataframe (with person-centered data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data$centeredVAR&lt;-pcenter(data$ID,data$var)
</code></pre>

<hr>
<h2 id='pmean'>Centering on person-means</h2><span id='topic+pmean'></span>

<h3>Description</h3>

<p>This function allows you calculate person-level means. This will create a level-2 variable that can be used in tandem with person-centered means. This is useful if you are interested in both the within-person and between-person effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmean(ID, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmean_+3A_id">ID</code></td>
<td>
<p>name of ID variable</p>
</td></tr>
<tr><td><code id="pmean_+3A_var">var</code></td>
<td>
<p>name of variable to be centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column in your dataframe (with person-level means)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data$centeredVAR&lt;-pmean(data$ID,data$var)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
