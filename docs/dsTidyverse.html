<!DOCTYPE html><html lang="en"><head><title>Help for package dsTidyverse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dsTidyverse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arrangeDS'><p>Order the rows of a data frame by the values of selected columns</p></a></li>
<li><a href='#asTibbleDS'><p>Coerce a data frame or matrix to a tibble</p></a></li>
<li><a href='#bindColsDS'><p>Bind multiple data frames by column</p></a></li>
<li><a href='#bindRowsDS'><p>Bind multiple data frames by row.</p></a></li>
<li><a href='#caseWhenDS'><p>Performs dplyr case_when</p></a></li>
<li><a href='#checkPermissivePrivacyControlLevel'><p>checkPermissivePrivacyControlLevel</p></a></li>
<li><a href='#distinctDS'><p>Keep distinct/unique rows</p></a></li>
<li><a href='#filterDS'><p>Performs dplyr filter</p></a></li>
<li><a href='#groupByDS'><p>Group by one or more variables</p></a></li>
<li><a href='#groupKeysDS'><p>Performs dplyr <code>group_keys</code>.</p></a></li>
<li><a href='#ifElseDS'><p>Vectorised if-else</p></a></li>
<li><a href='#listPermittedTidyverseFunctionsDS'><p>List of Permitted Tidyverse Functions</p></a></li>
<li><a href='#mutateDS'><p>Create, modify, and delete columns</p></a></li>
<li><a href='#renameDS'><p>Rename columns</p></a></li>
<li><a href='#selectDS'><p>Keep or drop columns using their names and types</p></a></li>
<li><a href='#sliceDS'><p>Subset rows using their positions</p></a></li>
<li><a href='#ungroupDS'><p>Remove grouping from a tibble or data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'DataSHIELD' 'Tidyverse' Serverside Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Cadman &lt;t.j.cadman@umcg.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of selected 'Tidyverse' functions within 'DataSHIELD', an open-source federated analysis solution in R. Currently, DataSHIELD contains very limited tools for data manipulation, so the aim of this package is to improve the researcher experience by implementing essential functions for data manipulation, including subsetting, filtering, grouping, and renaming variables. This is the serverside package which should be installed on the server holding the data, and is used in conjuncture with the clientside package 'dsTidyverseClient' which is installed in the local R environment of the analyst. For more information, see <a href="https://www.tidyverse.org/">https://www.tidyverse.org/</a> and <a href="https://datashield.org/">https://datashield.org/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), tibble, DSLite, dsBaseClient, dsBase,
DSI, dplyr, purrr, mockery</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://cran.obiba.org/">https://cran.obiba.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-27 09:19:47 UTC; tcadman</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Cadman <a href="https://orcid.org/0000-0002-7682-5645"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Mariska Slofstra <a href="https://orcid.org/0000-0002-0400-0468"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Stuart Wheater [aut],
  Demetris Avraam [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-27 09:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='arrangeDS'>Order the rows of a data frame by the values of selected columns</h2><span id='topic+arrangeDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::arrange</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrangeDS(tidy_expr, df.name, .by_group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrangeDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Variables, or functions of variables. Use <code>desc()</code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="arrangeDS_+3A_df.name">df.name</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="arrangeDS_+3A_.by_group">.by_group</code></td>
<td>
<p>If TRUE, will sort first by grouping variable. Applies to grouped data frames
only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>df.name</code>, typically a data frame or tibble.
</p>

<hr>
<h2 id='asTibbleDS'>Coerce a data frame or matrix to a tibble</h2><span id='topic+asTibbleDS'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>tibble::as_tibble</code>. Currently only implemented for data frames and matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asTibbleDS(tidy_expr, x, .rows, .name_repair, rownames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asTibbleDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Unused in present function.</p>
</td></tr>
<tr><td><code id="asTibbleDS_+3A_x">x</code></td>
<td>
<p>A data frame or matrix.</p>
</td></tr>
<tr><td><code id="asTibbleDS_+3A_.rows">.rows</code></td>
<td>
<p>The number of rows, useful to create a 0-column tibble or just as an additional
check.</p>
</td></tr>
<tr><td><code id="asTibbleDS_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li><p> &quot;minimal&quot;: No name repair or checks, beyond basic existence.
</p>
</li>
<li><p> &quot;unique&quot;: Make sure names are unique and not empty.
</p>
</li>
<li><p> &quot;check_unique&quot;: (default value), no name repair, but check they are unique.
</p>
</li>
<li><p> &quot;universal&quot;: Make the names unique and syntactic.
</p>
</li></ul>
</td></tr>
<tr><td><code id="asTibbleDS_+3A_rownames">rownames</code></td>
<td>
<p>How to treat existing row names of a data frame or matrix:
</p>

<ul>
<li><p> 'NULL': remove row names. This is the default.
</p>
</li>
<li><p> 'NA': keep row names.
</p>
</li>
<li><p> A string: the name of a new column. Existing rownames are transferred
into this column and the <code>row.names</code> attribute is deleted. No name repair is applied
to the new column name, even if <code>x</code> already contains a column of that name.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble.
</p>

<hr>
<h2 id='bindColsDS'>Bind multiple data frames by column</h2><span id='topic+bindColsDS'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>dplyr::bind_cols</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindColsDS(to_combine = NULL, .name_repair = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bindColsDS_+3A_to_combine">to_combine</code></td>
<td>
<p>Data frames to combine. Each argument can either be a data frame, a list that
could be a data frame, or a list of data frames. Columns are matched by name, and any missing
columns will be filled with NA.</p>
</td></tr>
<tr><td><code id="bindColsDS_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of &quot;unique&quot;, &quot;universal&quot;, or &quot;check_unique&quot;. See
<code>vctrs::vec_as_names()</code> for the meaning of these options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame the same type as the first element of <code>to_combine</code>
</p>

<hr>
<h2 id='bindRowsDS'>Bind multiple data frames by row.</h2><span id='topic+bindRowsDS'></span>

<h3>Description</h3>

<p>DataSHIELD implementation of <code>dplyr::bind_rows</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindRowsDS(to_combine = NULL, .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bindRowsDS_+3A_to_combine">to_combine</code></td>
<td>
<p>Data frames to combine. Each argument can either be a data frame, a list that
could be a data frame, or a list of data frames. Columns are matched by name, and any missing
columns will be filled with NA.</p>
</td></tr>
<tr><td><code id="bindRowsDS_+3A_.id">.id</code></td>
<td>
<p>he name of an optional identifier column. Provide a string to create an output column
that identifies each input. The column will use names if available, otherwise it will use
positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame the same type as the first element of <code>to_combine</code>
</p>

<hr>
<h2 id='caseWhenDS'>Performs dplyr case_when</h2><span id='topic+caseWhenDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::case_when</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caseWhenDS(tidy_expr = NULL, .default = NULL, .ptype = NULL, .size = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caseWhenDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>A sequence of two-sided formulas. The left hand side (LHS) determines which
values match this case. The right hand side (RHS) provides the replacement value.
The LHS inputs must evaluate to logical vectors.
The RHS inputs will be coerced to their common type.
All inputs will be recycled to their common size. That said, we encourage all LHS inputs to be
the same size. Recycling is mainly useful for RHS inputs, where you might supply a size 1 input
that will be recycled to the size of the LHS inputs.
NULL inputs are ignored.</p>
</td></tr>
<tr><td><code id="caseWhenDS_+3A_.default">.default</code></td>
<td>
<p>The value used when all of the LHS inputs return either FALSE or NA.</p>
</td></tr>
<tr><td><code id="caseWhenDS_+3A_.ptype">.ptype</code></td>
<td>
<p>An optional prototype declaring the desired output type. If supplied, this overrides the common type of true, false, and missing.</p>
</td></tr>
<tr><td><code id="caseWhenDS_+3A_.size">.size</code></td>
<td>
<p>An optional size declaring the desired output size. If supplied, this overrides the size of condition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same size as the common size computed from the inputs in <code>tidy_expr</code> and the same type as the common type of the RHS inputs in <code>tidy_expr</code>.
</p>

<hr>
<h2 id='checkPermissivePrivacyControlLevel'>checkPermissivePrivacyControlLevel</h2><span id='topic+checkPermissivePrivacyControlLevel'></span>

<h3>Description</h3>

<p>This serverside function check that the server is running in &quot;permissive&quot; privacy control level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPermissivePrivacyControlLevel(privacyControlLevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkPermissivePrivacyControlLevel_+3A_privacycontrollevels">privacyControlLevels</code></td>
<td>
<p>is a vector of strings which contains the privacy control level names which are permitted by the calling method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests whether the R option &quot;datashield.privacyControlLevel&quot; is set to &quot;permissive&quot;, if it isn't
will cause a call to stop() with the message &quot;BLOCKED: The server is running in 'non-permissive' mode which
has caused this method to be blocked&quot;.
</p>


<h3>Value</h3>

<p>Returns an error if the method is not permitted; otherwise, no value is returned.
</p>


<h3>Author(s)</h3>

<p>Wheater, Dr SM., DataSHIELD Team.
</p>

<hr>
<h2 id='distinctDS'>Keep distinct/unique rows</h2><span id='topic+distinctDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::distinct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinctDS(tidy_expr, df.name, .keep_all)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distinctDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Optional variables to use when determining uniqueness. If there are multiple rows for
a given combination of inputs, only the first row will be preserved. If omitted, will use all
variables in the data frame.</p>
</td></tr>
<tr><td><code id="distinctDS_+3A_df.name">df.name</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy data frame
(e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="distinctDS_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If TRUE, keep all variables in df.name If a combination of expr is not distinct,
this keeps the first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>df.name</code>, typically a data frame or tibble.
</p>

<hr>
<h2 id='filterDS'>Performs dplyr filter</h2><span id='topic+filterDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::filter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterDS(tidy_expr, df.name, .by, .preserve)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Diffused expression that return a logical value, and are defined in terms of the
variables in <code>df.name</code>.</p>
</td></tr>
<tr><td><code id="filterDS_+3A_df.name">df.name</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy data frame
(e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="filterDS_+3A_.by">.by</code></td>
<td>
<p>Optionally, a selection of columns to group by for just this operation, functioning as
an alternative to <code>group_by</code>.</p>
</td></tr>
<tr><td><code id="filterDS_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the df.name input is grouped. If .preserve = FALSE (the default),
the grouping structure is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>df.name</code>, typically a data frame or tibble.
</p>

<hr>
<h2 id='groupByDS'>Group by one or more variables</h2><span id='topic+groupByDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::group_by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupByDS(tidy_expr, df.name, .add, .drop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupByDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Diffused grouping expression.</p>
</td></tr>
<tr><td><code id="groupByDS_+3A_df.name">df.name</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy data frame
(e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="groupByDS_+3A_.add">.add</code></td>
<td>
<p>When FALSE, the default, <code>group_by()</code> will override existing groups. To add to
the existing groups, use .add = TRUE.</p>
</td></tr>
<tr><td><code id="groupByDS_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the data? The default is
TRUE except when df.name has been previously grouped with .drop = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grouped data frame with class grouped_df, unless the combination of <code>tidy_expr</code>
and <code>.add</code> yields a empty set of grouping columns, in which case a tibble will be returned.
</p>

<hr>
<h2 id='groupKeysDS'>Performs dplyr <code>group_keys</code>.</h2><span id='topic+groupKeysDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::group_keys</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupKeysDS(tidy_select, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupKeysDS_+3A_tidy_select">tidy_select</code></td>
<td>
<p>Unused in this function.</p>
</td></tr>
<tr><td><code id="groupKeysDS_+3A_x">x</code></td>
<td>
<p>a grouped tibble.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame describing the groups.
</p>

<hr>
<h2 id='ifElseDS'>Vectorised if-else</h2><span id='topic+ifElseDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dply::if_else</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifElseDS(
  condition = NULL,
  true = NULL,
  false = NULL,
  missing = NULL,
  ptype = NULL,
  size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifElseDS_+3A_condition">condition</code></td>
<td>
<p>A list, specifying a logical vector in tidyverse syntax, ie data and column names unquoted.</p>
</td></tr>
<tr><td><code id="ifElseDS_+3A_true">true</code></td>
<td>
<p>Vector to use for TRUE value of condition.</p>
</td></tr>
<tr><td><code id="ifElseDS_+3A_false">false</code></td>
<td>
<p>Vector to use for FALSE value of condition.</p>
</td></tr>
<tr><td><code id="ifElseDS_+3A_missing">missing</code></td>
<td>
<p>If not NULL, will be used as the value for NA values of condition. Follows the same size and type rules as true and false.</p>
</td></tr>
<tr><td><code id="ifElseDS_+3A_ptype">ptype</code></td>
<td>
<p>An optional prototype declaring the desired output type. If supplied, this overrides the common type of true, false, and missing.</p>
</td></tr>
<tr><td><code id="ifElseDS_+3A_size">size</code></td>
<td>
<p>An optional size declaring the desired output size. If supplied, this overrides the size of condition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same size as <code>condition</code> and the same type as the common type of <code>true</code>, <code>false</code>, and <code>missing</code>.
</p>

<hr>
<h2 id='listPermittedTidyverseFunctionsDS'>List of Permitted Tidyverse Functions</h2><span id='topic+listPermittedTidyverseFunctionsDS'></span>

<h3>Description</h3>

<p>This function returns a vector of function names that are permitted to be passed within the
dsTidyverse functions, e.g. within the 'tidy_select' argument of 'ds.mutate.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listPermittedTidyverseFunctionsDS()
</code></pre>


<h3>Value</h3>

<p>A character vector of function names, each representing a permitted function. Functions
not included in this list will be blocked.
</p>

<hr>
<h2 id='mutateDS'>Create, modify, and delete columns</h2><span id='topic+mutateDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>mutate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutateDS(tidy_expr, df.name, .keep = NULL, .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutateDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Name-value pairs. The name gives the name of the column in the output.</p>
</td></tr>
<tr><td><code id="mutateDS_+3A_df.name">df.name</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="mutateDS_+3A_.keep">.keep</code></td>
<td>
<p>.keep Control which columns from <code>df.name</code> are retained in the output. Grouping
columns and columns created by <code>tidy_expr</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code>: Retains all columns from <code>df.name</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code>: Retains only the columns used in <code>tidy_expr</code> to create new columns.
</p>
</li>
<li> <p><code>"unused"</code>: Retains only the columns not used in <code>tidy_expr</code> to create new columns. This is useful if you generate new columns but no longer need the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code>: Doesn't retain any extra columns from <code>df.name</code>. Only the grouping variables and columns created by <code>tidy_expr</code> are kept.
</p>
</li></ul>

<p>Grouping columns and columns created by <code>tidy_expr</code> are always kept.</p>
</td></tr>
<tr><td><code id="mutateDS_+3A_.before">.before</code></td>
<td>
<p>&lt;tidy-select&gt; Optionally, control where new columns should appear (the default is
to add to the right hand side). See <code>relocate</code> for more details.</p>
</td></tr>
<tr><td><code id="mutateDS_+3A_.after">.after</code></td>
<td>
<p>&lt;tidy-select&gt; Optionally, control where new columns should appear (the default is
to add to the right hand side). See <code>relocate</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>df.name</code>, typically a data frame or tibble.
</p>

<hr>
<h2 id='renameDS'>Rename columns</h2><span id='topic+renameDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of<code>dplyr::rename</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameDS(tidy_expr, df.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="renameDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>list containing diffused expression.</p>
</td></tr>
<tr><td><code id="renameDS_+3A_df.name">df.name</code></td>
<td>
<p>A data frame or tibble.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>df.name</code>, typically a data frame or tibble.
</p>

<hr>
<h2 id='selectDS'>Keep or drop columns using their names and types</h2><span id='topic+selectDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::select</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectDS(tidy_expr, df.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>One or more unquoted expressions separated by commas.</p>
</td></tr>
<tr><td><code id="selectDS_+3A_df.name">df.name</code></td>
<td>
<p>A data frame or tibble.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs dplyr select
</p>


<h3>Value</h3>

<p>An object of the same type as <code>df.name</code>, typically a data frame or tibble.
</p>

<hr>
<h2 id='sliceDS'>Subset rows using their positions</h2><span id='topic+sliceDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::slice</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliceDS(tidy_expr, df.name, .by, .preserve)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sliceDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Provide either positive values to keep, or negative values to drop. The values
provided must be either all positive or all negative. Indices beyond the number of rows in the
input are silently ignored.</p>
</td></tr>
<tr><td><code id="sliceDS_+3A_df.name">df.name</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy data frame
(e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="sliceDS_+3A_.by">.by</code></td>
<td>
<p>Optionally, a selection of columns to group by for just this operation, functioning as
an alternative to <code>group_by</code>.</p>
</td></tr>
<tr><td><code id="sliceDS_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the df.name input is grouped. If .preserve = FALSE (the default),
the grouping structure is recalculated based on the resulting data, otherwise the grouping is
kept as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>df.name</code>, typically a data frame or tibble.
</p>

<hr>
<h2 id='ungroupDS'>Remove grouping from a tibble or data frame</h2><span id='topic+ungroupDS'></span>

<h3>Description</h3>

<p>DataSHIELD implentation of <code>dplyr::ungroup</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ungroupDS(tidy_expr, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ungroupDS_+3A_tidy_expr">tidy_expr</code></td>
<td>
<p>Unused in this function.</p>
</td></tr>
<tr><td><code id="ungroupDS_+3A_x">x</code></td>
<td>
<p>A tibble.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ungrouped data frame or tibble.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
