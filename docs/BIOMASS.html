<!DOCTYPE html><html lang="en"><head><title>Help for package BIOMASS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BIOMASS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BIOMASS-package'><p>BIOMASS: Estimating Aboveground Biomass and Its Uncertainty in Tropical Forests</p></a></li>
<li><a href='#AGBmonteCarlo'><p>Propagating above ground biomass (AGB) or carbon (AGC) errors to the stand level</p></a></li>
<li><a href='#apgFamilies'><p>Angiosperm Phylogeny Group (APG III) dataset</p></a></li>
<li><a href='#attributeTree'><p>Attribute trees to subplots</p></a></li>
<li><a href='#attributeTreeCoord'><p>Attribute GPS coordinates to trees</p></a></li>
<li><a href='#bilinear_interpolation'><p>Generalized bilinear interpolation of coordinates</p></a></li>
<li><a href='#cacheManager'><p>Function that return a possibly cached file, transparently downloading it if missing</p></a></li>
<li><a href='#cachePath'><p>Function used to build a file path based on a cache folder</p></a></li>
<li><a href='#check_plot_coord'><p>Check coordinates of plot corners and trees</p></a></li>
<li><a href='#clearCache'><p>Function to clear cache content and possibly remove it</p></a></li>
<li><a href='#computeAGB'><p>Computing tree above ground biomass (AGB)</p></a></li>
<li><a href='#computeE'><p>Retrieving Chave's environmental index</p></a></li>
<li><a href='#computeFeldRegion'><p>Retrieving Feldpausch regions</p></a></li>
<li><a href='#correctCoordGPS'><p>Correct the GPS coordinates</p></a></li>
<li><a href='#correctTaxo'><p>Correct trees taxonomy</p></a></li>
<li><a href='#createCache'><p>Function used to create or activate a permanent cache.</p></a></li>
<li><a href='#cutPlot'><p>Divides one or more plots into subplots</p></a></li>
<li><a href='#divide_plot'><p>Divides one ore more plots into subplots</p></a></li>
<li><a href='#feldCoef'><p>Feldpausch et al. 2012 coefficients for generalized height-diameter models</p></a></li>
<li><a href='#genusFamily'><p>Genus Family database</p></a></li>
<li><a href='#getBioclimParam'><p>Retrieving bioclimatic parameters</p></a></li>
<li><a href='#getTaxonomy'><p>Retrieve trees taxonomy</p></a></li>
<li><a href='#getWoodDensity'><p>Estimating wood density</p></a></li>
<li><a href='#HDmethods'><p>HDmethods</p></a></li>
<li><a href='#latlong2UTM'><p>Translate the long lat coordinate in UTM coordinate</p></a></li>
<li><a href='#modelHD'><p>Fitting height-diameter models</p></a></li>
<li><a href='#NouraguesCoords'><p>Nouragues plot coordinates</p></a></li>
<li><a href='#NouraguesHD'><p>Height-Diameter data</p></a></li>
<li><a href='#NouraguesPlot201'><p>Nouragues plot 201 coordinates</p></a></li>
<li><a href='#NouraguesTrees'><p>Nouragues forest dataset</p></a></li>
<li><a href='#numberCorner'><p>Get the UTM coordinates with the corner of the plot</p></a></li>
<li><a href='#param_4'><p>Posterior distribution of Chave et al.'s 2014 equation 4 parameters</p></a></li>
<li><a href='#param_7'><p>Posterior distribution of parameters associated with the equation 7 by Chave et al. 2014.</p></a></li>
<li><a href='#predictHeight'><p>Tree height predictions</p></a></li>
<li><a href='#procrust'><p>Procrust analysis</p></a></li>
<li><a href='#retrieveH'><p>Retrieving tree height from models</p></a></li>
<li><a href='#sd_10'><p>Mean standard deviation of wood density estimates at different taxonomic levels</p></a></li>
<li><a href='#subplot_summary'><p>Summarise and display tree information by subplot</p></a></li>
<li><a href='#summaryByPlot'><p>Summarise by plot the posterior distribution of AGB values</p></a></li>
<li><a href='#wdData'><p>The global wood density database</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Aboveground Biomass and Its Uncertainty in Tropical
Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions to estimate aboveground biomass/carbon and its uncertainty in tropical forests. 
	These functions allow to (1) retrieve and to correct taxonomy, (2) estimate wood density and its uncertainty, 
	(3) construct height-diameter models, (4) manage tree and plot coordinates, 
	(5) estimate the aboveground biomass/carbon at the stand level with associated uncertainty. 
	To cite 'BIOMASS', please use citation("BIOMASS"). 
	See more in the article of Réjou-Méchain et al. (2017) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12753">doi:10.1111/2041-210X.12753</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.6)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://umr-amap.github.io/BIOMASS/">https://umr-amap.github.io/BIOMASS/</a>,
<a href="https://github.com/umr-amap/BIOMASS/">https://github.com/umr-amap/BIOMASS/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/umr-amap/BIOMASS/issues/">https://github.com/umr-amap/BIOMASS/issues/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>minpack.lm, jsonlite, methods, proj4, graphics, stats, utils,
data.table (&ge; 1.9.8), rappdirs, sf, terra, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, prettydoc, testthat, vdiffr, curl, geodata,
httr2, pkgdown, dplyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-24 12:58:52 UTC; lamonica</td>
</tr>
<tr>
<td>Author:</td>
<td>Maxime Réjou-Méchain [aut, dtc],
  Guillaume Cornu <a href="https://orcid.org/0000-0002-7523-5176"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Dominique Lamonica [aut, cre],
  Arthur Bailly [aut],
  Arthur Pere [aut],
  Ariane Tanguy [aut],
  Jerome Chave [dtc],
  Ted Feldpausch [dtc],
  Philippe Verley [ctb],
  Camille Piponiot [aut],
  Bruno Hérault [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominique Lamonica &lt;dominique.lamonica@ird.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-24 13:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='BIOMASS-package'>BIOMASS: Estimating Aboveground Biomass and Its Uncertainty in Tropical Forests</h2><span id='topic+BIOMASS'></span><span id='topic+BIOMASS-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Contains functions to estimate aboveground biomass/carbon and its uncertainty in tropical forests. These functions allow to (1) retrieve and to correct taxonomy, (2) estimate wood density and its uncertainty, (3) construct height-diameter models, (4) manage tree and plot coordinates, (5) estimate the aboveground biomass/carbon at the stand level with associated uncertainty. To cite 'BIOMASS', please use citation(&quot;BIOMASS&quot;). See more in the article of Réjou-Méchain et al. (2017) <a href="https://doi.org/10.1111/2041-210X.12753">doi:10.1111/2041-210X.12753</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dominique Lamonica <a href="mailto:dominique.lamonica@ird.fr">dominique.lamonica@ird.fr</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Maxime Réjou-Méchain <a href="mailto:maxime.rejou@gmail.com">maxime.rejou@gmail.com</a> [data contributor]
</p>
</li>
<li><p> Guillaume Cornu <a href="mailto:gcornu@cirad.fr">gcornu@cirad.fr</a> (<a href="https://orcid.org/0000-0002-7523-5176">ORCID</a>)
</p>
</li>
<li><p> Arthur Bailly <a href="mailto:arthur.bailly@ird.fr">arthur.bailly@ird.fr</a>
</p>
</li>
<li><p> Arthur Pere
</p>
</li>
<li><p> Ariane Tanguy
</p>
</li>
<li><p> Camille Piponiot
</p>
</li>
<li><p> Bruno Hérault <a href="mailto:bruno.herault@cirad.fr">bruno.herault@cirad.fr</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Jerome Chave <a href="mailto:jerome.chave@univ-tlse3.fr">jerome.chave@univ-tlse3.fr</a> [data contributor]
</p>
</li>
<li><p> Ted Feldpausch <a href="mailto:T.R.Feldpausch@exeter.ac.uk">T.R.Feldpausch@exeter.ac.uk</a> [data contributor]
</p>
</li>
<li><p> Philippe Verley <a href="mailto:philippe.verley@ird.fr">philippe.verley@ird.fr</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://umr-amap.github.io/BIOMASS/">https://umr-amap.github.io/BIOMASS/</a>
</p>
</li>
<li> <p><a href="https://github.com/umr-amap/BIOMASS/">https://github.com/umr-amap/BIOMASS/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/umr-amap/BIOMASS/issues/">https://github.com/umr-amap/BIOMASS/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='AGBmonteCarlo'>Propagating above ground biomass (AGB) or carbon (AGC) errors to the stand level</h2><span id='topic+AGBmonteCarlo'></span>

<h3>Description</h3>

<p>Propagation of the errors throughout the steps needed to compute AGB or AGC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AGBmonteCarlo(
  D,
  WD = NULL,
  errWD = NULL,
  H = NULL,
  errH = NULL,
  HDmodel = NULL,
  coord = NULL,
  Dpropag = NULL,
  n = 1000,
  Carbon = FALSE,
  Dlim = NULL,
  plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AGBmonteCarlo_+3A_d">D</code></td>
<td>
<p>Vector of tree diameters (in cm)</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_wd">WD</code></td>
<td>
<p>Vector of wood density estimates (in g/cm3)</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_errwd">errWD</code></td>
<td>
<p>Vector of error associated to the wood density estimates (should be of the same size as <code>WD</code>)</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_h">H</code></td>
<td>
<p>(option 1) Vector of tree heights (in m). If set, <code>errH</code> must be set too.</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_errh">errH</code></td>
<td>
<p>(if <code>H</code>) Residual standard error (RSE) of a model or vector of errors (sd values) associated to tree height
values (in the latter case the vector should be of the same length as <code>H</code>).</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_hdmodel">HDmodel</code></td>
<td>
<p>(option 2) Model used to estimate tree height from tree diameter (output from <code><a href="#topic+modelHD">modelHD()</a></code>, see example).</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_coord">coord</code></td>
<td>
<p>(option 3) Coordinates of the site(s), either a vector giving a single site (e.g. c(longitude, latitude))
or a matrix/dataframe with two columns (e.g. cbind(longitude, latitude)). The coordinates are used to predict
height-diameter allometry with bioclimatic variables.</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_dpropag">Dpropag</code></td>
<td>
<p>This variable can take three kind of values, indicating how to propagate the errors on diameter measurements:
a single numerical value or a vector of the same size as <code>D</code>, both representing the standard deviation associated
with the diameter measurements or <code>"chave2004"</code> (an important error on 5 percent of the measures, a smaller error on
95 percent of the trees).</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_n">n</code></td>
<td>
<p>Number of iterations. Cannot be smaller than 50 or larger than 1000. By default <code>n = 1000</code></p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_carbon">Carbon</code></td>
<td>
<p>(logical) Whether or not the propagation should be done up to the carbon value (FALSE by default).</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_dlim">Dlim</code></td>
<td>
<p>(optional) Minimum diameter (in cm) for which above ground biomass should be calculated (all diameter below
<code>Dlim</code> will have a 0 value in the output).</p>
</td></tr>
<tr><td><code id="AGBmonteCarlo_+3A_plot">plot</code></td>
<td>
<p>(optional) Plot ID, must be either one value, or a vector of the same length as D. This argument is used to build
stand-specific HD models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Rejou-Mechain et al. (2017) for all details on the error propagation procedure.
</p>


<h3>Value</h3>

<p>Returns a list  with (if Carbon is FALSE):
</p>

<ul>
<li> <p><code>meanAGB</code>: Mean stand AGB value following the error propagation
</p>
</li>
<li> <p><code>medAGB</code>: Median stand AGB value following the error propagation
</p>
</li>
<li> <p><code>sdAGB</code>: Standard deviation of the stand AGB value following the error propagation
</p>
</li>
<li> <p><code>credibilityAGB</code>: Credibility interval at 95\
</p>
</li>
<li> <p><code>AGB_simu</code>: Matrix with the AGB of the trees (rows) times the n iterations (columns)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Maxime REJOU-MECHAIN, Bruno HERAULT, Camille PIPONIOT, Ariane TANGUY, Arthur PERE
</p>


<h3>References</h3>

<p>Chave, J. et al. (2004). <em>Error propagation and scaling for tropical forest biomass estimates</em>.
Philosophical Transactions of the Royal Society B: Biological Sciences, 359(1443), 409-420.
</p>
<p>Rejou-Mechain et al. (2017).
<em>BIOMASS: An R Package for estimating above-ground biomass and its uncertainty in tropical forests</em>.
Methods in Ecology and Evolution, 8 (9), 1163-1167.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a database
data(NouraguesHD)
data(NouraguesTrees)

# Modelling height-diameter relationship
HDmodel &lt;- modelHD(D = NouraguesHD$D, H = NouraguesHD$H, method = "log2")

# Retrieving wood density values

NouraguesWD &lt;- getWoodDensity(NouraguesTrees$Genus, NouraguesTrees$Species,
  stand = NouraguesTrees$Plot
)


# Propagating errors with a standard error for Wood density

resultMC &lt;- AGBmonteCarlo(
  D = NouraguesTrees$D, WD = NouraguesWD$meanWD,
  errWD = NouraguesWD$sdWD, HDmodel = HDmodel
)


# If only the coordinates are available
coord &lt;- c(-52.683213,4.083024 )

resultMC &lt;- AGBmonteCarlo(
  D = NouraguesTrees$D, WD = NouraguesWD$meanWD,
  errWD = NouraguesWD$sdWD, coord = coord
)


# Propagating errors with a standard error in wood density in all plots at once

NouraguesTrees$meanWD &lt;- NouraguesWD$meanWD
NouraguesTrees$sdWD &lt;- NouraguesWD$sdWD
resultMC &lt;- by(
  NouraguesTrees, NouraguesTrees$Plot,
  function(x) AGBmonteCarlo(
      D = x$D, WD = x$meanWD, errWD = x$sdWD,
      HDmodel = HDmodel, Dpropag = "chave2004"
    )
)
meanAGBperplot &lt;- unlist(sapply(resultMC, "[", 1))
credperplot &lt;- sapply(resultMC, "[", 4)


</code></pre>

<hr>
<h2 id='apgFamilies'>Angiosperm Phylogeny Group (APG III) dataset</h2><span id='topic+apgFamilies'></span>

<h3>Description</h3>

<p>APGIII Families taken from the Angiosperm Phylogeny Website (http://www.mobot.org/MOBOT/research/APweb/)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("apgFamilies")
</code></pre>


<h3>Format</h3>

<p>A data frame with 502 observations on the following 2 variables:
</p>

<ul>
<li> <p><code>order</code>: Vector of order
</p>
</li>
<li> <p><code>famAPG</code>: Vector of APGIII families
</p>
</li></ul>



<h3>Source</h3>

<p>Stevens, P. F. (2001 onwards). <em>Angiosperm Phylogeny Website</em>.
Version 12, July 2012. Retrieved on 2016-07-25 http://www.mobot.org/MOBOT/research/APweb/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(apgFamilies)
str(apgFamilies)
</code></pre>

<hr>
<h2 id='attributeTree'>Attribute trees to subplots</h2><span id='topic+attributeTree'></span>

<h3>Description</h3>

<p>Function to attribute the trees on each subplot, the trees that are at the exterior of the subplot will be marked as NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attributeTree(xy, plot, coordAbs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attributeTree_+3A_xy">xy</code></td>
<td>
<p>The coordinates of the trees for each plot</p>
</td></tr>
<tr><td><code id="attributeTree_+3A_plot">plot</code></td>
<td>
<p>The label of the plot (same length as the number of rows of <code>xy</code>)</p>
</td></tr>
<tr><td><code id="attributeTree_+3A_coordabs">coordAbs</code></td>
<td>
<p>Output of the function <code><a href="#topic+cutPlot">cutPlot()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the code of the subplot for each trees, the code will be <code>plot_X_Y</code>. <code>X</code> and <code>Y</code> are the coordinate
where the tree is inside the plot in regards to the corresponding subplot.
</p>


<h3>Author(s)</h3>

<p>Arthur PERE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Trees relative coordinates
xy &lt;- data.frame(x = runif(200, min = 0, max = 200), y = runif(200, min = 0, max = 200))


# cut the plot in multiple part
coord &lt;- data.frame(X = rep(c(0, 200, 0, 200), 2), Y = rep(c(0, 0, 200, 200), 2))
coord[1:4, ] &lt;- coord[1:4, ] + 5000
coord[5:8, ] &lt;- coord[5:8, ] + 6000
corner &lt;- rep(c(1, 2, 4, 3), 2)
plot &lt;- rep(c("plot1", "plot2"), each = 4)

cut &lt;- cutPlot(coord, plot, corner, gridsize = 100, dimX = 200, dimY = 200)


# Assign a plot to 200 trees
plot &lt;- rep(c("plot1", "plot2"), 100)

# attribute trees to subplots
attributeTree(xy, plot, cut)
</code></pre>

<hr>
<h2 id='attributeTreeCoord'>Attribute GPS coordinates to trees</h2><span id='topic+attributeTreeCoord'></span>

<h3>Description</h3>

<p>Attribute GPS coordinates to trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attributeTreeCoord(xy, plot, dim, coordAbs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attributeTreeCoord_+3A_xy">xy</code></td>
<td>
<p>The relative coordinates of the trees within each plot</p>
</td></tr>
<tr><td><code id="attributeTreeCoord_+3A_plot">plot</code></td>
<td>
<p>The label of the plot (same length as the number of rows of <code>xy</code> or length of 1)</p>
</td></tr>
<tr><td><code id="attributeTreeCoord_+3A_dim">dim</code></td>
<td>
<p>The dimension of the plot (either one value if the plot is a square or a vector if a rectangle)</p>
</td></tr>
<tr><td><code id="attributeTreeCoord_+3A_coordabs">coordAbs</code></td>
<td>
<p>The result of the function <code><a href="#topic+cutPlot">cutPlot()</a></code> or <code><a href="#topic+numberCorner">numberCorner()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns:
- <code>Xproj</code>: The <code>X</code> coordinates in the absolute coordinate system
- <code>Yproj</code>: The <code>Y</code> coordinates in the absolute coordinate system
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Trees relative coordinates
xy &lt;- data.frame(x = runif(200, min = 0, max = 200), y = runif(200, min = 0, max = 200))


# cut the plot in multiple part
coord &lt;- data.frame(X = rep(c(0, 200, 0, 200), 2), Y = rep(c(0, 0, 200, 200), 2))
coord[1:4, ] &lt;- coord[1:4, ] + 5000
coord[5:8, ] &lt;- coord[5:8, ] + 6000
corner &lt;- rep(c(1, 2, 4, 3), 2)
Forestplot &lt;- rep(c("plot1", "plot2"), each = 4)

Outcut &lt;- cutPlot(coord, Forestplot, corner, gridsize = 100, dimX = 200, dimY = 200)


# Assign a plot to 200 trees
Forestplot &lt;- rep(c("plot1", "plot2"), 100)

# attribute trees to subplots
attributeTreeCoord(xy, Forestplot, dim =100,coordAbs = Outcut)
</code></pre>

<hr>
<h2 id='bilinear_interpolation'>Generalized bilinear interpolation of coordinates</h2><span id='topic+bilinear_interpolation'></span>

<h3>Description</h3>

<p>Apply a generalized bilinear interpolation to convert any coordinates from one original coordinate system to another, using the plot's 4 corner coordinates of both system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bilinear_interpolation(
  coord,
  from_corner_coord,
  to_corner_coord,
  ordered_corner = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bilinear_interpolation_+3A_coord">coord</code></td>
<td>
<p>a matrix or data.frame : coordinates to be transformed, with X and Y corresponding to the first two columns</p>
</td></tr>
<tr><td><code id="bilinear_interpolation_+3A_from_corner_coord">from_corner_coord</code></td>
<td>
<p>a matrix or data.frame : corner coordinates of the rectangular plot in the original coordinate system, with X and Y corresponding to the first two columns</p>
</td></tr>
<tr><td><code id="bilinear_interpolation_+3A_to_corner_coord">to_corner_coord</code></td>
<td>
<p>a matrix or data.frame : corner coordinates of the plot in the coordinate system to be projected, with the same line order as from_corner_coord and , with X and Y corresponding to the first two columns</p>
</td></tr>
<tr><td><code id="bilinear_interpolation_+3A_ordered_corner">ordered_corner</code></td>
<td>
<p>a logical, if TRUE : indicating that from_corner_coord and to_corner_coord rows are sorted in correct order (clockwise or counter-clockwise)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot represented by the 4 coordinates in from_corner_coord must have 4 right angles, i.e. a rectangular (or square) plot.
</p>
<p>When ordered_corner = FALSE, the function automatically reassigns corners in a counter-clockwise order.
</p>


<h3>Value</h3>

<p>a data.frame containing the converted coordinates
</p>


<h3>Author(s)</h3>

<p>Arthur Bailly
</p>


<h3>References</h3>

<p>C. -C. Wei and C. -H. Chen, &quot;Generalized Bilinear Interpolation of Motion Vectors for Quad-Tree Mesh,&quot; 2008 International Conference on Intelligent Information Hiding and Multimedia Signal Processing, Harbin, China, 2008, pp. 635-638, doi: 10.1109/IIH-MSP.2008.283.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>from_corner_coord &lt;- expand.grid(X = c(0, 100), Y = c(0, 50))
rot_mat &lt;- matrix(c(cos(-pi/6),sin(-pi/6),-sin(-pi/6),cos(-pi/6)),nrow=2)
to_corner_coord &lt;- as.matrix(from_corner_coord) %*% rot_mat
to_corner_coord &lt;- sweep(to_corner_coord, 2, c(50,100), FUN = "+")
coord &lt;- expand.grid(X = seq(0,100,10), Y = seq(0,50,5))
projCoord = bilinear_interpolation(coord = coord,
                                   from_corner_coord = from_corner_coord,
                                   to_corner_coord = to_corner_coord)
</code></pre>

<hr>
<h2 id='cacheManager'>Function that return a possibly cached file, transparently downloading it if missing</h2><span id='topic+cacheManager'></span>

<h3>Description</h3>

<p>Function that return a possibly cached file, transparently downloading it if missing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cacheManager(nameFile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cacheManager_+3A_namefile">nameFile</code></td>
<td>
<p>character. file to resolve cached path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>file path of the resolved cached file.
</p>


<h3>Localisation</h3>

<p>Cache path discovery protocol
</p>

<ol>
<li><p> BIOMASS.cache option set to an <strong>existing</strong> folder
</p>
</li>
<li> <p><strong>existing</strong> user data folder <code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>
</p>

<ul>
<li><p> On Linux : <code style="white-space: pre;">&#8288;~/.local/share/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Mac OS X : <code style="white-space: pre;">&#8288;~/Library/Application Support/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows 7 up to 10 : <code style="white-space: pre;">&#8288;C:\\Users\\&lt;username&gt;\\AppData\\Local\\R\\BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows XP : <code style="white-space: pre;">&#8288;C:\\Documents and Settings\\&lt;username&gt;\\Data\\R\\BIOMASS&#8288;</code>
</p>
</li></ul>

</li>
<li><p> fallback to R session tempdir
</p>
</li></ol>


<hr>
<h2 id='cachePath'>Function used to build a file path based on a cache folder</h2><span id='topic+cachePath'></span>

<h3>Description</h3>

<p>Parameters are similar to that of file.path function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cachePath(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cachePath_+3A_...">...</code></td>
<td>
<p>character vectors. Elements of the subpath of cache path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of normalized file path with a source attribute
holding a hint to cache path source (&quot;option&quot;, &quot;data&quot;, &quot;temp&quot;)
</p>


<h3>Localisation</h3>

<p>Cache path discovery protocol
</p>

<ol>
<li><p> BIOMASS.cache option set to an <strong>existing</strong> folder
</p>
</li>
<li> <p><strong>existing</strong> user data folder <code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>
</p>

<ul>
<li><p> On Linux : <code style="white-space: pre;">&#8288;~/.local/share/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Mac OS X : <code style="white-space: pre;">&#8288;~/Library/Application Support/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows 7 up to 10 : <code style="white-space: pre;">&#8288;C:\\Users\\&lt;username&gt;\\AppData\\Local\\R\\BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows XP : <code style="white-space: pre;">&#8288;C:\\Documents and Settings\\&lt;username&gt;\\Data\\R\\BIOMASS&#8288;</code>
</p>
</li></ul>

</li>
<li><p> fallback to R session tempdir
</p>
</li></ol>


<hr>
<h2 id='check_plot_coord'>Check coordinates of plot corners and trees</h2><span id='topic+check_plot_coord'></span>

<h3>Description</h3>

<p>Quality check of plot corner and tree coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_plot_coord(
  corner_data,
  proj_coord = NULL,
  longlat = NULL,
  rel_coord,
  trust_GPS_corners,
  draw_plot = TRUE,
  tree_data = NULL,
  tree_coords = NULL,
  max_dist = 10,
  rm_outliers = TRUE,
  plot_ID = NULL,
  tree_plot_ID = NULL,
  ref_raster = NULL,
  prop_tree = NULL,
  ask = T
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_plot_coord_+3A_corner_data">corner_data</code></td>
<td>
<p>A data frame, data frame extension, containing the plot corner coordinates.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_proj_coord">proj_coord</code></td>
<td>
<p>(optional, if longlat is not supplied) A character vector of length 2, specifying the column names (resp. x, y) of the corner projected coordinates.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_longlat">longlat</code></td>
<td>
<p>(optional, if proj_coord is not supplied) A character vector of length 2 specifying the column names of the corner geographic coordinates (long,lat).</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_rel_coord">rel_coord</code></td>
<td>
<p>A character vector of length 2 specifying the column names (resp. x, y) of the corner relative coordinates (that of the field, ie, the local ones).</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_trust_gps_corners">trust_GPS_corners</code></td>
<td>
<p>A logical indicating whether or not you trust the GPS coordinates of the plot's corners. See details.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_draw_plot">draw_plot</code></td>
<td>
<p>A logical indicating if the plot design should be displayed and returned.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_tree_data">tree_data</code></td>
<td>
<p>A data frame, data frame extension, containing the relative coordinates (field/local coordinates) of the trees and optional other tree metrics.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_tree_coords">tree_coords</code></td>
<td>
<p>A character vector specifying the column names of the tree relative coordinates.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_max_dist">max_dist</code></td>
<td>
<p>If dealing with repeated measurements of each corner : the maximum distance (in meters) above which GPS measurements should be considered outliers (default 15 m).</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_rm_outliers">rm_outliers</code></td>
<td>
<p>If TRUE and dealing with repeated measurements of each corner, then outliers are removed from the coordinate calculation of the referenced corners.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_plot_id">plot_ID</code></td>
<td>
<p>If dealing with multiple plots : a character indicating the variable name for corner plot IDs in corner_data.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_tree_plot_id">tree_plot_ID</code></td>
<td>
<p>If dealing with multiple plots : a character indicating the variable name for tree plot IDs in tree_data.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_ref_raster">ref_raster</code></td>
<td>
<p>A SpatRaster object from terra package, typically a chm raster created from LiDAR data.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_prop_tree">prop_tree</code></td>
<td>
<p>The column name variable of tree_data for which the tree visualization will be proportional.</p>
</td></tr>
<tr><td><code id="check_plot_coord_+3A_ask">ask</code></td>
<td>
<p>If TRUE and dealing with multiple plots, then prompt user before displaying each plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If trust_GPS_corners is TRUE, corner coordinates in the projected coordinate system are averaging by corner (if multiple measures) and outlier corners are identified sequentially using these averages and the max_dist argument. Then, projected coordinates of the trees are calculated from the local coordinates using a bilinear interpolation that follows the correspondence of the corners between these two coordinate systems. Be aware that this projection only works if the plot, in the relative coordinates system, is rectangular (ie, has 4 right angles).
</p>
<p>If trust_GPS_corners is FALSE, corner coordinates in the projected coordinate system are calculated by a procrust analysis that preserves the shape and dimensions of the plot in the local coordinate system. Outlier corners are also identified sequentially and projected coordinates of the trees are calculated by applying the resulting procrust analysis.
</p>
<p>If longlat is supplied instead of proj_coord, the function will first convert the long/lat coordinates into UTM coordinates. An error may result if the parcel is located right between two UTM zones. In this case, the user has to convert himself his long/lat coordinates into any projected coordinates which have the same dimension than his local coordinates (in meters most of the time).
</p>
<p>If longlat and proj_coord are supplied, only longitude/latitude coordinates will be considered.
</p>
<p>When ref_raster is supplied, this raster is cropped for every plot contained in corner_data.
</p>


<h3>Value</h3>

<p>Returns a list including :
</p>

<ul>
<li> <p><code>corner_coord</code>: a data frame containing the projected coordinates (x_proj and y_proj) and the relative coordinates (x_rel and y_rel) of the 4 corners of the plot
</p>
</li>
<li> <p><code>polygon</code>: a sf object containing plot's polygon(s)
</p>
</li>
<li> <p><code>tree_data</code>: if <code>tree_data</code> is supplied in the arguments of the function, a data frame corresponding to tree_data for which the projected coordinates of the trees (x_proj and y_proj) are added, and also a variable telling if the trees are inside the plot (is_in_plot). The name of the relative tree coordinates are also standardised and renamed to (x_rel and y_rel).
</p>
</li>
<li> <p><code>outliers</code>: a data frame containing the projected coordinates and the row number of GPS measurements considered outliers
</p>
</li>
<li> <p><code>plot_design</code>: if <code>draw_plot</code> is TRUE, a ggplot object corresponding to the design of the plot
</p>
</li>
<li> <p><code>UTM_code</code>: if <code>longlat</code> is supplied, a character containing the UTM code of the GPS coordinates
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Arthur PERE, Maxime REJOU-MECHAIN, Arthur BAILLY
</p>
<p>Arthur BAILLY, Arthur PERE, Maxime REJOU-MECHAIN
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One plot with repeated measurements of each corner
data("NouraguesPlot201")
check_plot201 &lt;- check_plot_coord(
  corner_data = NouraguesPlot201,
  proj_coord = c("Xutm","Yutm"), rel_coord = c("Xfield","Yfield"),
  trust_GPS_corners = TRUE, draw_plot = FALSE)
check_plot201$corner_coord

  check_plot201$plot_design


# 4 plots with one measurement of each corner
data("NouraguesCoords")
check_plots &lt;- check_plot_coord(
  corner_data = NouraguesCoords,
  proj_coord = c("Xutm","Yutm"), rel_coord = c("Xfield","Yfield"),
  trust_GPS_corners = TRUE, plot_ID = "Plot", draw_plot = FALSE)
check_plots$corner_coord

  check_plots$plot_design


# Displaying the associated CHM raster and representing trees proportionally to their diameter
plot_204_coords &lt;- NouraguesCoords[NouraguesCoords$Plot==204,]
data("NouraguesTrees")
plot_204_trees &lt;- NouraguesTrees[NouraguesTrees$Plot == 204, ]
nouragues_raster &lt;- terra::rast(
  system.file("extdata", "NouraguesRaster.tif",
              package = "BIOMASS", mustWork = TRUE)
  )
check_plot_204 &lt;- check_plot_coord(
 corner_data = plot_204_coords,
 proj_coord = c("Xutm","Yutm"), rel_coord = c("Xfield","Yfield"),
 trust_GPS_corners = TRUE, draw_plot = FALSE,
 tree_data = plot_204_trees, tree_coords = c("Xfield","Yfield"),
 ref_raster = nouragues_raster, prop_tree = "D"
)

  check_plot_204$plot_design

</code></pre>

<hr>
<h2 id='clearCache'>Function to clear cache content and possibly remove it</h2><span id='topic+clearCache'></span>

<h3>Description</h3>

<p>It will refuse to clear or remove a custom cache folder set using BIOMASS.cache
option as we don't know whether this folder contains other possibly valuable
files apart from our cached files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearCache(remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clearCache_+3A_remove">remove</code></td>
<td>
<p>logical. If TRUE cache folder will be removed too (not only content)
resulting in deactivating cache as a side effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='computeAGB'>Computing tree above ground biomass (AGB)</h2><span id='topic+computeAGB'></span>

<h3>Description</h3>

<p>This function uses Chave et al. 2014's pantropical models to estimate the above ground biomass of tropical trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAGB(D, WD, H = NULL, coord = NULL, Dlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeAGB_+3A_d">D</code></td>
<td>
<p>Tree diameter (in cm), either a vector or a single value.</p>
</td></tr>
<tr><td><code id="computeAGB_+3A_wd">WD</code></td>
<td>
<p>Wood density (in g/cm3), either a vector or a single value. If not available, see <code><a href="#topic+getWoodDensity">getWoodDensity()</a></code>.</p>
</td></tr>
<tr><td><code id="computeAGB_+3A_h">H</code></td>
<td>
<p>(optional) Tree height (H in m), either a vector or a single value. If not available, see <code><a href="#topic+retrieveH">retrieveH()</a></code>
and <code><a href="#topic+modelHD">modelHD()</a></code>. Compulsory if the coordinates <code>coord</code> are not given.</p>
</td></tr>
<tr><td><code id="computeAGB_+3A_coord">coord</code></td>
<td>
<p>(optional) Coordinates of the site(s), either a vector giving a single site
(e.g. c(longitude, latitude)) or a matrix/dataframe with two columns (e.g. cbind(longitude, latitude)).
The coordinates are used to account for variation in height-diameter relationship thanks to an environmental
proxy (parameter E in Chave et al. 2014). Compulsory if tree heights <code>H</code> are not given.</p>
</td></tr>
<tr><td><code id="computeAGB_+3A_dlim">Dlim</code></td>
<td>
<p>(optional) Minimum diameter (in cm) for which aboveground biomass should be calculated
(all diameter below <code>Dlim</code> will have a 0 value in the output).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses two different ways of computing the above ground biomass of a tree:
</p>

<ol>
<li><p> If tree height data are available, the AGB is computed thanks to the following equation (Eq. 4 in Chave et al., 2014):
</p>
<p style="text-align: center;"><code class="reqn">AGB = 0.0673 * (WD * H * D^2)^0.976</code>
</p>

</li>
<li><p> If no tree height data is available, the AGB is computed thanks to the site coordinates with the following equation, slightly modified from Eq. 7 in Chave et al., 2014 (see Réjou-Méchain et al. 2017):
</p>
<p style="text-align: center;"><code class="reqn">AGB = exp(-2.024- 0.896*E + 0.920*log(WD) + 2.795*log(D) - 0.0461*(log(D)^2))</code>
</p>
<p> where <code>E</code> is a measure of environmental stress estimated from the site coordinates (<code>coord</code>).
</p>
</li></ol>



<h3>Value</h3>

<p>The function returns the AGB in Mg (or ton) as a single value or a vector.
</p>


<h3>Author(s)</h3>

<p>Maxime REJOU-MECHAIN, Ariane TANGUY, Arthur PERE
</p>


<h3>References</h3>

<p>Chave et al. (2014) <em>Improved allometric models to estimate the aboveground biomass of tropical trees</em>,
Global Change Biology, 20 (10), 3177-3190
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeE">computeE()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create variables
D &lt;- 10:99
WD &lt;- runif(length(D), min = 0.1, max = 1)
H &lt;- D^(2 / 3)

# If you have height data
AGB &lt;- computeAGB(D, WD, H)

# If you do not have height data and a single site
lat &lt;- 4.08
long &lt;- -52.68
coord &lt;- c(long, lat)

AGB &lt;- computeAGB(D, WD, coord = coord)


# If you do not have height data and several sites (here three)
lat &lt;- c(rep(4.08, 30), rep(3.98, 30), rep(4.12, 30))
long &lt;- c(rep(-52.68, 30), rep(-53.12, 30), rep(-53.29, 30))
coord &lt;- cbind(long, lat)

AGB &lt;- computeAGB(D, WD, coord = coord)


</code></pre>

<hr>
<h2 id='computeE'>Retrieving Chave's environmental index</h2><span id='topic+computeE'></span>

<h3>Description</h3>

<p>Extract the Chave et al. 2014's environmental index thanks to the coordinates of the data.
The function is time-consuming at its first use as it downloads a raster in a folder (see Details).
However, as soon as the raster is downloaded once, the function then runs fast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeE(coord)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeE_+3A_coord">coord</code></td>
<td>
<p>Coordinates of the site(s), a matrix/dataframe with two columns (e.g. cbind(longitude, latitude)) (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Chave's environmental index, <code>E</code>, has been shown to be an important covariable in
the diameter-height relationship for tropical trees. It is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">E = 1.e-3 * (0.178 * TS - 0.938 * CWD - 6.61 * PS)</code>
</p>

<p>where <code>TS</code> is temperature seasonality as defined in the Worldclim dataset (bioclimatic variable 4),
<code>CWD</code> is the climatic water deficit (in mm/yr, see Chave et al. 2014) and <code>PS</code> is the
precipitation seasonality as defined in the Worldclim dataset (bioclimatic variable 15).
</p>
<p>The E index is extracted from a raster file (2.5 arc-second resolution, or ca. 5 km) available
at http://chave.ups-tlse.fr/pantropical_allometry.htm
</p>


<h3>Value</h3>

<p>The function returns <code>E</code>, the environmental index computed thanks to the Chave et al 2014's formula as a single value or a vector.
</p>


<h3>Localisation</h3>

<p>Cache path discovery protocol
</p>

<ol>
<li><p> BIOMASS.cache option set to an <strong>existing</strong> folder
</p>
</li>
<li> <p><strong>existing</strong> user data folder <code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>
</p>

<ul>
<li><p> On Linux : <code style="white-space: pre;">&#8288;~/.local/share/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Mac OS X : <code style="white-space: pre;">&#8288;~/Library/Application Support/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows 7 up to 10 : <code style="white-space: pre;">&#8288;C:\\Users\\&lt;username&gt;\\AppData\\Local\\R\\BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows XP : <code style="white-space: pre;">&#8288;C:\\Documents and Settings\\&lt;username&gt;\\Data\\R\\BIOMASS&#8288;</code>
</p>
</li></ul>

</li>
<li><p> fallback to R session tempdir
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Jerome CHAVE, Maxime REJOU-MECHAIN, Ariane TANGUY, Arthur PERE
</p>


<h3>References</h3>

<p>Chave et al. (2014) <em>Improved allometric models to estimate the aboveground biomass of tropical trees</em>,
Global Change Biology, 20 (10), 3177-3190
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One study site
lat &lt;- 4.08
long &lt;- -52.68
coord &lt;- cbind(long, lat)

E &lt;- computeE(coord)


# Several study sites (here three sites)
long &lt;- c(-52.68, -51.12, -53.11)
lat &lt;- c(4.08, 3.98, 4.12)
coord &lt;- cbind(long, lat)

E &lt;- computeE(coord)


</code></pre>

<hr>
<h2 id='computeFeldRegion'>Retrieving Feldpausch regions</h2><span id='topic+computeFeldRegion'></span>

<h3>Description</h3>

<p>Extract the Feldpausch et al. (2012)'s regions using local coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeFeldRegion(coord, level = c("region"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeFeldRegion_+3A_coord">coord</code></td>
<td>
<p>Coordinates of the site(s), a matrix/dataframe with two columns (e.g. cbind(longitude, latitude)) (see examples).</p>
</td></tr>
<tr><td><code id="computeFeldRegion_+3A_level">level</code></td>
<td>
<p>a string or a vector of string, the length must match the number of rows of the parameter coord.
This parameter gives the scale at which Feldpausch regions should be assigned. There are tree levels:
</p>

<ul>
<li> <p><code>region</code>: Models assign at sub-continent levels, value by default
</p>
</li>
<li> <p><code>continent</code>: Models assign at the Africa, South America, Asia and Australia levels
</p>
</li>
<li> <p><code>world</code>: Pantropical model
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector with the Feldpausch et al. (2012)'s regions that can be
incorporated in the <code>retrieveH</code> function.
</p>


<h3>Author(s)</h3>

<p>Arthur PERE
</p>


<h3>References</h3>

<p>Feldpausch, T.R., et al. (2012). <em>Tree height integrated into pantropical forest biomass estimates.</em>
Biogeosciences, 9, 3381–3403.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # One study site
lat &lt;- 4.08
long &lt;- -52.68
coord &lt;- cbind(long, lat)

FeldRegion &lt;- computeFeldRegion(coord)


# Several study sites (here three sites)
long &lt;- c(-52.68, -51.12, -53.11)
lat &lt;- c(4.08, 3.98, 4.12)
coord &lt;- cbind(long, lat)

FeldRegion &lt;- computeFeldRegion(coord)


</code></pre>

<hr>
<h2 id='correctCoordGPS'>Correct the GPS coordinates</h2><span id='topic+correctCoordGPS'></span>

<h3>Description</h3>

<p>This function builds the most probable GPS coordinates of the plot corners from multiple GPS measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctCoordGPS(
  longlat = NULL,
  projCoord = NULL,
  coordRel,
  rangeX,
  rangeY,
  maxDist = 15,
  drawPlot = FALSE,
  rmOutliers = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctCoordGPS_+3A_longlat">longlat</code></td>
<td>
<p>(optional) data frame with the coordinate in longitude latitude (eg. cbind(longitude, latitude)).</p>
</td></tr>
<tr><td><code id="correctCoordGPS_+3A_projcoord">projCoord</code></td>
<td>
<p>(optional) data frame with the projected coordinate in X Y</p>
</td></tr>
<tr><td><code id="correctCoordGPS_+3A_coordrel">coordRel</code></td>
<td>
<p>data frame with the relative coordinate in the same order than the longlat or projCoord</p>
</td></tr>
<tr><td><code id="correctCoordGPS_+3A_rangex">rangeX</code></td>
<td>
<p>a vector of length 2 giving the range for plot relative X coordinates</p>
</td></tr>
<tr><td><code id="correctCoordGPS_+3A_rangey">rangeY</code></td>
<td>
<p>a vector of length 2 giving the range for plot relative Y coordinates</p>
</td></tr>
<tr><td><code id="correctCoordGPS_+3A_maxdist">maxDist</code></td>
<td>
<p>a numeric giving the maximum distance above which GPS measurements should be considered as outliers (by default 15 m)</p>
</td></tr>
<tr><td><code id="correctCoordGPS_+3A_drawplot">drawPlot</code></td>
<td>
<p>a logical if you want to display a graphical representation</p>
</td></tr>
<tr><td><code id="correctCoordGPS_+3A_rmoutliers">rmOutliers</code></td>
<td>
<p>a logical if you want to remove the outliers from coordinates calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GPS coordinates should be either given in longitude latitude (longlat) or in projected coordinates (projCoord)
</p>


<h3>Value</h3>

<p>If there are no outliers or rmOutliers = TRUE, a list with:
</p>

<ul>
<li> <p><code>cornerCoords</code>: a data.frame with the coordinates of the corners
</p>
</li>
<li> <p><code>correctedCoord</code>: a data.frame with the adjusted coordinates given as input
</p>
</li>
<li> <p><code>polygon</code>: a spatial polygon
</p>
</li>
<li> <p><code>outliers</code>: index of coordinates lines considered as outliers, if any
</p>
</li>
<li> <p><code>codeUTM</code>: the UTM code of the coordinates if the parameter <code>longlat</code> is set
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Arthur PERE, Maxime REJOU-MECHAIN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>projCoord &lt;- data.frame(
  X = c(
    runif(5, min = 9, max = 11), runif(5, min = 8, max = 12),
    runif(5, min = 80, max = 120), runif(5, min = 90, max = 110)
  ),
  Y = c(
    runif(5, min = 9, max = 11), runif(5, min = 80, max = 120),
    runif(5, min = 8, max = 12), runif(5, min = 90, max = 110)
  )
)
projCoord &lt;- projCoord + 1000
coordRel &lt;- data.frame(
  X = c(rep(0, 10), rep(100, 10)),
  Y = c(rep(c(rep(0, 5), rep(100, 5)), 2))
)

aa &lt;- correctCoordGPS(
  projCoord = projCoord, coordRel = coordRel,
  rangeX = c(0, 100), rangeY = c(0, 100)
)
bb &lt;- correctCoordGPS(
  projCoord = projCoord, coordRel = coordRel,
  rangeX = c(0, 100), rangeY = c(0, 100), rmOutliers = TRUE
)

correctCoordGPS(
  projCoord = projCoord, coordRel = coordRel,
  rangeX = c(0, 100), rangeY = c(0, 100), drawPlot = TRUE
)


</code></pre>

<hr>
<h2 id='correctTaxo'>Correct trees taxonomy</h2><span id='topic+correctTaxo'></span>

<h3>Description</h3>

<p>This function corrects typos for a given taxonomic name using the Taxonomic Name Resolution Service (TNRS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctTaxo(
  genus,
  species = NULL,
  score = 0.5,
  useCache = FALSE,
  verbose = TRUE,
  accepted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctTaxo_+3A_genus">genus</code></td>
<td>
<p>Vector of genera to be checked. Alternatively, the whole species name (genus + species)
or (genus + species + author) may be given (see example).</p>
</td></tr>
<tr><td><code id="correctTaxo_+3A_species">species</code></td>
<td>
<p>(optional) Vector of species to be checked (same size as the genus vector).</p>
</td></tr>
<tr><td><code id="correctTaxo_+3A_score">score</code></td>
<td>
<p>Score of the matching ( see https://tnrs.biendata.org/instructions ) below which corrections are discarded.</p>
</td></tr>
<tr><td><code id="correctTaxo_+3A_usecache">useCache</code></td>
<td>
<p>logical. Whether or not use a cache to reduce online search of taxa names (NULL means use cache but clear it first)</p>
</td></tr>
<tr><td><code id="correctTaxo_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE various messages are displayed during process</p>
</td></tr>
<tr><td><code id="correctTaxo_+3A_accepted">accepted</code></td>
<td>
<p>logical. If TRUE accepted names will be returned instead of matched names. Cache will not be used as synonymy changes over time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function create a file named correctTaxo.log (see Localisation), this file have the memory of all the previous requests, as
to avoid the replication of time-consuming server requests.
</p>
<p>By default, names are queried in batches of 500, with a 0.5s delay between each query. These values can be modified using options:
<code>options(BIOMASS.batch_size=500)</code> for batch size (max 1000), <code>options(BIOMASS.wait_delay=0.5)</code> for delay (in seconds).
</p>


<h3>Value</h3>

<p>The function returns a dataframe with the corrected (or not) genera and species.
</p>


<h3>Localisation</h3>

<p>Cache path discovery protocol
</p>

<ol>
<li><p> BIOMASS.cache option set to an <strong>existing</strong> folder
</p>
</li>
<li> <p><strong>existing</strong> user data folder <code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>
</p>

<ul>
<li><p> On Linux : <code style="white-space: pre;">&#8288;~/.local/share/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Mac OS X : <code style="white-space: pre;">&#8288;~/Library/Application Support/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows 7 up to 10 : <code style="white-space: pre;">&#8288;C:\\Users\\&lt;username&gt;\\AppData\\Local\\R\\BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows XP : <code style="white-space: pre;">&#8288;C:\\Documents and Settings\\&lt;username&gt;\\Data\\R\\BIOMASS&#8288;</code>
</p>
</li></ul>

</li>
<li><p> fallback to R session tempdir
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Ariane TANGUY, Arthur PERE, Maxime REJOU-MECHAIN, Guillaume CORNU
</p>


<h3>References</h3>

<p>Boyle, B. et al. (2013).
<em>The taxonomic name resolution service: An online tool for automated standardization of plant names</em>. BMC bioinformatics, 14, 1. doi:10.1186/1471-2105-14-16
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
correctTaxo(genus = "Astrocarium", species = "standleanum")
correctTaxo(genus = "Astrocarium standleanum")

## End(Not run)

</code></pre>

<hr>
<h2 id='createCache'>Function used to create or activate a permanent cache.</h2><span id='topic+createCache'></span>

<h3>Description</h3>

<p>Permanent cache is located by default in user data dir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCache(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createCache_+3A_path">path</code></td>
<td>
<p>Use a custom path to host cache</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can provide a custom path (that will be defined as a BIOMASS.cache option)
but clearCache function will refuse to operate on it for security reasons.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='cutPlot'>Divides one or more plots into subplots</h2><span id='topic+cutPlot'></span>

<h3>Description</h3>

<p>This function divides a plot (or several plots) in subplots and returns the coordinates of the grid.
These coordinates are calculated by a bilinear interpolation with the projected corner coordinates as references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutPlot(projCoord, plot, cornerNum, gridsize = 100, dimX = 200, dimY = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutPlot_+3A_projcoord">projCoord</code></td>
<td>
<p>A data frame containing the projected coordinates of plot corners, with X and Y on the first and second column respectively</p>
</td></tr>
<tr><td><code id="cutPlot_+3A_plot">plot</code></td>
<td>
<p>A vector indicating the plot codes</p>
</td></tr>
<tr><td><code id="cutPlot_+3A_cornernum">cornerNum</code></td>
<td>
<p>A vector with corners numbered from 1 to 4 for each plot, numbering must be in clockwise direction</p>
</td></tr>
<tr><td><code id="cutPlot_+3A_gridsize">gridsize</code></td>
<td>
<p>The size of the subplots</p>
</td></tr>
<tr><td><code id="cutPlot_+3A_dimx">dimX</code></td>
<td>
<p>A vector indicating the size of the plot on the X axis, in meters and in the relative coordinates system (if a single value is supplied, it will be replicated for all plots)</p>
</td></tr>
<tr><td><code id="cutPlot_+3A_dimy">dimY</code></td>
<td>
<p>A vector indicating the size of the plot on the Y axis, in meters and in the relative coordinates system (if a single value is supplied, it will be replicated for all plots)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data-frame containing as many rows as there are corners corresponding to the subplots, and the following columns :
</p>

<ul>
<li> <p><code>plot</code>: The plot code
</p>
</li>
<li> <p><code>subplot</code>: The automatically generated subplot code
</p>
</li>
<li> <p><code>XRel</code>:  The relative coordinates on the X axis (defined by corners 1-&gt;4)
</p>
</li>
<li> <p><code>YRel</code>:  The relative coordinates on the Y axis (defined by corners 1-&gt;2)
</p>
</li>
<li> <p><code>XAbs</code>:  The absolute (projected) X coordinates
</p>
</li>
<li> <p><code>YAbs</code>:  The absolute (projected) Y coordinates
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Arthur PERE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
coord &lt;- data.frame(X = c(0, 200, 0, 200), Y = c(0, 0, 200, 200)) + 5000
cornerNum &lt;- c(1, 2, 4, 3)
plot &lt;- rep("plot1", 4)

cut &lt;- cutPlot(coord, plot, cornerNum, gridsize = 100, dimX = 200, dimY = 200)

# plot the result
plot(coord, main = "example", xlim = c(4900, 5300), ylim = c(4900, 5300), asp = 1)
text(coord, labels = cornerNum, pos = 1)
points(cut$XAbs, cut$YAbs, pch = "+")
legend("bottomright", legend = c("orignal", "cut"), pch = c("o", "+"))

</code></pre>

<hr>
<h2 id='divide_plot'>Divides one ore more plots into subplots</h2><span id='topic+divide_plot'></span>

<h3>Description</h3>

<p>This function divides a plot (or several plots) into subplots in the relative coordinates system, and returns the coordinates of subplot corners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divide_plot(
  corner_data,
  rel_coord,
  proj_coord = NULL,
  grid_size,
  tree_data = NULL,
  tree_coords = NULL,
  corner_plot_ID = NULL,
  tree_plot_ID = NULL,
  grid_tol = 0.1,
  centred_grid = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="divide_plot_+3A_corner_data">corner_data</code></td>
<td>
<p>A data frame, data frame extension, containing the plot corner coordinates. Typically, the output <code style="white-space: pre;">&#8288;$corner_coord&#8288;</code> of the <code><a href="#topic+check_plot_coord">check_plot_coord()</a></code> function.</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_rel_coord">rel_coord</code></td>
<td>
<p>A character vector of length 2,  specifying the column names (resp. x, y) of the corner relative coordinates.</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_proj_coord">proj_coord</code></td>
<td>
<p>A character vector of length 2, specifying the column names (resp. x, y) of the corner projected coordinates.</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_grid_size">grid_size</code></td>
<td>
<p>A vector indicating the dimensions of grid cells (resp. X and Y dimensions). If only one value is given, grid cells will be considered as squares.</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_tree_data">tree_data</code></td>
<td>
<p>A data frame containing tree relative coordinates and other optional tree metrics (one row per tree).</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_tree_coords">tree_coords</code></td>
<td>
<p>A character vector of length 2, specifying the column names of the relative coordinates of the trees.</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_corner_plot_id">corner_plot_ID</code></td>
<td>
<p>If dealing with multiple plots : a vector indicating plot IDs for corners.</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_tree_plot_id">tree_plot_ID</code></td>
<td>
<p>If dealing with multiple plots : a vector indicating tree plot IDs.</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_grid_tol">grid_tol</code></td>
<td>
<p>A numeric between (0;1) corresponding to the percentage of the plot area allowed to be excluded from the plot division (when grid_size doesn't match exactly plot dimensions).</p>
</td></tr>
<tr><td><code id="divide_plot_+3A_centred_grid">centred_grid</code></td>
<td>
<p>When grid_size doesn't match exactly plot dimensions, a logical indicating if the subplot grid should be centered on the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If corner coordinates in the projected coordinate system are supplied (proj_coord), projected coordinates of subplot corners are calculated by a bilinear interpolation in relation with relative coordinates of plot corners. Be aware that this bilinear interpolation only works if the plot in the relative coordinates system is rectangular (ie, has 4 right angles).
</p>


<h3>Value</h3>

<p>If tree_data isn't supplied, returns a data-frame containing as many rows as there are corners corresponding to the subplots, and the following columns :
</p>

<ul>
<li> <p><code>corner_plot_ID</code>: If dealing with multiple plots : the plot code
</p>
</li>
<li> <p><code>subplot_ID</code>: The automatically generated subplot code, using the following rule : subplot_X_Y
</p>
</li>
<li> <p><code>x_rel</code> and <code>y_rel</code> : the relative X-axis and Y-axis coordinates of subplots corners.
</p>
</li>
<li> <p><code>x_proj</code> and <code>y_proj</code> :  if proj_coord is supplied, the projected X-axis and Y-axis coordinates of subplots corners
</p>
</li></ul>

<p>If tree_data is supplied, returns a list containing :
</p>

<ul>
<li><p> the previous data-frame
</p>
</li>
<li><p> the tree_data data-frame with the subplot_ID of each tree in the last column
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Arthur PERE, Arthur BAILLY
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One plot with repeated measurements of each corner
data("NouraguesPlot201")
check_plot201 &lt;- check_plot_coord(
  corner_data = NouraguesPlot201,
  proj_coord = c("Xutm","Yutm"), rel_coord = c("Xfield","Yfield"),
  trust_GPS_corners = TRUE, draw_plot = FALSE)
subplots_201 &lt;- divide_plot(
  corner_data = check_plot201$corner_coord, 
  rel_coord = c("x_rel","y_rel"), proj_coord = c("x_proj","y_proj"),
  grid_size = 50)
subplots_201

# Assigning trees to subplots
data("NouraguesTrees")
plot201_trees &lt;- NouraguesTrees[NouraguesTrees$Plot == 201,]
subplots_201 &lt;- suppressWarnings(
  divide_plot(
    corner_data = check_plot201$corner_coord, 
    rel_coord = c("x_rel","y_rel"), proj_coord = c("x_proj","y_proj"),
    grid_size = 50,
    tree_data = plot201_trees, tree_coords = c("Xfield","Yfield")))
head(subplots_201$sub_corner_coord)
head(subplots_201$tree_data)

# When grid dimensions don't fit perfectly plot dimensions

  divide_plot(
    corner_data = check_plot201$corner_coord, 
    rel_coord = c("x_rel","y_rel"),
    grid_size = c(41,41),
    grid_tol = 0.4, centred_grid = TRUE)


# Dealing with multiple plots
data("NouraguesCoords")
nouragues_subplots &lt;- suppressWarnings(
  divide_plot(
    corner_data = NouraguesCoords,
    rel_coord = c("Xfield","Yfield"), proj_coord = c("Xutm","Yutm"),
    corner_plot_ID = "Plot",
    grid_size = 50,
    tree_data = NouraguesTrees, tree_coords =  c("Xfield","Yfield"),
    tree_plot_ID = "Plot"))
head(nouragues_subplots$sub_corner_coord)
head(nouragues_subplots$tree_data)
</code></pre>

<hr>
<h2 id='feldCoef'>Feldpausch et al. 2012 coefficients for generalized height-diameter models</h2><span id='topic+feldCoef'></span>

<h3>Description</h3>

<p>Weibull coefficients from a height-diameter model of the form <code class="reqn">H = a(1-exp(-b*D^c))</code> given by Feldpausch
et al. 2012. in the table 3, with the associated RSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("feldCoef")
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 4 variables:
</p>

<ul>
<li> <p><code>a</code>: Coefficient a
</p>
</li>
<li> <p><code>b</code>: Coefficient b
</p>
</li>
<li> <p><code>c</code>: Coefficient c
</p>
</li>
<li> <p><code>RSE</code>: Vector of RSE
</p>
</li></ul>



<h3>Details</h3>

<p>This dataset is used in the function <code><a href="#topic+retrieveH">retrieveH()</a></code>
to predict height from diameter depending on the region.
</p>


<h3>References</h3>

<p>Feldpausch, T.R., et al. (2012). <em>Tree height integrated into pantropical forest biomass estimates</em>.
Biogeosciences, 9, 3381–3403.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(feldCoef)
str(feldCoef)
</code></pre>

<hr>
<h2 id='genusFamily'>Genus Family database</h2><span id='topic+genusFamily'></span>

<h3>Description</h3>

<p>To create this database, we combined the genera from The Plant List (http://www.theplantlist.org/1.1/browse/-/-/)
and the Vascular Plant Families and Genera from Kew (http://data.kew.org/vpfg1992/genlist.html).
Families were checked against the APGIII families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("genusFamily")
</code></pre>


<h3>Format</h3>

<p>A data frame with 28107 observations on the following 2 variables:
</p>

<ul>
<li> <p><code>family</code>: Vector of families APGIII corrected
</p>
</li>
<li> <p><code>genus</code>: Vector of genus
</p>
</li></ul>



<h3>Source</h3>

<p>WCSP (2015). <em>World Checklist of Selected Plant Families</em>.
Facilitated by the Royal Botanic Gardens, Kew. Published on the Internet; http://apps.kew.org/wcsp/ Retrieved 2015-12-17.
</p>
<p>The Plant List (2013). Version 1.1. Published on the Internet; http://www.theplantlist.org/ Retrieved 2016-08-25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genusFamily)
str(genusFamily)
</code></pre>

<hr>
<h2 id='getBioclimParam'>Retrieving bioclimatic parameters</h2><span id='topic+getBioclimParam'></span>

<h3>Description</h3>

<p>This function extracts three bioclimatic parameters thanks to the coordinates of the data:
the Climatic Water Deficit (CWD), the Temperature Seasonality (TS) and the Precipitation Seasonality (PS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBioclimParam(coord)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBioclimParam_+3A_coord">coord</code></td>
<td>
<p>Coordinates of the site(s), a matrix/dataframe with two columns (e.g. cbind(longitude, latitude)) (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is time-consuming at its first use as it downloads three raster files (one for each of
the parameter) which are then stored in folders named wc2-5 and CWD (see Localisation).
</p>
<p>However, as soon as the raster is downloaded once, the function then runs fast.
</p>


<h3>Value</h3>

<p>The function returns a data.frame with <code>tempSeas</code> (temperature seasonality,
i.e. bioclimatic variable 4 from the Worldclim dataset; Hijmans et al. 2005), <code>precSeas</code>
(precipitation seasonality, i.e. bioclimatic variable 15 from the Worldclim dataset; Hijmans
et al. 2005) and <code>CWD</code> (climatic water deficit; Chave et al. 2014).
</p>


<h3>Localisation</h3>

<p>Cache path discovery protocol
</p>

<ol>
<li><p> BIOMASS.cache option set to an <strong>existing</strong> folder
</p>
</li>
<li> <p><strong>existing</strong> user data folder <code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>
</p>

<ul>
<li><p> On Linux : <code style="white-space: pre;">&#8288;~/.local/share/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Mac OS X : <code style="white-space: pre;">&#8288;~/Library/Application Support/R/BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows 7 up to 10 : <code style="white-space: pre;">&#8288;C:\\Users\\&lt;username&gt;\\AppData\\Local\\R\\BIOMASS&#8288;</code>
</p>
</li>
<li><p> On Windows XP : <code style="white-space: pre;">&#8288;C:\\Documents and Settings\\&lt;username&gt;\\Data\\R\\BIOMASS&#8288;</code>
</p>
</li></ul>

</li>
<li><p> fallback to R session tempdir
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Ariane TANGUY, Arthur PERE
</p>


<h3>References</h3>

<p>Hijmans et al. (2005) <em>Very high resolution interpolated climate surfaces for global land areas</em>,
International journal of climatology, 25(15), 1965-1978.
Chave et al. (2014) <em>Improved allometric models to estimate the above-ground biomass of tropical trees</em>,
Global Change Biology, 20 (10), 3177-3190
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One study site
lat &lt;- 4.08
long &lt;- -52.68
coord &lt;- cbind(long, lat)

bioclim &lt;- getBioclimParam(coord)


# Several study sites (here three sites)
long &lt;- c(-52.68, -51.12, -53.11)
lat &lt;- c(4.08, 3.98, 4.12)
coord &lt;- cbind(long, lat)

bioclim &lt;- getBioclimParam(coord)


</code></pre>

<hr>
<h2 id='getTaxonomy'>Retrieve trees taxonomy</h2><span id='topic+getTaxonomy'></span>

<h3>Description</h3>

<p>From given genus, the function finds the APG III family, and optionally the order, from the <a href="#topic+genusFamily">genusFamily</a> database and the <a href="#topic+apgFamilies">apgFamilies</a> dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTaxonomy(genus, findOrder = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTaxonomy_+3A_genus">genus</code></td>
<td>
<p>Vector of genus names</p>
</td></tr>
<tr><td><code id="getTaxonomy_+3A_findorder">findOrder</code></td>
<td>
<p>(Boolean) If <code>TRUE</code>, the output will contain the taxonomical orders of the families.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the order (if <code>findOrder</code> is <code>TRUE</code>), family and genus.
</p>


<h3>Author(s)</h3>

<p>Ariane TANGUY, Arthur PERE, Maxime REJOU-MECHAIN
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the Family of the Aphelandra genus
getTaxonomy("Aphelandra")
# ... and the order

getTaxonomy("Aphelandra", findOrder = TRUE)

</code></pre>

<hr>
<h2 id='getWoodDensity'>Estimating wood density</h2><span id='topic+getWoodDensity'></span>

<h3>Description</h3>

<p>The function estimates the wood density (WD) of the trees from their taxonomy or from their congeners using the global wood density database (Chave et al. 2009, Zanne et al. 2009) or any additional dataset. The WD can either be attributed to an individual at a species, genus, family or stand level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWoodDensity(
  genus,
  species,
  stand = NULL,
  family = NULL,
  region = "World",
  addWoodDensityData = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getWoodDensity_+3A_genus">genus</code></td>
<td>
<p>Vector of genus names</p>
</td></tr>
<tr><td><code id="getWoodDensity_+3A_species">species</code></td>
<td>
<p>Vector of species names</p>
</td></tr>
<tr><td><code id="getWoodDensity_+3A_stand">stand</code></td>
<td>
<p>(optional) Vector with the corresponding stands of your data.
If set, the missing wood densities at the genus level will be attributed at stand level.
If not, the value attributed will be the mean of the whole tree dataset.</p>
</td></tr>
<tr><td><code id="getWoodDensity_+3A_family">family</code></td>
<td>
<p>(optional) Vector of families. If set, the missing wood densities at the genus
level will be attributed at family level if available.</p>
</td></tr>
<tr><td><code id="getWoodDensity_+3A_region">region</code></td>
<td>
<p>Region (or vector of region) of interest of your sample. By default, Region is
set to 'World', but you can restrict the WD estimates to a single region :
</p>

<ul>
<li> <p><code>AfricaExtraTrop</code>: Africa (extra tropical)
</p>
</li>
<li> <p><code>AfricaTrop</code>: Africa (tropical)
</p>
</li>
<li> <p><code>Australia</code>: Australia
</p>
</li>
<li> <p><code>AustraliaTrop</code>: Australia (tropical)
</p>
</li>
<li> <p><code>CentralAmericaTrop</code>: Central America (tropical)
</p>
</li>
<li> <p><code>China</code>: China
</p>
</li>
<li> <p><code>Europe</code>: Europe
</p>
</li>
<li> <p><code>India</code>: India
</p>
</li>
<li> <p><code>Madagascar</code>: Madagascar
</p>
</li>
<li> <p><code>Mexico</code>: Mexico
</p>
</li>
<li> <p><code>NorthAmerica</code>: North America
</p>
</li>
<li> <p><code>Oceania</code>: Oceania
</p>
</li>
<li> <p><code>SouthEastAsia</code>: South-East Asia
</p>
</li>
<li> <p><code>SouthEastAsiaTrop</code>: South-East Asia (tropical)
</p>
</li>
<li> <p><code>SouthAmericaExtraTrop</code>: South America (extra tropical)
</p>
</li>
<li> <p><code>SouthAmericaTrop</code>: South America (tropical)
</p>
</li>
<li> <p><code>World</code>: World
</p>
</li></ul>
</td></tr>
<tr><td><code id="getWoodDensity_+3A_addwooddensitydata">addWoodDensityData</code></td>
<td>
<p>A dataframe containing additional wood density data to be
combined with the global wood density database. The dataframe should be organized
in a dataframe with three (or four) columns: &quot;genus&quot;,&quot;species&quot;,&quot;wd&quot;, the fourth
column &quot;family&quot; is optional.</p>
</td></tr>
<tr><td><code id="getWoodDensity_+3A_verbose">verbose</code></td>
<td>
<p>A logical, give some statistic with the database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assigns to each taxon a species- or genus- level average if at least
one wood density value at the genus level is available for that taxon in the reference database.
If not, the mean wood density of the family (if set) or of the stand (if set) is given.
</p>
<p>The function also provides an estimate of the error associated with the wood density estimate
(i.e. a standard deviation): a mean standard deviation value is given to the tree at the
appropriate taxonomic level using the <a href="#topic+sd_10">sd_10</a> dataset.
</p>


<h3>Value</h3>

<p>Returns a dataframe containing the following information:
</p>

<ul>
<li> <p><code>family</code>: (if set) Family
</p>
</li>
<li> <p><code>genus</code>: Genus
</p>
</li>
<li> <p><code>species</code>: Species
</p>
</li>
<li> <p><code>meanWD</code> (g/cm^3): Mean wood density
</p>
</li>
<li> <p><code>sdWD</code> (g/cm^3): Standard deviation of the wood density that can be used in error propagation
(see <a href="#topic+sd_10">sd_10</a> and <code><a href="#topic+AGBmonteCarlo">AGBmonteCarlo()</a></code>)
</p>
</li>
<li> <p><code>levelWD</code>: Level at which wood density has been calculated. Can be species, genus, family,
dataset (mean of the entire dataset) or, if stand is set, the name of the stand (mean of the current stand)
</p>
</li>
<li> <p><code>nInd</code>: Number of individuals taken into account to compute the mean wood density
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Maxime REJOU-MECHAIN, Arthur PERE, Ariane TANGUY
</p>


<h3>References</h3>

<p>Chave, J., et al. <em>Towards a worldwide wood economics spectrum</em>. Ecology letters 12.4 (2009): 351-366.
Zanne, A. E., et al. <em>Global wood density database</em>. Dryad. Identifier: http://hdl. handle. net/10255/dryad 235 (2009).
</p>


<h3>See Also</h3>

<p><a href="#topic+wdData">wdData</a>, <a href="#topic+sd_10">sd_10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a data set
data(NouraguesTrees)

# Compute the Wood Density up to the genus level and give the mean wood density of the dataset

WD &lt;- getWoodDensity(
  genus = NouraguesTrees$Genus,
  species = NouraguesTrees$Species
)


# Compute the Wood Density up to the genus level and then give the mean wood density per stand

WD &lt;- getWoodDensity(
  genus = NouraguesTrees$Genus,
  species = NouraguesTrees$Species,
  stand = NouraguesTrees$plotId
)


# Compute the Wood Density up to the family level and then give the mean wood density per stand

WD &lt;- getWoodDensity(
  family = NouraguesTrees$family,
  genus = NouraguesTrees$Genus,
  species = NouraguesTrees$Species,
  stand = NouraguesTrees$plotId
)
str(WD)

</code></pre>

<hr>
<h2 id='HDmethods'>HDmethods</h2><span id='topic+HDmethods'></span><span id='topic+loglogFunction'></span><span id='topic+michaelisFunction'></span><span id='topic+weibullFunction'></span>

<h3>Description</h3>

<p>Methods used for modeling height-diameter relationship
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglogFunction(data, method)

michaelisFunction(data, weight = NULL)

weibullFunction(data, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HDmethods_+3A_data">data</code></td>
<td>
<p>Dataset with the informations of height (H) and diameter (D)</p>
</td></tr>
<tr><td><code id="HDmethods_+3A_method">method</code></td>
<td>
<p>In the case of the loglogFunction, the model is to be chosen between log1, log2 or log3.</p>
</td></tr>
<tr><td><code id="HDmethods_+3A_weight">weight</code></td>
<td>
<p>(optional) Vector indicating observation weights in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions model the relationship between tree height (H) and diameter (D).
<strong>loglogFunction</strong>
Compute two types of log model (log and log2) to predict H from D.
The model can be:
</p>

<ul>
<li><p> log 1: <code class="reqn">log(H) = a+ b*log(D)</code> (equivalent to a power model)
</p>
</li>
<li><p> log 2: <code class="reqn">log(H) = a+ b*log(D) + c*log(D)^2</code>
</p>
</li></ul>

<p><strong>michaelisFunction</strong>
Construct a Michaelis Menten model of the form: </p>
<p style="text-align: center;"><code class="reqn">H = (A * D) / (B + D)</code>
</p>
<p> (A and B are the model parameters to be estimated)
</p>
<p><strong>weibullFunction</strong>
Construct a three parameter Weibull model of the form: </p>
<p style="text-align: center;"><code class="reqn">H = a*(1-exp(-(D/b)^c))</code>
</p>
<p> (a, b, c are the model parameters to be estimated)
</p>


<h3>Value</h3>

<p>All the functions give an output similar to the one given by <code><a href="stats.html#topic+lm">stats::lm()</a></code>, obtained for
<code>michaelisFunction</code> and <code>weibullFunction</code> from <a href="minpack.lm.html#topic+nlsLM">minpack.lm::nlsLM</a>).
</p>
<p>Result of a model (lm object)
</p>
<p>Result of a model (nlsM object)
</p>
<p>Result of a model (nlsM object)
</p>


<h3>Author(s)</h3>

<p>Maxime REJOU-MECHAIN, Ariane TANGUY
</p>


<h3>References</h3>

<p>Michaelis, L., &amp; Menten, M. L. (1913). <em>Die kinetik der invertinwirkung</em>. Biochem. z, 49(333-369), 352.
Weibull, W. (1951). <em>Wide applicability</em>. Journal of applied mechanics, 103.
Baskerville, G. L. (1972). <em>Use of logarithmic regression in the estimation of plant biomass</em>.
Canadian Journal of Forest Research, 2(1), 49-53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelHD">modelHD()</a></code>
</p>

<hr>
<h2 id='latlong2UTM'>Translate the long lat coordinate in UTM coordinate</h2><span id='topic+latlong2UTM'></span>

<h3>Description</h3>

<p>Translate the long lat coordinate in UTM coordinate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong2UTM(coord)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latlong2UTM_+3A_coord">coord</code></td>
<td>
<p>Coordinates of the site(s), a matrix/dataframe with two columns (e.g. cbind(longitude, latitude)) (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with :
</p>

<ul>
<li> <p><code>long</code>: The longitude of the entry
</p>
</li>
<li> <p><code>lat</code>: The latitude of the entry
</p>
</li>
<li> <p><code>codeUTM</code>: The code <code>proj</code> for UTM
</p>
</li>
<li> <p><code>X</code>: The X UTM coordinate
</p>
</li>
<li> <p><code>Y</code>: The Y UTM coordinate
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
long &lt;- c(-52.68, -51.12, -53.11)
lat &lt;- c(4.08, 3.98, 4.12)
coord &lt;- cbind(long, lat)

UTMcoord &lt;- latlong2UTM(coord)


</code></pre>

<hr>
<h2 id='modelHD'>Fitting height-diameter models</h2><span id='topic+modelHD'></span>

<h3>Description</h3>

<p>This function fits and compares (optional) height-diameter models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelHD(D, H, method = NULL, useWeight = FALSE, drawGraph = FALSE, plot = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelHD_+3A_d">D</code></td>
<td>
<p>Vector with diameter measurements (in cm). NA values are accepted but a minimum of 10 valid entries (i.e. having a corresponding height in H) is required.</p>
</td></tr>
<tr><td><code id="modelHD_+3A_h">H</code></td>
<td>
<p>Vector with total height measurements (in m). NA values are accepted but a minimum of 10 valid entries (i.e. having a corresponding diameter in D) is required.</p>
</td></tr>
<tr><td><code id="modelHD_+3A_method">method</code></td>
<td>
<p>Method used to fit the relationship.
To be chosen between:
</p>

<ul>
<li><p> log1, log2
</p>

<ul>
<li><p> log 1: <code class="reqn">(log(H) = a+ b*log(D))</code> (equivalent to a power model)
</p>
</li>
<li><p> log 2: <code class="reqn">(log(H) = a+ b*log(D) + c*log(D)^2)</code>
</p>
</li></ul>

</li>
<li><p> weibull: <code class="reqn">H = a*(1-exp(-(D/b)^c))</code>
</p>
</li>
<li><p> michaelis: <code class="reqn">H = (A * D)/(B + D)</code>
</p>
</li></ul>

<p>If <code>NULL</code>, all the methods will be compared.</p>
</td></tr>
<tr><td><code id="modelHD_+3A_useweight">useWeight</code></td>
<td>
<p>If weight is <code>TRUE</code>, model weights will be <code class="reqn">(D^2)*H</code> (i.e. weights are proportional to tree
volume, so that larger trees have a stronger influence during the construction of the model).</p>
</td></tr>
<tr><td><code id="modelHD_+3A_drawgraph">drawGraph</code></td>
<td>
<p>If <code>TRUE</code>, a graphic will illustrate the relationship between H and D. Only if argument <code>plot</code> is null.</p>
</td></tr>
<tr><td><code id="modelHD_+3A_plot">plot</code></td>
<td>
<p>(optional) Plot ID, must be either one value, or a vector of the same length as D. This argument is used to build
stand-specific HD models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the back transformations for log-log models are done using the Baskerville correction (<code class="reqn">0.5 * RSE^2</code>,
where RSE is the Residual Standard Error).
</p>


<h3>Value</h3>

<p>If <code>plot</code> is NULL or has a single value, a single list is returned. If there is more than one plot,
multiple embedded lists are returned with plots as the list names.
</p>
<p>If <code>model</code> is not null (model comparison), returns a list :
</p>

<ul>
<li> <p><code>input</code>: list of the data used to construct the model (list(H, D))
</p>
</li>
<li> <p><code>model</code>: outputs of the model (same outputs as given by <code><a href="stats.html#topic+lm">stats::lm()</a></code>, <code><a href="stats.html#topic+nls">stats::nls()</a></code>)
</p>
</li>
<li> <p><code>RSE</code>: Residual Standard Error of the model
</p>
</li>
<li> <p><code>RSElog</code>: Residual Standard Error of the log model (<code>NULL</code> if other model)
</p>
</li>
<li> <p><code>residuals</code>: Residuals of the model
</p>
</li>
<li> <p><code>coefficients</code>: Coefficients of the model
</p>
</li>
<li> <p><code>R.squared</code>: <code class="reqn">R^2</code> of the model
</p>
</li>
<li> <p><code>formula</code>: Formula of the model
</p>
</li>
<li> <p><code>method</code>: Name of the method used to construct the model
</p>
</li>
<li> <p><code>predicted</code>: Predicted height values
</p>
</li>
<li> <p><code>fitPlot</code>: a ggplot object containing the model fitting plot
</p>
</li></ul>

<p>If the parameter model is null, the function return a plot with all the methods for
comparison, the function also returns a data.frame with:
</p>

<ul>
<li> <p><code>method</code>: The method that had been used to construct the plot
</p>
</li>
<li> <p><code>RSE</code>: Residual Standard Error of the model
</p>
</li>
<li> <p><code>RSElog</code>: Residual Standard Error of the log model (<code>NULL</code> if other model)
</p>
</li>
<li> <p><code>Average_bias</code>: The average bias for the model
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Maxime REJOU-MECHAIN, Arthur PERE, Ariane TANGUY, Arthur Bailly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+retrieveH">retrieveH()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a data set
data(NouraguesHD)

# Fit H-D models for the Nouragues dataset

HDmodel &lt;- modelHD(D = NouraguesHD$D, H = NouraguesHD$H, drawGraph = TRUE)


# For a chosen model
HDmodel &lt;- modelHD(D = NouraguesHD$D, H = NouraguesHD$H,
method = "log2", drawGraph = TRUE)

# Using weights
HDmodel &lt;- modelHD(
  D = NouraguesHD$D, H = NouraguesHD$H,
  method = "log2", useWeight = TRUE,
  drawGraph = TRUE)

# With multiple stands (plots)
HDmodel &lt;- modelHD(
  D = NouraguesHD$D, H = NouraguesHD$H,
  method = "log2", useWeight = TRUE, 
  plot = NouraguesHD$plotId, drawGraph = TRUE)

</code></pre>

<hr>
<h2 id='NouraguesCoords'>Nouragues plot coordinates</h2><span id='topic+NouraguesCoords'></span>

<h3>Description</h3>

<p>Dataset containing the corner coordinates of 4 plots of &lsquo;Petit Plateau&rsquo; in Nouragues forest (French Guiana).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NouraguesCoords)
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 observations (GPS measurements) of the 8 following variables :
</p>

<ul>
<li> <p><code>Site</code>: Name of the site set up in the Nouragues forest
</p>
</li>
<li> <p><code>Plot</code>: Plot ID of the site
</p>
</li>
<li> <p><code>Xfield</code>: Corner location on the x-axis in the local coordinate system (defined by the 4 corners of the plot)
</p>
</li>
<li> <p><code>Yfield</code>: Corner location on the y-axis in the local coordinate system
</p>
</li>
<li> <p><code>Xutm</code>: Corner location on the x-axis in the UTM coordinate system
</p>
</li>
<li> <p><code>Yutm</code>: Corner location on the y-axis in the UTM coordinate system
</p>
</li>
<li> <p><code>Long</code>: Corner longitude coordinate
</p>
</li>
<li> <p><code>Lat</code>: Corner latitude coordinate
</p>
</li></ul>



<h3>References</h3>

<p>Jaouen, Gaëlle, 2023, &quot;Nouragues forest permanent plots details&quot;, <a href="https://doi.org/10.18167/DVN1/HXKS4E">doi:10.18167/DVN1/HXKS4E</a>, CIRAD Dataverse, V2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NouraguesCoords)
str(NouraguesCoords)
</code></pre>

<hr>
<h2 id='NouraguesHD'>Height-Diameter data</h2><span id='topic+NouraguesHD'></span>

<h3>Description</h3>

<p>Dataset from two 1-ha plots from the Nouragues forest (French Guiana)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("NouraguesHD")
</code></pre>


<h3>Format</h3>

<p>A data frame with 1051 observations on the following variables :
</p>

<ul>
<li> <p><code>plotId</code>: Names of the plots
</p>
</li>
<li> <p><code>genus</code>: Genus
</p>
</li>
<li> <p><code>species</code>: Species
</p>
</li>
<li> <p><code>D</code>: Diameter (cm)
</p>
</li>
<li> <p><code>H</code>: Height (m)
</p>
</li>
<li> <p><code>lat</code>: Latitude
</p>
</li>
<li> <p><code>long</code>: Longitude
</p>
</li></ul>



<h3>References</h3>

<p>Réjou-Méchain, M. et al. (2015).
<em>Using repeated small-footprint LiDAR acquisitions to infer spatial and temporal variations of a high-biomass Neotropical forest</em>
Remote Sensing of Environment, 169, 93-101.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NouraguesHD)
str(NouraguesHD)
</code></pre>

<hr>
<h2 id='NouraguesPlot201'>Nouragues plot 201 coordinates</h2><span id='topic+NouraguesPlot201'></span>

<h3>Description</h3>

<p>Simulated corner coordinates of Nouragues 'Petit plateau' plot 201. The original coordinates have been modified to make the plot non-squared, and 10 repeated measurements of each corner have been simulated adding a random error to x and y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NouraguesPlot201)
</code></pre>


<h3>Format</h3>

<p>A data frame with 40 (simulated GPS measurements) of the 8 following variables :
</p>

<ul>
<li> <p><code>Site</code>: Name of the site set up in the Nouragues forest
</p>
</li>
<li> <p><code>Plot</code>: Plot ID of the site
</p>
</li>
<li> <p><code>Xfield</code>: Corner location on the x-axis in the local coordinate system (defined by the 4 corners of the plot)
</p>
</li>
<li> <p><code>Yfield</code>: Corner location on the y-axis in the local coordinate system
</p>
</li>
<li> <p><code>Xutm</code>: Corner location on the x-axis in the UTM coordinate system
</p>
</li>
<li> <p><code>Yutm</code>: Corner location on the y-axis in the UTM coordinate system
</p>
</li>
<li> <p><code>Long</code>: Corner longitude coordinate
</p>
</li>
<li> <p><code>Lat</code>: Corner latitude coordinate
</p>
</li></ul>



<h3>References</h3>

<p>Jaouen, Gaëlle, 2023, &quot;Nouragues forest permanent plots details&quot;, <a href="https://doi.org/10.18167/DVN1/HXKS4E">doi:10.18167/DVN1/HXKS4E</a>, CIRAD Dataverse, V2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NouraguesPlot201)
str(NouraguesPlot201)
</code></pre>

<hr>
<h2 id='NouraguesTrees'>Nouragues forest dataset</h2><span id='topic+NouraguesTrees'></span>

<h3>Description</h3>

<p>This dataset contains 4 of the 12 plots of &lsquo;Petit Plateau&rsquo; permanent plots fifth census, 2012, Nouragues forestTree dataset (French Guiana). For educational purposes, some virtual trees have been added in the dataset. Dead trees have been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NouraguesTrees)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2050 observations (trees) of the 8 following variables :
</p>

<ul>
<li> <p><code>site</code>: Name of the site set up in the Nouragues forest
</p>
</li>
<li> <p><code>plot</code>: Plot ID
</p>
</li>
<li> <p><code>Xfield</code>: Tree location on the x-axis in the local coordinate system (defined by the 4 corners of the plot)
</p>
</li>
<li> <p><code>Yfield</code>: Tree location on the y-axis in the local coordinate system
</p>
</li>
<li> <p><code>family</code>: Tree family
</p>
</li>
<li> <p><code>genus</code>: Tree genus
</p>
</li>
<li> <p><code>species</code>: Tree species
</p>
</li>
<li> <p><code>D</code>: Tree diameter (in cm)
</p>
</li></ul>



<h3>References</h3>

<p>&lsquo;Petit Plateau&rsquo; permanent plots fifth census, 2012, Nouragues forest, <a href="https://dataverse.cirad.fr/dataset.xhtml?persistentId=doi:10.18167/DVN1/TZ1RL9">https://doi.org/10.18167/DVN1/TZ1RL9</a>, CIRAD Dataverse, V1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(NouraguesTrees)
str(NouraguesTrees)
</code></pre>

<hr>
<h2 id='numberCorner'>Get the UTM coordinates with the corner of the plot</h2><span id='topic+numberCorner'></span>

<h3>Description</h3>

<p>Get the UTM coordinates from the latitude and longitude of the corners of a plot.
The function also assign a number to the corners in a clockwise or counterclockwise way, with the number 1 for the XY origin.
Corner numbering is done as followed:
</p>

<ul>
<li><p> axis X: the corner 1 to the corner 2
</p>
</li>
<li><p> axis Y: the corner 1 to the corner 4
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>numberCorner(longlat = NULL, projCoord = NULL, plot, origin, clockWise)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numberCorner_+3A_longlat">longlat</code></td>
<td>
<p>(optional) data frame with the coordinates in longitude latitude (eg. cbind(longitude, latitude)).</p>
</td></tr>
<tr><td><code id="numberCorner_+3A_projcoord">projCoord</code></td>
<td>
<p>(optional) data frame with the projected coordinates in X Y</p>
</td></tr>
<tr><td><code id="numberCorner_+3A_plot">plot</code></td>
<td>
<p>A vector of codes (names) of the plots</p>
</td></tr>
<tr><td><code id="numberCorner_+3A_origin">origin</code></td>
<td>
<p>A logical vector with TRUE corresponding of the origin of the axis of each plot.</p>
</td></tr>
<tr><td><code id="numberCorner_+3A_clockwise">clockWise</code></td>
<td>
<p>A logical, whether the numbering should be done in a clockwise (TRUE) or counterclockwise (FALSE) way.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with:
</p>

<ul>
<li> <p><code>plot</code>: The code of the plot
</p>
</li>
<li> <p><code>X</code>: The coordinates X in UTM
</p>
</li>
<li> <p><code>Y</code>: The coordinates Y in UTM
</p>
</li>
<li> <p><code>corner</code>: The corner numbers
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Arthur PERE, Maxime REJOU-MECHAIN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coord &lt;- data.frame(X = c(0, 200, 0, 200), Y = c(0, 0, 200, 200)) + 5000
plot &lt;- rep("plot1", 4)
origin &lt;- c(FALSE, FALSE, TRUE, FALSE)

# if you turn clock wise
corner &lt;- numberCorner(projCoord = coord, plot = plot, origin = origin, clockWise = TRUE)

# Plot the plot
plot(coord, asp = 1)
text(coord, labels = corner$corner, pos = 1)


# Using a counterclockwise way
corner &lt;- numberCorner(projCoord = coord, plot = plot, origin = origin, clockWise = FALSE)

# Plot the plot
plot(coord, asp = 1)
text(coord, labels = corner$corner, pos = 1)
</code></pre>

<hr>
<h2 id='param_4'>Posterior distribution of Chave et al.'s 2014 equation 4 parameters</h2><span id='topic+param_4'></span>

<h3>Description</h3>

<p>This matrix contains the posterior distribution of the parameters of Equation 4 of Chave et al. (2014),
obtained in a Bayesian framework with uninformative priors through a Metropolis algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("param_4")
</code></pre>


<h3>Format</h3>

<p>A data frame with 1001 observations on the following 3 variables.
</p>

<ul>
<li> <p><code>intercept</code>: Vector of intercept values
</p>
</li>
<li> <p><code>logagbt</code>: Vector of the model coefficients associated with the product wood density * diameter^2 * height
</p>
</li>
<li> <p><code>sd</code>: Vector of model residual standard error (RSE) values
</p>
</li></ul>



<h3>Details</h3>

<p>This dataset is used in the function <code><a href="#topic+AGBmonteCarlo">AGBmonteCarlo()</a></code>.
</p>


<h3>References</h3>

<p>Chave et al. (2014) <em>Improved allometric models to estimate the aboveground biomass of tropical trees</em>,
Global Change Biology, 20 (10), 3177-3190
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(param_4)
str(param_4)
</code></pre>

<hr>
<h2 id='param_7'>Posterior distribution of parameters associated with the equation 7 by Chave et al. 2014.</h2><span id='topic+param_7'></span>

<h3>Description</h3>

<p>This matrix contains the posterior distribution of the parameters of the Equation 7 of Chave et al., (2014),
obtained in a Bayesian framework with uninformative priors through a Metropolis algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("param_7")
</code></pre>


<h3>Format</h3>

<p>A data frame with 1001 observations on the following 9 variables.
</p>

<ul>
<li> <p><code>intercept</code>: Vector of intercept values
</p>
</li>
<li> <p><code>logwsg</code>: Vector of the model coefficients associated with log(wood density)
</p>
</li>
<li> <p><code>logdbh</code>: Vector of the model coefficients associated with log(diameter)
</p>
</li>
<li> <p><code>logdbh2</code>: Vector of the model coefficients associated with log(diameter)^2
</p>
</li>
<li> <p><code>E</code>: Vector of the model coefficients associated with the environmental index E
</p>
</li>
<li> <p><code>sd</code>: Vector of model residual standard error (RSE) values
</p>
</li>
<li> <p><code>temp</code>: Vector of the model coefficients associated with temperature seasonality
</p>
</li>
<li> <p><code>cwd</code>: Vector of the model coefficients associated with climatic water deficit
</p>
</li>
<li> <p><code>prec</code>: Vector of the model coefficients associated with precipitation seasonality
</p>
</li></ul>



<h3>Details</h3>

<p>This dataset is used in the function <code><a href="#topic+AGBmonteCarlo">AGBmonteCarlo()</a></code>.
</p>


<h3>References</h3>

<p>Chave et al. (2014) <em>Improved allometric models to estimate the aboveground biomass of tropical trees</em>,
Global Change Biology, 20 (10), 3177-3190
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(param_7)
str(param_7)
</code></pre>

<hr>
<h2 id='predictHeight'>Tree height predictions</h2><span id='topic+predictHeight'></span>

<h3>Description</h3>

<p>The function predicts height from diameter based on a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictHeight(D, model, err = FALSE, plot = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictHeight_+3A_d">D</code></td>
<td>
<p>Vector of diameter (in cm).</p>
</td></tr>
<tr><td><code id="predictHeight_+3A_model">model</code></td>
<td>
<p>A height-diameter model output by the function <code><a href="#topic+modelHD">modelHD()</a></code></p>
</td></tr>
<tr><td><code id="predictHeight_+3A_err">err</code></td>
<td>
<p>If <code>TRUE</code>, An error is taken randomly from a normal distribution with a mean of
zero and a standard deviation equalled to the residual standard error of the model (RSE). Only used
for the Monte Carlo approach (see <code><a href="#topic+AGBmonteCarlo">AGBmonteCarlo()</a></code>), otherwise it should be
let as <code>FALSE</code>, the default case.</p>
</td></tr>
<tr><td><code id="predictHeight_+3A_plot">plot</code></td>
<td>
<p>(optional) Plot ID, must be either one value, or a vector of the same length as D. This argument is used to build
stand-specific HD models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case where the error is <code>FALSE</code> and the model is a log-log model, we use the
Baskerville correction, a bias correction factor used to get unbiased backtransformation values.
</p>


<h3>Value</h3>

<p>Returns a vector of total tree height (in m).
</p>


<h3>Author(s)</h3>

<p>Maxime REJOU-MECHAIN, Ariane TANGUY, Arthur PERE
</p>


<h3>See Also</h3>

<p><code><a href="minpack.lm.html#topic+nlsLM">minpack.lm::nlsLM()</a></code>
</p>

<hr>
<h2 id='procrust'>Procrust analysis</h2><span id='topic+procrust'></span>

<h3>Description</h3>

<p>Do a procrust analysis. X is the target matrix, Y is the matrix we want to fit to the target.
This function returns a translation vector and a rotation matrix
After the procrust problem you <strong>must</strong> do the rotation before the translation.
<strong>Warning : The order of the value on both matrix is important</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procrust(X, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="procrust_+3A_x">X</code></td>
<td>
<p>the target matrix</p>
</td></tr>
<tr><td><code id="procrust_+3A_y">Y</code></td>
<td>
<p>the matrix we want to fit to the target</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the translation vector and the matrix of rotation
</p>


<h3>Author(s)</h3>

<p>Arthur PERE
</p>

<hr>
<h2 id='retrieveH'>Retrieving tree height from models</h2><span id='topic+retrieveH'></span>

<h3>Description</h3>

<p>From the diameter and either i) a model, ii) the coordinates of the plot or iii) the region, this function gives an estimate of the total tree height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieveH(D, model = NULL, coord = NULL, region = NULL, plot = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retrieveH_+3A_d">D</code></td>
<td>
<p>Vector of diameters.</p>
</td></tr>
<tr><td><code id="retrieveH_+3A_model">model</code></td>
<td>
<p>A model output by the function <code><a href="#topic+modelHD">modelHD()</a></code>.</p>
</td></tr>
<tr><td><code id="retrieveH_+3A_coord">coord</code></td>
<td>
<p>Coordinates of the site(s), either a vector (e.g. c(longitude, latitude)) or a
matrix/dataframe with two columns (e.g. cbind(longitude, latitude)).</p>
</td></tr>
<tr><td><code id="retrieveH_+3A_region">region</code></td>
<td>
<p>Area of your dataset to estimate tree height thanks to Weibull-H region-, continent-specific
and pantropical models proposed by Feldpausch et al. (2012). To be chosen between:
</p>

<ul>
<li> <p><code>Africa</code>: Africa
</p>
</li>
<li> <p><code>CAfrica</code>: Central Africa
</p>
</li>
<li> <p><code>EAfrica</code>: Eastern Africa
</p>
</li>
<li> <p><code>WAfrica</code>: Western Africa
</p>
</li>
<li> <p><code>SAmerica</code>: Southern America
</p>
</li>
<li> <p><code>BrazilianShield</code>: Brazilian Shield
</p>
</li>
<li> <p><code>ECAmazonia</code>: East-Central Amazonia
</p>
</li>
<li> <p><code>GuianaShield</code>: Guiana Shield
</p>
</li>
<li> <p><code>WAmazonia</code>: Western Amazonia
</p>
</li>
<li> <p><code>SEAsia</code>: South-Eastern Asia
</p>
</li>
<li> <p><code>NAustralia</code>: Northern Australia
</p>
</li>
<li> <p><code>Pantropical</code>: Pantropical
</p>
</li></ul>
</td></tr>
<tr><td><code id="retrieveH_+3A_plot">plot</code></td>
<td>
<p>(optional) Plot ID, must be either one value, or a vector of the same length as D. This argument is used to build
stand-specific HD models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with:
</p>

<ul>
<li> <p><code>H</code>: Height predicted by the model
</p>
</li>
<li> <p><code>RSE</code> Residual Standard Error of the model, or a vector of those for each plot
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ariane TANGUY, Maxime REJOU-MECHAIN, Arthur PERE
</p>


<h3>References</h3>

<p>Feldpausch et al. <em>Tree height integrated into pantropical forest biomass estimates</em>. Biogeosciences (2012): 3381-3403.
</p>
<p>Chave et al. <em>Improved allometric models to estimate the aboveground biomass of tropical trees</em>. Global change biology 20.10 (2014): 3177-3190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelHD">modelHD()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a database
data(NouraguesHD)
model &lt;- modelHD(D = NouraguesHD$D, H = NouraguesHD$H, method = "log2")

# If any height model is available
H &lt;- retrieveH(D = NouraguesHD$D, model = model)

# If the only data available are the coordinates of your spot
n &lt;- length(NouraguesHD$D)
coord &lt;- cbind(long = rep(-52.68, n), lat = rep(4.08, n))

H &lt;- retrieveH(D = NouraguesHD$D, coord = coord)


# If the only data available is the region of your spot
H &lt;- retrieveH(D = NouraguesHD$D, region = "GuianaShield")
</code></pre>

<hr>
<h2 id='sd_10'>Mean standard deviation of wood density estimates at different taxonomic levels</h2><span id='topic+sd_10'></span>

<h3>Description</h3>

<p>This dataset gives the mean standard deviation of wood density values of the <a href="#topic+wdData">wdData</a> dataset
at different taxonomical levels only considering taxa having more than 10 different values.
This dataset is used in the function <code><a href="#topic+getWoodDensity">getWoodDensity()</a></code> to associate at the appropriate taxonomic
level a mean error to wood density estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("sd_10")
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 observations on the following 2 variables:
</p>

<ul>
<li> <p><code>taxo</code>: Character vector with the different taxonomical levels (family, genus, species)
</p>
</li>
<li> <p><code>sd</code>: Numeric vector giving the mean standard deviation of wood density values
</p>
</li></ul>



<h3>Details</h3>

<p>This dataset is used in the function <code><a href="#topic+getWoodDensity">getWoodDensity()</a></code>.
</p>


<h3>References</h3>

<p>Rejou-Mechain et al. (2017).
<em>BIOMASS: An R Package for estimating above-ground biomass and its uncertainty in tropical forests</em>.
Methods in Ecology and Evolution, 8 (9), 1163-1167.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sd_10)
str(sd_10)
</code></pre>

<hr>
<h2 id='subplot_summary'>Summarise and display tree information by subplot</h2><span id='topic+subplot_summary'></span>

<h3>Description</h3>

<p>After applying the <code><a href="#topic+divide_plot">divide_plot()</a></code> function, this function summarises with any defined function the desired tree metric by sub-plot and displays the plot representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subplot_summary(
  subplots,
  value = NULL,
  draw_plot = TRUE,
  per_ha = TRUE,
  fun = sum,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subplot_summary_+3A_subplots">subplots</code></td>
<td>
<p>output of the <code><a href="#topic+divide_plot">divide_plot()</a></code> function</p>
</td></tr>
<tr><td><code id="subplot_summary_+3A_value">value</code></td>
<td>
<p>a character indicating the column in subplots$tree_data (a tree metric) to be summarised</p>
</td></tr>
<tr><td><code id="subplot_summary_+3A_draw_plot">draw_plot</code></td>
<td>
<p>a logical indicating whether the plot design should be displayed</p>
</td></tr>
<tr><td><code id="subplot_summary_+3A_per_ha">per_ha</code></td>
<td>
<p>a logical indicating whether the metric summary should be per hectare</p>
</td></tr>
<tr><td><code id="subplot_summary_+3A_fun">fun</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="subplot_summary_+3A_...">...</code></td>
<td>
<p>optional arguments to fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containg the following elements :
</p>

<ul>
<li> <p><code>tree_summary</code> : a summary of the metric per subplot
</p>
</li>
<li> <p><code>polygon</code> : an sf object : simple feature collection of the subplot's polygon
</p>
</li>
<li> <p><code>plot_design</code> : a ggplot object (or a list of ggplot objects) that can easily be modified
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Arthur Bailly
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One plot with repeated measurements of each corner
data("NouraguesPlot201")
data("NouraguesTrees")
check_plot201 &lt;- check_plot_coord(
  corner_data = NouraguesPlot201,
  proj_coord = c("Xutm","Yutm"), rel_coord = c("Xfield","Yfield"),
  trust_GPS_corners = TRUE, draw_plot = FALSE)
subplots_201 &lt;- suppressWarnings(
  divide_plot(
    corner_data = check_plot201$corner_coord, 
    rel_coord = c("x_rel","y_rel"), proj_coord = c("x_proj","y_proj"),
    grid_size = 50,
    tree_data =  NouraguesTrees[NouraguesTrees$Plot == 201,],
    tree_coords = c("Xfield","Yfield")))
# Sum summary (by default) of diameter
subplots_201_sum &lt;- subplot_summary(subplots_201 , value = "D", draw_plot = FALSE)
subplots_201_sum$tree_summary
subplots_201_sum$polygon

  subplots_201_sum$plot_design

# 9th quantile summary (for example) of diameter
subplots_201_quant &lt;- subplot_summary(subplots_201 , value = "D", draw_plot = FALSE,
                                      fun = quantile, probs=0.9)
  

# Dealing with multiple plots
## Not run: 
  data("NouraguesCoords")
  nouragues_subplots &lt;- suppressWarnings(
  divide_plot(
     corner_data = NouraguesCoords,
    rel_coord = c("Xfield","Yfield"), proj_coord = c("Xutm","Yutm"),
    corner_plot_ID = "Plot",
    grid_size = 50,
    tree_data = NouraguesTrees, tree_coords =  c("Xfield","Yfield"),
    tree_plot_ID = "Plot"))
  # Sum summary (by default)
  nouragues_sum &lt;- subplot_summary(nouragues_subplots , value = "D", draw_plot = FALSE)
  nouragues_sum$tree_summary
  subplots_201_sum$plot_design

## End(Not run)

</code></pre>

<hr>
<h2 id='summaryByPlot'>Summarise by plot the posterior distribution of AGB values</h2><span id='topic+summaryByPlot'></span>

<h3>Description</h3>

<p>This function summarizes the matrix <code>AGB_val</code> given by the function <code><a href="#topic+AGBmonteCarlo">AGBmonteCarlo()</a></code> by plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryByPlot(AGB_val, plot, drawPlot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaryByPlot_+3A_agb_val">AGB_val</code></td>
<td>
<p>Matrix resulting from the <code><a href="#topic+AGBmonteCarlo">AGBmonteCarlo()</a></code> function (AGB_val element of the list), or just the output of the <code><a href="#topic+AGBmonteCarlo">AGBmonteCarlo()</a></code> function.</p>
</td></tr>
<tr><td><code id="summaryByPlot_+3A_plot">plot</code></td>
<td>
<p>Vector corresponding to the plots code (plots ID)</p>
</td></tr>
<tr><td><code id="summaryByPlot_+3A_drawplot">drawPlot</code></td>
<td>
<p>A logic indicating whether the graphic should be displayed or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If some trees belong to an unknown plot (i.e. NA value in the plot arguments), their AGB values are randomly assigned
to a plot at each iteration of the AGB monte Carlo approach.
</p>


<h3>Value</h3>

<p>a data frame where:
</p>

<ul>
<li> <p><code>plot</code>: the code of the plot
</p>
</li>
<li> <p><code>AGB</code>: AGB value at the plot level
</p>
</li>
<li> <p><code>Cred_2.5</code>: the 2.5\
</p>
</li>
<li> <p><code>Cred_97.5</code>: the 97.5\
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Load a database
data(NouraguesHD)
data(NouraguesTrees)

# Modelling height-diameter relationship
HDmodel &lt;- modelHD(D = NouraguesHD$D, H = NouraguesHD$H, method = "log2")

# Retrieving wood density values

  NouraguesWD &lt;- getWoodDensity(NouraguesTrees$Genus, NouraguesTrees$Species,
                                stand = NouraguesTrees$plotId)


# Propagating errors

  resultMC &lt;- AGBmonteCarlo(
    D = NouraguesTrees$D, WD = NouraguesWD$meanWD,
    errWD = NouraguesWD$sdWD, HDmodel = HDmodel )
  
  # The summary by plot
  summaryByPlot(AGB_val = resultMC$AGB_simu, plot = NouraguesTrees$Plot)


</code></pre>

<hr>
<h2 id='wdData'>The global wood density database</h2><span id='topic+wdData'></span>

<h3>Description</h3>

<p>The global wood density database (Chave et al. 2009, Zanne et al. 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("wdData")
</code></pre>


<h3>Format</h3>

<p>A data frame with 16467 observations on the following 7 variables.
</p>

<ul>
<li> <p><code>family</code>: a character vector indicating the family
</p>
</li>
<li> <p><code>genus</code>: a character vector indicating the genus
</p>
</li>
<li> <p><code>species</code>: a character vector indicating the species
</p>
</li>
<li> <p><code>wd</code>: a numeric vector of wood densities (g/cm^3)
</p>
</li>
<li> <p><code>region</code>: a character vector of regions (see <code><a href="#topic+getWoodDensity">getWoodDensity()</a></code>)
</p>
</li>
<li> <p><code>referenceNumber</code>: a numeric vector of reference numbers (bibliography)
</p>
</li>
<li> <p><code>regionId</code>: a character vector of region ids
</p>
</li></ul>



<h3>Details</h3>

<p>This dataset is used in the function <code><a href="#topic+getWoodDensity">getWoodDensity()</a></code>, to estimate a taxon-average wood density value.
</p>


<h3>Source</h3>

<p>Zanne et al. <em>Global wood density database.</em> Dryad. Identifier: http://datadryad.org/handle/10255/dryad.235 (2009).
</p>


<h3>References</h3>

<p>Chave et al. (2009) <em>Towards a worldwide wood economics spectrum.</em> Ecology letters 12:4, 351-366.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wdData)
str(wdData)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
