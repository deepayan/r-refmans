<!DOCTYPE html><html><head><title>Help for package miceadds</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {miceadds}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#miceadds-package'>
<p>Some Additional Multiple Imputation Functions, Especially for 'mice'</p></a></li>
<li><a href='#complete.miceadds'>
<p>Creates Imputed Dataset from a <code>mids.nmi</code> or <code>mids.1chain</code> Object</p></a></li>
<li><a href='#crlrem'>
<p><span class="rlang"><b>R</b></span> Utilities: Removing CF Line Endings</p></a></li>
<li><a href='#cxxfunction.copy'>
<p><span class="rlang"><b>R</b></span> Utilities: Copy of an <span class="pkg">Rcpp</span> File</p></a></li>
<li><a href='#data.allison'>
<p>Datasets from Allison's <em>Missing Data</em> Book</p></a></li>
<li><a href='#data.enders'>
<p>Datasets from Enders' <em>Missing Data</em> Book</p></a></li>
<li><a href='#data.graham'>
<p>Datasets from Grahams <em>Missing Data</em> Book</p></a></li>
<li><a href='#data.internet'>
<p>Dataset Internet</p></a></li>
<li><a href='#data.largescale'>
<p>Large-scale Dataset for Testing Purposes (Many Cases, Few Variables)</p></a></li>
<li><a href='#data.ma'>
<p>Example Datasets for <span class="pkg">miceadds</span> Package</p></a></li>
<li><a href='#data.smallscale'>
<p>Small-Scale Dataset for Testing Purposes (Moderate Number of Cases,</p>
Many Variables)</a></li>
<li><a href='#datlist_create'>
<p>Creates Objects of Class <code>datlist</code> or <code>nested.datlist</code></p></a></li>
<li><a href='#datlist2Amelia'>
<p>Converting an Object of class <code>amelia</code></p></a></li>
<li><a href='#datlist2mids'>
<p>Converting a List of Multiply Imputed Data Sets into a <code>mids</code> Object</p></a></li>
<li><a href='#draw.pv.ctt'>
<p>Plausible Value Imputation Using a Known Measurement Error Variance</p>
(Based on Classical Test Theory)</a></li>
<li><a href='#filename_split'>
<p>Some Functionality for Strings and File Names</p></a></li>
<li><a href='#files_move'>
<p>Moves Files from One Directory to Another Directory</p></a></li>
<li><a href='#fleishman_sim'>
<p>Simulating Univariate Data from Fleishman Power Normal Transformations</p></a></li>
<li><a href='#grep.vec'>
<p><span class="rlang"><b>R</b></span> Utilities: Vector Based Versions of <code>grep</code></p></a></li>
<li><a href='#GroupMean'>
<p>Calculation of Groupwise Descriptive Statistics for Matrices</p></a></li>
<li><a href='#in_CI'>
<p>Indicator Function for Analyzing Coverage</p></a></li>
<li><a href='#index.dataframe'>
<p><span class="rlang"><b>R</b></span> Utilities: Include an Index to a Data Frame</p></a></li>
<li><a href='#jomo2datlist'>
<p>Converts a <span class="pkg">jomo</span> Data Frame in Long Format into a List of Datasets or an Object</p>
of Class <code>mids</code></a></li>
<li><a href='#kernelpls.fit2'>
<p>Kernel PLS Regression</p></a></li>
<li><a href='#library_install'>
<p><span class="rlang"><b>R</b></span> Utilities: Loading a Package or Installation of a Package if Necessary</p></a></li>
<li><a href='#lm.cluster'>
<p>Cluster Robust Standard Errors for Linear Models and General Linear Models</p></a></li>
<li><a href='#lmer_vcov'>
<p>Statistical Inference for Fixed and Random Structure for Fitted Models</p>
in <span class="pkg">lme4</span></a></li>
<li><a href='#load.data'>
<p><span class="rlang"><b>R</b></span> Utilities: Loading/Reading Data Files using <span class="pkg">miceadds</span></p></a></li>
<li><a href='#load.Rdata'>
<p><span class="rlang"><b>R</b></span> Utilities: Loading <code>Rdata</code> Files in a Convenient Way</p></a></li>
<li><a href='#ma_lme4_formula'>
<p>Utility Functions for Working with <span class="pkg">lme4</span> Formula Objects</p></a></li>
<li><a href='#ma_rmvnorm'>
<p>Simulating Normally Distributed Data</p></a></li>
<li><a href='#ma.scale2'>
<p>Standardization of a Matrix</p></a></li>
<li><a href='#ma.wtd.statNA'>
<p>Some Multivariate Descriptive Statistics for Weighted Data in <span class="pkg">miceadds</span></p></a></li>
<li><a href='#mi_dstat'>
<p>Cohen's d Effect Size for Missingness Indicators</p></a></li>
<li><a href='#mi.anova'>
<p>Analysis of Variance for Multiply Imputed Data Sets (Using the <code class="reqn">D_2</code> Statistic)</p></a></li>
<li><a href='#mice_imputation_2l_lmer'>
<p>Imputation of a Continuous or a Binary Variable From a Two-Level Regression Model</p>
using <span class="pkg">lme4</span> or <span class="pkg">blme</span></a></li>
<li><a href='#mice_inits'>
<p>Arguments for <code>mice::mice</code> Function</p></a></li>
<li><a href='#mice.1chain'>
<p>Multiple Imputation by Chained Equations using One Chain</p></a></li>
<li><a href='#mice.impute.2l.contextual.pmm'>
<p>Imputation by Predictive Mean Matching or Normal Linear Regression</p>
with Contextual Variables</a></li>
<li><a href='#mice.impute.2l.latentgroupmean.ml'>
<p>Imputation of Latent and Manifest Group Means for Multilevel Data</p></a></li>
<li><a href='#mice.impute.2lonly.function'><p>Imputation at Level 2 (in <span class="pkg">miceadds</span>)</p></a></li>
<li><a href='#mice.impute.bygroup'>
<p>Groupwise Imputation Function</p></a></li>
<li><a href='#mice.impute.catpmm'>
<p>Imputation of a Categorical Variable Using Multivariate Predictive</p>
Mean Matching</a></li>
<li><a href='#mice.impute.constant'>
<p>Imputation Using a Fixed Vector</p></a></li>
<li><a href='#mice.impute.hotDeck'>
<p>Imputation of a Variable Using Probabilistic Hot Deck Imputation</p></a></li>
<li><a href='#mice.impute.imputeR.lmFun'>
<p>Wrapper Function to Imputation Methods in the <span class="pkg">imputeR</span> Package</p></a></li>
<li><a href='#mice.impute.ml.lmer'>
<p>Multilevel Imputation Using <span class="pkg">lme4</span></p></a></li>
<li><a href='#mice.impute.plausible.values'>
<p>Plausible Value Imputation using Classical Test Theory and</p>
Based on Individual Likelihood</a></li>
<li><a href='#mice.impute.pls'>
<p>Imputation using Partial Least Squares for Dimension Reduction</p></a></li>
<li><a href='#mice.impute.pmm3'>
<p>Imputation by Predictive Mean Matching (in <span class="pkg">miceadds</span>)</p></a></li>
<li><a href='#mice.impute.rlm'>
<p>Imputation of a Linear Model by Bayesian Bootstrap</p></a></li>
<li><a href='#mice.impute.simputation'>
<p>Wrapper Function to Imputation Methods in the <span class="pkg">simputation</span> Package</p></a></li>
<li><a href='#mice.impute.smcfcs'>
<p>Substantive Model Compatible Multiple Imputation (Single Level)</p></a></li>
<li><a href='#mice.impute.synthpop'>
<p>Using a <span class="pkg">synthpop</span> Synthesizing Method in the <span class="pkg">mice</span> Package</p></a></li>
<li><a href='#mice.impute.tricube.pmm'>
<p>Imputation by Tricube Predictive Mean Matching</p></a></li>
<li><a href='#mice.impute.weighted.pmm'>
<p>Imputation by Weighted Predictive Mean Matching or Weighted Normal Linear Regression</p></a></li>
<li><a href='#mice.nmi'>
<p>Nested Multiple Imputation</p></a></li>
<li><a href='#miceadds-defunct'><p>Defunct <span class="pkg">miceadds</span> Functions</p></a></li>
<li><a href='#miceadds-utilities'><p>Utility Functions in <span class="pkg">miceadds</span></p></a></li>
<li><a href='#micombine.chisquare'>
<p>Combination of Chi Square Statistics of Multiply Imputed Datasets</p></a></li>
<li><a href='#micombine.cor'>
<p>Inference for Correlations and Covariances for Multiply Imputed Datasets</p></a></li>
<li><a href='#micombine.F'>
<p>Combination of F Statistics for Multiply Imputed Datasets Using a</p>
Chi Square Approximation</a></li>
<li><a href='#mids2datlist'>
<p>Converting a <code>mids</code>, <code>mids.1chain</code> or <code>mids.nmi</code></p>
Object in a Dataset List</a></li>
<li><a href='#mids2mlwin'><p>Export <code>mids</code> object to MLwiN</p></a></li>
<li><a href='#ml_mcmc'>
<p>MCMC Estimation for Mixed Effects Model</p></a></li>
<li><a href='#NestedImputationList'>
<p>Functions for Analysis of Nested Multiply Imputed Datasets</p></a></li>
<li><a href='#nestedList2List'>
<p>Converting a Nested List into a List (and Vice Versa)</p></a></li>
<li><a href='#NMIwaldtest'>
<p>Wald Test for Nested Multiply Imputed Datasets</p></a></li>
<li><a href='#nnig_sim'>
<p>Simulation of Multivariate Linearly Related Non-Normal Variables</p></a></li>
<li><a href='#output.format1'>
<p><span class="rlang"><b>R</b></span> Utilities: Formatting R Output on the <span class="rlang"><b>R</b></span> Console</p></a></li>
<li><a href='#pca.covridge'>
<p>Principal Component Analysis with Ridge Regularization</p></a></li>
<li><a href='#pool_mi'>
<p>Statistical Inference for Multiply Imputed Datasets</p></a></li>
<li><a href='#pool.mids.nmi'>
<p>Pooling for Nested Multiple Imputation</p></a></li>
<li><a href='#Reval'>
<p><span class="rlang"><b>R</b></span> Utilities: Evaluates a String as an Expression in <span class="rlang"><b>R</b></span></p></a></li>
<li><a href='#Rfunction_include_argument_values'>
<p>Utility Functions for Writing <span class="rlang"><b>R</b></span> Functions</p></a></li>
<li><a href='#Rhat.mice'>
<p>Rhat Convergence Statistic of a <code>mice</code> Imputation</p></a></li>
<li><a href='#round2'>
<p><span class="rlang"><b>R</b></span> Utilities: Rounding DIN 1333 (Kaufmaennisches Runden)</p></a></li>
<li><a href='#Rsessinfo'>
<p><span class="rlang"><b>R</b></span> Utilities: <span class="rlang"><b>R</b></span> Session Information</p></a></li>
<li><a href='#save.data'>
<p><span class="rlang"><b>R</b></span> Utilities: Saving/Writing Data Files using <span class="pkg">miceadds</span></p></a></li>
<li><a href='#save.Rdata'>
<p><span class="rlang"><b>R</b></span> Utilities: Save a Data Frame in <code>Rdata</code> Format</p></a></li>
<li><a href='#scale_datlist'>
<p>Adding a Standardized Variable to a List of Multiply Imputed Datasets or a</p>
Single Datasets</a></li>
<li><a href='#scan.vec'>
<p><span class="rlang"><b>R</b></span> Utilities: Scan a Character Vector</p></a></li>
<li><a href='#source.all'>
<p><span class="rlang"><b>R</b></span> Utilities: Source all R or <span class="pkg">Rcpp</span> Files within a Directory</p></a></li>
<li><a href='#stats0'>
<p>Descriptive Statistics for a Vector or a Data Frame</p></a></li>
<li><a href='#str_C.expand.grid'>
<p><span class="rlang"><b>R</b></span> Utilities: String Paste Combined with <code>expand.grid</code></p></a></li>
<li><a href='#subset_datlist'>
<p>Subsetting Multiply Imputed Datasets and Nested Multiply Imputed Datasets</p></a></li>
<li><a href='#sumpreserving.rounding'>
<p>Sum Preserving Rounding</p></a></li>
<li><a href='#syn_da'>
<p>Generation of Synthetic Data Utilizing Data Augmentation</p></a></li>
<li><a href='#syn_mice'>
<p>Constructs Synthetic Dataset with <span class="pkg">mice</span> Imputation Methods</p></a></li>
<li><a href='#syn.constant'>
<p>Synthesizing Method for Fixed Values by Design in <span class="pkg">synthpop</span></p></a></li>
<li><a href='#syn.formula'>
<p>Synthesizing Method for <span class="pkg">synthpop</span> Using a Formula Interface</p></a></li>
<li><a href='#syn.mice'>
<p>Using a <span class="pkg">mice</span> Imputation Method in the <span class="pkg">synthpop</span> Package</p></a></li>
<li><a href='#systime'>
<p><span class="rlang"><b>R</b></span> Utilities: Various Strings Representing System Time</p></a></li>
<li><a href='#tw.imputation'>
<p>Two-Way Imputation</p></a></li>
<li><a href='#VariableNames2String'>
<p>Stringing Variable Names with Line Breaks</p></a></li>
<li><a href='#visitSequence.determine'>
<p>Automatic Determination of a Visit Sequence in <code>mice</code></p></a></li>
<li><a href='#with.miceadds'>
<p>Evaluates an Expression for (Nested) Multiply Imputed Datasets</p></a></li>
<li><a href='#write.datlist'>
<p>Write a List of Multiply Imputed Datasets</p></a></li>
<li><a href='#write.fwf2'>
<p>Reading and Writing Files in Fixed Width Format</p></a></li>
<li><a href='#write.mice.imputation'>
<p>Export Multiply Imputed Datasets from a <code>mids</code> Object</p></a></li>
<li><a href='#write.pspp'>
<p>Writing a Data Frame into SPSS Format Using PSPP Software</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Some Additional Multiple Imputation Functions, Especially for
'mice'</td>
</tr>
<tr>
<td>Version:</td>
<td>3.17-44</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08 19:08:24</td>
</tr>
<tr>
<td>Author:</td>
<td>
    Alexander Robitzsch [aut,cre] (&lt;https://orcid.org/0000-0002-8226-3132&gt;),
    Simon Grund [aut] (&lt;https://orcid.org/0000-0002-1290-8986&gt;),
    Thorsten Henke [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Robitzsch &lt;robitzsch@ipn.uni-kiel.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Contains functions for multiple imputation which
    complements existing functionality in R.
    In particular, several imputation methods for the
    mice package (van Buuren &amp; Groothuis-Oudshoorn, 2011,
    &lt;<a href="https://doi.org/10.18637%2Fjss.v045.i03">doi:10.18637/jss.v045.i03</a>&gt;) are implemented.
    Main features of the miceadds package include
    plausible value imputation (Mislevy, 1991,
    &lt;<a href="https://doi.org/10.1007%2FBF02294457">doi:10.1007/BF02294457</a>&gt;), multilevel imputation for
    variables at any level or with any number of hierarchical
    and non-hierarchical levels (Grund, Luedtke &amp; Robitzsch,
    2018, &lt;<a href="https://doi.org/10.1177%2F1094428117703686">doi:10.1177/1094428117703686</a>&gt;; van Buuren, 2018, 
    Ch.7, &lt;<a href="https://doi.org/10.1201%2F9780429492259">doi:10.1201/9780429492259</a>&gt;), imputation using 
    partial least squares (PLS) for high dimensional 
    predictors (Robitzsch, Pham &amp; Yanagida, 2016), 
    nested multiple imputation (Rubin, 2003, 
    &lt;<a href="https://doi.org/10.1111%2F1467-9574.00217">doi:10.1111/1467-9574.00217</a>&gt;), substantive model
    compatible imputation (Bartlett et al., 2015,
    &lt;<a href="https://doi.org/10.1177%2F0962280214521348">doi:10.1177/0962280214521348</a>&gt;), and features
    for the generation of synthetic datasets
    (Reiter, 2005, &lt;<a href="https://doi.org/10.1111%2Fj.1467-985X.2004.00343.x">doi:10.1111/j.1467-985X.2004.00343.x</a>&gt;;
    Nowok, Raab, &amp; Dibben, 2016, &lt;<a href="https://doi.org/10.18637%2Fjss.v074.i11">doi:10.18637/jss.v074.i11</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5-0), mice (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, methods, mitools, Rcpp, stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BIFIEsurvey, blme, car, CDM, coda, foreign, inline, lme4,
MASS, Matrix, MBESS, MCMCglmm, mdmb, pls, numDeriv, readxl,
sandwich, sirt, sjlabelled, synthpop, TAM</td>
</tr>
<tr>
<td>Enhances:</td>
<td>Amelia, imputeR, jomo, micemd, mitml, pan, simputation</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexanderrobitzsch/miceadds">https://github.com/alexanderrobitzsch/miceadds</a>,
<a href="https://sites.google.com/view/alexander-robitzsch/software">https://sites.google.com/view/alexander-robitzsch/software</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexanderrobitzsch/miceadds/issues?state=open">https://github.com/alexanderrobitzsch/miceadds/issues?state=open</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 18:14:47 UTC; sunpn563</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='miceadds-package'>
Some Additional Multiple Imputation Functions, Especially for 'mice'
</h2><span id='topic+miceadds-package'></span><span id='topic+miceadds'></span>

<h3>Description</h3>


<p>    Contains functions for multiple imputation which
    complements existing functionality in R.
    In particular, several imputation methods for the
    mice package (van Buuren &amp; Groothuis-Oudshoorn, 2011,
    &lt;doi:10.18637/jss.v045.i03&gt;) are implemented.
    Main features of the miceadds package include
    plausible value imputation (Mislevy, 1991,
    &lt;doi:10.1007/BF02294457&gt;), multilevel imputation for
    variables at any level or with any number of hierarchical
    and non-hierarchical levels (Grund, Luedtke &amp; Robitzsch,
    2018, &lt;doi:10.1177/1094428117703686&gt;; van Buuren, 2018, 
    Ch.7, &lt;doi:10.1201/9780429492259&gt;), imputation using 
    partial least squares (PLS) for high dimensional 
    predictors (Robitzsch, Pham &amp; Yanagida, 2016), 
    nested multiple imputation (Rubin, 2003, 
    &lt;doi:10.1111/1467-9574.00217&gt;), substantive model
    compatible imputation (Bartlett et al., 2015,
    &lt;doi:10.1177/0962280214521348&gt;), and features
    for the generation of synthetic datasets
    (Reiter, 2005, &lt;doi:10.1111/j.1467-985X.2004.00343.x&gt;;
    Nowok, Raab, &amp; Dibben, 2016, &lt;doi:10.18637/jss.v074.i11&gt;).
</p>


<h3>Details</h3>


<ul>
<li><p> The <span class="pkg">miceadds</span> package contains some functionality for imputation of multilevel
data. The function <code><a href="#topic+mice.impute.ml.lmer">mice.impute.ml.lmer</a></code> is a general function for 
imputing multilevel data with hierarchical or cross-classified structures for
variables at an arbitrary level. This imputation method uses the <code>lme4::lmer</code> function
in the <span class="pkg">lme4</span> package. The imputation method <code><a href="#topic+mice.impute.2lonly.function">mice.impute.2lonly.function</a></code>
conducts an imputation for a variable at a higher level for already defined imputation
methods in the <span class="pkg">mice</span> package. Two-level imputation is available in several functions
in the <span class="pkg">mice</span> package (<code><a href="mice.html#topic+mice.impute.2l.pan">mice::mice.impute.2l.pan</a></code>,
<code><a href="mice.html#topic+mice.impute.2l.norm">mice::mice.impute.2l.norm</a></code>) 
as well in <span class="pkg">micemd</span> and <span class="pkg">hmi</span> packages. The <span class="pkg">miceadds</span> package contains
additional imputation methods for two-level datasets: 
<code><a href="#topic+mice.impute.2l.continuous">mice.impute.2l.continuous</a></code> for normally distributed data,
<code><a href="#topic+mice.impute.2l.pmm">mice.impute.2l.pmm</a></code> for predictive mean matching in multilevel models
and <code><a href="#topic+mice.impute.2l.binary">mice.impute.2l.binary</a></code> for binary data.   
</p>
</li>
<li><p> In addition to the usual <code>mice</code> imputation function which employs
parallel chains, the function <code><a href="#topic+mice.1chain">mice.1chain</a></code> does multiple
imputation from a single chain.
</p>
</li>
<li><p> Nested multiple imputation can be conducted with
<code><a href="#topic+mice.nmi">mice.nmi</a></code>. The function <code><a href="#topic+NMIcombine">NMIcombine</a></code> conducts 
statistical inference for nested multiply imputed datasets.
</p>
</li>
<li><p> Imputation based on partial least squares regression is implemented
in <code><a href="#topic+mice.impute.pls">mice.impute.pls</a></code>.
</p>
</li>
<li><p> Unidimensional plausible value imputation for latent variables (or
variables with measurement error) in the <span class="pkg">mice</span> sequential imputation
framework can be applied by using the method
<code><a href="#topic+mice.impute.plausible.values">mice.impute.plausible.values</a></code>.
</p>
</li>
<li><p> Substantive model compatible multiple imputation using fully conditional
specification can be conducted with <code><a href="#topic+mice.impute.smcfcs">mice.impute.smcfcs</a></code>.
</p>
</li>
<li><p> The function <code><a href="#topic+syn_mice">syn_mice</a></code> allows the generation of
synthetic datasets with imputation methods for <span class="pkg">mice</span>. It has
similar functionality as the <span class="pkg">synthpop</span> package (Nowok, Raab, &amp; Dibben, 2016).
The function <code><a href="#topic+mice.impute.synthpop">mice.impute.synthpop</a></code> allows the usage of
<span class="pkg">synthpop</span> synthesization methods in <span class="pkg">mice</span>, while
<code><a href="#topic+syn.mice">syn.mice</a></code> allows the usage of
<span class="pkg">mice</span> imputation methods in <span class="pkg">synthpop</span>.
</p>
</li>
<li><p> The method <code><a href="#topic+mice.impute.simputation">mice.impute.simputation</a></code> is a wrapper function
to imputation methods in the <span class="pkg">simputation</span> package. 
The methods <code><a href="#topic+mice.impute.imputeR.lmFun">mice.impute.imputeR.lmFun</a></code> and
<code><a href="#topic+mice.impute.imputeR.cFun">mice.impute.imputeR.cFun</a></code> are wrapper functions
to imputation methods in the <span class="pkg">imputeR</span> package.
</p>
</li>
<li><p> The <span class="pkg">miceadds</span> package also includes some functions <span class="rlang"><b>R</b></span> utility functions
(e.g. <code><a href="#topic+write.pspp">write.pspp</a></code>, <code><a href="#topic+ma.scale2">ma.scale2</a></code>).
</p>
</li>
<li><p> Imputations for questionnaire items can be
accomplished by two-way imputation (<code><a href="#topic+tw.imputation">tw.imputation</a></code>).
</p>
</li></ul>



<h3>Author(s)</h3>


<p>    Alexander Robitzsch [aut,cre] (&lt;https://orcid.org/0000-0002-8226-3132&gt;),
    Simon Grund [aut] (&lt;https://orcid.org/0000-0002-1290-8986&gt;),
    Thorsten Henke [ctb]
</p>
<p>Maintainer: Alexander Robitzsch &lt;robitzsch@ipn.uni-kiel.de&gt;
</p>


<h3>References</h3>

<p>Bartlett, J. W., Seaman, S. R., White, I. R., Carpenter, J. R., &amp; Alzheimer's Disease
Neuroimaging Initiative (2015). Multiple imputation of covariates by fully
conditional specification: Accommodating the substantive model.
<em>Statistical Methods in Medical Research, 24</em>(4), 462-487.
<a href="https://doi.org/10.1177/0962280214521348">doi:10.1177/0962280214521348</a>
</p>
<p>Grund, S., Luedtke, O., &amp; Robitzsch, A. (2018). Multiple imputation of multilevel
data in organizational research. <em>Organizational Research Methods, 21</em>(1), 111-149.
<a href="https://doi.org/10.1177/1094428117703686">doi:10.1177/1094428117703686</a>
</p>
<p>Mislevy, R. J. (1991). Randomization-based inference about latent variables
from complex samples. <em>Psychometrika, 56</em>(2), 177-196.
<a href="https://doi.org/10.1007/BF02294457">doi:10.1007/BF02294457</a>
</p>
<p>Nowok, B., Raab, G., &amp; Dibben, C. (2016).
<span class="pkg">synthpop</span>: Bespoke creation of synthetic data in <span class="rlang"><b>R</b></span>.
<em>Journal of Statistical Software, 74</em>(11), 1-26.
<a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>
</p>
<p>Reiter, J. P. (2005)  Releasing multiply-imputed, synthetic public use microdata: 
An illustration and empirical study.  
<em>Journal of the Royal Statistical Society, Series A, 168</em>(1), 185-205.
<a href="https://doi.org/10.1111/j.1467-985X.2004.00343.x">doi:10.1111/j.1467-985X.2004.00343.x</a>
</p>
<p>Robitzsch, A., Pham, G., &amp; Yanagida, T. (2016). Fehlende Daten und Plausible Values. 
In S. Breit &amp; C. Schreiner (Hrsg.). <em>Large-Scale Assessment mit R: Methodische 
Grundlagen der oesterreichischen Bildungsstandardueberpruefung</em> (S. 259-293). Wien: facultas.
</p>
<p>Rubin, D. B. (2003). Nested multiple imputation of NMES via partially
incompatible MCMC. <em>Statistica Neerlandica, 57</em>(1), 3-18.
<a href="https://doi.org/10.1111/1467-9574.00217">doi:10.1111/1467-9574.00217</a>
</p>
<p>van Buuren, S. (2018). <em>Flexible imputation of missing data</em>.
Boca Raton: CRC Press. <a href="https://doi.org/10.1201/9780429492259">doi:10.1201/9780429492259</a>
</p>
<p>van Buuren, S., &amp; Groothuis-Oudshoorn, K. (2011). <span class="pkg">mice</span>: 
Multivariate imputation by chained equations in <span class="rlang"><b>R</b></span>. 
<em>Journal of Statistical Software, 45</em>(3), 1-67.
<a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p>See also the CRAN task view <em>Missing Data</em>:<br />
<a href="https://CRAN.R-project.org/view=MissingData">https://CRAN.R-project.org/view=MissingData</a> <br />
</p>
<p>See other <span class="rlang"><b>R</b></span> packages for conducting multiple imputation:
<span class="pkg">mice</span>, <span class="pkg">Amelia</span>, <span class="pkg">pan</span>, <span class="pkg">mi</span>, <span class="pkg">norm</span>,
<span class="pkg">norm2</span>, <span class="pkg">BaBooN</span>, <span class="pkg">VIM</span>, ... <br />
</p>
<p>Some links to internet sites related to missing data:
</p>
<p><em>http://missingdata.lshtm.ac.uk/</em> <br />
<em>http://www.stefvanbuuren.nl/mi/</em> <br />
<em>http://www.bristol.ac.uk/cmm/software/realcom/</em> <br />
<em>https://rmisstastic.netlify.com/</em> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
##   ::'''''''''''''''''''''''''''''''''::
##   :: miceadds 0.11-69 (2013-12-01)   ::
##   ::'''''''''''''''''''''''''''''''''::
##
##  ----------------------- mice at work ---------------------------------
##
##                         (\-.
##                         / _`&gt; .---------.
##                 _)     / _)=  |'-------'|
##                (      / _/    |O   O   o|
##                 `-.__(___)_   | o O . o |
##                               `---------'
##
##                                          oo__
##                                         &lt;;___)------
##                                    oo__   " "
##                                   &lt;;___)------     oo__
##                                     " "           &lt;;___)------
##                                                     " "
</code></pre>

<hr>
<h2 id='complete.miceadds'>
Creates Imputed Dataset from a <code>mids.nmi</code> or <code>mids.1chain</code> Object
</h2><span id='topic+complete.mids.nmi'></span><span id='topic+complete.mids.1chain'></span>

<h3>Description</h3>

<p>Creates imputed dataset from a <code>mids.nmi</code> or <code>mids.1chain</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids.nmi'
complete(data, action=c(1,1), ...)

## S3 method for class 'mids.1chain'
complete(data, action=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete.miceadds_+3A_data">data</code></td>
<td>

<p>Object of class <code>mids.nmi</code> (for <code>complete.mids.nmi</code>) or
<code>mids.1chain</code> (for <code>complete.mids.1chain</code>)
</p>
</td></tr>
<tr><td><code id="complete.miceadds_+3A_action">action</code></td>
<td>

<p>A vector of length two indicating to indices of between and within
imputed dataset for for <code>complete.mids.nmi</code> and an integer for the
index of imputed dataset for <code>complete.mids.1chain</code>.
</p>
</td></tr>
<tr><td><code id="complete.miceadds_+3A_...">...</code></td>
<td>
<p>More arguments to be passed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See also the corresponding <code><a href="mice.html#topic+complete">mice::complete</a></code> function
and <code><a href="mitml.html#topic+mitmlComplete">mitml::mitmlComplete</a></code>.
</p>
<p>Imputation methods: <code><a href="#topic+mice.nmi">mice.nmi</a></code>, <code><a href="#topic+mice.1chain">mice.1chain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Nested multiple imputation and dataset extraction for TIMSS data
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2

# remove first four variables
M &lt;- length(datlist)
for (ll in 1:M){
    datlist[[ll]] &lt;- datlist[[ll]][, -c(1:4) ]
}

#***************
# (1) nested multiple imputation using mice
imp1 &lt;- miceadds::mice.nmi( datlist,  m=4, maxit=3 )
summary(imp1)

#***************
# (2) nested multiple imputation using mice.1chain
imp2 &lt;- miceadds::mice.nmi( datlist, Nimp=4, burnin=10,iter=22, type="mice.1chain")
summary(imp2)

#**************
# extract dataset for third orginal dataset the second within imputation
dat32a &lt;- miceadds::complete.mids.nmi( imp1, action=c(3,2) )
dat32b &lt;- miceadds::complete.mids.nmi( imp2, action=c(3,2) )

#############################################################################
# EXAMPLE 2: Imputation from one chain and extracting dataset for nhanes data
#############################################################################

library(mice)
data(nhanes, package="mice")

# nhanes data in one chain
imp1 &lt;- miceadds::mice.1chain( nhanes, burnin=5, iter=40, Nimp=4,
            method=rep("norm", 4 ) )

# extract first imputed dataset
dati1 &lt;- miceadds::complete.mids.1chain( imp1, action=1 )

## End(Not run)
</code></pre>

<hr>
<h2 id='crlrem'>
<span class="rlang"><b>R</b></span> Utilities: Removing CF Line Endings
</h2><span id='topic+crlrem'></span>

<h3>Description</h3>

<p>This function removes CF line endings from a text file
and writes the processed file in the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crlrem( filename1, filename2 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crlrem_+3A_filename1">filename1</code></td>
<td>

<p>Name of the original file (possibly with CF line endings)
</p>
</td></tr>
<tr><td><code id="crlrem_+3A_filename2">filename2</code></td>
<td>

<p>Name of the processed file (without CF line endings)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This is code by Dirk Eddelbuettel copied from
<a href="https://stat.ethz.ch/pipermail/r-devel/2010-September/058480.html">https://stat.ethz.ch/pipermail/r-devel/2010-September/058480.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
filename1 &lt;- "rm.arraymult__0.02.cpp"
filename2 &lt;- "rm.arraymult__0.03.cpp"
crlrem( filename1, filename2 )
## End(Not run)
</code></pre>

<hr>
<h2 id='cxxfunction.copy'>
<span class="rlang"><b>R</b></span> Utilities: Copy of an <span class="pkg">Rcpp</span> File
</h2><span id='topic+cxxfunction.copy'></span>

<h3>Description</h3>

<p>Copies the <span class="pkg">Rcpp</span> function into the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cxxfunction.copy(cppfct, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cxxfunction.copy_+3A_cppfct">cppfct</code></td>
<td>

<p>Rcpp function
</p>
</td></tr>
<tr><td><code id="cxxfunction.copy_+3A_name">name</code></td>
<td>

<p>Name of the output Rcpp function to be generated
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Eddelbuettel, D. &amp; Francois, R. (2011). <span class="pkg">Rcpp</span>: Seamless <span class="rlang"><b>R</b></span> and <span class="pkg">C++</span> integration.
<em>Journal of Statistical Software, 40</em>(8), 1-18.
<a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>
</p>


<h3>See Also</h3>

<p><code><a href="inline.html#topic+cxxfunction">inline::cxxfunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Rcpp code logistic distribution
#############################################################################

library(Rcpp)
library(inline)

# define Rcpp file
code1 &lt;- "
    // input array A
    Rcpp::NumericMatrix AA(A);
    // Rcpp::IntegerVector dimAA(dimA);
    int nrows=AA.nrow();
    int ncolumns=AA.ncol();
    Rcpp::NumericMatrix Alogis(nrows,ncolumns)  ;
    // compute logistic distribution
    for (int ii=0; ii&lt;nrows; ii++){
        Rcpp::NumericVector h1=AA.row(ii) ;
        Rcpp::NumericVector res=plogis( h1 ) ;
        for (int jj=0;jj&lt;ncolumns;jj++){
            Alogis(ii,jj)=res[jj] ;
                        }
                    }
    return( wrap(Alogis) );
    "
# compile Rcpp code
fct_rcpp &lt;- inline::cxxfunction( signature( A="matrix"), code1,
              plugin="Rcpp", verbose=TRUE )
# copy function and save it as object 'calclogis'
name &lt;- "calclogis"  # name of the function
cxxfunction.copy( cppfct=fct_rcpp, name=name )
# function is available as object named as name
Reval( paste0( name, " &lt;- fct_rcpp " ) )
# test function
m1 &lt;- outer( seq( -2, 2, len=10 ), seq(-1.5,1.5,len=4) )
calclogis(m1)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='data.allison'>
Datasets from Allison's <em>Missing Data</em> Book
</h2><span id='topic+data.allison'></span><span id='topic+data.allison.gssexp'></span><span id='topic+data.allison.hip'></span><span id='topic+data.allison.usnews'></span>

<h3>Description</h3>

<p>Datasets from Allison's missing data book (Allison 2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.allison.gssexp)
data(data.allison.hip)
data(data.allison.usnews)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> Data <code>data.allison.gssexp</code>:
</p>
<p><code>'data.frame':   2991 obs. of  14 variables:</code> <br />
<code> $ AGE     : num  33 59 NA 59 21 22 40 25 41 45 ...</code> <br />
<code> $ EDUC    : num  12 12 12 8 13 15 9 12 12 12 ...</code> <br />
<code> $ FEMALE  : num  1 0 1 0 1 1 1 0 1 1 ...</code> <br />
<code> $ SPANKING: num  1 1 2 2 NA 1 3 1 1 NA ...</code> <br />
<code> $ INCOM   : num  11.2 NA 16.2 18.8 13.8 ...</code> <br />
<code> $ NOCHILD : num  0 0 0 0 1 1 0 0 0 0 ...</code> <br />
<code> $ NODOUBT : num  NA NA NA 1 NA NA 1 NA NA 1 ...</code> <br />
<code> $ NEVMAR  : num  0 0 0 0 1 1 0 1 0 0 ...</code> <br />
<code> $ DIVSEP  : num  1 0 0 0 0 0 0 0 0 1 ...</code> <br />
<code> $ WIDOW   : num  0 0 0 0 0 0 1 0 1 0 ...</code> <br />
<code> $ BLACK   : num  1 1 1 0 1 1 0 1 1 1 ...</code> <br />
<code> $ EAST    : num  1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ MIDWEST : num  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ SOUTH   : num  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
</p>
</li>
<li><p> Data <code>data.allison.hip</code>:
</p>
<p><code>'data.frame':   880 obs. of  7 variables:</code> <br />
<code> $ SID : num  1 1 1 1 2 2 2 2 9 9 ...</code> <br />
<code> $ WAVE: num  1 2 3 4 1 2 3 4 1 2 ...</code> <br />
<code> $ ADL : num  3 2 3 3 3 1 2 1 3 3 ...</code> <br />
<code> $ PAIN: num  0 5 0 0 0 1 5 NA 0 NA ...</code> <br />
<code> $ SRH : num  2 4 2 2 4 1 1 2 2 3 ...</code> <br />
<code> $ WALK: num  1 0 0 0 0 0 0 0 1 NA ...</code> <br />
<code> $ CESD: num  9 28 31 11.6 NA ...</code> <br />
</p>
</li>
<li><p> Data <code>data.allison.usnews</code>:
</p>
<p><code>'data.frame':   1302 obs. of  7 variables:</code> <br />
<code> $ CSAT   : num  972 961 NA 881 NA ...</code> <br />
<code> $ ACT    : num  20 22 NA 20 17 20 21 NA 24 26 ...</code> <br />
<code> $ STUFAC : num  11.9 10 9.5 13.7 14.3 32.8 18.9 18.7 16.7 14 ...</code> <br />
<code> $ GRADRAT: num  15 NA 39 NA 40 55 51 15 69 72 ...</code> <br />
<code> $ RMBRD  : num  4.12 3.59 4.76 5.12 2.55 ...</code> <br />
<code> $ PRIVATE: num  1 0 0 0 0 1 0 0 0 1 ...</code> <br />
<code> $ LENROLL: num  4.01 6.83 4.49 7.06 6.89 ...</code> <br />
</p>
</li></ul>



<h3>Source</h3>

<p>The datasets were downloaded from <em>http://www.ats.ucla.edu/stat/examples/md/</em>.
</p>


<h3>References</h3>

<p>Allison, P. D. (2002). <em>Missing data</em>. Newbury Park, CA: Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Hip dataset | Imputation using a wide format
#############################################################################

# at first, the hip dataset is 'melted' for imputation

data(data.allison.hip)
  ##   head(data.allison.hip)
  ##     SID WAVE ADL PAIN SRH WALK   CESD
  ##   1   1    1   3    0   2    1  9.000
  ##   2   1    2   2    5   4    0 28.000
  ##   3   1    3   3    0   2    0 31.000
  ##   4   1    4   3    0   2    0 11.579
  ##   5   2    1   3    0   4    0     NA
  ##   6   2    2   1    1   1    0  2.222

library(reshape)
hip.wide &lt;- reshape::reshape(data.allison.hip, idvar="SID", timevar="WAVE",
                direction="wide")
  ##   &gt; head(hip.wide, 2)
  ##     SID ADL.1 PAIN.1 SRH.1 WALK.1 CESD.1 ADL.2 PAIN.2 SRH.2 WALK.2 CESD.2 ADL.3
  ##   1   1     3      0     2      1      9     2      5     4      0 28.000     3
  ##   5   2     3      0     4      0     NA     1      1     1      0  2.222     2
  ##     PAIN.3 SRH.3 WALK.3 CESD.3 ADL.4 PAIN.4 SRH.4 WALK.4 CESD.4
  ##   1      0     2      0     31     3      0     2      0 11.579
  ##   5      5     1      0     12     1     NA     2      0     NA

# imputation of the hip wide dataset
imp &lt;- mice::mice( as.matrix( hip.wide[,-1] ), m=5, maxit=3 )
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.enders'>
Datasets from Enders' <em>Missing Data</em> Book
</h2><span id='topic+data.enders'></span><span id='topic+data.enders.depression'></span><span id='topic+data.enders.eatingattitudes'></span><span id='topic+data.enders.employee'></span>

<h3>Description</h3>

<p>Datasets from Enders' missing data book (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.enders.depression)
data(data.enders.eatingattitudes)
data(data.enders.employee)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> Dataset <code>data.enders.depression</code>:
</p>
<p><code>'data.frame':   280 obs. of  8 variables:</code> <br />
<code> $ txgroup: int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ dep1   : int  46 49 40 47 33 44 45 53 40 55 ...</code> <br />
<code> $ dep2   : int  44 42 28 47 33 41 43 35 43 45 ...</code> <br />
<code> $ dep3   : int  26 29 31 NA 34 34 34 35 35 36 ...</code> <br />
<code> $ r2     : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ r3     : int  0 0 0 1 0 0 0 0 0 0 ...</code> <br />
<code> $ pattern: int  3 3 3 2 3 3 3 3 3 3 ...</code> <br />
<code> $ dropout: int  0 0 0 1 0 0 0 0 0 0 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.enders.eatingattitudes</code>:
</p>
<p><code>'data.frame':   400 obs. of  14 variables:</code> <br />
<code> $ id   : num  1 2 3 4 5 6 7 8 9 10 ...</code> <br />
<code> $ eat1 : num  4 6 3 3 3 4 5 4 4 6 ...</code> <br />
<code> $ eat2 : num  4 5 3 3 2 5 4 3 7 5 ...</code> <br />
<code> $ eat10: num  4 6 2 4 3 4 4 4 6 5 ...</code> <br />
<code> $ eat11: num  4 6 2 3 3 5 4 4 5 5 ...</code> <br />
<code> $ eat12: num  4 6 3 4 3 4 4 4 4 6 ...</code> <br />
<code> $ eat14: num  4 7 2 4 3 4 4 4 6 6 ...</code> <br />
<code> $ eat24: num  3 6 3 3 3 4 4 4 4 5 ...</code> <br />
<code> $ eat3 : num  4 5 3 3 4 4 3 6 4 5 ...</code> <br />
<code> $ eat18: num  5 6 3 5 4 5 3 6 4 6 ...</code> <br />
<code> $ eat21: num  4 5 2 4 4 4 3 5 4 5 ...</code> <br />
<code> $ bmi  : num  18.9 26 18.3 18.2 24.4 ...</code> <br />
<code> $ wsb  : num  9 13 6 5 10 7 11 8 10 12 ...</code> <br />
<code> $ anx  : num  11 19 8 14 7 11 12 12 14 12 ..</code> <br />
</p>
</li>
<li><p> Dataset <code>data.enders.employee</code>:
</p>
<p><code>'data.frame':   480 obs. of  9 variables:</code> <br />
<code> $ id      : num  1 2 3 4 5 6 7 8 9 10 ...</code> <br />
<code> $ age     : num  40 53 46 37 44 39 33 43 35 37 ...</code> <br />
<code> $ tenure  : num  10 14 10 8 9 10 7 9 9 10 ...</code> <br />
<code> $ female  : num  1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ wbeing  : num  8 6 NA 7 NA 7 NA 7 7 5 ...</code> <br />
<code> $ jobsat  : num  8 5 7 NA 5 NA 5 NA 7 6 ...</code> <br />
<code> $ jobperf : num  6 5 7 5 5 7 7 7 7 6 ...</code> <br />
<code> $ turnover: num  0 0 0 0 0 0 0 0 1 0 ...</code> <br />
<code> $ iq      : num  106 93 107 94 107 118 103 106 108 97 ...</code> <br />
</p>
</li></ul>



<h3>Source</h3>

<p>The datasets were downloaded from
<a href="https://www.appliedmissingdata.com/">https://www.appliedmissingdata.com/</a>.
</p>


<h3>References</h3>

<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>. Guilford Press.
</p>

<hr>
<h2 id='data.graham'>
Datasets from Grahams <em>Missing Data</em> Book
</h2><span id='topic+data.graham'></span><span id='topic+data.graham.ex3'></span><span id='topic+data.graham.ex6'></span><span id='topic+data.graham.ex8a'></span><span id='topic+data.graham.ex8b'></span><span id='topic+data.graham.ex8c'></span>

<h3>Description</h3>

<p>Datasets from Grahams missing data book (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.graham.ex3)
data(data.graham.ex6)
data(data.graham.ex8a)
data(data.graham.ex8b)
data(data.graham.ex8c)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> Dataset <code>data.graham.ex3</code>:
</p>
<p><code>'data.frame':   2756 obs. of  20 variables:</code> <br />
<code> $ school  : int  1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ alc7    : int  1 1 1 7 3 6 1 5 4 3 ...</code> <br />
<code> $ rskreb71: int  1 3 1 2 1 NA 1 2 1 2 ...</code> <br />
<code> $ rskreb72: int  NA NA NA NA NA NA NA 3 2 3 ...</code> <br />
<code> $ rskreb73: int  NA NA NA NA NA NA NA 2 1 2 ...</code> <br />
<code> $ rskreb74: int  NA NA NA NA NA NA NA 3 2 4 ...</code> <br />
<code> $ likepa71: int  4 2 3 3 2 NA 1 4 3 3 ...</code> <br />
<code> $ likepa72: int  5 2 4 2 2 NA 5 3 3 2 ...</code> <br />
<code> $ likepa73: int  4 1 3 3 2 NA 1 3 2 3 ...</code> <br />
<code> $ likepa74: int  5 3 1 5 4 4 3 4 3 2 ...</code> <br />
<code> $ likepa75: int  4 4 4 4 3 3 4 4 3 3 ...</code> <br />
<code> $ posatt71: int  1 1 1 1 1 2 1 NA NA NA ...</code> <br />
<code> $ posatt72: int  1 2 1 1 1 2 4 NA NA NA ...</code> <br />
<code> $ posatt73: int  1 1 1 1 1 2 1 NA NA NA ...</code> <br />
<code> $ alc8    : int  1 8 4 8 5 7 1 3 5 3 ...</code> <br />
<code> $ rskreb81: int  1 4 1 2 2 3 2 3 1 4 ...</code> <br />
<code> $ rskreb82: int  NA NA NA NA NA NA NA 3 1 4 ...</code> <br />
<code> $ rskreb83: int  NA NA NA NA NA NA NA 2 1 2 ...</code> <br />
<code> $ rskreb84: int  NA NA NA NA NA NA NA 3 2 4 ...</code> <br />
<code> $ alc9    : int  3 NA 7 NA 5 7 NA 6 6 7 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.graham.ex6</code>:
</p>
<p><code>'data.frame':   2756 obs. of  9 variables:</code> <br />
<code> $ school  : int  1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ program : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ alc7    : int  1 1 1 7 3 6 1 5 4 3 ...</code> <br />
<code> $ riskreb7: int  1 3 1 2 1 NA 1 2 1 2 ...</code> <br />
<code> $ likepar7: int  4 2 3 3 2 NA 1 4 3 3 ...</code> <br />
<code> $ posatt7 : int  1 1 1 1 1 2 1 NA NA NA ...</code> <br />
<code> $ alc8    : int  1 8 4 8 5 7 1 3 5 3 ...</code> <br />
<code> $ riskreb8: int  1 4 1 2 2 3 2 3 1 4 ...</code> <br />
<code> $ alc9    : int  3 NA 7 NA 5 7 NA 6 6 7 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.graham.ex8a</code>:
</p>
<p><code>'data.frame':   1023 obs. of  20 variables:</code> <br />
<code> $ skill1 : int  28 29 27 29 29 NA NA NA 29 NA ...</code> <br />
<code> $ skill2 : int  NA NA 29 29 NA NA NA NA NA 21 ...</code> <br />
<code> $ skill3 : int  NA NA 29 29 29 NA 28 10 29 25 ...</code> <br />
<code> $ skill4 : int  NA 29 25 29 29 28 29 NA NA NA ...</code> <br />
<code> $ skill5 : int  29 29 28 28 29 NA 29 10 NA 25 ...</code> <br />
<code> $ iplanV1: int  14 18 15 17 16 NA NA NA 18 NA ...</code> <br />
<code> $ iplanV2: int  NA NA 17 16 NA NA NA NA NA 16 ...</code> <br />
<code> $ iplanV3: int  NA NA 16 18 18 NA 17 1 18 16 ...</code> <br />
<code> $ iplanV4: int  NA 18 14 18 14 6 18 NA NA NA ...</code> <br />
<code> $ iplanV5: int  13 18 12 18 18 NA 18 3 NA 5 ...</code> <br />
<code> $ planA1 : int  1 0 2 8 3 NA NA NA 7 NA ...</code> <br />
<code> $ planA2 : int  NA NA 0 4 NA NA NA NA NA 6 ...</code> <br />
<code> $ planA3 : int  NA NA 1 4 7 NA 2 0 1 7 ...</code> <br />
<code> $ planA4 : int  NA 8 0 4 6 0 0 NA NA NA ...</code> <br />
<code> $ planA5 : int  0 7 1 5 7 NA 2 0 NA 6 ...</code> <br />
<code> $ planV1 : int  NA NA NA NA NA NA NA NA NA NA ...</code> <br />
<code> $ planV2 : int  NA NA NA NA NA NA NA NA NA 1 ...</code> <br />
<code> $ planV3 : int  NA NA 1 NA NA NA NA 0 NA 1 ...</code> <br />
<code> $ planV4 : int  NA NA NA NA 2 NA NA NA NA NA ...</code> <br />
<code> $ planV5 : int  2 NA 2 NA NA NA NA 0 NA NA ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.graham.ex8b</code>:
</p>
<p><code>'data.frame':   2570 obs. of  6 variables:</code> <br />
<code> $ rskreb71: int  1 3 1 2 1 NA 1 2 1 2 ...</code> <br />
<code> $ rskreb72: int  NA NA NA NA NA NA NA 3 2 3 ...</code> <br />
<code> $ posatt71: int  1 1 1 1 1 2 1 NA NA NA ...</code> <br />
<code> $ posatt72: int  1 2 1 1 1 2 4 NA NA NA ...</code> <br />
<code> $ posatt73: int  1 1 1 1 1 2 1 NA NA NA ...</code> <br />
<code> $ posatt  : int  3 4 3 3 3 6 6 NA NA NA ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.graham.ex8c</code>:
</p>
<p><code>'data.frame':   2756 obs. of  16 variables:</code> <br />
<code> $ s1      : int  1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ s2      : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s3      : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s4      : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s5      : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s6      : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s7      : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s8      : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s9      : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s10     : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ s11     : int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ xalc7   : int  1 1 1 7 3 6 1 5 4 3 ...</code> <br />
<code> $ rskreb72: int  NA NA NA NA NA NA NA 3 2 3 ...</code> <br />
<code> $ likepa71: int  4 2 3 3 2 NA 1 4 3 3 ...</code> <br />
<code> $ posatt71: int  1 1 1 1 1 2 1 NA NA NA ...</code> <br />
<code> $ alc8    : int  1 8 4 8 5 7 1 3 5 3 ...</code> <br />
</p>
</li></ul>



<h3>Source</h3>

<p>The datasets were downloaded from
http://methodology.psu.edu/pubs/books/missing.
</p>


<h3>References</h3>

<p>Graham, J. W. (2012). <em>Missing data</em>. New York: Springer.
<a href="https://doi.org/10.1007/978-1-4614-4018-5">doi:10.1007/978-1-4614-4018-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mitools)
library(mice)
library(Amelia)
library(jomo)

#############################################################################
# EXAMPLE 1: data.graham.8a | Imputation under multivariate normal model
#############################################################################

data(data.graham.ex8a)
dat &lt;- data.graham.ex8a
dat &lt;- dat[,1:10]
vars &lt;- colnames(dat)
V &lt;- length(vars)
# remove persons with completely missing data
dat &lt;- dat[ rowMeans( is.na(dat) ) &lt; 1, ]
summary(dat)

# some descriptive statistics
psych::describe(dat)

#**************
# imputation under a multivariate normal model
M &lt;- 7  # number of imputations

#--------- mice package
# define imputation method
impM &lt;- rep("norm", V)
names(impM) &lt;- vars
# mice imputation
imp1a &lt;- mice::mice( dat, method=impM, m=M, maxit=4 )
summary(imp1a)
# convert into a list of datasets
datlist1a &lt;- miceadds::mids2datlist(imp1a)

#--------- Amelia package
imp1b &lt;- Amelia::amelia( dat, m=M )
summary(imp1b)
datlist1b &lt;- imp1b$imputations

#--------- jomo package
imp1c &lt;- jomo::jomo1con(Y=dat, nburn=100, nbetween=10, nimp=M)
str(imp1c)
# convert into a list of datasets
datlist1c &lt;- miceadds::jomo2datlist(imp1c)

# alternatively one can use the jomo wrapper function
imp1c1 &lt;- jomo::jomo(Y=dat, nburn=100, nbetween=10, nimp=M)

#############################################################################
# EXAMPLE 2: data.graham.8b | Imputation with categorical variables
#############################################################################

data(data.graham.ex8b)
dat &lt;- data.graham.ex8b
vars &lt;- colnames(dat)
V &lt;- length(vars)

# descriptive statistics
psych::describe(dat)

#*******************************
# imputation in mice using predictive mean matching
imp1a &lt;- mice::mice( dat, m=5, maxit=10)
datlist1a &lt;- mitools::imputationList( miceadds::mids2datlist(imp1a) )
print(datlist1a)

#*******************************
# imputation in jomo treating all variables as categorical

# Note that variables must have values from 1 to N
# use categorize function from sirt package here
dat.categ &lt;- sirt::categorize( dat, categorical=colnames(dat), lowest=1 )
dat0 &lt;- dat.categ$data

# imputation in jomo treating all variables as categorical
Y_numcat &lt;- apply( dat0, 2, max, na.rm=TRUE )
imp1b &lt;- jomo::jomo1cat(Y.cat=dat0, Y.numcat=Y_numcat, nburn=100,
                 nbetween=10, nimp=5)

# recode original categories
datlist1b &lt;- sirt::decategorize( imp1b, categ_design=dat.categ$categ_design )
# convert into a list of datasets
datlist1b &lt;- miceadds::jomo2datlist(datlist1b)
datlist1b &lt;- mitools::imputationList( datlist1b )

# Alternatively, jomo can be used but categorical variables must be
# declared as factors
dat &lt;- dat0
# define two variables as factors
vars &lt;- miceadds::scan.vec(" rskreb71 rskreb72")
for (vv in vars){
    dat[, vv] &lt;- as.factor( dat[,vv] )
          }
# use jomo
imp1b1 &lt;- jomo::jomo(Y=dat, nburn=30, nbetween=10, nimp=5)

#****************************
# compare frequency tables for both imputation packages
fun_prop &lt;- function( variable ){
            t1 &lt;- table(variable)
            t1 / sum(t1)
                }

# variable rskreb71
res1a &lt;-  with( datlist1a, fun_prop(rskreb71) )
res1b &lt;-  with( datlist1b, fun_prop(rskreb71) )
summary( miceadds::NMIcombine(qhat=res1a, NMI=FALSE ) )
summary( miceadds::NMIcombine(qhat=res1b, NMI=FALSE ) )

# variable posatt
res2a &lt;-  with( datlist1a, fun_prop(posatt) )
res2b &lt;-  with( datlist1b, fun_prop(posatt) )
summary( miceadds::NMIcombine(qhat=res2a, NMI=FALSE ) )
summary( miceadds::NMIcombine(qhat=res2b, NMI=FALSE ) )

## End(Not run)
</code></pre>

<hr>
<h2 id='data.internet'>
Dataset Internet
</h2><span id='topic+data.internet'></span>

<h3>Description</h3>

<p>Dataset with items corresponding to internet attitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.internet)
</code></pre>


<h3>Format</h3>

<p>A data frame with 281 observations on the following 22 variables.
</p>
<p>The format of the dataset is
</p>
<p><code>'data.frame':   281 obs. of  22 variables:</code> <br />
<code> $ IN1 : num  1 5 2 3 1 3 2 3 2 1 ...</code> <br />
<code> $ IN2 : num  4 3 2 7 7 4 4 7 4 3 ...</code> <br />
<code> $ IN3 : num  4 5 4 2 1 2 5 2 2 4 ...</code> <br />
<code> [...]</code> <br />
<code> $ IN20: num  3 2 2 3 3 4 2 7 2 2 ...</code> <br />
<code> $ IN21: num  3 3 6 5 4 4 5 5 6 5 ...</code> <br />
<code> $ IN22: num  3 4 2 5 3 5 3 7 3 5 ...</code> <br />
</p>


<h3>Details</h3>

<p>The following text is copied from
<em>http://people.few.eur.nl/groenen/Data/index.htm</em>
</p>
<p>The data set is based on a questionnaire on attitudes towards the Internet. It
consists of evaluations of 22 statements about the Internet by 281 students at
Erasmus University Rotterdam. These data were gathered around 2002
before the wide availability of broadband Internet access in the Netherlands.
The statements were evaluated using a seven-point Likert scale, ranging
from 1 (completely disagree) to 7 (completely agree).
</p>
<p>We would like to thank Peter Verhoef for making these data available.
</p>
<p>Each variable (statement) is coded as follows:
</p>
<p>1. Completely disagree <br />
2. Disagree <br />
3. Slightly disagree <br />
4. Neutral <br />
5. Slightly agree <br />
6. Agree <br />
7. Completely agree <br />
</p>
<p>Internet items:
</p>
<p>1. Paying using Internet is safe<br />
2. Surfing the Internet is easy<br />
3. Internet is unreliable<br />
4. Internet is slow<br />
5. Internet is user-friendly<br />
6. Internet is the future's means of communication<br />
7. Internet is addictive<br />
8. Internet is fast<br />
9. Sending personal data using the Internet is unsafe<br />
10. The prices of Internet subscriptions are high<br />
11. Internet offers many possibilities for abuse<br />
12. The costs of surfing are high<br />
13. Internet offers unbounded opportunities<br />
14. Internet phone costs are high<br />
15. The content of web sites should be regulated<br />
16. Internet is easy to use<br />
17. I like surfing<br />
18. I often speak with friends about the Internet<br />
19. I like to be informed of important new things<br />
20. I always attempt new things on the Internet first<br />
21. I regularly visit websites recommended by others<br />
22. I know much about the Internet<br />
</p>


<h3>Source</h3>

<p>Peter Verhoef
</p>
<p><em>http://people.few.eur.nl/groenen/Data/index.htm</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data.internet)
# missing proportions
colMeans( is.na(data.internet) )
</code></pre>

<hr>
<h2 id='data.largescale'>
Large-scale Dataset for Testing Purposes (Many Cases, Few Variables)
</h2><span id='topic+data.largescale'></span>

<h3>Description</h3>

<p>Large-scale dataset with many cases and few variables
included for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.largescale)
</code></pre>


<h3>Format</h3>

<p>A data frame with 14000 observations on the following 13 variables.
The format is
</p>
<p><code>'data.frame':   14000 obs. of  13 variables:</code> <br />
<code> $ id: num  1e+07 1e+07 1e+07 1e+07 1e+07 ...</code> <br />
<code> $ D1: num  0 0 0 0 1 0 0 0 0 0 ...</code> <br />
<code> $ D2: num  0 0 0 1 0 1 0 1 0 0 ...</code> <br />
<code> $ D3: num  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ D4: num  0 0 0 1 0 0 0 1 0 0 ...</code> <br />
<code> $ D5: num  0 0 0 0 0 1 0 0 0 0 ...</code> <br />
<code> $ v1: num  118 117 94 106 86 117 96 96 82 95 ...</code> <br />
<code> $ v2: num  101 101 86 101 65 94 72 75 70 99 ...</code> <br />
<code> $ v3: num  0 0 0 0 0 1 0 0 0 0 ...</code> <br />
<code> $ v4: num  3 NA 3 5 2 5 5 5 4 2 ...</code> <br />
<code> $ v5: num  0 NA 0 0 0 1 0 0 0 0 ...</code> <br />
<code> $ v6: num  3 3 3 4 NA 1 3 3 2 3 ...</code> <br />
<code> $ v7: num  51 36 14 47 22 17 13 37 47 38 ...</code> <br />
</p>

<hr>
<h2 id='data.ma'>
Example Datasets for <span class="pkg">miceadds</span> Package
</h2><span id='topic+data.ma'></span><span id='topic+data.ma01'></span><span id='topic+data.ma02'></span><span id='topic+data.ma03'></span><span id='topic+data.ma04'></span><span id='topic+data.ma05'></span><span id='topic+data.ma06'></span><span id='topic+data.ma07'></span><span id='topic+data.ma08'></span><span id='topic+data.ma09'></span>

<h3>Description</h3>

<p>Example datasets for <span class="pkg">miceadds</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.ma01)
data(data.ma02)
data(data.ma03)
data(data.ma04)
data(data.ma05)
data(data.ma06)
data(data.ma07)
data(data.ma08)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> Dataset <code>data.ma01</code>:
</p>
<p>Dataset with students nested within school and
student weights (<code>studwgt</code>). The format is
</p>
<p><code>'data.frame':   4073 obs. of  11 variables:</code> <br />
<code> $ idstud  : num  1e+07 1e+07 1e+07 1e+07 1e+07 ...</code> <br />
<code> $ idschool: num  1001 1001 1001 1001 1001 ...</code> <br />
<code> $ studwgt : num  6.05 6.05 5.27 5.27 6.05 ...</code> <br />
<code> $ math    : int  594 605 616 524 685 387 536 594 387 562 ...</code> <br />
<code> $ read    : int  647 651 539 551 689 502 503 597 580 576 ...</code> <br />
<code> $ migrant : int  0 0 0 1 0 0 1 0 0 0 ...</code> <br />
<code> $ books   : int  6 6 5 2 6 3 4 6 6 5 ...</code> <br />
<code> $ hisei   : int  NA 77 69 45 66 53 43 NA 64 50 ...</code> <br />
<code> $ paredu  : int  3 7 7 2 7 3 4 NA 7 3 ...</code> <br />
<code> $ female  : int  1 1 0 0 1 1 0 0 1 1 ...</code> <br />
<code> $ urban   : num  1 1 1 1 1 1 1 1 1 1 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.ma02</code>:
</p>
<p>10 multiply imputed datasets of incomplete data <code>data.ma01</code>.
The format is
</p>
<p><code>List of 10</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
<code> $ :'data.frame':       4073 obs. of  11 variables:</code> <br />
</p>
</li>
<li><p> Dataset <code>data.ma03</code>:
</p>
<p>This dataset contains one variable
<code>math_EAP</code> for which a conditional posterior distribution with EAP
and its associated standard deviation is available.
</p>
<p><code>'data.frame':   120 obs. of  8 variables:</code> <br />
<code> $ idstud    : int  1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 ...</code> <br />
<code> $ female    : int  0 1 1 1 1 0 1 1 1 1 ...</code> <br />
<code> $ migrant   : int  1 1 0 1 1 0 0 0 1 0 ...</code> <br />
<code> $ hisei     : int  44 NA 26 NA 32 60 31 NA 34 26 ...</code> <br />
<code> $ educ      : int  NA 2 NA 1 4 NA 2 NA 2 NA ...</code> <br />
<code> $ read_wle  : num  74.8 78.1 103.2 81.2 119.2 ...</code> <br />
<code> $ math_EAP  : num  337 342 264 285 420 ...</code> <br />
<code> $ math_SEEAP: num  28 29.5 28.6 28.5 27.5 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.ma04</code>:
</p>
<p>This dataset contains two hypothetical
scales <code>A</code> and <code>B</code> and single variables <code>V5</code>, <code>V6</code> and
<code>V7</code>.
</p>
<p><code>'data.frame':   281 obs. of  13 variables:</code> <br />
<code> $ group: int  1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ A1   : int  2 2 2 1 1 3 3 NA 2 1 ...</code> <br />
<code> $ A2   : int  2 2 2 3 1 2 4 4 4 4 ...</code> <br />
<code> $ A3   : int  2 3 3 4 1 3 2 2 2 4 ...</code> <br />
<code> $ A4   : int  3 4 6 4 7 5 3 5 5 1 ...</code> <br />
<code> $ V5   : int  2 2 5 5 4 3 4 1 3 4 ...</code> <br />
<code> $ V6   : int  2 5 5 1 1 3 2 2 2 4 ...</code> <br />
<code> $ V7   : int  6 NA 4 5 6 2 5 5 6 7 ...</code> <br />
<code> $ B1   : int  7 NA 6 4 5 2 5 7 3 7 ...</code> <br />
<code> $ B2   : int  6 NA NA 6 3 3 4 6 6 7 ...</code> <br />
<code> $ B3   : int  7 NA 7 4 3 4 3 7 5 NA ...</code> <br />
<code> $ B4   : int  4 5 6 5 4 3 4 5 2 1 ...</code> <br />
<code> $ B5   : int  7 NA 7 4 4 3 5 7 5 4 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.ma05</code>:
</p>
<p>This is a two-level dataset with students nested within classes. Variables
at the student level are <code>Dscore</code>, <code>Mscore</code>, <code>denote</code>,
<code>manote</code>, <code>misei</code> and <code>migrant</code>. Variables at the class
level are <code>sprengel</code> and <code>groesse</code>.
</p>
<p><code>'data.frame':   1673 obs. of  10 variables:</code> <br />
<code> $ idstud  : int  100110001 100110002 100110003 100110004 100110005  ...</code> <br />
<code> $ idclass : int  1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 ...</code> <br />
<code> $ Dscore  : int  NA 558 643 611 518 552 NA 534 409 543 ...</code> <br />
<code> $ Mscore  : int  404 563 569 621 653 651 510 NA 517 566 ...</code> <br />
<code> $ denote  : int  NA 1 1 1 3 2 3 2 3 2 ...</code> <br />
<code> $ manote  : int  NA 1 1 1 1 1 2 2 2 1 ...</code> <br />
<code> $ misei   : int  NA 51 NA 38 NA 50 53 53 38 NA ...</code> <br />
<code> $ migrant : int  NA 0 0 NA 0 0 0 0 0 NA ...</code> <br />
<code> $ sprengel: int  0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ groesse : int  25 25 25 25 25 25 25 25 25 25 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.ma06</code>:
</p>
<p>This is a dataset in which the variable <code>FC</code> is only available
with grouped values (coarse data or interval data).
</p>
<p><code>'data.frame':   198 obs. of  7 variables:</code> <br />
<code> $ id    : num  1001 1002 1003 1004 1005 ...</code> <br />
<code> $ A1    : int  14 7 10 15 0 5 9 6 8 0 ...</code> <br />
<code> $ A2    : int  5 6 4 8 2 5 4 0 7 0 ...</code> <br />
<code> $ Edu   : int  4 3 1 5 5 1 NA 1 5 3 ...</code> <br />
<code> $ FC    : int  3 2 2 2 2 NA NA 2 2 NA ...</code> <br />
<code> $ FC_low: num  10 5 5 5 5 0 0 5 5 0 ...</code> <br />
<code> $ FC_upp: num  15 10 10 10 10 100 100 10 10 100 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.ma07</code>:
</p>
<p>This is a three-level dataset in which the variable <code>FC</code> is only available
with grouped values (coarse data or interval data).
</p>
<p><code>'data.frame':   1600 obs. of  9 variables:</code> <br />
<code> $ id3: num  1001 1001 1001 1001 1001 ...</code> <br />
<code> $ id2: num  101 101 101 101 101 101 101 101 101 101 ...</code> <br />
<code> $ id1: int  1 2 3 4 5 6 7 8 9 10 ...</code> <br />
<code> $ x1 : num  0.91 1.88 NA 1.52 0.93 0.51 2.11 0.99 2.42 NA ...</code> <br />
<code> $ x2 : num  -0.58 1.12 0.87 -0.01 -0.14 0.48 1.85 -0.9 0.93 0.63 ...</code> <br />
<code> $ y1 : num  1.66 1.66 1.66 1.66 1.66 1.66 1.66 1.66 1.66 1.66 ...</code> <br />
<code> $ y2 : num  0.96 0.96 0.96 0.96 0.96 0.96 0.96 0.96 0.96 0.96 ...</code> <br />
<code> $ z1 : num  -0.53 -0.53 -0.53 -0.53 -0.53 -0.53 -0.53 -0.53 -0.53 -0.53 ...</code> <br />
<code> $ z2 : num  0.42 0.42 0.42 0.42 0.42 0.42 0.42 0.42 0.42 0.42 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.ma08</code>:
</p>
<p>List with several vector of strings containing descriptive data from
published articles. See <code><a href="#topic+string_to_matrix">string_to_matrix</a></code> for converting
these strings into matrices.
</p>
<p><code>List of 4</code> <br />
<code> $ mat1: chr [1:6] "1. T1_mental_health" ...</code> <br />
<code> $ mat2: chr [1:16] "1. Exp voc-T1 -" ...</code> <br />
<code> $ mat3: chr [1:12] "1. TOWRE age 7\t-\t\t\t\t\t\t" ...</code> <br />
<code> $ mat4: chr [1:18] "1. Vocab. age 7\t-\t\t\t\t\t" ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.ma09</code>:
</p>
<p>This is a subset of a PISA dataset that is used for generating synthetic data.
</p>
<p><code>'data.frame':   342 obs. of  41 variables:</code> <br />
<code> $ SEX    : int  1 2 1 2 1 2 2 2 2 1 ...</code> <br />
<code> $ AGE    : num  16 15.9 16.3 15.5 15.9 ...</code> <br />
<code> $ HISEI  : int  37 46 66 51 25 NA 54 52 51 69 ...</code> <br />
<code> $ FISCED : int  3 3 6 3 3 NA 3 3 2 2 ...</code> <br />
<code> $ MISCED : int  3 4 4 4 3 NA 4 3 4 4 ...</code> <br />
<code> $ PV1MATH: num  643 556 510 604 462 ...</code> <br />
<code> $ M474Q01: int  1 1 1 1 0 1 1 1 1 0 ...</code> <br />
<code> $ M155Q02: int  2 2 2 2 2 0 0 2 2 2 ...</code> <br />
<code> $ M155Q01: int  1 1 0 1 1 1 1 1 1 1 ...</code> <br />
<code>[...]</code> <br />
</p>
</li></ul>


<hr>
<h2 id='data.smallscale'>
Small-Scale Dataset for Testing Purposes (Moderate Number of Cases,
Many Variables)
</h2><span id='topic+data.smallscale'></span>

<h3>Description</h3>

<p>Small-scale dataset for testing purposes (moderate number of cases,
many variables)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.smallscale)
</code></pre>


<h3>Format</h3>

<p>A data frame with 675 observations on the following 164 variables.
The format is
</p>
<p><code>'data.frame':   675 obs. of  164 variables:</code> <br />
<code> $ v1  : num  3 3 2 3 3 0 1 0 3 NA ...</code> <br />
<code> $ v2  : num  3 0 1 3 0 0 0 3 2 NA ...</code> <br />
<code> $ v3  : num  0 0 2 3 2 0 1 0 0 NA ...</code> <br />
<code> $ v4  : num  1 3 3 3 NA 0 0 0 3 NA ...</code> <br />
<code> $ v5  : num  0 0 3 3 0 0 3 1 3 3 ...</code> <br />
<code> $ v6  : num  8 8 9 8 9 9 9 8 9 9 ...</code> <br />
<code>[...]</code> <br />
</p>

<hr>
<h2 id='datlist_create'>
Creates Objects of Class <code>datlist</code> or <code>nested.datlist</code>
</h2><span id='topic+datlist_create'></span><span id='topic+nested.datlist_create'></span><span id='topic+print.datlist'></span><span id='topic+print.nested.datlist'></span><span id='topic+nested.datlist2datlist'></span><span id='topic+datlist2nested.datlist'></span>

<h3>Description</h3>

<p>Creates objects of class <code>datlist</code> or <code>nested.datlist</code>.
</p>
<p>The functions <code>nested.datlist2datlist</code> and
<code>datlist2nested.datlist</code> provide list conversions for imputed
datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datlist_create(datasets)

nested.datlist_create(datasets)

## S3 method for class 'datlist'
print(x, ...)

## S3 method for class 'nested.datlist'
print(x, ...)

nested.datlist2datlist(datlist)

datlist2nested.datlist(datlist, Nimp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datlist_create_+3A_datasets">datasets</code></td>
<td>

<p>For <code>datlist_create</code>: List of datasets, objects of class
<code>imputationList</code>, <code>mids</code>, <code>mids.1chain</code>,
</p>
<p>For <code>nested.datlist_create</code>: nested list of datasets,
<code>NestedImputationList</code>, <code>mids.nmi</code>
</p>
</td></tr>
<tr><td><code id="datlist_create_+3A_x">x</code></td>
<td>
<p>Object of classes <code>datlist</code> or
<code>nested.datlist</code>
</p>
</td></tr>
<tr><td><code id="datlist_create_+3A_datlist">datlist</code></td>
<td>
<p>Object of classes <code>datlist</code>, <code>imputationList</code>,
<code>nested.datlist</code> or <code>NestedImputationList</code>.
</p>
</td></tr>
<tr><td><code id="datlist_create_+3A_nimp">Nimp</code></td>
<td>
<p>Vector of length 2 containing numbers of between
and within imputations.</p>
</td></tr>
<tr><td><code id="datlist_create_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>datlist</code> or <code>nested.datlist</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## The function datlist_create is currently defined as
function (datasets)
{
    class(datasets) &lt;- "datlist"
    return(datasets)
  }

#############################################################################
# EXAMPLE 1: Create object of class datlist
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2

# class datlist
obj1 &lt;- miceadds::datlist_create(data.timss2)

#############################################################################
# EXAMPLE 2: Multiply imputed datasets: Different object classes
#############################################################################

library(mice)
data(nhanes2, package="mice")
set.seed(990)

# nhanes2 data imputation
imp1 &lt;- miceadds::mice.1chain( nhanes2, burnin=5, iter=25, Nimp=5 )
# object of class datlist
imp2 &lt;- miceadds::mids2datlist(imp1)
# alternatively, one can use datlist_create
imp2b &lt;- miceadds::datlist_create(imp1)
# object of class imputationList
imp3 &lt;- mitools::imputationList(imp2)
# retransform object in class datlist
imp2c &lt;- miceadds::datlist_create(imp3)
str(imp2c)

#############################################################################
# EXAMPLE 3: Nested multiply imputed datasets
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2
   # list of 5 datasets containing 5 plausible values

#** define imputation method and predictor matrix
data &lt;- datlist[[1]]
V &lt;- ncol(data)
# variables
vars &lt;- colnames(data)
# variables not used for imputation
vars_unused &lt;- miceadds::scan.vec("IDSTUD TOTWGT  JKZONE  JKREP" )

#- define imputation method
impMethod &lt;- rep("norm", V )
names(impMethod) &lt;- vars
impMethod[ vars_unused ] &lt;- ""

#- define predictor matrix
predM &lt;- matrix( 1, V, V )
colnames(predM) &lt;- rownames(predM) &lt;- vars
diag(predM) &lt;- 0
predM[, vars_unused ] &lt;- 0

# object of class nmi
imp1 &lt;- miceadds::mice.nmi( datlist, method=impMethod, predictorMatrix=predM,
                m=4, maxit=3 )
# object of class nested.datlist
imp2 &lt;- miceadds::mids2datlist(imp1)
# object of class NestedImputationList
imp3 &lt;- miceadds::NestedImputationList(imp2)
# redefine class nested.datlist
imp4 &lt;- miceadds::nested.datlist_create(imp3)

#############################################################################
# EXAMPLE 4: Conversions between nested lists of datasets and lists of datasets
#############################################################################

library(BIFIEsurvey)
data(data.timss4, package="BIFIEsurvey" )
datlist &lt;- data.timss4

# object of class nested.datlist
datlist1a &lt;- miceadds::nested.datlist_create(datlist)
# object of class NestedImputationList
datlist1b &lt;- miceadds::NestedImputationList(datlist)

# conversion to datlist
datlist2a &lt;- miceadds::nested.datlist2datlist(datlist1a)  # class datlist
datlist2b &lt;- miceadds::nested.datlist2datlist(datlist1b)  # class imputationList

# convert into a nested list with 2 between nests and 10 within nests
datlist3a &lt;- miceadds::datlist2nested.datlist(datlist2a, Nimp=c(2,10) )
datlist3b &lt;- miceadds::datlist2nested.datlist(datlist2b, Nimp=c(4,5) )

## End(Not run)
</code></pre>

<hr>
<h2 id='datlist2Amelia'>
Converting an Object of class <code>amelia</code>
</h2><span id='topic+datlist2Amelia'></span>

<h3>Description</h3>

<p>This function converts a list of multiply imputed data sets
to an object of class <code>amelia</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datlist2Amelia(datlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datlist2Amelia_+3A_datlist">datlist</code></td>
<td>

<p>List of multiply imputed data sets or an object of class <code>mids</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>amelia</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation of NHANES data using mice package
#############################################################################

library(mice)
library(Amelia)

data(nhanes,package="mice")
set.seed(566)  # fix random seed

# imputation with mice
imp &lt;- mice::mice(nhanes, m=7)

# conversion to amelia object
amp &lt;- miceadds::datlist2Amelia(datlist=imp)
str(amp)
plot(amp)
print(amp)
summary(amp)

## End(Not run)
</code></pre>

<hr>
<h2 id='datlist2mids'>
Converting a List of Multiply Imputed Data Sets into a <code>mids</code> Object
</h2><span id='topic+datalist2mids'></span><span id='topic+datlist2mids'></span>

<h3>Description</h3>

<p>This function converts a list of multiply imputed data sets
to a <code><a href="mice.html#topic+mids">mice::mids</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datlist2mids(dat.list, progress=FALSE)
datalist2mids(dat.list, progress=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datlist2mids_+3A_dat.list">dat.list</code></td>
<td>

<p>List of multiply imputed data sets or an object of class
<code>imputationList</code> (see
<code><a href="mitools.html#topic+imputationList">mitools::imputationList</a></code>
)
</p>
</td></tr>
<tr><td><code id="datlist2mids_+3A_progress">progress</code></td>
<td>

<p>An optional logical indicating whether conversion process be displayed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mids</code>
</p>


<h3>See Also</h3>

<p>See <code><a href="mice.html#topic+as.mids">mice::as.mids</a></code> for converting
a multiply imputed dataset in long format into a <code>mids</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation of NHANES data using Amelia package
#############################################################################

library(mice)
library(Amelia)

data(nhanes,package="mice")
set.seed(566)  # fix random seed

# impute 10 datasets using Amelia
a.out &lt;- Amelia::amelia(x=nhanes, m=10)
# plot of observed and imputed data
plot(a.out)

# convert list of multiply imputed datasets into a mids object
a.mids &lt;- miceadds::datlist2mids( a.out$imputations )

# linear regression: apply mice functionality lm.mids
mod &lt;- with( a.mids, stats::lm( bmi ~ age ) )
summary( mice::pool( mod ) )
  ##                    est       se         t       df     Pr(&gt;|t|)     lo 95
  ##  (Intercept) 30.624652 2.626886 11.658158 8.406608 1.767631e-06 24.617664
  ##  age         -2.280607 1.323355 -1.723352 8.917910 1.192288e-01 -5.278451
  ##                   hi 95 nmis       fmi    lambda
  ##  (Intercept) 36.6316392   NA 0.5791956 0.4897257
  ##  age          0.7172368    0 0.5549945 0.4652567

# fit linear regression model in Zelig
library(Zelig)
mod2 &lt;- Zelig::zelig( bmi ~ age, model="ls", data=a.out, cite=FALSE)
summary(mod2)
  ##  Model: Combined Imputations
  ##              Estimate Std.Error z value Pr(&gt;|z|)
  ##  (Intercept)   30.625     2.627  11.658  0.00000 ***
  ##  age           -2.281     1.323  -1.723  0.08482
  ##  ---
  ##  Signif. codes:  '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

# fit linear regression using mitools package
library(mitools)
datimp &lt;- mitools::imputationList(a.out$imputations)
mod3 &lt;- with( datimp, stats::lm( bmi ~ age ) )
summary( mitools::MIcombine( mod3 ) )
  ##  Multiple imputation results:
  ##        with(datimp, stats::lm(bmi ~ age))
  ##        MIcombine.default(mod3)
  ##                results       se    (lower     upper) missInfo
  ##  (Intercept) 30.624652 2.626886 25.304594 35.9447092     51 
  ##  age         -2.280607 1.323355 -4.952051  0.3908368     49 

## End(Not run)
</code></pre>

<hr>
<h2 id='draw.pv.ctt'>
Plausible Value Imputation Using a Known Measurement Error Variance
(Based on Classical Test Theory)
</h2><span id='topic+draw.pv.ctt'></span>

<h3>Description</h3>

<p>This function provides unidimensional plausible value imputation with a
known measurement error variance or classical test theory (Mislevy, 1991).
The reliability of the scale is estimated by Cronbach's Alpha or can be
provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.pv.ctt(y, dat.scale=NULL, x=NULL, samp.pars=TRUE,
      alpha=NULL, sig.e=NULL, var.e=NULL, true.var=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.pv.ctt_+3A_y">y</code></td>
<td>

<p>Vector of scale scores if <code>y</code> should not be used.
</p>
</td></tr>
<tr><td><code id="draw.pv.ctt_+3A_dat.scale">dat.scale</code></td>
<td>

<p>Matrix of item responses
</p>
</td></tr>
<tr><td><code id="draw.pv.ctt_+3A_x">x</code></td>
<td>

<p>Matrix of covariates
</p>
</td></tr>
<tr><td><code id="draw.pv.ctt_+3A_samp.pars">samp.pars</code></td>
<td>

<p>An optional logical indicating whether scale parameters
(reliability or measurement error standard deviation) should be sampled
</p>
</td></tr>
<tr><td><code id="draw.pv.ctt_+3A_alpha">alpha</code></td>
<td>

<p>Reliability estimate of the scale. The default of
<code>NULL</code> means that Cronbach's alpha will be used
as a reliability estimate.
</p>
</td></tr>
<tr><td><code id="draw.pv.ctt_+3A_sig.e">sig.e</code></td>
<td>

<p>Optional vector of the standard deviation of the error.
Note that it is <em>not</em> the error variance.
</p>
</td></tr>
<tr><td><code id="draw.pv.ctt_+3A_var.e">var.e</code></td>
<td>

<p>Optional vector of the variance of the error.
</p>
</td></tr>
<tr><td><code id="draw.pv.ctt_+3A_true.var">true.var</code></td>
<td>

<p>True score variance
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear model is assumed for drawing plausible values of a variable
<code class="reqn">Y</code> contaminated by measurement error. Assuming <code class="reqn">Y=\theta + e</code>
and a linear regression model for <code class="reqn">\theta</code>
</p>
<p style="text-align: center;"><code class="reqn"> \theta=\bold{X} \beta + \epsilon</code>
</p>

<p>(plausible value) imputations from the posterior distribution
<code class="reqn">P( \theta | Y, \bold{X} )</code> are drawn. See Mislevy (1991) for details.
</p>


<h3>Value</h3>

<p>A vector with plausible values
</p>


<h3>Note</h3>

<p>Plausible value imputation is also labeled as multiple overimputation
(Blackwell, Honaker &amp; King, 2011).
</p>


<h3>References</h3>

<p>Blackwell, M., Honaker, J., &amp; King, G. (2011).
<em>Multiple overimputation: A unified approach to measurement error and
missing data</em>. Technical Report.
</p>
<p>Mislevy, R. J. (1991). Randomization-based inference about latent variables
from complex samples. <em>Psychometrika, 56</em>(2), 177-196.
<a href="https://doi.org/10.1007/BF02294457">doi:10.1007/BF02294457</a>
</p>


<h3>See Also</h3>

<p>See also
<code><a href="sirt.html#topic+plausible.value.imputation.raschtype">sirt::plausible.value.imputation.raschtype</a></code>
for plausible value imputation.
</p>
<p>Plausible value imputations can be conducted in <span class="pkg">mice</span> using the
imputation method <code><a href="#topic+mice.impute.plausible.values">mice.impute.plausible.values</a></code>.
</p>
<p>Plausible values can be drawn in <span class="pkg">Amelia</span> by specifying observation-level
priors, see <code>Amelia::moPrep</code> and
<code>Amelia::amelia</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#############################################################################
# SIMULATED EXAMPLE 1: Scale scores
#############################################################################

set.seed(899)
n &lt;- 5000       # number of students
x &lt;- round( stats::runif( n, 0,1 ) )
y &lt;- stats::rnorm(n)
# simulate true score theta
theta &lt;- .6 + .4*x + .5 * y + stats::rnorm(n)
# simulate observed score by adding measurement error
sig.e &lt;- rep( sqrt(.40), n )
theta_obs &lt;- theta + stats::rnorm( n, sd=sig.e)

# calculate alpha
( alpha &lt;- stats::var( theta ) / stats::var( theta_obs ) )
# [1] 0.7424108
#=&gt; Ordinarily, sig.e or alpha will be known, assumed or estimated by using items,
#    replications or an appropriate measurement model.

# create matrix of predictors
X &lt;- as.matrix( cbind(x, y ) )

# plausible value imputation with scale score
imp1 &lt;- miceadds::draw.pv.ctt( y=theta_obs, x=X, sig.e=sig.e )
# check results
stats::lm( imp1 ~ x + y )

# imputation with alpha as an input
imp2 &lt;- miceadds::draw.pv.ctt( y=theta_obs, x=X, alpha=.74 )
stats::lm( imp2 ~ x + y )

#--- plausible value imputation in Amelia package
library(Amelia)

# define data frame
dat &lt;- data.frame( "x"=x, "y"=y, "theta"=theta_obs )
# generate observation-level priors for theta
priors &lt;- cbind( 1:n, 3, theta_obs, sig.e )
             # 3 indicates column index for theta
overimp &lt;- priors[,1:2]
# run Amelia
imp &lt;- Amelia::amelia( dat, priors=priors, overimp=overimp, m=10)
# create object of class datlist and evaluate results
datlist &lt;- miceadds::datlist_create( imp$imputations )
withPool_MI( with( datlist, stats::var(theta) ) )
stats::var(theta)       # compare with true variance
mod &lt;- with( datlist,  stats::lm( theta ~ x + y ) )
mitools::MIcombine(mod)

## End(Not run)
</code></pre>

<hr>
<h2 id='filename_split'>
Some Functionality for Strings and File Names
</h2><span id='topic+filename_split'></span><span id='topic+string_extract_part'></span><span id='topic+string_to_matrix'></span><span id='topic+filename_split_vec'></span>

<h3>Description</h3>

<p>The function <code>filename_split</code> splits a file name into parts.
</p>
<p>The function <code>string_extract_part</code> extracts a part of a string.
</p>
<p>The function <code>string_to_matrix</code> converts a string into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filename_split(file_name, file_sep="__", file_ext=".")
filename_split_vec( file_names, file_sep="__", file_ext=".")

string_extract_part( vec, part=1, sep="__", remove_empty=TRUE )

string_to_matrix(x, rownames=NULL, col_elim=NULL, as_numeric=FALSE,
               diag_val=NULL, extend=FALSE, col1_numeric=FALSE, split=" ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filename_split_+3A_file_name">file_name</code></td>
<td>

<p>File name
</p>
</td></tr>
<tr><td><code id="filename_split_+3A_file_names">file_names</code></td>
<td>
<p>File names</p>
</td></tr>
<tr><td><code id="filename_split_+3A_file_sep">file_sep</code></td>
<td>

<p>Separator within file name
</p>
</td></tr>
<tr><td><code id="filename_split_+3A_file_ext">file_ext</code></td>
<td>

<p>Separator for file extension
</p>
</td></tr>
<tr><td><code id="filename_split_+3A_vec">vec</code></td>
<td>
<p>Vector with strings</p>
</td></tr>
<tr><td><code id="filename_split_+3A_part">part</code></td>
<td>
<p>Integer indicating the part of the string to be selected</p>
</td></tr>
<tr><td><code id="filename_split_+3A_sep">sep</code></td>
<td>
<p>String separator</p>
</td></tr>
<tr><td><code id="filename_split_+3A_remove_empty">remove_empty</code></td>
<td>
<p>Logical indicating whether empty entries (<code>" "</code>&quot;)
should be removed.</p>
</td></tr>
<tr><td><code id="filename_split_+3A_x">x</code></td>
<td>
<p>String vector</p>
</td></tr>
<tr><td><code id="filename_split_+3A_rownames">rownames</code></td>
<td>
<p>Column index for row names</p>
</td></tr>
<tr><td><code id="filename_split_+3A_col_elim">col_elim</code></td>
<td>
<p>Indices for elimination of columns</p>
</td></tr>
<tr><td><code id="filename_split_+3A_as_numeric">as_numeric</code></td>
<td>
<p>Logical indicating whether numeric conversion is requested</p>
</td></tr>
<tr><td><code id="filename_split_+3A_diag_val">diag_val</code></td>
<td>
<p>Optional values for inclusion in diagonal of matrix</p>
</td></tr>
<tr><td><code id="filename_split_+3A_extend">extend</code></td>
<td>
<p>Optional indicating whether numeric matrix should be
extended to become a symmetric matrix</p>
</td></tr>
<tr><td><code id="filename_split_+3A_col1_numeric">col1_numeric</code></td>
<td>
<p>Logical indicating whether second column is selected in such
a way that it has to be always a numeric (see Example 5)</p>
</td></tr>
<tr><td><code id="filename_split_+3A_split">split</code></td>
<td>
<p>String used for splitting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with components of the file name (see Examples).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+files_move">files_move</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Demonstration example for filename_split
#############################################################################

# file name
file_name &lt;- "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES__2016-10-12_1000.csv"

# apply function
miceadds::filename_split( file_name )
  ##  $file_name
  ##  [1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES__2016-10-12_1000.csv"
  ##  $stem
  ##  [1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES"
  ##  $suffix
  ##  [1] "2016-10-12_1000"
  ##  $ext
  ##  [1] "csv"
  ##  $main
  ##  [1] "pisa_all_waves_invariant_items_DATA_ITEMS_RENAMED__DESCRIPTIVES.csv"

#############################################################################
# EXAMPLE 2: Example string_extract_part
#############################################################################

vec &lt;- c("ertu__DES", "ztu__DATA", "guzeuue745_ghshgk34__INFO", "zzu78347834_ghghwuz")

miceadds::string_extract_part( vec=vec, part=1, sep="__" )
miceadds::string_extract_part( vec=vec, part=2, sep="__" )
  ##  &gt; miceadds::string_extract_part( vec=vec, part=1, sep="__" )
  ##  [1] "ertu"                "ztu"                 "guzeuue745_ghshgk34"
  ##  [4] "zzu78347834_ghghwuz"
  ##  &gt; miceadds::string_extract_part( vec=vec, part=2, sep="__" )
  ##  [1] "DES"  "DATA" "INFO" NA

## Not run: 
#############################################################################
# EXAMPLE 3: Reading descriptive information from published articles
#############################################################################
data(data.ma08)
library(stringr)

#**** reading correlations (I)
dat &lt;- data.ma08$mat1
miceadds::string_to_matrix(dat, rownames=2, col_elim=c(1,2))

#**** reading correlations including some processing (II)
dat0 &lt;- data.ma08$mat2
dat &lt;- dat0[1:14]

# substitute "*"
dat &lt;- gsub("*", "", dat, fixed=TRUE )

# replace blanks in variable names
s1 &lt;- stringr::str_locate(dat, "[A-z] [A-z]")
start &lt;- s1[,"start"] + 1
for (ss in 1:length(start) ){
    if ( ! is.na( start[ss] ) ){
        substring( dat[ss], start[ss], start[ss] ) &lt;- "_"
    }
}

# character matrix
miceadds::string_to_matrix(dat)
# numeric matrix containing correlations
miceadds::string_to_matrix(dat, rownames=2, col_elim=c(1,2), as_numeric=TRUE, diag_val=1,
           extend=TRUE )
#** reading means and SDs
miceadds::string_to_matrix(dat0[ c(15,16)], rownames=1, col_elim=c(1), as_numeric=TRUE )

#**** reading correlations (III)
dat &lt;- data.ma08$mat3
dat &lt;- gsub(" age ", "_age_", dat, fixed=TRUE )
miceadds::string_to_matrix(dat, rownames=2, col_elim=c(1,2), as_numeric=TRUE, diag_val=1,
       extend=TRUE )

#**** reading correlations (IV)
dat &lt;- data.ma08$mat4 &lt;- dat0

# remove spaces in variable names
dat &lt;- gsub(" age ", "_age_", dat, fixed=TRUE )
s1 &lt;- stringr::str_locate_all(dat, "[A-z,.] [A-z]")
NL &lt;- length(dat)
for (ss in 1:NL ){
    NR &lt;- nrow(s1[[ss]])
    if (NR&gt;1){
        start &lt;- s1[[ss]][2,1]+1
        if ( ! is.na( start ) ){
            substring( dat[ss], start, start ) &lt;- "_"
        }
    }
}

miceadds::string_to_matrix(dat, rownames=2, col_elim=c(1,2), as_numeric=TRUE, diag_val=1,
     extend=TRUE )

#############################################################################
# EXAMPLE 4: Input string of length one
#############################################################################


pm0 &lt;- "
0.828
0.567 0.658
0.664 0.560 0.772
0.532 0.428 0.501 0.606
0.718 0.567 0.672 0.526 0.843"

miceadds::string_to_matrix(x=pm0, as_numeric=TRUE, extend=TRUE)

#############################################################################
# EXAMPLE 5: String with variable names and blanks
#############################################################################

tab1 &lt;- "
Geometric Shapes .629 .021 (.483) -.049 (.472)
Plates .473 .017 (.370) .105 (.405)
Two Characteristics .601 .013 (.452) -.033 (.444)
Crossing Out Boxes .597 -.062 (.425) -.036 (.445)
Numbers/Letters .731 .004 (.564) .003 (.513)
Numbers/Letters mixed .682 .085 (.555) .082 (.514)"

miceadds::string_to_matrix(x=tab1, col1_numeric=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='files_move'>
Moves Files from One Directory to Another Directory
</h2><span id='topic+files_move'></span>

<h3>Description</h3>

<p>Moves older (defined in alphanumeric order) files from one
directory to another directory. If directories do not exist,
they will be automatically created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>files_move(path1, path2, file_sep="__", pattern=NULL, path2_name="__ARCH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="files_move_+3A_path1">path1</code></td>
<td>

<p>Original directory
</p>
</td></tr>
<tr><td><code id="files_move_+3A_path2">path2</code></td>
<td>

<p>Target directory in which the files should be moved
</p>
</td></tr>
<tr><td><code id="files_move_+3A_file_sep">file_sep</code></td>
<td>

<p>Separator for files
</p>
</td></tr>
<tr><td><code id="files_move_+3A_pattern">pattern</code></td>
<td>

<p>Pattern in file names to be searched for
</p>
</td></tr>
<tr><td><code id="files_move_+3A_path2_name">path2_name</code></td>
<td>
<p>Part of the name of <code>path2</code> if argument
<code>path2</code> is missing. If <code>path2</code> is not provided, it has to be
a subdirectory of <code>path1</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+filename_split">filename_split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Move older files in '__ARCHIVE' directory
#############################################################################

# specify path
path1 &lt;- "p:/IPN/Projects/PISA/Trend_2015/2__Data/All_Waves/"
# specify target directory which is an archive
path2 &lt;- file.path( path1, "__ARCHIVE" )
# move files
files_move( path1, path2 )

## End(Not run)
</code></pre>

<hr>
<h2 id='fleishman_sim'>
Simulating Univariate Data from Fleishman Power Normal Transformations
</h2><span id='topic+fleishman_sim'></span><span id='topic+fleishman_coef'></span>

<h3>Description</h3>

<p>Simulates univariate non-normal data by using Fleishman power transformations
(Fleishman, 1978; Demirtas &amp; Hedeker, 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fleishman_sim(N=1, coef=NULL, mean=0, sd=1, skew=0, kurt=0)

fleishman_coef(mean=0, sd=1, skew=0, kurt=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fleishman_sim_+3A_n">N</code></td>
<td>

<p>Number of simulated values
</p>
</td></tr>
<tr><td><code id="fleishman_sim_+3A_coef">coef</code></td>
<td>

<p>Optional list containing coefficients of Fleishman polynomial estimated
by <code>fleishman_coef</code>.
</p>
</td></tr>
<tr><td><code id="fleishman_sim_+3A_mean">mean</code></td>
<td>

<p>Mean
</p>
</td></tr>
<tr><td><code id="fleishman_sim_+3A_sd">sd</code></td>
<td>

<p>Standard deviation
</p>
</td></tr>
<tr><td><code id="fleishman_sim_+3A_skew">skew</code></td>
<td>

<p>Skewness
</p>
</td></tr>
<tr><td><code id="fleishman_sim_+3A_kurt">kurt</code></td>
<td>

<p>(Excess) kurtosis
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">Z \sim N(0,1)</code>, the Fleishman power normal variable <code class="reqn">X</code> is defined as
<code class="reqn">X=a + bZ + cZ^2 + d Z^3</code>.
</p>


<h3>Value</h3>

<p>Vector of simulated values (<code>fleishman_sim</code>) or list of coefficients
(<code>fleishman_coef</code>).
</p>


<h3>References</h3>

<p>Demirtas, H., &amp; Hedeker, D. (2008). Imputing continuous data under some
non-Gaussian distributions. <em>Statistica Neerlandica, 62</em>(2), 193-205.
<a href="https://doi.org/10.1111/j.1467-9574.2007.00377.x">doi:10.1111/j.1467-9574.2007.00377.x</a>
</p>
<p>Fleishman, A. I. (1978). A method for simulating non-normal distributions.
<em>Psychometrika, 43</em>(4), 521-532.
<a href="https://doi.org/10.1007/BF02293811">doi:10.1007/BF02293811</a>
</p>


<h3>See Also</h3>

<p>See also the <code>BinOrdNonNor::Fleishman.coef.NN</code> function in the
<span class="pkg">BinOrdNonNor</span> package.
</p>
<p>See the <code><a href="#topic+nnig_sim">nnig_sim</a></code> function for simulating a non-normally distributed
multivariate variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Simulating values with Fleishman polynomial
#############################################################################

#* define mean, standard deviation, skewness and kurtosis
mean &lt;- .75
sd &lt;- 2
skew &lt;- 1
kurt &lt;- 3

#* compute coefficients of Fleishman polynomial
coeff &lt;- miceadds::fleishman_coef(mean=mean, sd=sd, skew=skew, kurt=kurt)
print(coeff)

# sample size
N &lt;- 1000
set.seed(2018)
#* simulate values based on estimated coefficients
X &lt;- miceadds::fleishman_sim(N=N, coef=coeff)
#* simulate values based on input of moments
X &lt;- miceadds::fleishman_sim(N=N, mean=mean, sd=sd, skew=skew, kurt=kurt)

## End(Not run)
</code></pre>

<hr>
<h2 id='grep.vec'>
<span class="rlang"><b>R</b></span> Utilities: Vector Based Versions of <code>grep</code>
</h2><span id='topic+grep.vec'></span><span id='topic+grep_leading'></span><span id='topic+grepvec_leading'></span><span id='topic+grepvec'></span>

<h3>Description</h3>

<p>These functions slightly extend the usage of <code>grep</code> but it is
extended to a vector argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grep.vec(pattern.vec, x, operator="AND", ...)

grepvec( pattern.vec, x, operator="AND", value=FALSE, ...)

grep_leading( pattern, x, value=FALSE )

grepvec_leading( patternvec, x, value=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grep.vec_+3A_pattern.vec">pattern.vec</code></td>
<td>

<p>String which should be looked for in vector <code>x</code>
</p>
</td></tr>
<tr><td><code id="grep.vec_+3A_x">x</code></td>
<td>

<p>A character vector
</p>
</td></tr>
<tr><td><code id="grep.vec_+3A_operator">operator</code></td>
<td>

<p>An optional string. The default argument <code>"AND"</code> searches all
entries in <code>x</code> which contain all elements of <code>pattern.vec</code>.
If <code>operator</code> is different from the default, then the <code>"OR"</code>
logic applies, i.e. the functions searches for vector entries which
contain at least one of the strings in <code>pattern.vec</code>.
</p>
</td></tr>
<tr><td><code id="grep.vec_+3A_pattern">pattern</code></td>
<td>
<p>String</p>
</td></tr>
<tr><td><code id="grep.vec_+3A_patternvec">patternvec</code></td>
<td>
<p>Vector of strings</p>
</td></tr>
<tr><td><code id="grep.vec_+3A_value">value</code></td>
<td>
<p>Logical indicating whether indices or values are requested</p>
</td></tr>
<tr><td><code id="grep.vec_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="base.html#topic+grep">base::grep</a></code>
(e.g., <code>fixed=TRUE</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Toy example
#############################################################################

vec &lt;- c("abcd", "bcde", "aedf", "cdf" )
# search for entries in vec with contain 'a' and 'f'
#  -&gt; operator="AND"
grep.vec( pattern.vec=c("a","f"), x=vec )
  ##   $x
  ##   [1] "aedf"
  ##   $index.x
  ##   [1] 3

grepvec( pattern.vec=c("a","f"), x=vec, value=TRUE)
grepvec( pattern.vec=c("a","f"), x=vec, value=FALSE)

# search for entries in vec which contain 'a' or 'f'
grep.vec( pattern.vec=c("a","f"), x=vec, operator="OR")
  ##   $x
  ##   [1] "abcd" "aedf" "cdf"
  ##   $index.x
  ##   [1] 1 3 4
</code></pre>

<hr>
<h2 id='GroupMean'>
Calculation of Groupwise Descriptive Statistics for Matrices
</h2><span id='topic+GroupMean'></span><span id='topic+GroupSum'></span><span id='topic+GroupSD'></span><span id='topic+gm'></span><span id='topic+cwc'></span>

<h3>Description</h3>

<p>Calculates some groupwise descriptive statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupMean(data, group, weights=NULL, extend=FALSE, elim=FALSE)

GroupSum(data, group, weights=NULL, extend=FALSE)

GroupSD(data, group, weights=NULL, extend=FALSE)

# group mean of a variable
gm(y, cluster, elim=FALSE)

# centering within clusters
cwc(y, cluster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GroupMean_+3A_data">data</code></td>
<td>

<p>A numeric data frame
</p>
</td></tr>
<tr><td><code id="GroupMean_+3A_group">group</code></td>
<td>

<p>A vector of group identifiers
</p>
</td></tr>
<tr><td><code id="GroupMean_+3A_weights">weights</code></td>
<td>
<p>An optional vector of sample weights</p>
</td></tr>
<tr><td><code id="GroupMean_+3A_extend">extend</code></td>
<td>
<p>Optional logical indicating whether the group means (or sums)
should be extended to the original dimensions of the dataset.</p>
</td></tr>
<tr><td><code id="GroupMean_+3A_elim">elim</code></td>
<td>
<p>Logical indicating whether a case in a row should be removed
from the calculation of the mean in a cluster</p>
</td></tr>
<tr><td><code id="GroupMean_+3A_y">y</code></td>
<td>
<p>Variable</p>
</td></tr>
<tr><td><code id="GroupMean_+3A_cluster">cluster</code></td>
<td>
<p>Cluster identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or a vector with groupwise calculated statistics
</p>


<h3>See Also</h3>

<p><code><a href="mitml.html#topic+clusterMeans">mitml::clusterMeans</a></code>
</p>
<p><code><a href="base.html#topic+rowsum">base::rowsum</a></code>,
<code><a href="stats.html#topic+aggregate">stats::aggregate</a></code>,
<code><a href="stats.html#topic+ave">stats::ave</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#############################################################################
# EXAMPLE 1: Group means and standard deviations for data.ma02
#############################################################################

data(data.ma02, package="miceadds" )
dat &lt;- data.ma02[[1]] # select first dataset

#--- group means for read and math
GroupMean( dat[, c("read","math") ], group=dat$idschool )
# using rowsum
a1 &lt;- base::rowsum( dat[, c("read","math") ], dat$idschool )
a2 &lt;- base::rowsum( 1+0*dat[, c("read","math") ], dat$idschool )
(a1/a2)[1:10,]
# using aggregate
stats::aggregate(  dat[, c("read","math") ], list(dat$idschool), mean )[1:10,]

#--- extend group means to original dataset
GroupMean( dat[, c("read","math") ], group=dat$idschool, extend=TRUE )
# using ave
stats::ave( dat[, "read" ], dat$idschool  )
stats::ave( dat[, "read" ], dat$idschool, FUN=mean )

#--- group standard deviations
GroupSD( dat[, c("read","math") ], group=dat$idschool)[1:10,]
# using aggregate
stats::aggregate(  dat[, c("read","math") ], list(dat$idschool), sd )[1:10,]

#############################################################################
# EXAMPLE 2: Calculating group means and group mean centering
#############################################################################

data(data.ma07, package="miceadds")
dat &lt;- data.ma07

# compute group means
miceadds::gm( dat$x1, dat$id2 )
# centering within clusters
miceadds::cwc( dat$x1, dat$id2 )

# evaluate formula with model.matrix
X &lt;- model.matrix( ~ I( miceadds::cwc(x1, id2) ) + I( miceadds::gm(x1,id2) ), data=dat )
head(X)

## End(Not run)
</code></pre>

<hr>
<h2 id='in_CI'>
Indicator Function for Analyzing Coverage
</h2><span id='topic+in_CI'></span>

<h3>Description</h3>

<p>Indicator function for analyzing coverage. The output indicates whether a
value lies within a computed confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_CI(est, se, true, level=0.95, df=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_CI_+3A_est">est</code></td>
<td>

<p>Vector of estimates
</p>
</td></tr>
<tr><td><code id="in_CI_+3A_se">se</code></td>
<td>

<p>Vector of standard errors
</p>
</td></tr>
<tr><td><code id="in_CI_+3A_true">true</code></td>
<td>

<p>Vector of true parameters
</p>
</td></tr>
<tr><td><code id="in_CI_+3A_level">level</code></td>
<td>

<p>Confidence level
</p>
</td></tr>
<tr><td><code id="in_CI_+3A_df">df</code></td>
<td>

<p>Degrees of freedom for <code class="reqn">t</code> distribution. The default corresponds to
the normal distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Toy example
#############################################################################

#-- simulate estimates and standard errors
set.seed(987)
n &lt;- 10
est &lt;- stats::rnorm( n, sd=1)
se &lt;- stats::runif( n, 0, .7 )
level &lt;- .95
true &lt;- 0

#-- apply coverage function
in_ci &lt;- miceadds::in_CI( est, se, true)
#-- check correctness
cbind( est, se, true, in_ci )
</code></pre>

<hr>
<h2 id='index.dataframe'>
<span class="rlang"><b>R</b></span> Utilities: Include an Index to a Data Frame
</h2><span id='topic+index.dataframe'></span>

<h3>Description</h3>

<p>This function includes an index variable to a data frame
in the first column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.dataframe(data,systime=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index.dataframe_+3A_data">data</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="index.dataframe_+3A_systime">systime</code></td>
<td>
<p>Should system time be included in the second column
of the data frame?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dfr &lt;- matrix( 2*1:12-3, 4,3 )
colnames(dfr) &lt;- paste0("X",1:ncol(dfr))
index.dataframe( dfr)
  ##     index X1 X2 X3
  ##   1     1 -1  7 15
  ##   2     2  1  9 17
  ##   3     3  3 11 19
  ##   4     4  5 13 21
index.dataframe( dfr, systime=TRUE)
  ##     index         file_created X1 X2 X3
  ##   1     1  2013-08-22 10:26:28 -1  7 15
  ##   2     2  2013-08-22 10:26:28  1  9 17
  ##   3     3  2013-08-22 10:26:28  3 11 19
  ##   4     4  2013-08-22 10:26:28  5 13 21
</code></pre>

<hr>
<h2 id='jomo2datlist'>
Converts a <span class="pkg">jomo</span> Data Frame in Long Format into a List of Datasets or an Object
of Class <code>mids</code>
</h2><span id='topic+jomo2datlist'></span><span id='topic+jomo2mids'></span>

<h3>Description</h3>

<p>Converts a <span class="pkg">jomo</span> data frame in long format into a list of datasets
or an object of class <code>mids</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo2datlist(jomo.dataframe, variable="Imputation")

jomo2mids(jomo.dataframe, variable="Imputation")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jomo2datlist_+3A_jomo.dataframe">jomo.dataframe</code></td>
<td>

<p>Data frame generated in <span class="pkg">jomo</span> package
</p>
</td></tr>
<tr><td><code id="jomo2datlist_+3A_variable">variable</code></td>
<td>

<p>Variable name for imputation index
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of multiply imputed datasets
</p>


<h3>See Also</h3>

<p>See the <span class="pkg">jomo</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Dataset nhanes | jomo imputation and conversion into a data list
#############################################################################

data(nhanes, package="mice")
dat &lt;- nhanes

# impute under multivariate normal model in jomo
imp1 &lt;- jomo::jomo1con(Y=dat, nburn=100, nbetween=10, nimp=5)
# convert into a list of datasets
datlist1 &lt;- miceadds::jomo2datlist(imp1)
# convert into mids object
datlist2 &lt;- miceadds::jomo2datlist(imp1)

## End(Not run)
</code></pre>

<hr>
<h2 id='kernelpls.fit2'>
Kernel PLS Regression
</h2><span id='topic+kernelpls.fit2'></span><span id='topic+predict.kernelpls.fit2'></span>

<h3>Description</h3>

<p>Fits a PLS regression model with the kernel algorithm (Dayal &amp; Macgregor, 1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelpls.fit2(X, Y, ncomp)

## S3 method for class 'kernelpls.fit2'
predict(object,X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernelpls.fit2_+3A_x">X</code></td>
<td>

<p>Matrix of regressors
</p>
</td></tr>
<tr><td><code id="kernelpls.fit2_+3A_y">Y</code></td>
<td>

<p>Vector of a univariate outcome
</p>
</td></tr>
<tr><td><code id="kernelpls.fit2_+3A_ncomp">ncomp</code></td>
<td>

<p>Number of components to be extracted
</p>
</td></tr>
<tr><td><code id="kernelpls.fit2_+3A_object">object</code></td>
<td>
<p>Object of class <code>kernelpls.fit2</code></p>
</td></tr>
<tr><td><code id="kernelpls.fit2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same list as in
<code>{pls::kernelpls.fit}</code>
is produced.
</p>
<p>In addition, <code class="reqn">R^2</code> measures are contained in
<code>R2</code>.
</p>


<h3>Author(s)</h3>

<p>This code is a <span class="pkg">Rcpp</span> translation of the original
<code>pls::kernelpls.fit</code> function from the <span class="pkg">pls</span> package
(see Mevik &amp; Wehrens, 2007).
</p>


<h3>References</h3>

<p>Dayal, B., &amp; Macgregor, J. F. (1997). Improved PLS algorithms.
<em>Journal of Chemometrics, 11</em>(1), 73-85.
</p>
<p>Mevik, B. H., &amp; Wehrens, R. (2007). The <span class="pkg">pls</span> package:
Principal component and partial least squares regression in <span class="rlang"><b>R</b></span>.
<em>Journal of Statistical Software, 18</em>, 1-24.
<a href="https://doi.org/10.18637/jss.v018.i02">doi:10.18637/jss.v018.i02</a>
</p>


<h3>See Also</h3>

<p>See the <span class="pkg">pls</span> package for further estimation algorithms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# SIMULATED EXAMPLE 1: 300 cases on 100 variables
#############################################################################
set.seed(789)
library(mvtnorm)

N &lt;- 300        # number of cases
p &lt;- 100        # number of predictors
rho1 &lt;- .6      # correlations between predictors

# simulate data
Sigma &lt;- base::diag(1-rho1,p) + rho1
X &lt;- mvtnorm::rmvnorm( N, sigma=Sigma )
beta &lt;- base::seq( 0, 1, len=p )
y &lt;- ( X %*% beta )[,1] + stats::rnorm( N, sd=.6 )
Y &lt;- base::matrix(y,nrow=N, ncol=1 )

# PLS regression
res &lt;- miceadds::kernelpls.fit2( X=X, Y=Y, ncomp=20 )

# predict new scores
Xpred &lt;- predict( res, X=X[1:10,] )

#############################################################################
# EXAMPLE 2: Dataset yarn from pls package
#############################################################################

# use kernelpls.fit from pls package
library(pls)
data(yarn,package="pls")
mod1 &lt;- pls::kernelpls.fit( X=yarn$NIR, Y=yarn$density, ncomp=10 )
# use kernelpls.fit2 from miceadds package
Y &lt;- base::matrix( yarn$density, ncol=1 )
mod2 &lt;- miceadds::kernelpls.fit2( X=yarn$NIR, Y=Y, ncomp=10 )

## End(Not run)
</code></pre>

<hr>
<h2 id='library_install'>
<span class="rlang"><b>R</b></span> Utilities: Loading a Package or Installation of a Package if Necessary
</h2><span id='topic+library_install'></span>

<h3>Description</h3>

<p>Loads packages specified in vector <code>pkg</code>. If some packages are not
yet installed, they will be automatically installed by this function using
<code><a href="utils.html#topic+install.packages">install.packages</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>library_install( pkg, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="library_install_+3A_pkg">pkg</code></td>
<td>

<p>Vector with package names
</p>
</td></tr>
<tr><td><code id="library_install_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to
<code><a href="utils.html#topic+install.packages">install.packages</a></code>
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# try to load packages PP and MCMCglmm
library_install( pkg=c("PP", "MCMCglmm") )

## End(Not run)
</code></pre>

<hr>
<h2 id='lm.cluster'>
Cluster Robust Standard Errors for Linear Models and General Linear Models
</h2><span id='topic+lm.cluster'></span><span id='topic+glm.cluster'></span><span id='topic+coef.lm.cluster'></span><span id='topic+coef.glm.cluster'></span><span id='topic+vcov.lm.cluster'></span><span id='topic+vcov.glm.cluster'></span><span id='topic+summary.lm.cluster'></span><span id='topic+summary.glm.cluster'></span>

<h3>Description</h3>

<p>Computes cluster robust standard errors for linear models
(<code><a href="stats.html#topic+lm">stats::lm</a></code>) and general linear models
(<code><a href="stats.html#topic+glm">stats::glm</a></code>) using the
<code><a href="sandwich.html#topic+vcovCL">multiwayvcov::vcovCL</a></code>
function in the <span class="pkg">sandwich</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.cluster(data, formula, cluster, weights=NULL, subset=NULL )

glm.cluster(data, formula, cluster, weights=NULL, subset=NULL, family="gaussian" )

## S3 method for class 'lm.cluster'
summary(object,...)
## S3 method for class 'glm.cluster'
summary(object,...)

## S3 method for class 'lm.cluster'
coef(object,...)
## S3 method for class 'glm.cluster'
coef(object,...)

## S3 method for class 'lm.cluster'
vcov(object,...)
## S3 method for class 'glm.cluster'
vcov(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.cluster_+3A_data">data</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="lm.cluster_+3A_formula">formula</code></td>
<td>

<p>An <span class="rlang"><b>R</b></span> formula
</p>
</td></tr>
<tr><td><code id="lm.cluster_+3A_cluster">cluster</code></td>
<td>

<p>Variable name for cluster variable contained in <code>data</code> or a vector
with cluster identifiers
</p>
</td></tr>
<tr><td><code id="lm.cluster_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="lm.cluster_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to be used.</p>
</td></tr>
<tr><td><code id="lm.cluster_+3A_family">family</code></td>
<td>
<p>Description of the error distribution and link function to be used in
the model, see <code><a href="stats.html#topic+glm">stats::glm</a></code>.</p>
</td></tr>
<tr><td><code id="lm.cluster_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code><a href="stats.html#topic+lm">stats::lm</a></code> and
<code><a href="stats.html#topic+glm">stats::glm</a></code>
</p>
</td></tr>
<tr><td><code id="lm.cluster_+3A_object">object</code></td>
<td>

<p>Object of class <code>lm.cluster</code> or <code>glm.cluster</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with following entries
</p>
<table>
<tr><td><code>lm_res</code></td>
<td>
<p>Value of <code><a href="stats.html#topic+lm">stats::lm</a></code></p>
</td></tr>
<tr><td><code>glm_res</code></td>
<td>
<p>Value of <code><a href="stats.html#topic+glm">stats::glm</a></code></p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Covariance matrix of parameter estimates</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">stats::lm</a></code>, <code><a href="stats.html#topic+glm">stats::glm</a></code>,
<code><a href="sandwich.html#topic+vcovCL">sandwich::vcovCL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#############################################################################
# EXAMPLE 1: Cluster robust standard errors data.ma01
#############################################################################

data(data.ma01)
dat &lt;- data.ma01

#*** Model 1: Linear regression
mod1 &lt;- miceadds::lm.cluster( data=dat, formula=read ~ hisei + female,
               cluster="idschool" )
coef(mod1)
vcov(mod1)
summary(mod1)

# estimate Model 1, but cluster is provided as a vector
mod1b &lt;- miceadds::lm.cluster( data=dat, formula=read ~ hisei + female,
                 cluster=dat$idschool)
summary(mod1b)

#*** Model 2: Logistic regression
dat$highmath &lt;- 1 * ( dat$math &gt; 600 )   # create dummy variable
mod2 &lt;- miceadds::glm.cluster( data=dat, formula=highmath ~ hisei + female,
                cluster="idschool", family="binomial")
coef(mod2)
vcov(mod2)
summary(mod2)

#############################################################################
# EXAMPLE 2: Cluster robust standard errors for multiply imputed datasets
#############################################################################

library(mitools)
data(data.ma05)
dat &lt;- data.ma05

# imputation of the dataset: use six imputations
resp &lt;- dat[, - c(1:2) ]
imp &lt;- mice::mice( resp, method="norm", maxit=3, m=6 )
datlist &lt;- miceadds::mids2datlist( imp )

# linear regression with cluster robust standard errors
mod &lt;- lapply(  datlist, FUN=function(data){
            miceadds::lm.cluster( data=data, formula=denote ~ migrant+ misei,
                    cluster=dat$idclass )
            }  )
# extract parameters and covariance matrix
betas &lt;- lapply( mod, FUN=function(rr){ coef(rr) } )
vars &lt;- lapply( mod, FUN=function(rr){ vcov(rr) } )
# conduct statistical inference
summary( miceadds::pool_mi( qhat=betas, u=vars ) )

#------ compute global F-test for hypothesis that all predictors have zero coefficient values
library(mitml)
Nimp &lt;- 6 # number of imputations
np &lt;- length(betas[[1]])   # number of parameters
beta_names &lt;- names(betas[[1]])
# define vector of parameters for which constraints should be tested
constraints &lt;- beta_names[-1]
# create input for mitml::testConstraints function
qhat &lt;- matrix( unlist(betas), ncol=Nimp)
rownames(qhat) &lt;- beta_names
uhat &lt;- array( unlist(vars), dim=c(np,np,Nimp))
dimnames(uhat) &lt;- list( beta_names, beta_names, NULL )
# compute global F-test
Ftest &lt;- mitml::testConstraints( qhat=betas, uhat=vars, constraints=constraints )
print(Ftest)

#############################################################################
# EXAMPLE 3: Comparing miceadds::lm.cluster() and lme4::lmer()
#############################################################################

data(data.ma01, package="miceadds")
dat &lt;- na.omit(data.ma01)

# center hisei variable
dat$hisei &lt;- dat$hisei - mean(dat$hisei)

# define school mean hisei
dat$hisei_gm &lt;- miceadds::GroupMean(dat$hisei, dat$idschool, extend=TRUE)[,2]
dat$cluster_size &lt;- miceadds::GroupSum(1+0*dat$hisei, dat$idschool, extend=TRUE)[,2]
dat$hisei_wc &lt;- dat$hisei - dat$hisei_gm



#*** Model 1a: lm, hisei with clustering
mod1a &lt;- miceadds::lm.cluster( data=dat, formula=read~hisei, cluster="idschool" )

#*** Model 1b: lmer, hisei
mod1b &lt;- lme4::lmer( data=dat, formula=read~hisei+(1|idschool) )

cbind( coef(mod1a), fixef(mod1b))
 ##  &gt; cbind( coef(mod1a), fixef(mod1b))
 ##                    [,1]        [,2]
 ##  (Intercept) 509.181691 507.8684752
 ##  hisei         1.524776   0.8161745

# variance explanation
vmod1b &lt;- r2mlm::r2mlm(mod1b)
vmod1b$Decompositions

#*** Model 2a: lm, hisei and hisei_gm with clustering
mod2a &lt;- miceadds::lm.cluster( data=dat, formula=read~hisei_wc+hisei_gm,
                                   cluster="idschool" )

#*** Model 2b: lmer, multilevel model
mod2b &lt;- lme4::lmer( data=dat, formula=read~hisei_wc+hisei_gm + (1|idschool) )

# variance explanation
vmod2b &lt;- r2mlm::r2mlm(mod2b)
vmod2b$Decompositions

cbind( coef(mod2a), fixef(mod2b))
 ##  &gt; cbind( coef(mod2a), fixef(mod2b))
 ##                     [,1]        [,2]
 ##  (Intercept) 509.1816911 508.0478629
 ##  hisei_wc      0.7503773   0.7503773
 ##  hisei_gm      5.8424012   5.5681941


## End(Not run)
</code></pre>

<hr>
<h2 id='lmer_vcov'>
Statistical Inference for Fixed and Random Structure for Fitted Models
in <span class="pkg">lme4</span>
</h2><span id='topic+lmer_vcov'></span><span id='topic+summary.lmer_vcov'></span><span id='topic+coef.lmer_vcov'></span><span id='topic+vcov.lmer_vcov'></span><span id='topic+lmer_vcov2'></span><span id='topic+lmer_pool'></span><span id='topic+summary.lmer_pool'></span><span id='topic+lmer_pool2'></span>

<h3>Description</h3>

<p>The function <code>lmer_vcov</code> conducts statistical inference for
fixed coefficients and standard deviations
and correlations of random effects structure of models fitted in the
<span class="pkg">lme4</span> package.
</p>
<p>The function <code>lmer_pool</code> applies the Rubin formula for inference
for fitted <span class="pkg">lme4</span> models for multiply imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmer_vcov(object, level=.95, use_reml=FALSE, ...)

## S3 method for class 'lmer_vcov'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'lmer_vcov'
coef(object, ...)
## S3 method for class 'lmer_vcov'
vcov(object, ...)

lmer_vcov2(object, level=.95, ...)

lmer_pool( models, level=.95, ...)
## S3 method for class 'lmer_pool'
summary(object, digits=4, file=NULL, ...)

lmer_pool2( models, level=.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmer_vcov_+3A_object">object</code></td>
<td>

<p>Fitted object in <span class="pkg">lme4</span>
</p>
</td></tr>
<tr><td><code id="lmer_vcov_+3A_level">level</code></td>
<td>
<p>Confidence level</p>
</td></tr>
<tr><td><code id="lmer_vcov_+3A_use_reml">use_reml</code></td>
<td>
<p>Logical indicating whether REML estimates should be used for
variance components (if provided)</p>
</td></tr>
<tr><td><code id="lmer_vcov_+3A_digits">digits</code></td>
<td>
<p>Number of digits used for rounding in summary</p>
</td></tr>
<tr><td><code id="lmer_vcov_+3A_file">file</code></td>
<td>
<p>Optional file name for sinking output</p>
</td></tr>
<tr><td><code id="lmer_vcov_+3A_models">models</code></td>
<td>
<p>List of models fitted in <span class="pkg">lme4</span> for a multiply
imputed dataset</p>
</td></tr>
<tr><td><code id="lmer_vcov_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with several entries:
</p>
<table>
<tr><td><code>par_summary</code></td>
<td>
<p>Parameter summary</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>Estimated parameters</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Covariance matrix of estimates</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Further values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Function originally from Ben Bolker, http://rpubs.com/bbolker/varwald
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+lmer">lme4::lmer</a></code>,
<code><a href="mitml.html#topic+testEstimates">mitml::testEstimates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Single model fitted in lme4
#############################################################################

library(lme4)
data(data.ma01, package="miceadds")
dat &lt;- na.omit(data.ma01)

#* fit multilevel model
formula &lt;- math ~ hisei + miceadds::gm( books, idschool ) + ( 1 + books | idschool )
mod1 &lt;- lme4::lmer( formula, data=dat, REML=FALSE)
summary(mod1)

#* statistical inference
res1 &lt;- miceadds::lmer_vcov( mod1 )
summary(res1)
coef(res1)
vcov(res1)

#############################################################################
# EXAMPLE 2: lme4 model for multiply imputed dataset
#############################################################################

library(lme4)
data(data.ma02, package="miceadds")
datlist &lt;- miceadds::datlist_create(data.ma02)

#** fit lme4 model for all imputed datasets
formula &lt;- math ~ hisei + miceadds::gm( books, idschool ) + ( 1 | idschool )
models &lt;- list()
M &lt;- length(datlist)
for (mm in 1:M){
    models[[mm]] &lt;- lme4::lmer( formula, data=datlist[[mm]], REML=FALSE)
}

#** statistical inference
res1 &lt;- miceadds::lmer_pool(models)
summary(res1)

## End(Not run)
</code></pre>

<hr>
<h2 id='load.data'>
<span class="rlang"><b>R</b></span> Utilities: Loading/Reading Data Files using <span class="pkg">miceadds</span>
</h2><span id='topic+load.data'></span><span id='topic+load.files'></span>

<h3>Description</h3>

<p>The function <code>load.data</code> is a wrapper function for loading or reading data frames
or matrices.
</p>
<p>The function <code>load.files</code> loads multiple files in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.data( filename, type=NULL, path=getwd(), load_fun=NULL, spss.default=TRUE, ...)

load.files( files, type=NULL, path=getwd(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.data_+3A_filename">filename</code></td>
<td>

<p>Name of the data file (matrix or data frame). This can also be a part
of the file name and the most recent file is loaded.
<code>filename</code> can also be a vector which strings and a file
is loaded which contains all the specified strings.
</p>
</td></tr>
<tr><td><code id="load.data_+3A_type">type</code></td>
<td>

<p>The type of file in which the data frame or matrix should be loaded.
This can be <code>Rdata</code> (for <span class="rlang"><b>R</b></span> binary format, using <code><a href="#topic+load.Rdata2">load.Rdata2</a></code>),
<code>csv</code> (using <code><a href="utils.html#topic+read.csv2">utils::read.csv2</a></code>),
<code>csv2</code> (using <code><a href="utils.html#topic+read.csv">utils::read.csv</a></code>),
<code>table</code> (using <code><a href="utils.html#topic+read.table">utils::read.table</a></code>; the dataset
must have the file extension <code>dat</code> or <code>txt</code>),
<code>xlsx</code> (using <code><a href="readxl.html#topic+read_excel">readxl::read_excel</a></code>; or using
the extension <code>xls</code>),
<code>sav</code> (using <code><a href="foreign.html#topic+read.spss">foreign::read.spss</a></code>),
<code>RDS</code>. If an alternative data loading function <code>load_fun</code> is chosen,
<code>type</code> must be the file extension.
</p>
</td></tr>
<tr><td><code id="load.data_+3A_path">path</code></td>
<td>
<p>Directory from which the dataset should be loaded.
It can also be set to <code>NULL</code> if the absolute path is already
included in <code>filename</code>.</p>
</td></tr>
<tr><td><code id="load.data_+3A_load_fun">load_fun</code></td>
<td>
<p>User-specified loading function</p>
</td></tr>
<tr><td><code id="load.data_+3A_spss.default">spss.default</code></td>
<td>
<p>Optional logical which is only applied
for <code>type="sav"</code> indicating whether the arguments
<code>to.data.frame=TRUE</code> and <code>use.value.labels=FALSE</code>
are used.</p>
</td></tr>
<tr><td><code id="load.data_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>load.Rdata2</code>,
<code>utils::read.csv2</code>, <code>utils::read.csv</code>, <code>utils::read.table</code>,
<code>readxl::read_excel</code>, <code>foreign::read.spss</code>, or <code>load_fun</code>.
</p>
</td></tr>
<tr><td><code id="load.data_+3A_files">files</code></td>
<td>
<p>Vector of file names</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See also <code><a href="#topic+load.Rdata">load.Rdata</a></code> for loading <span class="rlang"><b>R</b></span> data frames.
</p>
<p>See <code><a href="#topic+save.Rdata">save.Rdata</a></code> and <code><a href="#topic+save.data">save.data</a></code>
for saving/writing <span class="rlang"><b>R</b></span> data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Toy example
#############################################################################

# load a data frame in the file "data_s3.Rdata" and save this
# as the object "dat.s3"
dat.s3 &lt;- miceadds::load.data( filename="data_s3.Rdata", type="Rdata" )
print(str(dat.s3))

# load text input with base::readLines() function using the 'load_fun' argument
dat &lt;- miceadds::load.data( "my_output_", type="Rout", load_fun=readLines, path=path)

## End(Not run)
</code></pre>

<hr>
<h2 id='load.Rdata'>
<span class="rlang"><b>R</b></span> Utilities: Loading <code>Rdata</code> Files in a Convenient Way
</h2><span id='topic+load.Rdata'></span><span id='topic+load.Rdata2'></span>

<h3>Description</h3>

<p>These functions loads a <code>Rdata</code> object saved as a data frame or a matrix
in the current <span class="rlang"><b>R</b></span> environment. The function <code>load.Rdata</code>
saves the loaded object in the global environment while <code>load.Rdata2</code>
loads the object only specified environments. Hence, usage of
<code>load.Rdata2</code> instead of <code>load.Rdata</code> is recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.Rdata(filename, objname)

load.Rdata2(filename, path=getwd(), RDS=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.Rdata_+3A_filename">filename</code></td>
<td>

<p>Rdata file (matrix or data frame)
</p>
</td></tr>
<tr><td><code id="load.Rdata_+3A_objname">objname</code></td>
<td>

<p>Object name. This object will be a global variable in <span class="rlang"><b>R</b></span>.
</p>
</td></tr>
<tr><td><code id="load.Rdata_+3A_path">path</code></td>
<td>
<p>Directory from which the dataset should be loaded</p>
</td></tr>
<tr><td><code id="load.Rdata_+3A_rds">RDS</code></td>
<td>
<p>logical if object is saved as an RDS object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See also <code><a href="#topic+save.Rdata">save.Rdata</a></code> for saving data frames in
a <code>Rdata</code> format.
</p>
<p>See also: <code><a href="base.html#topic+load">base::load</a></code>, <code><a href="base.html#topic+save">base::save</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load a data frame in the file "data_s3.Rdata" and save this
# as the object "dat.s3"
load.Rdata( filename="data_s3.Rdata", "dat.s3" )
head(dat.s3)

# Alternatively one can use the function
dat.s3 &lt;- miceadds::load.Rdata2( filename="data_s3.Rdata")

## End(Not run)
</code></pre>

<hr>
<h2 id='ma_lme4_formula'>
Utility Functions for Working with <span class="pkg">lme4</span> Formula Objects
</h2><span id='topic+ma_lme4_formula'></span><span id='topic+ma_lme4_formula_terms'></span><span id='topic+ma_lme4_formula_design_matrices'></span>

<h3>Description</h3>

<p>Utility functions for working with <span class="pkg">lme4</span> formula objects. The function
<code>ma_lme4_formula_terms</code> decomposes an <span class="pkg">lme4</span> formula into several
parts for further processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma_lme4_formula_terms(formula)

ma_lme4_formula_design_matrices(formula, data, start_index=0, formula_terms=NULL,
        only_design_matrices=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma_lme4_formula_+3A_formula">formula</code></td>
<td>

<p>An <span class="rlang"><b>R</b></span> formula object
</p>
</td></tr>
<tr><td><code id="ma_lme4_formula_+3A_data">data</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="ma_lme4_formula_+3A_start_index">start_index</code></td>
<td>
<p>Starting index for cluster identifiers</p>
</td></tr>
<tr><td><code id="ma_lme4_formula_+3A_formula_terms">formula_terms</code></td>
<td>
<p>Optional argument with processed formula terms using the
function <code>ma_lme4_formula_terms</code></p>
</td></tr>
<tr><td><code id="ma_lme4_formula_+3A_only_design_matrices">only_design_matrices</code></td>
<td>
<p>Logical indicating whether only design matrices should
be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with several entries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Splitting a lme4 formula
#############################################################################

#*** formula for a multilevel model
formula &lt;- y ~ I( miceadds::cwc(x, idcluster)) + z + I(z^2) + I( miceadds::gm(x, idcluster) ) + w +
                        ( x + I(x^2) | idcluster)  + (0 +  w | idcluster ) +
                        ( 0 + I(as.factor(f)) | idcluster)
miceadds::ma_lme4_formula_terms(formula)

#*** formula for a single level model
formula2 &lt;- y ~ I( miceadds::cwc(x, idcluster)) + z + I(z^2) + I( miceadds::gm(x, idcluster) ) + w
miceadds::ma_lme4_formula_terms(formula2)

#############################################################################
# EXAMPLE 2: Design matrices for multilevel model
#############################################################################

data(data.ma07, package="miceadds")
dat &lt;- data.ma07

formula &lt;- x1 ~ x2 + I( miceadds::gm( x2, id2)) + I( miceadds::gm( x2, id3)) + y1 + z1 +
                    ( x2 | id2:id3 ) + ( 1 | id3 ) + ( 0 + x2 | id3 )
res &lt;- miceadds::ma_lme4_formula_design_matrices(formula, data=dat)
str(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='ma_rmvnorm'>
Simulating Normally Distributed Data
</h2><span id='topic+ma_rmvnorm'></span>

<h3>Description</h3>

<p>Some functions for normally distributed data.
</p>
<p>The function <code>ma_rmvnorm</code> is like <code>mvtnorm::rmvnorm</code>, but allows
for a covariance matrix <code>sigma</code> which can have zero variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma_rmvnorm(n, mu=NULL, sigma, eps=1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma_rmvnorm_+3A_n">n</code></td>
<td>

<p>Sample size
</p>
</td></tr>
<tr><td><code id="ma_rmvnorm_+3A_mu">mu</code></td>
<td>

<p>Mean vector
</p>
</td></tr>
<tr><td><code id="ma_rmvnorm_+3A_sigma">sigma</code></td>
<td>

<p>Covariance matrix
</p>
</td></tr>
<tr><td><code id="ma_rmvnorm_+3A_eps">eps</code></td>
<td>

<p>Trimming constant for zero variances
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of simulated values
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+mvrnorm">MASS::mvrnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Two-dimensional simulation with zero variance at dimension 1
#############################################################################

sigma &lt;- matrix( c(0,0,0,1), nrow=2, ncol=2)
miceadds::ma_rmvnorm( n=10, sigma=sigma )

## End(Not run)
</code></pre>

<hr>
<h2 id='ma.scale2'>
Standardization of a Matrix
</h2><span id='topic+ma.scale2'></span>

<h3>Description</h3>

<p>This function performs a z-standardization for a numeric matrix.
Note that in a case of a zero standard deviation all matrix entries
are divided by a small number such that no <code>NaN</code>s occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma.scale2(x, missings=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma.scale2_+3A_x">x</code></td>
<td>

<p>A numeric matrix in which missing values are permitted
</p>
</td></tr>
<tr><td><code id="ma.scale2_+3A_missings">missings</code></td>
<td>

<p>A logical indicating whether missings occur (or could occur) in the dataset
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">base::scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: z-standardization data.internet
#############################################################################

data(data.internet)
dat &lt;- data.internet

# z-standardize all variables in this dataset
zdat &lt;- miceadds::ma.scale2( dat, missings=TRUE )

## Not run: 
#############################################################################
# SIMULATED EXAMPLE 2: Speed comparison for many cases and many variables
#############################################################################

set.seed(9786)
# 3000 cases, 200 variables
N &lt;- 3000
p &lt;- 200
# simulate some data
x &lt;- matrix( stats::rnorm( N*p ), N, p )
x &lt;- round( x, 2 )

# compare computation times for 10 replications
B &lt;- 10
    s1 &lt;- Sys.time()        # scale in R
for (bb in 1:B){
    res &lt;- scale(x)
} ; s2 &lt;- Sys.time() ; d1 &lt;- s2-s1

    s1 &lt;- Sys.time()        # scale in miceadds
for (bb in 1:B){
    res1 &lt;- miceadds::ma.scale2(x)
} ; s2 &lt;- Sys.time() ; d2 &lt;- s2-s1

# scale in miceadds with missing handling
    s1 &lt;- Sys.time()
for (bb in 1:B){
    res1 &lt;- miceadds::ma.scale2(x,missings=TRUE)
} ; s2 &lt;- Sys.time() ; d3 &lt;- s2-s1
d1      # scale in R
d2      # scale in miceadds (no missing handling)
d3      # scale in miceadds (with missing handling)
  ##   &gt; d1      # scale in R
  ##   Time difference of 1.622431 secs
  ##   &gt; d2      # scale in miceadds (no missing handling)
  ##   Time difference of 0.156003 secs
  ##   &gt; d3      # scale in miceadds (with missing handling)
  ##   Time difference of 0.2028039 secs

## End(Not run)
</code></pre>

<hr>
<h2 id='ma.wtd.statNA'>
Some Multivariate Descriptive Statistics for Weighted Data in <span class="pkg">miceadds</span>
</h2><span id='topic+ma.wtd.statNA'></span><span id='topic+ma.wtd.covNA'></span><span id='topic+ma.wtd.corNA'></span><span id='topic+ma.wtd.meanNA'></span><span id='topic+ma.wtd.sdNA'></span><span id='topic+ma.wtd.skewnessNA'></span><span id='topic+ma.wtd.kurtosisNA'></span><span id='topic+ma.wtd.quantileNA'></span>

<h3>Description</h3>

<p>Some multivariate descriptive statistics for weighted datasets in <span class="pkg">miceadds</span>.
A list of (nested) multiply imputed data sets is also allowed as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma.wtd.meanNA(data, weights=NULL, vars=NULL )

ma.wtd.sdNA(data, weights=NULL, vars=NULL, method="unbiased" )

ma.wtd.covNA(data, weights=NULL, vars=NULL, method="unbiased" )

ma.wtd.corNA(data, weights=NULL, vars=NULL, method="unbiased" )

ma.wtd.skewnessNA(data, weights=NULL, vars=NULL, method="unbiased" )

ma.wtd.kurtosisNA(data, weights=NULL, vars=NULL, method="unbiased" )

ma.wtd.quantileNA( data, weights=NULL, vars=NULL, type=7,
          probs=seq(0,1,.25) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma.wtd.statNA_+3A_data">data</code></td>
<td>

<p>Numeric data vector or data frame or objects of one of the
classes <code>datlist</code>,
<code>imputationList</code>, <code>mids</code>, <code>mids.1chain</code>,
<code>nested.datlist</code>,
<code>NestedImputationList</code> or <code>BIFIEdata</code>.
</p>
</td></tr>
<tr><td><code id="ma.wtd.statNA_+3A_weights">weights</code></td>
<td>

<p>Optional vector of sampling weights
</p>
</td></tr>
<tr><td><code id="ma.wtd.statNA_+3A_vars">vars</code></td>
<td>
<p>Optional vector of variable names</p>
</td></tr>
<tr><td><code id="ma.wtd.statNA_+3A_method">method</code></td>
<td>
<p>Computation method for covariances. These amount to
choosing the divisor <code class="reqn">(n-1)</code> (<code>method="unbiased"</code>)
instead of <code class="reqn">n</code> (<code>method="ML"</code>). See
<code><a href="stats.html#topic+cov.wt">stats::cov.wt</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="ma.wtd.statNA_+3A_type">type</code></td>
<td>
<p>Quantile type. This specification follows
<code><a href="TAM.html#topic+weighted_quantile">TAM::weighted_quantile</a></code>
</p>
</td></tr>
<tr><td><code id="ma.wtd.statNA_+3A_probs">probs</code></td>
<td>
<p>Vector of probabilities used for calculation of quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contrary to ordinary <span class="rlang"><b>R</b></span> practice, missing values are ignored in the
calculation of descriptive statistics.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>ma.wtd.meanNA</code> </td><td style="text-align: left;"> weighted means </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ma.wtd.sdNA</code> </td><td style="text-align: left;"> weighted standard deviations </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ma.wtd.covNA</code> </td><td style="text-align: left;"> weighted covariance matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ma.wtd.corNA</code> </td><td style="text-align: left;"> weighted correlation matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ma.wtd.skewnessNA</code> </td><td style="text-align: left;"> weighted skewness </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ma.wtd.kurtosisNA</code> </td><td style="text-align: left;"> weighted (excess) kurtosis </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A vector or a matrix depending on the requested statistic.
</p>


<h3>Note</h3>

<p>If <code>data</code> is of class <code>BIFIEdata</code> and no weights are
specified, sample weights are extracted from the <code>BIFIEdata</code>
object.
</p>


<h3>See Also</h3>

<p>Some functions for weighted statistics:
<code><a href="stats.html#topic+weighted.mean">stats::weighted.mean</a></code>,
<code><a href="stats.html#topic+cov.wt">stats::cov.wt</a></code>,
<code>{Hmisc::wtd.var}</code>,
<code><a href="TAM.html#topic+weighted_quantile">TAM::weighted_quantile</a></code>, ...
</p>
<p>See <code><a href="#topic+micombine.cor">micombine.cor</a></code> for statistical inference of correlation
coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Weighted statistics for a single dataset data.ma01
#############################################################################

data(data.ma01)
dat &lt;- as.matrix(data.ma01[,-c(1:3)])

# weighted mean
ma.wtd.meanNA( dat, weights=data.ma01$studwgt )

# weighted SD
ma.wtd.sdNA( dat, weights=data.ma01$studwgt )

# weighted covariance for selected variables
ma.wtd.covNA( dat, weights=data.ma01$studwgt, vars=c("books","hisei") )

# weighted correlation
ma.wtd.corNA( dat, weights=data.ma01$studwgt )

## Not run: 
# weighted skewness
ma.wtd.skewnessNA( dat[,"books"], weights=data.ma01$studwgt )
# compare with result in TAM
TAM::weighted_skewness( x=dat[,"books"], w=data.ma01$studwgt )

# weighted kurtosis
ma.wtd.kurtosisNA( dat, weights=data.ma01$studwgt, vars=c("books","hisei") )
# compare with TAM
TAM::weighted_kurtosis( dat[,"books"], w=data.ma01$studwgt )
TAM::weighted_kurtosis( dat[,"hisei"], w=data.ma01$studwgt )

#############################################################################
# EXAMPLE 2: Weighted statistics multiply imputed dataset
#############################################################################

library(mitools)
data(data.ma05)
dat &lt;- data.ma05

# do imputations
resp &lt;- dat[, - c(1:2) ]
# object of class mids
imp &lt;- mice::mice( resp, method="norm", maxit=3, m=5 )
# object of class datlist
datlist &lt;- miceadds::mids2datlist( imp )
# object of class imputationList
implist &lt;- mitools::imputationList(datlist)

# weighted means
ma.wtd.meanNA(datlist)
ma.wtd.meanNA(implist)
ma.wtd.meanNA(imp)

# weighted quantiles
ma.wtd.quantileNA( implist, weights=data.ma05$studwgt, vars=c("manote","Dscore"))

#############################################################################
# EXAMPLE 3: Weighted statistics nested multiply imputed dataset
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2   # list of 5 datasets containing 5 plausible values

#** define imputation method and predictor matrix
data &lt;- datlist[[1]]
V &lt;- ncol(data)
# variables
vars &lt;- colnames(data)
# variables not used for imputation
vars_unused &lt;- miceadds::scan.vec("IDSTUD TOTWGT  JKZONE  JKREP" )
#- define imputation method
impMethod &lt;- rep("norm", V )
names(impMethod) &lt;- vars
impMethod[ vars_unused ] &lt;- ""
#- define predictor matrix
predM &lt;- matrix( 1, V, V )
colnames(predM) &lt;- rownames(predM) &lt;- vars
diag(predM) &lt;- 0
predM[, vars_unused ] &lt;- 0

# object of class mids.nmi
imp1 &lt;- miceadds::mice.nmi( datlist, method=impMethod, predictorMatrix=predM,
                m=4, maxit=3 )
# object of class nested.datlist
datlist &lt;- miceadds::mids2datlist(imp1)
# object of class NestedImputationList
imp2 &lt;- miceadds::NestedImputationList(datlist)

# weighted correlations
vars &lt;- c("books","ASMMAT","likesc")
ma.wtd.corNA( datlist,  vars=vars )
ma.wtd.corNA( imp2,  vars=vars )
ma.wtd.corNA( imp1,  vars=vars )

#############################################################################
# EXAMPLE 4: Multiply imputed datasets in BIFIEdata format
#############################################################################

library(BIFIEsurvey)
data(data.timss1, package="BIFIEsurvey")
data(data.timssrep, package="BIFIEsurvey")

# create BIFIEdata object
bdat &lt;- BIFIEsurvey::BIFIE.data( data.list=data.timss1, wgt=data.timss1[[1]]$TOTWGT,
            wgtrep=data.timssrep[, -1 ] )
summary(bdat)
# create BIFIEdata object in a compact way
bdat2 &lt;- BIFIEsurvey::BIFIE.data( data.list=data.timss1, wgt=data.timss1[[1]]$TOTWGT,
            wgtrep=data.timssrep[, -1 ], cdata=TRUE)
summary(bdat2)

# compute skewness
ma.wtd.skewnessNA( bdat, vars=c("ASMMAT", "books" ) )
ma.wtd.skewnessNA( bdat2, vars=c("ASMMAT", "books" ) )

#############################################################################
# EXAMPLE 5: Nested multiply imputed datasets in BIFIEdata format
#############################################################################

data(data.timss4, package="BIFIEsurvey")
data(data.timssrep, package="BIFIEsurvey")

# nested imputed dataset, save it in compact format
bdat &lt;- BIFIE.data( data.list=data.timss4, wgt=data.timss4[[1]][[1]]$TOTWGT,
            wgtrep=data.timssrep[, -1 ], NMI=TRUE, cdata=TRUE )
summary(bdat)
# skewness
ma.wtd.skewnessNA( bdat, vars=c("ASMMAT", "books" ) )

## End(Not run)
</code></pre>

<hr>
<h2 id='mi_dstat'>
Cohen's d Effect Size for Missingness Indicators
</h2><span id='topic+mi_dstat'></span>

<h3>Description</h3>

<p>Computes Cohen's d effect size indicating whether missingness
on a variable is related to other variables (covariates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi_dstat(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi_dstat_+3A_dat">dat</code></td>
<td>

<p>Data frame
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Missingness indicators refer to rows and covariates
to columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: d effect size for missingness indicators data.ma01
#############################################################################

data(data.ma01)
dat &lt;- data.ma01

# compute d effect sizes
md &lt;- miceadds::mi_dstat(dat)
round( md, 3 )
</code></pre>

<hr>
<h2 id='mi.anova'>
Analysis of Variance for Multiply Imputed Data Sets (Using the <code class="reqn">D_2</code> Statistic)
</h2><span id='topic+mi.anova'></span>

<h3>Description</h3>

<p>This function combines <code class="reqn">F</code> values from analysis of variance using
the <code class="reqn">D_2</code> statistic which is based on combining <code class="reqn">\chi^2</code> statistics
(see Allison, 2001, Grund, Luedtke &amp; Robitzsch, 2016;
<code><a href="#topic+micombine.F">micombine.F</a></code>, <code><a href="#topic+micombine.chisquare">micombine.chisquare</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.anova(mi.res, formula, type=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi.anova_+3A_mi.res">mi.res</code></td>
<td>

<p>Object of class <code>mids</code> or <code>mids.1chain</code>
</p>
</td></tr>
<tr><td><code id="mi.anova_+3A_formula">formula</code></td>
<td>

<p>Formula for <code>lm</code> function. Note that this can be also a string.
</p>
</td></tr>
<tr><td><code id="mi.anova_+3A_type">type</code></td>
<td>

<p>Type for ANOVA calculations. For <code>type=3</code>, the
<code><a href="car.html#topic+Anova">car::Anova</a></code> function
from the <span class="pkg">car</span> package is used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries:
</p>
<table>
<tr><td><code>r.squared</code></td>
<td>
<p>Explained variance <code class="reqn">R^2</code></p>
</td></tr>
<tr><td><code>anova.table</code></td>
<td>
<p>ANOVA table</p>
</td></tr>
</table>


<h3>References</h3>

<p>Allison, P. D. (2002). <em>Missing data</em>. Newbury Park, CA: Sage.
</p>
<p>Grund, S., Luedtke, O., &amp; Robitzsch, A. (2016). Pooling ANOVA results from
multiply imputed datasets: A simulation study.
<em>Methodology, 12</em>(3), 75-88.
<a href="https://doi.org/10.1027/1614-2241/a000111">doi:10.1027/1614-2241/a000111</a>
</p>


<h3>See Also</h3>

<p>This function uses <code><a href="#topic+micombine.F">micombine.F</a></code> and
<code><a href="#topic+micombine.chisquare">micombine.chisquare</a></code>.
</p>
<p>See <code><a href="mice.html#topic+pool.compare">mice::pool.compare</a></code> and
<code><a href="mitml.html#topic+testModels">mitml::testModels</a></code> for model
comparisons based on the <code class="reqn">D_1</code> statistic. The <code class="reqn">D_2</code> statistic
is also included in <code><a href="mitml.html#topic+testConstraints">mitml::testConstraints</a></code>.
</p>
<p>The <code class="reqn">D_1</code>, <code class="reqn">D_2</code> and <code class="reqn">D_3</code> statistics are also included in the
<span class="pkg">mice</span> package in functions <code><a href="mice.html#topic+D1">mice::D1</a></code>,
<code><a href="mice.html#topic+D2">mice::D2</a></code> and <code><a href="mice.html#topic+D3">mice::D3</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: nhanes2 data | two-way ANOVA
#############################################################################

library(mice)
library(car)
data(nhanes2, package="mice")
set.seed(9090)

# nhanes data in one chain and 8 imputed datasets
mi.res &lt;- miceadds::mice.1chain( nhanes2, burnin=4, iter=20, Nimp=8 )
# 2-way analysis of variance (type 2)
an2a &lt;- miceadds::mi.anova(mi.res=mi.res, formula="bmi ~ age * chl" )

# test of interaction effects using mitml::testModels()
mod1 &lt;- with( mi.res, stats::lm( bmi ~ age*chl ) )
mod0 &lt;- with( mi.res, stats::lm( bmi ~ age+chl ) )

mitml::testModels(model=mod1$analyses, null.model=mod0$analyses, method="D1")
mitml::testModels(model=mod1$analyses, null.model=mod0$analyses, method="D2")

# 2-way analysis of variance (type 3)
an2b &lt;- miceadds::mi.anova(mi.res=mi.res, formula="bmi ~ age * chl", type=3)

#****** analysis based on first imputed dataset

# extract first dataset
dat1 &lt;- mice::complete( mi.res$mids )

# type 2 ANOVA
lm1 &lt;- stats::lm( bmi ~ age * chl, data=dat1 )
summary( stats::aov( lm1 ) )
# type 3 ANOVA
lm2 &lt;- stats::lm( bmi ~ age * chl, data=dat1, contrasts=list(age=contr.sum))
car::Anova(mod=lm2, type=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice_imputation_2l_lmer'>
Imputation of a Continuous or a Binary Variable From a Two-Level Regression Model
using <span class="pkg">lme4</span> or <span class="pkg">blme</span>
</h2><span id='topic+mice.impute.2l.binary'></span><span id='topic+mice.impute.2l.continuous'></span><span id='topic+mice.impute.2l.pmm'></span>

<h3>Description</h3>

<p>The function <code>mice.impute.2l.continuous</code>
imputes values of continuous variables with a linear
mixed effects model using <code><a href="lme4.html#topic+lmer">lme4::lmer</a></code> or
<code><a href="blme.html#topic+blmer">blme::blmer</a></code>.
The <code><a href="lme4.html#topic+lmer">lme4::lmer</a></code> or
<code><a href="blme.html#topic+blmer">blme::blmer</a></code> function is also
used for predictive mean matching where the match is based
on predicted values which contain the fixed and (sampled)
random effects. Binary variables can be imputed
from a two-level logistic regression model
fitted with the <code><a href="lme4.html#topic+glmer">lme4::glmer</a></code> or
<code><a href="blme.html#topic+bglmer">blme::bglmer</a></code> function.
See Snijders and Bosker (2012) and Zinn (2013) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2l.continuous(y, ry, x, type, intercept=TRUE,
    groupcenter.slope=FALSE, draw.fixed=TRUE, random.effects.shrinkage=1E-6,
    glmer.warnings=TRUE, blme_use=FALSE, blme_args=NULL, ... )

mice.impute.2l.pmm(y, ry, x, type, intercept=TRUE,
    groupcenter.slope=FALSE, draw.fixed=TRUE, random.effects.shrinkage=1E-6,
    glmer.warnings=TRUE, donors=5, match_sampled_pars=TRUE,
    blme_use=FALSE, blme_args=NULL, ... )

mice.impute.2l.binary(y, ry, x, type, intercept=TRUE,
    groupcenter.slope=FALSE, draw.fixed=TRUE, random.effects.shrinkage=1E-6,
    glmer.warnings=TRUE, blme_use=FALSE, blme_args=NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice_imputation_2l_lmer_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete predictors.
</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_type">type</code></td>
<td>
<p>Type of predictor variable. The cluster identifier
has type <code>-2</code>, fixed effects predictors without a random slope
type <code>1</code> and predictors with fixed effects and random effects
have type <code>2</code>. If the cluster mean should be included for a covariate,
<code>3</code> should be chosen. The specification <code>4</code> includes the cluster mean,
the fixed effect and the random effect.</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_intercept">intercept</code></td>
<td>

<p>Optional logical indicating whether the intercept should be included.
</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_groupcenter.slope">groupcenter.slope</code></td>
<td>
<p>Optional logical indicating whether covariates
should be centered around group means</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_draw.fixed">draw.fixed</code></td>
<td>
<p>Optional logical indicating whether fixed effects
parameter should be randomly drawn</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_random.effects.shrinkage">random.effects.shrinkage</code></td>
<td>
<p>Shrinkage parameter for stabilizing the
covariance matrix of random effects</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_glmer.warnings">glmer.warnings</code></td>
<td>
<p>Optional logical indicating whether warnings from
<code>glmer</code> should be displayed</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_blme_use">blme_use</code></td>
<td>
<p>Logical indicating whether the <span class="pkg">blme</span>
package should be used.</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_blme_args">blme_args</code></td>
<td>
<p>(Prior) Arguments for <span class="pkg">blme</span>, see
<code><a href="blme.html#topic+blmer">blme::blmer</a></code> and
<code><a href="blme.html#topic+bmerDist-class">blme::bmerDist-class</a></code>.
</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_donors">donors</code></td>
<td>
<p>Number of donors used for predictive mean matching</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_match_sampled_pars">match_sampled_pars</code></td>
<td>
<p>Logical indicating whether values of nearest
neighbors should also be sampled in pmm imputation.</p>
</td></tr>
<tr><td><code id="mice_imputation_2l_lmer_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Bosker, R. J. (2012). <em>Multilevel analysis:
An introduction to basic and advanced multilevel modeling</em>.
Thousand Oaks, CA: Sage.
</p>
<p>Zinn, S. (2013). <em>An imputation model for multilevel binary data</em>.
NEPS Working Paper No 31.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mice.impute.ml.lmer">mice.impute.ml.lmer</a></code> for imputation for datasets with more than
two levels (e.g., three-level datasets or cross-classified datasets).
</p>
<p>Variables at a higher level (e.g. at level 2) can be imputed using <code>2lonly</code>
functions, for example the
<code><a href="mice.html#topic+mice.impute.2lonly.norm">mice::mice.impute.2lonly.norm</a></code> function
in the <span class="pkg">mice</span> package or the general <code><a href="#topic+mice.impute.2lonly.function">mice.impute.2lonly.function</a></code>
function in the <span class="pkg">miceadds</span> package which using an already defined imputation
method at level 1. If a level-2 variable for 3-level data should be imputed,
then <code><a href="#topic+mice.impute.ml.lmer">mice.impute.ml.lmer</a></code> can also be used to impute this variable
with a two-level imputation model in which level 1 corresponds to the original
level-2 units and level 2 corresponds to the original level-3 units.
</p>
<p>See <code><a href="mice.html#topic+mice.impute.2l.norm">mice::mice.impute.2l.norm</a></code> and
<code><a href="mice.html#topic+mice.impute.2l.pan">mice::mice.impute.2l.pan</a></code> for
imputation functions in the <span class="pkg">mice</span> package under fully conditional
specification for normally distributed variables. The function
<code><a href="mice.html#topic+mice.impute.2l.norm">mice::mice.impute.2l.norm</a></code> allows for
residual variances which are allowed to vary across groups while
<code><a href="mice.html#topic+mice.impute.2l.pan">mice::mice.impute.2l.pan</a></code> assumes
homogeneous residual variances.
</p>
<p>The <span class="pkg">micemd</span> package provides further imputation methods for the <span class="pkg">mice</span>
package for imputing multilevel data with fully conditional specification. The
function <code>micemd::mice.impute.2l.jomo</code>
has similar functionality like <code><a href="mice.html#topic+mice.impute.2l.pan">mice::mice.impute.2l.pan</a></code>
and imputes normally distributed two-level data with a Bayesian MCMC approach,
but relies on the <span class="pkg">jomo</span> package instead of the <span class="pkg">pan</span> package.
The functions <code><a href="mice.html#topic+mice.impute.2l.lmer">mice::mice.impute.2l.lmer</a></code> and
<code>micemd::mice.impute.2l.glm.norm</code>
have similar functionality like <code><a href="#topic+mice.impute.2l.continuous">mice.impute.2l.continuous</a></code>
and imputes normally distributed two-level data. The function
<code>{micemd::mice.impute.2l.glm.bin}</code>
has similar functionality like <code><a href="#topic+mice.impute.2l.binary">mice.impute.2l.binary</a></code>
and imputes binary two-level data.
</p>
<p>The <span class="pkg">hmi</span> package imputes single-level and multilevel data and is also
based on fully conditional specification. The package relies on the
MCMC estimation implemented in the <span class="pkg">MCMCglmm</span> package. The imputation procedure
can be run with the <code>hmi::hmi</code> function.
</p>
<p>See the <span class="pkg">pan</span> (<code><a href="pan.html#topic+pan">pan::pan</a></code>)
and the <span class="pkg">jomo</span> (<code><a href="jomo.html#topic+jomo">jomo::jomo</a></code>)
package for joint multilevel imputation. See
<code><a href="mitml.html#topic+panImpute">mitml::panImpute</a></code> and
<code><a href="mitml.html#topic+jomoImpute">mitml::jomoImpute</a></code> for
wrapper functions to these packages in the <span class="pkg">mitml</span>
package.
</p>
<p>Imputation by chained equations can also be conducted in blocks of multivariate
conditional distributions since <span class="pkg">mice</span> 3.0.0 (see the <code>blocks</code>
argument in <code><a href="mice.html#topic+mice">mice::mice</a></code>). The
<code><a href="mitml.html#topic+panImpute">mitml::panImpute</a></code> and
<code><a href="mitml.html#topic+jomoImpute">mitml::jomoImpute</a></code> functions can be used
with <code><a href="mice.html#topic+mice">mice::mice</a></code> by specifying imputation
methods <code>"panImpute"</code>
(see <code><a href="mice.html#topic+mice.impute.panImpute">mice::mice.impute.panImpute</a></code>)) and
<code>"jomoImpute"</code>
(see <code><a href="mice.html#topic+mice.impute.jomoImpute">mice::mice.impute.jomoImpute</a></code>)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation of a binary variable
#############################################################################

#--- simulate missing values
set.seed(976)
G &lt;- 30        # number of groups
n &lt;- 8        # number of persons per group
iccx &lt;- .2    # intra-class correlation X
iccy &lt;- .3    # latent intra-class correlation binary outcome
bx &lt;- .4    # regression coefficient
threshy &lt;- stats::qnorm(.70)  # threshold for y
x &lt;- rep( rnorm( G, sd=sqrt( iccx) ), each=n )  +
            rnorm(G*n, sd=sqrt( 1 - iccx) )
y &lt;- bx * x + rep( rnorm( G, sd=sqrt( iccy) ), each=n )  +
                rnorm(G*n, sd=sqrt( 1 - iccy) )
y &lt;- 1 * ( y &gt; threshy )
dat &lt;- data.frame( group=100+rep(1:G, each=n), x=x, y=y )

#* create some missings
dat1 &lt;- dat
dat1[ seq( 1, G*n, 3 ),"y" ]  &lt;- NA
dat1[ dat1$group==2, "y" ] &lt;- NA

#--- prepare imputation in mice
vars &lt;- colnames(dat1)
V &lt;- length(vars)
#* predictor matrix
predmat &lt;- matrix( 0, nrow=V, ncol=V)
rownames(predmat) &lt;- colnames(predmat) &lt;- vars
predmat["y", ] &lt;- c(-2,2,0)
#* imputation methods
impmeth &lt;- rep("",V)
names(impmeth) &lt;- vars
impmeth["y"] &lt;- "2l.binary"

#** imputation with logistic regression ('2l.binary')
imp1 &lt;- mice::mice( data=as.matrix(dat1), method=impmeth,
                predictorMatrix=predmat, maxit=1, m=5 )

#** imputation with predictive mean matching ('2l.pmm')
impmeth["y"] &lt;- "2l.pmm"
imp2 &lt;- mice::mice( data=as.matrix(dat1), method=impmeth,
                predictorMatrix=predmat, maxit=1, m=5 )

#** imputation with logistic regression using blme package
blme_args &lt;- list( "cov.prior"="invwishart")
imp3 &lt;- mice::mice( data=as.matrix(dat1), method=impmeth,
                predictorMatrix=predmat, maxit=1, m=5,
                blme_use=TRUE, blme_args=blme_args )

## End(Not run)
</code></pre>

<hr>
<h2 id='mice_inits'>
Arguments for <code>mice::mice</code> Function
</h2><span id='topic+mice_inits'></span>

<h3>Description</h3>

<p>Defines initial arguments of imputation method and
predictor matrix for <code>mice::mice</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice_inits(dat, ignore=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice_inits_+3A_dat">dat</code></td>
<td>

<p>Dataset
</p>
</td></tr>
<tr><td><code id="mice_inits_+3A_ignore">ignore</code></td>
<td>

<p>Vector of variables which should be ignored in imputation
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with entries
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>Imputation method</p>
</td></tr>
<tr><td><code>predictorMatrix</code></td>
<td>
<p>Predictor matrix</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="mice.html#topic+make.predictorMatrix">mice::make.predictorMatrix</a></code> and
<code><a href="mice.html#topic+make.method">mice::make.method</a></code> for generating an initial predictor matrix
and a vector of imputation methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Inits for mice imputation
#############################################################################

data(data.ma04, package="miceadds")
dat &lt;- data.ma04

res &lt;- miceadds::mice_inits(dat, ignore=c("group") )
str(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.1chain'>
Multiple Imputation by Chained Equations using One Chain
</h2><span id='topic+mice.1chain'></span><span id='topic+summary.mids.1chain'></span><span id='topic+plot.mids.1chain'></span><span id='topic+print.mids.1chain'></span>

<h3>Description</h3>

<p>This function modifies the <code><a href="mice.html#topic+mice">mice::mice</a></code> function to
multiply impute a dataset using a long chain instead of multiple parallel chains
which is the approach employed in <code>mice::mice</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.1chain(data, burnin=10, iter=20, Nimp=10, method=NULL,
     where=NULL, visitSequence=NULL, blots=NULL, post=NULL,
     defaultMethod=c("pmm", "logreg", "polyreg", "polr"),
     printFlag=TRUE, seed=NA, data.init=NULL, ...)

## S3 method for class 'mids.1chain'
summary(object,...)

## S3 method for class 'mids.1chain'
print(x, ...)

## S3 method for class 'mids.1chain'
plot(x, plot.burnin=FALSE, ask=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.1chain_+3A_data">data</code></td>
<td>

<p>Numeric matrix
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_burnin">burnin</code></td>
<td>

<p>Number of burn-in iterations
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_iter">iter</code></td>
<td>

<p>Total number of imputations (larger than <code>burnin</code>)
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_nimp">Nimp</code></td>
<td>

<p>Number of imputations
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_method">method</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_where">where</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_visitsequence">visitSequence</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_blots">blots</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_post">post</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_defaultmethod">defaultMethod</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_printflag">printFlag</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_seed">seed</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_data.init">data.init</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_object">object</code></td>
<td>
<p>Object of class <code>mids.1chain</code></p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_x">x</code></td>
<td>
<p>Object of class <code>mids.1chain</code></p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_plot.burnin">plot.burnin</code></td>
<td>
<p>An optional logical indicating whether burnin iterations
should be included in the traceplot</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_ask">ask</code></td>
<td>
<p>An optional logical indicating a user request for viewing next plot</p>
</td></tr>
<tr><td><code id="mice.1chain_+3A_...">...</code></td>
<td>

<p>See <code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table>
<tr><td><code>midsobj</code></td>
<td>
<p>Objects of class <code>mids</code></p>
</td></tr>
<tr><td><code>datlist</code></td>
<td>
<p>List of multiply imputed datasets</p>
</td></tr>
<tr><td><code>datalong</code></td>
<td>
<p>Original and imputed dataset in the long format</p>
</td></tr>
<tr><td><code>implist</code></td>
<td>
<p>List of <code>mids</code> objects for every imputation</p>
</td></tr>
<tr><td><code>chainMpar</code></td>
<td>
<p>Trace of means for all imputed variables</p>
</td></tr>
<tr><td><code>chainVarpar</code></td>
<td>
<p>Trace of variances for all imputed variables</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Multiple imputation can also be used for determining causal effects
(see Example 3; Schafer &amp; Kang, 2008).
</p>


<h3>See Also</h3>

<p><code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#############################################################################
# EXAMPLE 1: One chain nhanes data
#############################################################################

library(mice)
data(nhanes, package="mice")
set.seed(9090)

# nhanes data in one chain
imp.mi1 &lt;- miceadds::mice.1chain( nhanes, burnin=5, iter=40, Nimp=4,
                 method=rep("norm", 4 ) )
summary(imp.mi1)       # summary of mids.1chain
plot( imp.mi1 ) # trace plot excluding burnin iterations
plot( imp.mi1, plot.burnin=TRUE ) # trace plot including burnin iterations

# select mids object
imp.mi2 &lt;- imp.mi1$midsobj
summary(imp.mi2)    # summary of mids

# apply mice functionality lm.mids
mod &lt;- with( imp.mi2, stats::lm( bmi ~ age ) )
summary( mice::pool( mod ) )

#############################################################################
# EXAMPLE 2: One chain (mixed data: numeric and factor)
#############################################################################

library(mice)
data(nhanes2, package="mice")
set.seed(9090)

# nhanes2 data in one chain
imp.mi1 &lt;- miceadds::mice.1chain( nhanes2, burnin=5, iter=25, Nimp=5 )
# summary
summary( imp.mi1$midsobj )

#############################################################################
# EXAMPLE 3: Multiple imputation with counterfactuals for estimating
#            causal effects (average treatment effects)
# Schafer, J. L., &amp; Kang, J. (2008). Average causal effects from nonrandomized
#    studies: a practical guide and simulated example.
#    Psychological Methods, 13, 279-313.
#############################################################################

data(data.ma01)
dat &lt;- data.ma01[, 4:11]

# define counterfactuals for reading score for students with and
# without migrational background
dat$read.migrant1 &lt;- ifelse( paste(dat$migrant)==1, dat$read, NA )
dat$read.migrant0 &lt;- ifelse( paste(dat$migrant)==0, dat$read, NA )

# define imputation method
impmethod &lt;- rep("pls", ncol(dat) )
names(impmethod) &lt;- colnames(dat)

# define predictor matrix
pm &lt;- 4*(1 - diag( ncol(dat) ) )    # 4 - use all interactions
rownames(pm) &lt;- colnames(pm) &lt;- colnames(dat)
pm[ c( "read.migrant0", "read.migrant1"), ] &lt;- 0
# do not use counterfactuals for 'read' as a predictor
pm[, "read.migrant0"] &lt;- 0
pm[, "read.migrant1"] &lt;- 0
# define control variables for creation of counterfactuals
pm[ c( "read.migrant0", "read.migrant1"), c("hisei","paredu","female","books") ] &lt;- 4
  ##   &gt; pm
  ##                 math read migrant books hisei paredu female urban read.migrant1 read.migrant0
  ##   math             0    4       4     4     4      4      4     4             0             0
  ##   read             4    0       4     4     4      4      4     4             0             0
  ##   migrant          4    4       0     4     4      4      4     4             0             0
  ##   books            4    4       4     0     4      4      4     4             0             0
  ##   hisei            4    4       4     4     0      4      4     4             0             0
  ##   paredu           4    4       4     4     4      0      4     4             0             0
  ##   female           4    4       4     4     4      4      0     4             0             0
  ##   urban            4    4       4     4     4      4      4     0             0             0
  ##   read.migrant1    0    0       0     4     4      4      4     0             0             0
  ##   read.migrant0    0    0       0     4     4      4      4     0             0             0

# imputation using mice function and PLS imputation with
# predictive mean matching method 'pmm6'
imp &lt;- mice::mice( dat, method=impmethod, predictorMatrix=pm,
            maxit=4, m=5, pls.impMethod="pmm5" )

#*** Model 1: Raw score difference
mod1 &lt;- with( imp, stats::lm( read ~ migrant ) )
smod1 &lt;- summary( mice::pool(mod1) )
  ##   &gt; smod1
  ##                  est    se      t     df Pr(&gt;|t|)  lo 95  hi 95 nmis    fmi lambda
  ##   (Intercept) 510.21 1.460 349.37 358.26        0 507.34 513.09   NA 0.1053 0.1004
  ##   migrant     -43.38 3.757 -11.55  62.78        0 -50.89 -35.87  404 0.2726 0.2498

#*** Model 2: ANCOVA - regression adjustment
mod2 &lt;- with( imp, stats::lm( read ~ migrant + hisei + paredu + female + books) )
smod2 &lt;- summary( mice::pool(mod2) )
  ##   &gt; smod2
  ##                    est      se      t      df  Pr(&gt;|t|)    lo 95   hi 95 nmis      fmi   lambda
  ##   (Intercept) 385.1506 4.12027 93.477 3778.66 0.000e+00 377.0725 393.229   NA 0.008678 0.008153
  ##   migrant     -29.1899 3.30263 -8.838   87.46 9.237e-14 -35.7537 -22.626  404 0.228363 0.210917
  ##   hisei         0.9401 0.08749 10.745  160.51 0.000e+00   0.7673   1.113  733 0.164478 0.154132
  ##   paredu        2.9305 0.79081  3.706   41.34 6.190e-04   1.3338   4.527  672 0.339961 0.308780
  ##   female       38.1719 2.26499 16.853 1531.31 0.000e+00  33.7291  42.615    0 0.041093 0.039841
  ##   books        14.0113 0.88953 15.751  154.71 0.000e+00  12.2541  15.768  423 0.167812 0.157123

#*** Model 3a: Estimation using counterfactuals
mod3a &lt;- with( imp, stats::lm( I( read.migrant1 - read.migrant0) ~ 1 ) )
smod3a &lt;- summary( mice::pool(mod3a) )
  ##   &gt; smod3a
  ##                  est    se      t    df Pr(&gt;|t|)  lo 95  hi 95 nmis    fmi lambda
  ##   (Intercept) -22.54 7.498 -3.007 4.315  0.03602 -42.77 -2.311   NA 0.9652 0.9521

#*** Model 3b: Like Model 3a but using student weights
mod3b &lt;- with( imp, stats::lm( I( read.migrant1 - read.migrant0) ~ 1,
                        weights=data.ma01$studwgt ) )
smod3b &lt;- summary( mice::pool(mod3b) )
  ##   &gt; smod3b
  ##                  est    se      t  df Pr(&gt;|t|)  lo 95  hi 95 nmis    fmi lambda
  ##   (Intercept) -21.88 7.605 -2.877 4.3  0.04142 -42.43 -1.336   NA 0.9662 0.9535

#*** Model 4: Average treatment effect on the treated (ATT, migrants)
#             and non-treated (ATN, non-migrants)
mod4 &lt;- with( imp, stats::lm( I( read.migrant1 - read.migrant0) ~ 0 + as.factor( migrant) )   )
smod4 &lt;- summary( mice::pool(mod4) )
  ##   &gt; smod4
  ##                          est    se      t    df Pr(&gt;|t|)  lo 95   hi 95 nmis    fmi lambda
  ##   as.factor(migrant)0 -23.13 8.664 -2.669  4.27 0.052182 -46.59  0.3416   NA 0.9682 0.9562
  ##   as.factor(migrant)1 -19.95 5.198 -3.837 19.57 0.001063 -30.81 -9.0884   NA 0.4988 0.4501
# ATN=-23.13 and ATT=-19.95

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.2l.contextual.pmm'>
Imputation by Predictive Mean Matching or Normal Linear Regression
with Contextual Variables
</h2><span id='topic+mice.impute.2l.contextual.pmm'></span><span id='topic+mice.impute.2l.contextual.norm'></span>

<h3>Description</h3>

<p>This imputation method imputes a variable using linear regression
with predictive mean matching as the imputation method.
Including a contextual effects means that an aggregated variable at a cluster
level is included as a further covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2l.contextual.pmm(y, ry, x, type, imputationWeights=NULL,
     interactions=NULL, quadratics=NULL, pls.facs=NULL, ...)

mice.impute.2l.contextual.norm(y, ry, x, type, ridge=10^(-5),
   imputationWeights=NULL, interactions=NULL, quadratics=NULL, pls.facs=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_type">type</code></td>
<td>

<p>Type of predictor variables. <code>type=-2</code> refers to the cluster variable,
<code>type=2</code> denotes a variable for which also a contextual effect is
included and <code>type=1</code> denotes all other variables which are
included as 'ordinary' predictors.
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_imputationweights">imputationWeights</code></td>
<td>

<p>Optional vector of sample weights
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_interactions">interactions</code></td>
<td>

<p>Vector of variable names used for creating interactions
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_quadratics">quadratics</code></td>
<td>

<p>Vector of variable names used for creating quadratic terms
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_pls.facs">pls.facs</code></td>
<td>
<p>Number of factors used in partial least dimension reduction
(if requested)</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.contextual.pmm_+3A_ridge">ridge</code></td>
<td>

<p>Ridge parameter in the diagonal of <code class="reqn"> \bold{X}'\bold{X}</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>See Also</h3>

<p>For imputations at level 2 variables see
<code><a href="mice.html#topic+mice.impute.2lonly.norm">mice::mice.impute.2lonly.norm</a></code>
and <code><a href="mice.html#topic+mice.impute.2lonly.pmm">mice::mice.impute.2lonly.pmm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Sequential hierarchical imputation for data.ma05 dataset
#############################################################################

data(data.ma05)
dat &lt;- data.ma05

# define predictor matrix
predM &lt;- mice::make.predictorMatrix(data=dat)
# exclude student IDs
predM[, "idstud"] &lt;- 0
# define idclass as the cluster variable (type=-2)
predM[, "idclass" ] &lt;- -2

# initialize with norm method
impMethod &lt;- mice::make.method(data=dat)
names(impMethod) &lt;- names( imp0$method )
impMethod[ c("idstud","idclass")] &lt;- ""

#*****
# STUDENT LEVEL (Level 1)

# Use a random slope model for Dscore and Mscore as the imputation method.
# Here, variance homogeneity of residuals is assumed (contrary to
# the 2l.norm imputation method in the mice package).
impMethod[ c("Dscore", "Mscore") ] &lt;- "2l.pan"
predM[ c("Dscore","Mscore"), "misei" ] &lt;- 2    # random slopes on 'misei'
predM[, "idclass" ] &lt;- -2

# For imputing 'manote' and 'denote' use contextual effects (i.e. cluszer means)
# of variables 'misei' and 'migrant'
impMethod[ c("denote", "manote") ] &lt;- "2l.contextual.pmm"
predM[ c("denote", "manote"), c("misei","migrant")] &lt;- 2

# Use no cluster variable 'idclass' for imputation of 'misei'
impMethod[ "misei"] &lt;- "norm"
predM[ "misei", "idclass"] &lt;- 0 # use no multilevel imputation model

# Variable migrant: contextual effects of Dscore and misei
impMethod[ "migrant"] &lt;- "2l.contextual.pmm"
predM[ "migrant", c("Dscore",  "misei" ) ] &lt;- 2
predM[ "migrant", "idclass" ] &lt;- -2

#****
# CLASS LEVEL (Level 2)
# impute 'sprengel' and 'groesse' at the level of classes
impMethod[ "sprengel"] &lt;- "2lonly.pmm"
impMethod[ "groesse"] &lt;- "2lonly.norm"
predM[ c("sprengel","groesse"), "idclass" ] &lt;- -2

# do imputation
imp &lt;- mice::mice( dat, predictorMatrix=predM, m=3,  maxit=4,
           method=impMethod, paniter=100)
summary(imp)

#**** imputation model 2 with PLS dimension reduction

# define some interaction effects
interactions &lt;- list( manote=c("migrant", "misei") )
# number of PLS factors (5 factors)
pls.facs &lt;- list( manote=5 )

# do imputation
imp2 &lt;- mice::mice( dat, predictorMatrix=predM, interactions=interactions,
            pls.facs=pls.facs, method=impMethod, paniter=100)
summary(imp2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.2l.latentgroupmean.ml'>
Imputation of Latent and Manifest Group Means for Multilevel Data
</h2><span id='topic+mice.impute.2l.latentgroupmean.ml'></span><span id='topic+mice.impute.2l.latentgroupmean.mcmc'></span><span id='topic+mice.impute.2l.groupmean'></span><span id='topic+mice.impute.2l.groupmean.elim'></span>

<h3>Description</h3>

<p>The imputation method <code>2l.latentgroupmean</code> imputes a latent group mean
assuming an infinite population of subjects within a group
(Grund, Luedtke &amp; Robitzsch, 2018; see also
Luedtke, Marsh, Robitzsch, Trautwein, Asparouhov &amp; Muthen, 2008
or Croon &amp; van Veldhoven, 2007).
Therefore, unreliability of group means when treating subjects as
indicators is taken into account.
</p>
<p>The imputation method <code>mice.impute.2l.groupmean</code> just imputes (i.e. computes)
the manifest group mean. See also
<code><a href="mice.html#topic+mice.impute.2lonly.mean">mice::mice.impute.2lonly.mean</a></code>.
</p>
<p>The imputation method <code>mice.impute.2l.groupmean.elim</code> computes the
group mean eliminating the subject under study from the calculation.
Therefore, this imputation method will lead to different values of
individuals within the same group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2l.latentgroupmean.ml(y, ry, x, type, pls.facs=NULL,
    imputationWeights=NULL, interactions=NULL, quadratics=NULL,
    EAP=FALSE, ...)

mice.impute.2l.latentgroupmean.mcmc(y, ry, x, type, pls.facs=NULL,
    imputationWeights=NULL, interactions=NULL, quadratics=NULL,
    mcmc.burnin=100, mcmc.adapt=100, mcmc.iter=1000, draw.fixed=TRUE, EAP=FALSE, ...)

mice.impute.2l.groupmean(y, ry, x, type, grmeanwarning=TRUE, ...)

mice.impute.2l.groupmean.elim(y, ry, x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_type">type</code></td>
<td>

<p>Type of predictor variables. <code>type=-2</code> refers to the cluster variable,
<code>type=2</code> denotes a variable for which also a (latent) group mean
should be calculated. Predictors with <code>type=1</code> denote all other variables.
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_pls.facs">pls.facs</code></td>
<td>

<p>Number of factors used for PLS regression (optional).
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_imputationweights">imputationWeights</code></td>
<td>

<p>Optional vector of sample weights.
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_interactions">interactions</code></td>
<td>

<p>Vector of variable names used for creating interactions
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_quadratics">quadratics</code></td>
<td>

<p>Vector of variable names used for creating quadratic terms
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_draw.fixed">draw.fixed</code></td>
<td>
<p>Optional logical indicating whether parameters for fixed
effects should be sampled.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_eap">EAP</code></td>
<td>
<p>Logical indicating whether EAPs should be used for imputation.
The default <code>FALSE</code> corresponds to sampling from the posterior
distribution.
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_mcmc.burnin">mcmc.burnin</code></td>
<td>
<p>Number of MCMC burn-in iterations.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_mcmc.adapt">mcmc.adapt</code></td>
<td>
<p>Number of MCMC iterations in adaptation phase.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_mcmc.iter">mcmc.iter</code></td>
<td>
<p>Total number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_grmeanwarning">grmeanwarning</code></td>
<td>

<p>An optional logical indicating whether some group means cannot be calculated.
</p>
</td></tr>
<tr><td><code id="mice.impute.2l.latentgroupmean.ml_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The imputation of the latent group mean uses the
<code><a href="lme4.html#topic+lmer">lme4::lmer</a></code> function of the <span class="pkg">lme4</span> package
for <code>mice.impute.2l.latentgroupmean.ml</code> and the
<code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm::MCMCglmm</a></code> function
of the <span class="pkg">MCMCglmm</span> package for <code>mice.impute.2l.latentgroupmean.ml</code>.
Latent group mean imputation also follows
Mislevy (1991).
</p>


<h3>Value</h3>

<p>A vector of length <code>y</code> containing imputed group means.
</p>


<h3>References</h3>

<p>Croon, M. A., &amp; van Veldhoven, M. J. (2007). Predicting group-level outcome
variables from variables measured at the individual level: a latent variable
multilevel model. <em>Psychological Methods, 12</em>(1), 45-57.
<a href="https://doi.org/10.1037/1082-989X.12.1.45">doi:10.1037/1082-989X.12.1.45</a>
</p>
<p>Grund, S., Luedtke, O., &amp; Robitzsch, A. (2018). Multiple imputation of missing data at
level 2: A comparison of fully conditional and joint modeling in multilevel designs.
<em>Journal of Educational and Behavioral Statistics, 43</em>(3), 316-353.
<a href="https://doi.org/10.3102/1076998617738087">doi:10.3102/1076998617738087</a>
</p>
<p>Luedtke, O., Marsh, H. W., Robitzsch, A., Trautwein, U., Asparouhov, T., &amp;
Muthen, B. (2008). The multilevel latent covariate model: a new, more
reliable approach to group-level effects in contextual studies.
<em>Psychological Methods, 13</em>(3), 203-229.
<a href="https://doi.org/10.1037/a0012869">doi:10.1037/a0012869</a>
</p>
<p>Mislevy, R. J. (1991). Randomization-based inference about latent variables
from complex samples. <em>Psychometrika, 56</em>(2), 177-196.
<a href="https://doi.org/10.1007/BF02294457">doi:10.1007/BF02294457</a>
</p>


<h3>See Also</h3>

<p><code><a href="mice.html#topic+mice.impute.2lonly.mean">mice::mice.impute.2lonly.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Two-level imputation data.ma05 dataset with imputation
#            of a latent group mean
#############################################################################

data(data.ma05)
dat &lt;- data.ma05

# include manifest group mean for 'Mscore'
dat$M.Mscore &lt;- NA
# include latent group group for 'Mscore'
dat$LM.Mscore &lt;- NA    #=&gt; LM: latent group mean

# define predictor matrix
predM &lt;- mice::make.predictorMatrix(data=dat)
# exclude student ISs
predM[, "idstud"] &lt;- 0
# idclass is the cluster identifier
predM[, "idclass" ] &lt;- -2

# define imputation methods
impMethod &lt;- mice::make.method(data=dat)
# initialize with norm
impMethod &lt;- rep( "norm", length(impMethod) )
names(impMethod) &lt;- names( imp$method )
impMethod[ c("idstud","idclass")] &lt;- ""

#*****
# STUDENT LEVEL (Level 1)

# Use a random slope model for Dscore and Mscore as the imputation method.
# Here, variance homogeneity of residuals is assumed (contrary to
# the 2l.norm imputation method in the mice package).
impMethod[ c("Dscore", "Mscore") ] &lt;- "2l.pan"
predM[ c("Dscore","Mscore"), "misei" ] &lt;- 2    # random slopes on 'misei'
predM[, "idclass" ] &lt;- -2

# For imputing 'manote' and 'denote' use contextual effects (i.e. cluster means)
# of variables 'misei' and 'migrant'
impMethod[ c("denote", "manote") ] &lt;- "2l.contextual.pmm"
predM[ c("denote", "manote"), c("misei","migrant")] &lt;- 2

# Use no cluster variable 'idclass' for imputation of 'misei'
impMethod[ "misei"] &lt;- "norm"
predM[ "misei", "idclass"] &lt;- 0 # use no multilevel imputation model

# Variable migrant: contextual effects of Dscore and misei
impMethod[ "migrant"] &lt;- "2l.contextual.pmm"
predM[ "migrant", c("Dscore",  "misei" ) ] &lt;- 2
predM[ "migrant", "idclass" ] &lt;- -2

#****
# CLASS LEVEL (Level 2)
# impute 'sprengel' and 'groesse' at the level of classes
impMethod[ "sprengel"] &lt;- "2lonly.pmm2"
impMethod[ "groesse"] &lt;- "2lonly.norm2"
predM[ c("sprengel","groesse"), "idclass" ] &lt;- -2

# manifest group mean for Mscore
impMethod[ "M.Mscore" ] &lt;- "2l.groupmean"
# latent group mean for Mscore
impMethod[ "LM.Mscore" ] &lt;- "2l.latentgroupmean.ml"
predM[ "M.Mscore", "Mscore" ] &lt;- 2

# covariates for latent group mean of 'Mscore'
predM[ "LM.Mscore", "Mscore" ] &lt;- 2
predM[ "LM.Mscore", c( "Dscore", "sprengel" ) ] &lt;- 1

# do imputations
imp &lt;- mice::mice( dat, predictorMatrix=predM, m=3,  maxit=4,
         method=impMethod, allow.na=TRUE, pan.iter=100)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.2lonly.function'>Imputation at Level 2 (in <span class="pkg">miceadds</span>)</h2><span id='topic+mice.impute.2lonly.function'></span>

<h3>Description</h3>

<p>The imputation method <code>mice.impute.2lonly.function</code> is a general
imputation function for level 2 imputation which allow any
defined imputation function at level 1 in <span class="pkg">mice</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.2lonly.function(y, ry, x, wy=NULL, type, imputationFunction,
     cluster_var, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.2lonly.function_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.function_+3A_ry">ry</code></td>
<td>
<p>Vector of missing data pattern
(<code>FALSE</code>=missing, <code>TRUE</code>=observed)</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.function_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete
covariates. Only numeric variables are permitted for
usage of this function.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.function_+3A_wy">wy</code></td>
<td>
<p>Logical vector of <code>length(y)</code> indicating at which positions
imputations should be conducted.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.function_+3A_type">type</code></td>
<td>
<p>Cluster identifier can be specified by <code>-2</code> for aggregation. However,
we recommend to use the argument <code>cluster_var</code> for specifying the cluster variable
at Level 2. Predictors must be specified by <code>1</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.function_+3A_imputationfunction">imputationFunction</code></td>
<td>
<p>Imputation function for <span class="pkg">mice</span>. Any
imputation method which is defined at level 1 can be used
for level 2 imputation.
</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.function_+3A_cluster_var">cluster_var</code></td>
<td>
<p>Cluster identifier for Level 2 units</p>
</td></tr>
<tr><td><code id="mice.impute.2lonly.function_+3A_...">...</code></td>
<td>
<p>Other named arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis</code> with imputations.
</p>


<h3>See Also</h3>

<p>See <code><a href="mice.html#topic+mice.impute.2lonly.norm">mice::mice.impute.2lonly.norm</a></code> and
the <code><a href="mice.html#topic+mice.impute.2lonly.pmm">mice::mice.impute.2lonly.pmm</a></code>
function.
</p>
<p>See also the <span class="pkg">jomo</span> package (<code><a href="jomo.html#topic+jomo2">jomo::jomo2</a></code>)
for joint multilevel imputation of level 1 and
level 2 variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation of level 2 variables
#############################################################################

#**** Simulate some data
# x,y ... level 1 variables
# v,w ... level 2 variables

set.seed(987)
G &lt;- 250            # number of groups
n &lt;- 20             # number of persons
beta &lt;- .3          # regression coefficient
rho &lt;- .30          # residual intraclass correlation
rho.miss &lt;- .10     # correlation with missing response
missrate &lt;- .50     # missing proportion
y1 &lt;- rep( stats::rnorm( G, sd=sqrt(rho)), each=n ) + stats::rnorm(G*n, sd=sqrt(1-rho))
w &lt;- rep( round( stats::rnorm(G ), 2 ), each=n )
v &lt;- rep( round( stats::runif( G, 0, 3 ) ), each=n )
x &lt;-  stats::rnorm( G*n )
y &lt;- y1 + beta  * x + .2 * w + .1 * v
dfr0 &lt;- dfr &lt;- data.frame( "group"=rep(1:G, each=n ), "x"=x, "y"=y,
        "w"=w, "v"=v )
dfr[ rho.miss * x + stats::rnorm( G*n, sd=sqrt( 1 - rho.miss ) ) &lt;
                stats::qnorm(missrate), "y" ] &lt;- NA
dfr[ rep( stats::rnorm(G), each=n ) &lt; stats::qnorm(missrate), "w" ] &lt;- NA
dfr[ rep( stats::rnorm(G), each=n ) &lt; stats::qnorm(missrate), "v" ] &lt;- NA

#* initial predictor matrix and imputation methods
predM &lt;- mice::make.predictorMatrix(data=dfr)
impM &lt;- mice::make.method(data=dfr)

#...
# multilevel imputation
predM1 &lt;- predM
predM1[c("w","v","y"),"group"] &lt;- c(0,0,-2)
predM1["y","x"] &lt;- 1        # fixed x effects imputation
impM1 &lt;- impM
impM1[c("y","w","v")] &lt;- c("2l.continuous", "2lonly.function", "2lonly.function" )
# define imputation functions
imputationFunction &lt;- list( "w"="sample", "v"="pmm5" )
# define cluster variable
cluster_var &lt;- list( "w"="group", "v"="group" )

# impute
imp1 &lt;- mice::mice( as.matrix(dfr), m=1, predictorMatrix=predM1, method=impM1, maxit=5,
            imputationFunction=imputationFunction, cluster_var=cluster_var )

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.bygroup'>
Groupwise Imputation Function
</h2><span id='topic+mice.impute.bygroup'></span>

<h3>Description</h3>

<p>The function <code>mice.impute.bygroup</code> performs groupwise imputation for arbitrary
imputation methods defined in <span class="pkg">mice</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.bygroup(y, ry, x, wy=NULL, group, imputationFunction, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.bygroup_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="mice.impute.bygroup_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.bygroup_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete
covariates.</p>
</td></tr>
<tr><td><code id="mice.impute.bygroup_+3A_wy">wy</code></td>
<td>
<p>Vector of <code>length(y)</code> indicating which entries should be imputed.</p>
</td></tr>
<tr><td><code id="mice.impute.bygroup_+3A_group">group</code></td>
<td>

<p>Name of grouping variable
</p>
</td></tr>
<tr><td><code id="mice.impute.bygroup_+3A_imputationfunction">imputationFunction</code></td>
<td>

<p>Imputation method for <span class="pkg">mice</span>
</p>
</td></tr>
<tr><td><code id="mice.impute.bygroup_+3A_...">...</code></td>
<td>

<p>More arguments to be passed to imputation function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of imputed values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Cluster-specific imputation for some variables
#############################################################################

library(mice)
data( data.ma01, package="miceadds")
dat &lt;- data.ma01

# use sub-dataset
dat &lt;- dat[ dat$idschool &lt;=1006, ]
V &lt;- ncol(dat)
# create initial predictor matrix and imputation methods
predictorMatrix &lt;- matrix( 1, nrow=V, ncol=V)
diag(predictorMatrix) &lt;- 0
rownames(predictorMatrix) &lt;- colnames(predictorMatrix) &lt;- colnames(dat)
predictorMatrix[, c("idstud", "studwgt","urban" ) ] &lt;- 0
method &lt;- rep("norm", V)
names(method) &lt;- colnames(dat)

#** groupwise imputation of variable books
method["books"] &lt;- "bygroup"
# specify name of the grouping variable ('idschool') and imputation method ('norm')
group &lt;- list( "books"="idschool" )
imputationFunction &lt;- list("books"="norm" )

#** conduct multiple imputation in mice
imp &lt;- mice::mice( dat, method=method, predictorMatrix=predictorMatrix,
            m=1, maxit=1, group=group, imputationFunction=imputationFunction )

#############################################################################
# EXAMPLE 2: Group-wise multilevel imputation '2l.pan'
#############################################################################

library(mice)
data( data.ma01, package="miceadds" )
dat &lt;- data.ma01

# select data
dat &lt;- dat[, c("idschool","hisei","books","female") ]
V &lt;- ncol(dat)
dat &lt;- dat[ ! is.na( dat$books), ]
# define factor variable

dat$books &lt;- as.factor(dat$books)
# create initial predictor matrix and imputation methods
predictorMatrix &lt;- matrix( 0, nrow=V, ncol=V)
rownames(predictorMatrix) &lt;- colnames(predictorMatrix) &lt;- colnames(dat)
predictorMatrix["idschool", ] &lt;- 0
predictorMatrix[ "hisei", "idschool" ] &lt;- -2
predictorMatrix[ "hisei", c("books","female") ] &lt;- 1
method &lt;- rep("", V)
names(method) &lt;- colnames(dat)
method["hisei"] &lt;- "bygroup"
group &lt;- list( "hisei"="female" )
imputationFunction &lt;- list("hisei"="2l.pan" )

#** conduct multiple imputation in mice
imp &lt;- mice::mice( dat, method=method, predictorMatrix=predictorMatrix,
            m=1, maxit=1, group=group, imputationFunction=imputationFunction )
str(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.catpmm'>
Imputation of a Categorical Variable Using Multivariate Predictive
Mean Matching
</h2><span id='topic+mice.impute.catpmm'></span>

<h3>Description</h3>

<p>Imputes a categorical variable using multivariate predictive mean matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.catpmm(y, ry, x, donors=5, ridge=10^(-5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.catpmm_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.catpmm_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.catpmm_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.catpmm_+3A_donors">donors</code></td>
<td>
<p>Number of donors used for random sampling of nearest
neighbors in imputation</p>
</td></tr>
<tr><td><code id="mice.impute.catpmm_+3A_ridge">ridge</code></td>
<td>
<p>Numerical constant used for avioding collinearity issues. Noise
is added to covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.catpmm_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The categorical outcome variable is recoded as a vector of dummy variables.
A multivariate linear regression is specified for computing predicted values.
The L1 distance (i.e., sum of absolute deviations) is utilized for
predictive mean matching. Predictive mean matching for categorical variables
has been proposed by Meinfelder (2009) using a multinomial regression instead of
ordinary linear regression.
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>References</h3>

<p>Meinfelder, F. (2009). <em>Analysis of Incomplete Survey Data - Multiple
Imputation via Bayesian Bootstrap Predictive Mean Matching</em>.
Dissertation thesis. University of Bamberg, Germany.
<a href="https://fis.uni-bamberg.de/handle/uniba/213">https://fis.uni-bamberg.de/handle/uniba/213</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation internat data
#############################################################################

data(data.internet, package="miceadds")
dat &lt;- data.internet

#** empty imputation
imp0 &lt;- mice::mice(dat, m=1, maxit=0)
method &lt;- imp0$method
predmat &lt;- imp0$predictorMatrix

#** define factor variable

dat1 &lt;- dat
dat1[,1] &lt;- as.factor(dat1[,1])
method[1] &lt;- "catpmm"

#** impute with 'catpmm''
imp &lt;- mice::mice(dat1, method=method1, m=5)
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.constant'>
Imputation Using a Fixed Vector
</h2><span id='topic+mice.impute.constant'></span>

<h3>Description</h3>

<p>Defines a fixed vector of values for imputation of a variable.
The method is particularly useful for the generation of
synthetic datasets, see <code><a href="#topic+syn_mice">syn_mice</a></code> (Example 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.constant(y, ry, x, fixed_values, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.constant_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="mice.impute.constant_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.constant_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete
covariates.</p>
</td></tr>
<tr><td><code id="mice.impute.constant_+3A_fixed_values">fixed_values</code></td>
<td>

<p>Vector containing fixed values
</p>
</td></tr>
<tr><td><code id="mice.impute.constant_+3A_...">...</code></td>
<td>

<p>More arguments to be passed to imputation function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of imputed values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn.constant">syn.constant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Example with fixed imputed values
#############################################################################

data(nhanes, package="mice")
dat &lt;- nhanes

#* define methods
method &lt;- c(age="", bmi="constant", hyp="norm", chl="pmm")
fixed_values &lt;- list( bmi=rep(27,9) )

#* impute
imp &lt;- mice::mice(dat, method=method, m=1, maxit=3, fixed_values=fixed_values)
table(mice::complete(imp, action=1)$bmi)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.hotDeck'>
Imputation of a Variable Using Probabilistic Hot Deck Imputation
</h2><span id='topic+mice.impute.hotDeck'></span>

<h3>Description</h3>

<p>Imputes a variable under a random draw from a pool of donors
defined by a distance function. Uncertainty with respect
to the creation of donor pools is introduced by drawing a Bootstrap
sample (approximate Bayesian Bootstrap, ABB)
from observations with complete data (see Andridge &amp; Little, 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.hotDeck(y, ry, x, donors=5, method="Mahalanobis", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.hotDeck_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.hotDeck_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.hotDeck_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.hotDeck_+3A_donors">donors</code></td>
<td>
<p>Number of donors used for random sampling of nearest
neighbors in imputation</p>
</td></tr>
<tr><td><code id="mice.impute.hotDeck_+3A_method">method</code></td>
<td>
<p>Method used for computation of weights in distance function.
Options are the Mahalanobis metric (<code>method="Mahalanobis"</code>),
weighted by correlations of covariates with the outcome
(<code>method="cor"</code>) and weighting by linear regression
coefficients (<code>method="lm"</code>).
</p>
</td></tr>
<tr><td><code id="mice.impute.hotDeck_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>References</h3>

<p>Andridge, R. R., &amp;  and Little, R. J. A. (2010).
A review of hot deck imputation for survey non-response.
<em>International Statistical Review, 78</em>(1), 40-64.
<a href="https://doi.org/10.1111/j.1751-5823.2010.00103.x">doi:10.1111/j.1751-5823.2010.00103.x</a>
</p>


<h3>See Also</h3>

<p>See also the packages <span class="pkg">hot.deck</span> and
<span class="pkg">HotDeckImputation</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Hot deck imputation NHANES dataset
#############################################################################

data(nhanes, package="mice")
dat &lt;- nhanes

#*** prepare imputation method
vars &lt;- colnames(dat)
V &lt;- length(vars)
impMethod &lt;- rep("hotDeck", V)
method &lt;- "cor"

#*** imputation in mice
imp &lt;- mice::mice( data=as.matrix(dat), m=1, method=impMethod, method=method )
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.imputeR.lmFun'>
Wrapper Function to Imputation Methods in the <span class="pkg">imputeR</span> Package
</h2><span id='topic+mice.impute.imputeR.lmFun'></span><span id='topic+mice.impute.imputeR.cFun'></span>

<h3>Description</h3>

<p>The imputation methods <code>"imputeR.lmFun"</code> and <code>"imputeR.cFun"</code> provide
interfaces to imputation methods in the <span class="pkg">imputeR</span> package for
continuous and binary data, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.imputeR.lmFun(y, ry, x, Fun=NULL, draw_boot=TRUE, add_noise=TRUE, ... )

mice.impute.imputeR.cFun(y, ry, x, Fun=NULL, draw_boot=TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.imputeR.lmFun_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.imputeR.lmFun_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.imputeR.lmFun_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.imputeR.lmFun_+3A_fun">Fun</code></td>
<td>
<p>Name of imputation functions in <span class="pkg">imputeR</span> package, e.g.,
<code>imputeR::ridgeR</code>, see Details.</p>
</td></tr>
<tr><td><code id="mice.impute.imputeR.lmFun_+3A_draw_boot">draw_boot</code></td>
<td>
<p>Logical indicating whether a Bootstrap sample is taken
for sampling model parameters</p>
</td></tr>
<tr><td><code id="mice.impute.imputeR.lmFun_+3A_add_noise">add_noise</code></td>
<td>
<p>Logical indicating whether empirical residuals should be
added to predicted values</p>
</td></tr>
<tr><td><code id="mice.impute.imputeR.lmFun_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for continuous variables:
</p>
<p><code><a href="imputeR.html#topic+CubistR">imputeR::CubistR</a></code>,
<code><a href="imputeR.html#topic+glmboostR">imputeR::glmboostR</a></code>,
<code><a href="imputeR.html#topic+lassoR">imputeR::lassoR</a></code>,
<code><a href="imputeR.html#topic+pcrR">imputeR::pcrR</a></code>,
<code><a href="imputeR.html#topic+plsR">imputeR::plsR</a></code>,
<code><a href="imputeR.html#topic+ridgeR">imputeR::ridgeR</a></code>,
<code><a href="imputeR.html#topic+stepBackR">imputeR::stepBackR</a></code>,
<code><a href="imputeR.html#topic+stepBothR">imputeR::stepBothR</a></code>,
<code><a href="imputeR.html#topic+stepForR">imputeR::stepForR</a></code>
<br />
</p>
<p>Methods for binary variables:
<code><a href="imputeR.html#topic+gbmC">imputeR::gbmC</a></code>,
<code><a href="imputeR.html#topic+lassoC">imputeR::lassoC</a></code>,
<code><a href="imputeR.html#topic+ridgeC">imputeR::ridgeC</a></code>,
<code><a href="imputeR.html#topic+rpartC">imputeR::rpartC</a></code>,
<code><a href="imputeR.html#topic+stepBackC">imputeR::stepBackC</a></code>,
<code><a href="imputeR.html#topic+stepBothC">imputeR::stepBothC</a></code>,
<code><a href="imputeR.html#topic+stepForC">imputeR::stepForC</a></code>
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Example with binary and continuous variables
#############################################################################

library(mice)
library(imputeR)

data(nhanes, package="mice")
dat &lt;- nhanes
dat$hyp &lt;- as.factor(dat$hyp)

#* define imputation methods
method &lt;- c(age="",bmi="norm",hyp="imputeR.cFun",chl="imputeR.lmFun")
Fun &lt;- list( hyp=imputeR::ridgeC, chl=imputeR::ridgeR)

#** do imputation
imp &lt;- mice::mice(dat1, method=method, maxit=10, m=4, Fun=Fun)
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.ml.lmer'>
Multilevel Imputation Using <span class="pkg">lme4</span>
</h2><span id='topic+mice.impute.ml.lmer'></span>

<h3>Description</h3>

<p>This function is a general imputation function based on the linear mixed effects
model as implemented in <code>lme4::lmer</code>. The imputation model can be hierarchical
or non-hierarchical and can be written in a general form
<code class="reqn">\bold{y}=\bold{X} \bold{\beta} + \sum_{v=1}^V \bold{Z}_v \bold{u}_v</code> for <code class="reqn">V</code>
multivariate random effects. While predictors can be selected by specifying the rows
in the predictor matrix in <code>mice::mice</code> (i.e., modification of <code>type</code>),
the level of random effects can be specified with <code>levels_id</code> and random slopes
can be selected with <code>random_slopes</code>.
</p>
<p>The function <code>mice.impute.ml.lmer</code> allows the imputation of variables at
arbitrary levels. The corresponding level can be specified with <code>levels_id</code>.
All predictor variables are aggregated to the corresponding level of the variable
to be imputed.
</p>
<p>Several strategies for the specification of the design
matrix <code class="reqn">\bold{X}</code> are accommodated. By default, predictors at a lower level
are automatically aggregated to the higher level and included as further
predictors to maintain the multilevel structure in the data (Grund, Luedtke &amp; Robitzsch,
2018; Enders, Mistler &amp; Keller, 2016; argument <code>aggregate_automatically=TRUE</code>). Further,
interactions and quadratic effects can be defined by respective arguments
<code>interactions</code> and <code>quadratics</code>. The dimension
of the matrix of predictors can be reduced by applying partial least squares regression,
see <code><a href="#topic+mice.impute.pls">mice.impute.pls</a></code>.
</p>
<p>The function now only allows continuous data (<code>model="continuous"</code>),
ordinal data (<code>model="pmm"</code>) or
binary data (<code>model="pmm"</code> or <code>model="binary"</code>). Nominal variables with
missing values cannot (yet) be handled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.ml.lmer(y, ry, x, type, levels_id, variables_levels=NULL,
    random_slopes=NULL, aggregate_automatically=TRUE, intercept=TRUE,
    groupcenter.slope=FALSE, draw.fixed=TRUE, random.effects.shrinkage=1e-06,
    glmer.warnings=TRUE, model="continuous", donors=3, match_sampled_pars=FALSE,
    blme_use=FALSE, blme_args=NULL, pls.facs=0, interactions=NULL,
    quadratics=NULL, min.int.cor=0, min.all.cor=0, pls.print.progress=FALSE,
    group_index=NULL, iter_re=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.ml.lmer_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> <code class="reqn">\times</code> <code>p</code>) of complete predictors.
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_type">type</code></td>
<td>
<p>Predictor variables associated with fixed effects.
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_levels_id">levels_id</code></td>
<td>

<p>Specification of the level identifiers (see Examples)
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_variables_levels">variables_levels</code></td>
<td>

<p>Specification of the level of variables (see Examples)
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_random_slopes">random_slopes</code></td>
<td>

<p>Specification of random slopes (see Examples)
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_aggregate_automatically">aggregate_automatically</code></td>
<td>

<p>Logical indicating whether aggregated effects at higher levels are automatically
included.
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_intercept">intercept</code></td>
<td>

<p>Optional logical indicating whether the intercept should be included.
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_groupcenter.slope">groupcenter.slope</code></td>
<td>
<p>Optional logical indicating whether covariates
should be centered around group means</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_draw.fixed">draw.fixed</code></td>
<td>
<p>Optional logical indicating whether fixed effects
parameter should be randomly drawn</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_random.effects.shrinkage">random.effects.shrinkage</code></td>
<td>
<p>Shrinkage parameter for stabilizing the
covariance matrix of random effects</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_glmer.warnings">glmer.warnings</code></td>
<td>
<p>Optional logical indicating whether warnings from
<code>glmer</code> should be displayed</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_model">model</code></td>
<td>

<p>Type of model. Can be <code>"continuous"</code> for normally distributed data,
<code>"binary"</code> for dichotomous data specifying a logistic mixed effects model
and <code>"pmm"</code> for predictive mean matching.
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_donors">donors</code></td>
<td>
<p>Number of donors used for predictive mean matching</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_match_sampled_pars">match_sampled_pars</code></td>
<td>
<p>Logical indicating whether values of nearest
neighbors should also be sampled in pmm imputation.</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_blme_use">blme_use</code></td>
<td>
<p>Logical indicating whether the <span class="pkg">blme</span>
package should be used.</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_blme_args">blme_args</code></td>
<td>
<p>(Prior) Arguments for <span class="pkg">blme</span>, see
<code><a href="blme.html#topic+blmer">blme::blmer</a></code> and
<code><a href="blme.html#topic+bmerDist-class">blme::bmerDist-class</a></code>.
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_pls.facs">pls.facs</code></td>
<td>

<p>Number of factors used in PLS dimension reduction
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_interactions">interactions</code></td>
<td>

<p>Specification of predictors with interaction effects
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_quadratics">quadratics</code></td>
<td>

<p>Specification of predictors with quadratic effects
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_min.int.cor">min.int.cor</code></td>
<td>

<p>Minimum absolute value of correlation with outcome for interaction effects to be retained
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_min.all.cor">min.all.cor</code></td>
<td>

<p>Minimum absolute value of correlation with outcome for predictors to be retained
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_pls.print.progress">pls.print.progress</code></td>
<td>

<p>Logical indicating whether progress of algorithm should be displayed
</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_group_index">group_index</code></td>
<td>
<p>Optional vector for group identifiers (internally used
in <code>mice.impute.bygroup</code></p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_iter_re">iter_re</code></td>
<td>
<p>Number of iterations for sampling random effects in random intercept
models for continuous outcomes. Using <code>iter_re&gt;0</code> is necessary for cross-classified
models with not fully balanced designs.</p>
</td></tr>
<tr><td><code id="mice.impute.ml.lmer_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of imputed values
</p>


<h3>References</h3>

<p>Enders, C. K., Mistler, S. A., &amp; Keller, B. T. (2016). Multilevel multiple imputation:
A review and evaluation of joint modeling and chained equations imputation.
<em>Psychological Methods, 21</em>(2), 222-240.
<a href="https://doi.org/10.1037/met0000063">doi:10.1037/met0000063</a>
</p>
<p>Grund, S., Luedtke, O., &amp; Robitzsch, A. (2018). Multiple imputation of multilevel
data in organizational research. <em>Organizational Research Methods, 21</em>(1), 111-149.
<a href="https://doi.org/10.1177/1094428117703686">doi:10.1177/1094428117703686</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mice.impute.2l.continuous">mice.impute.2l.continuous</a></code> for two-level imputation in <span class="pkg">mice</span> and
for several links to other packages which enable multilevel imputation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation of three-level data with normally distributed residuals
#############################################################################

data(data.ma07, package="miceadds")
dat &lt;- data.ma07

# variables at level 1 (identifier id1): x1 (some missings), x2 (complete)
# variables at level 2 (identifier id2): y1 (some missings), y2 (complete)
# variables at level 3 (identifier id3): z1 (some missings), z2 (complete)

#****************************************************************************
# Imputation model 1

#----- specify levels of variables (only relevent for variables
#      with missing values)
variables_levels &lt;- miceadds:::mice_imputation_create_type_vector( colnames(dat), value="")
 # leave variables at lowest level blank (i.e., "")
variables_levels[ c("y1","y2") ] &lt;- "id2"
variables_levels[ c("z1","z2") ] &lt;- "id3"

#----- specify predictor matrix
predmat &lt;- mice::make.predictorMatrix(data=dat)
predmat[, c("id2", "id3") ] &lt;- 0
# set -2 for cluster identifier for level 3 variable z1
# because "2lonly" function is used
predmat[ "z1", "id3" ] &lt;- -2

#----- specify imputation methods
method &lt;- mice::make.method(data=dat)
method[c("x1","y1")] &lt;- "ml.lmer"
method[c("z1")] &lt;- "2lonly.norm"

#----- specify hierarchical structure of imputation models
levels_id &lt;- list()
#** hierarchical structure for variable x1
levels_id[["x1"]] &lt;- c("id2", "id3")
#** hierarchical structure for variable y1
levels_id[["y1"]] &lt;- c("id3")

#----- specify random slopes
random_slopes &lt;- list()
#** random slopes for variable x1
random_slopes[["x1"]] &lt;- list( "id2"=c("x2"), "id3"=c("y1") )
# if no random slopes should be specified, the corresponding entry can be left empty
# and only a random intercept is used in the imputation model

#----- imputation in mice
imp1 &lt;- mice::mice( dat, maxit=10, m=5, method=method,
            predictorMatrix=predmat, levels_id=levels_id,  random_slopes=random_slopes,
            variables_levels=variables_levels )
summary(imp1)

#****************************************************************************
# Imputation model 2

#----- impute x1 with predictive mean matching and y1 with normally distributed residuals
model &lt;- list(x1="pmm", y1="continuous")

#----- assume only random intercepts
random_slopes &lt;- NULL

#---- create interactions with z2 for all predictors in imputation models for x1 and y1
interactions &lt;- list("x1"="z2", "y1"="z2")

#----- imputation in mice
imp2 &lt;- mice::mice( dat, method=method, predictorMatrix=predmat,
                levels_id=levels_id, random_slopes=random_slopes,
                variables_levels=variables_levels, model=model, interactions=interactions)
summary(imp2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.plausible.values'>
Plausible Value Imputation using Classical Test Theory and
Based on Individual Likelihood
</h2><span id='topic+mice.impute.plausible.values'></span>

<h3>Description</h3>

<p>This imputation function performs unidimensional plausible value
imputation if (subject-wise) measurement errors or the reliability
of the scale is known (Mislevy, 1991; see also Asparouhov &amp; Muthen, 2010;
Blackwell, Honaker &amp; King, 2011, 2017a, 2017b).
The function also allows the input of an individual likelihood
obtained by fitting an item response model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.plausible.values(y, ry, x, type, alpha=NULL,
    alpha.se=0, scale.values=NULL, sig.e.miss=1e+06,
    like=NULL, theta=NULL, normal.approx=NULL,
    pviter=15, imputationWeights=rep(1, length(y)), plausible.value.print=TRUE,
    pls.facs=NULL, interactions=NULL, quadratics=NULL, extract_data=TRUE,
    control_latreg=list( progress=FALSE, ridge=1e-5 ),  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.plausible.values_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> <code class="reqn">\times</code> <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_type">type</code></td>
<td>

<p>Type of predictor variables. <code>type=3</code> refers to items belonging to
a scale to be imputed. A cluster (grouping) variable is defined by
<code>type=-2</code>. If for some predictors, the cluster means should also
be included as predictors, then specify <code>type=2</code> (see Imputation
Model 3 of Example 1).
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_alpha">alpha</code></td>
<td>

<p>A known reliability estimate. An optional standard error of the estimate
can be provided in <code>alpha.se</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_alpha.se">alpha.se</code></td>
<td>

<p>Optional numeric value of the standard error of the <code>alpha</code>
reliability estimate if in every iteration a new reliability
should be sampled.
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_scale.values">scale.values</code></td>
<td>

<p>A list consisting of scale values of scale values and its
corresponding standard errors (see Example 1).
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_sig.e.miss">sig.e.miss</code></td>
<td>

<p>A standard error of measurement for cases with missing values on a scale
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_like">like</code></td>
<td>
<p>Individual likelihood evaluated at <code>theta</code></p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_theta">theta</code></td>
<td>
<p>Grid of unidimensional latent variable</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_normal.approx">normal.approx</code></td>
<td>
<p>Logical indicating whether the
individual posterior should be approximated by a normal distribution</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_pviter">pviter</code></td>
<td>

<p>Number of iterations in each imputation which should be run until the
plausible values are drawn
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_imputationweights">imputationWeights</code></td>
<td>

<p>Optional vector of sample weights
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_plausible.value.print">plausible.value.print</code></td>
<td>

<p>An optional logical indicating whether some information about the
plausible value imputation should be printed at the console
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_pls.facs">pls.facs</code></td>
<td>

<p>Number of PLS factors if PLS dimension reduction is used
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_interactions">interactions</code></td>
<td>

<p>Vector of variable names used for creating interactions
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_quadratics">quadratics</code></td>
<td>

<p>Vector of variable names used for creating quadratic terms
</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_extract_data">extract_data</code></td>
<td>
<p>Logical indicating whether input data should be extracted
from parent environment within <code><a href="mice.html#topic+mice">mice::mice</a></code> routine</p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_control_latreg">control_latreg</code></td>
<td>
<p>Control arguments for <code><a href="TAM.html#topic+tam.latreg">TAM::tam.latreg</a></code></p>
</td></tr>
<tr><td><code id="mice.impute.plausible.values_+3A_...">...</code></td>
<td>

<p>Further objects to be passed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear model is assumed for drawing plausible values of a variable
<code class="reqn">Y</code> contaminated by measurement error. Assuming <code class="reqn">Y=\theta + e</code>
and a linear regression model for <code class="reqn">\theta</code>
</p>
<p style="text-align: center;"><code class="reqn"> \theta=\bold{X} \beta + \epsilon</code>
</p>

<p>(plausible value) imputations from the posterior distribution
<code class="reqn">P( \theta | Y, \bold{X} )</code> are drawn. See Mislevy (1991) for details.
</p>


<h3>Value</h3>

<p>A vector of length <code>nrow(x)</code> containing imputed plausible values.
</p>


<h3>Note</h3>

<p>Plausible value imputation is also known as multiple overimputation
(Blackwell, Honaker &amp; King, 2016a, 2016b) which is implemented
in the <span class="pkg">Amelia</span> package, see <code>Amelia::moPrep</code>
and <code>Amelia::amelia</code>.
</p>


<h3>References</h3>

<p>Asparouhov, T., &amp; Muthen, B. (2010). <em>Plausible values for latent variables
using Mplus</em>. Technical Report. <a href="https://www.statmodel.com/papers.shtml">https://www.statmodel.com/papers.shtml</a>
</p>
<p>Blackwell, M., Honaker, J., &amp; King, G. (2011).
<em>Multiple overimputation: A unified approach to measurement error and
missing data</em>. Technical Report.
</p>
<p>Blackwell, M., Honaker, J., &amp; King, G. (2017a).
A unified approach to measurement error and missing data: Overview and
applications. <em>Sociological Methods &amp; Research, 46</em>(3), 303-341.
</p>
<p>Blackwell, M., Honaker, J., &amp; King, G. (2017b).
A unified approach to measurement error and missing data: Details and
extensions. <em>Sociological Methods &amp; Research, 46</em>(3), 342-369.
</p>
<p>Mislevy, R. J. (1991). Randomization-based inference about latent variables
from complex samples. <em>Psychometrika, 56</em>, 177-196.
</p>


<h3>See Also</h3>

<p>See <code><a href="TAM.html#topic+tam.latreg">TAM::tam.latreg</a></code> for fitting latent regression
models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Plausible value imputation for data.ma04 | 2 scales
#############################################################################

data(data.ma04, package="miceadds")
dat &lt;- data.ma04

# Scale 1 consists of items A1,...,A4
# Scale 2 consists of items B1,...,B5
dat$scale1 &lt;- NA
dat$scale2 &lt;- NA

#** inits imputation method and predictor matrix
res &lt;- miceadds::mice_inits(dat, ignore=c("group") )
predM &lt;- res$predictorMatrix
impMethod &lt;- res$method
impMethod &lt;- gsub("pmm", "norm", impMethod )

# look at missing proportions
colSums( is.na(dat) )

# redefine imputation methods for plausible value imputation
impMethod[ "scale1" ] &lt;- "plausible.values"
predM[ "scale1",  ] &lt;- 1
predM[ "scale1", c("A1", "A2",  "A3", "A4" ) ] &lt;- 3
    # items corresponding to a scale should be declared by a 3 in the predictor matrix
impMethod[ "scale2" ] &lt;- "plausible.values"
predM[,"scale2"  ] &lt;- 0
predM[ "scale2",  c("A2","A3","A4","V6","V7") ] &lt;- 1
diag(predM) &lt;- 0

# use imputed scale values as predictors for V5, V6 and V7
predM[ c("V5","V6","V7"), c("scale1","scale2" ) ] &lt;- 1
# exclude for V5, V6 and V7 the items of scales A and B as predictors
predM[ c("V5","V6","V7"), c( paste0("A",2:4), paste0("B",1:5) ) ] &lt;- 0
# exclude 'group' as a predictor
predM[,"group"] &lt;- 0

# look at imputation method and predictor matrix
impMethod
predM

#-------------------------------
# Parameter for imputation
#***
# scale 1 (A1,...,A4)
# known Cronbach's Alpha
alpha &lt;- NULL
alpha &lt;- list( "scale1"=.8 )
alpha.se &lt;- list( "scale1"=.05 )  # sample alpha with a standard deviation of .05

#***
# scale 2 (B1,...,B5)
# means and SE's of scale scores are assumed to be known
M.scale2 &lt;- rowMeans( dat[, paste("B",1:5,sep="")  ] )
# M.scale2[ is.na( m1) ] &lt;- mean( M.scale2, na.rm=TRUE )
SE.scale2 &lt;- rep( sqrt( stats::var(M.scale2,na.rm=T)*(1-.8) ), nrow(dat) )
#=&gt; heterogeneous measurement errors are allowed
scale.values &lt;- list( "scale2"=list( "M"=M.scale2, "SE"=SE.scale2 ) )

#*** Imputation Model 1: Imputation four using parallel chains
imp1 &lt;- mice::mice( dat, predictorMatrix=predM, m=4, maxit=5,
          alpha.se=alpha.se, method=impMethod,  allow.na=TRUE, alpha=alpha,
          scale.values=scale.values  )
summary(imp1)

# extract first imputed dataset
dat11 &lt;- mice::complete( imp, 1 )

#*** Imputation Model 2: Imputation using one long chain
imp2 &lt;- miceadds::mice.1chain( dat, predictorMatrix=predM, burnin=10, iter=20, Nimp=4,
          alpha.se=alpha.se, method=impMethod,  allow.na=TRUE, alpha=alpha,
          scale.values=scale.values )
summary(imp2)

#-------------
#*** Imputation Model 3: Imputation including  group level variables

# use group indicator for plausible value estimation
predM[ "scale1", "group" ] &lt;- -2
# V7 and B1 should be aggregated at the group level
predM[ "scale1", c("V7","B1") ] &lt;- 2
predM[ "scale2", "group" ] &lt;- -2
predM[ "scale2", c("V7","A1") ] &lt;- 2

# perform single imputation (m=1)
imp &lt;- mice::mice( dat, predictorMatrix=predM, m=1, maxit=10,
            method=impMethod,  allow.na=TRUE, alpha=alpha,
            scale.values=scale.values )
dat10 &lt;- mice::complete(imp)

# multilevel model
library(lme4)
mod &lt;- lme4::lmer( scale1 ~ ( 1 | group), data=dat11 )
summary(mod)

mod &lt;- lme4::lmer( scale1 ~ ( 1 | group), data=dat10)
summary(mod)

#############################################################################
# EXAMPLE 2: Plausible value imputation with chained equations
#############################################################################

# - simulate a latent variable theta and dichotomous item responses
# - two covariates X in which the second covariate has measurement error

library(sirt)
library(TAM)
library(lavaan)

set.seed(7756)
N &lt;- 2000    # number of persons
I &lt;- 10     # number of items

# simulate covariates
X &lt;- MASS::mvrnorm( N, mu=c(0,0), Sigma=matrix( c(1,.5,.5,1),2,2 ) )
colnames(X) &lt;- paste0("X",1:2)
# second covariate with measurement error with variance var.err
var.err &lt;- .3
X.err &lt;- X
X.err[,2] &lt;- X[,2] + stats::rnorm(N, sd=sqrt(var.err) )
# simulate theta
theta &lt;- .5*X[,1] + .4*X[,2] + stats::rnorm( N, sd=.5 )
# simulate item responses
itemdiff &lt;- seq( -2, 2, length=I)  # item difficulties
dat &lt;- sirt::sim.raschtype( theta, b=itemdiff )

#***********************
#*** Model 0: Regression model with true variables
mod0 &lt;- stats::lm( theta ~ X )
summary(mod0)

#**********************
# plausible value imputation for abilities and error-prone
# covariates using the mice package

# creating the likelihood for plausible value for abilities
mod11 &lt;- TAM::tam.mml( dat )
likePV &lt;- IRT.likelihood(mod11)
# creating the likelihood for error-prone covariate X2
# The known measurement error variance is 0.3.
lavmodel &lt;- "
  X2true=~ 1*X2
  X2 ~~ 0.3*X2
    "
mod12 &lt;- lavaan::cfa( lavmodel, data=as.data.frame(X.err) )
summary(mod12)
likeX2 &lt;- IRTLikelihood.cfa( data=X.err, cfaobj=mod12)
str(likeX2)

#-- create data input for mice package
data &lt;- data.frame( "PVA"=NA, "X1"=X[,1], "X2"=NA  )
vars &lt;- colnames(data)
V &lt;- length(vars)
predictorMatrix &lt;- 1 - diag(V)
rownames(predictorMatrix) &lt;- colnames(predictorMatrix) &lt;- vars
method &lt;- rep("norm", V )
names(method) &lt;- vars
method[c("PVA","X2")] &lt;- "plausible.values"

#-- create argument lists for plausible value imputation
# likelihood and theta grid of plausible value derived from IRT model
like &lt;- list( "PVA"=likePV, "X2"=likeX2 )
theta &lt;- list( "PVA"=attr(likePV,"theta"),
                "X2"=attr(likeX2, "theta") )
#-- initial imputations
data.init &lt;- data
data.init$PVA &lt;- mod11$person$EAP
data.init$X2 &lt;- X.err[,"X2"]

#-- imputation using the mice and miceadds package
imp1 &lt;- mice::mice( as.matrix(data), predictorMatrix=predictorMatrix, m=4,
            maxit=6, method=method,  allow.na=TRUE,
            theta=theta, like=like, data.init=data.init )
summary(imp1)

# compute linear regression
mod4a &lt;- with( imp1, stats::lm( PVA ~ X1 + X2 ) )
summary( mice::pool(mod4a) )

#############################################################################
# EXAMPLE 3: Plausible value imputation with known error variance
#############################################################################

#---- simulate data
set.seed(987)
N &lt;- 1000         # number of persons
var_err &lt;- .4     # error variance
dat &lt;- data.frame( x1=stats::rnorm(N), x2=stats::rnorm(N) )
dat$theta &lt;- .3 * dat$x1 - .5*dat$x2 + stats::rnorm(N)
dat$y &lt;- dat$theta + stats::rnorm( N, sd=sqrt(var_err) )

#-- linear regression for measurement-error-free data
mod0a &lt;- stats::lm( theta ~ x1 + x2, data=dat )
summary(mod0a)
#-- linear regression for data with measurement error
mod0b &lt;- stats::lm( y ~ x1 + x2, data=dat )
summary(mod0b)

#-- process data for imputation

dat1 &lt;- dat
dat1$theta &lt;- NA
scale.values &lt;- list( "theta"=list( "M"=dat$y, "SE"=rep(sqrt(var_err),N )))
dat1$y &lt;- NULL

cn &lt;- colnames(dat1)
V &lt;- length(cn)
method &lt;- rep("", length(cn) )
names(method) &lt;- cn
method["theta"] &lt;- "plausible.values"

#-- imputation in mice
imp &lt;- mice::mice( dat1, maxit=1, m=5, allow.na=TRUE, method=method,
            scale.values=scale.values )
summary(imp)

#-- inspect first dataset
summary( mice::complete(imp, action=1) )

#-- linear regression based on imputed datasets
mod1 &lt;- with(imp, stats::lm( theta ~ x1 + x2 ) )
summary( mice::pool(mod1) )

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.pls'>
Imputation using Partial Least Squares for Dimension Reduction
</h2><span id='topic+mice.impute.pls'></span><span id='topic+mice.impute.2l.pls2'></span>

<h3>Description</h3>

<p>This function imputes a variable with missing values using
PLS regression (Mevik &amp; Wehrens, 2007) for a dimension
reduction of the predictor space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.pls(y, ry, x, type, pls.facs=NULL,
   pls.impMethod="pmm", donors=5, pls.impMethodArgs=NULL, pls.print.progress=TRUE,
   imputationWeights=rep(1, length(y)), pcamaxcols=1E+09,
   min.int.cor=0, min.all.cor=0, N.largest=0, pls.title=NULL, print.dims=TRUE,
   pls.maxcols=5000, use_boot=FALSE, envir_pos=NULL, extract_data=TRUE,
   remove_lindep=TRUE, derived_vars=NULL, ...)

mice.impute.2l.pls2(y, ry, x, type, pls.facs=NULL, pls.impMethod="pmm",
   pls.print.progress=TRUE, imputationWeights=rep(1, length(y)), pcamaxcols=1E+09,
   tricube.pmm.scale=NULL, min.int.cor=0, min.all.cor=0, N.largest=0,
   pls.title=NULL, print.dims=TRUE, pls.maxcols=5000, envir_pos=parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.pls_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete
covariates.</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_type">type</code></td>
<td>

<p><code>type=1</code> &ndash; variable is used as a predictor,
</p>
<p><code>type=4</code> &ndash; create interactions with the specified
variable with all other predictors,
</p>
<p><code>type=5</code> &ndash; create a quadratic term of the specified variable
</p>
<p><code>type=6</code> &ndash; if some interactions are specified, ignore
the variables with entry <code>6</code> when creating interactions
</p>
<p><code>type=-2</code> &ndash; specification of a cluster variable. The cluster mean
of the outcome <code>y</code> (when eliminating the subject under study)
is included as a further predictor in the imputation.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_pls.facs">pls.facs</code></td>
<td>

<p>Number of factors used in PLS regression. This argument can also
be specified as a list defining different numbers of factors
for all variables to be imputed.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_pls.impmethod">pls.impMethod</code></td>
<td>
<p>Imputation method used for in PLS estimation.
Any imputation method can be used except if <code>imputationWeights</code>
is provided. Imputation weights are available for <code>norm</code> and <code>pmm</code>.
Categorical variables can be imputed with the method <code>catpmm</code>
(see <code><a href="#topic+mice.impute.catpmm">mice.impute.catpmm</a></code>). For the method <code>catpmm</code>,
multivariate PLS regression is employed for dummy-coded categories of
the outcome variable. The method <code>xplsfacs</code> creates only PLS factors
of the regression model.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_donors">donors</code></td>
<td>
<p>Number of donors if predictive mean matching is used
(<code>pls.impMethod="pmm"</code>).</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_pls.impmethodargs">pls.impMethodArgs</code></td>
<td>
<p>Arguments for imputation method
<code>pls.impMethod</code>.</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_pls.print.progress">pls.print.progress</code></td>
<td>

<p>Print progress during PLS regression.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_imputationweights">imputationWeights</code></td>
<td>

<p>Vector of sample weights to be used in imputation models.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_pcamaxcols">pcamaxcols</code></td>
<td>

<p>Amount of variance explained by principal components (must be a number between
0 and 1) or number of factors used in PCA (an integer larger than 1).
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_min.int.cor">min.int.cor</code></td>
<td>

<p>Minimum absolute correlation for an interaction of two predictors
to be included in the PLS regression model
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_min.all.cor">min.all.cor</code></td>
<td>

<p>Minimum absolute correlation for inclusion in the PLS regression
model.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_n.largest">N.largest</code></td>
<td>

<p>Number of variable to be included which do have the largest
absolute correlations.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_pls.title">pls.title</code></td>
<td>

<p>Title for progress print in console output.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_print.dims">print.dims</code></td>
<td>

<p>An optional logical indicating whether dimensions of
inputs should be printed.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_pls.maxcols">pls.maxcols</code></td>
<td>

<p>Maximum number of interactions to be created.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_use_boot">use_boot</code></td>
<td>
<p>Logical whether Bayesian bootstrap should be used for
drawing regression parameters</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_envir_pos">envir_pos</code></td>
<td>
<p>Position of the environment from which the data should
be extracted.</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_extract_data">extract_data</code></td>
<td>
<p>Logical indicating whether input data should be extracted
from parent environment within <code><a href="mice.html#topic+mice">mice::mice</a></code>  routine</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_remove_lindep">remove_lindep</code></td>
<td>
<p>Logical indicating whether linear dependencies should
be automatically detected and some predictors are removed</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_derived_vars">derived_vars</code></td>
<td>
<p>Optional list containing formulas with derived variables for
inclusion in PLS dimension reduction</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed.
</p>
</td></tr>
<tr><td><code id="mice.impute.pls_+3A_tricube.pmm.scale">tricube.pmm.scale</code></td>
<td>
<p>Scale factor for tricube PMM imputation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputations
if <code>pls.impMethod !="xplsfacs"</code>. In case of
<code>pls.impMethod=="xplsfacs"</code> a matrix with PLS factors
is computed.
</p>


<h3>Note</h3>

<p>The <code>mice.impute.2l.pls2</code> function is just included for reasons of
backward compatibility to former <span class="pkg">miceadds</span> versions.
</p>


<h3>References</h3>

<p>Mevik, B. H., &amp; Wehrens, R. (2007). The <span class="pkg">pls</span> package:
Principal component and partial least squares regression in <span class="rlang"><b>R</b></span>.
<em>Journal of Statistical Software, 18</em>, 1-24.
<a href="https://doi.org/10.18637/jss.v018.i02">doi:10.18637/jss.v018.i02</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: PLS imputation method for internet data
#############################################################################

data(data.internet)
dat &lt;- data.internet

# specify predictor matrix
predictorMatrix &lt;- matrix( 1, ncol(dat), ncol(dat) )
rownames(predictorMatrix) &lt;- colnames(predictorMatrix) &lt;- colnames(dat)
diag( predictorMatrix) &lt;- 0

# use PLS imputation method for all variables
impMethod &lt;- rep( "pls", ncol(dat) )
names(impMethod) &lt;- colnames(dat)

# define predictors for interactions (entries with type 4 in predictorMatrix)
predictorMatrix[c("IN1","IN15","IN16"),c("IN1","IN3","IN10","IN13")] &lt;- 4
# define predictors which should appear as linear and quadratic terms (type 5)
predictorMatrix[c("IN1","IN8","IN9","IN10","IN11"),c("IN1","IN2","IN7","IN5")] &lt;- 5

# use 9 PLS factors for all variables
pls.facs &lt;- as.list( rep( 9, length(impMethod) ) )
names(pls.facs) &lt;- names(impMethod)
pls.facs$IN1 &lt;- 15   # use 15 PLS factors for variable IN1

# choose norm or pmm imputation method
pls.impMethod &lt;- as.list( rep("norm", length(impMethod) ) )
names(pls.impMethod) &lt;- names(impMethod)
pls.impMethod[ c("IN1","IN6")] &lt;- "pmm"

# some arguments for imputation method
pls.impMethodArgs &lt;- list( "IN1"=list( "donors"=10 ),
                           "IN2"=list( "ridge2"=1E-4 ) )

# Model 1: Three parallel chains
imp1 &lt;- mice::mice(data=dat, method=impMethod,
     m=3, maxit=5, predictorMatrix=predictorMatrix,
     pls.facs=pls.facs, # number of PLS factors
     pls.impMethod=pls.impMethod,  # Imputation Method in PLS imputation
     pls.impMethodArgs=pls.impMethodArgs, # arguments for imputation method
     pls.print.progress=TRUE, ls.meth="ridge" )
summary(imp1)

# Model 2: One long chain
imp2 &lt;- miceadds::mice.1chain(data=dat, method=impMethod,
     burnin=10, iter=21, Nimp=3, predictorMatrix=predictorMatrix,
     pls.facs=pls.facs, pls.impMethod=pls.impMethod,
     pls.impMethodArgs=pls.impMethodArgs, ls.meth="ridge" )
summary(imp2)

# Model 3: inclusion of additional derived variables

# define derived variables for IN1
derived_vars &lt;- list( "IN1"=~I( ifelse( IN2&gt;IN3, IN2, IN3 ) ) + I( sin(IN2) ) )

imp3 &lt;- miceadds::mice.1chain(data=dat, method=impMethod, derived_vars=derived_vars,
     burnin=10, iter=21, Nimp=3, predictorMatrix=predictorMatrix,
     pls.facs=pls.facs, pls.impMethod=pls.impMethod,
     pls.impMethodArgs=pls.impMethodArgs, ls.meth="ridge" )
summary(imp3)

#*** example for using imputation function at the level of a variable

# extract first imputed dataset
imp1 &lt;- mice::complete(imp1, action=1)
data_imp1[ is.na(dat$IN1), "IN1" ] &lt;- NA

# define variables
y &lt;- data_imp1$IN1
x &lt;- data_imp1[, -1 ]
ry &lt;- ! is.na(y)
cn &lt;- colnames(dat)
p &lt;- ncol(dat)
type &lt;- rep(1,p)
names(type) &lt;- cn
type["IN1"] &lt;- 0

# imputation of variable 'IN1'
imp0 &lt;- miceadds::mice.impute.pls(y=y, x=x, ry=ry, type=type, pls.facs=10, pls.impMethod="norm",
             ls.meth="ridge", extract_data=FALSE )

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.pmm3'>
Imputation by Predictive Mean Matching (in <span class="pkg">miceadds</span>)
</h2><span id='topic+mice.impute.pmm3'></span><span id='topic+mice.impute.pmm4'></span><span id='topic+mice.impute.pmm5'></span><span id='topic+mice.impute.pmm6'></span>

<h3>Description</h3>

<p>This function imputes values by predictive mean matching like
the <code><a href="mice.html#topic+mice.impute.pmm">mice::mice.impute.pmm</a></code>
method in the <span class="pkg">mice</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.pmm3(y, ry, x, donors=3, noise=10^5, ridge=10^(-5), ...)
mice.impute.pmm4(y, ry, x, donors=3, noise=10^5, ridge=10^(-5), ...)
mice.impute.pmm5(y, ry, x, donors=3, noise=10^5, ridge=10^(-5), ...)
mice.impute.pmm6(y, ry, x, donors=3, noise=10^5, ridge=10^(-5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.pmm3_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="mice.impute.pmm3_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.pmm3_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete
covariates.</p>
</td></tr>
<tr><td><code id="mice.impute.pmm3_+3A_donors">donors</code></td>
<td>

<p>Number of donors used for imputation
</p>
</td></tr>
<tr><td><code id="mice.impute.pmm3_+3A_noise">noise</code></td>
<td>

<p>Numerical value to break ties
</p>
</td></tr>
<tr><td><code id="mice.impute.pmm3_+3A_ridge">ridge</code></td>
<td>

<p>Ridge parameter in the diagonal of <code class="reqn"> \bold{X}'\bold{X}</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.pmm3_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The imputation method <code>pmm3</code> imitates
<code><a href="mice.html#topic+mice.impute.pmm">mice::mice.impute.pmm</a></code> imputation method
in <span class="pkg">mice</span>.
</p>
<p>The imputation method <code>pmm4</code> ignores ties in predicted <code class="reqn">y</code> values.
With many predictors, this does not probably implies any substantial problem.
</p>
<p>The imputation method <code>pmm5</code> suffers from the same problem. Contrary to
the other PMM methods, it searches <code class="reqn">D</code> donors (specified by <code>donors</code>)
smaller than the predicted value and <code class="reqn">D</code> donors larger than the
predicted value and randomly samples a value from this set of <code class="reqn">2 \cdot D</code>
donors.
</p>
<p>The imputation method <code>pmm6</code> is just the <span class="pkg">Rcpp</span> implementation
of <code>pmm5</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+data.largescale">data.largescale</a></code> and <code><a href="#topic+data.smallscale">data.smallscale</a></code>
for speed comparisons of different functions for predictive mean
matching.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# SIMULATED EXAMPLE 1: Two variables x and y with missing y
#############################################################################
set.seed(1413)

rho &lt;- .6   # correlation between x and y
N &lt;- 6800    # number of cases
x &lt;- stats::rnorm(N)
My &lt;- .35   # mean of y
y.com &lt;- y &lt;- My + rho * x + stats::rnorm(N, sd=sqrt( 1 - rho^2 ) )

# create missingness on y depending on rho.MAR parameter
rho.mar &lt;- .4    # correlation response tendency z and x
missrate &lt;- .25  # missing response rate
# simulate response tendency z and missings on y
z &lt;- rho.mar * x + stats::rnorm(N, sd=sqrt( 1 - rho.mar^2 ) )
y[ z &lt; stats::qnorm( missrate ) ] &lt;- NA
dat &lt;- data.frame(x, y )

# mice imputation
impmethod &lt;- rep("pmm", 2 )
names(impmethod) &lt;- colnames(dat)

# pmm (in mice)
imp1 &lt;- mice::mice( as.matrix(dat), m=1, maxit=1, method=impmethod)
# pmm3 (in miceadds)
imp3 &lt;- mice::mice( as.matrix(dat), m=1, maxit=1,
           method=gsub("pmm","pmm3",impmethod)  )
# pmm4 (in miceadds)
imp4 &lt;- mice::mice( as.matrix(dat), m=1, maxit=1,
           method=gsub("pmm","pmm4",impmethod)  )
# pmm5 (in miceadds)
imp5 &lt;- mice::mice( as.matrix(dat), m=1, maxit=1,
           method=gsub("pmm","pmm5",impmethod)  )
# pmm6 (in miceadds)
imp6 &lt;- mice::mice( as.matrix(dat), m=1, maxit=1,
           method=gsub("pmm","pmm6",impmethod)  )

dat.imp1 &lt;- mice::complete( imp1, 1 )
dat.imp3 &lt;- mice::complete( imp3, 1 )
dat.imp4 &lt;- mice::complete( imp4, 1 )
dat.imp5 &lt;- mice::complete( imp5, 1 )
dat.imp6 &lt;- mice::complete( imp6, 1 )

dfr &lt;- NULL
# means
dfr &lt;- rbind( dfr, c( mean( y.com ), mean( y, na.rm=TRUE ), mean( dat.imp1$y),
    mean( dat.imp3$y), mean( dat.imp4$y), mean( dat.imp5$y),  mean( dat.imp6$y)  ) )
# SD
dfr &lt;- rbind( dfr, c( stats::sd( y.com ), stats::sd( y, na.rm=TRUE ),
      stats::sd( dat.imp1$y), stats::sd( dat.imp3$y), stats::sd( dat.imp4$y),
      stats::sd( dat.imp5$y), stats::sd( dat.imp6$y) ) )
# correlations
dfr &lt;- rbind( dfr, c( stats::cor( x,y.com ),
    stats::cor( x[ ! is.na(y) ], y[ ! is.na(y) ] ),
    stats::cor( dat.imp1$x, dat.imp1$y), stats::cor( dat.imp3$x, dat.imp3$y),
    stats::cor( dat.imp4$x, dat.imp4$y), stats::cor( dat.imp5$x, dat.imp5$y),
    stats::cor( dat.imp6$x, dat.imp6$y)
        ) )
rownames(dfr) &lt;- c("M_y", "SD_y", "cor_xy" )
colnames(dfr) &lt;- c("compl", "ld", "pmm", "pmm3", "pmm4", "pmm5","pmm6")
##           compl     ld    pmm   pmm3   pmm4   pmm5   pmm6
##   M_y    0.3306 0.4282 0.3314 0.3228 0.3223 0.3264 0.3310
##   SD_y   0.9910 0.9801 0.9873 0.9887 0.9891 0.9882 0.9877
##   cor_xy 0.6057 0.5950 0.6072 0.6021 0.6100 0.6057 0.6069

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.rlm'>
Imputation of a Linear Model by Bayesian Bootstrap
</h2><span id='topic+mice.impute.rlm'></span><span id='topic+mice.impute.lqs'></span><span id='topic+mice.impute.lm'></span><span id='topic+mice.impute.lm_fun'></span>

<h3>Description</h3>

<p>These functions impute from linear models using the functions
<code><a href="stats.html#topic+lm">stats::lm</a></code>, <code><a href="MASS.html#topic+rlm">MASS::rlm</a></code>
or <code><a href="MASS.html#topic+lqs">MASS::lqs</a></code>. The method <code>mice.impute.lm_fun</code>
allows the definition of a general linear regression fitting function for
which the methods <code>predict</code> and <code>residuals</code> are defined.
</p>
<p>Parameters of the model are estimated
by Bayesian bootstrap. Predicted values are computed and residuals are randomly
drawn from the empirical distribution of residuals of observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.lm(y, ry, x, wy=NULL, lm_args=NULL, trafo=NULL, antitrafo=NULL, ...)

mice.impute.rlm(y, ry, x, wy=NULL, lm_args=NULL, trafo=NULL, antitrafo=NULL, ...)

mice.impute.lqs(y, ry, x, wy=NULL, lm_args=NULL, trafo=NULL, antitrafo=NULL, ...)

mice.impute.lm_fun(y, ry, x, wy=NULL, lm_args=NULL, lm_fun="lm", trafo=NULL,
               antitrafo=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.rlm_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.rlm_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.rlm_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.rlm_+3A_wy">wy</code></td>
<td>
<p>Vector of logicals indicating which entries should be imputed</p>
</td></tr>
<tr><td><code id="mice.impute.rlm_+3A_lm_args">lm_args</code></td>
<td>
<p>List of arguments for <code><a href="stats.html#topic+lm">stats::lm</a></code>,
<code><a href="MASS.html#topic+rlm">MASS::rlm</a></code>, <code><a href="MASS.html#topic+lqs">MASS::lqs</a></code> or
a user-defined function.</p>
</td></tr>
<tr><td><code id="mice.impute.rlm_+3A_lm_fun">lm_fun</code></td>
<td>
<p>Linear regression fitting function, e.g. <code>stats::lm</code> for which
S3 methods <code>predict</code> and <code>residuals</code> are defined.</p>
</td></tr>
<tr><td><code id="mice.impute.rlm_+3A_trafo">trafo</code></td>
<td>
<p>Optional function for transforming the outcome values</p>
</td></tr>
<tr><td><code id="mice.impute.rlm_+3A_antitrafo">antitrafo</code></td>
<td>
<p>Optional function which is the inverse function of <code>trafo</code></p>
</td></tr>
<tr><td><code id="mice.impute.rlm_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Some toy example illustrating the methods
#############################################################################

library(MASS)
library(mice)

#-- simulate data
set.seed(98)
N &lt;- 1000
x &lt;- stats::rnorm(N)
z &lt;- 0.5*x + stats::rnorm(N, sd=.7)
y &lt;- stats::rnorm(N, mean=.3*x - .2*z, sd=1 )
dat &lt;- data.frame(x,z,y)
dat[ seq(1,N,3), c("x","y") ] &lt;- NA
dat[ seq(1,N,4), "z" ] &lt;- NA

#-- define imputation methods
imp &lt;- mice::mice(dat, maxit=0)
method &lt;- imp$method
method["x"] &lt;- "rlm"
method["z"] &lt;- "lm"
method["y"] &lt;- "lqs"

#-- impute data
imp &lt;- mice::mice(dat, method=method)
summary(imp)

#--- example using transformations
dat1$x &lt;- exp(dat1$x)
dat1$z &lt;- stats::plogis(dat1$z)

trafo &lt;- list(x=log, z=stats::qlogis)
antitrafo &lt;- list(x=exp, z=stats::plogis)

#- impute with transformations
imp2 &lt;- mice::mice(dat1, method=method, m=1, maxit=3, trafo=trafo, antitrafo=antitrafo)
print(imp2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.simputation'>
Wrapper Function to Imputation Methods in the <span class="pkg">simputation</span> Package
</h2><span id='topic+mice.impute.simputation'></span>

<h3>Description</h3>

<p>This imputation method provides a wrapper function to univariate imputation methods
in the <span class="pkg">simputation</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.simputation(y, ry, x, Fun=NULL, Fun_args=NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.simputation_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.simputation_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.simputation_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.simputation_+3A_fun">Fun</code></td>
<td>
<p>Name of imputation functions in <span class="pkg">simputation</span> package, e.g.,
<code>imputeR::impute_lm</code>, see Details.</p>
</td></tr>
<tr><td><code id="mice.impute.simputation_+3A_fun_args">Fun_args</code></td>
<td>
<p>Optional argument list for <code>Fun</code></p>
</td></tr>
<tr><td><code id="mice.impute.simputation_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection of imputation methods included in the <span class="pkg">simputation</span> package:
</p>
<p>linear regression: <code><a href="simputation.html#topic+impute_lm">simputation::impute_lm</a></code>, <br />
robist linear regression with M-estimators:
<code><a href="simputation.html#topic+impute_rlm">simputation::impute_rlm</a></code>, <br />
regularized regression with lasso/elasticnet/ridge regression:
<code><a href="simputation.html#topic+impute_en">simputation::impute_en</a></code>, <br />
CART models or random forests:
<code><a href="simputation.html#topic+impute_cart">simputation::impute_cart</a></code>,
<code><a href="simputation.html#topic+impute_rf">simputation::impute_rf</a></code>, <br />
Hot deck imputation:
<code><a href="simputation.html#topic+impute_rhd">simputation::impute_rhd</a></code>,
<code><a href="simputation.html#topic+impute_shd">simputation::impute_shd</a></code>, <br />
Predictive mean matching:
<code><a href="simputation.html#topic+impute_pmm">simputation::impute_pmm</a></code>, <br />
k-nearest neighbours imputation:
<code><a href="simputation.html#topic+impute_knn">simputation::impute_knn</a></code>
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Nhanes example
#############################################################################

library(mice)
library(simputation)

data(nhanes, package="mice")
dat &lt;- nhanes

#** imputation methods
method &lt;- c(age="",bmi="norm", hyp="norm", chl="simputation")
Fun &lt;- list( chl=simputation::impute_lm)
Fun_args &lt;- list( chl=list(add_residual="observed") )

#** do imputations
imp &lt;- mice::mice(dat, method=method, Fun=Fun, Fun_args=Fun_args)
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.smcfcs'>
Substantive Model Compatible Multiple Imputation (Single Level)
</h2><span id='topic+mice.impute.smcfcs'></span>

<h3>Description</h3>

<p>Computes substantive model compatible multiple imputation (Bartlett et al., 2015;
Bartlett &amp; Morris, 2015). Several regression functions are allowed (see <code>dep_type</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.smcfcs(y, ry, x, wy=NULL, sm, dep_type="norm", sm_type="norm",
       fac_sd_proposal=1, mh_iter=20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.smcfcs_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_wy">wy</code></td>
<td>
<p>Logical vector indicating positions where imputations
should be conducted.</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_sm">sm</code></td>
<td>
<p>Formula for substantive model.</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_dep_type">dep_type</code></td>
<td>
<p>Distribution type for variable which is imputed.
Possible choices are <code>"norm"</code> (normal distribution),
<code>"lognorm"</code> (lognormal distribution),
<code>"yj"</code> (Yeo-Johnson distribution,
see <code><a href="mdmb.html#topic+yjt_regression">mdmb::yjt_regression</a></code>), <code>"bc"</code>
(Box-Cox distribution, see
<code><a href="mdmb.html#topic+bct_regression">mdmb::bct_regression</a></code>), <code>"logistic"</code>
(logistic distribution).
</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_sm_type">sm_type</code></td>
<td>
<p>Distribution type for dependent variable in substantive model.
One of the distribution mentioned in <code>dep_type</code> can be chosen.</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_fac_sd_proposal">fac_sd_proposal</code></td>
<td>
<p>Starting value for factor of standard deviation in
Metropolis-Hastings sampling.</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_mh_iter">mh_iter</code></td>
<td>
<p>Number iterations in Metropolis-Hasting sampling</p>
</td></tr>
<tr><td><code id="mice.impute.smcfcs_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputed values are drawn based on a Metropolis-Hastings sampling algorithm
in which the standard deviation of the proposal distribution is adaptively tuned.
</p>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>References</h3>

<p>Bartlett, J. W., &amp; Morris, T. P. (2015). Multiple imputation of covariates by
substantive-model compatible fully conditional specification.
<em>Stata Journal, 15</em>(2), 437-456.
</p>
<p>Bartlett, J. W., Seaman, S. R., White, I. R., Carpenter, J. R., &amp; Alzheimer's Disease
Neuroimaging Initiative (2015). Multiple imputation of covariates by fully
conditional specification: Accommodating the substantive model.
<em>Statistical Methods in Medical Research, 24</em>(4), 462-487.
<a href="https://doi.org/10.1177/0962280214521348">doi:10.1177/0962280214521348</a>
</p>


<h3>See Also</h3>

<p>See the <span class="pkg">smcfcs</span> package for an alternative implementation of substantive model
multiple imputation in a fully conditional specification approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Substantive model with interaction effects
#############################################################################

library(mice)
library(mdmb)

#--- simulate data
set.seed(98)
N &lt;- 1000
x &lt;- stats::rnorm(N)
z &lt;- 0.5*x + stats::rnorm(N, sd=.7)
y &lt;- stats::rnorm(N, mean=.3*x - .2*z + .7*x*z, sd=1 )
dat &lt;- data.frame(x,z,y)
dat[ seq(1,N,3), c("x","y") ] &lt;- NA


#--- define imputation methods
imp &lt;- mice::mice(dat, maxit=0)
method &lt;- imp$method
method["x"] &lt;- "smcfcs"

# define substantive model
sm &lt;- y ~ x*z
# define formulas for imputation models
formulas &lt;- as.list( rep("",ncol(dat)))
names(formulas) &lt;- colnames(dat)
formulas[["x"]] &lt;- x ~ z
formulas[["y"]] &lt;- sm
formulas[["z"]] &lt;- z ~ 1

#- Yeo-Johnson distribution for x
dep_type &lt;- list()
dep_type$x &lt;- "yj"

#-- do imputation
imp &lt;- mice::mice(dat, method=method, sm=sm, formulas=formulas, m=1, maxit=10,
                   dep_type=dep_type)
summary(imp)

#############################################################################
# EXAMPLE 2: Substantive model with quadratic effects
#############################################################################

#** simulate data with missings
set.seed(50)
n &lt;- 1000
x &lt;- stats::rnorm(n)
z &lt;- stats::rnorm(n)
y &lt;- 0.5 * z + x + x^2 + stats::rnorm(n)
mm &lt;- stats::runif(n)
x[sample(1:n, size=370, prob=mm)] &lt;- NA
z[sample(1:n, size=480, prob=mm)] &lt;- NA
y[sample(1:n, size=500, prob=mm)] &lt;- NA

df &lt;- data.frame(x=x,y=y,z=z)

#** imputation
imp &lt;- mice::mice(df, method="smcfcs", sm=y ~ z + x + I(x^2), m=6, maxit=10)
summary(imp)

#** analysis
summary(mice::pool(with(imp, stats::lm(y ~ z + x + I(x^2)))))

#** imputation using the smcfcs package
df$x_sq &lt;- df$x^2
nonmice &lt;- smcfcs::smcfcs(df, smtype="lm", smformula=y ~ z + x + x_sq,
             method=c("norm", "", "norm", "x^2"))
mice::pool(lapply(nonmice$impDatasets, function(x) stats::lm(y ~ z + x + x_sq, data=x)))

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.synthpop'>
Using a <span class="pkg">synthpop</span> Synthesizing Method in the <span class="pkg">mice</span> Package
</h2><span id='topic+mice.impute.synthpop'></span>

<h3>Description</h3>

<p>The function allows to use a <span class="pkg">synthpop</span> synthesizing method to be used
in the <code><a href="mice.html#topic+mice">mice::mice</a></code> function of the <span class="pkg">mice</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.synthpop(y, ry, x, synthpop_fun="norm", synthpop_args=list(),
     proper=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.synthpop_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.synthpop_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.synthpop_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.synthpop_+3A_synthpop_fun">synthpop_fun</code></td>
<td>
<p>Synthesizing method in the <span class="pkg">synthpop</span> package</p>
</td></tr>
<tr><td><code id="mice.impute.synthpop_+3A_synthpop_args">synthpop_args</code></td>
<td>
<p>Function arguments of <code>syn_fun</code></p>
</td></tr>
<tr><td><code id="mice.impute.synthpop_+3A_proper">proper</code></td>
<td>
<p>Logical value specifying whether proper synthesis should be conducted.</p>
</td></tr>
<tr><td><code id="mice.impute.synthpop_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+syn.mice">syn.mice</a></code> for using a <span class="pkg">mice</span> imputation method in the
<span class="pkg">synthpop</span> package.
</p>
<p>See <code><a href="synthpop.html#topic+syn">synthpop::syn</a></code> for generating synthetic datasets
with the <span class="pkg">synthpop</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation of NHANES data using the 'syn.normrank' method
#############################################################################

library(synthpop)
data(nhanes, package="mice")
dat &lt;- nhanes

#* empty imputation
imp0 &lt;- mice::mice(dat, maxit=0)
method &lt;- imp0$method

#* define synthpop method 'normrank' for variable 'chl'
method["chl"] &lt;- "synthpop"
synthpop_fun &lt;- list( chl="normrank" )
synthpop_args &lt;- list( chl=list(smoothing="density") )

#* conduct imputation
imp &lt;- mice::mice(dat, method=method, m=1, maxit=3, synthpop_fun=synthpop_fun,
            synthpop_args=synthpop_args)
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.tricube.pmm'>
Imputation by Tricube Predictive Mean Matching
</h2><span id='topic+mice.impute.tricube.pmm'></span>

<h3>Description</h3>

<p>This function performs tricube predictive mean matching (see
<code>Hmisc::aregImpute</code>)
in which donors are weighted according to distances of predicted values.
Three donors are chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.tricube.pmm(y, ry, x, tricube.pmm.scale=0.2, tricube.boot=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.tricube.pmm_+3A_y">y</code></td>
<td>

<p>Incomplete data vector of length <code>n</code>
</p>
</td></tr>
<tr><td><code id="mice.impute.tricube.pmm_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.tricube.pmm_+3A_x">x</code></td>
<td>

<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.tricube.pmm_+3A_tricube.pmm.scale">tricube.pmm.scale</code></td>
<td>

<p>A scaling factor for tricube matching. The default is 0.2.
</p>
</td></tr>
<tr><td><code id="mice.impute.tricube.pmm_+3A_tricube.boot">tricube.boot</code></td>
<td>

<p>A logical indicating whether tricube matching should be performed
using a bootstrap sample
</p>
</td></tr>
<tr><td><code id="mice.impute.tricube.pmm_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>See Also</h3>

<p><code>Hmisc::aregImpute</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Tricube predictive mean matching for nhanes data
#############################################################################

library(mice)
data(nhanes, package="mice")
set.seed(9090)

#*** Model 1: Use default of tricube predictive mean matching
varnames &lt;- colnames(nhanes)
VV &lt;- length(varnames)
method &lt;- rep("tricube.pmm", VV )
names(method) &lt;- varnames
# imputation with mice
imp.mi1 &lt;- mice::mice( nhanes, m=5, maxit=4, method=method )

#*** Model 2: use item-specific imputation methods
iM2 &lt;- method
iM2["bmi"] &lt;- "pmm6"
# use imputation method 'tricube.pmm' for hyp and chl
# select different scale parameters for these variables
tricube.pmm.scale1 &lt;- list( "hyp"=.15, "chl"=.30 )
imp.mi2 &lt;- miceadds::mice.1chain( nhanes, burnin=5, iter=20, Nimp=4,
               method=iM2, tricube.pmm.scale=tricube.pmm.scale1  )

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.impute.weighted.pmm'>
Imputation by Weighted Predictive Mean Matching or Weighted Normal Linear Regression
</h2><span id='topic+mice.impute.weighted.pmm'></span><span id='topic+mice.impute.weighted.norm'></span>

<h3>Description</h3>

<p>Imputation by predictive mean matching or normal linear regression
using sampling weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.impute.weighted.pmm(y, ry, x, wy=NULL, imputationWeights=NULL,
      pls.facs=NULL, interactions=NULL, quadratics=NULL, donors=5, ...)

mice.impute.weighted.norm(y, ry, x, wy=NULL, ridge=1e-05, pls.facs=NULL,
     imputationWeights=NULL, interactions=NULL, quadratics=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.impute.weighted.pmm_+3A_y">y</code></td>
<td>
<p>Incomplete data vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_ry">ry</code></td>
<td>

<p>Vector of missing data pattern (<code>FALSE</code> &ndash; missing,
<code>TRUE</code> &ndash; observed)
</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_x">x</code></td>
<td>
<p>Matrix (<code>n</code> x <code>p</code>) of complete covariates.
</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_wy">wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value indicates
locations in <code>y</code> for which imputations are created.</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_imputationweights">imputationWeights</code></td>
<td>

<p>Optional vector of sampling weights
</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_pls.facs">pls.facs</code></td>
<td>

<p>Number of factors in PLS regression (if used). The default is <code>NULL</code>
which means that no PLS regression is used for dimension reduction.
</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_interactions">interactions</code></td>
<td>

<p>Optional vector of variables for which interactions should be created
</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_quadratics">quadratics</code></td>
<td>

<p>Optional vector of variables which should also be included as quadratic effects.
</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_donors">donors</code></td>
<td>
<p>Number of donors</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
<tr><td><code id="mice.impute.weighted.pmm_+3A_ridge">ridge</code></td>
<td>

<p>Ridge parameter in the diagonal of <code class="reqn"> \bold{X}'\bold{X}</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nmis=sum(!ry)</code> with imputed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation using sample weights
#############################################################################

data( data.ma01)
set.seed(977)

# select subsample
dat &lt;- as.matrix(data.ma01)
dat &lt;- dat[ 1:1000, ]

# empty imputation
imp0 &lt;- mice::mice( dat, maxit=0)

# redefine imputation methods
meth &lt;- imp0$method
meth[ meth=="pmm"  ] &lt;- "weighted.pmm"
meth[ c("paredu", "books", "migrant" ) ] &lt;- "weighted.norm"
# redefine predictor matrix
pm &lt;- imp0$predictorMatrix
pm[, 1:3 ] &lt;- 0
# do imputation
imp &lt;- mice::mice( dat, predictorMatrix=pm, method=meth,
           imputationWeights=dat[,"studwgt"], m=3, maxit=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='mice.nmi'>
Nested Multiple Imputation
</h2><span id='topic+mice.nmi'></span><span id='topic+summary.mids.nmi'></span><span id='topic+print.mids.nmi'></span>

<h3>Description</h3>

<p>Performs nested multiple imputation (Rubin, 2003) for the functions
<code><a href="mice.html#topic+mice">mice::mice</a></code> and <code><a href="#topic+mice.1chain">mice.1chain</a></code>.
The function <code>mice.nmi</code> generates an object of class <code>mids.nmi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice.nmi(datlist, type="mice", ...)

## S3 method for class 'mids.nmi'
summary(object, ...)

## S3 method for class 'mids.nmi'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice.nmi_+3A_datlist">datlist</code></td>
<td>

<p>List of datasets for which nested multiple imputation should be applied
</p>
</td></tr>
<tr><td><code id="mice.nmi_+3A_type">type</code></td>
<td>

<p>Imputation model: <code>type="mice"</code> for <code><a href="mice.html#topic+mice">mice::mice</a></code>  or
<code>type="mice.1chain"</code> for <code><a href="#topic+mice.1chain">mice.1chain</a></code>.
</p>
</td></tr>
<tr><td><code id="mice.nmi_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to <code><a href="mice.html#topic+mice">mice::mice</a></code>  or
<code><a href="#topic+mice.1chain">mice.1chain</a></code>.
</p>
</td></tr>
<tr><td><code id="mice.nmi_+3A_object">object</code></td>
<td>
<p>Object of class <code>mids.nmi</code>.</p>
</td></tr>
<tr><td><code id="mice.nmi_+3A_x">x</code></td>
<td>
<p>Object of class <code>mids.nmi</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>mids.nmi</code> with entries
</p>
<table>
<tr><td><code>imp</code></td>
<td>
<p>List of nested multiply imputed datasets whose entries
are of class <code>mids</code> or <code>mids.1chain</code>.</p>
</td></tr>
<tr><td><code>Nimp</code></td>
<td>
<p>Number of between and within imputations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rubin, D. B. (2003). Nested multiple imputation of NMES via partially
incompatible MCMC. <em>Statistica Neerlandica, 57</em>(1), 3-18.
<a href="https://doi.org/10.1111/1467-9574.00217">doi:10.1111/1467-9574.00217</a>
</p>


<h3>See Also</h3>

<p>For imputation models see <code><a href="mice.html#topic+mice">mice::mice</a></code>
and <code><a href="#topic+mice.1chain">mice.1chain</a></code>.
</p>
<p>Functions for analyses of nested multiply imputed datasets:
<code><a href="#topic+complete.mids.nmi">complete.mids.nmi</a></code>, <code><a href="#topic+with.mids.nmi">with.mids.nmi</a></code>,
<code><a href="#topic+pool.mids.nmi">pool.mids.nmi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Nested multiple imputation for TIMSS data
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2
   # list of 5 datasets containing 5 plausible values

#** define imputation method and predictor matrix
data &lt;- datlist[[1]]
V &lt;- ncol(data)
# variables
vars &lt;- colnames(data)
# variables not used for imputation
vars_unused &lt;- miceadds::scan.vec("IDSTUD TOTWGT  JKZONE  JKREP" )

#- define imputation method
impMethod &lt;- rep("norm", V )
names(impMethod) &lt;- vars
impMethod[ vars_unused ] &lt;- ""

#- define predictor matrix
predM &lt;- matrix( 1, V, V )
colnames(predM) &lt;- rownames(predM) &lt;- vars
diag(predM) &lt;- 0
predM[, vars_unused ] &lt;- 0

#***************
# (1) nested multiple imputation using mice
imp1 &lt;- miceadds::mice.nmi( datlist, method=impMethod, predictorMatrix=predM,
                m=4, maxit=3 )
summary(imp1)

#***************
# (2) nested multiple imputation using mice.1chain
imp2 &lt;- miceadds::mice.nmi( datlist, method=impMethod, predictorMatrix=predM,
            Nimp=4, burnin=10,iter=22, type="mice.1chain")
summary(imp2)

## End(Not run)
</code></pre>

<hr>
<h2 id='miceadds-defunct'>Defunct <span class="pkg">miceadds</span> Functions</h2><span id='topic+miceadds-defunct'></span><span id='topic+mice.impute.2l.pls'></span><span id='topic+fast.groupmean'></span><span id='topic+fast.groupsum'></span><span id='topic+mice.impute.2l.plausible.values'></span><span id='topic+mice.impute.2lonly.pmm2'></span><span id='topic+mice.impute.2lonly.norm2'></span><span id='topic+mice.impute.tricube.pmm2'></span>

<h3>Description</h3>

<p>These functions have been removed or replaced in the <span class="pkg">miceadds</span>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.groupmean(...)
fast.groupsum(...)
mice.impute.2l.plausible.values(...)
mice.impute.2l.pls(...)
mice.impute.2lonly.norm2(...)
mice.impute.2lonly.pmm2(...)
mice.impute.tricube.pmm2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miceadds-defunct_+3A_...">...</code></td>
<td>
<p>Arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fast.groupmean</code> function has been replaced by
<code><a href="#topic+GroupMean">GroupMean</a></code>.
</p>
<p>The <code>fast.groupsum</code> function has been replaced by
<code><a href="#topic+GroupSum">GroupSum</a></code>.
</p>
<p>The <code>mice.impute.2l.plausible.values</code> function has been replaced by
<code><a href="#topic+mice.impute.plausible.values">mice.impute.plausible.values</a></code>.
</p>
<p>The <code>mice.impute.2l.pls2</code> function has been replaced by
<code><a href="#topic+mice.impute.pls">mice.impute.pls</a></code>.
</p>
<p>The <code>mice.impute.2lonly.norm2</code> and <code>mice.impute.2lonly.pmm2</code>
functions can be safely replaced by the
<code><a href="mice.html#topic+mice.impute.2lonly.norm">mice::mice.impute.2lonly.norm</a></code> and
<code><a href="mice.html#topic+mice.impute.2lonly.pmm">mice::mice.impute.2lonly.pmm</a></code>
functions in the <span class="pkg">mice</span> package.
</p>
<p>The <code>mice.impute.tricube.pmm2</code> function has been replaced by
<code><a href="#topic+mice.impute.tricube.pmm">mice.impute.tricube.pmm</a></code>.
</p>

<hr>
<h2 id='miceadds-utilities'>Utility Functions in <span class="pkg">miceadds</span></h2><span id='topic+miceadds-utilities'></span><span id='topic+ma_exists_get'></span><span id='topic+ma_exists'></span><span id='topic+mice_imputation_get_states'></span>

<h3>Description</h3>

<p>Utility functions in <span class="pkg">miceadds</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## searches for objects in parent environments
ma_exists_get( x, pos, n_index=1:8)
ma_exists( x, pos, n_index=1:8)
mice_imputation_get_states( pos=parent.frame(n=1), n_index=1:20 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miceadds-utilities_+3A_x">x</code></td>
<td>
<p>Object name (character)</p>
</td></tr>
<tr><td><code id="miceadds-utilities_+3A_pos">pos</code></td>
<td>
<p>Environment</p>
</td></tr>
<tr><td><code id="miceadds-utilities_+3A_n_index">n_index</code></td>
<td>
<p>Levels in <code>parent.frame</code> in which object is searched</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>ma_exists_get</code> is used in <code>miceadds:::mice_imputation_get_states</code>.
</p>

<hr>
<h2 id='micombine.chisquare'>
Combination of Chi Square Statistics of Multiply Imputed Datasets
</h2><span id='topic+micombine.chisquare'></span>

<h3>Description</h3>

<p>This function does inference for the <code class="reqn">\chi^2</code> statistic based on multiply
imputed datasets (see e.g. Enders, 2010, p. 239 ff.; Allison, 2002).
This function is also denoted as the <code class="reqn">D_2</code> statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>micombine.chisquare(dk, df, display=TRUE, version=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="micombine.chisquare_+3A_dk">dk</code></td>
<td>

<p>Vector of chi square statistics
</p>
</td></tr>
<tr><td><code id="micombine.chisquare_+3A_df">df</code></td>
<td>

<p>Degrees of freedom of <code class="reqn">\chi^2</code> statistic
</p>
</td></tr>
<tr><td><code id="micombine.chisquare_+3A_display">display</code></td>
<td>

<p>An optional logical indicating whether results should be printed at the
<span class="rlang"><b>R</b></span> console.
</p>
</td></tr>
<tr><td><code id="micombine.chisquare_+3A_version">version</code></td>
<td>
<p>Integer indicating which calculation formula should be used.
The default <code>version=1</code> refers to the correct formula as in Enders (2010),
while <code>version=0</code> uses an incorrect formula as printed in Allison (2001).
The incorrect calculation <code>version=0</code> was included in <span class="pkg">miceadds</span> versions
smaller than version 2.0.
See also <em>http://statisticalhorizons.com/wp-content/uploads/2012/01/combchi.sas</em>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with following entries
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>Combined <code class="reqn">D_2</code> statistic which is approximately <code class="reqn">F</code>-distributed
with (<code>df</code>, <code>df2</code>) degrees of freedom</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The p value corresponding to <code>D</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Numerator degrees of freedom</p>
</td></tr>
<tr><td><code>df2</code></td>
<td>
<p>Denominator degrees of freedom</p>
</td></tr>
</table>


<h3>References</h3>

<p>Allison, P. D. (2002). <em>Missing data</em>. Newbury Park, CA: Sage.
</p>
<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>. Guilford Press.
</p>


<h3>See Also</h3>

<p>See also <code><a href="mice.html#topic+pool.compare">mice::pool.compare</a></code>
for a Wald test to compare two fitted models in the <span class="pkg">mice</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Chi square values of analyses from 7 multiply imputed datasets
#############################################################################

# Vector of 7 chi square statistics
dk &lt;- c(24.957, 18.051, 18.812, 17.362, 21.234, 18.615, 19.84)
dk.comb &lt;- miceadds::micombine.chisquare(dk=dk, df=4 )
  ##  Combination of Chi Square Statistics for Multiply Imputed Data
  ##  Using 7 Imputed Data Sets
  ##  F(4, 482.06)=4.438     p=0.00157
</code></pre>

<hr>
<h2 id='micombine.cor'>
Inference for Correlations and Covariances for Multiply Imputed Datasets
</h2><span id='topic+micombine.cor'></span><span id='topic+micombine.cov'></span>

<h3>Description</h3>

<p>Statistical inference for correlations and covariances
for multiply imputed datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>micombine.cor(mi.res, variables=NULL, conf.level=0.95,
     method="pearson", nested=FALSE, partial=NULL )

micombine.cov(mi.res, variables=NULL, conf.level=0.95,
     nested=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="micombine.cor_+3A_mi.res">mi.res</code></td>
<td>

<p>Object of class <code>mids</code> or <code>mids.1chain</code>
</p>
</td></tr>
<tr><td><code id="micombine.cor_+3A_variables">variables</code></td>
<td>

<p>Indices of variables for selection
</p>
</td></tr>
<tr><td><code id="micombine.cor_+3A_conf.level">conf.level</code></td>
<td>

<p>Confidence level
</p>
</td></tr>
<tr><td><code id="micombine.cor_+3A_method">method</code></td>
<td>
<p>Method for calculating correlations. Must be one
of <code>"pearson"</code> or <code>"spearman"</code>. The default is the
calculation of the Pearson correlation.
</p>
</td></tr>
<tr><td><code id="micombine.cor_+3A_nested">nested</code></td>
<td>
<p>Logical indicating whether the input dataset stems from
a nested multiple imputation.</p>
</td></tr>
<tr><td><code id="micombine.cor_+3A_partial">partial</code></td>
<td>
<p>Formula object for computing partial correlations. The
terms which should be residualized are written in the formula
object <code>partial</code>. Alternatively, it can be a vector of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the coefficients (<code>r</code>, <code>cov</code>) and its
corresponding standard error (<code>rse</code>, <code>cov_se</code>),
fraction of missing information
(<code>fmi</code>) and a <code class="reqn">t</code> value (<code>t</code>).
</p>
<p>The corresponding coefficients can also be obtained as matrices
by requesting <code>attr(result,"r_matrix")</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+cor.test">stats::cor.test</a></code> for testing
correlation coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: nhanes data | combination of correlation coefficients
#############################################################################

library(mice)
data(nhanes, package="mice")
set.seed(9090)

# nhanes data in one chain
imp.mi &lt;- miceadds::mice.1chain( nhanes, burnin=5, iter=20, Nimp=4,
                  method=rep("norm", 4) )

# correlation coefficients of variables 4, 2 and 3 (indexed in nhanes data)
res &lt;- miceadds::micombine.cor(mi.res=imp.mi, variables=c(4,2,3) )
  ##     variable1 variable2       r    rse fisher_r fisher_rse    fmi       t      p
  ##   1       chl       bmi  0.2458 0.2236   0.2510     0.2540 0.3246  0.9879 0.3232
  ##   2       chl       hyp  0.2286 0.2152   0.2327     0.2413 0.2377  0.9643 0.3349
  ##   3       bmi       hyp -0.0084 0.2198  -0.0084     0.2351 0.1904 -0.0358 0.9714
  ##     lower95 upper95
  ##   1 -0.2421  0.6345
  ##   2 -0.2358  0.6080
  ##   3 -0.4376  0.4239

# extract matrix with correlations and its standard errors
attr(res, "r_matrix")
attr(res, "rse_matrix")

# inference for covariance
res2 &lt;- miceadds::micombine.cov(mi.res=imp.mi, variables=c(4,2,3) )

# inference can also be conducted for non-imputed data
res3 &lt;- miceadds::micombine.cov(mi.res=nhanes, variables=c(4,2,3) )

# partial correlation residualizing bmi and chl
res4 &lt;- miceadds::micombine.cor(mi.res=imp.mi, variables=c("age","hyp" ),
                  partial=~bmi+chl )
res4
# alternatively, 'partial' can also be defined as c('age','hyp')

#############################################################################
# EXAMPLE 2: nhanes data | comparing different correlation coefficients
#############################################################################

library(psych)
library(mitools)

# imputing data
imp1 &lt;- mice::mice( nhanes,  method=rep("norm", 4 ) )
summary(imp1)

#*** Pearson correlation
res1 &lt;- miceadds::micombine.cor(mi.res=imp1, variables=c(4,2) )

#*** Spearman rank correlation
res2 &lt;- miceadds::micombine.cor(mi.res=imp1, variables=c(4,2),  method="spearman")

#*** Kendalls tau
# test of computation of tau for first imputed dataset
dat1 &lt;- mice::complete(imp1, action=1)
tau1 &lt;- psych::corr.test(x=dat1[,c(4,2)], method="kendall")
tau1$r[1,2]    # estimate
tau1$se     # standard error

# results of Kendalls tau for all imputed datasets
res3 &lt;- with( data=imp1,
        expr=psych::corr.test( x=cbind( chl, bmi ), method="kendall") )
# extract estimates
betas &lt;- lapply( res3$analyses, FUN=function(ll){ ll$r[1,2] } )
# extract variances
vars &lt;- lapply( res3$analyses, FUN=function(ll){ (ll$se[1,2])^2 } )
# Rubin inference
tau_comb &lt;- mitools::MIcombine( results=betas, variances=vars )
summary(tau_comb)

#############################################################################
# EXAMPLE 3: Inference for correlations for nested multiply imputed datasets
#############################################################################

library(BIFIEsurvey)
data(data.timss4, package="BIFIEsurvey" )
datlist &lt;- data.timss4

# object of class nested.datlist
datlist &lt;- miceadds::nested.datlist_create(datlist)
# inference for correlations
res2 &lt;- miceadds::micombine.cor(mi.res=datlist, variables=c("lang", "migrant", "ASMMAT"))

## End(Not run)
</code></pre>

<hr>
<h2 id='micombine.F'>
Combination of F Statistics for Multiply Imputed Datasets Using a
Chi Square Approximation
</h2><span id='topic+micombine.F'></span>

<h3>Description</h3>

<p>Several <code class="reqn">F</code> statistics from multiply imputed datasets are combined using
an approximation based on <code class="reqn">\chi^2</code> statistics
(see <code><a href="#topic+micombine.chisquare">micombine.chisquare</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>micombine.F(Fvalues, df1, display=TRUE, version=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="micombine.F_+3A_fvalues">Fvalues</code></td>
<td>

<p>Vector containing <code class="reqn">F</code> values.
</p>
</td></tr>
<tr><td><code id="micombine.F_+3A_df1">df1</code></td>
<td>

<p>Degrees of freedom of the numerator. Degrees of freedom of the
numerator are approximated by <code class="reqn">\infty</code> (large number of degrees
of freedom).
</p>
</td></tr>
<tr><td><code id="micombine.F_+3A_display">display</code></td>
<td>

<p>A logical indicating whether results should be displayed at the console
</p>
</td></tr>
<tr><td><code id="micombine.F_+3A_version">version</code></td>
<td>
<p>Integer indicating which calculation formula should be used.
The default <code>version=1</code> refers to the correct formula as in Enders (2010),
while <code>version=0</code> uses an incorrect formula as printed in Allison (2001).
The incorrect calculation <code>version=0</code> was included in <span class="pkg">miceadds</span> versions
smaller than version 2.0.
See also <em>http://statisticalhorizons.com/wp-content/uploads/2012/01/combchi.sas</em>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same output as in <code><a href="#topic+micombine.chisquare">micombine.chisquare</a></code>
</p>


<h3>References</h3>

<p>Allison, P. D. (2002). <em>Missing data</em>. Newbury Park, CA: Sage.
</p>
<p>Enders, C. K. (2010). <em>Applied missing data analysis</em>. Guilford Press.
</p>
<p>Grund, S., Luedtke, O., &amp; Robitzsch, A. (2016). Pooling ANOVA results from
multiply imputed datasets: A simulation study.
<em>Methodology, 12</em>(3), 75-88.
<a href="https://doi.org/10.1027/1614-2241/a000111">doi:10.1027/1614-2241/a000111</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+micombine.chisquare">micombine.chisquare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: F statistics for 5 imputed datasets
#############################################################################

Fvalues &lt;- c( 6.76, 4.54, 4.23, 5.45, 4.78 )
micombine.F(Fvalues, df1=4 )
  ##  Combination of Chi Square Statistics for Multiply Imputed Data
  ##  Using 5 Imputed Data Sets
  ##  F(4, 52.94)=3.946     p=0.00709
</code></pre>

<hr>
<h2 id='mids2datlist'>
Converting a <code>mids</code>, <code>mids.1chain</code> or <code>mids.nmi</code>
Object in a Dataset List
</h2><span id='topic+mids2datlist'></span>

<h3>Description</h3>

<p>Converts a <code>mids</code>, <code>mids.1chain</code> or <code>mids.nmi</code>
object in a dataset list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mids2datlist(midsobj, X=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mids2datlist_+3A_midsobj">midsobj</code></td>
<td>

<p>Object of class <code>mids</code>, <code>mids.1chain</code> or <code>mids.nmi</code>
</p>
</td></tr>
<tr><td><code id="mids2datlist_+3A_x">X</code></td>
<td>
<p>Optional data frame of variables to be included in
imputed datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of multiply imputed datasets of classes
<code>datlist</code> or <code>nested.datlist</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputing nhanes data and convert result into a dataset list
#############################################################################

data(nhanes,package="mice")

#**** imputation using mice
imp1 &lt;- mice::mice( nhanes, m=3, maxit=5 )
# convert mids object into list
datlist1 &lt;- miceadds::mids2datlist( imp1 )

#**** imputation using mice.1chain
imp2 &lt;- miceadds::mice.1chain( nhanes, burnin=4, iter=20, Nimp=5 )
# convert mids.1chain object into list
datlist2 &lt;- miceadds::mids2datlist( imp2 )

#############################################################################
# EXAMPLE 2: Nested multiple imputation and datalist conversion
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2
   # list of 5 datasets containing 5 plausible values

# remove first four variables
M &lt;- length(datlist)
for (ll in 1:M){
    datlist[[ll]] &lt;- datlist[[ll]][, -c(1:4) ]
                }

#***************
# (1) nested multiple imputation using mice
imp1 &lt;- miceadds::mice.nmi( datlist,  m=4, maxit=3 )
summary(imp1)

#***************
# (2) nested multiple imputation using mice.1chain
imp2 &lt;- miceadds::mice.nmi( datlist, Nimp=4, burnin=10,iter=22, type="mice.1chain")
summary(imp2)

#**************
# conversion into a datalist
datlist.i1 &lt;- miceadds::mids2datlist( imp1 )
datlist.i2 &lt;- miceadds::mids2datlist( imp2 )

#############################################################################
# EXAMPLE 3: mids object conversion and inclusion of further variables
#############################################################################

data(data.ma05)
dat &lt;- data.ma05

# imputation
resp &lt;- dat[, - c(1:2) ]
imp &lt;- mice::mice( resp, method="norm", maxit=2, m=3 )

# convert mids object into datalist
datlist0 &lt;- miceadds::mids2datlist( imp )
# convert mids object into datalist and include some id variables
datlist1 &lt;- miceadds::mids2datlist( imp, X=dat[,c(1,2) ] )

## End(Not run)
</code></pre>

<hr>
<h2 id='mids2mlwin'>Export <code>mids</code> object to MLwiN</h2><span id='topic+mids2mlwin'></span>

<h3>Description</h3>

<p>Converts a <code>mids</code> object into a format recognized by the multilevel
software MLwiN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mids2mlwin(imp, file.prefix, path=getwd(), sep=" ", dec=".", silent=FALSE,
   X=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mids2mlwin_+3A_imp">imp</code></td>
<td>
<p>The <code>imp</code> argument is an object of class
<code>mids</code>, typically produced by the <code>mice()</code>
function.</p>
</td></tr>
<tr><td><code id="mids2mlwin_+3A_file.prefix">file.prefix</code></td>
<td>
<p>A character string describing the
prefix of the output data files.</p>
</td></tr>
<tr><td><code id="mids2mlwin_+3A_path">path</code></td>
<td>
<p>A character string containing the path of the
output file.  By default, files are written to the
current <code>R</code> working directory.</p>
</td></tr>
<tr><td><code id="mids2mlwin_+3A_sep">sep</code></td>
<td>
<p>The separator between the data fields.</p>
</td></tr>
<tr><td><code id="mids2mlwin_+3A_dec">dec</code></td>
<td>
<p>The decimal separator for numerical data.</p>
</td></tr>
<tr><td><code id="mids2mlwin_+3A_silent">silent</code></td>
<td>
<p>A logical flag stating whether the names of
the files should be printed.</p>
</td></tr>
<tr><td><code id="mids2mlwin_+3A_x">X</code></td>
<td>
<p>Optional data frame of variables to be included in
imputed datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Thorsten Henke
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# imputation nhanes data
data(nhanes)
imp &lt;- mice::mice(nhanes)
# write files to MLwiN
mids2mlwin(imp, file.prefix="nhanes" )

## End(Not run)
</code></pre>

<hr>
<h2 id='ml_mcmc'>
MCMC Estimation for Mixed Effects Model
</h2><span id='topic+ml_mcmc'></span><span id='topic+ml_mcmc_fit'></span><span id='topic+plot.ml_mcmc'></span><span id='topic+summary.ml_mcmc'></span><span id='topic+coef.ml_mcmc'></span><span id='topic+vcov.ml_mcmc'></span><span id='topic+miceadds_rcpp_ml_mcmc_sample_beta'></span><span id='topic+miceadds_rcpp_ml_mcmc_sample_u'></span><span id='topic+miceadds_rcpp_ml_mcmc_sample_psi'></span><span id='topic+miceadds_rcpp_ml_mcmc_sample_sigma2'></span><span id='topic+miceadds_rcpp_ml_mcmc_sample_latent_probit'></span><span id='topic+miceadds_rcpp_ml_mcmc_sample_thresholds'></span><span id='topic+miceadds_rcpp_ml_mcmc_predict_fixed_random'></span><span id='topic+miceadds_rcpp_ml_mcmc_predict_random_list'></span><span id='topic+miceadds_rcpp_ml_mcmc_predict_random'></span><span id='topic+miceadds_rcpp_ml_mcmc_predict_fixed'></span><span id='topic+miceadds_rcpp_ml_mcmc_subtract_fixed'></span><span id='topic+miceadds_rcpp_ml_mcmc_subtract_random'></span><span id='topic+miceadds_rcpp_ml_mcmc_compute_ztz'></span><span id='topic+miceadds_rcpp_ml_mcmc_compute_xtx'></span><span id='topic+miceadds_rcpp_ml_mcmc_probit_category_prob'></span><span id='topic+miceadds_rcpp_pnorm'></span><span id='topic+miceadds_rcpp_qnorm'></span><span id='topic+miceadds_rcpp_rtnorm'></span>

<h3>Description</h3>

<p>Fits a mixed effects model via MCMC. The outcome can be normally distributed
or ordinal (Goldstein, 2011; Goldstein, Carpenter, Kenward &amp; Levin, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ml_mcmc( formula, data, iter=3000, burnin=500, print_iter=100, outcome="normal",
     nu0=NULL, s0=1, psi_nu0_list=NULL, psi_S0_list=NULL, inits_lme4=FALSE,
     thresh_fac=5.8, ridge=1e-5)

## S3 method for class 'ml_mcmc'
summary(object, digits=4, file=NULL, ...)

## S3 method for class 'ml_mcmc'
plot(x, ask=TRUE, ...)

## S3 method for class 'ml_mcmc'
coef(object, ...)

## S3 method for class 'ml_mcmc'
vcov(object, ...)

ml_mcmc_fit(y, X, Z_list, beta, Psi_list, sigma2, alpha, u_list, idcluster_list,
    onlyintercept_list, ncluster_list, sigma2_nu0, sigma2_sigma2_0, psi_nu0_list,
    psi_S0_list, est_sigma2, est_probit, parameter_index, est_parameter, npar, iter,
    save_iter, verbose=TRUE, print_iter=500, parnames0=NULL, K=9999, est_thresh=FALSE,
    thresh_fac=5.8, ridge=1e-5, parm_summary=TRUE )

## exported Rcpp functions
miceadds_rcpp_ml_mcmc_sample_beta(xtx_inv, X, Z_list, y, u_list, idcluster_list, sigma2,
     onlyintercept_list, NR, ridge)
miceadds_rcpp_ml_mcmc_sample_u(X, beta, Z_list, y, ztz_list, idcluster_list,
    ncluster_list, sigma2, Psi_list, onlyintercept_list, NR, u0_list, ridge)
miceadds_rcpp_ml_mcmc_sample_psi(u_list, nu0_list, S0_list, NR, ridge)
miceadds_rcpp_ml_mcmc_sample_sigma2(y, X, beta, Z_list, u_list, idcluster_list,
     onlyintercept_list, nu0, sigma2_0, NR, ridge)
miceadds_rcpp_ml_mcmc_sample_latent_probit(X, beta, Z_list, u_list, idcluster_list, NR,
     y_int, alpha, minval, maxval)
miceadds_rcpp_ml_mcmc_sample_thresholds(X, beta, Z_list, u_list, idcluster_list, NR, K,
     alpha, sd_proposal, y_int)
miceadds_rcpp_ml_mcmc_predict_fixed_random(X, beta, Z_list, u_list, idcluster_list, NR)
miceadds_rcpp_ml_mcmc_predict_random_list(Z_list, u_list, idcluster_list, NR, N)
miceadds_rcpp_ml_mcmc_predict_random(Z, u, idcluster)
miceadds_rcpp_ml_mcmc_predict_fixed(X, beta)
miceadds_rcpp_ml_mcmc_subtract_fixed(y, X, beta)
miceadds_rcpp_ml_mcmc_subtract_random(y, Z, u, idcluster, onlyintercept)
miceadds_rcpp_ml_mcmc_compute_ztz(Z, idcluster, ncluster)
miceadds_rcpp_ml_mcmc_compute_xtx(X)
miceadds_rcpp_ml_mcmc_probit_category_prob(y_int, alpha, mu1, use_log)
miceadds_rcpp_pnorm(x, mu, sigma)
miceadds_rcpp_qnorm(x, mu, sigma)
miceadds_rcpp_rtnorm(mu, sigma, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ml_mcmc_+3A_formula">formula</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> formula in <span class="pkg">lme4</span>-like specification</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_data">data</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_iter">iter</code></td>
<td>

<p>Number of iterations
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_burnin">burnin</code></td>
<td>
<p>Number of burnin iterations</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_print_iter">print_iter</code></td>
<td>

<p>Integer indicating that every <code>print_iter</code>th iteration progress
should be displayed</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_outcome">outcome</code></td>
<td>
<p>Outcome distribution: <code>"normal"</code> or <code>"probit"</code></p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_nu0">nu0</code></td>
<td>
<p>Prior sample size</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_s0">s0</code></td>
<td>
<p>Prior guess for variance</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_inits_lme4">inits_lme4</code></td>
<td>
<p>Logical indicating whether initial values should
be obtained from fitting the model in the <span class="pkg">lme4</span> package</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_thresh_fac">thresh_fac</code></td>
<td>
<p>Factor for proposal variance for estimating thresholds
which is determined as <code>thresh_fac</code><code class="reqn">/N</code> (<code class="reqn">5.8/N</code> as default).
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_ridge">ridge</code></td>
<td>
<p>Ridge parameter for covariance matrices in sampling</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_object">object</code></td>
<td>
<p>Object of class <code>ml_mcmc</code></p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_digits">digits</code></td>
<td>
<p>Number of digits after decimal used for printing</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_file">file</code></td>
<td>
<p>Optional file name</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_x">x</code></td>
<td>
<p>Object of class <code>ml_mcmc</code></p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_ask">ask</code></td>
<td>
<p>Logical indicating whether display of the next plot should be requested
via clicking</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_y">y</code></td>
<td>

<p>Outcome vector
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_x">X</code></td>
<td>

<p>Design matrix fixed effects
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_z_list">Z_list</code></td>
<td>

<p>Design matrices random effects
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_beta">beta</code></td>
<td>

<p>Initial vector fixed coefficients
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_psi_list">Psi_list</code></td>
<td>

<p>Initial covariance matrices random effects
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_sigma2">sigma2</code></td>
<td>

<p>Initial residual covariance matrix
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_alpha">alpha</code></td>
<td>
<p>Vector of thresholds</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_u_list">u_list</code></td>
<td>

<p>List with initial values for random effects
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_idcluster_list">idcluster_list</code></td>
<td>

<p>List with cluster identifiers for random effects
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_onlyintercept_list">onlyintercept_list</code></td>
<td>

<p>List of logicals indicating whether only random intercepts are used
for a corresponding random effect
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_ncluster_list">ncluster_list</code></td>
<td>

<p>List containing number of clusters for each random effect
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_sigma2_nu0">sigma2_nu0</code></td>
<td>

<p>Prior sample size residual variance
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_sigma2_sigma2_0">sigma2_sigma2_0</code></td>
<td>

<p>Prior guess residual variance
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_psi_nu0_list">psi_nu0_list</code></td>
<td>

<p>List of prior sample sizes for covariance matrices of random effects
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_psi_s0_list">psi_S0_list</code></td>
<td>

<p>List of prior guesses for covariance matrices of random effects
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_est_sigma2">est_sigma2</code></td>
<td>

<p>Logical indicating whether residual variance should be estimated
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_est_probit">est_probit</code></td>
<td>

<p>Logical indicating whether probit model for ordinal outcomes should be estimated
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_parameter_index">parameter_index</code></td>
<td>

<p>List containing integers for saving parameters
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_est_parameter">est_parameter</code></td>
<td>

<p>List of logicals indicating which parameter type should be estimated
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_npar">npar</code></td>
<td>

<p>Number of parameters
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_save_iter">save_iter</code></td>
<td>

<p>Vector indicating which iterations should be used
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_verbose">verbose</code></td>
<td>

<p>Logical indicating whether progress should be displayed
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_parnames0">parnames0</code></td>
<td>

<p>Optional vector of parameter names
</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_k">K</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_est_thresh">est_thresh</code></td>
<td>
<p>Logical indicating whether thresholds should be estimated</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_parm_summary">parm_summary</code></td>
<td>
<p>Logical indicating whether a parameter summary table
should be computed</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_xtx_inv">xtx_inv</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_nr">NR</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_ztz_list">ztz_list</code></td>
<td>
<p>List containing design matrices for random effects</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_u0_list">u0_list</code></td>
<td>
<p>List containing random effects</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_nu0_list">nu0_list</code></td>
<td>
<p>List with prior sample sizes</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_s0_list">S0_list</code></td>
<td>
<p>List with prior guesses</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_sigma2_0">sigma2_0</code></td>
<td>
<p>Numeric</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_y_int">y_int</code></td>
<td>
<p>Integer vector</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_minval">minval</code></td>
<td>
<p>Numeric</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_maxval">maxval</code></td>
<td>
<p>Numeric</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_sd_proposal">sd_proposal</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_n">N</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_z">Z</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_u">u</code></td>
<td>
<p>Matrix containing random effects</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_idcluster">idcluster</code></td>
<td>
<p>Integer vector</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_onlyintercept">onlyintercept</code></td>
<td>
<p>Logical</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_ncluster">ncluster</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_mu1">mu1</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_use_log">use_log</code></td>
<td>
<p>Logical</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_mu">mu</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_sigma">sigma</code></td>
<td>
<p>Numeric</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_lower">lower</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="ml_mcmc_+3A_upper">upper</code></td>
<td>
<p>Vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits a linear mixed effects model <code class="reqn">y=\bm{X}\bm{beta}+
\bm{Z}\bm{u}+e</code> with MCMC sampling. In case of ordinal data,
the ordinal variable <code class="reqn">y</code> is replaced by an underlying latent normally
distributed variable <code class="reqn">y^\ast</code> and the residual variance is fixed to 1.
</p>


<h3>Value</h3>

<p>List with following entries (selection)
</p>
<table>
<tr><td><code>sampled_values</code></td>
<td>
<p>Sampled values</p>
</td></tr>
<tr><td><code>par_summary</code></td>
<td>
<p>Parameter summary</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goldstein, H. (2011). <em>Multilevel statistical models</em>. New York: Wiley.
<a href="https://doi.org/10.1002/9780470973394">doi:10.1002/9780470973394</a>
</p>
<p>Goldstein, H., Carpenter, J., Kenward, M., &amp; Levin, K. (2009). Multilevel models with
multivariate mixed response types. <em>Statistical Modelling, 9</em>(3), 173-197.
<a href="https://doi.org/10.1177/1471082X0800900301">doi:10.1177/1471082X0800900301</a>
</p>


<h3>See Also</h3>

<p>See also the <span class="pkg">MCMCglmm</span> package for MCMC estimation and
the <span class="pkg">lme4</span> package for maximum likelihood estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Multilevel model continuous data
#############################################################################

library(lme4)

#*** simulate data
set.seed(9097)

# number of clusters and units within clusters
K &lt;- 150
n &lt;- 15
iccx &lt;- .2
idcluster &lt;- rep( 1:K, each=n )
w &lt;- stats::rnorm( K )
x &lt;- rep( stats::rnorm( K, sd=sqrt(iccx) ), each=n) +
               stats::rnorm( n*K, sd=sqrt( 1 - iccx ))
X &lt;- data.frame(int=1, "x"=x, xaggr=miceadds::gm(x, idcluster),
        w=rep( w, each=n ) )
X &lt;- as.matrix(X)
Sigma &lt;- diag( c(2, .5 ) )
u &lt;- MASS::mvrnorm( K, mu=c(0,0), Sigma=Sigma )
beta &lt;- c( 0, .3, .7, 1 )
Z &lt;- X[, c("int", "x") ]
ypred &lt;- as.matrix(X) %*% beta + rowSums( Z * u[ idcluster, ] )
y &lt;- ypred[,1] + stats::rnorm( n*K, sd=1 )
data &lt;- as.data.frame(X)
data$idcluster &lt;- idcluster
data$y &lt;- y

#*** estimate mixed effects model with miceadds::ml_mcmc() function
formula &lt;- y ~ x + miceadds::gm(x, idcluster) + w + ( 1 + x | idcluster)
mod1 &lt;- miceadds::ml_mcmc( formula=formula, data=data)
plot(mod1)
summary(mod1)

#*** compare results with lme4 package
mod2 &lt;- lme4::lmer(formula=formula, data=data)
summary(mod2)

#############################################################################
# EXAMPLE 2: Multilevel model for ordinal outcome
#############################################################################

#*** simulate data
set.seed(456)
# number of clusters and units within cluster
K &lt;- 500
n &lt;- 10
iccx &lt;- .2
idcluster &lt;- rep( 1:K, each=n )
w &lt;- rnorm( K )
x &lt;- rep( stats::rnorm( K, sd=sqrt(iccx)), each=n) +
                 stats::rnorm( n*K, sd=sqrt( 1 - iccx ))
X &lt;- data.frame("int"=1, "x"=x, "xaggr"=miceadds::gm(x, idcluster),
        w=rep( w, each=n ) )
X &lt;- as.matrix(X)
u &lt;- matrix( stats::rnorm(K, sd=sqrt(.5) ), ncol=1)
beta &lt;- c( 0, .3, .7, 1 )
Z &lt;- X[, c("int") ]
ypred &lt;- as.matrix(X) %*% beta + Z * u[ idcluster, ]
y &lt;- ypred[,1] + stats::rnorm( n*K, sd=1 )
data &lt;- as.data.frame(X)
data$idcluster &lt;- idcluster
alpha &lt;- c(-Inf, -.4, 0, 1.7,  Inf)
data$y &lt;- cut( y, breaks=alpha, labels=FALSE ) - 1

#*** estimate model
formula &lt;- y ~ miceadds::cwc(x, idcluster) + miceadds::gm(x,idcluster) + w + ( 1 | idcluster)
mod &lt;- miceadds::ml_mcmc( formula=formula, data=data, iter=2000, burnin=500,
                outcome="probit", inits_lme4=FALSE)
summary(mod)
plot(mod)

## End(Not run)
</code></pre>

<hr>
<h2 id='NestedImputationList'>
Functions for Analysis of Nested Multiply Imputed Datasets
</h2><span id='topic+NestedImputationList'></span><span id='topic+MIcombine.NestedImputationResultList'></span><span id='topic+print.NestedImputationList'></span>

<h3>Description</h3>

<p>The function <code>NestedImputationList</code> takes a list of lists of datasets
and converts this into an object of class <code>NestedImputationList</code>.
</p>
<p>Statistical models can be estimated with the function
<code><a href="#topic+with.NestedImputationList">with.NestedImputationList</a></code>.
</p>
<p>The <code><a href="mitools.html#topic+MIcombine">mitools::MIcombine</a></code>
method can be used for objects of class
<code>NestedImputationResultList</code> which are the output of
<code><a href="#topic+with.NestedImputationList">with.NestedImputationList</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NestedImputationList( datasets )

## S3 method for class 'NestedImputationList'
print(x, ...)

## S3 method for class 'NestedImputationResultList'
MIcombine(results, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NestedImputationList_+3A_datasets">datasets</code></td>
<td>

<p>List of lists of datasets which are created by nested multiple imputation.
</p>
</td></tr>
<tr><td><code id="NestedImputationList_+3A_x">x</code></td>
<td>
<p>Object of class <code>NestedImputationResultsList</code></p>
</td></tr>
<tr><td><code id="NestedImputationList_+3A_results">results</code></td>
<td>
<p>Object of class <code>NestedImputationResultsList</code></p>
</td></tr>
<tr><td><code id="NestedImputationList_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>NestedImputationList</code>: Object of class <code>NestedImputationList</code>.
</p>
<p>Function <code>MIcombine.NestedImputationList</code>:
Object of class <code>mipo.nmi</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with.NestedImputationList">with.NestedImputationList</a></code>,
<code><a href="#topic+within.NestedImputationList">within.NestedImputationList</a></code>,
<code><a href="#topic+pool.mids.nmi">pool.mids.nmi</a></code>,
<code><a href="#topic+NMIcombine">NMIcombine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Nested multiple imputation and conversion into an object of class
#            NestedImputationList
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2

# remove first four variables
M &lt;- length(datlist)
for (ll in 1:M){
    datlist[[ll]] &lt;- datlist[[ll]][, -c(1:4) ]
                }

# nested multiple imputation using mice
imp1 &lt;- miceadds::mice.nmi( datlist,  m=3, maxit=2 )
summary(imp1)

# create object of class NestedImputationList
datlist1 &lt;- miceadds::mids2datlist( imp1 )
datlist1 &lt;- miceadds::NestedImputationList( datlist1 )

# estimate linear model using with
res1 &lt;- with( datlist1, stats::lm( ASMMAT ~ female + migrant ) )
# pool results
mres1 &lt;- mitools::MIcombine( res1 )
summary(mres1)
coef(mres1)
vcov(mres1)

## End(Not run)
</code></pre>

<hr>
<h2 id='nestedList2List'>
Converting a Nested List into a List (and Vice Versa)
</h2><span id='topic+nestedList2List'></span><span id='topic+List2nestedList'></span>

<h3>Description</h3>

<p>Converts a nested list into a list (and vice versa).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nestedList2List(nestedList)

List2nestedList(List, N_between, N_within=NULL, loop_within=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nestedList2List_+3A_nestedlist">nestedList</code></td>
<td>
<p>A nested list</p>
</td></tr>
<tr><td><code id="nestedList2List_+3A_list">List</code></td>
<td>

<p>A list
</p>
</td></tr>
<tr><td><code id="nestedList2List_+3A_n_between">N_between</code></td>
<td>

<p>Number of between list elements
</p>
</td></tr>
<tr><td><code id="nestedList2List_+3A_n_within">N_within</code></td>
<td>

<p>Number of within list elements
</p>
</td></tr>
<tr><td><code id="nestedList2List_+3A_loop_within">loop_within</code></td>
<td>

<p>Optional logical indicating whether looping should start from within
list
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or a nested list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: List conversions using a small example
#############################################################################

# define a nestedList
nestedList &lt;- as.list(1:3)
nestedList[[1]] &lt;- as.list( 2:4 )
nestedList[[2]] &lt;- as.list( 34 )
nestedList[[3]] &lt;- as.list( 4:9 )

# convert a nested list into a list
v2 &lt;- miceadds::nestedList2List( nestedList)

## reconvert list v2 into a nested list, looping within first
v3 &lt;- miceadds::List2nestedList(v2, N_between=5)
# looping between first
v4 &lt;- miceadds::List2nestedList(v2, N_between=5, loop_within=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='NMIwaldtest'>
Wald Test for Nested Multiply Imputed Datasets
</h2><span id='topic+NMIwaldtest'></span><span id='topic+create.designMatrices.waldtest'></span><span id='topic+summary.NMIwaldtest'></span><span id='topic+MIwaldtest'></span><span id='topic+summary.MIwaldtest'></span>

<h3>Description</h3>

<p>Performs a Wald test for nested multiply imputed datasets (<code>NMIwaldtest</code>)
and ordinary multiply imputed datasets (<code>MIwaldtest</code>),
see Reiter and Raghunathan (2007).
The corresponding statistic is also called the <code class="reqn">D_1</code> statistic.
</p>
<p>The function <code>create.designMatrices.waldtest</code> is a helper function
for the creation of design matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMIwaldtest(qhat, u, Cdes=NULL, rdes=NULL, testnull=NULL)

MIwaldtest(qhat, u, Cdes=NULL, rdes=NULL, testnull=NULL)

## S3 method for class 'NMIwaldtest'
summary(object, digits=4,...)

## S3 method for class 'MIwaldtest'
summary(object, digits=4,...)

create.designMatrices.waldtest(pars, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMIwaldtest_+3A_qhat">qhat</code></td>
<td>

<p>List or array of estimated parameters
</p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_u">u</code></td>
<td>

<p>List or array of estimated covariance matrices of parameters
</p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_cdes">Cdes</code></td>
<td>

<p>Design matrix <code class="reqn">C</code> for parameter test (see Details)
</p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_rdes">rdes</code></td>
<td>

<p>Constant vector <code class="reqn">r</code> (see Details)
</p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_testnull">testnull</code></td>
<td>

<p>Vector containing names of parameters which should be tested for
a parameter value of zero.
</p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_object">object</code></td>
<td>
<p>Object of class <code>NMIwaldtest</code></p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_digits">digits</code></td>
<td>
<p>Number of digits after decimal for print</p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_pars">pars</code></td>
<td>
<p>Vector of parameter names</p>
</td></tr>
<tr><td><code id="NMIwaldtest_+3A_k">k</code></td>
<td>
<p>Number of linear hypotheses which should be tested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wald test is performed for a linear hypothesis <code class="reqn">C \bold{\theta}=r</code>
for a parameter vector <code class="reqn">\bold{\theta}</code>.
</p>


<h3>Value</h3>

<p>List with following entries
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>Data frame with test statistic</p>
</td></tr>
<tr><td><code>qhat</code></td>
<td>
<p>Transformed parameter according to linear hypothesis</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>Covariance matrix of transformed parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code>create.designMatrices.waldtest</code> is a helper
function for the creation of design matrices.
</p>


<h3>References</h3>

<p>Reiter, J. P. and Raghunathan, T. E. (2007). The multiple adaptations of multiple
imputation. <em>Journal of the American Statistical Association, 102</em>(480), 1462-1471.
<a href="https://doi.org/10.1198/016214507000000932">doi:10.1198/016214507000000932</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMIcombine">NMIcombine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Nested multiple imputation and Wald test | TIMSS data
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2
# remove first four variables
M &lt;- length(datlist)
for (ll in 1:M){
    datlist[[ll]] &lt;- datlist[[ll]][, -c(1:4) ]
}

#***************
# (1) nested multiple imputation using mice
imp1 &lt;- miceadds::mice.nmi( datlist,  m=3, maxit=2 )
summary(imp1)

#**** Model 1: Linear regression with interaction effects
res1 &lt;- with( imp1, stats::lm( likesc ~ female*migrant + female*books  ) )
pres1 &lt;- miceadds::pool.mids.nmi( res1 )
summary(pres1)

# test whether both interaction effects equals zero
pars &lt;- dimnames(pres1$qhat)[[3]]
des &lt;- miceadds::create.designMatrices.waldtest( pars=pars, k=2)
Cdes &lt;- des$Cdes
rdes &lt;- des$rdes
Cdes[1, "female:migrant"] &lt;- 1
Cdes[2, "female:books"] &lt;- 1
wres1 &lt;- miceadds::NMIwaldtest( qhat=pres1$qhat, u=pres1$u, Cdes=Cdes, rdes=rdes )
summary(wres1)

# a simpler specification is the use of "testnull"
testnull &lt;- c("female:migrant", "female:books")
wres1b &lt;- miceadds::NMIwaldtest( qhat=qhat, u=u, testnull=testnull )
summary(wres1b)

#**** Model 2: Multivariate linear regression
res2 &lt;- with( imp1, stats::lm( cbind( ASMMAT, ASSSCI ) ~
                           0 + I(1*(female==1)) + I(1*(female==0))   ) )
pres2 &lt;- miceadds::pool.mids.nmi( res2 )
summary(pres2)

# test whether both gender differences equals -10 points
pars &lt;- dimnames(pres2$qhat)[[3]]
  ##  &gt; pars
  ##  [1] "ASMMAT:I(1 * (female==1))" "ASMMAT:I(1 * (female==0))"
  ##  [3] "ASSSCI:I(1 * (female==1))" "ASSSCI:I(1 * (female==0))"

des &lt;- miceadds::create.designMatrices.waldtest( pars=pars, k=2)
Cdes &lt;- des$Cdes
rdes &lt;- c(-10,-10)
Cdes[1, "ASMMAT:I(1*(female==1))"] &lt;- 1
Cdes[1, "ASMMAT:I(1*(female==0))"] &lt;- -1
Cdes[2, "ASSSCI:I(1*(female==1))"] &lt;- 1
Cdes[2, "ASSSCI:I(1*(female==0))"] &lt;- -1

wres2 &lt;- miceadds::NMIwaldtest( qhat=pres2$qhat, u=pres2$u, Cdes=Cdes, rdes=rdes )
summary(wres2)

# test only first hypothesis
wres2b &lt;- miceadds::NMIwaldtest( qhat=pres2$qhat, u=pres2$u, Cdes=Cdes[1,,drop=FALSE],
                         rdes=rdes[1] )
summary(wres2b)

#############################################################################
# EXAMPLE 2: Multiple imputation and Wald test | TIMSS data
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
dat &lt;- data.timss2[[1]]
dat &lt;- dat[, - c(1:4) ]

# perform multiple imputation
imp &lt;- mice::mice( dat, m=6, maxit=3 )

# define analysis model
res1 &lt;- with( imp, lm( likesc ~ female*migrant + female*books  ) )
pres1 &lt;- mice::pool( res1 )
summary(pres1)

# Wald test for zero interaction effects
qhat &lt;- mitools::MIextract(res1$analyses, fun=coef)
u &lt;- mitools::MIextract(res1$analyses, fun=vcov)
pars &lt;- names(qhat[[1]])
des &lt;- miceadds::create.designMatrices.waldtest( pars=pars, k=2)
Cdes &lt;- des$Cdes
rdes &lt;- des$rdes
Cdes[1, "female:migrant"] &lt;- 1
Cdes[2, "female:books"] &lt;- 1

# apply MIwaldtest function
wres1 &lt;- miceadds::MIwaldtest( qhat, u, Cdes, rdes )
summary(wres1)

# use again "testnull"
testnull &lt;- c("female:migrant", "female:books")
wres1b &lt;- miceadds::MIwaldtest( qhat=qhat, u=u, testnull=testnull )
summary(wres1b)

#***** linear regression with cluster robust standard errors

# convert object of class mids into a list object
datlist_imp &lt;- miceadds::mids2datlist( imp )
# define cluster
idschool &lt;- as.numeric( substring( data.timss2[[1]]$IDSTUD, 1, 5 ) )
# linear regression
res2 &lt;- lapply( datlist_imp, FUN=function(data){
           miceadds::lm.cluster( data=data, formula=likesc ~ female*migrant + female*books,
                            cluster=idschool ) } )
# extract parameters and covariance matrix
qhat &lt;- lapply( res2, FUN=function(rr){ coef(rr) } )
u &lt;- lapply( res2, FUN=function(rr){ vcov(rr) } )
# perform Wald test
wres2 &lt;- miceadds::MIwaldtest( qhat, u, Cdes, rdes )
summary(wres2)

## End(Not run)
</code></pre>

<hr>
<h2 id='nnig_sim'>
Simulation of Multivariate Linearly Related Non-Normal Variables
</h2><span id='topic+nnig_coef'></span><span id='topic+nnig_sim'></span>

<h3>Description</h3>

<p>Simulates multivariate linearly related non-normally distributed variables
(Foldnes &amp; Olsson, 2016). For marginal distributions, skewness and (excess) kurtosis
values are provided and the values are simulated according to the Fleishman
power transformation (Fleishman, 1978; see <code><a href="#topic+fleishman_sim">fleishman_sim</a></code>).
</p>
<p>The function <code>nnig_sim</code> simulates data from a multivariate random variable
<code class="reqn">\bold{Y}</code> which is related to a number of independent variables <code class="reqn">\bold{X}</code>
(independent generators; Foldnes &amp; Olsson, 2016)
which are Fleishman power normally distributed. In detail, it holds that
<code class="reqn">\bold{Y}=\bold{\mu} + \bold{A} \bold{X}</code> where the covariance matrix
<code class="reqn">\bold{\Sigma}</code> is decomposed according to a Cholesky decomposition
<code class="reqn">\bold{\Sigma}=\bold{A} \bold{A}^T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># determine coefficients
nnig_coef(mean=NULL, Sigma, skew, kurt)

# simulate values
nnig_sim(N, coef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnig_sim_+3A_mean">mean</code></td>
<td>

<p>Vector of means. The default is a vector containing zero means.
</p>
</td></tr>
<tr><td><code id="nnig_sim_+3A_sigma">Sigma</code></td>
<td>

<p>Covariance matrix
</p>
</td></tr>
<tr><td><code id="nnig_sim_+3A_skew">skew</code></td>
<td>

<p>Vector of skewness values
</p>
</td></tr>
<tr><td><code id="nnig_sim_+3A_kurt">kurt</code></td>
<td>

<p>Vector of (excess) kurtosis values
</p>
</td></tr>
<tr><td><code id="nnig_sim_+3A_n">N</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="nnig_sim_+3A_coef">coef</code></td>
<td>
<p>List of parameters generated by <code>nnig_coef</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter values (<code>nnig_coef</code>) or a data frame with
simulated values (<code>nnig_sim</code>).
</p>


<h3>References</h3>

<p>Fleishman, A. I. (1978). A method for simulating non-normal distributions.
<em>Psychometrika, 43</em>(4), 521-532.
<a href="https://doi.org/10.1007/BF02293811">doi:10.1007/BF02293811</a>
</p>
<p>Foldnes, N., &amp; Olsson, U. H. (2016). A simple simulation technique for nonnormal data
with prespecified skewness, kurtosis, and covariance matrix.
<em>Multivariate Behavioral Research, 51</em>(2-3), 207-219.
<a href="https://doi.org/10.1080/00273171.2015.1133274">doi:10.1080/00273171.2015.1133274</a>
</p>
<p>Vale, D. C., &amp; Maurelli, V. A. (1983). Simulating multivariate nonnormal distributions.
<em>Psychometrika, 48</em>(3), 465-471.
<a href="https://doi.org/10.1007/BF02293687">doi:10.1007/BF02293687</a>
</p>


<h3>See Also</h3>

<p>See <code>fungible::monte1</code> for simulating multivariate linearly related
non-normally distributed variables generated by the method of Vale and Morelli (1983).
See also the <code>MultiVarMI::MVNcorr</code> function in the <b>MultiVarMI</b> package
and the <b>SimMultiCorrData</b> package.
</p>
<p>The <b>MultiVarMI</b> also includes an imputation function <code>MultiVarMI::MI</code>
for non-normally distributed variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Simulating data with nnig_sim function
#############################################################################

#* define input parameters
Sigma &lt;- matrix( c(1,.5, .2,
                  .5, 1,.7,
                  .2, .7, 1), 3, 3 )
skew &lt;- c(0,1,1)
kurt &lt;- c(1,3,3)

#* determine coefficients
coeff &lt;- miceadds::nnig_coef( Sigma=Sigma, skew=skew, kurt=kurt )
print(coeff)

#* simulate data
set.seed(2018)
Y &lt;- miceadds::nnig_sim( N=2000, coef=coeff)

#* check descriptive statistics
apply(Y, 2, TAM::weighted_skewness )
apply(Y, 2, TAM::weighted_kurtosis )

## End(Not run)
</code></pre>

<hr>
<h2 id='output.format1'>
<span class="rlang"><b>R</b></span> Utilities: Formatting R Output on the <span class="rlang"><b>R</b></span> Console
</h2><span id='topic+output.format1'></span>

<h3>Description</h3>

<p>This function does some formatting of output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output.format1(stringtype, label, rep.N=1,stringlength=70)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output.format1_+3A_stringtype">stringtype</code></td>
<td>

<p>Type of string for display, e.g. <code>"*"</code>, <code>"-"</code>, ...
</p>
</td></tr>
<tr><td><code id="output.format1_+3A_label">label</code></td>
<td>

<p>Some comment which should be displayed at the console
</p>
</td></tr>
<tr><td><code id="output.format1_+3A_rep.n">rep.N</code></td>
<td>

<p>Number of lines which shall be left blank
</p>
</td></tr>
<tr><td><code id="output.format1_+3A_stringlength">stringlength</code></td>
<td>

<p>Length of vector with <code>label</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a string output at the <span class="rlang"><b>R</b></span> console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>output.format1(stringtype="*'", label="HELLO WORLD", stringlength=20)
##   *'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'*'
##   HELLO WORLD
</code></pre>

<hr>
<h2 id='pca.covridge'>
Principal Component Analysis with Ridge Regularization
</h2><span id='topic+pca.covridge'></span>

<h3>Description</h3>

<p>Performs a principal component analysis for a dataset while a ridge
parameter is added on the diagonal of the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca.covridge(x, ridge=1E-10, wt=NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.covridge_+3A_x">x</code></td>
<td>

<p>A numeric matrix
</p>
</td></tr>
<tr><td><code id="pca.covridge_+3A_ridge">ridge</code></td>
<td>

<p>Ridge regularization parameter for the covariance matrix
</p>
</td></tr>
<tr><td><code id="pca.covridge_+3A_wt">wt</code></td>
<td>
<p>Optional vector of weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries:
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>Matrix of factor loadings</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>Matrix of principal component scores</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>

<p>Vector of standard deviations of factors (square root of eigenvalues)
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Principal component analysis in <span class="pkg">stats</span>:
<code><a href="stats.html#topic+princomp">stats::princomp</a></code>
</p>
<p>For calculating first eigenvalues of a symmetric matrix see also
<code>sirt::sirt_eigenvalues</code> in the <span class="pkg">sirt</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: PCA on imputed internet data
#############################################################################

library(mice)
data(data.internet)
dat &lt;- as.matrix( data.internet)

# single imputation in mice
imp &lt;- mice::mice( dat, m=1, maxit=10 )

# apply PCA
pca.imp &lt;- miceadds::pca.covridge( complete(imp) )
  ##   &gt; pca.imp$sdev
  ##      Comp.1    Comp.2    Comp.3    Comp.4    Comp.5    Comp.6    Comp.7
  ##   3.0370905 2.3950176 2.2106816 2.0661971 1.8252900 1.7009921 1.6379599

# compare results with princomp
pca2.imp &lt;- stats::princomp( complete(imp) )
  ##   &gt; pca2.imp
  ##   Call:
  ##   stats::princomp(x=complete(imp))
  ##
  ##   Standard deviations:
  ##      Comp.1    Comp.2    Comp.3    Comp.4    Comp.5    Comp.6    Comp.7
  ##   3.0316816 2.3907523 2.2067445 2.0625173 1.8220392 1.6979627 1.6350428

## End(Not run)
</code></pre>

<hr>
<h2 id='pool_mi'>
Statistical Inference for Multiply Imputed Datasets
</h2><span id='topic+pool_mi'></span><span id='topic+summary.pool_mi'></span><span id='topic+coef.pool_mi'></span><span id='topic+vcov.pool_mi'></span>

<h3>Description</h3>

<p>Statistical inference for multiply imputed datasets. See
<code><a href="mitools.html#topic+MIcombine">mitools::MIcombine</a></code> or
<code><a href="mice.html#topic+pool">mice::pool</a></code> for
functions of the same functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_mi(qhat, u=NULL, se=NULL, dfcom=1e+07, method="smallsample")

## S3 method for class 'pool_mi'
summary(object, alpha=0.05, ...)

## S3 method for class 'pool_mi'
coef(object, ...)

## S3 method for class 'pool_mi'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_mi_+3A_qhat">qhat</code></td>
<td>

<p>List of parameter vectors
</p>
</td></tr>
<tr><td><code id="pool_mi_+3A_u">u</code></td>
<td>

<p>List of covariance matrices
</p>
</td></tr>
<tr><td><code id="pool_mi_+3A_se">se</code></td>
<td>

<p>List of vector of standard errors. Either <code>u</code> or
<code>se</code> must be provided.
</p>
</td></tr>
<tr><td><code id="pool_mi_+3A_dfcom">dfcom</code></td>
<td>

<p>Degrees of freedom of statistical analysis
</p>
</td></tr>
<tr><td><code id="pool_mi_+3A_method">method</code></td>
<td>

<p>The default is the small sample inference (<code>"smallsample"</code>).
Any other input provides large sample inference.
</p>
</td></tr>
<tr><td><code id="pool_mi_+3A_object">object</code></td>
<td>
<p>Object of class <code>pool_mi</code></p>
</td></tr>
<tr><td><code id="pool_mi_+3A_alpha">alpha</code></td>
<td>
<p>Confidence level</p>
</td></tr>
<tr><td><code id="pool_mi_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of with similar output as produced by the
<code><a href="mice.html#topic+pool">mice::pool</a></code> function.
</p>


<h3>See Also</h3>

<p><code><a href="mitools.html#topic+MIcombine">mitools::MIcombine</a></code>,
<code><a href="mice.html#topic+pool">mice::pool</a></code>,
<code><a href="mitml.html#topic+testEstimates">mitml::testEstimates</a></code>
</p>
<p>For statistical inference for nested multiply imputed datasets see
<code><a href="#topic+NMIcombine">NMIcombine</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Statistical inference for models based on imputationList
#############################################################################

library(mitools)
library(mice)
library(Zelig)
library(mitml)
library(lavaan)
library(semTools)
data(data.ma02)

# save dataset as imputation list
imp &lt;- mitools::imputationList( data.ma02 )
# mids object
imp0 &lt;- miceadds::datlist2mids( imp )
# datlist object
imp1 &lt;- miceadds::datlist_create(data.ma02)

#--- apply linear model based on imputationList
mod &lt;- with( imp, stats::lm( read ~ hisei + female ) )
#--- apply linear model for mids object
mod0 &lt;- with( imp0, stats::lm( read ~ hisei + female ) )
# extract coefficients
cmod &lt;- mitools::MIextract( mod, fun=coef)
# extract standard errors
semod &lt;- lapply( mod, FUN=function(mm){
    smm &lt;- summary(mm)
    smm$coef[,"Std. Error"]
} )
# extract covariance matrix
vmod &lt;- mitools::MIextract( mod, fun=vcov)

#*** pooling based on covariance matrices
res1 &lt;- miceadds::pool_mi( qhat=cmod, u=vmod )
summary(res1)
coef(res1)
vcov(res1)

#*** pooling based on standard errors
res2 &lt;- miceadds::pool_mi( qhat=cmod, se=semod )

#*** pooling with MIcombine
res3 &lt;- mitools::MIcombine( results=cmod, variances=vmod )

#*** pooling with pool function in mice
res4 &lt;- mice::pool( mod0 )

#*** analysis in Zelig
# convert datalist into object of class amelia
mi02 &lt;- list( "imputations"=data.ma02)
class(mi02) &lt;- "amelia"
res5 &lt;- Zelig::zelig( read ~ hisei + female, model="ls", data=mi02 )

#*** analysis in lavaan
lavmodel &lt;- "
     read ~ hisei + female
     read ~~ a*read
     read ~ 1
     # residual standard deviation
     sde :=sqrt(a)
       "
# analysis for first imputed dataset
mod6a &lt;- lavaan::sem( lavmodel, data=imp1[[1]] )
summary(mod6a)
# analysis based on all datasets using with
mod6b &lt;- lapply( imp1, FUN=function(data){
           res &lt;- lavaan::sem( lavmodel, data=data )
           return(res)
                } )
# extract parameters and covariance matrices
qhat0 &lt;- lapply( mod6b, FUN=function(ll){  coef(ll) } )
u0 &lt;- lapply( mod6b, FUN=function(ll){  vcov(ll) } )
res6b &lt;- mitools::MIcombine( results=qhat0, variances=u0 )

# extract informations for all parameters
qhat &lt;- lapply( mod6b, FUN=function(ll){
        h1 &lt;- lavaan::parameterEstimates(ll)
        parnames &lt;- paste0( h1$lhs, h1$op, h1$rhs )
        v1 &lt;- h1$est
        names(v1) &lt;- parnames
        return(v1)
     } )
se &lt;- lapply( mod6b, FUN=function(ll){
        h1 &lt;- lavaan::parameterEstimates(ll)
        parnames &lt;- paste0( h1$lhs, h1$op, h1$rhs )
        v1 &lt;- h1$se
        names(v1) &lt;- parnames
        return(v1)
     } )
res6c &lt;- miceadds::pool_mi( qhat=qhat, se=se )

# function runMI in semTools package
res6d &lt;- semTools::runMI(model=lavmodel, data=imp1, m=length(imp1) )
  # semTools version 0.4-9 provided an error message
# perform inference with mitml package
se2 &lt;- lapply( se, FUN=function(ss){  ss^2  } )  # input variances
res6e &lt;- mitml::testEstimates(qhat=qhat, uhat=se2)

#*** complete model estimation and inference in mitml

# convert into object of class mitml.list
ml02 &lt;- mitml::as.mitml.list( data.ma02)
# estimate regression
mod7 &lt;- with( ml02, stats::lm( read ~ hisei + female ) )
# inference
res7 &lt;- mitml::testEstimates( mod7 )

#*** model comparison
summary(res1)
summary(res2)
summary(res3)
summary(res4)
summary(res5)
summary(res6b)
summary(res6c)
print(res6e)
print(res7)

## End(Not run)
</code></pre>

<hr>
<h2 id='pool.mids.nmi'>
Pooling for Nested Multiple Imputation
</h2><span id='topic+pool.mids.nmi'></span><span id='topic+summary.mipo.nmi'></span><span id='topic+coef.mipo.nmi'></span><span id='topic+vcov.mipo.nmi'></span><span id='topic+NMIcombine'></span><span id='topic+NMIextract'></span><span id='topic+pool_nmi'></span>

<h3>Description</h3>

<p>Statistical inference for scalar parameters for nested multiply imputed
datasets (Rubin, 2003; Harel &amp; Schafer, 2002, 2003; Reiter &amp; Raghanuthan, 2007;
Harel, 2007).
</p>
<p>The <code>NMIcombine</code> (<code>pool_nmi</code> as a synonym)
and <code>NMIextract</code> functions are extensions of
<code><a href="mitools.html#topic+MIcombine">mitools::MIcombine</a></code> and
<code><a href="mitools.html#topic+MIextract">mitools::MIextract</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool.mids.nmi(object, method="largesample")

NMIcombine( qhat, u=NULL, se=NULL, NMI=TRUE, comp_cov=TRUE, is_list=TRUE,
       method=1)

pool_nmi( qhat, u=NULL, se=NULL, NMI=TRUE, comp_cov=TRUE, is_list=TRUE,
       method=1)

NMIextract(results, expr, fun)

## S3 method for class 'mipo.nmi'
summary(object, digits=4, ...)

## S3 method for class 'mipo.nmi'
coef(object, ...)

## S3 method for class 'mipo.nmi'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.mids.nmi_+3A_object">object</code></td>
<td>

<p>Object of class <code>mids.nmi</code>. For <code>summary</code> it must be an object
of class <code>mipo.nmi</code>.
</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_method">method</code></td>
<td>

<p>For <code>pool.mids.nmi</code>: Method for calculating degrees of freedom. Until now, only the
method <code>"largesample"</code> is available. <br />
For <code>NMIcombine</code> and <code>pool_nmi</code>: Computation method of fraction of missing information.
<code>method=1</code> is due to Harel and Schafer (2003) or Shen (2007).
<code>method=2</code> is due to Harel and Schafer (2002) and is coherent to
the calculation for multiply imputed datasets, while the former method is not.
</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_qhat">qhat</code></td>
<td>
<p>List of lists of parameter estimates. In case of an ordinary
imputation it can only be a list.</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_u">u</code></td>
<td>
<p>Optional list of lists of covariance matrices of parameter estimates</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_se">se</code></td>
<td>
<p>Optional vector of standard errors. This argument overwrites
<code>u</code> if it is provided.
</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_nmi">NMI</code></td>
<td>
<p>Optional logical indicating whether the <code>NMIcombine</code>
function should be applied for results of
nested multiply imputed datasets.
It is set to <code>FALSE</code> if only a list results of multiply imputed
datasets is available.</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_comp_cov">comp_cov</code></td>
<td>
<p>Optional logical indicating whether covariances between
parameter estimates should be estimated.</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_is_list">is_list</code></td>
<td>
<p>Optional logical indicating whether <code>qhat</code> and <code>u</code>
are provided as lists as an input. If <code>is_list=FALSE</code>,
appropriate arrays can be used as input.</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_results">results</code></td>
<td>
<p>A list of objects</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_expr">expr</code></td>
<td>
<p>An expression</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_fun">fun</code></td>
<td>
<p>A function of one argument</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_digits">digits</code></td>
<td>
<p>Number of digits after decimal for printing results in
<code>summary</code>.</p>
</td></tr>
<tr><td><code id="pool.mids.nmi_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>mipo.nmi</code> with following entries
</p>
<table>
<tr><td><code>qhat</code></td>
<td>
<p>Estimated parameters in all imputed datasets</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>Estimated covariance matrices of parameters in all imputed datasets</p>
</td></tr>
<tr><td><code>qbar</code></td>
<td>
<p>Estimated parameter</p>
</td></tr>
<tr><td><code>ubar</code></td>
<td>
<p>Average estimated variance within imputations</p>
</td></tr>
<tr><td><code>Tm</code></td>
<td>
<p>Total variance of parameters</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Total fraction of missing information</p>
</td></tr>
<tr><td><code>lambda_Between</code></td>
<td>
<p>Fraction of missing information of between imputed
datasets (first stage imputation)</p>
</td></tr>
<tr><td><code>lambda_Within</code></td>
<td>
<p>Fraction of missing information of within imputed
datasets (second stage imputation)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Harel, O., &amp; Schafer, J. (2002). <em>Two stage multiple imputation</em>.
Joint Statistical Meetings - Biometrics Section.
</p>
<p>Harel, O., &amp; Schafer, J. (2003). <em>Multiple imputation in two stages</em>.
In Proceedings of Federal Committee on Statistical Methodology 2003 Conference.
</p>
<p>Harel, O. (2007). Inferences on missing information under multiple imputation
and two-stage multiple imputation. <em>Statistical Methodology, 4</em>(1), 75-89.
<a href="https://doi.org/10.1016/j.stamet.2006.03.002">doi:10.1016/j.stamet.2006.03.002</a>
</p>
<p>Reiter, J. P. and Raghunathan, T. E. (2007). The multiple adaptations of multiple
imputation. <em>Journal of the American Statistical Association, 102</em>(480), 1462-1471.
<a href="https://doi.org/10.1198/016214507000000932">doi:10.1198/016214507000000932</a>
</p>
<p>Rubin, D. B. (2003). Nested multiple imputation of NMES via partially
incompatible MCMC. <em>Statistica Neerlandica, 57</em>(1), 3-18.
<a href="https://doi.org/10.1111/1467-9574.00217">doi:10.1111/1467-9574.00217</a>
</p>


<h3>See Also</h3>

<p><code><a href="mice.html#topic+pool">mice::pool</a></code>,
<code><a href="mitools.html#topic+MIcombine">mitools::MIcombine</a></code>,
<code><a href="mitools.html#topic+MIextract">mitools::MIextract</a></code>
</p>
<p><code><a href="#topic+mice.nmi">mice.nmi</a></code>,
<code><a href="#topic+MIcombine.NestedImputationResultList">MIcombine.NestedImputationResultList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Nested multiple imputation and statistical inference
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2
# remove first four variables
M &lt;- length(datlist)
for (ll in 1:M){
    datlist[[ll]] &lt;- datlist[[ll]][, -c(1:4) ]
               }

#***************
# (1) nested multiple imputation using mice
imp1 &lt;- miceadds::mice.nmi( datlist,  m=3, maxit=2 )
summary(imp1)

#***************
# (2) first linear regression: ASMMAT ~ migrant + female
res1 &lt;- with( imp1, stats::lm( ASMMAT ~ migrant + female ) ) # fit
pres1 &lt;- miceadds::pool.mids.nmi( res1 )  # pooling
summary(pres1)  # summary
coef(pres1)
vcov(pres1)

#***************
# (3) second linear regression: likesc ~ migrant + books
res2 &lt;- with( imp1, stats::lm( likesc ~ migrant + books  ) )
pres2 &lt;- miceadds::pool.mids.nmi( res2 )
summary(pres2)

#***************
# (4) some descriptive statistics using the mids.nmi object
res3 &lt;- with( imp1, c( "M_lsc"=mean(likesc), "SD_lsc"=stats::sd(likesc) ) )
pres3 &lt;- miceadds::NMIcombine( qhat=res3$analyses )
summary(pres3)

#*************
# (5) apply linear regression based on imputation list

# convert mids object to datlist
datlist2 &lt;- miceadds::mids2datlist( imp1 )
str(datlist2, max.level=1)

# double application of lapply to the list of list of nested imputed datasets
res4 &lt;- lapply( datlist2, FUN=function(dl){
    lapply( dl, FUN=function(data){
            stats::lm( ASMMAT ~ migrant + books, data=data )
                                } )
                }  )

# extract coefficients
qhat &lt;- lapply( res4, FUN=function(bb){
            lapply( bb, FUN=function(ww){
                    coef(ww)
                        } )
                } )
# shorter function
NMIextract( results=res4, fun=coef )

# extract covariance matrices
u &lt;- lapply( res4, FUN=function(bb){
            lapply( bb, FUN=function(ww){
                    vcov(ww)
                        } )
                } )
# shorter function
NMIextract( results=res4, fun=vcov )

# apply statistical inference using the NMIcombine function
pres4 &lt;- miceadds::NMIcombine( qhat=qhat, u=u )
summary(pres4)

#--- statistical inference if only standard errors are available
# extract standard errors
se &lt;- lapply( res4, FUN=function(bb){
            lapply( bb, FUN=function(ww){
                # ww &lt;- res4[[1]][[1]]
                sww &lt;- summary(ww)
                sww$coef[,"Std. Error"]
                        } )
                } )
se
# apply NMIcombine function
pres4b &lt;- miceadds::NMIcombine( qhat=qhat, se=se )
# compare results
summary(pres4b)
summary(pres4)

#############################################################################
# EXAMPLE 2: Some comparisons for a multiply imputed dataset
#############################################################################

library(mitools)
data(data.ma02)

# save dataset as imputation list
imp &lt;- mitools::imputationList( data.ma02 )
print(imp)
# save dataset as an mids object
imp1 &lt;- miceadds::datlist2mids( imp )

# apply linear model based on imputationList
mod &lt;- with( imp, stats::lm( read ~ hisei + female ) )
# same linear model based on mids object
mod1 &lt;- with( imp1, stats::lm( read ~ hisei + female ) )

# extract coefficients
cmod &lt;- mitools::MIextract( mod, fun=coef)
# extract standard errors
semod &lt;- lapply( mod, FUN=function(mm){
                smm &lt;- summary(mm)
                smm$coef[,"Std. Error"]
                        } )
# extract covariance matrix
vmod &lt;- mitools::MIextract( mod, fun=vcov)

#*** pooling with NMIcombine with se (1a) and vcov (1b) as input
pmod1a &lt;- miceadds::NMIcombine( qhat=cmod, se=semod, NMI=FALSE )
pmod1b &lt;- miceadds::NMIcombine( qhat=cmod, u=vmod, NMI=FALSE )
# use method 2 which should conform to MI inference of mice::pool
pmod1c &lt;- miceadds::NMIcombine( qhat=cmod, u=vmod, NMI=FALSE, method=2)

#*** pooling with mitools::MIcombine function
pmod2 &lt;- mitools::MIcombine( results=cmod, variances=vmod )
#*** pooling with mice::pool function
pmod3a &lt;- mice::pool( mod1 )
pmod3b &lt;- mice::pool( mod1, method="Rubin")

#--- compare results
summary(pmod1a)   # method=1  (the default)
summary(pmod1b)   # method=1  (the default)
summary(pmod1c)   # method=2
summary(pmod2)
summary(pmod3a)
summary(pmod3b)

## End(Not run)
</code></pre>

<hr>
<h2 id='Reval'>
<span class="rlang"><b>R</b></span> Utilities: Evaluates a String as an Expression in <span class="rlang"><b>R</b></span>
</h2><span id='topic+Reval'></span><span id='topic+Revalpr'></span><span id='topic+Revalprstr'></span><span id='topic+Revalpr_round'></span><span id='topic+Revalpr_maxabs'></span>

<h3>Description</h3>

<p>This function evaluates a string as an <span class="rlang"><b>R</b></span> expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reval(Rstring, print.string=TRUE, n.eval.parent=1)

# Reval( print(Rstring) )
Revalpr(Rstring, print.string=TRUE)

#  Reval( print(str(Rstring)) )
Revalprstr(Rstring, print.string=TRUE)

#  Reval( print(round(Rstring, digits)) )
Revalpr_round( Rstring, digits=5, print.string=TRUE)

#  Reval( print(max(abs(Rstring_x - Rstring_y)) ) )
Revalpr_maxabs( Rstring_x, Rstring_y, print.string=TRUE, na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reval_+3A_rstring">Rstring</code></td>
<td>

<p>String which shall be evaluated in <span class="rlang"><b>R</b></span>
</p>
</td></tr>
<tr><td><code id="Reval_+3A_print.string">print.string</code></td>
<td>

<p>Should the string printed on the console?
</p>
</td></tr>
<tr><td><code id="Reval_+3A_n.eval.parent">n.eval.parent</code></td>
<td>
<p>Index of parent environment in which the <span class="rlang"><b>R</b></span>
command should be evaluated.
</p>
</td></tr>
<tr><td><code id="Reval_+3A_digits">digits</code></td>
<td>
<p>Number of digits after decimal.</p>
</td></tr>
<tr><td><code id="Reval_+3A_rstring_x">Rstring_x</code></td>
<td>
<p>String corresponding to an <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="Reval_+3A_rstring_y">Rstring_y</code></td>
<td>
<p>String corresponding to an <span class="rlang"><b>R</b></span> object</p>
</td></tr>
<tr><td><code id="Reval_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether missing values should be removed
from calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The string is evaluated in the parent environment. See
<code><a href="base.html#topic+eval">base::eval</a></code>  for the definition of environments in <span class="rlang"><b>R</b></span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function is simply a shortage function
# See the definition of this function:
Reval &lt;- function( Rstring, print.string=TRUE){
    if (print.string){ cat( paste( Rstring ), "\n"  ) }
        eval.parent( parse( text=paste( Rstring )), n=1 )
            }

Reval( "a &lt;- 2^3" )
  ## a &lt;- 2^3
a
  ## [1] 8
</code></pre>

<hr>
<h2 id='Rfunction_include_argument_values'>
Utility Functions for Writing <span class="rlang"><b>R</b></span> Functions
</h2><span id='topic+Rfunction_include_argument_values'></span><span id='topic+Rfunction_output_list_result_function'></span><span id='topic+Rfunction'></span><span id='topic+Rcppfunction_remove_classes'></span><span id='topic+Rcppfunction'></span>

<h3>Description</h3>

<p>Utility functions for writing <span class="rlang"><b>R</b></span> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## include argument values in a function input
Rfunction_include_argument_values(string, maxlen=70)

## assign objects to entries in a list
Rfunction_output_list_result_function(string, mid=" &lt;- res$")

## delete declaration of Rcpp and RcppArmadillo object classes
Rcppfunction_remove_classes(string, maxlen=70, remove=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rfunction_include_argument_values_+3A_string">string</code></td>
<td>

<p>String
</p>
</td></tr>
<tr><td><code id="Rfunction_include_argument_values_+3A_maxlen">maxlen</code></td>
<td>

<p>Maximal string length for output
</p>
</td></tr>
<tr><td><code id="Rfunction_include_argument_values_+3A_mid">mid</code></td>
<td>

<p>Middle term in the output
</p>
</td></tr>
<tr><td><code id="Rfunction_include_argument_values_+3A_remove">remove</code></td>
<td>
<p>Logical indicating whether object classes should be removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Toy examples
#############################################################################

##**** extend missing arguments

string &lt;- "
          mice.impute.2l.pls2(y, ry, x, type, pls.facs=pls.facs  ))
          "
cat( miceadds::Rfunction_include_argument_values(string) )
  ##    mice.impute.2l.pls2( y=y, ry=ry, x=x, type=type, pls.facs=pls.facs )

##**** assignment to objects as entries in a list

string &lt;- "
          list( vname=vname, p, type=type, data=data, levels_id )
          "
cat( miceadds::Rfunction_output_list_result_function( string ) )
  ##
  ##  vname &lt;- res$vname
  ##  p &lt;- res$p
  ##  type &lt;- res$type
  ##  data &lt;- res$data
  ##  levels_id &lt;- res$levels_id


string &lt;- "
arma::colvec miceadds_rcpp_rtnorm2( arma::colvec mu,
            double sigma0, arma::colvec lower, arma::colvec upper,
            double minval, double maxval)
    "

cat( miceadds::Rcppfunction_remove_classes(string, maxlen=70) )
cat( miceadds::Rcppfunction_remove_classes(string, maxlen=70, remove=FALSE) )
</code></pre>

<hr>
<h2 id='Rhat.mice'>
Rhat Convergence Statistic of a <code>mice</code> Imputation
</h2><span id='topic+Rhat.mice'></span>

<h3>Description</h3>

<p>Computes the Rhat statistic for a <code>mids</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rhat.mice(mice.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rhat.mice_+3A_mice.object">mice.object</code></td>
<td>

<p>Object of class <code>mids</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing the Rhat statistic for mean and variances for all variables
of the Markov chains used for imputation
</p>


<h3>References</h3>

<p>Gelman, A., &amp; Hill, J. (2007).
<em>Data analysis using regression and multilevel/hierarchical models</em>.
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Rhat statistic for nhanes data
#############################################################################

library(mice)
data(nhanes, package="mice")
set.seed(9090)

# nhanes 3 parallel chains
imp1 &lt;- mice::mice( nhanes, m=3, maxit=10, method=rep("norm", 4 ))
miceadds::Rhat.mice( imp1 )
  ##     variable MissProp Rhat.M.imp Rhat.Var.imp
  ##   1      bmi       36  1.0181998     1.155807
  ##   2      hyp       32  1.0717677     1.061174
  ##   3      chl       40  0.9717109     1.318721

## End(Not run)
</code></pre>

<hr>
<h2 id='round2'>
<span class="rlang"><b>R</b></span> Utilities: Rounding DIN 1333 (Kaufmaennisches Runden)
</h2><span id='topic+round2'></span>

<h3>Description</h3>

<p>This is a rounding function which rounds up for all numbers
according to the rule of 'kaufmaennisches Runden' (DIN 1333).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round2(vec, digits=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round2_+3A_vec">vec</code></td>
<td>

<p>Numeric vector
</p>
</td></tr>
<tr><td><code id="round2_+3A_digits">digits</code></td>
<td>

<p>Number of digits after decimal for rounding
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with rounded values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1:
#############################################################################

vec &lt;- c( 1.5, 2.5, 3.5, 1.51,  1.49)
vec
round(vec)
round2(vec)
  ##   &gt; vec
  ##   [1] 1.50 2.50 3.50 1.51 1.49
  ##   &gt; round(vec)
  ##   [1] 2 2 4 2 1
  ##   &gt; miceadds::round2(vec)
  ##   [1] 2 3 4 2 1

#############################################################################
# EXAMPLE 2:
#############################################################################

vec &lt;- - c( 1.5, 2.5, 3.5, 1.51,  1.49)
vec
round(vec)
round2(vec)
  ##   &gt; vec
  ##   [1] -1.50 -2.50 -3.50 -1.51 -1.49
  ##   &gt; round(vec)
  ##   [1] -2 -2 -4 -2 -1
  ##   &gt; miceadds::round2(vec)
  ##   [1] -2 -3 -4 -2 -1

#############################################################################
# EXAMPLE 3:
#############################################################################

vec &lt;- c(8.4999999, 8.5, 8.501, 7.4999999, 7.5, 7.501 )
round(vec)
round2( vec )
round2( vec, digits=1)
round2( -vec )
  ##   &gt; round(vec)
  ##   [1] 8 8 9 7 8 8
  ##   &gt; miceadds::round2( vec )
  ##   [1] 8 9 9 7 8 8
  ##   &gt; miceadds::round2( vec, digits=1)
  ##   [1] 8.5 8.5 8.5 7.5 7.5 7.5
  ##   &gt; miceadds::round2( -vec )
  ##   [1] -8 -9 -9 -7 -8 -8
</code></pre>

<hr>
<h2 id='Rsessinfo'>
<span class="rlang"><b>R</b></span> Utilities: <span class="rlang"><b>R</b></span> Session Information
</h2><span id='topic+Rsessinfo'></span>

<h3>Description</h3>

<p>Informs about current <span class="rlang"><b>R</b></span> session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rsessinfo()
</code></pre>


<h3>Value</h3>

<p>A string containing reduced information about <span class="rlang"><b>R</b></span>
session info
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rsessinfo()
  ##   &gt; miceadds::Rsessinfo()
  ##   [1] "R version 2.15.2 (2012-10-26) x86_64, mingw32 | nodename=SD70 | login=robitzsch"
</code></pre>

<hr>
<h2 id='save.data'>
<span class="rlang"><b>R</b></span> Utilities: Saving/Writing Data Files using <span class="pkg">miceadds</span>
</h2><span id='topic+save.data'></span>

<h3>Description</h3>

<p>This function is a wrapper function for saving or writing data frames
or matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.data( data, filename, type="Rdata", path=getwd(), row.names=FALSE, na=NULL,
      suffix=NULL, suffix_space="__", index=FALSE, systime=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.data_+3A_data">data</code></td>
<td>
<p>Data frame or matrix to be saved</p>
</td></tr>
<tr><td><code id="save.data_+3A_filename">filename</code></td>
<td>

<p>Name of data file
</p>
</td></tr>
<tr><td><code id="save.data_+3A_type">type</code></td>
<td>

<p>The type of file in which the data frame or matrix should be loaded.
This can be <code>Rdata</code> (for <span class="rlang"><b>R</b></span> binary format, using
<code><a href="base.html#topic+save">base::save</a></code>,
<code>csv</code> (using <code><a href="utils.html#topic+write.csv2">utils::write.csv2</a></code>),
<code>csv</code> (using <code><a href="utils.html#topic+write.csv">utils::write.csv</a></code>),
<code>table</code> (using <code><a href="utils.html#topic+write.table">utils::write.table</a></code>),
<code>sav</code> (using <code><a href="sjlabelled.html#topic+write_spss">sjlabelled::write_spss</a></code>),
<code>RDS</code> (using <code><a href="base.html#topic+saveRDS">saveRDS</a></code>).
<code>type</code> can also be a vector if the data frame should be
saved in multiple formats.
</p>
</td></tr>
<tr><td><code id="save.data_+3A_path">path</code></td>
<td>
<p>Directory from which the dataset should be loaded</p>
</td></tr>
<tr><td><code id="save.data_+3A_row.names">row.names</code></td>
<td>
<p>Optional logical indicating whether row names
should be included in saved <code>csv</code> or <code>csv2</code> files.</p>
</td></tr>
<tr><td><code id="save.data_+3A_na">na</code></td>
<td>
<p>Missing value handling. The default is <code>""</code> for <code>type="csv"</code>
and <code>type="csv2"</code> and is <code>"."</code> for <code>type="table"</code>.</p>
</td></tr>
<tr><td><code id="save.data_+3A_suffix">suffix</code></td>
<td>
<p>Optional suffix in file name.</p>
</td></tr>
<tr><td><code id="save.data_+3A_suffix_space">suffix_space</code></td>
<td>
<p>Optional place holder if a suffix is used.</p>
</td></tr>
<tr><td><code id="save.data_+3A_index">index</code></td>
<td>
<p>Optional logical indicating whether an index should be
included in the first column using the function
<code><a href="#topic+index.dataframe">index.dataframe</a></code>.
</p>
</td></tr>
<tr><td><code id="save.data_+3A_systime">systime</code></td>
<td>
<p>If <code>index=TRUE</code>, this optional logical indicates
whether a time stamp should be included in the second column.
</p>
</td></tr>
<tr><td><code id="save.data_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>save</code>,
<code>write.csv2</code>, <code>write.csv</code>, <code>write.table</code>
or <code>sjlabelled::write_spss</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+load.Rdata">load.Rdata</a></code> and <code><a href="#topic+load.data">load.data</a></code>
for saving/writing <span class="rlang"><b>R</b></span> data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Save dataset data.ma01
#############################################################################

#*** use data.ma01 as an example for writing data files using save.data
data(data.ma01)
dat &lt;- data.ma01

# set a working directory
pf2 &lt;- "P:/ARb/temp_miceadds"

# save data in Rdata format
miceadds::save.data( dat, filename="ma01data", type="Rdata", path=pf2)

# save data in table format without row and column names
miceadds::save.data( dat, filename="ma01data", type="table", path=pf2,
            row.names=FALSE, na=".", col.names=FALSE)

# save data in csv2 format, including time stamp in file name
# and row index and time stamp in saved data
miceadds::save.data( dat, filename="ma01data", type="csv2", path=pf2,
            row.names=FALSE, na="", suffix=systime()[5],
            index=TRUE, systime=TRUE )

# save data in sav format
miceadds::save.data( dat, filename="ma02data", type="sav",  path=pf2 )

# save data file in different formats
types &lt;- c("Rdata", "csv2", "sav")
sapply( types, FUN=function(type){
    miceadds::save.data( dat, filename="ma02data", type=type,  path=pf2,
               suffix=miceadds::systime()[3], row.names=TRUE  )
                                    } )

# save data frame in multiple file formats (sav, table and csv2)
miceadds::save.data( dat, filename="ma03data", type=c("sav","table","csv2"),  path=pf2,
            suffix=miceadds::systime()[7]  )

## End(Not run)
</code></pre>

<hr>
<h2 id='save.Rdata'>
<span class="rlang"><b>R</b></span> Utilities: Save a Data Frame in <code>Rdata</code> Format
</h2><span id='topic+save.Rdata'></span>

<h3>Description</h3>

<p>This function saves a data frame in a <code>Rdata</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save.Rdata(dat, name, path=NULL, part.numb=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save.Rdata_+3A_dat">dat</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="save.Rdata_+3A_name">name</code></td>
<td>

<p>Name of the <span class="rlang"><b>R</b></span> object to be saved
</p>
</td></tr>
<tr><td><code id="save.Rdata_+3A_path">path</code></td>
<td>

<p>Directory for saving the object
</p>
</td></tr>
<tr><td><code id="save.Rdata_+3A_part.numb">part.numb</code></td>
<td>

<p>Number of rows of the data frame which should also
be saved in csv format. The default is saving 1000 rows.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dfr &lt;- matrix( 2*1:12-3, 4,3 )
save.Rdata( dfr, "dataframe_test" )

## End(Not run)
</code></pre>

<hr>
<h2 id='scale_datlist'>
Adding a Standardized Variable to a List of Multiply Imputed Datasets or a
Single Datasets
</h2><span id='topic+scale_datlist'></span>

<h3>Description</h3>

<p>Adds a standardized variable to a list of multiply imputed datasets or
a single dataset. This function extends <code><a href="base.html#topic+scale">base::scale</a></code>
for a data frame to a list of multiply imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_datlist(datlist, orig_var, trafo_var, weights=NULL, M=0, SD=1,
    digits=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_datlist_+3A_datlist">datlist</code></td>
<td>

<p>A data frame, a list of multiply imputed datasets of one of the classes
<code>datlist</code> or <code>imputationList</code> or a list of nested multiply
imputed datasets of one of the classes <code>nested_datlist</code> or
<code>NestedImputationList</code>.
</p>
</td></tr>
<tr><td><code id="scale_datlist_+3A_orig_var">orig_var</code></td>
<td>

<p>Vector with names of the variables to be transformed
</p>
</td></tr>
<tr><td><code id="scale_datlist_+3A_trafo_var">trafo_var</code></td>
<td>

<p>Vector with names of the standardized variables
</p>
</td></tr>
<tr><td><code id="scale_datlist_+3A_weights">weights</code></td>
<td>

<p>Optional vector of sample weights. Alternatively, the <code>weights</code>
can also be a string indicating the variable used from
<code>datlist</code>.
</p>
</td></tr>
<tr><td><code id="scale_datlist_+3A_m">M</code></td>
<td>

<p>Mean of the transformed variable
</p>
</td></tr>
<tr><td><code id="scale_datlist_+3A_sd">SD</code></td>
<td>

<p>Standard deviation of the transformed variable
</p>
</td></tr>
<tr><td><code id="scale_datlist_+3A_digits">digits</code></td>
<td>

<p>Number of digits used for rounding the standardized variable
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">base::scale</a></code>, <code><a href="#topic+ma.scale2">ma.scale2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Standardized variables in list of multiply imputed datasets
#############################################################################

data(data.ma02)
datlist &lt;- data.ma02

#--- object of class 'datlist'
datlist &lt;- miceadds::datlist_create( datlist )

# mean and SD of variable hisei
miceadds::ma.wtd.meanNA(data=datlist, weights=datlist[[1]]$studwgt, vars="hisei" )
mean( unlist( lapply( datlist, FUN=function(data){
        stats::weighted.mean( data$hisei, data$studwgt )  } ) ) )
miceadds::ma.wtd.sdNA(data=datlist, weights=datlist[[1]]$studwgt, vars="hisei" )
mean( unlist( lapply( datlist, FUN=function(data){
        sqrt( Hmisc::wtd.var( data$hisei, data$studwgt ) ) } ) ) )

# standardize variable hisei to M=100 and SD=15
datlist1a &lt;- miceadds::scale_datlist( datlist=datlist, orig_var="hisei",
               trafo_var="hisei100", weights=datlist[[1]]$studwgt, M=100, SD=15 )

# check mean and SD
miceadds::ma.wtd.meanNA(data=datlist1a, weights=datlist[[1]]$studwgt, vars="hisei100")
miceadds::ma.wtd.sdNA(data=datlist1a, weights=datlist[[1]]$studwgt, vars="hisei100")

#--- do standardization for unweighted sample with books &lt;=3
# -&gt; define a weighting variable at first
datlist0 &lt;- mitools::imputationList( datlist )
datlist2a &lt;- miceadds::within.imputationList( datlist0, {
             # define weighting variable
                 wgt_books &lt;- 1 * ( books &lt;=3 )
                    } )

# standardize variable hisei to M=100 and SD=15 with respect to weighting variable
datlist2b &lt;- miceadds::scale_datlist( datlist=datlist2a, orig_var="hisei", trafo_var="hisei100",
         weights="wgt_books", M=100, SD=15 )

# check mean and SD (groupwise)
miceadds::ma.wtd.meanNA(data=datlist1a, weights=datlist[[1]]$studwgt, vars="hisei100")
miceadds::ma.wtd.sdNA(data=datlist1a, weights=datlist[[1]]$studwgt, vars="hisei100")

#--- transformation for a single dataset
dat0 &lt;- datlist[[1]]
dat0a &lt;- miceadds::scale_datlist( datlist=dat0, orig_var="hisei", trafo_var="hisei100",
                    weights=dat0$studwgt, M=100, SD=15 )
stats::weighted.mean( dat0a[,"hisei"],  w=dat0a$studwgt )
stats::weighted.mean( dat0a[,"hisei100"],  w=dat0a$studwgt )
sqrt( Hmisc::wtd.var( dat0a[,"hisei100"],  weights=dat0a$studwgt ) )

#--- Standardizations for objects of class imputationList
datlist2 &lt;- mitools::imputationList(datlist)   # object class conversion
datlist2a &lt;- miceadds::scale_datlist( datlist=datlist2, orig_var="hisei",
                 trafo_var="hisei100", weights=datlist[[1]]$studwgt, M=100, SD=15 )

#############################################################################
# EXAMPLE 2: Standardized variables in list of nested multiply imputed datasets
#############################################################################

# nested multiply imputed dataset in BIFIEsurvey package
data(data.timss4, package="BIFIEsurvey")
datlist &lt;- data.timss4
wgt &lt;- datlist[[1]][[1]]$TOTWGT

# class nested.datlist
imp1 &lt;- miceadds::nested.datlist_create( datlist )
# class NestedImputationList
imp2 &lt;- miceadds::NestedImputationList( datlist )

# standardize variable scsci
imp1a &lt;- miceadds::scale_datlist( datlist=imp1, orig_var="scsci", trafo_var="zscsci", weights=wgt)
# check descriptives
miceadds::ma.wtd.meanNA( imp1a, weights=wgt, vars=c("scsci", "zscsci" ) )
miceadds::ma.wtd.sdNA( imp1a, weights=wgt, vars=c("scsci", "zscsci" ) )

#############################################################################
# EXAMPLE 3: Standardization of variables for imputed data in mice package
#############################################################################

data(nhanes, package="mice")
set.seed(76)

#--- impute nhanes data
imp &lt;- mice::mice(nhanes)
#--- convert into datlist
datlist &lt;- miceadds::mids2datlist(imp)
#--- scale datlist (all variables)
vars &lt;- colnames(nhanes)
sdatlist &lt;- miceadds::scale_datlist(datlist, orig_var=vars, trafo_var=paste0("z",vars) )
#--- reconvert to mids object
imp2 &lt;- miceadds::datlist2mids(sdatlist)
#*** compare descriptive statistics of objects
round( miceadds::mean0( mice::complete(imp, action=1) ), 2 )
round( miceadds::mean0( mice::complete(imp2, action=1) ), 2 )

## End(Not run)
</code></pre>

<hr>
<h2 id='scan.vec'>
<span class="rlang"><b>R</b></span> Utilities: Scan a Character Vector
</h2><span id='topic+scan.vec'></span><span id='topic+scan.vector'></span><span id='topic+scan0'></span>

<h3>Description</h3>

<p>The function <code>scan.vec</code> function splits a string into a character
vector. The function <code>scan0</code> is the
<code><a href="base.html#topic+scan">base::scan</a></code> function using the default
<code>what="character"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan.vec(vec)
scan.vector(vec)

scan0(file="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan.vec_+3A_vec">vec</code></td>
<td>

<p>A string which should be split according to blanks
</p>
</td></tr>
<tr><td><code id="scan.vec_+3A_file">file</code></td>
<td>

<p>File to be scanned. See <code><a href="base.html#topic+scan">base::scan</a></code>.
</p>
</td></tr>
<tr><td><code id="scan.vec_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed.
See <code><a href="base.html#topic+scan">base::scan</a></code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scan">base::scan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Example scan.vec | reading a string
#############################################################################


vars &lt;- miceadds::scan.vector( "urbgrad \n  groesse  \t  Nausg  grpgroesse   privat  ")
vars
  ## [1] "urbgrad"    "groesse"    "Nausg"      "grpgroesse"
  ## [6] "privat"

## the next lines are only commented out to fulfill CRAN checks
## vars2 &lt;- miceadds::scan0()
##     female urbgrad  groesse  Nausg    grpgroesse   privat
</code></pre>

<hr>
<h2 id='source.all'>
<span class="rlang"><b>R</b></span> Utilities: Source all R or <span class="pkg">Rcpp</span> Files within a Directory
</h2><span id='topic+source.all'></span><span id='topic+source.Rcpp.all'></span><span id='topic+rcpp_create_header_file'></span>

<h3>Description</h3>

<p>The function <code>source.all</code> sources all <span class="rlang"><b>R</b></span> files within a specified directory and
is based on <code><a href="base.html#topic+source">base::source</a></code>.
</p>
<p>The function <code>source.Rcpp.all</code> sources all <span class="pkg">Rcpp</span> files within a specified directory
and is based on <code><a href="Rcpp.html#topic+sourceCpp">Rcpp::sourceCpp</a></code>.
</p>
<p>The function <code>rcpp_create_header_file</code> creates a cpp header file for a <span class="pkg">Rcpp</span>
file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source.all( path, grepstring="\\.R",  print.source=TRUE, file_sep="__"  )

source.Rcpp.all( path, file_names=NULL, ext="\\.cpp", excl="RcppExports",
   remove_temp_file=FALSE )

rcpp_create_header_file(file_name, pack=NULL, path=getwd() )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="source.all_+3A_path">path</code></td>
<td>

<p>Path where the files are located
</p>
</td></tr>
<tr><td><code id="source.all_+3A_grepstring">grepstring</code></td>
<td>

<p>Which strings should be looked for?
<code>grepstring</code> can also be a vector.
</p>
</td></tr>
<tr><td><code id="source.all_+3A_print.source">print.source</code></td>
<td>

<p>An optional logical whether the source process printed on the console?
</p>
</td></tr>
<tr><td><code id="source.all_+3A_file_sep">file_sep</code></td>
<td>
<p>String at which file name should be split for looking
for most recent files</p>
</td></tr>
<tr><td><code id="source.all_+3A_file_names">file_names</code></td>
<td>
<p>Optional vector of (parts of) file names</p>
</td></tr>
<tr><td><code id="source.all_+3A_ext">ext</code></td>
<td>
<p>File extension for <span class="pkg">Rcpp</span> files</p>
</td></tr>
<tr><td><code id="source.all_+3A_excl">excl</code></td>
<td>
<p>String indicating which files should be omitted from sourcing</p>
</td></tr>
<tr><td><code id="source.all_+3A_remove_temp_file">remove_temp_file</code></td>
<td>
<p>Logical indicating whether temporary <span class="pkg">Rcpp</span>
files should be removed.</p>
</td></tr>
<tr><td><code id="source.all_+3A_file_name">file_name</code></td>
<td>
<p>File name</p>
</td></tr>
<tr><td><code id="source.all_+3A_pack">pack</code></td>
<td>
<p>Optional string for package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For loading header files, the line <code>// [include_header_file]</code> has to be included
before loading the header file using a line of the form
<code>#include "my_function.h"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# define path
path &lt;- "c:/myfiles/"
# source all files containing the string 'Rex'
source.all( path, "Rex" )

## End(Not run)
</code></pre>

<hr>
<h2 id='stats0'>
Descriptive Statistics for a Vector or a Data Frame
</h2><span id='topic+stats0'></span><span id='topic+max0'></span><span id='topic+min0'></span><span id='topic+mean0'></span><span id='topic+sd0'></span><span id='topic+var0'></span><span id='topic+quantile0'></span><span id='topic+prop_miss'></span>

<h3>Description</h3>

<p>Applies descriptive statistics to a vector or a data frame. The function
<code>stats0</code> is a general function. This function is used for extending
the basic descriptive statistics functions from the <span class="pkg">base</span> and
<span class="pkg">stats</span> package. The function <code>prop_miss</code> computes the proportion
of missing data for each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats0(x, FUN, na.rm=TRUE,...)

max0(x, na.rm=TRUE)
mean0(x, na.rm=TRUE)
min0(x, na.rm=TRUE)
quantile0(x, probs=seq(0, 1, 0.25), na.rm=TRUE)
sd0(x, na.rm=TRUE)
var0(x, na.rm=TRUE)

prop_miss(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats0_+3A_x">x</code></td>
<td>

<p>Vector or a data frame
</p>
</td></tr>
<tr><td><code id="stats0_+3A_fun">FUN</code></td>
<td>

<p>Function which is applied to <code>x</code>
</p>
</td></tr>
<tr><td><code id="stats0_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether missing data should be removed</p>
</td></tr>
<tr><td><code id="stats0_+3A_probs">probs</code></td>
<td>
<p>Probabilities</p>
</td></tr>
<tr><td><code id="stats0_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+max">base::max</a></code>,
<code><a href="base.html#topic+mean">base::mean</a></code>,
<code><a href="base.html#topic+min">base::min</a></code>,
<code><a href="stats.html#topic+quantile">stats::quantile</a></code>,
<code><a href="stats.html#topic+sd">stats::sd</a></code>,
<code><a href="stats.html#topic+var">stats::var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Descriptive statistics toy datasets
#############################################################################

#--- simulate vector y and data frame dat
set.seed(765)
N &lt;- 25    # number of observations
y &lt;- stats::rnorm(N)
V &lt;- 4    # number of variables
dat &lt;- matrix( stats::rnorm( N*V ), ncol=V )
colnames(dat) &lt;- paste0("V",1:V)

#-- standard deviation
apply( dat, 2, stats::sd )
sd0( dat )
#-- mean
apply( dat, 2, base::mean )
mean0( dat )
#-- quantile
apply( dat, 2, stats::quantile )
quantile0( dat )
#-- minimum and maximum
min0(dat)
max0(dat)

#*** apply functions to missing data
dat1 &lt;- dat
dat1[ cbind( c(2,5),2) ] &lt;- NA

#-- proportion of missing data
prop_miss( dat1 )
#-- MAD statistic
stats0( dat, FUN=stats::mad )
#-- SD
sd0(y)
</code></pre>

<hr>
<h2 id='str_C.expand.grid'>
<span class="rlang"><b>R</b></span> Utilities: String Paste Combined with <code>expand.grid</code>
</h2><span id='topic+str_C.expand.grid'></span>

<h3>Description</h3>

<p>String paste combined with <code>expand.grid</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_C.expand.grid(xlist, indices=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_C.expand.grid_+3A_xlist">xlist</code></td>
<td>

<p>A list of character vectors
</p>
</td></tr>
<tr><td><code id="str_C.expand.grid_+3A_indices">indices</code></td>
<td>
<p>Optional vector of indices to be permuted in <code>xlist</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Some toy examples
#############################################################################

x1 &lt;- list( c("a","b" ), c("t", "r","v") )
str_C.expand.grid( x1 )
  ##   [1] "at" "bt" "ar" "br" "av" "bv"

x1 &lt;- list( c("a","b" ), paste0("_", 1:4 ), c("t", "r","v") )
str_C.expand.grid( x1, indices=c(2,1,3) )
  ##    [1] "_1at" "_1bt" "_2at" "_2bt" "_3at" "_3bt" "_4at" "_4bt" "_1ar" "_1br"
  ##   [11] "_2ar" "_2br" "_3ar" "_3br" "_4ar" "_4br" "_1av" "_1bv" "_2av" "_2bv"
  ##   [21] "_3av" "_3bv" "_4av" "_4bv"

## Not run: 
##***************************************************************************
## The function 'str_C.expand.grid' is currently defined as
function( xlist, indices=NULL )
{
     xeg &lt;- expand.grid( xlist)
     if ( ! is.null(indices) ){    xeg &lt;- xeg[, indices ]}
     apply( xeg, 1, FUN=function(vv){ paste0( vv, collapse="") } )
}
##***************************************************************************

## End(Not run)
</code></pre>

<hr>
<h2 id='subset_datlist'>
Subsetting Multiply Imputed Datasets and Nested Multiply Imputed Datasets
</h2><span id='topic+subset_datlist'></span><span id='topic+subset.datlist'></span><span id='topic+subset.imputationList'></span><span id='topic+subset.mids'></span><span id='topic+subset.mids.1chain'></span><span id='topic+subset_nested.datlist'></span><span id='topic+subset.nested.datlist'></span><span id='topic+subset.NestedImputationList'></span>

<h3>Description</h3>

<p>Returns a subsets of multiply imputed datasets or nested multiply imputed datasets.
These function allows choosing parts of the imputed datasets using the
<code>index</code> argument for multiply imputed datasets and <code>index_between</code> and
<code>index_within</code> for nested multiply imputed datasets as well as the application
of the <code><a href="base.html#topic+subset">base::subset</a></code> S3 method for selecting
cases and variables in datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_datlist(datlist, subset=TRUE, select=NULL, expr_subset=NULL,
        index=NULL, toclass="datlist")

## S3 method for class 'datlist'
subset(x, subset, select=NULL, expr_subset=NULL,
                     index=NULL, ...)
## S3 method for class 'imputationList'
subset(x, subset, select=NULL, expr_subset=NULL,
                     index=NULL, ...)
## S3 method for class 'mids'
subset(x, subset, select=NULL, expr_subset=NULL,
                     index=NULL, ...)
## S3 method for class 'mids.1chain'
subset(x, subset, select=NULL, expr_subset=NULL,
                     index=NULL, ...)

subset_nested.datlist( datlist, subset=TRUE, select=NULL, expr_subset=NULL,
      index_between=NULL, index_within=NULL, toclass="nested.datlist",
          simplify=FALSE )

## S3 method for class 'nested.datlist'
subset(x, subset, select=NULL, expr_subset=NULL,
                index_between=NULL, index_within=NULL, simplify=FALSE, ...)
## S3 method for class 'NestedImputationList'
subset(x, subset, select=NULL, expr_subset=NULL,
                index_between=NULL, index_within=NULL, simplify=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_datlist_+3A_datlist">datlist</code></td>
<td>

<p>For <code>subset_datlist</code> it is a list of datasets or an object of class
<code>datlist</code>, <code>imputationList</code>, <code>mids</code> or <code>mids.1chain</code>. <br />
For <code>subset_nested.datlist</code> it is a list of datasets or an object of class
<code>nested.datlist</code> or <code>NestedImputationList</code>.
</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_subset">subset</code></td>
<td>

<p>Logical expression indicating elements or rows to keep, see
<code><a href="base.html#topic+subset">base::subset</a></code>. <code>subset</code> can also
be a numeric vector containing row indices.
</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_select">select</code></td>
<td>
<p>Expression indicating columns to select from a data frame</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_expr_subset">expr_subset</code></td>
<td>
<p>Expression indicating a selection criterion for
selection rows.</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_index">index</code></td>
<td>

<p>Vector of indices indicating which of the multiply imputed datasets
should be selected.
</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_toclass">toclass</code></td>
<td>

<p>The object class in which the datasets should be saved.
</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_index_between">index_between</code></td>
<td>
<p>Index for between nest datasets</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_index_within">index_within</code></td>
<td>
<p>Index for within nest datasets</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_simplify">simplify</code></td>
<td>
<p>Optional logical indicating whether a nested multiply
imputed dataset should be simplified to a multiplied imputed dataset.
</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_x">x</code></td>
<td>
<p>Object containing multiply imputed or nested multiply imputed
datasets</p>
</td></tr>
<tr><td><code id="subset_datlist_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For multiply imputed datasets: Object of class <code>datlist</code>,
<code>imputationList</code> or <code>mids</code> <br />
For nested multiply imputed datasets: Object of class
<code>nested.datlist</code> or <code>NestedImputationList</code>.
</p>


<h3>Note</h3>

<p>If subsetting is applied to objects of class <code>mids</code> (or <code>mids.1chain</code>),
then informations about the imputation procedure are lost.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">base::subset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Subsetting and selection of multiply imputed datasets
#############################################################################

data(data.ma02)

# define original list of datasets
datlist1a &lt;- data.ma02
# object of class datlist
datlist1b &lt;- miceadds::datlist_create(datlist1a)
datlist1b
# object of class imputationList
datlist1c &lt;- mitools::imputationList(datlist1a)
datlist1c
# object of class mids
datlist1d &lt;- miceadds::datlist2mids(datlist1a)
datlist1d

# select some imputed datasets
datlist2a &lt;- miceadds::subset_datlist( datlist1a, index=c(5,3,7) )
datlist2a
# convert to class imputationList
datlist2b &lt;- miceadds::subset_datlist( datlist1a, index=c(5,3,7),
                      toclass="imputationList")
datlist2b
# convert to class mids
datlist2c &lt;- miceadds::subset_datlist( datlist1a, index=1:3, toclass="mids")
datlist2c

# select some variables
datlist3a &lt;- miceadds::subset_datlist( datlist1a, select=c("idstud", "books")  )
datlist3a
# Because datlist1b is a datlist it is equivalent to
datlist3b &lt;- subset( datlist1b, select=c("idstud", "books")  )
datlist3b
# operating on imputationList class
datlist3c &lt;- miceadds::subset_datlist( datlist1c, select=c("idstud", "books")  )
datlist3c
# operating on mids class
datlist3d &lt;- miceadds::subset_datlist( datlist1d, select=c("idstud", "books")  )
datlist3d
# selection of rows and columns in multiply imputed datasets
datlist4a &lt;- miceadds::subset_datlist( datlist1a, index=1:5,
                  subset=datlist1a[[1]]$idschool &lt; 1067,
                  select=c("idstud", "idschool","hisei") )
datlist4a
# convert to class mids
datlist4b &lt;- miceadds::subset_datlist( datlist1a, index=1:5,
                  subset=datlist1a[[1]]$idschool &lt; 1067,
                  select=c("idstud", "idschool","hisei"), toclass="mids" )
datlist4b
# The same functionality, but now applying to object of class mids datlist1d
datlist4c &lt;- miceadds::subset_datlist( datlist1d, index=1:5,
               subset=datlist1a[[1]]$idschool &lt; 1067,
               select=c("idstud", "idschool","hisei") )
datlist4c

# expression for selecting rows specific in each data frame
# which can result in differently sized datasets (because the variable
# migrant is imputed)
datlist5a &lt;- miceadds::subset_datlist( datlist1a,  expr_subset=expression(migrant==1) )
datlist5a

# select the first 100 cases
datlist6a &lt;- miceadds::subset_datlist( datlist1a, select=c("idstud", "books"),
                       subset=1:100 )
datlist6a

#############################################################################
# EXAMPLE 2: Subsetting and selection of nested multiply imputed datasets
#############################################################################

library(BIFIEsurvey)
data(data.timss4, package="BIFIEsurvey")
dat &lt;- data.timss4

# create object of class 'nested.datlist'
datlist1a &lt;- miceadds::nested.datlist_create( dat )
# create object of class 'NestedImputationList'
datlist1b &lt;- miceadds::NestedImputationList(dat)

# select some between datasets
datlist2a &lt;- subset_nested.datlist( datlist1a, index_between=c(1,3,4) )
datlist2a
# shorter version
datlist2b &lt;- subset( datlist1a, index_between=c(1,3,4) )
datlist2b
# conversion of a NestedImputationList
datlist2c &lt;- subset( datlist1b, index_between=c(1,3,4))
datlist2c
# select rows and columns
sel_cases &lt;- datlist1a[[1]][[1]]$JKZONE &lt;=42
datlist3a &lt;- subset( datlist1a, subset=sel_cases,
                 select=c("IDSTUD","books", "ASMMAT") )
datlist3a
# remove within nest
datlist4a &lt;- subset( datlist1a, index_within=1 )
datlist4a
# remove within nest and simplify structure
datlist4b &lt;- subset( datlist1a, index_within=1, simplify=TRUE)
datlist4b
datlist4c &lt;- subset( datlist1b, index_within=1, simplify=TRUE)
datlist4c
# remove between nest
datlist5a &lt;- subset( datlist1a, index_between=1, simplify=TRUE)
datlist5a
datlist5b &lt;- subset( datlist1b, index_between=1, simplify=TRUE)
datlist5b

## End(Not run)
</code></pre>

<hr>
<h2 id='sumpreserving.rounding'>
Sum Preserving Rounding
</h2><span id='topic+sumpreserving.rounding'></span>

<h3>Description</h3>

<p>This function implements sum preserving rounding. If the supplied
data is a matrix, then the sum of all row entries is preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumpreserving.rounding(data, digits=0, preserve=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumpreserving.rounding_+3A_data">data</code></td>
<td>

<p>Vector or data frame
</p>
</td></tr>
<tr><td><code id="sumpreserving.rounding_+3A_digits">digits</code></td>
<td>

<p>Number of digits to be round
</p>
</td></tr>
<tr><td><code id="sumpreserving.rounding_+3A_preserve">preserve</code></td>
<td>

<p>Should the sum be preserved?
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1:
#############################################################################

# define example data
data &lt;- c( 1455, 1261, 1067, 970, 582, 97 )
data &lt;- 100 * data / sum(data)

( x1 &lt;- round( data ) )
sum(x1)
(x2 &lt;- miceadds::sumpreserving.rounding( data ) )
sum(x2)

  ##   &gt; ( x1 &lt;- round( data ) )
  ##   [1] 27 23 20 18 11  2
  ##   &gt; sum(x1)
  ##   [1] 101
  ##   &gt; (x2 &lt;- miceadds::sumpreserving.rounding( data ) )
  ##   [1] 27 23 20 18 10  2
  ##   &gt; sum(x2)
  ##   [1] 100

#############################################################################
# EXAMPLE 2:
#############################################################################

# matrix input
data &lt;- rbind( data, data )
( x1 &lt;- round( data ) )
rowSums(x1)
(x2 &lt;- miceadds::sumpreserving.rounding( data ) )
rowSums(x2)

#############################################################################
# EXAMPLE 3:
#############################################################################

x2 &lt;- c( 1.4, 1.4, 1.2 )
round(x2)
sumpreserving.rounding(x2)
  ##   &gt; round(x2)
  ##   [1] 1 1 1
  ##   &gt; miceadds::sumpreserving.rounding(x2)
  ##   [1] 1 2 1
</code></pre>

<hr>
<h2 id='syn_da'>
Generation of Synthetic Data Utilizing Data Augmentation
</h2><span id='topic+syn_da'></span>

<h3>Description</h3>

<p>This function generates synthetic data utilizing data augmentation
(Jiang et al., 2022; Grund et al., 2022). Continuous
and ordinal variables can be handled. The order of the synthesized variables
can be defined using the argument <code>syn_vars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn_da(dat, syn_vars=NULL, fix_vars=NULL, ord_vars=NULL, da_noise=0.5,
   use_pls=TRUE, ncomp=20, exact_regression=TRUE, exact_marginal=TRUE,
   imp_maxit=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn_da_+3A_dat">dat</code></td>
<td>

<p>Original dataset
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_syn_vars">syn_vars</code></td>
<td>

<p>Vector with variable names that should be synthesized
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_fix_vars">fix_vars</code></td>
<td>

<p>Vector with variable names that are held fixed in the synthesis
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_ord_vars">ord_vars</code></td>
<td>

<p>Vector with ordinal variables that are treated as factors when modeled
as predictors in the regression model
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_da_noise">da_noise</code></td>
<td>

<p>Proportion of variance (i.e., unreliability) that is added as noise in data
augmentation. The argument can be numeric or a vector, depending on whether it is made
variable-specific.
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_use_pls">use_pls</code></td>
<td>

<p>Logical indicating whether partial least squares (PLS) should be used for dimension
reduction
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_ncomp">ncomp</code></td>
<td>

<p>Number of PLS factors
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_exact_regression">exact_regression</code></td>
<td>

<p>Logical indicating whether residuals are forced to be uncorrelated with
predictors in the synthesis model
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_exact_marginal">exact_marginal</code></td>
<td>

<p>Logical indicating whether marginal distributions of the variables should be
preserved
</p>
</td></tr>
<tr><td><code id="syn_da_+3A_imp_maxit">imp_maxit</code></td>
<td>

<p>Number of iterations in the imputation if the original dataset contains
missing values
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries
</p>
<table>
<tr><td><code>dat_syn</code></td>
<td>
<p>generated synthetic data</p>
</td></tr>
<tr><td><code>dat2</code></td>
<td>
<p>Data frame containing original and synthetic data</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>more entries</p>
</td></tr>
</table>


<h3>References</h3>

<p>Grund, S., Luedtke, O., &amp; Robitzsch, A. (2022). Using synthetic data to improve
the reproducibility of statistical results in psychological research.
<em>Psychological Methods</em>. Epub ahead of print. <a href="https://doi.org/10.1037/met0000526">doi:10.1037/met0000526</a>
</p>
<p>Jiang, B., Raftery, A. E., Steele, R. J., &amp; Wang, N. (2022). Balancing inferential
integrity and disclosure risk via model targeted masking and multiple imputation.
<em>Journal of the American Statistical Association, 117</em>(537), 52-66.
<a href="https://doi.org/10.1080/01621459.2021.1909597">doi:10.1080/01621459.2021.1909597</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Generate synthetic data with item responses and covariates
#############################################################################

data(data.ma09, package="miceadds")
dat &lt;- data.ma09

# fixed variables in synthesis
fix_vars &lt;- c("PV1MATH", "SEX","AGE")
# ordinal variables in synthesis
ord_vars &lt;- c("FISCED", "MISCED", items)
# variables that should be synthesized
syn_vars &lt;- c("HISEI", "FISCED", "MISCED", items)

#-- synthesize data
mod &lt;- miceadds::syn_da( dat=dat0, syn_vars=syn_vars, fix_vars=fix_vars,
            ord_vars=ord_vars, da_noise=0.5, imp_maxit=2, use_pls=TRUE, ncomp=20,
            exact_regression=TRUE, exact_marginal=TRUE)
#- extract synthetic dataset
mod$dat_syn

## End(Not run)
</code></pre>

<hr>
<h2 id='syn_mice'>
Constructs Synthetic Dataset with <span class="pkg">mice</span> Imputation Methods
</h2><span id='topic+syn_mice'></span>

<h3>Description</h3>

<p>Constructs synthetic dataset with <span class="pkg">mice</span> imputation methods. The functionality
is very similar to the functionality of
<code><a href="synthpop.html#topic+syn">synthpop::syn</a></code> in the <span class="pkg">synthpop</span> package
(Nowok, Raab, &amp; Dibben, 2016). Methods defined in <span class="pkg">synthpop</span> are accessible
via <code><a href="#topic+mice.impute.synthpop">mice.impute.synthpop</a></code> (see Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn_mice(data, m=5, k=NULL, syn_check=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn_mice_+3A_data">data</code></td>
<td>
<p>Original data frame</p>
</td></tr>
<tr><td><code id="syn_mice_+3A_m">m</code></td>
<td>
<p>Number of synthetic datasets</p>
</td></tr>
<tr><td><code id="syn_mice_+3A_k">k</code></td>
<td>
<p>Number of observations in synthetic data</p>
</td></tr>
<tr><td><code id="syn_mice_+3A_syn_check">syn_check</code></td>
<td>
<p>Logical indicating whether checks in
<code><a href="synthpop.html#topic+syn">synthpop::syn</a></code> should be performed.
</p>
</td></tr>
<tr><td><code id="syn_mice_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed, with conventions in
<code><a href="mice.html#topic+mice">mice::mice</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>synds</code>, see <code><a href="synthpop.html#topic+syn">synthpop::syn</a></code>.
</p>


<h3>References</h3>

<p>Nowok, B., Raab, G., &amp; Dibben, C. (2016).
<span class="pkg">synthpop</span>: Bespoke creation of synthetic data in <span class="rlang"><b>R</b></span>.
<em>Journal of Statistical Software, 74</em>(11), 1-26.
<a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>
</p>


<h3>See Also</h3>

<p><code><a href="mice.html#topic+mice">mice::mice</a></code>,
<code><a href="synthpop.html#topic+syn">synthpop::syn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Synthesization of SD2011 using mice functionality
#############################################################################

library(synthpop)

#** selection of dataset
data(SD2011, package="synthpop")
vars &lt;- c("sex","age","ls","smoke")
dat  &lt;- SD2011[1:1000, vars]
dat$ls &lt;- as.numeric(dat$ls)

#** default synthesis
imp0 &lt;- synthpop::syn(dat)
pred0 &lt;- imp0$predictor.matrix
method0 &lt;- imp0$method

#* define imputation methods
method &lt;- c(sex="synthpop", age="synthpop", ls="synthpop", smoke="logreg")
# only for smoke, an original mice imputation method is used

#- define synthpop functions
synthpop_fun &lt;- list(sex="constant", age="constant", ls="cart")

#- arguments for 'syn.cart' method
synthpop_args &lt;- list(ls=list(smoothing="density"))

#- fixed values for 'syn.constant' method
fixed_values &lt;- dat[,1:2]

#- do synthesization
imp &lt;- miceadds::syn_mice(dat, m=1, synthpop_fun=synthpop_fun, method=method,
            pedictorMatrix=pred0, rf.fixed_values=fixed_values, synthpop_args=synthpop_args)
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='syn.constant'>
Synthesizing Method for Fixed Values by Design in <span class="pkg">synthpop</span>
</h2><span id='topic+syn.constant'></span>

<h3>Description</h3>

<p>Defines a synthesizing method for fixed values of a variable by design
in the <span class="pkg">synthpop</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.constant(y, x, xp, fixed_values, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.constant_+3A_y">y</code></td>
<td>
<p>Original data vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="syn.constant_+3A_x">x</code></td>
<td>
<p>Matrix (<code class="reqn">n \times p</code>) of original covariates</p>
</td></tr>
<tr><td><code id="syn.constant_+3A_xp">xp</code></td>
<td>
<p>Matrix (<code class="reqn">k \times p</code>) of synthesised covariates</p>
</td></tr>
<tr><td><code id="syn.constant_+3A_fixed_values">fixed_values</code></td>
<td>
<p>Vector containing fixed values</p>
</td></tr>
<tr><td><code id="syn.constant_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the synthesis method <code>"mice"</code> in
<code><a href="synthpop.html#topic+syn">synthpop::syn</a></code>, the function argument has to appear
as <code>rf.fixed_values</code> (convention in <span class="pkg">synthpop</span>).
</p>


<h3>Value</h3>

<p>A vector of length <code>k</code> with synthetic values of <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="synthpop.html#topic+syn">synthpop::syn</a></code>,
<code><a href="#topic+mice.impute.constant">mice.impute.constant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: SD2011 | Fixed values for variable sex
#############################################################################

library(synthpop)

#** selection of dataset
data(SD2011, package="synthpop")
vars &lt;- c("sex","age","ls","smoke")
dat  &lt;- SD2011[1:1000, vars]
dat$ls &lt;- as.numeric(dat$ls)

#** default synthesis
imp0 &lt;- synthpop::syn(dat)
pred &lt;- imp0$predictor.matrix
method &lt;- imp0$method

#** constant vector
method["sex"] &lt;- "constant"
fixed_values &lt;- data.frame( sex=rep(dat$sex[c(1,2)], each=1000) )
imp &lt;- synthpop::syn( dat, method=method, k=2000, m=1,
                rf.fixed_values=fixed_values)
table(imp$syn$sex)

## End(Not run)
</code></pre>

<hr>
<h2 id='syn.formula'>
Synthesizing Method for <span class="pkg">synthpop</span> Using a Formula Interface
</h2><span id='topic+syn.formula'></span>

<h3>Description</h3>

<p>Defines a synthesizing method for for <span class="pkg">synthpop</span> using a formula interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.formula(y, x, xp, proper=FALSE, syn_formula, syn_fun, syn_args, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.formula_+3A_y">y</code></td>
<td>
<p>Original data vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="syn.formula_+3A_x">x</code></td>
<td>
<p>Matrix (<code class="reqn">n \times p</code>) of original covariates</p>
</td></tr>
<tr><td><code id="syn.formula_+3A_xp">xp</code></td>
<td>
<p>Matrix (<code class="reqn">k \times p</code>) of synthesised covariates</p>
</td></tr>
<tr><td><code id="syn.formula_+3A_proper">proper</code></td>
<td>
<p>Logical value specifying whether proper synthesis should be conducted.</p>
</td></tr>
<tr><td><code id="syn.formula_+3A_syn_formula">syn_formula</code></td>
<td>
<p>A formula object</p>
</td></tr>
<tr><td><code id="syn.formula_+3A_syn_fun">syn_fun</code></td>
<td>
<p>Synthesizing method in <span class="pkg">synthpop</span> package</p>
</td></tr>
<tr><td><code id="syn.formula_+3A_syn_args">syn_args</code></td>
<td>
<p>Function arguments of <code>syn_fun</code></p>
</td></tr>
<tr><td><code id="syn.formula_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the synthesis method <code>"mice"</code> in
<code><a href="synthpop.html#topic+syn">synthpop::syn</a></code>, the function arguments have to appear
as <code>rf.syn_formula</code>, <code>rf.syn_fun</code> and <code>rf.syn_args</code>
(convention in <span class="pkg">synthpop</span>).
</p>


<h3>Value</h3>

<p>A vector of length <code>k</code> with synthetic values of <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="synthpop.html#topic+syn">synthpop::syn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: SD2011 | using a formula for defining the regression model
#############################################################################

library(synthpop)

#** selection of dataset
data(SD2011, package="synthpop")
vars &lt;- c("sex","age","ls","smoke")
dat  &lt;- SD2011[1:1000, vars]
dat$ls &lt;- as.numeric(dat$ls)

#** default synthesis
imp0 &lt;- synthpop::syn(dat)
pred &lt;- imp0$predictor.matrix
method &lt;- imp0$method

#** use synthesizing method 'formula'
method["ls"] &lt;- "formula"
syn_fun &lt;- list( ls="normrank" )
syn_args &lt;- list( ls=list( smoothing="density" ) )
syn_formula &lt;- list( ls=~ sex + age + I(age^2) + I(age&gt;50) )

#* synthesize data
imp &lt;- synthpop::syn( dat, method=method, predictor.matrix=pred, k=2000, m=1,
            rf.syn_fun=syn_fun, rf.syn_args=syn_args, rf.syn_formula=syn_formula)
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='syn.mice'>
Using a <span class="pkg">mice</span> Imputation Method in the <span class="pkg">synthpop</span> Package
</h2><span id='topic+syn.mice'></span>

<h3>Description</h3>

<p>The function allows to use a <span class="pkg">mice</span> imputation method to be used
in the <code><a href="synthpop.html#topic+syn">synthpop::syn</a></code> function of
the <span class="pkg">synthpop</span> package (Nowok, Raab, &amp; Dibben, 2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.mice(y, x, xp, mice_fun, mice_args, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.mice_+3A_y">y</code></td>
<td>
<p>Original data vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="syn.mice_+3A_x">x</code></td>
<td>
<p>Matrix (<code class="reqn">n \times p</code>) of original covariates</p>
</td></tr>
<tr><td><code id="syn.mice_+3A_xp">xp</code></td>
<td>
<p>Matrix (<code class="reqn">k \times p</code>) of synthesised covariates</p>
</td></tr>
<tr><td><code id="syn.mice_+3A_mice_fun">mice_fun</code></td>
<td>
<p>Name of imputation method for <span class="pkg">mice</span></p>
</td></tr>
<tr><td><code id="syn.mice_+3A_mice_args">mice_args</code></td>
<td>
<p>Optional list of arguments for <code>mice_fun</code>, see Examples.</p>
</td></tr>
<tr><td><code id="syn.mice_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the synthesis method <code>"mice"</code> in
<code><a href="synthpop.html#topic+syn">synthpop::syn</a></code>, the function arguments have to appear
as <code>rf.mice_fun</code> and <code>rf.mice_arg</code> (convention in <span class="pkg">synthpop</span>).
</p>


<h3>Value</h3>

<p>A vector of length <code>k</code> with synthetic values of <code>y</code>.
</p>


<h3>References</h3>

<p>Nowok, B., Raab, G., &amp; Dibben, C. (2016).
<span class="pkg">synthpop</span>: Bespoke creation of synthetic data in <span class="rlang"><b>R</b></span>.
<em>Journal of Statistical Software, 74</em>(11), 1-26.
<a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>
</p>


<h3>See Also</h3>

<p><code><a href="synthpop.html#topic+syn">synthpop::syn</a></code>, <code><a href="#topic+syn_mice">syn_mice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: SD2011 | Minimal example for using a mice imputation method
#############################################################################

library(synthpop)

#** selection of dataset
data(SD2011, package="synthpop")
vars &lt;- c("sex","age","ls","smoke")
dat  &lt;- SD2011[1:1000, vars]
dat$ls &lt;- as.numeric(dat$ls)
dat$smoke &lt;- 1*(paste(dat$smoke)=="YES")

#** default synthesis
imp0 &lt;- synthpop::syn(dat)
pred &lt;- imp0$predictor.matrix
method &lt;- imp0$method

#** use mice imputation method 'rlm' for variable 'ls'
method[c("ls","smoke")] &lt;- c("mice","mice")
mice_fun &lt;- list( ls="rlm", smoke="pmm")
mice_args &lt;- list( ls=list( trafo=log, antitrafo=exp) )

#* synthesize data
imp &lt;- synthpop::syn( dat, method=method, predictor.matrix=pred, k=2000, m=1,
            rf.mice_fun=mice_fun, rf.mice_args=mice_args)
summary(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='systime'>
<span class="rlang"><b>R</b></span> Utilities: Various Strings Representing System Time
</h2><span id='topic+systime'></span>

<h3>Description</h3>

<p>This function generates system time strings in several formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>systime()
</code></pre>


<h3>Value</h3>

<p>A vector with entries of system time (see Examples).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Output of systime
#############################################################################

systime()
  ##
  ##  &gt; miceadds::systime()
  ##  [1] "2016-02-29 10:25:44"
  ##  [2] "2016-02-29"
  ##  [3] "20160229"
  ##  [4] "2016-02-29_1025"
  ##  [5] "2016-02-29_1000"
  ##  [6] "20160229_102544"
  ##  [7] "20160229102544"
  ##  [8] "IPNERZW-C014_20160229102544"
</code></pre>

<hr>
<h2 id='tw.imputation'>
Two-Way Imputation
</h2><span id='topic+tw.imputation'></span><span id='topic+tw.mcmc.imputation'></span>

<h3>Description</h3>

<p>Two-way imputation using the simple method of Sijtsma and van der Ark (2003)
and the MCMC based imputation of van Ginkel, van der Ark, Sijtsma and Vermunt (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tw.imputation(data, integer=FALSE)

tw.mcmc.imputation(data, iter=100, integer=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tw.imputation_+3A_data">data</code></td>
<td>

<p>Matrix of item responses corresponding to a scale
</p>
</td></tr>
<tr><td><code id="tw.imputation_+3A_integer">integer</code></td>
<td>

<p>A logical indicating whether imputed values should be integers.
The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="tw.imputation_+3A_iter">iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For persons <code class="reqn">p</code> and items <code class="reqn">i</code>, the two-way imputation is conducted
by posing a linear model of tau-equivalent measurements:
</p>
<p style="text-align: center;"><code class="reqn">X_{pi}=\theta_p + b_i + \varepsilon_{ij} </code>
</p>

<p>If the score <code class="reqn">X_{pi}</code> is missing then it is imputed by
</p>
<p style="text-align: center;"><code class="reqn">\hat{X}_{pi}=\tilde{X}_p + b_i </code>
</p>
<p> where <code class="reqn">\tilde{X}_p</code> is the
person mean of person <code class="reqn">p</code> of the remaining items with observed responses.
</p>
<p>The two-way imputation can also be seen as a scaling procedure to obtain
a scale score which takes different item means into account.
</p>


<h3>Value</h3>

<p>A matrix with original and imputed values
</p>


<h3>References</h3>

<p>Sijtsma, K., &amp; Van der Ark, L. A. (2003).
Investigation and treatment of missing item scores in test and questionnaire
data. <em>Multivariate Behavioral Research, 38</em>(4), 505-528.
<a href="https://doi.org/10.1207/s15327906mbr3804_4">doi:10.1207/s15327906mbr3804_4</a>
</p>
<p>Van Ginkel, J. R., Van der Ark, A., Sijtsma, K., &amp; Vermunt, J. K. (2007).
Two-way imputation: A Bayesian method for estimating missing scores in tests
and questionnaires, and an accurate approximation.
<em>Computational Statistics &amp; Data Analysis, 51</em>(8), 4013-4027.
<a href="https://doi.org/10.1016/j.csda.2006.12.022">doi:10.1016/j.csda.2006.12.022</a>
</p>


<h3>See Also</h3>

<p>The two-way imputation method is also implemented in
the <code>TestDataImputation::Twoway</code> function of the
<b>TestDataImputation</b> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Two-way imputation data.internet
#############################################################################

data(data.internet)
data &lt;- data.internet

#***
# Model 1: Two-way imputation method of Sijtsma and van der Ark (2003)
set.seed(765)
dat.imp &lt;- miceadds::tw.imputation( data )
dat.imp[ 278:281,]
  ##       IN9     IN10    IN11     IN12
  ##   278   5 4.829006 5.00000 4.941611
  ##   279   5 4.000000 4.78979 4.000000
  ##   280   7 4.000000 7.00000 7.000000
  ##   281   4 3.000000 5.00000 5.000000

#***
# Model 2: Two-way imputation method using MCMC
dat.imp &lt;- miceadds::tw.mcmc.imputation( data, iter=3)
dat.imp[ 278:281,]
  ##       IN9     IN10     IN11     IN12
  ##   278   5 6.089222 5.000000 3.017244
  ##   279   5 4.000000 5.063547 4.000000
  ##   280   7 4.000000 7.000000 7.000000
  ##   281   4 3.000000 5.000000 5.000000

## End(Not run)
</code></pre>

<hr>
<h2 id='VariableNames2String'>
Stringing Variable Names with Line Breaks
</h2><span id='topic+VariableNames2String'></span>

<h3>Description</h3>

<p>Stringing variable names with line breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VariableNames2String(vars, breaks=80, sep=" ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VariableNames2String_+3A_vars">vars</code></td>
<td>

<p>Vector with variable names
</p>
</td></tr>
<tr><td><code id="VariableNames2String_+3A_breaks">breaks</code></td>
<td>

<p>Numeric value for line break of variable string
</p>
</td></tr>
<tr><td><code id="VariableNames2String_+3A_sep">sep</code></td>
<td>

<p>Separator
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String with line breaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Toy example
#############################################################################

data(data.ma01)
# extract variable names
vars &lt;- colnames(data.ma01)
# convert into a long string with line breaks at column 25
vars2 &lt;- miceadds::VariableNames2String(vars, breaks=25)
vars
  ##   [1] "idstud"   "idschool" "studwgt"  "math"     "read"     "migrant"
  ##   [7] "books"    "hisei"    "paredu"   "female"   "urban"
vars2
  ##  idstud idschool studwgt
  ##  math read migrant books
  ##  hisei paredu female
  ##  urban
</code></pre>

<hr>
<h2 id='visitSequence.determine'>
Automatic Determination of a Visit Sequence in <code>mice</code>
</h2><span id='topic+visitSequence.determine'></span>

<h3>Description</h3>

<p>This function automatically determines a visit sequence for a specified
model in <code><a href="mice.html#topic+mice">mice::mice</a></code> when passive variables are defined
as imputation methods. Note that redundant visits could be computed and
a user should check the plausibility of the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visitSequence.determine(impMethod, vis, data, maxit=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visitSequence.determine_+3A_impmethod">impMethod</code></td>
<td>

<p>Vector with imputation methods
</p>
</td></tr>
<tr><td><code id="visitSequence.determine_+3A_vis">vis</code></td>
<td>

<p>Initial vector of visit sequence
</p>
</td></tr>
<tr><td><code id="visitSequence.determine_+3A_data">data</code></td>
<td>

<p>Data frame to be used for multiple imputations
</p>
</td></tr>
<tr><td><code id="visitSequence.determine_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iteration for computation of the updated visit sequence
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated vector of the visit sequence
</p>


<h3>See Also</h3>

<p>Used in  the <code><a href="mice.html#topic+mice">mice::mice</a></code> function as an argument.
The function <code><a href="mice.html#topic+make.visitSequence">mice::make.visitSequence</a></code>
creates a visit sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Visit sequence for a small imputation model
#############################################################################

data( data.smallscale )
# select a small number of variables
dat &lt;- data.smallscale[, paste0("v",1:4) ]
V &lt;- ncol(dat)

# define initial vector of imputation methods
impMethod &lt;- rep("norm", V)
names(impMethod) &lt;- colnames(dat)
# define variable names and imputation method for passive variables in a data frame
dfr.impMeth &lt;- data.frame( "variable"=NA,
                  "impMethod"=NA )
dfr.impMeth[1,] &lt;- c("v1_v1", "~ I(v1^2)" )
dfr.impMeth[2,] &lt;- c("v2_v4", "~ I(v2*v4)" )
dfr.impMeth[3,] &lt;- c("v4log", "~ I( log(abs(v4)))" )
dfr.impMeth[4,] &lt;- c("v12", "~ I( v1 + v2 + 3*v1_v1 - v2_v4 )" )
# add variables to dataset and imputation methods
VV &lt;- nrow(dfr.impMeth)
for (vv in 1:VV){
    impMethod[ dfr.impMeth[vv,1] ] &lt;- dfr.impMeth[vv,2]
    dat[, dfr.impMeth[vv,1] ] &lt;- NA
}

# run empty imputation model to obtain initial vector of visit sequence
imp0 &lt;- mice::mice( dat, m=1, method=impMethod, maxit=0 )
imp0$vis

# update visit sequence
vis1 &lt;- miceadds::visitSequence.determine( impMethod=impMethod, vis=imp0$vis, data=dat)

# imputation with updated visit sequence
imp &lt;- mice::mice( dat, m=1, method=impMethod, visitSequence=vis1, maxit=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='with.miceadds'>
Evaluates an Expression for (Nested) Multiply Imputed Datasets
</h2><span id='topic+with.mids.1chain'></span><span id='topic+with.mids.nmi'></span><span id='topic+with.NestedImputationList'></span><span id='topic+with.datlist'></span><span id='topic+with.nested.datlist'></span><span id='topic+within.imputationList'></span><span id='topic+within.NestedImputationList'></span><span id='topic+within.datlist'></span><span id='topic+within.nested.datlist'></span><span id='topic+summary.mira.nmi'></span><span id='topic+withPool_MI'></span><span id='topic+withPool_NMI'></span>

<h3>Description</h3>

<p>Evaluates an expression for (nested) multiply imputed datasets. These
functions extend the following functions:
<code><a href="mice.html#topic+with.mids">mice::with.mids</a></code>,
<code><a href="base.html#topic+with">base::with</a></code>,
<code><a href="base.html#topic+within.data.frame">base::within.data.frame</a></code>,
<code><a href="mitools.html#topic+with.imputationList">mitools::with.imputationList</a></code>.
</p>
<p>The <code>withPool</code> functions try to pool estimates (by simple averaging)
obtained by <code>with</code> or a list of results of imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mids.1chain'
with(data, expr, ...)
## S3 method for class 'datlist'
with(data, expr, fun, ...)

## S3 method for class 'mids.nmi'
with(data, expr, ...)
## S3 method for class 'nested.datlist'
with(data, expr, fun, ...)
## S3 method for class 'NestedImputationList'
with(data, expr, fun, ...)

## S3 method for class 'datlist'
within(data, expr, ...)
## S3 method for class 'imputationList'
within(data, expr, ...)

## S3 method for class 'nested.datlist'
within(data, expr, ...)
## S3 method for class 'NestedImputationList'
within(data, expr, ...)

withPool_MI(x, ...)

withPool_NMI(x, ...)

## S3 method for class 'mira.nmi'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.miceadds_+3A_data">data</code></td>
<td>

<p>Object of class <code>mids.1chain</code>, <code>mids.nmi</code>, <code>imputationList</code>
or <code>NestedImputationList</code>
</p>
</td></tr>
<tr><td><code id="with.miceadds_+3A_expr">expr</code></td>
<td>

<p>Expression with a formula object.
</p>
</td></tr>
<tr><td><code id="with.miceadds_+3A_fun">fun</code></td>
<td>
<p>A function taking a data frame argument</p>
</td></tr>
<tr><td><code id="with.miceadds_+3A_...">...</code></td>
<td>

<p>Additional parameters to be passed to <code>expr</code>.
</p>
</td></tr>
<tr><td><code id="with.miceadds_+3A_object">object</code></td>
<td>
<p>Object of class <code>mira.nmi</code>.</p>
</td></tr>
<tr><td><code id="with.miceadds_+3A_x">x</code></td>
<td>
<p>List with vectors or matrices as results of an analysis
for (nested) multiply imputed datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>with.mids.1chain</code>: List of class <code>mira</code>.
</p>
<p><code>with.mids.nmi</code>: List of class <code>mira.nmi</code>.
</p>
<p><code>with.datlist</code>: List of class <code>imputationResultList</code>.
</p>
<p><code>with.NestedImputationList</code> or <code>with.nested.datlist</code>: List of class
<code>NestedImputationResultList</code>.
</p>
<p><code>within.imputationList</code>: List of class <code>imputationList</code>.
</p>
<p><code>within.NestedImputationList</code>: List of class
<code>NestedImputationList</code>.
</p>
<p><code>withPool_MI</code> or <code>withPool_NMI</code>: Vector or matrix with
pooled estimates
</p>


<h3>Author(s)</h3>

<p>Slightly modified code of <code><a href="mice.html#topic+with.mids">mice::with.mids</a></code>,
<code><a href="mice.html#topic+summary.mira">mice::summary.mira</a></code>,
<code><a href="base.html#topic+within.data.frame">base::within.data.frame</a></code>
</p>


<h3>See Also</h3>

<p>See the corresponding functionality in <span class="pkg">base</span>, <span class="pkg">mice</span>,
<span class="pkg">mitools</span> and <span class="pkg">mitml</span> packages:<br />
<code><a href="mice.html#topic+with.mids">mice::with.mids</a></code>,
<code><a href="mitools.html#topic+with.imputationList">mitools::with.imputationList</a></code>,
<code><a href="mitml.html#topic+with.mitml.list">mitml::with.mitml.list</a></code>,
<code><a href="base.html#topic+with">base::with</a></code>
</p>
<p><code><a href="base.html#topic+within.data.frame">base::within.data.frame</a></code>,
<code><a href="mitml.html#topic+within.mitml.list">mitml::within.mitml.list</a></code>,
</p>
<p><code><a href="mice.html#topic+summary.mira">mice::summary.mira</a></code>,
</p>
<p>Imputation functions in <span class="pkg">miceadds</span>:
<code><a href="#topic+mice.1chain">mice.1chain</a></code>, <code><a href="#topic+mice.nmi">mice.nmi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: One chain nhanes data | application of 'with' and 'within'
#############################################################################

library(mice)
data(nhanes, package="mice")
set.seed(9090)

# nhanes data in one chain
imp &lt;- miceadds::mice.1chain( nhanes, burnin=5, iter=40, Nimp=4 )
# apply linear regression
res &lt;- with( imp, expr=stats::lm( hyp ~ age + bmi  ) )
summary(res)
# pool results
summary( mice::pool(res))

# calculate some descriptive statistics
res2 &lt;- with( imp, expr=c("M1"=mean(hyp), "SD_age"=stats::sd(age) ) )
# pool estimates
withPool_MI(res2)

# with method for datlist
imp1 &lt;- miceadds::datlist_create(imp)
res2b &lt;- with( imp1, fun=function(data){
                    dfr &lt;- data.frame("M"=colMeans(data),
                             "Q5"=apply( data, 2, stats::quantile, .05 ),
                             "Q95"=apply( data, 2, stats::quantile, .95 ) )
                    return(dfr)
                        } )
withPool_MI(res2b)

# convert mids object into an object of class imputationList
datlist &lt;- miceadds::mids2datlist( imp )
datlist &lt;- mitools::imputationList(datlist)

# define formulas for modification of the data frames in imputationList object
datlist2 &lt;- within( datlist, {
                     age.D3 &lt;- 1*(age==3)
                     hyp_chl &lt;- hyp * chl
                        } )
# look at modified dataset
head( datlist2$imputations[[1]] )

# convert into a datlist
datlist2b &lt;- miceadds::datlist_create( datlist2 )

# apply linear model using expression
mod1a &lt;- with( datlist2, expr=stats::lm( hyp ~ age.D3 ) )
# do the same but now with a function argument
mod1b &lt;- with( datlist2, fun=function(data){
                    stats::lm( data$hyp ~ data$age.D3 )
                        } )
# apply the same model for object datlist2b
mod2a &lt;- with( datlist2b, expr=lm( hyp ~ age.D3 ) )
mod2b &lt;- with( datlist2b, fun=function(data){
                    stats::lm( data$hyp ~ data$age.D3 )
                        } )

mitools::MIcombine(mod1a)
mitools::MIcombine(mod1b)
mitools::MIcombine(mod2a)
mitools::MIcombine(mod2b)

#############################################################################
# EXAMPLE 2: Nested multiple imputation and application of with/within methods
#############################################################################

library(BIFIEsurvey)
data(data.timss2, package="BIFIEsurvey" )
datlist &lt;- data.timss2

# remove first four variables
M &lt;- length(datlist)
for (ll in 1:M){
    datlist[[ll]] &lt;- datlist[[ll]][, -c(1:4) ]
                }

# nested multiple imputation using mice
imp1 &lt;- miceadds::mice.nmi( datlist,  m=4, maxit=3 )
summary(imp1)
# apply linear model and use summary method for all analyses of imputed datasets
res1 &lt;- with( imp1, stats::lm( ASMMAT ~ migrant + female ) )
summary(res1)

# convert mids.nmi object into an object of class NestedImputationList
datlist1 &lt;- miceadds::mids2datlist( imp1 )
datlist1 &lt;- miceadds::NestedImputationList( datlist1 )
# convert into nested.datlist object
datlist1b &lt;- miceadds::nested.datlist_create(datlist1)

# use with function
res1b &lt;- with( datlist1, stats::glm( ASMMAT ~ migrant + female ) )
# apply for nested.datlist
res1c &lt;- with( datlist1b, stats::glm( ASMMAT ~ migrant + female ) )

# use within function for data transformations
datlist2 &lt;- within( datlist1, {
                highsc &lt;- 1*(ASSSCI &gt; 600)
                books_dum &lt;- 1*(books&gt;=3)
                rm(scsci)   # remove variable scsci
                    } )

# include random number in each dataset
N &lt;- attr( datlist1b, "nobs")
datlist3 &lt;- within( datlist1b, {
                rn &lt;- stats::runif( N, 0, .5 )
                    } )

#-- some applications of withPool_NMI
# mean and SD
res3a &lt;- with( imp1, c( "m1"=mean(ASMMAT), "sd1"=stats::sd(ASMMAT) ) )
withPool_NMI(res3a)
# quantiles
vars &lt;- c("ASMMAT", "lang", "scsci")
res3b &lt;- with( datlist1b, fun=function(data){
                dat &lt;- data[,vars]
                res0 &lt;- sapply( vars, FUN=function(vv){
                    stats::quantile( dat[,vv], probs=c(.25, .50, .75) )
                                    } )
                t(res0)
                    } )
withPool_NMI(res3b)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.datlist'>
Write a List of Multiply Imputed Datasets
</h2><span id='topic+write.datlist'></span>

<h3>Description</h3>

<p>Writes a list of multiply imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.datlist(datlist, name, include.varnames=TRUE, type="csv2",
     separate=TRUE, Mplus=FALSE, round=NULL, Rdata=TRUE,
     subdir=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.datlist_+3A_datlist">datlist</code></td>
<td>

<p>List of imputed datasets. Can also be an object of class
<code>mids</code>, <code>mids.1chain</code> or <code>imputationList</code>
</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_name">name</code></td>
<td>

<p>Name of files to be saved
</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_include.varnames">include.varnames</code></td>
<td>

<p>Logical indicating whether variables should be saved
</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_type">type</code></td>
<td>

<p>File type of datasets to be saved, see <code><a href="#topic+save.data">save.data</a></code>.
</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_separate">separate</code></td>
<td>
<p>Logical indicating whether imputed datasets
should be written in separate files.
</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_mplus">Mplus</code></td>
<td>

<p>Logical indicating whether files should be written for usage
in Mplus software
</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_round">round</code></td>
<td>

<p>Number of digits to round after decimal. The default is no rounding.
</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_rdata">Rdata</code></td>
<td>

<p>Logical indicating whether <code>datlist</code> should also be saved
in <span class="rlang"><b>R</b></span> binary format.
</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_subdir">subdir</code></td>
<td>
<p>Logical indicating whether results should be written into
a subdirectory.</p>
</td></tr>
<tr><td><code id="write.datlist_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code><a href="#topic+save.data">save.data</a></code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See also <code><a href="mice.html#topic+mids2mplus">mice::mids2mplus</a></code>,
<code><a href="mice.html#topic+mids2spss">mice::mids2spss</a></code> and
<code><a href="#topic+write.mice.imputation">write.mice.imputation</a></code> for writing objects of class
<code>mids</code>.
</p>
<p>See also <code>Amelia::write.amelia</code> for
writing imputed datasets in <span class="pkg">Amelia</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Write data list imputed in mice
#############################################################################

data(data.ma01)
dat &lt;- as.matrix(data.ma01)

# start with empty imputation
imp0 &lt;- mice::mice( dat, maxit=0)

# modify predictor matrix
predM &lt;- imp0$predictorMatrix
predM[, c("idschool", "idstud" ) ] &lt;- 0
# modify imputation method
impMeth &lt;- imp0$method
impMeth[ impMeth=="pmm" ] &lt;- "norm"

# do imputations in mice
imp &lt;- mice::mice( dat, predictorMatrix=predM, method=impMeth, m=3, maxit=4 )

# write imputed data in format "csv2" and round after 4 digits
write.datlist( datlist=imp, name="mice_imp_csv2", round=4 )
# write imputed data in R binary format
write.datlist( datlist=imp, name="mice_imp_Rdata", type="Rdata")
# write data for Mplus usage
write.datlist( datlist=imp, name="mice_imp_Mplus", Mplus=TRUE, round=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.fwf2'>
Reading and Writing Files in Fixed Width Format
</h2><span id='topic+write.fwf2'></span><span id='topic+read.fwf2'></span>

<h3>Description</h3>

<p>Reads and writes files in fixed width format. The functions are written
for being more efficient than <code><a href="utils.html#topic+read.fwf">utils::read.fwf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fwf2(dat, format.full, format.round, file)

read.fwf2( file, format.full, variables=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fwf2_+3A_dat">dat</code></td>
<td>

<p>Data frame (or matrix). Variables can be numeric or strings. However,
string length of string variables are not allowed to be larger
than what is specified in <code>format.full</code>.
</p>
</td></tr>
<tr><td><code id="write.fwf2_+3A_format.full">format.full</code></td>
<td>

<p>Vector with fixed width variable lengths
</p>
</td></tr>
<tr><td><code id="write.fwf2_+3A_format.round">format.round</code></td>
<td>

<p>Vector with digits after decimals
</p>
</td></tr>
<tr><td><code id="write.fwf2_+3A_file">file</code></td>
<td>

<p>File name
</p>
</td></tr>
<tr><td><code id="write.fwf2_+3A_variables">variables</code></td>
<td>
<p>Optional vector with variable names</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.fwf">utils::read.fwf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Write and read a file in fixed width format
#############################################################################

# set working directory
path &lt;- "P:/ARb/temp"
setwd(path)

# define a data frame
set.seed(9876)
dat &lt;- data.frame( "x"=seq( 1, 21, len=5), "y"=stats::runif( 5 ),
            "z"=stats::rnorm( 5 ) )

# save data frame in fixed width format
format.full &lt;- c(6, 6, 8 )
format.round &lt;- c( 0, 2, 3 )
write.fwf2( dat, format.full=format.full, format.round=format.round,
                file="testdata" )

# read the data
dat1 &lt;- miceadds::read.fwf2( file="testdata.dat", format.full=c(6,6,8),
               variables=c("x","y","z") )
# check differences between data frames
dat - dat1

#############################################################################
# EXAMPLE 2: Write datasets containing some string variables in fwf format
#############################################################################

n &lt;- 5
dat &lt;- data.frame( "x"=stats::runif(n, 0, 9 ), "y"=LETTERS[1:n] )
write.fwf2(dat, format.full=c(4,2), format.round=c(2,0),  file="testdata")

## End(Not run)
</code></pre>

<hr>
<h2 id='write.mice.imputation'>
Export Multiply Imputed Datasets from a <code>mids</code> Object
</h2><span id='topic+write.mice.imputation'></span>

<h3>Description</h3>

<p>Exports multiply imputed datasets and information about the imputation.
Objects of class <code>mids</code> (generated by <code><a href="mice.html#topic+mice">mice::mice</a></code>)
and <code>mids.1chain</code> (generated by <code><a href="#topic+mice.1chain">mice.1chain</a></code>) are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.mice.imputation(mi.res, name, include.varnames=TRUE,
      long=TRUE, mids2spss=TRUE, spss.dec=",", dattype=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.mice.imputation_+3A_mi.res">mi.res</code></td>
<td>

<p>Object of class <code>mids</code> or <code>mids.1chain</code>
</p>
</td></tr>
<tr><td><code id="write.mice.imputation_+3A_name">name</code></td>
<td>

<p>Name of created subdirectory and datasets
</p>
</td></tr>
<tr><td><code id="write.mice.imputation_+3A_include.varnames">include.varnames</code></td>
<td>

<p>An optional logical indicating whether variable names should be included
in the imputed dataset. The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="write.mice.imputation_+3A_long">long</code></td>
<td>

<p>An optional logical indicating whether the dataset should also
be saved in a long format?
</p>
</td></tr>
<tr><td><code id="write.mice.imputation_+3A_mids2spss">mids2spss</code></td>
<td>

<p>An optional logical indicating whether a syntax for reading imputed datasets
in SPSS should be included
</p>
</td></tr>
<tr><td><code id="write.mice.imputation_+3A_spss.dec">spss.dec</code></td>
<td>

<p>SPSS decimal separator (can be <code>","</code> or <code>"."</code>)
</p>
</td></tr>
<tr><td><code id="write.mice.imputation_+3A_dattype">dattype</code></td>
<td>

<p>Format of the saved dataset: <code>csv</code> or <code>csv2</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Several files are saved using <code>impxxx</code> (the <code>name</code>)
as the prefix:
</p>
<table>
<tr><td><code>impxxx.Rdata</code></td>
<td>
<p>Saved object of class <code>mids</code></p>
</td></tr>
<tr><td><code>impxxx__DATALIST.Rdata</code></td>
<td>
<p>Saved object of a list containing multiply
imputed datasets</p>
</td></tr>
<tr><td><code>impxxx__IMP_LIST</code></td>
<td>
<p>File with list of multiply imputed datasets</p>
</td></tr>
<tr><td><code>impxxx__IMP_SUMMARY</code></td>
<td>
<p>Summary file of the imputation</p>
</td></tr>
<tr><td><code>impxxx__IMPDATA_nn</code></td>
<td>
<p>Imputed datasets <code>nn</code></p>
</td></tr>
<tr><td><code>impxxx__IMPMETHOD</code></td>
<td>
<p>File containing imputation methods</p>
</td></tr>
<tr><td><code>impxxx__LEGENDE</code></td>
<td>
<p>File with variable names of the dataset</p>
</td></tr>
<tr><td><code>impxxx__LONG</code></td>
<td>
<p>Imputed datasets in long format</p>
</td></tr>
<tr><td><code>impxxx__PREDICTORMATRIX</code></td>
<td>
<p>File containing the predictor matrix</p>
</td></tr>
<tr><td><code>impxxx__SPSS.sps</code></td>
<td>
<p>SPSS syntax for reading the corresponding
<code>txt</code> file into SPSS format.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See also <code><a href="mice.html#topic+mids2mplus">mice::mids2mplus</a></code> and
<code><a href="mice.html#topic+mids2spss">mice::mids2spss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Imputation of nhanes data and write imputed datasets on disk
#############################################################################

data(nhanes,package="mice")

#**********
# Model 1: Imputation using mice
imp1 &lt;- mice::mice( nhanes, m=3, maxit=5 )
# write results
write.mice.imputation(mi.res=imp1, name="mice_imp1" )

#**********
# Model 2: Imputation using mice.1chain
imp2 &lt;- miceadds::mice.1chain( nhanes, burnin=10, iter=20, Nimp=4 )
# write results
write.mice.imputation(mi.res=imp2, name="mice_imp2" )

## End(Not run)
</code></pre>

<hr>
<h2 id='write.pspp'>
Writing a Data Frame into SPSS Format Using PSPP Software
</h2><span id='topic+write.pspp'></span>

<h3>Description</h3>

<p>Writes a data frame into SPSS format using the <em>PSPP</em> software.
To use this function, download and install PSPP at first:
<a href="http://www.gnu.org/software/pspp/pspp.html">http://www.gnu.org/software/pspp/pspp.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pspp(data, datafile, pspp.path, decmax=6,
   as.factors=TRUE, use.bat=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pspp_+3A_data">data</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="write.pspp_+3A_datafile">datafile</code></td>
<td>

<p>Name of the output file (without file ending)
</p>
</td></tr>
<tr><td><code id="write.pspp_+3A_pspp.path">pspp.path</code></td>
<td>

<p>Path where the PSPP executable is located, e.g.
<code>"C:/Program Files (x86)/PSPP/bin/"</code>
</p>
</td></tr>
<tr><td><code id="write.pspp_+3A_decmax">decmax</code></td>
<td>

<p>Maximum number of digits after decimal
</p>
</td></tr>
<tr><td><code id="write.pspp_+3A_as.factors">as.factors</code></td>
<td>
<p>A logical indicating whether all factors and string entries
should be treated as factors in the output file.</p>
</td></tr>
<tr><td><code id="write.pspp_+3A_use.bat">use.bat</code></td>
<td>
<p>A logical indicating whether PSPP executed via a batch file in
the DOS mode (<code>TRUE</code>) or directly invoked via the <code>system</code> command
from within <span class="rlang"><b>R</b></span> (<code>FALSE</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset in <em>sav</em> format (SPSS format).
</p>


<h3>Author(s)</h3>

<p>The code was adapted from
<a href="https://stat.ethz.ch/pipermail/r-help/2006-January/085941.html">https://stat.ethz.ch/pipermail/r-help/2006-January/085941.html</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="foreign.html#topic+write.foreign">foreign::write.foreign</a></code>.
</p>
<p>For writing sav files see also <code>haven::write_sav</code>
and  <code><a href="sjlabelled.html#topic+write_spss">sjlabelled::write_spss</a></code>.
</p>
<p>For convenient viewing <em>sav</em> files we recommend the freeware
program <em>ViewSav</em>, see <a href="http://www.asselberghs.dds.nl/stuff.htm">http://www.asselberghs.dds.nl/stuff.htm</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Write a data frame into SPSS format
#############################################################################

#****
# (1) define data frame
data &lt;- data.frame( "pid"=1000+1:5, "height"=round(rnorm( 5 ),4),
                "y"=10*c(1,1,1,2,2), "r2"=round( rnorm(5),2),
                "land"=as.factor( c( rep("A",1), rep("B", 4 ) ) ) )
#****
# (2) define variable labels
v1 &lt;- rep( "", ncol(data) )
names(v1) &lt;-  colnames(data)
attr( data, "variable.labels" ) &lt;- v1
attr(data,"variable.labels")["pid"] &lt;- "Person ID"
attr(data,"variable.labels")["height"] &lt;- "Height of a person"
attr(data,"variable.labels")["y"] &lt;- "Gender"

#****
# (3) define some value labels
v1 &lt;- c(10,20)
names(v1) &lt;- c("male", "female" )
attr( data$y, "value.labels" ) &lt;- v1

#****
# (4a) run PSPP to produce a sav file
write.pspp( data, datafile="example_data1",
        pspp.path="C:/Program Files (x86)/PSPP/bin/" )

#****
# (4b) produce strings instead of factors
write.pspp( data, datafile="example_data2",
        pspp.path="C:/Program Files (x86)/PSPP/bin/", as.factors=FALSE )

#****
# write sav file using haven package
library(haven)
haven::write_sav( data, "example_data1a.sav" )

#****
# write sav file using sjlabelled package
library(sjlabelled)
data &lt;- sjlabelled::set_label( data, attr(data, "variable.labels") )
sjlabelled::write_spss( data, "example_data1b.sav" )

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
