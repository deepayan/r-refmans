<!DOCTYPE html><html><head><title>Help for package regsem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {regsem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cv_regsem'><p>The main function that runs multiple penalty values.</p></a></li>
<li><a href='#det_range'><p>Determine the initial range for stability selection</p></a></li>
<li><a href='#det_range_par'><p>Determine the initial range for stability selection, parallel version</p></a></li>
<li><a href='#efaModel'><p>Generates an EFA model to be used by lavaan and regsem</p>
Function created by Florian Scharf for the paper
Should regularization replace simple structure rotation in
Exploratory Factor Analysis &ndash; Scharf &amp; Nestler (in press at SEM)</a></li>
<li><a href='#extractMatrices'><p>This function extracts RAM matrices from a lavaan object.</p></a></li>
<li><a href='#fit_indices'><p>Calculates the fit indices</p></a></li>
<li><a href='#multi_optim'><p>Multiple starts for Regularized Structural Equation Modeling</p></a></li>
<li><a href='#parse_parameters'><p>Takes either a vector of parameter ids or a</p>
vector of named parameters and returns a vector of parameter ids</a></li>
<li><a href='#pen_mod'><p>Penalized model syntax.</p></a></li>
<li><a href='#plot.cvregsem'><p>Plot function for cv_regsem</p></a></li>
<li><a href='#rcpp_fit_fun'><p>Calculates the objective function values.</p></a></li>
<li><a href='#rcpp_grad_ram'><p>Calculates the gradient vector based on Von Oertzen and Brick, 2014</p></a></li>
<li><a href='#rcpp_quasi_calc'><p>Compute quasi Hessian</p></a></li>
<li><a href='#rcpp_RAMmult'><p>Take RAM matrices, multiplies, and returns Implied Covariance matrix.</p></a></li>
<li><a href='#regsem'><p>Regularized Structural Equation Modeling. Tests a single penalty. For</p>
testing multiple penalties, see cv_regsem().</a></li>
<li><a href='#stabsel'><p>Stability selection</p></a></li>
<li><a href='#stabsel_par'><p>Stability selection, parallelized version</p></a></li>
<li><a href='#stabsel_thr'><p>Tuning the probability threshold.</p></a></li>
<li><a href='#summary.cvregsem'><p>print information about cvregsem object</p></a></li>
<li><a href='#summary.regsem'><p>Summary results from regsem.</p></a></li>
<li><a href='#xmed'><p>Function to performed exploratory mediation with continuous and categorical variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regularized Structural Equation Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ross Jacobucci &lt;rcjacobuc@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses both ridge and lasso penalties (and extensions) to penalize
    specific parameters in structural equation models. The package offers additional
    cost functions, cross validation, and other extensions beyond traditional structural
    equation models. Also contains a function to perform exploratory mediation (XMed). </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Rjacobucci/regsem/">https://github.com/Rjacobucci/regsem/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Rjacobucci/regsem/issues/">https://github.com/Rjacobucci/regsem/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>lavaan, Rcpp, Rsolnp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>snowfall, markdown, MASS, GA, caret, glmnet, ISLR, lbfgs,
numDeriv, psych, knitr, nloptr, NlcOptim, optimx, semPlot,
colorspace, plyr, matrixStats, stringr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-01 17:13:30 UTC; rjacobuc</td>
</tr>
<tr>
<td>Author:</td>
<td>Ross Jacobucci [aut, cre],
  Kevin Grimm [ctb],
  Andreas Brandmaier [ctb],
  Sarfaraz Serang [ctb],
  Rogier Kievit [ctb],
  Florian Scharf [ctb],
  Xiaobei Li [ctb],
  Ai Ye [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-02 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cv_regsem'>The main function that runs multiple penalty values.</h2><span id='topic+cv_regsem'></span>

<h3>Description</h3>

<p>The main function that runs multiple penalty values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_regsem(
  model,
  n.lambda = 40,
  pars_pen = "regressions",
  metric = ifelse(fit.ret2 == "train", "BIC", "chisq"),
  mult.start = FALSE,
  multi.iter = 10,
  jump = 0.01,
  lambda.start = 0,
  alpha = 0.5,
  gamma = 3.7,
  type = "lasso",
  random.alpha = 0.5,
  fit.ret = c("rmsea", "BIC", "chisq"),
  fit.ret2 = "train",
  n.boot = 20,
  data = NULL,
  optMethod = "rsolnp",
  gradFun = "ram",
  hessFun = "none",
  test.cov = NULL,
  test.n.obs = NULL,
  prerun = FALSE,
  parallel = FALSE,
  ncore = 2,
  Start = "lavaan",
  subOpt = "nlminb",
  diff_par = NULL,
  LB = -Inf,
  UB = Inf,
  par.lim = c(-Inf, Inf),
  block = TRUE,
  full = TRUE,
  calc = "normal",
  max.iter = 2000,
  tol = 1e-05,
  round = 3,
  solver = FALSE,
  quasi = FALSE,
  solver.maxit = 5,
  alpha.inc = FALSE,
  step = 0.1,
  momentum = FALSE,
  step.ratio = FALSE,
  line.search = FALSE,
  nlminb.control = list(),
  warm.start = FALSE,
  missing = "listwise",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_regsem_+3A_model">model</code></td>
<td>
<p>Lavaan output object. This is a model that was previously
run with any of the lavaan main functions: cfa(), lavaan(), sem(),
or growth(). It also can be from the efaUnrotate() function from
the semTools package. Currently, the parts of the model which cannot
be handled in regsem is the use of multiple group models, missing
other than listwise, thresholds from categorical variable models,
the use of additional estimators other than
ML, most notably WLSMV for categorical variables. Note: the model
does not have to actually run (use do.fit=FALSE), converge etc...
regsem() uses the lavaan object as more of a parser and to get
sample covariance matrix.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_n.lambda">n.lambda</code></td>
<td>
<p>number of penalization values to test.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_pars_pen">pars_pen</code></td>
<td>
<p>Parameter indicators to penalize. There are multiple ways to specify.
The default is to penalize all regression parameters (&quot;regressions&quot;). Additionally,
one can specify all loadings (&quot;loadings&quot;), or both c(&quot;regressions&quot;,&quot;loadings&quot;).
Next, parameter labels can be assigned in the lavaan syntax and passed to pars_pen.
See the example.Finally, one can take the parameter numbers from the A or S matrices and pass these
directly. See extractMatrices(lav.object)$A.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_metric">metric</code></td>
<td>
<p>Which fit index to use to choose a final model?
Note that it chooses the best fit that also achieves convergence
(conv=0).</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_mult.start">mult.start</code></td>
<td>
<p>Logical. Whether to use multi_optim() (TRUE) or
regsem() (FALSE).</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_multi.iter">multi.iter</code></td>
<td>
<p>maximum number of random starts for multi_optim</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_jump">jump</code></td>
<td>
<p>Amount to increase penalization each iteration.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_lambda.start">lambda.start</code></td>
<td>
<p>What value to start the penalty at</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_alpha">alpha</code></td>
<td>
<p>Mixture for elastic net. 1 = ridge, 0 = lasso</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_gamma">gamma</code></td>
<td>
<p>Additional penalty for MCP and SCAD</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_type">type</code></td>
<td>
<p>Penalty type. Options include &quot;none&quot;, &quot;lasso&quot;, &quot;ridge&quot;,
&quot;enet&quot; for the elastic net,
&quot;alasso&quot; for the adaptive lasso
and &quot;diff_lasso&quot;. diff_lasso penalizes the discrepency between
parameter estimates and some pre-specified values. The values
to take the deviation from are specified in diff_par. Two methods for
sparser results than lasso are the smooth clipped absolute deviation,
&quot;scad&quot;, and the minimum concave penalty, &quot;mcp&quot;. Last option is &quot;rlasso&quot;
which is the randomised lasso to be used for stability selection.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_random.alpha">random.alpha</code></td>
<td>
<p>Alpha parameter for randomised lasso. Has to be between
0 and 1, with a default of 0.5. Note this is only used for
&quot;rlasso&quot;, which pairs with stability selection.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_fit.ret">fit.ret</code></td>
<td>
<p>Fit indices to return.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_fit.ret2">fit.ret2</code></td>
<td>
<p>Return fits using only dataset &quot;train&quot; or bootstrap &quot;boot&quot;? Have to
do 2 sample CV manually.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_n.boot">n.boot</code></td>
<td>
<p>Number of bootstrap samples if fit.ret2=&quot;boot&quot;</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_data">data</code></td>
<td>
<p>Optional dataframe. Only required for missing=&quot;fiml&quot;.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_optmethod">optMethod</code></td>
<td>
<p>Solver to use. Two main options for use: rsoolnp and coord_desc.
Although slightly slower, rsolnp works much better for complex models.
coord_desc uses gradient descent with soft thresholding for the type of
of penalty. Rsolnp is a nonlinear solver that doesn't rely on gradient
information. There is a similar type of solver also available for use,
slsqp from the nloptr package. coord_desc can also be used with hessian
information, either through the use of quasi=TRUE, or specifying a hess_fun.
However, this option is not recommended at this time.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_gradfun">gradFun</code></td>
<td>
<p>Gradient function to use. Recommended to use &quot;ram&quot;,
which refers to the method specified in von Oertzen &amp; Brick (2014).
Only for use with optMethod=&quot;coord_desc&quot;.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_hessfun">hessFun</code></td>
<td>
<p>hessian function to use. Currently not recommended.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_test.cov">test.cov</code></td>
<td>
<p>Covariance matrix from test dataset. Necessary for CV=T</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_test.n.obs">test.n.obs</code></td>
<td>
<p>Number of observations in test set. Used when CV=T</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_prerun">prerun</code></td>
<td>
<p>Logical. Use rsolnp to first optimize before passing to
gradient descent? Only for use with coord_desc</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_parallel">parallel</code></td>
<td>
<p>Logical. whether to parallelize the processes running models for all
values of lambda.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_ncore">ncore</code></td>
<td>
<p>Number of cores to use when parallel=TRUE</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_start">Start</code></td>
<td>
<p>type of starting values to use.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_subopt">subOpt</code></td>
<td>
<p>type of optimization to use in the optimx package.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_diff_par">diff_par</code></td>
<td>
<p>parameter values to deviate from.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_lb">LB</code></td>
<td>
<p>lower bound vector.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_ub">UB</code></td>
<td>
<p>upper bound vector</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_par.lim">par.lim</code></td>
<td>
<p>Vector of minimum and maximum parameter estimates. Used to
stop optimization and move to new starting values if violated.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_block">block</code></td>
<td>
<p>Whether to use block coordinate descent</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_full">full</code></td>
<td>
<p>Whether to do full gradient descent or block</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_calc">calc</code></td>
<td>
<p>Type of calc function to use with means or not. Not recommended
for use.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_max.iter">max.iter</code></td>
<td>
<p>Number of iterations for coordinate descent</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_tol">tol</code></td>
<td>
<p>Tolerance for coordinate descent</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_round">round</code></td>
<td>
<p>Number of digits to round results to</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_solver">solver</code></td>
<td>
<p>Whether to use solver for coord_desc</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_quasi">quasi</code></td>
<td>
<p>Whether to use quasi-Newton</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_solver.maxit">solver.maxit</code></td>
<td>
<p>Max iterations for solver in coord_desc</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_alpha.inc">alpha.inc</code></td>
<td>
<p>Whether alpha should increase for coord_desc</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_step">step</code></td>
<td>
<p>Step size</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_momentum">momentum</code></td>
<td>
<p>Momentum for step sizes</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_step.ratio">step.ratio</code></td>
<td>
<p>Ratio of step size between A and S. Logical</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_line.search">line.search</code></td>
<td>
<p>Use line search for optimization. Default is no, use fixed step size</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_nlminb.control">nlminb.control</code></td>
<td>
<p>list of control values to pass to nlminb</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_warm.start">warm.start</code></td>
<td>
<p>Whether start values are based on previous iteration.
This is not recommended.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_missing">missing</code></td>
<td>
<p>How to handle missing data. Current options are &quot;listwise&quot;
and &quot;fiml&quot;.</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bar?</p>
</td></tr>
<tr><td><code id="cv_regsem_+3A_...">...</code></td>
<td>
<p>Any additional arguments to pass to regsem() or multi_optim().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parameters Matrix of parameter estimates across the penalties
</p>
<p>fits Fit metrics across penalties
</p>
<p>final_pars Parameter estimates from the best fitting model according to metric
</p>
<p>pars_pen Parameter indicators that were penalized.
</p>
<p>df Degrees of freedom
</p>
<p>metric The fit function used to choose a final model
</p>
<p>call
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(regsem)
# put variables on same scale for regsem
HS &lt;- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod &lt;- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS)
# increase to &gt; 25
cv.out = cv_regsem(outt,type="lasso", pars_pen=c(1:2,6:8),
          n.lambda=5,jump=0.01)
# check parameter numbers
extractMatrices(outt)["A"]
# equivalent to
mod &lt;- '
f =~ 1*x1 + l1*x2 + l2*x3 + l3*x4 + l4*x5 + l5*x6 + l6*x7 + l7*x8 + l8*x9
'
outt = cfa(mod,HS)
# increase to &gt; 25
cv.out = cv_regsem(outt, type="lasso", pars_pen=c("l1","l2","l6","l7","l8"),
         n.lambda=5,jump=0.01)
summary(cv.out)
plot(cv.out, show.minimum="BIC")

mod &lt;- '
f =~ x1 + x2 + x3 + x4 + x5 + x6
'
outt = cfa(mod, HS)
# can penalize all loadings
cv.out = cv_regsem(outt,type="lasso", pars_pen="loadings",
                  n.lambda=5,jump=0.01)

mod2 &lt;- '
f =~ x4+x5+x3
#x1 ~ x7 + x8 + x9 + x2
x1 ~ f
x2 ~ f
'
outt2 = cfa(mod2, HS)
extractMatrices(outt2)$A
# if no pars_pen specification, defaults to all
# regressions
cv.out = cv_regsem(outt2,type="lasso",
                  n.lambda=15,jump=0.03)
# check
cv.out$pars_pen

</code></pre>

<hr>
<h2 id='det_range'>Determine the initial range for stability selection</h2><span id='topic+det_range'></span>

<h3>Description</h3>

<p>This function perform regsem on bootstrap samples to determine the initial range for stability selection. Interquartile range of the bootstrap optimal regularization amounts are uesd as the final range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det_range(data, model, times = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det_range_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="det_range_+3A_model">model</code></td>
<td>
<p>lavaan output object.</p>
</td></tr>
<tr><td><code id="det_range_+3A_times">times</code></td>
<td>
<p>number of bootstrap samples used.</p>
</td></tr>
<tr><td><code id="det_range_+3A_...">...</code></td>
<td>
<p>Any additional arguments to pass to regsem() or cv_regsem().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result the lambda values and the upper bound and lower bound of the interquartile range.
</p>

<hr>
<h2 id='det_range_par'>Determine the initial range for stability selection, parallel version</h2><span id='topic+det_range_par'></span>

<h3>Description</h3>

<p>This function perform regsem on bootstrap samples to determine the initial range for stability selection. Interquartile range of the bootstrap optimal regularization amounts are uesd as the final range. Parallelization is used to achieve faster performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det_range_par(data, model, times = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det_range_par_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="det_range_par_+3A_model">model</code></td>
<td>
<p>lavaan output object.</p>
</td></tr>
<tr><td><code id="det_range_par_+3A_times">times</code></td>
<td>
<p>number of bootstrap samples used.</p>
</td></tr>
<tr><td><code id="det_range_par_+3A_...">...</code></td>
<td>
<p>Any additional arguments to pass to regsem() or cv_regsem().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result the lambda values and the upper bound and lower bound of the interquartile range.
</p>

<hr>
<h2 id='efaModel'>Generates an EFA model to be used by lavaan and regsem
Function created by Florian Scharf for the paper
Should regularization replace simple structure rotation in
Exploratory Factor Analysis &ndash; Scharf &amp; Nestler (in press at SEM)</h2><span id='topic+efaModel'></span>

<h3>Description</h3>

<p>Generates an EFA model to be used by lavaan and regsem
Function created by Florian Scharf for the paper
Should regularization replace simple structure rotation in
Exploratory Factor Analysis &ndash; Scharf &amp; Nestler (in press at SEM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efaModel(nFactors, variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efaModel_+3A_nfactors">nFactors</code></td>
<td>
<p>Number of latent factors to generate.</p>
</td></tr>
<tr><td><code id="efaModel_+3A_variables">variables</code></td>
<td>
<p>Names of variables to be used as indicators</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model Full EFA model parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
HS &lt;- data.frame(scale(HolzingerSwineford1939[,7:15]))
# Note to find number of factors, recommended to use
# fa.parallel() from the psych package
# using the wrong number of factors can distort the results
mod = efaModel(3, colnames(HS))

semFit = sem(mod, data = HS, int.ov.free = FALSE, int.lv.free = FALSE,
            std.lv = TRUE, std.ov = TRUE, auto.fix.single = FALSE, se = "none")

# note it requires smaller penalties than other applications
reg.out2 = cv_regsem(model = semFit, pars_pen = "loadings",
                    mult.start = TRUE, multi.iter = 10,
                    n.lambda = 100, type = "lasso", jump = 10^-5, lambda.start = 0.001)
reg.out2
plot(reg.out2) # note that the solution jumps around -- make sure best fit makes sense

## End(Not run)
</code></pre>

<hr>
<h2 id='extractMatrices'>This function extracts RAM matrices from a lavaan object.</h2><span id='topic+extractMatrices'></span>

<h3>Description</h3>

<p>This function extracts RAM matrices from a lavaan object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractMatrices(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractMatrices_+3A_model">model</code></td>
<td>
<p>Lavaan model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The RAM matrices from <code>model</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lavaan)
data(HolzingerSwineford1939)
HS.model &lt;- ' visual =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed =~ x7 + x8 + x9 '
mod &lt;- cfa(HS.model, data=HolzingerSwineford1939)
mats = extractMatrices(mod)
</code></pre>

<hr>
<h2 id='fit_indices'>Calculates the fit indices</h2><span id='topic+fit_indices'></span>

<h3>Description</h3>

<p>Calculates the fit indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_indices(model, CV = FALSE, CovMat = NULL, data = NULL, n.obs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_indices_+3A_model">model</code></td>
<td>
<p>regsem model object.</p>
</td></tr>
<tr><td><code id="fit_indices_+3A_cv">CV</code></td>
<td>
<p>cross-validation. Note that this requires splitting the dataset
into a training and test set prior to running the model. The
model should be run on the training set, with the test set
held out and then passed to CovMat=.</p>
</td></tr>
<tr><td><code id="fit_indices_+3A_covmat">CovMat</code></td>
<td>
<p>If CV=T then test covariance matrix must be supplied. Note
That this should be done before running the lavaan model and should
not overlap with the data or covariance matrix used to run the model.</p>
</td></tr>
<tr><td><code id="fit_indices_+3A_data">data</code></td>
<td>
<p>supply the dataset?</p>
</td></tr>
<tr><td><code id="fit_indices_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of observations in the test set for CV.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fits Full set of fit indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit_indices()

## End(Not run)
</code></pre>

<hr>
<h2 id='multi_optim'>Multiple starts for Regularized Structural Equation Modeling</h2><span id='topic+multi_optim'></span>

<h3>Description</h3>

<p>Multiple starts for Regularized Structural Equation Modeling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_optim(
  model,
  max.try = 10,
  lambda = 0,
  alpha = 0.5,
  gamma = 3.7,
  random.alpha = 0.5,
  LB = -Inf,
  UB = Inf,
  par.lim = c(-Inf, Inf),
  block = TRUE,
  full = TRUE,
  type = "lasso",
  optMethod = "rsolnp",
  gradFun = "ram",
  pars_pen = "regressions",
  diff_par = NULL,
  hessFun = "none",
  tol = 1e-05,
  round = 3,
  solver = FALSE,
  quasi = FALSE,
  solver.maxit = 50000,
  alpha.inc = FALSE,
  line.search = FALSE,
  prerun = FALSE,
  step = 0.1,
  momentum = FALSE,
  step.ratio = FALSE,
  verbose = FALSE,
  warm.start = FALSE,
  Start2 = NULL,
  nlminb.control = NULL,
  max.iter = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_optim_+3A_model">model</code></td>
<td>
<p>Lavaan output object. This is a model that was previously
run with any of the lavaan main functions: cfa(), lavaan(), sem(),
or growth(). It also can be from the efaUnrotate() function from
the semTools package. Currently, the parts of the model which cannot
be handled in regsem is the use of multiple group models, missing
other than listwise, thresholds from categorical variable models,
the use of additional estimators other than
ML, most notably WLSMV for categorical variables. Note: the model
does not have to actually run (use do.fit=FALSE), converge etc...
regsem() uses the lavaan object as more of a parser and to get
sample covariance matrix.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_max.try">max.try</code></td>
<td>
<p>number of starts to try before convergence.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_lambda">lambda</code></td>
<td>
<p>Penalty value. Note: higher values will result in additional
convergence issues.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_alpha">alpha</code></td>
<td>
<p>Mixture for elastic net.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_gamma">gamma</code></td>
<td>
<p>Additional penalty for MCP and SCAD</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_random.alpha">random.alpha</code></td>
<td>
<p>Alpha parameter for randomised lasso. Has to be between
0 and 1, with a default of 0.5. Note this is only used for
&quot;rlasso&quot;, which pairs with stability selection.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_lb">LB</code></td>
<td>
<p>lower bound vector. Note: This is very important to specify
when using regularization. It greatly increases the chances of
converging.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_ub">UB</code></td>
<td>
<p>Upper bound vector</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_par.lim">par.lim</code></td>
<td>
<p>Vector of minimum and maximum parameter estimates. Used to
stop optimization and move to new starting values if violated.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_block">block</code></td>
<td>
<p>Whether to use block coordinate descent</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_full">full</code></td>
<td>
<p>Whether to do full gradient descent or block</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_type">type</code></td>
<td>
<p>Penalty type. Options include &quot;none&quot;, &quot;lasso&quot;,
&quot;enet&quot; for the elastic net,
&quot;alasso&quot; for the adaptive lasso
and &quot;diff_lasso&quot;. If ridge penalties are desired, use type=&quot;enet&quot; and
alpha=1. diff_lasso penalizes the discrepency between
parameter estimates and some pre-specified values. The values
to take the deviation from are specified in diff_par. Two methods for
sparser results than lasso are the smooth clipped absolute deviation,
&quot;scad&quot;, and the minimum concave penalty, &quot;mcp&quot;. Last option is &quot;rlasso&quot;
which is the randomised lasso to be used for stability selection.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_optmethod">optMethod</code></td>
<td>
<p>Solver to use. Two main options for use: rsoolnp and coord_desc.
Although slightly slower, rsolnp works much better for complex models.
coord_desc uses gradient descent with soft thresholding for the type of
of penalty. Rsolnp is a nonlinear solver that doesn't rely on gradient
information. There is a similar type of solver also available for use,
slsqp from the nloptr package. coord_desc can also be used with hessian
information, either through the use of quasi=TRUE, or specifying a hess_fun.
However, this option is not recommended at this time.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_gradfun">gradFun</code></td>
<td>
<p>Gradient function to use. Recommended to use &quot;ram&quot;,
which refers to the method specified in von Oertzen &amp; Brick (2014).
Only for use with optMethod=&quot;coord_desc&quot;.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_pars_pen">pars_pen</code></td>
<td>
<p>Parameter indicators to penalize. There are multiple ways to specify.
The default is to penalize all regression parameters (&quot;regressions&quot;). Additionally,
one can specify all loadings (&quot;loadings&quot;), or both c(&quot;regressions&quot;,&quot;loadings&quot;).
Next, parameter labels can be assigned in the lavaan syntax and passed to pars_pen.
See the example.Finally, one can take the parameter numbers from the A or S matrices and pass these
directly. See extractMatrices(lav.object)$A.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_diff_par">diff_par</code></td>
<td>
<p>Parameter values to deviate from. Only used when
type=&quot;diff_lasso&quot;.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_hessfun">hessFun</code></td>
<td>
<p>Hessian function to use. Currently not recommended.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_tol">tol</code></td>
<td>
<p>Tolerance for coordinate descent</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_round">round</code></td>
<td>
<p>Number of digits to round results to</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_solver">solver</code></td>
<td>
<p>Whether to use solver for coord_desc</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_quasi">quasi</code></td>
<td>
<p>Whether to use quasi-Newton. Currently not recommended.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_solver.maxit">solver.maxit</code></td>
<td>
<p>Max iterations for solver in coord_desc</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_alpha.inc">alpha.inc</code></td>
<td>
<p>Whether alpha should increase for coord_desc</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_line.search">line.search</code></td>
<td>
<p>Use line search for optimization. Default is no, use fixed step size</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_prerun">prerun</code></td>
<td>
<p>Logical. Use rsolnp to first optimize before passing to
gradient descent? Only for use with coord_desc.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_step">step</code></td>
<td>
<p>Step size</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_momentum">momentum</code></td>
<td>
<p>Momentum for step sizes</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_step.ratio">step.ratio</code></td>
<td>
<p>Ratio of step size between A and S. Logical</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print iteration number.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_warm.start">warm.start</code></td>
<td>
<p>Whether start values are based on previous iteration.
This is not recommended.</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_start2">Start2</code></td>
<td>
<p>Provided starting values. Not required</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_nlminb.control">nlminb.control</code></td>
<td>
<p>list of control values to pass to nlminb</p>
</td></tr>
<tr><td><code id="multi_optim_+3A_max.iter">max.iter</code></td>
<td>
<p>Number of iterations for coordinate descent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fit Full set of output from regsem()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Note that this is not currently recommended. Use cv_regsem() instead
library(regsem)
# put variables on same scale for regsem
HS &lt;- data.frame(scale(HolzingerSwineford1939[ ,7:15]))
mod &lt;- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS, meanstructure=TRUE)

fit1 &lt;- multi_optim(outt, max.try=40,
                   lambda=0.1, type="lasso")


# growth model
model &lt;- ' i =~ 1*t1 + 1*t2 + 1*t3 + 1*t4
          s =~ 0*t1 + s1*t2 + s2*t3 + 3*t4 '
fit &lt;- growth(model, data=Demo.growth)
summary(fit)
fitmeasures(fit)
fit3 &lt;- multi_optim(fit, lambda=0.2, type="lasso")
summary(fit3)

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_parameters'>Takes either a vector of parameter ids or a
vector of named parameters and returns a vector of parameter ids</h2><span id='topic+parse_parameters'></span>

<h3>Description</h3>

<p>Takes either a vector of parameter ids or a
vector of named parameters and returns a vector of parameter ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_parameters(x, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_parameters_+3A_x">x</code></td>
<td>
<p>Parameter labels</p>
</td></tr>
<tr><td><code id="parse_parameters_+3A_model">model</code></td>
<td>
<p>Lavaan model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL if undefined input. Else vector of parameter ids
</p>

<hr>
<h2 id='pen_mod'>Penalized model syntax.</h2><span id='topic+pen_mod'></span>

<h3>Description</h3>

<p>This function create a lavaan model syntax with paths corresponding to paremeters penalized to 0 removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen_mod(model, nm = NULL, pars_pen = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen_mod_+3A_model">model</code></td>
<td>
<p>lavaan output object.</p>
</td></tr>
<tr><td><code id="pen_mod_+3A_nm">nm</code></td>
<td>
<p>names(regsemOutput$coefficients).</p>
</td></tr>
<tr><td><code id="pen_mod_+3A_pars_pen">pars_pen</code></td>
<td>
<p>a vector of numbers corresponding to paths to be removed (same sequence as regsemOutput$coefficients).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new.mod new model in lavaan syntax.
</p>

<hr>
<h2 id='plot.cvregsem'>Plot function for cv_regsem</h2><span id='topic+plot.cvregsem'></span>

<h3>Description</h3>

<p>Plot function for cv_regsem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvregsem'
plot(
  x,
  ...,
  pars = NULL,
  show.minimum = "BIC",
  col = NULL,
  type = "l",
  lwd = 3,
  h_line = 0,
  lty = 1,
  xlab = NULL,
  ylab = NULL,
  legend.x = NULL,
  legend.y = NULL,
  legend.cex = 1,
  legend.bg = par("bg"),
  grey.out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cvregsem_+3A_x">x</code></td>
<td>
<p>An x from cv_regsem.</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_pars">pars</code></td>
<td>
<p>Which parameters to plot</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_show.minimum">show.minimum</code></td>
<td>
<p>What fit index to use</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_col">col</code></td>
<td>
<p>A specification for the default plotting color.</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_type">type</code></td>
<td>
<p>what type of plot should be drawn. Possible types are &quot;p&quot; for points, &quot;l&quot; for lines, or &quot;b&quot; for both</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_h_line">h_line</code></td>
<td>
<p>Where to draw horizontal line</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_xlab">xlab</code></td>
<td>
<p>X axis label</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_legend.x">legend.x</code></td>
<td>
<p>x-coordinate of legend. See ?legend</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_legend.y">legend.y</code></td>
<td>
<p>y-coordinate of legend. See ?legend</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_legend.cex">legend.cex</code></td>
<td>
<p>cex of legend. See ?legend</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_legend.bg">legend.bg</code></td>
<td>
<p>legend background color. See ?legend</p>
</td></tr>
<tr><td><code id="plot.cvregsem_+3A_grey.out">grey.out</code></td>
<td>
<p>Add grey to background</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of parameter estimates across penalties
</p>

<hr>
<h2 id='rcpp_fit_fun'>Calculates the objective function values.</h2><span id='topic+rcpp_fit_fun'></span>

<h3>Description</h3>

<p>Calculates the objective function values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_fit_fun(
  ImpCov,
  SampCov,
  type2,
  lambda,
  gamma,
  pen_vec,
  pen_diff,
  e_alpha,
  rlasso_pen,
  pen_vec1,
  pen_vec2,
  dual_pen1,
  dual_pen2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_fit_fun_+3A_impcov">ImpCov</code></td>
<td>
<p>expected covariance matrix.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_sampcov">SampCov</code></td>
<td>
<p>Sample covariance matrix.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_type2">type2</code></td>
<td>
<p>penalty type.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_lambda">lambda</code></td>
<td>
<p>penalty value.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_gamma">gamma</code></td>
<td>
<p>additional penalty for mcp and scad</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_pen_vec">pen_vec</code></td>
<td>
<p>vector of penalized parameters.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_pen_diff">pen_diff</code></td>
<td>
<p>Vector of values to take deviation from.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_e_alpha">e_alpha</code></td>
<td>
<p>Alpha for elastic net</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_rlasso_pen">rlasso_pen</code></td>
<td>
<p>Alpha for rlasso2</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_pen_vec1">pen_vec1</code></td>
<td>
<p>vector of penalized parameters for lasso penalty.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_pen_vec2">pen_vec2</code></td>
<td>
<p>vector of penalized parameters for ridge penalty.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_dual_pen1">dual_pen1</code></td>
<td>
<p>vector of penalized parameters for lasso penalty.</p>
</td></tr>
<tr><td><code id="rcpp_fit_fun_+3A_dual_pen2">dual_pen2</code></td>
<td>
<p>vector of penalized parameters for ridge penalty.</p>
</td></tr>
</table>

<hr>
<h2 id='rcpp_grad_ram'>Calculates the gradient vector based on Von Oertzen and Brick, 2014</h2><span id='topic+rcpp_grad_ram'></span>

<h3>Description</h3>

<p>Calculates the gradient vector based on Von Oertzen and Brick, 2014
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_grad_ram(
  par,
  ImpCov,
  SampCov,
  Areg,
  Sreg,
  A,
  S,
  Fmat,
  lambda,
  type2,
  pen_vec,
  diff_par
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_grad_ram_+3A_par">par</code></td>
<td>
<p>vector with parameters.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_impcov">ImpCov</code></td>
<td>
<p>expected covariance matrix.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_sampcov">SampCov</code></td>
<td>
<p>Sample covariance matrix.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_areg">Areg</code></td>
<td>
<p>A matrix with current parameter estimates.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_sreg">Sreg</code></td>
<td>
<p>S matrix with current parameter estimates.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_a">A</code></td>
<td>
<p>A matrix with parameter labels.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_s">S</code></td>
<td>
<p>S matrix with parameter labels.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_fmat">Fmat</code></td>
<td>
<p>Fmat matrix.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_lambda">lambda</code></td>
<td>
<p>penalty value.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_type2">type2</code></td>
<td>
<p>penalty type.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_pen_vec">pen_vec</code></td>
<td>
<p>parameter indicators to be penalized.</p>
</td></tr>
<tr><td><code id="rcpp_grad_ram_+3A_diff_par">diff_par</code></td>
<td>
<p>parameter values to take deviations from.</p>
</td></tr>
</table>

<hr>
<h2 id='rcpp_quasi_calc'>Compute quasi Hessian</h2><span id='topic+rcpp_quasi_calc'></span>

<h3>Description</h3>

<p>Compute quasi Hessian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_quasi_calc(I, s, y, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_quasi_calc_+3A_i">I</code></td>
<td>
<p>identity matrix.</p>
</td></tr>
<tr><td><code id="rcpp_quasi_calc_+3A_s">s</code></td>
<td>
<p>s vector.</p>
</td></tr>
<tr><td><code id="rcpp_quasi_calc_+3A_y">y</code></td>
<td>
<p>y vector.</p>
</td></tr>
<tr><td><code id="rcpp_quasi_calc_+3A_h">H</code></td>
<td>
<p>previous Hessian.</p>
</td></tr>
</table>

<hr>
<h2 id='rcpp_RAMmult'>Take RAM matrices, multiplies, and returns Implied Covariance matrix.</h2><span id='topic+rcpp_RAMmult'></span>

<h3>Description</h3>

<p>Take RAM matrices, multiplies, and returns Implied Covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_RAMmult(par, A, S, S_fixed, A_fixed, A_est, S_est, Fmat, I)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_RAMmult_+3A_par">par</code></td>
<td>
<p>parameter estimates.</p>
</td></tr>
<tr><td><code id="rcpp_RAMmult_+3A_a">A</code></td>
<td>
<p>A matrix with parameter labels.</p>
</td></tr>
<tr><td><code id="rcpp_RAMmult_+3A_s">S</code></td>
<td>
<p>S matrix with parameter labels.</p>
</td></tr>
<tr><td><code id="rcpp_RAMmult_+3A_s_fixed">S_fixed</code></td>
<td>
<p>S matrix with fixed indicators.</p>
</td></tr>
<tr><td><code id="rcpp_RAMmult_+3A_a_fixed">A_fixed</code></td>
<td>
<p>A matrix with fixed indicators.</p>
</td></tr>
<tr><td><code id="rcpp_RAMmult_+3A_a_est">A_est</code></td>
<td>
<p>A matrix with parameter estimates.</p>
</td></tr>
<tr><td><code id="rcpp_RAMmult_+3A_s_est">S_est</code></td>
<td>
<p>S matrix with parameter estimates.</p>
</td></tr>
<tr><td><code id="rcpp_RAMmult_+3A_fmat">Fmat</code></td>
<td>
<p>Fmat matrix.</p>
</td></tr>
<tr><td><code id="rcpp_RAMmult_+3A_i">I</code></td>
<td>
<p>Diagonal matrix of ones.</p>
</td></tr>
</table>

<hr>
<h2 id='regsem'>Regularized Structural Equation Modeling. Tests a single penalty. For
testing multiple penalties, see cv_regsem().</h2><span id='topic+regsem'></span>

<h3>Description</h3>

<p>Regularized Structural Equation Modeling. Tests a single penalty. For
testing multiple penalties, see cv_regsem().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regsem(
  model,
  lambda = 0,
  alpha = 0.5,
  gamma = 3.7,
  type = "lasso",
  dual_pen = NULL,
  random.alpha = 0.5,
  data = NULL,
  optMethod = "rsolnp",
  estimator = "ML",
  gradFun = "none",
  hessFun = "none",
  prerun = FALSE,
  parallel = "no",
  Start = "lavaan",
  subOpt = "nlminb",
  longMod = FALSE,
  pars_pen = "regressions",
  diff_par = NULL,
  LB = -Inf,
  UB = Inf,
  par.lim = c(-Inf, Inf),
  block = TRUE,
  full = TRUE,
  calc = "normal",
  max.iter = 500,
  tol = 1e-05,
  round = 3,
  solver = FALSE,
  quasi = FALSE,
  solver.maxit = 5,
  alpha.inc = FALSE,
  line.search = FALSE,
  step = 0.1,
  momentum = FALSE,
  step.ratio = FALSE,
  nlminb.control = list(),
  missing = "listwise"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regsem_+3A_model">model</code></td>
<td>
<p>Lavaan output object. This is a model that was previously
run with any of the lavaan main functions: cfa(), lavaan(), sem(),
or growth(). It also can be from the efaUnrotate() function from
the semTools package. Currently, the parts of the model which cannot
be handled in regsem is the use of multiple group models, missing
other than listwise, thresholds from categorical variable models,
the use of additional estimators other than
ML, most notably WLSMV for categorical variables. Note: the model
does not have to actually run (use do.fit=FALSE), converge etc...
regsem() uses the lavaan object as more of a parser and to get
sample covariance matrix.</p>
</td></tr>
<tr><td><code id="regsem_+3A_lambda">lambda</code></td>
<td>
<p>Penalty value. Note: higher values will result in additional
convergence issues. If using values &gt; 0.1, it is recommended to use
mutli_optim() instead. See <code><a href="#topic+multi_optim">multi_optim</a></code> for more detail.</p>
</td></tr>
<tr><td><code id="regsem_+3A_alpha">alpha</code></td>
<td>
<p>Mixture for elastic net. 1 = ridge, 0 = lasso</p>
</td></tr>
<tr><td><code id="regsem_+3A_gamma">gamma</code></td>
<td>
<p>Additional penalty for MCP and SCAD</p>
</td></tr>
<tr><td><code id="regsem_+3A_type">type</code></td>
<td>
<p>Penalty type. Options include &quot;none&quot;, &quot;lasso&quot;,
&quot;enet&quot; for the elastic net,
&quot;alasso&quot; for the adaptive lasso
and &quot;diff_lasso&quot;. If ridge penalties are desired, use type=&quot;enet&quot; and
alpha=1. diff_lasso penalizes the discrepency between
parameter estimates and some pre-specified values. The values
to take the deviation from are specified in diff_par. Two methods for
sparser results than lasso are the smooth clipped absolute deviation,
&quot;scad&quot;, and the minimum concave penalty, &quot;mcp&quot;. Last option is &quot;rlasso&quot;
which is the randomised lasso to be used for stability selection.</p>
</td></tr>
<tr><td><code id="regsem_+3A_dual_pen">dual_pen</code></td>
<td>
<p>Two penalties to be used for type=&quot;dual&quot;, first is lasso, second ridge</p>
</td></tr>
<tr><td><code id="regsem_+3A_random.alpha">random.alpha</code></td>
<td>
<p>Alpha parameter for randomised lasso. Has to be between
0 and 1, with a default of 0.5. Note this is only used for
&quot;rlasso&quot;, which pairs with stability selection.</p>
</td></tr>
<tr><td><code id="regsem_+3A_data">data</code></td>
<td>
<p>Optional dataframe. Only required for missing=&quot;fiml&quot; which
is not currently working.</p>
</td></tr>
<tr><td><code id="regsem_+3A_optmethod">optMethod</code></td>
<td>
<p>Solver to use. Two main options for use: rsoolnp and coord_desc.
Although slightly slower, rsolnp works much better for complex models.
coord_desc uses gradient descent with soft thresholding for the type of
of penalty. Rsolnp is a nonlinear solver that doesn't rely on gradient
information. There is a similar type of solver also available for use,
slsqp from the nloptr package. coord_desc can also be used with hessian
information, either through the use of quasi=TRUE, or specifying a hess_fun.
However, this option is not recommended at this time.</p>
</td></tr>
<tr><td><code id="regsem_+3A_estimator">estimator</code></td>
<td>
<p>Whether to use maximum likelihood (ML) or unweighted least squares
(ULS) as a base estimator.</p>
</td></tr>
<tr><td><code id="regsem_+3A_gradfun">gradFun</code></td>
<td>
<p>Gradient function to use. Recommended to use &quot;ram&quot;,
which refers to the method specified in von Oertzen &amp; Brick (2014).
Only for use with optMethod=&quot;coord_desc&quot;.</p>
</td></tr>
<tr><td><code id="regsem_+3A_hessfun">hessFun</code></td>
<td>
<p>Hessian function to use. Recommended to use &quot;ram&quot;,
which refers to the method specified in von Oertzen &amp; Brick (2014).
This is currently not recommended.</p>
</td></tr>
<tr><td><code id="regsem_+3A_prerun">prerun</code></td>
<td>
<p>Logical. Use rsolnp to first optimize before passing to
gradient descent? Only for use with coord_desc.</p>
</td></tr>
<tr><td><code id="regsem_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Whether to parallelize the processes?</p>
</td></tr>
<tr><td><code id="regsem_+3A_start">Start</code></td>
<td>
<p>type of starting values to use. Only recommended to use
&quot;default&quot;. This sets factor loadings and variances to 0.5.
Start = &quot;lavaan&quot; uses the parameter estimates from the lavaan
model object. This is not recommended as it can increase the
chances in getting stuck at the previous parameter estimates.</p>
</td></tr>
<tr><td><code id="regsem_+3A_subopt">subOpt</code></td>
<td>
<p>Type of optimization to use in the optimx package.</p>
</td></tr>
<tr><td><code id="regsem_+3A_longmod">longMod</code></td>
<td>
<p>If TRUE, the model is using longitudinal data? This changes
the sample covariance used.</p>
</td></tr>
<tr><td><code id="regsem_+3A_pars_pen">pars_pen</code></td>
<td>
<p>Parameter indicators to penalize. There are multiple ways to specify.
The default is to penalize all regression parameters (&quot;regressions&quot;). Additionally,
one can specify all loadings (&quot;loadings&quot;), or both c(&quot;regressions&quot;,&quot;loadings&quot;).
Next, parameter labels can be assigned in the lavaan syntax and passed to pars_pen.
See the example.Finally, one can take the parameter numbers from the A or S matrices and pass these
directly. See extractMatrices(lav.object)$A.</p>
</td></tr>
<tr><td><code id="regsem_+3A_diff_par">diff_par</code></td>
<td>
<p>Parameter values to deviate from. Only used when
type=&quot;diff_lasso&quot;.</p>
</td></tr>
<tr><td><code id="regsem_+3A_lb">LB</code></td>
<td>
<p>lower bound vector. Note: This is very important to specify
when using regularization. It greatly increases the chances of
converging.</p>
</td></tr>
<tr><td><code id="regsem_+3A_ub">UB</code></td>
<td>
<p>Upper bound vector</p>
</td></tr>
<tr><td><code id="regsem_+3A_par.lim">par.lim</code></td>
<td>
<p>Vector of minimum and maximum parameter estimates. Used to
stop optimization and move to new starting values if violated.</p>
</td></tr>
<tr><td><code id="regsem_+3A_block">block</code></td>
<td>
<p>Whether to use block coordinate descent</p>
</td></tr>
<tr><td><code id="regsem_+3A_full">full</code></td>
<td>
<p>Whether to do full gradient descent or block</p>
</td></tr>
<tr><td><code id="regsem_+3A_calc">calc</code></td>
<td>
<p>Type of calc function to use with means or not. Not recommended
for use.</p>
</td></tr>
<tr><td><code id="regsem_+3A_max.iter">max.iter</code></td>
<td>
<p>Number of iterations for coordinate descent</p>
</td></tr>
<tr><td><code id="regsem_+3A_tol">tol</code></td>
<td>
<p>Tolerance for coordinate descent</p>
</td></tr>
<tr><td><code id="regsem_+3A_round">round</code></td>
<td>
<p>Number of digits to round results to</p>
</td></tr>
<tr><td><code id="regsem_+3A_solver">solver</code></td>
<td>
<p>Whether to use solver for coord_desc</p>
</td></tr>
<tr><td><code id="regsem_+3A_quasi">quasi</code></td>
<td>
<p>Whether to use quasi-Newton</p>
</td></tr>
<tr><td><code id="regsem_+3A_solver.maxit">solver.maxit</code></td>
<td>
<p>Max iterations for solver in coord_desc</p>
</td></tr>
<tr><td><code id="regsem_+3A_alpha.inc">alpha.inc</code></td>
<td>
<p>Whether alpha should increase for coord_desc</p>
</td></tr>
<tr><td><code id="regsem_+3A_line.search">line.search</code></td>
<td>
<p>Use line search for optimization. Default is no, use fixed step size</p>
</td></tr>
<tr><td><code id="regsem_+3A_step">step</code></td>
<td>
<p>Step size</p>
</td></tr>
<tr><td><code id="regsem_+3A_momentum">momentum</code></td>
<td>
<p>Momentum for step sizes</p>
</td></tr>
<tr><td><code id="regsem_+3A_step.ratio">step.ratio</code></td>
<td>
<p>Ratio of step size between A and S. Logical</p>
</td></tr>
<tr><td><code id="regsem_+3A_nlminb.control">nlminb.control</code></td>
<td>
<p>list of control values to pass to nlminb</p>
</td></tr>
<tr><td><code id="regsem_+3A_missing">missing</code></td>
<td>
<p>How to handle missing data. Current options are &quot;listwise&quot;
and &quot;fiml&quot;. &quot;fiml&quot; is not currently working well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out List of return values from optimization program
</p>
<p>convergence Convergence status. 0 = converged, 1 or 99 means the model did not converge.
</p>
<p>par.ret Final parameter estimates
</p>
<p>Imp_Cov Final implied covariance matrix
</p>
<p>grad Final gradient.
</p>
<p>KKT1 Were final gradient values close enough to 0.
</p>
<p>KKT2 Was the final Hessian positive definite.
</p>
<p>df Final degrees of freedom. Note that df changes with lasso
penalties.
</p>
<p>npar Final number of free parameters. Note that this can change
with lasso penalties.
</p>
<p>SampCov Sample covariance matrix.
</p>
<p>fit Final F_ml fit. Note this is the final parameter estimates
evaluated with the F_ml fit function.
</p>
<p>coefficients Final parameter estimates
</p>
<p>nvar Number of variables.
</p>
<p>N sample size.
</p>
<p>nfac Number of factors
</p>
<p>baseline.chisq Baseline chi-square.
</p>
<p>baseline.df Baseline degrees of freedom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that this is not currently recommended. Use cv_regsem() instead
library(lavaan)
# put variables on same scale for regsem
HS &lt;- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod &lt;- '
f =~ 1*x1 + l1*x2 + l2*x3 + l3*x4 + l4*x5 + l5*x6 + l6*x7 + l7*x8 + l8*x9
'
# Recommended to specify meanstructure in lavaan
outt = cfa(mod, HS, meanstructure=TRUE)

fit1 &lt;- regsem(outt, lambda=0.05, type="lasso",
  pars_pen=c("l1", "l2", "l6", "l7", "l8"))
#equivalent to pars_pen=c(1:2, 6:8)
#summary(fit1)
</code></pre>

<hr>
<h2 id='stabsel'>Stability selection</h2><span id='topic+stabsel'></span>

<h3>Description</h3>

<p>Stability selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabsel(
  data,
  model,
  det.range = FALSE,
  from,
  to,
  times = 50,
  jump = 0.01,
  detr.nlambda = 20,
  n.lambda = 40,
  n.boot = 100,
  det.thr = FALSE,
  p = 0.8,
  p.from = 0.5,
  p.to = 1,
  p.jump = 0.05,
  p.method = "aic",
  type = "lasso",
  pars_pen = "regressions",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsel_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="stabsel_+3A_model">model</code></td>
<td>
<p>lavaan syntax model.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_det.range">det.range</code></td>
<td>
<p>Whether to determine the range of penalization values for stability selection through bootstrapping. Default is FALSE, from and to arguments are then needed. If set to TRUE, then jump, times and detr.nlambda arguments will be needed.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_from">from</code></td>
<td>
<p>Minimum value of penalization values for stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_to">to</code></td>
<td>
<p>Maximum value of penalization values for stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_times">times</code></td>
<td>
<p>Number of bootstrapping sample used to determine the range. Default is 50.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_jump">jump</code></td>
<td>
<p>Amount to increase penalization each iteration. Default is 0.01</p>
</td></tr>
<tr><td><code id="stabsel_+3A_detr.nlambda">detr.nlambda</code></td>
<td>
<p>Number of penalization values to test for determining range.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_n.lambda">n.lambda</code></td>
<td>
<p>Number of penalization values to test for stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_n.boot">n.boot</code></td>
<td>
<p>Number of bootstrap samples needed for stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_det.thr">det.thr</code></td>
<td>
<p>Whether to determine the probability threshold value. Default is FALSE, p is then needed. If set to TRUE, p.from, p.to, p.method arguments will be needed.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_p">p</code></td>
<td>
<p>Probability threshold: above which selection probability is the path kept in the modle. Default value is 0.8.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_p.from">p.from</code></td>
<td>
<p>Lower bound of probability threshold to test. Default is 0.5.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_p.to">p.to</code></td>
<td>
<p>Upper bound of probability threshold to test. Default is 1.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_p.jump">p.jump</code></td>
<td>
<p>Amount to increase threshold each iteration. Default is 0.05.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_p.method">p.method</code></td>
<td>
<p>Which fit index to use to choose a final model?</p>
</td></tr>
<tr><td><code id="stabsel_+3A_type">type</code></td>
<td>
<p>Penalty type</p>
</td></tr>
<tr><td><code id="stabsel_+3A_pars_pen">pars_pen</code></td>
<td>
<p>Parameter indicators to penalize.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_...">...</code></td>
<td>
<p>Any additional arguments to pass to regsem() or cv_regsem().</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(regsem)
# put variables on same scale for regsem
HS &lt;- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod &lt;- '
f =~ 1*x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
x1 ~~ r1*x2;x1 ~~ r2*x3;x1 ~~ r3*x4;x1 ~~ r4*x5
'
outt = cfa(mod, HS)

stabsel.out = stabsel(data=HS,model=mod,det.range=TRUE,detr.nlambda=20,n.lambda=5,
                    n.boot=10,p=0.9,type="alasso", p.method="aic",
                    pars_pen=c("r1","r2","r3","r4"))
stabsel.out$selection_results


</code></pre>

<hr>
<h2 id='stabsel_par'>Stability selection, parallelized version</h2><span id='topic+stabsel_par'></span>

<h3>Description</h3>

<p>Stability selection, parallelized version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabsel_par(
  data,
  model,
  det.range = FALSE,
  from,
  to,
  times = 50,
  jump = 0.01,
  detr.nlambda = 20,
  n.lambda = 40,
  n.boot = 100,
  det.thr = FALSE,
  p = 0.8,
  p.from = 0.5,
  p.to = 1,
  p.jump = 0.05,
  p.method = "aic",
  type = "lasso",
  pars_pen = "regressions",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsel_par_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_model">model</code></td>
<td>
<p>lavaan syntax model.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_det.range">det.range</code></td>
<td>
<p>Whether to determine the range of penalization values for stability selection through bootstrapping. Default is FALSE, from and to arguments are then needed. If set to TRUE, then jump, times and detr.nlambda arguments will be needed.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_from">from</code></td>
<td>
<p>Minimum value of penalization values for stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_to">to</code></td>
<td>
<p>Maximum value of penalization values for stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_times">times</code></td>
<td>
<p>Number of bootstrapping sample used to determine the range. Default is 50.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_jump">jump</code></td>
<td>
<p>Amount to increase penalization each iteration. Default is 0.01</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_detr.nlambda">detr.nlambda</code></td>
<td>
<p>Number of penalization values to test for determing range.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_n.lambda">n.lambda</code></td>
<td>
<p>Number of penalization values to test for stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_n.boot">n.boot</code></td>
<td>
<p>Number of bootstrap samples needed for stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_det.thr">det.thr</code></td>
<td>
<p>Whether to determine the probability threshold value. Default is FALSE, p is then needed. If set to TRUE, p.from, p.to, p.method arguments will be needed.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_p">p</code></td>
<td>
<p>Probability threshold: above which selection probability is the path kept in the modle. Default value is 0.8.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_p.from">p.from</code></td>
<td>
<p>Lower bound of probability threshold to test. Default is 0.5.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_p.to">p.to</code></td>
<td>
<p>Upper bound of probability threshold to test. Default is 1.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_p.jump">p.jump</code></td>
<td>
<p>Amount to increase threshold each iteration. Default is 0.05.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_p.method">p.method</code></td>
<td>
<p>Which fit index to use to choose a final model?</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_type">type</code></td>
<td>
<p>Penalty type</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_pars_pen">pars_pen</code></td>
<td>
<p>Parameter indicators to penalize.</p>
</td></tr>
<tr><td><code id="stabsel_par_+3A_...">...</code></td>
<td>
<p>Any additional arguments to pass to regsem() or cv_regsem().</p>
</td></tr>
</table>

<hr>
<h2 id='stabsel_thr'>Tuning the probability threshold.</h2><span id='topic+stabsel_thr'></span>

<h3>Description</h3>

<p>This function tune the probability threshold parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabsel_thr(
  stabsel = NULL,
  data = NULL,
  model = NULL,
  est_model = NULL,
  prob = NULL,
  nm = NULL,
  pars.pen = NULL,
  from = 0.5,
  to = 1,
  jump = 0.01,
  method = "aic"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsel_thr_+3A_stabsel">stabsel</code></td>
<td>
<p>output object from stabsel function. If specified, data, model, est_model, prob, nm, and pars.pen parameters are not needed.</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_model">model</code></td>
<td>
<p>lavaan syntax model.</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_est_model">est_model</code></td>
<td>
<p>lavaan output object.</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_prob">prob</code></td>
<td>
<p>matrix of selection probabilities.</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_nm">nm</code></td>
<td>
<p>names(regsemOutput$coefficients).</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_pars.pen">pars.pen</code></td>
<td>
<p>a vector of numbers corresponding to paths to be removed (same sequence as regsemOutput$coefficients).</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_from">from</code></td>
<td>
<p>starting value of the threshold parameter.</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_to">to</code></td>
<td>
<p>end value of the threshold parameter.</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_jump">jump</code></td>
<td>
<p>increment of the threshold parameter.</p>
</td></tr>
<tr><td><code id="stabsel_thr_+3A_method">method</code></td>
<td>
<p>fit indices uesd to tune the parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rtn results using the optimal threshold.
</p>

<hr>
<h2 id='summary.cvregsem'>print information about cvregsem object</h2><span id='topic+summary.cvregsem'></span>

<h3>Description</h3>

<p>print information about cvregsem object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvregsem'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cvregsem_+3A_object">object</code></td>
<td>
<p>cv_regsem object</p>
</td></tr>
<tr><td><code id="summary.cvregsem_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Details regarding convergence and fit
</p>

<hr>
<h2 id='summary.regsem'>Summary results from regsem.</h2><span id='topic+summary.regsem'></span>

<h3>Description</h3>

<p>Summary results from regsem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regsem'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.regsem_+3A_object">object</code></td>
<td>
<p>An object from regsem.</p>
</td></tr>
<tr><td><code id="summary.regsem_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Details regarding convergence and fit
</p>

<hr>
<h2 id='xmed'>Function to performed exploratory mediation with continuous and categorical variables</h2><span id='topic+xmed'></span>

<h3>Description</h3>

<p>Function to performed exploratory mediation with continuous and categorical variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmed(
  data,
  iv,
  mediators,
  dv,
  covariates = NULL,
  type = "lasso",
  nfolds = 10,
  show.lambda = F,
  epsilon = 0.001,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmed_+3A_data">data</code></td>
<td>
<p>Name of the dataset</p>
</td></tr>
<tr><td><code id="xmed_+3A_iv">iv</code></td>
<td>
<p>Name (or vector of names) of independent variable(s)</p>
</td></tr>
<tr><td><code id="xmed_+3A_mediators">mediators</code></td>
<td>
<p>Name of mediators</p>
</td></tr>
<tr><td><code id="xmed_+3A_dv">dv</code></td>
<td>
<p>Name of dependent variable</p>
</td></tr>
<tr><td><code id="xmed_+3A_covariates">covariates</code></td>
<td>
<p>Name of covariates to be included in model.</p>
</td></tr>
<tr><td><code id="xmed_+3A_type">type</code></td>
<td>
<p>What type of penalty. Options include lasso, ridge, and enet.</p>
</td></tr>
<tr><td><code id="xmed_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of cross-validation folds.</p>
</td></tr>
<tr><td><code id="xmed_+3A_show.lambda">show.lambda</code></td>
<td>
<p>Displays lambda values in output</p>
</td></tr>
<tr><td><code id="xmed_+3A_epsilon">epsilon</code></td>
<td>
<p>Threshold for determining whether effect is 0 or not.</p>
</td></tr>
<tr><td><code id="xmed_+3A_seed">seed</code></td>
<td>
<p>Set seed to control CV results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients from best fitting model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example
library(ISLR)
College1 = College[which(College$Private=="Yes"),]
Data = data.frame(scale(College1[c("Grad.Rate","Accept","Outstate","Room.Board","Books","Expend")]))
Data$Grad.Rate &lt;- ifelse(Data$Grad.Rate &gt; 0,1,0)
Data$Grad.Rate &lt;- as.factor(Data$Grad.Rate)
#lavaan model with all mediators
model1 &lt;-
 ' # direct effect (c_prime)
Grad.Rate ~ c_prime*Accept
# mediators
Outstate ~ a1*Accept
Room.Board ~ a2*Accept
Books ~ a3*Accept
Expend ~ a6*Accept
Grad.Rate ~ b1*Outstate + b2*Room.Board + b3*Books + b6*Expend
# indirect effects (a*b)
a1b1 := a1*b1
a2b2 := a2*b2
a3b3 := a3*b3
a6b6 := a6*b6
# total effect (c)
c := c_prime + (a1*b1) + (a2*b2) + (a3*b3) + (a6*b6)
'
#p-value approach using delta method standard errors
fit.delta = sem(model1,data=Data,fixed.x=TRUE,ordered="Grad.Rate")
summary(fit.delta)

#xmed()

iv &lt;- "Accept"
dv &lt;- "Grad.Rate"
mediators &lt;- c("Outstate","Room.Board","Books","Expend")

out &lt;- xmed(Data,iv,mediators,dv)
out

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
