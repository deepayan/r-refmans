<!DOCTYPE html><html><head><title>Help for package dtts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dtts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align'><p>Align a <code>data.table</code> onto a <code>nanotime</code> vector</p></a></li>
<li><a href='#align_idx'><p>Get the index of the alignment of one vector onto another</p></a></li>
<li><a href='#frequency+2Cdata.table-method'><p>Return the number of observations per interval</p></a></li>
<li><a href='#grid_align'><p>Align a <code>data.table</code> onto a <code>nanotime</code> vector grid</p></a></li>
<li><a href='#ops'><p>Arithmetic operations on two <code>data.table</code> time-series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'data.table' Time-Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Dirk Eddelbuettel and Leonardo Silvestri</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Eddelbuettel &lt;edd@debian.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>High-frequency time-series support via 'nanotime' and 'data.table'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>nanotime, data.table (&ge; 1.5.0), methods, bit64, Rcpp (&ge;
0.11.5), RcppCCTZ (&ge; 0.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppCCTZ, RcppDate, nanotime</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eddelbuettel/dtts/issues">https://github.com/eddelbuettel/dtts/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 15:57:58 UTC; edd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='align'>Align a <code>data.table</code> onto a <code>nanotime</code> vector</h2><span id='topic+align'></span><span id='topic+align+2Cdata.table+2Cnanotime+2Cnanoduration+2Cnanoduration-method'></span><span id='topic+align+2Cdata.table+2Cnanotime+2Cmissing+2Cmissing-method'></span><span id='topic+align+2Cdata.table+2Cnanotime+2Cnanoduration+2Cmissing-method'></span><span id='topic+align+2Cdata.table+2Cnanotime+2Cmissing+2Cnanoduration-method'></span><span id='topic+align+2Cdata.table+2Cnanotime+2Cnanoperiod+2Cnanoperiod-method'></span><span id='topic+align+2Cdata.table+2Cnanotime+2Cnanoperiod+2Cmissing-method'></span><span id='topic+align+2Cdata.table+2Cnanotime+2Cmissing+2Cnanoperiod-method'></span>

<h3>Description</h3>

<p><code>align</code> returns the subset of <code>data.table</code> <code>x</code> that
aligns on the temporal vector <code>y</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align(x, y, start, end, ...)

## S4 method for signature 'data.table,nanotime,nanoduration,nanoduration'
align(
  x,
  y,
  start = as.nanoduration(0),
  end = as.nanoduration(0),
  sopen = FALSE,
  eopen = TRUE,
  func = NULL
)

## S4 method for signature 'data.table,nanotime,missing,missing'
align(
  x,
  y,
  start = as.nanoduration(0),
  end = as.nanoduration(0),
  sopen = FALSE,
  eopen = TRUE,
  func = NULL
)

## S4 method for signature 'data.table,nanotime,nanoduration,missing'
align(
  x,
  y,
  start = as.nanoduration(0),
  end = as.nanoduration(0),
  sopen = FALSE,
  eopen = TRUE,
  func = NULL
)

## S4 method for signature 'data.table,nanotime,missing,nanoduration'
align(
  x,
  y,
  start = as.nanoduration(0),
  end = as.nanoduration(0),
  sopen = FALSE,
  eopen = TRUE,
  func = NULL
)

## S4 method for signature 'data.table,nanotime,nanoperiod,nanoperiod'
align(
  x,
  y,
  start = as.nanoperiod(0),
  end = as.nanoperiod(0),
  sopen = FALSE,
  eopen = TRUE,
  tz,
  func = NULL
)

## S4 method for signature 'data.table,nanotime,nanoperiod,missing'
align(
  x,
  y,
  start = as.nanoperiod(0),
  end = as.nanoperiod(0),
  sopen = FALSE,
  eopen = TRUE,
  tz,
  func = NULL
)

## S4 method for signature 'data.table,nanotime,missing,nanoperiod'
align(
  x,
  y,
  start = as.nanoperiod(0),
  end = as.nanoperiod(0),
  sopen = FALSE,
  eopen = TRUE,
  tz,
  func = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_+3A_x">x</code></td>
<td>
<p>the <code>data.table</code> time-series to align from</p>
</td></tr>
<tr><td><code id="align_+3A_y">y</code></td>
<td>
<p>the <code>nanotime</code> vector to align to</p>
</td></tr>
<tr><td><code id="align_+3A_start">start</code></td>
<td>
<p>scalar or vector of same length as <code>y</code> of type
<code>integer64</code>; <code>start</code> is added to each element in
<code>y</code> and it then defines the starting point of the
interval under consideration for the alignment on that
element of <code>y</code></p>
</td></tr>
<tr><td><code id="align_+3A_end">end</code></td>
<td>
<p>scalar or vector of same length as <code>y</code> of type
<code>integer64</code>; <code>start</code> is added to each element in
<code>y</code> and it then defines the ending point of the interval
under consideration for the alignment on that element of
<code>y</code></p>
</td></tr>
<tr><td><code id="align_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
<tr><td><code id="align_+3A_sopen">sopen</code></td>
<td>
<p>boolean scalar or vector of same lengths as <code>y</code>
that indicates if the start of the interval is open or
closed. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="align_+3A_eopen">eopen</code></td>
<td>
<p>boolean scalar or vector of same lengths as <code>y</code>
that indicates if the end of the interval is open or
closed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="align_+3A_func">func</code></td>
<td>
<p>a function taking one argument and which provides an
arbitrary aggregation of its argument; if <code>NULL</code> then a
function which takes the closest observation is used.</p>
</td></tr>
<tr><td><code id="align_+3A_tz">tz</code></td>
<td>
<p>scalar or vector of same length as <code>y</code> of type
character. Only used when the type of <code>start</code> and
<code>end</code> is <code>nanoperiod</code>. It defines the time zone for
the definition of the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each element in <code>y</code>, intervals are created around this
element with <code>start</code> and <code>end</code>. All the elements of
<code>x</code> that fall within this interval are given as argument to
the function <code>func</code>. The function <code>func</code> show reduce
this <code>data.frame</code> to one unique row that will be associated
with the <code>nanotime</code> value in <code>y</code>.
</p>


<h3>Value</h3>

<p>a <code>data.table</code> time-series of the same length as
<code>y</code>; this is a subset of <code>x</code> with the
<code>nanotime</code> index of <code>y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
y &lt;- nanotime((1:10)*1e9)
x &lt;- data.table(index=nanotime((1:10)*1e9), data=1:10)
align(x, y, as.nanoduration(-1e9), as.nanoduration(1e9), colMeans)

## End(Not run)


</code></pre>

<hr>
<h2 id='align_idx'>Get the index of the alignment of one vector onto another</h2><span id='topic+align_idx'></span><span id='topic+align_idx+2Cnanotime+2Cnanotime+2Cnanoduration+2Cnanoduration-method'></span><span id='topic+align_idx+2Cnanotime+2Cnanotime+2Cmissing+2Cmissing-method'></span><span id='topic+align_idx+2Cnanotime+2Cnanotime+2Cmissing+2Cnanoduration-method'></span><span id='topic+align_idx+2Cnanotime+2Cnanotime+2Cnanoduration+2Cmissing-method'></span><span id='topic+align_idx+2Cnanotime+2Cnanotime+2Cnanoperiod+2Cnanoperiod-method'></span><span id='topic+align_idx+2Cnanotime+2Cnanotime+2Cmissing+2Cnanoperiod-method'></span><span id='topic+align_idx+2Cnanotime+2Cnanotime+2Cnanoperiod+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>align_idx</code> returns the index of the alignment of <code>x</code> on <code>y</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_idx(x, y, start, end, ...)

## S4 method for signature 'nanotime,nanotime,nanoduration,nanoduration'
align_idx(
  x,
  y,
  start,
  end,
  sopen = FALSE,
  eopen = TRUE,
  bypass_x_check = FALSE,
  bypass_y_check = FALSE
)

## S4 method for signature 'nanotime,nanotime,missing,missing'
align_idx(
  x,
  y,
  start,
  end,
  sopen = FALSE,
  eopen = TRUE,
  bypass_x_check = FALSE,
  bypass_y_check = FALSE
)

## S4 method for signature 'nanotime,nanotime,missing,nanoduration'
align_idx(
  x,
  y,
  start,
  end,
  sopen = FALSE,
  eopen = TRUE,
  bypass_x_check = FALSE,
  bypass_y_check = FALSE
)

## S4 method for signature 'nanotime,nanotime,nanoduration,missing'
align_idx(
  x,
  y,
  start,
  end,
  sopen = FALSE,
  eopen = TRUE,
  bypass_x_check = FALSE,
  bypass_y_check = FALSE
)

## S4 method for signature 'nanotime,nanotime,nanoperiod,nanoperiod'
align_idx(
  x,
  y,
  start = as.nanoperiod(0),
  end = as.nanoperiod(0),
  sopen = FALSE,
  eopen = TRUE,
  tz,
  bypass_x_check = FALSE,
  bypass_y_check = FALSE
)

## S4 method for signature 'nanotime,nanotime,missing,nanoperiod'
align_idx(
  x,
  y,
  start = as.nanoperiod(0),
  end = as.nanoperiod(0),
  sopen = FALSE,
  eopen = TRUE,
  tz,
  bypass_x_check = FALSE,
  bypass_y_check = FALSE
)

## S4 method for signature 'nanotime,nanotime,nanoperiod,missing'
align_idx(
  x,
  y,
  start = as.nanoperiod(0),
  end = as.nanoperiod(0),
  sopen = FALSE,
  eopen = TRUE,
  tz,
  bypass_x_check = FALSE,
  bypass_y_check = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_idx_+3A_x">x</code></td>
<td>
<p>the <code>nanotime</code> vector to align from</p>
</td></tr>
<tr><td><code id="align_idx_+3A_y">y</code></td>
<td>
<p>the <code>nanotime</code> vector to align to</p>
</td></tr>
<tr><td><code id="align_idx_+3A_start">start</code></td>
<td>
<p>scalar or vector of same length as <code>y</code> of type
<code>nanoduration</code> or <code>nanoperiod</code>; <code>start</code> is
added to each element in <code>y</code> and it then defines the
starting point of the interval under consideration for the
alignment on that element of <code>y</code></p>
</td></tr>
<tr><td><code id="align_idx_+3A_end">end</code></td>
<td>
<p>scalar or vector of same length as <code>y</code> of type
<code>nanoduration</code> or <code>nanoperiod</code>; <code>start</code> is
added to each element in <code>y</code> and it then defines the
ending point of the interval under consideration for the
alignment on that element of <code>y</code></p>
</td></tr>
<tr><td><code id="align_idx_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
<tr><td><code id="align_idx_+3A_sopen">sopen</code></td>
<td>
<p>boolean scalar or vector of same lengths as <code>y</code>
that indicates if the start of the interval is open or
closed. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="align_idx_+3A_eopen">eopen</code></td>
<td>
<p>boolean scalar or vector of same lengths as <code>y</code>
that indicates if the end of the interval is open or
closed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="align_idx_+3A_bypass_x_check">bypass_x_check</code></td>
<td>
<p>logical indicating if the sorting of
<code>x</code> should be bypassed. This can provide a marginal
speedup, but should be used carefully.</p>
</td></tr>
<tr><td><code id="align_idx_+3A_bypass_y_check">bypass_y_check</code></td>
<td>
<p>logical indicating if the sorting of
<code>y</code> should be bypassed. This can provide a marginal
speedup, but should be used carefully.</p>
</td></tr>
<tr><td><code id="align_idx_+3A_tz">tz</code></td>
<td>
<p>scalar or vector of same length as <code>y</code> of type
character. Only used when the type of <code>start</code> and
<code>end</code> is <code>nanoperiod</code>. It defines the time zone for
the definition of the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to perform the alignment, intervals are created around
each elements in <code>y</code> using <code>start</code> and <code>end</code>. For
each such interval, the closest element in <code>x</code> is chosen. If
no element in <code>x</code> falls in the interval, then NaN is
returned.
</p>
<p>When only <code>x</code> and <code>y</code> are specified, the
default is to close the intervals so that the alignment simply
picks up equal points. Note that it is possible to specify
meaningless intervals, for instance with a <code>start</code> that
is beyond <code>end</code>. In this case, the alignment will simply
return NA for each element in <code>y</code>. In principle, the
<code>start</code> and <code>end</code> are chosen to define an interval
is the past, or around the points in <code>y</code>, but if they are
both positive, they can define intervals in the future.
</p>


<h3>Value</h3>

<p>a vector of indices of the same length as <code>y</code>; this
vector indexes into <code>x</code> and represent the closest point
of <code>x</code> that is in the interval defined around each point
in <code>y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
align_idx(nanotime(c(10:14, 17:19)), nanotime(11:20))
## [1]  2  3  4  5  NA NA  6  7  8  NA

## End(Not run)
</code></pre>

<hr>
<h2 id='frequency+2Cdata.table-method'>Return the number of observations per interval</h2><span id='topic+frequency+2Cdata.table-method'></span>

<h3>Description</h3>

<p><code>frequency</code> returns the number of observations in
<code>data.table</code> <code>x</code> for each interval specified by
<code>by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.table'
frequency(
  x,
  by,
  grid_start,
  grid_end,
  tz,
  ival_start = -by,
  ival_end,
  ival_sopen = FALSE,
  ival_eopen = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_x">x</code></td>
<td>
<p>the <code>data.table</code> time-series for which to calculate
the frequency</p>
</td></tr>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_by">by</code></td>
<td>
<p>interval specified as a <code>nanoduration</code> or
<code>nanoperiod</code>.</p>
</td></tr>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_grid_start">grid_start</code></td>
<td>
<p>scalar <code>nanotime</code> defining the start of the
grid; by default the first element of <code>x</code> is taken.</p>
</td></tr>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_grid_end">grid_end</code></td>
<td>
<p>scalar <code>nanotime</code> defining the end of the
grid; by default the last element of <code>x</code> is taken.</p>
</td></tr>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_tz">tz</code></td>
<td>
<p>scalar of type character. Only used when the type of
<code>by</code> and <code>end</code> is <code>nanoperiod</code>. It defines the
time zone for the definition of the interval.</p>
</td></tr>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_ival_start">ival_start</code></td>
<td>
<p>scalar of type <code>nanoduration</code> or
<code>nanoperiod</code>; <code>ival_start</code> is added to each element
of the grid and it then defines the starting point of the
interval under consideration for the alignment onto that
element. This defaults to -<code>by</code> and most likely does not
need to be overriden.</p>
</td></tr>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_ival_end">ival_end</code></td>
<td>
<p>scalar of type <code>nanoduration</code> or
<code>nanoperiod</code>; <code>ival_end</code> is added to each element of
the grid and it then defines the ending point of the interval
under consideration for the alignment onto that element. This
defaults to 0 and most likely does not need to be overriden.</p>
</td></tr>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_ival_sopen">ival_sopen</code></td>
<td>
<p>boolean scalar that indicates if the start of
the interval is open or closed. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="frequency+2B2Cdata.table-method_+3A_ival_eopen">ival_eopen</code></td>
<td>
<p>boolean scalar that indicates if the end of the
interval is open or closed. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code> time-series with the number of
observations in <code>x</code> that fall withing the intervals
defined by the grid interval defined by <code>by</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
one_second &lt;- as.nanoduration("00:00:01")
one_minute &lt;- 60 * one_second
x &lt;- data.table(index=nanotime((1:100) * one_second), 1)
setkey(x, index)
frequency(x, one_minute)

## End(Not run)
</code></pre>

<hr>
<h2 id='grid_align'>Align a <code>data.table</code> onto a <code>nanotime</code> vector grid</h2><span id='topic+grid_align'></span><span id='topic+grid_align+2Cdata.table+2Cnanoduration-method'></span><span id='topic+grid_align+2Cdata.table+2Cnanoperiod-method'></span>

<h3>Description</h3>

<p><code>grid_align</code> returns the subset of <code>data.table</code> <code>x</code>
that aligns on the grid defined by <code>by</code>, <code>start</code> and
<code>end</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_align(x, by, ...)

## S4 method for signature 'data.table,nanoduration'
grid_align(
  x,
  by,
  func = NULL,
  grid_start = x[[1]][1] + by,
  grid_end = tail(x[[1]], 1),
  ival_start = -by,
  ival_end = as.nanoduration(0),
  ival_sopen = FALSE,
  ival_eopen = TRUE
)

## S4 method for signature 'data.table,nanoperiod'
grid_align(
  x,
  by,
  func = NULL,
  grid_start = plus(x[[1]][1], by, tz),
  grid_end = tail(x[[1]], 1),
  ival_start = -by,
  ival_end = as.nanoperiod(0),
  ival_sopen = FALSE,
  ival_eopen = TRUE,
  tz
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_align_+3A_x">x</code></td>
<td>
<p>the <code>data.table</code> time-series to align from</p>
</td></tr>
<tr><td><code id="grid_align_+3A_by">by</code></td>
<td>
<p>interval specified as a <code>nanoduration</code> or
<code>nanoperiod</code>.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_func">func</code></td>
<td>
<p>a function taking one argument and which provides an
arbitrary aggregation of its argument; if <code>NULL</code> then a
function which takes the closest observation is used.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_grid_start">grid_start</code></td>
<td>
<p>scalar <code>nanotime</code> defining the start of the
grid; by default the first element of <code>x</code> is taken.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_grid_end">grid_end</code></td>
<td>
<p>scalar <code>nanotime</code> defining the end of the grid; by
default the last element of <code>x</code> is taken.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_ival_start">ival_start</code></td>
<td>
<p>scalar of type <code>nanoduration</code> or
<code>nanoperiod</code>; <code>ival_start</code> is added to each element
of the grid and it then defines the starting point of the
interval under consideration for the alignment onto that
element.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_ival_end">ival_end</code></td>
<td>
<p>scalar of type <code>nanoduration</code> or
<code>nanoperiod</code>; <code>ival_end</code> is added to each element of
the grid and it then defines the ending point of the interval
under consideration for the alignment onto that element.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_ival_sopen">ival_sopen</code></td>
<td>
<p>boolean scalar that indicates if the start of
the interval is open or closed. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_ival_eopen">ival_eopen</code></td>
<td>
<p>boolean scalar that indicates if the end of the
interval is open or closed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="grid_align_+3A_tz">tz</code></td>
<td>
<p>scalar of type character. Only used when the type of
<code>by</code> and <code>end</code> is <code>nanoperiod</code>. It defines the
time zone for the definition of the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grid defined by the parameter <code>by</code>, <code>start</code> and
<code>end</code> is created. The function then does a standard alignment
of <code>x</code> onto this grid (see the <code>align</code> function)
</p>


<h3>Value</h3>

<p>a <code>data.table</code> time-series of the same length as
<code>y</code> with the aggregations computed by <code>func</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
one_second &lt;- 1e9
x &lt;- data.table(index=nanotime(cumsum(sin(seq(0.001, pi, 0.001)) * one_second)))
x &lt;- x[, V2 := 1:nrow(x)]
setkey(x, index)
grid_align(x, as.nanoduration("00:01:00"), sum)

## End(Not run)
</code></pre>

<hr>
<h2 id='ops'>Arithmetic operations on two <code>data.table</code> time-series</h2><span id='topic+ops'></span><span id='topic+ops+2Cdata.table+2Cdata.table+2Ccharacter-method'></span>

<h3>Description</h3>

<p><code>ops</code> returns the <code>y</code> time-series on which the <code>x</code>
time-series values are applied using the specified operator
<code>op</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ops(x, y, op_string)

## S4 method for signature 'data.table,data.table,character'
ops(x, y, op_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ops_+3A_x">x</code></td>
<td>
<p>the <code>data.table</code> time-series that determines the
left operand</p>
</td></tr>
<tr><td><code id="ops_+3A_y">y</code></td>
<td>
<p>the <code>data.table</code> time-series that determines the
right operand <code>nanoperiod</code>.</p>
</td></tr>
<tr><td><code id="ops_+3A_op_string">op_string</code></td>
<td>
<p>string defining the operation to apply; the
supported values for <code>op</code> are &quot;*&quot;, &quot;/&quot;, &quot;+&quot;, &quot;-&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The n elements of the <code>x</code> time-series operand define a set of
n-1 intervals, and the value associated with each interval is
applied to all the observations in the <code>y</code> time-series
operand that fall in the interval. Note that the interval is
closed at the beginning and open at the end. The supported values
for <code>op</code> are &quot;*&quot;, &quot;/&quot;, &quot;+&quot;, &quot;-&quot;.
</p>
<p>There has to be one numeric column in <code>x</code> and <code>y</code>; there
has to be either a one to one correspondance between the number of
numeric columns in <code>x</code> and <code>y</code>, or there must be only
one numeric column in <code>x</code> that will be applied to all numeric
columns in <code>y</code>. Non-numeric columns must not appear in
<code>x</code>, whereas they will be skipped of they appear in <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
one_second_duration  &lt;- as.nanoduration("00:00:01")
t1 &lt;- nanotime(1:2 * one_second_duration * 3)
t2 &lt;- nanotime(1:4 * one_second_duration)
dt1 &lt;- data.table(index=t1, data1 = 1:length(t1))
setkey(dt1, index)
dt2 &lt;- data.table(index=t2, data1 = 1:length(t2))
setkey(dt2, index)
ops(dt1, dt2, "+")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
