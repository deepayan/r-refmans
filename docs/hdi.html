<!DOCTYPE html><html lang="en"><head><title>Help for package hdi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hdi-package'><p>hdi</p></a></li>
<li><a href='#boot.lasso.proj'><p>P-values based on the bootstrapped lasso projection method</p></a></li>
<li><a href='#clusterGroupBound'><p>Hierarchical structure group tests in linear model</p></a></li>
<li><a href='#fdr.adjust'><p>Function to calculate FDR adjusted p-values</p></a></li>
<li><a href='#glm.pval'><p>Function to calculate p-values for a generalized linear model.</p></a></li>
<li><a href='#groupBound'><p>Lower bound on the l1-norm of groups of regression variables</p></a></li>
<li><a href='#hdi'><p>Function to perform inference in high-dimensional (generalized) linear models</p></a></li>
<li><a href='#lasso.cv'><p>Select Predictors via (10-fold) Cross-Validation of the Lasso</p></a></li>
<li><a href='#lasso.firstq'><p>Determine the first q Predictors in the Lasso Path</p></a></li>
<li><a href='#lasso.proj'><p>P-values based on lasso projection method</p></a></li>
<li><a href='#lm.ci'><p>Function to calculate confidence intervals for ordinary multiple</p>
linear regression.</a></li>
<li><a href='#lm.pval'><p>Function to calculate p-values for ordinary multiple linear regression.</p></a></li>
<li><a href='#multi.split'><p>Calculate P-values Based on Multi-Splitting Approach</p></a></li>
<li><a href='#plot.clusterGroupBound'><p>Plot output of hierarchical testing of groups of variables</p></a></li>
<li><a href='#riboflavin'><p>Riboflavin data set</p></a></li>
<li><a href='#ridge.proj'><p>P-values based on ridge projection method</p></a></li>
<li><a href='#rXb'><p>Generate Data Design Matrix <code class="reqn">X</code> and Coefficient Vector <code class="reqn">\beta</code></p></a></li>
<li><a href='#stability'><p>Function to perform stability selection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High-Dimensional Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Lukas Meier [aut, cre], Ruben Dezeure [aut], Nicolai Meinshausen [aut], Martin Maechler [aut], Peter Buehlmann [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lukas Meier &lt;meier@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of multiple approaches to perform inference in high-dimensional models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>scalreg</td>
</tr>
<tr>
<td>DependsNote:</td>
<td>scalreg does not correctly import lars etc, so we need to
depend on it</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, parallel, MASS, glmnet, linprog</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix</td>
</tr>
<tr>
<td>SuggestsNote:</td>
<td>for tests only</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-27 12:25:06 UTC; meierluk</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-27 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hdi-package'>hdi</h2><span id='topic+hdi-package'></span>

<h3>Description</h3>

<p>Implementation of multiple approaches to perform inference in high-dimensional models.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hdi</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> High-Dimensional Inference</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1-9</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-05-27</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Lukas Meier [aut, cre], Ruben Dezeure [aut], Nicolai Meinshausen [aut], Martin Maechler [aut], Peter Buehlmann [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Lukas Meier &lt;meier@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implementation of multiple approaches to perform inference in high-dimensional models.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> scalreg</td>
</tr>
<tr>
 <td style="text-align: left;">
DependsNote: </td><td style="text-align: left;"> scalreg does not correctly import lars etc, so we need to depend on it</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> grDevices, graphics, stats, parallel, MASS, glmnet, linprog</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> Matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
SuggestsNote: </td><td style="text-align: left;"> for tests only</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
boot.lasso.proj         P-values based on the bootstrapped lasso
                        projection method
clusterGroupBound       Hierarchical structure group tests in linear
                        model
fdr.adjust              Function to calculate FDR adjusted p-values
glm.pval                Function to calculate p-values for a
                        generalized linear model.
groupBound              Lower bound on the l1-norm of groups of
                        regression variables
hdi                     Function to perform inference in
                        high-dimensional (generalized) linear models
hdi-package             hdi
lasso.cv                Select Predictors via (10-fold)
                        Cross-Validation of the Lasso
lasso.firstq            Determine the first q Predictors in the Lasso
                        Path
lasso.proj              P-values based on lasso projection method
lm.ci                   Function to calculate confidence intervals for
                        ordinary multiple linear regression.
lm.pval                 Function to calculate p-values for ordinary
                        multiple linear regression.
multi.split             Calculate P-values Based on Multi-Splitting
                        Approach
plot.clusterGroupBound
                        Plot output of hierarchical testing of groups
                        of variables
rXb                     Generate Data Design Matrix X and Coefficient
                        Vector beta
riboflavin              Riboflavin data set
ridge.proj              P-values based on ridge projection method
stability               Function to perform stability selection
</pre>


<h3>Author(s)</h3>

<p>Lukas Meier,
Ruben Dezeure,
Nicolai Meinshausen,
Martin Mächler,
Peter Bühlmann,
Maintainer: Lukas Meier &lt;meier@stat.math.ethz.ch&gt;
</p>


<h3>References</h3>

<p>Dezeure, R., Bühlmann, P., Meier, L. and Meinshausen, N. (2015)
High-dimensional inference: confidence intervals, p-values and
R-software hdi.
<em>Statistical Science</em> <b>30</b>, 533&ndash;558. 
</p>
<p>Meinshausen, N., Meier, L. and Bühlmann, P. (2009)
P-values for high-dimensional regression.
<em>Journal of the American Statistical Association</em> <b>104</b>, 1671&ndash;1681.
</p>
<p>Meinshausen, N. (2015)
Group-bound: confidence intervals for groups of variables in sparse
high-dimensional regression without assumptions on the design.
<em>Journal of the Royal Statistical Society: Series B</em>,
<b>77</b>(5), 923&ndash;945. 
</p>
<p>Meinshausen, N. and Bühlmann, P. (2010)
Stability selection (with discussion).
<em>Journal of the Royal Statistical Society: Series B</em> <b>72</b>, 417&ndash;473.
</p>

<hr>
<h2 id='boot.lasso.proj'>P-values based on the bootstrapped lasso projection method</h2><span id='topic+boot.lasso.proj'></span>

<h3>Description</h3>

<p>Compute p-values based on the lasso projection method, also known as
the de-sparsified Lasso, using the bootstrap to approximate the
distribution of the estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.lasso.proj(x, y, family = "gaussian", standardize = TRUE,
                multiplecorr.method = "WY",
                parallel = FALSE, ncores = getOption("mc.cores", 2L),
                betainit = "cv lasso", sigma = NULL, Z = NULL, verbose = FALSE,
                return.Z = FALSE, robust= FALSE,
                B = 1000, boot.shortcut = FALSE,
                return.bootdist = FALSE, wild = FALSE,
                gaussian.stub = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.lasso.proj_+3A_x">x</code></td>
<td>
<p>Design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_family">family</code></td>
<td>
<p>family</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_standardize">standardize</code></td>
<td>
<p>Should design matrix be standardized to unit column
standard deviation.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_multiplecorr.method">multiplecorr.method</code></td>
<td>
<p>Either &quot;WY&quot; or any of
<code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code>.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_parallel">parallel</code></td>
<td>
<p>Should parallelization be used? (logical)</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_betainit">betainit</code></td>
<td>
<p>Either a numeric vector, corresponding to a sparse
estimate of the coefficient vector, or the method to be used for the
initial estimation, &quot;scaled lasso&quot; or &quot;cv lasso&quot;.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_sigma">sigma</code></td>
<td>
<p>Estimate of the standard deviation of the error term. This
estimate needs to be compatible with the initial
estimate (see betainit) provided or calculated. Otherwise, results
will not be correct.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_z">Z</code></td>
<td>
<p>user input, also see <code>return.Z</code> below</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_verbose">verbose</code></td>
<td>
<p>A boolean to enable reporting on the progress of the
computations. (Only prints out information when Z is not provided by
the user)</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_return.z">return.Z</code></td>
<td>
<p>An option to return the intermediate result which only
depends on the design matrix x. This intermediate results
can be used when calling the function again and the design matrix
is the same as before.</p>
</td></tr>



<tr><td><code id="boot.lasso.proj_+3A_robust">robust</code></td>
<td>
<p>Uses a robust variance estimation procedure to be able
to deal with model misspecification.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_b">B</code></td>
<td>
<p>The number of bootstrap samples to be used.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_boot.shortcut">boot.shortcut</code></td>
<td>
<p>A boolean to enable the computational shortcut
for the bootstrap. If set to true, the lasso is not re-tuned for
each bootstrap iteration, but it uses the tuning parameter computed
on the original data instead.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_return.bootdist">return.bootdist</code></td>
<td>
<p>A boolean specifying if one is to return the
computed bootstrap distributions to the estimator. (Matrix size:
ncol(x)*B) If the multiple testing method was chosen to be WY, the
bootstrap distribution computer under the complete null hypothesis
is returned as well. This option is required if one wants to compute
confidence intervals afterwards.</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_wild">wild</code></td>
<td>
<p>Perform the wild bootstrap based on N(0,1) distributed
random variables</p>
</td></tr>
<tr><td><code id="boot.lasso.proj_+3A_gaussian.stub">gaussian.stub</code></td>
<td>
<p>DEVELOPER OPTION. Only enable if you know what
you are doing.
A boolean to run stub code instead of actually bootstrapping the
estimator. It generates a finite sample distribution for each
estimate by sampling B samples from
N(0,\hat{s.e.}_j^2). (Note: we do not sample from the multivariate
gaussian with the covariance matrix. Therefore, no dependencies are 
modelled at all.) Useful for debugging and for checking if the 
bootstrap is way off for some reason.</p>
</td></tr> 
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pval</code></td>
<td>
<p>Individual p-values for each parameter.</p>
</td></tr>
<tr><td><code>pval.corr</code></td>
<td>
<p>Multiple testing corrected p-values for each
parameter.</p>
</td></tr>









<tr><td><code>sigmahat</code></td>
<td>
<p><code class="reqn">\widehat{\sigma}</code> coming from the scaled lasso.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>Only different from NULL if the option return.Z is on. This
is an intermediate result from the computation which only depends on
the design matrix x. These are the residuals of the nodewise
regressions.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The number of bootstrap samples used.</p>
</td></tr>
<tr><td><code>boot.shortcut</code></td>
<td>
<p>If the bootstrap shortcut has been used or not.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>What tuning parameter was used for the bootstrap
shortcut. NULL if no shortcut was used or if no valid lambda was
available to use for the shortcut.</p>
</td></tr>
<tr><td><code>cboot.dist</code></td>
<td>
<p>Only different from NULL if the option
return.bootdist is on. This is a ncol(x)*B matrix where each row
contains the computed centered bootstrap distribution for that
estimate.</p>
</td></tr>
<tr><td><code>cboot.dist.underH0</code></td>
<td>
<p>Only different from NULL if the option
return.bootdist is on and if the multiple testing method is WY. This
is a ncol(x)*B matrix where each row 
contains the computed centered bootstrap distribution for that
estimate. These bootstrap distributions were computed under the
complete null hypothesis (b_1 = ... = b_p = 0).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ruben Dezeure</p>


<h3>References</h3>

<p>van de Geer, S., Bühlmann, P., Ritov, Y. and Dezeure, R. (2014)
On asymptotically optimal confidence regions and tests for
high-dimensional models. <em>Annals of Statistics</em> <b>42</b>, 1166&ndash;1202._
</p>
<p>Zhang, C., Zhang, S. (2014)
Confidence intervals for low dimensional parameters in high
dimensional linear models. <em>Journal of the Royal Statistical
Society: Series B</em> <b>76</b>, 217&ndash;242.
</p>
<p>Bühlmann, P. and van de Geer, S. (2015)
High-dimensional inference in misspecified linear models.
<em>Electronic Journal of Statistics</em> <b>9</b>, 1449&ndash;1473.
</p>
<p>Dezeure, R., Bühlmann, P. and Zhang, C. (2016)
High-dimensional simultaneous inference with the bootstrap
<em>http://arxiv.org/abs/1606.03940</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 10), nrow = 100, ncol = 10)
y &lt;- x[,1] + x[,2] + rnorm(100)


fit.lasso &lt;- boot.lasso.proj(x, y)
which(fit.lasso$pval.corr &lt; 0.05) # typically: '1' and '2' and no other



## Use the computational shortcut for the bootstrap to speed up
## computations
fit.lasso.shortcut &lt;- boot.lasso.proj(x, y, boot.shortcut = TRUE)
which(fit.lasso.shortcut$pval.corr &lt; 0.05) # typically: '1' and '2' and no other



## Return the bootstrap distribution as well and compute confidence intervals based on it
fit.lasso.allinfo &lt;- boot.lasso.proj(x, y, return.bootdist = TRUE)
confint(fit.lasso.allinfo, level = 0.95)
confint(fit.lasso.allinfo, parm = 1:3)

## Use the scaled lasso for the initial estimate
fit.lasso.scaled &lt;- boot.lasso.proj(x, y, betainit = "scaled lasso")
which(fit.lasso.scaled$pval.corr &lt; 0.05)

## Use a robust estimate for the standard error
fit.lasso.robust &lt;- boot.lasso.proj(x, y, robust = TRUE)
which(fit.lasso.robust$pval.corr &lt; 0.05)

</code></pre>

<hr>
<h2 id='clusterGroupBound'>Hierarchical structure group tests in linear model</h2><span id='topic+clusterGroupBound'></span>

<h3>Description</h3>

<p>Computes confidence intervals for the l1-norm of groups of linear regression
coefficients in a hierarchical clustering tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterGroupBound(x, y, method = "average",
                  dist = as.dist(1 - abs(cor(x))), alpha = 0.05,
                  eps = 0.1, hcloutput, nsplit = 11,
                  s = min(10, ncol(x) - 1),
                  silent = FALSE, setseed = TRUE, lpSolve = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterGroupBound_+3A_x">x</code></td>
<td>
<p>numeric design matrix of the regression <code class="reqn">n \times p</code>
with <code class="reqn">p</code> columns for <code class="reqn">p</code> predictor variables and <code class="reqn">n</code>
rows corresponding to <code class="reqn">n</code> observations.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_y">y</code></td>
<td>
<p>numeric response variable of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string; the method used for
constructing the hierarchical clustering tree (default:
<code>"average"</code> for &ldquo;average linkage&rdquo;) via
<code><a href="stats.html#topic+hclust">hclust</a></code>.
Alternatively, you can provide your own hierarchical clustering
through the optional argument <code>hcloutput</code>.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_dist">dist</code></td>
<td>
<p>a distance matrix can be specified on which the
hierarchical clustering will be based (see <code><a href="stats.html#topic+dist">dist</a></code>).  The
default option is that the distance between variables will be
calculated as 1 less the absolute correlation matrix.
Alternatively, you can provide your own hierarchical clustering
through the optional argument <code>hcloutput</code>.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_alpha">alpha</code></td>
<td>
<p>numeric level in <code class="reqn">(0, 1)</code> at which the test / confidence
intervals are to be constructed.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_eps">eps</code></td>
<td>
<p>a level of eps*alpha is used and the values of different
splits are aggregated using the (1-eps) quantile. See reference
below for more details.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_hcloutput">hcloutput</code></td>
<td>
<p>optionally, the value of a <code><a href="stats.html#topic+hclust">hclust</a>()</code>
call. If it is provided, the arguments <code>dist</code> and <code>method</code>
are ignored.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_nsplit">nsplit</code></td>
<td>
<p>the number of data splits used.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_s">s</code></td>
<td>
<p>the dimensionality of the projection that is used. Lower
values lead to faster computation and if <code class="reqn">n &gt; 50</code>, then <code>s</code>
is set to 50 if left unspecified, to avoid lengthy computations.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_silent">silent</code></td>
<td>
<p>logical enabling progress output.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_setseed">setseed</code></td>
<td>
<p>a logical; if this is true (recommended), then the same
random seeds are used for all groups, which makes the confidence
intervals simultaneously valid over all groups of variables tested.</p>
</td></tr>
<tr><td><code id="clusterGroupBound_+3A_lpsolve">lpSolve</code></td>
<td>
<p>logical; only set it to false if <code>lpSolve()</code> is not
working on the current machine: setting it to false will result in
much slower computations; only use on small problems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with components
</p>
<table role = "presentation">
<tr><td><code>groupNumber</code></td>
<td>
<p>The index of the group tested in the original
hierarchical clustering tree</p>
</td></tr>
<tr><td><code>members</code></td>
<td>
<p>A list containing the variables that belong into each
testes group</p>
</td></tr>
<tr><td><code>noMembers</code></td>
<td>
<p>A vector containing the number of members in each group</p>
</td></tr>
<tr><td><code>lowerBound</code></td>
<td>
<p>The lower bound on the l1-norm in each group</p>
</td></tr>
<tr><td><code>position</code></td>
<td>
<p>The position on the x-axis of each group (used for plotting)</p>
</td></tr>
<tr><td><code>leftChild</code></td>
<td>
<p>Gives the index of the group that corresponds to the
left child node in the tested tree (negative values correspond to leaf
nodes)</p>
</td></tr>
<tr><td><code>rightChild</code></td>
<td>
<p>Same as <code>leftCHild</code> for the right child of each node</p>
</td></tr>
<tr><td><code>isLeaf</code></td>
<td>
<p>Logical vector. Is <code>TRUE</code> for a group if it is a leaf
node in the tested tree or if both child nodes have a zero lower bound
on their group l1-norm</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolai Meinshausen</p>


<h3>References</h3>

<p>Meinshausen, N. (2015); JRSS B, see <code><a href="#topic+groupBound">groupBound</a></code>.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+groupBound">groupBound</a></code> to compute the lower bound for selected
groups of variables whereas you use this <code>clusterGroupBound</code> to
test all groups in a hierarchical clustering tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a regression problem with correlated design (n = 10, p = 3):
## a block of size 2 and a block of size 1, within-block correlation is 0.99

set.seed(29)
p   &lt;- 3
n   &lt;- 10

Sigma &lt;- diag(p)
Sigma[1,2] &lt;- Sigma[2,1] &lt;- 0.99

x &lt;- matrix(rnorm(n * p), nrow = n) %*% chol(Sigma)

## Create response with active variable 1
beta    &lt;- rep(0, p)
beta[1] &lt;- 5

y  &lt;- as.numeric(x %*% beta + rnorm(n))

out &lt;- clusterGroupBound(x, y, nsplit = 4) ## use larger value for nsplit!

## Plot and print the hierarchical group-test
plot(out)
print(out)
out$members
out$lowerBound

</code></pre>

<hr>
<h2 id='fdr.adjust'>Function to calculate FDR adjusted p-values</h2><span id='topic+fdr.adjust'></span>

<h3>Description</h3>

<p>Calculates FDR adjusted p-values similar to R-function
p.adjust but *without* adjustment for multiplicity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdr.adjust(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdr.adjust_+3A_p">p</code></td>
<td>
<p>Vector of p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the p-values are already corrected for
multiplicity. P-values with a value of 1 are currently ignored.</p>


<h3>Value</h3>

<p>Vector of p-values.</p>


<h3>Author(s)</h3>

<p>Lukas Meier</p>


<h3>References</h3>

<p>Meinshausen, N., Meier, L. and Bühlmann, P. (2009),
<em>P-values for high-dimensional regression</em>, Journal of the
American Statistical Association 104, 1671-1681.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 1000), nrow = 100, ncol = 1000)
y &lt;- x[,1] * 2 + x[,2] * 2.5 + rnorm(100)

## Multi-splitting with lasso.firstq as model selector function
fit.multi &lt;- multi.split(x, y, model.selector =lasso.firstq,
                         args.model.selector = list(q = 10))
p.adjust &lt;- fdr.adjust(fit.multi$pval.corr)
</code></pre>

<hr>
<h2 id='glm.pval'>Function to calculate p-values for a generalized linear model.</h2><span id='topic+glm.pval'></span>

<h3>Description</h3>

<p>Calculates (classical) p-values for an ordinary generalized
linear model in the n &gt; p situation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.pval(x, y, family = "binomial", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.pval_+3A_x">x</code></td>
<td>
<p>Design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="glm.pval_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="glm.pval_+3A_family">family</code></td>
<td>
<p>As in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="glm.pval_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should information be printed out if algorithm
did not converge?</p>
</td></tr>
<tr><td><code id="glm.pval_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A model with intercept is fitted but the p-value of the intercept
is not reported in the output.</p>


<h3>Value</h3>

<p>Vector of p-values (not including the intercept).</p>


<h3>Author(s)</h3>

<p>Lukas Meier</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdi">hdi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## ...
</code></pre>

<hr>
<h2 id='groupBound'>Lower bound on the l1-norm of groups of regression variables</h2><span id='topic+groupBound'></span>

<h3>Description</h3>

<p>Computes a lower bound that forms a one-sided confidence interval for
the group l1-norm of a specified group of regression parameters. It is
assumed that errors have a Gaussian distribution with unknown noise
level.  The underlying vector that inference is made about is the
l1-sparsest approximation to the noiseless data.



</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupBound(x, y, group, alpha = 0.05, eps = 0.1, nsplit = 11,
           s = min(10, ncol(x) - 1), setseed = TRUE,
           silent = FALSE, lpSolve = TRUE, parallel = FALSE,
           ncores = getOption("mc.cores", 2L))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupBound_+3A_x">x</code></td>
<td>
<p>numeric design matrix of the regression <code class="reqn">n \times p</code>
with <code class="reqn">p</code> columns for <code class="reqn">p</code> predictor variables and <code class="reqn">n</code>
rows corresponding to <code class="reqn">n</code> observations.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_y">y</code></td>
<td>
<p>numeric response variable of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_group">group</code></td>
<td>
<p>either a numeric vector with entries in <code class="reqn">\{1,...,p\}</code>
or a <code><a href="base.html#topic+list">list</a></code> with such numeric vectors. If <code>group</code>
is a numeric vector, this is the group of variables for which a
lower bound is computed. If <code>group</code> is a list, the lower bound
is computed for each group in the list.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_alpha">alpha</code></td>
<td>
<p>numeric level in <code class="reqn">(0,1)</code> at which the test /
confidence interval is computed.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_eps">eps</code></td>
<td>
<p>a level of eps * alpha is used and the values of different
splits are aggregated using the (1 - eps) quantile. See reference
below for more details.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_nsplit">nsplit</code></td>
<td>
<p>the number of data splits used.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_s">s</code></td>
<td>
<p>the dimensionality of the projection that is used.  Lower
values lead to faster computation and if <code class="reqn">n &gt; 50</code>, then <code>s</code>
is set to 50 if left unspecified, to avoid lengthy computations.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_setseed">setseed</code></td>
<td>
<p>a logical; if this is true (recommended), then the same
random seeds are used for all groups, which makes the confidence
intervals simultaneously valid over all groups of variables tested.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_silent">silent</code></td>
<td>
<p>logical enabling progress output.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_lpsolve">lpSolve</code></td>
<td>
<p>logical; only set it to false if <code>lpSolve()</code> is not
working on the current machine: setting it to false will result in
much slower computations; only use on small problems.</p>
</td></tr>
<tr><td><code id="groupBound_+3A_parallel">parallel</code></td>
<td>
<p>should parallelization be used? (logical)</p>
</td></tr>
<tr><td><code id="groupBound_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used for parallelization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data are split since the noise level is unknown.  On the
first part of the random split, a cross-validated lasso solution is
computed, using the <a href="https://CRAN.R-project.org/package=glmnet"><span class="pkg">glmnet</span></a> implementation.  This estimator
is used as an initial estimator on the second half of the data.
Results at level <code>alpha</code> are aggregated over <code>nsplit</code> splits
via the median of results at levels <code>alpha/2</code>.
</p>


<h3>Value</h3>

<p>If <code>group</code> is a single numeric vector, a scalar containg the lower
bound for this group of variables is returned. If <code>group</code> is a
list, a numeric vector is retuned where each entry corresponds to the
group of variables defined in the same order in <code>group</code>.
</p>


<h3>Author(s)</h3>

<p>Nicolai Meinshausen</p>


<h3>References</h3>

<p>Meinshausen, N. (2015)
Group bound: confidence intervals for groups of variables in sparse
high dimensional regression without assumptions on the design.
<em>Journal of the Royal Statistical Society: Series B</em>, <b>77</b>,
923&ndash;945; doi: <a href="https://doi.org/10.1111/rssb.12094">10.1111/rssb.12094</a>.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+clusterGroupBound">clusterGroupBound</a></code> to test all groups in a
hierarchical clustering tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a regression problem with correlated design: p = 6, n = 50,
## block size B = 3 and within-block correlation of rho = 0.99
p   &lt;- 6
n   &lt;- 50
B   &lt;- 3
rho &lt;- 0.99

ind   &lt;- rep(1:ceiling(p / B), each = B)[1:p]
Sigma &lt;- diag(p)

for (ii in unique(ind)){
  id &lt;- which(ind == ii)
  Sigma[id, id] &lt;- rho
}
diag(Sigma) &lt;- 1

x &lt;- matrix(rnorm(n * p), nrow = n) %*% chol(Sigma)

## Create response with active variable 1
beta    &lt;- rep(0, p)
beta[1] &lt;- 5

y  &lt;- as.numeric(x %*% beta + rnorm(n))

## Compute lower bounds:

## Lower bound for the L1-norm of *all* variables 1-6 of the sparsest
## optimal vector
nsplit &lt;- 4  ## to make example run fast (use larger value)
lowerBoundAll &lt;- groupBound(x, y, 1:p, nsplit = nsplit)
cat("\nlower bound for all variables 1-6: ", lowerBoundAll, "\n")

## Compute additional lower bounds:
q()## Lower bounds for variable 1 itself, then group {1,3}, 1-2, 1-3, 2-6,
lowerBound &lt;- groupBound(x, y, list(1, c(1,3), 1:2, 1:3, 2:6),
                         nsplit = nsplit)
cat("lower bound for the groups\n\t {1}, {1,3}, {1,2}, {1..3}, {2..6}:\n\t",
    format(formatC(c(lowerBound))), "\n")
</code></pre>

<hr>
<h2 id='hdi'>Function to perform inference in high-dimensional (generalized) linear models</h2><span id='topic+hdi'></span>

<h3>Description</h3>

<p>Perform inference in high-dimensional (generalized) linear
models using various approaches.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdi(x, y, method = "multi.split", B = NULL, fraction = 0.5,
    model.selector = NULL, EV = NULL, threshold = 0.75,
    gamma = seq(0.05, 0.99, by = 0.01),
    classical.fit = NULL,
    args.model.selector = NULL, args.classical.fit = NULL,
    verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdi_+3A_x">x</code></td>
<td>
<p>Design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="hdi_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="hdi_+3A_method">method</code></td>
<td>
<p>Multi-splitting (&quot;multi.split&quot;) or stability-selection
(&quot;stability&quot;).</p>
</td></tr>
<tr><td><code id="hdi_+3A_b">B</code></td>
<td>
<p>Number of sample-splits (for &quot;multi.split&quot;) or sub-sample
iterations (for &quot;stability&quot;). Default is 50 (&quot;multi.split&quot;)or 100
(&quot;stability&quot;). Ignored otherwise.</p>
</td></tr>
<tr><td><code id="hdi_+3A_fraction">fraction</code></td>
<td>
<p>Fraction of data used at each of the B iterations.</p>
</td></tr>
<tr><td><code id="hdi_+3A_model.selector">model.selector</code></td>
<td>
<p>Function to perform model selection. Default is
<code><a href="#topic+lasso.cv">lasso.cv</a></code> (&quot;multi.split&quot;) and
<code><a href="#topic+lasso.firstq">lasso.firstq</a></code> (&quot;stability&quot;). Function must have at
least two arguments: x (the design matrix) and y (the response
vector). Return value is the index vector of selected columns. See
<code><a href="#topic+lasso.cv">lasso.cv</a></code> and <code><a href="#topic+lasso.firstq">lasso.firstq</a></code> for
examples. Additional arguments can be passed through
<code>args.model.selector</code>.</p>
</td></tr>
<tr><td><code id="hdi_+3A_ev">EV</code></td>
<td>
<p>(only for
&quot;stability&quot;). Bound(s) for expected number of false positives . Can
be a vector.</p>
</td></tr>
<tr><td><code id="hdi_+3A_threshold">threshold</code></td>
<td>
<p>(only for &quot;stability&quot;). Bound on selection frequency.</p>
</td></tr>
<tr><td><code id="hdi_+3A_gamma">gamma</code></td>
<td>
<p>(only for &quot;multi.split&quot;). Vector of gamma-values.</p>
</td></tr>
<tr><td><code id="hdi_+3A_classical.fit">classical.fit</code></td>
<td>
<p>(only
for &quot;multi.split&quot;). Function to calculate (classical)
p-values. Default is <code><a href="#topic+lm.pval">lm.pval</a></code>. Function must
have at least two arguments: x (the design matrix) and y (the
response vector). Return value is the vector of p-values. See
<code><a href="#topic+lm.pval">lm.pval</a></code> for an example. Additional arguments can be
passed through <code>args.classical.fit</code>.</p>
</td></tr>
<tr><td><code id="hdi_+3A_args.model.selector">args.model.selector</code></td>
<td>
<p>Named list of further arguments for
function <code>model.selector</code>.</p>
</td></tr>
<tr><td><code id="hdi_+3A_args.classical.fit">args.classical.fit</code></td>
<td>
<p>Named list of further arguments for function
<code>classical.fit</code>.</p>
</td></tr>
<tr><td><code id="hdi_+3A_verbose">verbose</code></td>
<td>
<p>Should information be printed out while computing
(logical).</p>
</td></tr>
<tr><td><code id="hdi_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the underlying functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pval</code></td>
<td>
<p>(only for &quot;multi.split&quot;). Vector of p-values.</p>
</td></tr>
<tr><td><code>gamma.min</code></td>
<td>
<p>(only for &quot;multi.split&quot;). Value of gamma where
minimal p-values was attained.</p>
</td></tr>
<tr><td><code>select</code></td>
<td>
<p>(only for &quot;stability&quot;). List with selected predictors
for the supplied values of EV.</p>
</td></tr>
<tr><td><code>EV</code></td>
<td>
<p>(only for &quot;stability&quot;). Vector of corresponding values of EV.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>(only for &quot;stability&quot;). Used thresholds.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>(only for &quot;stability&quot;). Vector of selection frequencies.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lukas Meier</p>


<h3>References</h3>

<p>Meinshausen, N., Meier, L. and Bühlmann, P. (2009)
P-values for high-dimensional regression.
<em>Journal of the American Statistical Association</em> <b>104</b>, 1671&ndash;1681.
</p>
<p>Meinshausen, N. and Bühlmann, P. (2010)
Stability selection (with discussion).
<em>Journal of the Royal Statistical Society: Series B</em> <b>72</b>, 417&ndash;473.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stability">stability</a></code>, <code><a href="#topic+multi.split">multi.split</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 200), nrow = 100, ncol = 200)
y &lt;- x[,1] * 2 + x[,2] * 2.5 + rnorm(100)

## Multi-splitting with lasso.firstq as model selector function
fit.multi &lt;- hdi(x, y, method = "multi.split",
                 model.selector =lasso.firstq,
                 args.model.selector = list(q = 10))
fit.multi
fit.multi$pval.corr[1:10] ## the first 10 p-values

## Stability selection
fit.stab &lt;- hdi(x, y, method = "stability", EV = 2)
fit.stab
fit.stab$freq[1:10] ## frequency of the first 10 predictors
</code></pre>

<hr>
<h2 id='lasso.cv'>Select Predictors via (10-fold) Cross-Validation of the Lasso</h2><span id='topic+lasso.cv'></span>

<h3>Description</h3>

<p>Performs (n-fold) cross-validation of the lasso (via
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>) and determines the prediction
optimal set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso.cv(x, y,
         nfolds = 10,
         grouped = nrow(x) &gt; 3*nfolds,
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasso.cv_+3A_x">x</code></td>
<td>
<p>numeric design matrix (without intercept) of dimension <code class="reqn">n
      \times p</code>.</p>
</td></tr>
<tr><td><code id="lasso.cv_+3A_y">y</code></td>
<td>
<p>response vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="lasso.cv_+3A_nfolds">nfolds</code></td>
<td>
<p>the number of folds to be used in the cross-validation</p>
</td></tr>
<tr><td><code id="lasso.cv_+3A_grouped">grouped</code></td>
<td>
<p>corresponds to the <code>grouped</code> argument to <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. This has
a smart default such that glmnet does not give a warning about too
small sample size.</p>
</td></tr>
<tr><td><code id="lasso.cv_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function basically only calls <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>, see source
code.
</p>


<h3>Value</h3>

<p>Vector of selected predictors.</p>


<h3>Author(s)</h3>

<p>Lukas Meier</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdi">hdi</a></code> which uses <code>lasso.cv()</code> by default;
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>.
An alternative for <code>hdi()</code>: <code><a href="#topic+lasso.firstq">lasso.firstq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 1000), nrow = 100, ncol = 1000)
y &lt;- x[,1] * 2 + x[,2] * 2.5 + rnorm(100)
sel &lt;- lasso.cv(x, y)
sel
</code></pre>

<hr>
<h2 id='lasso.firstq'>Determine the first q Predictors in the Lasso Path</h2><span id='topic+lasso.firstq'></span>

<h3>Description</h3>

<p>Determines the q predictors that enter the lasso path first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso.firstq(x, y, q, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasso.firstq_+3A_x">x</code></td>
<td>
<p>numeric design matrix (without intercept) of dimension <code class="reqn">n
      \times p</code>.</p>
</td></tr>
<tr><td><code id="lasso.firstq_+3A_y">y</code></td>
<td>
<p>response vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="lasso.firstq_+3A_q">q</code></td>
<td>
<p>number of predictors that should be selected, a positive integer.</p>
</td></tr>
<tr><td><code id="lasso.firstq_+3A_...">...</code></td>
<td>
<p>optional additional arguments to be passed to <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lasso.firstq</code> function calls
<code><a href="glmnet.html#topic+glmnet">glmnet</a></code> in a special way and simply postprocesses its
nonzero predictor list, see its source code.
</p>


<h3>Value</h3>

<p>Vector of selected predictors.</p>


<h3>Author(s)</h3>

<p>Lukas Meier</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdi">hdi</a></code>;
the default choice for <code>hdi()</code>, <code><a href="#topic+lasso.cv">lasso.cv</a></code>.
<code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 1000), nrow = 100, ncol = 1000)
y &lt;- x[,1] * 2 + x[,2] * 2.5 + rnorm(100)
sel &lt;- lasso.firstq(x, y, q = 5)
sel # 5 integers from {1,2, ..., 1000},  including '1' and '2', typically
</code></pre>

<hr>
<h2 id='lasso.proj'>P-values based on lasso projection method</h2><span id='topic+lasso.proj'></span>

<h3>Description</h3>

<p>Compute p-values based on the lasso projection method, also known as
the de-sparsified Lasso, using an asymptotic gaussian approximation
to the distribution of the estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso.proj(x, y, family = "gaussian", standardize = TRUE,
           multiplecorr.method = "holm", N = 10000,
           parallel = FALSE, ncores = getOption("mc.cores", 2L),
           betainit = "cv lasso", sigma = NULL, Z = NULL, verbose = FALSE,
           return.Z = FALSE, suppress.grouptesting = FALSE, robust = FALSE,
	   do.ZnZ = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasso.proj_+3A_x">x</code></td>
<td>
<p>Design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_family">family</code></td>
<td>
<p>family</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_standardize">standardize</code></td>
<td>
<p>Should design matrix be standardized to unit column
standard deviation.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_multiplecorr.method">multiplecorr.method</code></td>
<td>
<p>Either &quot;WY&quot; or any of
<code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code>.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_n">N</code></td>
<td>
<p>Number of empirical samples (only used if multiplecorr.method
== &quot;WY&quot;)</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_parallel">parallel</code></td>
<td>
<p>Should parallelization be used? (logical)</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_betainit">betainit</code></td>
<td>
<p>Either a numeric vector, corresponding to a sparse
estimate of the coefficient vector, or the method to be used for the
initial estimation, &quot;scaled lasso&quot; or &quot;cv lasso&quot;.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_sigma">sigma</code></td>
<td>
<p>Estimate of the standard deviation of the error term. This
estimate needs to be compatible with the initial
estimate (see betainit) provided or calculated. Otherwise, results
will not be correct.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_z">Z</code></td>
<td>
<p>user input, also see <code>return.Z</code> below</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_verbose">verbose</code></td>
<td>
<p>A boolean to enable reporting on the progress of the
computations. (Only prints out information when Z is not provided by
the user)</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_return.z">return.Z</code></td>
<td>
<p>An option to return the intermediate result which only
depends on the design matrix x. This intermediate results
can be used when calling the function again and the design matrix
is the same as before.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_suppress.grouptesting">suppress.grouptesting</code></td>
<td>
<p>A boolean to optionally suppress the
preparations made for testing groups. This will avoid quite a bit of
computation and memory usage. The output will also be smaller.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_robust">robust</code></td>
<td>
<p>Uses a robust variance estimation procedure to be able
to deal with model misspecification.</p>
</td></tr>
<tr><td><code id="lasso.proj_+3A_do.znz">do.ZnZ</code></td>
<td>
<p>Use a slightly different way of choosing tuning
parameters to compute Z, called Z&amp;Z based on Zhang and Zhang (2014).
This choice of tuning parameter
results in a slightly higher variance of the estimator.
More concretely, it achieves a 25
variance of the estimator (over j=1..ncol(x)) in comparison to tuning with
cross-validation.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pval</code></td>
<td>
<p>Individual p-values for each parameter.</p>
</td></tr>
<tr><td><code>pval.corr</code></td>
<td>
<p>Multiple testing corrected p-values for each
parameter.</p>
</td></tr>
<tr><td><code>groupTest</code></td>
<td>
<p>Function to perform groupwise tests. Groups are
indicated using an index vector with entries in 1,...,p or a list thereof.</p>
</td></tr>
<tr><td><code>clusterGroupTest</code></td>
<td>
<p>Function to perform groupwise tests based on
hierarchical clustering. You can either provide a distance matrix
and clustering method or the output of hierarchical clustering from
the function <code><a href="stats.html#topic+hclust">hclust</a></code> as for
<code><a href="#topic+clusterGroupBound">clusterGroupBound</a></code>. P-values are adjusted for multiple testing.</p>
</td></tr>


<tr><td><code>sigmahat</code></td>
<td>
<p><code class="reqn">\widehat{\sigma}</code> coming from the scaled lasso.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>Only different from NULL if the option return.Z is on. This
is an intermediate result from the computation which only depends on
the design matrix x. These are the residuals of the nodewise regressions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ruben Dezeure</p>


<h3>References</h3>

<p>van de Geer, S., Bühlmann, P., Ritov, Y. and Dezeure, R. (2014)
On asymptotically optimal confidence regions and tests for
high-dimensional models. <em>Annals of Statistics</em> <b>42</b>, 1166&ndash;1202._
</p>
<p>Zhang, C., Zhang, S. (2014)
Confidence intervals for low dimensional parameters in high
dimensional linear models. <em>Journal of the Royal Statistical
Society: Series B</em> <b>76</b>, 217&ndash;242.
</p>
<p>Bühlmann, P. and van de Geer, S. (2015)
High-dimensional inference in misspecified linear models.
<em>Electronic Journal of Statistics</em> <b>9</b>, 1449&ndash;1473.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 10), nrow = 100, ncol = 10)
y &lt;- x[,1] + x[,2] + rnorm(100)
fit.lasso &lt;- lasso.proj(x, y)
which(fit.lasso$pval.corr &lt; 0.05) # typically: '1' and '2' and no other

## Group-wise testing of the first two coefficients
fit.lasso$groupTest(1:2)

##Compute confidence intervals
confint(fit.lasso, level = 0.95)


## Hierarchical testing using distance matrix based on
## correlation matrix
out.clust &lt;- fit.lasso$clusterGroupTest()
plot(out.clust)

## Fit the lasso projection method without doing the preparations
## for group testing (saves time and memory)
fit.lasso.faster &lt;- lasso.proj(x, y, suppress.grouptesting = TRUE)

## Use the scaled lasso for the initial estimate
fit.lasso.scaled &lt;- lasso.proj(x, y, betainit = "scaled lasso")
which(fit.lasso.scaled$pval.corr &lt; 0.05)

## Use a robust estimate for the standard error
fit.lasso.robust &lt;- lasso.proj(x, y, robust = TRUE)
which(fit.lasso.robust$pval.corr &lt; 0.05)


## Perform the Z&amp;Z version of the lasso projection method
fit.lasso &lt;- lasso.proj(x, y, do.ZnZ = TRUE)

which(fit.lasso$pval.corr &lt; 0.05) # typically: '1' and '2' and no other
</code></pre>

<hr>
<h2 id='lm.ci'>Function to calculate confidence intervals for ordinary multiple
linear regression.</h2><span id='topic+lm.ci'></span>

<h3>Description</h3>

<p>Calculates (classical) confidence intervals for an ordinary
multiple linear regression model in the n &gt; p situation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.ci(x, y, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm.ci_+3A_x">x</code></td>
<td>
<p>Design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="lm.ci_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="lm.ci_+3A_level">level</code></td>
<td>
<p>Coverage level.</p>
</td></tr>
<tr><td><code id="lm.ci_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A model with intercept is fitted but the p-value of the intercept
is not reported in the output.</p>


<h3>Value</h3>

<p>Matrix of confidence interval bounds (not including the intercept).</p>


<h3>Author(s)</h3>

<p>Lukas Meier</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdi">hdi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 5), nrow = 100, ncol = 5)
y &lt;- x[,1] * 2 + x[,2] * 2.5 + rnorm(100)
ci &lt;- lm.ci(x, y)
ci
</code></pre>

<hr>
<h2 id='lm.pval'>Function to calculate p-values for ordinary multiple linear regression.</h2><span id='topic+lm.pval'></span>

<h3>Description</h3>

<p>Calculates (classical) p-values for an ordinary multiple linear
regression in the n &gt; p situation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.pval(x, y, exact = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm.pval_+3A_x">x</code></td>
<td>
<p>Design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="lm.pval_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="lm.pval_+3A_exact">exact</code></td>
<td>
<p>Logical. TRUE if p-values based on t-distribution should
be calculated. FALSE if normal distribution should be used as
approximation.</p>
</td></tr>
<tr><td><code id="lm.pval_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A model with intercept is fitted but the p-value of the intercept
is not reported in the output.</p>


<h3>Value</h3>

<p>Vector of p-values (not including the intercept).</p>


<h3>Author(s)</h3>

<p>Lukas Meier</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdi">hdi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 5), nrow = 100, ncol = 5)
y &lt;- x[,1] * 2 + x[,2] * 2.5 + rnorm(100)
pval &lt;- lm.pval(x, y)
pval
</code></pre>

<hr>
<h2 id='multi.split'>Calculate P-values Based on Multi-Splitting Approach</h2><span id='topic+multi.split'></span>

<h3>Description</h3>

<p>Calculate p-values and confidence intervals based on the
multi-splitting approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.split(x, y, B = 100, fraction = 0.5, ci = TRUE, ci.level = 0.95,
            model.selector = lasso.cv,
            classical.fit = lm.pval, classical.ci = lm.ci,
            parallel = FALSE, ncores = getOption("mc.cores", 2L),
            gamma = seq(ceiling(0.05 * B) / B, 1 - 1 / B, by = 1 / B),
            args.model.selector = NULL, args.classical.fit = NULL,
            args.classical.ci = NULL,
            return.nonaggr = FALSE, return.selmodels = FALSE,
            repeat.max = 20,
            verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi.split_+3A_x">x</code></td>
<td>
<p>numeric design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="multi.split_+3A_y">y</code></td>
<td>
<p>numeric response vector.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_b">B</code></td>
<td>
<p>the number of sample-splits, a positive integer.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_fraction">fraction</code></td>
<td>
<p>a number in <code class="reqn">(0,1)</code>, the fraction of data used at
each sample split for the model selection process.  The remaining
data is used for calculating the p-values.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_ci">ci</code></td>
<td>
<p>logical indicating if a confidence interval should be
calculated for each parameter.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_ci.level">ci.level</code></td>
<td>
<p>(if <code>ci</code> is true:) a number in <code class="reqn">(0,1)</code>,
typically close to 1, the desired coverage level of the confidence
intervals.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_model.selector">model.selector</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> to perform model
selection, with default <code><a href="#topic+lasso.cv">lasso.cv</a></code>.  The function must have at
least two arguments, <code>x</code> (the design matrix) and <code>y</code> (the
response vector).  Return value is the index vector of selected columns.  See
<code><a href="#topic+lasso.cv">lasso.cv</a></code> and <code><a href="#topic+lasso.firstq">lasso.firstq</a></code> for an
example.  Additional arguments can be passed via <code>args.model.selector</code>.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_classical.fit">classical.fit</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> to calculate (classical)
p-values.  Default is <code><a href="#topic+lm.pval">lm.pval</a></code>.  The function must have
at least two arguments, <code>x</code> (the design matrix) and <code>y</code>
(the response vector), and return the vector of p-values.  See
<code><a href="#topic+lm.pval">lm.pval</a></code> for an example.  Additional arguments can be
passed through <code>args.classical.fit</code>.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_classical.ci">classical.ci</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> to calculate (classical)
confidence intervals.  Default is <code><a href="#topic+lm.ci">lm.ci</a></code>.  The function
must have at least 3 arguments, <code>x</code> (the design matrix),
<code>y</code> (the response vector) and <code>level</code> (the coverage
level), and return the matrix of confidence intervals.  See
<code><a href="#topic+lm.ci">lm.ci</a></code> for an example.  Additional arguments can be
passed through <code>args.classical.ci</code>.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_parallel">parallel</code></td>
<td>
<p>logical indicating if parallelization via
<code><a href="parallel.html#topic+mclapply">mclapply</a></code> should be used.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used for parallelization as
<code>mc.cores</code> in <code><a href="parallel.html#topic+mclapply">mclapply</a>()</code>.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_gamma">gamma</code></td>
<td>
<p>vector of gamma-values.  In case gamma is a scalar, the
value <code class="reqn">Q_j</code> instead of <code class="reqn">P_j</code> is being calculated (see
reference below).</p>
</td></tr>
<tr><td><code id="multi.split_+3A_args.model.selector">args.model.selector</code></td>
<td>
<p>named <code><a href="base.html#topic+list">list</a></code> of further arguments for
function <code>model.selector</code>.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_args.classical.fit">args.classical.fit</code></td>
<td>
<p>named <code><a href="base.html#topic+list">list</a></code> of further
arguments for function <code>classical.fit</code>.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_args.classical.ci">args.classical.ci</code></td>
<td>
<p>named <code><a href="base.html#topic+list">list</a></code> of further arguments
for function <code>classical.ci</code>.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_return.nonaggr">return.nonaggr</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the
unadjusted p-values be returned.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_return.selmodels">return.selmodels</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the
selected models (at each split) should be returned.  Necessary for
the <code>clusterGroupTest()</code> part of the result.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_repeat.max">repeat.max</code></td>
<td>
<p>positive integer indicating the maximal number of
split trials.   Should not matter in regular cases, but necessary to
prevent infinite loops in borderline cases.</p>
</td></tr>
<tr><td><code id="multi.split_+3A_verbose">verbose</code></td>
<td>
<p>should information be printed out while computing? (logical).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pval.corr</code></td>
<td>
<p>Vector of multiple testing corrected p-values.</p>
</td></tr>
<tr><td><code>gamma.min</code></td>
<td>
<p>Value of gamma where minimal p-values was attained.</p>
</td></tr>
<tr><td><code>clusterGroupTest</code></td>
<td>
<p>Function to perform groupwise tests based on
hierarchical clustering.  You can either provide a distance matrix
and clustering method or the output of hierarchical clustering from
the function <code><a href="stats.html#topic+hclust">hclust</a></code> as for
<code><a href="#topic+clusterGroupBound">clusterGroupBound</a></code>. P-values are adjusted for multiple
testing.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Lukas Meier, Ruben Dezeure, Jacopo Mandozzi</p>


<h3>References</h3>

<p>Meinshausen, N., Meier, L. and Bühlmann, P. (2009)
P-values for high-dimensional regression.
<em>Journal of the American Statistical Association</em> <b>104</b>,
1671&ndash;1681.
</p>
<p>Mandozzi, J. and Bühlmann, P. (2015)
A sequential rejection testing method for high-dimensional regression
with correlated variables. To appear in the International Journal of
Biostatistics. Preprint arXiv:1502.03300
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lasso.cv">lasso.cv</a></code>, <code><a href="#topic+lasso.firstq">lasso.firstq</a></code>;
<code><a href="#topic+lm.pval">lm.pval</a></code>, <code><a href="#topic+lm.ci">lm.ci</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;-  40 # a bit small, to keep example "fast"
p &lt;- 256
x &lt;- matrix(rnorm(n * p), nrow = n, ncol = p)
y &lt;- x[,1] * 2 + x[,2] * 2.5 + rnorm(n)

## Multi-splitting with lasso.firstq as model selector function
## 'q' must be specified
fit.multi &lt;- multi.split(x, y, model.selector = lasso.firstq,
                         args.model.selector = list(q = 10))
fit.multi
head(fit.multi$pval.corr, 10) ## the first 10 p-values
ci. &lt;- confint(fit.multi)
head(ci.) # the first 6
stopifnot(all.equal(ci.,
     with(fit.multi, cbind(lci, uci)), check.attributes=FALSE))


## Use default 'lasso.cv' (slower!!) -- incl cluster group testing:
system.time(fit.m2 &lt;- multi.split(x, y, return.selmodels = TRUE))# 9 sec (on "i7")
head(fit.m2$pval.corr) ## the first  6  p-values
head(confint(fit.m2))  ## the first  6  95% conf.intervals

## Now do clustergroup testing
clGTst &lt;- fit.m2$clusterGroupTest
names(envGT &lt;- environment(clGTst))# about 14
if(!interactive()) # if you are curious (and advanced):
  print(ls.str(envGT), max = 0)
stopifnot(identical(clGTst, envGT$clusterGroupTest))
ccc &lt;- clGTst()
str(ccc)
ccc$hh   # the clustering
has.1.or.2 &lt;- sapply(ccc$clusters,
                function(j.set) any(c(1,2) %in% j.set))
ccc$pval[ has.1.or.2] ## all very small
ccc$pval[!has.1.or.2] ## all 1

</code></pre>

<hr>
<h2 id='plot.clusterGroupBound'>Plot output of hierarchical testing of groups of variables</h2><span id='topic+plot.clusterGroupBound'></span>

<h3>Description</h3>

<p>The <code><a href="base.html#topic+plot">plot</a>()</code> method for <code>"<a href="#topic+clusterGroupBound">clusterGroupBound</a>"</code> objects
plots the outcome of applying a lower bound on the l1-norm on groups of
variables in a hierarchical clustering tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterGroupBound'
plot(x, cexfactor = 1, yaxis = "members",
     xlab = "", col = NULL, pch = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.clusterGroupBound_+3A_x">x</code></td>
<td>
<p>an object of <code><a href="base.html#topic+class">class</a></code> <code>"clusterGroupBound"</code>,
as resulting from <code><a href="#topic+clusterGroupBound">clusterGroupBound</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot.clusterGroupBound_+3A_cexfactor">cexfactor</code></td>
<td>
<p>numeric expansion factor for the size of the node symbols.</p>
</td></tr>
<tr><td><code id="plot.clusterGroupBound_+3A_yaxis">yaxis</code></td>
<td>
<p>a string; for the default <code>"members"</code>, the hierarchical tree
is shown as function of cluster size on the y-axis, whereas the node
sizes are proportional to the lower l1-norm of the respective groups
of variables. If <code>yaxis</code> takes any different value, then this
is reversed and the tree is shown against the lower l1-norm on the
y-axis, while node sizes are now proportional to the number of
elements in each cluster.</p>
</td></tr>
<tr><td><code id="plot.clusterGroupBound_+3A_xlab">xlab</code></td>
<td>
<p>label used for the x-axis; by default none.</p>
</td></tr>
<tr><td><code id="plot.clusterGroupBound_+3A_col">col</code></td>
<td>
<p>the colour of the symbols for the nodes.</p>
</td></tr>
<tr><td><code id="plot.clusterGroupBound_+3A_pch">pch</code></td>
<td>
<p>the plot symbol (see <code><a href="graphics.html#topic+points">points</a></code>) of the symbols
for the nodes.</p>
</td></tr>
<tr><td><code id="plot.clusterGroupBound_+3A_...">...</code></td>
<td>
<p>optional additional arguments passed to
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned</p>


<h3>Author(s)</h3>

<p>Nicolai Meinshausen <a href="mailto:meinshausen@stat.math.ethz.ch">meinshausen@stat.math.ethz.ch</a></p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+clusterGroupBound">clusterGroupBound</a>()</code> to test all groups in a
hierarchical clustering tree.
Use <code><a href="#topic+groupBound">groupBound</a>()</code> to compute the lower bound for selected
groups of variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a regression problem with correlated design (n = 10, p = 3):
## a block of size 2 and a block of size 1, within-block correlation is 0.99

set.seed(29)
p   &lt;- 3
n   &lt;- 10

Sigma &lt;- diag(p)
Sigma[1,2] &lt;- Sigma[2,1] &lt;- 0.99

x &lt;- matrix(rnorm(n * p), nrow = n) %*% chol(Sigma)

## Create response with active variable 1
beta    &lt;- rep(0, p)
beta[1] &lt;- 5

y  &lt;- as.numeric(x %*% beta + rnorm(n))

## Compute the lower bound for all groups in a hierarchical clustering tree
cgb5 &lt;- clusterGroupBound(x, y, nsplit = 4) ## use larger value for nsplit!

## Plot the tree with y-axis proportional to the (log) of the number of
## group members and node sizes proportional to the lower l1-norm bound.
plot(cgb5)

## Show the lower bound on the y-axis and node sizes proportional to
## number of group members
plot(cgb5, yaxis = "")

</code></pre>

<hr>
<h2 id='riboflavin'>Riboflavin data set</h2><span id='topic+riboflavin'></span>

<h3>Description</h3>

<p>Dataset of riboflavin production by Bacillus subtilis
containing <code class="reqn">n=71</code> observations of <code class="reqn">p=4088</code> predictors (gene
expressions) and a one-dimensional response (riboflavin production).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(riboflavin)</code></pre>


<h3>Format</h3>


<dl>
<dt>y</dt><dd><p>Log-transformed riboflavin production rate (original name:
q_RIBFLV).</p>
</dd>
<dt>x</dt><dd><p>(Co-)variables measuring the logarithm of the expression
level of 4088 genes.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data kindly provided by DSM (Switzerland).</p>


<h3>References</h3>

<p>Bühlmann, P., Kalisch, M. and Meier,
L. (2014) <em>High-dimensional statistics with a view towards
applications in biology</em>. Annual Review of Statistics and
its Applications <b>1</b>, 255&ndash;278
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(riboflavin)</code></pre>

<hr>
<h2 id='ridge.proj'>P-values based on ridge projection method</h2><span id='topic+ridge.proj'></span>

<h3>Description</h3>

<p>Compute p-values for lasso-type regression coefficients
based on the ridge projection method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridge.proj(x, y, family = "gaussian", standardize = TRUE,
           lambda = 1, betainit = "cv lasso", sigma = NULL,
           suppress.grouptesting = FALSE,
           multiplecorr.method = "holm", N = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ridge.proj_+3A_x">x</code></td>
<td>
<p>design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="ridge.proj_+3A_y">y</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="ridge.proj_+3A_family">family</code></td>
<td>
<p>family</p>
</td></tr>
<tr><td><code id="ridge.proj_+3A_standardize">standardize</code></td>
<td>
<p>Should design matrix be standardized to unit column
standard deviation (logical)?</p>
</td></tr>
<tr><td><code id="ridge.proj_+3A_lambda">lambda</code></td>
<td>
<p>Value of penalty parameter lambda (ridge regression).</p>
</td></tr>
<tr><td><code id="ridge.proj_+3A_betainit">betainit</code></td>
<td>
<p>Either a numeric vector, corresponding to a sparse
estimate of the coefficient vector, or the method to be used for the
initial estimation, &quot;scaled lasso&quot; or &quot;cv lasso&quot;.</p>
</td></tr>
<tr><td><code id="ridge.proj_+3A_sigma">sigma</code></td>
<td>
<p>Estimate of the standard deviation of the error term. This
estimate needs to be compatible with the initial
estimate (see betainit) provided or calculated. Otherwise, results
won't be correct.</p>
</td></tr>
<tr><td><code id="ridge.proj_+3A_suppress.grouptesting">suppress.grouptesting</code></td>
<td>
<p>A boolean to optionally suppress the
preparations made for testing groups. This will avoid quite a bit of
computation and memory usage. The output will also be smaller.</p>
</td></tr>  
<tr><td><code id="ridge.proj_+3A_multiplecorr.method">multiplecorr.method</code></td>
<td>
<p>Either &quot;WY&quot; or any of
<code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code>.</p>
</td></tr>
<tr><td><code id="ridge.proj_+3A_n">N</code></td>
<td>
<p>number of empirical samples (only used if
<code>multiplecorr.method = "WY"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pval</code></td>
<td>
<p>Individual p-values for each parameter.</p>
</td></tr>
<tr><td><code>pval.corr</code></td>
<td>
<p>Multiple testing corrected p-values for each
parameter.</p>
</td></tr>
<tr><td><code>groupTest</code></td>
<td>
<p>Function to perform groupwise tests.  Groups are
indicated using an index vector with entries in <code class="reqn">{1,\ldots,p}</code>
or a list thereof.</p>
</td></tr>
<tr><td><code>clusterGroupTest</code></td>
<td>
<p>Function to perform groupwise tests based on
hierarchical clustering. You can either provide a distance matrix
and clustering method or the output of hierarchical clustering from
the function <code><a href="stats.html#topic+hclust">hclust</a></code> as for
<code><a href="#topic+clusterGroupBound">clusterGroupBound</a></code>. P-values are adjusted for multiple testing.</p>
</td></tr>


<tr><td><code>sigmahat</code></td>
<td>
<p><code class="reqn">\widehat{\sigma}</code> coming from the scaled lasso.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Buehlmann, Ruben Dezeure, Lukas Meier</p>


<h3>References</h3>

<p>Bühlmann, P. (2013)
Statistical significance in high-dimensional linear models.
<em>Bernoulli</em> <b>19</b>, 1212&ndash;1242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 100), nrow = 100, ncol = 100)
y &lt;- x[,1] + x[,2] + rnorm(100)
fit.ridge &lt;- ridge.proj(x, y)
which(fit.ridge$pval.corr &lt; 0.05)

## Use the scaled lasso for the initial estimate
fit.ridge.scaled  &lt;- ridge.proj(x, y, betainit = "scaled lasso")
which(fit.ridge.scaled$pval.corr &lt; 0.05)

## Group-wise testing of the first two coefficients
fit.ridge$groupTest(1:2)

## Hierarchical testing using distance matrix based on
## correlation matrix
out.clust &lt;- fit.ridge$clusterGroupTest()
plot(out.clust)

## Fit the method without doing the preparations
## for group testing (saves time and memory)
fit.ridge.faster &lt;- ridge.proj(x, y, suppress.grouptesting = TRUE)
</code></pre>

<hr>
<h2 id='rXb'>Generate Data Design Matrix <code class="reqn">X</code> and Coefficient Vector <code class="reqn">\beta</code></h2><span id='topic+rXb'></span><span id='topic+rX'></span>

<h3>Description</h3>

<p>Generate a random design matrix <code class="reqn">X</code> and coefficient vector <code class="reqn">\beta</code>
useful for simulations of (high dimensional) linear models.
In particular, the function <code>rXb()</code> can be used to exactly
recreate the reference linear model datasets of the hdi paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rXb(n, p, s0,
    xtype = c("toeplitz", "exp.decay", "equi.corr"),
    btype = "U[-2,2]",
    permuted = FALSE, iteration = NA, do2S = TRUE,
    x.par = switch(xtype,
                   "toeplitz"  = 0.9,
                   "equi.corr" = 0.8,
                   "exp.decay" = c(0.4, 5)),
   verbose = TRUE)

rX(n, p, xtype, permuted, do2S = TRUE,
   par = switch(xtype,
                "toeplitz"  = 0.9,
                "equi.corr" = 0.8,
                "exp.decay" = c(0.4, 5)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rXb_+3A_n">n</code></td>
<td>
<p>integer; the sample size <code class="reqn">n</code> (paper had always <code>n = 100</code>).</p>
</td></tr>
<tr><td><code id="rXb_+3A_p">p</code></td>
<td>
<p>integer; the number of coefficients in the linear
model. (paper had always <code>p = 500</code>).</p>
</td></tr>
<tr><td><code id="rXb_+3A_s0">s0</code></td>
<td>
<p>integer number of <em>nonzero</em> coefficients desired in the
model; hence at most <code>p</code>.</p>
</td></tr>
<tr><td><code id="rXb_+3A_xtype">xtype</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the type of design matrix
one wants to generate.  Must be one of <code>"toeplitz"</code>,
<code>"equi.corr"</code> or <code>"exp.decay"</code>.</p>
</td></tr>
<tr><td><code id="rXb_+3A_btype">btype</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the type of
nonzero coefficients (&ldquo;beta&rdquo;) one wants to generate.  In the hdi
paper, this has been one of
&quot;U[-2,2]&quot;, &quot;U[0,2]&quot;, &quot;U[0,4]&quot;, &quot;bfix1&quot;, &quot;bfix2&quot; and &quot;bfix10&quot;.  In
general, any string of the form <code>"U[a,b]"</code> or <code>"bfix&lt;c&gt;"</code>
is allowed, where <code>a</code>, <code>b</code>, and <code>&lt;c&gt;</code> must be numbers
(with <code class="reqn">a \le b</code>).</p>
</td></tr>
<tr><td><code id="rXb_+3A_permuted">permuted</code></td>
<td>
<p>logical specifying if the columns of the design matrix
should be permuted.</p>
</td></tr>
<tr><td><code id="rXb_+3A_iteration">iteration</code></td>
<td>
<p>integer or <code>NA</code> specifying if seeds should be
set to generate reproducible
realizations of the design type and coefficients type. <code>NA</code>
corresponds to not setting seeds. Iteration numbers 1 to 50
correspond to the setups from the paper.
If a seed is set, the original <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> at the
point of entering the function is saved and is restored upon exit of
the data generation.
If <code>NA</code>, the current <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> is
taken as usual in <span class="rlang"><b>R</b></span>.</p>
</td></tr>
<tr><td><code id="rXb_+3A_do2s">do2S</code></td>
<td>
<p>logical indicating if in the case of <code>xtype</code>s
<code>"toeplitz"</code> or <code>"equi.corr"</code>, the <code class="reqn">p \times p</code>
covariance matrix should be inverted twice.  Must be true, to
regenerate the <code class="reqn">X</code> matrices from the hdi paper exactly
&ldquo;to the last bit&rdquo;.</p>
</td></tr>
<tr><td><code id="rXb_+3A_x.par">x.par</code>, <code id="rXb_+3A_par">par</code></td>
<td>
<p>the parameters to be used for the design matrix.  Must be
a numeric vector of length one or two.  The default uses the
parameters also used in the hdi paper.</p>
</td></tr>
<tr><td><code id="rXb_+3A_verbose">verbose</code></td>
<td>
<p>should the function give a message if seeds are being
set? (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Generation of the design matrix <code class="reqn">X</code>:</b>
<br />
For all <code>xtype</code>'s, the <code class="reqn">X</code> matrix will be multivariate
normal, with mean zero and (co)variance matrix <code class="reqn">\Sigma = </code><code>C</code>
determined from <code>xtype</code>, <code>x.par</code> and <code class="reqn">p</code> as follows:
</p>

<dl>
<dt><code>xtype = "toeplitz"</code>:</dt><dd><p><code>C &lt;- par ^ abs(toeplitz(0:(p-1)))</code></p>
</dd>
<dt><code>xtype = "equi.corr"</code>:</dt><dd><p><code class="reqn">\Sigma_{i,j} = \code{par}</code>
for <code class="reqn">i \ne j</code>, and <code class="reqn">= 1</code>
for <code class="reqn">i = j</code>, i.e., on the diagonal.</p>
</dd>
<dt><code>xtype = "exp.decay"</code>:</dt><dd><p><code>C &lt;- solve(par[1] ^
	abs(toeplitz(0:(p-1)) / par[2]))</code></p>
</dd>
</dl>



<h3>Value</h3>


<dl>
<dt>For <code>rXb()</code>:</dt><dd><p>A <code><a href="base.html#topic+list">list</a></code> with components
</p>

<dl>
<dt>x</dt><dd><p>the generated <code class="reqn">n \times p</code> design matrix <code class="reqn">X</code>.</p>
</dd>
<dt>beta</dt><dd><p>the generated coefficient vector <code class="reqn">\beta</code> (&lsquo;beta&rsquo;).</p>
</dd></dl>

</dd>
<dt>For <code>rX()</code>:</dt><dd><p>the generated <code class="reqn">n \times p</code> design
matrix <code class="reqn">X</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ruben Dezeure <a href="mailto:dezeure@stat.math.ethz.ch">dezeure@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p>Dezeure, R., Bühlmann, P., Meier, L. and
Meinshausen, N. (2015) 
High-dimensional inference: confidence intervals, p-values and
R-software hdi.
<em>Statistical Science</em> <b>30</b>, 533&ndash;558.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate the first realization of the linear model with design matrix
## type Toeplitz and coefficients type uniform between -2 and 2

dset &lt;- rXb(n = 80, p = 20, s0 = 3,
            xtype = "toeplitz", btype = "U[-2,2]")
x &lt;- dset$x
beta &lt;- dset$beta

## generate 100 response vectors of this linear model
y &lt;- as.vector( x %*% beta ) + replicate(100, rnorm(nrow(x)))

## Use  'beta_min' fulfilling  beta's  (non standard 'btype'):
str(ds2 &lt;- rXb(n = 50, p = 12, s0 = 3,
               xtype = "exp.decay", btype = "U[0.1, 5]"))

## Generate a design matrix of type "toeplitz"
set.seed(3) # making it reproducible
X3 &lt;- rX(n = 800, p = 500, xtype = "toeplitz", permuted = FALSE)

## permute the columns
set.seed(3)
Xp &lt;- rX(n = 800, p = 500, xtype = "toeplitz", permuted = TRUE)
</code></pre>

<hr>
<h2 id='stability'>Function to perform stability selection</h2><span id='topic+stability'></span>

<h3>Description</h3>

<p>Function to perform stability selection</p>


<h3>Usage</h3>

<pre><code class='language-R'>stability(x, y, EV, threshold = 0.75, B = 100, fraction = 0.5,
          model.selector = lasso.firstq, args.model.selector = NULL,
          parallel = FALSE, ncores = getOption("mc.cores", 2L),
          verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stability_+3A_x">x</code></td>
<td>
<p>Design matrix (without intercept).</p>
</td></tr>
<tr><td><code id="stability_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="stability_+3A_ev">EV</code></td>
<td>
<p>Bound for expected number of false positives.</p>
</td></tr>
<tr><td><code id="stability_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for selection frequency. Must be in (0.5, 1).</p>
</td></tr>
<tr><td><code id="stability_+3A_b">B</code></td>
<td>
<p>Number of sub-sample iterations.</p>
</td></tr>
<tr><td><code id="stability_+3A_fraction">fraction</code></td>
<td>
<p>Fraction of data used at each of the B sub-samples.</p>
</td></tr>
<tr><td><code id="stability_+3A_model.selector">model.selector</code></td>
<td>
<p>Function to perform model selection. Default is
<code><a href="#topic+lasso.firstq">lasso.firstq</a></code>. User supplied function must have at
least three arguments: x (the design matrix), y (the response
vector) and q (the maximal model size). Return value is the index
vector of selected columns. See <code><a href="#topic+lasso.firstq">lasso.firstq</a></code> for an
example. Additional arguments can be passed through
<code>args.model.selector</code>.</p>
</td></tr>
<tr><td><code id="stability_+3A_args.model.selector">args.model.selector</code></td>
<td>
<p>Named list of further arguments for
function <code>model.selector</code>.</p>
</td></tr>
<tr><td><code id="stability_+3A_parallel">parallel</code></td>
<td>
<p>Should parallelization be used? (logical)</p>
</td></tr>
<tr><td><code id="stability_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallelization.</p>
</td></tr>
<tr><td><code id="stability_+3A_verbose">verbose</code></td>
<td>
<p>Should information be printed out while computing (logical).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>selected</code></td>
<td>
<p>Vector of selected predictors.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>Vector of selection frequencies.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Size of fitted models in order to control error rate at
desired level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lukas Meier</p>


<h3>References</h3>

<p>Meinshausen, N. and Bühlmann, P. (2010)
Stability selection (with discussion).
<em>Journal of the Royal Statistical Society: Series B</em> <b>72</b>, 417&ndash;473.
</p>
<p>Bühlmann, P., Kalisch, M. and Meier,
L. (2014) <em>High-dimensional statistics with a view towards
applications in biology</em>. Annual Review of Statistics and
its Applications <b>1</b>, 255&ndash;278</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(100 * 1000), nrow = 100, ncol = 1000)
y &lt;- x[,1] * 2 + x[,2] * 2.5 + rnorm(100)
fit.stab &lt;- stability(x, y, EV = 1)
fit.stab
fit.stab$freq[1:10] ## selection frequency of the first 10 predictors
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
