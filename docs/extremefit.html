<!DOCTYPE html><html><head><title>Help for package extremefit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {extremefit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bandwidth.CV'><p>Choice of the bandwidth by cross validation.</p></a></li>
<li><a href='#bandwidth.grid'><p>Bandwidth Grid</p></a></li>
<li><a href='#Biweight.kernel'><p>Biweight kernel function</p></a></li>
<li><a href='#bootCI'><p>Pointwise confidence intervals by bootstrap</p></a></li>
<li><a href='#bootCI.ts'><p>Pointwise confidence intervals by bootstrap</p></a></li>
<li><a href='#Burr+20Distribution'><p>Burr distribution</p></a></li>
<li><a href='#cox.adapt'><p>Compute the extreme quantile procedure for Cox model</p></a></li>
<li><a href='#CriticalValue'><p>Computation of the critical value in the hill.adapt function</p></a></li>
<li><a href='#dataOyster'>
<p>High-frequency noninvasive valvometry data</p></a></li>
<li><a href='#dataWind'><p>Wind speed for Brest (France)</p></a></li>
<li><a href='#Epa.kernel'><p>Epanechnikov kernel function</p></a></li>
<li><a href='#Gaussian.kernel'><p>Gaussian kernel function</p></a></li>
<li><a href='#goftest'><p>Goodness of fit test statistics</p></a></li>
<li><a href='#goftest.hill.adapt'><p>Goodness of fit test statistics</p></a></li>
<li><a href='#goftest.hill.ts'><p>Goodness of fit test statistics for time series</p></a></li>
<li><a href='#hill'><p>Hill estimator</p></a></li>
<li><a href='#hill.adapt'><p>Compute the extreme quantile procedure</p></a></li>
<li><a href='#hill.ts'><p>Compute the extreme quantile procedure on a time dependent data</p></a></li>
<li><a href='#LoadCurve'><p>Load curve of an habitation</p></a></li>
<li><a href='#Pareto+20Distribution'><p>Pareto distribution</p></a></li>
<li><a href='#Pareto+20mix'><p>Pareto mixture distribution</p></a></li>
<li><a href='#plot.hill'><p>Hill plot</p></a></li>
<li><a href='#plot.hill.adapt'><p>Hill.adapt plot</p></a></li>
<li><a href='#pparetoCP'><p>Pareto change point distribution</p></a></li>
<li><a href='#predict.cox.adapt'><p>Predict the survival or quantile function from the extreme procedure for the Cox model</p></a></li>
<li><a href='#predict.hill'><p>Predict the adaptive survival or quantile function</p></a></li>
<li><a href='#predict.hill.adapt'><p>Predict the adaptive survival or quantile function</p></a></li>
<li><a href='#predict.hill.ts'><p>Predict the adaptive survival or quantile function for a time serie</p></a></li>
<li><a href='#probgrid'><p>Probability grid</p></a></li>
<li><a href='#rburr.dependent'><p>Generate Burr dependent data</p></a></li>
<li><a href='#Rectangular.kernel'><p>Rectangular kernel function</p></a></li>
<li><a href='#Triang.kernel'><p>Triangular kernel function</p></a></li>
<li><a href='#TruncGauss.kernel'><p>Truncated Gaussian kernel function</p></a></li>
<li><a href='#wecdf'><p>Weighted empirical cumulative distribution function</p></a></li>
<li><a href='#wquantile'><p>Weighted quantile</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of Extreme Conditional Quantiles and Probabilities</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-05-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Gilles Durrieu, Ion Grama, Kevin Jaunatre, Quang-Khoai Pham, Jean-Marie
    Tricot</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, R.rsp</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Jaunatre &lt;kevin.jaunatre@hotmail.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extreme value theory, nonparametric kernel estimation, tail
    conditional probabilities, extreme conditional quantile, adaptive estimation,
    quantile regression, survival probabilities.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-03 11:21:32 UTC; kevin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-04 08:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bandwidth.CV'>Choice of the bandwidth by cross validation.</h2><span id='topic+bandwidth.CV'></span>

<h3>Description</h3>

<p>Choose a bandwidth by minimizing the cross validation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidth.CV(X, t, Tgrid, hgrid, pcv = 0.99,
  kernel = TruncGauss.kernel, kpar = NULL, CritVal = 3.6,
  plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth.CV_+3A_x">X</code></td>
<td>
<p>a vector of the observed values.</p>
</td></tr>
<tr><td><code id="bandwidth.CV_+3A_t">t</code></td>
<td>
<p>a vector of time covariates which should have the same length as X.</p>
</td></tr>
<tr><td><code id="bandwidth.CV_+3A_tgrid">Tgrid</code></td>
<td>
<p>a sequence of times used to perform the cross validation (can be any sequence in the interval <code>[min(t) , max(t)]</code> ).</p>
</td></tr>
<tr><td><code id="bandwidth.CV_+3A_hgrid">hgrid</code></td>
<td>
<p>a sequence of values from which the bandwidth is selected.</p>
</td></tr>
<tr><td><code id="bandwidth.CV_+3A_pcv">pcv</code></td>
<td>
<p>a probability value which determines the level of quantiles used to perform the cross validation, with default 0.99.</p>
</td></tr>
<tr><td><code id="bandwidth.CV_+3A_kernel">kernel</code></td>
<td>
<p>a kernel function used to compute the weights in the time domain, with default the truncated gaussian kernel.</p>
</td></tr>
<tr><td><code id="bandwidth.CV_+3A_kpar">kpar</code></td>
<td>
<p>a value for the kernel function parameter, with no default value.</p>
</td></tr>
<tr><td><code id="bandwidth.CV_+3A_critval">CritVal</code></td>
<td>
<p>a critical value associated to the kernel function computed from the function <code>CriticalValue</code>, with default 3.6 corresponding to the truncated Gaussian kernel.</p>
</td></tr>
<tr><td><code id="bandwidth.CV_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, the cross validation function is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence <code class="reqn">hgrid</code> must be geometric. (see <code><a href="#topic+bandwidth.grid">bandwidth.grid</a></code> to generate a geometric grid of bandwidths).
</p>
<p>The value <code class="reqn">pcv</code> should be scalar (vector values are not admitted).
</p>


<h3>Value</h3>

<table>
<tr><td><code>hgrid</code></td>
<td>
<p>the sequence of bandwidth given in input.</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>the values of the cross validation function for <code>hgrid</code>.</p>
</td></tr>
<tr><td><code>h.cv</code></td>
<td>
<p>the bandwidth that minimizes the cross-validation function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Durrieu, G., Grama, I., Jaunatre, K., Pham, Q. and Tricot, J.- M
</p>


<h3>References</h3>

<p>Durrieu, G. and Grama, I. and Pham, Q. and Tricot, J.- M (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bandwidth.grid">bandwidth.grid</a></code> , <code><a href="#topic+CriticalValue">CriticalValue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the data
theta &lt;- function(t){
   0.5+0.25*sin(2*pi*t)
 }
n &lt;- 5000
t &lt;- 1:n/n
Theta &lt;- theta(t)
Data &lt;- NULL
for(i in 1:n){
   Data[i] &lt;- rparetomix(1, a = 1/Theta[i], b = 1/Theta[i]+5, c = 0.75)
 }

#compute the cross validation bandwidth
Tgrid &lt;- seq(0, 1, 0.02) #define a grid to perform the cross validation
hgrid &lt;- bandwidth.grid(0.1, 0.3, 20) #define a grid of bandwidths
## Not run:  #For computation time purpose
  Hcv &lt;- bandwidth.CV(Data, t, Tgrid, hgrid, pcv = 0.99, plot = TRUE)
  #The computing time can be long
  Hcv

## End(Not run)


</code></pre>

<hr>
<h2 id='bandwidth.grid'>Bandwidth Grid</h2><span id='topic+bandwidth.grid'></span>

<h3>Description</h3>

<p>Create either a geometric or an uniform grid of bandwidths between two values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidth.grid(hmin, hmax, length = 20, type = "geometric")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth.grid_+3A_hmin">hmin</code></td>
<td>
<p>the minimum value of the grid.</p>
</td></tr>
<tr><td><code id="bandwidth.grid_+3A_hmax">hmax</code></td>
<td>
<p>the maximum value of the grid.</p>
</td></tr>
<tr><td><code id="bandwidth.grid_+3A_length">length</code></td>
<td>
<p>the length of the grid.</p>
</td></tr>
<tr><td><code id="bandwidth.grid_+3A_type">type</code></td>
<td>
<p>the type of grid, either <code class="reqn">geometric</code> or <code class="reqn">uniform</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The geometric grid is defined by:
</p>
<p style="text-align: center;"><code class="reqn">
  grid(l) = hmin * exp( ( log(hmax)-log(hmin) ) / (length -1) ) ^ l  ,  l = 0 , ... , (length -1)
</code>
</p>



<h3>Value</h3>

<p>Return a geometric or uniform grid of size <code class="reqn">length</code> between <code class="reqn">hmin</code> and <code class="reqn">hmax</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hmin &lt;- 0.05
hmax &lt;- 0.2
length &lt;- 20
(h.geometric &lt;- bandwidth.grid(hmin, hmax, length, type = "geometric"))
(h.uniform &lt;- bandwidth.grid(hmin, hmax, length, type = "uniform"))

</code></pre>

<hr>
<h2 id='Biweight.kernel'>Biweight kernel function</h2><span id='topic+Biweight.kernel'></span>

<h3>Description</h3>

<p>Biweight kernel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Biweight.kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Biweight.kernel_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Biweight kernel:
</p>
<p style="text-align: center;"><code class="reqn">
  K(x) = 15/16 ( 1 - x^2 )^2  (abs(x)&lt;=1)
</code>
</p>

<p>We recommend a critical value of 7 for this kernel function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(function(x) Biweight.kernel(x),-2, 2,
main = " Biweight kernel ")

</code></pre>

<hr>
<h2 id='bootCI'>Pointwise confidence intervals by bootstrap</h2><span id='topic+bootCI'></span>

<h3>Description</h3>

<p>Pointwise quantiles and survival probabilities confidence intervals using bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootCI(X, weights = rep(1, length(X)), probs = 1:(length(X) -
  1)/length(X), xgrid = sort(X), B = 100, alpha = 0.05,
  type = "quantile", CritVal = 10, initprop = 1/10, gridlen = 100,
  r1 = 1/4, r2 = 1/20, plot = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootCI_+3A_x">X</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_probs">probs</code></td>
<td>
<p>used if type = &quot;quantile&quot;, a numeric vector of probabilities with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_xgrid">xgrid</code></td>
<td>
<p>used if type = &quot;survival&quot;, a numeric vector with values in the domain of X.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_b">B</code></td>
<td>
<p>an integer giving the number of bootstrap iterations.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_alpha">alpha</code></td>
<td>
<p>the type 1 error of the bootstrap (1-<code class="reqn">alpha</code>)-confidence interval.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_type">type</code></td>
<td>
<p>type is either &quot;quantile&quot; or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_critval">CritVal</code></td>
<td>
<p>a critical value associated to the kernel function given by <code><a href="#topic+CriticalValue">CriticalValue</a></code>. The default value is 10 corresponding to the rectangular kernel.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_gridlen">gridlen</code>, <code id="bootCI_+3A_initprop">initprop</code>, <code id="bootCI_+3A_r1">r1</code>, <code id="bootCI_+3A_r2">r2</code></td>
<td>
<p>parameters used in the function hill.adapt (see <code><a href="#topic+hill.adapt">hill.adapt</a></code>).</p>
</td></tr>
<tr><td><code id="bootCI_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, the bootstrap confidence interval is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate B samples of <code class="reqn">X</code> with replacement to estimate the quantiles of orders <code class="reqn">probs</code> or the survival probability corresponding to <code class="reqn">xgrid</code>. Determine the bootstrap pointwise (1-<code class="reqn">alpha</code>)-confidence interval for the quantiles or the survival probabilities.
</p>


<h3>Value</h3>

<table>
<tr><td><code>LowBound</code></td>
<td>
<p>the lower bound of the bootstrap (1-<code class="reqn">alpha</code>)-confidence interval.</p>
</td></tr>
<tr><td><code>UppBound</code></td>
<td>
<p>the upper bound of the bootstrap (1-<code class="reqn">alpha</code>)-confidence interval of level.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+hill.adapt">hill.adapt</a></code>,<code><a href="#topic+CriticalValue">CriticalValue</a></code>,<code><a href="#topic+predict.hill.adapt">predict.hill.adapt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- abs(rcauchy(400))
hh &lt;- hill.adapt(X)
probs &lt;- probgrid(0.1, 0.999999, length = 100)
B &lt;- 200
## Not run:  #For computing time purpose
  bootCI(X, weights = rep(1, length(X)), probs = probs, B = B, plot = TRUE)
  xgrid &lt;- sort(sample(X, 100))
  bootCI(X, weights = rep(1, length(X)), xgrid = xgrid, type = "survival", B = B, plot = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='bootCI.ts'>Pointwise confidence intervals by bootstrap</h2><span id='topic+bootCI.ts'></span>

<h3>Description</h3>

<p>Pointwise quantiles and survival probabilities confidence intervals using bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootCI.ts(X, t, Tgrid, h, kernel = TruncGauss.kernel, kpar = NULL,
  prob = 0.99, threshold = quantile(X, 0.99), B = 100,
  alpha = 0.05, type = "quantile", CritVal = 3.6, initprop = 1/10,
  gridlen = 100, r1 = 1/4, r2 = 1/20, plot = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootCI.ts_+3A_x">X</code></td>
<td>
<p>a vector of the observed values.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_t">t</code></td>
<td>
<p>a vector of time covariates which should have the same length as X.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_tgrid">Tgrid</code></td>
<td>
<p>a sequence of times used to perform the cross validation (can be any sequence in the interval <code>[min(t) , max(t)]</code> ).</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_h">h</code></td>
<td>
<p>a bandwidth value (vector values are not admitted).</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_kernel">kernel</code></td>
<td>
<p>a kernel function used to compute the weights in the time domain, with default the truncated gaussian kernel.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_kpar">kpar</code></td>
<td>
<p>a value for the kernel function parameter, with no default value.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_prob">prob</code></td>
<td>
<p>used if type = &quot;quantile&quot;, a scalar value in <code class="reqn">[0,1]</code> which determines the quantile order (vector values are not admitted).</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_threshold">threshold</code></td>
<td>
<p>used if type = &quot;survival&quot;, a scalar value in the domain of X.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_b">B</code></td>
<td>
<p>an integer giving the number of bootstrap iterations.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_alpha">alpha</code></td>
<td>
<p>the type 1 error of the bootstrap (1-<code class="reqn">alpha</code>)-confidence interval.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_type">type</code></td>
<td>
<p>type is either &quot;quantile&quot; or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_critval">CritVal</code></td>
<td>
<p>a critical value associated to the kernel function given by <code><a href="#topic+CriticalValue">CriticalValue</a></code>. The default value is 3.6 corresponding to the truncated Gaussian kernel.</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_gridlen">gridlen</code>, <code id="bootCI.ts_+3A_initprop">initprop</code>, <code id="bootCI.ts_+3A_r1">r1</code>, <code id="bootCI.ts_+3A_r2">r2</code></td>
<td>
<p>parameters used in the function hill.adapt (see <code><a href="#topic+hill.adapt">hill.adapt</a></code>).</p>
</td></tr>
<tr><td><code id="bootCI.ts_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, the bootstrap confidence interval is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each point in <code class="reqn">Tgrid</code>, generate B samples of <code class="reqn">X</code> with replacement to estimate the quantile of order <code class="reqn">prob</code> or the survival probability beyond <code class="reqn">threshold</code>. Determine the bootstrap pointwise (1-<code class="reqn">alpha</code>)-confidence interval for the quantiles or the survival probabilities.
</p>
<p>The kernel implemented in this packages are : Biweight kernel, Epanechnikov kernel, Rectangular kernel, Triangular kernel and the truncated Gaussian kernel.
</p>


<h3>Value</h3>

<table>
<tr><td><code>LowBound</code></td>
<td>
<p>the lower bound of the bootstrap (1-<code class="reqn">alpha</code>)-confidence interval.</p>
</td></tr>
<tr><td><code>UppBound</code></td>
<td>
<p>the upper bound of the bootstrap (1-<code class="reqn">alpha</code>)-confidence interval of level.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The executing time of the function can be time consuming if the B parameter or the sample size are high (B=100 and the sample size = 5000 for example) .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill.ts">hill.ts</a></code>,<code><a href="#topic+predict.hill.ts">predict.hill.ts</a></code>, <code><a href="#topic+Biweight.kernel">Biweight.kernel</a></code>, <code><a href="#topic+Epa.kernel">Epa.kernel</a></code>, <code><a href="#topic+Rectangular.kernel">Rectangular.kernel</a></code>, <code><a href="#topic+Triang.kernel">Triang.kernel</a></code>, <code><a href="#topic+TruncGauss.kernel">TruncGauss.kernel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- function(t){
   0.5+0.25*sin(2*pi*t)
 }
n &lt;- 5000
t &lt;- 1:n/n
Theta &lt;- theta(t)
set.seed(123)
Data &lt;- NULL
for(i in 1:n){
   Data[i] &lt;- rparetomix(1, a = 1/Theta[i], b = 1/Theta[i]+5, c = 0.75)
 }
Tgrid &lt;- seq(1, length(Data)-1, length = 20)/n
h &lt;- 0.1
## Not run:  #For computing time purpose
  bootCI.ts(Data, t, Tgrid, h, kernel = TruncGauss.kernel, kpar = c(sigma = 1),
            CritVal = 3.6, threshold = 2, type = "survival", B = 100, plot = TRUE)
  true.p &lt;- NULL
  for(i in 1:n){
     true.p[i] &lt;- 1-pparetomix(2, a = 1/Theta[i], b = 1/Theta[i]+5, c = 0.75)
   }
  lines(t, true.p, col = "red")
  bootCI.ts(Data, t, Tgrid, h, kernel = TruncGauss.kernel, kpar = c(sigma = 1),
 prob = 0.999, type = "quantile", B = 100, plot = TRUE)
  true.quantile &lt;- NULL
  for(i in 1:n){
     true.quantile[i] &lt;- qparetomix(0.999, a = 1/Theta[i], b = 1/Theta[i]+5, c = 0.75)
   }
  lines(t, log(true.quantile), col = "red")

## End(Not run)


</code></pre>

<hr>
<h2 id='Burr+20Distribution'>Burr distribution</h2><span id='topic+Burr+20Distribution'></span><span id='topic+rburr'></span><span id='topic+dburr'></span><span id='topic+pburr'></span><span id='topic+qburr'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the Burr distribution with <code class="reqn">a</code> and <code class="reqn">k</code> two parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rburr(n, a, k)

dburr(x, a, k)

pburr(q, a, k)

qburr(p, a, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Burr+2B20Distribution_+3A_n">n</code></td>
<td>
<p>a number of observations. If length(n) &gt; 1, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Burr+2B20Distribution_+3A_a">a</code></td>
<td>
<p>a parameter of the burr distribution</p>
</td></tr>
<tr><td><code id="Burr+2B20Distribution_+3A_k">k</code></td>
<td>
<p>a parameter of the burr distribution</p>
</td></tr>
<tr><td><code id="Burr+2B20Distribution_+3A_x">x</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="Burr+2B20Distribution_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="Burr+2B20Distribution_+3A_p">p</code></td>
<td>
<p>a vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cumulative Burr distribution is
</p>
<p style="text-align: center;"><code class="reqn">
  F(x) = 1-( 1 + (x ^ a) ) ^{- k },  x &gt;0,  a &gt;0,  k &gt; 0
</code>
</p>



<h3>Value</h3>

<p>dburr gives the density, pburr gives the distribution function, qburr gives the quantile function, and rburr generates random deviates.
</p>
<p>The length of the result is determined by n for rburr, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>
<p>The numerical arguments other than n are recycled to the length of the result. Only the first elements of the logical arguments are used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(function(x) dburr(x,3,1), 0, 5,ylab="density",
main = " burr density ")

plot(function(x) pburr(x,3,1), 0, 5,ylab="distribution function",
     main = " burr Cumulative ")

plot(function(x) qburr(x,3,1), 0, 1,ylab="quantile",
     main = " burr Quantile ")

#generate a sample of burr distribution of size n
n &lt;- 100
x &lt;- rburr(n, 1, 1)


</code></pre>

<hr>
<h2 id='cox.adapt'>Compute the extreme quantile procedure for Cox model</h2><span id='topic+cox.adapt'></span>

<h3>Description</h3>

<p>Compute the extreme quantile procedure for Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.adapt(X, cph, cens = rep(1, length(X)), data = rep(0, length(X)),
  initprop = 1/10, gridlen = 100, r1 = 1/4, r2 = 1/20,
  CritVal = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox.adapt_+3A_x">X</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="cox.adapt_+3A_cph">cph</code></td>
<td>
<p>an output object of the function coxph from the package survival.</p>
</td></tr>
<tr><td><code id="cox.adapt_+3A_cens">cens</code></td>
<td>
<p>a binary vector corresponding to the censored values.</p>
</td></tr>
<tr><td><code id="cox.adapt_+3A_data">data</code></td>
<td>
<p>a data frame containing the covariates values.</p>
</td></tr>
<tr><td><code id="cox.adapt_+3A_initprop">initprop</code></td>
<td>
<p>the initial proportion at which we begin to test the model.</p>
</td></tr>
<tr><td><code id="cox.adapt_+3A_gridlen">gridlen</code></td>
<td>
<p>the length of the grid for which the test is done.</p>
</td></tr>
<tr><td><code id="cox.adapt_+3A_r1">r1</code></td>
<td>
<p>a proportion value of the data from the right that we skip in the test statistic.</p>
</td></tr>
<tr><td><code id="cox.adapt_+3A_r2">r2</code></td>
<td>
<p>a proportion value of the data from the left that we skip in the test statistic.</p>
</td></tr>
<tr><td><code id="cox.adapt_+3A_critval">CritVal</code></td>
<td>
<p>the critical value assiociated to procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of data, a vector of censorship and a data frame of covariates, this function compute the adaptive procedure described in Grama and Jaunatre (2018).
</p>
<p>We suppose that the data are in the domain of attraction of the Frechet-Pareto type and that the hazard are somewhat proportionals. Otherwise, the procedure will not work.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the coefficients of the coxph procedure.</p>
</td></tr>
<tr><td><code>Xsort</code></td>
<td>
<p>the sorted vector of the data.</p>
</td></tr>
<tr><td><code>sortcens</code></td>
<td>
<p>the sorted vector of the censorship.</p>
</td></tr>
<tr><td><code>sortebz</code></td>
<td>
<p>the sorted matrix of the covariates.</p>
</td></tr>
<tr><td><code>ch</code></td>
<td>
<p>the Hill estimator associated to the baseline function.</p>
</td></tr>
<tr><td><code>TestingGrid</code></td>
<td>
<p>the grid used for the statistic test.</p>
</td></tr>
<tr><td><code>TS</code>, <code>TS1</code>, <code>TS.max</code>, <code>TS1.max</code></td>
<td>
<p>respectively the test statistic, the likelihood ratio test, the maximum of the test statistic and the maximum likelihood ratio test.</p>
</td></tr>
<tr><td><code>window1</code>, <code>window2</code></td>
<td>
<p>indices from which the threshold was chosen.</p>
</td></tr>
<tr><td><code>Paretodata</code></td>
<td>
<p>logical: if TRUE the distribution of the data is a Pareto distribution.</p>
</td></tr>
<tr><td><code>Paretotail</code></td>
<td>
<p>logical: if TRUE a Pareto tail was detected.</p>
</td></tr>
<tr><td><code>madapt</code></td>
<td>
<p>the first indice of the TestingGrid for which the test statistic exceeds the critical value.</p>
</td></tr>
<tr><td><code>kadapt</code></td>
<td>
<p>the adaptive indice of the threshold.</p>
</td></tr>
<tr><td><code>kadapt.maxlik</code></td>
<td>
<p>the maximum likelihood corresponding to the adaptive threshold in the selected testing grid.</p>
</td></tr>
<tr><td><code>hadapt</code></td>
<td>
<p>the adaptive weighted parameter of the Pareto distribution after the threshold.</p>
</td></tr>
<tr><td><code>Xadapt</code></td>
<td>
<p>the adaptive threshold.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ion Grama, Kevin Jaunatre
</p>


<h3>References</h3>

<p>Grama, I. and Jaunatre, K. (2018). Estimation of Extreme Survival Probabilities with Cox Model. arXiv:1805.01638.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
data(bladder)

X &lt;- bladder2$stop-bladder2$start
Z &lt;- as.matrix(bladder2[, c(2:4, 8)])
delta &lt;- bladder2$event

ord &lt;- order(X)
X &lt;- X[ord]
Z &lt;- Z[ord,]
delta &lt;- delta[ord]

cph&lt;-coxph(Surv(X, delta) ~ Z)

ca &lt;- cox.adapt(X, cph, delta, Z)

</code></pre>

<hr>
<h2 id='CriticalValue'>Computation of the critical value in the hill.adapt function</h2><span id='topic+CriticalValue'></span>

<h3>Description</h3>

<p>For a given kernel function, compute the critical value (CritVal) of the test statistic in the hill.adapt function by Monte-Carlo simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CriticalValue(NMC, n, kernel = TruncGauss.kernel, kpar = NULL,
  prob = 0.95, gridlen = 100, initprop = 0.1, r1 = 0.25,
  r2 = 0.05, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CriticalValue_+3A_nmc">NMC</code></td>
<td>
<p>the number of Monte-Carlo simulations.</p>
</td></tr>
<tr><td><code id="CriticalValue_+3A_n">n</code></td>
<td>
<p>the sample size.</p>
</td></tr>
<tr><td><code id="CriticalValue_+3A_kernel">kernel</code></td>
<td>
<p>a kernel function for which the critical value is computed. The available kernel functions are Epanechnikov, Triangular, Truncated Gaussian, Biweight and Rectangular. The truncated gaussian kernel is by default.</p>
</td></tr>
<tr><td><code id="CriticalValue_+3A_kpar">kpar</code></td>
<td>
<p>a value for the kernel function parameter, with no default value.</p>
</td></tr>
<tr><td><code id="CriticalValue_+3A_prob">prob</code></td>
<td>
<p>a vector of type 1 errors.</p>
</td></tr>
<tr><td><code id="CriticalValue_+3A_gridlen">gridlen</code>, <code id="CriticalValue_+3A_initprop">initprop</code>, <code id="CriticalValue_+3A_r1">r1</code>, <code id="CriticalValue_+3A_r2">r2</code></td>
<td>
<p>parameters used in the function hill.adapt (see <code><a href="#topic+hill.adapt">hill.adapt</a></code>).</p>
</td></tr>
<tr><td><code id="CriticalValue_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, the empirical cummulative distribution function and the critical values are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the type 1 errors <code class="reqn">prob</code>, this function returns the critical values.
</p>


<h3>References</h3>

<p>Durrieu, G. and Grama, I. and Pham, Q. and Tricot, J.- M (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill.adapt">hill.adapt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
NMC &lt;- 500
prob &lt;- c(0.99)
## Not run:  #For computing time purpose
  CriticalValue(NMC, n, TruncGauss.kernel, kpar = c(sigma = 1), prob, gridlen = 100 ,
                initprop = 1/10, r1 = 1/4, r2 = 1/20, plot = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='dataOyster'>
High-frequency noninvasive valvometry data
</h2><span id='topic+dataOyster'></span>

<h3>Description</h3>

<p>The data frame provides the opening amplitude of one oyster's shells (in mm) with respect to the time (in hours). The opening velocity of the oyster's shells is also given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataOyster")</code></pre>


<h3>Format</h3>

<p>A list of 2 elements.
</p>

<dl>
<dt><code>$data : a data frame with 54000 observations for 3 variables</code></dt><dd>
<dl>
<dt><code>time</code></dt><dd><p>Time of measurement (in hours).</p>
</dd>
<dt><code>opening</code></dt><dd><p>opening amplitude between the two shells (in mm).</p>
</dd>
<dt><code>velocity</code></dt><dd><p>a numeric vector (in mm/s). Negative values correspond to the opening velocity of the shells and positive values to the closing velocity of the shells.</p>
</dd></dl>
</dd>
<dt><code>$Tgrid : A grid of time to perform the procedure.</code></dt><dd></dd>
</dl>
 


<h3>References</h3>

<p>Durrieu, G., Grama, I., Pham, Q. &amp; Tricot, J.- M (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>
<p>Azais, R., Coudret R. &amp; Durrieu G. (2014). A hidden renewal model for monitoring aquatic systems biosensors. Environmetrics, 25.3, 189-199.
</p>
<p>Schmitt, F. G., De Rosa, M., Durrieu, G., Sow, M., Ciret, P., Tran, D., &amp; Massabuau, J. C. (2011). Statistical study of bivalve high frequency microclosing behavior: Scaling properties and shot noise analysis. International Journal of Bifurcation and Chaos, 21(12), 3565-3576.
</p>
<p>Sow, M., Durrieu, G., Briollais, L., Ciret, P., &amp; Massabuau, J. C. (2011). Water quality assessment by means of HFNI valvometry and high-frequency data modeling. Environmental monitoring and assessment, 182(1-4), 155-170.
</p>
<p>website : http://molluscan-eye.epoc.u-bordeaux1.fr/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("dataOyster")
Velocity &lt;- dataOyster$data[, 3]
time &lt;- dataOyster$data[, 1]
plot(time, Velocity, type = "l", xlab = "time (hour)",
      ylab = "Velocity (mm/s)")

Tgrid &lt;- seq(0, 24, 0.05) 
#Grid with positive velocity
new.Tgrid &lt;- dataOyster$Tgrid

X &lt;- Velocity + (-min(Velocity)) #We shift the data to be positive

## Not run:  #For computing time purpose
#We find the h by minimizing the cross validation function 

hgrid &lt;- bandwidth.grid(0.05, 0.5, 50, type = "geometric")


#H &lt;- bandwidth.CV(X, time, new.Tgrid, hgrid,
#                 TruncGauss.kernel, kpar = c(sigma = 1),
#                 pcv = 0.99, CritVal = 3.4, plot = TRUE)
#hcv &lt;- H$h.cv

hcv &lt;- 0.2981812
#we use our method with the h found previously
TS.Oyster &lt;- hill.ts(X, t = time, new.Tgrid, h = hcv, 
                   TruncGauss.kernel, kpar = c(sigma = 1),
                   CritVal = 3.4)
          
plot(time, Velocity, type = "l", ylim = c(-0.6, 1),
    main = "Extreme quantiles estimator",
    xlab = "Time (hour)", ylab = "Velocity (mm/s)")
pgrid &lt;- c(0.999)
pred.quant.Oyster &lt;- predict(TS.Oyster, newdata = pgrid, type = "quantile")

quant0.999 &lt;- rep(0, length(Tgrid))
quant0.999[match(new.Tgrid, Tgrid)] &lt;- 
          as.numeric(pred.quant.Oyster$y)-
          (-min(Velocity))
lines(Tgrid, quant0.999, col = "magenta")   



## End(Not run)
</code></pre>

<hr>
<h2 id='dataWind'>Wind speed for Brest (France)</h2><span id='topic+dataWind'></span>

<h3>Description</h3>

<p>The data frame provides the wind speed of Brest from 1976 to 2005.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataWind")</code></pre>


<h3>Format</h3>

<p>The data is the wind speed in meters per second (m/s) every day from 1976 to 2005.
</p>

<dl>
<dt><code>Year</code></dt><dd><p>The year of the measure.</p>
</dd>
<dt><code>Month</code></dt><dd><p>The month of the measure.</p>
</dd>
<dt><code>Day</code></dt><dd><p>the day of the measure.</p>
</dd>
<dt><code>Speed</code></dt><dd><p>The wind speed in meters per second</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
library(extremefit)
data("dataWind")
attach(dataWind)

pred &lt;- NULL
for(m in 1:12){
  indices &lt;- which(Month == m)
  X &lt;- Speed[indices]*60*60/1000
  H &lt;- hill.adapt(X)
  pred[m] &lt;- predict(H, newdata = 100, type = "survival")$y
}
plot(pred, ylab = "Estimated survival probability", xlab = "Month")

</code></pre>

<hr>
<h2 id='Epa.kernel'>Epanechnikov kernel function</h2><span id='topic+Epa.kernel'></span>

<h3>Description</h3>

<p>Epanechnikov kernel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Epa.kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Epa.kernel_+3A_x">x</code></td>
<td>
<p>vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Epanechnikov kernel:
</p>
<p style="text-align: center;"><code class="reqn">
  K(x) = 3/4 ( 1 - x^2 ) (abs(x)&lt;=1)
</code>
</p>

<p>We recommend a critical value of 6.1 for this kernel function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(function(x) Epa.kernel(x), -2, 2, ylab = "Epanechnikov kernel function")

</code></pre>

<hr>
<h2 id='Gaussian.kernel'>Gaussian kernel function</h2><span id='topic+Gaussian.kernel'></span>

<h3>Description</h3>

<p>Gaussian kernel function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian.kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussian.kernel_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gaussian Kernel with the value of standard deviation equal to 1/3.
</p>
<p style="text-align: center;"><code class="reqn">
  K(x) = (1/{(1/3)*sqrt(2 \pi)}  exp(-(3*x)^2/2)) (abs(x) &lt;= 1)
</code>
</p>

<p>We recommend a critical value of 8.3 for this kernel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(function(x) Gaussian.kernel(x), -2, 2,
main = " Gaussian kernel")

</code></pre>

<hr>
<h2 id='goftest'>Goodness of fit test statistics</h2><span id='topic+goftest'></span>

<h3>Description</h3>

<p>goftest is a generic function whose application depends on the class of its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goftest(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goftest_+3A_object">object</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="goftest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by goftest depends on the class of its argument. See the documentation of the particular methods for details of what is produced by that method.
</p>


<h3>References</h3>

<p>Grama, I. and Spokoiny, V. (2008). Statistics of extremes by oracle estimation. Ann. of Statist., 36, 1619-1648.
</p>
<p>Durrieu, G. and Grama, I. and Pham, Q. and Tricot, J.- M (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+goftest.hill.adapt">goftest.hill.adapt</a></code>, <code><a href="#topic+goftest.hill.ts">goftest.hill.ts</a></code>
</p>

<hr>
<h2 id='goftest.hill.adapt'>Goodness of fit test statistics</h2><span id='topic+goftest.hill.adapt'></span>

<h3>Description</h3>

<p>Give the results of the goodness of fit tests for testing the null hypothesis that the tail is fitted by a Pareto distribution, starting from the adaptive threshold, against the Pareto change point distribution for all possible change points (for more details see pages 447 and 448 of Durrieu et al. (2015)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hill.adapt'
goftest(object, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goftest.hill.adapt_+3A_object">object</code></td>
<td>
<p>output of the function hill.adapt.</p>
</td></tr>
<tr><td><code id="goftest.hill.adapt_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, the test statistics are plotted.</p>
</td></tr>
<tr><td><code id="goftest.hill.adapt_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>TS.window</code></td>
<td>
<p>the test statistic inside the window. (pages 447 and 448 of Durrieu et al.(2015))</p>
</td></tr>
<tr><td><code>TS</code></td>
<td>
<p>the test statistic.</p>
</td></tr>
<tr><td><code>CritVal</code></td>
<td>
<p>the critical value of the test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Grama, I. and Spokoiny, V. (2008). Statistics of extremes by oracle estimation. Ann. of Statist., 36, 1619-1648.
</p>
<p>Durrieu, G. and Grama, I. and Pham, Q. and Tricot, J.- M (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill.adapt">hill.adapt</a></code>, <code><a href="#topic+goftest">goftest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- abs(rcauchy(100))
HH &lt;- hill.adapt(x, weights=rep(1, length(x)), initprop = 0.1,
               gridlen = 100 , r1 = 0.25, r2 = 0.05, CritVal=10)

#the critical value 10 is assiociated to the rectangular kernel.

goftest(HH, plot = TRUE)

# we observe that for this data, the null hypothesis that the tail
# is fitted by a Pareto distribution is not rejected as the maximal
# value in the graph does not exceed the critical value.


</code></pre>

<hr>
<h2 id='goftest.hill.ts'>Goodness of fit test statistics for time series</h2><span id='topic+goftest.hill.ts'></span>

<h3>Description</h3>

<p>Give the results of the goodness of fit test for testing the null hypothesis that the tail is fitted by a Pareto distribution starting from the adaptive threshold (for more details see pages 447 and 448 of Durrieu et al. (2015)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hill.ts'
goftest(object, X, t, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goftest.hill.ts_+3A_object">object</code></td>
<td>
<p>output of the hill.ts function.</p>
</td></tr>
<tr><td><code id="goftest.hill.ts_+3A_x">X</code></td>
<td>
<p>a vector of the observed values.</p>
</td></tr>
<tr><td><code id="goftest.hill.ts_+3A_t">t</code></td>
<td>
<p>a vector of time covariates which should have the same length as X.</p>
</td></tr>
<tr><td><code id="goftest.hill.ts_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, the test statistic are plotted.</p>
</td></tr>
<tr><td><code id="goftest.hill.ts_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>TS.window</code></td>
<td>
<p>the maximum value of test statistics inside the window for each t in Tgrid (see help(hill.ts) ).</p>
</td></tr>
<tr><td><code>TS.max</code></td>
<td>
<p>the maximum value of test statistics for each t in Tgrid (see help(hill.ts) ).</p>
</td></tr>
<tr><td><code>CritVal</code></td>
<td>
<p>the critical value of the test.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Grama, I. and Spokoiny, V. (2008). Statistics of extremes by oracle estimation. Ann. of Statist., 36, 1619-1648.
</p>
<p>Durrieu, G. and Grama, I. and Pham, Q. and Tricot, J.- M (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill.ts">hill.ts</a></code>, <code><a href="#topic+goftest">goftest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta&lt;-function(t){0.5+0.25*sin(2*pi*t)}
n&lt;-5000
t&lt;-1:n/n
Theta&lt;-theta(t)
Data&lt;-NULL
Tgrid&lt;-seq(0.01,0.99,0.01)
#example with fixed bandwidth
for(i in 1:n){Data[i]&lt;-rparetomix(1,a=1/Theta[i],b=5/Theta[i]+5,c=0.75,precision=10^(-5))}
## Not run:  #For computing time purpose
  #example
  hgrid &lt;- bandwidth.grid(0.009, 0.2, 20, type = "geometric")
  TgridCV &lt;- seq(0.01, 0.99, 0.1)
  hcv &lt;- bandwidth.CV(Data, t, TgridCV, hgrid, pcv = 0.99,
         TruncGauss.kernel, kpar = c(sigma = 1), CritVal = 3.6, plot = TRUE)

  Tgrid &lt;- seq(0.01,0.99,0.01)
  hillTs &lt;- hill.ts(Data, t, Tgrid, h = hcv$h.cv, TruncGauss.kernel, kpar = c(sigma = 1),
                   CritVal = 3.6, gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)
  goftest(hillTs, Data, t, plot = TRUE)

  # we observe that for this data, the null hypothesis that the tail
  # is fitted by a Pareto distribution is not rejected
  # for all points on the Tgrid


## End(Not run)


</code></pre>

<hr>
<h2 id='hill'>Hill estimator</h2><span id='topic+hill'></span>

<h3>Description</h3>

<p>Compute the weighted Hill estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hill(X, weights = rep(1, length(X)), grid = X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hill_+3A_x">X</code></td>
<td>
<p>a vector of data.</p>
</td></tr>
<tr><td><code id="hill_+3A_weights">weights</code></td>
<td>
<p>a vector of weights assiociated to <code class="reqn">x</code>.</p>
</td></tr>
<tr><td><code id="hill_+3A_grid">grid</code></td>
<td>
<p>a vector of values for which the Hill estimator is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the weighted Hill estimator for vectors <code class="reqn">grid</code>, data and weights (see references below).
</p>


<h3>Value</h3>

<table>
<tr><td><code>xsort</code></td>
<td>
<p>the sorted data.</p>
</td></tr>
<tr><td><code>wsort</code></td>
<td>
<p>the weights assiociated to <code class="reqn">xsort</code>.</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>the grid for which the Hill estimator is computed.</p>
</td></tr>
<tr><td><code>hill</code></td>
<td>
<p>the Hill estimators.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ion Grama
</p>


<h3>References</h3>

<p>Grama, I. and Spokoiny, V. (2008). Statistics of extremes by oracle estimation. Ann. of Statist., 36, 1619-1648.
</p>
<p>Durrieu, G. and Grama, I. and Pham, Q. and Tricot, J.- M (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>
<p>Hill, B.M. (1975). A simple general approach to inference about the tail of a distribution. Annals of Statistics, 3, 1163-1174.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- abs(rcauchy(100))
weights &lt;- rep(1, length(X))
wh &lt;- hill(X, w = weights)
</code></pre>

<hr>
<h2 id='hill.adapt'>Compute the extreme quantile procedure</h2><span id='topic+hill.adapt'></span>

<h3>Description</h3>

<p>Compute the extreme quantile procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hill.adapt(X, weights = rep(1, length(X)), initprop = 1/10,
  gridlen = 100, r1 = 1/4, r2 = 1/20, CritVal = 10, plot = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hill.adapt_+3A_x">X</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="hill.adapt_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weigths associated to the vector <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="hill.adapt_+3A_initprop">initprop</code></td>
<td>
<p>the initial proportion at which we begin to test the model.</p>
</td></tr>
<tr><td><code id="hill.adapt_+3A_gridlen">gridlen</code></td>
<td>
<p>the length of the grid for which the test is done.</p>
</td></tr>
<tr><td><code id="hill.adapt_+3A_r1">r1</code></td>
<td>
<p>a proportion value of the data from the right that we skip in the test statistic.</p>
</td></tr>
<tr><td><code id="hill.adapt_+3A_r2">r2</code></td>
<td>
<p>a proportion value of the data from the left that we skip in the test statistic.</p>
</td></tr>
<tr><td><code id="hill.adapt_+3A_critval">CritVal</code></td>
<td>
<p>the critical value assiociated to the weights.</p>
</td></tr>
<tr><td><code id="hill.adapt_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code>, the results are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of data and assiociated weights, this function compute the adaptive procedure described in Grama and Spokoiny (2008) and Durrieu et al. (2015).
</p>
<p>We suppose that the data are in the domain of attraction of the Frechet-Pareto type. Otherwise, the procedure will not work.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Xsort</code></td>
<td>
<p>the sorted vector of the data.</p>
</td></tr>
<tr><td><code>sortweights</code></td>
<td>
<p>the weights associated to Xsort.</p>
</td></tr>
<tr><td><code>wh</code></td>
<td>
<p>the weighted Hill estimator associated to X (output of the function hill).</p>
</td></tr>
<tr><td><code>TestingGrid</code></td>
<td>
<p>the grid used for the statistic test.</p>
</td></tr>
<tr><td><code>TS</code>, <code>TS1</code>, <code>TS.max</code>, <code>TS1.max</code></td>
<td>
<p>respectively the test statistic, the likelihood ratio test, the maximum of the test statistic and the maximum likelihood ratio test.</p>
</td></tr>
<tr><td><code>Paretodata</code></td>
<td>
<p>logical: if TRUE the distribution of the data is a Pareto distribution.</p>
</td></tr>
<tr><td><code>Paretotail</code></td>
<td>
<p>logical: if TRUE a Pareto tail was detected.</p>
</td></tr>
<tr><td><code>madapt</code></td>
<td>
<p>the first indice of the TestingGrid for which the test statistic exceeds the critical value.</p>
</td></tr>
<tr><td><code>kadapt</code></td>
<td>
<p>the adaptive indice of the threshold.</p>
</td></tr>
<tr><td><code>kadapt.maxlik</code></td>
<td>
<p>the maximum likelihood corresponding to the adaptive threshold in the selected testing grid.</p>
</td></tr>
<tr><td><code>hadapt</code></td>
<td>
<p>the adaptive weighted parameter of the Pareto distribution after the threshold.</p>
</td></tr>
<tr><td><code>Xadapt</code></td>
<td>
<p>the adaptive threshold.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ion Grama
</p>


<h3>References</h3>

<p>Grama, I. and Spokoiny, V. (2008). Statistics of extremes by oracle estimation. Ann. of Statist., 36, 1619-1648.
</p>
<p>Durrieu, G. and Grama, I. and Pham, Q. and Tricot, J.- M. (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>
<p>Durrieu, G. and Grama, I. and Jaunatre, K. and Pham, Q.-K. and Tricot, J.-M. (2018). extremefit: A Package for Extreme Quantiles. Journal of Statistical Software, 87, 1&ndash;20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- abs(rcauchy(100))
HH &lt;- hill.adapt(x, weights=rep(1, length(x)), initprop = 0.1,
               gridlen = 100 , r1 = 0.25, r2 = 0.05, CritVal=10,plot=TRUE)
#the critical value 10 is assiociated to the rectangular kernel.
HH$Xadapt # is the adaptive threshold
HH$hadapt # is the adaptive parameter of the Pareto distribution

</code></pre>

<hr>
<h2 id='hill.ts'>Compute the extreme quantile procedure on a time dependent data</h2><span id='topic+hill.ts'></span><span id='topic+print.hill.ts'></span>

<h3>Description</h3>

<p>Compute the function hill.adapt on time dependent data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hill.ts(X, t, Tgrid = seq(min(t), max(t), length = 10), h,
  kernel = TruncGauss.kernel, kpar = NULL, CritVal = 3.6,
  gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)

## S3 method for class 'hill.ts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hill.ts_+3A_x">X</code></td>
<td>
<p>a vector of the observed values.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_t">t</code></td>
<td>
<p>a vector of time covariates which should have the same length as X.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_tgrid">Tgrid</code></td>
<td>
<p>a grid of time (can be any sequence in the interval <code>[min(t) , max(t)]</code> ).</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_h">h</code></td>
<td>
<p>a bandwidth value (vector values are not admitted).</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_kernel">kernel</code></td>
<td>
<p>a kernel function used to compute the weights in the time domain, with default the truncated Gaussian kernel.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_kpar">kpar</code></td>
<td>
<p>a value for the kernel function parameter, with no default value.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_critval">CritVal</code></td>
<td>
<p>a critical value associated to the kernel function given by <code><a href="#topic+CriticalValue">CriticalValue</a></code>. The default value is 3.6 corresponding to the truncated Gaussian kernel.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_gridlen">gridlen</code></td>
<td>
<p>the gridlen parameter used in the function hill.adapt. The length of the grid for which the test will be done.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_initprop">initprop</code></td>
<td>
<p>the initprop parameter used in the function hill.adapt. The initial proportion at which we will begin to test the model.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_r1">r1</code></td>
<td>
<p>the r1 parameter used in the function hill.adapt. The proportion from the right that we will skip in the test statistic.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_r2">r2</code></td>
<td>
<p>the r2 parameter used in the function hill.adapt. The proportion from the left that we will skip in the test statistic.</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_x">x</code></td>
<td>
<p>the result of the hill.ts function</p>
</td></tr>
<tr><td><code id="hill.ts_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given time serie and kernel function, the function hill.ts will give the results of the adaptive procedure for each <code class="reqn">t</code>. The adaptive procedure is described in Durrieu et al. (2005).
</p>
<p>The kernel implemented in this packages are : Biweight kernel, Epanechnikov kernel, Rectangular kernel, Triangular kernel and the truncated Gaussian kernel.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Tgrid</code></td>
<td>
<p>the given vector <code class="reqn">Tgrid</code>.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>the given value <code class="reqn">h</code>.</p>
</td></tr>
<tr><td><code>Threshold</code></td>
<td>
<p>the adaptive threshold <code class="reqn">\tau</code> for each <code class="reqn">t</code> in <code class="reqn">Tgrid</code>.</p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>the adaptive estimator of <code class="reqn">\theta</code> for each <code class="reqn">t</code> in <code class="reqn">Tgrid</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Durrieu, G. and Grama, I. and Pham, Q. and Tricot, J.- M (2015). Nonparametric adaptive estimator of extreme conditional tail probabilities quantiles. Extremes, 18, 437-478.
</p>
<p>Durrieu, G. and Grama, I. and Jaunatre, K. and Pham, Q.-K. and Tricot, J.-M. (2018). extremefit: A Package for Extreme Quantiles. Journal of Statistical Software, 87, 1&ndash;20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill.adapt">hill.adapt</a></code>, <code><a href="#topic+Biweight.kernel">Biweight.kernel</a></code>, <code><a href="#topic+Epa.kernel">Epa.kernel</a></code>, <code><a href="#topic+Rectangular.kernel">Rectangular.kernel</a></code>, <code><a href="#topic+Triang.kernel">Triang.kernel</a></code>, <code><a href="#topic+TruncGauss.kernel">TruncGauss.kernel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
theta &lt;- function(t){
   0.5+0.25*sin(2*pi*t)
 }
n &lt;- 5000
t &lt;- 1:n/n
Theta &lt;- theta(t)
Data &lt;- NULL
Tgrid &lt;- seq(0.01, 0.99, 0.01)
#example with fixed bandwidth
## Not run:  #For computing time purpose
  for(i in 1:n){
     Data[i] &lt;- rparetomix(1, a = 1/Theta[i], b = 5/Theta[i]+5, c = 0.75, precision = 10^(-5))
   }

  #example
  hgrid &lt;- bandwidth.grid(0.009, 0.2, 20, type = "geometric")
  TgridCV &lt;- seq(0.01, 0.99, 0.1)
  hcv &lt;- bandwidth.CV(Data, t, TgridCV, hgrid, pcv = 0.99, TruncGauss.kernel,
                     kpar = c(sigma = 1), CritVal = 3.6, plot = TRUE)

  Tgrid &lt;- seq(0.01, 0.99, 0.01)
  hillTs &lt;- hill.ts(Data, t, Tgrid, h = hcv$h.cv, kernel = TruncGauss.kernel,
             kpar = c(sigma = 1), CritVal = 3.6,gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)
  plot(hillTs$Tgrid, hillTs$Theta, xlab = "t", ylab = "Estimator of theta")
  lines(t, Theta, col = "red")


## End(Not run)


</code></pre>

<hr>
<h2 id='LoadCurve'>Load curve of an habitation</h2><span id='topic+LoadCurve'></span>

<h3>Description</h3>

<p>The data frame provides electric consumption of an habitation in France over one month.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LoadCurve")</code></pre>


<h3>Format</h3>

<p>The data is the electric consumption of an habitation in Kilovolt-amps (kVA) every 10 minutes during one month. The habitation has a contract that allows a maximum power of 6 kVA.A list of 2 elements.
</p>

<dl>
<dt><code>$data : a data frame with 24126 observations for 2 variables</code></dt><dd>

<dl>
<dt><code>Time</code></dt><dd><p>the number of day since the 1st of January, 1970.</p>
</dd>
<dt><code>Value</code></dt><dd><p>the value of the electric consumtion in kVA.</p>
</dd>
</dl>
</dd>
<dt><code>$Tgrid : A grid of time to perform the procedure.</code></dt><dd></dd>
</dl>
 


<h3>Source</h3>

<p>Electricite Reseau Distribution France</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("LoadCurve")

X&lt;-LoadCurve$data$Value
days&lt;-LoadCurve$data$Time
Tgrid &lt;- seq(min(days), max(days), length = 400)
new.Tgrid &lt;- LoadCurve$Tgrid
## Not run:  #For computing time purpose
# Choice of the bandwidth by cross validation. 
# We choose the truncated Gaussian kernel and the critical value 
# of the goodness-of-fit test 3.4. 
# As the computing time is high, we give the value of the bandwidth.

#hgrid &lt;- bandwidth.grid(0.8, 5, 60)
#hcv&lt;-bandwidth.CV(X=X, t=days, new.Tgrid, hgrid, pcv = 0.99,
#                 kernel = TruncGauss.kernel, CritVal = 3.4, plot = FALSE)
#h.cv &lt;- hcv$h.cv

h.cv &lt;- 3.444261
HH&lt;-hill.ts(X, days, new.Tgrid, h=h.cv, kernel = TruncGauss.kernel, CritVal = 3.4)

Quant&lt;-rep(NA,length(Tgrid))
Quant[match(new.Tgrid, Tgrid)]&lt;-as.numeric(predict(HH, 
            newdata = 0.99, type = "quantile")$y)
            
Date&lt;-as.POSIXct(days*86400, origin = "1970-01-01",
                 tz = "Europe/Paris")
plot(Date, X/1000, ylim = c(0, 8),
      type = "l", ylab = "Electric consumption (kVA)", xlab = "Time")

lines(as.POSIXlt((Tgrid)*86400, origin = "1970-01-01",
                 tz = "Europe/Paris"), Quant/1000, col = "red")

## End(Not run)
</code></pre>

<hr>
<h2 id='Pareto+20Distribution'>Pareto distribution</h2><span id='topic+Pareto+20Distribution'></span><span id='topic+ppareto'></span><span id='topic+dpareto'></span><span id='topic+qpareto'></span><span id='topic+rpareto'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the Pareto distribution where <code class="reqn">a</code>, <code class="reqn">loc</code> and <code class="reqn">scale</code> are respectively the shape, the location and the scale parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppareto(q, a = 1, loc = 0, scale = 1)

dpareto(x, a = 1, loc = 0, scale = 1)

qpareto(p, a = 1, loc = 0, scale = 1)

rpareto(n, a = 1, loc = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pareto+2B20Distribution_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto+2B20Distribution_+3A_a">a</code></td>
<td>
<p>a vector of shape parameter of the Pareto distribution.</p>
</td></tr>
<tr><td><code id="Pareto+2B20Distribution_+3A_loc">loc</code></td>
<td>
<p>a vector of location parameter of the Pareto distribution.</p>
</td></tr>
<tr><td><code id="Pareto+2B20Distribution_+3A_scale">scale</code></td>
<td>
<p>a vector of scale parameter of the Pareto distribution.</p>
</td></tr>
<tr><td><code id="Pareto+2B20Distribution_+3A_x">x</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto+2B20Distribution_+3A_p">p</code></td>
<td>
<p>a vector of probabilities.</p>
</td></tr>
<tr><td><code id="Pareto+2B20Distribution_+3A_n">n</code></td>
<td>
<p>a number of observations. If length(n) &gt; 1, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">shape</code>, <code class="reqn">loc</code> or <code class="reqn">scale</code> parameters are not specified, the respective default values are <code class="reqn">1</code>, <code class="reqn">0</code> and <code class="reqn">1</code>.
</p>
<p>The cumulative Pareto distribution is
</p>
<p style="text-align: center;"><code class="reqn">
  F(x) = 1- ((x-loc)/scale) ^ {-a},  x &gt; loc,  a &gt; 0, scale &gt; 0
</code>
</p>

<p>where <code class="reqn">a</code> is the shape of the distribution.
</p>
<p>The density of the Pareto distribution is
</p>
<p style="text-align: center;"><code class="reqn">
  f(x) = (((x-loc)/scale)^( - a - 1) * a/scale) * (x-loc &gt;= scale),  x &gt; loc,  a &gt; 0, scale &gt; 0
</code>
</p>



<h3>Value</h3>

<p>dpareto gives the density, ppareto gives the distribution function, qpareto gives the quantile function, and rpareto generates random deviates.
</p>
<p>The length of the result is determined by n for rpareto, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>
<p>The numerical arguments other than n are recycled to the length of the result. Only the first elements of the logical arguments are used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(3,1))
plot(function(x) dpareto(x), 1, 5,ylab="density",
     main = " Pareto density ")

plot(function(x) ppareto(x), 1, 5,ylab="distribution function",
     main = " Pareto Cumulative ")

plot(function(x) qpareto(x), 0, 1,ylab="quantile",
     main = " Pareto Quantile ")

#generate a sample of pareto distribution of size n
n &lt;- 100
x &lt;- rpareto(n)

</code></pre>

<hr>
<h2 id='Pareto+20mix'>Pareto mixture distribution</h2><span id='topic+Pareto+20mix'></span><span id='topic+pparetomix'></span><span id='topic+dparetomix'></span><span id='topic+qparetomix'></span><span id='topic+rparetomix'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the Pareto mixture distribution with <code class="reqn">a</code> equal to the shape of the first Pareto Distribution, <code class="reqn">b</code> equal to the shape of the second Pareto Distribution and <code class="reqn">c</code> is the mixture proportion. The locations and the scales parameters are equals to <code class="reqn">0</code> and <code class="reqn">1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pparetomix(q, a = 1, b = 2, c = 0.75)

dparetomix(x, a = 1, b = 2, c = 0.75)

qparetomix(p, a = 1, b = 2, c = 0.75, precision = 10^(-10),
  initvalue = 0.5, Nmax = 1000)

rparetomix(n, a = 1, b = 2, c = 0.75, precision = 10^(-10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pareto+2B20mix_+3A_q">q</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_a">a</code></td>
<td>
<p>the shape parameter of the first Pareto Distribution.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_b">b</code></td>
<td>
<p>the shape parameter of the second Pareto Distribution.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_c">c</code></td>
<td>
<p>the value of the mixture proportion.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_x">x</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_p">p</code></td>
<td>
<p>a vector of probabilities.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_precision">precision</code></td>
<td>
<p>the precision of the Newton method.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_initvalue">initvalue</code></td>
<td>
<p>the initial value of the Newton method.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_nmax">Nmax</code></td>
<td>
<p>the maximum of iteration done for the Newton method.</p>
</td></tr>
<tr><td><code id="Pareto+2B20mix_+3A_n">n</code></td>
<td>
<p>the number of observations. If length(n) &gt; 1, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code class="reqn">a</code>, <code class="reqn">b</code> and <code class="reqn">c</code> are not specified, they respectively take the default values <code class="reqn">1</code>, <code class="reqn">2</code> and <code class="reqn">0.75</code>.
</p>
<p>The cumulative Pareto mixture distribution is
</p>
<p style="text-align: center;"><code class="reqn">
  F(x) = c  (1- x ^ {-a}) + ( 1 - c ) (1 - x ^ {-b}),  x \ge 1,  a &gt;0,  b &gt; 0, 0 \le c \le 1
</code>
</p>

<p>where <code class="reqn">a</code> and <code class="reqn">b</code> are the shapes of the distribution and <code class="reqn">c</code> is the mixture proportion.
</p>


<h3>Value</h3>

<p>dparetomix gives the density, pparetomix gives the distribution function, qparetomix gives the quantile function, and rparetomix generates random deviates.
</p>
<p>The length of the result is determined by n for rparetomix, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>
<p>The numerical arguments other than n are recycled to the length of the result. Only the first elements of the logical arguments are used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(3,1))
plot(function(x) dparetomix(x), 0, 5,ylab="density",
     main = " Pareto mixture density ")
mtext("dparetomix(x)", adj = 0)

plot(function(x) pparetomix(x), 0, 5,ylab="distribution function",
     main = " Pareto mixture Cumulative ")
mtext("pparetomix(x)", adj = 0)

plot(function(x) qparetomix(x), 0, 1,ylim=c(0,5),ylab="quantiles",
     main = " Pareto mixture Quantile ")
mtext("qparetomix(x)", adj = 0)

#generate a sample of the Pareto mix distribution of size n
n &lt;- 100
x &lt;- rparetomix(n)


</code></pre>

<hr>
<h2 id='plot.hill'>Hill plot</h2><span id='topic+plot.hill'></span>

<h3>Description</h3>

<p>Graphical representation of the hill estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hill'
plot(x, xaxis = "ranks", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hill_+3A_x">x</code></td>
<td>
<p>output object of the function hill.</p>
</td></tr>
<tr><td><code id="plot.hill_+3A_xaxis">xaxis</code></td>
<td>
<p>either &quot;ranks&quot; or &quot;xsort&quot;.</p>
</td></tr>
<tr><td><code id="plot.hill_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If xaxis=&quot;ranks&quot;, the function draws the Hill estimators for each ranks of the grid output of the function hill.
If xaxis=&quot;xsort&quot;, the function draws the Hill estimators for each data of the grid output of the function hill.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill">hill</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- abs(rcauchy(100))
hh &lt;- hill(x)
par(mfrow = c(2, 1))
plot(hh, xaxis = "ranks")
plot(hh, xaxis = "xsort")

</code></pre>

<hr>
<h2 id='plot.hill.adapt'>Hill.adapt plot</h2><span id='topic+plot.hill.adapt'></span>

<h3>Description</h3>

<p>Graphical representation of the hill.adapt function last iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hill.adapt'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hill.adapt_+3A_x">x</code></td>
<td>
<p>output object of the function hill.adapt.</p>
</td></tr>
<tr><td><code id="plot.hill.adapt_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weighted hill estimator, the test statistic, the penalized likelihood graphs of the last iteration and the survival function are given. The blue line corresponds to the threshold (indice or value). The magenta lines correspond to the window (r1, r2) where the estimation is computed. The red lines corresponds to the initial proportion (initprop) and the last non rejected point of the statistic test (madapt).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill.adapt">hill.adapt</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- abs(rcauchy(100))
HH &lt;- hill.adapt(x, weights=rep(1, length(x)), initprop = 0.1,
               gridlen = 50 , r1 = 0.25, r2 = 0.05, CritVal=10)
plot(HH)


</code></pre>

<hr>
<h2 id='pparetoCP'>Pareto change point distribution</h2><span id='topic+pparetoCP'></span><span id='topic+qparetoCP'></span><span id='topic+rparetoCP'></span>

<h3>Description</h3>

<p>Distribution function, quantile function and random generation for the Pareto change point distribution with <code class="reqn">a0</code> equal to the shape of the first pareto distribution, <code class="reqn">a1</code> equal to the shape of the second pareto distribution, <code class="reqn">x0</code> equal to the scale and <code class="reqn">x1</code> equal to the change point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pparetoCP(x, a0 = 1, a1 = 2, x0 = 1, x1 = 6)

qparetoCP(p, a0 = 1, a1 = 2, x0 = 1, x1 = 6)

rparetoCP(n, a0 = 1, a1 = 2, x0 = 1, x1 = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pparetoCP_+3A_x">x</code></td>
<td>
<p>a vector of quantiles.</p>
</td></tr>
<tr><td><code id="pparetoCP_+3A_a0">a0</code></td>
<td>
<p>a vector of shape parameter of the Pareto distribution before <code class="reqn">x1</code>.</p>
</td></tr>
<tr><td><code id="pparetoCP_+3A_a1">a1</code></td>
<td>
<p>a vector of shape parameter of the Pareto distribution after <code class="reqn">x1</code>.</p>
</td></tr>
<tr><td><code id="pparetoCP_+3A_x0">x0</code></td>
<td>
<p>a vector of scale parameter of the function.</p>
</td></tr>
<tr><td><code id="pparetoCP_+3A_x1">x1</code></td>
<td>
<p>a vector of change point value.</p>
</td></tr>
<tr><td><code id="pparetoCP_+3A_p">p</code></td>
<td>
<p>a vector of probabilities.</p>
</td></tr>
<tr><td><code id="pparetoCP_+3A_n">n</code></td>
<td>
<p>a number of observations. If length(n) &gt; 1, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If not specified, <code class="reqn">a0, a1, x0</code> and <code class="reqn">x1</code> are taking respectively the values <code class="reqn">1, 2, 1</code> and <code class="reqn">6</code>
</p>
<p>The cumulative Pareto change point distribution is given by :
</p>
<p style="text-align: center;"><code class="reqn">
    F(x) = (x &lt;= x1)* (1 - x^{-a0}) + (x &gt; x1) * ( 1 - x^{-a1} * x1^{-a0 + a1})
  </code>
</p>



<h3>Value</h3>

<p>pparetoCP gives the distribution function, qparetoCP gives the quantile function, and rparetoCP generates random deviates.
</p>
<p>The length of the result is determined by n for rparetoCP, and is the maximum of the lengths of the numerical arguments for the other functions.
</p>
<p>The numerical arguments other than n are recycled to the length of the result. Only the first elements of the logical arguments are used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(2,1))

plot(function(x) pparetoCP(x), 0, 5,ylab="distribution function",
     main = " Pareto change point Cumulative ")
mtext("pparetoCP(x)", adj = 0)

plot(function(x) qparetoCP(x), 0, 1,ylab="quantiles",
     main = " Pareto change point Quantile")
mtext("qparetoCP(x)", adj = 0)

#generate a sample of pareto distribution of size n
n &lt;- 100
x &lt;- rparetoCP(n)

</code></pre>

<hr>
<h2 id='predict.cox.adapt'>Predict the survival or quantile function from the extreme procedure for the Cox model</h2><span id='topic+predict.cox.adapt'></span>

<h3>Description</h3>

<p>Give the survival or quantile function from the extreme procedure for the Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cox.adapt'
predict(object, newdata = NULL, input = NULL,
  type = "quantile", aggregation = "none", AggInd = object$kadapt,
  M = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cox.adapt_+3A_object">object</code></td>
<td>
<p>output object of the function cox.adapt.</p>
</td></tr>
<tr><td><code id="predict.cox.adapt_+3A_newdata">newdata</code></td>
<td>
<p>a data frame with which to predict.</p>
</td></tr>
<tr><td><code id="predict.cox.adapt_+3A_input">input</code></td>
<td>
<p>optionnaly, the name of the variable to estimate.</p>
</td></tr>
<tr><td><code id="predict.cox.adapt_+3A_type">type</code></td>
<td>
<p>either &quot;quantile&quot; or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="predict.cox.adapt_+3A_aggregation">aggregation</code></td>
<td>
<p>either &quot;none&quot;, &quot;simple&quot; or &quot;adaptive&quot;.</p>
</td></tr>
<tr><td><code id="predict.cox.adapt_+3A_aggind">AggInd</code></td>
<td>
<p>Indices of thresholds to be aggregated.</p>
</td></tr>
<tr><td><code id="predict.cox.adapt_+3A_m">M</code></td>
<td>
<p>Number of thresholds to be aggregated.</p>
</td></tr>
<tr><td><code id="predict.cox.adapt_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">newdata</code> must be a data frame with the co-variables from which to predict and a variable of probabilities with its name starting with a &quot;p&quot; if type = &quot;quantile&quot; or a variable of quantiles with its name starting with a &quot;x&quot; if type = &quot;survival&quot;.
The name of the variable from which to predict can also be written as <code class="reqn">input</code>.
</p>


<h3>Value</h3>

<p>The function provide the quantile assiociated to the adaptive model for the probability grid if type = &quot;quantile&quot;. And the survival function assiociated to the adaptive model for the quantile grid if type = &quot;survival&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cox.adapt">cox.adapt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
data(bladder)

X &lt;- bladder2$stop-bladder2$start
Z &lt;- as.matrix(bladder2[, c(2:4, 8)])
delta &lt;- bladder2$event

ord &lt;- order(X)
X &lt;- X[ord]
Z &lt;- Z[ord,]
delta &lt;- delta[ord]

cph&lt;-coxph(Surv(X, delta) ~ Z)

ca &lt;- cox.adapt(X, cph, delta, bladder2[ord,])

xgrid &lt;- X
newdata &lt;- as.data.frame(cbind(xgrid,bladder2[ord,]))

Plac &lt;- predict(ca, newdata = newdata, type = "survival")
Treat &lt;- predict(ca, newdata = newdata, type = "survival")

PlacSA &lt;- predict(ca, newdata = newdata,
                          type = "survival", aggregation = "simple", AggInd = c(10,20,30,40))
TreatSA &lt;- predict(ca, newdata = newdata,
                          type = "survival", aggregation = "simple", AggInd = c(10,20,30,40))


PlacAA &lt;- predict(ca, newdata = newdata,
                          type = "survival", aggregation = "adaptive", M=10)
TreatAA &lt;- predict(ca, newdata = newdata,
                          type = "survival", aggregation = "adaptive", M=10)

</code></pre>

<hr>
<h2 id='predict.hill'>Predict the adaptive survival or quantile function</h2><span id='topic+predict.hill'></span>

<h3>Description</h3>

<p>Give the adaptive survival function or quantile function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hill'
predict(object, newdata = NULL, type = "quantile",
  input = NULL, threshold.rank = 0, threshold = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hill_+3A_object">object</code></td>
<td>
<p>output  object of the function hill.</p>
</td></tr>
<tr><td><code id="predict.hill_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame or a vector with which to predict. If omitted, the original data points are used.</p>
</td></tr>
<tr><td><code id="predict.hill_+3A_type">type</code></td>
<td>
<p>either &quot;quantile&quot; or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="predict.hill_+3A_input">input</code></td>
<td>
<p>optionnaly, the name of the variable to estimate.</p>
</td></tr>
<tr><td><code id="predict.hill_+3A_threshold.rank">threshold.rank</code></td>
<td>
<p>the rank value for the hill output of the threshold, with default value 0.</p>
</td></tr>
<tr><td><code id="predict.hill_+3A_threshold">threshold</code></td>
<td>
<p>the value of threshold, with default value 0.</p>
</td></tr>
<tr><td><code id="predict.hill_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If type = &quot;quantile&quot;, <code class="reqn">newdata</code> must be between 0 and 1. If type = &quot;survival&quot;, <code class="reqn">newdata</code> must be in the domain of the data from the <code>hill</code> function.
If <code class="reqn">newdata</code> is a data frame, the variable from which to predict must be the first one or its name must start with a &quot;p&quot; if type = &quot;quantile&quot; and &quot;x&quot; if type = &quot;survival&quot;.
The name of the variable from which to predict can also be written as <code class="reqn">input</code>.
</p>


<h3>Value</h3>

<p>The function provide the quantile assiociated to the adaptive model for the probability grid (transformed to -log(1-p) in the output) if type = &quot;quantile&quot;. And the survival function assiociated to the adaptive model for the quantile grid if type = &quot;survival&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill">hill</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- abs(rcauchy(100))
hh &lt;- hill(x)
#example for a fixed value of threshold
predict(hh, threshold = 3)
#example for a fixed rank value of threshold
predict(hh, threshold.rank = 30)

</code></pre>

<hr>
<h2 id='predict.hill.adapt'>Predict the adaptive survival or quantile function</h2><span id='topic+predict.hill.adapt'></span>

<h3>Description</h3>

<p>Give the adaptive survival function or quantile function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hill.adapt'
predict(object, newdata = NULL, type = "quantile",
  input = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hill.adapt_+3A_object">object</code></td>
<td>
<p>output object of the function hill.adapt.</p>
</td></tr>
<tr><td><code id="predict.hill.adapt_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame or a vector with which to predict. If omitted, the original data points are used.</p>
</td></tr>
<tr><td><code id="predict.hill.adapt_+3A_type">type</code></td>
<td>
<p>either &quot;quantile&quot; or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="predict.hill.adapt_+3A_input">input</code></td>
<td>
<p>optionnaly, the name of the variable to estimate.</p>
</td></tr>
<tr><td><code id="predict.hill.adapt_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If type = &quot;quantile&quot;, <code class="reqn">newdata</code> must be between 0 and 1. If type = &quot;survival&quot;, <code class="reqn">newdata</code> must be in the domain of the data from the <code>hill.adapt</code> function.
If <code class="reqn">newdata</code> is a data frame, the variable from which to predict must be the first one or its name must start with a &quot;p&quot; if type = &quot;quantile&quot; and &quot;x&quot; if type = &quot;survival&quot;.
The name of the variable from which to predict can also be written as <code class="reqn">input</code>.
</p>


<h3>Value</h3>

<p>The function provide the quantile assiociated to the adaptive model for the probability grid (transformed to -log(1-p) in the output) if type = &quot;quantile&quot;. And the survival function assiociated to the adaptive model for the quantile grid if type = &quot;survival&quot;.
</p>


<h3>References</h3>

<p>Durrieu, G. and Grama, I. and Jaunatre, K. and Pham, Q.-K. and Tricot, J.-M. (2018). extremefit: A Package for Extreme Quantiles. Journal of Statistical Software, 87, 1&ndash;20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill.adapt">hill.adapt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rparetoCP(1000)

HH &lt;- hill.adapt(x, weights=rep(1, length(x)), initprop = 0.1,
               gridlen = 100 , r1 = 0.25, r2 = 0.05, CritVal=10)

newdata &lt;- probgrid(p1 = 0.01, p2 = 0.999, length = 100)
pred.quantile &lt;- predict(HH, newdata, type = "quantile")
newdata &lt;- seq(0, 50, 0.1)
pred.survival &lt;- predict(HH, newdata, type = "survival")#survival function

#compare the theorical quantile and the adaptive one.
predict(HH, 0.9999, type = "quantile")
qparetoCP(0.9999)

#compare the theorical probability and the adaptive one assiociated to a quantile.
predict(HH, 20, type = "survival")
1 - pparetoCP(20)

</code></pre>

<hr>
<h2 id='predict.hill.ts'>Predict the adaptive survival or quantile function for a time serie</h2><span id='topic+predict.hill.ts'></span>

<h3>Description</h3>

<p>Give the adaptive survival function or quantile function of a time serie
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hill.ts'
predict(object, newdata = NULL, type = "quantile",
  input = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hill.ts_+3A_object">object</code></td>
<td>
<p>output object of the function hill.ts.</p>
</td></tr>
<tr><td><code id="predict.hill.ts_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame or a vector with which to predict. If omitted, the original data points are used.</p>
</td></tr>
<tr><td><code id="predict.hill.ts_+3A_type">type</code></td>
<td>
<p>either &quot;quantile&quot; or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="predict.hill.ts_+3A_input">input</code></td>
<td>
<p>optionnaly, the name of the variable to estimate.</p>
</td></tr>
<tr><td><code id="predict.hill.ts_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If type = &quot;quantile&quot;, <code class="reqn">newdata</code> must be between 0 and 1. If type = &quot;survival&quot;, <code class="reqn">newdata</code> must be in the domain of the data from the function <code>hill.ts</code>.
If <code class="reqn">newdata</code> is a data frame, the variable from which to predict must be the first one or its name must start with a &quot;p&quot; if type = &quot;quantile&quot; and &quot;x&quot; if type = &quot;survival&quot;.
The name of the variable from which to predict can also be written as <code class="reqn">input</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>p</code></td>
<td>
<p>the input vector of probabilities.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the input vector of values.</p>
</td></tr>
<tr><td><code>Tgrid</code></td>
<td>
<p>Tgrid output of the function hill.ts.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>the estimted quantiles assiociated to newdata.</p>
</td></tr>
<tr><td><code>survival</code></td>
<td>
<p>the estimated survival function assiociated to newdata.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Durrieu, G. and Grama, I. and Jaunatre, K. and Pham, Q.-K. and Tricot, J.-M. (2018). extremefit: A Package for Extreme Quantiles. Journal of Statistical Software, 87, 1&ndash;20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hill.ts">hill.ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a pareto mixture sample of size n with a time varying parameter
theta &lt;- function(t){
   0.5+0.25*sin(2*pi*t)
 }
n &lt;- 4000
t &lt;- 1:n/n
Theta &lt;- theta(t)
Data &lt;- NULL
set.seed(1240)
for(i in 1:n){
   Data[i] &lt;- rparetomix(1, a = 1/Theta[i], b = 1/Theta[i]+5, c = 0.75, precision = 10^(-5))
 }
## Not run:  #For computing time purpose
  #choose the bandwidth by cross validation
  Tgrid &lt;- seq(0, 1, 0.1)#few points to improve the computing time
  hgrid &lt;- bandwidth.grid(0.01, 0.2, 20, type = "geometric")
  hcv &lt;- bandwidth.CV(Data, t, Tgrid, hgrid, TruncGauss.kernel,
         kpar = c(sigma = 1), pcv = 0.99, CritVal = 3.6, plot = TRUE)
  h.cv &lt;- hcv$h.cv

  #we modify the Tgrid to cover the data set
  Tgrid &lt;- seq(0, 1, 0.02)
  hillTs &lt;- hill.ts(Data, t, Tgrid, h = h.cv, TruncGauss.kernel, kpar = c(sigma = 1),
           CritVal = 3.6, gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)
  p &lt;- c(0.999)
  pred.quantile.ts &lt;- predict(hillTs, newdata = p, type = "quantile")
  true.quantile &lt;- NULL
  for(i in 1:n){
     true.quantile[i] &lt;- qparetomix(p, a = 1/Theta[i], b = 1/Theta[i]+5, c = 0.75)
   }
  plot(Tgrid, log(as.numeric(pred.quantile.ts$y)),
       ylim = c(0, max(log(as.numeric(pred.quantile.ts$y)))), ylab = "log(0.999-quantiles)")
  lines(t, log(true.quantile), col = "red")
  lines(t, log(Data), col = "blue")


  #comparison with other fixed bandwidths

  plot(Tgrid, log(as.numeric(pred.quantile.ts$y)),
       ylim = c(0, max(log(as.numeric(pred.quantile.ts$y)))), ylab = "log(0.999-quantiles)")
  lines(t, log(true.quantile), col = "red")

  hillTs &lt;- hill.ts(Data, t, Tgrid, h = 0.1, TruncGauss.kernel, kpar = c(sigma = 1),
                    CritVal = 3.6, gridlen = 100,initprop = 1/10, r1 = 1/4, r2 = 1/20)
  pred.quantile.ts &lt;- predict(hillTs, p, type = "quantile")
  lines(Tgrid, log(as.numeric(pred.quantile.ts$y)), col = "green")


  hillTs &lt;- hill.ts(Data, t, Tgrid, h = 0.3, TruncGauss.kernel, kpar = c(sigma = 1),
               CritVal = 3.6, gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)
  pred.quantile.ts &lt;- predict(hillTs, p, type = "quantile")
  lines(Tgrid, log(as.numeric(pred.quantile.ts$y)), col = "blue")


  hillTs &lt;- hill.ts(Data, t, Tgrid, h = 0.04, TruncGauss.kernel, kpar = c(sigma = 1),
             CritVal = 3.6, gridlen = 100, initprop = 1/10, r1 = 1/4, r2 = 1/20)
  pred.quantile.ts &lt;- predict(hillTs ,p, type = "quantile")
  lines(Tgrid, log(as.numeric(pred.quantile.ts$y)), col = "magenta")

## End(Not run)



</code></pre>

<hr>
<h2 id='probgrid'>Probability grid</h2><span id='topic+probgrid'></span>

<h3>Description</h3>

<p>Create a geometric grid of probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probgrid(p1, p2, length = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probgrid_+3A_p1">p1</code></td>
<td>
<p>the first element of the grid.</p>
</td></tr>
<tr><td><code id="probgrid_+3A_p2">p2</code></td>
<td>
<p>the last element of the grid.</p>
</td></tr>
<tr><td><code id="probgrid_+3A_length">length</code></td>
<td>
<p>the length of the grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a geometric grid of length <code class="reqn">length</code> between <code class="reqn">p1</code> and <code class="reqn">p2</code>.The default value of <code class="reqn">length</code> is <code class="reqn">50</code>.
</p>


<h3>Value</h3>

<p>A vector of probabilities between <code class="reqn">p1</code> and <code class="reqn">p2</code> and length <code class="reqn">length</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- 0.01
p2 &lt;- 0.99
length &lt;- 500
pgrid &lt;- probgrid(p1, p2, length)

</code></pre>

<hr>
<h2 id='rburr.dependent'>Generate Burr dependent data</h2><span id='topic+rburr.dependent'></span>

<h3>Description</h3>

<p>Random generation function for the dependent Burr with a, b two shapes parameters and alpha the dependence parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rburr.dependent(n, a, b, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rburr.dependent_+3A_n">n</code></td>
<td>
<p>the number of observations. If length(n) &gt; 1, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rburr.dependent_+3A_a">a</code></td>
<td>
<p>a parameter of the function.</p>
</td></tr>
<tr><td><code id="rburr.dependent_+3A_b">b</code></td>
<td>
<p>a parameter of the function.</p>
</td></tr>
<tr><td><code id="rburr.dependent_+3A_alpha">alpha</code></td>
<td>
<p>the dependence parameter. It is defined by a single value between 0 and 1. The value 1 corresponds to the full independence. The closer to 0 the value of alpha is, the stronger is the dependence. <code class="reqn">alpha</code> cannot take the value 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The description of the dependence is described in <em>Fawcett and Walshaw (2007)</em>. The Burr distribution is :
<code class="reqn">
  F(x) = 1 - ( 1 + (x ^ a) ) ^ { - b }, x &gt; 0, a &gt; 0, b &gt; 0
</code>
where a and b are shapes of the distribution.
</p>


<h3>Value</h3>

<p>Generates a vector of random deviates. The length of the result is determined by n.
</p>


<h3>References</h3>

<p>Fawcett, D. and Walshaw, D. (2007). Improved estimation for temporally clustered extremes. Environmetrics, 18.2, 173-188.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- function(t){
   1/2*(1/10+sin(pi*t))*(11/10-1/2*exp(-64*(t-1/2)^2))
 }
n &lt;- 200
t &lt;- 1:n/n
Theta &lt;- theta(t)
plot(theta)
alpha &lt;- 0.6
Burr.dependent &lt;- rburr.dependent(n, 1/Theta, 1, alpha)


</code></pre>

<hr>
<h2 id='Rectangular.kernel'>Rectangular kernel function</h2><span id='topic+Rectangular.kernel'></span>

<h3>Description</h3>

<p>Rectangular kernel function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rectangular.kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rectangular.kernel_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rectangular kernel function
</p>
<p>Rectangular Kernel
</p>
<p style="text-align: center;"><code class="reqn">
  K(x) = 1 (abs(x) &lt;= 1)
</code>
</p>

<p>We recommend a critical value of 10 for this kernel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(function(x) Rectangular.kernel(x), -2, 2,
main = " Rectangular kernel ")

</code></pre>

<hr>
<h2 id='Triang.kernel'>Triangular kernel function</h2><span id='topic+Triang.kernel'></span>

<h3>Description</h3>

<p>Triangular kernel function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Triang.kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Triang.kernel_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Triangular Kernel
</p>
<p style="text-align: center;"><code class="reqn">
  K(x) = ( 1 - abs(x) )  (abs(x) &lt;= 1)
</code>
</p>

<p>We recommend a critical value of 6.9 for this kernel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(function(x) Triang.kernel(x), -2, 2,
main = " Triangular kernel")

</code></pre>

<hr>
<h2 id='TruncGauss.kernel'>Truncated Gaussian kernel function</h2><span id='topic+TruncGauss.kernel'></span>

<h3>Description</h3>

<p>Truncated Gaussian kernel function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TruncGauss.kernel(x, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TruncGauss.kernel_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="TruncGauss.kernel_+3A_sigma">sigma</code></td>
<td>
<p>the standard deviation of the truncated gaussian kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Truncated Gaussian Kernel with <code class="reqn">sigma</code> the standard deviation parameter with default value <code class="reqn">1</code>.
</p>
<p style="text-align: center;"><code class="reqn">
  K(x) = (1/{sigma*sqrt(2 \pi)}  exp(-(x/sigma)^2/2)) (abs(x) &lt;= 1)
</code>
</p>

<p>We recommend a critical value of 3.6 for this kernel with sigma=1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(function(x) TruncGauss.kernel(x), -2, 2,
main = " Truncated Gaussian kernel")

</code></pre>

<hr>
<h2 id='wecdf'>Weighted empirical cumulative distribution function</h2><span id='topic+wecdf'></span>

<h3>Description</h3>

<p>Calculate the values of the weighted empirical cumulative distribution function for a given vector of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wecdf(X, x, weights = rep(1, length(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wecdf_+3A_x">X</code></td>
<td>
<p>the vector of data to create the wecdf.</p>
</td></tr>
<tr><td><code id="wecdf_+3A_x">x</code></td>
<td>
<p>the vector of data that you want the corresponding wecdf values.</p>
</td></tr>
<tr><td><code id="wecdf_+3A_weights">weights</code></td>
<td>
<p>the weights applicated to the vector <code class="reqn">X</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Give the value of the wecdf.
If the weights are 1 (the default value), the wecdf become the ecdf of <code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>Return a vector of the wecdf values corresponding to <code class="reqn">x</code> given a reference vector <code class="reqn">X</code> with weights <code class="reqn">weights</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- rpareto(10)
x &lt;- seq(0.8, 50, 0.01)
plot(x, wecdf(X, x, rep(1,length(X))))

#to compare with the ecdf function
f &lt;- ecdf(X)
lines(x, f(x), col = "red", type = "s")

</code></pre>

<hr>
<h2 id='wquantile'>Weighted quantile</h2><span id='topic+wquantile'></span>

<h3>Description</h3>

<p>Compute the weighted quantile of order p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wquantile(X, p, weights = rep(1, length(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wquantile_+3A_x">X</code></td>
<td>
<p>a vector of data.</p>
</td></tr>
<tr><td><code id="wquantile_+3A_p">p</code></td>
<td>
<p>a vector of probabilities.</p>
</td></tr>
<tr><td><code id="wquantile_+3A_weights">weights</code></td>
<td>
<p>the weights assiociated to the vector <code class="reqn">X</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Give the weighted quantile for a given <code class="reqn">p</code>
</p>


<h3>Value</h3>

<p>A vector of quantile assiociated to the probabilities vector given in input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- rpareto(10)
p &lt;- seq(0.01, 0.99, 0.01)
plot(p, wquantile(X, p, rep(1,length(X))), type = "s")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
