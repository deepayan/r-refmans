<!DOCTYPE html><html><head><title>Help for package stelfi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stelfi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fit_hawkes'><p>Self-exciting Hawkes process(es)</p></a></li>
<li><a href='#fit_lgcp'><p>Spatial or spatiotemporal log-Gaussian Cox process (LGCP)</p></a></li>
<li><a href='#fit_mlgcp'><p>Marked spatial log-Gaussian Cox process (mLGCP)</p></a></li>
<li><a href='#fit_stelfi'><p>Modelling spatiotemporal self-excitement</p></a></li>
<li><a href='#get_coefs'><p>Extract reported parameter estimates</p></a></li>
<li><a href='#get_fields'><p>Estimated random field(s)</p></a></li>
<li><a href='#get_weights'><p>Mesh weights</p></a></li>
<li><a href='#horse_mesh'><p>Example Delaunay triangulation</p></a></li>
<li><a href='#horse_sf'><p>Example <code>sf</code> <code>POLYGON</code></p></a></li>
<li><a href='#iraq_terrorism'><p>Terrorism in Iraq, 2013 - 2017</p></a></li>
<li><a href='#marked'><p>Example marked point pattern data set</p></a></li>
<li><a href='#mesh_2_sf'><p>Transform a <code>fmesher::fm_mesh_2d</code> into a <code>sf</code> object</p></a></li>
<li><a href='#meshmetrics'><p>Calculate a number of different geometric attributes of a Delaunay triangulation</p></a></li>
<li><a href='#multi_hawkes'><p>Example multivariate Hawkes dataset</p></a></li>
<li><a href='#nz_earthquakes'><p>Earthquakes in Canterbury, NZ, 2010 - 2014</p></a></li>
<li><a href='#nz_murders'><p>Murders of NZ, 2004 - 2019</p></a></li>
<li><a href='#retweets_niwa'><p>Retweets of NIWA's viral leopard seal Tweet</p></a></li>
<li><a href='#sasquatch'><p>Sasquatch (bigfoot) sightings in the USA, 2000 - 2005</p></a></li>
<li><a href='#show_field'><p>Plot the estimated random field(s) of a fitted LGCP</p></a></li>
<li><a href='#show_hawkes'><p>Plot Hawkes intensity</p></a></li>
<li><a href='#show_lambda'><p>Plot the estimated intensity from a fitted LGCP model</p></a></li>
<li><a href='#sim_hawkes'><p>Simulate a self-exciting Hawkes process</p></a></li>
<li><a href='#sim_lgcp'><p>Simulate a log-Gaussian Cox process (LGCP)</p></a></li>
<li><a href='#stelfi'><p>A package to fit Hawkes and Log-Gaussian Cox Point Process models</p>
using Template Model Builder</a></li>
<li><a href='#uk_serial'><p>Serial killers of the UK, 1828 - 2015</p></a></li>
<li><a href='#xyt'><p>Self-exciting point pattern</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hawkes and Log-Gaussian Cox Point Processes Using Template Model
Builder</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-29</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>TMB (&ge; 1.9.6), sf (&ge; 1.0.14), fmesher, Matrix, ggplot2 (&ge;
3.4.3), dplyr (&ge; 1.1.3), gridExtra (&ge; 2.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Hawkes and log-Gaussian Cox process models with extensions. Introduced in Hawkes (1971) &lt;<a href="https://doi.org/10.2307%2F2334319">doi:10.2307/2334319</a>&gt; a Hawkes process is a self-exciting temporal point process where the occurrence of an event immediately increases the chance of another. We extend this to consider self-inhibiting process and a non-homogeneous background rate. A log-Gaussian Cox process is a Poisson point process where the log-intensity is given by a Gaussian random field. We extend this  to a joint likelihood formulation fitting a marked log-Gaussian Cox model. In addition, the package offers functionality to fit self-exciting spatiotemporal point processes. Models are fitted via maximum likelihood using 'TMB' (Template Model Builder). Where included 1) random fields are assumed to be Gaussian and are integrated over using the Laplace approximation and 2) a stochastic partial differential equation model, introduced by Lindgren, Rue, and Lindstr√∂m. (2011) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2011.00777.x">doi:10.1111/j.1467-9868.2011.00777.x</a>&gt;, is defined for the field(s). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cmjt/stelfi/">https://github.com/cmjt/stelfi/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cmjt/stelfi/issues">https://github.com/cmjt/stelfi/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.1.10), rmarkdown, parallel, spatstat.utils,
spatstat.geom, hawkesbow, covr, knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-23 22:46:07 UTC; charlotte</td>
</tr>
<tr>
<td>Author:</td>
<td>Charlotte M. Jones-Todd
    <a href="https://orcid.org/0000-0003-1201-2781"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph] (Charlotte Jones-Todd wrote and continued developmend of the
    main code.),
  Alec van Helsdingen [aut] (Alec van Helsdingen wrote the Hawkes
    templates and extended self-exciting TMB templates),
  Xiangjie Xue [ctb] (Xiangjie Xue worked the early spatio-temporal
    self-exciting TMB templates),
  Marsden Fund 3723517 [fnd],
  Asian Office of Aerospace Research &amp; Development FA2386-21-1-4028 [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charlotte M. Jones-Todd &lt;cmjonestodd@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-24 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fit_hawkes'>Self-exciting Hawkes process(es)</h2><span id='topic+fit_hawkes'></span><span id='topic+fit_hawkes_cbf'></span><span id='topic+fit_mhawkes'></span>

<h3>Description</h3>

<p>Fit a Hawkes process using Template Model Builder (TMB). The function <code>fit_hawkes()</code> fits a
self-exciting Hawkes process with a constant background rate. Whereas, <code>fit_hawkes_cbf()</code> fits a Hawkes
processes with a user defined custom background function (non-homogeneous background rate). The function
<code>fit_mhawkes()</code> fits a multivariate Hawkes process that allows for between- and within-stream
self-excitement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hawkes(
  times,
  parameters = list(),
  model = 1,
  marks = c(rep(1, length(times))),
  tmb_silent = TRUE,
  optim_silent = TRUE,
  ...
)

fit_hawkes_cbf(
  times,
  parameters = list(),
  model = 1,
  marks = c(rep(1, length(times))),
  background,
  background_integral,
  background_parameters,
  background_min,
  tmb_silent = TRUE,
  optim_silent = TRUE
)

fit_mhawkes(
  times,
  stream,
  parameters = list(),
  tmb_silent = TRUE,
  optim_silent = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hawkes_+3A_times">times</code></td>
<td>
<p>A vector of numeric observed time points.</p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter starting values:
</p>

<ul>
<li> <p><code>mu</code>, a vector of base rates for each stream of the multivariate Hawkes process,
</p>
</li>
<li> <p><code>alpha</code>, a matrix of the between- and within-stream self-excitement: the diagonal
elements represent the within-stream excitement and the off-diagonals the excitement between streams,
</p>
</li>
<li> <p><code>beta</code>, a vector of the exponential intensity decay for each stream of the multivariate
Hawkes process,
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_model">model</code></td>
<td>
<p>A numeric indicator specifying which model to fit:
</p>

<ul>
<li> <p><code>model = 1</code>, fits a Hawkes process with exponential decay (default);
</p>
</li>
<li> <p><code>model = 2</code>, fits a Hawkes process with an <code>alpha</code> that can be negative.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_marks">marks</code></td>
<td>
<p>Optional, a vector of numeric marks, defaults to 1 (i.e., no marks).</p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_tmb_silent">tmb_silent</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then
TMB inner optimisation tracing information will be printed.</p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_optim_silent">optim_silent</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then for each iteration
<code>optim()</code> output will be printed.</p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>optim()</code></p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_background">background</code></td>
<td>
<p>A function taking one parameter and an
independent variable, returning a scalar.</p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_background_integral">background_integral</code></td>
<td>
<p>The integral of <code>background</code>.</p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_background_parameters">background_parameters</code></td>
<td>
<p>The parameter(s)
for the background function <code>background</code>.
This could be a list of multiple values.</p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_background_min">background_min</code></td>
<td>
<p>A function taking one parameter and two points,
returns min of <code>background</code> between those points.</p>
</td></tr>
<tr><td><code id="fit_hawkes_+3A_stream">stream</code></td>
<td>
<p>A character vector specifying the stream ID of each observation in <code>times</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A univariate Hawkes (Hawkes, AG. 1971) process is a self-exciting temporal point process
with conditional intensity function
<code class="reqn">\lambda(t) = \mu + \alpha \Sigma_{i:\tau_i&lt;t}e^{(-\beta * (t-\tau_i))}</code>.  Here <code class="reqn">\mu</code> is the constant
baseline rate, <code class="reqn">\alpha</code> is the instantaneous increase in intensity after an event, and <code class="reqn">\beta</code> is the
exponential decay in intensity. The term <code class="reqn">\Sigma_{i:\tau_i&lt;t} \cdots</code> describes the historic dependence
and the clustering density of the temporal point process, where the <code class="reqn">\tau_i</code> are the events in
time occurring prior to time <code class="reqn">t</code>. From this we can derive the following quantities 1) <code class="reqn">\frac{\alpha}{\beta}</code>
is the branching ratio, it gives the average number of events triggered by an event, and
2) <code class="reqn">\frac{1}{\beta}</code> gives the rate of decay of the self-excitement.
Including mark information results in the conditional intensity
<code class="reqn">\lambda(t; m(t)) = \mu + \alpha \Sigma_{i:\tau_i&lt;t}m(\tau_i)e^{(-\beta * (t-\tau_i))}</code>,
where <code class="reqn">m(t)</code> is the temporal mark. This model can be fitted with <code>fit_hawkes()</code>.
</p>
<p>An in-homogenous marked Hawkes process has conditional intensity function
<code class="reqn">\lambda(t) = \mu(t) + \alpha \Sigma_{i:\tau_i&lt;t}e^{(-\beta * (t-\tau_i))}</code>. Here, the
background rate, <code class="reqn">\mu(t)</code>, varies in time. Such a model can be fitted
using <code>fit_hawkes_cbf()</code> where the parameters of the custom background function are estimated
before being passed to <code>TMB</code>.
</p>
<p>A multivariate Hawkes process that allows for between- and within-stream self-excitement.
The conditional intensity for the <code class="reqn">j^{th}</code> (<code class="reqn">j = 1, ..., N</code>) stream is given by
<code class="reqn">\lambda(t)^{j*} = \mu_j + \Sigma_{k = 1}^N\Sigma_{i:\tau_i&lt;t} \alpha_{jk} e^{(-\beta_j * (t-\tau_i))}</code>, where
<code class="reqn">j, k  \in (1, ..., N)</code>. Here, <code class="reqn">\alpha_{jk}</code> is the excitement caused by the
<code class="reqn">k^{th}</code> stream on the <code class="reqn">j^{th}</code>. Therefore, <code class="reqn">\boldsymbol{\alpha}</code> is an <code class="reqn">N x N</code>
matrix where the diagonals represent the within-stream excitement and the off-diagonals
represent the excitement between streams.
</p>


<h3>Value</h3>

<p>A list containing components of the fitted model, see <code>TMB::MakeADFun</code>. Includes
</p>

<ul>
<li> <p><code>par</code>, a numeric vector of estimated parameter values;
</p>
</li>
<li> <p><code>objective</code>, the objective function;
</p>
</li>
<li> <p><code>gr</code>, the TMB calculated gradient function; and
</p>
</li>
<li> <p><code>simulate</code>, (where available) a simulation function. 
</p>
</li></ul>



<h3>References</h3>

<p>Hawkes, AG. (1971) Spectra of some self-exciting and mutually exciting point processes.
<em>Biometrika</em>, <strong>58</strong>: 83&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+show_hawkes">show_hawkes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### ********************** ###
## A Hawkes model
### ********************** ###
data(retweets_niwa, package = "stelfi")
times &lt;- unique(sort(as.numeric(difftime(retweets_niwa, min(retweets_niwa), units = "mins"))))
params &lt;- c(mu = 0.05, alpha = 0.05, beta = 0.1)
fit &lt;- fit_hawkes(times = times, parameters = params)
get_coefs(fit)
### ********************** ###
## A Hawkes model with marks (ETAS-type)
### ********************** ###
data("nz_earthquakes", package = "stelfi")
earthquakes &lt;- nz_earthquakes[order(nz_earthquakes$origintime),]
earthquakes &lt;- earthquakes[!duplicated(earthquakes$origintime), ]
times &lt;- earthquakes$origintime
times &lt;- as.numeric(difftime(times, min(times), units = "hours"))
marks &lt;- earthquakes$magnitude
params &lt;- c(mu = 0.05, alpha = 0.05, beta = 1)
fit &lt;- fit_hawkes(times = times, parameters = params, marks = marks)
get_coefs(fit)


### ********************** ###
## A Hawkes process with a custom background function
### ********************** ###
if(require("hawkesbow")) {
times &lt;- hawkesbow::hawkes(1000, fun = function(y) {1 + 0.5*sin(y)},
M = 1.5, repr = 0.5, family = "exp", rate = 2)$p
## The background function must take a single parameter and
## the time(s) at which it is evaluated
background &lt;- function(params,times) {
A = exp(params[[1]])
B = stats::plogis(params[[2]]) * A
return(A + B  *sin(times))
}
## The background_integral function must take a
## single parameter and the time at which it is evaluated
background_integral &lt;- function(params,x) {
        A = exp(params[[1]])
        B = stats::plogis(params[[2]]) * A
        return((A*x)-B*cos(x))
}
param = list(alpha = 0.5, beta = 1.5)
background_param = list(1,1)
fit &lt;- fit_hawkes_cbf(times = times, parameters = param,
background = background,
background_integral = background_integral,
background_parameters = background_param)
get_coefs(fit)
}


### ********************** ###
## A multivariate Hawkes model
### ********************** ###
data(multi_hawkes, package = "stelfi")
fit &lt;- fit_mhawkes(times = multi_hawkes$times, stream = multi_hawkes$stream,
parameters = list(mu =  c(0.2,0.2),
alpha =  matrix(c(0.5,0.1,0.1,0.5),byrow = TRUE,nrow = 2),
beta = c(0.7,0.7)))
get_coefs(fit)

</code></pre>

<hr>
<h2 id='fit_lgcp'>Spatial or spatiotemporal log-Gaussian Cox process (LGCP)</h2><span id='topic+fit_lgcp'></span>

<h3>Description</h3>

<p>Fit a log-Gaussian Cox process (LGCP) using Template Model Builder (TMB) and the
<code>R_inla</code> namespace for the SPDE-based construction of the latent field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_lgcp(
  locs,
  sf,
  smesh,
  tmesh,
  parameters,
  covariates,
  tmb_silent = TRUE,
  nlminb_silent = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_lgcp_+3A_locs">locs</code></td>
<td>
<p>A <code>data.frame</code> of <code>x</code> and <code>y</code> locations, <code class="reqn">2 \times n</code>. If a
spatiotemporal model is to be fitted then there should be the third column (<code>t</code>) of the occurrence times.</p>
</td></tr>
<tr><td><code id="fit_lgcp_+3A_sf">sf</code></td>
<td>
<p>An <code>sf</code> of type <code>POLYGON</code> specifying the spatial region
of the domain.</p>
</td></tr>
<tr><td><code id="fit_lgcp_+3A_smesh">smesh</code></td>
<td>
<p>A Delaunay triangulation of the spatial domain returned by <code>fmesher::fm_mesh_2d()</code>.</p>
</td></tr>
<tr><td><code id="fit_lgcp_+3A_tmesh">tmesh</code></td>
<td>
<p>Optional, a temporal mesh returned by <code>fmesher::fm_mesh_1d()</code>.</p>
</td></tr>
<tr><td><code id="fit_lgcp_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter starting values:
</p>

<ul>
<li> <p><code>beta</code>, a vector of fixed effects coefficients to be estimated, <code class="reqn">\beta</code>
(same length as <code>ncol(covariates)</code> + 1 );
</p>
</li>
<li>  <p><code>log_tau</code>, the <code class="reqn">\textrm{log}(\tau)</code> parameter for the GMRF;
</p>
</li>
<li> <p><code>log_kappa</code>, <code class="reqn">\textrm{log}(\kappa)</code> parameter for the GMRF;
</p>
</li>
<li> <p><code>atanh_rho</code>, optional, <code class="reqn">\textrm{arctan}(\rho)</code> AR1 temporal parameter.
</p>
</li></ul>

<p>Default values are used if none are provided. NOTE: these may not always be appropriate.</p>
</td></tr>
<tr><td><code id="fit_lgcp_+3A_covariates">covariates</code></td>
<td>
<p>Optional, a <code>matrix</code> of covariates at each
<code>smesh</code> and <code>tmesh</code> node combination.</p>
</td></tr>
<tr><td><code id="fit_lgcp_+3A_tmb_silent">tmb_silent</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then
TMB inner optimisation tracing information will be printed.</p>
</td></tr>
<tr><td><code id="fit_lgcp_+3A_nlminb_silent">nlminb_silent</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then for each iteration
<code>nlminb()</code> output will be printed.</p>
</td></tr>
<tr><td><code id="fit_lgcp_+3A_...">...</code></td>
<td>
<p>optional extra arguments to pass into <code>stats::nlminb()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A log-Gaussian Cox process (LGCP) where the Gaussian random field, <code class="reqn">Z(\boldsymbol{x})</code>,
has zero mean, variance-covariance matrix <code class="reqn">\boldsymbol{Q}^{-1}</code>, and covariance function
<code class="reqn">C_Z</code>. The random intensity surface is
<code class="reqn">\Lambda(\boldsymbol{x}) = \textrm{exp}(\boldsymbol{X}\beta + G(\boldsymbol{x}) + \epsilon)</code>,
for design matrix <code class="reqn">\boldsymbol{X}</code>, coefficients <code class="reqn">\boldsymbol{\beta}</code>, and random error <code class="reqn">\epsilon</code>.
</p>
<p>Shown in Lindgren et. al., (2011) the stationary solution to the SPDE (stochastic
partial differential equation) <code class="reqn">(\kappa^2 - \Delta)^{\frac{\nu + \frac{d}{2}}{2}}G(s) = W(s)</code> is
a random field with a Mat√©rn covariance function,
<code class="reqn">C_Z \propto {\kappa || x - y||}^{\nu}K_{\nu}{\kappa || x - y||}</code>. Here <code class="reqn">\nu</code> controls
the smoothness of the field and <code class="reqn">\kappa</code> controls the range.
</p>
<p>A Markovian random field is obtained when <code class="reqn">\alpha = \nu + \frac{d}{2}</code> is an integer. Following
Lindgren et. al., (2011) we set <code class="reqn">\alpha = 2</code> in 2D and therefore fix <code class="reqn">\nu = 1</code>. Under these
conditions the solution to the SPDE is a Gaussian Markov Random Field (GMRF). This is the approximation
we use.
</p>
<p>The (approximate) spatial range <code class="reqn">= \frac{\sqrt{8 \nu}}{\kappa} = \frac{\sqrt{8}}{\kappa}</code> and
the standard deviation of the model, <code class="reqn">\sigma = \frac{1}{\sqrt{4 \pi \kappa^2 \tau^2}}</code>.
Under <code>INLA</code> (Lindgren and Rue, 2015) methodology the practical range is defined as the
distance such that the correlation is <code class="reqn">\sim 0.139</code>.
</p>


<h3>Value</h3>

<p>A list containing components of the fitted model, see <code>TMB::MakeADFun</code>. Includes
</p>

<ul>
<li> <p><code>par</code>, a numeric vector of estimated parameter values;
</p>
</li>
<li> <p><code>objective</code>, the objective function;
</p>
</li>
<li> <p><code>gr</code>, the TMB calculated gradient function; and
</p>
</li>
<li> <p><code>simulate</code>, a simulation function. 
</p>
</li></ul>



<h3>References</h3>

<p>Lindgren, F., Rue, H., and Lindstr√∂m, J. (2011)
An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic
partial differential equation approach. <em>Journal of the Royal Statistical Society: Series B
(Statistical Methodology)</em>, <strong>73</strong>: 423&ndash;498.
</p>
<p>Lindgren, F. and Rue, H. (2015) Bayesian spatial modelling with R-INLA.
<em>Journal of Statistical Software</em>, <strong>63</strong>: 1&ndash;25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mlgcp">fit_mlgcp</a></code> and <code><a href="#topic+sim_lgcp">sim_lgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### ********************** ###
## A spatial only LGCP
### ********************** ###
if(requireNamespace("fmesher")) {
data(xyt, package = "stelfi")
domain &lt;- sf::st_as_sf(xyt$window)
locs &lt;- data.frame(x = xyt$x, y = xyt$y)
bnd &lt;- fmesher::fm_as_segm(as.matrix(sf::st_coordinates(domain)[, 1:2]))
smesh &lt;- fmesher::fm_mesh_2d(boundary = bnd,
max.edge = 0.75, cutoff = 0.3)
fit &lt;- fit_lgcp(locs = locs, sf = domain, smesh = smesh,
parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1)))
### ********************** ###
## A spatiotemporal LGCP, AR(1)
### ********************** ###
ndays &lt;- 2
locs &lt;- data.frame(x = xyt$x, y = xyt$y, t = xyt$t)
w0 &lt;- 2
tmesh &lt;- fmesher::fm_mesh_1d(seq(0, ndays, by = w0))
fit &lt;- fit_lgcp(locs = locs, sf = domain, smesh = smesh, tmesh = tmesh,
 parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1), atanh_rho = 0.2))
}

</code></pre>

<hr>
<h2 id='fit_mlgcp'>Marked spatial log-Gaussian Cox process (mLGCP)</h2><span id='topic+fit_mlgcp'></span>

<h3>Description</h3>

<p>Fit a marked LGCP using Template Model Builder (TMB) and the <code>R_inla</code>
namespace for the SPDE-based construction of the latent field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mlgcp(
  locs,
  sf,
  marks,
  smesh,
  parameters = list(),
  methods,
  strfixed = matrix(1, nrow = nrow(locs), ncol = ncol(marks)),
  fields = rep(1, ncol(marks)),
  covariates,
  pp_covariates,
  marks_covariates,
  tmb_silent = TRUE,
  nlminb_silent = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mlgcp_+3A_locs">locs</code></td>
<td>
<p>A <code>data.frame</code> of <code>x</code> and <code>y</code> locations, 2xn.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_sf">sf</code></td>
<td>
<p>An <code>sf</code> of type <code>POLYGON</code> specifying the spatial region
of the domain.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_marks">marks</code></td>
<td>
<p>A matrix of marks for each observation of the point pattern.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_smesh">smesh</code></td>
<td>
<p>A Delaunay triangulation of the spatial domain returned by <code>fmesher::fm_mesh_2d()</code>.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_parameters">parameters</code></td>
<td>
<p>a list of named parameters:
log_tau, log_kappa, betamarks, betapp, marks_coefs_pp.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_methods">methods</code></td>
<td>
<p>An integer value:
</p>

<ul>
<li> <p><code>0</code> (default), Gaussian distribution, parameter estimated is mean;
</p>
</li>
<li> <p><code>1</code>, Poisson distribution, parameter estimated is intensity;
</p>
</li>
<li> <p><code>2</code>, binomial distribution, parameter estimated is logit/probability;
</p>
</li>
<li> <p><code>3</code>, gamma distribution, the implementation in TMB is shape-scale.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_strfixed">strfixed</code></td>
<td>
<p>A matrix of fixed structural parameters, defined for each event and mark.
Defaults to <code>1</code>. If mark distribution
</p>

<ul>
<li><p> Normal, then this is the log of standard deviation;
</p>
</li>
<li><p> Poisson, then not used;
</p>
</li>
<li><p> Binomial, then this is the number of trials;
</p>
</li>
<li><p> Gamma, then this is the log of the scale.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_fields">fields</code></td>
<td>
<p>A binary vector indicating whether there is a new random
field for each mark. By default, each mark has its own random field.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_covariates">covariates</code></td>
<td>
<p>Covariate(s) corresponding to each area in the spatial mesh</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_pp_covariates">pp_covariates</code></td>
<td>
<p>Which columns of the covariates apply to the point process</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_marks_covariates">marks_covariates</code></td>
<td>
<p>Which columns of the covariates apply to the marks.
By default, all covariates apply to the marks only.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_tmb_silent">tmb_silent</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then
TMB inner optimisation tracing information will be printed.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_nlminb_silent">nlminb_silent</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then for each iteration
<code>nlminb()</code> output will be printed.</p>
</td></tr>
<tr><td><code id="fit_mlgcp_+3A_...">...</code></td>
<td>
<p>optional extra arguments to pass into <code>stats::nlminb()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random intensity surface of the point process is (as <code><a href="#topic+fit_lgcp">fit_lgcp</a></code>)
<code class="reqn">\Lambda(\boldsymbol{x}) = \textrm{exp}(\boldsymbol{X}\beta + G(\boldsymbol{x}) + \epsilon)</code>,
for design matrix <code class="reqn">\boldsymbol{X}</code>, coefficients <code class="reqn">\boldsymbol{\beta}</code>, and random error <code class="reqn">\epsilon</code>.
</p>
<p>Each mark, <code class="reqn">m_j</code>, is jointly modelled and has their own random field
<code class="reqn">M_j(s) = f^{-1}((\boldsymbol{X}\beta)_{m_j} + G_{m_j}(\boldsymbol{x}) + \alpha_{m_j}\; G(\boldsymbol{x}) + \epsilon_{m_j})</code>
where <code class="reqn">\alpha_{.}</code> are coefficient(s) linking the point process and the mark(s).
</p>
<p><code class="reqn">M_j(s)</code> depends on the distribution of the marks. If the marks are from a Poisson distribution, it is
the intensity (as with the point process). If the marks are from a Binomial distribution, it is the
success probability, and the user must supply the number of trials for each event (via <code>strfixed</code>).
If the marks are normally distributed then this models the mean, and the user must supply
the standard deviation (via <code>strfixed</code>). The user can choose for the point processes and the marks to
share a common GMRF, i.e. <code class="reqn">G_m(s) = G_{pp}(s)</code>; this is controlled via the argument <code>fields</code>.
</p>


<h3>Value</h3>

<p>A list containing components of the fitted model, see <code>TMB::MakeADFun</code>. Includes
</p>

<ul>
<li> <p><code>par</code>, a numeric vector of estimated parameter values;
</p>
</li>
<li> <p><code>objective</code>, the objective function; and
</p>
</li>
<li> <p><code>gr</code>, the TMB calculated gradient function.
</p>
</li></ul>



<h3>References</h3>

<p>Lindgren, F., Rue, H., and Lindstr√∂m, J. (2011)
An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic
partial differential equation approach. <em>Journal of the Royal Statistical Society: Series B
(Statistical Methodology)</em>, <strong>73</strong>: 423&ndash;498.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_lgcp">fit_lgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### ********************** ###
## A joint likelihood marked LGCP model
### ********************** ###
if(requireNamespace("fmesher")){
data(marked, package = "stelfi")
loc.d &lt;- 3 * cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))
domain &lt;- sf::st_sf(geometry = sf::st_sfc(sf::st_polygon(list(loc.d))))
smesh &lt;- fmesher::fm_mesh_2d(loc.domain = loc.d, offset = c(0.3, 1),
max.edge = c(0.3, 0.7), cutoff = 0.05)
locs &lt;- cbind(x = marked$x, y = marked$y)
marks &lt;- cbind(m1 = marked$m1) ## Gaussian mark
parameters &lt;- list(betamarks = matrix(0, nrow = 1, ncol = ncol(marks)),
log_tau = rep(log(1), 2), log_kappa = rep(log(1), 2),
marks_coefs_pp = rep(0, ncol(marks)), betapp = 0)
fit &lt;- fit_mlgcp(locs = locs, marks = marks,
sf = domain, smesh = smesh,
parameters = parameters, methods = 0,fields = 1)
}

</code></pre>

<hr>
<h2 id='fit_stelfi'>Modelling spatiotemporal self-excitement</h2><span id='topic+fit_stelfi'></span>

<h3>Description</h3>

<p>Fits spatiotemporal Hawkes models. The self-excitement is 
Gaussian in space and exponentially decaying in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_stelfi(
  times,
  locs,
  sf,
  smesh,
  parameters,
  covariates,
  GMRF = FALSE,
  time_independent = TRUE,
  tmb_silent = TRUE,
  nlminb_silent = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_stelfi_+3A_times">times</code></td>
<td>
<p>A vector of numeric observed time points.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_locs">locs</code></td>
<td>
<p>A <code>data.frame</code> of <code>x</code> and <code>y</code> locations, 2xn.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_sf">sf</code></td>
<td>
<p>An <code>sf</code> of type <code>POLYGON</code> specifying the spatial region
of the domain.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_smesh">smesh</code></td>
<td>
<p>A Delaunay triangulation of the spatial domain returned by <code>fmesher::fm_mesh_2d()</code>.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_parameters">parameters</code></td>
<td>
<p>A list of named parameters:
</p>

<ul>
<li> <p><code>coefs</code>, logged base rate of the Hawkes process and coefficients of covariates
</p>
</li>
<li> <p><code>alpha</code>, intensity jump after an event occurrence
</p>
</li>
<li> <p><code>beta</code>,  rate of exponential decay of intensity after event occurrence
</p>
</li>
<li> <p><code>tau</code>,  <code class="reqn">\tau</code> parameter for the GMRF (supplied only if <code>GMRF = TRUE</code>)
</p>
</li>
<li> <p><code>kappa</code>, <code class="reqn">\kappa</code> parameter for the GMRF (supplied only if <code>GMRF = TRUE</code>)
</p>
</li>
<li> <p><code>xsigma</code>, standard deviation on x-axis of self-exciting kernel (if <code>time_independent = FALSE</code>, it is the s.d. after 1 time unit)
</p>
</li>
<li> <p><code>ysigma</code>, standard deviation on y-axis of self-exciting kernel (if <code>time_independent = FALSE</code>, it is the s.d. after 1 time unit)
</p>
</li>
<li> <p><code>rho</code>, correlation between x and y for the self-exciting kernel (the off-diagonal elements in the kernel's covariate matrix are <code>xsigma * ysigma * rho</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_covariates">covariates</code></td>
<td>
<p>Optional, a <code>matrix</code> of covariates at each
<code>smesh</code> node.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_gmrf">GMRF</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, a Gaussian Markov
Random Field is included as a latent spatial effect.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_time_independent">time_independent</code></td>
<td>
<p>Logical, default <code>TRUE</code>. If <code>FALSE</code>, Gaussian kernels have a
covariate matrix that is proportional to time since the event.
Warning, this is very memory intensive.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_tmb_silent">tmb_silent</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then
TMB inner optimisation tracing information will be printed.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_nlminb_silent">nlminb_silent</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) then for each iteration
<code>nlminb()</code> output will be printed.</p>
</td></tr>
<tr><td><code id="fit_stelfi_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>optim()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temporal self-excitement follows an exponential decay function.
The self-excitement over space follows a Gaussian distribution centered at the triggering event.
There are two formulations of this model. The default is that the Gaussian function has a fixed spatial
covariance matrix, independent of time. Alternatively, covariance can be directly proportional to time,
meaning that the self-excitement radiates out from the center over time.
This can be appropriate when the mechanism causing self-excitement travels
at a finite speed, but is very memory-intensive. The spatiotemporal intensity function
used by <code><a href="#topic+stelfi">stelfi</a></code> is
<code class="reqn">\lambda(s,t) = \mu + \alpha \Sigma_{i:\tau_i&lt;t}(\textrm{exp}(-\beta * (t-\tau_i)) G_i(s-x_i, t - \tau_i))</code>
where
</p>

<ul>
<li> <p><code class="reqn">\mu</code> is the background rate,
</p>
</li>
<li> <p><code class="reqn">\beta</code> is the rate of temporal decay,
</p>
</li>
<li> <p><code class="reqn">\alpha</code> is the increase in intensity after an event,
</p>
</li>
<li> <p><code class="reqn">\tau_i</code> are the event times,
</p>
</li>
<li> <p><code class="reqn">x_i</code> are the event locations (in 2D Euclidean space), and
</p>
</li>
<li> <p><code class="reqn">G_i(s-x_i, t - \tau_i)</code> is the spatial self-excitement kernel.
</p>
</li></ul>

<p><code class="reqn">G_i(.,.)</code> can take two forms:
</p>

<ul>
<li><p> For time-independent spatial excitement (<code>time_independent = TRUE</code>),
<code class="reqn">G_i(s-x_i, t - \tau_i) = f(s - x_i)</code>
where <code class="reqn">f</code> is the density function of <code class="reqn">\textrm{N}(0, \Sigma)</code>.
</p>
</li>
<li><p> For time-dependent spatial excitement (<code>time_independent = FALSE</code>),
<code class="reqn">G_i(s-x_i, t - \tau_i) = f(s - x_i)</code>
where <code class="reqn">f</code> is the density function of <code class="reqn">\textrm{N}(0, (t-\tau_i)\Sigma)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing components of the fitted model, see <code>TMB::MakeADFun</code>. Includes
</p>

<ul>
<li> <p><code>par</code>, a numeric vector of estimated parameter values;
</p>
</li>
<li> <p><code>objective</code>, the objective function; and
</p>
</li>
<li> <p><code>gr</code>, the TMB calculated gradient function.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fit_hawkes">fit_hawkes</a></code> and <code><a href="#topic+fit_lgcp">fit_lgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## No GMRF
if(requireNamespace("fmesher")){
data(xyt, package = "stelfi")
N &lt;- 50
locs &lt;- data.frame(x = xyt$x[1:N], y = xyt$y[1:N])
times &lt;- xyt$t[1:N]
domain &lt;- sf::st_as_sf(xyt$window)
bnd &lt;- fmesher::fm_as_segm(as.matrix(sf::st_coordinates(domain)[, 1:2]))
smesh &lt;- fmesher::fm_mesh_2d(boundary = bnd, max.edge = 0.75, cutoff = 0.3) 
param &lt;- list( mu = 3, alpha = 1, beta = 3, xsigma = 0.2, ysigma = 0.2, rho = 0.8)
fit &lt;- fit_stelfi(times = times, locs = locs, sf = domain, smesh = smesh, parameters = param) 
get_coefs(fit)
## GMRF
param &lt;- list( mu = 5, alpha = 1, beta = 3, kappa = 0.9, tau = 1, xsigma = 0.2,
ysigma = 0.2, rho = 0.8)
fit &lt;- fit_stelfi(times = times, locs = locs, sf = domain, smesh = smesh,
parameters = param, GMRF = TRUE)
get_coefs(fit)
}

</code></pre>

<hr>
<h2 id='get_coefs'>Extract reported parameter estimates</h2><span id='topic+get_coefs'></span>

<h3>Description</h3>

<p>Return parameter estimates from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_coefs(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_coefs_+3A_obj">obj</code></td>
<td>
<p>A fitted model as returned by one of  <code><a href="#topic+fit_hawkes">fit_hawkes</a></code>, <code><a href="#topic+fit_hawkes_cbf">fit_hawkes_cbf</a></code>, <code><a href="#topic+fit_lgcp">fit_lgcp</a></code>,  <code><a href="#topic+fit_mlgcp">fit_mlgcp</a></code>, or <code><a href="#topic+fit_stelfi">fit_stelfi</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of estimated parameters and standard errors returned by
<code>TMB::sdreport</code> (<code>"report"</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_hawkes">fit_hawkes</a></code>,  <code><a href="#topic+fit_hawkes_cbf">fit_hawkes_cbf</a></code>, <code><a href="#topic+fit_lgcp">fit_lgcp</a></code>,  <code><a href="#topic+fit_mlgcp">fit_mlgcp</a></code>, and <code><a href="#topic+fit_stelfi">fit_stelfi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Hawkes
data(retweets_niwa, package = "stelfi")
times &lt;- unique(sort(as.numeric(difftime(retweets_niwa, min(retweets_niwa),units = "mins"))))
params &lt;- c(mu = 9, alpha = 3, beta = 10)
fit &lt;- fit_hawkes(times = times, parameters = params)
get_coefs(fit)
## LGCP
if(requireNamespace("fmesher")) {
data(xyt, package = "stelfi")
domain &lt;- sf::st_as_sf(xyt$window)
locs &lt;- data.frame(x = xyt$x, y = xyt$y)
bnd &lt;- fmesher::fm_as_segm(as.matrix(sf::st_coordinates(domain)[, 1:2]))
smesh &lt;- fmesher::fm_mesh_2d(boundary = bnd, max.edge = 0.75, cutoff = 0.3)
fit &lt;- fit_lgcp(locs = locs, sf = domain, smesh = smesh,
parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1)))
get_coefs(fit)
}
</code></pre>

<hr>
<h2 id='get_fields'>Estimated random field(s)</h2><span id='topic+get_fields'></span>

<h3>Description</h3>

<p>Extract the estimated mean, or standard deviation, of the 
values of the Gaussian Markov random field for a fitted log-Gaussian
Cox process model at each node of <code>smesh</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fields(obj, smesh, tmesh, plot = FALSE, sd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fields_+3A_obj">obj</code></td>
<td>
<p>A fitted model object returned by <code><a href="#topic+fit_lgcp">fit_lgcp</a></code>.</p>
</td></tr>
<tr><td><code id="get_fields_+3A_smesh">smesh</code></td>
<td>
<p>A Delaunay triangulation of the spatial domain returned by <code>fmesher::fm_mesh_2d()</code>.</p>
</td></tr>
<tr><td><code id="get_fields_+3A_tmesh">tmesh</code></td>
<td>
<p>Optional, a temporal mesh returned by <code>fmesher::fm_mesh_1d()</code>.</p>
</td></tr>
<tr><td><code id="get_fields_+3A_plot">plot</code></td>
<td>
<p>Logical, if <code>TRUE</code> then the returned values are plotted.
Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_fields_+3A_sd">sd</code></td>
<td>
<p>Logical, if <code>TRUE</code> then standard errors returned.
Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector or a <code>list</code> of returned values at each <code>smesh</code> node.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_lgcp">fit_lgcp</a></code> and <code><a href="#topic+fit_mlgcp">fit_mlgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("fmesher")) {
data(xyt, package = "stelfi")
domain &lt;- sf::st_as_sf(xyt$window)
locs &lt;- data.frame(x = xyt$x, y = xyt$y)
bnd &lt;- fmesher::fm_as_segm(as.matrix(sf::st_coordinates(domain)[, 1:2]))
smesh &lt;- fmesher::fm_mesh_2d(boundary = bnd, max.edge = 0.75, cutoff = 0.3)
fit &lt;- fit_lgcp(locs = locs, sf = domain, smesh = smesh,
parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1)))
get_fields(fit, smesh, plot = TRUE)
}

</code></pre>

<hr>
<h2 id='get_weights'>Mesh weights</h2><span id='topic+get_weights'></span>

<h3>Description</h3>

<p>Calculate the  areas (weights) around the mesh nodes that 
are within the specified spatial polygon <code>sf</code> of the domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_weights(mesh, sf, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_weights_+3A_mesh">mesh</code></td>
<td>
<p>A spatial mesh of class <code>fmesher::fm_mesh_2d()</code></p>
</td></tr>
<tr><td><code id="get_weights_+3A_sf">sf</code></td>
<td>
<p>An <code>sf</code> of type <code>POLYGON</code> specifying the region
of the domain.</p>
</td></tr>
<tr><td><code id="get_weights_+3A_plot">plot</code></td>
<td>
<p>Logical, whether to plot the calculated <code>mesh</code> weights. 
Default, <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a simple features, <code>sf</code>, object or values returned by <code>geom_sf</code>.
</p>


<h3>See Also</h3>

<p><a href="https://becarioprecario.bitbucket.io/spde-gitbook/">https://becarioprecario.bitbucket.io/spde-gitbook/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(horse_mesh, package = "stelfi")
data(horse_sf, package = "stelfi")
get_weights(horse_mesh, horse_sf, plot = TRUE)
</code></pre>

<hr>
<h2 id='horse_mesh'>Example Delaunay triangulation</h2><span id='topic+horse_mesh'></span>

<h3>Description</h3>

<p>Example Delaunay triangulation
</p>


<h3>Format</h3>

<p>A <code>fmesher::fm_mesh_2d()</code> based on the outline of a horse
</p>

<hr>
<h2 id='horse_sf'>Example <code>sf</code> <code>POLYGON</code></h2><span id='topic+horse_sf'></span>

<h3>Description</h3>

<p>Example <code>sf</code> <code>POLYGON</code>
</p>


<h3>Format</h3>

<p>A <code>sf</code> <code>POLYGON</code> of a horse outline
</p>

<hr>
<h2 id='iraq_terrorism'>Terrorism in Iraq, 2013 - 2017</h2><span id='topic+iraq_terrorism'></span>

<h3>Description</h3>

<p>A dataset containing information of terrorism activity carried out
by the Islamic State of Iraq and the Levant (ISIL) in Iraq,
2013 - 2017.
</p>


<h3>Format</h3>

<p>A simple features dataframe, of type <code>POINT</code>, with 4208 observations and 16 fields:
</p>

<dl>
<dt>iyear</dt><dd><p>numeric year 2013&ndash;2017</p>
</dd>
<dt>imonth</dt><dd><p>numeric month index 1&ndash;12</p>
</dd>
<dt>iday</dt><dd><p>numeric day 1&ndash;31 (zeros are a non-entry)</p>
</dd>
<dt>country</dt><dd><p>country (IRAQ)</p>
</dd>
<dt>latitude</dt><dd><p>latitude location</p>
</dd>
<dt>longitude</dt><dd><p>longitude location</p>
</dd>
<dt>utm_x</dt><dd><p>x-coord location UTM</p>
</dd>
<dt>utm_y</dt><dd><p>y-coord location UTM</p>
</dd>
<dt>success</dt><dd><p>logical, was fatal? <code>TRUE</code> = fatal</p>
</dd>
<dt>nkill</dt><dd><p>number of fatalities per attack</p>
</dd>
<dt>specificity</dt><dd><p>spatial accuracy of event: 1 = most accurate, 5 = worst</p>
</dd>
<dt>gname</dt><dd><p>character name of attack perpetrators (ISIL)</p>
</dd>
<dt>x_coord</dt><dd><p>x coordinate from location projected onto a sphere</p>
</dd>
<dt>y_coord</dt><dd><p>y coordinate from location projected onto a sphere</p>
</dd>
<dt>z_coord</dt><dd><p>z coordinate from location projected onto a sphere</p>
</dd>
<dt>popdensity</dt><dd><p>scaled: number of people per kilometer squared</p>
</dd>
<dt>luminosity</dt><dd><p>scaled: luminosity</p>
</dd>
<dt>tt</dt><dd><p>scaled: time to nearest city in minutes</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.start.umd.edu/gtd/">https://www.start.umd.edu/gtd/</a>
</p>

<hr>
<h2 id='marked'>Example marked point pattern data set</h2><span id='topic+marked'></span>

<h3>Description</h3>

<p>Example marked point pattern data set
</p>


<h3>Format</h3>

<p>A data frame with 159 rows and 5 variables:
</p>

<dl>
<dt>x</dt><dd><p>x coordinate</p>
</dd>
<dt>y</dt><dd><p>y coordinate</p>
</dd>
<dt>m1</dt><dd><p>mark, Gaussian distributed</p>
</dd>
<dt>m2</dt><dd><p>mark, Bernoulli distributed</p>
</dd>
<dt>m3</dt><dd><p>mark, Gamma distributed</p>
</dd>
</dl>


<hr>
<h2 id='mesh_2_sf'>Transform a <code>fmesher::fm_mesh_2d</code> into a <code>sf</code> object</h2><span id='topic+mesh_2_sf'></span>

<h3>Description</h3>

<p>Transform a <code>fmesher::fm_mesh_2d</code> into a <code>sf</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh_2_sf(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_2_sf_+3A_mesh">mesh</code></td>
<td>
<p>A <code>fmesher::fm_mesh_2d</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple features, <code>sf</code>, object.
</p>


<h3>Source</h3>

<p>Modified from <code>sp</code> based function suggested by Finn in the
R-inla discussion Google Group
<a href="https://groups.google.com/g/r-inla-discussion-group/c/z1n1exlZrKM">https://groups.google.com/g/r-inla-discussion-group/c/z1n1exlZrKM</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meshmetrics">meshmetrics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(horse_mesh, package = "stelfi")
sf &lt;- mesh_2_sf(horse_mesh)
if(require("ggplot2")) {
ggplot(sf) + geom_sf()
}
</code></pre>

<hr>
<h2 id='meshmetrics'>Calculate a number of different geometric attributes of a Delaunay triangulation</h2><span id='topic+meshmetrics'></span>

<h3>Description</h3>

<p>Calculates a number of geometric attributes for a given
Delaunay triangulation based on the circumscribed and inscribed circle of each triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meshmetrics(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meshmetrics_+3A_mesh">mesh</code></td>
<td>
<p>A <code>fmesher::fm_mesh_2d</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A triangle's circumcircle (circumscribed circle) is the unique circle that passes
through each of its three vertices. A triangle's incircle (inscribed circle) is the
largest circle that can be contained within it (i.e., touches it's three edges).
</p>


<h3>Value</h3>

<p>An object of class <code>sf</code> with the following data for each triangle in the
triangulation
</p>

<ul>
<li> <p><code>V1</code>, <code>V2</code>, and <code>V3</code> corresponding vertices
of <code>mesh</code> matches <code>mesh$graph$tv</code>;
</p>
</li>
<li> <p><code>ID</code>, numeric triangle id;
</p>
</li>
<li> <p><code>angleA</code>, <code>angleB</code>, and <code>angleC</code>, the
interior angles;
</p>
</li>
<li><p> circumcircle radius, circumradius, <code>circumcircle_R</code> (<code class="reqn">R</code>);
</p>
</li>
<li><p> incircle radius <code>incircle_r</code> (<code class="reqn">r</code>);
</p>
</li>
<li><p> centroid locations of the circumcircle, circumcenter, (<code>c_Ox, c_Oy</code>);
</p>
</li>
<li><p> centroid locations of the incircle, incenter, (<code>i_Ox, i_Oy</code>);
</p>
</li>
<li><p> the radius-edge ratio <code>radius_edge</code> <code class="reqn">\frac{R}{l_{min}}</code>,
where <code class="reqn">l_{min}</code> is the minimum edge length;
</p>
</li>
<li><p> the radius ratio <code>radius_ratio</code> <code class="reqn">\frac{r}{R}</code>;
</p>
</li>
<li> <p><code>area</code>, area (<code class="reqn">A</code>);
</p>
</li>
<li> <p><code>quality</code> a measure of &quot;quality&quot; defined as
<code class="reqn">\frac{4\sqrt{3}|A|}{\Sigma_{i = 1}^3 L_i^2}</code>,
where <code class="reqn">L_i</code> is the length of edge <code class="reqn">i</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(horse_mesh, package = "stelfi")
metrics &lt;- meshmetrics(horse_mesh)
if(require("ggplot2")) {
ggplot(metrics) + geom_sf(aes(fill = radius_ratio))
}
</code></pre>

<hr>
<h2 id='multi_hawkes'>Example multivariate Hawkes dataset</h2><span id='topic+multi_hawkes'></span>

<h3>Description</h3>

<p>Two-stream multivariate Hawkes data with <code class="reqn">mu_1 = \mu_2 = 0.2</code>,
<code class="reqn">beta_1 = \beta_2 = 0.7</code>, and <code class="reqn">\boldsymbol{\alpha}</code> =
<code>matrix(c(0.5,0.1,0.1,0.5),byrow = TRUE,nrow = 2)</code>.
</p>


<h3>Format</h3>

<p>A data frame with 213 observations and 2 variables:
</p>

<dl>
<dt>times</dt><dd><p>ordered time stamp of observation</p>
</dd>
<dt>stream</dt><dd><p>character giving stream ID (i.e., Stream 1 or
Stream 2) of observation</p>
</dd>
</dl>


<hr>
<h2 id='nz_earthquakes'>Earthquakes in Canterbury, NZ, 2010 - 2014</h2><span id='topic+nz_earthquakes'></span>

<h3>Description</h3>

<p>Earthquake data from Canterbury,
New Zealand 16-Jan-2010&ndash;24-Dec-2014.
</p>


<h3>Format</h3>

<p>A simple features dataframe, of type <code>POINT</code>, with 3824 observations and 3 fields:
</p>

<dl>
<dt>origintime</dt><dd><p>The UTC time of the event's occurrence</p>
</dd>
<dt>magnitude</dt><dd><p>The magnitude of the earthquake</p>
</dd>
<dt>depth</dt><dd><p>The focal depth of the event (km)</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://quakesearch.geonet.org.nz/">https://quakesearch.geonet.org.nz/</a>
</p>

<hr>
<h2 id='nz_murders'>Murders of NZ, 2004 - 2019</h2><span id='topic+nz_murders'></span>

<h3>Description</h3>

<p>A dataset of recorded murder cases in New Zealand 2004 - 2019.
</p>


<h3>Format</h3>

<p>A simple features dataframe, of type <code>POINT</code>, with 967 observations and 11 fields:
</p>

<dl>
<dt>sex</dt><dd><p>Biological sex of victim</p>
</dd>
<dt>age</dt><dd><p>Age of victim (years)</p>
</dd>
<dt>date</dt><dd><p>Month and day of murder</p>
</dd>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>cause</dt><dd><p>Cause of death</p>
</dd>
<dt>killer</dt><dd><p>Killer</p>
</dd>
<dt>name</dt><dd><p>Name of victim</p>
</dd>
<dt>full_date</dt><dd><p>Date object of observation on single days</p>
</dd>
<dt>month</dt><dd><p>Month name of observation</p>
</dd>
<dt>cause_cat</dt><dd><p>Cause of death as category</p>
</dd>
<dt>region</dt><dd><p>NZ region</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data scraped and cleaned by Charlie Timmings,
honours student at the University of Auckland from the website
<a href="https://interactives.stuff.co.nz/2019/the-homicide-report/">https://interactives.stuff.co.nz/2019/the-homicide-report/</a>
</p>

<hr>
<h2 id='retweets_niwa'>Retweets of NIWA's viral leopard seal Tweet</h2><span id='topic+retweets_niwa'></span>

<h3>Description</h3>

<p>A dataset of retweet times of NIWA's viral leopard seal tweet
on the 5th Feb 2019 (<a href="https://twitter.com/niwa_nz/status/1092610541401587712">https://twitter.com/niwa_nz/status/1092610541401587712</a>).
</p>


<h3>Format</h3>

<p>A vector of length 4890 specifying the date and time of retweet (UTC)
</p>


<h3>Source</h3>

<p><a href="https://twitter.com/niwa_nz/status/1092610541401587712">https://twitter.com/niwa_nz/status/1092610541401587712</a>
</p>

<hr>
<h2 id='sasquatch'>Sasquatch (bigfoot) sightings in the USA, 2000 - 2005</h2><span id='topic+sasquatch'></span>

<h3>Description</h3>

<p>Subset of data sourced from the Bigfoot Field Researchers Organization (BFRO)
(<a href="https://data.world/timothyrenner/bfro-sightings-data">https://data.world/timothyrenner/bfro-sightings-data</a>).
</p>


<h3>Format</h3>

<p>A simple features dataframe, of type <code>POINT</code>, with 972 observations and 27 fields:
</p>

<dl>
<dt>observed</dt><dd><p>Text observation summary</p>
</dd>
<dt>location_details</dt><dd><p>Text location summary</p>
</dd>
<dt>county</dt><dd><p>County</p>
</dd>
<dt>state</dt><dd><p>State</p>
</dd>
<dt>season</dt><dd><p>Season</p>
</dd>
<dt>title</dt><dd><p>Report title</p>
</dd>
<dt>date</dt><dd><p>Date</p>
</dd>
<dt>number</dt><dd><p>Report number</p>
</dd>
<dt>classification</dt><dd><p>Report classification</p>
</dd>
<dt>geohash</dt><dd><p>Geohash code</p>
</dd>
<dt>temperature_high</dt><dd><p>Reported weather measure</p>
</dd>
<dt>temperature_mid</dt><dd><p>Reported weather measure</p>
</dd>
<dt>temperature_low</dt><dd><p>Reported weather measure</p>
</dd>
<dt>dew_point</dt><dd><p>Reported weather measure</p>
</dd>
<dt>humidity</dt><dd><p>Reported weather measure</p>
</dd>
<dt>cloud_cover</dt><dd><p>Reported weather measure</p>
</dd>
<dt>moon_phase</dt><dd><p>Reported measure</p>
</dd>
<dt>precip_intensity</dt><dd><p>Reported weather measure</p>
</dd>
<dt>precip_probability</dt><dd><p>Reported weather measure</p>
</dd>
<dt>precip_type</dt><dd><p>Reported weather measure</p>
</dd>
<dt>pressure</dt><dd><p>Reported weather measure</p>
</dd>
<dt>summary</dt><dd><p>Text weather summary</p>
</dd>
<dt>uv_index</dt><dd><p>Reported weather measure</p>
</dd>
<dt>visibility</dt><dd><p>Reported weather measure</p>
</dd>
<dt>wind_bearing</dt><dd><p>Reported weather measure</p>
</dd>
<dt>wind_speed</dt><dd><p>Reported weather measure</p>
</dd>
<dt>year</dt><dd><p>Year</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://data.world/timothyrenner/bfro-sightings-data">https://data.world/timothyrenner/bfro-sightings-data</a>
</p>

<hr>
<h2 id='show_field'>Plot the estimated random field(s) of a fitted LGCP</h2><span id='topic+show_field'></span>

<h3>Description</h3>

<p>Plots the values of <code>x</code> at each node of <code>smesh</code>, with
optional control over resolutions using <code>dims</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_field(x, smesh, sf, dims = c(500, 500), clip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_field_+3A_x">x</code></td>
<td>
<p>A vector of values, one value per each <code>smesh</code> node.</p>
</td></tr>
<tr><td><code id="show_field_+3A_smesh">smesh</code></td>
<td>
<p>A Delaunay triangulation of the spatial domain returned by <code>fmesher::fm_mesh_2d()</code>.</p>
</td></tr>
<tr><td><code id="show_field_+3A_sf">sf</code></td>
<td>
<p>Optional, <code>sf</code> of type <code>POLYGON</code> specifying the region
of the domain.</p>
</td></tr>
<tr><td><code id="show_field_+3A_dims">dims</code></td>
<td>
<p>A numeric vector of length 2 specifying
the spatial pixel resolution. Default <code>c(500,500)</code>.</p>
</td></tr>
<tr><td><code id="show_field_+3A_clip">clip</code></td>
<td>
<p>Logical, if <code>TRUE</code> then plotted values are 'clipped' to the domain
supplied as <code>sf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gg</code> class object, values returned by <code>geom_tile</code> and <code>geom_sf</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+show_lambda">show_lambda</a></code> and <code><a href="#topic+get_fields">get_fields</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("fmesher")){
if(require("sf")){
data(xyt, package = "stelfi")
domain &lt;- sf::st_as_sf(xyt$window)
bnd &lt;- fmesher::fm_as_segm(as.matrix(sf::st_coordinates(domain)[, 1:2]))
smesh &lt;- fmesher::fm_mesh_2d(boundary = bnd, max.edge = 0.75, cutoff = 0.3)
parameters &lt;- c(beta = 1, log_tau = log(1), log_kappa = log(1))
simdata &lt;- sim_lgcp(parameters = parameters, sf = domain, smesh = smesh)
show_field(c(simdata$x), smesh = smesh, sf = domain)
show_field(c(simdata$x), smesh = smesh, sf = domain, clip = TRUE)
}
}

</code></pre>

<hr>
<h2 id='show_hawkes'>Plot Hawkes intensity</h2><span id='topic+show_hawkes'></span><span id='topic+show_hawkes_GOF'></span>

<h3>Description</h3>

<p>Plots a Hawkes intensity function, options to extend to 
non-homogeneous background intensity.
</p>
<p>Plots a number of goodness-of-fit plots for a fitted
Hawkes process. Includes 1) a comparison of the  compensator and observed 
events, 2) a histogram of transformed interarrival times, 3) a Q-Q plot of 
transformed interarrival times, and 4) the CDF of consecutive interarrival 
times, In addition, results of a Kolmogorov-Smirnov and
Ljung-Box hypothesis test for the interarrival times are printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_hawkes(obj)

show_hawkes_GOF(
  obj,
  background_integral = NULL,
  plot = TRUE,
  return_values = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_hawkes_+3A_obj">obj</code></td>
<td>
<p>Either object returned by <code><a href="#topic+fit_hawkes">fit_hawkes</a></code>/<code><a href="#topic+fit_hawkes_cbf">fit_hawkes_cbf</a></code> 
or a named list with elements <code>times</code> and <code>params</code>. If the latter, 
then <code>times</code> should be a numeric vector of observed time points, and 
<code>params</code> must contain, <code>alpha</code> (intensity jump after an event occurrence) 
and <code>beta</code> (exponential intensity decay). In addition, should contain 
either <code>mu</code> (base rate of the Hawkes process) or <code>background_parameters</code>
(parameter(s) for the assumed non-homogeneous background function;
could be a list of multiple values). May also contain <code>marks</code> (a vector of numerical marks).</p>
</td></tr>
<tr><td><code id="show_hawkes_+3A_background_integral">background_integral</code></td>
<td>
<p>Function, as defined in <code><a href="#topic+fit_hawkes_cbf">fit_hawkes_cbf</a></code>.</p>
</td></tr>
<tr><td><code id="show_hawkes_+3A_plot">plot</code></td>
<td>
<p>Logical, whether to plot  goodness-of-fit plots. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="show_hawkes_+3A_return_values">return_values</code></td>
<td>
<p>Logical, whether to return GOF values. Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+show_hawkes">show_hawkes</a></code> returns a <code>gtable</code> object
with <code>geom_line</code> and <code>geom_histogram</code> values.
</p>
<p><code><a href="#topic+show_hawkes_GOF">show_hawkes_GOF</a></code> returns no value unless <code>return_values = TRUE</code>,
in this case a list of interarrival times is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(retweets_niwa, package = "stelfi")
times &lt;- unique(sort(as.numeric(difftime(retweets_niwa, min(retweets_niwa),units = "mins"))))
params &lt;- c(mu = 9, alpha = 3, beta = 10)
show_hawkes(list(times = times, params = params))
fit &lt;- fit_hawkes(times = times, parameters = params)
show_hawkes(fit)
data(retweets_niwa, package = "stelfi")
times &lt;- unique(sort(as.numeric(difftime(retweets_niwa, min(retweets_niwa),units = "mins"))))
params &lt;- c(mu = 9, alpha = 3, beta = 10)
show_hawkes_GOF(list(times = times, params = params))
fit &lt;- fit_hawkes(times = times, parameters = params)
show_hawkes_GOF(fit)
</code></pre>

<hr>
<h2 id='show_lambda'>Plot the estimated intensity from a fitted LGCP model</h2><span id='topic+show_lambda'></span>

<h3>Description</h3>

<p>Plots the estimated spatial intensity from
a fitted log-Gaussian Cox process model. If <code>obj</code> is a
spatiotemporal model then <code>timestamp</code> provides control
over which temporal index to plot the estimated spatial intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_lambda(
  obj,
  smesh,
  sf,
  tmesh,
  covariates,
  clip = FALSE,
  dims = c(500, 500),
  timestamp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_lambda_+3A_obj">obj</code></td>
<td>
<p>A fitted LGCP model object for, for example, <code>fit_lgcp()</code>.</p>
</td></tr>
<tr><td><code id="show_lambda_+3A_smesh">smesh</code></td>
<td>
<p>A Delaunay triangulation of the spatial domain returned by <code>fmesher::fm_mesh_2d()</code>.</p>
</td></tr>
<tr><td><code id="show_lambda_+3A_sf">sf</code></td>
<td>
<p>An <code>sf</code> of type <code>POLYGON</code> specifying the spatial region
of the domain.</p>
</td></tr>
<tr><td><code id="show_lambda_+3A_tmesh">tmesh</code></td>
<td>
<p>Optional, a temporal mesh returned by <code>fmesher::fm_mesh_1d()</code>.</p>
</td></tr>
<tr><td><code id="show_lambda_+3A_covariates">covariates</code></td>
<td>
<p>Optional, a <code>matrix</code> of covariates at each
<code>smesh</code> and <code>tmesh</code> node combination.</p>
</td></tr>
<tr><td><code id="show_lambda_+3A_clip">clip</code></td>
<td>
<p>Logical, if <code>TRUE</code> then plotted values are 'clipped' to the domain
supplied as <code>sf</code>.</p>
</td></tr>
<tr><td><code id="show_lambda_+3A_dims">dims</code></td>
<td>
<p>A numeric vector of length 2 specifying
the spatial pixel resolution. Default <code>c(500,500)</code>.</p>
</td></tr>
<tr><td><code id="show_lambda_+3A_timestamp">timestamp</code></td>
<td>
<p>The index of time stamp to plot. Default <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gg</code> class object, values returned by <code>geom_tile</code> and <code>geom_sf</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_lgcp">fit_lgcp</a></code>, <code><a href="#topic+show_field">show_field</a></code>, and <code><a href="#topic+get_fields">get_fields</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("fmesher")) {
data(xyt, package = "stelfi")
domain &lt;- sf::st_as_sf(xyt$window)
locs &lt;- data.frame(x = xyt$x, y = xyt$y)
bnd &lt;- fmesher::fm_as_segm(as.matrix(sf::st_coordinates(domain)[, 1:2]))
smesh &lt;- fmesher::fm_mesh_2d(boundary = bnd, max.edge = 0.75, cutoff = 0.3)
fit &lt;- fit_lgcp(locs = locs, sf = domain, smesh = smesh,
parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1)))
show_lambda(fit, smesh = smesh, sf = domain)
}

</code></pre>

<hr>
<h2 id='sim_hawkes'>Simulate a self-exciting Hawkes process</h2><span id='topic+sim_hawkes'></span>

<h3>Description</h3>

<p>Simulates a self-exciting Hawkes process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_hawkes(mu, alpha, beta, n = 100, plot = FALSE, seed = 123, method = "1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_hawkes_+3A_mu">mu</code></td>
<td>
<p>A numeric specifying base rate of the Hawkes process.</p>
</td></tr>
<tr><td><code id="sim_hawkes_+3A_alpha">alpha</code></td>
<td>
<p>A numeric specifying intensity jump after an event
occurrence.</p>
</td></tr>
<tr><td><code id="sim_hawkes_+3A_beta">beta</code></td>
<td>
<p>A numeric specifying exponential intensity decay</p>
</td></tr>
<tr><td><code id="sim_hawkes_+3A_n">n</code></td>
<td>
<p>A numeric depending on method: if <code>method = "1"</code> specifies
end of the time line within which to simulate the process, 
if <code>method = "2"</code> specifies the number of observations to simulate.
Default, <code>100</code>.</p>
</td></tr>
<tr><td><code id="sim_hawkes_+3A_plot">plot</code></td>
<td>
<p>Logical, if <code>TRUE</code> data plotted along with the intensity.
Default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim_hawkes_+3A_seed">seed</code></td>
<td>
<p>The seed. Default, <code>123</code></p>
</td></tr>
<tr><td><code id="sim_hawkes_+3A_method">method</code></td>
<td>
<p>A character &quot;1&quot; or &quot;2&quot; specifying the method (see details)
to simulate Hawkes process. Default,<code>"1"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Option of two methods to simulate a Hawkes process: 
if <code>method = "1"</code> then a univariate Hawkes process as 
<code>hawkes::simulateHawkes()</code> is simulated,
if <code>method = "2"</code> then an accept/reject
framework is used.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector of simulated event times.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_hawkes">fit_hawkes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_hawkes(10.2, 3.1, 8.9)
sim_hawkes(10.2, 3.1, 8.9, method = "2")

</code></pre>

<hr>
<h2 id='sim_lgcp'>Simulate a log-Gaussian Cox process (LGCP)</h2><span id='topic+sim_lgcp'></span>

<h3>Description</h3>

<p>Simulate a realisation of a log-Gaussian Cox process (LGCP) using the
<code>TMB</code> <code>C++</code> template. If <code>rho</code> is supplied in <code>parameters</code>
as well as <code>tmesh</code> then spatiotemporal (AR(1)) data will be simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_lgcp(parameters, sf, smesh, tmesh, covariates, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_lgcp_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter starting values:
</p>

<ul>
<li> <p><code>beta</code>, a vector of fixed effects coefficients to be estimated, <code class="reqn">\beta</code>
(same length as <code>ncol(covariates)</code> + 1 );
</p>
</li>
<li>  <p><code>log_tau</code>, the <code class="reqn">\textrm{log}(\tau)</code> parameter for the GMRF;
</p>
</li>
<li> <p><code>log_kappa</code>, <code class="reqn">\textrm{log}(\kappa)</code> parameter for the GMRF;
</p>
</li>
<li> <p><code>atanh_rho</code>, optional, <code class="reqn">\textrm{arctan}(\rho)</code> AR1 temporal parameter.
</p>
</li></ul>

<p>Default values are used if none are provided. NOTE: these may not always be appropriate.</p>
</td></tr>
<tr><td><code id="sim_lgcp_+3A_sf">sf</code></td>
<td>
<p>An <code>sf</code> of type <code>POLYGON</code> specifying the spatial region
of the domain.</p>
</td></tr>
<tr><td><code id="sim_lgcp_+3A_smesh">smesh</code></td>
<td>
<p>A Delaunay triangulation of the spatial domain returned by <code>fmesher::fm_mesh_2d()</code>.</p>
</td></tr>
<tr><td><code id="sim_lgcp_+3A_tmesh">tmesh</code></td>
<td>
<p>Optional, a temporal mesh returned by <code>fmesher::fm_mesh_1d()</code>.</p>
</td></tr>
<tr><td><code id="sim_lgcp_+3A_covariates">covariates</code></td>
<td>
<p>Optional, a <code>matrix</code> of covariates at each
<code>smesh</code> and <code>tmesh</code> node combination.</p>
</td></tr>
<tr><td><code id="sim_lgcp_+3A_all">all</code></td>
<td>
<p>Logical, if <code>TRUE</code> then all model components are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. If <code>all = FALSE</code> then only the simulated values of
the GMRF at each mesh node are returned, <code>x</code>, alongside the number of
events, <code>y</code>, simulated at each node.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_lgcp">fit_lgcp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("fmesher")){
if(require("sf")) {
data(xyt, package = "stelfi")
domain &lt;- sf::st_as_sf(xyt$window)
bnd &lt;- fmesher::fm_as_segm(as.matrix(sf::st_coordinates(domain)[, 1:2]))
smesh &lt;- fmesher::fm_mesh_2d(boundary = bnd,
max.edge = 0.75, cutoff = 0.3)
parameters &lt;- c(beta = 1, log_tau = log(1), log_kappa = log(1))
sim &lt;- sim_lgcp(parameters = parameters, sf = domain, smesh = smesh)
## spatiotemporal
ndays &lt;- 2
w0 &lt;- 2
tmesh &lt;- fmesher::fm_mesh_1d(seq(0, ndays, by = w0))
parameters &lt;- c(beta = 1, log_tau = log(1), log_kappa = log(1), atanh_rho = 0.2)
sim &lt;- sim_lgcp(parameters = parameters, sf = domain, smesh = smesh, tmesh = tmesh)
}
}
</code></pre>

<hr>
<h2 id='stelfi'>A package to fit Hawkes and Log-Gaussian Cox Point Process models
using Template Model Builder</h2><span id='topic+stelfi'></span><span id='topic+stelfi-package'></span>

<h3>Description</h3>

<p>Fit Hawkes and log-Gaussian Cox process models with extensions.
Introduced in Hawkes (1971) a Hawkes process is a
self-exciting temporal point process where the occurrence of an event
immediately increases the chance of another. We extend this to consider
self-inhibiting process and a non-homogeneous background rate.
A log-Gaussian Cox process is a Poisson point process where the
log-intensity is given by a Gaussian random field. We extend this
to a joint likelihood formulation fitting a marked log-Gaussian Cox model.
In addition, the package offers functionality to fit self-exciting
spatiotemporal point processes. Models are fitted via maximum likelihood
using 'TMB' (Template Model Builder) (Kristensen, Nielsen, Berg, Skaug,
and Bell, 2016). Where included 1) random fields are assumed to be
Gaussian and are integrated over using the Laplace approximation and
2) a stochastic partial differential equation model, introduced by
Lindgren, Rue, and Lindstr√∂m. (2011), is defined for the field(s).
</p>


<h3>Model fitting</h3>


<ul>
<li><p> The functions <code><a href="#topic+fit_hawkes">fit_hawkes</a></code> and <code><a href="#topic+fit_hawkes_cbf">fit_hawkes_cbf</a></code>
fit self-exciting Hawkes (Hawkes AG., 1971) processes to temporal point pattern data.
</p>
</li>
<li><p> The function <code><a href="#topic+fit_lgcp">fit_lgcp</a></code> fit a log-Gaussian Cox process to
either spatial or spatiotemporal point pattern data. If a spatiotemporal
model is fitted a AR1 process is assumed for the temporal progression.
</p>
</li>
<li><p> The function <code><a href="#topic+fit_mlgcp">fit_mlgcp</a></code> fits a joint likelihood model between
the point locations and the mark(s).
</p>
</li>
<li><p> The function <code><a href="#topic+fit_stelfi">fit_stelfi</a></code> fits self-exciting spatiotemporal
Hawkes models to point pattern data. The self-excitement is Gaussian in space
and exponentially decaying over time. In addition, a GMRF can be included
to account for latent spatial dependency.
</p>
</li></ul>



<h3>References</h3>

<p>Hawkes, AG. (1971) Spectra of some self-exciting and
mutually exciting point processes. <em>Biometrika</em>, <strong>58</strong>: 83&ndash;90.
</p>
<p>Lindgren, F., Rue, H., and Lindstr√∂m, J. (2011)
An explicit link between Gaussian fields and Gaussian Markov random
fields: the stochastic partial differential equation approach.
<em>Journal of the Royal Statistical Society: Series B
(Statistical Methodology)</em>, <strong>73</strong>: 423&ndash;498.
</p>
<p>Kristensen, K., Nielsen, A., Berg, C. W., Skaug, H., and
Bell B. M. (2016). TMB: Automatic Differentiation and Laplace
Approximation. <em>Journal of Statistical Software</em>, <strong>70</strong>: 1&ndash;21.
</p>

<hr>
<h2 id='uk_serial'>Serial killers of the UK, 1828 - 2015</h2><span id='topic+uk_serial'></span>

<h3>Description</h3>

<p>A dataset containing the names and number of recorded
murders committed by some of the infamous UK serial killers
from 1828 to 2015.
</p>


<h3>Format</h3>

<p>A dataframe with 62 rows and 8 variables:
</p>

<dl>
<dt>number_of_kills</dt><dd><p>approx number of murders committed</p>
</dd>
<dt>years</dt><dd><p>The years of operation</p>
</dd>
<dt>name</dt><dd><p>Name of convicted serial killer</p>
</dd>
<dt>aka</dt><dd><p>Some serial killers were given nicknames</p>
</dd>
<dt>year_start</dt><dd><p>Year the murders began</p>
</dd>
<dt>tear_end</dt><dd><p>Year the murders ended</p>
</dd>
<dt>date_of_first_kill</dt><dd><p>Date, if known, first murder was committed</p>
</dd>
<dt>population_million</dt><dd><p>Est popn in millions at time of first murder</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.murderuk.com/">https://www.murderuk.com/</a>
</p>

<hr>
<h2 id='xyt'>Self-exciting point pattern</h2><span id='topic+xyt'></span>

<h3>Description</h3>

<p>Simulated self-exciting spatiotemporal point pattern of class <code>stppp</code>
</p>


<h3>Format</h3>

<p>A <code>stppp</code> object with 653 observations
</p>

<dl>
<dt>window</dt><dd><p>Domain of the point pattern of class <code>owin</code></p>
</dd>
<dt>n</dt><dd><p>Number of observations, 653</p>
</dd>
<dt>x</dt><dd><p>x coordinate</p>
</dd>
<dt>y</dt><dd><p>y coordinate</p>
</dd>
<dt>markformat</dt><dd><p><code>none</code></p>
</dd>
<dt>t</dt><dd><p>Timestamp of points</p>
</dd>
<dt>tlim</dt><dd><p>Time frame <code>0 2</code></p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
