<!DOCTYPE html><html><head><title>Help for package magi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {magi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calCov'><p>Calculate stationary Gaussian process kernel</p></a></li>
<li><a href='#FNdat'><p>Dataset of noisy observations from the FitzHugh-Nagumo (FN) equations</p></a></li>
<li><a href='#fnmodelODE'><p>The FitzHugh-Nagumo (FN) equations</p></a></li>
<li><a href='#gpcov'><p>Conditional covariance of Gaussian process given observations</p></a></li>
<li><a href='#gpmean'><p>Conditional mean of Gaussian process given observations</p></a></li>
<li><a href='#gpsmoothing'><p>Gaussian process smoothing</p></a></li>
<li><a href='#gpsmoothllik'><p>Marginal log-likelihood for Gaussian process smoothing</p></a></li>
<li><a href='#hes1modelODE'><p>Hes1 equations: oscillation of mRNA and protein levels</p></a></li>
<li><a href='#is.magioutput'><p>MagiSolver output (<code>magioutput</code>) object</p></a></li>
<li><a href='#magi'><p><code>magi</code>: MAnifold-Constrained Gaussian Process Inference</p></a></li>
<li><a href='#MagiPosterior'><p>MAGI posterior density</p></a></li>
<li><a href='#MagiSolver'><p>MAnifold-constrained Gaussian process Inference (MAGI)</p></a></li>
<li><a href='#plot.magioutput'><p>Generate plots from <code>magioutput</code> object</p></a></li>
<li><a href='#ptransmodelODE'><p>Protein transduction model</p></a></li>
<li><a href='#setDiscretization'><p>Set discretization level</p></a></li>
<li><a href='#summary.magioutput'><p>Summary of parameter estimates from <code>magioutput</code> object</p></a></li>
<li><a href='#testDynamicalModel'><p>Test dynamic system model specification</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>MAnifold-Constrained Gaussian Process Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-21</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides fast and accurate inference for the parameter estimation problem in Ordinary Differential
    Equations, including the case when there are unobserved system components. Implements the MAGI method
    (MAnifold-constrained Gaussian process Inference) of Yang, Wong, and Kou (2021) &lt;<a href="https://doi.org/10.1073%2Fpnas.2020397118">doi:10.1073/pnas.2020397118</a>&gt;.
    A user guide is provided by the accompanying software paper Wong, Yang, and Kou (2024) &lt;<a href="https://doi.org/10.18637%2Fjss.v109.i04">doi:10.18637/jss.v109.i04</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.18637/jss.v109.i04">https://doi.org/10.18637/jss.v109.i04</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6), gridExtra, gridBase, grid, methods, deSolve</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, BH, roptim</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, mvtnorm, covr, knitr, MASS, rmarkdown, markdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-21 21:13:19 UTC; s246wong</td>
</tr>
<tr>
<td>Author:</td>
<td>Shihao Yang <a href="https://orcid.org/0000-0003-3910-4969"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Samuel W.K. Wong <a href="https://orcid.org/0000-0002-7325-7267"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  S.C. Kou [ctb, cph] (Contributor of MAGI method development)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shihao Yang &lt;shihao.yang@isye.gatech.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-22 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calCov'>Calculate stationary Gaussian process kernel</h2><span id='topic+calCov'></span>

<h3>Description</h3>

<p>Covariance calculations for Gaussian process kernels.
Currently supports matern, rbf, compact1, periodicMatern, generalMatern, and rationalQuadratic kernels.
Can also return m_phi and other additional quantities useful for ODE inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calCov(
  phi,
  rInput,
  signrInput,
  bandsize = NULL,
  complexity = 3,
  kerneltype = "matern",
  df,
  noiseInjection = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calCov_+3A_phi">phi</code></td>
<td>
<p>the kernel hyper-parameters. See details for hyper-parameter specification for each <code>kerneltype</code>.</p>
</td></tr>
<tr><td><code id="calCov_+3A_rinput">rInput</code></td>
<td>
<p>the distance matrix between all time points s and t, i.e., |s - t|</p>
</td></tr>
<tr><td><code id="calCov_+3A_signrinput">signrInput</code></td>
<td>
<p>the sign matrix of the time differences, i.e., sign(s - t)</p>
</td></tr>
<tr><td><code id="calCov_+3A_bandsize">bandsize</code></td>
<td>
<p>size for band matrix approximation. See details.</p>
</td></tr>
<tr><td><code id="calCov_+3A_complexity">complexity</code></td>
<td>
<p>integer value for the complexity of the kernel calculations desired:
</p>

<ul>
<li><p> 0 includes C only
</p>
</li>
<li><p> 1 additionally includes Cprime, Cdoubleprime, dCdphi
</p>
</li>
<li><p> 2 or above additionally includes Ceigen1over, CeigenVec, Cinv, mphi, Kphi, Keigen1over, KeigenVec, Kinv, mphiLeftHalf, dCdphiCube
</p>
</li></ul>

<p>See details for their definitions.</p>
</td></tr>
<tr><td><code id="calCov_+3A_kerneltype">kerneltype</code></td>
<td>
<p>must be one of <code>matern</code>, <code>rbf</code>, <code>compact1</code>, <code>periodicMatern</code>, <code>generalMatern</code>, <code>rationalQuadratic</code>. See details for the kernel formulae.</p>
</td></tr>
<tr><td><code id="calCov_+3A_df">df</code></td>
<td>
<p>degrees of freedom, for <code>generalMatern</code> and <code>rationalQuadratic</code> kernels only.  Default is <code>df=2.01</code> for <code>generalMatern</code> and <code>df=0.01</code> for <code>rationalQuadratic</code>.</p>
</td></tr>
<tr><td><code id="calCov_+3A_noiseinjection">noiseInjection</code></td>
<td>
<p>a small value added to the diagonal elements of C and Kphi for numerical stability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance formulae and the hyper-parameters <code>phi</code> for the supported kernels are as follows.  Stationary kernels have <code class="reqn">C(s,t) = C(r)</code> where <code class="reqn">r = |s-t|</code> is the distance between the two time points.   Generally, the hyper-parameter <code>phi[1]</code> controls the overall variance level while <code>phi[2]</code> controls the bandwidth.
</p>

<dl>
<dt><code>matern</code></dt><dd><p> This is the simplified Matern covariance with <code>df = 5/2</code>:
</p>
<p style="text-align: center;"><code class="reqn">C(r) = phi[1] * (1 + \sqrt 5 r/phi[2] + 5r^2/(3 phi[2]^2)) * \exp(-\sqrt 5 r/phi[2])</code>
</p>

</dd>
<dt><code>rbf</code></dt><dd>
<p style="text-align: center;"><code class="reqn">C(r) = phi[1] * \exp(-r^2/(2 phi[2]^2))</code>
</p>

</dd>
<dt><code>compact1</code></dt><dd>
<p style="text-align: center;"><code class="reqn">C(r) = phi[1] * \max(1-r/phi[2],0)^4 * (4r/phi[2]+1) </code>
</p>

</dd>
<dt><code>periodicMatern</code></dt><dd>
<p>Define <code class="reqn">r' =  | \sin(r \pi/phi[3])*2 |</code>.  Then the covariance is given by <code class="reqn">C(r')</code> using the Matern formula.
</p>
</dd>
<dt><code>generalMatern</code></dt><dd>
<p style="text-align: center;"><code class="reqn">C(r) = phi[1] * 2^(1-df) / \Gamma(df) * ( \sqrt(2.0 * df) * r / phi[2] )^df * besselK( \sqrt(2.0 * df) * r / phi[2] , df)</code>
</p>

<p>where <code>besselK</code> is the modified Bessel function of the second kind.
</p>
</dd>
<dt><code>rationalQuadratic</code></dt><dd>
<p style="text-align: center;"><code class="reqn">C(r) = phi[1] * (1 + r^2/(2 df phi[2]^2))^(-df)</code>
</p>

</dd>
</dl>

<p>The kernel calculations available and their definitions are as follows: 
</p>

<dl>
<dt>C</dt><dd><p>The covariance matrix corresponding to the distance matrix <code>rInput</code>.</p>
</dd>
<dt>Cprime</dt><dd><p>The cross-covariance matrix  <code class="reqn">d C(s,t) / ds</code>.</p>
</dd>
<dt>Cdoubleprime</dt><dd><p>The cross-covariance matrix  <code class="reqn">d^2 C(s,t) / ds dt</code>.</p>
</dd>
<dt>dCdphi</dt><dd><p>A list with the matrices <code class="reqn">dC / dphi</code> for each element of phi.</p>
</dd>
<dt>Ceigen1over</dt><dd><p>The reciprocals of the eigenvalues of C.</p>
</dd>
<dt>CeigenVec</dt><dd><p>Matrix of eigenvectors of C.</p>
</dd>
<dt>Cinv</dt><dd><p>The inverse of C.</p>
</dd>
<dt>mphi</dt><dd><p>The matrix <code>Cprime * Cinv</code>.</p>
</dd>
<dt>Kphi</dt><dd><p>The matrix <code>Cdoubleprime - Cprime * Kinv * t(Cprime)</code>.</p>
</dd>
<dt>Keigen1over</dt><dd><p>The reciprocals of the eigenvalues of Kphi.</p>
</dd>
<dt>Kinv</dt><dd><p>The inverse of Kphi.</p>
</dd>
<dt>mphiLeftHalf</dt><dd><p>The matrix <code>Cprime * CeigenVec</code>.</p>
</dd>
<dt>dCdphiCube</dt><dd><p><code class="reqn">dC / dphi</code> as a 3-D array, with the third dimension corresponding to the elements of phi.</p>
</dd>
</dl>

<p>If <code>bandsize</code> is a positive integer, additionally CinvBand, mphiBand, and KinvBand are provided in the return list, which are
band matrix approximations to Cinv, mphi, and Kinv with the specified <code>bandsize</code>.
</p>


<h3>Value</h3>

<p>A list containing the kernel calculations included by the value of <code>complexity</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo  &lt;- outer(0:40, t(0:40), '-')[, 1, ]
r &lt;- abs(foo)
signr &lt;- -sign(foo)
calCov(c(0.2, 2), r, signr, bandsize = 20, kerneltype = "generalMatern", df = 2.01)

</code></pre>

<hr>
<h2 id='FNdat'>Dataset of noisy observations from the FitzHugh-Nagumo (FN) equations</h2><span id='topic+FNdat'></span>

<h3>Description</h3>

<p>The classic FN equations model the spike potentials of neurons, where system components <code class="reqn">V</code> and <code class="reqn">R</code> are the voltage and recovery variables, respectively.
</p>
<p><code class="reqn">V</code> and <code class="reqn">R</code> are governed by the following differential equations:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{dV}{dt} = c(V-\frac{V^3}{3}+R) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{dR}{dt} = -\frac{1}{c}(V-a+bR) </code>
</p>

<p>where <code class="reqn">\theta = (a,b,c)</code> are system parameters.
This dataset was generated by first numerically solving these ODEs from <code class="reqn">t=0</code> to <code class="reqn">t=20</code>, with initial conditions <code class="reqn">V(0) = -1</code> and <code class="reqn">R(0) = 1</code> and parameters <code class="reqn">\theta = (0.2, 0.2, 3)</code>.
The system components were taken to be measured at 28 observation time points (as indicated in <code>time</code> column) with additive Gaussian noise (standard deviation 0.2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FNdat)
</code></pre>


<h3>Format</h3>

<p>A data frame with 28 rows and 3 columns (time, <code class="reqn">V</code>, <code class="reqn">R</code>).
</p>


<h3>References</h3>

<p>FitzHugh, R (1961). Impulses and Physiological States in Theoretical Models of Nerve Membrane. <em>Biophysical Journal</em>, 1(6), 445–466.
</p>

<hr>
<h2 id='fnmodelODE'>The FitzHugh-Nagumo (FN) equations</h2><span id='topic+fnmodelODE'></span><span id='topic+fnmodelDx'></span><span id='topic+fnmodelDtheta'></span>

<h3>Description</h3>

<p>The classic FN equations model the spike potentials of neurons, where system components <code class="reqn">X = (V,R)</code> represent the voltage and recovery variables, respectively.
</p>
<p><code class="reqn">V</code> and <code class="reqn">R</code> are governed by the following differential equations:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{dV}{dt} = c(V-\frac{V^3}{3}+R) </code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{dR}{dt} = -\frac{1}{c}(V-a+bR) </code>
</p>

<p>where <code class="reqn">\theta = (a,b,c)</code> are system parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnmodelODE(theta, x, tvec)

fnmodelDx(theta, x, tvec)

fnmodelDtheta(theta, x, tvec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnmodelODE_+3A_theta">theta</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="fnmodelODE_+3A_x">x</code></td>
<td>
<p>matrix of system states (one per column) at the time points in <code>tvec</code>.</p>
</td></tr>
<tr><td><code id="fnmodelODE_+3A_tvec">tvec</code></td>
<td>
<p>vector of time points</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fnmodelODE</code> returns an array with the values of the derivatives <code class="reqn">\dot{X}</code>.
</p>
<p><code>fnmodelDx</code> returns a 3-D array with the values of the gradients with respect to <code class="reqn">X</code>.
</p>
<p><code>fnmodelDtheta</code> returns a 3-D array with the values of the gradients with respect to <code class="reqn">\theta</code>.
</p>


<h3>References</h3>

<p>FitzHugh, R (1961). Impulses and Physiological States in Theoretical Models of Nerve Membrane. <em>Biophysical Journal</em>, 1(6), 445–466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- c(0.2, 0.2, 3)
x &lt;- matrix(1:10, nrow = 5, ncol = 2)
tvec &lt;- 1:5

fnmodelODE(theta, x, tvec)

</code></pre>

<hr>
<h2 id='gpcov'>Conditional covariance of Gaussian process given observations</h2><span id='topic+gpcov'></span>

<h3>Description</h3>

<p>Compute the conditional covariance of a Gaussian process, given a vector of observations, hyper-parameters <code>phi</code>, and noise standard deviation <code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpcov(yobs, tvec, tnew, phi, sigma, kerneltype = "generalMatern")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpcov_+3A_yobs">yobs</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="gpcov_+3A_tvec">tvec</code></td>
<td>
<p>vector of time points corresponding to observations</p>
</td></tr>
<tr><td><code id="gpcov_+3A_tnew">tnew</code></td>
<td>
<p>vector of time points at which the conditional covariance should be computed</p>
</td></tr>
<tr><td><code id="gpcov_+3A_phi">phi</code></td>
<td>
<p>vector of hyper-parameters for the covariance kernel (<code>kerneltype</code>)</p>
</td></tr>
<tr><td><code id="gpcov_+3A_sigma">sigma</code></td>
<td>
<p>the noise level (if known). By default, both <code>phi</code> and <code>sigma</code> are estimated. If a value for <code>sigma</code> is supplied, then <code>sigma</code> is held fixed at the supplied value and only <code>phi</code> is estimated.</p>
</td></tr>
<tr><td><code id="gpcov_+3A_kerneltype">kerneltype</code></td>
<td>
<p>the covariance kernel, types <code>matern</code>, <code>rbf</code>, <code>compact1</code>, <code>periodicMatern</code>, <code>generalMatern</code> are supported.  See <code><a href="#topic+calCov">calCov</a></code> for their definitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The conditional covariance matrix for the GP evaluated at the time points in <code>tnew</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Fitzhugh-Nagumo dataset
data(FNdat)

tnew &lt;- seq(15, 20, by = 0.5)

# GP covariance of V component at time points in tnew given observations
gpcov(FNdat$V, FNdat$time, tnew, c(2.3, 1.2), 0.2)

</code></pre>

<hr>
<h2 id='gpmean'>Conditional mean of Gaussian process given observations</h2><span id='topic+gpmean'></span>

<h3>Description</h3>

<p>Compute the conditional mean of a Gaussian process (and optionally, its derivative), given a vector of observations, hyper-parameters <code>phi</code>, and noise standard deviation <code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpmean(
  yobs,
  tvec,
  tnew,
  phi,
  sigma,
  kerneltype = "generalMatern",
  deriv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpmean_+3A_yobs">yobs</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="gpmean_+3A_tvec">tvec</code></td>
<td>
<p>vector of time points corresponding to observations</p>
</td></tr>
<tr><td><code id="gpmean_+3A_tnew">tnew</code></td>
<td>
<p>vector of time points at which the conditional mean should be computed</p>
</td></tr>
<tr><td><code id="gpmean_+3A_phi">phi</code></td>
<td>
<p>vector of hyper-parameters for the covariance kernel (<code>kerneltype</code>)</p>
</td></tr>
<tr><td><code id="gpmean_+3A_sigma">sigma</code></td>
<td>
<p>the noise level (if known). By default, both <code>phi</code> and <code>sigma</code> are estimated. If a value for <code>sigma</code> is supplied, then <code>sigma</code> is held fixed at the supplied value and only <code>phi</code> is estimated.</p>
</td></tr>
<tr><td><code id="gpmean_+3A_kerneltype">kerneltype</code></td>
<td>
<p>the covariance kernel, types <code>matern</code>, <code>rbf</code>, <code>compact1</code>, <code>periodicMatern</code>, <code>generalMatern</code> are supported.  See <code><a href="#topic+calCov">calCov</a></code> for their definitions.</p>
</td></tr>
<tr><td><code id="gpmean_+3A_deriv">deriv</code></td>
<td>
<p>logical; if true, the conditional mean of the GP's derivative is also computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the values of the conditional mean function evaluated at the time points in <code>tnew</code>. If <code>deriv = TRUE</code>, returned with an additional attribute <code>deriv</code> that contains the values of the conditional mean of the GP derivative evaluated at the time points in <code>tnew</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Fitzhugh-Nagumo dataset
data(FNdat)

tnew &lt;- seq(0, 20, by = 0.5)

# GP mean of V component at time points in tnew given observations
gpmean(FNdat$V, FNdat$time, tnew, c(2.3, 1.2), 0.2)

</code></pre>

<hr>
<h2 id='gpsmoothing'>Gaussian process smoothing</h2><span id='topic+gpsmoothing'></span>

<h3>Description</h3>

<p>Estimate hyper-parameters <code>phi</code> and noise standard deviation <code>sigma</code> for a vector of observations using Gaussian process smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpsmoothing(yobs, tvec, kerneltype = "generalMatern", sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpsmoothing_+3A_yobs">yobs</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="gpsmoothing_+3A_tvec">tvec</code></td>
<td>
<p>vector of time points corresponding to observations</p>
</td></tr>
<tr><td><code id="gpsmoothing_+3A_kerneltype">kerneltype</code></td>
<td>
<p>the covariance kernel, types <code>matern</code>, <code>rbf</code>, <code>compact1</code>, <code>periodicMatern</code>, <code>generalMatern</code> are supported.  See <code><a href="#topic+calCov">calCov</a></code> for their definitions.</p>
</td></tr>
<tr><td><code id="gpsmoothing_+3A_sigma">sigma</code></td>
<td>
<p>the noise level (if known). By default, both <code>phi</code> and <code>sigma</code> are estimated. If a value for <code>sigma</code> is supplied, then <code>sigma</code> is held fixed at the supplied value and only <code>phi</code> is estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the elements <code>phi</code> and <code>sigma</code> with their estimated values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data and observation times
tvec &lt;- seq(0, 20, by = 0.5)
y &lt;- c(-1.16, -0.18, 1.57, 1.99, 1.95, 1.85, 1.49, 1.58, 1.47, 0.96, 
0.75, 0.22, -1.34, -1.72, -2.11, -1.56, -1.51, -1.29, -1.22, 
-0.36, 1.78, 2.36, 1.78, 1.8, 1.76, 1.4, 1.02, 1.28, 1.21, 0.04, 
-1.35, -2.1, -1.9, -1.49, -1.55, -1.35, -0.98, -0.34, 1.9, 1.99, 1.84)

gpsmoothing(y, tvec)
 

</code></pre>

<hr>
<h2 id='gpsmoothllik'>Marginal log-likelihood for Gaussian process smoothing</h2><span id='topic+gpsmoothllik'></span>

<h3>Description</h3>

<p>Marginal log-likelihood and gradient as a function of GP hyper-parameters phi and observation noise standard deviation sigma. For use in Gaussian process smoothing where values of phi and sigma may be optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpsmoothllik(phisig, yobs, rInput, kerneltype = "generalMatern")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpsmoothllik_+3A_phisig">phisig</code></td>
<td>
<p>vector containing GP hyper-parameters phi and observation noise SD sigma. See <code><a href="#topic+calCov">calCov</a></code> for the definitions of the hyper-parameters.</p>
</td></tr>
<tr><td><code id="gpsmoothllik_+3A_yobs">yobs</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="gpsmoothllik_+3A_rinput">rInput</code></td>
<td>
<p>distance matrix between all time points of <code>yobs</code></p>
</td></tr>
<tr><td><code id="gpsmoothllik_+3A_kerneltype">kerneltype</code></td>
<td>
<p>the covariance kernel, types <code>matern</code>, <code>rbf</code>, <code>compact1</code>, <code>periodicMatern</code>, <code>generalMatern</code> are supported.  See <code><a href="#topic+calCov">calCov</a></code> for their definitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>value</code> and <code>grad</code>, which are the log-likelihood value and gradient with respect to <code>phisig</code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Suppose phi[1] = 0.5, phi[2] = 3, sigma = 0.1
gpsmoothllik(c(0.5, 3, 0.1), rnorm(10), abs(outer(0:9, t(0:9), '-')[, 1, ]))

</code></pre>

<hr>
<h2 id='hes1modelODE'>Hes1 equations: oscillation of mRNA and protein levels</h2><span id='topic+hes1modelODE'></span><span id='topic+hes1modelDx'></span><span id='topic+hes1modelDtheta'></span><span id='topic+hes1logmodelODE'></span><span id='topic+hes1logmodelDx'></span><span id='topic+hes1logmodelDtheta'></span>

<h3>Description</h3>

<p>The Hes1 equations model the oscillatory cycles of protein and messenger ribonucleic acid (mRNA) levels in cultured cells. The system components <code class="reqn">X = (P, M, H)</code> represent the concentrations of protein, mRNA, and the Hes1-interacting factor that provides a negative feedback loop.
</p>
<p><code class="reqn">P</code>, <code class="reqn">M</code>, and <code class="reqn">H</code> are governed by the following differential equations:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{dP}{dt} = -aPH + bM - cP </code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{dM}{dt} = -d_M M + \frac{e}{1 + P^2} </code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{dH}{dt} = -aPH + \frac{f}{1+ P^2} - gH </code>
</p>
 
<p>where <code class="reqn">\theta = (a,b,c,d_M,e,f,g)</code> are system parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hes1modelODE(theta, x, tvec)

hes1modelDx(theta, x, tvec)

hes1modelDtheta(theta, x, tvec)

hes1logmodelODE(theta, x, tvec)

hes1logmodelDx(theta, x, tvec)

hes1logmodelDtheta(theta, x, tvec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hes1modelODE_+3A_theta">theta</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="hes1modelODE_+3A_x">x</code></td>
<td>
<p>matrix of system states (one per column) at the time points in <code>tvec</code>.</p>
</td></tr>
<tr><td><code id="hes1modelODE_+3A_tvec">tvec</code></td>
<td>
<p>vector of time points</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hes1modelODE</code> returns an array with the values of the derivatives <code class="reqn">\dot{X}</code>.
</p>
<p><code>hes1modelDx</code> returns a 3-D array with the values of the gradients with respect to <code class="reqn">X</code>.
</p>
<p><code>hes1modelDtheta</code> returns a 3-D array with the values of the gradients with respect to <code class="reqn">\theta</code>.
</p>
<p><code>hes1logmodelODE</code>, <code>hes1logmodelDx</code>, and <code>hes1logmodelDtheta</code> are the log-transformed versions of <code>hes1modelODE</code>, <code>hes1modelDx</code>, and <code>hes1modelDtheta</code>, respectively.
</p>


<h3>References</h3>

<p>Hirata H, Yoshiura S, Ohtsuka T, Bessho Y, Harada T, Yoshikawa K, Kageyama R (2002). Oscillatory Expression of the bHLH Factor Hes1 Regulated by a Negative Feedback Loop.
<em>Science</em>, 298(5594), 840–843.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- c(0.022, 0.3, 0.031, 0.028, 0.5, 20, 0.3)
x &lt;- matrix(1:15, nrow = 5, ncol = 3)
tvec &lt;- 1:5

hes1modelODE(theta, x, tvec)

</code></pre>

<hr>
<h2 id='is.magioutput'>MagiSolver output (<code>magioutput</code>) object</h2><span id='topic+is.magioutput'></span><span id='topic+magioutput'></span>

<h3>Description</h3>

<p>Check for and create a magioutput object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.magioutput(object)

magioutput(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.magioutput_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="is.magioutput_+3A_...">...</code></td>
<td>
<p>arguments required to create a magioutput object. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the core <code><a href="#topic+MagiSolver">MagiSolver</a></code> function returns a <code>magioutput</code> object as output, which is a list that contains the following elements:
</p>

<dl>
<dt><code>theta</code></dt><dd><p>matrix of MCMC samples for the system parameters <code class="reqn">\theta</code>, after burn-in.</p>
</dd>
<dt><code>xsampled</code></dt><dd><p>array of MCMC samples for the system trajectories at each discretization time point, after burn-in.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>matrix of MCMC samples for the observation noise SDs <code class="reqn">\sigma</code>, after burn-in.</p>
</dd>
<dt><code>phi</code></dt><dd><p>matrix of estimated GP hyper-parameters, one column for each system component.</p>
</dd>
<dt><code>lp</code></dt><dd><p>vector of log-posterior values at each MCMC iteration, after burn-in.</p>
</dd>
<dt><code>y, tvec, odeModel</code></dt><dd><p>from the inputs to <code>MagiSolver</code>.</p>
</dd>
</dl>
 
<p>Printing a <code>magioutput</code> object displays a brief summary of the settings used for the <code>MagiSolver</code> run.
The summary method for a <code>magioutput</code> object prints a table of parameter estimates, see <code><a href="#topic+summary.magioutput">summary.magioutput</a></code> for more details. 
Plotting a <code>magioutput</code> object by default shows the inferred trajectories for each component, see <code><a href="#topic+plot.magioutput">plot.magioutput</a></code> for more details.
</p>


<h3>Value</h3>

<p>logical. Is the input a magioutput object?
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up odeModel list for the Fitzhugh-Nagumo equations
fnmodel &lt;- list(
  fOde = fnmodelODE,
  fOdeDx = fnmodelDx,
  fOdeDtheta = fnmodelDtheta,
  thetaLowerBound = c(0, 0, 0),
  thetaUpperBound = c(Inf, Inf, Inf)
)

# Example FN data
data(FNdat)

# Create magioutput from a short MagiSolver run (demo only, more iterations needed for convergence)
result &lt;- MagiSolver(FNdat, fnmodel, control = list(nstepsHmc = 5, niterHmc = 50)) 

is.magioutput(result)

</code></pre>

<hr>
<h2 id='magi'><code>magi</code>: MAnifold-Constrained Gaussian Process Inference</h2><span id='topic+magi'></span>

<h3>Description</h3>

<p><code>magi</code> is a package that provides fast and accurate inference for the parameter estimation problem in Ordinary Differential Equations, including the case when there are unobserved system components.
In the references below, please see our software paper Wong, Yang, and Kou (2024) for a detailed user guide and Yang, Wong, and Kou (2021) for details of the MAGI method (MAnifold-constrained Gaussian process Inference).
</p>


<h3>References</h3>

<p>Wong, S. W. K., Yang, S., &amp; Kou, S. C. (2024). <code>magi</code>: A Package for Inference of Dynamic Systems from Noisy and Sparse Data via Manifold-Constrained Gaussian Processes. <em>Journal of Statistical Software</em>, 109 (4), 1-47. <a href="https://doi.org/10.18637/jss.v109.i04">doi:10.18637/jss.v109.i04</a>
</p>
<p>Yang, S., Wong, S. W. K., &amp; Kou, S. C. (2021). Inference of Dynamic Systems from Noisy and
Sparse Data via Manifold-constrained Gaussian Processes. <em>Proceedings of the National Academy of Sciences</em>, 118 (15), e2020397118. <a href="https://doi.org/10.1073/pnas.2020397118">doi:10.1073/pnas.2020397118</a>
</p>

<hr>
<h2 id='MagiPosterior'>MAGI posterior density</h2><span id='topic+MagiPosterior'></span>

<h3>Description</h3>

<p>Computes the MAGI log-posterior value and gradient for an ODE model with the given inputs: the observations <code class="reqn">Y</code>, the latent system trajectories <code class="reqn">X</code>,
the parameters <code class="reqn">\theta</code>, the noise standard deviations <code class="reqn">\sigma</code>, and covariance kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MagiPosterior(
  y,
  xlatent,
  theta,
  sigma,
  covAllDimInput,
  odeModel,
  priorTemperatureInput = 1,
  useBand = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MagiPosterior_+3A_y">y</code></td>
<td>
<p>data matrix of observations</p>
</td></tr>
<tr><td><code id="MagiPosterior_+3A_xlatent">xlatent</code></td>
<td>
<p>matrix of system trajectory values</p>
</td></tr>
<tr><td><code id="MagiPosterior_+3A_theta">theta</code></td>
<td>
<p>vector of parameter values <code class="reqn">\theta</code></p>
</td></tr>
<tr><td><code id="MagiPosterior_+3A_sigma">sigma</code></td>
<td>
<p>vector of observation noise for each system component</p>
</td></tr>
<tr><td><code id="MagiPosterior_+3A_covalldiminput">covAllDimInput</code></td>
<td>
<p>list of covariance kernel objects for each system component. Covariance calculations may be carried out with <code><a href="#topic+calCov">calCov</a></code>.</p>
</td></tr>
<tr><td><code id="MagiPosterior_+3A_odemodel">odeModel</code></td>
<td>
<p>list of ODE functions and inputs. See details.</p>
</td></tr>
<tr><td><code id="MagiPosterior_+3A_priortemperatureinput">priorTemperatureInput</code></td>
<td>
<p>vector of tempering factors for the GP prior, derivatives, and observations, in that order. Controls the influence of the GP prior relative to the likelihood.  Recommended values: the total number of observations divided by the total number of discretization points for the GP prior and derivatives, and 1 for the observations.</p>
</td></tr>
<tr><td><code id="MagiPosterior_+3A_useband">useBand</code></td>
<td>
<p>logical: should the band matrix approximation be used?  If <code>TRUE</code>, <code>covAllDimInput</code> must include CinvBand, mphiBand, and KinvBand as computed by <code><a href="#topic+calCov">calCov</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>value</code> for the value of the log-posterior density and <code>grad</code> for its gradient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Trajectories from the Fitzhugh-Nagumo equations
tvec &lt;- seq(0, 20, 2)
Vtrue &lt;- c(-1, 1.91, 1.38, -1.32, -1.5, 1.73, 1.66, 0.89, -1.82, -0.93, 1.89)
Rtrue &lt;- c(1, 0.33, -0.62, -0.82, 0.5, 0.94, -0.22, -0.9, -0.08, 0.95, 0.3)

# Noisy observations
Vobs &lt;- Vtrue + rnorm(length(tvec), sd = 0.05)
Robs &lt;- Rtrue + rnorm(length(tvec), sd = 0.1)

# Prepare distance matrix for covariance kernel calculation
foo &lt;- outer(tvec, t(tvec), '-')[, 1, ]
r &lt;- abs(foo)
r2 &lt;- r^2
signr &lt;- -sign(foo)
  
# Choose some hyperparameter values to illustrate
rphi &lt;- c(0.95, 3.27)
vphi &lt;- c(1.98, 1.12)
phiTest &lt;- cbind(vphi, rphi)

# Covariance computations
curCovV &lt;- calCov(phiTest[,1], r, signr, kerneltype = "generalMatern")
curCovR &lt;- calCov(phiTest[,2], r, signr, kerneltype = "generalMatern")

# Y and X inputs to MagiPosterior
yInput &lt;- data.matrix(cbind(Vobs, Robs))
xlatentTest &lt;- data.matrix(cbind(Vtrue, Rtrue))

# Create odeModel list for FN equations
fnmodel &lt;- list(
  fOde = fnmodelODE,
  fOdeDx = fnmodelDx,
  fOdeDtheta = fnmodelDtheta,
  thetaLowerBound = c(0, 0, 0),
  thetaUpperBound = c(Inf, Inf, Inf)
)

MagiPosterior(yInput, xlatentTest, theta = c(0.2, 0.2, 3), sigma = c(0.05, 0.1),
    list(curCovV, curCovR), fnmodel)


</code></pre>

<hr>
<h2 id='MagiSolver'>MAnifold-constrained Gaussian process Inference (MAGI)</h2><span id='topic+MagiSolver'></span>

<h3>Description</h3>

<p>Core function of the MAGI method for inferring the parameters and trajectories of dynamic systems governed by ordinary differential equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MagiSolver(y, odeModel, tvec, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MagiSolver_+3A_y">y</code></td>
<td>
<p>data matrix of observations</p>
</td></tr>
<tr><td><code id="MagiSolver_+3A_odemodel">odeModel</code></td>
<td>
<p>list of ODE functions and inputs. See details.</p>
</td></tr>
<tr><td><code id="MagiSolver_+3A_tvec">tvec</code></td>
<td>
<p>vector of discretization time points corresponding to rows of <code>y</code>.  If missing, <code>MagiSolver</code> will use the column named 'time' in <code>y</code>.</p>
</td></tr>
<tr><td><code id="MagiSolver_+3A_control">control</code></td>
<td>
<p>list of control variables, which may include 'sigma', 'phi', 'theta', 'xInit', 'mu', 'dotmu', 'priorTemperature', 'niterHmc',
'nstepsHmc', 'burninRatio', 'stepSizeFactor', 'bandSize', 'useFixedSigma', 'kerneltype', 'skipMissingComponentOptimization', 'positiveSystem', 'verbose'.  See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data matrix <code>y</code> has a column for each system component, and optionally a column 'time' with the discretization time points. If the column 'time' is not provided in <code>y</code>, a vector of time points must be provided via the <code>tvec</code> argument. The rows of <code>y</code> correspond to the discretization set <code class="reqn">I</code> at which the GP is constrained to the derivatives of the ODE system. To set the desired discretization level for inference, use <code><a href="#topic+setDiscretization">setDiscretization</a></code> to prepare the data matrix for input into <code>MagiSolver</code>. Missing observations are indicated with <code>NA</code> or <code>NaN</code>.
</p>
<p>The list <code>odeModel</code> is used for specification of the ODE system and its parameters. It must include five elements:
</p>

<dl>
<dt><code>fOde</code></dt><dd><p>function that computes the ODEs, specified with the form <code>f(theta, x, tvec)</code>. <code>fOde</code> should return a matrix where columns correspond to the system components of <code>x</code>, see examples.</p>
</dd>
<dt><code>fOdeDx</code></dt><dd><p>function that computes the gradients of the ODEs with respect to the system components. <code>fOdeDx</code> should return a 3-D array, where the slice <code>[, i, j]</code> is the partial derivative of the ODE for the j-th system component with respect to the i-th system component, see examples.</p>
</dd>
<dt><code>fOdeDtheta</code></dt><dd><p>function that computes the gradients of the ODEs with respect to the parameters <code class="reqn">\theta</code>. <code>fOdeDtheta</code> should return a 3-D array, where the slice <code>[, i, j]</code> is the partial derivative of the ODE for the j-th system component with respect to the i-th parameter in <code class="reqn">\theta</code>, see examples.</p>
</dd>
<dt><code>thetaLowerBound</code></dt><dd><p>a vector indicating the lower bounds of each parameter in <code class="reqn">\theta</code>.</p>
</dd>
<dt><code>thetaUpperBound</code></dt><dd><p>a vector indicating the upper bounds of each parameter in <code class="reqn">\theta</code>.</p>
</dd>
</dl>

<p>Additional control variables can be supplied to <code>MagiSolver</code> via the optional list <code>control</code>, which may include the following:
</p>

<dl>
<dt><code>sigma</code></dt><dd><p>a vector of noise levels (observation noise standard deviations) <code class="reqn">\sigma</code> for each component, at which to initialize MCMC sampling.  By default, <code>MagiSolver</code> computes starting values for <code>sigma</code> via Gaussian process (GP) smoothing. If the noise levels are known, specify <code>sigma</code> together with <code>useFixedSigma = TRUE</code>.</p>
</dd>
<dt><code>phi</code></dt><dd><p>a matrix of GP hyper-parameters for each component, with rows for the kernel hyper-parameters and columns for the system components. By default, <code>MagiSolver</code> estimates <code>phi</code> via an optimization routine.</p>
</dd>
<dt><code>theta</code></dt><dd><p>a vector of starting values for the parameters <code class="reqn">\theta</code>, at which to initialize MCMC sampling. By default, <code>MagiSolver</code> uses an optimization routine to obtain starting values.</p>
</dd>
<dt><code>xInit</code></dt><dd><p>a matrix of values for the system trajectories of the same dimension as <code>y</code>, at which to initialize MCMC sampling. Default is linear interpolation between the observed (non-missing) values of <code>y</code> and an optimization routine for entirely unobserved components of <code>y</code>.</p>
</dd>
<dt><code>mu</code></dt><dd><p>a matrix of values for the mean function of the GP prior, of the same dimension as <code>y</code>. Default is a zero mean function.</p>
</dd>
<dt><code>dotmu</code></dt><dd><p>a matrix of values for the derivatives of the GP prior mean function, of the same dimension as <code>y</code>. Default is zero.</p>
</dd>
<dt><code>priorTemperature</code></dt><dd><p>the tempering factor by which to divide the contribution of the GP prior, to control the influence of the GP prior relative to the likelihood. Default is the total number of observations divided by the total number of discretization points.</p>
</dd>
<dt><code>niterHmc</code></dt><dd><p>MCMC sampling from the posterior is carried out via the Hamiltonian Monte Carlo (HMC) algorithm. <code>niterHmc</code> specifies the number of HMC iterations to run.  Default is 20000 HMC iterations.</p>
</dd>
<dt><code>nstepsHmc</code></dt><dd><p>the number of leapfrog steps per HMC iteration. Default is 200.</p>
</dd>
<dt><code>burninRatio</code></dt><dd><p>the proportion of HMC iterations to be discarded as burn-in. Default is 0.5, which discards the first half of the MCMC samples.</p>
</dd>
<dt><code>stepSizeFactor</code></dt><dd><p>initial leapfrog step size factor for HMC. Can be a specified as a scalar (applied to all posterior dimensions) or a vector (with length corresponding to the dimension of the posterior). Default is 0.01, and the leapfrog step size is automatically tuned during burn-in to achieve an acceptance rate between 60-90%.</p>
</dd>
<dt><code>bandSize</code></dt><dd><p>a band matrix approximation is used to speed up matrix operations, with default band size 20. Can be increased if <code>MagiSolver</code> returns an error indicating numerical instability.</p>
</dd>
<dt><code>useFixedSigma</code></dt><dd><p>logical, set to <code>TRUE</code> if <code>sigma</code> is known.  If <code>useFixedSigma = TRUE</code>, the known values of <code class="reqn">\sigma</code> must be supplied via the <code>sigma</code> control variable. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>kerneltype</code></dt><dd><p>the GP covariance kernel, <code>generalMatern</code> is the default and recommended choice. Other available choices are <code>matern</code>, <code>rbf</code>, <code>compact1</code>, <code>periodicMatern</code>. See <code><a href="#topic+calCov">calCov</a></code> for their definitions.</p>
</dd>
<dt><code>skipMissingComponentOptimization</code></dt><dd><p>logical, set to <code>TRUE</code> to skip automatic optimization for missing components. If <code>skipMissingComponentOptimization = TRUE</code>, values for <code>xInit</code> and <code>phi</code> must be supplied for all system components. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>positiveSystem</code></dt><dd><p>logical, set to <code>TRUE</code> if the system cannot be negative. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>logical, set to <code>TRUE</code> to output diagnostic and progress messages to the console. Default is <code>FALSE</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>MagiSolver</code> returns an object of class <code><a href="#topic+magioutput">magioutput</a></code> which contains the following elements:
</p>

<dl>
<dt><code>theta</code></dt><dd><p>matrix of MCMC samples for the system parameters <code class="reqn">\theta</code>, after burn-in.</p>
</dd>
<dt><code>xsampled</code></dt><dd><p>array of MCMC samples for the system trajectories at each discretization time point, after burn-in.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>matrix of MCMC samples for the observation noise SDs <code class="reqn">\sigma</code>, after burn-in.</p>
</dd>
<dt><code>phi</code></dt><dd><p>matrix of estimated GP hyper-parameters, one column for each system component.</p>
</dd>
<dt><code>lp</code></dt><dd><p>vector of log-posterior values at each MCMC iteration, after burn-in.</p>
</dd>
<dt><code>y, tvec, odeModel</code></dt><dd><p>from the inputs to <code>MagiSolver</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Wong, S. W. K., Yang, S., &amp; Kou, S. C. (2024). 'magi': A Package for Inference of Dynamic Systems from Noisy and Sparse Data via Manifold-Constrained Gaussian Processes. *Journal of Statistical Software*, 109 (4), 1-47. <a href="https://doi.org/10.18637/jss.v109.i04">doi:10.18637/jss.v109.i04</a>
</p>
<p>Yang, S., Wong, S. W. K., &amp; Kou, S. C. (2021). Inference of Dynamic Systems from Noisy and 
Sparse Data via Manifold-constrained Gaussian Processes. *Proceedings of the National Academy of Sciences*, 118 (15), e2020397118. <a href="https://doi.org/10.1073/pnas.2020397118">doi:10.1073/pnas.2020397118</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up odeModel list for the Fitzhugh-Nagumo equations
fnmodel &lt;- list(
  fOde = fnmodelODE,
  fOdeDx = fnmodelDx,
  fOdeDtheta = fnmodelDtheta,
  thetaLowerBound = c(0, 0, 0),
  thetaUpperBound = c(Inf, Inf, Inf)
)

# Example noisy data observed from the FN system
data(FNdat)

# Set discretization for a total of 81 equally-spaced time points from 0 to 20
yinput &lt;- setDiscretization(FNdat, by = 0.25)

# Run MagiSolver
# Short sampler run for demo only, more iterations needed for convergence
MagiSolver(yinput, fnmodel, control = list(nstepsHmc = 5, niterHmc = 101))

# Use 3000 HMC iterations with 100 leapfrog steps per iteration
FNres &lt;- MagiSolver(yinput, fnmodel, control = list(nstepsHmc = 100, niterHmc = 3000))
# Summary of parameter estimates
summary(FNres)
# Plot of inferred trajectories
plot(FNres, comp.names = c("V", "R"), xlab = "Time", ylab = "Level")


</code></pre>

<hr>
<h2 id='plot.magioutput'>Generate plots from <code>magioutput</code> object</h2><span id='topic+plot.magioutput'></span>

<h3>Description</h3>

<p>Plots inferred system trajectories or diagnostic traceplots from the output of <code>MagiSolver</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'magioutput'
plot(
  x,
  type = "traj",
  obs = TRUE,
  ci = TRUE,
  ci.col = "skyblue",
  comp.names,
  par.names,
  est = "mean",
  lower = 0.025,
  upper = 0.975,
  sigma = FALSE,
  lp = TRUE,
  nplotcol = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.magioutput_+3A_x">x</code></td>
<td>
<p>a <code>magioutput</code> object.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_type">type</code></td>
<td>
<p>string; the default <code>type = "traj"</code> plots inferred trajectories, while setting <code>type = "trace"</code> generates diagnostic traceplots for the MCMC samples of the parameters and log-posterior values.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_obs">obs</code></td>
<td>
<p>logical; if true, points will be added on the plots for the observations when <code>type = "traj"</code>.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_ci">ci</code></td>
<td>
<p>logical; if true, credible bands/intervals will be added to the plots.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_ci.col">ci.col</code></td>
<td>
<p>string; color to use for credible bands.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_comp.names">comp.names</code></td>
<td>
<p>vector of system component names, when <code>type = "traj"</code>. If provided, should be the same length as the number of system components in <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_par.names">par.names</code></td>
<td>
<p>vector of parameter names, when <code>type = "trace"</code>. If provided, should be the same length as the number of parameters in <code class="reqn">\theta</code>, or the combined length of <code class="reqn">\theta</code> and <code class="reqn">\sigma</code> when <code>sigma = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_est">est</code></td>
<td>
<p>string specifying the posterior quantity to plot as the estimate. Can be &quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, or &quot;none&quot;. Default is &quot;mean&quot;, which plots the posterior mean of the MCMC samples.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_lower">lower</code></td>
<td>
<p>the lower quantile of the credible band/interval, default is 0.025. Only used if <code>ci = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_upper">upper</code></td>
<td>
<p>the upper quantile of the credible band/interval, default is 0.975. Only used if <code>ci = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_sigma">sigma</code></td>
<td>
<p>logical; if true, the noise levels <code class="reqn">\sigma</code> will be included in the traceplots when <code>type = "trace"</code>.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_lp">lp</code></td>
<td>
<p>logical; if true, the values of the log-posterior will be included in the traceplots when <code>type = "trace"</code>.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_nplotcol">nplotcol</code></td>
<td>
<p>the number of subplots per row.</p>
</td></tr>
<tr><td><code id="plot.magioutput_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the inferred system trajectories (when <code>type = "traj"</code>) or diagnostic traceplots of the parameters and log-posterior (when <code>type = "trace"</code>) from the MCMC samples.
By default, the posterior mean is treated as the estimate of the trajectories and parameters (<code>est = "mean"</code>).
Alternatives are the posterior median (<code>est = "median"</code>, taken component-wise) and the posterior mode (<code>est = "mode"</code>, approximated by the MCMC sample with the highest log-posterior value).
</p>
<p>The default <code>type = "traj"</code> produces plots of the inferred trajectories and credible bands from the MCMC samples, one subplot for each system component.
By default, <code>lower = 0.025</code> and <code>upper = 0.975</code> produces a central 95% credible band when <code>ci = TRUE</code>.
Adding the observed data points (<code>obs = TRUE</code>) can provide a visual assessment of the inferred trajectories.
</p>
<p>Setting <code>type = "trace"</code> generates diagnostic traceplots for the MCMC samples of the system parameters and the values of the log-posterior, which is a useful tool for informally assessing convergence.
In this case, the <code>est</code> and <code>ci</code> options add horizontal lines to the plots that indicate the estimate (in red) and credible interval (in green) for each parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up odeModel list for the Fitzhugh-Nagumo equations
fnmodel &lt;- list(
  fOde = fnmodelODE,
  fOdeDx = fnmodelDx,
  fOdeDtheta = fnmodelDtheta,
  thetaLowerBound = c(0, 0, 0),
  thetaUpperBound = c(Inf, Inf, Inf)
)

# Example FN data
data(FNdat)
y &lt;- setDiscretization(FNdat, by = 0.25)

# Create magioutput from a short MagiSolver run (demo only, more iterations needed for convergence)
result &lt;- MagiSolver(y, fnmodel, control = list(nstepsHmc = 20, niterHmc = 500)) 

# Inferred trajectories
plot(result, comp.names = c("V", "R"), xlab = "Time", ylab = "Level")

# Parameter trace plots
plot(result, type = "trace", par.names = c("a", "b", "c", "sigmaV", "sigmaR"), sigma = TRUE)

</code></pre>

<hr>
<h2 id='ptransmodelODE'>Protein transduction model</h2><span id='topic+ptransmodelODE'></span><span id='topic+ptransmodelDx'></span><span id='topic+ptransmodelDtheta'></span>

<h3>Description</h3>

<p>The protein transduction equations model a biochemical reaction involving a signaling protein that degrades over time.  The system components <code class="reqn">X = (S, S_d, R, S_R, R_{pp})</code> represent the levels of signaling protein, its degraded form, inactive state of <code class="reqn">R</code>, <code class="reqn">S-R</code> complex, and activated state of <code class="reqn">R</code>.
</p>
<p><code class="reqn">S</code>, <code class="reqn">S_d</code>, <code class="reqn">R</code>, <code class="reqn">S_R</code> and <code class="reqn">R_{pp}</code> are governed by the following differential equations:
</p>
<p style="text-align: center;"><code class="reqn"> \frac{dS}{dt} = -k_1 \cdot S -k_2 \cdot S \cdot R + k_3 \cdot S_R </code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{dS_d}{dt} = k_1 \cdot S  </code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{dR}{dt} = -k_2 \cdot S \cdot R + k_3 \cdot S_R + \frac{V \cdot R_{pp}}{K_m + R_{pp}} </code>
</p>

<p style="text-align: center;"><code class="reqn"> \frac{dS_R}{dt} = k_2 \cdot S \cdot R - k_3 \cdot S_R - k_4 \cdot S_R </code>
</p>
 
<p style="text-align: center;"><code class="reqn"> \frac{dR_{pp}}{dt} = k_4 \cdot S_R - \frac{V \cdot R_{pp}}{K_m + R_{pp}}</code>
</p>
 
<p>where <code class="reqn">\theta = (k_1, k_2, k_3,k_4, V, K_m)</code> are system parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptransmodelODE(theta, x, tvec)

ptransmodelDx(theta, x, tvec)

ptransmodelDtheta(theta, x, tvec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptransmodelODE_+3A_theta">theta</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="ptransmodelODE_+3A_x">x</code></td>
<td>
<p>matrix of system states (one per column) at the time points in <code>tvec</code>.</p>
</td></tr>
<tr><td><code id="ptransmodelODE_+3A_tvec">tvec</code></td>
<td>
<p>vector of time points</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ptransmodelODE</code> returns an array with the values of the derivatives <code class="reqn">\dot{X}</code>.
</p>
<p><code>ptransmodelDx</code> returns a 3-D array with the values of the gradients with respect to <code class="reqn">X</code>.
</p>
<p><code>ptransmodelDtheta</code> returns a 3-D array with the values of the gradients with respect to <code class="reqn">\theta</code>.
</p>


<h3>References</h3>

<p>Vyshemirsky, V., &amp; Girolami, M. A. (2008). Bayesian Ranking of Biochemical System Models. <em>Bioinformatics</em>, 24(6), 833-839.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- c(0.07, 0.6, 0.05, 0.3, 0.017, 0.3)
x &lt;- matrix(1:25, nrow = 5, ncol = 5)
tvec &lt;- 1:5

ptransmodelODE(theta, x, tvec)

</code></pre>

<hr>
<h2 id='setDiscretization'>Set discretization level</h2><span id='topic+setDiscretization'></span>

<h3>Description</h3>

<p>Set the discretization level of a data matrix for input to <code><a href="#topic+MagiSolver">MagiSolver</a></code>, by inserting time points where the GP is constrained to the derivatives of the ODE system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDiscretization(dat, level, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDiscretization_+3A_dat">dat</code></td>
<td>
<p>data matrix. Must include a column with name 'time'.</p>
</td></tr>
<tr><td><code id="setDiscretization_+3A_level">level</code></td>
<td>
<p>discretization level (a positive integer). <code>2^level - 1</code> equally-spaced time points will be inserted between each row of <code>dat</code>.</p>
</td></tr>
<tr><td><code id="setDiscretization_+3A_by">by</code></td>
<td>
<p>discretization interval. As an alternative to <code>level</code>, time points will be inserted (as needed) to form an equally-spaced discretization set from the first to last observations of <code>dat</code>, with interval <code>by</code> between successive discretization points. This can be useful when the time points in <code>dat</code> are unevenly spaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specify the desired discretization using <code>level</code> or <code>by</code>.
</p>


<h3>Value</h3>

<p>Returns a data matrix with the same columns as <code>dat</code>, with rows added for the inserted discretization time points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(time = 0:10, x = rnorm(11))
setDiscretization(dat, level = 2)
setDiscretization(dat, by = 0.2)

</code></pre>

<hr>
<h2 id='summary.magioutput'>Summary of parameter estimates from <code>magioutput</code> object</h2><span id='topic+summary.magioutput'></span>

<h3>Description</h3>

<p>Computes a summary table of parameter estimates from the output of <code>MagiSolver</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'magioutput'
summary(
  object,
  sigma = FALSE,
  par.names,
  est = "mean",
  lower = 0.025,
  upper = 0.975,
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.magioutput_+3A_object">object</code></td>
<td>
<p>a <code>magioutput</code> object.</p>
</td></tr>
<tr><td><code id="summary.magioutput_+3A_sigma">sigma</code></td>
<td>
<p>logical; if true, the noise levels <code class="reqn">\sigma</code> will be included in the summary.</p>
</td></tr>
<tr><td><code id="summary.magioutput_+3A_par.names">par.names</code></td>
<td>
<p>vector of parameter names for the summary table. If provided, should be the same length as the number of parameters in <code class="reqn">\theta</code>, or the combined length of <code class="reqn">\theta</code> and <code class="reqn">\sigma</code> when <code>sigma = TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.magioutput_+3A_est">est</code></td>
<td>
<p>string specifying the posterior quantity to treat as the estimate. Default is <code>est = "mean"</code>, which treats the posterior mean as the estimate. Alternatives are the posterior median (<code>est = "median"</code>, taken component-wise) and the posterior mode (<code>est = "mode"</code>, approximated by the MCMC sample with the highest log-posterior value).</p>
</td></tr>
<tr><td><code id="summary.magioutput_+3A_lower">lower</code></td>
<td>
<p>the lower quantile of the credible interval, default is 0.025.</p>
</td></tr>
<tr><td><code id="summary.magioutput_+3A_upper">upper</code></td>
<td>
<p>the upper quantile of the credible interval, default is 0.975.</p>
</td></tr>
<tr><td><code id="summary.magioutput_+3A_digits">digits</code></td>
<td>
<p>integer; the number of significant digits to print.</p>
</td></tr>
<tr><td><code id="summary.magioutput_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes parameter estimates and credible intervals from the MCMC samples. By default, the posterior mean is treated as the parameter estimate, and <code>lower = 0.025</code> and <code>upper = 0.975</code> produces a central 95% credible interval.
</p>


<h3>Value</h3>

<p>Returns a matrix where rows display the estimate, lower credible limit, and upper credible limit of each parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up odeModel list for the Fitzhugh-Nagumo equations
fnmodel &lt;- list(
  fOde = fnmodelODE,
  fOdeDx = fnmodelDx,
  fOdeDtheta = fnmodelDtheta,
  thetaLowerBound = c(0, 0, 0),
  thetaUpperBound = c(Inf, Inf, Inf)
)

# Example FN data
data(FNdat)

# Create magioutput from a short MagiSolver run (demo only, more iterations needed for convergence)
result &lt;- MagiSolver(FNdat, fnmodel, control = list(nstepsHmc = 5, niterHmc = 100)) 

summary(result, sigma = TRUE, par.names = c("a", "b", "c", "sigmaV", "sigmaR"))
</code></pre>

<hr>
<h2 id='testDynamicalModel'>Test dynamic system model specification</h2><span id='topic+testDynamicalModel'></span>

<h3>Description</h3>

<p>Given functions for the ODE and its gradients (with respect to the system components and parameters), verify the correctness of the gradients using numerical differentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDynamicalModel(modelODE, modelDx, modelDtheta, modelName, x, theta, tvec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDynamicalModel_+3A_modelode">modelODE</code></td>
<td>
<p>function that computes the ODEs, specified with the form <code>f(theta, x, tvec)</code>. See examples.</p>
</td></tr>
<tr><td><code id="testDynamicalModel_+3A_modeldx">modelDx</code></td>
<td>
<p>function that computes the gradients of the ODEs with respect to the system components. See examples.</p>
</td></tr>
<tr><td><code id="testDynamicalModel_+3A_modeldtheta">modelDtheta</code></td>
<td>
<p>function that computes the gradients of the ODEs with respect to the parameters <code class="reqn">\theta</code>. See examples.</p>
</td></tr>
<tr><td><code id="testDynamicalModel_+3A_modelname">modelName</code></td>
<td>
<p>string giving a name for the model</p>
</td></tr>
<tr><td><code id="testDynamicalModel_+3A_x">x</code></td>
<td>
<p>data matrix of system values, one column for each component, at which to test the gradients</p>
</td></tr>
<tr><td><code id="testDynamicalModel_+3A_theta">theta</code></td>
<td>
<p>vector of parameter values for <code class="reqn">\theta</code>, at which to test the gradients</p>
</td></tr>
<tr><td><code id="testDynamicalModel_+3A_tvec">tvec</code></td>
<td>
<p>vector of time points corresponding to the rows of <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls <code><a href="testthat.html#topic+test_that">test_that</a></code> to test equality of the analytic and numeric gradients.
</p>


<h3>Value</h3>

<p>A list with elements <code>testDx</code> and <code>testDtheta</code>, each with value <code>TRUE</code> if the corresponding gradient check passed and <code>FALSE</code> if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ODE system and gradients for Fitzhugh-Nagumo equations: fnmodelODE, fnmodelDx, fnmodelDtheta

# Example of incorrect gradient with respect to parameters theta
fnmodelDthetaWrong &lt;- function(theta, x, tvec) {
  resultDtheta &lt;- array(0, c(nrow(x), length(theta), ncol(x)))
  
  V = x[, 1]
  R = x[, 2]
  
  resultDtheta[, 3, 1] = V - V^3 / 3.0 - R
  
  resultDtheta[, 1, 2] =  1.0 / theta[3] 
  resultDtheta[, 2, 2] = -R / theta[3]
  resultDtheta[, 3, 2] = 1.0 / (theta[3]^2) * (V - theta[1] + theta[2] * R)
  
  resultDtheta
}

# Sample data for testing gradient correctness
data(FNdat)
 
# Correct gradients
testDynamicalModel(fnmodelODE, fnmodelDx, fnmodelDtheta, 
    "FN equations", FNdat[, c("V", "R")], c(.5, .6, 2), FNdat$time)
    
# Incorrect theta gradient (test fails)
testDynamicalModel(fnmodelODE, fnmodelDx, fnmodelDthetaWrong, 
    "FN equations", FNdat[, c("V", "R")], c(.5, .6, 2), FNdat$time)
    

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
