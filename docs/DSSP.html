<!DOCTYPE html><html lang="en"><head><title>Help for package DSSP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DSSP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DSSP-package'><p>Implementation of the Direct Sampling Spatial Prior</p></a></li>
<li><a href='#DSSP'><p>DSSP</p></a></li>
<li><a href='#make.M'><p>Precision Matrix Function</p></a></li>
<li><a href='#plot.dsspMod'><p>Diagnostic, Density and Contour Plots</p></a></li>
<li><a href='#predict.dsspMod'><p>Predictions from a model with new data.</p></a></li>
<li><a href='#residuals.dsspMod'><p>Get residuals from <code>dsspMod</code> model</p></a></li>
<li><a href='#sample.delta'><p>Function to sample from the posterior of the variance parameter</p></a></li>
<li><a href='#sample.eta'><p>Function to sample from the posterior of the smoothing parameter eta conditioned on the data y.</p></a></li>
<li><a href='#sample.nu'><p>Function to sample from the posterior of the spatial effects</p></a></li>
<li><a href='#summary.dsspMod'><p>Summarise a <code>dsspMod</code> model</p></a></li>
<li><a href='#tps.rbf'><p>TPS radial basis function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Implementation of the Direct Sampling Spatial Prior</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-07-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gentry White &lt;gentry.white@qut.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Draw samples from the direct sampling spatial prior model as
    described in G. White, D. Sun, P. Speckman (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1906.05575">doi:10.48550/arXiv.1906.05575</a>&gt;. The basic model assumes a Gaussian
    likelihood and derives a spatial prior based on thin-plate splines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gentrywhite/DSSP">https://github.com/gentrywhite/DSSP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gentrywhite/DSSP/issues">https://github.com/gentrywhite/DSSP/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>mcmcse, posterior, rust, sp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cowplot, ggplot2, gstat, interp, knitr, rmarkdown, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-06 20:02:32 UTC; Rex</td>
</tr>
<tr>
<td>Author:</td>
<td>Gentry White <a href="https://orcid.org/0000-0002-1170-9299"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rex Parsons <a href="https://orcid.org/0000-0002-6053-8174"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-12 11:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='DSSP-package'>Implementation of the Direct Sampling Spatial Prior</h2><span id='topic+DSSP-package'></span>

<h3>Description</h3>

<p>Draw samples from the direct sampling spatial prior model as
    described in G. White, D. Sun, P. Speckman (2019) &lt;arXiv:1906.05575&gt;. The basic model assumes a Gaussian
    likelihood and derives a spatial prior based on thin-plate splines.</p>


<h3>Package Content</h3>


<p>Index of help topics:
</p>
<pre>
DSSP                    DSSP
DSSP-package            Implementation of the Direct Sampling Spatial
                        Prior
make.M                  Precision Matrix Function
plot.dsspMod            Diagnostic, Density and Contour Plots
predict.dsspMod         Predictions from a model with new data.
residuals.dsspMod       Get residuals from 'dsspMod' model
sample.delta            Function to sample from the posterior of the
                        variance parameter
sample.eta              Function to sample from the posterior of the
                        smoothing parameter eta conditioned on the data
                        y.
sample.nu               Function to sample from the posterior of the
                        spatial effects
summary.dsspMod         Summarise a 'dsspMod' model
tps.rbf                 TPS radial basis function
</pre>

<h3>Maintainer</h3>

<p>Gentry White &lt;gentry.white@qut.edu.au&gt;</p>


<h3>Author(s)</h3>

<p>NA</p>

<hr>
<h2 id='DSSP'>DSSP</h2><span id='topic+DSSP'></span>

<h3>Description</h3>

<p>This function samples from the log-posterior of all parameters in the model and returns a list
object containing the samples. It performs a few compatibility checks on the inputs, then
calls the sample.eta(), sample.delta(), and sample.nu().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSSP(formula, data, N, pars, log_prior = function(x) -x, coords = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DSSP_+3A_formula">formula</code></td>
<td>
<p>a two sided linear formula with the response on left and the covariates on the right.</p>
</td></tr>
<tr><td><code id="DSSP_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> or <code>sp::SpatialPointsDataFrame</code> containing the response variable, covariates and coordinates.</p>
</td></tr>
<tr><td><code id="DSSP_+3A_n">N</code></td>
<td>
<p>is the number of random samples to be drawn from the joint posterior for eta, delta, and nu.</p>
</td></tr>
<tr><td><code id="DSSP_+3A_pars">pars</code></td>
<td>
<p>a vector of the prior shape and rate parameters for the inverse-gamma
prior distribution of delta, the variance parameter for the Gaussian likelihood.</p>
</td></tr>
<tr><td><code id="DSSP_+3A_log_prior">log_prior</code></td>
<td>
<p>a function evaluating the log of the prior density of eta. Default to be <code>function(x) -x</code>.</p>
</td></tr>
<tr><td><code id="DSSP_+3A_coords">coords</code></td>
<td>
<p>spatial coordinates passed as the <code>value</code> argument to <code>sp::coordinates()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The direct sampling spatial prior model assumes that the spatial model can be written
as the likelihood parameterised with mean vector nu and variance delta
</p>
<p style="text-align: center;"><code class="reqn">(y | nu, delta) ~ N(nu, delta * I)</code>
</p>

<p>where I is the identity matrix.  The prior for the vector of spatial effects nu is
improper but is proportional to
</p>
<p style="text-align: center;"><code class="reqn">\pi(nu | eta) propto (det(M)/2\pi)^{1/2} * exp(-eta nu' M nu/2),</code>
</p>

<p>the prior for delta is assumed to be a inverse-gamma distribution
</p>
<p style="text-align: center;"><code class="reqn">(delta) ~ IG(a,b)</code>
</p>

<p>and the prior for eta can be specified for the user as any valid density function for eta &gt; 0.
</p>


<h3>Value</h3>

<p>A list containing N samples of nu, eta, delta, and the original data X and Y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the Meuse River dataset from the package 'gstat'

library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y

f &lt;- function(x) -x ## log-prior for exponential distribution for the smoothing parameter

## Draw 100 samples from the posterior of eta given the data y.
OUTPUT &lt;- DSSP(
  formula = log(zinc) ~ 1, data = meuse.all, N = 100,
  pars = c(0.001, 0.001), log_prior = f
)
</code></pre>

<hr>
<h2 id='make.M'>Precision Matrix Function</h2><span id='topic+make.M'></span>

<h3>Description</h3>

<p>This function creates the precision matrix for the spatial prior based on thin-plate splines
and returns the matrix M, and its eigenvalues and eigenvectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.M(X, covariates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.M_+3A_x">X</code></td>
<td>
<p>a matrix of spatial coordinates. It is recommended that the coordinates be scaled and centred.</p>
</td></tr>
<tr><td><code id="make.M_+3A_covariates">covariates</code></td>
<td>
<p>the observed values for the covariates (including intercept).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The M matrix is the precision matrix for the
spatial effects from the direct sampling spatial prior (DSSP) model. M is based on
thin plate splines basis functions, see White et. al. 2019 for more details on how the
matrix M is constructed.
</p>


<h3>Value</h3>

<p>A list containing the precision matrix M and the object M.eigen containing
eigenvalues and eigenvectors for the matrix M.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the Meuse River dataset from the package 'gstat'

library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y
X &lt;- scale(coordinates(meuse.all))
make.M(X)
</code></pre>

<hr>
<h2 id='plot.dsspMod'>Diagnostic, Density and Contour Plots</h2><span id='topic+plot.dsspMod'></span>

<h3>Description</h3>

<p>Diagnostic, Density and Contour Plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsspMod'
plot(
  x,
  robust_residuals = TRUE,
  contour_plots = TRUE,
  nx = 100,
  ny = 100,
  nlevels = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dsspMod_+3A_x">x</code></td>
<td>
<p>an object of class <code>dsspMod</code></p>
</td></tr>
<tr><td><code id="plot.dsspMod_+3A_robust_residuals">robust_residuals</code></td>
<td>
<p>whether to use robust residuals (median of predicted).
Default to be <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.dsspMod_+3A_contour_plots">contour_plots</code></td>
<td>
<p>whether or not to return a second panel with contour plots.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.dsspMod_+3A_nx">nx</code></td>
<td>
<p>dimension of output grid in x direction.
Used for interpolation (<code>akime::interp()</code>).</p>
</td></tr>
<tr><td><code id="plot.dsspMod_+3A_ny">ny</code></td>
<td>
<p>dimension of output grid in y direction.
Used for interpolation (<code>akime::interp()</code>).</p>
</td></tr>
<tr><td><code id="plot.dsspMod_+3A_nlevels">nlevels</code></td>
<td>
<p>number of levels used in contour plot.</p>
</td></tr>
<tr><td><code id="plot.dsspMod_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code>ggplot2::scale_fill_distiller()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the plots printed (individually and together in grid)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y

f &lt;- function(x) -x ## log-prior for exponential distribution for the smoothing parameter

## Draw 100 samples from the posterior of eta given the data y.
OUTPUT &lt;- DSSP(
  formula = log(zinc) ~ 1, data = meuse.all, N = 100,
  pars = c(0.001, 0.001), log_prior = f
)
plot(OUTPUT, contour_plots = FALSE)
</code></pre>

<hr>
<h2 id='predict.dsspMod'>Predictions from a model with new data.</h2><span id='topic+predict.dsspMod'></span>

<h3>Description</h3>

<p>Predictions from a model with new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsspMod'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.dsspMod_+3A_object">object</code></td>
<td>
<p>a fitted dsspMod object.</p>
</td></tr>
<tr><td><code id="predict.dsspMod_+3A_newdata">newdata</code></td>
<td>
<p>a data frame for which to evaluate predictions.</p>
</td></tr>
<tr><td><code id="predict.dsspMod_+3A_...">...</code></td>
<td>
<p>optional and ignored arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns matrix with posterior densities for each row in the input data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("meuse.all", package = "gstat")
sp::coordinates(meuse.all) &lt;- ~ x + y
meuse.fit &lt;- DSSP(
  formula = log(zinc) ~ 1, data = meuse.all[1:155, ], N = 100, function(x) -2 * log(1 + x),
  pars = c(0.001, 0.001)
)
preds &lt;- predict(meuse.fit, meuse.all[156:164, ])
</code></pre>

<hr>
<h2 id='residuals.dsspMod'>Get residuals from <code>dsspMod</code> model</h2><span id='topic+residuals.dsspMod'></span>

<h3>Description</h3>

<p>Get residuals from <code>dsspMod</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsspMod'
residuals(object, newdata, robust = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.dsspMod_+3A_object">object</code></td>
<td>
<p>an object of class <code>dsspMod</code></p>
</td></tr>
<tr><td><code id="residuals.dsspMod_+3A_newdata">newdata</code></td>
<td>
<p>a data frame for which to estimate residuals.</p>
</td></tr>
<tr><td><code id="residuals.dsspMod_+3A_robust">robust</code></td>
<td>
<p>whether or not to use median (rather than mean) of posterior
density to as estimate calculate residuals.</p>
</td></tr>
<tr><td><code id="residuals.dsspMod_+3A_...">...</code></td>
<td>
<p>additional arguments which are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector containing residuals with same length as rows in data used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y

f &lt;- function(x) -x ## log-prior for exponential distribution for the smoothing parameter

## Draw 100 samples from the posterior of eta given the data y.
OUTPUT &lt;- DSSP(
  formula = log(zinc) ~ 1, data = meuse.all, N = 100,
  pars = c(0.001, 0.001), log_prior = f
)
residuals(OUTPUT)
</code></pre>

<hr>
<h2 id='sample.delta'>Function to sample from the posterior of the variance parameter</h2><span id='topic+sample.delta'></span>

<h3>Description</h3>

<p>This function samples from the log-posterior density of the variance parameter from the likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.delta(eta, ND, EV, Q, pars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample.delta_+3A_eta">eta</code></td>
<td>
<p>samples of the smoothing parameter from the sample.eta function.</p>
</td></tr>
<tr><td><code id="sample.delta_+3A_nd">ND</code></td>
<td>
<p>the rank of the precision matrix, the default value is n-3 for spatial data.</p>
</td></tr>
<tr><td><code id="sample.delta_+3A_ev">EV</code></td>
<td>
<p>eigenvalues of the precision matrix spatial prior from the function make.M().</p>
</td></tr>
<tr><td><code id="sample.delta_+3A_q">Q</code></td>
<td>
<p>the data vector from the cross-product of observed data, Y, and eigenvalues from the M matrix, V.</p>
</td></tr>
<tr><td><code id="sample.delta_+3A_pars">pars</code></td>
<td>
<p>a vector of the prior shape and rate parameters for the
inverse-gamma prior distribution of delta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N samples drawn from the posterior of <code class="reqn">\pi(delta | eta, y)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the Meuse River dataset from the package 'gstat'

library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y
X &lt;- scale(coordinates(meuse.all))
tmp &lt;- make.M(X)

M &lt;- tmp$M

Y &lt;- scale(log(meuse.all$zinc))

ND &lt;- nrow(X) - 3
M.list &lt;- make.M(X) ##  Only Needs to return the eigenvalues and vectors
M &lt;- M.list$M
EV &lt;- M.list$M.eigen$values
V &lt;- M.list$M.eigen$vectors
Q &lt;- crossprod(Y, V)

f &lt;- function(x) -x ## log-prior for exponential distribution for the smoothing parameter
## Draw 100 samples from the posterior of eta given the data y.

ETA &lt;- sample.eta(100, ND, EV, Q, f, UL = 1000)
DELTA &lt;- sample.delta(ETA, ND, EV, Q, pars = c(0.001, 0.001))
##  Old Slow Version of sample.nu()
## sample.delta&lt;-function(eta,nd,ev,Q,pars)
## {
##   N&lt;-length(eta)
##   f.beta&lt;-function(x)
##   {
##     lambda&lt;-1/(1+x*ev)
##     b&lt;-tcrossprod(Q,diag(1-lambda))
##     beta&lt;-0.5*tcrossprod(Q,b)+pars[2]
##     return(beta)
##   }
##   alpha&lt;-pars[1]+nd*0.5
##   beta&lt;-sapply(eta,f.beta)
##   delta&lt;-1/rgamma(N,shape=alpha,rate=beta)
##   return(delta)
## }
</code></pre>

<hr>
<h2 id='sample.eta'>Function to sample from the posterior of the smoothing parameter eta conditioned on the data y.</h2><span id='topic+sample.eta'></span>

<h3>Description</h3>

<p>This function samples from the log-posterior density of the smoothing parameter from the
thin-plate splines based spatial prior using a ratio-of-uniform sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.eta(N, ND, EV, Q, UL = 1000, log_prior)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample.eta_+3A_n">N</code></td>
<td>
<p>the number of samples desired.</p>
</td></tr>
<tr><td><code id="sample.eta_+3A_nd">ND</code></td>
<td>
<p>the rank of the precision matrix, the default value is n-3 for spatial data.</p>
</td></tr>
<tr><td><code id="sample.eta_+3A_ev">EV</code></td>
<td>
<p>eigenvalues of the precision matrix spatial prior from the function make.M().</p>
</td></tr>
<tr><td><code id="sample.eta_+3A_q">Q</code></td>
<td>
<p>the data vector from the cross-product of observed data, Y, and eigenvalues from the M matrix, V.</p>
</td></tr>
<tr><td><code id="sample.eta_+3A_ul">UL</code></td>
<td>
<p>the upper limit for the smoothing parameter value; used for the
ratio-of-uniform sampler, default is 1000.</p>
</td></tr>
<tr><td><code id="sample.eta_+3A_log_prior">log_prior</code></td>
<td>
<p>a function of x evaluating the log of the prior density for eta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N samples drawn from the posterior of eta given the data y <code class="reqn">\pi(eta | y)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the Meuse River dataset from the package 'gstat'

library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y
X &lt;- scale(coordinates(meuse.all))
tmp &lt;- make.M(X)

EV &lt;- tmp$M.eigen$values
V &lt;- tmp$M.eigen$vectors

M &lt;- tmp$M

Y &lt;- scale(log(meuse.all$zinc))
Q &lt;- crossprod(Y, V)

ND &lt;- nrow(X) - 3
f &lt;- function(x) -x ## log-prior for exponential distribution for the smoothing parameter

## Draw 100 samples from the posterior of eta given the data y.
sample.eta(100, ND, EV, Q, UL = 1000, f)
</code></pre>

<hr>
<h2 id='sample.nu'>Function to sample from the posterior of the spatial effects</h2><span id='topic+sample.nu'></span>

<h3>Description</h3>

<p>This function samples from the posterior density of the spatial effects from the direct sampling
spatial prior (DSSP) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.nu(Y, eta, delta, EV, V)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample.nu_+3A_y">Y</code></td>
<td>
<p>vector of observed data.</p>
</td></tr>
<tr><td><code id="sample.nu_+3A_eta">eta</code></td>
<td>
<p>samples of the smoothing parameter from the <code>sample.eta</code> function.</p>
</td></tr>
<tr><td><code id="sample.nu_+3A_delta">delta</code></td>
<td>
<p>samples of the variance parameter from the <code>sample.delta</code> function.</p>
</td></tr>
<tr><td><code id="sample.nu_+3A_ev">EV</code></td>
<td>
<p>eigenvalues of the precision matrix spatial prior from the function <code>make.M()</code>.</p>
</td></tr>
<tr><td><code id="sample.nu_+3A_v">V</code></td>
<td>
<p>eigenvectors of the precision matrix spatial prior from the function <code>make.M()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of samples with each column a random draw from the posterior
of the spatial effects from the DSSP model <code class="reqn">\pi(nu | eta, delta, y)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the Meuse River dataset from the package 'gstat'

library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y
X &lt;- scale(coordinates(meuse.all))
tmp &lt;- make.M(X)

EV &lt;- tmp$M.eigen$values
V &lt;- tmp$M.eigen$vectors

Y &lt;- scale(log(meuse.all$zinc))
Q &lt;- crossprod(Y, V)

ND &lt;- nrow(X) - 3
f &lt;- function(x) -x ## log-prior for exponential distribution for the smoothing parameter
## Draw 100 samples from the posterior of eta given the data y.

ETA &lt;- sample.eta(100, ND, EV, Q, f, UL = 1000)
DELTA &lt;- sample.delta(ETA, ND, EV, Q, pars = c(0.001, 0.001))
NU &lt;- sample.nu(Y, ETA, DELTA, EV, V)
</code></pre>

<hr>
<h2 id='summary.dsspMod'>Summarise a <code>dsspMod</code> model</h2><span id='topic+summary.dsspMod'></span>

<h3>Description</h3>

<p>Summarise a <code>dsspMod</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsspMod'
summary(object, prob = 0.95, robust = FALSE, mc_se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dsspMod_+3A_object">object</code></td>
<td>
<p>an object of class <code>dsspMod</code></p>
</td></tr>
<tr><td><code id="summary.dsspMod_+3A_prob">prob</code></td>
<td>
<p>the desired probability to be covered by the credible intervals.
The default is 0.95.</p>
</td></tr>
<tr><td><code id="summary.dsspMod_+3A_robust">robust</code></td>
<td>
<p>whether or not to use the median (rather than the mean) to
calculate the estimates that summarise the posterior.
Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.dsspMod_+3A_mc_se">mc_se</code></td>
<td>
<p>whether or not to include the uncertainty in <code>Estimate</code>
caused by sampling should be shown in the summary. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.dsspMod_+3A_...">...</code></td>
<td>
<p>additional arguments which are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;dsspModsummary&quot;. Provides a summary of the the Direct Sampling Spatial Prior (DSSP) model. Includes details of the formula used to fit the model, and a summary of the model (<code class="reqn">eta, delta</code>) and the covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y

f &lt;- function(x) -x ## log-prior for exponential distribution for the smoothing parameter

## Draw 100 samples from the posterior of eta given the data y.
OUTPUT &lt;- DSSP(
  formula = log(zinc) ~ 1, data = meuse.all, N = 100,
  pars = c(0.001, 0.001), log_prior = f
)
summary(OUTPUT)
</code></pre>

<hr>
<h2 id='tps.rbf'>TPS radial basis function</h2><span id='topic+tps.rbf'></span>

<h3>Description</h3>

<p>Function to compute the thin-plate splines radial basis function for internal use by the function make.M().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tps.rbf(x, is.even)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tps.rbf_+3A_x">x</code></td>
<td>
<p>is a Euclidean distance between two points.</p>
</td></tr>
<tr><td><code id="tps.rbf_+3A_is.even">is.even</code></td>
<td>
<p>is a logical argument indicating TRUE if the dimension of the space where the thin-plate spline smoother is being fitted is even.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the thin-plate spline radial basis function depending on the if d is odd or even.
</p>


<h3>Value</h3>

<p>The resulting value of the thin-plate spline radial basis function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the Meuse River dataset from the package 'gstat'

library(sp)
library(gstat)
data(meuse.all)
coordinates(meuse.all) &lt;- ~ x + y
X &lt;- scale(coordinates(meuse.all))
D &lt;- as.matrix(dist(X))
K &lt;- tps.rbf(D, TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
