<!DOCTYPE html><html><head><title>Help for package minty</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {minty}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.col_spec'><p>Generate a column specification</p></a></li>
<li><a href='#col_skip'><p>Create column specification</p></a></li>
<li><a href='#date_names'><p>Create or retrieve date names</p></a></li>
<li><a href='#locale'><p>Create locales</p></a></li>
<li><a href='#parse_atomic'><p>Parse logicals, integers, and reals</p></a></li>
<li><a href='#parse_datetime'><p>Parse date/times</p></a></li>
<li><a href='#parse_factor'><p>Parse factors</p></a></li>
<li><a href='#parse_guess'><p>Parse using the &quot;best&quot; type</p></a></li>
<li><a href='#parse_number'><p>Parse numbers, flexibly</p></a></li>
<li><a href='#parse_vector'><p>Parse a character vector.</p></a></li>
<li><a href='#type_convert'><p>Re-convert character columns in existing data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Minimal Type Guesser</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Port the type guesser from 'readr' (so-called 'readr' first edition parsing engine, now superseded by 'vroom').</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gesistsa.github.io/minty/">https://gesistsa.github.io/minty/</a>,
<a href="https://github.com/gesistsa/minty">https://github.com/gesistsa/minty</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gesistsa/minty/issues">https://github.com/gesistsa/minty/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11, tzdb (&ge; 0.1.1)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>tzdb</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, stringi, testthat, withr, hms, readr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>gesistsa/tsatemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-20 11:16:09 UTC; chainsawriot</td>
</tr>
<tr>
<td>Author:</td>
<td>Chung-hong Chan <a href="https://orcid.org/0000-0002-6232-7530"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Hadley Wickham [aut] (author of the ported code from readr),
  Jim Hester [aut] (author of the ported code from readr),
  Romain Francois [ctb] (author of the ported code from readr),
  Jennifer Bryan [aut] (author of the ported code from readr),
  Shelby Bearrows [ctb] (author of the ported code from readr),
  Posit Software, PBC [cph] (copyright holder of readr),
  David Olson [aut] (author of src/tzfile.h)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chung-hong Chan &lt;chainsawtiney@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-22 11:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.col_spec'>Generate a column specification</h2><span id='topic+as.col_spec'></span>

<h3>Description</h3>

<p>This is most useful for generating a specification using the short form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.col_spec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.col_spec_+3A_x">x</code></td>
<td>
<p>Input object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list / S3 object representing column specification
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.col_spec("cccnnn")
</code></pre>

<hr>
<h2 id='col_skip'>Create column specification</h2><span id='topic+col_skip'></span><span id='topic+cols'></span><span id='topic+cols_only'></span>

<h3>Description</h3>

<p><code>cols()</code> includes all columns in the input data, guessing the column types
as the default. <code>cols_only()</code> includes only the columns you explicitly
specify, skipping the rest. In general you can substitute <code>list()</code> for
<code>cols()</code> without changing the behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_skip()

cols(..., .default = col_guess())

cols_only(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_skip_+3A_...">...</code></td>
<td>
<p>Either column objects created by <code style="white-space: pre;">&#8288;col_*()&#8288;</code>, or their abbreviated
character names (as described in the <code>col_types</code> argument of
read_delim). If you're only overriding a few columns, it's
best to refer to columns by name. If not named, the column types must match
the column names exactly.</p>
</td></tr>
<tr><td><code id="col_skip_+3A_.default">.default</code></td>
<td>
<p>Any named columns not explicitly overridden in <code>...</code>
will be read with this column type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available specifications are: (with string abbreviations in brackets)
</p>

<ul>
<li> <p><code>col_logical()</code> [l], containing only <code>T</code>, <code>F</code>, <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li> <p><code>col_integer()</code> [i], integers.
</p>
</li>
<li> <p><code>col_double()</code> [d], doubles.
</p>
</li>
<li> <p><code>col_character()</code> [c], everything else.
</p>
</li>
<li> <p><code>col_factor(levels, ordered)</code> [f], a fixed set of values.
</p>
</li>
<li> <p><code>col_date(format = "")</code> [D]: with the locale's <code>date_format</code>.
</p>
</li>
<li> <p><code>col_time(format = "")</code> [t]: with the locale's <code>time_format</code>.
</p>
</li>
<li> <p><code>col_datetime(format = "")</code> [T]: ISO8601 date times
</p>
</li>
<li> <p><code>col_number()</code> [n], numbers containing the <code>grouping_mark</code>
</p>
</li>
<li> <p><code>col_skip()</code> [_, -], don't import this column.
</p>
</li>
<li> <p><code>col_guess()</code> [?], parse using the &quot;best&quot; type based on the input.
</p>
</li></ul>



<h3>Value</h3>

<p>a list / S3 object representing column specification
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+parse_datetime">parse_datetime</a>()</code>,
<code><a href="#topic+parse_factor">parse_factor</a>()</code>,
<code><a href="#topic+parse_guess">parse_guess</a>()</code>,
<code><a href="#topic+parse_logical">parse_logical</a>()</code>,
<code><a href="#topic+parse_number">parse_number</a>()</code>,
<code><a href="#topic+parse_vector">parse_vector</a>()</code>
</p>
<p>Other parsers: 
<code><a href="#topic+parse_datetime">parse_datetime</a>()</code>,
<code><a href="#topic+parse_factor">parse_factor</a>()</code>,
<code><a href="#topic+parse_guess">parse_guess</a>()</code>,
<code><a href="#topic+parse_logical">parse_logical</a>()</code>,
<code><a href="#topic+parse_number">parse_number</a>()</code>,
<code><a href="#topic+parse_vector">parse_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cols(a = col_integer())
cols_only(a = col_integer())

# You can also use the standard abbreviations
cols(a = "i")
cols(a = "i", b = "d", c = "_")

# You can also use multiple sets of column definitions by combining
# them like so:

t1 &lt;- cols(
  column_one = col_integer(),
  column_two = col_number()
)

t2 &lt;- cols(
  column_three = col_character()
)

t3 &lt;- t1
t3$cols &lt;- c(t1$cols, t2$cols)
t3
</code></pre>

<hr>
<h2 id='date_names'>Create or retrieve date names</h2><span id='topic+date_names'></span><span id='topic+date_names_lang'></span><span id='topic+date_names_langs'></span>

<h3>Description</h3>

<p>When parsing dates, you often need to know how weekdays of the week and
months are represented as text. This pair of functions allows you to either
create your own, or retrieve from a standard list. The standard list is
derived from ICU (<code style="white-space: pre;">&#8288;http://site.icu-project.org&#8288;</code>) via the stringi package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c("AM", "PM"))

date_names_lang(language)

date_names_langs()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_names_+3A_mon">mon</code>, <code id="date_names_+3A_mon_ab">mon_ab</code></td>
<td>
<p>Full and abbreviated month names.</p>
</td></tr>
<tr><td><code id="date_names_+3A_day">day</code>, <code id="date_names_+3A_day_ab">day_ab</code></td>
<td>
<p>Full and abbreviated week day names. Starts with Sunday.</p>
</td></tr>
<tr><td><code id="date_names_+3A_am_pm">am_pm</code></td>
<td>
<p>Names used for AM and PM.</p>
</td></tr>
<tr><td><code id="date_names_+3A_language">language</code></td>
<td>
<p>A BCP 47 locale, made up of a language and a region,
e.g. <code>"en"</code> for American English. See <code>date_names_langs()</code>
for a complete list of available locales.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list / S3 object representing data time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date_names_lang("en")
date_names_lang("ko")
date_names_lang("fr")
</code></pre>

<hr>
<h2 id='locale'>Create locales</h2><span id='topic+locale'></span><span id='topic+default_locale'></span>

<h3>Description</h3>

<p>A locale object tries to capture all the defaults that can vary between
countries. You set the locale in once, and the details are automatically
passed on down to the columns parsers. The defaults have been chosen to
match R (i.e. US English) as closely as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locale(
  date_names = "en",
  date_format = "%AD",
  time_format = "%AT",
  decimal_mark = ".",
  grouping_mark = ",",
  tz = "UTC",
  encoding = "UTF-8",
  asciify = FALSE
)

default_locale()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locale_+3A_date_names">date_names</code></td>
<td>
<p>Character representations of day and month names. Either
the language code as string (passed on to <code><a href="#topic+date_names_lang">date_names_lang()</a></code>)
or an object created by <code><a href="#topic+date_names">date_names()</a></code>.</p>
</td></tr>
<tr><td><code id="locale_+3A_date_format">date_format</code>, <code id="locale_+3A_time_format">time_format</code></td>
<td>
<p>Default date and time formats.</p>
</td></tr>
<tr><td><code id="locale_+3A_decimal_mark">decimal_mark</code>, <code id="locale_+3A_grouping_mark">grouping_mark</code></td>
<td>
<p>Symbols used to indicate the decimal
place, and to chunk larger numbers. Decimal mark can only be <code style="white-space: pre;">&#8288;,&#8288;</code> or
<code>.</code>.</p>
</td></tr>
<tr><td><code id="locale_+3A_tz">tz</code></td>
<td>
<p>Default tz. This is used both for input (if the time zone isn't
present in individual strings), and for output (to control the default
display). The default is to use &quot;UTC&quot;, a time zone that does not use
daylight savings time (DST) and hence is typically most useful for data.
The absence of time zones makes it approximately 50x faster to generate
UTC times than any other time zone.
</p>
<p>Use <code>""</code> to use the system default time zone, but beware that this
will not be reproducible across systems.
</p>
<p>For a complete list of possible time zones, see <code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code>.
Americans, note that &quot;EST&quot; is a Canadian time zone that does not have
DST. It is <em>not</em> Eastern Standard Time. It's better to use
&quot;US/Eastern&quot;, &quot;US/Central&quot; etc.</p>
</td></tr>
<tr><td><code id="locale_+3A_encoding">encoding</code></td>
<td>
<p>Default encoding (not used in <code>minty</code>).</p>
</td></tr>
<tr><td><code id="locale_+3A_asciify">asciify</code></td>
<td>
<p>Should diacritics be stripped from date names and converted to
ASCII? This is useful if you're dealing with ASCII data where the correct
spellings have been lost. Requires the <span class="pkg">stringi</span> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list / S3 object representing the locale information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locale()
locale("fr")

# South American locale
locale("es", decimal_mark = ",")
</code></pre>

<hr>
<h2 id='parse_atomic'>Parse logicals, integers, and reals</h2><span id='topic+parse_logical'></span><span id='topic+parse_integer'></span><span id='topic+parse_double'></span><span id='topic+parse_character'></span><span id='topic+col_logical'></span><span id='topic+col_integer'></span><span id='topic+col_double'></span><span id='topic+col_character'></span>

<h3>Description</h3>

<p>Use <code style="white-space: pre;">&#8288;parse_*()&#8288;</code> if you have a character vector you want to parse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_logical(
  x,
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)

parse_integer(
  x,
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)

parse_double(
  x,
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)

parse_character(
  x,
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)

col_logical()

col_integer()

col_double()

col_character()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_atomic_+3A_x">x</code></td>
<td>
<p>Character vector of values to parse.</p>
</td></tr>
<tr><td><code id="parse_atomic_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="parse_atomic_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="parse_atomic_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="parse_atomic_+3A_.return_problems">.return_problems</code></td>
<td>
<p>Whether to hide the <code>problems</code> tibble from the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a parsed vector
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+col_skip">col_skip</a>()</code>,
<code><a href="#topic+parse_datetime">parse_datetime</a>()</code>,
<code><a href="#topic+parse_factor">parse_factor</a>()</code>,
<code><a href="#topic+parse_guess">parse_guess</a>()</code>,
<code><a href="#topic+parse_number">parse_number</a>()</code>,
<code><a href="#topic+parse_vector">parse_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_integer(c("1", "2", "3"))
parse_double(c("1", "2", "3.123"))
parse_number("$1,123,456.00")

# Use locale to override default decimal and grouping marks
es_MX &lt;- locale("es", decimal_mark = ",")
parse_number("$1.123.456,00", locale = es_MX)

# Invalid values are replaced with missing values with a warning.
x &lt;- c("1", "2", "3", "-")
parse_double(x)
# Or flag values as missing
parse_double(x, na = "-")
</code></pre>

<hr>
<h2 id='parse_datetime'>Parse date/times</h2><span id='topic+parse_datetime'></span><span id='topic+parse_date'></span><span id='topic+parse_time'></span><span id='topic+col_datetime'></span><span id='topic+col_date'></span><span id='topic+col_time'></span>

<h3>Description</h3>

<p>Parse date/times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_datetime(
  x,
  format = "",
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)

parse_date(
  x,
  format = "",
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)

parse_time(
  x,
  format = "",
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)

col_datetime(format = "")

col_date(format = "")

col_time(format = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_datetime_+3A_x">x</code></td>
<td>
<p>A character vector of dates to parse.</p>
</td></tr>
<tr><td><code id="parse_datetime_+3A_format">format</code></td>
<td>
<p>A format specification, as described below. If set to &quot;&quot;,
date times are parsed as ISO8601, dates and times used the date and
time formats specified in the <code><a href="#topic+locale">locale()</a></code>.
</p>
<p>Unlike <code><a href="base.html#topic+strptime">strptime()</a></code>, the format specification must match
the complete string.</p>
</td></tr>
<tr><td><code id="parse_datetime_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="parse_datetime_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="parse_datetime_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="parse_datetime_+3A_.return_problems">.return_problems</code></td>
<td>
<p>Whether to hide the <code>problems</code> tibble from the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+POSIXct">POSIXct()</a></code> vector with <code>tzone</code> attribute set to
<code>tz</code>. Elements that could not be parsed (or did not generate valid
dates) will be set to <code>NA</code>, and a warning message will inform
you of the total number of failures.
</p>


<h3>Format specification</h3>

<p><code>minty</code> (inherited from <code>readr</code>) uses a format specification similar to <code><a href="base.html#topic+strptime">strptime()</a></code>.
There are three types of element:
</p>

<ol>
<li><p> Date components are specified with &quot;%&quot; followed by a letter. For example
&quot;%Y&quot; matches a 4 digit year, &quot;%m&quot;, matches a 2 digit month and &quot;%d&quot; matches
a 2 digit day. Month and day default to <code>1</code>, (i.e. Jan 1st) if not present,
for example if only a year is given.
</p>
</li>
<li><p> Whitespace is any sequence of zero or more whitespace characters.
</p>
</li>
<li><p> Any other character is matched exactly.
</p>
</li></ol>

<p><code>parse_datetime()</code> recognises the following format specifications:
</p>

<ul>
<li><p> Year: &quot;%Y&quot; (4 digits). &quot;%y&quot; (2 digits); 00-69 -&gt; 2000-2069, 70-99 -&gt;
1970-1999.
</p>
</li>
<li><p> Month: &quot;%m&quot; (2 digits), &quot;%b&quot; (abbreviated name in current locale), &quot;%B&quot;
(full name in current locale).
</p>
</li>
<li><p> Day: &quot;%d&quot; (2 digits), &quot;%e&quot; (optional leading space), &quot;%a&quot; (abbreviated
name in current locale).
</p>
</li>
<li><p> Hour: &quot;%H&quot; or &quot;%I&quot; or &quot;%h&quot;, use I (and not H) with AM/PM, use h (and not H)
if your times represent durations longer than one day.
</p>
</li>
<li><p> Minutes: &quot;%M&quot;
</p>
</li>
<li><p> Seconds: &quot;%S&quot; (integer seconds), &quot;%OS&quot; (partial seconds)
</p>
</li>
<li><p> Time zone: &quot;%Z&quot; (as name, e.g. &quot;America/Chicago&quot;), &quot;%z&quot; (as offset from
UTC, e.g. &quot;+0800&quot;)
</p>
</li>
<li><p> AM/PM indicator: &quot;%p&quot;.
</p>
</li>
<li><p> Non-digits: &quot;%.&quot; skips one non-digit character, &quot;%+&quot; skips one or more
non-digit characters, &quot;%*&quot; skips any number of non-digits characters.
</p>
</li>
<li><p> Automatic parsers: &quot;%AD&quot; parses with a flexible YMD parser, &quot;%AT&quot; parses
with a flexible HMS parser.
</p>
</li>
<li><p> Time since the Unix epoch: &quot;%s&quot; decimal seconds since the Unix epoch.
</p>
</li>
<li><p> Shortcuts: &quot;%D&quot; = &quot;%m/%d/%y&quot;, &quot;%F&quot; = &quot;%Y-%m-%d&quot;, &quot;%R&quot; = &quot;%H:%M&quot;, &quot;%T&quot; =
&quot;%H:%M:%S&quot;, &quot;%x&quot; = &quot;%y/%m/%d&quot;.
</p>
</li></ul>



<h3>ISO8601 support</h3>

<p>Currently, <code>minty</code> does not support all of ISO8601. Missing features:
</p>

<ul>
<li><p> Week &amp; weekday specifications, e.g. &quot;2013-W05&quot;, &quot;2013-W05-10&quot;.
</p>
</li>
<li><p> Ordinal dates, e.g. &quot;2013-095&quot;.
</p>
</li>
<li><p> Using commas instead of a period for decimal separator.
</p>
</li></ul>

<p>The parser is also a little laxer than ISO8601:
</p>

<ul>
<li><p> Dates and times can be separated with a space, not just T.
</p>
</li>
<li><p> Mostly correct specifications like &quot;2009-05-19 14:&quot; and &quot;200912-01&quot; work.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+col_skip">col_skip</a>()</code>,
<code><a href="#topic+parse_factor">parse_factor</a>()</code>,
<code><a href="#topic+parse_guess">parse_guess</a>()</code>,
<code><a href="#topic+parse_logical">parse_logical</a>()</code>,
<code><a href="#topic+parse_number">parse_number</a>()</code>,
<code><a href="#topic+parse_vector">parse_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Format strings --------------------------------------------------------
parse_datetime("01/02/2010", "%d/%m/%Y")
parse_datetime("01/02/2010", "%m/%d/%Y")
# Handle any separator
parse_datetime("01/02/2010", "%m%.%d%.%Y")

# Dates look the same, but internally they use the number of days since
# 1970-01-01 instead of the number of seconds. This avoids a whole lot
# of troubles related to time zones, so use if you can.
parse_date("01/02/2010", "%d/%m/%Y")
parse_date("01/02/2010", "%m/%d/%Y")

# You can parse timezones from strings (as listed in OlsonNames())
parse_datetime("2010/01/01 12:00 US/Central", "%Y/%m/%d %H:%M %Z")
# Or from offsets
parse_datetime("2010/01/01 12:00 -0600", "%Y/%m/%d %H:%M %z")

# Use the locale parameter to control the default time zone
# (but note UTC is considerably faster than other options)
parse_datetime("2010/01/01 12:00", "%Y/%m/%d %H:%M",
  locale = locale(tz = "US/Central")
)
parse_datetime("2010/01/01 12:00", "%Y/%m/%d %H:%M",
  locale = locale(tz = "US/Eastern")
)

# Unlike strptime, the format specification must match the complete
# string (ignoring leading and trailing whitespace). This avoids common
# errors:
strptime("01/02/2010", "%d/%m/%y")
parse_datetime("01/02/2010", "%d/%m/%y")

# Failures -------------------------------------------------------------
parse_datetime("01/01/2010", "%d/%m/%Y")
parse_datetime(c("01/ab/2010", "32/01/2010"), "%d/%m/%Y")

# Locales --------------------------------------------------------------
# By default, readr expects English date/times, but that's easy to change'
parse_datetime("1 janvier 2015", "%d %B %Y", locale = locale("fr"))
parse_datetime("1 enero 2015", "%d %B %Y", locale = locale("es"))

# ISO8601 --------------------------------------------------------------
# With separators
parse_datetime("1979-10-14")
parse_datetime("1979-10-14T10")
parse_datetime("1979-10-14T10:11")
parse_datetime("1979-10-14T10:11:12")
parse_datetime("1979-10-14T10:11:12.12345")

# Without separators
parse_datetime("19791014")
parse_datetime("19791014T101112")

# Time zones
us_central &lt;- locale(tz = "US/Central")
parse_datetime("1979-10-14T1010", locale = us_central)
parse_datetime("1979-10-14T1010-0500", locale = us_central)
parse_datetime("1979-10-14T1010Z", locale = us_central)
# Your current time zone
parse_datetime("1979-10-14T1010", locale = locale(tz = ""))
</code></pre>

<hr>
<h2 id='parse_factor'>Parse factors</h2><span id='topic+parse_factor'></span><span id='topic+col_factor'></span>

<h3>Description</h3>

<p><code>parse_factor()</code> is similar to <code><a href="base.html#topic+factor">factor()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_factor(
  x,
  levels = NULL,
  ordered = FALSE,
  na = c("", "NA"),
  locale = default_locale(),
  include_na = TRUE,
  trim_ws = TRUE,
  .return_problems = FALSE
)

col_factor(levels = NULL, ordered = FALSE, include_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_factor_+3A_x">x</code></td>
<td>
<p>Character vector of values to parse.</p>
</td></tr>
<tr><td><code id="parse_factor_+3A_levels">levels</code></td>
<td>
<p>Character vector of the allowed levels. When <code>levels = NULL</code>
(the default), <code>levels</code> are discovered from the unique values of <code>x</code>, in
the order in which they appear in <code>x</code>.</p>
</td></tr>
<tr><td><code id="parse_factor_+3A_ordered">ordered</code></td>
<td>
<p>Is it an ordered factor?</p>
</td></tr>
<tr><td><code id="parse_factor_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="parse_factor_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="parse_factor_+3A_include_na">include_na</code></td>
<td>
<p>If <code>TRUE</code> and <code>x</code> contains at least one <code>NA</code>, then <code>NA</code>
is included in the levels of the constructed factor.</p>
</td></tr>
<tr><td><code id="parse_factor_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="parse_factor_+3A_.return_problems">.return_problems</code></td>
<td>
<p>Whether to hide the <code>problems</code> tibble from the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a parsed vector
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+col_skip">col_skip</a>()</code>,
<code><a href="#topic+parse_datetime">parse_datetime</a>()</code>,
<code><a href="#topic+parse_guess">parse_guess</a>()</code>,
<code><a href="#topic+parse_logical">parse_logical</a>()</code>,
<code><a href="#topic+parse_number">parse_number</a>()</code>,
<code><a href="#topic+parse_vector">parse_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># discover the levels from the data
parse_factor(c("a", "b"))
parse_factor(c("a", "b", "-99"))
parse_factor(c("a", "b", "-99"), na = c("", "NA", "-99"))
parse_factor(c("a", "b", "-99"), na = c("", "NA", "-99"), include_na = FALSE)

# provide the levels explicitly
parse_factor(c("a", "b"), levels = letters[1:5])

x &lt;- c("cat", "dog", "caw")
animals &lt;- c("cat", "dog", "cow")

# base::factor() silently converts elements that do not match any levels to
# NA
factor(x, levels = animals)

# parse_factor() generates same factor as base::factor() but throws a warning
# and reports problems
parse_factor(x, levels = animals)
</code></pre>

<hr>
<h2 id='parse_guess'>Parse using the &quot;best&quot; type</h2><span id='topic+parse_guess'></span><span id='topic+col_guess'></span>

<h3>Description</h3>

<p><code>parse_guess()</code> returns the parser vector. This function uses a number of heuristics
to determine which type of vector is &quot;best&quot;. Generally they try to err of
the side of safety, as it's straightforward to override the parsing choice
if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_guess(
  x,
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  guess_integer = FALSE,
  .return_problems = FALSE
)

col_guess()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_guess_+3A_x">x</code></td>
<td>
<p>Character vector of values to parse.</p>
</td></tr>
<tr><td><code id="parse_guess_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="parse_guess_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="parse_guess_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="parse_guess_+3A_guess_integer">guess_integer</code></td>
<td>
<p>If <code>TRUE</code>, guess integer types for whole numbers, if
<code>FALSE</code> guess numeric type for all numbers.</p>
</td></tr>
<tr><td><code id="parse_guess_+3A_.return_problems">.return_problems</code></td>
<td>
<p>Whether to hide the <code>problems</code> tibble from the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a parsed vector
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+col_skip">col_skip</a>()</code>,
<code><a href="#topic+parse_datetime">parse_datetime</a>()</code>,
<code><a href="#topic+parse_factor">parse_factor</a>()</code>,
<code><a href="#topic+parse_logical">parse_logical</a>()</code>,
<code><a href="#topic+parse_number">parse_number</a>()</code>,
<code><a href="#topic+parse_vector">parse_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Logical vectors
parse_guess(c("FALSE", "TRUE", "F", "T"))

# Integers and doubles
parse_guess(c("1", "2", "3"))
parse_guess(c("1.6", "2.6", "3.4"))

# Numbers containing grouping mark
parse_guess("1,234,566")

# ISO 8601 date times
parse_guess(c("2010-10-10"))
</code></pre>

<hr>
<h2 id='parse_number'>Parse numbers, flexibly</h2><span id='topic+parse_number'></span><span id='topic+col_number'></span>

<h3>Description</h3>

<p>This parses the first number it finds, dropping any non-numeric characters
before the first number and all characters after the first number. The
grouping mark specified by the locale is ignored inside the number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_number(
  x,
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)

col_number()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_number_+3A_x">x</code></td>
<td>
<p>Character vector of values to parse.</p>
</td></tr>
<tr><td><code id="parse_number_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="parse_number_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="parse_number_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="parse_number_+3A_.return_problems">.return_problems</code></td>
<td>
<p>Whether to hide the <code>problems</code> tibble from the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector (double) of parsed numbers.
</p>
<p>a parsed vector
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+col_skip">col_skip</a>()</code>,
<code><a href="#topic+parse_datetime">parse_datetime</a>()</code>,
<code><a href="#topic+parse_factor">parse_factor</a>()</code>,
<code><a href="#topic+parse_guess">parse_guess</a>()</code>,
<code><a href="#topic+parse_logical">parse_logical</a>()</code>,
<code><a href="#topic+parse_vector">parse_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## These all return 1000
parse_number("$1,000") ## leading `$` and grouping character `,` ignored
parse_number("euro1,000") ## leading non-numeric euro ignored
parse_number("t1000t1000") ## only parses first number found

parse_number("1,234.56")
## explicit locale specifying European grouping and decimal marks
parse_number("1.234,56", locale = locale(decimal_mark = ",", grouping_mark = "."))
## SI/ISO 31-0 standard spaces for number grouping
parse_number("1 234.56", locale = locale(decimal_mark = ".", grouping_mark = " "))

## Specifying strings for NAs
parse_number(c("1", "2", "3", "NA"))
parse_number(c("1", "2", "3", "NA", "Nothing"), na = c("NA", "Nothing"))
</code></pre>

<hr>
<h2 id='parse_vector'>Parse a character vector.</h2><span id='topic+parse_vector'></span>

<h3>Description</h3>

<p>Parse a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_vector(
  x,
  collector,
  na = c("", "NA"),
  locale = default_locale(),
  trim_ws = TRUE,
  .return_problems = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_vector_+3A_x">x</code></td>
<td>
<p>Character vector of elements to parse.</p>
</td></tr>
<tr><td><code id="parse_vector_+3A_collector">collector</code></td>
<td>
<p>Column specification.</p>
</td></tr>
<tr><td><code id="parse_vector_+3A_.return_problems">.return_problems</code></td>
<td>
<p>Whether to hide the <code>problems</code> tibble from the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a parsed vector
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+col_skip">col_skip</a>()</code>,
<code><a href="#topic+parse_datetime">parse_datetime</a>()</code>,
<code><a href="#topic+parse_factor">parse_factor</a>()</code>,
<code><a href="#topic+parse_guess">parse_guess</a>()</code>,
<code><a href="#topic+parse_logical">parse_logical</a>()</code>,
<code><a href="#topic+parse_number">parse_number</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("1", "2", "3", "NA")
parse_vector(x, col_integer())
parse_vector(x, col_double())
</code></pre>

<hr>
<h2 id='type_convert'>Re-convert character columns in existing data frame</h2><span id='topic+type_convert'></span>

<h3>Description</h3>

<p>This is useful if you need to do some manual munging - you can read the
columns in as character, clean it up with (e.g.) regular expressions and
then let readr take another stab at parsing it. The name is a homage to
the base <code><a href="utils.html#topic+type.convert">utils::type.convert()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_convert(
  df,
  col_types = NULL,
  na = c("", "NA"),
  trim_ws = TRUE,
  locale = default_locale(),
  guess_integer = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_convert_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="type_convert_+3A_col_types">col_types</code></td>
<td>
<p>One of <code>NULL</code>, a <code><a href="#topic+cols">cols()</a></code> specification, or
a string.
</p>
<p>If <code>NULL</code>, column types will be imputed using all rows.</p>
</td></tr>
<tr><td><code id="type_convert_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="type_convert_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="type_convert_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="type_convert_+3A_guess_integer">guess_integer</code></td>
<td>
<p>If <code>TRUE</code>, guess integer types for whole numbers, if
<code>FALSE</code> guess numeric type for all numbers.</p>
</td></tr>
<tr><td><code id="type_convert_+3A_verbose">verbose</code></td>
<td>
<p>whether to print messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Note</h3>

<p><code>type_convert()</code> removes a 'spec' attribute (if it presents).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = as.character(runif(10)),
  y = as.character(sample(10)),
  stringsAsFactors = FALSE
)
str(df)
str(type_convert(df))

df &lt;- data.frame(x = c("NA", "10"), stringsAsFactors = FALSE)
str(type_convert(df))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
