<!DOCTYPE html><html lang="en"><head><title>Help for package VertexWiseR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VertexWiseR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#atlas_to_surf'><p>Atlas to surface</p></a></li>
<li><a href='#CAT12vextract'><p>CAT12vextract</p></a></li>
<li><a href='#decode_surf_data'><p>Decode surface data</p></a></li>
<li><a href='#edgelist_hip'><p>List of edges for the hippocampal template</p></a></li>
<li><a href='#edgelist-class'><p>Edge list object</p></a></li>
<li><a href='#fs_stats'><p>fs_stats()</p></a></li>
<li><a href='#fs5_to_fs6'><p>fsaverage5 to fsaverage6</p></a></li>
<li><a href='#fs6_to_fs5'><p>fsaverage6 to fsaverage5</p></a></li>
<li><a href='#fs6_to_fs5_map'><p>fsaverage6 template object for nearest neighbor conversion in fs6_to_fs5()</p></a></li>
<li><a href='#FSLRvextract'><p>FSLRvextract</p></a></li>
<li><a href='#hip_points_cells'><p>points and cells data required to build the hippocampus surface template</p></a></li>
<li><a href='#HIPvextract'><p>HIPvextract</p></a></li>
<li><a href='#MNImap_hip'><p>Hippocampal surface in MNI space</p></a></li>
<li><a href='#MNIsurface-class'><p>MNI surface map object</p></a></li>
<li><a href='#plot_surf'><p>Surface plotter</p></a></li>
<li><a href='#plot_surf3d'><p>3D Surface plotter</p></a></li>
<li><a href='#RFT_vertex_analysis'><p>Vertex-wise analysis with random field theory cluster correction</p></a></li>
<li><a href='#ROImap_fs5'><p>Atlas parcellations of fsaverage5</p></a></li>
<li><a href='#ROImap_fs6'><p>Atlas parcellations of fsaverage6</p></a></li>
<li><a href='#ROImap_fslr32k'><p>Atlas parcellations of FS_LR32k</p></a></li>
<li><a href='#ROImap_hip'><p>Atlas parcellations of the hippocampus (CITI168)</p></a></li>
<li><a href='#ROImap-class'><p>Region-of-Interest mapping object</p></a></li>
<li><a href='#smooth_surf'><p>Smooth surface</p></a></li>
<li><a href='#surf_to_atlas'><p>Surface to atlas</p></a></li>
<li><a href='#surf_to_vol'><p>Surface to volume</p></a></li>
<li><a href='#SURFvextract'><p>SURFvextract</p></a></li>
<li><a href='#TFCE_threshold'><p>Thresholding TFCE output</p></a></li>
<li><a href='#TFCE_vertex_analysis'><p>Vertex-wise analysis with threshold-free cluster enhancement (fixed effect)</p></a></li>
<li><a href='#TFCE_vertex_analysis_mixed'><p>Vertex-wise analysis with threshold-free cluster enhancement (mixed effect)</p></a></li>
<li><a href='#VWRfirstrun'><p>VertexWiseR system requirements installation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simplified Vertex-Wise Analyses of Whole-Brain and Hippocampal
Surface</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charly Billaud &lt;charly.billaud@ntu.edu.sg&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to run statistical analyses on
    surface-based neuroimaging data, computing measures including cortical
    thickness and surface area of the whole-brain and of the hippocampi.
    It can make use of 'FreeSurfer', 'fMRIprep' and 'HCP' preprocessed
    datasets and 'HippUnfold' hippocampal segmentation outputs for a given
    sample by restructuring the data values into a single file. The single
    file can then be used by the package for analyses independently from
    its base dataset and without need for its access.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cogbrainhealthlab.github.io/VertexWiseR/">https://cogbrainhealthlab.github.io/VertexWiseR/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Miniconda3 (v24.9.2), Python (&lt;= v3.12), BrainStat
(v0.4.2), vtk (v9.3.1)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ciftiTools, doParallel, doSNOW, foreach, freesurferformats,
fs, gifti, grDevices, igraph, methods, plotly, png, rappdirs,
reticulate, stats, stringr, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-18 08:46:45 UTC; charly.billaud</td>
</tr>
<tr>
<td>Author:</td>
<td>Junhong Yu <a href="https://orcid.org/0000-0002-2563-9658"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Charly Billaud <a href="https://orcid.org/0009-0001-3466-9963"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-18 12:00:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='atlas_to_surf'>Atlas to surface</h2><span id='topic+atlas_to_surf'></span>

<h3>Description</h3>

<p>Maps average parcellation surface values (e.g. produced with the surf_to_atlas() function) to the fsaverage5, fsaverage6 or fslr32k space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atlas_to_surf(parcel_data, template)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atlas_to_surf_+3A_parcel_data">parcel_data</code></td>
<td>
<p>A matrix or vector object containing average surface measures for each region of interest, see the surf_to_atlas() output format.</p>
</td></tr>
<tr><td><code id="atlas_to_surf_+3A_template">template</code></td>
<td>
<p>A string object stating the surface space on which to map the data ('fsaverage5', 'fsaverage6', 'fslr32k', 'CIT168' (hippocampal)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently supports the Desikan-Killiany-70, Schaefer-100, Schaefer-200, Schaefer-400, Glasser-360, or Destrieux-148 atlases for cortical surfaces, and the 'bigbrain' 10-parcels atlas for hippocampal surfaces. ROI to vertex mapping data for 1 to 4 were obtained from the <a href="https://github.com/MICA-MNI/ENIGMA/tree/master/enigmatoolbox/datasets/parcellations">'ENIGMA toolbox'</a> ; and data for 5 from <a href="https://github.com/nilearn/nilearn/blob/a366d22e426b07166e6f8ce1b7ac6eb732c88155/nilearn/datasets/atlas.py">'Nilearn' 's nilearn.datasets.fetch_atlas_surf_destrieux</a> . atlas_to_surf() will automatically detect the atlas based on the number of columns.
</p>


<h3>Value</h3>

<p>A matrix or vector object containing vertex-wise surface data mapped in fsaverage5, fsaverage6, fslr32k, or CIT168 space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surf_to_atlas">surf_to_atlas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parcel_data = t(runif(100,min=0, max=100));
surf_data = atlas_to_surf(parcel_data, template='fsaverage5');
</code></pre>

<hr>
<h2 id='CAT12vextract'>CAT12vextract</h2><span id='topic+CAT12vextract'></span>

<h3>Description</h3>

<p>Extracts vertex-wise surface-based measures for each subject from a <a href="https://neuro-jena.github.io/cat12-help/">CAT12</a> preprocessed directory, resampled to a 32k mesh, and stores them all as a single .RDS file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAT12vextract(
  sdirpath = "./",
  filename,
  measure = "thickness",
  subj_ID = TRUE,
  silent = FALSE,
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAT12vextract_+3A_sdirpath">sdirpath</code></td>
<td>
<p>A string object containing the path to the CAT12 subjects preprocessed directory. Default is the current working directory (&quot;./&quot;).</p>
</td></tr>
<tr><td><code id="CAT12vextract_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output RDS file. Default is 'CAT12_measure.rds' in the R temporary directory (tempdir()).</p>
</td></tr>
<tr><td><code id="CAT12vextract_+3A_measure">measure</code></td>
<td>
<p>A string object containing the name of the measure of interest. Options are 'thickness', 'depth', 'fractaldimension', 'gyrification', and 'toroGI20mm'. Default is 'thickness.'</p>
</td></tr>
<tr><td><code id="CAT12vextract_+3A_subj_id">subj_ID</code></td>
<td>
<p>A logical object to determine whether to return a list object containing both subject ID and data matrix. Subject IDs are assumed to be the top directory names in the sdirpath.</p>
</td></tr>
<tr><td><code id="CAT12vextract_+3A_silent">silent</code></td>
<td>
<p>A logical object to determine whether messages will be silenced. Set to 'FALSE' by default</p>
</td></tr>
<tr><td><code id="CAT12vextract_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches inside the CAT12 preprocessed for 32k meshes (.gii) with the user-selected measure, extracts the data from these files, and organizes the left and right hemisphere vertex data for each subject as rows in a N x 64984 data matrix within a .rds object. Python and reticulate are required as the <a href="https://nipy.org/nibabel/">NiBabel</a> package is used to import .gii files outputted by CAT12.
</p>


<h3>Value</h3>

<p>A .RDSfile with a list containing 1. the list of subject IDs (first element) and 2. a surface data matrix object (second element), or only a data matrix object. The matrix has N subjects x M vertices dimensions and can be readily used by VertexWiseR statistical analysis functions. Each row corresponds to a subject (in the order they are listed in the folder) and contains the left to right hemispheres' vertex-wise values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CAT12vextract(sdirpath="./", 
filename='thickness.rds', 
measure='thickness', 
subj_ID = TRUE, 
VWR_check=FALSE)

</code></pre>

<hr>
<h2 id='decode_surf_data'>Decode surface data</h2><span id='topic+decode_surf_data'></span>

<h3>Description</h3>

<p>Correlates the significant clusters of an earlier vertex-wise analysis with a database of task-based fMRI and voxel-based morphometric statistical maps and associate them with relevant key words. Decoding currently works with surfaces in fsaverage5 space only.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_surf_data(surf_data, contrast = "positive", VWR_check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decode_surf_data_+3A_surf_data">surf_data</code></td>
<td>
<p>A numeric vector or object containing the surface data,  in fsaverage5 (1 x 20484 vertices). It can only be one row of vertices (not a cohort surface data matrix).</p>
</td></tr>
<tr><td><code id="decode_surf_data_+3A_contrast">contrast</code></td>
<td>
<p>A string object indicating whether to decode the positive or negative mask ('positive' or 'negative')</p>
</td></tr>
<tr><td><code id="decode_surf_data_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="https://nimare.readthedocs.io/en/stable/index.html">'NiMARE'</a> python module is used for the imaging decoding and is imported via the reticulate package. The function also downloads the <a href="https://github.com/neurosynth/neurosynth-data">'Neurosynth' database</a> in the package's inst/extdata directory (~8 Mb) for the analysis.
</p>


<h3>Value</h3>

<p>A data.frame object listing the keywords and their Pearson's R values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CTv = rbinom(20484, 1, 0.001) 
decoding = decode_surf_data(CTv, 'positive', VWR_check=FALSE);
head(decoding)
</code></pre>

<hr>
<h2 id='edgelist_hip'>List of edges for the hippocampal template</h2><span id='topic+edgelist_hip'></span>

<h3>Description</h3>

<p>A Nx2 matrix object listing each vertex of the hippocampal template and the vertices adjacent to it (making an edge together).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist_hip
</code></pre>


<h3>Format</h3>



<h4><code>edgelist_hip</code></h4>


<dl>
<dt>Nx2 matrix object</dt><dd><p>Matrix with two columns and N rows corresponding to the unique edges in the fsaverage5 surface</p>
</dd>
</dl>



<hr>
<h2 id='edgelist-class'>Edge list object</h2><span id='topic+edgelist-class'></span>

<h3>Description</h3>

<p>A class for adjacent vertex correspondance
</p>


<h3>Slots</h3>


<dl>
<dt><code>matrix</code></dt><dd><p>A N x 2 matrix object listing each vertex of the template and the vertices adjacent to it (making an edge together).</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the template surface</p>
</dd>
</dl>

<hr>
<h2 id='fs_stats'>fs_stats()</h2><span id='topic+fs_stats'></span>

<h3>Description</h3>

<p>Extracts descriptive statistics, for the whole-brain and subcortical region-of-interests (ROI), within a FreeSurfer subjects directory. It reads them from the aseg.stats file, as generated by the default FreeSurfer preprocessing pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs_stats(sdirpath = "./", sublist, ROImeasure = "Volume_mm3")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs_stats_+3A_sdirpath">sdirpath</code></td>
<td>
<p>A string object indicating the path to the 'FreeSurfer' subjects directory. Default is the current working directory (&quot;./&quot;).</p>
</td></tr>
<tr><td><code id="fs_stats_+3A_sublist">sublist</code></td>
<td>
<p>A string object indicating the path to the subject list generated by SURFvextract as 'sublist.txt' (optional). This allows users to retrieve stats only from a selected list of subjects. The subject list is a list with 1 subject ID per line.</p>
</td></tr>
<tr><td><code id="fs_stats_+3A_roimeasure">ROImeasure</code></td>
<td>
<p>A string object indicating what summary measure to extract for the subocrtical ROIs. Choices include: 'NVoxels', 'Volume_mm3', 'StructName', 'normMean', 'normStdDev', 'normMin', 'normMax', and 'normRange'. Default is 'Volume_mm3'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame object with N columns per aseg.stats measures and N row per subjects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs_stats(sdirpath="freesurfer_subjdir")
</code></pre>

<hr>
<h2 id='fs5_to_fs6'>fsaverage5 to fsaverage6</h2><span id='topic+fs5_to_fs6'></span>

<h3>Description</h3>

<p>Remaps vertex-wise surface data in fsaverage5 space to fsaverage6 space using the nearest neighbor approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs5_to_fs6(surf_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs5_to_fs6_+3A_surf_data">surf_data</code></td>
<td>
<p>A N x V matrix object containing the surface data (N row for each subject, V for each vertex), in fsaverage5 (20484 vertices)  space. See also SURFvextract() output format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object containing vertex-wise surface data mapped in fsaverage6 space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fs6_to_fs5">fs6_to_fs5</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CTv = runif(20484,min=0, max=100);
CTv_fs6 = fs5_to_fs6(CTv);
</code></pre>

<hr>
<h2 id='fs6_to_fs5'>fsaverage6 to fsaverage5</h2><span id='topic+fs6_to_fs5'></span>

<h3>Description</h3>

<p>Remaps vertex-wise surface data in fsaverage6 space to fsaverage5 space using the nearest neighbor approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs6_to_fs5(surf_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs6_to_fs5_+3A_surf_data">surf_data</code></td>
<td>
<p>A N x V matrix object containing the surface data (N row for each subject, V for each vertex), in fsaverage6 (81924 vertices) space. See also SURFvextract() output format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object containing vertex-wise surface data mapped in fsaverage5 space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fs5_to_fs6">fs5_to_fs6</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surf_data = runif(81924,min=0, max=100);
fs5_data=fs6_to_fs5(surf_data)
</code></pre>

<hr>
<h2 id='fs6_to_fs5_map'>fsaverage6 template object for nearest neighbor conversion in fs6_to_fs5()</h2><span id='topic+fs6_to_fs5_map'></span>

<h3>Description</h3>

<p>fsaverage6 template object for nearest neighbor conversion in fs6_to_fs5()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs6_to_fs5_map
</code></pre>


<h3>Format</h3>



<h4><code>fs6_to_fs5_map</code></h4>

<p>An array of 81924 integers ()
</p>

<dl>
<dt>vertices</dt><dd><p>81924 integers corresponding to each fsaverage6 vertex</p>
</dd>
</dl>



<hr>
<h2 id='FSLRvextract'>FSLRvextract</h2><span id='topic+FSLRvextract'></span>

<h3>Description</h3>

<p>Extracts vertex-wise surface-based measures for each subject from HCP and fMRIprep preprocessed directory, and stores it as a single .RDS file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSLRvextract(
  sdirpath = "./",
  wb_path,
  filename,
  dscaler,
  subj_ID = TRUE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FSLRvextract_+3A_sdirpath">sdirpath</code></td>
<td>
<p>A string object containing the path to the HCP or fMRIprep preprocessed directory. Default is the current working directory (&quot;./&quot;).</p>
</td></tr>
<tr><td><code id="FSLRvextract_+3A_wb_path">wb_path</code></td>
<td>
<p>The filepath to the workbench folder that you have previously downloaded and unzipped</p>
</td></tr>
<tr><td><code id="FSLRvextract_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output RDS file. Default is 'fslr32k.rds' in the R temporary directory (tempdir()).</p>
</td></tr>
<tr><td><code id="FSLRvextract_+3A_dscaler">dscaler</code></td>
<td>
<p>A string object containing the filename suffix of the dscaler file. These dscaler files are named differently depending on the preprocessing pipeline used. Examples of filename suffixes are shown below
</p>

<ul>
<li> <p><code>.thickness_MSMAll.32k_fs_LR.dscalar.nii</code> (HCP MSMAll pipeline)
</p>
</li>
<li> <p><code>.sulc_MSMAll.32k_fs_LR.dscalar.nii</code> (HCP MSMAll pipeline)
</p>
</li>
<li> <p><code>.thickness.32k_fs_LR.dscalar.nii</code> (HCP legacy pipeline)
</p>
</li>
<li> <p><code>.sulc.32k_fs_LR.dscalar.nii</code> (HCP legacy pipeline)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_space-fsLR_den-91k_thickness.dscalar.nii&#8288;</code> (fMRIprep; using the <code style="white-space: pre;">&#8288;--cifti-output 91k&#8288;</code> flag)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_space-fsLR_den-91k_curv.dscalar.nii&#8288;</code> (fMRIprep; using the <code style="white-space: pre;">&#8288;--cifti-output 91k&#8288;</code> flag)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_space-fsLR_den-91k_sulc.dscalar.nii&#8288;</code> (fMRIprep; using the <code style="white-space: pre;">&#8288;--cifti-output 91k&#8288;</code> flag)</p>
</li></ul>
</td></tr>
<tr><td><code id="FSLRvextract_+3A_subj_id">subj_ID</code></td>
<td>
<p>A logical object to determine whether to return a list object containing both subject ID and data matrix.</p>
</td></tr>
<tr><td><code id="FSLRvextract_+3A_silent">silent</code></td>
<td>
<p>A logical object to determine whether messages will be silenced. Set to 'FALSE' by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches for the HCP preprocessed directory by listing out files with certain suffixes, extract the data from these files, and organize the left and right hemisphere vertex data for each subject as rows in a N x 64984 data matrix within a .rds object.
</p>


<h3>Value</h3>

<p>A .RDSfile with a list containing 1. the list of subject IDs (first element) and 2. a surface data matrix object (second element), or only a data matrix object. The matrix has N subjects x M vertices dimensions and can be readily used by VertexWiseR statistical analysis functions. Each row corresponds to a subject (in the order they are listed in the folder) and contains the left to right hemispheres' vertex-wise values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat_fslr32k=FSLRvextract(sdirpath="./", 
wb_path="/path/to/workbench",
filename="dat_fslr32k.rds",
dscaler=".thickness_MSMAll.32k_fs_LR.dscalar.nii", 
subj_ID = TRUE, silent=FALSE)

</code></pre>

<hr>
<h2 id='hip_points_cells'>points and cells data required to build the hippocampus surface template</h2><span id='topic+hip_points_cells'></span>

<h3>Description</h3>

<p>points and cells data required to build the hippocampus surface template
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hip_points_cells
</code></pre>


<h3>Format</h3>



<h4><code>hip_points_cells</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>data frame with 7262 rows (vertices), 3 columns (MNI coordinates X, y, Z)</p>
</dd>
<dt>vertices</dt><dd><p>data frame with 14266 rows (vertices), 3 columns (vertices of all unique triangles</p>
</dd>
<dt>vertices</dt><dd><p>data frame with 7262 rows (vertices), 3 columns (MNI coordinates X, y, Z for unfolded hippocampal surface)</p>
</dd>
</dl>



<hr>
<h2 id='HIPvextract'>HIPvextract</h2><span id='topic+HIPvextract'></span>

<h3>Description</h3>

<p>Extracts hippocampal vertex-wise surface-based measures for each subject in the 'HippUnfold' subjects directory, and stores it as a single .RDS file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HIPvextract(sdirpath = "./", filename, measure = "thickness", subj_ID = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HIPvextract_+3A_sdirpath">sdirpath</code></td>
<td>
<p>A string object containing the path to the 'HippUnfold' subjects directory. Default is the current working directory (&quot;./&quot;).</p>
</td></tr>
<tr><td><code id="HIPvextract_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output RDS file. Default is 'hip_measure.rds' in the R temporary directory (tempdir()).</p>
</td></tr>
<tr><td><code id="HIPvextract_+3A_measure">measure</code></td>
<td>
<p>A string object containing the name of the measure of interest. Options are 'thickness','curvature','gyrification' and 'surfarea' (For more information see <a href="https://hippunfold.readthedocs.io/en/latest/outputs/output_files.html#surface-metrics">the 'HippUnfold' documentation</a>). Default is thickness.</p>
</td></tr>
<tr><td><code id="HIPvextract_+3A_subj_id">subj_ID</code></td>
<td>
<p>A logical object stating whether to return a list object containing both subject ID and data matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches for the hippocampal surface data by listing out files with certain suffixes, extract the data from these files, and organize the left and right hippocampal vertex data for each subject as rows in a N x 14524 data matrix within a .rds object.
</p>


<h3>Value</h3>

<p>A .RDSfile with a list containing 1. the list of subject IDs (first element) and 2. a surface data matrix object (second element), or only a data matrix object. The matrix has N subjects x M vertices dimensions and can be readily used by VertexWiseR statistical analysis functions. Each row corresponds to a subject (in the order they are listed in the folder) and contains the left to right hemispheres' hippocampal vertex-wise values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HIPvextract(sdirpath = "./", filename = paste0(tempdir(),"/hip_data.RDS"), measure = "thickness") 

</code></pre>

<hr>
<h2 id='MNImap_hip'>Hippocampal surface in MNI space</h2><span id='topic+MNImap_hip'></span>

<h3>Description</h3>

<p>A matrix with 14524 columns corresponding to the hippocampal template vertices and 3 rows corresponding to each vertex's X,Y,Z coordinates in MNI space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MNImap_hip
</code></pre>


<h3>Format</h3>



<h4><code>MNImap_hip</code></h4>

<p>A 3x14524 matrix object
</p>

<dl>
<dt>coordinates</dt><dd><p>14524 rows (vertices), 3 columns (X,Y,Z coordinates)</p>
</dd>
</dl>



<hr>
<h2 id='MNIsurface-class'>MNI surface map object</h2><span id='topic+MNIsurface-class'></span>

<h3>Description</h3>

<p>A class for surface coordinates in MNI space
</p>


<h3>Slots</h3>


<dl>
<dt><code>matrix</code></dt><dd><p>A matrix object with N vertices columns x  3 rows corresponding to each vertex's X,Y,Z coordinates in MNI space.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the template surface</p>
</dd>
</dl>

<hr>
<h2 id='plot_surf'>Surface plotter</h2><span id='topic+plot_surf'></span>

<h3>Description</h3>

<p>Plots surface data in a grid with one or multiple rows in a .png file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_surf(
  surf_data,
  filename,
  title = "",
  surface = "inflated",
  cmap,
  limits,
  colorbar = TRUE,
  size,
  zoom,
  show.plot.window = TRUE,
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_surf_+3A_surf_data">surf_data</code></td>
<td>
<p>A numeric vector (length of V) or a matrix (N rows x V columns), where N is the number of subplots, and V is the number of vertices. It can be the output from SURFvextract(), FSLRvextract(), HIPvextract() as well as masks or vertex-wise results outputted by analyses functions. Alternatively, atlas ROI values as supported by atlas_to_surf() may be given.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output .png. Default is 'plot.png' in the R temporary directory (tempdir()).Only filenames with a .png extension are allowed.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_title">title</code></td>
<td>
<p>A string object for setting the title in the plot. Default is none. For titles that too long to be fully displayed within the plot, we recommend splitting them into multiple lines by inserting &quot;\n&quot;.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_surface">surface</code></td>
<td>
<p>A string object containing the name of the type of cortical surface background rendered. Possible options include &quot;white&quot;, &quot;smoothwm&quot;,&quot;pial&quot; and &quot;inflated&quot; (default). The surface parameter is ignored for hippocampal surface data.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_cmap">cmap</code></td>
<td>
<p>A string object specifying the name of an existing colormap or a vector of hexadecimal color codes to be used as a custom colormap. The names of existing colormaps are listed in the <a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">'Matplotlib' plotting library</a>.
</p>
<p>Default cmap is set to <code>"Reds"</code> for positive values, <code>"Blues_r"</code> for negative values and <code>"RdBu"</code> when both positive and negative values exist.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_limits">limits</code></td>
<td>
<p>A combined pair of numeric vector composed of the lower and upper color scale limits of the plot. If the limits are specified, the same limits will be applied to all subplots. When left unspecified, the same symmetrical limits c(-max(abs(surf_dat),max(abs(surf_dat))) will be used for all subplots. If set to NULL, each subplot will have its own limits corresponding to their min and max values</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_colorbar">colorbar</code></td>
<td>
<p>A logical object stating whether to include a color bar in the plot or not (default is TRUE).</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_size">size</code></td>
<td>
<p>A combined pair of numeric vector indicating the image dimensions (width and height in pixels). Default is c(1920,400) for whole-brain surface and c(400,200) for hippocampal surface.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_zoom">zoom</code></td>
<td>
<p>A numeric value for adjusting the level of zoom on the figures. Default is 1.25 for whole-brain surface and 1.20 for hippocampal surface.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_show.plot.window">show.plot.window</code></td>
<td>
<p>A logical object to determine if the generated plot is to be shown within RStudio's plot window</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs the plot as a .png image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results = runif(20484,min=0, max=1);
plot_surf(surf_data = results, 
filename=paste0(tempdir(),"/output.png"),
title = 'Cortical thickness', 
surface = 'inflated', cmap = 'Blues',
VWR_check=FALSE)
</code></pre>

<hr>
<h2 id='plot_surf3d'>3D Surface plotter</h2><span id='topic+plot_surf3d'></span>

<h3>Description</h3>

<p>Plots 3D cortical surfaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_surf3d(
  surf_data,
  surf_color = "grey",
  cmap,
  limits,
  atlas = 1,
  hemi = "b",
  medial_gap = 0,
  orientation_labels = TRUE,
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_surf3d_+3A_surf_data">surf_data</code></td>
<td>
<p>A numeric vector (length of V)</p>
</td></tr>
<tr><td><code id="plot_surf3d_+3A_surf_color">surf_color</code></td>
<td>
<p>color of the cortical surface. Set to <code>'grey'</code> by default</p>
</td></tr>
<tr><td><code id="plot_surf3d_+3A_cmap">cmap</code></td>
<td>
<p>A string vector containing 2 to 4 color names/codes specifying the colors to be used for the color scale. See <code>RColorBrewer::display.brewer.all()</code> for all possible cmap options. If none are specified, appropriate colors will be automatically selected according to <code>range(surf_data)</code></p>
</td></tr>
<tr><td><code id="plot_surf3d_+3A_limits">limits</code></td>
<td>
<p>A combined pair of numeric vector composed of the lower and upper color scale limits of the plot. When left unspecified, the symmetrical limits <code style="white-space: pre;">&#8288;c(-max(abs(surf_dat),max(abs(surf_dat)))&#8288;</code> will be used.</p>
</td></tr>
<tr><td><code id="plot_surf3d_+3A_atlas">atlas</code></td>
<td>
<p>atlas used for identifying region labels. 1=Desikan, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400. Set to <code>1</code> by default. This argument is ignored for hippocampal surfaces.</p>
</td></tr>
<tr><td><code id="plot_surf3d_+3A_hemi">hemi</code></td>
<td>
<p>A string specifying the hemisphere to plot. Possible values are <code>l</code> (left), <code>r</code> (right) or <code>b</code> (both).</p>
</td></tr>
<tr><td><code id="plot_surf3d_+3A_medial_gap">medial_gap</code></td>
<td>
<p>A numeric value specifying the amount of gap (in MNI coordinate units) to separate the left and right hemispheres. Set to <code>0</code> (no gap between hemispheres) by default. In order to view the medial surfaces clearly, it is recommended that this value is set to <code>20</code>. This argument is ignored if <code>hemi!='b'</code></p>
</td></tr>
<tr><td><code id="plot_surf3d_+3A_orientation_labels">orientation_labels</code></td>
<td>
<p>A boolean object specifying if orientation labels are to be displayed. Set to <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="plot_surf3d_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot_ly object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surf_data = runif(20484);
plot_surf3d(surf_data = surf_data, VWR_check=FALSE)
</code></pre>

<hr>
<h2 id='RFT_vertex_analysis'>Vertex-wise analysis with random field theory cluster correction</h2><span id='topic+RFT_vertex_analysis'></span>

<h3>Description</h3>

<p>Fits a linear or linear mixed model with the cortical or hippocampal surface data as the predicted outcome, and returns cluster-thresholded (Random field theory) t-stat map selected contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RFT_vertex_analysis(
  model,
  contrast,
  random,
  formula,
  formula_dataset,
  surf_data,
  p = 0.05,
  atlas = 1,
  smooth_FWHM,
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RFT_vertex_analysis_+3A_model">model</code></td>
<td>
<p>An N X P data.frame object containing N rows for each subject and P columns for each predictor included in the model. This data.frame should not include the random effects variable.</p>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_contrast">contrast</code></td>
<td>
<p>A N x 1 numeric vector or object containing the values of the predictor of interest. Its length should equal the number of subjects in model (and can be a single column from model). The cluster-thresholded t-stat maps will be estimated only for this predictor.</p>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_random">random</code></td>
<td>
<p>A N x 1 numeric vector or object containing the values of the random variable (optional). Its length should be equal to the number of subjects in model (it should NOT be inside the model data.frame).</p>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_formula">formula</code></td>
<td>
<p>An optional string or formula object describing the predictors to be fitted against the surface data, replacing the model, contrast, or random arguments. If this argument is used, the formula_dataset argument must also be provided.
</p>

<ul>
<li><p> The dependent variable is not needed, as it will always be the surface data values.
</p>
</li>
<li><p> The first independent variable in the formula will always be interpreted as the contrast of interest for which to estimate cluster-thresholded t-stat maps.
</p>
</li>
<li><p> Only one random regressor can be given and must be indicated as '(1|variable_name)'.
</p>
</li></ul>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_formula_dataset">formula_dataset</code></td>
<td>
<p>An optional data.frame object containing the independent variables to be used with the formula (the IV names in the formula must match their column names in the dataset).</p>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_surf_data">surf_data</code></td>
<td>
<p>A N x V matrix object containing the surface data (N row for each subject, V for each vertex), in fsaverage5 (20484 vertices), fsaverage6 (81924 vertices), fslr32k (64984 vertices) or hippocampal (14524 vertices) space. See also Hipvextract(), SURFvextract() or FSLRvextract output formats. Alternatively, a string object containing the path to the surface object (.rds file) outputted by extraction functions may be given.</p>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_p">p</code></td>
<td>
<p>A numeric object specifying the p-value to threshold the results (Default is 0.05)</p>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_atlas">atlas</code></td>
<td>
<p>A numeric integer object corresponding to the atlas of interest.  1=Desikan, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400. Set to <code>1</code> by default. This argument is ignored for hippocampal surfaces.</p>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_smooth_fwhm">smooth_FWHM</code></td>
<td>
<p>A numeric vector object specifying the desired smoothing width in mm. It should not be specified if the surf_data has been smoothed previously with smooth_surf(), because this result in surf_data being smoothed twice.</p>
</td></tr>
<tr><td><code id="RFT_vertex_analysis_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function imports and adapts the <a href="https://brainstat.readthedocs.io/en/master/_modules/brainstat/stats/SLM.html#SLM)"> 'BrainStat' Python library</a>.
</p>
<p>By default, false discovery rate correction is used together with the Random field theory (RFT) cluster correction. To look at data without any form of cluster correction, users can simply refer to the outputted 'tstat_map'.
</p>
<p>Output definitions:
</p>

<ul>
<li> <p><code>nverts</code>: number of vertices in the cluster
</p>
</li>
<li> <p><code>P</code>: p-value of the cluster
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;X, Y and Z&#8288;</code>: MNI coordinates of the vertex with the highest t-statistic in the cluster.
</p>
</li>
<li> <p><code>tstat</code>: t statistic of the vertex with the highest t-statistic in the cluster
</p>
</li>
<li> <p><code>region</code>: the region this highest -statistic vertex is located in, as determined/labelled by the selected atlas
</p>
</li></ul>



<h3>Value</h3>

<p>A list object containing the cluster level results, unthresholded t-stat map, thresholded t-stat map, positive, negative and bidirectional cluster maps, and a FDR-corrected p-value map.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TFCE_vertex_analysis">TFCE_vertex_analysis</a></code>, <code><a href="#topic+TFCE_vertex_analysis_mixed">TFCE_vertex_analysis_mixed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demodata = readRDS(system.file('demo_data/SPRENG_behdata_site1.rds', 
package = 'VertexWiseR'))[1:100,]
CTv = readRDS(file = url(paste0("https://github.com",
"/CogBrainHealthLab/VertexWiseR/blob/main/inst/demo_data/",
"SPRENG_CTv_site1.rds?raw=TRUE")))[1:100,] 

vertexwise_model=RFT_vertex_analysis(model=demodata[,c("sex","age")], 
contrast=demodata[,"age"], surf_data = CTv, atlas=1,p = 0.05, 
VWR_check=FALSE)

#Description of the output:
#vertexwise_model$cluster_level_results

#Formula alternative:
#formula= as.formula("~ age + sex")
#vertexwise_model=RFT_vertex_analysis(formula=formula, 
#formula_dataset=demodata, surf_data = CTv, atlas=1, p = 0.05, 
#VWR_check=FALSE)
</code></pre>

<hr>
<h2 id='ROImap_fs5'>Atlas parcellations of fsaverage5</h2><span id='topic+ROImap_fs5'></span>

<h3>Description</h3>

<p>A list containing two data frames, 1) listing fsaverage5 vertices and each parcellation number they correspond to, and 2) listing each available atlas and their corresponding labels (1=aparc, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROImap_fs5
</code></pre>


<h3>Format</h3>



<h4><code>ROImap_fs5</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>data frame with 20484 rows (vertices), 6 columns (atlases)</p>
</dd>
<dt>atlases</dt><dd><p>data frame with 400 rows (labels, not all are filled depending on atlas), 6 columns (atlases)</p>
</dd>
</dl>



<hr>
<h2 id='ROImap_fs6'>Atlas parcellations of fsaverage6</h2><span id='topic+ROImap_fs6'></span>

<h3>Description</h3>

<p>A list containing two data frames, 1) listing fsaverage6 vertices and each atlas parcellation number they correspond to, and 2) listing each available atlas and their corresponding labels (1=aparc, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROImap_fs6
</code></pre>


<h3>Format</h3>



<h4><code>ROImap_fs6</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>data frame with 81924 rows (vertices), 6 columns (atlases)</p>
</dd>
<dt>atlases</dt><dd><p>data frame with 400 rows (labels, not all are filled depending on atlas), 6 columns (atlases)</p>
</dd>
</dl>



<hr>
<h2 id='ROImap_fslr32k'>Atlas parcellations of FS_LR32k</h2><span id='topic+ROImap_fslr32k'></span>

<h3>Description</h3>

<p>A list containing two data frames, 1) listing FS_LR32k vertices and each atlas parcellation number they correspond to, and 2) listing each available atlas and their corresponding labels (1=aparc, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROImap_fslr32k
</code></pre>


<h3>Format</h3>



<h4><code>ROImap_fslr32k</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>data frame with 64984 rows (vertices), 6 columns (atlases)</p>
</dd>
<dt>atlases</dt><dd><p>data frame with 400 rows (labels, not all are filled depending on atlas), 6 columns (atlases)</p>
</dd>
</dl>



<hr>
<h2 id='ROImap_hip'>Atlas parcellations of the hippocampus (CITI168)</h2><span id='topic+ROImap_hip'></span>

<h3>Description</h3>

<p>A list containing 1) a matrix listing CITI168 vertices and each parcellation number they correspond to, and  2) a data frame listing the  hippocampal atlas labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROImap_hip
</code></pre>


<h3>Format</h3>



<h4><code>ROImap_hip</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>array of 14524 numeric vectors (vertices)</p>
</dd>
<dt>atlases</dt><dd><p>data frame with 10 rows listing names of left and right hippocampal subfields</p>
</dd>
</dl>



<hr>
<h2 id='ROImap-class'>Region-of-Interest mapping object</h2><span id='topic+ROImap-class'></span>

<h3>Description</h3>

<p>A class for surface vertices mapping on atlas labels
</p>


<h3>Slots</h3>


<dl>
<dt><code>matrix</code></dt><dd><p>A matrix object with N vertices from a template and each parcellation number the vertices correspond in 6 atlases (6 columns).</p>
</dd>
<dt><code>atlases</code></dt><dd><p>Each available of the 6 available atlases and their corresponding labels (1=aparc, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400).</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the template surface</p>
</dd>
</dl>

<hr>
<h2 id='smooth_surf'>Smooth surface</h2><span id='topic+smooth_surf'></span>

<h3>Description</h3>

<p>Smooths surface data at defined full width at half maximum (FWHM) as per the corresponding template of surface data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_surf(surf_data, FWHM, VWR_check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_surf_+3A_surf_data">surf_data</code></td>
<td>
<p>A N x V matrix object containing the surface data (N row for each subject, V for each vertex), in fsaverage5 (20484 vertices), fsaverage6 (81924 vertices), fslr32k (64984 vertices) or hippocampal (14524 vertices) space. See also Hipvextract(), SURFvextract() or FSLRvextract output formats. Alternatively, a string object containing the path to the surface object (.rds file) outputted by extraction functions may be given.</p>
</td></tr>
<tr><td><code id="smooth_surf_+3A_fwhm">FWHM</code></td>
<td>
<p>A numeric vector object containing the desired smoothing width in mm</p>
</td></tr>
<tr><td><code id="smooth_surf_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object with smoothed vertex-wise values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surf_data = readRDS(file = url(paste0("https://github.com",
"/CogBrainHealthLab/VertexWiseR/blob/main/inst/demo_data/",
"FINK_Tv_ses13.rds?raw=TRUE")))[1:3,]

surf_data_smoothed=smooth_surf(surf_data, 10, VWR_check=FALSE);
</code></pre>

<hr>
<h2 id='surf_to_atlas'>Surface to atlas</h2><span id='topic+surf_to_atlas'></span>

<h3>Description</h3>

<p>Returns the mean or sum of vertex-wise surface data for each ROI of a selected atlas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf_to_atlas(surf_data, atlas, mode = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf_to_atlas_+3A_surf_data">surf_data</code></td>
<td>
<p>A N x V matrix object containing the surface data (N row for each subject, V for each vertex), in fsaverage5 (20484 vertices), fsaverage6 (81924 vertices), fslr32k (64984 vertices) or hippocampal (14524 vertices) space. See also Hipvextract(), SURFvextract() or FSLRvextract output formats.</p>
</td></tr>
<tr><td><code id="surf_to_atlas_+3A_atlas">atlas</code></td>
<td>
<p>A numeric integer object corresponding to the atlas of interest.  1=Desikan, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400. Set to <code>1</code> by default. This argument is ignored for hippocampal surfaces.</p>
</td></tr>
<tr><td><code id="surf_to_atlas_+3A_mode">mode</code></td>
<td>
<p>A string indicating whether to extract the sum ('sum') or the average ('mean') of the ROI vertices values. Default is 'mean'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently works with the aparc/Desikan-Killiany-70, Destrieux-148, Glasser-360, Schaefer-100, Schaefer-200, Schaefer-400 atlases. ROI to vertex mapping data were obtained from the <a href="https://github.com/MICA-MNI/ENIGMA/tree/master/enigmatoolbox/datasets/parcellations">'ENIGMA toolbox'</a> ; data for Destrieux came from <a href="https://github.com/nilearn/nilearn/blob/a366d22e426b07166e6f8ce1b7ac6eb732c88155/nilearn/datasets/atlas.py"> 'Nilearn' 's nilearn.datasets.fetch_atlas_surf_destrieux</a>
</p>
<p>For hippocampal data, the function currently works with the &quot;bigbrain&quot; 10-parcels atlas integrated in 'HippUnfold.' See also <a href="https://doi.org/10.1016/j.neuroimage.2019.116328">doi:10.1016/j.neuroimage.2019.116328</a>.
</p>


<h3>Value</h3>

<p>A matrix object with ROI as column and corresponding average vertex-wise values as row
</p>


<h3>See Also</h3>

<p><code><a href="#topic+atlas_to_surf">atlas_to_surf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CTv = runif(20484,min=0, max=100)
parcel_data = surf_to_atlas(CTv, 1)
</code></pre>

<hr>
<h2 id='surf_to_vol'>Surface to volume</h2><span id='topic+surf_to_vol'></span>

<h3>Description</h3>

<p>Converts surface data to volumetric data (.nii file)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf_to_vol(surf_data, filename, VWR_check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf_to_vol_+3A_surf_data">surf_data</code></td>
<td>
<p>A numeric vector or object containing the surface data, either in fsaverage5 (1 x 20484 vertices) or fsaverage6 (1 x 81924 vertices) space. It can only be one row of vertices (not a cohort surface data matrix).</p>
</td></tr>
<tr><td><code id="surf_to_vol_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output .nii file (default is 'output.nii' in the R temporary directory (tempdir())).</p>
</td></tr>
<tr><td><code id="surf_to_vol_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A .nii volume file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CTv = runif(20484,min=0, max=100);
surf_to_vol(CTv, filename = paste0(tempdir(),'/volume.nii'), VWR_check=FALSE)
</code></pre>

<hr>
<h2 id='SURFvextract'>SURFvextract</h2><span id='topic+SURFvextract'></span>

<h3>Description</h3>

<p>Extracts whole-brain vertex-wise surface-based measures for each subject in a 'FreeSurfer' output subjects directory, resamples the data to a common surface template, and stores it as a .rds file. This function requires the 'FreeSurfer' environment to be preset in the unix environment and a 'FreeSurfer' license key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SURFvextract(
  sdirpath = "./",
  filename,
  template = "fsaverage5",
  measure = "thickness",
  subj_ID = TRUE,
  fshomepath
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SURFvextract_+3A_sdirpath">sdirpath</code></td>
<td>
<p>A string object containing the path to the 'FreeSurfer' preprocessed subjects directory. This directory must be the output directory from a <a href="https://surfer.nmr.mgh.harvard.edu/fswiki/recon-all">FreeSurfer preprocessing recon-all pipeline</a>. Default is the current working directory (&quot;./&quot;).</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output RDS file. Default is 'brain_measure.rds' in the R temporary directory (tempdir()).</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_template">template</code></td>
<td>
<p>A string object containing the name of surface template (available: 'fsaverage5', 'fsaverage6'). Default is fsaverage5.</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_measure">measure</code></td>
<td>
<p>A string object containing the name of the measure of interest. Options include thickness, curv, sulc, area, and volume (for freesurfer 7.4.1 or later). Default is thickness. Note that non-standard surface measures stored in &quot;surf/&quot; also work, provided the full name and extension following lh./rh. is given (e.g., &quot;w-g.pct.mgh&quot; for grey-white matter contrast).</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_subj_id">subj_ID</code></td>
<td>
<p>A logical object stating whether to include subject IDs (folder names in the subjects directory) as a first column to the output matrix. Default is TRUE.</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_fshomepath">fshomepath</code></td>
<td>
<p>An optional string object containing the path to the FreeSurfer installation directory. This makes sure R accesses FreeSurfer if the system environment variables are not inherited  as would be the case if you are running the function from RStudio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that RStudio does not inherit the shell environment variables if it is open from a terminal. In that case, the fshomepath argument needs to be provided.
The function runs system shell commands that will produce in the set subjects directory: 1) a sorted list of subjects &quot;sublist.txt&quot;; 2) a link file to the selected surface fsaverage template. 3) left and right hemisphere .mgh maps outputted by 'FreeSurfer' 's mris_preproc.
</p>


<h3>Value</h3>

<p>A .RDSfile with a list containing 1. the list of subject IDs (first element) and 2. a surface data matrix object (second element), or only a data matrix object. The matrix has N subjects x M vertices dimensions and can be used readily by VertexWiseR statistical analysis functions. Each row corresponds to a subject (in the order they are listed in the folder) and contains the left to right hemispheres' vertex-wise values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SURFvextract(sdirpath = "freesurfer_subjdir", 
filename=paste0(tempdir(), "/CTv.rds"), template="fsaverage5",
measure="curv") 
</code></pre>

<hr>
<h2 id='TFCE_threshold'>Thresholding TFCE output</h2><span id='topic+TFCE_threshold'></span>

<h3>Description</h3>

<p>Threshold TFCE maps from the TFCE_vertex_analysis() output and identifies significant clusters at the desired threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFCE_threshold(TFCEoutput, p = 0.05, atlas = 1, k = 20, VWR_check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TFCE_threshold_+3A_tfceoutput">TFCEoutput</code></td>
<td>
<p>An object containing the output from TFCE_vertex_analysis()</p>
</td></tr>
<tr><td><code id="TFCE_threshold_+3A_p">p</code></td>
<td>
<p>A numeric object specifying the p-value to threshold the results (Default is 0.05)</p>
</td></tr>
<tr><td><code id="TFCE_threshold_+3A_atlas">atlas</code></td>
<td>
<p>A numeric integer object corresponding to the atlas of interest.  1=Desikan, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400. Set to <code>1</code> by default. This argument is ignored for hippocampal surfaces.</p>
</td></tr>
<tr><td><code id="TFCE_threshold_+3A_k">k</code></td>
<td>
<p>Cluster-forming threshold (Default is 20)</p>
</td></tr>
<tr><td><code id="TFCE_threshold_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing the cluster level results, thresholded t-stat map, and positive, negative and bidirectional cluster maps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model1_TFCE=readRDS(system.file('demo_data/model1_TFCE.rds', 
package = 'VertexWiseR'))

TFCEanalysis_output=TFCE_threshold(model1_TFCE, p=0.05, atlas=1,
VWR_check=FALSE)
TFCEanalysis_output$cluster_level_results
</code></pre>

<hr>
<h2 id='TFCE_vertex_analysis'>Vertex-wise analysis with threshold-free cluster enhancement (fixed effect)</h2><span id='topic+TFCE_vertex_analysis'></span>

<h3>Description</h3>

<p>Fits a linear model with the cortical or hippocampal surface data as the predicted outcome, and returns t-stat and threshold-free cluster enhancement (TFCE) statistical maps for the selected contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFCE_vertex_analysis(
  model,
  contrast,
  formula,
  formula_dataset,
  surf_data,
  nperm = 100,
  tail = 2,
  nthread = 10,
  smooth_FWHM,
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TFCE_vertex_analysis_+3A_model">model</code></td>
<td>
<p>An N X P data.frame object containing N rows for each subject and P columns for each predictor included in the model</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_contrast">contrast</code></td>
<td>
<p>A N x 1 numeric vector or object containing the values of the predictor of interest. Its length should equal the number of subjects in model (and can be a single column from model). The t-stat and TFCE maps will be estimated only for this predictor.</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_formula">formula</code></td>
<td>
<p>An optional string or formula object describing the predictors to be fitted against the surface data, replacing the model, contrast, or random arguments. If this argument is used, the formula_dataset argument must also be provided.
</p>

<ul>
<li><p> The dependent variable is not needed, as it will always be the surface data values.
</p>
</li>
<li><p> The first independent variable in the formula will always be interpreted as the contrast of interest for which to estimate cluster-thresholded t-stat maps.
</p>
</li>
<li><p> Only one random regressor can be given and must be indicated as '(1|variable_name)'.
</p>
</li></ul>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_formula_dataset">formula_dataset</code></td>
<td>
<p>An optional data.frame object containing the independent variables to be used with the formula (the IV names in the formula must match their column names in the dataset).</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_surf_data">surf_data</code></td>
<td>
<p>A N x V matrix object containing the surface data (N row for each subject, V for each vertex), in fsaverage5 (20484 vertices), fsaverage6 (81924 vertices), fslr32k (64984 vertices) or hippocampal (14524 vertices) space. See also Hipvextract(), SURFvextract() or FSLRvextract output formats. Alternatively, a string object containing the path to the surface object (.rds file) outputted by extraction functions may be given.</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_nperm">nperm</code></td>
<td>
<p>A numeric integer object specifying the number of permutations generated for the subsequent thresholding procedures (default = 100)</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_tail">tail</code></td>
<td>
<p>A numeric integer object specifying whether to test a one-sided positive (1), one-sided negative (-1) or two-sided (2) hypothesis</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_nthread">nthread</code></td>
<td>
<p>A numeric integer object specifying the number of CPU threads to allocate</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_smooth_fwhm">smooth_FWHM</code></td>
<td>
<p>A numeric vector object specifying the desired smoothing width in mm. It should not be specified if the surf_data has been smoothed previously with smooth_surf(), because this result in surf_data being smoothed twice.</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This TFCE method is adapted from the <a href="https://github.com/nilearn/nilearn/blob/main/nilearn/mass_univariate/_utils.py#L7C8-L7C8"> 'Nilearn' Python library</a>.
</p>


<h3>Value</h3>

<p>A list object containing the t-stat and the TFCE statistical maps which can then be subsequently thresholded using TFCE_threshold()
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RFT_vertex_analysis">RFT_vertex_analysis</a></code>, <code><a href="#topic+TFCE_vertex_analysis_mixed">TFCE_vertex_analysis_mixed</a></code>, <code><a href="#topic+TFCE_threshold">TFCE_threshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demodata = readRDS(system.file('demo_data/SPRENG_behdata_site1.rds',
package = 'VertexWiseR'))[1:5,]
CTv = readRDS(file = url(paste0("https://github.com",
"/CogBrainHealthLab/VertexWiseR/blob/main/inst/demo_data/",
"SPRENG_CTv_site1.rds?raw=TRUE")))[1:5,]

TFCEpos=TFCE_vertex_analysis(model=demodata[,c("sex","age")], 
contrast=demodata[,"age"], surf_data=CTv, tail=1, 
nperm=5, nthread = 2, VWR_check=FALSE)

#To threshold the results, you may then run:
#results=TFCE_threshold(TFCEpos, p=0.05, atlas=1)
#results$cluster_level_results

#Formula alternative:
#formula= as.formula("~ age + sex")
#TFCEpos=TFCE_vertex_analysis(formula=formula, 
#formula_dataset=demodata, surf_data=CTv, tail=1, 
#nperm=5, nthread = 2, VWR_check=FALSE) 

</code></pre>

<hr>
<h2 id='TFCE_vertex_analysis_mixed'>Vertex-wise analysis with threshold-free cluster enhancement (mixed effect)</h2><span id='topic+TFCE_vertex_analysis_mixed'></span>

<h3>Description</h3>

<p>Fits a linear mixed effects model with the cortical or hippocampal surface data as the predicted outcome, and returns t-stat and threshold-free cluster enhancement (TFCE) statistical maps for the selected contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFCE_vertex_analysis_mixed(
  model,
  contrast,
  random,
  formula,
  formula_dataset,
  surf_data,
  nperm = 100,
  tail = 2,
  nthread = 10,
  smooth_FWHM,
  perm_type = "row",
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_model">model</code></td>
<td>
<p>An N X P data.frame object containing N rows for each subject and P columns for each predictor included in the model.This data.frame should not include the random effects variable.</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_contrast">contrast</code></td>
<td>
<p>A N x 1 numeric vector or object containing the values of the predictor of interest. Its length should equal the number of subjects in model (and can be a single column from model). The t-stat and TFCE maps will be estimated only for this predictor.</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_random">random</code></td>
<td>
<p>A N x 1 numeric vector or object containing the values of the random variable (optional). Its length should be equal to the number of subjects in model (it should NOT be inside the model data.frame).</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_formula">formula</code></td>
<td>
<p>An optional string or formula object describing the predictors to be fitted against the surface data, replacing the model, contrast, or random arguments. If this argument is used, the formula_dataset argument must also be provided.
</p>

<ul>
<li><p> The dependent variable is not needed, as it will always be the surface data values.
</p>
</li>
<li><p> The first independent variable in the formula will always be interpreted as the contrast of interest for which to estimate cluster-thresholded t-stat maps.
</p>
</li>
<li><p> Only one random regressor can be given and must be indicated as '(1|variable_name)'.
</p>
</li></ul>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_formula_dataset">formula_dataset</code></td>
<td>
<p>An optional data.frame object containing the independent variables to be used with the formula (the IV names in the formula must match their column names in the dataset).</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_surf_data">surf_data</code></td>
<td>
<p>A N x V matrix object containing the surface data (N row for each subject, V for each vertex), in fsaverage5 (20484 vertices), fsaverage6 (81924 vertices), fslr32k (64984 vertices) or hippocampal (14524 vertices) space. See also Hipvextract(), SURFvextract() or FSLRvextract output formats. Alternatively, a string object containing the path to the surface object (.rds file) outputted by extraction functions may be given.</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_nperm">nperm</code></td>
<td>
<p>A numeric integer object specifying the number of permutations generated for the subsequent thresholding procedures (default = 100)</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_tail">tail</code></td>
<td>
<p>A numeric integer object specifying whether to test a one-sided positive (1), one-sided negative (-1) or two-sided (2) hypothesis</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_nthread">nthread</code></td>
<td>
<p>A numeric integer object specifying the number of CPU threads to allocate</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_smooth_fwhm">smooth_FWHM</code></td>
<td>
<p>A numeric vector object specifying the desired smoothing width in mm. It should not be specified if the surf_data has been smoothed previously with smooth_surf(), because this result in surf_data being smoothed twice.</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_perm_type">perm_type</code></td>
<td>
<p>A string object specifying whether to permute the rows (&quot;row&quot;), between subjects (&quot;between&quot;), within subjects (&quot;within&quot;) or between and within subjects (&quot;within_between&quot;) for random subject effects. Default is &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="TFCE_vertex_analysis_mixed_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This TFCE method is adapted from the <a href="https://github.com/nilearn/nilearn/blob/main/nilearn/mass_univariate/_utils.py#L7C8-L7C8">'Nilearn' Python library</a>.
</p>


<h3>Value</h3>

<p>A list object containing the t-stat and the TFCE statistical maps which can then be subsequently thresholded using TFCE_threshold()
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RFT_vertex_analysis">RFT_vertex_analysis</a></code>,  <code><a href="#topic+TFCE_vertex_analysis">TFCE_vertex_analysis</a></code>, <code><a href="#topic+TFCE_threshold">TFCE_threshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demodata = readRDS(system.file('demo_data/SPRENG_behdata_site1.rds', package = 'VertexWiseR'))[1:5,]
CTv = readRDS(file = url(paste0("https://github.com",
"/CogBrainHealthLab/VertexWiseR/blob/main/inst/demo_data/",
"SPRENG_CTv_site1.rds?raw=TRUE")))[1:5,]

TFCEpos=TFCE_vertex_analysis_mixed(model=demodata[,c("sex",
"age")], contrast=demodata[,"age"], random=demodata[,"id"], 
surf_data=CTv, nperm =5,tail = 1, nthread = 2, VWR_check=FALSE)

#To get significant clusters, you may then run:
#results=TFCE_threshold(TFCEpos, p=0.05, atlas=1)
#results$cluster_level_results

#Formula alternative:
#formula= as.formula("~ age + sex + (1|id)")
#TFCEpos=TFCE_vertex_analysis_mixed(formula=formula, 
#formula_dataset=demodata, surf_data=CTv, tail=1, 
#nperm=5, nthread = 2, VWR_check=FALSE) 

</code></pre>

<hr>
<h2 id='VWRfirstrun'>VertexWiseR system requirements installation</h2><span id='topic+VWRfirstrun'></span>

<h3>Description</h3>

<p>Helps the user verify if VertexWisrR's system requirements are present and install them (a suitable 'Python' or 'Miniconda' environment, 'BrainStat' toolbox and libraries). If they are installed already, nothing will be overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VWRfirstrun(requirement = "any", n_vert = 0, promptless = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VWRfirstrun_+3A_requirement">requirement</code></td>
<td>
<p>String that specifies a requirement to enquire about:
</p>

<ul>
<li><p> For only Python/Conda installation: 'python/conda only'
</p>
</li>
<li><p> For Python/Conda and Brainstat installation: 'conda/brainstat'
</p>
</li>
<li><p> For specific 'BrainStat' libraries: 'fsaverage5', 'fsaverage6', 'fslr32k', 'yeo_parcels'
</p>
</li>
<li><p> For the neurosynth database: 'neurosynth'.
Default is 'any' and checks everything.
</p>
</li></ul>
</td></tr>
<tr><td><code id="VWRfirstrun_+3A_n_vert">n_vert</code></td>
<td>
<p>Numeric vector indicating the number of vertices of a given surface data so that only the required templates are asked for. It will modify the requirement argument accordingly.</p>
</td></tr>
<tr><td><code id="VWRfirstrun_+3A_promptless">promptless</code></td>
<td>
<p>A boolean object specifying whether to prompt the user for action when system requirements are missing. If TRUE, VWRfirstrun() will simply inform of what is missing and will not prompt for action. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>VertexWiseR imports and makes use of the R package 'reticulate.' 'reticulate' is a package that allows R to borrow or translate Python functions into R. Using 'reticulate', the package calls functions from the 'BrainStat' Python module. For 'reticulate' to work properly with VertexWiseR, a Python environment needs to be installed with it  the default choice offered by VWRfirstrun is to let reticulate (version 1.41.0) create an ephemeral Python virtual environment using UV and py_require().
If for a reason this is not desirable, VWRfirstrun() also gives the choice to install a 'Miniconda' (lightweight version of Python) or Python environment in a reticulate default path or a specified path.
Vertex-wise statistical analyses of cortical surface require fsaverage and parcellation templates as imported by default in 'BrainStat'.
The decode_surf_data() function also requires the 'Neurosynth' database to be downloaded.
</p>


<h3>Value</h3>

<p>No returned value in interactive session. In non-interactive sessions, a string object informing that system requirements are missing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VWRfirstrun()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
