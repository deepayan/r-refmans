<!DOCTYPE html><html><head><title>Help for package VertexWiseR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VertexWiseR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#atlas_to_surf'><p>Atlas to surface</p></a></li>
<li><a href='#decode_surf_data'><p>Decode surface data</p></a></li>
<li><a href='#edgelistfs5'><p>List of edges for the fsaverage5 template</p></a></li>
<li><a href='#edgelistfs6'><p>List of edges for the fsaverage6 template</p></a></li>
<li><a href='#edgelistHIP'><p>List of edges for the hippocampal template</p></a></li>
<li><a href='#fs5_to_fs6'><p>fsaverage5 to fsaverage6</p></a></li>
<li><a href='#fs6_to_fs5'><p>fsaverage6 to fsaverage5</p></a></li>
<li><a href='#fs6_to_fs5_map'><p>fsaverage6 template object for nearest neighbor conversion in fs6_to_fs5()</p></a></li>
<li><a href='#hip_points_cells'><p>points and cells data required to build the hippocampus surface template</p></a></li>
<li><a href='#HIPvextract'><p>HIPvextract</p></a></li>
<li><a href='#MNImap_fs5'><p>fsaverage5 surface in MNI space</p></a></li>
<li><a href='#MNImap_fs6'><p>fsaverage6 surface in MNI space</p></a></li>
<li><a href='#MNImap_hip'><p>Hippocampal surface in MNI space</p></a></li>
<li><a href='#plot_surf'><p>Surface plotter</p></a></li>
<li><a href='#ROImap_fs5'><p>Atlas parcellations of fsaverage5</p></a></li>
<li><a href='#ROImap_fs6'><p>Atlas parcellations of fsaverage6</p></a></li>
<li><a href='#ROImap_HIP'><p>Atlas parcellations of the hippocampus</p></a></li>
<li><a href='#smooth_surf'><p>Smooth surface</p></a></li>
<li><a href='#surf_to_atlas'><p>Surface to atlas</p></a></li>
<li><a href='#surf_to_vol'><p>Surface to volume</p></a></li>
<li><a href='#SURFvextract'><p>SURFvextract</p></a></li>
<li><a href='#TFCE.threshold'><p>Thresholding TFCE output</p></a></li>
<li><a href='#TFCE.vertex_analysis'><p>Vertex-wise analysis with TFCE (fixed effect)</p></a></li>
<li><a href='#TFCE.vertex_analysis.mixed'><p>Vertex-wise analysis with TFCE (mixed effect)</p></a></li>
<li><a href='#vertex_analysis'><p>Vertex-wise analysis</p></a></li>
<li><a href='#VWRfirstrun'><p>VertexWiseR system requirements installation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simplified Vertex-Wise Analyses of Whole-Brain and Hippocampal
Surface</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charly Billaud &lt;charly.billaud@ntu.edu.sg&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to run statistical analyses on
    surface-based neuroimaging data, computing measures including cortical
    thickness and surface area of the whole-brain and of the hippocampi.
    It can make use of 'FreeSurfer' preprocessed datasets and 'HippUnfold'
    hippocampal segmentation outputs for a given sample by restructuring
    the data values into a single file. The single file can then be used
    by the package for analyses independently from its base dataset and
    without need for its access.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cogbrainhealthlab.github.io/VertexWiseR/">https://cogbrainhealthlab.github.io/VertexWiseR/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Miniconda3 (&gt;= 23.10.0); BrainStat (reticulate
installation, &gt;=0.4.2)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, doSNOW, foreach, freesurferformats, fs, gifti,
grDevices, igraph, methods, reticulate, stats, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-13 10:06:13 UTC; charly.billaud</td>
</tr>
<tr>
<td>Author:</td>
<td>Junhong Yu <a href="https://orcid.org/0000-0002-2563-9658"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Charly Billaud <a href="https://orcid.org/0009-0001-3466-9963"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-13 18:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='atlas_to_surf'>Atlas to surface</h2><span id='topic+atlas_to_surf'></span>

<h3>Description</h3>

<p>Maps average parcellation surface values (e.g. produced with the surf_to_atlas() function) to the fsaverage5 or fsaverage6 space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atlas_to_surf(parcel_data, template)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atlas_to_surf_+3A_parcel_data">parcel_data</code></td>
<td>
<p>A matrix or vector object containing average surface measures for each region of interest, see the surf_to_atlas() output format.</p>
</td></tr>
<tr><td><code id="atlas_to_surf_+3A_template">template</code></td>
<td>
<p>A string object stating the surface space on which to map the data ('fsaverage5' or 'fsaverage6').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently works with the Desikan-Killiany-70, Schaefer-100, Schaefer-200, Schaefer-400, Glasser-360, or Destrieux-148 atlases. ROI to vertex mapping data for 1 to 4 were obtained from the <a href="https://github.com/MICA-MNI/ENIGMA/tree/master/enigmatoolbox/datasets/parcellations">'ENIGMA toolbox'</a> ; and data for 5 from <a href="https://github.com/nilearn/nilearn/blob/a366d22e426b07166e6f8ce1b7ac6eb732c88155/nilearn/datasets/atlas.py">'Nilearn' 's nilearn.datasets.fetch_atlas_surf_destrieux</a> . atlas_to_surf() will automatically detect the atlas based on the number of columns.
</p>


<h3>Value</h3>

<p>A matrix or vector object containing vertex-wise surface data mapped in fsaverage5 or fsaverage6 space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surf_to_atlas">surf_to_atlas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parcel_data = t(runif(100,min=0, max=100));
surf_data = atlas_to_surf(parcel_data, template='fsaverage5');
</code></pre>

<hr>
<h2 id='decode_surf_data'>Decode surface data</h2><span id='topic+decode_surf_data'></span>

<h3>Description</h3>

<p>Correlates the significant clusters of an earlier vertex-wise analysis with a database of task-based fMRI and voxel-based morphometric statistical maps and associate them with relevant key words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_surf_data(surf_data, contrast = "positive", VWR_check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_surf_data_+3A_surf_data">surf_data</code></td>
<td>
<p>a numeric vector with a length of 20484</p>
</td></tr>
<tr><td><code id="decode_surf_data_+3A_contrast">contrast</code></td>
<td>
<p>A string object indicating whether to decode the positive or negative mask ('positive' or 'negative')</p>
</td></tr>
<tr><td><code id="decode_surf_data_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="https://nimare.readthedocs.io/en/stable/index.html">'NiMARE'</a> python module is used for the imaging decoding and is imported via the reticulate package. The function also downloads the <a href="https://github.com/neurosynth/neurosynth-data">'Neurosynth' database</a> in the package's inst/extdata directory (~8 Mb) for the analysis.
</p>


<h3>Value</h3>

<p>A data.frame object listing the keywords and their Pearson's R values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CTv = rbinom(20484, 1, 0.001) 
decoding = decode_surf_data(CTv, 'positive', VWR_check=FALSE);
head(decoding)
</code></pre>

<hr>
<h2 id='edgelistfs5'>List of edges for the fsaverage5 template</h2><span id='topic+edgelistfs5'></span>

<h3>Description</h3>

<p>A Nx2 matrix object listing each vertex of the fsaverage5 template and the vertices adjacent to it (making an edge together).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelistfs5
</code></pre>


<h3>Format</h3>



<h4><code>edgelistfs5</code></h4>


<dl>
<dt>Nx2 matrix object</dt><dd><p>Matrix with two columns and N rows corresponding to the unique edges in the fsaverage5 surface</p>
</dd>
</dl>



<hr>
<h2 id='edgelistfs6'>List of edges for the fsaverage6 template</h2><span id='topic+edgelistfs6'></span>

<h3>Description</h3>

<p>A Nx2 matrix object listing each vertex of the fsaverage5 template and the vertices adjacent to it (making an edge together).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelistfs6
</code></pre>


<h3>Format</h3>



<h4><code>edgelistfs6</code></h4>


<dl>
<dt>Nx2 matrix object</dt><dd><p>Matrix with two columns and N rows corresponding to the unique edges in the fsaverage6 surface</p>
</dd>
</dl>



<hr>
<h2 id='edgelistHIP'>List of edges for the hippocampal template</h2><span id='topic+edgelistHIP'></span>

<h3>Description</h3>

<p>A Nx2 matrix object listing each vertex of the hippocampal template and the vertices adjacent to it (making an edge together).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelistHIP
</code></pre>


<h3>Format</h3>



<h4><code>edgelistHIP</code></h4>


<dl>
<dt>Nx2 matrix object</dt><dd><p>Matrix with two columns and N rows corresponding to the unique edges in the fsaverage5 surface</p>
</dd>
</dl>



<hr>
<h2 id='fs5_to_fs6'>fsaverage5 to fsaverage6</h2><span id='topic+fs5_to_fs6'></span>

<h3>Description</h3>

<p>Remaps vertex-wise surface data in fsaverage5 space to fsaverage6 space using the nearest neighbor approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs5_to_fs6(surf_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs5_to_fs6_+3A_surf_data">surf_data</code></td>
<td>
<p>A numeric vector or matrix object containing the surface data, see SURFvextract() output format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object containing vertex-wise surface data mapped in fsaverage6 space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fs6_to_fs5">fs6_to_fs5</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CTv = runif(20484,min=0, max=100);
CTv_fs6 = fs5_to_fs6(CTv);
</code></pre>

<hr>
<h2 id='fs6_to_fs5'>fsaverage6 to fsaverage5</h2><span id='topic+fs6_to_fs5'></span>

<h3>Description</h3>

<p>Remaps vertex-wise surface data in fsaverage6 space to fsaverage5 space using the nearest neighbor approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs6_to_fs5(surf_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs6_to_fs5_+3A_surf_data">surf_data</code></td>
<td>
<p>A numeric vector or matrix object containing the surface data, see SURFvextract() output format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object containing vertex-wise surface data mapped in fsaverage5 space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fs5_to_fs6">fs5_to_fs6</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surf_data = runif(81924,min=0, max=100);
fs5_data=fs6_to_fs5(surf_data)
</code></pre>

<hr>
<h2 id='fs6_to_fs5_map'>fsaverage6 template object for nearest neighbor conversion in fs6_to_fs5()</h2><span id='topic+fs6_to_fs5_map'></span>

<h3>Description</h3>

<p>fsaverage6 template object for nearest neighbor conversion in fs6_to_fs5()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs6_to_fs5_map
</code></pre>


<h3>Format</h3>



<h4><code>fs6_to_fs5_map</code></h4>

<p>An array of 81924 integers ()
</p>

<dl>
<dt>vertices</dt><dd><p>81924 integers corresponding to each fsaverage6 vertex</p>
</dd>
</dl>



<hr>
<h2 id='hip_points_cells'>points and cells data required to build the hippocampus surface template</h2><span id='topic+hip_points_cells'></span>

<h3>Description</h3>

<p>points and cells data required to build the hippocampus surface template
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hip_points_cells
</code></pre>


<h3>Format</h3>



<h4><code>hip_points_cells</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>data frame with 7262 rows (vertices), 3 columns (MNI coordinates X, y, Z)</p>
</dd>
<dt>vertices</dt><dd><p>data frame with 14266 rows (vertices), 3 columns (vertices of all unique triangles</p>
</dd>
<dt>vertices</dt><dd><p>data frame with 7262 rows (vertices), 3 columns (MNI coordinates X, y, Z for unfolded hippocampal surface)</p>
</dd>
</dl>



<hr>
<h2 id='HIPvextract'>HIPvextract</h2><span id='topic+HIPvextract'></span>

<h3>Description</h3>

<p>Extracts hippocampal vertex-wise surface-based measures for each subject in the 'HippUnfold' subjects directory, and stores it as a single .RDS file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HIPvextract(sdirpath = "./", filename, measure = "thickness", subj_ID = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HIPvextract_+3A_sdirpath">sdirpath</code></td>
<td>
<p>A string object containing the path to the 'HippUnfold' subjects directory. Default is the current working directory (&quot;./&quot;).</p>
</td></tr>
<tr><td><code id="HIPvextract_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output RDS file. Default is 'hip_measure.rds' in the R temporary directory (tempdir()).</p>
</td></tr>
<tr><td><code id="HIPvextract_+3A_measure">measure</code></td>
<td>
<p>A string object containing the name of the measure of interest. Options are 'thickness','curvature','gyrification' and 'surfarea' (For more information see <a href="https://hippunfold.readthedocs.io/en/latest/outputs/output_files.html#surface-metrics">the 'HippUnfold' documentation</a>). Default is thickness.</p>
</td></tr>
<tr><td><code id="HIPvextract_+3A_subj_id">subj_ID</code></td>
<td>
<p>A logical object stating whether to return a list object containing both subject ID and data matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function searches for the hippocampal surface data by listing out files with certain suffixes, extract the data from these files, and organize the left and right hippocampal vertex data for each subject as rows in a N x 14524 data matrix within a .rds object.
</p>


<h3>Value</h3>

<p>A .RDSfile with a list containing 1. the list of subject IDs (first element) and 2. a surface data matrix object (second element), or a data matrix object. The matrix can be readily used by VertexWiseR statistical analysis functions. Each row corresponds to a subject (in the same order as 1) and contains the left to right hemispheres' vertex-wise values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HIPvextract(sdirpath = "./", filename = paste0(tempdir(),"/hip_data.RDS"), measure = "thickness") 

</code></pre>

<hr>
<h2 id='MNImap_fs5'>fsaverage5 surface in MNI space</h2><span id='topic+MNImap_fs5'></span>

<h3>Description</h3>

<p>A matrix with 20484 columns corresponding to the fsaverage5 vertices and 3 rows corresponding to each vertex's X,Y,Z coordinates in MNI space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MNImap_fs5
</code></pre>


<h3>Format</h3>



<h4><code>MNImap_fs5</code></h4>

<p>A 3x20494 matrix object
</p>

<dl>
<dt>coordinates</dt><dd><p>20484 rows (vertices), 3 columns (X,Y,Z coordinates)</p>
</dd>
</dl>



<hr>
<h2 id='MNImap_fs6'>fsaverage6 surface in MNI space</h2><span id='topic+MNImap_fs6'></span>

<h3>Description</h3>

<p>A matrix with 81924 columns corresponding to the fsaverage6 vertices and 3 rows corresponding to each vertex's X,Y,Z coordinates in MNI space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MNImap_fs6
</code></pre>


<h3>Format</h3>



<h4><code>MNImap_fs6</code></h4>

<p>A 3x81924 matrix object
</p>

<dl>
<dt>coordinates</dt><dd><p>81924 rows (vertices), 3 columns (X,Y,Z coordinates)</p>
</dd>
</dl>



<hr>
<h2 id='MNImap_hip'>Hippocampal surface in MNI space</h2><span id='topic+MNImap_hip'></span>

<h3>Description</h3>

<p>A matrix with 14524 columns corresponding to the hippocampal template vertices and 3 rows corresponding to each vertex's X,Y,Z coordinates in MNI space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MNImap_hip
</code></pre>


<h3>Format</h3>



<h4><code>MNImap_hip</code></h4>

<p>A 3x14524 matrix object
</p>

<dl>
<dt>coordinates</dt><dd><p>14524 rows (vertices), 3 columns (X,Y,Z coordinates)</p>
</dd>
</dl>



<hr>
<h2 id='plot_surf'>Surface plotter</h2><span id='topic+plot_surf'></span>

<h3>Description</h3>

<p>Plots surface data in a grid with one or multiple rows in a .png file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_surf(
  surf_data,
  filename,
  title = "",
  surface = "inflated",
  cmap,
  limits,
  colorbar = TRUE,
  size,
  zoom,
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_surf_+3A_surf_data">surf_data</code></td>
<td>
<p>A numeric vector (length of V) or a matrix (N rows x V columns), where N is the number of subplots, and V is the number of vertices. It can be the output from SURFvextract() as well as masks or vertex-wise results outputted by analyses functions.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output .png. Default is 'plot.png' in the R temporary directory (tempdir()).</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_title">title</code></td>
<td>
<p>A string object for setting the title in the plot. Default is none. For titles that too long to be fully displayed within the plot, we recommend splitting them into multiple lines by inserting &quot;\n&quot;.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_surface">surface</code></td>
<td>
<p>A string object containing the name of the type of cortical surface background rendered. Possible options include &quot;white&quot;, &quot;smoothwm&quot;,&quot;pial&quot; and &quot;inflated&quot; (default). The surface parameter is ignored for hippocampal surface data.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_cmap">cmap</code></td>
<td>
<p>A string object specifying the name of an existing colormap or a vector of hexadecimal color codes to be used as a custom colormap. The names of existing colormaps are listed in the <a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">'Matplotlib' plotting library</a>.
</p>
<p>Default cmap is set to <code>"Reds"</code> for positive values, <code>"Blues_r"</code> for negative values and <code>"RdBu"</code> when both positive and negative values exist.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_limits">limits</code></td>
<td>
<p>A combined pair of numeric vector composed of the lower and upper color scale limits of the plot. If the limits are specified, the same limits will be applied to all subplots. When left unspecified, the same symmetrical limits c(-max(abs(surf_dat),max(abs(surf_dat))) will be used for all subplots. If set to NULL, each subplot will have its own limits corresponding to their min and max values</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_colorbar">colorbar</code></td>
<td>
<p>A logical object stating whether to include a color bar in the plot or not (default is TRUE).</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_size">size</code></td>
<td>
<p>A combined pair of numeric vector indicating the image dimensions (width and height in pixels). Default is c(1920,400) for whole-brain surface and c(400,200) for hippocampal surface.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_zoom">zoom</code></td>
<td>
<p>A numeric value for adjusting the level of zoom on the figures. Default is 1.25 for whole-brain surface and 1.20 for hippocampal surface.</p>
</td></tr>
<tr><td><code id="plot_surf_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Outputs the plot as a .png image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results = runif(20484,min=0, max=1);
plot_surf(surf_data = results, filename=paste0(tempdir(),"/output.png"),title = 
'Cortical thickness', surface = 'inflated', cmap = 'Blues',
VWR_check=FALSE)
</code></pre>

<hr>
<h2 id='ROImap_fs5'>Atlas parcellations of fsaverage5</h2><span id='topic+ROImap_fs5'></span>

<h3>Description</h3>

<p>A list containing two data frames, 1) listing vertex coordinates for each atlas label in fsaverage5 template space, and 2) listing each available atlas and their corresponding labels (1=aparc, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROImap_fs5
</code></pre>


<h3>Format</h3>



<h4><code>ROImap_fs5</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>data frame with 20484 rows (vertices), 6 columns (atlases)</p>
</dd>
<dt>atlases</dt><dd><p>data frame with 400 rows (labels, not all are filled depending on atlas), 6 columns (atlases)</p>
</dd>
</dl>



<hr>
<h2 id='ROImap_fs6'>Atlas parcellations of fsaverage6</h2><span id='topic+ROImap_fs6'></span>

<h3>Description</h3>

<p>A list containing two data frames, 1) listing vertex coordinates for each atlas label in fsaverage6 template space, and  2) listing each available atlas and their corresponding labels (1=aparc, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROImap_fs6
</code></pre>


<h3>Format</h3>



<h4><code>ROImap_fs6</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>data frame with 81924 rows (vertices), 6 columns (atlases)</p>
</dd>
<dt>atlases</dt><dd><p>data frame with 400 rows (labels, not all are filled depending on atlas), 6 columns (atlases)</p>
</dd>
</dl>



<hr>
<h2 id='ROImap_HIP'>Atlas parcellations of the hippocampus</h2><span id='topic+ROImap_HIP'></span>

<h3>Description</h3>

<p>A list containing 1) a matrix  listing vertex coordinates for each template hippocampal surface, and  2) a data frame listing 10 bilateral hippocampal subfields and corresponding labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROImap_HIP
</code></pre>


<h3>Format</h3>



<h4><code>ROImap_HIP</code></h4>

<p>A list object with two data frame objects: ()
</p>

<dl>
<dt>vertices</dt><dd><p>array of 14524 numeric vectors (vertices)</p>
</dd>
<dt>atlases</dt><dd><p>data frame with 10 rows listing names of left and right hippocampal subfields</p>
</dd>
</dl>



<hr>
<h2 id='smooth_surf'>Smooth surface</h2><span id='topic+smooth_surf'></span>

<h3>Description</h3>

<p>Smooths surface data at defined full width at half maximum (FWHM) as per the corresponding template of surface data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_surf(surf_data, FWHM, VWR_check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_surf_+3A_surf_data">surf_data</code></td>
<td>
<p>A matrix object containing the surface data, see SURFvextract() or HIPvextract() output format</p>
</td></tr>
<tr><td><code id="smooth_surf_+3A_fwhm">FWHM</code></td>
<td>
<p>A numeric vector object containing the desired smoothing width in mm</p>
</td></tr>
<tr><td><code id="smooth_surf_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object with smoothed vertex-wise values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surf_data = readRDS(file = url(paste0("https://github.com",
"/CogBrainHealthLab/VertexWiseR/blob/main/inst/demo_data/",
"FINK_Tv_ses13.rds?raw=TRUE")))[1:3,]
surf_data_smoothed=smooth_surf(surf_data, 10, VWR_check=FALSE);
</code></pre>

<hr>
<h2 id='surf_to_atlas'>Surface to atlas</h2><span id='topic+surf_to_atlas'></span>

<h3>Description</h3>

<p>Returns the mean or sum of vertex-wise surface data for each ROI of a selected atlas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf_to_atlas(surf_data, atlas, mode = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surf_to_atlas_+3A_surf_data">surf_data</code></td>
<td>
<p>A matrix object containing the surface data in fsaverage5 (20484 vertices), fsaverage6 (81924 vertices) or hippocampal (14524 vertices) space. See also Hipvextract() or SURFvextract() output format.</p>
</td></tr>
<tr><td><code id="surf_to_atlas_+3A_atlas">atlas</code></td>
<td>
<p>A numeric integer object corresponding to the atlas of interest. 1=aparc, 2=Destrieux-148, 3=Glasser-360, 4=Schaefer-100, 5=Schaefer-200, 6=Schaefer-400. For hippocampal surface, the 'bigbrain' hippocampal atlas is used by default and ignores the option.</p>
</td></tr>
<tr><td><code id="surf_to_atlas_+3A_mode">mode</code></td>
<td>
<p>A string indicating whether to extract the sum ('sum') or the average ('mean') of the ROI vertices values. Default is 'mean'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently works with the aparc/Desikan-Killiany-70, Destrieux-148, Glasser-360, Schaefer-100, Schaefer-200, Schaefer-400 atlases. ROI to vertex mapping data were obtained from the <a href="https://github.com/MICA-MNI/ENIGMA/tree/master/enigmatoolbox/datasets/parcellations">'ENIGMA toolbox'</a> ; data for Destrieux came from <a href="https://github.com/nilearn/nilearn/blob/a366d22e426b07166e6f8ce1b7ac6eb732c88155/nilearn/datasets/atlas.py"> 'Nilearn' 's nilearn.datasets.fetch_atlas_surf_destrieux</a>
</p>
<p>For hippocampal data, the function currently works with the &quot;bigbrain&quot; atlas integrated in 'HippUnfold.' See also <a href="https://doi.org/10.1016/j.neuroimage.2019.116328">doi:10.1016/j.neuroimage.2019.116328</a>.
</p>


<h3>Value</h3>

<p>A matrix object with ROI as column and corresponding average vertex-wise values as row
</p>


<h3>See Also</h3>

<p><code><a href="#topic+atlas_to_surf">atlas_to_surf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CTv = runif(20484,min=0, max=100)
surf_to_atlas(CTv, 1)
</code></pre>

<hr>
<h2 id='surf_to_vol'>Surface to volume</h2><span id='topic+surf_to_vol'></span>

<h3>Description</h3>

<p>Converts surface data to volumetric data (.nii file)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf_to_vol(surf_data, filename, VWR_check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surf_to_vol_+3A_surf_data">surf_data</code></td>
<td>
<p>A vector object containing the surface data, either in fsaverage5 or fsaverage6 space. It can only be one row of vertices (no cohort surface data matrix).</p>
</td></tr>
<tr><td><code id="surf_to_vol_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output .nii file (default is 'output.nii' in the R temporary directory (tempdir())).</p>
</td></tr>
<tr><td><code id="surf_to_vol_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A .nii volume file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CTv = runif(20484,min=0, max=100);
surf_to_vol(CTv, filename = paste0(tempdir(),'/volume.nii'), VWR_check=FALSE)
</code></pre>

<hr>
<h2 id='SURFvextract'>SURFvextract</h2><span id='topic+SURFvextract'></span>

<h3>Description</h3>

<p>Extracts whole-brain vertex-wise surface-based measures for each subject in a 'FreeSurfer' output subjects directory, resamples the data to a common surface template, and stores it as a .rds file. This function requires the 'FreeSurfer' environment to be preset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SURFvextract(
  sdirpath = "./",
  filename,
  template = "fsaverage5",
  measure = "thickness",
  subj_ID = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SURFvextract_+3A_sdirpath">sdirpath</code></td>
<td>
<p>A string object containing the path to the 'FreeSurfer' subjects directory. Default is the current working directory (&quot;./&quot;).</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_filename">filename</code></td>
<td>
<p>A string object containing the desired name of the output RDS file. Default is 'brain_measure.rds' in the R temporary directory (tempdir()).</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_template">template</code></td>
<td>
<p>A string object containing the name of surface template (available: 'fsaverage5', 'fsaverage6'). Default is fsaverage5.</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_measure">measure</code></td>
<td>
<p>A string object containing the name of the measure of interest. Options are thickness, curv, sulc, area, and volume (for freesurfer 7.4.1 or later). Default is thickness.</p>
</td></tr>
<tr><td><code id="SURFvextract_+3A_subj_id">subj_ID</code></td>
<td>
<p>A logical object stating whether to include subject IDs (folder names in the subjects directory) as a first column to the output matrix. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs system shell commands that will produce in the set subjects directory: 1) a sorted list of subjects &quot;sublist.txt&quot;; 2) a link file to the selected surface fsaverage template. 3) left and right hemisphere .mgh maps outputted by 'FreeSurfer' 's mris_preproc.
This function was currently not tested on a MacOS system.
</p>


<h3>Value</h3>

<p>A .RDSfile with a list containing 1. the list of subject IDs (first element) and 2. a surface data matrix object (second element), or a data matrix object. The matrix can be used readily by VertexWiseR statistical analysis functions. Each row corresponds to a subject (in the same order as 1) and contains the left to right hemispheres' vertex-wise values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SURFvextract(sdirpath = "freesurfer_subjdir", 
filename=paste0(tempdir(), "/CTv.rds"), template="fsaverage5", 
measure="curv") 
</code></pre>

<hr>
<h2 id='TFCE.threshold'>Thresholding TFCE output</h2><span id='topic+TFCE.threshold'></span>

<h3>Description</h3>

<p>Threshold TFCE maps from the TFCE.vertex_analysis() output and identifies significant clusters at the desired threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFCE.threshold(TFCE.output, p = 0.05, atlas = 1, k = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TFCE.threshold_+3A_tfce.output">TFCE.output</code></td>
<td>
<p>An object containing the output from TFCE.vertex_analysis()</p>
</td></tr>
<tr><td><code id="TFCE.threshold_+3A_p">p</code></td>
<td>
<p>A numeric object specifying the p-value to threshold the results (Default is 0.05)</p>
</td></tr>
<tr><td><code id="TFCE.threshold_+3A_atlas">atlas</code></td>
<td>
<p>A numeric integer object corresponding to the atlas of interest. 1=Desikan, 2=Schaefer-100, 3=Schaefer-200, 4=Glasser-360, 5=Destrieux-148 (Default is 1)</p>
</td></tr>
<tr><td><code id="TFCE.threshold_+3A_k">k</code></td>
<td>
<p>Cluster-forming threshold (Default is 20)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing the cluster level results, thresholded t-stat map, and positive, negative and bidirectional cluster maps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model1_TFCE=readRDS(system.file('demo_data/model1_TFCE.rds', 
package = 'VertexWiseR'))

TFCEanalysis_output=TFCE.threshold(model1_TFCE, p=0.05, atlas=1)
TFCEanalysis_output$cluster_level_results
</code></pre>

<hr>
<h2 id='TFCE.vertex_analysis'>Vertex-wise analysis with TFCE (fixed effect)</h2><span id='topic+TFCE.vertex_analysis'></span>

<h3>Description</h3>

<p>Fits a linear model with the cortical or hippocampal surface data as the predicted outcome, and returns t-stat and TFCE statistical maps for the selected contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFCE.vertex_analysis(
  model,
  contrast,
  surf_data,
  nperm = 100,
  tail = 2,
  nthread = 10,
  smooth_FWHM,
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TFCE.vertex_analysis_+3A_model">model</code></td>
<td>
<p>An N X V data.frame object containing N rows for each subject and V columns for each predictor included in the model</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis_+3A_contrast">contrast</code></td>
<td>
<p>A numeric vector or object containing the values of the predictor of interest. The t-stat and TFCE maps will be estimated only for this predictor</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis_+3A_surf_data">surf_data</code></td>
<td>
<p>A matrix object containing the surface data, see SURFvextract() or HIPvextract() output format.</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis_+3A_nperm">nperm</code></td>
<td>
<p>A numeric integer object specifying the number of permutations generated for the subsequent thresholding procedures (default = 100)</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis_+3A_tail">tail</code></td>
<td>
<p>A numeric integer object specifying whether to test a one-sided positive (1), one-sided negative (-1) or two-sided (2) hypothesis</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis_+3A_nthread">nthread</code></td>
<td>
<p>A numeric integer object specifying the number of CPU threads to allocate</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis_+3A_smooth_fwhm">smooth_FWHM</code></td>
<td>
<p>A numeric vector object specifying the desired smoothing width in mm</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This TFCE method is adapted from the <a href="https://github.com/nilearn/nilearn/blob/main/nilearn/mass_univariate/_utils.py#L7C8-L7C8"> 'Nilearn' Python library</a>.
</p>


<h3>Value</h3>

<p>A list object containing the t-stat and the TFCE statistical maps which can then be subsequently thresholded using TFCE.threshold()
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TFCE.threshold">TFCE.threshold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demodata = readRDS(system.file('demo_data/SPRENG_behdata_site1.rds',
package = 'VertexWiseR'))[1:5,]
surf_data = readRDS(file = url(paste0("https://github.com",
"/CogBrainHealthLab/VertexWiseR/blob/main/inst/demo_data/",
"SPRENG_CTv_site1.rds?raw=TRUE")))[1:5,]
model=demodata[,c(2,7)]
contrast=demodata[,7]

TFCE.pos=TFCE.vertex_analysis(model, contrast, surf_data, tail=1, 
nperm=5, nthread = 2, VWR_check=FALSE)

#To threshold the results, you may then run:
#results=TFCE.threshold(TFCE.pos, p=0.05, atlas=1)
#results$cluster_level_results

</code></pre>

<hr>
<h2 id='TFCE.vertex_analysis.mixed'>Vertex-wise analysis with TFCE (mixed effect)</h2><span id='topic+TFCE.vertex_analysis.mixed'></span>

<h3>Description</h3>

<p>Fits a linear mixed effects model with the cortical or hippocampal surface data as the predicted outcome, and returns t-stat and TFCE statistical maps for the selected contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFCE.vertex_analysis.mixed(
  model,
  contrast,
  surf_data,
  random,
  nperm = 100,
  tail = 2,
  nthread = 10,
  smooth_FWHM,
  perm_type = "row",
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_model">model</code></td>
<td>
<p>An N X V data.frame object containing N rows for each subject and V columns for each predictor included in the model.This data.frame should not include the random effects variable.</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_contrast">contrast</code></td>
<td>
<p>A numeric vector or object containing the values of the predictor of interest. The t-stat and TFCE maps will be estimated only for this predictor</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_surf_data">surf_data</code></td>
<td>
<p>A matrix object containing the surface data, see SURFvextract() or HIPvextract()  output format.</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_random">random</code></td>
<td>
<p>An object or vector containing the values of the random variable</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_nperm">nperm</code></td>
<td>
<p>A numeric integer object specifying the number of permutations generated for the subsequent thresholding procedures (default = 100)</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_tail">tail</code></td>
<td>
<p>A numeric integer object specifying whether to test a one-sided positive (1), one-sided negative (-1) or two-sided (2) hypothesis</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_nthread">nthread</code></td>
<td>
<p>A numeric integer object specifying the number of CPU threads to allocate</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_smooth_fwhm">smooth_FWHM</code></td>
<td>
<p>A numeric vector object specifying the desired smoothing width in mm</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_perm_type">perm_type</code></td>
<td>
<p>A string object specifying whether to permute the rows (&quot;row&quot;), between subjects (&quot;between&quot;), within subjects (&quot;within&quot;) or between and within subjects (&quot;within_between&quot;) for random subject effects. Default is &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="TFCE.vertex_analysis.mixed_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This TFCE method is adapted from the <a href="https://github.com/nilearn/nilearn/blob/main/nilearn/mass_univariate/_utils.py#L7C8-L7C8">'Nilearn' Python library</a>.
</p>


<h3>Value</h3>

<p>A list object containing the t-stat and the TFCE statistical maps which can then be subsequently thresholded using TFCE.threshold()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demodata = readRDS(system.file('demo_data/SPRENG_behdata_site1.rds', package = 'VertexWiseR'))[1:5,]
surf_data = readRDS(file = url(paste0("https://github.com",
"/CogBrainHealthLab/VertexWiseR/blob/main/inst/demo_data/",
"SPRENG_CTv_site1.rds?raw=TRUE")))[1:5,]

TFCE.pos=TFCE.vertex_analysis.mixed(model=demodata[,c(2,7)],
contrast=demodata[,7], surf_data,random=demodata[,1], 
nperm =5,tail = 1, nthread = 2, VWR_check=FALSE)

#To get significant clusters, you may then run:
#results=TFCE.threshold(TFCE.pos, p=0.05, atlas=1)
#results$cluster_level_results

</code></pre>

<hr>
<h2 id='vertex_analysis'>Vertex-wise analysis</h2><span id='topic+vertex_analysis'></span>

<h3>Description</h3>

<p>Fits a linear or linear mixed model with the cortical or hippocampal surface data as the predicted outcome, and returns cluster-thresholded (Random field theory) t-stat map selected contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_analysis(
  model,
  contrast,
  random,
  surf_data,
  p = 0.05,
  atlas = 1,
  smooth_FWHM,
  VWR_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_analysis_+3A_model">model</code></td>
<td>
<p>An N X V data.frame object containing N rows for each subject and V columns for each predictor included in the model. This data.frame should not include the random effects variable.</p>
</td></tr>
<tr><td><code id="vertex_analysis_+3A_contrast">contrast</code></td>
<td>
<p>A numeric vector or object containing the values of the predictor of interest. The cluster-thresholded t-stat maps will be estimated only for this predictor</p>
</td></tr>
<tr><td><code id="vertex_analysis_+3A_random">random</code></td>
<td>
<p>An object containing the values of the random variable (optional)</p>
</td></tr>
<tr><td><code id="vertex_analysis_+3A_surf_data">surf_data</code></td>
<td>
<p>A matrix object containing the surface data, see SURFvextract() or HIPvextract() output format.</p>
</td></tr>
<tr><td><code id="vertex_analysis_+3A_p">p</code></td>
<td>
<p>A numeric object specifying the p-value to threshold the results (Default is 0.05)</p>
</td></tr>
<tr><td><code id="vertex_analysis_+3A_atlas">atlas</code></td>
<td>
<p>A numeric integer object corresponding to the atlas of interest. 1=Desikan, 2=Schaefer-100, 3=Schaefer-200, 4=Glasser-360, 5=Destrieux-148.</p>
</td></tr>
<tr><td><code id="vertex_analysis_+3A_smooth_fwhm">smooth_FWHM</code></td>
<td>
<p>A numeric vector object specifying the desired smoothing width in mm</p>
</td></tr>
<tr><td><code id="vertex_analysis_+3A_vwr_check">VWR_check</code></td>
<td>
<p>A boolean object specifying whether to check and validate system requirements. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function imports and adapts the <a href="https://brainstat.readthedocs.io/en/master/_modules/brainstat/stats/SLM.html#SLM)"> 'BraiStat' Python library</a>.
</p>
<p>Output definitions:
</p>

<ul>
<li> <p><code>nverts</code>: number of vertices in the cluster
</p>
</li>
<li> <p><code>P</code>: p-value of the cluster
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;X, Y and Z&#8288;</code>: MNI coordinates of the vertex with the highest t-statistic in the cluster.
</p>
</li>
<li> <p><code>tstat</code>: t statistic of the vertex with the highest t-statistic in the cluster
</p>
</li>
<li> <p><code>region</code>: the region this highest -statistic vertex is located in, as determined/labelled by the selected atlas
</p>
</li></ul>



<h3>Value</h3>

<p>A list object containing the cluster level results, thresholded t-stat map, and positive, negative and bidirectional cluster maps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demodata = readRDS(system.file('demo_data/SPRENG_behdata_site1.rds', 
package = 'VertexWiseR'))[1:100,]
CTv = readRDS(file = url(paste0("https://github.com",
"/CogBrainHealthLab/VertexWiseR/blob/main/inst/demo_data/",
"SPRENG_CTv_site1.rds?raw=TRUE")))[1:100,]

vertexwise_model=vertex_analysis(model=demodata[,c(2,7)], 
contrast=demodata[,7], surf_data = CTv, atlas=1,p = 0.05, 
VWR_check=FALSE)

#Description of the output:
#vertexwise_model$cluster_level_results
</code></pre>

<hr>
<h2 id='VWRfirstrun'>VertexWiseR system requirements installation</h2><span id='topic+VWRfirstrun'></span>

<h3>Description</h3>

<p>Helps the user verify if VertexWisrR's system requirements are present and install them ('Miniconda', 'BrainStat' toolbox and libraries). If they are installed already, nothing will be overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VWRfirstrun(requirement = "any", n_vert = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VWRfirstrun_+3A_requirement">requirement</code></td>
<td>
<p>String that specifies a requirement to enquire about (for specific 'BrainStat' libraries: 'fsaverage5', 'fsaverage6', 'yeo_parcels'; for neurosynth database: &quot;neurosynth&quot;). Default is 'any' requirement and checks everything.</p>
</td></tr>
<tr><td><code id="VWRfirstrun_+3A_n_vert">n_vert</code></td>
<td>
<p>Numeric vector indicating the number of vertices of a given surface data so that only the required templates are asked for</p>
</td></tr>
</table>


<h3>Details</h3>

<p>VertexWiseR imports and makes use of the R package 'reticulate.' 'reticulate' is a package that allows R to borrow or translate Python functions into R. Using 'reticulate', the package calls functions from the 'BrainStat' Python module. For 'reticulate' to work properly with VertexWiseR, the latest version of 'Miniconda' needs to be installed with it â€” 'Miniconda' is a lightweight version of Python, specifically for use within 'RStudio'. Likewise, analyses of cortical surface require fsaverage templates as imported by 'BrainStat' The decode_surf_data() function also requires the 'Neurosynth' database to be downloaded.
</p>


<h3>Value</h3>

<p>No returned value in interactive session. In non-interactive sessions, a string object informing that system requirements are missing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VWRfirstrun()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
