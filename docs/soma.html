<!DOCTYPE html><html><head><title>Help for package soma</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {soma}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all2one'><p>Options for the available SOMA variants</p></a></li>
<li><a href='#soma'><p>The Self-Organising Migrating Algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-01</td>
</tr>
<tr>
<td>Title:</td>
<td>General-Purpose Optimisation with the Self-Organising Migrating
Algorithm</td>
</tr>
<tr>
<td>Author:</td>
<td>Jon Clayden</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jon Clayden &lt;code@clayden.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>reportr (&ge; 1.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, covr, shades</td>
</tr>
<tr>
<td>Description:</td>
<td>An R implementation of the Self-Organising Migrating Algorithm, a general-purpose, stochastic optimisation algorithm. The approach is similar to that of genetic algorithms, although it is based on the idea of a series of &ldquo;migrations&rdquo; by a fixed set of individuals, rather than the development of successive generations. It can be applied to any cost-minimisation problem with a bounded parameter space, and is robust to local minima.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jonclayden/soma/">https://github.com/jonclayden/soma/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-01 23:09:44 UTC; jon</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-02 08:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='all2one'>Options for the available SOMA variants</h2><span id='topic+all2one'></span><span id='topic+soma.options'></span><span id='topic+t3a'></span><span id='topic+pareto'></span>

<h3>Description</h3>

<p>These functions generate option lists (and provide defaults) for the SOMA
algorithm variants available in the package, which control how the algorithm
will proceed and when it will terminate. Each function corresponds to a
different top-level strategy, described in a different reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all2one(
  populationSize = 10L,
  nMigrations = 20L,
  pathLength = 3,
  stepLength = 0.11,
  perturbationChance = 0.1,
  minAbsoluteSep = 0,
  minRelativeSep = 0.001
)

t3a(
  populationSize = 30L,
  nMigrations = 20L,
  nSteps = 45L,
  migrantPoolSize = 10L,
  leaderPoolSize = 10L,
  nMigrants = 4L,
  minAbsoluteSep = 0,
  minRelativeSep = 0.001
)

pareto(
  populationSize = 100L,
  nMigrations = 20L,
  nSteps = 10L,
  perturbationFrequency = 1,
  stepFrequency = 1,
  minAbsoluteSep = 0,
  minRelativeSep = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all2one_+3A_populationsize">populationSize</code></td>
<td>
<p>The number of individuals in the population. It is
recommended that this be somewhat larger than the number of parameters
being optimised over, and it should not be less than 2. The default varies
by strategy.</p>
</td></tr>
<tr><td><code id="all2one_+3A_nmigrations">nMigrations</code></td>
<td>
<p>The maximum number of migrations to complete.</p>
</td></tr>
<tr><td><code id="all2one_+3A_pathlength">pathLength</code></td>
<td>
<p>The distance towards the leader that individuals may
migrate. A value of 1 corresponds to the leader's position itself, and
values greater than one (recommended) allow for some overshoot.</p>
</td></tr>
<tr><td><code id="all2one_+3A_steplength">stepLength</code></td>
<td>
<p>The granularity at which potential steps are evaluated.
It is recommended that the <code>pathLength</code> not be a whole multiple of
this value.</p>
</td></tr>
<tr><td><code id="all2one_+3A_perturbationchance">perturbationChance</code></td>
<td>
<p>The probability that individual parameters are
changed on any given step.</p>
</td></tr>
<tr><td><code id="all2one_+3A_minabsolutesep">minAbsoluteSep</code></td>
<td>
<p>The smallest absolute difference between the maximum
and minimum cost function values. If the difference falls below this
minimum, the algorithm will terminate. The default is 0, meaning that this
termination criterion will never be met.</p>
</td></tr>
<tr><td><code id="all2one_+3A_minrelativesep">minRelativeSep</code></td>
<td>
<p>The smallest relative difference between the maximum
and minimum cost function values. If the difference falls below this
minimum, the algorithm will terminate.</p>
</td></tr>
<tr><td><code id="all2one_+3A_nsteps">nSteps</code></td>
<td>
<p>The number of candidate steps towards the leader per migrating
individual. This option is used instead of <code>pathLength</code> and
<code>stepLength</code> under the T3A and Pareto strategies, where the step
length is variable.</p>
</td></tr>
<tr><td><code id="all2one_+3A_migrantpoolsize">migrantPoolSize</code>, <code id="all2one_+3A_leaderpoolsize">leaderPoolSize</code></td>
<td>
<p>The number of randomly selected
individuals to include in the migrant and leader pools, respectively,
under the T3A strategy.</p>
</td></tr>
<tr><td><code id="all2one_+3A_nmigrants">nMigrants</code></td>
<td>
<p>The number of individuals that will migrate, at each
migration, under the T3A strategy.</p>
</td></tr>
<tr><td><code id="all2one_+3A_perturbationfrequency">perturbationFrequency</code>, <code id="all2one_+3A_stepfrequency">stepFrequency</code></td>
<td>
<p>Scale factors affecting how
rapidly the perturbation probability and step sizes fluctuate under the
Pareto strategy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All To One (the <code>all2one</code> function) is the original SOMA strategy. At
each &ldquo;migration&rdquo;, the cost function is evaluated for all individuals in
the population, and the one with the lowest value is designated the
&ldquo;leader&rdquo;. All other individuals migrate towards the leader's position in
some or all dimensions of the parameter space, with a fixed probability of
perturbation in each dimension. Each migration is evaluated against the cost
function at several points on the line towards the leader, and the location
with the lowest value becomes the individual's starting position for the
next migration.
</p>
<p>The Team To Team Adaptive (T3A) strategy (Diep, 2019) differs in that only a
random subset of individuals are selected into a migrant pool and a leader
pool for any given migration. A subset of most optimal migrants are then
migrated towards the single most optimal individual from the leader pool.
The perturbation probability and step length along the trajectory towards
the leader also vary according to formulae given by the strategy author as
the algorithm progresses through the migrations.
</p>
<p>In the Pareto strategy (Diep et al., 2019), all individuals are sorted by
cost function value at the start of each migration. The leader is selected
randomly from the top 4% (20% of 20%) of most optimal individuals, and
a single migrant is chosen at random from between the 20th and the 36th
percentiles of the population (the top 20% of the bottom 80%). The
perturbation probability and the step length again vary across migrations,
but this time in a sinusoidal fashion, and the migrant is updated in all
dimensions, but some more slowly than others.
</p>


<h3>Value</h3>

<p>A list of class <code>"soma.options"</code>.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>I. Zelinka (2004). SOMA - self-organizing migrating algorithm. In G.C.
Onwubolu &amp; B.V. Babu, eds, New optimization techniques in engineering.
Volume 141 of &ldquo;Studies in Fuzziness and Soft Computing&rdquo;, pp. 167-217.
Springer.
</p>
<p>Q.B. Diep (2019). Self-Organizing Migrating Algorithm Team To Team
Adaptive â€“ SOMA T3A. In proceedings of the 2019 IEEE Congress on
Evolutionary Computation (CEC), pp. 1182-1187. IEEE.
</p>
<p>Q.B. Diep, I. Zelinka &amp; S. Das (2019). Pareto-Based Self-Organizing
Migrating Algorithm. Mendel 25(1):111-120.
</p>

<hr>
<h2 id='soma'>The Self-Organising Migrating Algorithm</h2><span id='topic+soma'></span><span id='topic+bounds'></span><span id='topic+plot.soma'></span>

<h3>Description</h3>

<p>The Self-Organising Migrating Algorithm (SOMA) is a general-purpose,
stochastic optimisation algorithm. The approach is similar to that of
genetic algorithms, although it is based on the idea of a series of
&ldquo;migrations&rdquo; by a fixed set of individuals, rather than the development
of successive generations. It can be applied to any cost-minimisation
problem with a bounded parameter space, and is robust to local minima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soma(costFunction, bounds, options = list(), init = NULL, ...)

bounds(min, max)

## S3 method for class 'soma'
plot(x, y = NULL, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soma_+3A_costfunction">costFunction</code></td>
<td>
<p>A cost function which takes a numeric vector of
parameters as its first argument, and returns a numeric scalar
representing the associated cost value.</p>
</td></tr>
<tr><td><code id="soma_+3A_bounds">bounds</code></td>
<td>
<p>A list with elements <code>min</code> and <code>max</code>, each a numeric
vector giving the upper and lower bounds for each parameter, respectively.</p>
</td></tr>
<tr><td><code id="soma_+3A_options">options</code></td>
<td>
<p>A list of options for the SOMA algorithm itself, usually
generated by functions like <code><a href="#topic+all2one">all2one</a></code>.</p>
</td></tr>
<tr><td><code id="soma_+3A_init">init</code></td>
<td>
<p>An optional matrix giving the starting population's positions in
parameter space, one per column. If omitted, initialisation is random (as
is usual for SOMA), but specifying a starting state can be helpful when
running the algorithm in stages or investigating the consistency of
solutions.</p>
</td></tr>
<tr><td><code id="soma_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code>costFunction</code> (for <code>soma</code>)
or the default plotting method (for <code>plot.soma</code>).</p>
</td></tr>
<tr><td><code id="soma_+3A_min">min</code>, <code id="soma_+3A_max">max</code></td>
<td>
<p>Vectors of minimum and maximum bound values for each
parameter to the <code>costFunction</code>.</p>
</td></tr>
<tr><td><code id="soma_+3A_x">x</code></td>
<td>
<p>An object of class <code>"soma"</code>.</p>
</td></tr>
<tr><td><code id="soma_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="soma_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add to an existing plot canvas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"soma"</code>, containing the following elements.
</p>

<dl>
<dt>leader</dt><dd><p>The index of the &ldquo;leader&rdquo;, the individual in the
population with the lowest cost.</p>
</dd>
<dt>population</dt><dd><p>A matrix whose columns give the parameter values for
each individual in the population at convergence.</p>
</dd>
<dt>cost</dt><dd><p>A vector giving the cost function values for each individual
at convergence.</p>
</dd>
<dt>history</dt><dd><p>A vector giving the cost of the leader for each migration
during the optimisation. This should be nonincreasing.</p>
</dd>
<dt>migrations</dt><dd><p>The number of migrations completed.</p>
</dd>
<dt>evaluations</dt><dd><p>The number of times the <code>costFunction</code> was
evaluated.</p>
</dd>
</dl>

<p>A <code>plot</code> method is available for this class, which shows the history
of leader cost values during the optimisation.
</p>


<h3>Author(s)</h3>

<p>R implementation by Jon Clayden &lt;code@clayden.org&gt;.
</p>


<h3>References</h3>

<p>I. Zelinka (2004). SOMA - self-organizing migrating algorithm. In G.C.
Onwubolu &amp; B.V. Babu, eds, New optimization techniques in engineering.
Volume 141 of &ldquo;Studies in Fuzziness and Soft Computing&rdquo;, pp. 167-217.
Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+soma.options">soma.options</a></code> for setting options. <code><a href="stats.html#topic+optim">optim</a></code>
implements other general-purpose optimisation methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rastrigin's function, which contains many local minima
rastrigin &lt;- function (x) 10 * length(x) + sum(x^2 - 10 * cos(2*pi*x))

# Find the global minimum over the range -5 to 5 in each parameter
x &lt;- soma(rastrigin, bounds(c(-5,-5), c(5,5)))

# Find the location of the leader - should be near the true minimum of c(0,0)
print(x$population[,x$leader])

# Plot the cost history of the leaders
plot(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
